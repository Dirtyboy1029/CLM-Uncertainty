{"code": "R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;\n\t\tattr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "MagickExport Image *ReadStream(const ImageInfo *image_info,StreamHandler stream,\n  ExceptionInfo *exception)\n{\n  CacheMethods\n    cache_methods;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  read_info=CloneImageInfo(image_info);\n  read_info->cache=AcquirePixelCache(0);\n  GetPixelCacheMethods(&cache_methods);\n  cache_methods.get_virtual_pixel_handler=GetVirtualPixelStream;\n  cache_methods.get_virtual_pixels_handler=GetVirtualPixelsStream;\n  cache_methods.get_virtual_metacontent_from_handler=\n    GetVirtualMetacontentFromStream;\n  cache_methods.get_authentic_pixels_handler=GetAuthenticPixelsStream;\n  cache_methods.queue_authentic_pixels_handler=QueueAuthenticPixelsStream;\n  cache_methods.sync_authentic_pixels_handler=SyncAuthenticPixelsStream;\n  cache_methods.get_authentic_pixels_from_handler=GetAuthenticPixelsFromStream;\n  cache_methods.get_authentic_metacontent_from_handler=\n    GetAuthenticMetacontentFromStream;\n  cache_methods.get_one_virtual_pixel_from_handler=GetOneVirtualPixelFromStream;\n  cache_methods.get_one_authentic_pixel_from_handler=\n    GetOneAuthenticPixelFromStream;\n  cache_methods.destroy_pixel_handler=DestroyPixelStream;\n  SetPixelCacheMethods(read_info->cache,&cache_methods);\n  read_info->stream=stream;\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    InitializePixelChannelMap(image);\n  read_info=DestroyImageInfo(read_info);\n  return(image);\n}", "target": 1}
{"code": "ip_optprint(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n{\n\tregister u_int option_len;\n\tconst char *sep = \"\";\n\tfor (; length > 0; cp += option_len, length -= option_len) {\n\t\tu_int option_code;\n\t\tND_PRINT((ndo, \"%s\", sep));\n\t\tsep = \",\";\n\t\tND_TCHECK(*cp);\n\t\toption_code = *cp;\n\t\tND_PRINT((ndo, \"%s\",\n\t\t          tok2str(ip_option_values,\"unknown %u\",option_code)));\n\t\tif (option_code == IPOPT_NOP ||\n                    option_code == IPOPT_EOL)\n\t\t\toption_len = 1;\n\t\telse {\n\t\t\tND_TCHECK(cp[1]);\n\t\t\toption_len = cp[1];\n\t\t\tif (option_len < 2) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (option_len > length) {\n\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\treturn;\n\t\t}\n\t\tND_TCHECK2(*cp, option_len);\n\t\tswitch (option_code) {\n\t\tcase IPOPT_EOL:\n\t\t\treturn;\n\t\tcase IPOPT_TS:\n\t\t\tip_printts(ndo, cp, option_len);\n\t\t\tbreak;\n\t\tcase IPOPT_RR:       \n\t\tcase IPOPT_SSRR:\n\t\tcase IPOPT_LSRR:\n\t\t\tip_printroute(ndo, cp, option_len);\n\t\t\tbreak;\n\t\tcase IPOPT_RA:\n\t\t\tif (option_len < 4) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_TCHECK(cp[3]);\n\t\t\tif (EXTRACT_16BITS(&cp[2]) != 0)\n\t\t\t\tND_PRINT((ndo, \" value %u\", EXTRACT_16BITS(&cp[2])));\n\t\t\tbreak;\n\t\tcase IPOPT_NOP:       \n\t\tcase IPOPT_SECURITY:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}", "target": 1}
{"code": " int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *ret)\n {\n     int ok = 0;\n    BIGNUM *q = NULL;\n     *ret = 0;\n    q = BN_new();\n    if (q == NULL)\n         goto err;\n    BN_set_word(q, 1);\n    if (BN_cmp(pub_key, q) <= 0)\n         *ret |= DH_CHECK_PUBKEY_TOO_SMALL;\n    BN_copy(q, dh->p);\n    BN_sub_word(q, 1);\n    if (BN_cmp(pub_key, q) >= 0)\n         *ret |= DH_CHECK_PUBKEY_TOO_LARGE;\n     ok = 1;\n  err:\n    if (q != NULL)\n        BN_free(q);\n     return (ok);\n }", "target": 1}
{"code": "lyd_new_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "int sctp_verify_asconf(const struct sctp_association *asoc,\n\t\t       struct sctp_paramhdr *param_hdr, void *chunk_end,\n\t\t       struct sctp_paramhdr **errp) {\n\tsctp_addip_param_t *asconf_param;\n\tunion sctp_params param;\n\tint length, plen;\n\tparam.v = (sctp_paramhdr_t *) param_hdr;\n\twhile (param.v <= chunk_end - sizeof(sctp_paramhdr_t)) {\n\t\tlength = ntohs(param.p->length);\n\t\t*errp = param.p;\n\t\tif (param.v > chunk_end - length ||\n\t\t    length < sizeof(sctp_paramhdr_t))\n\t\t\treturn 0;\n\t\tswitch (param.p->type) {\n\t\tcase SCTP_PARAM_ADD_IP:\n\t\tcase SCTP_PARAM_DEL_IP:\n\t\tcase SCTP_PARAM_SET_PRIMARY:\n\t\t\tasconf_param = (sctp_addip_param_t *)param.v;\n\t\t\tplen = ntohs(asconf_param->param_hdr.length);\n\t\t\tif (plen < sizeof(sctp_addip_param_t) +\n\t\t\t    sizeof(sctp_paramhdr_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase SCTP_PARAM_SUCCESS_REPORT:\n\t\tcase SCTP_PARAM_ADAPTATION_LAYER_IND:\n\t\t\tif (length != sizeof(sctp_addip_param_t))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tparam.v += WORD_ROUND(length);\n\t}\n\tif (param.v != chunk_end)\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_finish_object( bson *b ) {\n    char *start;\n    int i;\n    if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n    bson_append_byte( b , 0 );\n    start = b->data + b->stack[ --b->stackPos ];\n    i = b->cur - start;\n    bson_little_endian32( start, &i );\n    return BSON_OK;\n}", "target": 1}
{"code": "static ssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\tif (segment_eq(get_fs(), KERNEL_DS))\n\t\tflags |= AOP_FLAG_UNINTERRUPTIBLE;\n\tdo {\n\t\tstruct page *page;\n\t\tpgoff_t index;\t\t\n\t\tunsigned long offset;\t\n\t\tunsigned long bytes;\t\n\t\tsize_t copied;\t\t\n\t\tvoid *fsdata;\n\t\toffset = (pos & (PAGE_CACHE_SIZE - 1));\n\t\tindex = pos >> PAGE_CACHE_SHIFT;\n\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\nagain:\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\tpagefault_disable();\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tpagefault_enable();\n\t\tflush_dcache_page(page);\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\t\tcond_resched();\n\t\tif (unlikely(copied == 0)) {\n\t\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tiov_iter_advance(i, copied);\n\t\tpos += copied;\n\t\twritten += copied;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t} while (iov_iter_count(i));\n\treturn written ? written : status;\n}", "target": 1}
{"code": "PHPAPI int php_swoole_unserialize(void *buffer, size_t len, zval *return_value, zval *object_args, long flag)\n{\n    SBucketType type = *(SBucketType*) (buffer);\n    zend_uchar real_type = type.data_type;\n    buffer += sizeof (SBucketType);\n    switch (real_type)\n    {\n        case IS_NULL:\n        case IS_TRUE:\n        case IS_FALSE:\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_LONG:\n            swoole_unserialize_long(buffer, return_value, type);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_DOUBLE:\n            swoole_unserialize_raw(buffer, return_value);\n            Z_TYPE_INFO_P(return_value) = real_type;\n            break;\n        case IS_STRING:\n            len -= sizeof (SBucketType);\n            zend_string *str = swoole_unserialize_string(buffer, len);\n            ZVAL_STR(return_value, str);\n            break;\n        case IS_ARRAY:\n        {\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            uint32_t num = 0;\n            buffer = get_array_real_len(buffer, type.data_len, &num);\n            if (!swoole_unserialize_arr(buffer, return_value, num, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        }\n        case IS_UNDEF:\n            if (swoole_seria_check_eof(buffer, len) < 0)\n            {\n                  php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"detect the error eof\");\n                  return SW_FALSE;\n            }\n            unser_start = buffer - sizeof (SBucketType);\n            if (!swoole_unserialize_object(buffer, return_value, type.data_len, object_args, flag))\n            {\n                return SW_FALSE;\n            }\n            break;\n        default:\n            php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"the type is not supported by swoole serialize.\");\n            return SW_FALSE;\n    }\n    return SW_TRUE;\n}", "target": 1}
{"code": "static void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "AuthenticationFeature::AuthenticationFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"Authentication\"),\n      _userManager(nullptr),\n      _authCache(nullptr),\n      _authenticationUnixSockets(true),\n      _authenticationSystemOnly(true),\n      _localAuthentication(true),\n      _active(true),\n      _authenticationTimeout(0.0) {\n  setOptional(false);\n  startsAfter<application_features::BasicFeaturePhaseServer>();\n#ifdef USE_ENTERPRISE\n  startsAfter<LdapFeature>();\n#endif\n}", "target": 1}
{"code": "static int magicmouse_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\tstruct input_dev *input = msc->input;\n\tint x = 0, y = 0, ii, clicks = 0, npoints;\n\tswitch (data[0]) {\n\tcase TRACKPAD_REPORT_ID:\n \t\tif (size < 4 || ((size - 4) % 9) != 0)\n \t\t\treturn 0;\n \t\tnpoints = (size - 4) / 9;\n \t\tmsc->ntouches = 0;\n \t\tfor (ii = 0; ii < npoints; ii++)\n \t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 9 + 4);\n\t\tclicks = data[1];\n\t\tbreak;\n\tcase MOUSE_REPORT_ID:\n \t\tif (size < 6 || ((size - 6) % 8) != 0)\n \t\t\treturn 0;\n \t\tnpoints = (size - 6) / 8;\n \t\tmsc->ntouches = 0;\n \t\tfor (ii = 0; ii < npoints; ii++)\n \t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 8 + 6);\n\t\tx = (int)(((data[3] & 0x0c) << 28) | (data[1] << 22)) >> 22;\n\t\ty = (int)(((data[3] & 0x30) << 26) | (data[2] << 22)) >> 22;\n\t\tclicks = data[3];\n\t\tbreak;\n\tcase DOUBLE_REPORT_ID:\n\t\tmagicmouse_raw_event(hdev, report, data + 2, data[1]);\n\t\tmagicmouse_raw_event(hdev, report, data + 2 + data[1],\n\t\t\tsize - 2 - data[1]);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\n\t\tmagicmouse_emit_buttons(msc, clicks & 3);\n\t\tinput_report_rel(input, REL_X, x);\n\t\tinput_report_rel(input, REL_Y, y);\n\t} else { \n\t\tinput_report_key(input, BTN_MOUSE, clicks & 1);\n\t\tinput_mt_report_pointer_emulation(input, true);\n\t}\n\tinput_sync(input);\n\treturn 1;\n}", "target": 1}
{"code": "parserule(struct scanner *s, struct environment *env)\n{\n\tstruct rule *r;\n\tchar *var;\n\tstruct evalstring *val;\n\tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n\tr = mkrule(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\truleaddvar(r, var, val);\n\t\tif (strcmp(var, \"command\") == 0)\n\t\t\thascommand = true;\n\t\telse if (strcmp(var, \"rspfile\") == 0)\n\t\t\thasrspfile = true;\n\t\telse if (strcmp(var, \"rspfile_content\") == 0)\n\t\t\thasrspcontent = true;\n\t}\n\tif (!hascommand)\n\t\tfatal(\"rule '%s' has no command\", r->name);\n\tif (hasrspfile != hasrspcontent)\n\t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n\tenvaddrule(env, r);\n}", "target": 1}
{"code": "static int hso_get_config_data(struct usb_interface *interface)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\tu8 *config_data = kmalloc(17, GFP_KERNEL);\n\tu32 if_num = interface->cur_altsetting->desc.bInterfaceNumber;\n\ts32 result;\n\tif (!config_data)\n\t\treturn -ENOMEM;\n\tif (usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t    0x86, 0xC0, 0, 0, config_data, 17,\n\t\t\t    USB_CTRL_SET_TIMEOUT) != 0x11) {\n\t\tkfree(config_data);\n\t\treturn -EIO;\n\t}\n\tswitch (config_data[if_num]) {\n\tcase 0x0:\n\t\tresult = 0;\n\t\tbreak;\n\tcase 0x1:\n\t\tresult = HSO_PORT_DIAG;\n\t\tbreak;\n\tcase 0x2:\n\t\tresult = HSO_PORT_GPS;\n\t\tbreak;\n\tcase 0x3:\n\t\tresult = HSO_PORT_GPS_CONTROL;\n\t\tbreak;\n\tcase 0x4:\n\t\tresult = HSO_PORT_APP;\n\t\tbreak;\n\tcase 0x5:\n\t\tresult = HSO_PORT_APP2;\n\t\tbreak;\n\tcase 0x6:\n\t\tresult = HSO_PORT_CONTROL;\n\t\tbreak;\n\tcase 0x7:\n\t\tresult = HSO_PORT_NETWORK;\n\t\tbreak;\n\tcase 0x8:\n\t\tresult = HSO_PORT_MODEM;\n\t\tbreak;\n\tcase 0x9:\n\t\tresult = HSO_PORT_MSD;\n\t\tbreak;\n\tcase 0xa:\n\t\tresult = HSO_PORT_PCSC;\n\t\tbreak;\n\tcase 0xb:\n\t\tresult = HSO_PORT_VOICE;\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t}\n\tif (result)\n\t\tresult |= HSO_INTF_BULK;\n\tif (config_data[16] & 0x1)\n\t\tresult |= HSO_INFO_CRC_BUG;\n\tkfree(config_data);\n\treturn result;\n}", "target": 1}
{"code": "static ssize_t fuse_fill_write_pages(struct fuse_req *req,\n\t\t\t       struct address_space *mapping,\n\t\t\t       struct iov_iter *ii, loff_t pos)\n{\n\tstruct fuse_conn *fc = get_fuse_conn(mapping->host);\n\tunsigned offset = pos & (PAGE_CACHE_SIZE - 1);\n\tsize_t count = 0;\n\tint err;\n\treq->in.argpages = 1;\n\treq->page_descs[0].offset = offset;\n\tdo {\n\t\tsize_t tmp;\n\t\tstruct page *page;\n\t\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\t\tsize_t bytes = min_t(size_t, PAGE_CACHE_SIZE - offset,\n\t\t\t\t     iov_iter_count(ii));\n\t\tbytes = min_t(size_t, bytes, fc->max_write - count);\n again:\n\t\terr = -EFAULT;\n\t\tif (iov_iter_fault_in_readable(ii, bytes))\n\t\t\tbreak;\n\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);\n\treturn count > 0 ? count : err;\n}", "target": 1}
{"code": "int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n\t\tif (encoded[1] & 0x80)\n\t\t\tm_adpcmState[c].previousValue -= 0x10000;\n\t\tm_adpcmState[c].index = encoded[2];\n\t\t*decoded++ = m_adpcmState[c].previousValue;\n\t\tencoded += 4;\n\t}\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tint16_t *output = decoded + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n\t\t\t\toutput += channelCount;\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n\t\t\t\toutput += channelCount;\n\t\t\t\tencoded++;\n\t\t\t}\n\t\t}\n\t\tdecoded += channelCount * 8;\n\t}\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}", "target": 1}
{"code": "int linenoiseHistorySave(const char* filename) {\n    FILE* fp = fopen(filename, \"wt\");\n    if (fp == NULL) {\n        return -1;\n    }\n    for (int j = 0; j < historyLen; ++j) {\n        if (history[j][0] != '\\0') {\n            fprintf(fp, \"%s\\n\", history[j]);\n        }\n    }\n    fclose(fp);\n    return 0;\n}", "target": 1}
{"code": "static Jsi_RC jsi_BitfieldToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue,\n    Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    Jsi_csgset *bsget = spec->init.OPT_BITS;\n    Jsi_Interp *d = interp;\n    int idx = spec->idx;\n    uchar *data = (uchar*)record;\n    int64_t inum;\n    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;\n    if (!d || !bsget || idx<0) \n        return Jsi_LogBug(\"invalid bitfield\");\n    Jsi_RC rc = (*bsget)(interp, data, &inum, spec, idx, 0);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n    if (enumSpec) {\n        struct numStruct { int64_t numVal; } nval = { inum };\n        Jsi_OptionSpec eSpec[] = {\n            JSI_OPT(CUSTOM, struct numStruct, numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC, .custom=Jsi_Opt_SwitchEnum,\n            .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ), \n            JSI_OPT_END(struct numStruct)\n        };\n        if (JSI_OK != jsi_EnumToValue(interp, eSpec, outValue, outStr, (void*)&nval, flags))\n            return JSI_ERROR;\n    } else if (outStr) {\n        char obuf[100];\n        snprintf(obuf, sizeof(obuf), \"%\" PRId64, inum);\n        Jsi_DSAppend(outStr, obuf, NULL);\n    } else {\n        Jsi_Number num = (Jsi_Number)inum;\n        Jsi_ValueMakeNumber(interp, outValue, num);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "static apr_status_t session_identity_decode(request_rec * r, session_rec * z)\n{\n    char *last = NULL;\n    char *encoded, *pair;\n    const char *sep = \"&\";\n    if (!z->encoded) {\n        return OK;\n    }\n    encoded = apr_pstrdup(r->pool, z->encoded);\n    pair = apr_strtok(encoded, sep, &last);\n    while (pair && pair[0]) {\n        char *plast = NULL;\n        const char *psep = \"=\";\n        char *key = apr_strtok(pair, psep, &plast);\n        char *val = apr_strtok(NULL, psep, &plast);\n        if (key && *key) {\n            if (!val || !*val) {\n                apr_table_unset(z->entries, key);\n            }\n            else if (!ap_unescape_urlencoded(key) && !ap_unescape_urlencoded(val)) {\n                if (!strcmp(SESSION_EXPIRY, key)) {\n                    z->expiry = (apr_time_t) apr_atoi64(val);\n                }\n                else {\n                    apr_table_set(z->entries, key, val);\n                }\n            }\n        }\n        pair = apr_strtok(NULL, sep, &last);\n    }\n    z->encoded = NULL;\n    return OK;\n}", "target": 1}
{"code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : \"\");\n\t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n\t\treturn CMD_SUCCESS;\n\t}", "target": 1}
{"code": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n    for (i = 0; argv[i]; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n    if (ogs_app()->parameter.no_hss == 0)\n        hss_thread = test_child_create(\"hss\", argv_out);\n    if (ogs_app()->parameter.no_pcrf == 0)\n        pcrf_thread = test_child_create(\"pcrf\", argv_out);\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_sgwu == 0)\n        sgwu_thread = test_child_create(\"sgwu\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_sgwc == 0)\n        sgwc_thread = test_child_create(\"sgwc\", argv_out);\n    if (ogs_app()->parameter.no_mme == 0)\n        mme_thread = test_child_create(\"mme\", argv_out);\n    ogs_msleep(5000);\n    return OGS_OK;;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = Jsi_ObjGetLength(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = Jsi_ObjGetLength(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 1}
{"code": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempt to set secure setting.\");\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static TEE_Result do_allocate_keypair(struct dh_keypair *key, size_t size_bits)\n{\n\tDH_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(size_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(size_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(size_bits);\n\tif (!key->q)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDH_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "content::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n  if (Emit(\"will-navigate\", params.url))\n    return nullptr;\n  if (IsDestroyed())\n    return nullptr;\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}", "target": 1}
{"code": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n \thdr->sadb_msg_version = PF_KEY_V2;\n \thdr->sadb_msg_errno = (uint8_t) 0;\n \thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n \tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 1}
{"code": "void net_checksum_calculate(uint8_t *data, int length)\n{\n    int hlen, plen, proto, csum_offset;\n    uint16_t csum;\n    if ((data[14] & 0xf0) != 0x40)\n\treturn; \n    hlen  = (data[14] & 0x0f) * 4;\n    plen  = (data[16] << 8 | data[17]) - hlen;\n    proto = data[23];\n    switch (proto) {\n    case PROTO_TCP:\n\tcsum_offset = 16;\n\tbreak;\n    case PROTO_UDP:\n\tcsum_offset = 6;\n\tbreak;\n    default:\n\treturn;\n    }\n    if (plen < csum_offset+2)\n\treturn;\n    data[14+hlen+csum_offset]   = 0;\n    data[14+hlen+csum_offset+1] = 0;\n    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);\n    data[14+hlen+csum_offset]   = csum >> 8;\n    data[14+hlen+csum_offset+1] = csum & 0xff;\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    BoxBlurContext *s = ctx->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int plane;\n    int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);\n    int w[4] = { inlink->w, cw, cw, inlink->w };\n    int h[4] = { in->height, ch, ch, in->height };\n    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n    if (!out) {\n        av_frame_free(&in);\n        return AVERROR(ENOMEM);\n    }\n    av_frame_copy_props(out, in);\n    for (plane = 0; in->data[plane] && plane < 4; plane++)\n        hblur(out->data[plane], out->linesize[plane],\n              in ->data[plane], in ->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n    for (plane = 0; in->data[plane] && plane < 4; plane++)\n        vblur(out->data[plane], out->linesize[plane],\n              out->data[plane], out->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n    av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "search_memslots(struct kvm_memslots *slots, gfn_t gfn)\n{\n\tint start = 0, end = slots->used_slots;\n\tint slot = atomic_read(&slots->lru_slot);\n\tstruct kvm_memory_slot *memslots = slots->memslots;\n\tif (gfn >= memslots[slot].base_gfn &&\n\t    gfn < memslots[slot].base_gfn + memslots[slot].npages)\n\t\treturn &memslots[slot];\n\twhile (start < end) {\n\t\tslot = start + (end - start) / 2;\n\t\tif (gfn >= memslots[slot].base_gfn)\n\t\t\tend = slot;\n\t\telse\n\t\t\tstart = slot + 1;\n\t}\n\tif (gfn >= memslots[start].base_gfn &&\n\t    gfn < memslots[start].base_gfn + memslots[start].npages) {\n\t\tatomic_set(&slots->lru_slot, start);\n\t\treturn &memslots[start];\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "int64_t BZ2File::readImpl(char * buf, int64_t length) {\n  if (length == 0) {\n    return 0;\n  }\n  assertx(m_bzFile);\n  int len = BZ2_bzread(m_bzFile, buf, length);\n  if (len <= 0) {\n    setEof(true);\n    if (len < 0) {\n      return -1;\n    }\n  }\n  return len;\n}", "target": 1}
{"code": "static int semctl_down(struct ipc_namespace *ns, int semid,\n\t\t       int cmd, int version, void __user *p)\n{\n\tstruct sem_array *sma;\n\tint err;\n\tstruct semid64_ds semid64;\n\tstruct kern_ipc_perm *ipcp;\n\tif(cmd == IPC_SET) {\n\t\tif (copy_semid_from_user(&semid64, p, version))\n\t\t\treturn -EFAULT;\n\t}\n\tipcp = ipcctl_pre_down_nolock(ns, &sem_ids(ns), semid, cmd,\n\t\t\t\t      &semid64.sem_perm, 0);\n\tif (IS_ERR(ipcp))\n\t\treturn PTR_ERR(ipcp);\n\tsma = container_of(ipcp, struct sem_array, sem_perm);\n\terr = security_sem_semctl(sma, cmd);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\tgoto out_unlock;\n\t}\n\tswitch(cmd){\n\tcase IPC_RMID:\n\t\tipc_lock_object(&sma->sem_perm);\n\t\tfreeary(ns, ipcp);\n\t\tgoto out_up;\n\tcase IPC_SET:\n\t\tipc_lock_object(&sma->sem_perm);\n\t\terr = ipc_update_perm(&semid64.sem_perm, ipcp);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\tsma->sem_ctime = get_seconds();\n\t\tbreak;\n\tdefault:\n\t\trcu_read_unlock();\n\t\terr = -EINVAL;\n\t\tgoto out_up;\n\t}\nout_unlock:\n\tsem_unlock(sma);\nout_up:\n\tup_write(&sem_ids(ns).rw_mutex);\n\treturn err;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tsctp_chunkhdr_t *ch = NULL;\n\tif ((chunk = queue->in_progress)) {\n\t\tif (chunk->singleton ||\n\t\t    chunk->end_of_packet ||\n\t\t    chunk->pdiscard) {\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tchunk = queue->in_progress = NULL;\n\t\t} else {\n\t\t\tch = (sctp_chunkhdr_t *) chunk->chunk_end;\n\t\t\tskb_pull(chunk->skb,\n\t\t\t\t chunk->chunk_end - chunk->skb->data);\n\t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\n\t\t\t\tsctp_chunk_free(chunk);\n\t\t\t\tchunk = queue->in_progress = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (!chunk) {\n\t\tstruct list_head *entry;\n\t\tif (list_empty(&queue->in_chunk_list))\n\t\t\treturn NULL;\n\t\tentry = queue->in_chunk_list.next;\n\t\tchunk = queue->in_progress =\n\t\t\tlist_entry(entry, struct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\t\tchunk->singleton = 1;\n\t\tch = (sctp_chunkhdr_t *) chunk->skb->data;\n\t\tchunk->data_accepted = 0;\n\t}\n\tchunk->chunk_hdr = ch;\n\tchunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\tif (unlikely(skb_is_nonlinear(chunk->skb))) {\n\t\tif (chunk->chunk_end > skb_tail_pointer(chunk->skb))\n\t\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\t}\n\tskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\n\tchunk->subh.v = NULL; \n\tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\n\t\tchunk->singleton = 0;\n\t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n\t\tsctp_chunk_free(chunk);\n\t\tchunk = queue->in_progress = NULL;\n\t\treturn NULL;\n\t} else {\n\t\tchunk->end_of_packet = 1;\n\t}\n\tpr_debug(\"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\n\",\n\t\t chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len);\n\treturn chunk;\n}", "target": 1}
{"code": "inline void* aligned_malloc(size_t size, size_t alignment) {\n  return folly::detail::aligned_malloc(size, alignment);\n}", "target": 1}
{"code": "hphp_libxml_input_buffer_noload(const char *URI, xmlCharEncoding enc) {\n  return nullptr;\n}", "target": 1}
{"code": "static int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(provider);\n}", "target": 1}
{"code": "static void coroutine_fn mirror_wait_on_conflicts(MirrorOp *self,\n                                                  MirrorBlockJob *s,\n                                                  uint64_t offset,\n                                                  uint64_t bytes)\n{\n    uint64_t self_start_chunk = offset / s->granularity;\n    uint64_t self_end_chunk = DIV_ROUND_UP(offset + bytes, s->granularity);\n    uint64_t self_nb_chunks = self_end_chunk - self_start_chunk;\n    while (find_next_bit(s->in_flight_bitmap, self_end_chunk,\n                         self_start_chunk) < self_end_chunk &&\n           s->ret >= 0)\n    {\n        MirrorOp *op;\n        QTAILQ_FOREACH(op, &s->ops_in_flight, next) {\n            uint64_t op_start_chunk = op->offset / s->granularity;\n            uint64_t op_nb_chunks = DIV_ROUND_UP(op->offset + op->bytes,\n                                                 s->granularity) -\n                                    op_start_chunk;\n            if (op == self) {\n                continue;\n            }\n            if (ranges_overlap(self_start_chunk, self_nb_chunks,\n                               op_start_chunk, op_nb_chunks))\n            {\n                if (op->waiting_for_op) {\n                    continue;\n                }\n                self->waiting_for_op = op;\n                qemu_co_queue_wait(&op->waiting_requests, NULL);\n                self->waiting_for_op = NULL;\n                break;\n            }\n        }\n    }\n}", "target": 1}
{"code": "nbd_unlocked_opt_go (struct nbd_handle *h)\n{\n  int err;\n  nbd_completion_callback c = { .callback = go_complete, .user_data = &err };\n  int r = nbd_unlocked_aio_opt_go (h, &c);\n  if (r == -1)\n    return r;\n  r = wait_for_option (h);\n  if (r == 0 && err) {\n    assert (nbd_internal_is_state_negotiating (get_next_state (h)));\n    set_error (err, \"server replied with error to opt_go request\");\n    return -1;\n  }\n  if (r == 0)\n    assert (nbd_internal_is_state_ready (get_next_state (h)));\n  return r;\n}", "target": 1}
{"code": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n\t       sizeof(ualg->cru_driver_name));\n\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n\t       CRYPTO_MAX_ALG_NAME);\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "gsm_xsmp_client_connect (GsmXSMPClient *client,\n                         SmsConn        conn,\n                         unsigned long *mask_ret,\n                         SmsCallbacks  *callbacks_ret)\n{\n        client->priv->conn = conn;\n        if (client->priv->protocol_timeout) {\n                g_source_remove (client->priv->protocol_timeout);\n                client->priv->protocol_timeout = 0;\n        }\n        g_debug (\"GsmXSMPClient: Initializing client %s\", client->priv->description);\n        *mask_ret = 0;\n        *mask_ret |= SmsRegisterClientProcMask;\n        callbacks_ret->register_client.callback = register_client_callback;\n        callbacks_ret->register_client.manager_data  = client;\n        *mask_ret |= SmsInteractRequestProcMask;\n        callbacks_ret->interact_request.callback = interact_request_callback;\n        callbacks_ret->interact_request.manager_data = client;\n        *mask_ret |= SmsInteractDoneProcMask;\n        callbacks_ret->interact_done.callback = interact_done_callback;\n        callbacks_ret->interact_done.manager_data = client;\n        *mask_ret |= SmsSaveYourselfRequestProcMask;\n        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;\n        callbacks_ret->save_yourself_request.manager_data = client;\n        *mask_ret |= SmsSaveYourselfP2RequestProcMask;\n        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;\n        callbacks_ret->save_yourself_phase2_request.manager_data = client;\n        *mask_ret |= SmsSaveYourselfDoneProcMask;\n        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;\n        callbacks_ret->save_yourself_done.manager_data = client;\n        *mask_ret |= SmsCloseConnectionProcMask;\n        callbacks_ret->close_connection.callback = close_connection_callback;\n        callbacks_ret->close_connection.manager_data  = client;\n        *mask_ret |= SmsSetPropertiesProcMask;\n        callbacks_ret->set_properties.callback = set_properties_callback;\n        callbacks_ret->set_properties.manager_data = client;\n        *mask_ret |= SmsDeletePropertiesProcMask;\n        callbacks_ret->delete_properties.callback = delete_properties_callback;\n        callbacks_ret->delete_properties.manager_data = client;\n        *mask_ret |= SmsGetPropertiesProcMask;\n        callbacks_ret->get_properties.callback = get_properties_callback;\n        callbacks_ret->get_properties.manager_data = client;\n}", "target": 1}
{"code": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrlcpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrlcpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\t\tstrlcpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}", "target": 1}
{"code": "\tCxFile(void) { };", "target": 1}
{"code": "status_t GraphicBuffer::unflatten(\n void const*& buffer, size_t& size, int const*& fds, size_t& count) {\n if (size < 8*sizeof(int)) return NO_MEMORY;\n int const* buf = static_cast<int const*>(buffer);\n if (buf[0] != 'GBFR') return BAD_TYPE;\n     const size_t numFds  = buf[8];\n     const size_t numInts = buf[9];\n     const size_t sizeNeeded = (10 + numInts) * sizeof(int);\n     if (size < sizeNeeded) return NO_MEMORY;\n    size_t fdCountNeeded = 0;\n     if (count < fdCountNeeded) return NO_MEMORY;\n     if (handle) {\n        free_handle();\n }\n if (numFds || numInts) {\n        width  = buf[1];\n        height = buf[2];\n        stride = buf[3];\n         format = buf[4];\n         usage  = buf[5];\n         native_handle* h = native_handle_create(numFds, numInts);\n         memcpy(h->data,          fds,     numFds*sizeof(int));\n         memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));\n         handle = h;\n } else {\n        width = height = stride = format = usage = 0;\n        handle = NULL;\n }\n    mId = static_cast<uint64_t>(buf[6]) << 32;\n    mId |= static_cast<uint32_t>(buf[7]);\n    mOwner = ownHandle;\n if (handle != 0) {\n status_t err = mBufferMapper.registerBuffer(handle);\n if (err != NO_ERROR) {\n            width = height = stride = format = usage = 0;\n            handle = NULL;\n            ALOGE(\"unflatten: registerBuffer failed: %s (%d)\",\n                    strerror(-err), err);\n return err;\n }\n }\n    buffer = reinterpret_cast<void const*>(static_cast<int const*>(buffer) + sizeNeeded);\n    size -= sizeNeeded;\n    fds += numFds;\n    count -= numFds;\n return NO_ERROR;\n}", "target": 1}
{"code": "static int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\tdown_read(&card->controls_rwsem);\n\tresult = snd_ctl_elem_read(card, control);\n\tup_read(&card->controls_rwsem);\n\tif (result < 0)\n\t\tgoto error;\n\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\tresult = -EFAULT;\n error:\n\tkfree(control);\n\treturn result;\n}", "target": 1}
{"code": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n     (void) cs;\n     PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n         PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n         mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n         return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    return MK_PLUGIN_RET_NOT_ME;\n}", "target": 1}
{"code": "void posixtimer_rearm(struct siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\tif (timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1;\n\t\t++timr->it_requeue_pending;\n\t\tinfo->si_overrun += timr->it_overrun_last;\n\t}\n\tunlock_timer(timr, flags);\n}", "target": 1}
{"code": "file_extension(const char *s)\t\n{\n  const char\t*extension;\t\n  static char\tbuf[1024];\t\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n    return (\"jpg\");\n  else if (!strncmp(s, \"data:image/png;\", 15))\n    return (\"png\");\n  else if ((extension = strrchr(s, '/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n  strlcpy(buf, extension, sizeof(buf));\n  *(char *)strchr(buf, '#') = '\\0';\n  return (buf);\n}", "target": 1}
{"code": "  static TfLiteRegistration DelegateRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      TfLiteTensor* output0 = GetOutput(context, node, 0);\n      TF_LITE_ENSURE(context, IsDynamicTensor(output0));\n      const TfLiteTensor* input = GetInput(context, node, 0);\n      TfLiteTensor* output1 = GetOutput(context, node, 1);\n      TF_LITE_ENSURE(context, input->dims->size == output1->dims->size);\n      TF_LITE_ENSURE(context, input->dims->data[0] == output1->dims->data[0]);\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "\tvoid initialize(const string &path, bool owner) {\n\t\tTRACE_POINT();\n\t\tthis->path  = path;\n\t\tthis->owner = owner;\n\t\tmakeDirTree(path, \"u=rwx,g=rx,o=rx\");\n\t}", "target": 1}
{"code": "int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n{\n\tu8 *buf = NULL;\n\tint err;\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tget_random_bytes(buf, slen);\n\t\tseed = buf;\n\t}\n\terr = tfm->seed(tfm, seed, slen);\n\tkfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "static int cg_opendir(const char *path, struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tconst char *cgroup;\n\tstruct file_info *dir_info;\n\tchar *controller = NULL;\n\tif (!fc)\n\t\treturn -EIO;\n\tif (strcmp(path, \"/cgroup\") == 0) {\n\t\tcgroup = NULL;\n\t\tcontroller = NULL;\n\t} else {\n\t\tcontroller = pick_controller_from_path(fc, path);\n\t\tif (!controller)\n\t\t\treturn -EIO;\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\treturn -EACCES;\n\t}\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;\n\tdir_info->file = NULL;\n\tdir_info->buflen = 0;\n\tfi->fh = (unsigned long)dir_info;\n\treturn 0;\n}", "target": 1}
{"code": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                               gss_buffer_t interprocess_token)\n {\n     OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n     if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;\n    }\n     return maj;\n }", "target": 1}
{"code": "tlb_update_vma_flags(struct mmu_gather *tlb, struct vm_area_struct *vma) { }", "target": 1}
{"code": "walk_string(fz_context *ctx, int uni, int remove, editable_str *str)\n {\n        int rune;\n       if (str->utf8 == NULL)\n                return;\n        do\n\t{\n\t\tchar *s = &str->utf8[str->pos];\n\t\tsize_t len;\n\t\tint n = fz_chartorune(&rune, s);\n\t\tif (rune == uni)\n\t\t{\n\t\t\tstr->pos += n;\n\t\t}\n\t\telse if (uni == 32) {\n\t\t\tbreak;\n\t\t}\n\t\telse if (rune == 32) {\n\t\t}\n\t\telse\n\t\t{\n\t\t\tstr->pos = -1;\n\t\t\tbreak;\n\t\t}\n\t\tif (remove)\n\t\t{\n\t\t\tlen = strlen(s+n);\n\t\t\tmemmove(s, s+n, len+1);\n\t\t\tstr->edited = 1;\n\t\t}\n\t}\n\twhile (rune != uni);\n}", "target": 1}
{"code": "struct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n        put_bits(&pb, 3, 5); \n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n    adts->write_adts = 1;\n    return 0;\n}", "target": 1}
{"code": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n \t\tgoto exit;\n \t}\n \ts_cmd->command += ec->cmd_offset;\n \tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n \tif (ret < 0)\n \t\tgoto exit;\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n \t\tret = -EFAULT;\n exit:\n \tkfree(s_cmd);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n \tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n \t\treturn -EINVAL;\n \treturn 0;\n }", "target": 1}
{"code": "static void hci_extended_inquiry_result_evt(struct hci_dev *hdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct inquiry_data data;\n\tstruct extended_inquiry_info *info = (void *) (skb->data + 1);\n\tint num_rsp = *((__u8 *) skb->data);\n\tsize_t eir_len;\n\tBT_DBG(\"%s num_rsp %d\", hdev->name, num_rsp);\n\tif (!num_rsp)\n\t\treturn;\n\tif (hci_dev_test_flag(hdev, HCI_PERIODIC_INQ))\n\t\treturn;\n\thci_dev_lock(hdev);\n\tfor (; num_rsp; num_rsp--, info++) {\n\t\tu32 flags;\n\t\tbool name_known;\n\t\tbacpy(&data.bdaddr, &info->bdaddr);\n\t\tdata.pscan_rep_mode\t= info->pscan_rep_mode;\n\t\tdata.pscan_period_mode\t= info->pscan_period_mode;\n\t\tdata.pscan_mode\t\t= 0x00;\n\t\tmemcpy(data.dev_class, info->dev_class, 3);\n\t\tdata.clock_offset\t= info->clock_offset;\n\t\tdata.rssi\t\t= info->rssi;\n\t\tdata.ssp_mode\t\t= 0x01;\n\t\tif (hci_dev_test_flag(hdev, HCI_MGMT))\n\t\t\tname_known = eir_get_data(info->data,\n\t\t\t\t\t\t  sizeof(info->data),\n\t\t\t\t\t\t  EIR_NAME_COMPLETE, NULL);\n\t\telse\n\t\t\tname_known = true;\n\t\tflags = hci_inquiry_cache_update(hdev, &data, name_known);\n\t\teir_len = eir_get_length(info->data, sizeof(info->data));\n\t\tmgmt_device_found(hdev, &info->bdaddr, ACL_LINK, 0x00,\n\t\t\t\t  info->dev_class, info->rssi,\n\t\t\t\t  flags, info->data, eir_len, NULL, 0);\n\t}\n\thci_dev_unlock(hdev);\n}", "target": 1}
{"code": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}", "target": 1}
{"code": "pam_converse (int num_msg, PAM_CONVERSE_ARG2_TYPE **msg,\n  struct pam_response **resp, void *appdata_ptr)\n{\nint sep = 0;\nstruct pam_response *reply;\nif (  pam_arg_ended\n   || !(reply = malloc(sizeof(struct pam_response) * num_msg)))\n  return PAM_CONV_ERR;\nfor (int i = 0; i < num_msg; i++)\n  {\n  uschar *arg;\n  switch (msg[i]->msg_style)\n    {\n    case PAM_PROMPT_ECHO_ON:\n    case PAM_PROMPT_ECHO_OFF:\n      if (!(arg = string_nextinlist(&pam_args, &sep, NULL, 0)))\n\t{\n\targ = US\"\";\n\tpam_arg_ended = TRUE;\n\t}\n      reply[i].resp = CS string_copy_malloc(arg); \n      reply[i].resp_retcode = PAM_SUCCESS;\n      break;\n    case PAM_TEXT_INFO:    \n    case PAM_ERROR_MSG:\n      reply[i].resp_retcode = PAM_SUCCESS;\n      reply[i].resp = NULL;\n      break;\n    default:  \n      free(reply);\n      pam_conv_had_error = TRUE;\n      return PAM_CONV_ERR;\n    }\n  }\n*resp = reply;\nreturn PAM_SUCCESS;\n}", "target": 1}
{"code": "get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n\tstruct _7zip *zip = (struct _7zip *)a->format->data;\n\tssize_t bytes_avail;\n \tif (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n\t\t*buff = __archive_read_ahead(a, 1, &bytes_avail);\n \t\tif (bytes_avail <= 0) {\n \t\t\tarchive_set_error(&a->archive,\n \t\t\t    ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Truncated 7-Zip file data\");\n\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif ((size_t)bytes_avail >\n\t\t    zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\tif ((size_t)bytes_avail > size)\n\t\t\tbytes_avail = (ssize_t)size;\n\t\tzip->pack_stream_bytes_unconsumed = bytes_avail;\n\t} else if (zip->uncompressed_buffer_pointer == NULL) {\n\t\tarchive_set_error(&(a->archive),\n\t\t    ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n\t\treturn (ARCHIVE_FATAL);\n\t} else {\n\t\tif (minimum > zip->uncompressed_buffer_bytes_remaining) {\n\t\t\tif (extract_pack_stream(a, minimum) < 0)\n\t\t\t\treturn (ARCHIVE_FATAL);\n\t\t}\n\t\tif (size > zip->uncompressed_buffer_bytes_remaining)\n\t\t\tbytes_avail = (ssize_t)\n\t\t\t    zip->uncompressed_buffer_bytes_remaining;\n\t\telse\n\t\t\tbytes_avail = (ssize_t)size;\n\t\t*buff = zip->uncompressed_buffer_pointer;\n\t\tzip->uncompressed_buffer_pointer += bytes_avail;\n\t}\n\tzip->uncompressed_buffer_bytes_remaining -= bytes_avail;\n\treturn (bytes_avail);\n}", "target": 1}
{"code": "static int t220_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x87, 0 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x86;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 0;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(50);\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0x51;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n\t\t\t\t\t&d->dev->i2c_adap, NULL);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,\n\t\t\t\t\t&d->dev->i2c_adap, &tda18271_config)) {\n\t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "static void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval = 0;\n\tint port_number;\n\tint status = urb->status;\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\", __func__, status);\n\t}\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n\tport_number = edge_port->port->port_number;\n\tif (edge_port->lsr_event) {\n\t\tedge_port->lsr_event = 0;\n\t\tdev_dbg(dev, \"%s ===== Port %u LSR Status = %02x, Data = %02x ======\\n\",\n\t\t\t__func__, port_number, edge_port->lsr_mask, *data);\n\t\thandle_new_lsr(edge_port, 1, edge_port->lsr_mask, *data);\n\t\t--urb->actual_length;\n\t\t++data;\n\t}\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\t\tif (edge_port->close_pending)\n\t\t\tdev_dbg(dev, \"%s - close pending, dropping data on the floor\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t\telse\n\t\t\tedge_tty_recv(edge_port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\tedge_port->port->icount.rx += urb->actual_length;\n\t}\nexit:\n\tspin_lock(&edge_port->ep_lock);\n\tif (edge_port->ep_read_urb_state == EDGE_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (edge_port->ep_read_urb_state == EDGE_READ_URB_STOPPING)\n\t\tedge_port->ep_read_urb_state = EDGE_READ_URB_STOPPED;\n\tspin_unlock(&edge_port->ep_lock);\n\tif (retval)\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\", __func__, retval);\n}", "target": 1}
{"code": "ChunkedDecode(Request *reqPtr, bool update)\n{\n    const Tcl_DString *bufPtr;\n    const char        *end, *chunkStart;\n    bool              success = NS_TRUE;\n    NS_NONNULL_ASSERT(reqPtr != NULL);\n    bufPtr = &reqPtr->buffer;\n    end = bufPtr->string + bufPtr->length;\n    chunkStart = bufPtr->string + reqPtr->chunkStartOff;\n    while (reqPtr->chunkStartOff <  (size_t)bufPtr->length) {\n        char   *p = strstr(chunkStart, \"\\r\\n\");\n        size_t  chunk_length;\n        if (p == NULL) {\n            Ns_Log(DriverDebug, \"ChunkedDecode: chunk did not find end-of-line\");\n            success = NS_FALSE;\n            break;\n        }\n        *p = '\\0';\n        chunk_length = (size_t)strtol(chunkStart, NULL, 16);\n        *p = '\\r';\n        if (p + 2 + chunk_length > end) {\n            Ns_Log(DriverDebug, \"ChunkedDecode: chunk length past end of buffer\");\n            success = NS_FALSE;\n            break;\n        }\n        if (update) {\n            char *writeBuffer = bufPtr->string + reqPtr->chunkWriteOff;\n            memmove(writeBuffer, p + 2, chunk_length);\n            reqPtr->chunkWriteOff += chunk_length;\n            *(writeBuffer + chunk_length) = '\\0';\n        }\n        reqPtr->chunkStartOff += (size_t)(p - chunkStart) + 4u + chunk_length;\n        chunkStart = bufPtr->string + reqPtr->chunkStartOff;\n    }\n    return success;\n}", "target": 1}
{"code": "_XcursorThemeInherits (const char *full)\n{\n    char    line[8192];\n    char    *result = NULL;\n    FILE    *f;\n    if (!full)\n        return NULL;\n    f = fopen (full, \"r\");\n    if (f)\n    {\n\twhile (fgets (line, sizeof (line), f))\n\t{\n\t    if (!strncmp (line, \"Inherits\", 8))\n\t    {\n\t\tchar    *l = line + 8;\n\t\tchar    *r;\n\t\twhile (*l == ' ') l++;\n \t\tif (*l != '=') continue;\n \t\tl++;\n \t\twhile (*l == ' ') l++;\n\t\tresult = malloc (strlen (l));\n \t\tif (result)\n \t\t{\n \t\t    r = result;\n\t\t    while (*l)\n\t\t    {\n\t\t\twhile (XcursorSep(*l) || XcursorWhite (*l)) l++;\n\t\t\tif (!*l)\n\t\t\t    break;\n\t\t\tif (r != result)\n\t\t\t    *r++ = ':';\n\t\t\twhile (*l && !XcursorWhite(*l) &&\n\t\t\t       !XcursorSep(*l))\n\t\t\t    *r++ = *l++;\n\t\t    }\n\t\t    *r++ = '\\0';\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\tfclose (f);\n    }\n    return result;\n}", "target": 1}
{"code": "getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static getprivs_ret            ret;\n    gss_buffer_desc                client_name, service_name;\n    OM_uint32                      minor_stat;\n    kadm5_server_handle_t          handle;\n    const char                     *errmsg = NULL;\n    xdr_free(xdr_getprivs_ret, &ret);\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n    if (errmsg != NULL)\n        krb5_free_error_message(handle->context, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static int do_sched_cfs_period_timer(struct cfs_bandwidth *cfs_b, int overrun, unsigned long flags)\n{\n\tu64 runtime, runtime_expires;\n\tint throttled;\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tgoto out_deactivate;\n\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\tcfs_b->nr_periods += overrun;\n\tif (cfs_b->idle && !throttled)\n\t\tgoto out_deactivate;\n\t__refill_cfs_bandwidth_runtime(cfs_b);\n\tif (!throttled) {\n\t\tcfs_b->idle = 1;\n\t\treturn 0;\n\t}\n\tcfs_b->nr_throttled += overrun;\n\truntime_expires = cfs_b->runtime_expires;\n\twhile (throttled && cfs_b->runtime > 0 && !cfs_b->distribute_running) {\n\t\truntime = cfs_b->runtime;\n\t\tcfs_b->distribute_running = 1;\n\t\traw_spin_unlock_irqrestore(&cfs_b->lock, flags);\n\t\truntime = distribute_cfs_runtime(cfs_b, runtime,\n\t\t\t\t\t\t runtime_expires);\n\t\traw_spin_lock_irqsave(&cfs_b->lock, flags);\n\t\tcfs_b->distribute_running = 0;\n\t\tthrottled = !list_empty(&cfs_b->throttled_cfs_rq);\n\t\tlsub_positive(&cfs_b->runtime, runtime);\n\t}\n\tcfs_b->idle = 0;\n\treturn 0;\nout_deactivate:\n\treturn 1;\n}", "target": 1}
{"code": "\tvirtual size_t\tRead(void *buffer, size_t size, size_t count)\n\t{\n\t\tif (!m_fp) return 0;\n\t\treturn fread(buffer, size, count, m_fp);\n\t}", "target": 1}
{"code": "static void TEST_sub_add_single(void)\n{\n\tstruct mosquitto__config config;\n\tstruct mosquitto__listener listener;\n\tstruct mosquitto context;\n\tstruct mosquitto__subhier *sub;\n\tint rc;\n\tmemset(&db, 0, sizeof(struct mosquitto_db));\n\tmemset(&config, 0, sizeof(struct mosquitto__config));\n\tmemset(&listener, 0, sizeof(struct mosquitto__listener));\n\tmemset(&context, 0, sizeof(struct mosquitto));\n\tcontext.id = \"client\";\n\tdb.config = &config;\n\tlistener.port = 1883;\n\tconfig.listeners = &listener;\n\tconfig.listener_count = 1;\n\tdb__open(&config);\n\trc = sub__add(&context, \"a/b/c/d/e\", 0, 0, 0);\n\tCU_ASSERT_EQUAL(rc, MOSQ_ERR_SUCCESS);\n\tCU_ASSERT_PTR_NOT_NULL(db.subs);\n\tif(db.subs){\n\t\tsub = db.subs;\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"a\");\n\t\thier_quick_check(&sub, NULL, \"b\");\n\t\thier_quick_check(&sub, NULL, \"c\");\n\t\thier_quick_check(&sub, NULL, \"d\");\n\t\thier_quick_check(&sub, &context, \"e\");\n\t\tCU_ASSERT_PTR_NULL(sub);\n\t}\n\tmosquitto__free(context.subs);\n\tdb__close();\n}", "target": 1}
{"code": "ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\ncleanup:\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n}", "target": 1}
{"code": "static int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n \t\t\tgoto out;\n \t\t}\n \t\tret = -EIO;\n \t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n \t\tif (bh) {\n \t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}", "target": 1}
{"code": "struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tkey_ref = search_process_keyrings(&ctx);\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}", "target": 1}
{"code": "static void *etm_setup_aux(int event_cpu, void **pages,\n\t\t\t   int nr_pages, bool overwrite)\n{\n\tint cpu;\n\tcpumask_t *mask;\n\tstruct coresight_device *sink;\n\tstruct etm_event_data *event_data = NULL;\n\tevent_data = alloc_event_data(event_cpu);\n\tif (!event_data)\n\t\treturn NULL;\n\tsink = coresight_get_enabled_sink(true);\n\tif (!sink)\n\t\tgoto err;\n\tINIT_WORK(&event_data->work, free_event_data);\n\tmask = &event_data->mask;\n\tfor_each_cpu(cpu, mask) {\n\t\tstruct coresight_device *csdev;\n\t\tcsdev = per_cpu(csdev_src, cpu);\n\t\tif (!csdev)\n\t\t\tgoto err;\n\t\tevent_data->path[cpu] = coresight_build_path(csdev, sink);\n\t\tif (IS_ERR(event_data->path[cpu]))\n\t\t\tgoto err;\n\t}\n \tif (!sink_ops(sink)->alloc_buffer)\n \t\tgoto err;\n \tevent_data->snk_config =\n \t\t\tsink_ops(sink)->alloc_buffer(sink, cpu, pages,\n\t\t\t\t\t\t     nr_pages, overwrite);\n\tif (!event_data->snk_config)\n\t\tgoto err;\nout:\n\treturn event_data;\nerr:\n\tetm_free_aux(event_data);\n\tevent_data = NULL;\n\tgoto out;\n}", "target": 1}
{"code": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\t*_request = NULL;\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n\tpool_unref(&request->pool);\n}", "target": 1}
{"code": "rpl_print(netdissect_options *ndo,\n          const struct icmp6_hdr *hdr,\n          const u_char *bp, u_int length)\n{\n        int secured = hdr->icmp6_code & 0x80;\n        int basecode= hdr->icmp6_code & 0x7f;\n        if(secured) {\n                ND_PRINT((ndo, \", (SEC) [worktodo]\"));\n                return;\n        } else {\n                ND_PRINT((ndo, \", (CLR)\"));\n        }\n        switch(basecode) {\n        case ND_RPL_DAG_IS:\n                ND_PRINT((ndo, \"DODAG Information Solicitation\"));\n                if(ndo->ndo_vflag) {\n                }\n                break;\n        case ND_RPL_DAG_IO:\n                ND_PRINT((ndo, \"DODAG Information Object\"));\n                if(ndo->ndo_vflag) {\n                        rpl_dio_print(ndo, bp, length);\n                }\n                break;\n        case ND_RPL_DAO:\n                ND_PRINT((ndo, \"Destination Advertisement Object\"));\n                if(ndo->ndo_vflag) {\n                        rpl_dao_print(ndo, bp, length);\n                }\n                break;\n        case ND_RPL_DAO_ACK:\n                ND_PRINT((ndo, \"Destination Advertisement Object Ack\"));\n                if(ndo->ndo_vflag) {\n                        rpl_daoack_print(ndo, bp, length);\n                }\n                break;\n        default:\n                ND_PRINT((ndo, \"RPL message, unknown code %u\",hdr->icmp6_code));\n                break;\n        }\n\treturn;\n#if 0\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n#endif\n}", "target": 1}
{"code": "  const hbc::DebugOffsets *getDebugOffsets(uint32_t) const override {\n    llvm_unreachable(\"Accessing debug offsets from a lazy module\");\n  }", "target": 1}
{"code": "static int zr364xx_vidioc_querycap(struct file *file, void *priv,\n\t\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct zr364xx_camera *cam = video_drvdata(file);\n\tstrscpy(cap->driver, DRIVER_DESC, sizeof(cap->driver));\n\tstrscpy(cap->card, cam->udev->product, sizeof(cap->card));\n\tstrscpy(cap->bus_info, dev_name(&cam->udev->dev),\n\t\tsizeof(cap->bus_info));\n\tcap->device_caps = V4L2_CAP_VIDEO_CAPTURE |\n\t\t\t    V4L2_CAP_READWRITE |\n\t\t\t    V4L2_CAP_STREAMING;\n\tcap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\n\treturn 0;\n}", "target": 1}
{"code": "int CommandData::IsProcessFile(FileHeader &FileHead,bool *ExactMatch,int MatchType,\n                               wchar *MatchedArg,uint MatchedArgSize)\n{\n  if (MatchedArg!=NULL && MatchedArgSize>0)\n    *MatchedArg=0;\n  if (wcslen(FileHead.FileName)>=NM)\n    return 0;\n  bool Dir=FileHead.Dir;\n  if (ExclCheck(FileHead.FileName,Dir,false,true))\n    return 0;\n#ifndef SFX_MODULE\n  if (TimeCheck(FileHead.mtime))\n    return 0;\n  if ((FileHead.FileAttr & ExclFileAttr)!=0 || InclAttrSet && (FileHead.FileAttr & InclFileAttr)==0)\n    return 0;\n  if (!Dir && SizeCheck(FileHead.UnpSize))\n    return 0;\n#endif\n  wchar *ArgName;\n  FileArgs.Rewind();\n  for (int StringCount=1;(ArgName=FileArgs.GetString())!=NULL;StringCount++)\n    if (CmpName(ArgName,FileHead.FileName,MatchType))\n    {\n      if (ExactMatch!=NULL)\n        *ExactMatch=wcsicompc(ArgName,FileHead.FileName)==0;\n      if (MatchedArg!=NULL)\n        wcsncpyz(MatchedArg,ArgName,MatchedArgSize);\n      return StringCount;\n    }\n  return 0;\n}", "target": 1}
{"code": "ChildProcessTerminationInfo ChildProcessLauncherHelper::GetTerminationInfo(\n    const ChildProcessLauncherHelper::Process& process,\n    bool known_dead) {\n  ChildProcessTerminationInfo info;\n   if (!java_peer_avaiable_on_client_thread_)\n     return info;\n  Java_ChildProcessLauncherHelperImpl_getTerminationInfo(\n       AttachCurrentThread(), java_peer_, reinterpret_cast<intptr_t>(&info));\n   base::android::ApplicationState app_state =\n      base::android::ApplicationStatusListener::GetState();\n  bool app_foreground =\n      app_state == base::android::APPLICATION_STATE_HAS_RUNNING_ACTIVITIES ||\n      app_state == base::android::APPLICATION_STATE_HAS_PAUSED_ACTIVITIES;\n  if (app_foreground &&\n      (info.binding_state == base::android::ChildBindingState::MODERATE ||\n       info.binding_state == base::android::ChildBindingState::STRONG)) {\n    info.status = base::TERMINATION_STATUS_OOM_PROTECTED;\n  } else {\n    info.status = base::TERMINATION_STATUS_NORMAL_TERMINATION;\n  }\n  return info;\n}", "target": 1}
{"code": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\tmod_alias_patch_connection(srv, con, p);\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n \t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n \t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n \t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n \t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\treturn HANDLER_GO_ON;\n}", "target": 1}
{"code": "bool SubsetterImpl::ResolveCompositeGlyphs(const unsigned int* glyph_ids,\n                                           size_t glyph_count,\n                                           IntegerSet* glyph_id_processed) {\n  if (glyph_ids == NULL || glyph_count == 0 || glyph_id_processed == NULL) {\n    return false;\n  }\n  GlyphTablePtr glyph_table =\n      down_cast<GlyphTable*>(font_->GetTable(Tag::glyf));\n  LocaTablePtr loca_table = down_cast<LocaTable*>(font_->GetTable(Tag::loca));\n  if (glyph_table == NULL || loca_table == NULL) {\n    return false;\n  }\n  IntegerSet glyph_id_remaining;\n  glyph_id_remaining.insert(0);  \n  for (size_t i = 0; i < glyph_count; ++i) {\n    glyph_id_remaining.insert(glyph_ids[i]);\n  }\n  while (!glyph_id_remaining.empty()) {\n    IntegerSet comp_glyph_id;\n    for (IntegerSet::iterator i = glyph_id_remaining.begin(),\n                              e = glyph_id_remaining.end(); i != e; ++i) {\n      if (*i < 0 || *i >= loca_table->NumGlyphs()) {\n        continue;\n      }\n      int32_t length = loca_table->GlyphLength(*i);\n      if (length == 0) {\n        continue;\n      }\n      int32_t offset = loca_table->GlyphOffset(*i);\n      GlyphPtr glyph;\n      glyph.Attach(glyph_table->GetGlyph(offset, length));\n      if (glyph == NULL) {\n        continue;\n      }\n      if (glyph->GlyphType() == GlyphType::kComposite) {\n        Ptr<GlyphTable::CompositeGlyph> comp_glyph =\n            down_cast<GlyphTable::CompositeGlyph*>(glyph.p_);\n        for (int32_t j = 0; j < comp_glyph->NumGlyphs(); ++j) {\n          int32_t glyph_id = comp_glyph->GlyphIndex(j);\n          if (glyph_id_processed->find(glyph_id) == glyph_id_processed->end() &&\n              glyph_id_remaining.find(glyph_id) == glyph_id_remaining.end()) {\n            comp_glyph_id.insert(comp_glyph->GlyphIndex(j));\n          }\n        }\n      }\n      glyph_id_processed->insert(*i);\n    }\n     glyph_id_remaining.clear();\n     glyph_id_remaining = comp_glyph_id;\n   }\n }", "target": 1}
{"code": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\tif (!res)\n\t\tgoto out;\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n \tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n  out:\n \tkfree(resp);\n \treturn res;\n}", "target": 1}
{"code": "bool MemoryManager::validate_user_write(const Process& process, VirtualAddress vaddr) const\n{\n    auto* region = region_from_vaddr(process, vaddr);\n    return region && region->is_writable();\n}", "target": 1}
{"code": "static void encode_share_access(struct xdr_stream *xdr, int open_flags)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tswitch (open_flags & (FMODE_READ|FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_READ);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_WRITE);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tWRITE32(NFS4_SHARE_ACCESS_BOTH);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t}\n\tWRITE32(0);\t\t\n}", "target": 1}
{"code": "build_principal_va(krb5_context context, krb5_principal princ,\n                   unsigned int rlen, const char *realm, va_list ap)\n{\n    krb5_error_code retval = 0;\n    char *r = NULL;\n    krb5_data *data = NULL;\n    krb5_int32 count = 0;\n    krb5_int32 size = 2;  \n    char *component = NULL;\n    data = malloc(size * sizeof(krb5_data));\n    if (!data) { retval = ENOMEM; }\n    if (!retval) {\n        r = strdup(realm);\n        if (!r) { retval = ENOMEM; }\n    }\n    while (!retval && (component = va_arg(ap, char *))) {\n        if (count == size) {\n            krb5_data *new_data = NULL;\n            size *= 2;\n            new_data = realloc(data, size * sizeof(krb5_data));\n            if (new_data) {\n                data = new_data;\n            } else {\n                retval = ENOMEM;\n            }\n        }\n        if (!retval) {\n            data[count].length = strlen(component);\n            data[count].data = strdup(component);\n            if (!data[count].data) { retval = ENOMEM; }\n            count++;\n        }\n    }\n    if (!retval) {\n        princ->type = KRB5_NT_UNKNOWN;\n        princ->magic = KV5M_PRINCIPAL;\n        princ->realm = make_data(r, rlen);\n        princ->data = data;\n        princ->length = count;\n        r = NULL;    \n        data = NULL; \n    }\n    if (data) {\n        while (--count >= 0) {\n            free(data[count].data);\n        }\n        free(data);\n    }\n    free(r);\n    return retval;\n}", "target": 1}
{"code": "void headerMergeLegacySigs(Header h, Header sigh)\n{\n    HeaderIterator hi;\n    struct rpmtd_s td;\n    hi = headerInitIterator(sigh);\n    for (; headerNext(hi, &td); rpmtdFreeData(&td))\n    {\n\tswitch (td.tag) {\n\tcase RPMSIGTAG_SIZE:\n\t    td.tag = RPMTAG_SIGSIZE;\n\t    break;\n\tcase RPMSIGTAG_PGP:\n\t    td.tag = RPMTAG_SIGPGP;\n\t    break;\n\tcase RPMSIGTAG_MD5:\n\t    td.tag = RPMTAG_SIGMD5;\n\t    break;\n\tcase RPMSIGTAG_GPG:\n\t    td.tag = RPMTAG_SIGGPG;\n\t    break;\n\tcase RPMSIGTAG_PGP5:\n\t    td.tag = RPMTAG_SIGPGP5;\n\t    break;\n\tcase RPMSIGTAG_PAYLOADSIZE:\n\t    td.tag = RPMTAG_ARCHIVESIZE;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURES:\n\t    td.tag = RPMTAG_FILESIGNATURES;\n\t    break;\n\tcase RPMSIGTAG_FILESIGNATURELENGTH:\n\t    td.tag = RPMTAG_FILESIGNATURELENGTH;\n\t    break;\n\tcase RPMSIGTAG_VERITYSIGNATURES:\n\tcase RPMSIGTAG_VERITYSIGNATUREALGO:\n\tcase RPMSIGTAG_SHA1:\n\tcase RPMSIGTAG_SHA256:\n\tcase RPMSIGTAG_DSA:\n\tcase RPMSIGTAG_RSA:\n\tdefault:\n\t    if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE))\n\t\tcontinue;\n\t    break;\n\t}\n\tif (!headerIsEntry(h, td.tag)) {\n\t    switch (td.type) {\n\t    case RPM_NULL_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    case RPM_CHAR_TYPE:\n\t    case RPM_INT8_TYPE:\n\t    case RPM_INT16_TYPE:\n\t    case RPM_INT32_TYPE:\n\t    case RPM_INT64_TYPE:\n\t\tif (td.count != 1)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_STRING_TYPE:\n\t    case RPM_STRING_ARRAY_TYPE:\n\t    case RPM_BIN_TYPE:\n\t\tif (td.count >= 16*1024)\n\t\t    continue;\n\t\tbreak;\n\t    case RPM_I18NSTRING_TYPE:\n\t\tcontinue;\n\t\tbreak;\n\t    }\n\t    (void) headerPut(h, &td, HEADERPUT_DEFAULT);\n\t}\n    }\n    headerFreeIterator(hi);\n}", "target": 1}
{"code": "jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}", "target": 1}
{"code": "static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n \tunsigned int buffer_size;\n \tvoid *buffer;\n \tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n \tif (stream->ops->copy) {\n \t\tbuffer = NULL;\n\t} else {\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}", "target": 1}
{"code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  int pos = 0;\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n  for(int i = 0; i < commentFields; i++) {\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    int commentSeparatorPosition = comment.find(\"=\");\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n    addField(key, value, false);\n  }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n    Tensor key(*key_tensor);\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }", "target": 1}
{"code": "void zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withscores = 1;\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}", "target": 1}
{"code": "png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n   {\n      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n      size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit=PNG_UINT_31_MAX;\n      else\n         idat_limit = png_ptr->height * row_factor;\n      row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); \n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}", "target": 1}
{"code": "Literal *hermes::evalUnaryOperator(\n    UnaryOperatorInst::OpKind kind,\n    IRBuilder &builder,\n    Literal *operand) {\n  switch (kind) {\n    case UnaryOperatorInst::OpKind::MinusKind:\n      switch (operand->getKind()) {\n        case ValueKind::LiteralNumberKind:\n          if (auto *literalNum = llvh::dyn_cast<LiteralNumber>(operand)) {\n            auto V = -literalNum->getValue();\n            return builder.getLiteralNumber(V);\n          }\n          break;\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralNaN();\n        case ValueKind::LiteralBoolKind:\n          if (evalIsTrue(builder, operand)) {\n            return builder.getLiteralNumber(-1);\n          } else { \n            return builder.getLiteralNegativeZero();\n          }\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralNegativeZero();\n        default:\n          break;\n      }\n      break;\n    case UnaryOperatorInst::OpKind::TypeofKind:\n      switch (operand->getKind()) {\n        case ValueKind::GlobalObjectKind:\n        case ValueKind::LiteralNullKind:\n          return builder.getLiteralString(\"object\");\n        case ValueKind::LiteralUndefinedKind:\n          return builder.getLiteralString(\"undefined\");\n        case ValueKind::LiteralBoolKind:\n          return builder.getLiteralString(\"boolean\");\n        case ValueKind::LiteralNumberKind:\n          return builder.getLiteralString(\"number\");\n        case ValueKind::LiteralStringKind:\n          return builder.getLiteralString(\"string\");\n        default:\n          llvm_unreachable(\"Invalid literal kind.\");\n      }\n      break;\n    case UnaryOperatorInst::OpKind::BangKind:\n      if (evalIsTrue(builder, operand)) {\n        return builder.getLiteralBool(false);\n      }\n      if (evalIsFalse(builder, operand)) {\n        return builder.getLiteralBool(true);\n      }\n      break;\n    case UnaryOperatorInst::OpKind::VoidKind:\n      return builder.getLiteralUndefined();\n    default:\n      break;\n  }\n  return nullptr;\n}", "target": 1}
{"code": "StatusWith<Message> MessageCompressorManager::decompressMessage(const Message& msg,\n                                                                MessageCompressorId* compressorId) {\n    auto inputHeader = msg.header();\n    ConstDataRangeCursor input(inputHeader.data(), inputHeader.data() + inputHeader.dataLen());\n    if (input.length() < CompressionHeader::size()) {\n        return {ErrorCodes::BadValue, \"Invalid compressed message header\"};\n    }\n    CompressionHeader compressionHeader(&input);\n    auto compressor = _registry->getCompressor(compressionHeader.compressorId);\n    if (!compressor) {\n        return {ErrorCodes::InternalError,\n                \"Compression algorithm specified in message is not available\"};\n    }\n    if (compressorId) {\n        *compressorId = compressor->getId();\n    }\n    LOG(3) << \"Decompressing message with \" << compressor->getName();\n    size_t bufferSize = compressionHeader.uncompressedSize + MsgData::MsgDataHeaderSize;\n    if (bufferSize > MaxMessageSizeBytes) {\n        return {ErrorCodes::BadValue,\n                \"Decompressed message would be larger than maximum message size\"};\n    }\n    auto outputMessageBuffer = SharedBuffer::allocate(bufferSize);\n    MsgData::View outMessage(outputMessageBuffer.get());\n    outMessage.setId(inputHeader.getId());\n    outMessage.setResponseToMsgId(inputHeader.getResponseToMsgId());\n    outMessage.setOperation(compressionHeader.originalOpCode);\n    outMessage.setLen(bufferSize);\n    DataRangeCursor output(outMessage.data(), outMessage.data() + outMessage.dataLen());\n    auto sws = compressor->decompressData(input, output);\n    if (!sws.isOK())\n        return sws.getStatus();\n    if (sws.getValue() != static_cast<std::size_t>(compressionHeader.uncompressedSize)) {\n        return {ErrorCodes::BadValue, \"Decompressing message returned less data than expected\"};\n    }\n    outMessage.setLen(sws.getValue() + MsgData::MsgDataHeaderSize);\n    return {Message(outputMessageBuffer)};\n}", "target": 1}
{"code": "void hashtable_clear(hashtable_t *hashtable)\n{\n    size_t i;\n    hashtable_do_clear(hashtable);\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list_init(&hashtable->list);\n    hashtable->size = 0;\n}", "target": 1}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n    Tensor group_assignment = c->input(2);\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment,\n                             ALL_TO_ALL_COLLECTIVE, resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    VLOG(1) << \"CollectiveAllToAll group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "gss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n    return (GSS_S_COMPLETE);\n}", "target": 1}
{"code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}", "target": 1}
{"code": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\nretry:\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\tfutex_wait_queue_me(hb, &q, to);\n\tret = 0;\n\tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out_put_key;\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n\t\tgoto retry;\n\t}\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out_put_key;\n\trestart = &current_thread_info()->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n\tret = -ERESTART_RESTARTBLOCK;\nout_put_key:\n\tput_futex_key(fshared, &q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": " static BT_HDR *create_pbuf(UINT16 len, UINT8 *data)\n {\n    BT_HDR* p_buf = GKI_getbuf((UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR)));\n     if (p_buf) {\n         UINT8* pbuf_data;\n        p_buf->len = len;\n        p_buf->offset = BTA_HH_MIN_OFFSET;\n        pbuf_data = (UINT8*) (p_buf + 1) + p_buf->offset;\n        memcpy(pbuf_data, data, len);\n }\n return p_buf;\n}", "target": 1}
{"code": "checked_xcalloc (size_t num, size_t size)\n{\n    alloc_limit_assert (\"checked_xcalloc\", (num *size));\n    return xcalloc (num, size);\n}", "target": 1}
{"code": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\tassert(n >= 0 && n < 32);\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}", "target": 1}
{"code": "MagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  char\n    key[MaxTextExtent],\n    property[MaxTextExtent];\n  MagickBooleanType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MaxTextExtent);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),CloneStringInfo(profile));\n  if ((status != MagickFalse) &&\n      ((LocaleCompare(name,\"iptc\") == 0) || (LocaleCompare(name,\"8bim\") == 0)))\n    (void) GetProfilesFromResourceBlock(image,profile,exception);\n  (void) FormatLocaleString(property,MaxTextExtent,\"%s:sans\",name);\n  (void) GetImageProperty(image,property,exception);\n  return(status);\n}", "target": 1}
{"code": "int hidp_connection_add(struct hidp_connadd_req *req,\n\t\t\tstruct socket *ctrl_sock,\n\t\t\tstruct socket *intr_sock)\n{\n\tstruct hidp_session *session;\n\tstruct l2cap_conn *conn;\n\tstruct l2cap_chan *chan = l2cap_pi(ctrl_sock->sk)->chan;\n\tint ret;\n\tret = hidp_verify_sockets(ctrl_sock, intr_sock);\n\tif (ret)\n\t\treturn ret;\n\tconn = NULL;\n\tl2cap_chan_lock(chan);\n\tif (chan->conn)\n\t\tconn = l2cap_conn_get(chan->conn);\n\tl2cap_chan_unlock(chan);\n\tif (!conn)\n\t\treturn -EBADFD;\n\tret = hidp_session_new(&session, &chan->dst, ctrl_sock,\n\t\t\t       intr_sock, req, conn);\n\tif (ret)\n\t\tgoto out_conn;\n\tret = l2cap_register_user(conn, &session->user);\n\tif (ret)\n\t\tgoto out_session;\n\tret = 0;\nout_session:\n\thidp_session_put(session);\nout_conn:\n\tl2cap_conn_put(conn);\n\treturn ret;\n}", "target": 1}
{"code": "static GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->n);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->qp);\n\tcrypto_bignum_free(key->dp);\n\tcrypto_bignum_free(key->dq);\n}", "target": 1}
{"code": "void pid_ns_release_proc(struct pid_namespace *ns)\n{\n\tmntput(ns->proc_mnt);\n}", "target": 1}
{"code": "static int append_ia5(STACK_OF(OPENSSL_STRING) **sk, const ASN1_IA5STRING *email)\n{\n    char *emtmp;\n    if (email->type != V_ASN1_IA5STRING)\n        return 1;\n    if (!email->data || !email->length)\n        return 1;\n    if (*sk == NULL)\n        *sk = sk_OPENSSL_STRING_new(sk_strcmp);\n    if (*sk == NULL)\n        return 0;\n    if (sk_OPENSSL_STRING_find(*sk, (char *)email->data) != -1)\n        return 1;\n    emtmp = OPENSSL_strdup((char *)email->data);\n    if (emtmp == NULL || !sk_OPENSSL_STRING_push(*sk, emtmp)) {\n        OPENSSL_free(emtmp);    \n        X509_email_free(*sk);\n        *sk = NULL;\n        return 0;\n    }\n    return 1;\n}", "target": 1}
{"code": "void smp_proc_enc_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n   uint8_t* p = p_data->p_data;\n   SMP_TRACE_DEBUG(\"%s\", __func__);\n   STREAM_TO_ARRAY(p_cb->ltk, p, BT_OCTET16_LEN);\n   smp_key_distribution(p_cb, NULL);\n}", "target": 1}
{"code": "cmnd_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    struct alias *a;\n    struct sudo_command *c;\n    int rc, matched = UNSPEC;\n    debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\tcase COMMAND:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "request_rec *h2_request_create_rec(const h2_request *req, conn_rec *c)\n{\n    int access_status = HTTP_OK;    \n    const char *rpath;\n    const char *s;\n#if AP_MODULE_MAGIC_AT_LEAST(20150222, 13)\n    request_rec *r = ap_create_request(c);\n#else\n    request_rec *r = my_ap_create_request(c);\n#endif\n    r->headers_in = apr_table_clone(r->pool, req->headers);\n    ap_run_pre_read_request(r, c);\n    r->request_time = req->request_time;\n    r->method = req->method;\n    r->method_number = ap_method_number_of(r->method);\n    if (r->method_number == M_GET && r->method[0] == 'H') {\n        r->header_only = 1;\n    }\n    rpath = (req->path ? req->path : \"\");\n    ap_parse_uri(r, rpath);\n    r->protocol = (char*)\"HTTP/2.0\";\n    r->proto_num = HTTP_VERSION(2, 0);\n    r->the_request = apr_psprintf(r->pool, \"%s %s %s\", \n                                  r->method, rpath, r->protocol);\n    r->hostname = NULL;\n    ap_update_vhost_from_headers(r);\n    r->per_dir_config = r->server->lookup_defaults;\n    s = apr_table_get(r->headers_in, \"Expect\");\n    if (s && s[0]) {\n        if (ap_cstr_casecmp(s, \"100-continue\") == 0) {\n            r->expecting_100 = 1;\n        }\n        else {\n            r->status = HTTP_EXPECTATION_FAILED;\n            ap_send_error_response(r, 0);\n        }\n    }\n    ap_add_input_filter_handle(ap_http_input_filter_handle,\n                               NULL, r, r->connection);\n    if (access_status != HTTP_OK\n        || (access_status = ap_run_post_read_request(r))) {\n        ap_log_cerror(APLOG_MARK, APLOG_DEBUG, 0, c, APLOGNO(03367)\n                      \"h2_request: access_status=%d, request_create failed\",\n                      access_status);\n        ap_die(access_status, r);\n        ap_update_child_status(c->sbh, SERVER_BUSY_LOG, r);\n        ap_run_log_transaction(r);\n        r = NULL;\n        goto traceout;\n    }\n    AP_READ_REQUEST_SUCCESS((uintptr_t)r, (char *)r->method, \n                            (char *)r->uri, (char *)r->server->defn_name, \n                            r->status);\n    return r;\ntraceout:\n    AP_READ_REQUEST_FAILURE((uintptr_t)r);\n    return r;\n}", "target": 1}
{"code": "R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fread (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}", "target": 1}
{"code": "static gint conv_jistoeuc(gchar *outbuf, gint outlen, const gchar *inbuf)\n{\n\tconst guchar *in = inbuf;\n\tgchar *out = outbuf;\n\tJISState state = JIS_ASCII;\n\twhile (*in != '\\0' && (out - outbuf) > outlen - 3) {\n\t\tif (*in == ESC) {\n\t\t\tin++;\n\t\t\tif (*in == '$') {\n\t\t\t\tif (*(in + 1) == '@' || *(in + 1) == 'B') {\n\t\t\t\t\tstate = JIS_KANJI;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else if (*(in + 1) == '(' &&\n\t\t\t\t\t   *(in + 2) == 'D') {\n\t\t\t\t\tstate = JIS_AUXKANJI;\n\t\t\t\t\tin += 3;\n\t\t\t\t} else {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t}\n\t\t\t} else if (*in == '(') {\n\t\t\t\tif (*(in + 1) == 'B' || *(in + 1) == 'J') {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else if (*(in + 1) == 'I') {\n\t\t\t\t\tstate = JIS_HWKANA;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstate = JIS_ASCII;\n\t\t\t}\n\t\t} else if (*in == 0x0e) {\n\t\t\tstate = JIS_HWKANA;\n\t\t\tin++;\n\t\t} else if (*in == 0x0f) {\n\t\t\tstate = JIS_ASCII;\n\t\t\tin++;\n\t\t} else {\n\t\t\tswitch (state) {\n\t\t\tcase JIS_ASCII:\n\t\t\t\t*out++ = *in++;\n\t\t\t\tbreak;\n\t\t\tcase JIS_KANJI:\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tif (*in == '\\0') break;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\tcase JIS_HWKANA:\n\t\t\t\t*out++ = 0x8e;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\tcase JIS_AUXKANJI:\n\t\t\t\t*out++ = 0x8f;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tif (*in == '\\0') break;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t*out = '\\0';\n\treturn 0;\n}", "target": 1}
{"code": "njs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_object_t              *object;\n    njs_promise_capability_t  *capability;\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n    if (njs_is_object(x)) {\n        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n                                         njs_object_t);\n        if (object != NULL) {\n            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                     &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NULL;\n            }\n            if (njs_values_same(&value, constructor)) {\n                return njs_promise(x);\n            }\n        }\n    }\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n    return njs_promise(&capability->promise);\n}", "target": 1}
{"code": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n    avio_rl64(pb);            \n    avio_rl64(pb);            \n    count = avio_rl32(pb);    \n    avio_rl16(pb);            \n    name_len = avio_rl16(pb); \n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); \n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n        avio_rl64(pb);             \n        pres_time = avio_rl64(pb); \n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             \n        avio_rl32(pb);             \n        avio_rl32(pb);             \n        name_len = avio_rl32(pb);  \n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n    return 0;\n}", "target": 1}
{"code": "static void jsiDumpInstr(Jsi_Interp *interp, jsi_Pstate *ps, Jsi_Value *_this,\n    jsi_TryList *trylist, jsi_OpCode *ip, Jsi_OpCodes *opcodes)\n{\n    int i;\n    char buf[200];\n    jsi_code_decode(interp, ip, ip - opcodes->codes, buf, sizeof(buf));\n    Jsi_Printf(interp, jsi_Stderr, \"%p: %-30.200s : THIS=%s, STACK=[\", ip, buf, jsi_evalprint(_this));\n    for (i = 0; i < interp->framePtr->Sp; ++i) {\n        Jsi_Printf(interp, jsi_Stderr, \"%s%s\", (i>0?\", \":\"\"), jsi_evalprint(_jsi_STACKIDX(i)));\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"]\");\n    if (ip->fname) {\n        const char *fn = ip->fname,  *cp = Jsi_Strrchr(fn, '/');\n        if (cp) fn = cp+1;\n        Jsi_Printf(interp, jsi_Stderr, \", %s:%d\", fn, ip->Line);\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"\\n\");\n    jsi_TryList *tlt = trylist;\n    for (i = 0; tlt; tlt = tlt->next) i++;\n    if (ps->last_exception)\n        Jsi_Printf(interp, jsi_Stderr, \"TL: %d, excpt: %s\\n\", i, jsi_evalprint(ps->last_exception));\n}", "target": 1}
{"code": " xsltGenerateIdFunction(xmlXPathParserContextPtr ctxt, int nargs){\n     xmlNodePtr cur = NULL;\n     long val;\n     xmlChar str[30];\n     xmlDocPtr doc;\n     if (nargs == 0) {\n \tcur = ctxt->context->node;\n     } else if (nargs == 1) {\n\txmlXPathObjectPtr obj;\n \txmlNodeSetPtr nodelist;\n \tint i, ret;\n\tif ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n\t    ctxt->error = XPATH_INVALID_TYPE;\n\t    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"generate-id() : invalid arg expecting a node-set\\n\");\n\t    return;\n\t}\n\tobj = valuePop(ctxt);\n\tnodelist = obj->nodesetval;\n\tif ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n\t    xmlXPathFreeObject(obj);\n\t    valuePush(ctxt, xmlXPathNewCString(\"\"));\n\t    return;\n\t}\n\tcur = nodelist->nodeTab[0];\n\tfor (i = 1;i < nodelist->nodeNr;i++) {\n\t    ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n \t    if (ret == -1)\n \t        cur = nodelist->nodeTab[i];\n \t}\n\txmlXPathFreeObject(obj);\n     } else {\n \txsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n \t\t\"generate-id() : invalid number of args %d\\n\", nargs);\n\tctxt->error = XPATH_INVALID_ARITY;\n\treturn;\n    }\n    if (cur->type != XML_NAMESPACE_DECL)\n        doc = cur->doc;\n    else {\n        xmlNsPtr ns = (xmlNsPtr) cur;\n        if (ns->context != NULL)\n            doc = ns->context;\n        else\n            doc = ctxt->context->doc;\n     }\n     val = (long)((char *)cur - (char *)doc);\n     if (val >= 0) {\n       sprintf((char *)str, \"idp%ld\", val);\n    } else {\n      sprintf((char *)str, \"idm%ld\", -val);\n    }\n    valuePush(ctxt, xmlXPathNewString(str));\n}", "target": 1}
{"code": "snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number)\n{\n  uint32_t original_out_len;\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER);\n  return out;\n}", "target": 1}
{"code": "static int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == '%')\n                ptr++;\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n            else {\n                if (*ptr == ' ')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 3);\n}", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n     if (!c->synth_tile || !c->jpeg_tile ||\n         c->old_tile_w < c->tile_width ||\n         c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n         aligned_height = FFALIGN(c->tile_height,    16);\n         av_free(c->synth_tile);\n         av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "static TEE_Result do_alloc_keypair(struct ecc_keypair *s, uint32_t type,\n\t\t\t\t   size_t size_bits __unused)\n{\n\tif (type != TEE_TYPE_ECDSA_KEYPAIR &&\n\t    type != TEE_TYPE_ECDH_KEYPAIR)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n \tup = nla_data(rp);\n \tulen = xfrm_replay_state_esn_len(up);\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n \t\treturn -EINVAL;\n \tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "AppProto AppLayerProtoDetectGetProto(AppLayerProtoDetectThreadCtx *tctx,\n                                     Flow *f,\n                                     uint8_t *buf, uint32_t buflen,\n                                     uint8_t ipproto, uint8_t direction)\n{\n    SCEnter();\n    SCLogDebug(\"buflen %u for %s direction\", buflen,\n             (direction & STREAM_TOSERVER) ? \"toserver\" : \"toclient\");\n     AppProto alproto = ALPROTO_UNKNOWN;\n     if (!FLOW_IS_PM_DONE(f, direction)) {\n         AppProto pm_results[ALPROTO_MAX];\n        uint16_t pm_matches = AppLayerProtoDetectPMGetProto(tctx, f,\n                                                   buf, buflen,\n                                                   direction,\n                                                   ipproto,\n                                                    pm_results);\n         if (pm_matches > 0) {\n             alproto = pm_results[0];\n            goto end;\n         }\n     }\n    if (!FLOW_IS_PP_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPPGetProto(f, buf, buflen,\n                                                ipproto, direction);\n        if (alproto != ALPROTO_UNKNOWN)\n            goto end;\n    }\n    if (!FLOW_IS_PE_DONE(f, direction)) {\n        alproto = AppLayerProtoDetectPEGetProto(f, ipproto, direction);\n     }\n  end:\n     SCReturnUInt(alproto);\n }", "target": 1}
{"code": "void log_flush(LOG_MODE new_mode) {\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_MODE]);\n    if(log_mode!=LOG_MODE_CONFIGURED || new_mode!=LOG_MODE_ERROR)\n        log_mode=new_mode;\n    if(new_mode!=LOG_MODE_BUFFER) {\n        CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_BUFFER]);\n        while(head) {\n            struct LIST *tmp=head;\n            head=head->next;\n            log_raw(tmp->opt, tmp->level, tmp->stamp, tmp->id, tmp->text);\n            str_free(tmp);\n        }\n        head=tail=NULL;\n        CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_BUFFER]);\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_MODE]);\n}", "target": 1}
{"code": "static int ip_identify_match_check(void *obj, void *arg, int flags)\n{\n\tstruct ip_identify_match *identify = obj;\n\tstruct ast_sockaddr_with_tp *addr_with_tp = arg;\n\tstruct ast_sockaddr address = addr_with_tp->addr;\n\tint sense;\n\tsense = ast_apply_ha(identify->matches, &address);\n\tif (sense != AST_SENSE_ALLOW) {\n\t\tast_debug(3, \"Address %s matches identify '%s'\\n\",\n\t\t\t\tast_sockaddr_stringify(&address),\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\tif (ast_strlen_zero(identify->transport) || !strcasecmp(identify->transport, addr_with_tp->tp)) {\n\t\t\tast_debug(3, \"Transport %s matches identify '%s'\\n\",\n\t\t\t\taddr_with_tp->tp,\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\t\treturn CMP_MATCH;\n\t\t} else {\n\t\t\tast_debug(3, \"Transport %s match not matched identify '%s'\\n\",\n\t\t\t\taddr_with_tp->tp,\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tast_debug(3, \"Address %s does not match identify '%s'\\n\",\n\t\t\t\tast_sockaddr_stringify(&address),\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\treturn 0;\n\t}\n}", "target": 1}
{"code": "gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n    }\n    if (src != tmp_im) {\n        gdFree(tmp_im);\n    }\n\treturn dst;\n}", "target": 1}
{"code": "rsock_init_unixsock(VALUE sock, VALUE path, int server)\n{\n    struct sockaddr_un sockaddr;\n    socklen_t sockaddrlen;\n    int fd, status;\n    rb_io_t *fptr;\n    FilePathValue(path);\n    INIT_SOCKADDR_UN(&sockaddr, sizeof(struct sockaddr_un));\n    if (sizeof(sockaddr.sun_path) < (size_t)RSTRING_LEN(path)) {\n        rb_raise(rb_eArgError, \"too long unix socket path (%ldbytes given but %dbytes max)\",\n            RSTRING_LEN(path), (int)sizeof(sockaddr.sun_path));\n    }\n    memcpy(sockaddr.sun_path, RSTRING_PTR(path), RSTRING_LEN(path));\n    sockaddrlen = rsock_unix_sockaddr_len(path);\n    fd = rsock_socket(AF_UNIX, SOCK_STREAM, 0);\n    if (fd < 0) {\n\trsock_sys_fail_path(\"socket(2)\", path);\n    }\n    if (server) {\n        status = bind(fd, (struct sockaddr*)&sockaddr, sockaddrlen);\n    }\n    else {\n\tint prot;\n\tstruct unixsock_arg arg;\n\targ.sockaddr = &sockaddr;\n\targ.sockaddrlen = sockaddrlen;\n\targ.fd = fd;\n        status = (int)rb_protect(unixsock_connect_internal, (VALUE)&arg, &prot);\n\tif (prot) {\n\t    close(fd);\n\t    rb_jump_tag(prot);\n\t}\n    }\n    if (status < 0) {\n\tint e = errno;\n\tclose(fd);\n\trsock_syserr_fail_path(e, \"connect(2)\", path);\n    }\n    if (server) {\n\tif (listen(fd, SOMAXCONN) < 0) {\n\t    int e = errno;\n\t    close(fd);\n\t    rsock_syserr_fail_path(e, \"listen(2)\", path);\n\t}\n    }\n    rsock_init_sock(sock, fd);\n    if (server) {\n\tGetOpenFile(sock, fptr);\n        fptr->pathv = rb_str_new_frozen(path);\n    }\n    return sock;\n}", "target": 1}
{"code": " static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n {\n \tif (file->f_flags & O_DSYNC)\n \t\treturn 0;\n \tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n \t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n \t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n \t\treturn 1;\n \treturn 0;\n }", "target": 1}
{"code": "static void rtreenode(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){\n  char *zText = 0;\n  RtreeNode node;\n  Rtree tree;\n  int ii;\n  UNUSED_PARAMETER(nArg);\n  memset(&node, 0, sizeof(RtreeNode));\n  memset(&tree, 0, sizeof(Rtree));\n  tree.nDim = (u8)sqlite3_value_int(apArg[0]);\n  tree.nDim2 = tree.nDim*2;\n  tree.nBytesPerCell = 8 + 8 * tree.nDim;\n  node.zData = (u8 *)sqlite3_value_blob(apArg[1]);\n  for(ii=0; ii<NCELL(&node); ii++){\n    char zCell[512];\n    int nCell = 0;\n    RtreeCell cell;\n    int jj;\n    nodeGetCell(&tree, &node, ii, &cell);\n    sqlite3_snprintf(512-nCell,&zCell[nCell],\"%lld\", cell.iRowid);\n    nCell = (int)strlen(zCell);\n    for(jj=0; jj<tree.nDim2; jj++){\n#ifndef SQLITE_RTREE_INT_ONLY\n      sqlite3_snprintf(512-nCell,&zCell[nCell], \" %g\",\n                       (double)cell.aCoord[jj].f);\n#else\n      sqlite3_snprintf(512-nCell,&zCell[nCell], \" %d\",\n                       cell.aCoord[jj].i);\n#endif\n      nCell = (int)strlen(zCell);\n    }\n    if( zText ){\n      char *zTextNew = sqlite3_mprintf(\"%s {%s}\", zText, zCell);\n      sqlite3_free(zText);\n      zText = zTextNew;\n    }else{\n      zText = sqlite3_mprintf(\"{%s}\", zCell);\n    }\n  }\n  sqlite3_result_text(ctx, zText, -1, sqlite3_free);\n}", "target": 1}
{"code": "static int rsi_init_usb_interface(struct rsi_hw *adapter,\n\t\t\t\t  struct usb_interface *pfunction)\n{\n\tstruct rsi_91x_usbdev *rsi_dev;\n\tint status;\n\trsi_dev = kzalloc(sizeof(*rsi_dev), GFP_KERNEL);\n\tif (!rsi_dev)\n\t\treturn -ENOMEM;\n\tadapter->rsi_dev = rsi_dev;\n\trsi_dev->usbdev = interface_to_usbdev(pfunction);\n\trsi_dev->priv = (void *)adapter;\n\tif (rsi_find_bulk_in_and_out_endpoints(pfunction, adapter)) {\n\t\tstatus = -EINVAL;\n\t\tgoto fail_eps;\n\t}\n\tadapter->device = &pfunction->dev;\n\tusb_set_intfdata(pfunction, adapter);\n\trsi_dev->tx_buffer = kmalloc(2048, GFP_KERNEL);\n\tif (!rsi_dev->tx_buffer) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_eps;\n\t}\n\tif (rsi_usb_init_rx(adapter)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to init RX handle\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_rx;\n\t}\n\trsi_dev->tx_blk_size = 252;\n\tadapter->block_size = rsi_dev->tx_blk_size;\n\tadapter->check_hw_queue_status = rsi_usb_check_queue_status;\n\tadapter->determine_event_timeout = rsi_usb_event_timeout;\n\tadapter->rsi_host_intf = RSI_HOST_INTF_USB;\n\tadapter->host_intf_ops = &usb_host_intf_ops;\n#ifdef CONFIG_RSI_DEBUGFS\n\tadapter->num_debugfs_entries = (MAX_DEBUGFS_ENTRIES - 1);\n#endif\n\trsi_dbg(INIT_ZONE, \"%s: Enabled the interface\\n\", __func__);\n\treturn 0;\nfail_rx:\n\tkfree(rsi_dev->tx_buffer);\nfail_eps:\n\tkfree(rsi_dev);\n\treturn status;\n}", "target": 1}
{"code": "void giveup_all(struct task_struct *tsk)\n{\n\tunsigned long usermsr;\n\tif (!tsk->thread.regs)\n\t\treturn;\n\tusermsr = tsk->thread.regs->msr;\n\tif ((usermsr & msr_all_available) == 0)\n\t\treturn;\n\tmsr_check_and_set(msr_all_available);\n\tcheck_if_tm_restore_required(tsk);\n\tWARN_ON((usermsr & MSR_VSX) && !((usermsr & MSR_FP) && (usermsr & MSR_VEC)));\n#ifdef CONFIG_PPC_FPU\n\tif (usermsr & MSR_FP)\n\t\t__giveup_fpu(tsk);\n#endif\n#ifdef CONFIG_ALTIVEC\n\tif (usermsr & MSR_VEC)\n\t\t__giveup_altivec(tsk);\n#endif\n#ifdef CONFIG_SPE\n\tif (usermsr & MSR_SPE)\n\t\t__giveup_spe(tsk);\n#endif\n\tmsr_check_and_clear(msr_all_available);\n}", "target": 1}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    emalloc(len) :\n\t\t    erealloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\tport = (char *)json_string_value(json_array_get(val, 1));\n \tif (!port)\n \t\tport = pool->stratum_port;\n\tsprintf(address, \"%s:%s\", url, port);\n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\tclear_pool_work(pool);\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "  QInt16() {}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tchar *name = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\tRBinJavaAttrMetas *type_info = NULL;\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\tname = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\ttype_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((attr = type_info->allocs->new_obj (buffer, nsz, buf_offset))) {\n\t\t\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\t\t}\n\t} else {\n\t\teprintf (\"r_bin_java_read_next_attr_from_buffer: Cannot find type_info for %s\\n\", name);\n\t}\n\tfree (name);\n\treturn attr;\n}", "target": 1}
{"code": "static int ext4_convert_unwritten_extents_endio(handle_t *handle,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      struct ext4_ext_path *path)\n{\n\tstruct ext4_extent *ex;\n\tint depth;\n\tint err = 0;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\text_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)le32_to_cpu(ex->ee_block),\n\t\text4_ext_get_actual_len(ex));\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\text4_ext_mark_initialized(ex);\n\text4_ext_try_to_merge(handle, inode, path, ex);\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}", "target": 1}
{"code": "file_continue(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    es_ptr pscratch = esp - 2;\n    file_enum *pfen = r_ptr(esp - 1, file_enum);\n    int devlen = esp[-3].value.intval;\n    gx_io_device *iodev = r_ptr(esp - 4, gx_io_device);\n    uint len = r_size(pscratch);\n    uint code;\n    if (len < devlen)\n        return_error(gs_error_rangecheck);     \n    memcpy((char *)pscratch->value.bytes, iodev->dname, devlen);\n    code = iodev->procs.enumerate_next(pfen, (char *)pscratch->value.bytes + devlen,\n                len - devlen);\n    if (code == ~(uint) 0) {    \n        esp -= 5;               \n        return o_pop_estack;\n    } else if (code > len)      \n        return_error(gs_error_rangecheck);\n    else {\n        push(1);\n        ref_assign(op, pscratch);\n        r_set_size(op, code + devlen);\n        push_op_estack(file_continue);  \n        *++esp = pscratch[2];   \n        return o_push_estack;\n    }\n}", "target": 1}
{"code": "poly_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPOLYGON    *poly;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * npts;\n\tpoly = (POLYGON *) palloc0(size);\t\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = npts;\n\tif ((!path_decode(FALSE, npts, str, &isopen, &s, &(poly->p[0])))\n\t\t|| (*s != '\\0'))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t  errmsg(\"invalid input syntax for type polygon: \\\"%s\\\"\", str)));\n\tmake_bound_box(poly);\n\tPG_RETURN_POLYGON_P(poly);\n}", "target": 1}
{"code": "mmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response)\n{\n    if (*bufPos == maxBufPos)\n        return false;\n    uint8_t tag = buffer[(*bufPos)++];\n    if (tag != 0x19) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n    int length;\n    *bufPos = BerDecoder_decodeLength(buffer, &length, *bufPos, maxBufPos);\n    if (*bufPos < 0)  {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n    if (length > 255) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n      return false;\n    }\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "static bool do_write_pids(pid_t tpid, const char *contrl, const char *cg, const char *file, const char *buf)\n{\n\tint sock[2] = {-1, -1};\n\tpid_t qpid, cpid = -1;\n\tFILE *pids_file = NULL;\n\tbool answer = false, fail = false;\n\tpids_file = open_pids_file(contrl, cg);\n\tif (!pids_file)\n\t\treturn false;\n\tif (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) < 0) {\n\t\tperror(\"socketpair\");\n\t\tgoto out;\n\t}\n\tcpid = fork();\n\tif (cpid == -1)\n\t\tgoto out;\n\tif (!cpid) { \n\t\tfclose(pids_file);\n\t\tpid_from_ns_wrapper(sock[1], tpid);\n\t}\n\tconst char *ptr = buf;\n\twhile (sscanf(ptr, \"%d\", &qpid) == 1) {\n\t\tstruct ucred cred;\n\t\tchar v;\n\t\tif (write(sock[0], &qpid, sizeof(qpid)) != sizeof(qpid)) {\n\t\t\tfprintf(stderr, \"%s: error writing pid to child: %s\\n\",\n\t\t\t\t__func__, strerror(errno));\n\t\t\tgoto out;\n\t\t}\n\t\tif (recv_creds(sock[0], &cred, &v)) {\n\t\t\tif (v == '0') {\n\t\t\t\tif (fprintf(pids_file, \"%d\", (int) cred.pid) < 0)\n\t\t\t\t\tfail = true;\n\t\t\t}\n\t\t}\n\t\tptr = strchr(ptr, '\\n');\n\t\tif (!ptr)\n\t\t\tbreak;\n\t\tptr++;\n\t}\n\tqpid = -1;\n\tif (write(sock[0], &qpid ,sizeof(qpid)) != sizeof(qpid))\n\t\tfprintf(stderr, \"Warning: failed to ask child to exit\\n\");\n\tif (!fail)\n\t\tanswer = true;\nout:\n\tif (cpid != -1)\n\t\twait_for_pid(cpid);\n\tif (sock[0] != -1) {\n\t\tclose(sock[0]);\n\t\tclose(sock[1]);\n\t}\n\tif (pids_file) {\n\t\tif (fclose(pids_file) != 0)\n\t\t\tanswer = false;\n\t}\n\treturn answer;\n}", "target": 1}
{"code": "int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint id;\n\tint next_id = ids->next_id;\n\tif (size > IPCMNI)\n\t\tsize = IPCMNI;\n\tif (ids->in_use >= size)\n\t\treturn -ENOSPC;\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_init(&new->lock);\n\tnew->deleted = false;\n\trcu_read_lock();\n\tspin_lock(&new->lock);\n\tid = idr_alloc(&ids->ipcs_idr, new,\n\t\t       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,\n\t\t       GFP_NOWAIT);\n\tidr_preload_end();\n\tif (id < 0) {\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn id;\n\t}\n\tids->in_use++;\n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n\tif (next_id < 0) {\n\t\tnew->seq = ids->seq++;\n\t\tif (ids->seq > IPCID_SEQ_MAX)\n\t\t\tids->seq = 0;\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tids->next_id = -1;\n\t}\n\tnew->id = ipc_buildid(id, new->seq);\n\treturn id;\n}", "target": 1}
{"code": "size_t olm_pk_decrypt(\n    OlmPkDecryption * decryption,\n    void const * ephemeral_key, size_t ephemeral_key_length,\n    void const * mac, size_t mac_length,\n    void * ciphertext, size_t ciphertext_length,\n    void * plaintext, size_t max_plaintext_length\n) {\n    if (max_plaintext_length\n            < olm_pk_max_plaintext_length(decryption, ciphertext_length)) {\n        decryption->last_error =\n            OlmErrorCode::OLM_OUTPUT_BUFFER_TOO_SMALL;\n        return std::size_t(-1);\n    }\n    struct _olm_curve25519_public_key ephemeral;\n    olm::decode_base64(\n        (const uint8_t*)ephemeral_key, ephemeral_key_length,\n        (uint8_t *)ephemeral.public_key\n    );\n    olm::SharedKey secret;\n    _olm_crypto_curve25519_shared_secret(&decryption->key_pair, &ephemeral, secret);\n    uint8_t raw_mac[MAC_LENGTH];\n    olm::decode_base64((const uint8_t*)mac, olm::encode_base64_length(MAC_LENGTH), raw_mac);\n    size_t raw_ciphertext_length = olm::decode_base64_length(ciphertext_length);\n    olm::decode_base64((const uint8_t *)ciphertext, ciphertext_length, (uint8_t *)ciphertext);\n    size_t result = _olm_cipher_aes_sha_256_ops.decrypt(\n        olm_pk_cipher,\n        secret, sizeof(secret),\n        (uint8_t *) raw_mac, MAC_LENGTH,\n        (const uint8_t *) ciphertext, raw_ciphertext_length,\n        (uint8_t *) plaintext, max_plaintext_length\n    );\n    if (result == std::size_t(-1)) {\n        decryption->last_error =\n            OlmErrorCode::OLM_BAD_MESSAGE_MAC;\n        return std::size_t(-1);\n    } else {\n        return result;\n    }\n}", "target": 1}
{"code": "  Statement_Ptr Expand::operator()(Declaration_Ptr d)\n  {\n    Block_Obj ab = d->block();\n    String_Obj old_p = d->property();\n    Expression_Obj prop = old_p->perform(&eval);\n    String_Obj new_p = Cast<String>(prop);\n    if (!new_p) {\n      std::string str(prop->to_string(ctx.c_options));\n      new_p = SASS_MEMORY_NEW(String_Constant, old_p->pstate(), str);\n    }\n    Expression_Obj value = d->value()->perform(&eval);\n    Block_Obj bb = ab ? operator()(ab) : NULL;\n    if (!bb) {\n      if (!value || (value->is_invisible() && !d->is_important())) return 0;\n    }\n    Declaration_Ptr decl = SASS_MEMORY_NEW(Declaration,\n                                        d->pstate(),\n                                        new_p,\n                                        value,\n                                        d->is_important(),\n                                        d->is_custom_property(),\n                                        bb);\n    decl->tabs(d->tabs());\n    return decl;\n  }", "target": 1}
{"code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n {\n   size_t i;\n   size_t e;\n   if (c->stack == NULL) return;\n   e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n     mrb_value v = c->stbase[i];\n     if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n     }\n   }\n }", "target": 1}
{"code": "static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\tif (unlikely(!host && hv_vcpu->enforce_cpuid && new_config.direct_mode &&\n\t\t     !(hv_vcpu->cpuid_cache.features_edx &\n\t\t       HV_STIMER_DIRECT_MODE_AVAILABLE)))\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_config(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"Missing context\");\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }", "target": 1}
{"code": "fr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\treturn capabilities;\n}", "target": 1}
{"code": " cdf_count_chain(const cdf_sat_t *sat, cdf_secid_t sid, size_t size)\n {\n \tsize_t i, j;\n\tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * size);\n \tDPRINTF((\"Chain:\"));\n \tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tDPRINTF((\" %d\", sid));\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Counting chain loop limit\"));\n \t\t\terrno = EFTYPE;\n \t\t\treturn (size_t)-1;\n \t\t}\n\t\tif (sid > maxsector) {\n\t\t\tDPRINTF((\"Sector %d > %d\\n\", sid, maxsector));\n \t\t\terrno = EFTYPE;\n \t\t\treturn (size_t)-1;\n \t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tif (i == 0) {\n\t\tDPRINTF((\" none, sid: %d\\n\", sid));\n\t\treturn (size_t)-1;\n\t}\n\tDPRINTF((\"\\n\"));\n\treturn i;\n}", "target": 1}
{"code": "void PDPClient::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n#if HAVE_SECURITY\n    if (mp_RTPSParticipant->is_secure())\n    {\n        eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());\n        for (auto& svr : mp_builtin->m_DiscoveryServers)\n        {\n            if (data_matches_with_prefix(svr.guidPrefix, pdata))\n            {\n                if (nullptr == svr.proxy)\n                {\n                    svr.proxy = get_participant_proxy_data(svr.guidPrefix);\n                }\n                match_pdp_reader_nts_(svr, pdata.m_guid.guidPrefix);\n                match_pdp_writer_nts_(svr, pdata.m_guid.guidPrefix);\n                break;\n            }\n        }\n    }\n#endif \n    perform_builtin_endpoints_matching(pdata);\n}", "target": 1}
{"code": "int tls_free_buffers(OSSL_RECORD_LAYER *rl)\n{\n    if (rl->direction == OSSL_RECORD_DIRECTION_WRITE) {\n        if (rl->nextwbuf < rl->numwpipes) {\n            if (rl->nextwbuf != 0\n                    || rl->numwpipes != 1\n                    || TLS_BUFFER_get_left(&rl->wbuf[0]) != 0)\n                return 0;\n        }\n        tls_release_write_buffer(rl);\n        return 1;\n    }\n    if (rl->curr_rec < rl->num_recs || TLS_BUFFER_get_left(&rl->rbuf) != 0)\n        return 0;\n    return tls_release_read_buffer(rl);\n}", "target": 1}
{"code": "queryin(char *buf)\n{\n\tQPRS_STATE\tstate;\n\tint32\t\ti;\n\tltxtquery  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n#ifdef BS_DEBUG\n\tchar\t\tpbuf[16384],\n\t\t\t   *cur;\n#endif\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"syntax error\"),\n\t\t\t\t errdetail(\"Empty query.\")));\n\tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n\tquery = (ltxtquery *) palloc(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = state.num;\n\tptr = GETQUERY(query);\n\tfor (i = 0; i < state.num; i++)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\tptr[i].distance = state.str->distance;\n\t\tptr[i].length = state.str->length;\n\t\tptr[i].flag = state.str->flag;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\tpos = 0;\n\tfindoprnd(ptr, &pos);\n\treturn query;\n}", "target": 1}
{"code": "int gnutls_x509_ext_import_proxy(const gnutls_datum_t * ext, int *pathlen,\n\t\t\t      char **policyLanguage, char **policy,\n\t\t\t      size_t * sizeof_policy)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint result;\n\tgnutls_datum_t value = { NULL, 0 };\n\tif ((result = asn1_create_element\n\t     (_gnutls_get_pkix(), \"PKIX1.ProxyCertInfo\",\n\t      &c2)) != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = _asn1_strict_der_decode(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (pathlen) {\n\t\tresult = _gnutls_x509_read_uint(c2, \"pCPathLenConstraint\",\n\t\t\t\t\t\t(unsigned int *)\n\t\t\t\t\t\tpathlen);\n\t\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND)\n\t\t\t*pathlen = -1;\n\t\telse if (result != GNUTLS_E_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tresult = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tresult = _gnutls_x509_read_value(c2, \"proxyPolicy.policyLanguage\",\n\t\t\t\t\t &value);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tif (policyLanguage) {\n\t\t*policyLanguage = (char *)value.data;\n\t} else {\n\t\tgnutls_free(value.data);\n\t\tvalue.data = NULL;\n\t}\n\tresult = _gnutls_x509_read_value(c2, \"proxyPolicy.policy\", &value);\n\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND) {\n\t\tif (policy)\n\t\t\t*policy = NULL;\n\t\tif (sizeof_policy)\n\t\t\t*sizeof_policy = 0;\n\t} else if (result < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t} else {\n\t\tif (policy) {\n\t\t\t*policy = (char *)value.data;\n\t\t\tvalue.data = NULL;\n\t\t}\n\t\tif (sizeof_policy)\n\t\t\t*sizeof_policy = value.size;\n\t}\n\tresult = 0;\n cleanup:\n\tgnutls_free(value.data);\n\tasn1_delete_structure(&c2);\n\treturn result;\n}", "target": 1}
{"code": "Adaptation::Ecap::Host::Host()\n{\n    libecap::headerTransferEncoding.assignHostId(Http::HdrType::TRANSFER_ENCODING);\n    libecap::headerReferer.assignHostId(Http::HdrType::REFERER);\n    libecap::headerContentLength.assignHostId(Http::HdrType::CONTENT_LENGTH);\n    libecap::headerVia.assignHostId(Http::HdrType::VIA);\n    libecap::protocolHttp.assignHostId(AnyP::PROTO_HTTP);\n    libecap::protocolHttps.assignHostId(AnyP::PROTO_HTTPS);\n    libecap::protocolFtp.assignHostId(AnyP::PROTO_FTP);\n    libecap::protocolGopher.assignHostId(AnyP::PROTO_GOPHER);\n    libecap::protocolWais.assignHostId(AnyP::PROTO_WAIS);\n    libecap::protocolUrn.assignHostId(AnyP::PROTO_URN);\n    libecap::protocolWhois.assignHostId(AnyP::PROTO_WHOIS);\n    protocolCacheObj.assignHostId(AnyP::PROTO_CACHE_OBJECT);\n    protocolIcp.assignHostId(AnyP::PROTO_ICP);\n#if USE_HTCP\n    protocolHtcp.assignHostId(AnyP::PROTO_HTCP);\n#endif\n    protocolIcy.assignHostId(AnyP::PROTO_ICY);\n    protocolUnknown.assignHostId(AnyP::PROTO_UNKNOWN);\n    metaBypassable.assignHostId(1);\n}", "target": 1}
{"code": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}", "target": 1}
{"code": "static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n\tconst char *p;\n\tchar *fileline;\n\tchar offset[SDB_NUM_BUFSZ];\n\tchar *offset_ptr;\n\tif (!s || !file) {\n\t\treturn;\n\t}\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tprint (\"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\toffset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}", "target": 1}
{"code": "static ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n}", "target": 1}
{"code": "aspath_put (struct stream *s, struct aspath *as, int use32bit )\n{\n  struct assegment *seg = as->segments;\n  size_t bytes = 0;\n  if (!seg || seg->length == 0)\n    return 0;\n  if (seg)\n    {\n      while (seg && (ASSEGMENT_LEN(seg, use32bit) <= STREAM_WRITEABLE(s)))\n        {\n          struct assegment *next = seg->next;\n          int written = 0;\n          int asns_packed = 0;\n          size_t lenp;\n          while ( (seg->length - written) > AS_SEGMENT_MAX)\n            {\n               assegment_header_put (s, seg->type, AS_SEGMENT_MAX);\n               assegment_data_put (s, seg->as, AS_SEGMENT_MAX, use32bit);\n               written += AS_SEGMENT_MAX;\n              bytes += ASSEGMENT_SIZE (written, use32bit);\n             }\n          lenp = assegment_header_put (s, seg->type, seg->length - written);\n          assegment_data_put (s, (seg->as + written), seg->length - written, \n                              use32bit);\n          while (next && ASSEGMENTS_PACKABLE (seg, next))\n            {\n              assegment_data_put (s, next->as, next->length, use32bit);\n\t      stream_putc_at (s, lenp, seg->length - written + next->length);\n              asns_packed += next->length;\n\t      next = next->next;\n\t    }\n          bytes += ASSEGMENT_SIZE (seg->length - written + asns_packed, \n\t\t\t\t   use32bit);\n          seg = next;\n        }\n    }\n  return bytes;\n}", "target": 1}
{"code": " static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n {\n\tstruct rtnl_link_ifmap map = {\n\t\t.mem_start   = dev->mem_start,\n\t\t.mem_end     = dev->mem_end,\n\t\t.base_addr   = dev->base_addr,\n\t\t.irq         = dev->irq,\n\t\t.dma         = dev->dma,\n\t\t.port        = dev->if_port,\n\t};\n \tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n \t\treturn -EMSGSIZE;\n\treturn 0;\n}", "target": 1}
{"code": "void LightProcess::ChangeUser(const std::string &username) {\n  if (username.empty()) return;\n  for (int i = 0; i < g_procsCount; i++) {\n    Lock lock(g_procs[i].m_procMutex);\n    fprintf(g_procs[i].m_fout, \"change_user\\n%s\\n\", username.c_str());\n    fflush(g_procs[i].m_fout);\n  }\n}", "target": 1}
{"code": "static bool svm_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)\n{\n\tunsigned long cr4 = kvm_read_cr4(vcpu);\n\tbool smep = cr4 & X86_CR4_SMEP;\n\tbool smap = cr4 & X86_CR4_SMAP;\n\tbool is_user = svm_get_cpl(vcpu) == 3;\n\tif (smap && (!smep || is_user)) {\n\t\tif (!sev_guest(vcpu->kvm))\n\t\t\treturn true;\n\t\tpr_err_ratelimited(\"KVM: SEV Guest triggered AMD Erratum 1096\\n\");\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t}\n\treturn false;\n}", "target": 1}
{"code": "init_remote_listener(int port, gboolean encrypted)\n{\n    int rc;\n    int *ssock = NULL;\n    struct sockaddr_in saddr;\n    int optval;\n    static struct mainloop_fd_callbacks remote_listen_fd_callbacks = \n        {\n            .dispatch = cib_remote_listen,\n            .destroy = remote_connection_destroy,\n        };\n    if (port <= 0) {\n        return 0;\n    }\n    if (encrypted) {\n#ifndef HAVE_GNUTLS_GNUTLS_H\n        crm_warn(\"TLS support is not available\");\n        return 0;\n#else\n        crm_notice(\"Starting a tls listener on port %d.\", port);\n        gnutls_global_init();\n        gnutls_global_set_log_function(debug_log);\n        gnutls_dh_params_init(&dh_params);\n        gnutls_dh_params_generate2(dh_params, DH_BITS);\n        gnutls_anon_allocate_server_credentials(&anon_cred_s);\n        gnutls_anon_set_server_dh_params(anon_cred_s, dh_params);\n#endif\n    } else {\n        crm_warn(\"Starting a plain_text listener on port %d.\", port);\n    }\n#ifndef HAVE_PAM\n    crm_warn(\"PAM is _not_ enabled!\");\n#endif\n    ssock = malloc(sizeof(int));\n    *ssock = socket(AF_INET, SOCK_STREAM, 0);\n    if (*ssock == -1) {\n        crm_perror(LOG_ERR, \"Can not create server socket.\" ERROR_SUFFIX);\n        free(ssock);\n        return -1;\n    }\n    optval = 1;\n    rc = setsockopt(*ssock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    if(rc < 0) {\n        crm_perror(LOG_INFO, \"Couldn't allow the reuse of local addresses by our remote listener\");\n    }\n    memset(&saddr, '\\0', sizeof(saddr));\n    saddr.sin_family = AF_INET;\n    saddr.sin_addr.s_addr = INADDR_ANY;\n    saddr.sin_port = htons(port);\n    if (bind(*ssock, (struct sockaddr *)&saddr, sizeof(saddr)) == -1) {\n        crm_perror(LOG_ERR, \"Can not bind server socket.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -2;\n    }\n    if (listen(*ssock, 10) == -1) {\n        crm_perror(LOG_ERR, \"Can not start listen.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -3;\n    }\n    mainloop_add_fd(\"cib-remote\", G_PRIORITY_DEFAULT, *ssock, ssock, &remote_listen_fd_callbacks);\n    return *ssock;\n}", "target": 1}
{"code": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\terr = notify_change(upperdentry, attr, NULL);\n\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t} else {\n\t\terr = ovl_copy_up_last(dentry, attr, false);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static void on_page_prepare(GtkNotebook *assistant, GtkWidget *page, gpointer user_data)\n{\n    if (!is_processing_finished())\n    {\n        show_next_step_button();\n        clear_warnings();\n    }\n    gtk_widget_hide(g_btn_detail);\n    gtk_widget_hide(g_btn_onfail);\n    if (!g_expert_mode)\n        gtk_widget_hide(g_btn_repeat);\n    save_items_from_notepad();\n    save_text_from_text_view(g_tv_comment, FILENAME_COMMENT);\n    if (pages[PAGENO_SUMMARY].page_widget == page)\n    {\n        if (!g_expert_mode)\n        {\n            int n = select_next_page_no(pages[PAGENO_SUMMARY].page_no, NULL);\n            log_info(\"switching to page_no:%d\", n);\n            gtk_notebook_set_current_page(assistant, n);\n            return;\n        }\n    }\n    if (pages[PAGENO_EDIT_ELEMENTS].page_widget == page)\n    {\n        if (highlight_forbidden())\n        {\n            add_sensitive_data_warning();\n            show_warnings();\n            gtk_expander_set_expanded(g_exp_search, TRUE);\n        }\n        else\n            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g_rb_custom_search), TRUE);\n        show_warnings();\n    }\n    if (pages[PAGENO_REVIEW_DATA].page_widget == page)\n    {\n        update_ls_details_checkboxes(g_event_selected);\n        gtk_widget_set_sensitive(g_btn_next, gtk_toggle_button_get_active(g_tb_approve_bt));\n    }\n    if (pages[PAGENO_EDIT_COMMENT].page_widget == page)\n    {\n        gtk_widget_show(g_btn_detail);\n        gtk_widget_set_sensitive(g_btn_next, false);\n        on_comment_changed(gtk_text_view_get_buffer(g_tv_comment), NULL);\n    }\n    if (pages[PAGENO_EVENT_PROGRESS].page_widget == page)\n    {\n        log_info(\"g_event_selected:'%s'\", g_event_selected);\n        if (g_event_selected\n         && g_event_selected[0]\n        ) {\n            clear_warnings();\n            start_event_run(g_event_selected);\n        }\n    }\n    if(pages[PAGENO_EVENT_SELECTOR].page_widget == page)\n    {\n        if (!g_expert_mode && !g_auto_event_list)\n            hide_next_step_button();\n    }\n}", "target": 1}
{"code": "xid_map_enter(netdissect_options *ndo,\n              const struct sunrpc_msg *rp, const u_char *bp)\n{\n\tconst struct ip *ip = NULL;\n\tconst struct ip6_hdr *ip6 = NULL;\n\tstruct xid_map_entry *xmep;\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\tswitch (IP_V((const struct ip *)bp)) {\n\tcase 4:\n\t\tip = (const struct ip *)bp;\n\t\tbreak;\n\tcase 6:\n\t\tip6 = (const struct ip6_hdr *)bp;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\txmep = &xid_map[xid_map_next];\n\tif (++xid_map_next >= XIDMAPSIZE)\n\t\txid_map_next = 0;\n\tUNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));\n\tif (ip) {\n\t\txmep->ipver = 4;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));\n\t}\n\telse if (ip6) {\n\t\txmep->ipver = 6;\n \t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n \t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n \t}\n \txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n \txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n \treturn (1);\n }", "target": 1}
{"code": "entityValueInitProcessor(XML_Parser parser,\n                         const char *s,\n                         const char *end,\n                         const char **nextPtr)\n{\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(encoding, start, end, &next);\n    eventEndPtr = next;\n    if (tok <= 0) {\n      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE:   \n      default:\n        break;\n      }\n      return storeEntityValue(parser, encoding, s, end);\n    }\n    else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      switch (ps_parsing) {\n      case XML_SUSPENDED:\n        *nextPtr = next;\n        return XML_ERROR_NONE;\n      case XML_FINISHED:\n        return XML_ERROR_ABORTED;\n      default:\n        *nextPtr = next;\n      }\n      processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    eventPtr = start;\n  }\n}", "target": 1}
{"code": "static int tipc_nl_compat_link_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t    struct nlattr **attrs)\n{\n\tstruct nlattr *link[TIPC_NLA_LINK_MAX + 1];\n\tstruct tipc_link_info link_info;\n\tint err;\n\tif (!attrs[TIPC_NLA_LINK])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(link, TIPC_NLA_LINK_MAX, attrs[TIPC_NLA_LINK],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n \tlink_info.dest = nla_get_flag(link[TIPC_NLA_LINK_DEST]);\n \tlink_info.up = htonl(nla_get_flag(link[TIPC_NLA_LINK_UP]));\n\tstrcpy(link_info.str, nla_data(link[TIPC_NLA_LINK_NAME]));\n \treturn tipc_add_tlv(msg->rep, TIPC_TLV_LINK_INFO,\n \t\t\t    &link_info, sizeof(link_info));\n}", "target": 1}
{"code": "    Curl()\n    {\n        requestHeaders = 0;\n        curl = curl_easy_init();\n        if (!curl) throw Error(\"unable to initialize curl\");\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_CAINFO, getEnv(\"SSL_CERT_FILE\", \"/etc/ssl/certs/ca-certificates.crt\").c_str());\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, (\"Nix/\" + nixVersion).c_str());\n        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, headerCallback);\n        curl_easy_setopt(curl, CURLOPT_HEADERDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progressCallback_);\n        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0);\n        showProgress = isatty(STDERR_FILENO);\n    }", "target": 1}
{"code": "static const char *check_secret(int module, const char *user, const char *group,\n\t\t\t\tconst char *challenge, const char *pass)\n{\n\tchar line[1024];\n        char pass2[MAX_DIGEST_LEN*2];\n        const char *fname = lp_secrets_file(module);\n        STRUCT_STAT st;\n       int fd, ok = 1;\n        int user_len = strlen(user);\n        int group_len = group ? strlen(group) : 0;\n        char *err;\n       if (!fname || !*fname || (fd = open(fname, O_RDONLY)) < 0)\n                return \"no secrets file\";\n       if (do_fstat(fd, &st) == -1) {\n                rsyserr(FLOG, errno, \"fstat(%s)\", fname);\n                ok = 0;\n        } else if (lp_strict_modes(module)) {\n\t\t\trprintf(FLOG, \"secrets file must not be other-accessible (see strict modes option)\\n\");\n\t\t\tok = 0;\n\t\t} else if (MY_UID() == 0 && st.st_uid != 0) {\n\t\t\trprintf(FLOG, \"secrets file must be owned by root when running as root (see strict modes)\\n\");\n\t\t\tok = 0;\n\t\t}\n                }", "target": 1}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_NS_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_NS_BASE + DRAM1_NS_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len || dram_end < len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif ((dst < prot_start && dst > prot_start - len) || prot_start < len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\tif (addr_loaded_cnt >= CHECK_IMAGE_AREA_CNT) {\n\t\tERROR(\"BL2: max loadable non secure images reached\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\taddr_loaded[addr_loaded_cnt].dest = dst;\n\taddr_loaded[addr_loaded_cnt].length = len;\n\tfor(int n=0; n<addr_loaded_cnt; n++) {\n\t\tif (((dst > addr_loaded[n].dest) &&\n\t\t     (dst <  addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    (((dst < addr_loaded[n].dest) &&\n\t\t      (dst + len)) > addr_loaded[n].dest)) {\n\t\t\tERROR(\"BL2: image is inside a previous image area.\\n\");\n\t\t\tresult = IO_FAIL;\n\t\t}\n\t}\n\taddr_loaded_cnt++;\n\treturn result;\n}", "target": 1}
{"code": "void Huff_Compress(msg_t *mbuf, int offset) {\n\tint\t\t\ti, ch, size;\n\tbyte\t\tseq[65536];\n\tbyte*\t\tbuffer;\n\thuff_t\t\thuff;\n\tsize = mbuf->cursize - offset;\n\tbuffer = mbuf->data+ + offset;\n\tif (size<=0) {\n\t\treturn;\n\t}\n\tCom_Memset(&huff, 0, sizeof(huff_t));\n\thuff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);\n\thuff.tree->symbol = NYT;\n\thuff.tree->weight = 0;\n\thuff.lhead->next = huff.lhead->prev = NULL;\n\thuff.tree->parent = huff.tree->left = huff.tree->right = NULL;\n\tseq[0] = (size>>8);\n\tseq[1] = size&0xff;\n\tbloc = 16;\n\tfor (i=0; i<size; i++ ) {\n\t\tch = buffer[i];\n\t\tHuff_transmit(&huff, ch, seq);\t\t\t\t\t\t\n\t\tHuff_addRef(&huff, (byte)ch);\t\t\t\t\t\t\t\t\n\t}\n\tbloc += 8;\t\t\t\t\t\t\t\t\t\t\t\t\n\tmbuf->cursize = (bloc>>3) + offset;\n\tCom_Memcpy(mbuf->data+offset, seq, (bloc>>3));\n}", "target": 1}
{"code": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); \n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\treturn nh.nh_type;\n}", "target": 1}
{"code": "static void adpt_sparc_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_ULTRASPARC;\n}", "target": 1}
{"code": "static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)\n{\n\tstruct evtchn_fifo_control_block *control_block;\n\tunsigned long ready;\n\tunsigned q;\n\tcontrol_block = per_cpu(cpu_control_block, cpu);\n\tready = xchg(&control_block->ready, 0);\n\twhile (ready) {\n\t\tq = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES);\n\t\tconsume_one_event(cpu, control_block, q, &ready, drop);\n\t\tready |= xchg(&control_block->ready, 0);\n\t}\n}", "target": 1}
{"code": "int MDC2_Update(MDC2_CTX *c, const unsigned char *in, size_t len)\n{\n    size_t i, j;\n     i = c->num;\n     if (i != 0) {\n        if (i + len < MDC2_BLOCK) {\n             memcpy(&(c->data[i]), in, len);\n             c->num += (int)len;\n            return 1;\n        } else {\n            j = MDC2_BLOCK - i;\n            memcpy(&(c->data[i]), in, j);\n            len -= j;\n            in += j;\n            c->num = 0;\n            mdc2_body(c, &(c->data[0]), MDC2_BLOCK);\n        }\n    }\n    i = len & ~((size_t)MDC2_BLOCK - 1);\n    if (i > 0)\n        mdc2_body(c, in, i);\n    j = len - i;\n    if (j > 0) {\n        memcpy(&(c->data[0]), &(in[i]), j);\n        c->num = (int)j;\n    }\n    return 1;\n}", "target": 1}
{"code": "static void jsR_calllwfunction(js_State *J, int n, js_Function *F, js_Environment *scope)\n{\n\tjs_Value v;\n\tint i;\n        jsR_savescope(J, scope);\n        if (n > F->numparams) {\n               js_pop(J, F->numparams - n);\n                n = F->numparams;\n        }\n        for (i = n; i < F->varlen; ++i)\n\t\tjs_pushundefined(J);\n\tjsR_run(J, F);\n\tv = *stackidx(J, -1);\n\tTOP = --BOT; \n\tjs_pushvalue(J, v);\n\tjsR_restorescope(J);\n}", "target": 1}
{"code": "Status TransposeShapeFn(InferenceContext* c) {\n  ShapeHandle input = c->input(0);\n  ShapeHandle perm_shape = c->input(1);\n  const Tensor* perm = c->input_tensor(1);\n  DimensionHandle perm_elems = c->NumElements(perm_shape);\n  if (!c->RankKnown(input) && !c->ValueKnown(perm_elems) && perm == nullptr) {\n    c->set_output(0, c->UnknownShape());\n    return Status::OK();\n  }\n  int64_t rank;\n  if (c->RankKnown(input)) {\n    rank = c->Rank(input);\n  } else if (c->ValueKnown(perm_elems)) {\n    rank = c->Value(perm_elems);\n  } else {\n    rank = perm->NumElements();\n  }\n  if (!c->RankKnown(input) && rank < 2) {\n    c->set_output(0, input);\n    return Status::OK();\n  }\n  std::vector<DimensionHandle> dims;\n  dims.resize(rank);\n  TF_RETURN_IF_ERROR(c->WithRank(input, rank, &input));\n  TF_RETURN_IF_ERROR(c->WithRank(perm_shape, 1, &perm_shape));\n  TF_RETURN_IF_ERROR(c->WithValue(perm_elems, rank, &perm_elems));\n  if (perm != nullptr) {\n    std::vector<int64_t> data;\n    if (perm->dtype() == DT_INT32) {\n      data = AsInt64<int32>(perm, rank);\n    } else {\n      data = AsInt64<int64_t>(perm, rank);\n    }\n    for (int32_t i = 0; i < rank; ++i) {\n      int64_t in_idx = data[i];\n      if (in_idx >= rank) {\n        return errors::InvalidArgument(\"perm dim \", in_idx,\n                                       \" is out of range of input rank \", rank);\n      }\n      dims[i] = c->Dim(input, in_idx);\n    }\n  } else {\n    for (int i = 0; i < rank; ++i) {\n      dims[i] = c->UnknownDim();\n    }\n  }\n  c->set_output(0, c->MakeShape(dims));\n  return Status::OK();\n}", "target": 1}
{"code": "void M_LoadDefaults (void)\n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\tfclose (f);\n    }\n    for (i = 0; i < numdefaults; i++)\n    {\n        if (defaults[i].scantranslate)\n        {\n            parm = *defaults[i].location;\n            defaults[i].untranslated = parm;\n            *defaults[i].location = scantokey[parm];\n        }\n    }\n}", "target": 1}
{"code": "static int MP4_ReadBox_String( stream_t *p_stream, MP4_Box_t *p_box )\n{\n    MP4_READBOX_ENTER( MP4_Box_data_string_t );\n    p_box->data.p_string->psz_text = malloc( p_box->i_size + 1 - 8 ); \n    if( p_box->data.p_string->psz_text == NULL )\n        MP4_READBOX_EXIT( 0 );\n    memcpy( p_box->data.p_string->psz_text, p_peek, p_box->i_size - 8 );\n    p_box->data.p_string->psz_text[p_box->i_size - 8] = '\\0';\n#ifdef MP4_VERBOSE\n        msg_Dbg( p_stream, \"read box: \\\"%4.4s\\\" text=`%s'\", (char *) & p_box->i_type,\n                 p_box->data.p_string->psz_text );\n#endif\n    MP4_READBOX_EXIT( 1 );\n}", "target": 1}
{"code": "static int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc != 5)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\tdevaddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\tlength = hextoul(argv[3], NULL);\n\tmemaddr = (u_char *)hextoul(argv[4], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, devaddr, memaddr, length);\n#else\n\tret = i2c_read(chip, devaddr, alen, memaddr, length);\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\treturn 0;\n}", "target": 1}
{"code": "      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,\n                                const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(ecdsa.domain()),\n         m_x(ecdsa.private_value())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }", "target": 1}
{"code": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  \n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  \n  else  \n    condmovestack(L,{},{});  \n  luaE_shrinkCI(L);  \n}", "target": 1}
{"code": "void QuicClientPromisedInfo::OnPromiseHeaders(const SpdyHeaderBlock& headers) {\n   SpdyHeaderBlock::const_iterator it = headers.find(kHttp2MethodHeader);\n  DCHECK(it != headers.end());\n   if (!(it->second == \"GET\" || it->second == \"HEAD\")) {\n     QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has invalid method \"\n                   << it->second;\n    Reset(QUIC_INVALID_PROMISE_METHOD);\n    return;\n  }\n  if (!SpdyUtils::UrlIsValid(headers)) {\n    QUIC_DVLOG(1) << \"Promise for stream \" << id_ << \" has invalid URL \"\n                  << url_;\n    Reset(QUIC_INVALID_PROMISE_URL);\n    return;\n  }\n  if (!session_->IsAuthorized(SpdyUtils::GetHostNameFromHeaderBlock(headers))) {\n    Reset(QUIC_UNAUTHORIZED_PROMISE_URL);\n    return;\n  }\n  request_headers_.reset(new SpdyHeaderBlock(headers.Clone()));\n}", "target": 1}
{"code": "static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data)\n\t\treturn 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\top->size = 2;\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}", "target": 1}
{"code": "asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n \t\t\t\t unsigned long arg)\n {\n\tstruct oabi_flock64 user;\n \tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; \n\tunsigned long local_arg = arg;\n\tint ret;\n \tswitch (cmd) {\n \tcase F_OFD_GETLK:\n \tcase F_OFD_SETLK:\n \tcase F_OFD_SETLKW:\n \tcase F_GETLK64:\n \tcase F_SETLK64:\n \tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n \t}\n\treturn ret;\n }", "target": 1}
{"code": "ext2_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}", "target": 1}
{"code": "static inline void vmacache_invalidate(struct mm_struct *mm)\n{\n\tmm->vmacache_seqnum++;\n\tif (unlikely(mm->vmacache_seqnum == 0))\n\t\tvmacache_flush_all(mm);\n}", "target": 1}
{"code": "static void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) \n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tstruct zip_file *zf;\n\tzend_long index = -1;\n\tzend_long flags = 0;\n\tzend_long len = 0;\n\tzend_string *filename;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|ll\", &filename, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|ll\", &index, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\t}\n\tif (sb.size < 1) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tif (len < 1) {\n\t\tlen = sb.size;\n\t}\n\tif (index >= 0) {\n\t\tzf = zip_fopen_index(intern, index, flags);\n\t} else {\n\t\tzf = zip_fopen(intern, ZSTR_VAL(filename), flags);\n\t}\n\tif (zf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tbuffer = zend_string_alloc(len, 0);\n\tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\tif (n < 1) {\n\t\tzend_string_free(buffer);\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tzip_fclose(zf);\n\tZSTR_VAL(buffer)[n] = '\\0';\n\tZSTR_LEN(buffer) = n;\n\tRETURN_NEW_STR(buffer);\n}", "target": 1}
{"code": "PackLinuxElf64::elf_find_dynamic(unsigned int key) const\n{\n    Elf64_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {\n        upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));\n        if (t) {\n            return &((unsigned char const *)file_image)[(size_t)t];\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "static UINT ExtractRunLengthMegaMega(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\tif (!buffer_within_range(pbOrderHdr, 2, pbEnd))\n\t{\n\t\t*advance = 0;\n\t\treturn 0;\n\t}\n\trunLength = ((UINT16)pbOrderHdr[1]) | (((UINT16)pbOrderHdr[2]) << 8);\n\t(*advance) += 2;\n\treturn runLength;\n}", "target": 1}
{"code": "void LibRaw::exp_bef(float shift, float smooth)\n{\n    if(shift>8) shift = 8;\n    if(shift<0.25) shift = 0.25;\n    if(smooth < 0.0) smooth = 0.0;\n    if(smooth > 1.0) smooth = 1.0;\n    unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));\n    if(shift <=1.0)\n        {\n            for(int i=0;i<=TBLN;i++)\n                lut[i] = (unsigned short)((float)i*shift);\n        }\n    else\n        {\n            float x1,x2,y1,y2;\n            float cstops = log(shift)/log(2.0f);\n            float room = cstops*2;\n            float roomlin = powf(2.0f,room);\n            x2 = (float)TBLN;\n            x1 = (x2+1)/roomlin-1;\n            y1 = x1*shift;\n            y2 = x2*(1+(1-smooth)*(shift-1));\n            float sq3x=powf(x1*x1*x2,1.0f/3.0f);\n            float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);\n            float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);\n            float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;\n            for(int i=0;i<=TBLN;i++)\n                {\n                    float X = (float)i;\n                    float Y = A*powf(X,1.0f/3.0f)+B*X+CC;\n                    if(i<x1)\n                        lut[i] = (unsigned short)((float)i*shift);\n                    else\n                        lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));\n                }\n        }\n    for(int i=0; i< S.height*S.width; i++)\n        {\n            imgdata.image[i][0] = lut[imgdata.image[i][0]];\n            imgdata.image[i][1] = lut[imgdata.image[i][1]];\n            imgdata.image[i][2] = lut[imgdata.image[i][2]];\n            imgdata.image[i][3] = lut[imgdata.image[i][3]];\n        }\n    C.data_maximum = lut[C.data_maximum];\n    C.maximum = lut[C.maximum];\n    free(lut);\n}", "target": 1}
{"code": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n    return &pair->list;\n}", "target": 1}
{"code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n \t\t\t\tvoid __user *buffer, size_t *lenp,\n \t\t\t\tloff_t *ppos)\n {\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n \tif (ret || !write)\n \t\treturn ret;\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  CHECK(input != nullptr) << \"node = \" << node.name()\n                          << \" input = \" << node.input(0);\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "void xfrm_state_fini(struct net *net)\n{\n\tunsigned int sz;\n\tflush_work(&net->xfrm.state_hash_work);\n\tflush_work(&xfrm_state_gc_work);\n\txfrm_state_flush(net, IPSEC_PROTO_ANY, false, true);\n\tWARN_ON(!list_empty(&net->xfrm.state_all));\n\tsz = (net->xfrm.state_hmask + 1) * sizeof(struct hlist_head);\n\tWARN_ON(!hlist_empty(net->xfrm.state_byspi));\n\txfrm_hash_free(net->xfrm.state_byspi, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bysrc));\n\txfrm_hash_free(net->xfrm.state_bysrc, sz);\n\tWARN_ON(!hlist_empty(net->xfrm.state_bydst));\n\txfrm_hash_free(net->xfrm.state_bydst, sz);\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 4>::ConstTensor input,\n                  typename TTypes<T, 3>::ConstTensor filter,\n                  typename TTypes<T, 4>::ConstTensor out_backprop,\n                  int stride_rows, int stride_cols, int rate_rows,\n                  int rate_cols, int pad_top, int pad_left,\n                  typename TTypes<T, 4>::Tensor in_backprop) {\n    const int batch = input.dimension(0);\n    const int input_rows = input.dimension(1);\n    const int input_cols = input.dimension(2);\n    const int depth = input.dimension(3);\n    const int filter_rows = filter.dimension(0);\n    const int filter_cols = filter.dimension(1);\n    const int output_rows = out_backprop.dimension(1);\n    const int output_cols = out_backprop.dimension(2);\n    in_backprop.setZero();\n    for (int b = 0; b < batch; ++b) {\n      for (int h_out = 0; h_out < output_rows; ++h_out) {\n        int h_beg = h_out * stride_rows - pad_top;\n        for (int w_out = 0; w_out < output_cols; ++w_out) {\n          int w_beg = w_out * stride_cols - pad_left;\n          for (int d = 0; d < depth; ++d) {\n            T cur_val = Eigen::NumTraits<T>::lowest();\n            int h_in_max = (h_beg < 0) ? 0 : h_beg;\n            int w_in_max = (w_beg < 0) ? 0 : w_beg;\n            for (int h = 0; h < filter_rows; ++h) {\n              const int h_in = h_beg + h * rate_rows;\n              if (h_in >= 0 && h_in < input_rows) {\n                for (int w = 0; w < filter_cols; ++w) {\n                  const int w_in = w_beg + w * rate_cols;\n                  if (w_in >= 0 && w_in < input_cols) {\n                    const T val = input(b, h_in, w_in, d) + filter(h, w, d);\n                    if (val > cur_val) {\n                      cur_val = val;\n                      h_in_max = h_in;\n                      w_in_max = w_in;\n                    }\n                  }\n                }\n              }\n            }\n            in_backprop(b, h_in_max, w_in_max, d) +=\n                out_backprop(b, h_out, w_out, d);\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "static void Sp_match(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint len;\n\tconst char *a, *b, *c, *e;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\tre = js_toregexp(J, -1);\n\tif (!(re->flags & JS_REGEXP_G)) {\n\t\tjs_RegExp_prototype_exec(J, re, text);\n\t\treturn;\n\t}\n\tre->last = 0;\n\tjs_newarray(J);\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\t\ta = c;\n\t\tif (c - b == 0)\n\t\t\t++a;\n\t}\n\tif (len == 0) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushnull(J);\n\t}\n}", "target": 1}
{"code": "bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)\n{\n    barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;\n    try {\n        auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);\n        fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,\n                                                             barrier::FingerprintType::SHA1);\n        fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,\n                                                               barrier::FingerprintType::SHA256);\n    } catch (const std::exception& e) {\n        LOG((CLOG_ERR \"%s\", e.what()));\n        return false;\n    }\n    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\",\n         barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n         barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n    LOG((CLOG_NOTE \"fingerprint_db_path: %s\", fingerprint_db_path.u8string().c_str()));\n    barrier::FingerprintDatabase db;\n    db.read(fingerprint_db_path);\n    if (!db.fingerprints().empty()) {\n        LOG((CLOG_NOTE \"Read %d fingerprints from: %s\", db.fingerprints().size(),\n             fingerprint_db_path.u8string().c_str()));\n    } else {\n        LOG((CLOG_NOTE \"Could not read fingerprints from: %s\",\n             fingerprint_db_path.u8string().c_str()));\n    }\n    if (db.is_trusted(fingerprint_sha256)) {\n        LOG((CLOG_NOTE \"Fingerprint matches trusted fingerprint\"));\n        return true;\n    } else {\n        LOG((CLOG_NOTE \"Fingerprint does not match trusted fingerprint\"));\n        return false;\n    }\n}", "target": 1}
{"code": "static int io_rw_init_file(struct io_kiocb *req, fmode_t mode)\n{\n\tstruct kiocb *kiocb = &req->rw.kiocb;\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tstruct file *file = req->file;\n\tint ret;\n\tif (unlikely(!file || !(file->f_mode & mode)))\n\t\treturn -EBADF;\n\tif (!io_req_ffs_set(req))\n\t\treq->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT;\n\tkiocb->ki_flags = iocb_flags(file);\n\tret = kiocb_set_rw_flags(kiocb, req->rw.flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\tif ((kiocb->ki_flags & IOCB_NOWAIT) ||\n\t    ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req)))\n\t\treq->flags |= REQ_F_NOWAIT;\n\tif (ctx->flags & IORING_SETUP_IOPOLL) {\n\t\tif (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll)\n\t\t\treturn -EOPNOTSUPP;\n\t\tkiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE;\n\t\tkiocb->ki_complete = io_complete_rw_iopoll;\n\t\treq->iopoll_completed = 0;\n\t} else {\n\t\tif (kiocb->ki_flags & IOCB_HIPRI)\n\t\t\treturn -EINVAL;\n\t\tkiocb->ki_complete = io_complete_rw;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  char * unescape(char * dest, const char * src)\n  {\n    while (*src) {\n      if (*src == '\\\\') {\n\t++src;\n\tswitch (*src) {\n\tcase 'n': *dest = '\\n'; break;\n\tcase 'r': *dest = '\\r'; break;\n\tcase 't': *dest = '\\t'; break;\n\tcase 'f': *dest = '\\f'; break;\n\tcase 'v': *dest = '\\v'; break;\n\tdefault: *dest = *src;\n\t}\n      } else {\n\t*dest = *src;\n      }\n      ++src;\n      ++dest;\n    }\n    *dest = '\\0';\n    return dest;\n  }", "target": 1}
{"code": " LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n {\n \tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n \tif(!file) return 0;\n \tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n \t}\n\tretval = (int)tmpretval;\n \tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n \t}\n\topenmpt_free_string(str);\n\treturn retval;\n }", "target": 1}
{"code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n\tif (ctxt) {\n\t\tzend_bool old;\n\t\tctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n\t\tctxt->sax->comment = soap_Comment;\n\t\tctxt->sax->warning = NULL;\n\t\tctxt->sax->error = NULL;\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\told = php_libxml_disable_entity_loader(1);\n\t\txmlParseDocument(ctxt);\n\t\tphp_libxml_disable_entity_loader(old);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static struct wildmat *split_wildmats(char *str)\n{\n    const char *prefix;\n    char pattern[MAX_MAILBOX_BUFFER] = \"\", *p, *c;\n    struct wildmat *wild = NULL;\n    int n = 0;\n    if ((prefix = config_getstring(IMAPOPT_NEWSPREFIX)))\n\tsnprintf(pattern, sizeof(pattern), \"%s.\", prefix);\n    p = pattern + strlen(pattern);\n    do {\n\tif ((c = strrchr(str, ',')))\n\t    *c++ = '\\0';\n\telse\n\t    c = str;\n\tif (!(n % 10)) \n\t    wild = xrealloc(wild, (n + 11) * sizeof(struct wildmat));\n\tif (*c == '!') wild[n].not = 1;\t\t\n\telse if (*c == '@') wild[n].not = -1;\t\n\telse wild[n].not = 0;\n\tstrcpy(p, wild[n].not ? c + 1 : c);\n\twild[n++].pat = xstrdup(pattern);\n    } while (c != str);\n    wild[n].pat = NULL;\n    return wild;\n}", "target": 1}
{"code": "urnParseReply(const char *inbuf, const HttpRequestMethod& m)\n{\n    char *buf = xstrdup(inbuf);\n    char *token;\n    url_entry *list;\n    url_entry *old;\n    int n = 32;\n    int i = 0;\n    debugs(52, 3, \"urnParseReply\");\n    list = (url_entry *)xcalloc(n + 1, sizeof(*list));\n    for (token = strtok(buf, crlf); token; token = strtok(NULL, crlf)) {\n        debugs(52, 3, \"urnParseReply: got '\" << token << \"'\");\n        if (i == n) {\n            old = list;\n            n <<= 2;\n            list = (url_entry *)xcalloc(n + 1, sizeof(*list));\n            memcpy(list, old, i * sizeof(*list));\n            safe_free(old);\n        }\n        AnyP::Uri uri;\n        if (!uri.parse(m, SBuf(token)) || !*uri.host())\n            continue;\n#if USE_ICMP\n        list[i].rtt = netdbHostRtt(uri.host());\n        if (0 == list[i].rtt) {\n            debugs(52, 3, \"Pinging \" << uri.host());\n            netdbPingSite(uri.host());\n        }\n#else\n        list[i].rtt = 0;\n#endif\n        list[i].url = xstrdup(uri.absolute().c_str());\n        list[i].host = xstrdup(uri.host());\n        list[i].flags.cached = storeGetPublic(list[i].url, m) ? 1 : 0;\n        ++i;\n    }\n    debugs(52, 3, \"urnParseReply: Found \" << i << \" URLs\");\n    return list;\n}", "target": 1}
{"code": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n   BUG_IF(tree_root == NULL);\n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n   unfold_blk(&tree_root);\n   fprintf(stdout, \" done.\\n\\n\");\n   labels_to_offsets();\n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   *fop = array;\n   return (i);\n}", "target": 1}
{"code": "static pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n\t\t\t       const pj_uint8_t *pkt, const pj_uint8_t *start,\n\t\t\t       const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n\treturn status;\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n\treturn status;\n    p = (start + name_part_len);\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n    *parsed_len = (int)(p - start);\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "build_config(char *prefix, struct server *server)\n {\n     char *path    = NULL;\n     int path_size = strlen(prefix) + strlen(server->port) + 20;\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n     fprintf(f, \"{\\n\");\n     fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n     fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n     fprintf(f, \"\\n}\\n\");\n     fclose(f);\n     ss_free(path);\n}", "target": 1}
{"code": "static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n{\n\tstruct flakey_c *fc = ti->private;\n\treturn __blkdev_driver_ioctl(fc->dev->bdev, fc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\treturn 0;\n}", "target": 1}
{"code": " static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n \t\t\trdesc[106] == 0x03) {\n \t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n \t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static CURLcode tftp_connect(struct connectdata *conn, bool *done)\n{\n  tftp_state_data_t *state;\n  int blksize;\n  blksize = TFTP_BLKSIZE_DEFAULT;\n  state = conn->proto.tftpc = calloc(1, sizeof(tftp_state_data_t));\n  if(!state)\n    return CURLE_OUT_OF_MEMORY;\n  if(conn->data->set.tftp_blksize) {\n    blksize = (int)conn->data->set.tftp_blksize;\n    if(blksize > TFTP_BLKSIZE_MAX || blksize < TFTP_BLKSIZE_MIN)\n      return CURLE_TFTP_ILLEGAL;\n  }\n  if(!state->rpacket.data) {\n    state->rpacket.data = calloc(1, blksize + 2 + 2);\n    if(!state->rpacket.data)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  if(!state->spacket.data) {\n    state->spacket.data = calloc(1, blksize + 2 + 2);\n    if(!state->spacket.data)\n      return CURLE_OUT_OF_MEMORY;\n  }\n  connclose(conn, \"TFTP\");\n  state->conn = conn;\n  state->sockfd = state->conn->sock[FIRSTSOCKET];\n  state->state = TFTP_STATE_START;\n  state->error = TFTP_ERR_NONE;\n  state->blksize = blksize;\n  state->requested_blksize = blksize;\n  ((struct sockaddr *)&state->local_addr)->sa_family =\n    (CURL_SA_FAMILY_T)(conn->ip_addr->ai_family);\n  tftp_set_timeouts(state);\n  if(!conn->bits.bound) {\n    int rc = bind(state->sockfd, (struct sockaddr *)&state->local_addr,\n                  conn->ip_addr->ai_addrlen);\n    if(rc) {\n      char buffer[STRERROR_LEN];\n      failf(conn->data, \"bind() failed; %s\",\n            Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));\n      return CURLE_COULDNT_CONNECT;\n    }\n    conn->bits.bound = TRUE;\n  }\n  Curl_pgrsStartNow(conn->data);\n  *done = TRUE;\n  return CURLE_OK;\n}", "target": 1}
{"code": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}", "target": 1}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, \n\t\t\t     0, \n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\tkfree(status_buf);\n\treturn rc;\n}", "target": 1}
{"code": "void AverageEvalQuantizedUint8(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<uint8_t>(input), GetTensorShape(output), \\\n                    GetTensorData<uint8_t>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n    state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}", "target": 1}
{"code": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n  auto sep = file.rfind('/');\n  if (sep != std::string::npos) {\n    auto path = to + file.substr(0, sep);\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n    if (sep == file.length() - 1) {\n      return true;\n    }\n  }\n  to.append(file);\n  struct zip_stat zipStat;\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static unsigned long mmap_legacy_base(unsigned long rnd)\n{\n\tif (mmap_is_ia32())\n\t\treturn TASK_UNMAPPED_BASE;\n\telse\n\t\treturn TASK_UNMAPPED_BASE + rnd;\n}", "target": 1}
{"code": "juniper_atm1_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM1;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[0] == 0x80) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            return l2info.header_len;\n        }\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\n}", "target": 1}
{"code": "static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct gnttab_copy **gopp)\n{\n\tstruct gnttab_copy *gop = *gopp;\n\tu16 pending_idx = *((u16 *)skb->data);\n\tstruct pending_tx_info *pending_tx_info = netbk->pending_tx_info;\n\tstruct xenvif *vif = pending_tx_info[pending_idx].vif;\n\tstruct xen_netif_tx_request *txp;\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i, err, start;\n\terr = gop->status;\n\tif (unlikely(err)) {\n\t\tpending_ring_idx_t index;\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\ttxp = &pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t}\n\tstart = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);\n\tfor (i = start; i < nr_frags; i++) {\n\t\tint j, newerr;\n\t\tpending_ring_idx_t index;\n\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[i]);\n\t\tnewerr = (++gop)->status;\n\t\tif (likely(!newerr)) {\n\t\t\tif (unlikely(err))\n\t\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t\tcontinue;\n\t\t}\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tpending_idx = *((u16 *)skb->data);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\tfor (j = start; j < i; j++) {\n\t\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[j]);\n\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t}\n\t\terr = newerr;\n\t}\n\t*gopp = gop + 1;\n\treturn err;\n}", "target": 1}
{"code": "compat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2_f(\"original public key proposal: %s\", pkalg_prop);\n\tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat public key proposal: %s\", pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}", "target": 1}
{"code": "int nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols)\n{\n\tint rc;\n\tpr_debug(\"dev_name %s initiator protocols 0x%x target protocols 0x%x\\n\",\n\t\t dev_name(&dev->dev), im_protocols, tm_protocols);\n\tif (!im_protocols && !tm_protocols)\n\t\treturn -EINVAL;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc) {\n\t\tdev->polling = true;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "NOEXPORT int ssl_tlsext_ticket_key_cb(SSL *ssl, unsigned char *key_name,\n        unsigned char *iv, EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc) {\n    CLI *c;\n    const EVP_CIPHER *cipher;\n    int iv_len;\n    (void)key_name; \n    s_log(LOG_DEBUG, \"Session ticket processing callback\");\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n    if(!HMAC_Init_ex(hctx, (const unsigned char *)(c->opt->ticket_mac->key_val),\n        c->opt->ticket_mac->key_len, EVP_sha256(), NULL)) {\n        s_log(LOG_ERR, \"HMAC_Init_ex failed\");\n        return -1;\n    }\n    if(c->opt->ticket_key->key_len == 16)\n        cipher = EVP_aes_128_cbc();\n    else \n        cipher = EVP_aes_256_cbc();\n    if(enc) { \n        iv_len = EVP_CIPHER_iv_length(cipher);\n        if(RAND_bytes(iv, iv_len) <= 0) { \n            s_log(LOG_ERR, \"RAND_bytes failed\");\n            return -1;\n        }\n        if(!EVP_EncryptInit_ex(ctx, cipher, NULL,\n            (const unsigned char *)(c->opt->ticket_key->key_val), iv)) {\n            s_log(LOG_ERR, \"EVP_EncryptInit_ex failed\");\n            return -1;\n        }\n    } else \n        if(!EVP_DecryptInit_ex(ctx, cipher, NULL,\n            (const unsigned char *)(c->opt->ticket_key->key_val), iv)) {\n            s_log(LOG_ERR, \"EVP_DecryptInit_ex failed\");\n            return -1;\n        }\n    if(strcmp(SSL_get_version(c->ssl), \"TLSv1.3\"))\n        return 1; \n    else\n        return 2; \n}", "target": 1}
{"code": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\tplen = ntohl(nh.nh_len);\n \tif (!(plen <= *len))\n \t\tprintf(\"PLEN %d type %d len %d\\n\",\n \t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); \n \t*len = plen;\n \tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\treturn nh.nh_type;\n}", "target": 1}
{"code": "static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount, expires;\n\tint expires_seq;\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tamount = min_amount;\n\telse {\n\t\tstart_cfs_bandwidth(cfs_b);\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\texpires_seq = cfs_b->expires_seq;\n\texpires = cfs_b->runtime_expires;\n\traw_spin_unlock(&cfs_b->lock);\n\tcfs_rq->runtime_remaining += amount;\n\tif (cfs_rq->expires_seq != expires_seq) {\n\t\tcfs_rq->expires_seq = expires_seq;\n\t\tcfs_rq->runtime_expires = expires;\n\t}\n\treturn cfs_rq->runtime_remaining > 0;\n}", "target": 1}
{"code": "static UINT drdynvc_process_capability_request(drdynvcPlugin* drdynvc, int Sp,\n        int cbChId, wStream* s)\n{\n\tUINT status;\n \tif (!drdynvc)\n \t\treturn CHANNEL_RC_BAD_INIT_HANDLE;\n \tWLog_Print(drdynvc->log, WLOG_TRACE, \"capability_request Sp=%d cbChId=%d\", Sp, cbChId);\n \tStream_Seek(s, 1); \n \tStream_Read_UINT16(s, drdynvc->version);\n \tif ((drdynvc->version == 2) || (drdynvc->version == 3))\n \t{\n \t\tStream_Read_UINT16(s, drdynvc->PriorityCharge0);\n \t\tStream_Read_UINT16(s, drdynvc->PriorityCharge1);\n \t\tStream_Read_UINT16(s, drdynvc->PriorityCharge2);\n\t\tStream_Read_UINT16(s, drdynvc->PriorityCharge3);\n\t}\n\tstatus = drdynvc_send_capability_response(drdynvc);\n\tdrdynvc->state = DRDYNVC_STATE_READY;\n \treturn status;\n }", "target": 1}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    int name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    if (name_size == 0) return;\n    char* name = new char[name_size+1];\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 1}
{"code": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\tspin_lock_init(&hsr->seqnr_lock);\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\thsr->protVersion = protocol_version;\n\tnetif_carrier_off(hsr_dev);\n \tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n \tif (res)\n\t\treturn res;\n \tres = register_netdevice(hsr_dev);\n \tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\treturn 0;\n fail:\n \thsr_for_each_port(hsr, port)\n \t\thsr_del_port(port);\n \treturn res;\n }", "target": 1}
{"code": "static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_alg *alg;\n\tstruct shash_alg *salg;\n\tint err;\n\tint ds;\n\tint ss;\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\n\tif (err)\n\t\treturn err;\n \tsalg = shash_attr_alg(tb[1], 0, 0);\n \tif (IS_ERR(salg))\n \t\treturn PTR_ERR(salg);\n \terr = -EINVAL;\n \tds = salg->digestsize;\n \tss = salg->statesize;\n\talg = &salg->base;\n \tif (ds > alg->cra_blocksize ||\n \t    ss < alg->cra_blocksize)\n \t\tgoto out_put_alg;\n\tinst = shash_alloc_instance(\"hmac\", alg);\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\terr = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,\n\t\t\t\t      shash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\tinst->alg.base.cra_alignmask = alg->cra_alignmask;\n\tss = ALIGN(ss, alg->cra_alignmask + 1);\n\tinst->alg.digestsize = ds;\n\tinst->alg.statesize = ss;\n\tinst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +\n\t\t\t\t     ALIGN(ss * 2, crypto_tfm_ctx_alignment());\n\tinst->alg.base.cra_init = hmac_init_tfm;\n\tinst->alg.base.cra_exit = hmac_exit_tfm;\n\tinst->alg.init = hmac_init;\n\tinst->alg.update = hmac_update;\n\tinst->alg.final = hmac_final;\n\tinst->alg.finup = hmac_finup;\n\tinst->alg.export = hmac_export;\n\tinst->alg.import = hmac_import;\n\tinst->alg.setkey = hmac_setkey;\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nout_free_inst:\n\t\tshash_free_instance(shash_crypto_instance(inst));\n\t}\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1}
{"code": "static int ext4_end_io_nolock(ext4_io_end_t *io)\n{\n\tstruct inode *inode = io->inode;\n\tloff_t offset = io->offset;\n\tssize_t size = io->size;\n\tint ret = 0;\n\text4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"\n\t\t   \"list->prev 0x%p\\n\",\n\t           io, inode->i_ino, io->list.next, io->list.prev);\n\tif (list_empty(&io->list))\n\t\treturn ret;\n\tif (io->flag != EXT4_IO_UNWRITTEN)\n\t\treturn ret;\n\tif (offset + size <= i_size_read(inode))\n\t\tret = ext4_convert_unwritten_extents(inode, offset, size);\n\tif (ret < 0) {\n\t\tprintk(KERN_EMERG \"%s: failed to convert unwritten\"\n\t\t\t\"extents to written extents, error is %d\"\n\t\t\t\" io is still on inode %lu aio dio list\\n\",\n                       __func__, ret, inode->i_ino);\n\t\treturn ret;\n\t}\n\tio->flag = 0;\n\treturn ret;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf)\n{\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\tsctp_addip_param_t\t*asconf_param;\n\tstruct sctp_chunk\t*asconf_ack;\n\t__be16\terr_code;\n\tint\tlength = 0;\n\tint\tchunk_len;\n\t__u32\tserial;\n\tint\tall_param_pass = 1;\n\tchunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n\thdr = (sctp_addiphdr_t *)asconf->skb->data;\n\tserial = ntohl(hdr->serial);\n\tlength = sizeof(sctp_addiphdr_t);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tchunk_len -= length;\n\tlength = ntohs(addr_param->p.length);\n\tasconf_param = (void *)addr_param + length;\n\tchunk_len -= length;\n\tasconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4);\n\tif (!asconf_ack)\n\t\tgoto done;\n\twhile (chunk_len > 0) {\n\t\terr_code = sctp_process_asconf_param(asoc, asconf,\n\t\t\t\t\t\t     asconf_param);\n\t\tif (SCTP_ERROR_NO_ERROR != err_code)\n\t\t\tall_param_pass = 0;\n\t\tif (!all_param_pass)\n\t\t\tsctp_add_asconf_response(asconf_ack,\n\t\t\t\t\t\t asconf_param->crr_id, err_code,\n\t\t\t\t\t\t asconf_param);\n\t\tif (SCTP_ERROR_RSRC_LOW == err_code)\n\t\t\tgoto done;\n\t\tlength = ntohs(asconf_param->param_hdr.length);\n\t\tasconf_param = (void *)asconf_param + length;\n\t\tchunk_len -= length;\n\t}\ndone:\n\tasoc->peer.addip_serial++;\n\tif (asconf_ack) {\n\t\tsctp_chunk_hold(asconf_ack);\n\t\tlist_add_tail(&asconf_ack->transmitted_list,\n\t\t\t      &asoc->asconf_ack_list);\n\t}\n\treturn asconf_ack;\n}", "target": 1}
{"code": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn)\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n  data->conn = NULL;\n}", "target": 1}
{"code": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\tfl6_free_socklist(sk);\n\topt = xchg(&np->opt, NULL);\n\tif (opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n}", "target": 1}
{"code": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n  if (rc == IDN2_OK)\n    {\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n      free(output_u8);\n    }\n  return rc;\n}", "target": 1}
{"code": "_pdfioTokenGet(_pdfio_token_t *tb,\t\n\t       char           *buffer,\t\n\t       size_t         bufsize)\t\n{\n  if (tb->num_tokens > 0)\n  {\n    tb->num_tokens --;\n    strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1);\n    buffer[bufsize - 1] = '\\0';\n    PDFIO_DEBUG(\"_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\\n\", tb, buffer, (unsigned)bufsize, buffer);\n    free(tb->tokens[tb->num_tokens]);\n    tb->tokens[tb->num_tokens] = NULL;\n    return (true);\n  }\n  return (_pdfioTokenRead(tb, buffer, bufsize));\n}", "target": 1}
{"code": "void codingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}\n}", "target": 1}
{"code": "MagickExport MagickBooleanType SetImageExtent(Image *image,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n  if ((columns == 0) || (rows == 0))\n    ThrowBinaryException(ImageError,\"NegativeOrZeroImageSize\",image->filename);\n  image->columns=columns;\n  image->rows=rows;\n  if ((image->depth == 0) || (image->depth > (8*sizeof(MagickSizeType))))\n    ThrowBinaryException(ImageError,\"ImageDepthNotSupported\",image->filename);\n  return(SyncImagePixelCache(image,exception));\n}", "target": 1}
{"code": "pxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\tint words = count / 4;\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\tbuffer->length = words;\n\tbuffer->ptr[words] = 0x01000000;\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer->next = NULL;\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\tpriv->ready_last = buffer;\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\treturn words * 4;\n}", "target": 1}
{"code": "gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\tconst int angle_rounded = (int)floor(angle * 100);\n\tif (bgcolor < 0 || bgcolor >= gdMaxColors) {\n\t\treturn NULL;\n\t}\n\tif (src->trueColor == 0) {\n\t\tif (bgcolor >= 0) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\tswitch (angle_rounded) {\n\t\tcase 9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\t\tcase 18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\t\tcase 27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\treturn prog;\n}", "target": 1}
{"code": "static bool ParseSparseAccessor(Accessor *accessor, std::string *err,\n                                const json &o) {\n  accessor->sparse.isSparse = true;\n  int count = 0;\n  if (!ParseIntegerProperty(&count, err, o, \"count\", true, \"SparseAccessor\")) {\n    return false;\n  }\n  json_const_iterator indices_iterator;\n  json_const_iterator values_iterator;\n  if (!FindMember(o, \"indices\", indices_iterator)) {\n    (*err) = \"the sparse object of this accessor doesn't have indices\";\n    return false;\n  }\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;\n  accessor->sparse.values.byteOffset = values_byte_offset;\n  return true;\n}", "target": 1}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n {\n\tstruct loop_device *lo = disk->private_data;\n \tint err;\n \tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n \tmutex_unlock(&lo->lo_ctl_mutex);\n }", "target": 1}
{"code": "   void CreateAuthenticatorFactory() {\n     DCHECK(context_->network_task_runner()->BelongsToCurrentThread());\n     std::string local_certificate = key_pair_.GenerateCertificate();\n     if (local_certificate.empty()) {\n       LOG(ERROR) << \"Failed to generate host certificate.\";\n      Shutdown(kHostInitializationFailed);\n      return;\n    }\n    scoped_ptr<protocol::AuthenticatorFactory> factory(\n        new protocol::Me2MeHostAuthenticatorFactory(\n            local_certificate, *key_pair_.private_key(), host_secret_hash_));\n    host_->SetAuthenticatorFactory(factory.Pass());\n  }", "target": 1}
{"code": "static void *gp_worker_main(void *pvt)\n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n    while (!t->pool->shutdown) {\n        gp_debug_set_conn_id(0);\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_exit(NULL);\n            }\n        }\n        q = t->query;\n        t->query = NULL;\n        pthread_mutex_unlock(&t->cond_mutex);\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        pthread_mutex_lock(&t->pool->lock);\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n        pthread_mutex_unlock(&t->pool->lock);\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n    pthread_exit(NULL);\n}", "target": 1}
{"code": "static inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\tfollow_dotdot(nd);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "static unsigned int unix_dgram_poll(struct file *file, struct socket *sock,\n\t\t\t\t    poll_table *wait)\n{\n\tstruct sock *sk = sock->sk, *other;\n\tunsigned int mask, writable;\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\n\t\tmask |= POLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP | POLLIN | POLLRDNORM;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tif (sk->sk_state == TCP_CLOSE)\n\t\t\tmask |= POLLHUP;\n\t\tif (sk->sk_state == TCP_SYN_SENT)\n\t\t\treturn mask;\n\t}\n\tif (!(poll_requested_events(wait) & (POLLWRBAND|POLLWRNORM|POLLOUT)))\n\t\treturn mask;\n\twritable = unix_writable(sk);\n\tother = unix_peer_get(sk);\n\tif (other) {\n\t\tif (unix_peer(other) != sk) {\n\t\t\tsock_poll_wait(file, &unix_sk(other)->peer_wait, wait);\n\t\t\tif (unix_recvq_full(other))\n\t\t\t\twritable = 0;\n\t\t}\n\t\tsock_put(other);\n\t}\n\tif (writable)\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\telse\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\treturn mask;\n}", "target": 1}
{"code": "static int empty_write_end(struct page *page, unsigned from,\n\t\t\t   unsigned to, int mode)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *bh;\n\tunsigned offset, blksize = 1 << inode->i_blkbits;\n\tpgoff_t end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;\n\tzero_user(page, from, to-from);\n\tmark_page_accessed(page);\n\tif (page->index < end_index || !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\tif (!gfs2_is_writeback(ip))\n\t\t\tgfs2_page_add_databufs(ip, page, from, to);\n\t\tblock_commit_write(page, from, to);\n\t\treturn 0;\n\t}\n\toffset = 0;\n\tbh = page_buffers(page);\n\twhile (offset < to) {\n\t\tif (offset >= from) {\n\t\t\tset_buffer_uptodate(bh);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\tclear_buffer_new(bh);\n\t\t\twrite_dirty_buffer(bh, WRITE);\n\t\t}\n\t\toffset += blksize;\n\t\tbh = bh->b_this_page;\n\t}\n\toffset = 0;\n\tbh = page_buffers(page);\n\twhile (offset < to) {\n\t\tif (offset >= from) {\n\t\t\twait_on_buffer(bh);\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\treturn -EIO;\n\t\t}\n\t\toffset += blksize;\n\t\tbh = bh->b_this_page;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n \tu32 device_idx, target_idx;\n \tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n \t\treturn -EINVAL;\n \tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}", "target": 1}
{"code": "njs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n    code = (njs_vmcode_array_t *) pc;\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n    if (njs_fast_path(array != NULL)) {\n        if (code->ctor) {\n            value = array->start;\n            length = array->length;\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n        } else {\n            array->length = 0;\n        }\n        njs_set_array(&vm->retval, array);\n        return sizeof(njs_vmcode_array_t);\n    }\n    return NJS_ERROR;\n}", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  Quantum\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "v8::Local<v8::Value> ModuleSystem::RequireForJsInner(\n    v8::Local<v8::String> module_name) {\n  v8::EscapableHandleScope handle_scope(GetIsolate());\n  v8::Local<v8::Context> v8_context = context()->v8_context();\n  v8::Context::Scope context_scope(v8_context);\n  v8::Local<v8::Object> global(context()->v8_context()->Global());\n  v8::Local<v8::Value> modules_value;\n  if (!GetPrivate(global, kModulesField, &modules_value) ||\n      modules_value->IsUndefined()) {\n    Warn(GetIsolate(), \"Extension view no longer exists\");\n    return v8::Undefined(GetIsolate());\n  }\n   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n   v8::Local<v8::Value> exports;\n  if (!GetProperty(v8_context, modules, module_name, &exports) ||\n       !exports->IsUndefined())\n     return handle_scope.Escape(exports);\n   exports = LoadModule(*v8::String::Utf8Value(module_name));\n  SetProperty(v8_context, modules, module_name, exports);\n   return handle_scope.Escape(exports);\n }", "target": 1}
{"code": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\twait_for_completion(&fcomp.comp);\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1}
{"code": "ecc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)\n{\n  mp_limb_t u1, u0;\n  mp_size_t n;\n  n = 2*p->size;\n  u1 = rp[--n];\n  u0 = rp[n-1];\n  for (; n >= p->size; n--)\n    {\n      mp_limb_t q2, q1, q0, t, cy;\n      q1 = u1 - (u1 > u0);\n      q0 = u0 - u1;\n      t = u1 << 32;\n      q0 += t;\n      t = (u1 >> 32) + (q0 < t) + 1;\n      q1 += t;\n      q2 = q1 < t;\n      u1 = u0 + (q1 << 32) - q1;\n      t = -(mp_limb_t) (u1 > q0);\n      u1 -= t & 0xffffffff;\n      q1 += t;\n      q2 += t + (q1 < t);\n      assert (q2 < 2);\n      t = mpn_submul_1 (rp + n - 4, p->m, 2, q1);\n      t += cnd_sub_n (q2, rp + n - 3, p->m, 1);\n      t += (-q2) & 0xffffffff;\n      u0 = rp[n-2];\n      cy = (u0 < t);\n      u0 -= t;\n      t = (u1 < cy);\n      u1 -= cy;\n      u1 += cnd_add_n (t, rp + n - 4, p->m, 3);\n      u1 -= (-t) & 0xffffffff;\n    }\n  rp[2] = u0;\n  rp[3] = u1;\n}", "target": 1}
{"code": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n  if (text[1] == EOF)\n    return 0;\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n    if (text[2] == EOF)\n      return 0;\n    text[3] = RE_YY_INPUT(yyscanner);\n    if (text[3] == EOF)\n      return 0;\n  }\n  *escaped_char = escaped_char_value(text);\n  return 1;", "target": 1}
{"code": "      TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {\n    if (tuple[index].has_value()) {\n      return Status(errors::InvalidArgument(\n          \"The tensor for index '\", index, \"' for key '\", key.scalar<int64>()(),\n          \"' was already initialized '\", dtypes_.size(), \"'.\"));\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "bool DSClientEvent::event()\n{\n    bool restart = false;\n    ParticipantProxyData* part_proxy_data;\n    eprosima::shared_lock<eprosima::shared_mutex> lock(mp_PDP->mp_builtin->getDiscoveryMutex());\n    for (auto server: mp_PDP->remote_server_attributes())\n    {\n        std::unique_lock<std::recursive_mutex> pdp_lock(*mp_PDP->getMutex());\n        part_proxy_data = mp_PDP->get_participant_proxy_data(server.guidPrefix);\n        if (nullptr != part_proxy_data)\n        {\n            if (!mp_EDP->areRemoteEndpointsMatched(part_proxy_data))\n            {\n                mp_EDP->assignRemoteEndpoints(*(part_proxy_data));\n            }\n        }\n        else\n        {\n            restart = true;\n        }\n    }\n    if (restart)\n    {\n        mp_PDP->_serverPing = true;\n        mp_PDP->announceParticipantState(false);\n        EPROSIMA_LOG_INFO(CLIENT_PDP_THREAD,\n                \"Client \" << mp_PDP->getRTPSParticipant()->getGuid() << \" PDP announcement\");\n    }\n    return restart;\n}", "target": 1}
{"code": "raw_copy_from_user(void *dst, const void __user *src, unsigned long size)\n{\n\tint ret = 0;\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic(dst, (__force void *)src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u8 *)dst, (u8 __user *)src,\n\t\t\t      ret, \"b\", \"b\", \"=q\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u16 *)dst, (u16 __user *)src,\n\t\t\t      ret, \"w\", \"w\", \"=r\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u32 *)dst, (u32 __user *)src,\n\t\t\t      ret, \"l\", \"k\", \"=r\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t      ret, \"q\", \"\", \"=r\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t       ret, \"q\", \"\", \"=r\", 10);\n\t\tif (likely(!ret))\n\t\t\t__get_user_asm_nozero(*(u16 *)(8 + (char *)dst),\n\t\t\t\t       (u16 __user *)(8 + (char __user *)src),\n\t\t\t\t       ret, \"w\", \"w\", \"=r\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t       ret, \"q\", \"\", \"=r\", 16);\n\t\tif (likely(!ret))\n\t\t\t__get_user_asm_nozero(*(u64 *)(8 + (char *)dst),\n\t\t\t\t       (u64 __user *)(8 + (char __user *)src),\n\t\t\t\t       ret, \"q\", \"\", \"=r\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic(dst, (__force void *)src, size);\n\t}\n}", "target": 1}
{"code": "long keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\told_setting = current_cred_xxx(jit_keyring);\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto error;\n\t\t\tret = 0;\n\t\t}\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 1}
{"code": "mm_memvalid(struct mm_master *mm, void *address, size_t size)\n{\n\tvoid *end = (char *)address + size;\n\tif (address < mm->address)\n\t\tfatal(\"mm_memvalid: address too small: %p\", address);\n\tif (end < address)\n\t\tfatal(\"mm_memvalid: end < address: %p < %p\", end, address);\n\tif (end > MM_ADDRESS_END(mm))\n\t\tfatal(\"mm_memvalid: address too large: %p\", address);\n}", "target": 1}
{"code": "static void oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tif (cfg->scrub_request_headers != 0) {\n\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n\t\t\t\toidc_cfg_dir_authn_header(r));\n\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n\t\t\t\t!= cfg->claim_prefix)) {\n\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n\t\t}\n\t}\n}", "target": 1}
{"code": "void ZydisFormatterBufferInitTokenized(ZydisFormatterBuffer* buffer,\n    ZydisFormatterToken** first_token, void* user_buffer, ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(first_token);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n    *first_token = user_buffer;\n    (*first_token)->type = ZYDIS_TOKEN_INVALID;\n    (*first_token)->next = 0;\n    user_buffer = (ZyanU8*)user_buffer + sizeof(ZydisFormatterToken);\n    length -= sizeof(ZydisFormatterToken);\n    buffer->is_token_list              = ZYAN_TRUE;\n    buffer->capacity                   = length;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *(char*)user_buffer = '\\0';\n}", "target": 1}
{"code": "TfLiteRegistration GetPassthroughOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.init = [](TfLiteContext* context, const char*, size_t) -> void* {\n    auto* first_new_tensor = new int;\n    context->AddTensors(context, 2, first_new_tensor);\n    return first_new_tensor;\n  };\n  reg.free = [](TfLiteContext* context, void* buffer) {\n    delete static_cast<int*>(buffer);\n  };\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    auto* first_new_tensor = static_cast<int*>(node->user_data);\n    const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n    TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n    TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, tensor1, newSize));\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(2);\n    for (int i = 0; i < 2; ++i) {\n      node->temporaries->data[i] = *(first_new_tensor) + i;\n    }\n    auto setup_temporary = [&](int id) {\n      TfLiteTensor* tmp = &context->tensors[id];\n      tmp->type = kTfLiteFloat32;\n      tmp->allocation_type = kTfLiteArenaRw;\n      return context->ResizeTensor(context, tmp,\n                                   TfLiteIntArrayCopy(tensor0->dims));\n    };\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[0]));\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[1]));\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    auto populate = [&](int id) {\n      TfLiteTensor* t = &context->tensors[id];\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        t->data.f[i] = a0->data.f[i];\n      }\n    };\n    populate(node->outputs->data[0]);\n    populate(node->temporaries->data[0]);\n    populate(node->temporaries->data[1]);\n    return kTfLiteOk;\n  };\n  return reg;\n}", "target": 1}
{"code": "int fit_config_verify_required_sigs(const void *fit, int conf_noffset,\n\t\t\t\t    const void *sig_blob)\n{\n\tint noffset;\n\tint sig_node;\n\tint verified = 0;\n\tint reqd_sigs = 0;\n\tbool reqd_policy_all = true;\n\tconst char *reqd_mode;\n\tsig_node = fdt_subnode_offset(sig_blob, 0, FIT_SIG_NODENAME);\n\tif (sig_node < 0) {\n\t\tdebug(\"%s: No signature node found: %s\\n\", __func__,\n\t\t      fdt_strerror(sig_node));\n\t\treturn 0;\n\t}\n\treqd_mode = fdt_getprop(sig_blob, sig_node, \"required-mode\", NULL);\n\tif (reqd_mode && !strcmp(reqd_mode, \"any\"))\n\t\treqd_policy_all = false;\n\tdebug(\"%s: required-mode policy set to '%s'\\n\", __func__,\n\t      reqd_policy_all ? \"all\" : \"any\");\n\tfdt_for_each_subnode(noffset, sig_blob, sig_node) {\n\t\tconst char *required;\n\t\tint ret;\n\t\trequired = fdt_getprop(sig_blob, noffset, FIT_KEY_REQUIRED,\n\t\t\t\t       NULL);\n\t\tif (!required || strcmp(required, \"conf\"))\n\t\t\tcontinue;\n\t\treqd_sigs++;\n\t\tret = fit_config_verify_sig(fit, conf_noffset, sig_blob,\n\t\t\t\t\t    noffset);\n\t\tif (ret) {\n\t\t\tif (reqd_policy_all) {\n\t\t\t\tprintf(\"Failed to verify required signature '%s'\\n\",\n\t\t\t\t       fit_get_name(sig_blob, noffset, NULL));\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tverified++;\n\t\t\tif (!reqd_policy_all)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (reqd_sigs && !verified) {\n\t\tprintf(\"Failed to verify 'any' of the required signature(s)\\n\");\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "smix(uint8_t * B, size_t r, uint64_t N, uint32_t * V, uint32_t * XY)\n{\n  uint32_t * X = XY;\n  uint32_t * Y = &XY[32 * r];\n  uint32_t * Z = &XY[64 * r];\n  uint64_t i;\n  uint64_t j;\n  size_t k;\n  for (k = 0; k < 32 * r; k++) {\n    X[k] = folly::Endian::little32(*((uint32_t *) &B[4 * k]));\n  }\n  for (i = 0; i < N; i += 2) {\n    blkcpy(&V[i * (32 * r)], X, 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    blkcpy(&V[(i + 1) * (32 * r)], Y, 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (i = 0; i < N; i += 2) {\n    j = integerify(X, r) & (N - 1);\n    blkxor(X, &V[j * (32 * r)], 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    j = integerify(Y, r) & (N - 1);\n    blkxor(Y, &V[j * (32 * r)], 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (k = 0; k < 32 * r; k++) {\n    *((uint32_t *) &B[4 * k]) = folly::Endian::little32(X[k]);\n  }\n}", "target": 1}
{"code": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\tspin_lock_init(&hsr->seqnr_lock);\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\thsr->protVersion = protocol_version;\n\tnetif_carrier_off(hsr_dev);\n\tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n\tif (res)\n\t\treturn res;\n\tres = register_netdevice(hsr_dev);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\treturn 0;\nfail:\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\n\treturn res;\n}", "target": 1}
{"code": "display_dollar(colnr_T col)\n{\n    colnr_T save_col;\n    if (!redrawing())\n\treturn;\n    cursor_off();\n    save_col = curwin->w_cursor.col;\n    curwin->w_cursor.col = col;\n    if (has_mbyte)\n    {\n\tchar_u *p;\n\tp = ml_get_curline();\n\tcurwin->w_cursor.col -= (*mb_head_off)(p, p + col);\n    }\n    curs_columns(FALSE);\t    \n    if (curwin->w_wcol < curwin->w_width)\n    {\n\tedit_putchar('$', FALSE);\n\tdollar_vcol = curwin->w_virtcol;\n    }\n    curwin->w_cursor.col = save_col;\n}", "target": 1}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 1}
{"code": "uint32_t skip(Protocol_& prot, TType type) {\n  switch (type) {\n  case T_BOOL: {\n    bool boolv;\n    return prot.readBool(boolv);\n  }\n  case T_BYTE: {\n    int8_t bytev;\n    return prot.readByte(bytev);\n  }\n  case T_I16: {\n    int16_t i16;\n    return prot.readI16(i16);\n  }\n  case T_I32: {\n    int32_t i32;\n    return prot.readI32(i32);\n  }\n  case T_I64: {\n    int64_t i64;\n    return prot.readI64(i64);\n  }\n  case T_DOUBLE: {\n    double dub;\n    return prot.readDouble(dub);\n  }\n  case T_STRING: {\n    std::string str;\n    return prot.readBinary(str);\n  }\n  case T_STRUCT: {\n    uint32_t result = 0;\n    std::string name;\n    int16_t fid;\n    TType ftype;\n    result += prot.readStructBegin(name);\n    while (true) {\n      result += prot.readFieldBegin(name, ftype, fid);\n      if (ftype == T_STOP) {\n        break;\n      }\n      result += skip(prot, ftype);\n      result += prot.readFieldEnd();\n    }\n    result += prot.readStructEnd();\n    return result;\n  }\n  case T_MAP: {\n    uint32_t result = 0;\n    TType keyType;\n    TType valType;\n    uint32_t i, size;\n    result += prot.readMapBegin(keyType, valType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, keyType);\n      result += skip(prot, valType);\n    }\n    result += prot.readMapEnd();\n    return result;\n  }\n  case T_SET: {\n    uint32_t result = 0;\n    TType elemType;\n    uint32_t i, size;\n    result += prot.readSetBegin(elemType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, elemType);\n    }\n    result += prot.readSetEnd();\n    return result;\n  }\n  case T_LIST: {\n    uint32_t result = 0;\n    TType elemType;\n    uint32_t i, size;\n    result += prot.readListBegin(elemType, size);\n    for (i = 0; i < size; i++) {\n      result += skip(prot, elemType);\n    }\n    result += prot.readListEnd();\n    return result;\n  }\n  case T_STOP:\n  case T_VOID:\n  case T_U64:\n  case T_UTF8:\n  case T_UTF16:\n    break;\n  }\n  return 0;\n}", "target": 1}
{"code": "MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    const char *needle1 = \"filepos=\";\n    const char *needle2 = \"recindex=\";\n    const size_t needle1_length = strlen(needle1);\n    const size_t needle2_length = strlen(needle2);\n    const size_t needle_length = max(needle1_length,needle2_length);\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    const unsigned char tag_open = '<';\n    const unsigned char tag_close = '>';\n    unsigned char last_border = tag_open;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end &&\n            (memcmp(data, needle1, needle1_length) == 0 ||\n             memcmp(data, needle2, needle2_length) == 0)) {\n                if (last_border != tag_open) {\n                    data += needle_length;\n                    continue;\n                }\n                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                if (*(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n    for (file = (XkbFile *) file->defs; file;\n          file = (XkbFile *) file->common.next) {\n         if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n             file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n             continue;\n         }\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        files[file->file_type] = file;\n    }\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n    return UpdateDerivedKeymapFields(keymap);\n}", "target": 1}
{"code": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  int len;\n  if(!*path)\n    path = \"INBOX\";\n  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n  if(!imapc->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n  return CURLE_OK;\n}", "target": 1}
{"code": "  void encode(bufferlist& bl) const {\n    __u8 struct_v = 1;\n    ::encode(struct_v, bl);\n    ::encode(nonce, bl);\n  }", "target": 1}
{"code": "WORD32 ihevcd_create(iv_obj_t *ps_codec_obj,\n                            void *pv_api_ip,\n                            void *pv_api_op)\n {\n     ihevcd_cxa_create_op_t *ps_create_op;\n     WORD32 ret;\n     codec_t *ps_codec;\n     ps_create_op = (ihevcd_cxa_create_op_t *)pv_api_op;\n     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n     ret = ihevcd_allocate_static_bufs(&ps_codec_obj, pv_api_ip, pv_api_op);\n    if((IV_FAIL == ret) && (NULL != ps_codec_obj))\n     {\n        ihevcd_free_static_bufs(ps_codec_obj);\n         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n return IV_FAIL;\n }\n    ps_codec = (codec_t *)ps_codec_obj->pv_codec_handle;\n    ret = ihevcd_init(ps_codec);\n    TRACE_INIT(NULL);\n    STATS_INIT();\n return ret;\n}", "target": 1}
{"code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\treturn 0;\n}", "target": 1}
{"code": "void processInputBuffer(client *c) {\n    server.current_client = c;\n    while(sdslen(c->querybuf)) {\n        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;\n        if (c->flags & CLIENT_BLOCKED) break;\n        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;\n         if (!c->reqtype) {\n            if (c->querybuf[0] == '*') {\n                c->reqtype = PROTO_REQ_MULTIBULK;\n            } else {\n                c->reqtype = PROTO_REQ_INLINE;\n            }\n        }\n        if (c->reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;\n        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break;\n        } else {\n            serverPanic(\"Unknown request type\");\n        }\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            if (processCommand(c) == C_OK)\n                resetClient(c);\n            if (server.current_client == NULL) break;\n        }\n    }\n    server.current_client = NULL;\n}", "target": 1}
{"code": "snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find_next(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "xmlDocPtr soap_xmlParseMemory(const void *buf, size_t buf_size)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n */\n        ctxt = xmlCreateMemoryParserCtxt(buf, buf_size);\n        if (ctxt) {\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n#if LIBXML_VERSION >= 20703\n\t\tctxt->options |= XML_PARSE_HUGE;\n#endif\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int can_open_cached(struct nfs4_state *state, int mode)\n{\n\tint ret = 0;\n\tswitch (mode & (FMODE_READ|FMODE_WRITE|O_EXCL)) {\n\t\tcase FMODE_READ:\n\t\t\tret |= test_bit(NFS_O_RDONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_WRONLY_STATE, &state->flags) != 0;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tret |= test_bit(NFS_O_RDWR_STATE, &state->flags) != 0;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bool extractPages (const char *srcFileName, const char *destFileName) {\n  char pathName[4096];\n  GooString *gfileName = new GooString (srcFileName);\n  PDFDoc *doc = new PDFDoc (gfileName, NULL, NULL, NULL);\n  if (!doc->isOk()) {\n    error(errSyntaxError, -1, \"Could not extract page(s) from damaged file ('{0:s}')\", srcFileName);\n    return false;\n  }\n  if (firstPage == 0 && lastPage == 0) {\n    firstPage = 1;\n    lastPage = doc->getNumPages();\n  }\n  if (lastPage == 0)\n    lastPage = doc->getNumPages();\n  if (firstPage == 0)\n   if (firstPage == 0)\n     firstPage = 1;\n   if (firstPage != lastPage && strstr(destFileName, \"%d\") == NULL) {\n    error(errSyntaxError, -1, \"'{0:s}' must contain '%%d' if more than one page should be extracted\", destFileName);\n     return false;\n   }\n   for (int pageNo = firstPage; pageNo <= lastPage; pageNo++) {\n     snprintf (pathName, sizeof (pathName) - 1, destFileName, pageNo);\n     GooString *gpageName = new GooString (pathName);\n\t{\n\t  printUsage (\"pdfseparate\", \"<PDF-sourcefile> <PDF-pattern-destfile>\",\n\t\t      argDesc);\n\t}\n      if (printVersion || printHelp)\n\texitCode = 0;\n      goto err0;\n    }\n  globalParams = new GlobalParams();\n  ok = extractPages (argv[1], argv[2]);\n  if (ok) {\n    exitCode = 0;\n  }\n  delete globalParams;\nerr0:\n  return exitCode;\n}", "target": 1}
{"code": "evbuffer_add(struct evbuffer *buf, const void *data_in, size_t datlen)\n{\n\tstruct evbuffer_chain *chain, *tmp;\n\tconst unsigned char *data = data_in;\n\tsize_t remain, to_alloc;\n\tint result = -1;\n\tEVBUFFER_LOCK(buf);\n\tif (buf->freeze_end) {\n\t\tgoto done;\n\t}\n\tchain = buf->last;\n\tif (chain == NULL) {\n\t\tchain = evbuffer_chain_new(datlen);\n\t\tif (!chain)\n\t\t\tgoto done;\n\t\tevbuffer_chain_insert(buf, chain);\n\t}\n\tif ((chain->flags & EVBUFFER_IMMUTABLE) == 0) {\n\t\tremain = (size_t)(chain->buffer_len - chain->misalign - chain->off);\n\t\tif (remain >= datlen) {\n\t\t\tmemcpy(chain->buffer + chain->misalign + chain->off,\n\t\t\t    data, datlen);\n\t\t\tchain->off += datlen;\n\t\t\tbuf->total_len += datlen;\n\t\t\tbuf->n_add_for_cb += datlen;\n\t\t\tgoto out;\n\t\t} else if (!CHAIN_PINNED(chain) &&\n\t\t    evbuffer_chain_should_realign(chain, datlen)) {\n\t\t\tevbuffer_chain_align(chain);\n\t\t\tmemcpy(chain->buffer + chain->off, data, datlen);\n\t\t\tchain->off += datlen;\n\t\t\tbuf->total_len += datlen;\n\t\t\tbuf->n_add_for_cb += datlen;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tremain = 0;\n\t}\n\tto_alloc = chain->buffer_len;\n\tif (to_alloc <= EVBUFFER_CHAIN_MAX_AUTO_SIZE/2)\n\t\tto_alloc <<= 1;\n\tif (datlen > to_alloc)\n\t\tto_alloc = datlen;\n\ttmp = evbuffer_chain_new(to_alloc);\n\tif (tmp == NULL)\n\t\tgoto done;\n\tif (remain) {\n\t\tmemcpy(chain->buffer + chain->misalign + chain->off,\n\t\t    data, remain);\n\t\tchain->off += remain;\n\t\tbuf->total_len += remain;\n\t\tbuf->n_add_for_cb += remain;\n\t}\n\tdata += remain;\n\tdatlen -= remain;\n\tmemcpy(tmp->buffer, data, datlen);\n\ttmp->off = datlen;\n\tevbuffer_chain_insert(buf, tmp);\n\tbuf->n_add_for_cb += datlen;\nout:\n\tevbuffer_invoke_callbacks_(buf);\n\tresult = 0;\ndone:\n\tEVBUFFER_UNLOCK(buf);\n\treturn result;\n}", "target": 1}
{"code": "smtp_log_to_file(smtp_t *smtp)\n{\n\tFILE *fp = fopen(\"/tmp/smtp-alert.log\", \"a\");\n\ttime_t now;\n\tstruct tm tm;\n\tchar time_buf[25];\n\tint time_buf_len;\n\ttime(&now);\n\tlocaltime_r(&now, &tm);\n\ttime_buf_len = strftime(time_buf, sizeof time_buf, \"%a %b %e %X %Y\", &tm);\n\tfprintf(fp, \"%s: %s -> %s\\n\"\n\t\t    \"%*sSubject: %s\\n\"\n\t\t    \"%*sBody:    %s\\n\\n\",\n\t\t    time_buf, global_data->email_from, smtp->email_to,\n\t\t    time_buf_len - 7, \"\", smtp->subject,\n\t\t    time_buf_len - 7, \"\", smtp->body);\n\tfclose(fp);\n\tfree_smtp_all(smtp);\n}", "target": 1}
{"code": "int line6_init_pcm(struct usb_line6 *line6,\n\t\t   struct line6_pcm_properties *properties)\n{\n\tint i, err;\n\tunsigned ep_read = line6->properties->ep_audio_r;\n\tunsigned ep_write = line6->properties->ep_audio_w;\n\tstruct snd_pcm *pcm;\n\tstruct snd_line6_pcm *line6pcm;\n\tif (!(line6->properties->capabilities & LINE6_CAP_PCM))\n\t\treturn 0;\t\n\terr = snd_line6_new_pcm(line6, &pcm);\n\tif (err < 0)\n\t\treturn err;\n\tline6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL);\n\tif (!line6pcm)\n\t\treturn -ENOMEM;\n\tmutex_init(&line6pcm->state_mutex);\n\tline6pcm->pcm = pcm;\n\tline6pcm->properties = properties;\n\tline6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255;\n\tline6pcm->volume_monitor = 255;\n\tline6pcm->line6 = line6;\n\tline6pcm->max_packet_size_in =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_rcvisocpipe(line6->usbdev, ep_read), 0);\n\tline6pcm->max_packet_size_out =\n\t\tusb_maxpacket(line6->usbdev,\n\t\t\tusb_sndisocpipe(line6->usbdev, ep_write), 1);\n\tspin_lock_init(&line6pcm->out.lock);\n\tspin_lock_init(&line6pcm->in.lock);\n\tline6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD;\n\tline6->line6pcm = line6pcm;\n\tpcm->private_data = line6pcm;\n\tpcm->private_free = line6_cleanup_pcm;\n\terr = line6_create_audio_out_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\terr = line6_create_audio_in_urbs(line6pcm);\n\tif (err < 0)\n\t\treturn err;\n\tfor (i = 0; i < ARRAY_SIZE(line6_controls); i++) {\n\t\terr = snd_ctl_add(line6->card,\n\t\t\t\t  snd_ctl_new1(&line6_controls[i], line6pcm));\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "Status UncompressElement(const CompressedElement& compressed,\n                         std::vector<Tensor>* out) {\n  int num_components = compressed.component_metadata_size();\n  out->clear();\n  out->reserve(num_components);\n  std::vector<struct iovec> iov(num_components);\n  std::vector<tstring> tensor_proto_strs;\n  tensor_proto_strs.reserve(num_components);\n  int64 total_size = 0;\n  for (int i = 0; i < num_components; ++i) {\n    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      iov[i].iov_base = buffer->data();\n      iov[i].iov_len = buffer->size();\n    } else {\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();\n      tstring& tensor_proto_str = tensor_proto_strs.back();\n      tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes());\n      iov[i].iov_base = tensor_proto_str.mdata();\n      iov[i].iov_len = tensor_proto_str.size();\n    }\n    total_size += iov[i].iov_len;\n  }\n  const std::string& compressed_data = compressed.data();\n  size_t uncompressed_size;\n  if (!port::Snappy_GetUncompressedLength(\n          compressed_data.data(), compressed_data.size(), &uncompressed_size)) {\n    return errors::Internal(\n        \"Could not get snappy uncompressed length. Compressed data size: \",\n        compressed_data.size());\n  }\n  if (uncompressed_size != static_cast<size_t>(total_size)) {\n    return errors::Internal(\n        \"Uncompressed size mismatch. Snappy expects \", uncompressed_size,\n        \" whereas the tensor metadata suggests \", total_size);\n  }\n  if (!port::Snappy_UncompressToIOVec(compressed_data.data(),\n                                      compressed_data.size(), iov.data(),\n                                      num_components)) {\n    return errors::Internal(\"Failed to perform snappy decompression.\");\n  }\n  int tensor_proto_strs_index = 0;\n  for (int i = 0; i < num_components; ++i) {\n    if (DataTypeCanUseMemcpy(compressed.component_metadata(i).dtype())) {\n      continue;\n    }\n    TensorProto tp;\n    if (!tp.ParseFromString(tensor_proto_strs[tensor_proto_strs_index++])) {\n      return errors::Internal(\"Could not parse TensorProto\");\n    }\n    if (!out->at(i).FromProto(tp)) {\n      return errors::Internal(\"Could not parse Tensor\");\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\tusb_msg.dlc = cf->len;\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\treturn NETDEV_TX_OK;\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "QSqlRecord QODBCDriver::record(const QString& tablename) const\n{\n    Q_D(const QODBCDriver);\n    QSqlRecord fil;\n    if (!isOpen())\n        return fil;\n    SQLHANDLE hStmt;\n    QString catalog, schema, table;\n    const_cast<QODBCDriverPrivate*>(d)->splitTableQualifier(tablename, catalog, schema, table);\n    if (isIdentifierEscaped(catalog, QSqlDriver::TableName))\n        catalog = stripDelimiters(catalog, QSqlDriver::TableName);\n    else\n        catalog = d->adjustCase(catalog);\n    if (isIdentifierEscaped(schema, QSqlDriver::TableName))\n        schema = stripDelimiters(schema, QSqlDriver::TableName);\n    else\n        schema = d->adjustCase(schema);\n    if (isIdentifierEscaped(table, QSqlDriver::TableName))\n        table = stripDelimiters(table, QSqlDriver::TableName);\n    else\n        table = d->adjustCase(table);\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::record: Unable to allocate handle\"_L1, d);\n        return fil;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    r =  SQLColumns(hStmt,\n                     catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),\n                     catalog.length(),\n                     schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),\n                     schema.length(),\n                     toSQLTCHAR(table).data(),\n                     table.length(),\n                     NULL,\n                     0);\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::record: Unable to execute column list\"_L1, d);\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n    while (r == SQL_SUCCESS) {\n        fil.append(qMakeFieldInfo(hStmt, d));\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle \"_L1 + QString::number(r), d);\n    return fil;\n}", "target": 1}
{"code": "struct sock *inet_csk_clone_lock(const struct sock *sk,\n\t\t\t\t const struct request_sock *req,\n\t\t\t\t const gfp_t priority)\n{\n\tstruct sock *newsk = sk_clone_lock(sk, priority);\n\tif (newsk) {\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\t\tnewsk->sk_state = TCP_SYN_RECV;\n\t\tnewicsk->icsk_bind_hash = NULL;\n\t\tinet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;\n\t\tinet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;\n\t\tinet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);\n\t\tnewsk->sk_write_space = sk_stream_write_space;\n \t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n \t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n \t\tatomic64_set(&newsk->sk_cookie,\n \t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));\n\t\tnewicsk->icsk_retransmits = 0;\n\t\tnewicsk->icsk_backoff\t  = 0;\n\t\tnewicsk->icsk_probes_out  = 0;\n\t\tmemset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));\n\t\tsecurity_inet_csk_clone(newsk, req);\n\t}\n\treturn newsk;\n}", "target": 1}
{"code": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n \tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n \tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n \tif( !load->real ) {\n \t\tif( !(load->real = vips_foreign_load_temp( load )) )\n \t\t\treturn( NULL );\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif \n\t\tload->real->progress_signal = load->out;\n \t\tg_object_set_qdata( G_OBJECT( load->real ), \n \t\t\tvips__foreign_load_operation, load ); \n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n \t\t\treturn( NULL );\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\treturn( vips_region_new( load->real ) );\n}", "target": 1}
{"code": "xcalloc (size_t num, size_t size)\n{\n    void *ptr = malloc(num * size);\n    if (ptr)\n    {\n        memset (ptr, '\\0', (num * size));\n    }\n    return ptr;\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictFusedBatchNorm(\n    const OpContext& op_context, NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  const bool is_training = IsTraining(op_info);\n  int64_t ops = 0;\n  const auto rsqrt_cost = Eigen::internal::functor_traits<\n      Eigen::internal::scalar_rsqrt_op<float>>::Cost;\n  if (is_training) {\n    ops = dims.iz * (dims.batch * dims.ix * dims.iy * 4 + 6 + rsqrt_cost);\n  } else {\n    ops = dims.batch * dims.ix * dims.iy * dims.iz * 2;\n  }\n  node_costs->num_compute_ops = ops;\n  const int64_t size_nhwc =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  const int64_t size_c =\n      CalculateTensorSize(op_info.inputs(1), &found_unknown_shapes);\n  if (is_training) {\n    node_costs->num_input_bytes_accessed = {size_nhwc, size_c, size_c};\n    node_costs->num_output_bytes_accessed = {size_nhwc, size_c, size_c, size_c,\n                                             size_c};\n    node_costs->internal_read_bytes = size_nhwc;\n  } else {\n    node_costs->num_input_bytes_accessed = {size_nhwc, size_c, size_c, size_c,\n                                            size_c};\n    node_costs->num_output_bytes_accessed = {size_nhwc};\n  }\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static Jsi_RC NumberToExponentialCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMEFMT, prec, num);\n#ifdef __WIN32\n    char *e = strrchr(buf, 'e');\n    if (e && (e[1]=='+' || e[1]=='-')) {\n        e++;\n        int eNum = atoi(e);\n        if (e[0]=='-')\n            eNum = -eNum;\n        e++;\n        snprintf(e, (e-buf), \"%02d\", eNum);\n    }\n#endif\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_tensor = context->input(0);\n    const auto input_tensor_flat = input_tensor.flat<int32>();\n    const Tensor& input_splits = context->input(1);\n    const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n    OP_REQUIRES(\n        context, input_splits_flat(0) == 0,\n        errors::InvalidArgument(\"First value in input_splits must be zero.\"));\n    OP_REQUIRES(context,\n                input_splits_flat(input_splits_flat.size() - 1) ==\n                    input_tensor_flat.size(),\n                errors::InvalidArgument(\"Last value in input_splits must be \"\n                                        \"equal to length of input_tensor.\"));\n    TensorShape output_shape({input_splits.dim_size(0) - 1});\n    Tensor* output_tensor;\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n    auto output_tensor_flat = output_tensor->flat<tstring>();\n    int idx = 0;\n    for (int i = 1; i < input_splits_flat.size(); ++i) {\n      icu::UnicodeString unicode_string;\n      icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n      OP_REQUIRES(\n          context, input_splits_flat(i - 1) <= input_splits_flat(i),\n          errors::InvalidArgument(\n              \"Values in input_splits must be equal or in ascending order.\"));\n      OP_REQUIRES(\n          context, input_splits_flat(i) <= input_tensor_flat.size(),\n          errors::InvalidArgument(\"Values in input_splits must be less than or \"\n                                  \"equal to input_tensor length.\"));\n      for (; idx < input_splits_flat(i); ++idx) {\n        int32_t code_point = input_tensor_flat(idx);\n        if (!U_IS_UNICODE_CHAR(code_point)) {\n          if (error_options_.error_on_malformatting) {\n            context->CtxFailure(errors::InvalidArgument(\n                \"Code point is out of range for Unicode, or a noncharacter.\"));\n            return;\n          } else if (!error_options_.elide_replacement) {\n            code_point = error_options_.subst;\n          }\n        }\n        appendable_unicode_string.appendCodePoint(code_point);\n      }\n      tstring result;\n      Encode(encoding_, unicode_string, &result);\n      output_tensor_flat(i - 1) = std::move(result);\n    }\n  }", "target": 1}
{"code": "bool GetNetworkList(NetworkInterfaceList* networks, int policy) {\n  int s = socket(AF_INET, SOCK_DGRAM, 0);\n  if (s <= 0) {\n    PLOG(ERROR) << \"socket\";\n    return false;\n   }\n  uint32_t num_ifs = 0;\n  if (ioctl_netc_get_num_ifs(s, &num_ifs) < 0) {\n    PLOG(ERROR) << \"ioctl_netc_get_num_ifs\";\n    PCHECK(close(s) == 0);\n    return false;\n   }\n  for (uint32_t i = 0; i < num_ifs; ++i) {\n    netc_if_info_t interface;\n    if (ioctl_netc_get_if_info_at(s, &i, &interface) < 0) {\n      PLOG(WARNING) << \"ioctl_netc_get_if_info_at\";\n      continue;\n    }\n    if (internal::IsLoopbackOrUnspecifiedAddress(\n            reinterpret_cast<sockaddr*>(&(interface.addr)))) {\n       continue;\n    }\n    IPEndPoint address;\n    if (!address.FromSockAddr(reinterpret_cast<sockaddr*>(&(interface.addr)),\n                              sizeof(interface.addr))) {\n      DLOG(WARNING) << \"ioctl_netc_get_if_info returned invalid address.\";\n       continue;\n    }\n    int prefix_length = 0;\n    IPEndPoint netmask;\n    if (netmask.FromSockAddr(reinterpret_cast<sockaddr*>(&(interface.netmask)),\n                             sizeof(interface.netmask))) {\n      prefix_length = MaskPrefixLength(netmask.address());\n    }\n     int attributes = 0;\n    networks->push_back(\n        NetworkInterface(interface.name, interface.name, interface.index,\n                         NetworkChangeNotifier::CONNECTION_UNKNOWN,\n                         address.address(), prefix_length, attributes));\n   }\n  PCHECK(close(s) == 0);\n   return true;\n }", "target": 1}
{"code": "R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAnnotation *annotation = NULL;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tannotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\tfor (i = 0; i < annotation->num_element_value_pairs; i++) {\n\t\tif (offset > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tevps = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (evps) {\n\t\t\toffset += evps->size;\n\t\t\tr_list_append (annotation->element_value_pairs, (void *) evps);\n\t\t}\n\t}\n\tannotation->size = offset;\n\treturn annotation;\n}", "target": 1}
{"code": "static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tif (fault_in_pages_writeable(iov->iov_base, this_len))\n\t\t\tbreak;\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n{\n\t__issue_discard_cmd(sbi, false);\n\t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, false);\n}", "target": 1}
{"code": "static void ip_expire(unsigned long arg)\n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\tspin_lock(&qp->q.lock);\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\tipq_kill(qp);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n \tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n \t\tstruct sk_buff *head = qp->q.fragments;\n \t\trcu_read_lock();\n \t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n \t\tif (!head->dev)\n \t\t\tgoto out_rcu_unlock;\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n\t\t}\n \t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}", "target": 1}
{"code": "static int uvc_scan_chain_forward(struct uvc_video_chain *chain,\n\tstruct uvc_entity *entity, struct uvc_entity *prev)\n{\n\tstruct uvc_entity *forward;\n\tint found;\n\tforward = NULL;\n\tfound = 0;\n\twhile (1) {\n\t\tforward = uvc_entity_by_reference(chain->dev, entity->id,\n\t\t\tforward);\n\t\tif (forward == NULL)\n\t\t\tbreak;\n\t\tif (forward == prev)\n\t\t\tcontinue;\n\t\tswitch (UVC_ENTITY_TYPE(forward)) {\n\t\tcase UVC_VC_EXTENSION_UNIT:\n\t\t\tif (forward->bNrInPins != 1) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Extension unit %d \"\n\t\t\t\t\t  \"has more than 1 input pin.\\n\",\n\t\t\t\t\t  entity->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n\t\t\t\tif (!found)\n\t\t\t\t\tprintk(KERN_CONT \" (->\");\n\t\t\t\tprintk(KERN_CONT \" XU %d\", forward->id);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase UVC_OTT_VENDOR_SPECIFIC:\n\t\tcase UVC_OTT_DISPLAY:\n\t\tcase UVC_OTT_MEDIA_TRANSPORT_OUTPUT:\n\t\tcase UVC_TT_STREAMING:\n\t\t\tif (UVC_ENTITY_IS_ITERM(forward)) {\n\t\t\t\tuvc_trace(UVC_TRACE_DESCR, \"Unsupported input \"\n\t\t\t\t\t\"terminal %u.\\n\", forward->id);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tlist_add_tail(&forward->chain, &chain->entities);\n\t\t\tif (uvc_trace_param & UVC_TRACE_PROBE) {\n\t\t\t\tif (!found)\n\t\t\t\t\tprintk(KERN_CONT \" (->\");\n\t\t\t\tprintk(KERN_CONT \" OT %d\", forward->id);\n\t\t\t\tfound = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (found)\n\t\tprintk(KERN_CONT \")\");\n\treturn 0;\n}", "target": 1}
{"code": "monitor_apply_keystate(struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t\n\tstruct kex *kex;\n\tint r;\n\tdebug3(\"%s: packet_set_state\", __func__);\n\tif ((r = ssh_packet_set_state(ssh, child_state)) != 0)\n                fatal(\"%s: packet_set_state: %s\", __func__, ssh_err(r));\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n\tif ((kex = ssh->kex) != NULL) {\n#ifdef WITH_OPENSSL\n\t\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n\t\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\t\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\t\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\t\tkex->host_key_index=&get_hostkey_index;\n\t\tkex->sign = sshd_hostkey_sign;\n\t}\n\tif (options.compression) {\n\t\tssh_packet_set_compress_hooks(ssh, pmonitor->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n}", "target": 1}
{"code": "  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size =\n        prefix_size + internal::to_unsigned(spec.precision());\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    CharPtr result = prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size);\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    return result;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::uninitialized_fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::uninitialized_fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}", "target": 1}
{"code": "ansi_step(pansi, ch)\n\tstruct ansi_state *pansi;\n\tLWCHAR ch;\n{\n\tif (pansi->hlink)\n\t{\n\t\tif (ch == '\\7')\n\t\t\treturn ANSI_END;\n\t\tif (pansi->prev_esc && ch == '\\\\')\n\t\t\treturn ANSI_END;\n\t\tpansi->prev_esc = (ch == ESC);\n\t\treturn ANSI_MID;\n\t}\n\tif (pansi->hindex >= 0)\n\t{\n\t\tstatic char hlink_prefix[] = ESCS \"]8;\";\n\t\tif (ch == hlink_prefix[pansi->hindex] ||\n\t\t    (pansi->hindex == 0 && IS_CSI_START(ch)))\n\t\t{\n\t\t\tpansi->hindex++;\n\t\t\tif (hlink_prefix[pansi->hindex] == '\\0')\n\t\t\t\tpansi->hlink = 1; \n\t\t\treturn ANSI_MID;\n\t\t}\n\t\tpansi->hindex = -1; \n\t}\n\tif (is_ansi_middle(ch))\n\t\treturn ANSI_MID;\n\tif (is_ansi_end(ch))\n\t\treturn ANSI_END;\n\treturn ANSI_ERR;\n}", "target": 1}
{"code": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && !ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && !ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (struct pgstate *)io;\n\t}\n\treturn ((u_char *)ps <= ep? 0 : -1);\n}", "target": 1}
{"code": "int af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len)\n{\n\tsize_t off;\n\tssize_t n;\n\tint npages, i;\n\tn = iov_iter_get_pages(iter, sgl->pages, len, ALG_MAX_PAGES, &off);\n\tif (n < 0)\n\t\treturn n;\n\tnpages = PAGE_ALIGN(off + n);\n\tif (WARN_ON(npages == 0))\n\t\treturn -EINVAL;\n\tsg_init_table(sgl->sg, npages);\n\tfor (i = 0, len = n; i < npages; i++) {\n\t\tint plen = min_t(int, len, PAGE_SIZE - off);\n\t\tsg_set_page(sgl->sg + i, sgl->pages[i], plen, off);\n\t\toff = 0;\n\t\tlen -= plen;\n\t}\n\treturn n;\n}", "target": 1}
{"code": "static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\tclient->auth_user = client->db->auth_user;\n\tclient->pool = get_pool(client->db, client->db->auth_user);\n\tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}", "target": 1}
{"code": "nfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n                 int flags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct nfs4_state *state;\n\tstruct rpc_cred *cred;\n\tint status = 0;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred)) {\n\t\tstatus = PTR_ERR(cred);\n\t\tgoto out;\n\t}\n\tstate = nfs4_do_open(dir, &path, flags, sattr, cred);\n\td_drop(dentry);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out_putcred;\n\t}\n\td_add(dentry, igrab(state->inode));\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tif (flags & O_EXCL) {\n\t\tstruct nfs_fattr fattr;\n\t\tstatus = nfs4_do_setattr(state->inode, cred, &fattr, sattr, state);\n\t\tif (status == 0)\n\t\t\tnfs_setattr_update_inode(state->inode, sattr);\n\t\tnfs_post_op_update_inode(state->inode, &fattr);\n\t}\n\tif (status == 0 && (nd->flags & LOOKUP_OPEN) != 0)\n\t\tstatus = nfs4_intent_set_file(nd, &path, state);\n\telse\n\t\tnfs4_close_sync(&path, state, flags);\nout_putcred:\n\tput_rpccred(cred);\nout:\n\treturn status;\n}", "target": 1}
{"code": "static int em_fxsave(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tsize_t size;\n\tint rc;\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->ops->get_fpu(ctxt);\n\trc = asm_safe(\"fxsave %[fx]\", , [fx] \"+m\"(fx_state));\n\tctxt->ops->put_fpu(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)\n\t\tsize = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);\n\telse\n\t\tsize = offsetof(struct fxregs_state, xmm_space[0]);\n\treturn segmented_write(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n}", "target": 1}
{"code": "static ssize_t aio_poll(struct aio_kiocb *aiocb, const struct iocb *iocb)\n{\n\tstruct kioctx *ctx = aiocb->ki_ctx;\n\tstruct poll_iocb *req = &aiocb->poll;\n\tstruct aio_poll_table apt;\n\t__poll_t mask;\n\tif ((u16)iocb->aio_buf != iocb->aio_buf)\n\t\treturn -EINVAL;\n\tif (iocb->aio_offset || iocb->aio_nbytes || iocb->aio_rw_flags)\n\t\treturn -EINVAL;\n\tINIT_WORK(&req->work, aio_poll_complete_work);\n\treq->events = demangle_poll(iocb->aio_buf) | EPOLLERR | EPOLLHUP;\n\treq->file = fget(iocb->aio_fildes);\n\tif (unlikely(!req->file))\n\t\treturn -EBADF;\n\treq->head = NULL;\n\treq->woken = false;\n\treq->cancelled = false;\n\tapt.pt._qproc = aio_poll_queue_proc;\n\tapt.pt._key = req->events;\n\tapt.iocb = aiocb;\n\tapt.error = -EINVAL; \n\tINIT_LIST_HEAD(&req->wait.entry);\n\tinit_waitqueue_func_entry(&req->wait, aio_poll_wake);\n\trefcount_set(&aiocb->ki_refcnt, 2);\n\tmask = vfs_poll(req->file, &apt.pt) & req->events;\n\tif (unlikely(!req->head)) {\n\t\tgoto out;\n\t}\n\tspin_lock_irq(&ctx->ctx_lock);\n\tspin_lock(&req->head->lock);\n\tif (req->woken) {\n\t\tmask = 0;\n\t\tapt.error = 0;\n\t} else if (mask || apt.error) {\n\t\tWARN_ON_ONCE(list_empty(&req->wait.entry));\n\t\tlist_del_init(&req->wait.entry);\n\t} else {\n\t\tlist_add_tail(&aiocb->ki_list, &ctx->active_reqs);\n\t\taiocb->ki_cancel = aio_poll_cancel;\n\t}\n\tspin_unlock(&req->head->lock);\n\tspin_unlock_irq(&ctx->ctx_lock);\nout:\n\tif (unlikely(apt.error)) {\n\t\tfput(req->file);\n\t\treturn apt.error;\n\t}\n\tif (mask)\n\t\taio_poll_complete(aiocb, mask);\n\tiocb_put(aiocb);\n\treturn 0;\n}", "target": 1}
{"code": "CMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n \t\treturn 0;\n \t}\n \tif (strlen(parv[1]) > 400)\n \t{\n \t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\tsptr->local->sasl_out++;\n\treturn 0;\n}", "target": 1}
{"code": "pci_set_cfgdata8(struct pci_vdev *dev, int offset, uint8_t val)\n{\n\tassert(offset <= PCI_REGMAX);\n\t*(uint8_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "  TfLiteRegistration CopyOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n      TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n      TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n      return context->ResizeTensor(context, tensor1, newSize);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      CallReporting* call_reporting =\n          static_cast<CallReporting*>(node->builtin_data);\n      const TfLiteTensor* a0 = GetInput(context, node, 0);\n      TfLiteTensor* a1 = GetOutput(context, node, 0);\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        a1->data.f[i] = a0->data.f[i];\n      }\n      call_reporting->Record();\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev,\n\t\tRBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\tbuf = parse_attr_value (buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len);\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tbool is_valid_string_form = (attribute->attr_form == DW_FORM_strp ||\n\t\t\tattribute->attr_form == DW_FORM_string) &&\n\t\t\tattribute->string.content;\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\n\tint rc;\n\tunsigned char key2[8];\n\tstruct crypto_skcipher *tfm_des;\n\tstruct scatterlist sgin, sgout;\n\tstruct skcipher_request *req;\n\tstr_to_key(key, key2);\n\ttfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_des)) {\n\t\trc = PTR_ERR(tfm_des);\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_err;\n\t}\n\treq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_free_skcipher;\n\t}\n\tcrypto_skcipher_setkey(tfm_des, key2, 8);\n\tsg_init_one(&sgin, in, 8);\n\tsg_init_one(&sgout, out, 8);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\n\trc = crypto_skcipher_encrypt(req);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);\n\tskcipher_request_free(req);\nsmbhash_free_skcipher:\n\tcrypto_free_skcipher(tfm_des);\nsmbhash_err:\n\treturn rc;\n}", "target": 1}
{"code": "p_ntp_time(netdissect_options *ndo,\n\t   const struct l_fixedpt *lfp)\n{\n\tuint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tdouble ff;\n\ti = GET_BE_U_4(lfp->int_part);\n\tuf = GET_BE_U_4(lfp->fraction);\n\tff = uf;\n\tif (ff < 0.0)\t\t\n\t\tff += FMAXINT;\n\tff = ff / FMAXINT;\t\t\t\n\tf = (uint32_t)(ff * 1000000000.0);\t\n\tND_PRINT(\"%u.%09u\", i, f);\n\tif (i) {\n\t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n\t    time_t seconds;\n\t    struct tm *tm;\n\t    char time_buf[128];\n\t    seconds = (time_t)seconds_64bit;\n\t    if (seconds != seconds_64bit) {\n\t\tND_PRINT(\" (unrepresentable)\");\n\t    } else {\n\t\ttm = gmtime(&seconds);\n\t\tif (tm == NULL) {\n\t\t    ND_PRINT(\" (unrepresentable)\");\n\t\t} else {\n\t\t    strftime(time_buf, sizeof (time_buf), \"%Y-%m-%dT%H:%M:%SZ\", tm);\n\t\t    ND_PRINT(\" (%s)\", time_buf);\n\t\t}\n\t    }\n\t}\n}", "target": 1}
{"code": "Node* Graph::AddNode(NodeDef node_def, Status* status) {\n  const OpRegistrationData* op_reg_data;\n  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));\n  if (!status->ok()) return nullptr;\n  DataTypeVector inputs;\n  DataTypeVector outputs;\n  status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));\n  if (!status->ok()) {\n    *status = AttachDef(*status, node_def);\n    return nullptr;\n  }\n  Node::NodeClass node_class = op_reg_data->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(node_def.op());\n  if (op_reg_data->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();\n    const auto ctor_type =\n        full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);\n    const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();\n    if (ctor_typedef.type_id() != TFT_UNSET) {\n      *(node_def.mutable_experimental_type()) = ctor_typedef;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();\n  }\n  Node* node = AllocateNode(std::make_shared<NodeProperties>(\n                                &op_reg_data->op_def, std::move(node_def),\n                                inputs, outputs, op_reg_data->fwd_type_fn),\n                            nullptr, node_class);\n  return node;\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\tstruct nfs4_state *state = NULL;\n\tstruct nfs_delegation *delegation;\n\tint ret;\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\tgoto out;\n\t}\n\tret = -EAGAIN;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\tgoto err;\n\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh, &data->f_attr);\n\tret = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto err;\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err_put_inode;\n\tif (data->o_res.delegation_type != 0) {\n\t\tint delegation_flags = 0;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\t\tif (delegation)\n\t\t\tdelegation_flags = delegation->flags;\n\t\trcu_read_unlock();\n\t\tif ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t\telse\n\t\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t}\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\tdata->o_arg.open_flags);\n\tiput(inode);\nout:\n\treturn state;\nerr_put_inode:\n\tiput(inode);\nerr:\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\tax25->state = AX25_STATE_0;\n\tax25_link_failed(ax25, reason);\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}", "target": 1}
{"code": "int ssl3_do_change_cipher_spec(SSL *s)\n\t{\n\tint i;\n\tconst char *sender;\n\tint slen;\n\tif (s->state & SSL_ST_ACCEPT)\n\t\ti=SSL3_CHANGE_CIPHER_SERVER_READ;\n\telse\n\t\ti=SSL3_CHANGE_CIPHER_CLIENT_READ;\n\tif (s->s3->tmp.key_block == NULL)\n\t\t{\n\t\tif (s->session == NULL) \n\t\t\t{\n\t\t\tSSLerr(SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC,SSL_R_CCS_RECEIVED_EARLY);\n\t\t\treturn (0);\n\t\t\t}\n\t\ts->session->cipher=s->s3->tmp.new_cipher;\n\t\tif (!s->method->ssl3_enc->setup_key_block(s)) return(0);\n\t\t}\n\tif (!s->method->ssl3_enc->change_cipher_state(s,i))\n\t\treturn(0);\n\tif (s->state & SSL_ST_CONNECT)\n\t\t{\n\t\tsender=s->method->ssl3_enc->server_finished_label;\n\t\tslen=s->method->ssl3_enc->server_finished_label_len;\n\t\t}\n\telse\n\t\t{\n\t\tsender=s->method->ssl3_enc->client_finished_label;\n\t\tslen=s->method->ssl3_enc->client_finished_label_len;\n\t\t}\n\ts->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,\n\t\t&(s->s3->finish_dgst1),\n\t\t&(s->s3->finish_dgst2),\n\t\tsender,slen,s->s3->tmp.peer_finish_md);\n\treturn(1);\n\t}", "target": 1}
{"code": "static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,\n        const DetectEngineTransforms *transforms, Flow *f, const struct MpmListIdDataArgs *cbdata,\n        int list_id)\n{\n    SCEnter();\n    InspectionBuffer *buffer =\n            InspectionBufferMultipleForListGet(det_ctx, list_id, cbdata->local_id);\n    if (buffer == NULL)\n        return NULL;\n    if (buffer->initialized)\n        return buffer;\n    HttpHeaderThreadData *hdr_td = NULL;\n    HttpHeaderBuffer *buf =\n            HttpHeaderGetBufferSpace(det_ctx, f, flags, g_keyword_thread_id, &hdr_td);\n    if (unlikely(buf == NULL)) {\n        return NULL;\n    }\n    htp_tx_t *tx = (htp_tx_t *)cbdata->txv;\n    htp_table_t *headers;\n    if (flags & STREAM_TOSERVER) {\n        headers = tx->request_headers;\n    } else {\n        headers = tx->response_headers;\n    }\n    if (cbdata->local_id < htp_table_size(headers)) {\n        htp_header_t *h = htp_table_get_index(headers, cbdata->local_id, NULL);\n        size_t size1 = bstr_size(h->name);\n        size_t size2 = bstr_size(h->value);\n        size_t b_len = size1 + 2 + size2;\n        if (b_len > buf->size) {\n            if (HttpHeaderExpandBuffer(hdr_td, buf, b_len) != 0) {\n                return NULL;\n            }\n        }\n        memcpy(buf->buffer, bstr_ptr(h->name), bstr_size(h->name));\n        buf->buffer[size1] = ':';\n        buf->buffer[size1 + 1] = ' ';\n        memcpy(buf->buffer + size1 + 2, bstr_ptr(h->value), bstr_size(h->value));\n        buf->len = b_len;\n    } else {\n        InspectionBufferSetupMultiEmpty(buffer);\n        return NULL;\n    }\n    if (buf->len == 0) {\n        InspectionBufferSetupMultiEmpty(buffer);\n        return NULL;\n    }\n    InspectionBufferSetupMulti(buffer, transforms, buf->buffer, buf->len);\n    SCReturnPtr(buffer, \"InspectionBuffer\");\n}", "target": 1}
{"code": "inline bool ClientImpl::write_request(Stream &strm, Request &req,\n                                      bool close_connection, Error &error) {\n  if (close_connection) {\n    if (!req.has_header(\"Connection\")) {\n      req.headers.emplace(\"Connection\", \"close\");\n    }\n  }\n  if (!req.has_header(\"Host\")) {\n    if (is_ssl()) {\n      if (port_ == 443) {\n        req.headers.emplace(\"Host\", host_);\n      } else {\n        req.headers.emplace(\"Host\", host_and_port_);\n      }\n    } else {\n      if (port_ == 80) {\n        req.headers.emplace(\"Host\", host_);\n      } else {\n        req.headers.emplace(\"Host\", host_and_port_);\n      }\n    }\n  }\n  if (!req.has_header(\"Accept\")) { req.headers.emplace(\"Accept\", \"*", "target": 1}
{"code": "    FIO_NAME(_find_map_pos_)(FIO_NAME(s) * set, FIO_SET_HASH_TYPE hash_value,\n                             FIO_SET_TYPE obj) {\n  if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n    hash_value = FIO_SET_HASH_FORCE;\n  if (set->map) {\n    if (set->has_collisions && set->pos != set->count) {\n      FIO_NAME(rehash)(set);\n    }\n    size_t full_collisions_counter = 0;\n    FIO_NAME(_map_s_) * pos;\n    const uintptr_t mask = (1ULL << set->used_bits) - 1;\n    uintptr_t i;\n    const uintptr_t hash_value_i = FIO_SET_HASH2UINTPTR(hash_value, 0);\n    uintptr_t hash_alt = FIO_SET_HASH2UINTPTR(hash_value, set->used_bits);\n    pos = set->map + (hash_alt & mask);\n    if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n      return pos;\n    if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n      if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))\n        return pos;\n      set->has_collisions = 1;\n      ++full_collisions_counter;\n    }\n    i = 0;\n    const uintptr_t limit =\n        FIO_SET_CUCKOO_STEPS * (set->capa > (FIO_SET_MAX_MAP_SEEK << 2)\n                                    ? FIO_SET_MAX_MAP_SEEK\n                                    : (set->capa >> 2));\n    while (i < limit) {\n      i += FIO_SET_CUCKOO_STEPS;\n      pos = set->map + ((hash_alt + i) & mask);\n      if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n        return pos;\n      if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n        if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))\n          return pos;\n        set->has_collisions = 1;\n        if (++full_collisions_counter >= FIO_SET_MAX_MAP_FULL_COLLISIONS) {\n          FIO_LOG_WARNING(\n              \"(fio hash map) too many full collisions - under attack?\");\n          set->under_attack = 1;\n        }\n        if (set->under_attack) {\n          return pos;\n        }\n      }\n    }\n  }\n  return NULL;\n  (void)obj; \n}", "target": 1}
{"code": "static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n\t    : \"rm\"(div), \"A\"(divs));\n\treturn dum2;\n}", "target": 1}
{"code": "NOEXPORT void reload_config() {\n    static int delay=10; \n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif \n    if(options_parse(CONF_RELOAD)) {\n        s_log(LOG_ERR, \"Failed to reload the configuration file\");\n        return;\n    }\n    unbind_ports();\n    log_flush(LOG_MODE_BUFFER);\n#ifdef HAVE_CHROOT\n    if(global_options.chroot_dir && stat(\"/dev/log\", &sb))\n        log_close(SINK_OUTFILE);\n    else\n#endif \n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    options_free();\n    options_apply();\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    if(bind_ports() | exec_connect_start()) {\n        s_poll_sleep(delay/1000, delay%1000); \n        signal_post(SIGNAL_RELOAD_CONFIG); \n        delay*=2;\n        if(delay > 10000) \n            delay=10000;\n    } else {\n        delay=10; \n    }\n}", "target": 1}
{"code": "static ssize_t driver_override_store(struct device *_dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\tchar *driver_override, *old, *cp;\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\tdevice_lock(_dev);\n\told = dev->driver_override;\n\tif (strlen(driver_override)) {\n\t\tdev->driver_override = driver_override;\n\t} else {\n\t       kfree(driver_override);\n\t       dev->driver_override = NULL;\n\t}\n\tdevice_unlock(_dev);\n\tkfree(old);\n\treturn count;\n}", "target": 1}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n \tif (task->mm)\n \t\tdumpable = get_dumpable(task->mm);\n \trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n \t\trcu_read_unlock();\n \t\treturn -EPERM;\n \t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "static void do_free_publickey(struct ecc_public_key *key)\n{\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n}", "target": 1}
{"code": "    bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t      int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t      bool& isvalid, CryptoKey& session_key) override {\n      isvalid = true;\n      return true;\n    }", "target": 1}
{"code": "int url_is_local_not_ssh(const char *url)\n{\n\tconst char *colon = strchr(url, ':');\n\tconst char *slash = strchr(url, '/');\n\treturn !colon || (slash && slash < colon) ||\n\t\thas_dos_drive_prefix(url);\n}", "target": 1}
{"code": "processBatchMultiRuleset(batch_t *pBatch)\n{\n\truleset_t *currRuleset;\n\tbatch_t snglRuleBatch;\n\tint i;\n\tint iStart;\t\n\tint iNew;\t\n\tDEFiRet;\n\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n\twhile(1) { \n\t\tfor(iStart = 0 ; iStart < pBatch->nElem && pBatch->pElem[iStart].state == BATCH_STATE_DISC ; ++iStart)\n\t\t\t;\n\t\tif(iStart == pBatch->nElem)\n\t\t\tFINALIZE; \n\t\tcurrRuleset = batchElemGetRuleset(pBatch, iStart);\n\t\tiNew = 0;\n\t\tfor(i = iStart ; i < pBatch->nElem ; ++i) {\n\t\t\tif(batchElemGetRuleset(pBatch, i) == currRuleset) {\n\t\t\t\tbatchCopyElem(&(snglRuleBatch.pElem[iNew++]), &(pBatch->pElem[i]));\n\t\t\t\tpBatch->pElem[i].state = BATCH_STATE_DISC;\n\t\t\t}\n\t\t}\n\t\tsnglRuleBatch.nElem = iNew; \n\t\tbatchSetSingleRuleset(&snglRuleBatch, 1);\n\t\tprocessBatch(&snglRuleBatch);\n\t}\n\tbatchFree(&snglRuleBatch);\nfinalize_it:\n\tRETiRet;\n}", "target": 1}
{"code": "mm_xmalloc(struct mm_master *mm, size_t size)\n{\n\tvoid *address;\n\taddress = mm_malloc(mm, size);\n\tif (address == NULL)\n\t\tfatal(\"%s: mm_malloc(%zu)\", __func__, size);\n\tmemset(address, 0, size);\n\treturn (address);\n}", "target": 1}
{"code": "static int ocsp_verify_signer(X509 *signer, int response,\n                              X509_STORE *st, unsigned long flags,\n                              STACK_OF(X509) *untrusted, STACK_OF(X509) **chain)\n{\n    X509_STORE_CTX *ctx = X509_STORE_CTX_new();\n    X509_VERIFY_PARAM *vp;\n    int ret = -1;\n    if (ctx == NULL) {\n        ERR_raise(ERR_LIB_OCSP, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n    if (!X509_STORE_CTX_init(ctx, st, signer, untrusted)) {\n        ERR_raise(ERR_LIB_OCSP, ERR_R_X509_LIB);\n        goto end;\n    }\n    if ((vp = X509_STORE_CTX_get0_param(ctx)) == NULL)\n        goto end;\n    if ((flags & OCSP_PARTIAL_CHAIN) != 0)\n        X509_VERIFY_PARAM_set_flags(vp, X509_V_FLAG_PARTIAL_CHAIN);\n    if (response\n            && X509_get_ext_by_NID(signer, NID_id_pkix_OCSP_noCheck, -1) >= 0)\n        X509_VERIFY_PARAM_clear_flags(vp, X509_V_FLAG_CRL_CHECK);\n    X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_OCSP_HELPER);\n    X509_STORE_CTX_set_trust(ctx, X509_TRUST_OCSP_REQUEST);\n    ret = X509_verify_cert(ctx);\n    if (ret <= 0) {\n        ret = X509_STORE_CTX_get_error(ctx);\n        ERR_raise_data(ERR_LIB_OCSP, OCSP_R_CERTIFICATE_VERIFY_ERROR,\n                       \"Verify error: %s\", X509_verify_cert_error_string(ret));\n        goto end;\n    }\n    if (chain != NULL)\n        *chain = X509_STORE_CTX_get1_chain(ctx);\n end:\n    X509_STORE_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "validGlxScreen(ClientPtr client, int screen, __GLXscreen **pGlxScreen, int *err)\n{\n    if (screen >= screenInfo.numScreens) {\n \tclient->errorValue = screen;\n \t*err = BadValue;\n \treturn FALSE;\n    }\n    *pGlxScreen = glxGetScreen(screenInfo.screens[screen]);\n    return TRUE;\n}", "target": 1}
{"code": "static int l2tp_ip_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t\t   size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n \tif (flags & MSG_OOB)\n \t\tgoto out;\n\tif (addr_len)\n\t\t*addr_len = sizeof(*sin);\n \tskb = skb_recv_datagram(sk, flags, noblock, &err);\n \tif (!skb)\n \t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_timestamp(msg, sk, skb);\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n \t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n \t\tsin->sin_port = 0;\n \t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n \t}\n \tif (inet->cmsg_flags)\n \t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}", "target": 1}
{"code": "GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n{\n    size_t size, len;\n    BOOL ret = FALSE;\n    WCHAR *data = NULL;\n    DWORD bytes, read;\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n        ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n    }\n    size = bytes / sizeof(*data);\n    if (size == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    data = malloc(bytes);\n    if (data == NULL)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n        ReturnLastError(pipe, L\"malloc\");\n        goto out;\n    }\n    read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n    if (bytes != read)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n        ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n    }\n    if (data[size - 1] != 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->std_input = sud->options + len;\n    data = NULL; \n    ret = TRUE;\nout:\n    free(data);\n    return ret;\n}", "target": 1}
{"code": "DU_getStringDOElement(DcmItem *obj, DcmTagKey t, char *s, size_t bufsize)\n{\n    DcmByteString *elem;\n    DcmStack stack;\n    OFCondition ec = EC_Normal;\n    char* aString;\n    ec = obj->search(t, stack);\n    elem = (DcmByteString*) stack.top();\n    if (ec == EC_Normal && elem != NULL) {\n        if (elem->getLength() == 0) {\n            s[0] = '\\0';\n        } else {\n            ec =  elem->getString(aString);\n            OFStandard::strlcpy(s, aString, bufsize);\n        }\n    }\n    return (ec == EC_Normal);\n}", "target": 1}
{"code": "dbus_g_proxy_manager_filter (DBusConnection    *connection,\n                             DBusMessage       *message,\n                             void              *user_data)\n{\n  DBusGProxyManager *manager;\n  if (dbus_message_get_type (message) != DBUS_MESSAGE_TYPE_SIGNAL)\n    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;\n  manager = user_data;\n  dbus_g_proxy_manager_ref (manager);\n  LOCK_MANAGER (manager);\n  if (dbus_message_is_signal (message,\n                              DBUS_INTERFACE_LOCAL,\n                              \"Disconnected\"))\n    {\n      GSList *all;\n      GSList *tmp;\n      all = dbus_g_proxy_manager_list_all (manager);\n      tmp = all;\n      while (tmp != NULL)\n        {\n          DBusGProxy *proxy;\n          proxy = DBUS_G_PROXY (tmp->data);\n          UNLOCK_MANAGER (manager);\n          dbus_g_proxy_destroy (proxy);\n          g_object_unref (G_OBJECT (proxy));\n          LOCK_MANAGER (manager);\n          tmp = tmp->next;\n        }\n      g_slist_free (all);\n#ifndef G_DISABLE_CHECKS\n      if (manager->proxy_lists != NULL)\n        g_warning (\"Disconnection emitted \\\"destroy\\\" on all DBusGProxy, but somehow new proxies were created in response to one of those destroy signals. This will cause a memory leak.\");\n#endif\n    }\n  else\n    {\n      char *tri;\n      GSList *full_list;\n      GSList *owned_names;\n       GSList *tmp;\n       const char *sender;\n      if (dbus_message_is_signal (message,\n \t\t\t\t  DBUS_INTERFACE_DBUS,\n \t\t\t\t  \"NameOwnerChanged\"))\n \t{\n\t  DBusError derr;\n\t  dbus_error_init (&derr);\n\t  if (!dbus_message_get_args (message,\n\t\t\t\t      &derr,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &name,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &prev_owner,\n\t\t\t\t      DBUS_TYPE_STRING,\n\t\t\t\t      &new_owner,\n\t\t\t\t      DBUS_TYPE_INVALID))\n\t    {\n\t      dbus_error_free (&derr);\n\t    }\n\t  else if (manager->owner_names != NULL)\n\t    {\n\t      dbus_g_proxy_manager_replace_name_owner (manager, name, prev_owner, new_owner);\n\t    }\n\t}\n \t    }\n \t}", "target": 1}
{"code": "COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask) {\n\t\terr = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, nodes_addr(bm), alloc_size);\n\t}\n\tif (err)\n\t\treturn -EFAULT;\n\treturn sys_mbind(start, len, mode, nm, nr_bits+1, flags);\n}", "target": 1}
{"code": "Status BuildXlaCompilationCache(DeviceBase* device, FunctionLibraryRuntime* flr,\n                                const XlaPlatformInfo& platform_info,\n                                XlaCompilationCache** cache) {\n  if (platform_info.xla_device_metadata()) {\n    *cache = new XlaCompilationCache(\n        platform_info.xla_device_metadata()->client(),\n        platform_info.xla_device_metadata()->jit_device_type());\n    return Status::OK();\n  }\n  auto platform =\n      se::MultiPlatformManager::PlatformWithId(platform_info.platform_id());\n  if (!platform.ok()) {\n    return platform.status();\n  }\n  StatusOr<xla::Compiler*> compiler_for_platform =\n      xla::Compiler::GetForPlatform(platform.ValueOrDie());\n  if (!compiler_for_platform.ok()) {\n    const Status& status = compiler_for_platform.status();\n    if (status.code() == error::NOT_FOUND) {\n      return errors::Unimplemented(\"Could not find compiler for platform \",\n                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());\n  }\n  *cache = new XlaCompilationCache(\n      client.ValueOrDie(), DeviceType(registration->compilation_device_name));\n  return Status::OK();\n}", "target": 1}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape(ssm.shape());\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 1}
{"code": "TRIO_PRIVATE void TrioWriteString TRIO_ARGS5((self, string, flags, width, precision),\n                                             trio_class_t* self, TRIO_CONST char* string,\n                                             trio_flags_t flags, int width, int precision)\n{\n\tint length;\n\tint ch;\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\tif (string == NULL)\n\t{\n\t\tstring = internalNullString;\n\t\tlength = sizeof(internalNullString) - 1;\n#if TRIO_FEATURE_QUOTE\n\t\tflags &= (~FLAGS_QUOTE);\n#endif\n\t\twidth = 0;\n\t}\n\telse\n\t{\n\t\tif (precision == 0)\n\t\t{\n\t\t\tlength = trio_length(string);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlength = trio_length_max(string, precision);\n\t\t}\n\t}\n\tif ((NO_PRECISION != precision) && (precision < length))\n\t{\n\t\tlength = precision;\n\t}\n\twidth -= length;\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n\tif (!(flags & FLAGS_LEFTADJUST))\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\twhile (length-- > 0)\n\t{\n\t\tch = (int)((unsigned char)(*string++));\n\t\tTrioWriteStringCharacter(self, ch, flags);\n\t}\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n}", "target": 1}
{"code": " static void recalculate_apic_map(struct kvm *kvm)\n {\n \tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tnew = kzalloc(sizeof(struct kvm_apic_map), GFP_KERNEL);\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!new)\n\t\tgoto out;\n\tnew->ldr_bits = 8;\n\tnew->cid_shift = 8;\n\tnew->cid_mask = 0;\n\tnew->lid_mask = 0xff;\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tu16 cid, lid;\n\t\tu32 ldr;\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n \t\tif (apic_x2apic_mode(apic)) {\n \t\t\tnew->ldr_bits = 32;\n \t\t\tnew->cid_shift = 16;\n\t\t\tnew->cid_mask = new->lid_mask = 0xffff;\n \t\t} else if (kvm_apic_sw_enabled(apic) &&\n \t\t\t\t!new->cid_mask  &&\n \t\t\t\tkvm_apic_get_reg(apic, APIC_DFR) == APIC_DFR_CLUSTER) {\n\t\t\tnew->cid_shift = 4;\n\t\t\tnew->cid_mask = 0xf;\n\t\t\tnew->lid_mask = 0xf;\n\t\t}\n\t\tnew->phys_map[kvm_apic_id(apic)] = apic;\n\t\tldr = kvm_apic_get_reg(apic, APIC_LDR);\n\t\tcid = apic_cluster_id(new, ldr);\n\t\tlid = apic_logical_id(new, ldr);\n\t\tif (lid)\n\t\t\tnew->logical_map[cid][ffs(lid) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\tif (old)\n\t\tkfree_rcu(old, rcu);\n\tkvm_vcpu_request_scan_ioapic(kvm);\n}", "target": 1}
{"code": "static void adpt_release(adpt_hba *pHba)\n{\n\tstruct Scsi_Host *shost = pHba->host;\n\tscsi_remove_host(shost);\n\tadpt_i2o_delete_hba(pHba);\n\tscsi_host_put(shost);\n}", "target": 1}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tkey->reject_error = -error;\n\t\tsmp_wmb();\n\t\tset_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n \tmutex_unlock(&key_construction_mutex);\n\tif (keyring)\n \t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 1}
{"code": "void migrate_page_copy(struct page *newpage, struct page *page)\n{\n\tint cpupid;\n\tif (PageHuge(page) || PageTransHuge(page))\n\t\tcopy_huge_page(newpage, page);\n\telse\n\t\tcopy_highpage(newpage, page);\n\tif (PageError(page))\n\t\tSetPageError(newpage);\n\tif (PageReferenced(page))\n\t\tSetPageReferenced(newpage);\n\tif (PageUptodate(page))\n\t\tSetPageUptodate(newpage);\n\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\tcpupid = page_cpupid_xchg_last(page, -1);\n\tpage_cpupid_xchg_last(newpage, cpupid);\n\tksm_migrate_page(newpage, page);\n\tif (PageSwapCache(page))\n\t\tClearPageSwapCache(page);\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tif (PageWriteback(newpage))\n\t\tend_page_writeback(newpage);\n}", "target": 1}
{"code": "set_fflags_platform(struct archive_write_disk *a, int fd, const char *name,\n    mode_t mode, unsigned long set, unsigned long clear)\n{\n\tint\t\t ret;\n\tint\t\t myfd = fd;\n\tint newflags, oldflags;\n\tconst int sf_mask = 0\n#if defined(FS_IMMUTABLE_FL)\n\t    | FS_IMMUTABLE_FL\n#elif defined(EXT2_IMMUTABLE_FL)\n\t    | EXT2_IMMUTABLE_FL\n#endif\n#if defined(FS_APPEND_FL)\n\t    | FS_APPEND_FL\n#elif defined(EXT2_APPEND_FL)\n\t    | EXT2_APPEND_FL\n#endif\n#if defined(FS_JOURNAL_DATA_FL)\n\t    | FS_JOURNAL_DATA_FL\n#endif\n\t;\n\tif (set == 0 && clear == 0)\n\t\treturn (ARCHIVE_OK);\n\tif (!S_ISREG(mode) && !S_ISDIR(mode))\n\t\treturn (ARCHIVE_OK);\n\tif (myfd < 0) {\n\t\tmyfd = open(name, O_RDONLY | O_NONBLOCK | O_BINARY | O_CLOEXEC);\n\t\t__archive_ensure_cloexec_flag(myfd);\n\t}\n\tif (myfd < 0)\n\t\treturn (ARCHIVE_OK);\n\tret = ARCHIVE_OK;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_GETFLAGS\n\t    FS_IOC_GETFLAGS,\n#else\n\t    EXT2_IOC_GETFLAGS,\n#endif\n\t    &oldflags) < 0)\n\t\tgoto fail;\n\tnewflags = (oldflags & ~clear) | set;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\n\tif (errno != EPERM)\n\t\tgoto fail;\n\tnewflags &= ~sf_mask;\n\toldflags &= sf_mask;\n\tnewflags |= oldflags;\n\tif (ioctl(myfd,\n#ifdef FS_IOC_SETFLAGS\n\t    FS_IOC_SETFLAGS,\n#else\n\t    EXT2_IOC_SETFLAGS,\n#endif\n\t    &newflags) >= 0)\n\t\tgoto cleanup;\nfail:\n\tarchive_set_error(&a->archive, errno,\n\t    \"Failed to set file flags\");\n\tret = ARCHIVE_WARN;\ncleanup:\n\tif (fd < 0)\n\t\tclose(myfd);\n\treturn (ret);\n}", "target": 1}
{"code": "void ArrowHead()\n{\n    int k;\n    double length;\n    SaveGraphicsState;\n    if ( flip ) length = -arrow.length;\n    else        length =  arrow.length;\n    SetDashSize(0,0);\n    if ( arrow.stroke ) {\n        SetLineWidth(arrow.stroke);\n        for (k = 1; k <= 2; k++ ) {\n            SaveGraphicsState;\n            MoveTo(length*0.5,0);\n            LineTo(-length*0.5,arrow.width);\n            LineTo(-length*0.5+length*arrow.inset,0);\n            LineTo(-length*0.5,-arrow.width);\n            if (k == 1) {\n                SetBackgroundColor(NONSTROKING);\n                outpos += sprintf(outpos,\" h f\");\n            }\n            else {\n                outpos += sprintf(outpos,\" s\");\n            }\n            RestoreGraphicsState;\n        }\n    }\n    else {\n        MoveTo(length*0.5,0);\n        LineTo(-length*0.5,arrow.width);\n        LineTo(-length*0.5+length*arrow.inset,0);\n        LineTo(-length*0.5,-arrow.width);\n        outpos += sprintf(outpos,\" h f\");\n    }\n    RestoreGraphicsState;\n}", "target": 1}
{"code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tunsigned long h;\n\tconst unsigned char *p;\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (p = id->name; *p; p++)\n\t\th = MULTIPLIER * h + *p;\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "target": 1}
{"code": "void AuthenticationFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOldOption(\"server.disable-authentication\",\n                        \"server.authentication\");\n  options->addOldOption(\"server.disable-authentication-unix-sockets\",\n                        \"server.authentication-unix-sockets\");\n  options->addOldOption(\"server.authenticate-system-only\",\n                        \"server.authentication-system-only\");\n  options->addOldOption(\"server.allow-method-override\",\n                        \"http.allow-method-override\");\n  options->addOldOption(\"server.hide-product-header\",\n                        \"http.hide-product-header\");\n  options->addOldOption(\"server.keep-alive-timeout\", \"http.keep-alive-timeout\");\n  options->addOldOption(\"server.default-api-compatibility\", \"\");\n  options->addOldOption(\"no-server\", \"server.rest-server\");\n  options->addOption(\"--server.authentication\",\n                     \"enable authentication for ALL client requests\",\n                     new BooleanParameter(&_active));\n  options->addOption(\n      \"--server.authentication-timeout\",\n      \"timeout for the authentication cache in seconds (0 = indefinitely)\",\n      new DoubleParameter(&_authenticationTimeout));\n  options->addOption(\"--server.local-authentication\",\n                     \"enable authentication using the local user database\",\n                     new BooleanParameter(&_localAuthentication));\n  options->addOption(\n      \"--server.authentication-system-only\",\n      \"use HTTP authentication only for requests to /_api and /_admin\",\n      new BooleanParameter(&_authenticationSystemOnly));\n#ifdef ARANGODB_HAVE_DOMAIN_SOCKETS\n  options->addOption(\"--server.authentication-unix-sockets\",\n                     \"authentication for requests via UNIX domain sockets\",\n                     new BooleanParameter(&_authenticationUnixSockets));\n#endif\n  options\n      ->addOption(\"--server.jwt-secret\",\n                  \"secret to use when doing jwt authentication\",\n                  new StringParameter(&_jwtSecretProgramOption))\n      .setDeprecatedIn(30322)\n      .setDeprecatedIn(30402);\n  options->addOption(\n      \"--server.jwt-secret-keyfile\",\n      \"file containing jwt secret to use when doing jwt authentication.\",\n      new StringParameter(&_jwtSecretKeyfileProgramOption));\n  options->addOption(\n      \"--server.jwt-secret-folder\",\n      \"folder containing one or more jwt secret files to use for jwt \"\n      \"authentication. Files are sorted alphabetically: First secret \"\n      \"is used for signing + verifying JWT tokens. The latter secrets \"\n      \"are only used for verifying.\",\n      new StringParameter(&_jwtSecretFolderProgramOption),\n      arangodb::options::makeDefaultFlags(arangodb::options::Flags::Enterprise))\n      .setIntroducedIn(30700);\n}", "target": 1}
{"code": "NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\twhile (pAvPair)\n\t{\n\t\tUINT16 id = ntlm_av_pair_get_id(pAvPair);\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n\tif (!pAvPair)\n\t\tcbAvPair = 0;\n\tif (pcbAvPairListRemaining)\n\t\t*pcbAvPairListRemaining = cbAvPair;\n\treturn pAvPair;\n}", "target": 1}
{"code": "static bool imap_parser_read_string(struct imap_parser *parser,\n\t\t\t\t    const unsigned char *data, size_t data_size)\n{\n\tsize_t i;\n\tfor (i = parser->cur_pos; i < data_size; i++) {\n\t\tif (data[i] == '\"') {\n\t\t\timap_parser_save_arg(parser, data, i);\n\t\t\ti++; \n\t\t\tbreak;\n\t\t}\n\t\tif (data[i] == '\\\\') {\n\t\t\tif (i+1 == data_size) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (parser->str_first_escape < 0)\n\t\t\t\tparser->str_first_escape = i;\n\t\t\ti++;\n\t\t}\n\t\tif (is_linebreak(data[i]) &&\n\t\t    (parser->flags & IMAP_PARSE_FLAG_MULTILINE_STR) == 0) {\n\t\t\tparser->error = IMAP_PARSE_ERROR_BAD_SYNTAX;\n\t\t\tparser->error_msg = \"Missing '\\\"'\";\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tparser->cur_pos = i;\n\treturn parser->cur_type == ARG_PARSE_NONE;\n}", "target": 1}
{"code": " static int pagemap_open(struct inode *inode, struct file *file)\n {\n \tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n \t\t\t\"to stop being page-shift some time soon. See the \"\n \t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,\n\t\t\tstruct prefix_info *pinfo, u32 pid, u32 seq, \n\t\t\tint event, unsigned int flags)\n{\n\tstruct prefixmsg\t*pmsg;\n\tstruct nlmsghdr \t*nlh;\n\tunsigned char\t\t*b = skb->tail;\n\tstruct prefix_cacheinfo\tci;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);\n\tpmsg = NLMSG_DATA(nlh);\n\tpmsg->prefix_family = AF_INET6;\n\tpmsg->prefix_ifindex = idev->dev->ifindex;\n\tpmsg->prefix_len = pinfo->prefix_len;\n\tpmsg->prefix_type = pinfo->type;\n\tpmsg->prefix_flags = 0;\n\tif (pinfo->onlink)\n\t\tpmsg->prefix_flags |= IF_PREFIX_ONLINK;\n\tif (pinfo->autoconf)\n\t\tpmsg->prefix_flags |= IF_PREFIX_AUTOCONF;\n\tRTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);\n\tci.preferred_time = ntohl(pinfo->prefered);\n\tci.valid_time = ntohl(pinfo->valid);\n\tRTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "Status SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index,\n                               const bool validate_indices,\n                               sparse::SparseTensor* tensor) {\n  TensorShape shape;\n  TF_RETURN_IF_ERROR(TensorShape::BuildTensorShape(\n      ctx->input(base_index + 2).vec<int64_t>(), &shape));\n  CheckRankAtLeast2(ctx, shape);\n  std::vector<int64_t> order(shape.dims());\n  std::iota(order.begin(), order.end(), 0);\n  Status status = sparse::SparseTensor::Create(\n      ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor);\n  if (!validate_indices || !status.ok()) return status;\n  return tensor->IndicesValid();\n}", "target": 1}
{"code": "void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces->setTorrent(m_torrent);\n    pieces_availability->setTorrent(m_torrent);\n    if (!m_torrent) return;\n    updateSavePath(m_torrent);\n    hash_lbl->setText(m_torrent->hash());\n    PropListModel->model()->clear();\n    if (m_torrent->hasMetadata()) {\n        lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate));\n        label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n        comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment()));\n        loadUrlSeeds();\n        label_created_by_val->setText(m_torrent->creator());\n        PropListModel->model()->setupModelData(m_torrent->info());\n        filesList->setExpanded(PropListModel->index(0, 0), true);\n        PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities());\n    }\n    loadDynamicData();\n}", "target": 1}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n \tstruct usb_serial *serial = port->serial;\n \tstruct cypress_private *priv;\n \tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n \tif (!priv)\n \t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 1}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n \t\tfrag->len -= len;\n \t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n \t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 1}
{"code": "exsltSaxonLineNumberFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n    xmlNodePtr cur = NULL;\n    if (nargs == 0) {\n\tcur = ctxt->context->node;\n    } else if (nargs == 1) {\n\txmlXPathObjectPtr obj;\n\txmlNodeSetPtr nodelist;\n\tint i;\n\tif ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n\t    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"saxon:line-number() : invalid arg expecting a node-set\\n\");\n\t    ctxt->error = XPATH_INVALID_TYPE;\n\t    return;\n\t}\n\tobj = valuePop(ctxt);\n\tnodelist = obj->nodesetval;\n\tif ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n\t    xmlXPathFreeObject(obj);\n\t    valuePush(ctxt, xmlXPathNewFloat(-1));\n\t    return;\n\t}\n\tcur = nodelist->nodeTab[0];\n\tfor (i = 1;i < nodelist->nodeNr;i++) {\n\t    int ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n\t    if (ret == -1)\n\t\tcur = nodelist->nodeTab[i];\n\t}\n\txmlXPathFreeObject(obj);\n    } else {\n\txsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n\t\t\"saxon:line-number() : invalid number of args %d\\n\",\n\t\tnargs);\n\tctxt->error = XPATH_INVALID_ARITY;\n\treturn;\n    }\n    valuePush(ctxt, xmlXPathNewFloat(xmlGetLineNo(cur)));\n    return;\n}", "target": 1}
{"code": "gopherHTMLHeader(StoreEntry * e, const char *title, const char *substring)\n{\n    storeAppendPrintf(e, \"<!DOCTYPE HTML PUBLIC \\\"-\n    storeAppendPrintf(e, \"<HTML><HEAD><TITLE>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</TITLE>\");\n    storeAppendPrintf(e, \"<STYLE type=\\\"text/css\\\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\\n\");\n    storeAppendPrintf(e, \"</HEAD>\\n<BODY><H1>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</H1>\\n\");\n}", "target": 1}
{"code": "static int __init adpt_init(void)\n{\n\tint\t\terror;\n\tadpt_hba\t*pHba, *next;\n\tprintk(\"Loading Adaptec I2O RAID: Version \" DPT_I2O_VERSION \"\\n\");\n\terror = adpt_detect(&driver_template);\n\tif (error < 0)\n\t\treturn error;\n\tif (hba_chain == NULL)\n\t\treturn -ENODEV;\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\terror = scsi_add_host(pHba->host, &pHba->pDev->dev);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tscsi_scan_host(pHba->host);\n\t}\n\treturn 0;\nfail:\n\tfor (pHba = hba_chain; pHba; pHba = next) {\n\t\tnext = pHba->next;\n\t\tscsi_remove_host(pHba->host);\n\t}\n\treturn error;\n}", "target": 1}
{"code": "content::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n  if (Emit(\"will-navigate\", params.url))\n    return nullptr;\n  if (IsDestroyed())\n    return nullptr;\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}", "target": 1}
{"code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\tCloseHandle(Token);\n\treturn 0;\n#else\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n#ifdef HAVE_GETSPNAM\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\tuser_password = user->pw_passwd;\n#endif\n\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "size_t tls12_get_psigalgs(SSL *s, const unsigned char **psigs)\n\t{\n#ifndef OPENSSL_NO_EC\n\tswitch (tls1_suiteb(s))\n\t\t{\n\tcase SSL_CERT_FLAG_SUITEB_128_LOS:\n\t\t*psigs = suiteb_sigalgs;\n\t\treturn sizeof(suiteb_sigalgs);\n\tcase SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:\n\t\t*psigs = suiteb_sigalgs;\n\t\treturn 2;\n\tcase SSL_CERT_FLAG_SUITEB_192_LOS:\n\t\t*psigs = suiteb_sigalgs + 2;\n\t\treturn 2;\n\t\t}\n#endif\n\tif (s->server && s->cert->client_sigalgs)\n\t\t{\n\t\t*psigs = s->cert->client_sigalgs;\n\t\treturn s->cert->client_sigalgslen;\n\t\t}\n\telse if (s->cert->conf_sigalgs)\n\t\t{\n\t\t*psigs = s->cert->conf_sigalgs;\n\t\treturn s->cert->conf_sigalgslen;\n\t\t}\n\telse\n\t\t{\n\t\t*psigs = tls12_sigalgs;\n#ifdef OPENSSL_FIPS\n\t\tif (FIPS_mode())\n\t\t\treturn sizeof(tls12_sigalgs) - 2;\n\t\telse\n#endif\n\t\t\treturn sizeof(tls12_sigalgs);\n\t\t}\n\t}", "target": 1}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (sgx_params->output) {\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 1}
{"code": "void RunOneAveragePoolTest(const PoolParams& params,\n                           const RuntimeShape& input_shape,\n                           const int8* input_data,\n                           const RuntimeShape& output_shape) {\n  const int buffer_size = output_shape.FlatSize();\n  std::vector<int8> optimized_averagePool_output(buffer_size);\n  std::vector<int8> reference_averagePool_output(buffer_size);\n  reference_integer_ops::AveragePool(params, input_shape, input_data,\n                                     output_shape,\n                                     reference_averagePool_output.data());\n  optimized_integer_ops::AveragePool(params, input_shape, input_data,\n                                     output_shape,\n                                     optimized_averagePool_output.data());\n  for (int i = 0; i < buffer_size; i++) {\n    EXPECT_TRUE(reference_averagePool_output[i] ==\n                optimized_averagePool_output[i]);\n  }\n}", "target": 1}
{"code": "l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": " */\nstatic enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer)\n{\n\tstruct bfq_data *bfqd = container_of(timer, struct bfq_data,\n\t\t\t\t\t     idle_slice_timer);\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\tif (bfqq)\n\t\tbfq_idle_slice_timer_body(bfqq);\n\treturn HRTIMER_NORESTART;", "target": 1}
{"code": "static TEE_Result do_allocate_publickey(struct rsa_public_key *key,\n\t\t\t\t\tsize_t size_bits)\n{\n\tRSA_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->e = crypto_bignum_allocate(MAX_BITS_EXP_E);\n\tif (!key->e)\n\t\tgoto err_alloc_publickey;\n\tkey->n = crypto_bignum_allocate(size_bits);\n\tif (!key->n)\n\t\tgoto err_alloc_publickey;\n\treturn TEE_SUCCESS;\nerr_alloc_publickey:\n\tRSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static void do_free_publickey(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "untrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n    switch (response_id)\n    {\n        case RESPONSE_RUN:\n        {\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n        }\n        break;\n        case RESPONSE_MARK_TRUSTED:\n        {\n            file = nautilus_file_get_location (parameters->file);\n            nautilus_file_mark_desktop_file_trusted (file,\n                                                     parameters->parent_window,\n                                                     TRUE,\n                                                     NULL, NULL);\n            g_object_unref (file);\n        }\n        break;\n        default:\n        {\n        }\n        break;\n    }\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n    activate_parameters_desktop_free (parameters);\n}", "target": 1}
{"code": "static void adpt_ia64_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_IA64;\n}", "target": 1}
{"code": "static void lan78xx_disconnect(struct usb_interface *intf)\n{\n\tstruct lan78xx_net *dev;\n\tstruct usb_device *udev;\n\tstruct net_device *net;\n\tstruct phy_device *phydev;\n\tdev = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\tif (!dev)\n\t\treturn;\n\tset_bit(EVENT_DEV_DISCONNECT, &dev->flags);\n\tnetif_napi_del(&dev->napi);\n\tudev = interface_to_usbdev(intf);\n\tnet = dev->net;\n\tunregister_netdev(net);\n\tcancel_delayed_work_sync(&dev->wq);\n\tphydev = net->phydev;\n\tphy_unregister_fixup_for_uid(PHY_KSZ9031RNX, 0xfffffff0);\n\tphy_unregister_fixup_for_uid(PHY_LAN8835, 0xfffffff0);\n\tphy_disconnect(net->phydev);\n\tif (phy_is_pseudo_fixed_link(phydev))\n\t\tfixed_phy_unregister(phydev);\n\tusb_scuttle_anchored_urbs(&dev->deferred);\n\tif (timer_pending(&dev->stat_monitor))\n\t\tdel_timer_sync(&dev->stat_monitor);\n\tlan78xx_unbind(dev, intf);\n\tlan78xx_free_tx_resources(dev);\n\tlan78xx_free_rx_resources(dev);\n\tusb_kill_urb(dev->urb_intr);\n\tusb_free_urb(dev->urb_intr);\n\tfree_netdev(net);\n\tusb_put_dev(udev);\n}", "target": 1}
{"code": "static int rfcomm_get_dev_list(void __user *arg)\n{\n\tstruct rfcomm_dev *dev;\n\tstruct rfcomm_dev_list_req *dl;\n\tstruct rfcomm_dev_info *di;\n\tint n = 0, size, err;\n\tu16 dev_num;\n\tBT_DBG(\"\");\n\tif (get_user(dev_num, (u16 __user *) arg))\n\t\treturn -EFAULT;\n\tif (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))\n\t\treturn -EINVAL;\n\tsize = sizeof(*dl) + dev_num * sizeof(*di);\n\tdl = kmalloc(size, GFP_KERNEL);\n\tif (!dl)\n\t\treturn -ENOMEM;\n\tdi = dl->dev_info;\n\tspin_lock(&rfcomm_dev_lock);\n\tlist_for_each_entry(dev, &rfcomm_dev_list, list) {\n\t\tif (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))\n\t\t\tcontinue;\n\t\t(di + n)->id      = dev->id;\n\t\t(di + n)->flags   = dev->flags;\n\t\t(di + n)->state   = dev->dlc->state;\n\t\t(di + n)->channel = dev->channel;\n\t\tbacpy(&(di + n)->src, &dev->src);\n\t\tbacpy(&(di + n)->dst, &dev->dst);\n\t\tif (++n >= dev_num)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&rfcomm_dev_lock);\n\tdl->dev_num = n;\n\tsize = sizeof(*dl) + n * sizeof(*di);\n\terr = copy_to_user(arg, dl, size);\n\tkfree(dl);\n\treturn err ? -EFAULT : 0;\n}", "target": 1}
{"code": " bool HTMLFormElement::prepareForSubmission(Event* event)\n {\n     Frame* frame = document().frame();\n     if (m_isSubmittingOrPreparingForSubmission || !frame)\n         return m_isSubmittingOrPreparingForSubmission;\n    m_isSubmittingOrPreparingForSubmission = true;\n    m_shouldSubmit = false;\n    if (!validateInteractively(event)) {\n        m_isSubmittingOrPreparingForSubmission = false;\n        return false;\n    }\n    StringPairVector controlNamesAndValues;\n    getTextFieldValues(controlNamesAndValues);\n    RefPtr<FormState> formState = FormState::create(this, controlNamesAndValues, &document(), NotSubmittedByJavaScript);\n    frame->loader()->client()->dispatchWillSendSubmitEvent(formState.release());\n    if (dispatchEvent(Event::createCancelableBubble(eventNames().submitEvent)))\n        m_shouldSubmit = true;\n    m_isSubmittingOrPreparingForSubmission = false;\n    if (m_shouldSubmit)\n        submit(event, true, true, NotSubmittedByJavaScript);\n    return m_shouldSubmit;\n}", "target": 1}
{"code": "void SoundTouch::setChannels(uint numChannels)\n{\n    channels = numChannels;\n    pRateTransposer->setChannels((int)numChannels);\n    pTDStretch->setChannels((int)numChannels);\n}", "target": 1}
{"code": "static UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\trdpPrintJob* printjob = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse\n\t{\n\t\terror = printjob->Write(printjob, Stream_Pointer(irp->input), Length);\n\t}\n\tif (error)\n\t{\n\t\tWLog_ERR(TAG, \"printjob->Write failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\tmaxlen = strlen ((char*) psf->header) ;\n\tstart\t= ((char*) psf->header) + maxlen ;\n\tmaxlen\t= sizeof (psf->header) - maxlen ;\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\tstart [maxlen - 1] = 0 ;\n\tpsf->headindex = strlen ((char*) psf->header) ;\n\treturn ;\n} ", "target": 1}
{"code": "xmlDocPtr soap_xmlParseFile(const char *filename TSRMLS_DC)\n{\n\txmlParserCtxtPtr ctxt = NULL;\n\txmlDocPtr ret;\n\tzend_bool old_allow_url_fopen;\n\told_allow_url_fopen = PG(allow_url_fopen);\n\tPG(allow_url_fopen) = 1;\n\tctxt = xmlCreateFileParserCtxt(filename);\n        PG(allow_url_fopen) = old_allow_url_fopen;\n        if (ctxt) {\n                ctxt->keepBlanks = 0;\n                ctxt->sax->ignorableWhitespace = soap_ignorableWhitespace;\n                ctxt->sax->comment = soap_Comment;\n                ctxt->sax->warning = NULL;\n\t\txmlParseDocument(ctxt);\n\t\tif (ctxt->wellFormed) {\n\t\t\tret = ctxt->myDoc;\n\t\t\tif (ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\t\tret->URL = xmlCharStrdup(ctxt->directory);\n\t\t\t}\n\t\t} else {\n\t\t\tret = NULL;\n\t\t\txmlFreeDoc(ctxt->myDoc);\n\t\t\tctxt->myDoc = NULL;\n\t\t}\n\t\txmlFreeParserCtxt(ctxt);\n\t} else {\n\t\tret = NULL;\n\t}\n\tif (ret) {\n\t\tcleanup_xml_node((xmlNodePtr)ret);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_unescape( pj_scanner *scanner,\n\t\t\t\t   const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    char *dst = s;\n    pj_assert(pj_cis_match(spec,0)==0);\n    pj_assert(pj_cis_match(spec,'%')==0);\n    if (!pj_cis_match(spec, *s) && *s != '%') {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    out->ptr = s;\n    do {\n\tif (*s == '%') {\n\t    if (s+3 <= scanner->end && pj_isxdigit(*(s+1)) && \n\t\tpj_isxdigit(*(s+2))) \n\t    {\n\t\t*dst = (pj_uint8_t) ((pj_hex_digit_to_val(*(s+1)) << 4) +\n\t\t\t\t      pj_hex_digit_to_val(*(s+2)));\n\t\t++dst;\n\t\ts += 3;\n\t    } else {\n\t\t*dst++ = *s++;\n\t\t*dst++ = *s++;\n\t\tbreak;\n\t    }\n\t}\n\tif (pj_cis_match(spec, *s)) {\n\t    char *start = s;\n\t    do {\n\t\t++s;\n\t    } while (pj_cis_match(spec, *s));\n\t    if (dst != start) pj_memmove(dst, start, s-start);\n\t    dst += (s-start);\n\t} \n    } while (*s == '%');\n    scanner->curptr = s;\n    out->slen = (dst - out->ptr);\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}", "target": 1}
{"code": "SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,\n\t\tconst void __user * __user *, pages,\n\t\tconst int __user *, nodes,\n\t\tint __user *, status, int, flags)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint err;\n\tnodemask_t task_nodes;\n\tif (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))\n\t\treturn -EINVAL;\n\tif ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))\n\t\treturn -EPERM;\n\trcu_read_lock();\n\ttask = pid ? find_task_by_vpid(pid) : current;\n\tif (!task) {\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tget_task_struct(task);\n\ttcred = __task_cred(task);\n\tif (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&\n\t    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&\n\t    !capable(CAP_SYS_NICE)) {\n\t\trcu_read_unlock();\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n \terr = security_task_movememory(task);\n \tif (err)\n\t\tgoto out;\n\ttask_nodes = cpuset_mems_allowed(task);\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -EINVAL;\n\tif (nodes)\n\t\terr = do_pages_move(mm, task_nodes, nr_pages, pages,\n\t\t\t\t    nodes, status, flags);\n\telse\n\t\terr = do_pages_stat(mm, nr_pages, pages, status);\n\tmmput(mm);\n\treturn err;\nout:\n\tput_task_struct(task);\n\treturn err;\n}", "target": 1}
{"code": "path_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tdepth = 0;\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))\n\t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\tpath->closed = (!isopen);\n\tpath->dummy = 0;\n\tPG_RETURN_PATH_P(path);\n}", "target": 1}
{"code": "_rsvg_node_poly_build_path (const char *value,\n                            gboolean close_path)\n{\n    double *pointlist;\n    guint pointlist_len, i;\n    GString *d;\n    cairo_path_t *path;\n    char buf[G_ASCII_DTOSTR_BUF_SIZE];\n    pointlist = rsvg_css_parse_number_list (value, &pointlist_len);\n    if (pointlist == NULL)\n        return NULL;\n    if (pointlist_len < 2) {\n        g_free (pointlist);\n        return NULL;\n    }\n    d = g_string_new (NULL);\n    g_string_append (d, \" M \");\n    g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), pointlist[0]));\n    g_string_append_c (d, ' ');\n    g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), pointlist[1]));\n    for (i = 2; i < pointlist_len; i += 2) {\n        g_string_append (d, \" L \");\n        g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), pointlist[i]));\n        g_string_append_c (d, ' ');\n        g_string_append (d, g_ascii_dtostr (buf, sizeof (buf), pointlist[i + 1]));\n    }\n    if (close_path)\n        g_string_append (d, \" Z\");\n    path = rsvg_parse_path (d->str);\n    g_string_free (d, TRUE);\n    g_free (pointlist);\n    return path;\n}", "target": 1}
{"code": "bool ExtractHardlink(CommandData *Cmd,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); \n  if (!FileExist(NameExisting))\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    uiMsg(UIERROR_NOLINKTARGET);\n    ErrHandler.SetErrorCode(RARX_CREATE);\n    return false;\n  }\n  CreatePath(NameNew,true,Cmd->DisableNames);\n#ifdef _WIN_ALL\n  bool Success=CreateHardLink(NameNew,NameExisting,NULL)!=0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#elif defined(_UNIX)\n  char NameExistingA[NM],NameNewA[NM];\n  WideToChar(NameExisting,NameExistingA,ASIZE(NameExistingA));\n  WideToChar(NameNew,NameNewA,ASIZE(NameNewA));\n  bool Success=link(NameExistingA,NameNewA)==0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#else\n  return false;\n#endif\n}", "target": 1}
{"code": "static int sctp_setsockopt_auth_key(struct sock *sk,\n\t\t\t\t    char __user *optval,\n\t\t\t\t    int optlen)\n{\n\tstruct sctp_authkey *authkey;\n\tstruct sctp_association *asoc;\n\tint ret;\n\tif (!sctp_auth_enable)\n\t\treturn -EACCES;\n\tif (optlen <= sizeof(struct sctp_authkey))\n\t\treturn -EINVAL;\n\tauthkey = kmalloc(optlen, GFP_KERNEL);\n\tif (!authkey)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(authkey, optval, optlen)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (authkey->sca_keylength > optlen) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tasoc = sctp_id2assoc(sk, authkey->sca_assoc_id);\n\tif (!asoc && authkey->sca_assoc_id && sctp_style(sk, UDP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = sctp_auth_set_key(sctp_sk(sk)->ep, asoc, authkey);\nout:\n\tkfree(authkey);\n\treturn ret;\n}", "target": 1}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "request_env(agooReq req, VALUE self) {\n    if (Qnil == (VALUE)req->env) {\n\tvolatile VALUE\tenv = rb_hash_new();\n\trb_hash_aset(env, request_method_val, req_method(req));\n\trb_hash_aset(env, script_name_val, req_script_name(req));\n\trb_hash_aset(env, path_info_val, req_path_info(req));\n\trb_hash_aset(env, query_string_val, req_query_string(req));\n\trb_hash_aset(env, server_name_val, req_server_name(req));\n\trb_hash_aset(env, server_port_val, req_server_port(req));\n\tfill_headers(req, env);\n\trb_hash_aset(env, rack_version_val, rack_version_val_val);\n\trb_hash_aset(env, rack_url_scheme_val, req_rack_url_scheme(req));\n\trb_hash_aset(env, rack_input_val, req_rack_input(req));\n\trb_hash_aset(env, rack_errors_val, req_rack_errors(req));\n\trb_hash_aset(env, rack_multithread_val, req_rack_multithread(req));\n\trb_hash_aset(env, rack_multiprocess_val, Qfalse);\n\trb_hash_aset(env, rack_run_once_val, Qfalse);\n\trb_hash_aset(env, rack_logger_val, req_rack_logger(req));\n\trb_hash_aset(env, rack_upgrade_val, req_rack_upgrade(req));\n\trb_hash_aset(env, rack_hijackq_val, Qtrue);\n\trb_hash_aset(env, rack_hijack_val, self);\n\trb_hash_aset(env, rack_hijack_io_val, Qnil);\n\tif (agoo_server.rack_early_hints) {\n\t    volatile VALUE\teh = agoo_early_hints_new(req);\n\t    rb_hash_aset(env, early_hints_val, eh);\n\t}\n\treq->env = (void*)env;\n    }\n    return (VALUE)req->env;\n}", "target": 1}
{"code": "static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct rtnl_link_ifmap map = {\n\t\t.mem_start   = dev->mem_start,\n\t\t.mem_end     = dev->mem_end,\n\t\t.base_addr   = dev->base_addr,\n\t\t.irq         = dev->irq,\n\t\t.dma         = dev->dma,\n\t\t.port        = dev->if_port,\n\t};\n\tif (nla_put(skb, IFLA_MAP, sizeof(map), &map))\n\t\treturn -EMSGSIZE;\n\treturn 0;\n}", "target": 1}
{"code": "SRP_user_pwd *SRP_VBASE_get_by_user(SRP_VBASE *vb, char *username)\n {\n     int i;\n     SRP_user_pwd *user;\n    unsigned char digv[SHA_DIGEST_LENGTH];\n    unsigned char digs[SHA_DIGEST_LENGTH];\n    EVP_MD_CTX ctxt;\n     if (vb == NULL)\n         return NULL;\n     for (i = 0; i < sk_SRP_user_pwd_num(vb->users_pwd); i++) {\n         user = sk_SRP_user_pwd_value(vb->users_pwd, i);\n         if (strcmp(user->id, username) == 0)\n             return user;\n     }\n     if ((vb->seed_key == NULL) ||\n         (vb->default_g == NULL) || (vb->default_N == NULL))\n         return NULL;\n        if (!(len = t_fromb64(tmp, N)))\n            goto err;\n        N_bn = BN_bin2bn(tmp, len, NULL);\n        if (!(len = t_fromb64(tmp, g)))\n            goto err;\n        g_bn = BN_bin2bn(tmp, len, NULL);\n        defgNid = \"*\";\n    } else {\n        SRP_gN *gN = SRP_get_gN_by_id(g, NULL);\n        if (gN == NULL)\n            goto err;\n        N_bn = gN->N;\n        g_bn = gN->g;\n        defgNid = gN->id;\n    }", "target": 1}
{"code": "struct qmp *qmp_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct qmp *qmp;\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\tnp = of_parse_phandle(dev->of_node, \"qcom,qmp\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\tqmp = platform_get_drvdata(pdev);\n\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n}", "target": 1}
{"code": "int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b)\n{\n    int result = -1;\n    if (!a || !b || a->type != b->type)\n        return -1;\n    switch (a->type) {\n    case GEN_X400:\n    case GEN_EDIPARTY:\n        result = ASN1_TYPE_cmp(a->d.other, b->d.other);\n        break;\n    case GEN_OTHERNAME:\n        result = OTHERNAME_cmp(a->d.otherName, b->d.otherName);\n        break;\n    case GEN_EMAIL:\n    case GEN_DNS:\n    case GEN_URI:\n        result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5);\n        break;\n    case GEN_DIRNAME:\n        result = X509_NAME_cmp(a->d.dirn, b->d.dirn);\n        break;\n    case GEN_IPADD:\n        result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip);\n        break;\n    case GEN_RID:\n        result = OBJ_cmp(a->d.rid, b->d.rid);\n        break;\n    }\n    return result;\n}", "target": 1}
{"code": "check_shellsize(void)\n{\n    if (Rows < min_rows())\t\n\tRows = min_rows();\n    limit_screen_size();\n}", "target": 1}
{"code": "_forceinline void Unpack::CopyString(uint Length,uint Distance)\n{\n  size_t SrcPtr=UnpPtr-Distance;\n  if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH)\n  {\n    byte *Src=Window+SrcPtr;\n    byte *Dest=Window+UnpPtr;\n    UnpPtr+=Length;\n#ifdef FAST_MEMCPY\n    if (Distance<Length) \n#endif\n      while (Length>=8)\n      {\n        Dest[0]=Src[0];\n        Dest[1]=Src[1];\n        Dest[2]=Src[2];\n        Dest[3]=Src[3];\n        Dest[4]=Src[4];\n        Dest[5]=Src[5];\n        Dest[6]=Src[6];\n        Dest[7]=Src[7];\n        Src+=8;\n        Dest+=8;\n        Length-=8;\n      }\n#ifdef FAST_MEMCPY\n    else\n      while (Length>=8)\n      {\n        memcpy(Dest,Src,8); \n        Src+=8;\n        Dest+=8;\n        Length-=8;\n      }\n#endif\n    if (Length>0) { Dest[0]=Src[0];\n    if (Length>1) { Dest[1]=Src[1];\n    if (Length>2) { Dest[2]=Src[2];\n    if (Length>3) { Dest[3]=Src[3];\n    if (Length>4) { Dest[4]=Src[4];\n    if (Length>5) { Dest[5]=Src[5];\n    if (Length>6) { Dest[6]=Src[6]; } } } } } } } \n  }\n  else\n    while (Length-- > 0) \n    {\n      Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask];\n      UnpPtr=(UnpPtr+1) & MaxWinMask;\n    }\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "void Lua::setParamsTable(lua_State* vm, const char* table_name,\n\t\t\t const char* query) const {\n  char outbuf[FILENAME_MAX];\n  char *where;\n  char *tok;\n  char *query_string = query ? strdup(query) : NULL;\n  lua_newtable(L);\n  if (query_string) {\n    tok = strtok_r(query_string, \"&\", &where);\n    while(tok != NULL) {\n      char *_equal;\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) \n\t && (_equal = strchr(tok, '='))) {\n\tchar *decoded_buf;\n        int len;\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n        if((decoded_buf = (char*)malloc(len+1)) != NULL) {\n          Utils::urlDecode(_equal, decoded_buf, len+1);\n\t  Utils::purifyHTTPparam(tok, true, false);\n\t  Utils::purifyHTTPparam(decoded_buf, false, false);\n\t  FILE *fd;\n\t  if((decoded_buf[0] == '.')\n\t     && ((fd = fopen(decoded_buf, \"r\"))\n\t\t || (fd = fopen(realpath(decoded_buf, outbuf), \"r\")))) {\n\t    ntop->getTrace()->traceEvent(TRACE_WARNING, \"Discarded '%s'='%s' as argument is a valid file path\",\n\t\t\t\t\t tok, decoded_buf);\n\t    decoded_buf[0] = '\\0';\n\t    fclose(fd);\n\t  }\n\t  lua_push_str_table_entry(vm, tok, decoded_buf);\n          free(decoded_buf);\n        } else\n          ntop->getTrace()->traceEvent(TRACE_WARNING, \"Not enough memory\");\n      }\n      tok = strtok_r(NULL, \"&\", &where);\n    } \n  }\n  if(query_string) free(query_string);\n  if(table_name)\n    lua_setglobal(L, table_name);\n  else\n    lua_setglobal(L, (char*)\"_GET\"); \n}", "target": 1}
{"code": "build_model(XML_Parser parser) {\n  DTD *const dtd = parser->m_dtd; \n  XML_Content *ret;\n  XML_Content *cpos;\n  XML_Char *str;\n#if UINT_MAX >= SIZE_MAX\n  if (dtd->scaffCount > (size_t)(-1) / sizeof(XML_Content)) {\n    return NULL;\n  }\n  if (dtd->contentStringLen > (size_t)(-1) / sizeof(XML_Char)) {\n    return NULL;\n  }\n#endif\n  if (dtd->scaffCount * sizeof(XML_Content)\n      > (size_t)(-1) - dtd->contentStringLen * sizeof(XML_Char)) {\n    return NULL;\n  }\n  const size_t allocsize = (dtd->scaffCount * sizeof(XML_Content)\n                            + (dtd->contentStringLen * sizeof(XML_Char)));\n  ret = (XML_Content *)MALLOC(parser, allocsize);\n  if (! ret)\n    return NULL;\n  str = (XML_Char *)(&ret[dtd->scaffCount]);\n  cpos = &ret[1];\n  build_node(parser, 0, ret, &cpos, &str);\n  return ret;\n}", "target": 1}
{"code": "modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_modify_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_modify_principal((void *)handle, &arg->rec,\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n     return FALSE;\n}", "target": 1}
{"code": "struct GuestFileRead *qmp_guest_file_read(int64_t handle, bool has_count,\n                                          int64_t count, Error **errp)\n{\n    GuestFileHandle *gfh = guest_file_handle_find(handle, errp);\n    GuestFileRead *read_data = NULL;\n    guchar *buf;\n    FILE *fh;\n    size_t read_count;\n    if (!gfh) {\n        return NULL;\n    }\n    if (!has_count) {\n        count = QGA_READ_COUNT_DEFAULT;\n    } else if (count < 0) {\n        error_setg(errp, \"value '%\" PRId64 \"' is invalid for argument count\",\n                   count);\n        return NULL;\n    }\n    fh = gfh->fh;\n    if (gfh->state == RW_STATE_WRITING) {\n        int ret = fflush(fh);\n        if (ret == EOF) {\n            error_setg_errno(errp, errno, \"failed to flush file\");\n            return NULL;\n        }\n        gfh->state = RW_STATE_NEW;\n    }\n    buf = g_malloc0(count+1);\n    read_count = fread(buf, 1, count, fh);\n    if (ferror(fh)) {\n        error_setg_errno(errp, errno, \"failed to read file\");\n        slog(\"guest-file-read failed, handle: %\" PRId64, handle);\n    } else {\n        buf[read_count] = 0;\n        read_data = g_new0(GuestFileRead, 1);\n        read_data->count = read_count;\n        read_data->eof = feof(fh);\n        if (read_count) {\n            read_data->buf_b64 = g_base64_encode(buf, read_count);\n        }\n        gfh->state = RW_STATE_READING;\n    }\n    g_free(buf);\n    clearerr(fh);\n    return read_data;\n}", "target": 1}
{"code": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n  auto sep = file.rfind('/');\n  if (sep != std::string::npos) {\n    auto path = to + file.substr(0, sep);\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n    if (sep == file.length() - 1) {\n      return true;\n    }\n  }\n  to.append(file);\n  struct zip_stat zipStat;\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n \tsize_t datalen = prep->datalen;\n \tint ret = 0;\n \tif (datalen <= 0 || datalen > 32767 || !prep->data)\n \t\treturn -EINVAL;\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\tif (size > INT_MAX)\n\t\tsize = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov = &iov;\n\tiov.iov_len = size;\n\tiov.iov_base = ubuf;\n\tmsg.msg_name = (struct sockaddr *)&address;\n\tmsg.msg_namelen = sizeof(address);\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, size, flags);\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user(&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}", "target": 1}
{"code": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(port);\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\treturn sfd;\n}", "target": 1}
{"code": "int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tif ((fields->BufferOffset + fields->Len) > Stream_Length(s))\n\t\t\treturn -1;\n\t\tfields->Buffer = (PBYTE) malloc(fields->Len);\n\t\tif (!fields->Buffer)\n\t\t\treturn -1;\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Read(s, fields->Buffer, fields->Len);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void CScreenshotPortal::onScreenshot(sdbus::MethodCall& call) {\n    sdbus::ObjectPath requestHandle;\n    call >> requestHandle;\n    std::string appID;\n    call >> appID;\n    std::string parentWindow;\n    call >> parentWindow;\n    std::unordered_map<std::string, sdbus::Variant> options;\n    call >> options;\n    Debug::log(LOG, \"[screenshot] New screenshot request:\");\n    Debug::log(LOG, \"[screenshot]  | {}\", requestHandle.c_str());\n    Debug::log(LOG, \"[screenshot]  | appid: {}\", appID);\n    bool isInteractive = options.count(\"interactive\") && options[\"interactive\"].get<bool>() && inShellPath(\"slurp\");\n    const std::string HYPR_DIR             = \"/tmp/hypr/\";\n    const std::string SNAP_FILE            = \"xdph_screenshot.png\";\n    const std::string FILE_PATH            = HYPR_DIR + SNAP_FILE;\n    const std::string SNAP_CMD             = \"grim \" + FILE_PATH;\n    const std::string SNAP_INTERACTIVE_CMD = \"grim -g \\\"$(slurp)\\\" \" + FILE_PATH;\n    std::unordered_map<std::string, sdbus::Variant> results;\n    results[\"uri\"] = \"file:\n    std::filesystem::remove(FILE_PATH);\n    std::filesystem::create_directory(HYPR_DIR);\n    if (isInteractive)\n        execAndGet(SNAP_INTERACTIVE_CMD.c_str());\n    else\n        execAndGet(SNAP_CMD.c_str());\n    uint32_t responseCode = std::filesystem::exists(FILE_PATH) ? 0 : 1;\n    auto reply = call.createReply();\n    reply << responseCode;\n    reply << results;\n    reply.send();\n}", "target": 1}
{"code": "static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XSAVES\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XSAVE\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tmsg->msg_namelen = 0;\n\tif (u->addr) {\n\t\tmsg->msg_namelen = u->addr->len;\n\t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n\t}\n}", "target": 1}
{"code": "int enc_untrusted_inet_pton(int af, const char *src, void *dst) {\n  if (!src || !dst) {\n    return 0;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{\n      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetPtonHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_pton\", 3);\n  int result = output.next<int>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return -1;\n  }\n  auto klinux_addr_buffer = output.next();\n  size_t max_size = 0;\n  if (af == AF_INET) {\n    max_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    max_size = sizeof(struct in6_addr);\n  }\n  memcpy(dst, klinux_addr_buffer.data(),\n         std::min(klinux_addr_buffer.size(), max_size));\n  return result;\n}", "target": 1}
{"code": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n    pc->last_index= pc->index;\n    if(next == END_NOT_FOUND){\n        void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n            return AVERROR(ENOMEM);\n        pc->buffer = new_buffer;\n        memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n        pc->index += *buf_size;\n        return -1;\n    }\n    *buf_size=\n    pc->overread_index= pc->index + next;\n    if(pc->index){\n        void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n            return AVERROR(ENOMEM);\n        pc->buffer = new_buffer;\n        if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n            memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n    return 0;\n}", "target": 1}
{"code": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}", "target": 1}
{"code": " static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData,\n                                    OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n {\n    OPJ_UINT32 x, y;\n     OPJ_UINT8 *pix;\n     const OPJ_UINT8 *beyond;\n     beyond = pData + stride * height;\n     pix = pData;\n    x = y = 0U;\n     while (y < height) {\n         int c = getc(IN);\n         if (c == EOF) {\n            break;\n        }\n        if (c) { \n            int j;\n            OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);\n             for (j = 0; (j < c) && (x < width) &&\n                     ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                 *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));\n             }\n         } else { \n             c = getc(IN);\n            if (c == EOF) {\n                break;\n            }\n            if (c == 0x00) { \n                x = 0;\n                y++;\n                pix = pData + y * stride;\n            } else if (c == 0x01) { \n                break;\n            } else if (c == 0x02) { \n                c = getc(IN);\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { \n                int j;\n                OPJ_UINT8 c1 = 0U;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    if ((j & 1) == 0) {\n                         c1 = (OPJ_UINT8)getc(IN);\n                     }\n                     *pix = (OPJ_UINT8)((j & 1) ? (c1 & 0x0fU) : ((c1 >> 4) & 0x0fU));\n                 }\n                 if (((c & 3) == 1) || ((c & 3) == 2)) { \n                     getc(IN);\n                 }\n             }\n         }\n     }  \n     return OPJ_TRUE;\n }", "target": 1}
{"code": "int ecall_answer(struct ecall *ecall, enum icall_call_type call_type,\n\t\t bool audio_cbr)\n{\n\tint err = 0;\n\tif (!ecall)\n\t\treturn EINVAL;\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d\\n\", ecall, ecall->econn, call_type);\n\tif (!ecall->econn) {\n\t\twarning(\"ecall: answer: econn does not exist!\\n\");\n\t\treturn ENOENT;\n\t}\n\tif (ECONN_PENDING_INCOMING != econn_current_state(ecall->econn)) {\n\t\tinfo(\"ecall(%p): answer: invalid state (%s)\\n\", ecall,\n\t\t     econn_state_name(econn_current_state(ecall->econn)));\n\t\treturn EPROTO;\n\t}\n\tif (!ecall->flow) {\n\t\twarning(\"ecall: answer: no mediaflow\\n\");\n\t\treturn EPROTO;\n\t}\n\tecall->call_type = call_type;\n\tIFLOW_CALL(ecall->flow, set_call_type, call_type);\n\tecall->audio_cbr = audio_cbr;\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n#if 0\n\tif (ecall->props_local) {\n\t\tconst char *vstate_string =\n\t\t\tcall_type == ICALL_CALL_TYPE_VIDEO ? \"true\" : \"false\";\n\t\tint err2 = econn_props_update(ecall->props_local, \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t}\n\t}\n#endif\n\terr = generate_or_gather_answer(ecall, ecall->econn);\n\tif (err) {\n\t\twarning(\"ecall: answer: failed to gather_or_answer\\n\");\n\t\tgoto out;\n\t}\n\tecall->answered = true;\n\tecall->audio_setup_time = -1;\n\tecall->call_estab_time = -1;\n\tecall->ts_answered = tmr_jiffies();\n out:\n\treturn err;\n}", "target": 1}
{"code": "inline typename V::MapType FBUnserializer<V>::unserializeMap() {\n  p_ += CODE_SIZE;\n  typename V::MapType ret = V::createMap();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    switch (code) {\n      case FB_SERIALIZE_VARCHAR:\n      case FB_SERIALIZE_STRING:\n        {\n          auto key = unserializeString();\n          auto value = unserializeThing();\n          V::mapSet(ret, std::move(key), std::move(value));\n        }\n        break;\n      default:\n        {\n          auto key = unserializeInt64();\n          auto value = unserializeThing();\n          V::mapSet(ret, std::move(key), std::move(value));\n        }\n    }\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "lyd_new_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}", "target": 1}
{"code": "static int l2cap_build_conf_req(struct sock *sk, void *data)\n{\n\tstruct l2cap_pinfo *pi = l2cap_pi(sk);\n\tstruct l2cap_conf_req *req = data;\n\tstruct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };\n\tvoid *ptr = req->data;\n\tBT_DBG(\"sk %p\", sk);\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tif (pi->imtu != L2CAP_DEFAULT_MTU)\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->imtu);\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\t\trfc.mode            = L2CAP_MODE_ERTM;\n\t\trfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;\n\t\trfc.max_transmit    = L2CAP_DEFAULT_MAX_RECEIVE;\n\t\trfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);\n\t\trfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);\n\t\trfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\tbreak;\n\t}\n\treq->dcid  = cpu_to_le16(pi->dcid);\n\treq->flags = cpu_to_le16(0);\n\treturn ptr - data;\n}", "target": 1}
{"code": " void * calloc(size_t n, size_t lb)\n {\n    if (lb && n > SIZE_MAX / lb)\n       return NULL;\n #   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 1}
{"code": "bool ReturnsValidPath(int dir_type) {\n  base::FilePath path;\n  bool result = PathService::Get(dir_type, &path);\n  bool check_path_exists = true;\n#if defined(OS_POSIX)\n  if (dir_type == base::DIR_CACHE)\n    check_path_exists = false;\n#endif\n#if defined(OS_LINUX)\n  if (dir_type == base::DIR_USER_DESKTOP)\n    check_path_exists = false;\n#endif\n#if defined(OS_WIN)\n  if (dir_type == base::DIR_DEFAULT_USER_QUICK_LAUNCH) {\n    if (base::win::GetVersion() < base::win::VERSION_VISTA) {\n      wchar_t default_profile_path[MAX_PATH];\n      DWORD size = arraysize(default_profile_path);\n      return (result &&\n              ::GetDefaultUserProfileDirectory(default_profile_path, &size) &&\n              StartsWith(path.value(), default_profile_path, false));\n    }\n  } else if (dir_type == base::DIR_TASKBAR_PINS) {\n    if (base::win::GetVersion() < base::win::VERSION_WIN7)\n       check_path_exists = false;\n   }\n #endif\n#if defined(OS_MAC)\n   if (dir_type != base::DIR_EXE && dir_type != base::DIR_MODULE &&\n       dir_type != base::FILE_EXE && dir_type != base::FILE_MODULE) {\n     if (path.ReferencesParent())\n      return false;\n  }\n#else\n  if (path.ReferencesParent())\n    return false;\n#endif\n  return result && !path.empty() && (!check_path_exists ||\n                                     file_util::PathExists(path));\n}", "target": 1}
{"code": " static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n {\n    FILE *fp = fopen(dest_filename, \"w\");\n     if (!fp)\n         return false;\n    unsigned fd = 0;\n    while (fd <= 99999) \n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    const int dest_fd = fileno(fp);\n    if (fchown(dest_fd, uid, gid) < 0)\n    {\n        perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dest_filename, (long)uid, (long)gid);\n        fclose(fp);\n        unlink(dest_filename);\n        return false;\n    }\n    fclose(fp);\n    return true;\n}", "target": 1}
{"code": "static inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn tfm->generate(tfm, src, slen, dst, dlen);\n}", "target": 1}
{"code": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n    return TPM_SUCCESS;\n}", "target": 1}
{"code": "struct vfsmount *collect_mounts(struct path *path)\n {\n \tstruct mount *tree;\n \tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n \tnamespace_unlock();\n \tif (IS_ERR(tree))\n \t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}", "target": 1}
{"code": "static int CFScanDump_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx);\n    if (argc != 3) {\n        return RedisModule_WrongArity(ctx);\n    }\n    long long pos;\n    if (RedisModule_StringToLongLong(argv[2], &pos) != REDISMODULE_OK) {\n        return RedisModule_ReplyWithError(ctx, \"Invalid position\");\n    }\n    RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_READ);\n    CuckooFilter *cf;\n    int status = cfGetFilter(key, &cf);\n    if (status != SB_OK) {\n        return RedisModule_ReplyWithError(ctx, statusStrerror(status));\n    }\n    RedisModule_ReplyWithArray(ctx, 2);\n    if (!cf->numItems) {\n        RedisModule_ReplyWithLongLong(ctx, 0);\n        RedisModule_ReplyWithNull(ctx);\n        return REDISMODULE_OK;\n    }\n    if (pos == 0) {\n        CFHeader header;\n        fillCFHeader(&header, cf);\n        RedisModule_ReplyWithLongLong(ctx, 1);\n        RedisModule_ReplyWithStringBuffer(ctx, (const char *)&header, sizeof header);\n        return REDISMODULE_OK;\n    }\n    size_t chunkLen = 0;\n    const char *chunk = CF_GetEncodedChunk(cf, &pos, &chunkLen, MAX_SCANDUMP_SIZE);\n    if (chunk == NULL) {\n        RedisModule_ReplyWithLongLong(ctx, 0);\n        RedisModule_ReplyWithNull(ctx);\n    } else {\n        RedisModule_ReplyWithLongLong(ctx, pos);\n        RedisModule_ReplyWithStringBuffer(ctx, chunk, chunkLen);\n    }\n    return REDISMODULE_OK;\n}", "target": 1}
{"code": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n {\n \t*px = 1.0;\n \t*py = 1.0;\n\t*pcode = ctx->img1.density_code;\n\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n\t\t*px = ctx->img1.density_x;\n\t\t*py = ctx->img1.density_y;\n\t\treturn 1;\n \t}\n\treturn 0;\n }", "target": 1}
{"code": "void exit_sem(struct task_struct *tsk)\n{\n\tstruct sem_undo_list *ulp;\n\tulp = tsk->sysvsem.undo_list;\n\tif (!ulp)\n\t\treturn;\n\ttsk->sysvsem.undo_list = NULL;\n\tif (!atomic_dec_and_test(&ulp->refcnt))\n\t\treturn;\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tstruct list_head tasks;\n\t\tint semid;\n\t\tint i;\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc)\n\t\t\tsemid = -1;\n\t\t else\n\t\t\tsemid = un->semid;\n\t\trcu_read_unlock();\n\t\tif (semid == -1)\n\t\t\tbreak;\n\t\tsma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);\n\t\tif (IS_ERR(sma))\n\t\t\tcontinue;\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\tsem_unlock(sma);\n\t\t\tcontinue;\n\t\t}\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&ulp->lock);\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&ulp->lock);\n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tstruct sem * semaphore = &sma->sem_base[i];\n\t\t\tif (un->semadj[i]) {\n\t\t\t\tsemaphore->semval += un->semadj[i];\n\t\t\t\tif (semaphore->semval < 0)\n\t\t\t\t\tsemaphore->semval = 0;\n\t\t\t\tif (semaphore->semval > SEMVMX)\n\t\t\t\t\tsemaphore->semval = SEMVMX;\n\t\t\t\tsemaphore->sempid = task_tgid_vnr(current);\n\t\t\t}\n\t\t}\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n\t\tsem_unlock(sma);\n\t\twake_up_sem_queue_do(&tasks);\n\t\tkfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);\n}", "target": 1}
{"code": "DownloadResult downloadFile(string url, string expectedETag)\n{\n    DownloadResult res;\n    Curl curl;\n    if (curl.fetch(url, expectedETag)) {\n        res.cached = false;\n        res.data = curl.data;\n    } else\n        res.cached = true;\n    res.etag = curl.etag;\n    return res;\n}", "target": 1}
{"code": "static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)\n {\n     const char *perm = \"add\";\n    if (uid >= AID_APP) {\n         return 0; \n     }\n return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;\n}", "target": 1}
{"code": "GF_Err stbl_AppendSize(GF_SampleTableBox *stbl, u32 size, u32 nb_pack)\n{\n\tu32 i;\n\tif (!nb_pack) nb_pack = 1;\n\tif (!stbl->SampleSize->sampleCount) {\n\t\tstbl->SampleSize->sampleSize = size;\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (stbl->SampleSize->sampleSize && (stbl->SampleSize->sampleSize==size)) {\n\t\tstbl->SampleSize->sampleCount += nb_pack;\n\t\treturn GF_OK;\n\t}\n\tif (!stbl->SampleSize->sizes || (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)) {\n\t\tBool init_table = (stbl->SampleSize->sizes==NULL) ? 1 : 0;\n\t\tALLOC_INC(stbl->SampleSize->alloc_size);\n\t\tif (stbl->SampleSize->sampleCount+nb_pack > stbl->SampleSize->alloc_size)\n\t\t\tstbl->SampleSize->alloc_size = stbl->SampleSize->sampleCount+nb_pack;\n\t\tstbl->SampleSize->sizes = (u32 *)gf_realloc(stbl->SampleSize->sizes, sizeof(u32)*stbl->SampleSize->alloc_size);\n\t\tif (!stbl->SampleSize->sizes) return GF_OUT_OF_MEM;\n\t\tmemset(&stbl->SampleSize->sizes[stbl->SampleSize->sampleCount], 0, sizeof(u32) * (stbl->SampleSize->alloc_size - stbl->SampleSize->sampleCount) );\n\t\tif (init_table) {\n\t\t\tfor (i=0; i<stbl->SampleSize->sampleCount; i++)\n\t\t\t\tstbl->SampleSize->sizes[i] = stbl->SampleSize->sampleSize;\n\t\t}\n\t}\n\tstbl->SampleSize->sampleSize = 0;\n\tfor (i=0; i<nb_pack; i++) {\n\t\tstbl->SampleSize->sizes[stbl->SampleSize->sampleCount+i] = size;\n\t}\n\tstbl->SampleSize->sampleCount += nb_pack;\n\tif (size > stbl->SampleSize->max_size)\n\t\tstbl->SampleSize->max_size = size;\n\tstbl->SampleSize->total_size += size;\n\tstbl->SampleSize->total_samples += nb_pack;\n\treturn GF_OK;\n}", "target": 1}
{"code": "TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T>::ConstVec input,\n                  const bool signed_input, const int num_bits,\n                  const bool range_given, Tensor* input_min_tensor,\n                  Tensor* input_max_tensor, QuantizerRoundMode round_mode,\n                  bool narrow_range, typename TTypes<T>::Vec out) {\n    QuantizeAndDequantizeOneScaleImpl<CPUDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }", "target": 1}
{"code": "int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,\n                          const unsigned char *server,\n                          unsigned int server_len,\n                          const unsigned char *client, unsigned int client_len)\n{\n    unsigned int i, j;\n    const unsigned char *result;\n    int status = OPENSSL_NPN_UNSUPPORTED;\n    for (i = 0; i < server_len;) {\n        for (j = 0; j < client_len;) {\n            if (server[i] == client[j] &&\n                memcmp(&server[i + 1], &client[j + 1], server[i]) == 0) {\n                result = &server[i];\n                status = OPENSSL_NPN_NEGOTIATED;\n                goto found;\n            }\n            j += client[j];\n            j++;\n        }\n        i += server[i];\n        i++;\n    }\n    result = client;\n    status = OPENSSL_NPN_NO_OVERLAP;\n found:\n    *out = (unsigned char *)result + 1;\n    *outlen = result[0];\n    return status;\n}", "target": 1}
{"code": "  bool ms_deliver_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    for (list<Dispatcher*>::iterator p = dispatchers.begin();\n\t p != dispatchers.end();\n\t ++p) {\n      if ((*p)->ms_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid, session_key))\n\treturn true;\n    }\n    return false;\n  }", "target": 1}
{"code": "static int mongo_cursor_get_more( mongo_cursor *cursor ) {\n    int res;\n    if( cursor->limit > 0 && cursor->seen >= cursor->limit ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply ) {\n        cursor->err = MONGO_CURSOR_INVALID;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply->fields.cursorID ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else {\n        char *data;\n        int sl = strlen( cursor->ns )+1;\n        int limit = 0;\n        mongo_message *mm;\n        if( cursor->limit > 0 )\n            limit = cursor->limit - cursor->seen;\n        mm = mongo_message_create( 16 \n                                   +4 \n                                   +sl\n                                   +4 \n                                   +8 \n                                   , 0, 0, MONGO_OP_GET_MORE );\n        data = &mm->data;\n        data = mongo_data_append32( data, &ZERO );\n        data = mongo_data_append( data, cursor->ns, sl );\n        data = mongo_data_append32( data, &limit );\n        mongo_data_append64( data, &cursor->reply->fields.cursorID );\n        bson_free( cursor->reply );\n        res = mongo_message_send( cursor->conn, mm );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        res = mongo_read_response( cursor->conn, &( cursor->reply ) );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        cursor->current.data = NULL;\n        cursor->seen += cursor->reply->fields.num;\n        return MONGO_OK;\n    }\n}", "target": 1}
{"code": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n \t\treturn -ENOMEM;\n \tsize = roundup(size, PAGE_SIZE);\n \tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n \t\treturn ret;\n \tbo->dumb = false;\n \tvirtio_gpu_init_ttm_placement(bo, pinned);\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\tif (ret != 0)\n\t\treturn ret;\n\t*bo_ptr = bo;\n\treturn 0;\n}", "target": 1}
{"code": "static void server_real_connect(SERVER_REC *server, IPADDR *ip,\n\t\t\t\tconst char *unix_socket)\n{\n\tGIOChannel *handle;\n\tIPADDR *own_ip = NULL;\n\tconst char *errmsg;\n\tchar *errmsg2;\n\tchar ipaddr[MAX_IP_LEN];\n        int port;\n\tg_return_if_fail(ip != NULL || unix_socket != NULL);\n\tsignal_emit(\"server connecting\", 2, server, ip);\n\tif (server->connrec->no_connect)\n\t\treturn;\n\tif (ip != NULL) {\n\t\town_ip = ip == NULL ? NULL :\n\t\t\t(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\n\t\t\t server->connrec->own_ip4);\n\t\tport = server->connrec->proxy != NULL ?\n\t\t\tserver->connrec->proxy_port : server->connrec->port;\n\t\thandle = server->connrec->use_ssl ?\n\t\t\tnet_connect_ip_ssl(ip, port, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\n\t\t\tnet_connect_ip(ip, port, own_ip);\n\t} else {\n\t\thandle = net_connect_unix(unix_socket);\n\t}\n\tif (handle == NULL) {\n\t\terrmsg = g_strerror(errno);\n\t\terrmsg2 = NULL;\n\t\tif (errno == EADDRNOTAVAIL) {\n\t\t\tif (own_ip != NULL) {\n\t\t\t\tnet_ip2host(own_ip, ipaddr);\n\t\t\t\terrmsg2 = g_strconcat(errmsg, \": \", ipaddr, NULL);\n\t\t\t}\n\t\t\tserver->no_reconnect = TRUE;\n\t\t}\n\t\tif (server->connrec->use_ssl && errno == ENOSYS)\n\t\t\tserver->no_reconnect = TRUE;\n\t\tserver->connection_lost = TRUE;\n\t\tserver_connect_failed(server, errmsg2 ? errmsg2 : errmsg);\n\t\tg_free(errmsg2);\n\t} else {\n\t\tserver->handle = net_sendbuffer_create(handle, 0);\n#ifdef HAVE_OPENSSL\n\t\tif (server->connrec->use_ssl)\n\t\t\tserver_connect_callback_init_ssl(server, handle);\n\t\telse\n#endif\n\t\tserver->connect_tag =\n\t\t\tg_input_add(handle, G_INPUT_WRITE | G_INPUT_READ,\n\t\t\t\t    (GInputFunction)\n\t\t\t\t    server_connect_callback_init,\n\t\t\t\t    server);\n\t}\n}", "target": 1}
{"code": "setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "snmp_mib_add(snmp_mib_resource_t *new_resource)\n{\n  snmp_mib_resource_t *resource;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, new_resource->oid) > 0) {\n      break;\n    }\n  }\n  if(resource == NULL) {\n    list_add(snmp_mib, new_resource);\n  } else {\n    list_insert(snmp_mib, new_resource, resource);\n  }\n#if LOG_LEVEL == LOG_LEVEL_DBG\n  LOG_DBG(\"Table after insert.\\n\");\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    snmp_oid_print(resource->oid);\n  }\n#endif \n}", "target": 1}
{"code": "static inline bool unconditional(const struct ip6t_ip6 *ipv6)\n{\n\tstatic const struct ip6t_ip6 uncond;\n\treturn memcmp(ipv6, &uncond, sizeof(uncond)) == 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& indices = context->input(0);\n    const Tensor& values = context->input(1);\n    const Tensor& shape = context->input(2);\n    const Tensor& weights = context->input(3);\n    bool use_weights = weights.NumElements() > 0;\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(indices.shape()),\n                errors::InvalidArgument(\n                    \"Input indices must be a 2-dimensional tensor. Got: \",\n                    indices.shape().DebugString()));\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == values.shape(),\n          errors::InvalidArgument(\n              \"Weights and values must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; values shape: \", values.shape().DebugString()));\n    }\n    bool is_1d = shape.NumElements() == 1;\n    int num_batches = is_1d ? 1 : shape.flat<int64>()(0);\n    int num_values = values.NumElements();\n    OP_REQUIRES(context, num_values == indices.shape().dim_size(0),\n                errors::InvalidArgument(\n                    \"Number of values must match first dimension of indices.\",\n                    \"Got \", num_values,\n                    \" values, indices shape: \", indices.shape().DebugString()));\n    const auto indices_values = indices.matrix<int64>();\n    const auto values_values = values.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    auto per_batch_counts = BatchedMap<W>(num_batches);\n    T max_value = 0;\n    for (int idx = 0; idx < num_values; ++idx) {\n      int batch = is_1d ? 0 : indices_values(idx, 0);\n      const auto& value = values_values(idx);\n      if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n        if (binary_output_) {\n          per_batch_counts[batch][value] = 1;\n        } else if (use_weights) {\n          per_batch_counts[batch][value] += weight_values(idx);\n        } else {\n          per_batch_counts[batch][value]++;\n        }\n        if (value > max_value) {\n          max_value = value;\n        }\n      }\n    }\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }", "target": 1}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n  const MagicInfo\n    *magic_info;    \n  FILE\n    *ps_file;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MagickPathExtent];    \n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MagickPathExtent);\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1}
{"code": "static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)\n{\n if (parcel == NULL) {\n return NULL;\n }\n     android::Parcel* p = android::parcelForJavaObject(env, parcel);\n     SkRegion* region = new SkRegion;\n    size_t size = p->readInt32();\n    region->readFromMemory(p->readInplace(size), size);\n     return reinterpret_cast<jlong>(region);\n }", "target": 1}
{"code": "BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  \n\tStream_Write_UINT8(s, iBitmapFormat);       \n\tStream_Write_UINT8(s, cache_brush->cx);     \n\tStream_Write_UINT8(s, cache_brush->cy);     \n\tStream_Write_UINT8(s, cache_brush->style);  \n\tStream_Write_UINT8(s, cache_brush->length); \n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "\tSpawnPreparationInfo prepareSpawn(const Options &options) {\n\t\tTRACE_POINT();\n\t\tSpawnPreparationInfo info;\n\t\tprepareChroot(info, options);\n\t\tinfo.userSwitching = prepareUserSwitching(options);\n\t\tprepareSwitchingWorkingDirectory(info, options);\n\t\tinferApplicationInfo(info);\n\t\treturn info;\n\t}", "target": 1}
{"code": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n \t    && !vendor_intel(ctxt))\n \t\treturn emulate_ud(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n \tsetup_syscalls_segments(ctxt, &cs, &ss);\n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n \tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n \tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n \t\tcs.d = 0;\n \t\tcs.l = 1;\n \t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n \tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n \tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n \treturn X86EMUL_CONTINUE;\n }", "target": 1}
{"code": "void CConfig::Write(CFile& File, unsigned int iIndentation) {\n    CString sIndentation = CString(iIndentation, '\\t');\n    for (const auto& it : m_ConfigEntries) {\n        for (const CString& sValue : it.second) {\n            File.Write(sIndentation + it.first + \" = \" + sValue + \"\\n\");\n        }\n    }\n    for (const auto& it : m_SubConfigs) {\n        for (const auto& it2 : it.second) {\n            File.Write(\"\\n\");\n            File.Write(sIndentation + \"<\" + it.first + \" \" + it2.first + \">\\n\");\n            it2.second.m_pSubConfig->Write(File, iIndentation + 1);\n            File.Write(sIndentation + \"</\" + it.first + \">\\n\");\n        }\n    }\n}", "target": 1}
{"code": "static void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** cksum, int * hash)\n{\n    xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)\"style\");\n    const xmlChar * xmlval;\n    *hash = XAR_CKSUM_NONE;\n    if (style == NULL) {\n        cli_dbgmsg(\"cli_scaxar: xmlTextReaderGetAttribute no style attribute \"\n                   \"for checksum element\\n\");\n    } else {\n        cli_dbgmsg(\"cli_scanxar: checksum algorithm is %s.\\n\", style);        \n        if (0 == xmlStrcasecmp(style, (const xmlChar *)\"sha1\")) {\n            *hash = XAR_CKSUM_SHA1;\n        } else if (0 == xmlStrcasecmp(style, (const xmlChar *)\"md5\")) {\n            *hash = XAR_CKSUM_MD5;\n        } else {\n            cli_dbgmsg(\"cli_scanxar: checksum algorithm %s is unsupported.\\n\", style);\n            *hash = XAR_CKSUM_OTHER;\n        }\n    }\n    if (style != NULL)\n        xmlFree(style);\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        xmlval = xmlTextReaderConstValue(reader);\n        if (xmlval) {\n            *cksum = xmlStrdup(xmlval); \n            cli_dbgmsg(\"cli_scanxar: checksum value is %s.\\n\", *cksum);\n        } else {\n            *cksum = NULL;\n            cli_dbgmsg(\"cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\\n\");           \n        }\n    }\n    else\n        cli_dbgmsg(\"cli_scanxar: No text for XML checksum element.\\n\");\n}", "target": 1}
{"code": "hostlist_matches_int(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = host_matches(parse_tree, pw, lhost, shost, m);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n{\n    int     i, id, dummy;\n    char   *buf, *c;\n    long    start, sz;\n    start = ftell(fp);\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))\n        {\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            while (SAFE_F(fp, (fgetc(fp) != 't')))\n                ; \n            sz = pdf->xrefs[i].end - ftell(fp);\n            buf = malloc(sz + 1);\n            SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");\n            buf[sz] = '\\0';\n            if (!(c = strstr(buf, \"/Root\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Root\") + 1);\n            free(buf);\n            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);\n            if (!buf || !(c = strstr(buf, \"/Pages\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Pages\") + 1);\n            load_kids(fp, id, &pdf->xrefs[i]);\n            free(buf); \n        }\n    }\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "static netdev_features_t bnx2x_features_check(struct sk_buff *skb,\n\t\t\t\t\t      struct net_device *dev,\n\t\t\t\t\t      netdev_features_t features)\n{\n\tfeatures = vlan_features_check(skb, features);\n\treturn vxlan_features_check(skb, features);\n}", "target": 1}
{"code": "gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n     }\n     if (src != tmp_im) {\n        gdFree(tmp_im);\n     }\n \treturn dst;\n}", "target": 1}
{"code": "static GF_AV1Config* AV1_DuplicateConfig(GF_AV1Config const * const cfg) {\n\tu32 i = 0;\n\tGF_AV1Config *out = gf_malloc(sizeof(GF_AV1Config));\n\tout->marker = cfg->marker;\n\tout->version = cfg->version;\n\tout->seq_profile = cfg->seq_profile;\n\tout->seq_level_idx_0 = cfg->seq_level_idx_0;\n\tout->seq_tier_0 = cfg->seq_tier_0;\n\tout->high_bitdepth = cfg->high_bitdepth;\n\tout->twelve_bit = cfg->twelve_bit;\n\tout->monochrome = cfg->monochrome;\n\tout->chroma_subsampling_x = cfg->chroma_subsampling_x;\n\tout->chroma_subsampling_y = cfg->chroma_subsampling_y;\n\tout->chroma_sample_position = cfg->chroma_sample_position;\n\tout->initial_presentation_delay_present = cfg->initial_presentation_delay_present;\n\tout->initial_presentation_delay_minus_one = cfg->initial_presentation_delay_minus_one;\n\tout->obu_array = gf_list_new();\n\tfor (i = 0; i<gf_list_count(cfg->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *dst = gf_malloc(sizeof(GF_AV1_OBUArrayEntry)), *src = gf_list_get(cfg->obu_array, i);\n\t\tdst->obu_length = src->obu_length;\n\t\tdst->obu_type = src->obu_type;\n\t\tdst->obu = gf_malloc((size_t)dst->obu_length);\n\t\tmemcpy(dst->obu, src->obu, (size_t)src->obu_length);\n\t\tgf_list_add(out->obu_array, dst);\n\t}\n\treturn out;\n}", "target": 1}
{"code": "static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}", "target": 1}
{"code": "static void mkiss_close(struct tty_struct *tty)\n{\n\tstruct mkiss *ax;\n\twrite_lock_irq(&disc_data_lock);\n\tax = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!ax)\n\t\treturn;\n\tif (!refcount_dec_and_test(&ax->refcnt))\n\t\twait_for_completion(&ax->dead);\n\tnetif_stop_queue(ax->dev);\n\tax->tty = NULL;\n\tunregister_netdev(ax->dev);\n\tkfree(ax->rbuff);\n\tkfree(ax->xbuff);\n\tfree_netdev(ax->dev);\n}", "target": 1}
{"code": "static int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t root_uid = make_kuid(net->user_ns, 0);\n\tkgid_t root_gid = make_kgid(net->user_ns, 0);\n\tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n\t    uid_eq(root_uid, current_uid())) {\n\t\tint mode = (table->mode >> 6) & 7;\n\t\treturn (mode << 6) | (mode << 3) | mode;\n\t}\n\tif (gid_eq(root_gid, current_gid())) {\n\t\tint mode = (table->mode >> 3) & 7;\n\t\treturn (mode << 3) | mode;\n\t}\n\treturn table->mode;\n}", "target": 1}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  size_t * D = (size_t *) dest;\n  size_t * S = (size_t *) src;\n  size_t L = len / sizeof(size_t);\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] ^= S[i];\n}", "target": 1}
{"code": "void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {\n\tbloc = *offset;\n\tsend(huff->loc[ch], NULL, fout);\n\t*offset = bloc;\n}", "target": 1}
{"code": "void mt_init(mtrand *mt, uint32_t seed) {\n  int i;\n  mt->mt_buffer_[0] = seed;\n  mt->mt_index_ = MT_LEN;\n  for (i = 1; i < MT_LEN; i++) {\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^ \n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}", "target": 1}
{"code": "int pdf_is_pdf(FILE *fp)\n{\n    int   is_pdf;\n    char *header;\n    header = get_header(fp);\n    if (header && strstr(header, \"%PDF-\"))\n      is_pdf = 1;\n    else \n      is_pdf = 0;\n    free(header);\n    return is_pdf;\n}", "target": 1}
{"code": "get_cookies (SoupCookieJar *jar, SoupURI *uri, gboolean for_http, gboolean copy_cookies)\n{\n\tSoupCookieJarPrivate *priv;\n\tGSList *cookies, *domain_cookies;\n\tchar *domain, *cur, *next_domain;\n\tGSList *new_head, *cookies_to_remove = NULL, *p;\n\tpriv = soup_cookie_jar_get_instance_private (jar);\n\tif (!uri->host)\n\t\treturn NULL;\n\tcookies = NULL;\n\tdomain = cur = g_strdup_printf (\".%s\", uri->host);\n\tnext_domain = domain + 1;\n\tdo {\n\t\tnew_head = domain_cookies = g_hash_table_lookup (priv->domains, cur);\n\t\twhile (domain_cookies) {\n\t\t\tGSList *next = domain_cookies->next;\n\t\t\tSoupCookie *cookie = domain_cookies->data;\n\t\t\tif (cookie->expires && soup_date_is_past (cookie->expires)) {\n\t\t\t\tcookies_to_remove = g_slist_append (cookies_to_remove,\n\t\t\t\t\t\t\t\t    cookie);\n\t\t\t\tnew_head = g_slist_delete_link (new_head, domain_cookies);\n\t\t\t\tg_hash_table_insert (priv->domains,\n\t\t\t\t\t\t     g_strdup (cur),\n\t\t\t\t\t\t     new_head);\n\t\t\t} else if (soup_cookie_applies_to_uri (cookie, uri) &&\n\t\t\t\t   (for_http || !cookie->http_only))\n\t\t\t\tcookies = g_slist_append (cookies, copy_cookies ? soup_cookie_copy (cookie) : cookie);\n\t\t\tdomain_cookies = next;\n\t\t}\n\t\tcur = next_domain;\n\t\tif (cur)\n\t\t\tnext_domain = strchr (cur + 1, '.');\n\t} while (cur);\n\tg_free (domain);\n\tfor (p = cookies_to_remove; p; p = p->next) {\n\t\tSoupCookie *cookie = p->data;\n\t\tsoup_cookie_jar_changed (jar, cookie, NULL);\n\t\tsoup_cookie_free (cookie);\n\t}\n\tg_slist_free (cookies_to_remove);\n\treturn g_slist_sort_with_data (cookies, compare_cookies, jar);\n}", "target": 1}
{"code": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\tat91_aes_init();\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\treturn rc;\n}", "target": 1}
{"code": "void DownloadUIAdapterDelegate::OpenItem(const OfflineItem& item,\n                                          int64_t offline_id) {\n   JNIEnv* env = AttachCurrentThread();\n   Java_OfflinePageDownloadBridge_openItem(\n      env, ConvertUTF8ToJavaString(env, item.page_url.spec()), offline_id);\n }", "target": 1}
{"code": "bool QODBCResult::prepare(const QString& query)\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    SQLRETURN r;\n    d->rInf.clear();\n    if (d->hStmt && d->isStmtHandleValid()) {\n        r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCResult::prepare: Unable to close statement\"_L1, d);\n            return false;\n        }\n    }\n    r  = SQLAllocHandle(SQL_HANDLE_STMT,\n                         d->dpDbc(),\n                         &d->hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCResult::prepare: Unable to allocate statement handle\"_L1, d);\n        return false;\n    }\n    d->updateStmtHandleState();\n    if (isForwardOnly()) {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                            SQL_IS_UINTEGER);\n    } else {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_STATIC,\n                            SQL_IS_UINTEGER);\n    }\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n            \"QODBCResult::reset: Unable to set 'SQL_CURSOR_STATIC' as statement attribute. \"\n            \"Please check your ODBC driver configuration\"), QSqlError::StatementError, d));\n        return false;\n    }\n    r = SQLPrepare(d->hStmt,\n                    toSQLTCHAR(query).data(),\n                    (SQLINTEGER) query.length());\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to prepare statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "pci_populate_msicap(struct msicap *msicap, int msgnum, int nextptr)\n{\n\tint mmc;\n\tassert((msgnum & (msgnum - 1)) == 0 && msgnum >= 1 && msgnum <= 32);\n\tmmc = ffs(msgnum) - 1;\n\tbzero(msicap, sizeof(struct msicap));\n\tmsicap->capid = PCIY_MSI;\n\tmsicap->nextptr = nextptr;\n\tmsicap->msgctrl = PCIM_MSICTRL_64BIT | (mmc << 1);\n}", "target": 1}
{"code": "static long btrfs_ioctl_dev_info(struct btrfs_fs_info *fs_info,\n\t\t\t\t void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_info_args *di_args;\n\tstruct btrfs_device *dev;\n\tint ret = 0;\n\tchar *s_uuid = NULL;\n\tdi_args = memdup_user(arg, sizeof(*di_args));\n\tif (IS_ERR(di_args))\n\t\treturn PTR_ERR(di_args);\n\tif (!btrfs_is_empty_uuid(di_args->uuid))\n\t\ts_uuid = di_args->uuid;\n\trcu_read_lock();\n\tdev = btrfs_find_device(fs_info->fs_devices, di_args->devid, s_uuid,\n\t\t\t\tNULL);\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tdi_args->devid = dev->devid;\n\tdi_args->bytes_used = btrfs_device_get_bytes_used(dev);\n\tdi_args->total_bytes = btrfs_device_get_total_bytes(dev);\n\tmemcpy(di_args->uuid, dev->uuid, sizeof(di_args->uuid));\n\tif (dev->name) {\n\t\tstrncpy(di_args->path, rcu_str_deref(dev->name),\n\t\t\t\tsizeof(di_args->path) - 1);\n\t\tdi_args->path[sizeof(di_args->path) - 1] = 0;\n\t} else {\n\t\tdi_args->path[0] = '\\0';\n\t}\nout:\n\trcu_read_unlock();\n\tif (ret == 0 && copy_to_user(arg, di_args, sizeof(*di_args)))\n\t\tret = -EFAULT;\n\tkfree(di_args);\n\treturn ret;\n}", "target": 1}
{"code": " void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n \tvpn_packet_t outpkt;\n \toutpkt.len = len;\n \tif(c->options & OPTION_TCPONLY)\n \t\toutpkt.priority = 0;\n\telse\n\t\toutpkt.priority = -1;\n\tmemcpy(outpkt.data, buffer, len);\n\treceive_packet(c->node, &outpkt);\n}", "target": 1}
{"code": "int64_t OutputFile::readImpl(char* , int64_t ) {\n  raise_warning(\"cannot read from a php:\n  return -1;\n}", "target": 1}
{"code": "void ZRtp::storeMsgTemp(ZrtpPacketBase* pkt) {\n    int32_t length = pkt->getLength() * ZRTP_WORD_SIZE;\n    memset(tempMsgBuffer, 0, sizeof(tempMsgBuffer));\n    memcpy(tempMsgBuffer, (uint8_t*)pkt->getHeaderBase(), length);\n    lengthOfMsgData = length;\n}", "target": 1}
{"code": "void poly_frommsg(poly *r, const uint8_t msg[KYBER_INDCPA_MSGBYTES])\n{\n  unsigned int i,j;\n  int16_t mask;\n#if (KYBER_INDCPA_MSGBYTES != KYBER_N/8)\n#error \"KYBER_INDCPA_MSGBYTES must be equal to KYBER_N/8 bytes!\"\n#endif\n  for(i=0;i<KYBER_N/8;i++) {\n    for(j=0;j<8;j++) {\n      mask = -(int16_t)((msg[i] >> j)&1);\n      r->coeffs[8*i+j] = mask & ((KYBER_Q+1)/2);\n    }\n  }\n}", "target": 1}
{"code": "static int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  Quantum\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "int nfc_disable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_DISABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->disable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_DISABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n}", "target": 1}
{"code": "lib_file_open(gs_file_path_ptr  lib_path, const gs_memory_t *mem, i_ctx_t *i_ctx_p,\n                       const char *fname, uint flen, char *buffer, int blen, uint *pclen, ref *pfile)\n{   \n    bool starting_arg_file = (i_ctx_p == NULL) ? true : i_ctx_p->starting_arg_file;\n    bool search_with_no_combine = false;\n    bool search_with_combine = false;\n    char fmode[2] = { 'r', 0};\n    gx_io_device *iodev = iodev_default(mem);\n     gs_main_instance *minst = get_minst_from_memory(mem);\n     int code;\n     if (iodev == 0)\n         iodev = (gx_io_device *)gx_io_device_table[0];\n       search_with_combine = false;\n    } else {\n       search_with_no_combine = starting_arg_file;\n       search_with_combine = true;\n    }", "target": 1}
{"code": "PyImaging_LibTiffDecoderNew(PyObject* self, PyObject* args)\n{\n    ImagingDecoderObject* decoder;\n    char* mode;\n    char* rawmode;\n    char* compname;\n    int compression;\n    int fp;\n    if (! PyArg_ParseTuple(args, \"sssi\", &mode, &rawmode, &compname, &fp))\n        return NULL;\n    TRACE((\"new tiff decoder %s\\n\", compname));\n    if (strcasecmp(compname, \"tiff_ccitt\") == 0) {\n        compression = COMPRESSION_CCITTRLE;\n    } else if (strcasecmp(compname, \"group3\") == 0) {\n        compression = COMPRESSION_CCITTFAX3;\n    } else if (strcasecmp(compname, \"group4\") == 0) {\n        compression = COMPRESSION_CCITTFAX4;\n    } else if (strcasecmp(compname, \"tiff_raw_16\") == 0) {\n        compression = COMPRESSION_CCITTRLEW;\n    } else {\n        PyErr_SetString(PyExc_ValueError, \"unknown compession\");\n        return NULL;\n    }\n    decoder = PyImaging_DecoderNew(sizeof(TIFFSTATE));\n    if (decoder == NULL)\n        return NULL;\n    if (get_unpacker(decoder, mode, rawmode) < 0)\n        return NULL;\n    if (! ImagingLibTiffInit(&decoder->state, compression, fp)) {\n        Py_DECREF(decoder);\n        PyErr_SetString(PyExc_RuntimeError, \"tiff codec initialization failed\");\n        return NULL;\n    }\n    decoder->decode  = ImagingLibTiffDecode;\n    return (PyObject*) decoder;\n}", "target": 1}
{"code": "  SPLITS_TYPE RangeSize(T start, T limit, T delta) {\n    if (((delta > 0) && (limit < start)) || ((delta < 0) && (limit > start))) {\n      return 0;\n    }\n    return (std::is_integral<T>::value\n                ? ((std::abs(limit - start) + std::abs(delta) - 1) /\n                   std::abs(delta))\n                : std::ceil(std::abs((limit - start) / delta)));\n  }", "target": 1}
{"code": "void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\tif (!handle)\n\t\treturn NULL;\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\treturn pointer;\n}", "target": 1}
{"code": "static Image *ReadDOTImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    command[MagickPathExtent];\n  const char\n    *option;\n  graph_t\n    *graph;\n  Image\n    *image;\n  ImageInfo\n    *read_info;\n  MagickBooleanType\n    status;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  assert(graphic_context != (GVC_t *) NULL);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MagickPathExtent);\n  (void) AcquireUniqueFilename(read_info->filename);\n  (void) FormatLocaleString(command,MagickPathExtent,\"-Tsvg -o%s %s\",\n    read_info->filename,image_info->filename);\n#if !defined(WITH_CGRAPH)\n  graph=agread(GetBlobFileHandle(image));\n#else\n  graph=agread(GetBlobFileHandle(image),(Agdisc_t *) NULL);\n#endif\n  if (graph == (graph_t *) NULL)\n    {\n      (void) RelinquishUniqueFileResource(read_info->filename);\n      return ((Image *) NULL);\n    }\n  option=GetImageOption(image_info,\"dot:layout-engine\");\n  if (option == (const char *) NULL)\n    gvLayout(graphic_context,graph,(char *) \"dot\");\n  else\n    gvLayout(graphic_context,graph,(char *) option);\n  gvRenderFilename(graphic_context,graph,(char *) \"svg\",read_info->filename);\n  gvFreeLayout(graphic_context,graph);\n  agclose(graph);\n  (void) CopyMagickString(read_info->magick,\"SVG\",MaxTextExtent);\n  image=ReadImage(read_info,exception);\n  (void) RelinquishUniqueFileResource(read_info->filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  return(GetFirstImageInList(image));\n}", "target": 1}
{"code": "find_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n    if (!is_referral_req(kdc_active_realm, request))\n        goto cleanup;\n    hostname = data2string(krb5_princ_component(kdc_context,\n                                                request->server, 1));\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(kdc_context, hostname, &realms);\n    if (retval) {\n        kdc_err(kdc_context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    if (realms == NULL || realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(kdc_context, realms);\n    free(hostname);\n    return retval;\n}", "target": 1}
{"code": "        int          GetS16BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 1 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            if ( nRes & 0x8000 )\n                nRes |= ~0xffff;\n            return nRes;\n        }", "target": 1}
{"code": "static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n\t\tunsigned long arg)\n{\n\tstruct sem_undo *un;\n\tstruct sem_array *sma;\n\tstruct sem* curr;\n\tint err;\n\tint nsems;\n\tstruct list_head tasks;\n\tint val;\n#if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\n\tval = arg >> 32;\n#else\n\tval = arg;\n#endif\n\tsma = sem_lock_check(ns, semid);\n\tif (IS_ERR(sma))\n\t\treturn PTR_ERR(sma);\n\tINIT_LIST_HEAD(&tasks);\n\tnsems = sma->sem_nsems;\n\terr = -EACCES;\n\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO))\n\t\tgoto out_unlock;\n\terr = security_sem_semctl(sma, SETVAL);\n\tif (err)\n\t\tgoto out_unlock;\n\terr = -EINVAL;\n\tif(semnum < 0 || semnum >= nsems)\n\t\tgoto out_unlock;\n\tcurr = &sma->sem_base[semnum];\n\terr = -ERANGE;\n\tif (val > SEMVMX || val < 0)\n\t\tgoto out_unlock;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry(un, &sma->list_id, list_id)\n\t\tun->semadj[semnum] = 0;\n\tcurr->semval = val;\n\tcurr->sempid = task_tgid_vnr(current);\n\tsma->sem_ctime = get_seconds();\n\tdo_smart_update(sma, NULL, 0, 0, &tasks);\n\terr = 0;\nout_unlock:\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\treturn err;\n}", "target": 1}
{"code": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n{\n\t*px = 1.0;\n\t*py = 1.0;\n\t*pcode = ctx->img1.density_code;\n\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n\t\t*px = ctx->img1.density_x;\n\t\t*py = ctx->img1.density_y;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "bool ExtractUnixLink50(CommandData *Cmd,const wchar *Name,FileHeader *hd)\n{\n  char Target[NM];\n  WideToChar(hd->RedirName,Target,ASIZE(Target));\n  if (hd->RedirType==FSREDIR_WINSYMLINK || hd->RedirType==FSREDIR_JUNCTION)\n  {\n    if (strncmp(Target,\"\\\\??\\\\\",4)==0 || strncmp(Target,\"/\\?\\?/\",4)==0)\n      return false;\n    DosSlashToUnix(Target,Target,ASIZE(Target));\n  }\n  wchar TargetW[NM];\n  if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n    return false;\n  if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n      !IsRelativeSymlinkSafe(Cmd,hd->FileName,Name,TargetW)))\n    return false;\n  return UnixSymlink(Cmd,Target,Name,&hd->mtime,&hd->atime);\n}", "target": 1}
{"code": "pkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n    *valid_kdcPkId = 0;\n    pkiDebug(\"found kdcPkId in AS REQ\\n\");\n    is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n    if (is == NULL)\n        goto cleanup;\n    status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n    if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n    }\n    retval = 0;\ncleanup:\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n    return retval;\n}", "target": 1}
{"code": "grub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,\n                     struct grub_ext4_extent_header *ext_block,\n                     grub_uint32_t fileblock)\n{\n  struct grub_ext4_extent_idx *index;\n  while (1)\n    {\n      int i;\n      grub_disk_addr_t block;\n      index = (struct grub_ext4_extent_idx *) (ext_block + 1);\n      if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)\n        return 0;\n      if (ext_block->depth == 0)\n        return ext_block;\n      for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32(index[i].block))\n            break;\n        }\n      if (--i < 0)\n        return 0;\n      block = grub_le_to_cpu16 (index[i].leaf_hi);\n      block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);\n      if (grub_disk_read (data->disk,\n                          block << LOG2_EXT2_BLOCK_SIZE (data),\n                          0, EXT2_BLOCK_SIZE(data), buf))\n        return 0;\n      ext_block = (struct grub_ext4_extent_header *) buf;\n    }\n}", "target": 1}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static void mdbEvalSetColumnJSON(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    if (field->isnull) {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    const char *zBlob = \"\";\n    int bytes = 0;\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_STRING:\n            zBlob = field->buffer.vstring;\n        default:\n        {\n            if( !zBlob ) {\n                Jsi_DSAppend(dStr, \"null\", NULL);\n                return;\n            }\n            Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n            return;\n        }\n    }\n}", "target": 1}
{"code": "snmpDecodePacket(SnmpRequest * rq)\n{\n    struct snmp_pdu *PDU;\n    u_char *Community;\n    u_char *buf = rq->buf;\n    int len = rq->len;\n    if (!Config.accessList.snmp) {\n        debugs(49, DBG_IMPORTANT, \"WARNING: snmp_access not configured. agent query DENIED from : \" << rq->from);\n        return;\n    }\n    debugs(49, 5, HERE << \"Called.\");\n    PDU = snmp_pdu_create(0);\n    rq->session.Version = SNMP_VERSION_1;\n    Community = snmp_parse(&rq->session, PDU, buf, len);\n    if (Community) {\n        ACLFilledChecklist checklist(Config.accessList.snmp, NULL, NULL);\n        checklist.src_addr = rq->from;\n        checklist.snmp_community = (char *) Community;\n        if (checklist.fastCheck().allowed() && (snmp_coexist_V2toV1(PDU))) {\n            rq->community = Community;\n            rq->PDU = PDU;\n            debugs(49, 5, \"snmpAgentParse: reqid=[\" << PDU->reqid << \"]\");\n            snmpConstructReponse(rq);\n        } else {\n            debugs(49, DBG_IMPORTANT, \"WARNING: SNMP agent query DENIED from : \" << rq->from);\n        }\n        xfree(Community);\n    } else {\n        debugs(49, DBG_IMPORTANT, \"WARNING: Failed SNMP agent query from : \" << rq->from);\n        snmp_free_pdu(PDU);\n    }\n}", "target": 1}
{"code": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tiwl_sta_ucode_activate(priv, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "BPMDetect::BPMDetect(int numChannels, int aSampleRate) :\n    beat_lpf(_LPF_coeffs)\n{\n    beats.reserve(250); \n    this->sampleRate = aSampleRate;\n    this->channels = numChannels;\n    decimateSum = 0;\n    decimateCount = 0;\n    decimateBy = sampleRate / TARGET_SRATE;\n    assert(decimateBy > 0);\n    assert(INPUT_BLOCK_SIZE < decimateBy * DECIMATED_BLOCK_SIZE);\n    windowLen = (60 * sampleRate) / (decimateBy * MIN_BPM);\n    windowStart = (60 * sampleRate) / (decimateBy * MAX_BPM_RANGE);\n    assert(windowLen > windowStart);\n    xcorr = new float[windowLen];\n    memset(xcorr, 0, windowLen * sizeof(float));\n    pos = 0;\n    peakPos = 0;\n    peakVal = 0;\n    init_scaler = 1;\n    beatcorr_ringbuffpos = 0;\n    beatcorr_ringbuff = new float[windowLen];\n    memset(beatcorr_ringbuff, 0, windowLen * sizeof(float));\n    buffer = new FIFOSampleBuffer();\n    buffer->setChannels(1);\n    buffer->clear();\n    hamw = new float[XCORR_UPDATE_SEQUENCE];\n    hamming(hamw, XCORR_UPDATE_SEQUENCE);\n    hamw2 = new float[XCORR_UPDATE_SEQUENCE / 2];\n    hamming(hamw2, XCORR_UPDATE_SEQUENCE / 2);\n}", "target": 1}
{"code": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}", "target": 1}
{"code": "static int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n#ifdef\tCONFIG_USB_OTG\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc);\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}", "target": 1}
{"code": "static struct dentry *__lookup_hash(struct qstr *name,\n\t\tstruct dentry *base, struct nameidata *nd)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tint err;\n\tinode = base->d_inode;\n\tif (base->d_op && base->d_op->d_hash) {\n\t\terr = base->d_op->d_hash(base, name);\n\t\tdentry = ERR_PTR(err);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\tdentry = cached_lookup(base, name, nd);\n\tif (!dentry) {\n\t\tstruct dentry *new = d_alloc(base, name);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tif (!new)\n\t\t\tgoto out;\n\t\tdentry = inode->i_op->lookup(inode, new, nd);\n\t\tif (!dentry)\n\t\t\tdentry = new;\n\t\telse\n\t\t\tdput(new);\n\t}\nout:\n\treturn dentry;\n}", "target": 1}
{"code": " void ipc_rcu_putref(void *ptr)\n {\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n \t\treturn;\n \tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}", "target": 1}
{"code": "static void fio_cluster_listen_on_close(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  free(protocol);\n  cluster_data.uuid = -1;\n  if (fio_parent_pid() == getpid()) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) stopped listening for cluster connections\",\n                  (int)getpid());\n#endif\n    if (fio_data->active)\n      fio_stop();\n  }\n  (void)uuid;\n}", "target": 1}
{"code": "int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\treturn 1;\n}", "target": 1}
{"code": "err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\ttemp_s = mpz_to_n(&c, sig_len);\t\n        if(s_max_octets < sig_len) {\n            return \"2\"\"exponentiation failed; too many octets\";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n    padlen = sig_len - 3 - hash_len;\n    DBG(DBG_CRYPT,\n\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n \treturn \"3\"\"SIG padding does not check out\";\n     }\n    s += padlen + 3;\n    (*psig) = s;\n     return NULL;\n}", "target": 1}
{"code": "static void sas_eh_defer_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\tif (!dev_is_sata(dev)) {\n\t\tsas_eh_finish_cmd(cmd);\n\t\treturn;\n\t}\n\tsas_end_task(cmd, task);\n\tlist_move_tail(&cmd->eh_entry, &ha->eh_ata_q);\n}", "target": 1}
{"code": "static struct mount *clone_mnt(struct mount *old, struct dentry *root,\n\t\t\t\t\tint flag)\n{\n\tstruct super_block *sb = old->mnt.mnt_sb;\n\tstruct mount *mnt;\n\tint err;\n\tmnt = alloc_vfsmnt(old->mnt_devname);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))\n\t\tmnt->mnt_group_id = 0; \n\telse\n\t\tmnt->mnt_group_id = old->mnt_group_id;\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n \t}\n \tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~MNT_WRITE_HOLD;\n \tatomic_inc(&sb->s_active);\n \tmnt->mnt.mnt_sb = sb;\n \tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tbr_write_lock(&vfsmount_lock);\n\tlist_add_tail(&mnt->mnt_instance, &sb->s_mounts);\n\tbr_write_unlock(&vfsmount_lock);\n\tif ((flag & CL_SLAVE) ||\n\t    ((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {\n\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave_list);\n\t\tmnt->mnt_master = old;\n\t\tCLEAR_MNT_SHARED(mnt);\n\t} else if (!(flag & CL_PRIVATE)) {\n\t\tif ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))\n\t\t\tlist_add(&mnt->mnt_share, &old->mnt_share);\n\t\tif (IS_MNT_SLAVE(old))\n\t\t\tlist_add(&mnt->mnt_slave, &old->mnt_slave);\n\t\tmnt->mnt_master = old->mnt_master;\n\t}\n\tif (flag & CL_MAKE_SHARED)\n\t\tset_mnt_shared(mnt);\n\tif (flag & CL_EXPIRE) {\n\t\tif (!list_empty(&old->mnt_expire))\n\t\t\tlist_add(&mnt->mnt_expire, &old->mnt_expire);\n\t}\n\treturn mnt;\n out_free:\n\tfree_vfsmnt(mnt);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n {\n \tunsigned char *buf;\n\tassert(m->buf_);\n \tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n \t\treturn -1;\n \t}\n \tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "fu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tgint ret;\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n\t\treturn FALSE;\n\t}\n\tret = g_chmod(conf_path, 0660);\n\tif (ret == -1) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t    \"failed to set permissions on %s\",\n\t\t\t    conf_path);\n\t\treturn FALSE;\n\t}\n\treturn fu_plugin_set_config_value(self, key, value, error);\n}", "target": 1}
{"code": "int ZEXPORT deflatePrime (strm, bits, value)\n    z_streamp strm;\n    int bits;\n    int value;\n{\n    deflate_state *s;\n    int put;\n    if (deflateStateCheck(strm)) return Z_STREAM_ERROR;\n    s = strm->state;\n    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))\n        return Z_BUF_ERROR;\n    do {\n        put = Buf_size - s->bi_valid;\n        if (put > bits)\n            put = bits;\n        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);\n        s->bi_valid += put;\n        _tr_flush_bits(s);\n        value >>= put;\n        bits -= put;\n    } while (bits);\n    return Z_OK;\n}", "target": 1}
{"code": "static void on_underlying_io_bytes_received(void *context, const unsigned char *buffer, size_t size)\n{\n    if (context != NULL)\n    {\n        TLS_IO_INSTANCE *tls_io_instance = (TLS_IO_INSTANCE *)context;\n        unsigned char *new_socket_io_read_bytes = (unsigned char *)realloc(tls_io_instance->socket_io_read_bytes, tls_io_instance->socket_io_read_byte_count + size);\n        if (new_socket_io_read_bytes == NULL)\n        {\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else\n        {\n            tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;\n            (void)memcpy(tls_io_instance->socket_io_read_bytes + tls_io_instance->socket_io_read_byte_count, buffer, size);\n            tls_io_instance->socket_io_read_byte_count += size;\n        }\n    }\n    else\n    {\n        LogError(\"NULL value passed in context\");\n    }\n}", "target": 1}
{"code": "cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n \tif ((conn->validator == NULL) ||\n\t    cherokee_buffer_is_empty (&conn->validator->user))\n \t\treturn ret_error;\n \tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");\n\tif (size != conn->validator->user.len)\n\t\treturn ret_error;\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props->filter.buf ? props->filter.buf : \"\");\n\t\treturn ret_error;\n\t}\n\tTRACE (ENTRIES, \"subtree search (%s): done\\n\", ldap->filter.buf ? ldap->filter.buf : \"\");\n\tre = ldap_count_entries (ldap->conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tfirst = ldap_first_entry (ldap->conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tdn = ldap_get_dn (ldap->conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\tldap_msgfree (message);\n\tret = validate_dn (props, dn, conn->validator->passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_unbind_s (ldap->conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\tTRACE (ENTRIES, \"Access to use %s has been granted\\n\", conn->validator->user.buf);\n\treturn ret_ok;\n}", "target": 1}
{"code": "equal_h (const struct ecc_modulo *p,\n\t const mp_limb_t *x1, const mp_limb_t *z1,\n\t const mp_limb_t *x2, const mp_limb_t *z2,\n\t mp_limb_t *scratch)\n{\n#define t0 scratch\n#define t1 (scratch + p->size)\n  ecc_mod_mul (p, t0, x1, z2, t0);\n  if (mpn_cmp (t0, p->m, p->size) >= 0)\n    mpn_sub_n (t0, t0, p->m, p->size);\n  ecc_mod_mul (p, t1, x2, z1, t1);\n  if (mpn_cmp (t1, p->m, p->size) >= 0)\n    mpn_sub_n (t1, t1, p->m, p->size);\n  return mpn_cmp (t0, t1, p->size) == 0;\n#undef t0\n#undef t1\n}", "target": 1}
{"code": "static void sas_probe_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_PROBE, &port->disc.pending);\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\tsas_probe_sata(port);\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}", "target": 1}
{"code": "int mongo_env_write_socket( mongo *conn, const void *buf, int len ) {\n    const char *cbuf = buf;\n    int flags = 0;\n    while ( len ) {\n        int sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            conn->connected = 0;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n    return MONGO_OK;\n}", "target": 1}
{"code": "int ShellBrowserMain(const content::MainFunctionParams& parameters) {\n  bool layout_test_mode =\n      CommandLine::ForCurrentProcess()->HasSwitch(switches::kDumpRenderTree);\n  base::ScopedTempDir browser_context_path_for_layout_tests;\n  if (layout_test_mode) {\n    CHECK(browser_context_path_for_layout_tests.CreateUniqueTempDir());\n    CHECK(!browser_context_path_for_layout_tests.path().MaybeAsASCII().empty());\n    CommandLine::ForCurrentProcess()->AppendSwitchASCII(\n        switches::kContentShellDataPath,\n        browser_context_path_for_layout_tests.path().MaybeAsASCII());\n  }\n  scoped_ptr<content::BrowserMainRunner> main_runner_(\n      content::BrowserMainRunner::Create());\n  int exit_code = main_runner_->Initialize(parameters);\n  if (exit_code >= 0)\n    return exit_code;\n  if (CommandLine::ForCurrentProcess()->HasSwitch(\n        switches::kCheckLayoutTestSysDeps)) {\n    MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());\n    main_runner_->Run();\n    main_runner_->Shutdown();\n    return 0;\n  }\n  if (layout_test_mode) {\n    content::WebKitTestController test_controller;\n    std::string test_string;\n    CommandLine::StringVector args =\n        CommandLine::ForCurrentProcess()->GetArgs();\n    size_t command_line_position = 0;\n    bool ran_at_least_once = false;\n#if defined(OS_ANDROID)\n    std::cout << \"#READY\\n\";\n     std::cout.flush();\n #endif\n     while (GetNextTest(args, &command_line_position, &test_string)) {\n       if (test_string.empty())\n         continue;\n      if (test_string == \"QUIT\")\n        break;\n      bool enable_pixel_dumps;\n      std::string pixel_hash;\n      FilePath cwd;\n      GURL test_url = GetURLForLayoutTest(\n          test_string, &cwd, &enable_pixel_dumps, &pixel_hash);\n      if (!content::WebKitTestController::Get()->PrepareForLayoutTest(\n              test_url, cwd, enable_pixel_dumps, pixel_hash)) {\n        break;\n      }\n       ran_at_least_once = true;\n       main_runner_->Run();\n       if (!content::WebKitTestController::Get()->ResetAfterLayoutTest())\n         break;\n     }\n    if (!ran_at_least_once) {\n      MessageLoop::current()->PostTask(FROM_HERE, MessageLoop::QuitClosure());\n      main_runner_->Run();\n    }\n    exit_code = 0;\n  } else {\n    exit_code = main_runner_->Run();\n  }\n  main_runner_->Shutdown();\n  return exit_code;\n}", "target": 1}
{"code": "void HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {\n  headers_.remove_if([&](const HeaderEntryImpl& entry) {\n    bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());\n    if (to_remove) {\n      EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(entry.key().getStringView());\n      if (cb) {\n        StaticLookupResponse ref_lookup_response = cb(*this);\n        if (ref_lookup_response.entry_) {\n          *ref_lookup_response.entry_ = nullptr;\n        }\n      }\n    }\n    return to_remove;\n  });\n}", "target": 1}
{"code": "get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n \tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n \tint i;\n\twhile (leftover) {\n \t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n \t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\t\tleftover -= mc_size;\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\t\tucode_ptr += mc_size;\n\t}\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}", "target": 1}
{"code": "static void adu_disconnect(struct usb_interface *interface)\n{\n\tstruct adu_device *dev;\n\tdev = usb_get_intfdata(interface);\n\tmutex_lock(&dev->mtx);\t\n\tdev->udev = NULL;\t\n\tusb_deregister_dev(interface, &adu_class);\n\tmutex_unlock(&dev->mtx);\n\tmutex_lock(&adutux_mutex);\n\tusb_set_intfdata(interface, NULL);\n\tif (!dev->open_count)\n\t\tadu_delete(dev);\n\tmutex_unlock(&adutux_mutex);\n}", "target": 1}
{"code": "rpcap_remoteact_getsock(const char *host, int *error, char *errbuf)\n{\n\tstruct activehosts *temp;\t\t\t\n\tstruct addrinfo hints, *addrinfo, *ai_next;\t\n\tint retval;\n\taddrinfo = NULL;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\tretval = sock_initaddress(host, NULL, &hints, &addrinfo, errbuf,\n\t    PCAP_ERRBUF_SIZE);\n\tif (retval != 0)\n\t{\n\t\t*error = 1;\n\t\treturn NULL;\n\t}\n\ttemp = activeHosts;\n\twhile (temp)\n\t{\n\t\tai_next = addrinfo;\n\t\twhile (ai_next)\n\t\t{\n\t\t\tif (sock_cmpaddr(&temp->host, (struct sockaddr_storage *) ai_next->ai_addr) == 0)\n\t\t\t{\n\t\t\t\t*error = 0;\n\t\t\t\tfreeaddrinfo(addrinfo);\n\t\t\t\treturn temp;\n\t\t\t}\n\t\t\tai_next = ai_next->ai_next;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\t*error = 0;\n\treturn NULL;\n}", "target": 1}
{"code": "int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint res;\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\tif (IS_ERR(dst)) {\n\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\tsk->sk_route_caps = 0;\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(dst);\n\t}\n\trcu_read_lock();\n\tskb_dst_set_noref(skb, dst);\n\tfl6.daddr = sk->sk_v6_daddr;\n\tres = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\trcu_read_unlock();\n\treturn res;\n}", "target": 1}
{"code": "AsfVideo::HeaderReader::HeaderReader(const BasicIo::UniquePtr& io) : IdBuf_(GUID) {\n  if (io->size() >= io->tell() + GUID + QWORD) {\n    IdBuf_ = io->read(GUID);\n    size_ = readQWORDTag(io);\n    if (size_ >= GUID + QWORD)\n      remaining_size_ = size_ - GUID - QWORD;\n  }\n}", "target": 1}
{"code": "static int date_from_ISO8601 (const char *text, time_t * value) {\n   struct tm tm;\n * Begin Time Functions *\n ***********************/\n static int date_from_ISO8601 (const char *text, time_t * value) {\n    struct tm tm;\n    int n;\n    int i;\n       char buf[18];\n        if (strchr (text, '-')) {\n                char *p = (char *) text, *p2 = buf;\n   }\n                        if (*p != '-') {\n                                *p2 = *p;\n                                p2++;\n                        }\n                        p++;\n                }\n   }", "target": 1}
{"code": "openscript(\n    char_u\t*name,\n    int\t\tdirectly)\t\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\treturn;\n#endif\n    if (scriptin[curscript] != NULL)\t\n\t++curscript;\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t\n\trestart_edit = 0;\t\n\tp_im = FALSE;\t\t\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t\n\t    normal_cmd(&oa, FALSE);\t\n\t    vpeekc();\t\t\t\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}", "target": 1}
{"code": "void PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                             DatasetBase* input,\n                                             DatasetBase** output) {\n  int64_t num_threads = 0;\n  OP_REQUIRES_OK(\n      ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx, input, num_threads);\n}", "target": 1}
{"code": "static unsigned int seedsize(struct crypto_alg *alg)\n{\n\tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n\treturn alg->cra_rng.rng_make_random ?\n\t       alg->cra_rng.seedsize : ralg->seedsize;\n}", "target": 1}
{"code": "RsaAdjustPrimeCandidate(\n\t\t\tbigNum          prime\n\t\t\t)\n{\n    UINT16  highBytes;\n    crypt_uword_t       *msw = &prime->d[prime->size - 1];\n#define MASK (MAX_CRYPT_UWORD >> (RADIX_BITS - 16))\n    highBytes = *msw >> (RADIX_BITS - 16);\n    highBytes = ((UINT32)highBytes * (UINT32)0x4AFB) >> 16;\n    highBytes += 0xB505;\n    *msw = ((crypt_uword_t)(highBytes) << (RADIX_BITS - 16)) + (*msw & MASK);\n    prime->d[0] |= 1;\n}", "target": 1}
{"code": "dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 size;\n\tint end_offset;\n\tif (di->conformant_run)\n\t\treturn offset;\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_keybuffer_size, &size);\n\tend_offset = offset + (size*2);\n\tif (end_offset < offset) {\n\t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n\t}\n\twhile (offset < end_offset)\n\t\toffset = dissect_spoolss_uint16uni(\n\t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n\treturn offset;\n}", "target": 1}
{"code": " static int sock_close(struct inode *inode, struct file *filp)\n {\n\tsock_release(SOCKET_I(inode));\n \treturn 0;\n }", "target": 1}
{"code": "inline FIO_FUNC ssize_t fio_sendfile(intptr_t uuid, intptr_t source_fd,\n                                     off_t offset, size_t length) {\n  return fio_write2(uuid, .data.fd = source_fd, .length = length, .is_fd = 1,\n                    .offset = offset);\n}", "target": 1}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tlong ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n \tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Number of colors has to be greater than zero\");\n \t\tRETURN_FALSE;\n \t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n \tRETURN_TRUE;\n }", "target": 1}
{"code": "void DocumentWriter::setDecoder(TextResourceDecoder* decoder)\n{\n    m_decoder = decoder;\n}", "target": 1}
{"code": " void v9fs_device_unrealize_common(V9fsState *s, Error **errp)\n {\n    g_free(s->ctx.fs_root);\n     g_free(s->tag);\n }", "target": 1}
{"code": "int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\tif (ud->side == USBIP_STUB) {\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->actual_length;\n\t}\n \tif (!(size > 0))\n \t\treturn 0;\n \tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n \tif (ret != size) {\n \t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "gplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\n    PROCNAME(\"gplotMakeOutput\");\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n#ifndef _WIN32\n    snprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif  \n#ifndef OS_IOS \n    ignore = system(buf);  \n#endif \n    LEPT_FREE(cmdname);\n    return 0;\n}", "target": 1}
{"code": "R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find(cmd->aliases, k, NULL);\n}", "target": 1}
{"code": "int32_t ByteArray::Get(int32_t index) {\n  return InternalGet(index) & 0xff;\n}", "target": 1}
{"code": "vmxnet3_io_bar0_write(void *opaque, hwaddr addr,\n                      uint64_t val, unsigned size)\n {\n     VMXNET3State *s = opaque;\n     if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_TXPROD,\n                         VMXNET3_DEVICE_MAX_TX_QUEUES, VMXNET3_REG_ALIGN)) {\n         int tx_queue_idx =\n        return;\n    }\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_IMR,\n                        VMXNET3_MAX_INTRS, VMXNET3_REG_ALIGN)) {\n        int l = VMW_MULTIREG_IDX_BY_ADDR(addr, VMXNET3_REG_IMR,\n                                         VMXNET3_REG_ALIGN);\n        VMW_CBPRN(\"Interrupt mask for line %d written: 0x%\" PRIx64, l, val);\n        vmxnet3_on_interrupt_mask_changed(s, l, val);\n        return;\n    }\n    if (VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN) ||\n       VMW_IS_MULTIREG_ADDR(addr, VMXNET3_REG_RXPROD2,\n                        VMXNET3_DEVICE_MAX_RX_QUEUES, VMXNET3_REG_ALIGN)) {\n        return;\n    }\n    VMW_WRPRN(\"BAR0 unknown write [%\" PRIx64 \"] = %\" PRIx64 \", size %d\",\n              (uint64_t) addr, val, size);\n}", "target": 1}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 1}
{"code": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\toldsize += bits;\n\tif ( msg->maxsize - msg->cursize < 4 ) {\n\t\tmsg->overflowed = qtrue;\n\t\treturn;\n\t}\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\tif ( msg->oob ) {\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t} else if ( bits==32 ) {\n\t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 8);\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}", "target": 1}
{"code": "void CodeBlock::lazyCompileImpl(Runtime &runtime) {\n  assert(isLazy() && \"Laziness has not been checked\");\n  PerfSection perf(\"Lazy function compilation\");\n  auto *provider = (hbc::BCProviderLazy *)runtimeModule_->getBytecode();\n  auto *func = provider->getBytecodeFunction();\n  auto *lazyData = func->getLazyCompilationData();\n  auto bcModule = compileLazyFunction(lazyData);\n  runtimeModule_->initializeLazyMayAllocate(\n      hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(bcModule)));\n  functionID_ = runtimeModule_->getBytecode()->getGlobalFunctionIndex();\n  functionHeader_ =\n      runtimeModule_->getBytecode()->getFunctionHeader(functionID_);\n  bytecode_ = runtimeModule_->getBytecode()->getBytecode(functionID_);\n}", "target": 1}
{"code": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\tdo {\n\t\tnext = hugetlb_entry_end(h, addr, end);\n\t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\t\tif (pte && walk->hugetlb_entry)\n\t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr = next, addr != end);\n\treturn err;\n}", "target": 1}
{"code": "static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result = 0;\n\tif (!priv->comm_is_ok)\n\t\treturn -EIO;\n\tusb_clear_halt(serial->dev, 0x81);\n\tusb_clear_halt(serial->dev, 0x02);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->bytes_in = 0;\n\tpriv->bytes_out = 0;\n\tpriv->cmd_count = 0;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tcypress_send(port);\n\tif (tty)\n \t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n\tif (!port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"%s - interrupt_in_urb is empty!\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n \tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n \t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n \t\tport->interrupt_in_urb->transfer_buffer,\n\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv->read_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\treturn result;\n} ", "target": 1}
{"code": "mm_sshpam_init_ctx(Authctxt *authctxt)\n{\n\tBuffer m;\n\tint success;\n\tdebug3(\"%s\", __func__);\n\tbuffer_init(&m);\n\tbuffer_put_cstring(&m, authctxt->user);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);\n\tdebug3(\"%s: waiting for MONITOR_ANS_PAM_INIT_CTX\", __func__);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: pam_init_ctx failed\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (NULL);\n\t}\n\tbuffer_free(&m);\n\treturn (authctxt);\n}", "target": 1}
{"code": "  Status DoCompute(OpKernelContext* ctx) {\n    tensorflow::ResourceTagger tag(kTFDataResourceTag,\n                                   ctx->op_kernel().type_string());\n    tstring filename;\n    TF_RETURN_IF_ERROR(\n        ParseScalarArgument<tstring>(ctx, \"filename\", &filename));\n    tstring compression_type;\n    TF_RETURN_IF_ERROR(ParseScalarArgument<tstring>(ctx, \"compression_type\",\n                                                    &compression_type));\n    std::unique_ptr<WritableFile> file;\n    TF_RETURN_IF_ERROR(ctx->env()->NewWritableFile(filename, &file));\n    auto writer = absl::make_unique<io::RecordWriter>(\n        file.get(),\n        io::RecordWriterOptions::CreateRecordWriterOptions(compression_type));\n    DatasetBase* dataset;\n    TF_RETURN_IF_ERROR(GetDatasetFromVariantTensor(ctx->input(0), &dataset));\n    IteratorContext::Params params(ctx);\n    FunctionHandleCache function_handle_cache(params.flr);\n    params.function_handle_cache = &function_handle_cache;\n    ResourceMgr resource_mgr;\n    params.resource_mgr = &resource_mgr;\n    CancellationManager cancellation_manager(ctx->cancellation_manager());\n    params.cancellation_manager = &cancellation_manager;\n    IteratorContext iter_ctx(std::move(params));\n    DatasetBase* finalized_dataset;\n    TF_RETURN_IF_ERROR(FinalizeDataset(ctx, dataset, &finalized_dataset));\n    std::unique_ptr<IteratorBase> iterator;\n    TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(\n        &iter_ctx, nullptr, \"ToTFRecordOpIterator\", &iterator));\n    std::vector<Tensor> components;\n    components.reserve(finalized_dataset->output_dtypes().size());\n    bool end_of_sequence;\n    do {\n      TF_RETURN_IF_ERROR(\n          iterator->GetNext(&iter_ctx, &components, &end_of_sequence));\n      if (!end_of_sequence) {\n        TF_RETURN_IF_ERROR(\n            writer->WriteRecord(components[0].scalar<tstring>()()));\n      }\n      components.clear();\n    } while (!end_of_sequence);\n    return Status::OK();\n  }", "target": 1}
{"code": "mrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb_free(mrb, p);\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n  return p2;\n}", "target": 1}
{"code": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}", "target": 1}
{"code": "void RenderLayerScrollableArea::setScrollOffset(const IntPoint& newScrollOffset)\n{\n    if (!box().isMarquee()) {\n        if (m_scrollDimensionsDirty)\n            computeScrollDimensions();\n    }\n    if (scrollOffset() == toIntSize(newScrollOffset))\n        return;\n    setScrollOffset(toIntSize(newScrollOffset));\n    LocalFrame* frame = box().frame();\n    ASSERT(frame);\n    RefPtr<FrameView> frameView = box().frameView();\n    TRACE_EVENT1(TRACE_DISABLED_BY_DEFAULT(\"devtools.timeline\"), \"ScrollLayer\", \"data\", InspectorScrollLayerEvent::data(&box()));\n    InspectorInstrumentation::willScrollLayer(&box());\n    const RenderLayerModelObject* paintInvalidationContainer = box().containerForPaintInvalidation();\n    if (!frameView->isInPerformLayout()) {\n        layer()->clipper().clearClipRectsIncludingDescendants();\n         box().setPreviousPaintInvalidationRect(box().boundsRectForPaintInvalidation(paintInvalidationContainer));\n         frameView->updateAnnotatedRegions();\n        frameView->updateWidgetPositions();\n        RELEASE_ASSERT(frameView->renderView());\n         updateCompositingLayersAfterScroll();\n     }\n    frame->selection().setCaretRectNeedsUpdate();\n    FloatQuad quadForFakeMouseMoveEvent = FloatQuad(layer()->renderer()->previousPaintInvalidationRect());\n    quadForFakeMouseMoveEvent = paintInvalidationContainer->localToAbsoluteQuad(quadForFakeMouseMoveEvent);\n    frame->eventHandler().dispatchFakeMouseMoveEventSoonInQuad(quadForFakeMouseMoveEvent);\n    bool requiresPaintInvalidation = true;\n    if (!box().isMarquee() && box().view()->compositor()->inCompositingMode()) {\n        DisableCompositingQueryAsserts disabler;\n        bool onlyScrolledCompositedLayers = scrollsOverflow()\n            && !layer()->hasVisibleNonLayerContent()\n            && !layer()->hasNonCompositedChild()\n            && !layer()->hasBlockSelectionGapBounds()\n            && box().style()->backgroundLayers().attachment() != LocalBackgroundAttachment;\n        if (usesCompositedScrolling() || onlyScrolledCompositedLayers)\n            requiresPaintInvalidation = false;\n    }\n    if (requiresPaintInvalidation) {\n        if (box().frameView()->isInPerformLayout())\n            box().setShouldDoFullPaintInvalidation(true);\n        else\n            box().invalidatePaintUsingContainer(paintInvalidationContainer, layer()->renderer()->previousPaintInvalidationRect(), InvalidationScroll);\n    }\n    if (box().node())\n        box().node()->document().enqueueScrollEventForNode(box().node());\n    if (AXObjectCache* cache = box().document().existingAXObjectCache())\n        cache->handleScrollPositionChanged(&box());\n    InspectorInstrumentation::didScrollLayer(&box());\n}", "target": 1}
{"code": "static void coroutine_fn v9fs_xattrcreate(void *opaque)\n{\n    int flags;\n    int32_t fid;\n    int64_t size;\n    ssize_t err = 0;\n    V9fsString name;\n    size_t offset = 7;\n    V9fsFidState *file_fidp;\n    V9fsFidState *xattr_fidp;\n    V9fsPDU *pdu = opaque;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dsqd\", &fid, &name, &size, &flags);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_xattrcreate(pdu->tag, pdu->id, fid, name.data, size, flags);\n    file_fidp = get_fid(pdu, fid);\n    if (file_fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    xattr_fidp = file_fidp;\n    xattr_fidp->fid_type = P9_FID_XATTR;\n    xattr_fidp->fs.xattr.copied_len = 0;\n    xattr_fidp->fs.xattr.len = size;\n     xattr_fidp->fs.xattr.flags = flags;\n     v9fs_string_init(&xattr_fidp->fs.xattr.name);\n     v9fs_string_copy(&xattr_fidp->fs.xattr.name, &name);\n     xattr_fidp->fs.xattr.value = g_malloc0(size);\n     err = offset;\n     put_fid(pdu, file_fidp);\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n}", "target": 1}
{"code": "MONGO_EXPORT void *bson_malloc( int size ) {\n    void *p;\n    p = bson_malloc_func( size );\n    bson_fatal_msg( !!p, \"malloc() failed\" );\n    return p;\n}", "target": 1}
{"code": "void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;\n}", "target": 1}
{"code": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart;\n    Jsi_Obj *nobj, *obj;\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0),\n        *end = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!start) {\n        goto bail;\n    }\n    obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n    if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto done;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (n == 0) {\ndone:\n        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n        return JSI_OK;\n    }\n    Jsi_Number nend;\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto done;\n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        rc = Jsi_LogError(\"index too large: %d\", nsiz);\n        goto bail;\n    }\n    int i, m;\n    for (m = 0, i = istart; i <= iend; i++, m++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]);\n    }\n    Jsi_ObjSetLength(interp, nobj, nsiz);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}", "target": 1}
{"code": "  gray_render_span( int             y,\n                    int             count,\n                    const FT_Span*  spans,\n                    PWorker         worker )\n  {\n    unsigned char*  p;\n    FT_Bitmap*      map = &worker->target;\n     p = (unsigned char*)map->buffer - y * map->pitch;\n     if ( map->pitch >= 0 )\n      p += ( map->rows - 1 ) * map->pitch;\n     for ( ; count > 0; count--, spans++ )\n     {\n      unsigned char  coverage = spans->coverage;\n      if ( coverage )\n      {\n        if ( spans->len >= 8 )\n          FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );\n        else\n        {\n          unsigned char*  q = p + spans->x;\n          switch ( spans->len )\n          {\n          case 7: *q++ = (unsigned char)coverage;\n          case 6: *q++ = (unsigned char)coverage;\n          case 5: *q++ = (unsigned char)coverage;\n          case 4: *q++ = (unsigned char)coverage;\n          case 3: *q++ = (unsigned char)coverage;\n          case 2: *q++ = (unsigned char)coverage;\n          case 1: *q   = (unsigned char)coverage;\n          default:\n            ;\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n \t\t\tsa.aad.op = OP_SETPROCATTR;\n \t\t\tsa.aad.info = name;\n \t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n \t\t\t\t\t&sa, NULL);\n \t\t}\n \t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}", "target": 1}
{"code": "static Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (interp->breakpointHash)\n    {\n        int num;\n        char nbuf[100];\n        if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n            return Jsi_LogError(\"bad number\");\n        snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n        jsi_BreakPoint* bptr;\n        if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) {\n            switch (op) {\n                case 1: bptr->enabled = 0; break;\n                case 2: bptr->enabled = 1; break;\n                default:\n                    Jsi_HashEntryDelete(hPtr);\n            }\n            return JSI_OK;\n        }\n    }\n    return Jsi_LogError(\"unknown breakpoint\");\n}", "target": 1}
{"code": "void RateTransposer::setChannels(int nChannels)\n{\n    assert(nChannels > 0);\n    if (pTransposer->numChannels == nChannels) return;\n    pTransposer->setChannels(nChannels);\n    inputBuffer.setChannels(nChannels);\n    midBuffer.setChannels(nChannels);\n    outputBuffer.setChannels(nChannels);\n}", "target": 1}
{"code": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n    return -1;\n}", "target": 1}
{"code": "xmlStrncat(xmlChar *cur, const xmlChar *add, int len) {\n    int size;\n    xmlChar *ret;\n    if ((add == NULL) || (len == 0))\n        return(cur);\n    if (len < 0)\n\treturn(NULL);\n    if (cur == NULL)\n        return(xmlStrndup(add, len));\n    size = xmlStrlen(cur);\n    ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));\n    if (ret == NULL) {\n        xmlErrMemory(NULL, NULL);\n        return(cur);\n    }\n    memcpy(&ret[size], add, len * sizeof(xmlChar));\n    ret[size + len] = 0;\n    return(ret);\n}", "target": 1}
{"code": "_PUBLIC_ char *strupper_talloc_n_handle(struct smb_iconv_handle *iconv_handle,\n\t\t\t\t\tTALLOC_CTX *ctx, const char *src, size_t n)\n{\n\tsize_t size=0;\n\tchar *dest;\n\tif (!src) {\n\t\treturn NULL;\n\t}\n\tdest = talloc_array(ctx, char, 2*(n+1));\n\tif (dest == NULL) {\n                return NULL;\n        }\n       while (n-- && *src) {\n                size_t c_size;\n                codepoint_t c = next_codepoint_handle_ext(iconv_handle, src, n,\n                                                          CH_UNIX, &c_size);\n                src += c_size;\n                c = toupper_m(c);\n\t\tif (c_size == -1) {\n\t\t\ttalloc_free(dest);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize += c_size;\n\t}\n\tdest[size] = 0;\n\tdest = talloc_realloc(ctx, dest, char, size+1);\n\ttalloc_set_name_const(dest, dest);\n\treturn dest;\n}", "target": 1}
{"code": "static void get_socket_name(SingleInstData* data, char* buf, int len)\n{\n    const char* dpy = g_getenv(\"DISPLAY\");\n    char* host = NULL;\n    int dpynum;\n    if(dpy)\n    {\n        const char* p = strrchr(dpy, ':');\n        host = g_strndup(dpy, (p - dpy));\n        dpynum = atoi(p + 1);\n     }\n     else\n         dpynum = 0;\n     g_snprintf(buf, len, \"%s/.%s-socket-%s-%d-%s\",\n                 g_get_tmp_dir(),\n                 data->prog_name,\n                 host ? host : \"\",\n                 dpynum,\n                 g_get_user_name());\n }", "target": 1}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->input,\n                                               sgx_params->input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 1}
{"code": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); \n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); \n\treturn TRUE;\n}", "target": 1}
{"code": " static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n \t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n \t\trdesc[11] = rdesc[16] = 0xff;\n \t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                          char *buffer) {\n  uint16_t offset = 4 + (5 * 32);\n  int16_t len = msg->data_length - offset;\n  if (msg->has_data_length && len > 0) {\n    memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n    return len < 256 ? (uint8_t)len : 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "static int i2r_pci(X509V3_EXT_METHOD *method, PROXY_CERT_INFO_EXTENSION *pci,\n                   BIO *out, int indent)\n{\n    BIO_printf(out, \"%*sPath Length Constraint: \", indent, \"\");\n    if (pci->pcPathLengthConstraint)\n        i2a_ASN1_INTEGER(out, pci->pcPathLengthConstraint);\n    else\n        BIO_printf(out, \"infinite\");\n    BIO_puts(out, \"\\n\");\n    BIO_printf(out, \"%*sPolicy Language: \", indent, \"\");\n    i2a_ASN1_OBJECT(out, pci->proxyPolicy->policyLanguage);\n    BIO_puts(out, \"\\n\");\n    if (pci->proxyPolicy->policy && pci->proxyPolicy->policy->data)\n        BIO_printf(out, \"%*sPolicy Text: %s\\n\", indent, \"\",\n                   pci->proxyPolicy->policy->data);\n    return 1;\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "static void __nfs4_close(struct path *path, struct nfs4_state *state, mode_t mode, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tint newstate;\n\tatomic_inc(&owner->so_count);\n\tspin_lock(&owner->so_lock);\n\tswitch (mode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(path, state, wait);\n}", "target": 1}
{"code": "dns_resolver_match(const struct key *key,\n\t\t   const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\tkenter(\"%s,%s\", src, dsp);\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "static int irda_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\tint *uaddr_len, int peer)\n{\n\tstruct sockaddr_irda saddr;\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self = irda_sk(sk);\n\tif (peer) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\t\treturn -ENOTCONN;\n\t\tsaddr.sir_family = AF_IRDA;\n\t\tsaddr.sir_lsap_sel = self->dtsap_sel;\n\t\tsaddr.sir_addr = self->daddr;\n\t} else {\n\t\tsaddr.sir_family = AF_IRDA;\n\t\tsaddr.sir_lsap_sel = self->stsap_sel;\n\t\tsaddr.sir_addr = self->saddr;\n\t}\n\tIRDA_DEBUG(1, \"%s(), tsap_sel = %#x\\n\", __func__, saddr.sir_lsap_sel);\n\tIRDA_DEBUG(1, \"%s(), addr = %08x\\n\", __func__, saddr.sir_addr);\n\t*uaddr_len = sizeof (struct sockaddr_irda);\n\tmemcpy(uaddr, &saddr, *uaddr_len);\n\treturn 0;\n}", "target": 1}
{"code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n    free(ptr);\n    return nullptr;\n}", "target": 1}
{"code": "ptp_unpack_OPL (PTPParams *params, unsigned char* data, MTPProperties **pprops, unsigned int len)\n{ \n\tuint32_t prop_count = dtoh32a(data);\n\tMTPProperties *props = NULL;\n\tunsigned int offset = 0, i;\n\tif (prop_count == 0) {\n\t\t*pprops = NULL;\n\t\treturn 0;\n\t}\n\tptp_debug (params ,\"Unpacking MTP OPL, size %d (prop_count %d)\", len, prop_count);\n\tdata += sizeof(uint32_t);\n\tlen -= sizeof(uint32_t);\n\tprops = malloc(prop_count * sizeof(MTPProperties));\n\tif (!props) return 0;\n\tfor (i = 0; i < prop_count; i++) {\n\t\tif (len <= 0) {\n\t\t\tptp_debug (params ,\"short MTP Object Property List at property %d (of %d)\", i, prop_count);\n\t\t\tptp_debug (params ,\"device probably needs DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST_ALL\", i);\n\t\t\tptp_debug (params ,\"or even DEVICE_FLAG_BROKEN_MTPGETOBJPROPLIST\", i);\n\t\t\tqsort (props, i, sizeof(MTPProperties),_compare_func);\n\t\t\t*pprops = props;\n\t\t\treturn i;\n\t\t}\n\t\tprops[i].ObjectHandle = dtoh32a(data);\n\t\tdata += sizeof(uint32_t);\n\t\tlen -= sizeof(uint32_t);\n\t\tprops[i].property = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\t\tprops[i].datatype = dtoh16a(data);\n\t\tdata += sizeof(uint16_t);\n\t\tlen -= sizeof(uint16_t);\n\t\toffset = 0;\n\t\tptp_unpack_DPV(params, data, &offset, len, &props[i].propval, props[i].datatype);\n\t\tdata += offset;\n\t\tlen -= offset;\n\t}\n\tqsort (props, prop_count, sizeof(MTPProperties),_compare_func);\n\t*pprops = props;\n\treturn prop_count;\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    CHECK_GE(dtypes.size(), size_t{1});\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n\t\t\t     char *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\tentry->lsm[lsm_rule].type = audit_type;\n \tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n \t\t\t\t\t   Audit_equal, args,\n \t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n \treturn result;\n }", "target": 1}
{"code": " static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n {\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n }", "target": 1}
{"code": "static Status ValidateSavedTensors(const GraphDef& graph_def) {\n  for (const auto& node : graph_def.node()) {\n    TF_RETURN_IF_ERROR(ValidateNode(node));\n  }\n  if (graph_def.has_library()) {\n    const FunctionDefLibrary& library = graph_def.library();\n    for (const auto& function : library.function()) {\n      for (const auto& node : function.node_def()) {\n        TF_RETURN_IF_ERROR(ValidateNode(node));\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos,\n\tdouble *pv)\n{\n\tunsigned int field_type;\n\tunsigned int value_count;\n\tunsigned int value_pos;\n\tunsigned int numer, denom;\n\tfield_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian);\n\tvalue_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian);\n\tif(value_count!=1) return 0;\n\tif(field_type!=5) return 0; \n\tvalue_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian);\n\tif(value_pos > e->d_len-8) return 0;\n\tnumer = iw_get_ui32_e(&e->d[value_pos  ],e->endian);\n\tdenom = iw_get_ui32_e(&e->d[value_pos+4],e->endian);\n\tif(denom==0) return 0;\n\t*pv = ((double)numer)/denom;\n\treturn 1;\n}", "target": 1}
{"code": "njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n    length = array->length;\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n            prop->value = array->start[i];\n        }\n    }\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n    return NJS_OK;\n}", "target": 1}
{"code": "apr_byte_t oidc_cache_set(request_rec *r, const char *section, const char *key,\n\t\tconst char *value, apr_time_t expiry) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint encrypted = oidc_cfg_cache_encrypt(r);\n\tchar *encoded = NULL;\n\tapr_byte_t rc = FALSE;\n\tchar *msg = NULL;\n\toidc_debug(r,\n\t\t\t\"enter: %s (section=%s, len=%d, encrypt=%d, ttl(s)=%\" APR_TIME_T_FMT \", type=%s)\",\n\t\t\tkey, section, value ? (int )strlen(value) : 0, encrypted,\n\t\t\t\t\tapr_time_sec(expiry - apr_time_now()), cfg->cache->name);\n\tif (encrypted == 1) {\n\t\tkey = oidc_cache_get_hashed_key(r, cfg->crypto_passphrase, key);\n\t\tif (key == NULL)\n\t\t\tgoto out;\n\t\tif (value != NULL) {\n\t\t\tif (oidc_cache_crypto_encrypt(r, value,\n\t\t\t\t\toidc_cache_hash_passphrase(r, cfg->crypto_passphrase),\n\t\t\t\t\t&encoded) <= 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = encoded;\n\t\t}\n\t}\n\trc = cfg->cache->set(r, section, key, value, expiry);\nout:\n\tmsg = apr_psprintf(r->pool, \"%d bytes in %s cache backend for %skey %s\",\n\t\t\t(value ? (int) strlen(value) : 0),\n\t\t\t(cfg->cache->name ? cfg->cache->name : \"\"),\n\t\t\t(encrypted ? \"encrypted \" : \"\"), (key ? key : \"\"));\n\tif (rc == TRUE)\n\t\toidc_debug(r, \"successfully stored %s\", msg);\n\telse\n\t\toidc_warn(r, \"could NOT store %s\", msg);\n\treturn rc;\n}", "target": 1}
{"code": "static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u64 lun)\n{\n\tstruct adpt_device* d;\n\tif (chan >= MAX_CHANNEL)\n\t\treturn NULL;\n\td = pHba->channel[chan].device[id];\n\tif(!d || d->tid == 0) {\n\t\treturn NULL;\n\t}\n\tif(d->scsi_lun == lun){\n\t\treturn d;\n\t}\n\tfor(d=d->next_lun ; d ; d = d->next_lun){\n\t\tif(d->scsi_lun == lun){\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": " struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n {\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n }", "target": 1}
{"code": "TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,\n                             int axis, TfLiteTensor* output) {\n  const TfLiteIntArray& input_dims = *input.dims;\n  if (axis < 0) {\n    axis = input_dims.size + 1 + axis;\n  }\n  TF_LITE_ENSURE(context, axis <= input_dims.size);\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);\n  for (int i = 0; i < output_dims->size; ++i) {\n    if (i < axis) {\n      output_dims->data[i] = input_dims.data[i];\n    } else if (i == axis) {\n      output_dims->data[i] = 1;\n    } else {\n      output_dims->data[i] = input_dims.data[i - 1];\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 1}
{"code": "LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  \n    mask = 0;\n    func = NULL;\n  }\n  if (isLua(L->ci))\n    L->oldpc = L->ci->u.l.savedpc;\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  \n}", "target": 1}
{"code": "void AudioNode::Dispose() {\n  DCHECK(IsMainThread());\n#if DEBUG_AUDIONODE_REFERENCES\n  fprintf(stderr, \"[%16p]: %16p: %2d: AudioNode::dispose %16p\\n\", context(),\n          this, Handler().GetNodeType(), handler_.get());\n #endif\n   BaseAudioContext::GraphAutoLocker locker(context());\n   Handler().Dispose();\n  if (context()->HasRealtimeConstraint()) {\n     context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n         std::move(handler_));\n  } else {\n    if (context()->ContextState() == BaseAudioContext::kRunning) {\n      context()->GetDeferredTaskHandler().AddRenderingOrphanHandler(\n          std::move(handler_));\n    }\n   }\n }", "target": 1}
{"code": "gopherEndHTML(GopherStateData * gopherState)\n{\n    StoreEntry *e = gopherState->entry;\n    if (!gopherState->HTML_header_added) {\n        gopherHTMLHeader(e, \"Server Return Nothing\", nullptr);\n        storeAppendPrintf(e, \"<P>The Gopher query resulted in a blank response</P>\");\n    } else if (gopherState->HTML_pre) {\n        storeAppendPrintf(e, \"</PRE>\\n\");\n    }\n    gopherHTMLFooter(e);\n}", "target": 1}
{"code": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\twhile (begin && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\tif (!str[*begin]) {                \n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t} else if (isalpha ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t} else if (isdigit ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     \n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             \n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}", "target": 1}
{"code": "static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\treturn -ENOSYS;\n}", "target": 1}
{"code": "guestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  CLEANUP_FREE char **lines = NULL; \n  int64_t size;\n  char *ret;\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return safe_strdup (g, \"\");\n  }\n  ret = lines[0];               \n  return ret;\n}", "target": 1}
{"code": "pci_get_cfgdata32(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\treturn (*(uint32_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "int main(int argc, const char *argv[])\n{\n\tstruct group *grent;\n\tconst char *cmd;\n\tconst char *path;\n\tint i;\n\tstruct passwd *pw;\n\tgrent = getgrnam(ABUILD_GROUP);\n\tif (grent == NULL)\n\t\terrx(1, \"%s: Group not found\", ABUILD_GROUP);\n\tchar *name = NULL;\n\tpw = getpwuid(getuid());\n\tif (pw)\n\t\tname = pw->pw_name;\n\tif (!is_in_group(grent->gr_gid)) {\n\t\terrx(1, \"User %s is not a member of group %s\\n\",\n\t\t\tname ? name : \"(unknown)\", ABUILD_GROUP);\n\t}\n\tif (name == NULL)\n\t\twarnx(\"Could not find username for uid %d\\n\", getuid());\n\tsetenv(\"USER\", name ?: \"\", 1);\n\tcmd = strrchr(argv[0], '/');\n\tif (cmd)\n\t\tcmd++;\n\telse\n\t\tcmd = argv[0];\n\tcmd = strchr(cmd, '-');\n\tif (cmd == NULL)\n\t\terrx(1, \"Calling command has no '-'\");\n\tcmd++;\n\tpath = get_command_path(cmd);\n\tif (path == NULL)\n\t\terrx(1, \"%s: Not a valid subcommand\", cmd);\n\tfor (i = 1; i < argc; i++)\n\t\tif (strcmp(argv[i], \"--allow-untrusted\") == 0)\n\t\t\terrx(1, \"%s: not allowed option\", \"--allow-untrusted\");\n\targv[0] = path;\n\tsetuid(0);\n\tsetgid(0);\n\texecv(path, (char * const*)argv);\n\tperror(path);\n\treturn 1;\n}", "target": 1}
{"code": "int hashtable_init(hashtable_t *hashtable)\n{\n    size_t i;\n    hashtable->size = 0;\n    hashtable->num_buckets = 0;  \n    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    list_init(&hashtable->list);\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    return 0;\n}", "target": 1}
{"code": "_poppler_attachment_new (FileSpec *emb_file)\n{\n  PopplerAttachment *attachment;\n  PopplerAttachmentPrivate *priv;\n  EmbFile *embFile;\n  g_assert (emb_file != nullptr);\n  attachment = (PopplerAttachment *) g_object_new (POPPLER_TYPE_ATTACHMENT, nullptr);\n  priv = POPPLER_ATTACHMENT_GET_PRIVATE (attachment);\n  if (emb_file->getFileName ())\n    attachment->name = _poppler_goo_string_to_utf8 (emb_file->getFileName ());\n  if (emb_file->getDescription ())\n    attachment->description = _poppler_goo_string_to_utf8 (emb_file->getDescription ());\n  embFile = emb_file->getEmbeddedFile();\n  attachment->size = embFile->size ();\n  if (embFile->createDate ())\n    _poppler_convert_pdf_date_to_gtime (embFile->createDate (), (time_t *)&attachment->ctime);\n  if (embFile->modDate ())\n    _poppler_convert_pdf_date_to_gtime (embFile->modDate (), (time_t *)&attachment->mtime);\n  if (embFile->checksum () && embFile->checksum ()->getLength () > 0)\n    attachment->checksum = g_string_new_len (embFile->checksum ()->getCString (),\n                                             embFile->checksum ()->getLength ());\n  priv->obj_stream = embFile->streamObject()->copy();\n  return attachment;\n}", "target": 1}
{"code": "void queue_push(register Queue *qp, size_t extra_length, char const *info)\n{\n    register char *cp;\n    size_t memory_length;\n    size_t available_length;\n    size_t begin_length;\n    size_t n_begin;\n    size_t q_length;\n    if (!extra_length)\n        return;\n    memory_length    = qp->d_memory_end - qp->d_memory;\n    q_length = \n        qp->d_read <= qp->d_write ?\n            (size_t)(qp->d_write - qp->d_read)\n        :\n            memory_length - (qp->d_read - qp->d_write);\n    available_length = memory_length - q_length - 1;\n    if (message_show(MSG_INFO))\n        message(\"push_front %u bytes in `%s'\", (unsigned)extra_length, info);\n     if (extra_length > available_length)\n     {\n         memory_length += extra_length - available_length + BLOCK_QUEUE;\n         cp = new_memory(memory_length, sizeof(char));\n         if (message_show(MSG_INFO))\n            message(\"Reallocating queue at %p to %p\", qp->d_memory, cp);\n        if (qp->d_read > qp->d_write)               \n        {\n            size_t tail_len = qp->d_memory_end - qp->d_read;\n            memcpy(cp, qp->d_read, tail_len);       \n            memcpy(cp + tail_len, qp->d_memory, \n                                    (size_t)(qp->d_write - qp->d_memory));\n            qp->d_write = cp + q_length;\n            qp->d_read = cp;\n         }\n         else                                        \n         {\n            memcpy(cp, qp->d_memory, memory_length);\n             qp->d_read = cp + (qp->d_read - qp->d_memory);\n             qp->d_write = cp + (qp->d_write - qp->d_memory);\n         }\n        free(qp->d_memory);                         \n        qp->d_memory_end = cp + memory_length;      \n        qp->d_memory = cp;                          \n    }\n    begin_length = qp->d_read - qp->d_memory;   \n    n_begin = extra_length <= begin_length ?    \n                    extra_length                \n                :\n                    begin_length;\n    memcpy                                      \n    (                                           \n        qp->d_read -= n_begin,\n        info + extra_length - n_begin,\n        n_begin\n    );\n    if (extra_length > begin_length)            \n    {\n        extra_length -= begin_length;           \n        memcpy                                  \n        (                                       \n            qp->d_read = qp->d_memory_end - extra_length,\n            info,\n            extra_length\n        );\n    }\n}", "target": 1}
{"code": "rpmRC hdrblobInit(const void *uh, size_t uc,\n\t\trpmTagVal regionTag, int exact_size,\n\t\tstruct hdrblob_s *blob, char **emsg)\n{\n    rpmRC rc = RPMRC_FAIL;\n    memset(blob, 0, sizeof(*blob));\n    blob->ei = (int32_t *) uh; \n    blob->il = ntohl(blob->ei[0]);\n    blob->dl = ntohl(blob->ei[1]);\n    blob->pe = (entryInfo) &(blob->ei[2]);\n    blob->pvlen = sizeof(blob->il) + sizeof(blob->dl) +\n\t\t  (blob->il * sizeof(*blob->pe)) + blob->dl;\n    blob->dataStart = (uint8_t *) (blob->pe + blob->il);\n    blob->dataEnd = blob->dataStart + blob->dl;\n    if (blob->pvlen >= headerMaxbytes || (uc && blob->pvlen != uc)) {\n\trasprintf(emsg, _(\"blob size(%d): BAD, 8 + 16 * il(%d) + dl(%d)\"),\n\t\t\tblob->pvlen, blob->il, blob->dl);\n\tgoto exit;\n    }\n    if (hdrblobVerifyRegion(regionTag, exact_size, blob, emsg) == RPMRC_FAIL)\n\tgoto exit;\n    if (hdrblobVerifyInfo(blob, emsg))\n\tgoto exit;\n    rc = RPMRC_OK;\nexit:\n    return rc;\n}", "target": 1}
{"code": "  Status operator()(OpKernelContext* context,\n                    typename TTypes<Tindex>::ConstVec reverse_index_map,\n                    typename TTypes<T>::ConstVec grad_values,\n                    typename TTypes<T>::Vec d_values,\n                    typename TTypes<T>::Scalar d_default_value) {\n    const GPUDevice& device = context->eigen_device<GPUDevice>();\n    const Tindex N = reverse_index_map.dimension(0);\n    const Tindex N_full = grad_values.dimension(0);\n    Tensor visited_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(device) = visited.constant(false);\n    TF_RETURN_IF_ERROR(wrap_kernel_call(\n        GatherOriginalGradValuesKernel<T, Tindex>, device,\n        N, reverse_index_map, grad_values, d_values, visited));\n    gpuprim::CountingInputIterator<Tindex, Tindex> counting_iterator(Tindex(0));\n    ZeroMaskedValues<T, Tindex> mask_values_fn(visited.data(),\n                                               grad_values.data());\n    gpuprim::TransformInputIterator<T, decltype(mask_values_fn),\n                                    decltype(counting_iterator), Tindex>\n        transform_iterator(counting_iterator, mask_values_fn);\n    std::size_t temp_storage_bytes = 0;\n    auto gpuprim_status = gpuprim::DeviceReduce::Sum(\n        nullptr, temp_storage_bytes,\n        transform_iterator,\n        d_default_value.data(),\n        N_full,\n        device.stream());\n    if (gpuprim_status != gpuSuccess) {\n      return errors::Internal(\n          \"SparseFillEmptyRowsGrad: Could not launch \"\n          \"gpuprim::DeviceReduce::Sum to calculate temp_storage_bytes, \"\n          \"status: \",\n          GpuGetErrorString(gpuprim_status));\n    }\n    Tensor temp_storage;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        DT_INT8, TensorShape({static_cast<int64_t>(temp_storage_bytes)}),\n        &temp_storage));\n    gpuprim_status = gpuprim::DeviceReduce::Sum(\n        temp_storage.flat<int8>().data(), temp_storage_bytes,\n        transform_iterator,\n        d_default_value.data(),\n        N_full,\n        device.stream());\n    if (gpuprim_status != gpuSuccess) {\n      return errors::Internal(\n          \"SparseFillEmptyRowsGrad: Could not launch \"\n          \"gpuprim::DeviceReduce::Sum to sum values from originally-empty \"\n          \"rows. temp_storage_bytes: \",\n          temp_storage_bytes, \", status: \", GpuGetErrorString(gpuprim_status));\n    }\n    return OkStatus();\n  }", "target": 1}
{"code": "look_for_existing_users_sync (GdmDisplay *self)\n{\n        GdmDisplayPrivate *priv;\n        GError *error = NULL;\n        GVariant *call_result;\n        GVariant *user_list;\n        priv = gdm_display_get_instance_private (self);\n        priv->accountsservice_proxy = g_dbus_proxy_new_sync (priv->connection,\n                                                             0, NULL,\n                                                             \"org.freedesktop.Accounts\",\n                                                             \"/org/freedesktop/Accounts\",\n                                                             \"org.freedesktop.Accounts\",\n                                                             NULL,\n                                                             &error);\n        if (!priv->accountsservice_proxy) {\n                g_critical (\"Failed to contact accountsservice: %s\", error->message);\n                goto out;\n        }\n        call_result = g_dbus_proxy_call_sync (priv->accountsservice_proxy,\n                                              \"ListCachedUsers\",\n                                              NULL,\n                                              0,\n                                              -1,\n                                              NULL,\n                                              &error);\n        if (!call_result) {\n                g_critical (\"Failed to list cached users: %s\", error->message);\n                goto out;\n        }\n        g_variant_get (call_result, \"(@ao)\", &user_list);\n        priv->have_existing_user_accounts = g_variant_n_children (user_list) > 0;\n        g_variant_unref (user_list);\n        g_variant_unref (call_result);\nout:\n        g_clear_error (&error);\n        return priv->accountsservice_proxy != NULL && call_result != NULL;\n}", "target": 1}
{"code": "static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n \tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n \t\tstruct llc_pktinfo info;\n \t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n \t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n \t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}", "target": 1}
{"code": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n     ASN1_TIME atm;\n     long offset;\n     char buff1[24], buff2[24], *p;\n    int i, j;\n     p = buff1;\n    i = ctm->length;\n     str = (char *)ctm->data;\n     if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n             return 0;\n         memcpy(p, str, 10);\n         p += 10;\n         str += 10;\n     } else {\n        if (i < 13)\n             return 0;\n         memcpy(p, str, 12);\n         p += 12;\n         str += 12;\n     }\n     if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n         *(p++) = '0';\n         *(p++) = '0';\n     } else {\n         *(p++) = *(str++);\n         *(p++) = *(str++);\n        if (*str == '.') {\n             str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n         }\n     }\n     *(p++) = 'Z';\n     *(p++) = '\\0';\n    if (*str == 'Z')\n         offset = 0;\n    else {\n         if ((*str != '+') && (*str != '-'))\n             return 0;\n         offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n         offset += (str[3] - '0') * 10 + (str[4] - '0');\n         if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           \n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 \n        return -1;\n    else\n        return i;\n}", "target": 1}
{"code": "spell_read_tree(\n    FILE\t*fd,\n    char_u\t**bytsp,\n    idx_T\t**idxsp,\n    int\t\tprefixtree,\t\n    int\t\tprefixcnt)\t\n{\n    int\t\tlen;\n    int\t\tidx;\n    char_u\t*bp;\n    idx_T\t*ip;\n    len = get4c(fd);\n    if (len < 0)\n\treturn SP_TRUNCERROR;\n    if (len > 0)\n    {\n\tbp = lalloc((long_u)len, TRUE);\n\tif (bp == NULL)\n\t    return SP_OTHERERROR;\n\t*bytsp = bp;\n\tip = (idx_T *)lalloc_clear((long_u)(len * sizeof(int)), TRUE);\n\tif (ip == NULL)\n\t    return SP_OTHERERROR;\n\t*idxsp = ip;\n\tidx = read_tree_node(fd, bp, ip, len, 0, prefixtree, prefixcnt);\n\tif (idx < 0)\n\t    return idx;\n    }\n    return 0;\n}", "target": 1}
{"code": "static int decode_dds1(GetByteContext *gb, uint8_t *frame, int width, int height)\n{\n    const uint8_t *frame_start = frame;\n    const uint8_t *frame_end   = frame + width * height;\n    int mask = 0x10000, bitbuf = 0;\n    int i, v, offset, count, segments;\n    segments = bytestream2_get_le16(gb);\n    while (segments--) {\n        if (bytestream2_get_bytes_left(gb) < 2)\n            return AVERROR_INVALIDDATA;\n        if (mask == 0x10000) {\n            bitbuf = bytestream2_get_le16u(gb);\n            mask = 1;\n        }\n        if (bitbuf & mask) {\n            v = bytestream2_get_le16(gb);\n            offset = (v & 0x1FFF) << 2;\n            count = ((v >> 13) + 2) << 1;\n            if (frame - frame_start < offset || frame_end - frame < count*2 + width)\n                return AVERROR_INVALIDDATA;\n            for (i = 0; i < count; i++) {\n                frame[0] = frame[1] =\n                frame[width] = frame[width + 1] = frame[-offset];\n                frame += 2;\n            }\n        } else if (bitbuf & (mask << 1)) {\n            v = bytestream2_get_le16(gb)*2;\n            if (frame - frame_end < v)\n                 return AVERROR_INVALIDDATA;\n             frame += v;\n         } else {\n            if (frame_end - frame < width + 3)\n                 return AVERROR_INVALIDDATA;\n             frame[0] = frame[1] =\n             frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n            frame[0] = frame[1] =\n            frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);\n            frame += 2;\n        }\n        mask <<= 2;\n    }\n    return 0;\n}", "target": 1}
{"code": "static UINT serial_process_irp_write(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tDWORD nbWritten = 0;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length); \n\tStream_Read_UINT64(irp->input, Offset); \n\tStream_Seek(irp->input, 20);            \n\tWLog_Print(serial->log, WLOG_DEBUG, \"writing %\" PRIu32 \" bytes to %s\", Length,\n\t           serial->device.name);\n\tif (CommWriteFile(serial->hComm, Stream_Pointer(irp->input), Length, &nbWritten, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"write failure to %s, nbWritten=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbWritten, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes written to %s\", nbWritten,\n\t           serial->device.name);\n\tStream_Write_UINT32(irp->output, nbWritten); \n\tStream_Write_UINT8(irp->output, 0);          \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "Try<JWT, JWTError> JWT::parse(const string& token, const string& secret)\n{\n  const vector<string> components = strings::split(token, \".\");\n  if (components.size() != 3) {\n    return JWTError(\n        \"Expected 3 components in token, got \" + stringify(components.size()),\n        JWTError::Type::INVALID_TOKEN);\n  }\n  Try<JWT::Header> header = parse_header(components[0]);\n  if (header.isError()) {\n    return JWTError(header.error(), JWTError::Type::INVALID_TOKEN);\n  }\n  if (header->alg != JWT::Alg::HS256) {\n    return JWTError(\n        \"Token 'alg' value \\\"\" + stringify(header->alg) +\n        \"\\\" does not match, expected \\\"HS256\\\"\",\n        JWTError::Type::INVALID_TOKEN);\n  }\n  Try<JSON::Object> payload = parse_payload(components[1]);\n  if (payload.isError()) {\n    return JWTError(payload.error(), JWTError::Type::INVALID_TOKEN);\n  }\n  const Try<string> signature = base64::decode_url_safe(components[2]);\n  if (signature.isError()) {\n    return JWTError(\n        \"Failed to base64url-decode token signature: \" + signature.error(),\n        JWTError::Type::INVALID_TOKEN);\n  }\n  Try<string> hmac = generate_hmac_sha256(\n      components[0] + \".\" + components[1],\n      secret);\n  if (hmac.isError()) {\n    return JWTError(\n        \"Failed to generate HMAC signature: \" + hmac.error(),\n        JWTError::Type::UNKNOWN);\n  }\n  const bool valid = hmac.get() == signature.get();\n  if (!valid) {\n    return JWTError(\n        \"Token signature does not match\",\n        JWTError::Type::INVALID_TOKEN);\n  }\n  return JWT(header.get(), payload.get(), signature.get());\n}", "target": 1}
{"code": "TfLiteStatus MultiplyAndCheckOverflow(size_t a, size_t b, size_t* product) {\n  constexpr size_t size_t_bits = 8 * sizeof(size_t);\n  constexpr size_t overflow_upper_half_bit_position = size_t_bits / 2;\n  *product = a * b;\n  if (TFLITE_EXPECT_FALSE((a | b) >> overflow_upper_half_bit_position != 0)) {\n    if (a != 0 && *product / a != b) return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void qemu_input_queue_process(void *opaque)\n{\n    struct QemuInputEventQueueHead *queue = opaque;\n    QemuInputEventQueue *item;\n    g_assert(!QTAILQ_EMPTY(queue));\n    item = QTAILQ_FIRST(queue);\n    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);\n    QTAILQ_REMOVE(queue, item, node);\n    g_free(item);\n    while (!QTAILQ_EMPTY(queue)) {\n        item = QTAILQ_FIRST(queue);\n        switch (item->type) {\n        case QEMU_INPUT_QUEUE_DELAY:\n            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)\n                      + item->delay_ms);\n            return;\n        case QEMU_INPUT_QUEUE_EVENT:\n            qemu_input_event_send(item->src, item->evt);\n            qapi_free_InputEvent(item->evt);\n            break;\n        case QEMU_INPUT_QUEUE_SYNC:\n            qemu_input_event_sync();\n            break;\n        }\n        QTAILQ_REMOVE(queue, item, node);\n        queue_count--;\n        g_free(item);\n    }\n}", "target": 1}
{"code": "static void parse_version(pj_scanner *scanner, \n                          volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINVER;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    if (*(scanner->curptr+2) != '0') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}", "target": 1}
{"code": "inline void ScatterNd(const RuntimeShape& indices_shape,\n                      const IndicesT* indices_data,\n                      const RuntimeShape& updates_shape,\n                      const UpdatesT* updates_data,\n                      const RuntimeShape& output_shape, UpdatesT* output_data) {\n  ruy::profiler::ScopeLabel label(\"ScatterNd\");\n  int n_slices = 1;\n  int slice_size = 1;\n  const int outer_dims = indices_shape.DimensionsCount() - 1;\n  const int indices_nd = indices_shape.Dims(outer_dims);\n  const int updates_dims = updates_shape.DimensionsCount();\n  for (int i = 0; i < outer_dims; ++i) {\n    n_slices *= indices_shape.Dims(i);\n  }\n  for (int i = outer_dims; i < updates_dims; ++i) {\n    slice_size *= updates_shape.Dims(i);\n  }\n  int output_flat_size = output_shape.FlatSize();\n  int remain_flat_size = output_flat_size;\n  std::vector<int> dims_to_count(indices_nd, 0);\n  for (int i = 0; i < indices_nd; ++i) {\n    dims_to_count[i] = remain_flat_size / output_shape.Dims(i);\n    remain_flat_size = dims_to_count[i];\n  }\n  memset(output_data, 0, sizeof(UpdatesT) * output_flat_size);\n  for (int i = 0; i < n_slices; ++i) {\n    int to_pos = 0;\n    for (int j = 0; j < indices_nd; ++j) {\n      IndicesT idx = indices_data[i * indices_nd + j];\n      TFLITE_DCHECK(0 <= idx && idx < output_shape.Dims(j));\n      to_pos += idx * dims_to_count[j];\n    }\n    for (int j = 0; j < slice_size; j++) {\n      output_data[to_pos + j] += updates_data[i * slice_size + j];\n    }\n  }\n}", "target": 1}
{"code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        value += (1 << zeroes) - 1;\n    }\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n    *write_to = value;\n    return 0;\n}", "target": 1}
{"code": "static void mem_cgroup_usage_unregister_event(struct cgroup *cgrp,\n\tstruct cftype *cft, struct eventfd_ctx *eventfd)\n{\n\tstruct mem_cgroup *memcg = mem_cgroup_from_cont(cgrp);\n\tstruct mem_cgroup_thresholds *thresholds;\n\tstruct mem_cgroup_threshold_ary *new;\n\tint type = MEMFILE_TYPE(cft->private);\n\tu64 usage;\n\tint i, j, size;\n\tmutex_lock(&memcg->thresholds_lock);\n\tif (type == _MEM)\n\t\tthresholds = &memcg->thresholds;\n\telse if (type == _MEMSWAP)\n\t\tthresholds = &memcg->memsw_thresholds;\n\telse\n\t\tBUG();\n\tBUG_ON(!thresholds);\n\tusage = mem_cgroup_usage(memcg, type == _MEMSWAP);\n\t__mem_cgroup_threshold(memcg, type == _MEMSWAP);\n\tsize = 0;\n\tfor (i = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd != eventfd)\n\t\t\tsize++;\n\t}\n\tnew = thresholds->spare;\n\tif (!size) {\n\t\tkfree(new);\n\t\tnew = NULL;\n\t\tgoto swap_buffers;\n\t}\n\tnew->size = size;\n\tnew->current_threshold = -1;\n\tfor (i = 0, j = 0; i < thresholds->primary->size; i++) {\n\t\tif (thresholds->primary->entries[i].eventfd == eventfd)\n\t\t\tcontinue;\n\t\tnew->entries[j] = thresholds->primary->entries[i];\n\t\tif (new->entries[j].threshold < usage) {\n\t\t\t++new->current_threshold;\n\t\t}\n\t\tj++;\n\t}\nswap_buffers:\n\tthresholds->spare = thresholds->primary;\n\trcu_assign_pointer(thresholds->primary, new);\n\tsynchronize_rcu();\n\tmutex_unlock(&memcg->thresholds_lock);\n}", "target": 1}
{"code": "struct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\treturn change;\n}", "target": 1}
{"code": "static void agent_connect(UdscsConnection *conn)\n{\n    struct agent_data *agent_data;\n    agent_data = g_new0(struct agent_data, 1);\n    GError *err = NULL;\n    if (session_info) {\n        PidUid pid_uid = vdagent_connection_get_peer_pid_uid(VDAGENT_CONNECTION(conn), &err);\n        if (err || pid_uid.pid <= 0) {\n            static const char msg[] = \"Could not get peer PID, disconnecting new client\";\n            if (err) {\n                syslog(LOG_ERR, \"%s: %s\", msg, err->message);\n                g_error_free(err);\n            } else {\n                syslog(LOG_ERR, \"%s\", msg);\n            }\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n        agent_data->session = session_info_session_for_pid(session_info, pid_uid.pid);\n        uid_t session_uid = session_info_uid_for_session(session_info, agent_data->session);\n        if (!check_uid_of_pid(pid_uid.pid, pid_uid.uid) ||\n            (pid_uid.uid != 0 && pid_uid.uid != session_uid)) {\n            syslog(LOG_ERR, \"UID mismatch: UID=%u PID=%u suid=%u\", pid_uid.uid,\n                   pid_uid.pid, session_uid);\n            agent_data_destroy(agent_data);\n            udscs_server_destroy_connection(server, conn);\n            return;\n        }\n    }\n    g_object_set_data_full(G_OBJECT(conn), \"agent_data\", agent_data,\n                           (GDestroyNotify) agent_data_destroy);\n    udscs_write(conn, VDAGENTD_VERSION, 0, 0,\n                (uint8_t *)VERSION, strlen(VERSION) + 1);\n    update_active_session_connection(conn);\n    if (device_info) {\n        forward_data_to_session_agent(VDAGENTD_GRAPHICS_DEVICE_INFO,\n                                      (uint8_t *) device_info, device_info_size);\n    }\n}", "target": 1}
{"code": "authentic_emu_update_tokeninfo(struct sc_profile *profile, struct sc_pkcs15_card *p15card,\n\t\tstruct sc_pkcs15_tokeninfo *tinfo)\n{\n\tstruct sc_context *ctx = p15card->card->ctx;\n\tstruct sc_file *file = NULL;\n\tstruct sc_path path;\n\tunsigned char buffer[8];\n\tint rv,len;\n\tsc_format_path(AUTHENTIC_CACHE_TIMESTAMP_PATH, &path);\n\trv = sc_select_file(p15card->card, &path, &file);\n\tif (!rv) {\n\t\trv = sc_get_challenge(p15card->card, buffer, sizeof(buffer));\n\t\tif (!rv) {\n\t\t\tsc_file_free(file);\n\t\t\tLOG_TEST_RET(ctx, rv, \"Get challenge error\");\n\t\t}\n\t\tlen = file->size > sizeof(buffer) ? sizeof(buffer) : file->size;\n\t\trv = sc_update_binary(p15card->card, 0, buffer, len, 0);\n\t\tsc_file_free(file);\n\t\tLOG_TEST_RET(ctx, rv, \"Update binary error\");\n\t}\n\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n}", "target": 1}
{"code": "static int tcf_add_notify(struct tc_action *a, u32 pid, u32 seq, int event,\n                          u16 flags)\n{\n\tstruct tcamsg *t;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tstruct rtattr *x;\n\tunsigned char *b;\n\tint err = 0;\n\tskb = alloc_skb(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\tb = (unsigned char *)skb->tail;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*t), flags);\n\tt = NLMSG_DATA(nlh);\n\tt->tca_family = AF_UNSPEC;\n\tx = (struct rtattr*) skb->tail;\n\tRTA_PUT(skb, TCA_ACT_TAB, 0, NULL);\n\tif (tcf_action_dump(skb, a, 0, 0) < 0)\n\t\tgoto rtattr_failure;\n\tx->rta_len = skb->tail - (u8*)x;\n\tnlh->nlmsg_len = skb->tail - b;\n\tNETLINK_CB(skb).dst_groups = RTMGRP_TC;\n\terr = rtnetlink_send(skb, pid, RTMGRP_TC, flags&NLM_F_ECHO);\n\tif (err > 0)\n\t\terr = 0;\n\treturn err;\nrtattr_failure:\nnlmsg_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "get_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    \n    int\t\t*lenp)\t    \n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (has_mbyte && *lenp > 0)\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}", "target": 1}
{"code": "rdp_in_unistr(STREAM s, int in_len, char **string, uint32 * str_size)\n{\n\tstatic iconv_t icv_utf16_to_local;\n \tsize_t ibl, obl;\n \tchar *pin, *pout;\n \tif (!icv_utf16_to_local)\n \t{\n\t\ticv_utf16_to_local = iconv_open(g_codepage, WINDOWS_CODEPAGE);\n\t\tif (icv_utf16_to_local == (iconv_t) - 1)\n\t\t{\n\t\t\tlogger(Protocol, Error, \"rdp_in_unistr(), iconv_open[%s -> %s] fail %p\",\n\t\t\t       WINDOWS_CODEPAGE, g_codepage, icv_utf16_to_local);\n\t\t\tabort();\n\t\t}\n\t}\n\tif (*string == NULL)\n\t{\n\t\t*string = xmalloc(in_len * 2);\n\t\t*str_size = in_len * 2;\n\t}\n\tibl = in_len;\n\tobl = *str_size - 1;\n\tpin = (char *) s->p;\n\tpout = *string;\n\tif (iconv(icv_utf16_to_local, (char **) &pin, &ibl, &pout, &obl) == (size_t) - 1)\n\t{\n\t\tif (errno == E2BIG)\n\t\t{\n\t\t\tlogger(Protocol, Warning,\n\t\t\t       \"rdp_in_unistr(), server sent an unexpectedly long string, truncating\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogger(Protocol, Warning, \"rdp_in_unistr(), iconv fail, errno %d\", errno);\n\t\t\tfree(*string);\n\t\t\t*string = NULL;\n\t\t\t*str_size = 0;\n\t\t}\n\t\tabort();\n\t}\n\ts->p += in_len;\n\t*pout = 0;\n\tif (*string)\n\t\t*str_size = pout - *string;\n}", "target": 1}
{"code": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\tnfcmrvl_fw_dnld_deinit(priv);\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}", "target": 1}
{"code": "static int hci_sock_getname(struct socket *sock, struct sockaddr *addr,\n\t\t\t    int *addr_len, int peer)\n{\n\tstruct sockaddr_hci *haddr = (struct sockaddr_hci *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct hci_dev *hdev = hci_pi(sk)->hdev;\n\tBT_DBG(\"sock %p sk %p\", sock, sk);\n\tif (!hdev)\n\t\treturn -EBADFD;\n\tlock_sock(sk);\n \t*addr_len = sizeof(*haddr);\n \thaddr->hci_family = AF_BLUETOOTH;\n \thaddr->hci_dev    = hdev->id;\n \trelease_sock(sk);\n \treturn 0;\n}", "target": 1}
{"code": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\tkenter(\"%p{%u}\", user, uid);\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\tif (!user->uid_keyring) {\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n    }\n  ThrowImageException;\n}", "target": 1}
{"code": "inline int ComputeOutSize(TfLitePadding padding, int image_size,\n                          int filter_size, int stride, int dilation_rate = 1) {\n  int effective_filter_size = (filter_size - 1) * dilation_rate + 1;\n  switch (padding) {\n    case kTfLitePaddingSame:\n      return (image_size + stride - 1) / stride;\n    case kTfLitePaddingValid:\n      return (image_size + stride - effective_filter_size) / stride;\n    default:\n      return 0;\n  }\n}", "target": 1}
{"code": "bool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined _WIN_ALL\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}", "target": 1}
{"code": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[12];\n\tstruct keydata *keyptr = get_keyptr();\n\tmemcpy(hash, saddr, 16);\n\thash[4] = ((__force u16)sport << 16) + (__force u16)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\tseq = twothirdsMD4Transform((const __u32 *)daddr, hash) & HASH_MASK;\n\tseq += keyptr->count;\n\tseq += ktime_to_ns(ktime_get_real());\n\treturn seq;\n}", "target": 1}
{"code": "static int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n\tstruct dm_i2c_chip *i2c_chip;\n#endif\n\tif ((argc < 5) || (argc > 6))\n\t\treturn cmd_usage(cmdtp);\n\tmemaddr = (u_char *)hextoul(argv[1], NULL);\n\tchip = hextoul(argv[2], NULL);\n\tdevaddr = hextoul(argv[3], NULL);\n\talen = get_alen(argv[3], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn cmd_usage(cmdtp);\n\tlength = hextoul(argv[4], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\ti2c_chip = dev_get_parent_plat(dev);\n\tif (!i2c_chip)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tif (argc == 6 && !strcmp(argv[5], \"-s\")) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\ti2c_chip->flags &= ~DM_I2C_CHIP_WR_ADDRESS;\n\t\tret = dm_i2c_write(dev, devaddr, memaddr, length);\n#else\n\t\tret = i2c_write(chip, devaddr, alen, memaddr, length);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t} else {\n\t\twhile (length-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\t\ti2c_chip->flags |= DM_I2C_CHIP_WR_ADDRESS;\n\t\t\tret = dm_i2c_write(dev, devaddr++, memaddr++, 1);\n#else\n\t\t\tret = i2c_write(chip, devaddr++, alen, memaddr++, 1);\n#endif\n\t\t\tif (ret)\n\t\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\t\tudelay(11000);\n#endif\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "parse_delta(struct rpki_uri *uri, struct delta_head *parents_data,\n    struct proc_upd_args *args)\n{\n\tstruct rdr_delta_ctx ctx;\n\tstruct delta *delta;\n\tstruct doc_data *expected_data;\n\tint error;\n\texpected_data = &parents_data->doc_data;\n\tfnstack_push_uri(uri);\n\terror = hash_validate_file(\"sha256\", uri, expected_data->hash,\n\t    expected_data->hash_len);\n\tif (error)\n\t\tgoto pop_fnstack;\n\terror = delta_create(&delta);\n\tif (error)\n\t\tgoto pop_fnstack;\n\tctx.delta = delta;\n\tctx.parent = args->parent;\n\tctx.visited_uris = args->visited_uris;\n\tctx.expected_serial = parents_data->serial;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_delta, &ctx);\n\tdelta_destroy(delta);\npop_fnstack:\n\tfnstack_pop();\n\treturn error;\n}", "target": 1}
{"code": "void EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,\n                      const unsigned char *in, int inl)\n{\n    int i, j;\n    unsigned int total = 0;\n    *outl = 0;\n     if (inl <= 0)\n         return;\n     OPENSSL_assert(ctx->length <= (int)sizeof(ctx->enc_data));\n    if ((ctx->num + inl) < ctx->length) {\n         memcpy(&(ctx->enc_data[ctx->num]), in, inl);\n         ctx->num += inl;\n         return;\n    }\n    if (ctx->num != 0) {\n        i = ctx->length - ctx->num;\n        memcpy(&(ctx->enc_data[ctx->num]), in, i);\n        in += i;\n        inl -= i;\n        j = EVP_EncodeBlock(out, ctx->enc_data, ctx->length);\n        ctx->num = 0;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total = j + 1;\n    }\n    while (inl >= ctx->length) {\n        j = EVP_EncodeBlock(out, in, ctx->length);\n        in += ctx->length;\n        inl -= ctx->length;\n        out += j;\n        *(out++) = '\\n';\n        *out = '\\0';\n        total += j + 1;\n    }\n    if (inl != 0)\n        memcpy(&(ctx->enc_data[0]), in, inl);\n    ctx->num = inl;\n    *outl = total;\n}", "target": 1}
{"code": "static int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {\n\tint i;\n\tint chsz = 1;\n\tif (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < bufsz; i += chsz) {\n\t\tbuf[i] =0;\n\t\tr_socket_block_time (s, 1, 0, 1000);\n\t\tint olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);\n\t\tif (olen != chsz) {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}", "target": 1}
{"code": "  int Bind(const Node& node, int max_retry) override {\n    receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n    CHECK(receiver_ != NULL)\n        << \"create receiver socket failed: \" << zmq_strerror(errno);\n    int local = GetEnv(\"DMLC_LOCAL\", 0);\n    std::string addr = local ? \"ipc:\n    int port = node.port;\n    unsigned seed = static_cast<unsigned>(time(NULL)+port);\n    for (int i = 0; i < max_retry+1; ++i) {\n      auto address = addr + std::to_string(port);\n      if (zmq_bind(receiver_, address.c_str()) == 0) break;\n      if (i == max_retry) {\n        port = -1;\n      } else {\n        port = 10000 + rand_r(&seed) % 40000;\n      }\n    }\n    return port;\n  }", "target": 1}
{"code": "static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tmemcpy(state->stateid.data, deleg_stateid->data, sizeof(state->stateid.data));\n\t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n\tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, open_flags);\n\tspin_unlock(&state->owner->so_lock);\n}", "target": 1}
{"code": "void ExtractStreams(Archive &Arc,const wchar *FileName,bool TestMode)\n{\n  wchar FullName[NM+2];\n  if (FileName[0]!=0 && FileName[1]==0)\n  {\n    wcsncpyz(FullName,L\".\\\\\",ASIZE(FullName));\n    wcsncatz(FullName,FileName,ASIZE(FullName));\n  }\n  else\n    wcsncpyz(FullName,FileName,ASIZE(FullName));\n  wchar StreamName[NM];\n  GetStreamNameNTFS(Arc,StreamName,ASIZE(StreamName));\n  if (*StreamName!=':')\n  {\n    uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n  if (TestMode)\n  {\n    File CurFile;\n    Arc.ReadSubData(NULL,&CurFile,true);\n    return;\n  }\n  wcsncatz(FullName,StreamName,ASIZE(FullName));\n  FindData fd;\n  bool HostFound=FindFile::FastFind(FileName,&fd);\n  if ((fd.FileAttr & FILE_ATTRIBUTE_READONLY)!=0)\n    SetFileAttr(FileName,fd.FileAttr & ~FILE_ATTRIBUTE_READONLY);\n  File CurFile;\n  if (CurFile.WCreate(FullName) && Arc.ReadSubData(NULL,&CurFile,false))\n    CurFile.Close();\n  File HostFile;\n  if (HostFound && HostFile.Open(FileName,FMF_OPENSHARED|FMF_UPDATE))\n    SetFileTime(HostFile.GetHandle(),&fd.ftCreationTime,&fd.ftLastAccessTime,\n                &fd.ftLastWriteTime);\n  SetFileAttr(FileName,fd.FileAttr);\n}", "target": 1}
{"code": "static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = l2t_send(tdev, skb, l2e);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "static PixelChannels **AcquirePixelThreadSet(const Image *image)\n {\n   PixelChannels\n     **pixels;\n   register ssize_t\n     i;\n   size_t\n     number_threads;\n   number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(PixelChannels **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n   if (pixels == (PixelChannels **) NULL)\n     return((PixelChannels **) NULL);\n   (void) memset(pixels,0,number_threads*sizeof(*pixels));\n   for (i=0; i < (ssize_t) number_threads; i++)\n   {\n     register ssize_t\n       j;\n    pixels[i]=(PixelChannels *) AcquireQuantumMemory(image->columns,\n      sizeof(**pixels));\n     if (pixels[i] == (PixelChannels *) NULL)\n       return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) image->columns; j++)\n     {\n       register ssize_t\n         k;\n      for (k=0; k < MaxPixelChannels; k++)\n        pixels[i][j].channel[k]=0.0;\n    }\n  }\n  return(pixels);\n}", "target": 1}
{"code": "TfLiteStatus Subgraph::AddNodeWithParameters(\n    const std::vector<int>& inputs, const std::vector<int>& outputs,\n    const std::vector<int>& intermediates, const char* init_data,\n    size_t init_data_size, void* builtin_data,\n    const TfLiteRegistration* registration, int* node_index) {\n  std::unique_ptr<void, decltype(free)*> builtin_data_deleter(builtin_data,\n                                                              free);\n  if (state_ == kStateInvokableAndImmutable) {\n    ReportError(\"AddNodeWithParameters is disallowed when graph is immutable.\");\n    return kTfLiteError;\n  }\n  state_ = kStateUninvokable;\n  TF_LITE_ENSURE_OK(&context_, CheckTensorIndices(\"node inputs\", inputs.data(),\n                                                  inputs.size()));\n  TF_LITE_ENSURE_OK(\n      &context_,\n      CheckTensorIndices(\"node outputs\", outputs.data(), outputs.size()));\n  int new_node_index = nodes_and_registration_.size();\n  if (node_index) *node_index = new_node_index;\n  nodes_and_registration_.resize(nodes_and_registration_.size() + 1);\n  auto& node_and_reg = nodes_and_registration_.back();\n  TfLiteNode& node = node_and_reg.first;\n  if (node.inputs) TfLiteIntArrayFree(node.inputs);\n  if (node.outputs) TfLiteIntArrayFree(node.outputs);\n  if (node.intermediates) TfLiteIntArrayFree(node.intermediates);\n  if (node.temporaries) TfLiteIntArrayFree(node.temporaries);\n  node.inputs = ConvertVectorToTfLiteIntArray(inputs);\n  node.outputs = ConvertVectorToTfLiteIntArray(outputs);\n  node.intermediates = ConvertVectorToTfLiteIntArray(intermediates);\n  node.temporaries = TfLiteIntArrayCreate(0);\n  if (init_data) {\n    node.user_data = OpInit(*registration, init_data, init_data_size);\n  } else {\n    node.user_data = OpInit(\n        *registration, static_cast<const char*>(builtin_data_deleter.get()), 0);\n  }\n  node.builtin_data = builtin_data_deleter.release();\n  if (registration->builtin_code == BuiltinOperator_CUSTOM) {\n    node.custom_initial_data = init_data;\n    node.custom_initial_data_size = init_data_size;\n  } else {\n    node.custom_initial_data = nullptr;\n    node.custom_initial_data_size = 0;\n  }\n  node.delegate = nullptr;\n  node_and_reg.second = *registration;\n  execution_plan_.push_back(new_node_index);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "int avpriv_dv_produce_packet(DVDemuxContext *c, AVPacket *pkt,\n                      uint8_t* buf, int buf_size)\n{\n    int size, i;\n    uint8_t *ppcm[4] = {0};\n    if (buf_size < DV_PROFILE_BYTES ||\n        !(c->sys = avpriv_dv_frame_profile(c->sys, buf, buf_size)) ||\n        buf_size < c->sys->frame_size) {\n          return -1;   \n    }\n    size = dv_extract_audio_info(c, buf);\n    for (i = 0; i < c->ach; i++) {\n       c->audio_pkt[i].size = size;\n        c->audio_pkt[i].pts  = c->abytes * 30000*8 / c->ast[i]->codec->bit_rate;\n        ppcm[i] = c->audio_buf[i];\n     }\n    dv_extract_audio(buf, ppcm, c->sys);\n        if (buf[1] & 0x0C) {\n            c->audio_pkt[2].size = c->audio_pkt[3].size = 0;\n        } else {\n            c->audio_pkt[0].size = c->audio_pkt[1].size = 0;\n            c->abytes += size;\n        }\n    } else {\n        c->abytes += size;\n    }", "target": 1}
{"code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n  if(!data)\n    return CURLE_OK;\n  Curl_expire_clear(data); \n  m = data->multi;\n  if(m)\n    curl_multi_remove_handle(data->multi, data);\n  if(data->multi_easy)\n    curl_multi_cleanup(data->multi_easy);\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n  data->magic = 0; \n  if(data->state.rangestringalloc)\n    free(data->state.range);\n  Curl_free_request_state(data);\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n  Curl_resolver_cleanup(data->state.resolver);\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}", "target": 1}
{"code": "snmp_ber_decode_string_len_buffer(unsigned char *buf, uint32_t *buff_len, const char **str, uint32_t *length)\n{\n  uint8_t type, i, length_bytes;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != BER_DATA_TYPE_OCTET_STRING) {\n    return NULL;\n  }\n  if((*buf & 0x80) == 0) {\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n  } else {\n    length_bytes = (uint8_t)(*buf++ & 0x7F);\n    (*buff_len)--;\n    if(length_bytes > 4) {\n      return NULL;\n    }\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n    for(i = 1; i < length_bytes; ++i) {\n      *length <<= 8;\n      *length |= *buf++;\n      (*buff_len)--;\n    }\n  }\n  *str = (const char *)buf;\n  *buff_len -= *length;\n  return buf + *length;\n}", "target": 1}
{"code": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n \t}\n retry:\n \tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n \tif (ret)\n \t\tgoto out;\n\tfutex_wait_queue_me(hb, &q, to);\n \tret = 0;\n \tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n \tret = -ETIMEDOUT;\n \tif (to && !to->task)\n\t\tgoto out_put_key;\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n \t\tgoto retry;\n\t}\n \tret = -ERESTARTSYS;\n \tif (!abs_time)\n\t\tgoto out_put_key;\n \trestart = &current_thread_info()->restart_block;\n \trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n \tret = -ERESTART_RESTARTBLOCK;\nout_put_key:\n\tput_futex_key(fshared, &q.key);\n out:\n \tif (to) {\n \t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL);\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}", "target": 1}
{"code": "static int jpc_siz_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tunsigned int i;\n\tuint_fast8_t tmp;\n\tcstate = 0;\n\tif (jpc_getuint16(in, &siz->caps) ||\n\t  jpc_getuint32(in, &siz->width) ||\n\t  jpc_getuint32(in, &siz->height) ||\n\t  jpc_getuint32(in, &siz->xoff) ||\n\t  jpc_getuint32(in, &siz->yoff) ||\n\t  jpc_getuint32(in, &siz->tilewidth) ||\n\t  jpc_getuint32(in, &siz->tileheight) ||\n\t  jpc_getuint32(in, &siz->tilexoff) ||\n\t  jpc_getuint32(in, &siz->tileyoff) ||\n\t  jpc_getuint16(in, &siz->numcomps)) {\n\t\treturn -1;\n\t}\n\tif (!siz->width || !siz->height || !siz->tilewidth ||\n\t  !siz->tileheight || !siz->numcomps) {\n\t\treturn -1;\n\t}\n\tif (!(siz->comps = jas_alloc2(siz->numcomps, sizeof(jpc_sizcomp_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < siz->numcomps; ++i) {\n\t\tif (jpc_getuint8(in, &tmp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].hsamp) ||\n\t\t  jpc_getuint8(in, &siz->comps[i].vsamp)) {\n \t\t\tjas_free(siz->comps);\n \t\t\treturn -1;\n \t\t}\n \t\tsiz->comps[i].sgnd = (tmp >> 7) & 1;\n \t\tsiz->comps[i].prec = (tmp & 0x7f) + 1;\n \t}\n\tif (jas_stream_eof(in)) {\n\t\tjas_free(siz->comps);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\tword.ptr = value->ptr - 1; \n\te = value->ptr + value->len;\n\twhile (++word.ptr < e) {\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\tif (unlikely(n == word.ptr)) \n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl + c;\n\t\t}\n\t\tword.len = n - word.ptr;\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\treturn !not_first;\n fail:\n\treturn -1;\n}", "target": 1}
{"code": "std::string decodeBase64(\n    const std::string& encoded) {\n  if (encoded.size() == 0) {\n    return \"\";\n  }\n  using namespace boost::archive::iterators;\n  using b64it =\n    transform_width<binary_from_base64<std::string::const_iterator>, 8, 6>;\n  std::string decoded = std::string(b64it(std::begin(encoded)),\n                                    b64it(std::end(encoded)));\n  uint32_t numPadding = std::count(encoded.begin(), encoded.end(), '=');\n  decoded.erase(decoded.end() - numPadding, decoded.end());\n  return decoded;\n}", "target": 1}
{"code": "void comps_rtree_unite(COMPS_RTree *rt1, COMPS_RTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_RTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_RTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            }\n            if (((COMPS_RTreeData*)it->data)->data != NULL) {\n                    comps_rtree_set(rt1,\n                                    pair->key,\n                        rt2->data_cloner(((COMPS_RTreeData*)it->data)->data));\n            }\n            if (((COMPS_RTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}", "target": 1}
{"code": "errno_t sss_filter_sanitize_ex(TALLOC_CTX *mem_ctx,\n                               const char *input,\n                               char **sanitized,\n                               const char *ignore)\n{\n    char *output;\n    size_t i = 0;\n    size_t j = 0;\n    char *allowed;\n    output = talloc_array(mem_ctx, char, strlen(input) * 3 + 1);\n    if (!output) {\n        return ENOMEM;\n    }\n    while (input[i]) {\n        if (ignore == NULL) {\n            allowed = NULL;\n        } else {\n            allowed = strchr(ignore, input[i]);\n        }\n        if (allowed) {\n            output[j++] = input[i++];\n            continue;\n        }\n        switch(input[i]) {\n        case '\\t':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = '9';\n            break;\n        case ' ':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '0';\n            break;\n        case '*':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = 'a';\n            break;\n        case '(':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '8';\n            break;\n        case ')':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '9';\n            break;\n        case '\\\\':\n            output[j++] = '\\\\';\n            output[j++] = '5';\n            output[j++] = 'c';\n            break;\n        case '\\r':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = 'd';\n            break;\n        case '\\n':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = 'a';\n            break;\n        default:\n            output[j++] = input[i];\n        }\n        i++;\n    }\n    output[j] = '\\0';\n    *sanitized = talloc_realloc(mem_ctx, output, char, j+1);\n    if (!*sanitized) {\n        talloc_free(output);\n        return ENOMEM;\n    }\n    return EOK;\n}", "target": 1}
{"code": "mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \" Unknown Version (%d)\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));\n                return 1;\n        }\n        if (mpc->flags & MP_CAPABLE_C)\n                ND_PRINT((ndo, \" csum\"));\n        ND_PRINT((ndo, \" {0x%\" PRIx64, EXTRACT_64BITS(mpc->sender_key)));\n        if (opt_len == 20) \n                ND_PRINT((ndo, \",0x%\" PRIx64, EXTRACT_64BITS(mpc->receiver_key)));\n        ND_PRINT((ndo, \"}\"));\n        return 1;\n}", "target": 1}
{"code": "char **XListExtensions(\n    register Display *dpy,\n    int *nextensions)\t\n{\n\txListExtensionsReply rep;\n\tchar **list = NULL;\n\tchar *ch = NULL;\n\tchar *chend;\n\tint count = 0;\n\tregister unsigned i;\n\tregister int length;\n\t_X_UNUSED register xReq *req;\n\tunsigned long rlen = 0;\n\tLockDisplay(dpy);\n\tGetEmptyReq (ListExtensions, req);\n\tif (! _XReply (dpy, (xReply *) &rep, 0, xFalse)) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\tif (rep.nExtensions) {\n\t    list = Xmalloc (rep.nExtensions * sizeof (char *));\n\t    if (rep.length > 0 && rep.length < (INT_MAX >> 2)) {\n\t\trlen = rep.length << 2;\n\t\tch = Xmalloc (rlen + 1);\n\t    }\n\t    if ((!list) || (!ch)) {\n\t\tXfree(list);\n\t\tXfree(ch);\n\t\t_XEatDataWords(dpy, rep.length);\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn (char **) NULL;\n\t    }\n\t    _XReadPad (dpy, ch, rlen);\n\t    chend = ch + (rlen + 1);\n\t    length = *ch;\n\t    for (i = 0; i < rep.nExtensions; i++) {\n\t\tif (ch + length < chend) {\n\t\t    list[i] = ch+1;  \n\t\t    ch += length + 1; \n\t\t    if (ch <= chend) {\n\t\t\tlength = *ch;\n\t\t\t*ch = '\\0'; \n\t\t\tcount++;\n\t\t    } else {\n\t\t\tlist[i] = NULL;\n\t\t    }\n\t\t} else\n\t\t    list[i] = NULL;\n\t    }\n\t}\n\t*nextensions = count;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (list);\n}", "target": 1}
{"code": "int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n{\n\tResub scratch;\n\tint i;\n\tif (!sub)\n\t\tsub = &scratch;\n\tsub->nsub = prog->nsub;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n}", "target": 1}
{"code": "static void perf_event_exit_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tperf_event_exit_cpu_context(cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}", "target": 1}
{"code": "pci_emul_add_msixcap(struct pci_vdev *dev, int msgnum, int barnum)\n{\n\tuint32_t tab_size;\n\tstruct msixcap msixcap;\n\tassert(msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES);\n\tassert(barnum >= 0 && barnum <= PCIR_MAX_BAR_0);\n\ttab_size = msgnum * MSIX_TABLE_ENTRY_SIZE;\n\ttab_size = roundup2(tab_size, 4096);\n\tdev->msix.table_bar = barnum;\n\tdev->msix.pba_bar   = barnum;\n\tdev->msix.table_offset = 0;\n\tdev->msix.table_count = msgnum;\n\tdev->msix.pba_offset = tab_size;\n\tdev->msix.pba_size = PBA_SIZE(msgnum);\n\tpci_msix_table_init(dev, msgnum);\n\tpci_populate_msixcap(&msixcap, msgnum, barnum, tab_size);\n\tpci_emul_alloc_bar(dev, barnum, PCIBAR_MEM32,\n\t\t\t\ttab_size + dev->msix.pba_size);\n\treturn (pci_emul_add_capability(dev, (u_char *)&msixcap,\n\t\t\t\t\tsizeof(msixcap)));\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\tif((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\\n\");\n\t\treturn;\n\t}\n\tpos = 0;\n\tfor(y = 0; y < gdImageSY(image); y++) {\n\t\tfor(x = 0; x < gdImageSX(image); x++) {\n\t\t\tif(gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\tif(writewbmp(wbmp, &gd_putout, out)) {\n\t\tgd_error(\"Could not save WBMP\\n\");\n\t}\n\tfreewbmp(wbmp);\n}", "target": 1}
{"code": "static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)\n{\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->ris = qemu_get_be32(f);\n    s->im = qemu_get_be32(f);\n    s->rctl = qemu_get_be32(f);\n    s->tctl = qemu_get_be32(f);\n    s->thr = qemu_get_be32(f);\n    s->mctl = qemu_get_be32(f);\n    s->mdv = qemu_get_be32(f);\n    s->mtxd = qemu_get_be32(f);\n    s->mrxd = qemu_get_be32(f);\n    s->np = qemu_get_be32(f);\n    s->tx_fifo_len = qemu_get_be32(f);\n    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));\n    for (i = 0; i < 31; i++) {\n        s->rx[i].len = qemu_get_be32(f);\n        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));\n    }\n    s->next_packet = qemu_get_be32(f);\n    s->rx_fifo_offset = qemu_get_be32(f);\n    return 0;\n}", "target": 1}
{"code": "apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\toidc_debug(r, \"enter\");\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "inline int NumInputs(const TfLiteNode* node) { return node->inputs->size; }", "target": 1}
{"code": "static struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 1}
{"code": "unsigned long X509_issuer_and_serial_hash(X509 *a)\n{\n    unsigned long ret = 0;\n    EVP_MD_CTX *ctx = EVP_MD_CTX_new();\n    unsigned char md[16];\n    char *f;\n    if (ctx == NULL)\n        goto err;\n    f = X509_NAME_oneline(a->cert_info.issuer, NULL, 0);\n    if (!EVP_DigestInit_ex(ctx, EVP_md5(), NULL))\n        goto err;\n    if (!EVP_DigestUpdate(ctx, (unsigned char *)f, strlen(f)))\n        goto err;\n    OPENSSL_free(f);\n    if (!EVP_DigestUpdate\n        (ctx, (unsigned char *)a->cert_info.serialNumber.data,\n         (unsigned long)a->cert_info.serialNumber.length))\n        goto err;\n    if (!EVP_DigestFinal_ex(ctx, &(md[0]), NULL))\n        goto err;\n    ret = (((unsigned long)md[0]) | ((unsigned long)md[1] << 8L) |\n           ((unsigned long)md[2] << 16L) | ((unsigned long)md[3] << 24L)\n        ) & 0xffffffffL;\n err:\n    EVP_MD_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "void ndpi_search_oracle(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)\n{\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int16_t dport = 0, sport = 0;\n  NDPI_LOG_DBG(ndpi_struct, \"search ORACLE\\n\");\n  if(packet->tcp != NULL) {\n    sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest);\n    NDPI_LOG_DBG2(ndpi_struct, \"calculating ORACLE over tcp\\n\");\n    if ((dport == 1521 || sport == 1521)\n\t&&  (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))\n\t     || ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) \n\t     && (packet->payload[1] != 0x00)\n\t     && (packet->payload[2] == 0x00)\n\t\t && (packet->payload[3] == 0x00)))) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    } else if (packet->payload_packet_len == 213 && packet->payload[0] == 0x00 &&\n               packet->payload[1] == 0xd5 && packet->payload[2] == 0x00 &&\n               packet->payload[3] == 0x00 ) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    }\n  } else {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n  }\n}", "target": 1}
{"code": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n \t\t\t\t   u16 selector, int seg)\n {\n \tu8 cpl = ctxt->ops->cpl(ctxt);\n \treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n \t\t\t\t\t X86_TRANSFER_NONE, NULL);\n }", "target": 1}
{"code": "static gint conv_jistoeuc(gchar *outbuf, gint outlen, const gchar *inbuf)\n{\n\tconst guchar *in = inbuf;\n\tguchar *out = outbuf;\n\tJISState state = JIS_ASCII;\n\twhile (*in != '\\0') {\n\t\tif (*in == ESC) {\n\t\t\tin++;\n\t\t\tif (*in == '$') {\n\t\t\t\tif (*(in + 1) == '@' || *(in + 1) == 'B') {\n\t\t\t\t\tstate = JIS_KANJI;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else if (*(in + 1) == '(' &&\n\t\t\t\t\t   *(in + 2) == 'D') {\n\t\t\t\t\tstate = JIS_AUXKANJI;\n\t\t\t\t\tin += 3;\n\t\t\t\t} else {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t}\n\t\t\t} else if (*in == '(') {\n\t\t\t\tif (*(in + 1) == 'B' || *(in + 1) == 'J') {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else if (*(in + 1) == 'I') {\n\t\t\t\t\tstate = JIS_HWKANA;\n\t\t\t\t\tin += 2;\n\t\t\t\t} else {\n\t\t\t\t\tstate = JIS_ASCII;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstate = JIS_ASCII;\n\t\t\t}\n\t\t} else if (*in == 0x0e) {\n\t\t\tstate = JIS_HWKANA;\n\t\t\tin++;\n\t\t} else if (*in == 0x0f) {\n\t\t\tstate = JIS_ASCII;\n\t\t\tin++;\n\t\t} else {\n\t\t\tswitch (state) {\n\t\t\tcase JIS_ASCII:\n\t\t\t\t*out++ = *in++;\n\t\t\t\tbreak;\n\t\t\tcase JIS_KANJI:\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tif (*in == '\\0') break;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\tcase JIS_HWKANA:\n\t\t\t\t*out++ = 0x8e;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\tcase JIS_AUXKANJI:\n\t\t\t\t*out++ = 0x8f;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tif (*in == '\\0') break;\n\t\t\t\t*out++ = *in++ | 0x80;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t*out = '\\0';\n\treturn 0;\n}", "target": 1}
{"code": "raw_copy_to_user(void __user *dst, const void *src, unsigned long size)\n{\n\tint ret = 0;\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u8 *)src, (u8 __user *)dst,\n\t\t\t      ret, \"b\", \"b\", \"iq\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u16 *)src, (u16 __user *)dst,\n\t\t\t      ret, \"w\", \"w\", \"ir\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u32 *)src, (u32 __user *)dst,\n\t\t\t      ret, \"l\", \"k\", \"ir\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t      ret, \"q\", \"\", \"er\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 10);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(4[(u16 *)src], 4 + (u16 __user *)dst,\n\t\t\t\t       ret, \"w\", \"w\", \"ir\", 2);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 16);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(1[(u64 *)src], 1 + (u64 __user *)dst,\n\t\t\t\t       ret, \"q\", \"\", \"er\", 8);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\t}\n}", "target": 1}
{"code": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\tvoid *vapic;\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n\tkunmap_atomic(vapic);\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}", "target": 1}
{"code": "deinit_pci(struct vmctx *ctx)\n{\n\tstruct pci_vdev_ops *ops;\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct funcinfo *fi;\n\tint bus, slot, func;\n\tsize_t lowmem;\n\tstruct mem_range mr;\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI ECFG\";\n\tmr.base = PCI_EMUL_ECFG_BASE;\n\tmr.size = PCI_EMUL_ECFG_SIZE;\n\tunregister_mem(&mr);\n\tlowmem = vm_get_lowmem_size(ctx);\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI hole (32-bit)\";\n\tmr.base = lowmem;\n\tmr.size = (4ULL * 1024 * 1024 * 1024) - lowmem;\n\tunregister_mem_fallback(&mr);\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI hole (64-bit)\";\n\tmr.base = PCI_EMUL_MEMBASE64;\n\tmr.size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64;\n\tunregister_mem_fallback(&mr);\n\tfor (bus = 0; bus < MAXBUSES; bus++) {\n\t\tbi = pci_businfo[bus];\n\t\tif (bi == NULL)\n\t\t\tcontinue;\n\t\tfor (slot = 0; slot < MAXSLOTS; slot++) {\n\t\t\tsi = &bi->slotinfo[slot];\n\t\t\tfor (func = 0; func < MAXFUNCS; func++) {\n\t\t\t\tfi = &si->si_funcs[func];\n\t\t\t\tif (fi->fi_name == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tops = pci_emul_finddev(fi->fi_name);\n\t\t\t\tassert(ops != NULL);\n\t\t\t\tpr_notice(\"pci deinit %s\\n\", fi->fi_name);\n\t\t\t\tpci_emul_deinit(ctx, ops, bus, slot,\n\t\t\t\t    func, fi);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "static char *sanitize_cookie_path(const char *cookie_path)\n{\n  size_t len;\n  char *new_path = strdup(cookie_path);\n  if(!new_path)\n    return NULL;\n  if(new_path[0] == '\\\"') {\n    memmove((void *)new_path, (const void *)(new_path + 1), strlen(new_path));\n  }\n  if(new_path[strlen(new_path) - 1] == '\\\"') {\n    new_path[strlen(new_path) - 1] = 0x0;\n  }\n  if(new_path[0] != '/') {\n    free(new_path);\n    new_path = strdup(\"/\");\n    return new_path;\n  }\n  len = strlen(new_path);\n  if(1 < len && new_path[len - 1] == '/') {\n    new_path[len - 1] = 0x0;\n  }\n  return new_path;\n}", "target": 1}
{"code": "yaml_parser_save_simple_key(yaml_parser_t *parser)\n{\n    int required = (!parser->flow_level\n            && parser->indent == (ptrdiff_t)parser->mark.column);\n    assert(parser->simple_key_allowed || !required);    \n    if (parser->simple_key_allowed)\n    {\n        yaml_simple_key_t simple_key;\n        simple_key.possible = 1;\n        simple_key.required = required;\n        simple_key.token_number = \n            parser->tokens_parsed + (parser->tokens.tail - parser->tokens.head);\n        simple_key.mark = parser->mark;\n        if (!yaml_parser_remove_simple_key(parser)) return 0;\n        *(parser->simple_keys.top-1) = simple_key;\n    }\n    return 1;\n}", "target": 1}
{"code": "pthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "bool RGWSwiftWebsiteHandler::is_web_dir() const\n{\n  std::string subdir_name = url_decode(s->object.name);\n  if (subdir_name.empty()) {\n    return false;\n  } else if (subdir_name.back() == '/') {\n    subdir_name.pop_back();\n  }\n  rgw_obj obj(s->bucket, std::move(subdir_name));\n  RGWObjectCtx& obj_ctx = *static_cast<RGWObjectCtx *>(s->obj_ctx);\n  obj_ctx.set_atomic(obj);\n  obj_ctx.set_prefetch_data(obj);\n  RGWObjState* state = nullptr;\n  if (store->get_obj_state(&obj_ctx, s->bucket_info, obj, &state, false) < 0) {\n    return false;\n  }\n  if (! state->exists) {\n    return false;\n  }\n  std::string content_type;\n  get_contype_from_attrs(state->attrset, content_type);\n  const auto& ws_conf = s->bucket_info.website_conf;\n  const std::string subdir_marker = ws_conf.subdir_marker.empty()\n                                      ? \"application/directory\"\n                                      : ws_conf.subdir_marker;\n  return subdir_marker == content_type && state->size <= 1;\n}", "target": 1}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": " static void smp_task_done(struct sas_task *task)\n {\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n \tcomplete(&task->slow_task->completion);\n }", "target": 1}
{"code": "static void coroutine_fn v9fs_link(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    int32_t dfid, oldfid;\n    V9fsFidState *dfidp, *oldfidp;\n    V9fsString name;\n    size_t offset = 7;\n    int err = 0;\n    v9fs_string_init(&name);\n    err = pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    oldfidp = get_fid(pdu, oldfid);\n    if (oldfidp == NULL) {\n        err = -ENOENT;\n        goto out;\n    }\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n     if (!err) {\n         err = offset;\n     }\n out:\n     put_fid(pdu, dfidp);\n out_nofid:\n    pdu_complete(pdu, err);\n}", "target": 1}
{"code": "  t42_parse_font_matrix( T42_Face    face,\n                         T42_Loader  loader )\n  {\n    T42_Parser  parser = &loader->parser;\n    FT_Matrix*  matrix = &face->type1.font_matrix;\n    FT_Vector*  offset = &face->type1.font_offset;\n     FT_Face     root   = (FT_Face)&face->root;\n     FT_Fixed    temp[6];\n     FT_Fixed    temp_scale;\n    (void)T1_ToFixedArray( parser, 6, temp, 3 );\n     temp_scale = FT_ABS( temp[3] );\n    matrix->xx = temp[0];\n    matrix->yx = temp[1];\n    matrix->xy = temp[2];\n    matrix->yy = temp[3];\n    offset->x = temp[4] >> 16;\n    offset->y = temp[5] >> 16;\n       temp[2] = FT_DivFix( temp[2], temp_scale );\n       temp[4] = FT_DivFix( temp[4], temp_scale );\n       temp[5] = FT_DivFix( temp[5], temp_scale );\n      temp[3] = 0x10000L;\n     }", "target": 1}
{"code": "    inline PluginEndpointSecurityAttributesMask mask() const\n    {\n        PluginEndpointSecurityAttributesMask rv = PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_submessage_encrypted) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;\n        if (is_submessage_origin_authenticated) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ORIGIN_AUTHENTICATED;\n        if (is_payload_encrypted) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_ENCRYPTED;\n        return rv;\n    }", "target": 1}
{"code": "static pjmedia_sdp_attr *parse_attr( pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx)\n{\n    pjmedia_sdp_attr *attr;\n    ctx->last_error = PJMEDIA_SDP_EINATTR;\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn NULL;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get(scanner, &cs_token, &attr->name);\n    if (*scanner->curptr && *scanner->curptr != '\\r' && \n\t*scanner->curptr != '\\n') \n    {\n\tif (*scanner->curptr == ':')\n\t    pj_scan_get_char(scanner);\n\tif (*scanner->curptr != '\\r' && *scanner->curptr != '\\n') {\n\t    pj_scan_get_until_chr(scanner, \"\\r\\n\", &attr->value);\n\t} else {\n\t    attr->value.ptr = NULL;\n\t    attr->value.slen = 0;\n\t}\n    } else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n    pj_scan_skip_line(scanner);\n    return attr;\n}", "target": 1}
{"code": " static Maybe<bool> CollectValuesOrEntriesImpl(\n       Isolate* isolate, Handle<JSObject> object,\n       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,\n       PropertyFilter filter) {\n    int count = 0;\n     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,\n                                ALL_PROPERTIES);\n     Subclass::CollectElementIndicesImpl(\n         object, handle(object->elements(), isolate), &accumulator);\n     Handle<FixedArray> keys = accumulator.GetKeys();\n    for (int i = 0; i < keys->length(); ++i) {\n       Handle<Object> key(keys->get(i), isolate);\n      Handle<Object> value;\n       uint32_t index;\n       if (!key->ToUint32(&index)) continue;\n       uint32_t entry = Subclass::GetEntryForIndexImpl(\n           isolate, *object, object->elements(), index, filter);\n       if (entry == kMaxUInt32) continue;\n       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);\n       if (details.kind() == kData) {\n         value = Subclass::GetImpl(isolate, object->elements(), entry);\n       } else {\n         LookupIterator it(isolate, object, index, LookupIterator::OWN);\n         ASSIGN_RETURN_ON_EXCEPTION_VALUE(\n             isolate, value, Object::GetProperty(&it), Nothing<bool>());\n       }\n      if (get_entries) {\n        value = MakeEntryPair(isolate, index, value);\n       }\n       values_or_entries->set(count++, *value);\n     }\n *nof_items = count;\n return Just(true);\n }", "target": 1}
{"code": " void BeginInstallWithManifestFunction::OnParseSuccess(\n     const SkBitmap& icon, DictionaryValue* parsed_manifest) {\n  CHECK(parsed_manifest);\n  icon_ = icon;\n  parsed_manifest_.reset(parsed_manifest);\n  std::string init_errors;\n  dummy_extension_ = Extension::Create(\n      FilePath(),\n      Extension::INTERNAL,\n      *static_cast<DictionaryValue*>(parsed_manifest_.get()),\n      Extension::NO_FLAGS,\n      &init_errors);\n  if (!dummy_extension_.get()) {\n    OnParseFailure(MANIFEST_ERROR, std::string(kInvalidManifestError));\n    return;\n  }\n   if (icon_.empty())\n     icon_ = Extension::GetDefaultIcon(dummy_extension_->is_app());\n   ShowExtensionInstallDialog(profile(),\n                              this,\n                              dummy_extension_.get(),\n                             &icon_,\n                             dummy_extension_->GetPermissionMessageStrings(),\n                             ExtensionInstallUI::INSTALL_PROMPT);\n}", "target": 1}
{"code": "snmp_ber_encode_unsigned_integer(unsigned char *out, uint32_t *out_len, uint8_t type, uint32_t number)\n{\n  uint32_t original_out_len;\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, type);\n  return out;\n}", "target": 1}
{"code": "cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t i, maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE2(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n\t\tif (i >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn -1;\n\t\t}\n\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n\t\t    info, count, &maxcount) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "XML_GetFeatureList(void) {\n  static const XML_Feature features[] = {\n    {XML_FEATURE_SIZEOF_XML_CHAR, XML_L(\"sizeof(XML_Char)\"), sizeof(XML_Char)},\n    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L(\"sizeof(XML_LChar)\"),\n     sizeof(XML_LChar)},\n#ifdef XML_UNICODE\n    {XML_FEATURE_UNICODE, XML_L(\"XML_UNICODE\"), 0},\n#endif\n#ifdef XML_UNICODE_WCHAR_T\n    {XML_FEATURE_UNICODE_WCHAR_T, XML_L(\"XML_UNICODE_WCHAR_T\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_DTD, XML_L(\"XML_DTD\"), 0},\n#endif\n#if XML_CONTEXT_BYTES > 0\n    {XML_FEATURE_CONTEXT_BYTES, XML_L(\"XML_CONTEXT_BYTES\"), XML_CONTEXT_BYTES},\n#endif\n#ifdef XML_MIN_SIZE\n    {XML_FEATURE_MIN_SIZE, XML_L(\"XML_MIN_SIZE\"), 0},\n#endif\n#ifdef XML_NS\n    {XML_FEATURE_NS, XML_L(\"XML_NS\"), 0},\n#endif\n#ifdef XML_LARGE_SIZE\n    {XML_FEATURE_LARGE_SIZE, XML_L(\"XML_LARGE_SIZE\"), 0},\n#endif\n#ifdef XML_ATTR_INFO\n    {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n     XML_L(\"XML_BLAP_MAX_AMP\"),\n     (long int)\n         EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT},\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT,\n     XML_L(\"XML_BLAP_ACT_THRES\"),\n     EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT},\n#endif\n    {XML_FEATURE_END, NULL, 0}\n  };\n  return features;\n}", "target": 1}
{"code": "LogLuvClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_samplesperpixel =\n\t    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n\ttd->td_bitspersample = 16;\n\ttd->td_sampleformat = SAMPLEFORMAT_INT;\n}", "target": 1}
{"code": "ext_get_plugin(const char *name, const char *module, const char *revision)\n{\n    uint16_t u;\n    assert(name);\n    assert(module);\n    for (u = 0; u < ext_plugins_count; u++) {\n        if (!strcmp(name, ext_plugins[u].name) &&\n                !strcmp(module, ext_plugins[u].module) &&\n                (!ext_plugins[u].revision || !strcmp(revision, ext_plugins[u].revision))) {\n            return ext_plugins[u].plugin;\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "GF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "    Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) {\n        if (!getSSLManager()) {\n            return Status(ErrorCodes::ProtocolError,\n                          \"SSL support is required for the MONGODB-X509 mechanism.\");\n        }\n        if(user.getDB() != \"$external\") {\n            return Status(ErrorCodes::ProtocolError,\n                          \"X.509 authentication must always use the $external database.\");\n        }\n        ClientBasic *client = ClientBasic::getCurrent();\n        AuthorizationSession* authorizationSession = client->getAuthorizationSession();\n        std::string subjectName = client->port()->getX509SubjectName();\n        if (user.getUser() != subjectName) {\n            return Status(ErrorCodes::AuthenticationFailed,\n                          \"There is no x.509 client certificate matching the user.\");\n        }\n        else {\n            std::string srvSubjectName = getSSLManager()->getServerSubjectName();\n            std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find(\",OU=\"));\n            std::string peerClusterId = subjectName.substr(subjectName.find(\",OU=\"));\n            fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);\n            int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); \n            if (srvClusterId == peerClusterId) {\n                if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||\n                    clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {\n                    return Status(ErrorCodes::AuthenticationFailed, \"The provided certificate \" \n                                  \"can only be used for cluster authentication, not client \" \n                                  \"authentication. The current configuration does not allow \" \n                                  \"x.509 cluster authentication, check the --clusterAuthMode flag\");\n                }\n                authorizationSession->grantInternalAuthorization();\n            }\n            else {\n                if (_isX509AuthDisabled) {\n                    return Status(ErrorCodes::BadValue,\n                                  _x509AuthenticationDisabledMessage);\n                }\n                Status status = authorizationSession->addAndAuthorizeUser(user);\n                if (!status.isOK()) {\n                    return status;\n                }\n            }\n            return Status::OK();\n        }\n    }", "target": 1}
{"code": "bool ParamTraits<LOGFONT>::Read(const Message* m, PickleIterator* iter,\n                                 param_type* r) {\n   const char *data;\n   int data_size = 0;\n  bool result = m->ReadData(iter, &data, &data_size);\n  if (result && data_size == sizeof(LOGFONT)) {\n    memcpy(r, data, sizeof(LOGFONT));\n  } else {\n    result = false;\n    NOTREACHED();\n   }\n  return result;\n }", "target": 1}
{"code": "pixBlockconvGray(PIX     *pixs,\n                 PIX     *pixacc,\n                 l_int32  wc,\n                 l_int32  hc)\n{\nl_int32    w, h, d, wpl, wpla;\nl_uint32  *datad, *dataa;\nPIX       *pixd, *pixt;\n    PROCNAME(\"pixBlockconvGray\");\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_WARNING(\"kernel too large; returning a copy\\n\", procName);\n        L_INFO(\"w = %d, wc = %d, h = %d, hc = %d\\n\", procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\"pixacc not 32 bpp; making new one\\n\", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n    }\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pixSetPadBits(pixt, 0);\n    wpl = pixGetWpl(pixd);\n    wpla = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixt);\n    blockconvLow(datad, w, h, wpl, dataa, wpla, wc, hc);\n    pixDestroy(&pixt);\n    return pixd;\n}", "target": 1}
{"code": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  \n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  \n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  \n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  \n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}", "target": 1}
{"code": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\tgpio_dev = platform_get_drvdata(pdev);\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\treturn 0;\n}", "target": 1}
{"code": "void ff_jpeg2000_cleanup(Jpeg2000Component *comp, Jpeg2000CodingStyle *codsty)\n{\n    int reslevelno, bandno, precno;\n    for (reslevelno = 0;\n         comp->reslevel && reslevelno < codsty->nreslevels;\n         reslevelno++) {\n        Jpeg2000ResLevel *reslevel = comp->reslevel + reslevelno;\n        for (bandno = 0; bandno < reslevel->nbands; bandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (precno = 0; precno < reslevel->num_precincts_x * reslevel->num_precincts_y; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n                av_freep(&prec->zerobits);\n                av_freep(&prec->cblkincl);\n                av_freep(&prec->cblk);\n            }\n            av_freep(&band->prec);\n        }\n        av_freep(&reslevel->band);\n    }\n    ff_dwt_destroy(&comp->dwt);\n    av_freep(&comp->reslevel);\n    av_freep(&comp->i_data);\n    av_freep(&comp->f_data);\n}", "target": 1}
{"code": "static int netlbl_cipsov4_add_common(struct genl_info *info,\n\t\t\t\t     struct cipso_v4_doi *doi_def)\n{\n\tstruct nlattr *nla;\n\tint nla_rem;\n\tu32 iter = 0;\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n \tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n \t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n \t\t\t\treturn -EINVAL;\n \t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n \t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n \treturn 0;\n }", "target": 1}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "append_command(char_u *cmd)\n{\n    char_u *s = cmd;\n    char_u *d;\n    STRCAT(IObuff, \": \");\n    d = IObuff + STRLEN(IObuff);\n    while (*s != NUL && d - IObuff < IOSIZE - 7)\n    {\n\tif (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0)\n\t{\n\t    s += enc_utf8 ? 2 : 1;\n\t    STRCPY(d, \"<a0>\");\n\t    d += 4;\n\t}\n\telse\n\t    MB_COPY_CHAR(s, d);\n    }\n    *d = NUL;\n}", "target": 1}
{"code": "void gtkui_conf_read(void) {\n   FILE *fd;\n   const char *path;\n   char line[100], name[30];\n   short value;\n#ifdef OS_WINDOWS\n   path = ec_win_get_user_dir();\n#else\n   path = g_get_tmp_dir();\n#endif\n   filename = g_build_filename(path, \".ettercap_gtk\", NULL);\n   DEBUG_MSG(\"gtkui_conf_read: %s\", filename);\n   fd = fopen(filename, \"r\");\n   if(!fd) \n      return;\n   while(fgets(line, 100, fd)) {\n      sscanf(line, \"%s = %hd\", name, &value);\n      gtkui_conf_set(name, value);\n   }\n   fclose(fd);\n}", "target": 1}
{"code": "static int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    \n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\t*p++ = ' ';\n\tpj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\tp += m->desc.fmt[i].slen;\n    }\n    *p++ = '\\r';\n    *p++ = '\\n';\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    return (int)(p-buf);\n}", "target": 1}
{"code": "gxps_fonts_new_font_face (GXPSArchive *zip,\n\t\t\t  const gchar *font_uri,\n\t\t\t  GError     **error)\n{\n\tGHashTable        *ft_cache;\n\tFtFontFace         ft_face;\n\tFtFontFace        *ft_font_face;\n\tFT_Face            face;\n\tcairo_font_face_t *font_face;\n\tguchar            *font_data;\n\tgsize              font_data_len;\n\tgboolean           res;\n\tres = gxps_archive_read_entry (zip, font_uri,\n\t\t\t\t       &font_data, &font_data_len,\n\t\t\t\t       error);\n\tif (!res) {\n\t\tg_set_error (error,\n\t\t\t     GXPS_ERROR,\n\t\t\t     GXPS_ERROR_SOURCE_NOT_FOUND,\n\t\t\t     \"Font source %s not found in archive\",\n\t\t\t     font_uri);\n\t\treturn NULL;\n\t}\n\tft_face.font_data = font_data;\n\tft_face.font_data_len = (gssize)font_data_len;\n\tft_cache = get_ft_font_face_cache ();\n\tfont_face = g_hash_table_lookup (ft_cache, &ft_face);\n\tif (font_face) {\n\t\tg_free (font_data);\n\t\treturn font_face;\n\t}\n\tif (!gxps_fonts_new_ft_face (font_uri, font_data, font_data_len, &face)) {\n\t\tg_set_error (error,\n\t\t\t     GXPS_ERROR,\n\t\t\t     GXPS_ERROR_FONT,\n\t\t\t     \"Failed to load font %s\", font_uri);\n\t\tg_free (font_data);\n\t\treturn NULL;\n\t}\n\tfont_face = cairo_ft_font_face_create_for_ft_face (face, 0);\n\tif (cairo_font_face_set_user_data (font_face,\n\t\t\t\t\t   &ft_cairo_key,\n\t\t\t\t\t   face,\n\t\t\t\t\t   (cairo_destroy_func_t) FT_Done_Face)) {\n\t\tg_set_error (error,\n\t\t\t     GXPS_ERROR,\n\t\t\t     GXPS_ERROR_FONT,\n\t\t\t     \"Failed to load font %s: %s\",\n\t\t\t     font_uri,\n\t\t\t     cairo_status_to_string (cairo_font_face_status (font_face)));\n\t\tcairo_font_face_destroy (font_face);\n\t\tFT_Done_Face (face);\n\t\treturn NULL;\n\t}\n\tft_font_face = ft_font_face_new (font_data, (gssize)font_data_len);\n\tg_hash_table_insert (ft_cache, ft_font_face, font_face);\n\treturn font_face;\n}", "target": 1}
{"code": "        CFontFileBase(char *sFile, int nLen, bool bFreeFileData)\n        {\n            m_sFileData = m_sFile = (unsigned char *)sFile;\n            m_nLen = nLen;\n            m_bFreeFileData = bFreeFileData;\n            m_nPos = 0;\n        }", "target": 1}
{"code": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n         bigint *modulus, bigint *pub_exp)\n {\n    int i, size;\n     bigint *decrypted_bi, *dat_bi;\n     bigint *bir = NULL;\n     uint8_t *block = (uint8_t *)malloc(sig_len);\n     dat_bi = bi_import(ctx, sig, sig_len);\n     ctx->mod_offset = BIGINT_M_OFFSET;\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n     bi_export(ctx, decrypted_bi, block, sig_len);\n     ctx->mod_offset = BIGINT_M_OFFSET;\n    i = 10; \n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n     }\n     free(block);\n     bi_clear_cache(ctx);\n    return bir;\n}", "target": 1}
{"code": "  ps_parser_skip_PS_token( PS_Parser  parser )\n  {\n    FT_Byte*  cur   = parser->cursor;\n    FT_Byte*  limit = parser->limit;\n    FT_Error  error = FT_Err_Ok;\n    skip_spaces( &cur, limit );             \n    if ( cur >= limit )\n      goto Exit;\n    if ( *cur == '[' || *cur == ']' )\n    {\n      cur++;\n      goto Exit;\n    }\n    if ( *cur == '{' )                              \n    {\n      error = skip_procedure( &cur, limit );\n      goto Exit;\n    }\n    if ( *cur == '(' )                              \n    {\n      error = skip_literal_string( &cur, limit );\n      goto Exit;\n    }\n    if ( *cur == '<' )                              \n    {\n      if ( cur + 1 < limit && *(cur + 1) == '<' )   \n      {\n        cur++;\n        cur++;\n      }\n      else\n        error = skip_string( &cur, limit );\n      goto Exit;\n    }\n    if ( *cur == '>' )\n    {\n      cur++;\n      if ( cur >= limit || *cur != '>' )             \n      {\n        FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                   \" unexpected closing delimiter `>'\\n\" ));\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n      cur++;\n      goto Exit;\n    }\n    if ( *cur == '/' )\n      cur++;\n    while ( cur < limit )\n    {\n      if ( IS_PS_DELIM( *cur ) )\n        break;\n      cur++;\n    }\n  Exit:\n    if ( cur < limit && cur == parser->cursor )\n    {\n      FT_ERROR(( \"ps_parser_skip_PS_token:\"\n                 \" current token is `%c' which is self-delimiting\\n\"\n                 \"                        \"\n                 \" but invalid at this point\\n\",\n                 *cur ));\n       error = FT_THROW( Invalid_File_Format );\n     }\n     parser->error  = error;\n     parser->cursor = cur;\n   }", "target": 1}
{"code": "cib_send_tls(gnutls_session * session, xmlNode * msg)\n{\n    char *xml_text = NULL;\n#  if 0\n    const char *name = crm_element_name(msg);\n    if (safe_str_neq(name, \"cib_command\")) {\n        xmlNodeSetName(msg, \"cib_result\");\n    }\n#  endif\n    xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        int rc = 0;\n        len++;                  \n        crm_trace(\"Message size: %d\", len);\n        while (TRUE) {\n            rc = gnutls_record_send(*session, unsent, len);\n            crm_debug(\"Sent %d bytes\", rc);\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n                crm_debug(\"Retry\");\n            } else if (rc < 0) {\n                crm_debug(\"Connection terminated\");\n                break;\n            } else if (rc < len) {\n                crm_debug(\"Only sent %d of %d bytes\", rc, len);\n                len -= rc;\n                unsent += rc;\n            } else {\n                break;\n            }\n        }\n    }\n    free(xml_text);\n    return NULL;\n}", "target": 1}
{"code": "static int build_open_gop_key_points(AVStream *st)\n{\n    int k;\n    int sample_id = 0;\n    uint32_t cra_index;\n    MOVStreamContext *sc = st->priv_data;\n    if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count)\n        return 0;\n    sc->sample_offsets_count = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        sc->sample_offsets_count += sc->ctts_data[i].count;\n    av_freep(&sc->sample_offsets);\n    sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));\n    if (!sc->sample_offsets)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        for (int j = 0; j < sc->ctts_data[i].count; j++)\n             sc->sample_offsets[k++] = sc->ctts_data[i].duration;\n    cra_index = get_sgpd_sync_index(sc, HEVC_NAL_CRA_NUT); \n    if (!cra_index)\n        return 0;\n    sc->open_key_samples_count = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++)\n        if (sc->sync_group[i].index == cra_index)\n            sc->open_key_samples_count += sc->sync_group[i].count;\n    av_freep(&sc->open_key_samples);\n    sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));\n    if (!sc->open_key_samples)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++) {\n        const MOVSbgp *sg = &sc->sync_group[i];\n        if (sg->index == cra_index)\n            for (uint32_t j = 0; j < sg->count; j++)\n                sc->open_key_samples[k++] = sample_id;\n        sample_id += sg->count;\n    }\n    sc->min_sample_duration = UINT_MAX;\n    for (uint32_t i = 0; i < sc->stts_count; i++)\n        sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration);\n    return 0;\n}", "target": 1}
{"code": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\tif (!server)\n\t\treturn -1;\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\tserver->capture = shadow_capture_new(server);\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n    }\n    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n    buf4--;\n    while (len >= 32) {\n        DOBIG32;\n        len -= 32;\n    }\n    while (len >= 4) {\n        DOBIG4;\n        len -= 4;\n    }\n    buf4++;\n    buf = (const unsigned char FAR *)buf4;\n    if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}", "target": 1}
{"code": "static int xfrm_expand_policies(const struct flowi *fl, u16 family,\n\t\t\t\tstruct xfrm_policy **pols,\n\t\t\t\tint *num_pols, int *num_xfrms)\n{\n\tint i;\n\tif (*num_pols == 0 || !pols[0]) {\n\t\t*num_pols = 0;\n\t\t*num_xfrms = 0;\n\t\treturn 0;\n\t}\n\tif (IS_ERR(pols[0]))\n\t\treturn PTR_ERR(pols[0]);\n\t*num_xfrms = pols[0]->xfrm_nr;\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tif (pols[0]->action == XFRM_POLICY_ALLOW &&\n\t    pols[0]->type != XFRM_POLICY_TYPE_MAIN) {\n\t\tpols[1] = xfrm_policy_lookup_bytype(xp_net(pols[0]),\n\t\t\t\t\t\t    XFRM_POLICY_TYPE_MAIN,\n\t\t\t\t\t\t    fl, family,\n\t\t\t\t\t\t    XFRM_POLICY_OUT,\n\t\t\t\t\t\t    pols[0]->if_id);\n\t\tif (pols[1]) {\n\t\t\tif (IS_ERR(pols[1])) {\n\t\t\t\txfrm_pols_put(pols, *num_pols);\n\t\t\t\treturn PTR_ERR(pols[1]);\n\t\t\t}\n\t\t\t(*num_pols)++;\n\t\t\t(*num_xfrms) += pols[1]->xfrm_nr;\n\t\t}\n\t}\n#endif\n\tfor (i = 0; i < *num_pols; i++) {\n\t\tif (pols[i]->action != XFRM_POLICY_ALLOW) {\n\t\t\t*num_xfrms = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "cstrchr(char_u *s, int c)\n{\n    char_u\t*p;\n    int\t\tcc;\n    if (!rex.reg_ic || (!enc_utf8 && mb_char2len(c) > 1))\n\treturn vim_strchr(s, c);\n    if (enc_utf8 && c > 0x80)\n\tcc = utf_fold(c);\n    else\n\t if (MB_ISUPPER(c))\n\tcc = MB_TOLOWER(c);\n    else if (MB_ISLOWER(c))\n\tcc = MB_TOUPPER(c);\n    else\n\treturn vim_strchr(s, c);\n    if (has_mbyte)\n    {\n\tfor (p = s; *p != NUL; p += (*mb_ptr2len)(p))\n\t{\n\t    if (enc_utf8 && c > 0x80)\n\t    {\n\t\tif (utf_fold(utf_ptr2char(p)) == cc)\n\t\t    return p;\n\t    }\n\t    else if (*p == c || *p == cc)\n\t\treturn p;\n\t}\n    }\n    else\n\tfor (p = s; *p != NUL; ++p)\n\t    if (*p == c || *p == cc)\n\t\treturn p;\n    return NULL;\n}", "target": 1}
{"code": "static inline int file_list_cpu(struct file *file)\n{\n#ifdef CONFIG_SMP\n\treturn file->f_sb_list_cpu;\n#else\n\treturn smp_processor_id();\n#endif\n}", "target": 1}
{"code": "void SimpleSoftOMXComponent::onPortEnable(OMX_U32 portIndex, bool enable) {\n    CHECK_LT(portIndex, mPorts.size());\n PortInfo *port = &mPorts.editItemAt(portIndex);\n     CHECK_EQ((int)port->mTransition, (int)PortInfo::NONE);\n     CHECK(port->mDef.bEnabled == !enable);\n     if (!enable) {\n         port->mDef.bEnabled = OMX_FALSE;\n         port->mTransition = PortInfo::DISABLING;\n for (size_t i = 0; i < port->mBuffers.size(); ++i) {\n BufferInfo *buffer = &port->mBuffers.editItemAt(i);\n if (buffer->mOwnedByUs) {\n                buffer->mOwnedByUs = false;\n if (port->mDef.eDir == OMX_DirInput) {\n                    notifyEmptyBufferDone(buffer->mHeader);\n } else {\n                    CHECK_EQ(port->mDef.eDir, OMX_DirOutput);\n                    notifyFillBufferDone(buffer->mHeader);\n }\n }\n }\n        port->mQueue.clear();\n } else {\n        port->mTransition = PortInfo::ENABLING;\n }\n    checkTransitions();\n}", "target": 1}
{"code": "int ip_ra_control(struct sock *sk, unsigned char on,\n\t\t  void (*destructor)(struct sock *))\n{\n\tstruct ip_ra_chain *ra, *new_ra;\n\tstruct ip_ra_chain __rcu **rap;\n\tstruct net *net = sock_net(sk);\n\tif (sk->sk_type != SOCK_RAW || inet_sk(sk)->inet_num == IPPROTO_RAW)\n\t\treturn -EINVAL;\n\tnew_ra = on ? kmalloc(sizeof(*new_ra), GFP_KERNEL) : NULL;\n\tmutex_lock(&net->ipv4.ra_mutex);\n\tfor (rap = &net->ipv4.ra_chain;\n\t     (ra = rcu_dereference_protected(*rap,\n\t\t\tlockdep_is_held(&net->ipv4.ra_mutex))) != NULL;\n\t     rap = &ra->next) {\n\t\tif (ra->sk == sk) {\n\t\t\tif (on) {\n\t\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\t\t\tkfree(new_ra);\n\t\t\t\treturn -EADDRINUSE;\n\t\t\t}\n\t\t\tra->sk = NULL;\n\t\t\tRCU_INIT_POINTER(*rap, ra->next);\n\t\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\t\tif (ra->destructor)\n\t\t\t\tra->destructor(sk);\n\t\t\tra->saved_sk = sk;\n\t\t\tcall_rcu(&ra->rcu, ip_ra_destroy_rcu);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (!new_ra) {\n\t\tmutex_unlock(&net->ipv4.ra_mutex);\n\t\treturn -ENOBUFS;\n\t}\n\tnew_ra->sk = sk;\n\tnew_ra->destructor = destructor;\n\tRCU_INIT_POINTER(new_ra->next, ra);\n\trcu_assign_pointer(*rap, new_ra);\n\tsock_hold(sk);\n\tmutex_unlock(&net->ipv4.ra_mutex);\n\treturn 0;\n}", "target": 1}
{"code": "set<int> PipeSocketHandler::listen(const SocketEndpoint& endpoint) {\n  lock_guard<std::recursive_mutex> guard(globalMutex);\n  string pipePath = endpoint.name();\n  if (pipeServerSockets.find(pipePath) != pipeServerSockets.end()) {\n    throw runtime_error(\"Tried to listen twice on the same path\");\n  }\n  sockaddr_un local;\n  int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n  FATAL_FAIL(fd);\n  initServerSocket(fd);\n  local.sun_family = AF_UNIX; \n  strcpy(local.sun_path, pipePath.c_str());\n  unlink(local.sun_path);\n  FATAL_FAIL(::bind(fd, (struct sockaddr*)&local, sizeof(sockaddr_un)));\n  ::listen(fd, 5);\n#ifndef WIN32\n  FATAL_FAIL(::chmod(local.sun_path, S_IRUSR | S_IWUSR | S_IXUSR));\n#endif\n  pipeServerSockets[pipePath] = set<int>({fd});\n  return pipeServerSockets[pipePath];\n}", "target": 1}
{"code": "snmp_api_set_string(snmp_varbind_t *varbind, uint32_t *oid, char *string)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OCTET_STRING;\n  varbind->value.string.string = string;\n  varbind->value.string.length = strlen(string);\n}", "target": 1}
{"code": "ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           false);\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  auto msg_name_extent = output.next();\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n  auto msg_control_extent = output.next();\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n  return result;\n}", "target": 1}
{"code": "void gfs2_clear_rgrpd(struct gfs2_sbd *sdp)\n{\n\tstruct rb_node *n;\n\tstruct gfs2_rgrpd *rgd;\n\tstruct gfs2_glock *gl;\n\twhile ((n = rb_first(&sdp->sd_rindex_tree))) {\n\t\trgd = rb_entry(n, struct gfs2_rgrpd, rd_node);\n\t\tgl = rgd->rd_gl;\n\t\trb_erase(n, &sdp->sd_rindex_tree);\n\t\tif (gl) {\n\t\t\tspin_lock(&gl->gl_lockref.lock);\n\t\t\tgl->gl_object = NULL;\n\t\t\tspin_unlock(&gl->gl_lockref.lock);\n\t\t\tgfs2_glock_add_to_lru(gl);\n\t\t\tgfs2_glock_put(gl);\n\t\t}\n\t\tgfs2_free_clones(rgd);\n\t\tkfree(rgd->rd_bits);\n\t\treturn_all_reservations(rgd);\n\t\tkmem_cache_free(gfs2_rgrpd_cachep, rgd);\n\t}\n}", "target": 1}
{"code": "do_local_notify(xmlNode * notify_src, const char *client_id,\n                gboolean sync_reply, gboolean from_peer)\n{\n    cib_client_t *client_obj = NULL;\n    int local_rc = pcmk_ok;\n    if (client_id != NULL) {\n        client_obj = g_hash_table_lookup(client_list, client_id);\n    } else {\n        crm_trace(\"No client to sent the response to. F_CIB_CLIENTID not set.\");\n    }\n    if (client_obj == NULL) {\n        local_rc = -ECONNRESET;\n    } else {\n        int rid = 0;\n        if(sync_reply) {\n            CRM_LOG_ASSERT(client_obj->request_id);\n            rid = client_obj->request_id;\n            client_obj->request_id = 0;\n            crm_trace(\"Sending response %d to %s %s\",\n                      rid, client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        } else {\n            crm_trace(\"Sending an event to %s %s\",\n                      client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        }\n        if (client_obj->ipc && crm_ipcs_send(client_obj->ipc, rid, notify_src, !sync_reply) < 0) {\n            local_rc = -ENOMSG;\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client_obj->session) {\n            crm_send_remote_msg(client_obj->session, notify_src, client_obj->encrypted);\n#endif\n        } else if(client_obj->ipc == NULL) {\n            crm_err(\"Unknown transport for %s\", client_obj->name);\n        }\n    }\n    if (local_rc != pcmk_ok && client_obj != NULL) {\n        crm_warn(\"%sSync reply to %s failed: %s\",\n                 sync_reply ? \"\" : \"A-\",\n                 client_obj ? client_obj->name : \"<unknown>\", pcmk_strerror(local_rc));\n    }\n}", "target": 1}
{"code": "void svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "cib_tls_close(cib_t * cib)\n{\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    shutdown(private->command.socket, SHUT_RDWR);       \n    shutdown(private->callback.socket, SHUT_RDWR);      \n    close(private->command.socket);\n    close(private->callback.socket);\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (private->command.encrypted) {\n        gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->command.session));\n        gnutls_free(private->command.session);\n        gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->callback.session));\n        gnutls_free(private->callback.session);\n        gnutls_anon_free_client_credentials(anon_cred_c);\n        gnutls_global_deinit();\n    }\n#endif\n    return 0;\n}", "target": 1}
{"code": "int ipmi_destroy_user(struct ipmi_user *user)\n{\n\t_ipmi_destroy_user(user);\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkref_put(&user->refcount, free_user);\n\treturn 0;\n}", "target": 1}
{"code": "bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (session->restricted() && !IsFrameHostAllowedForRestrictedSessions())\n    return false;\n  session->SetRenderer(frame_host_ ? frame_host_->GetProcess()->GetID()\n                                   : ChildProcessHost::kInvalidUniqueID,\n                       frame_host_);\n  protocol::EmulationHandler* emulation_handler =\n      new protocol::EmulationHandler();\n  session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n  session->AddHandler(base::WrapUnique(emulation_handler));\n  session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));\n   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));\n  session->AddHandler(\n      base::WrapUnique(new protocol::TargetHandler(false )));\n   session->AddHandler(base::WrapUnique(new protocol::TracingHandler(\n       protocol::TracingHandler::Renderer,\n       frame_tree_node_ ? frame_tree_node_->frame_tree_node_id() : 0,\n      GetIOContext())));\n  session->AddHandler(\n      base::WrapUnique(new protocol::PageHandler(emulation_handler)));\n  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n  if (EnsureAgent())\n    session->AttachToAgent(agent_ptr_);\n  if (sessions().size() == 1) {\n    if (!base::FeatureList::IsEnabled(features::kVizDisplayCompositor) &&\n        !base::FeatureList::IsEnabled(\n            features::kUseVideoCaptureApiForDevToolsSnapshots)) {\n      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());\n    }\n    GrantPolicy();\n#if defined(OS_ANDROID)\n    GetWakeLock()->RequestWakeLock();\n#endif\n  }\n  return true;\n}", "target": 1}
{"code": "__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "static void gsm_cleanup_mux(struct gsm_mux *gsm, bool disc)\n{\n\tint i;\n\tstruct gsm_dlci *dlci = gsm->dlci[0];\n\tstruct gsm_msg *txq, *ntxq;\n\tgsm->dead = true;\n\tmutex_lock(&gsm->mutex);\n\tif (dlci) {\n\t\tif (disc && dlci->state != DLCI_CLOSED) {\n\t\t\tgsm_dlci_begin_close(dlci);\n\t\t\twait_event(gsm->event, dlci->state == DLCI_CLOSED);\n\t\t}\n\t\tdlci->dead = true;\n\t}\n\tdel_timer_sync(&gsm->kick_timer);\n\tdel_timer_sync(&gsm->t2_timer);\n\tdel_timer_sync(&gsm->ka_timer);\n\tflush_work(&gsm->tx_work);\n\tif (gsm->has_devices) {\n\t\tgsm_unregister_devices(gsm_tty_driver, gsm->num);\n\t\tgsm->has_devices = false;\n\t}\n\tfor (i = NUM_DLCI - 1; i >= 0; i--)\n\t\tif (gsm->dlci[i]) {\n\t\t\tgsm_dlci_release(gsm->dlci[i]);\n\t\t\tgsm->dlci[i] = NULL;\n\t\t}\n\tmutex_unlock(&gsm->mutex);\n\ttty_ldisc_flush(gsm->tty);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_ctrl_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_ctrl_list);\n\tlist_for_each_entry_safe(txq, ntxq, &gsm->tx_data_list, list)\n\t\tkfree(txq);\n\tINIT_LIST_HEAD(&gsm->tx_data_list);\n}", "target": 1}
{"code": "get_next_file(FILE *VFile, char *ptr)\n{\n\tchar *ret;\n\tret = fgets(ptr, PATH_MAX, VFile);\n\tif (!ret)\n\t\treturn NULL;\n\tif (ptr[strlen(ptr) - 1] == '\\n')\n\t\tptr[strlen(ptr) - 1] = '\\0';\n\treturn ret;\n}", "target": 1}
{"code": "struct bpf_map *bpf_map_meta_alloc(int inner_map_ufd)\n{\n\tstruct bpf_map *inner_map, *inner_map_meta;\n\tstruct fd f;\n\tf = fdget(inner_map_ufd);\n\tinner_map = __bpf_map_get(f);\n\tif (IS_ERR(inner_map))\n\t\treturn inner_map;\n\tif (inner_map->map_type == BPF_MAP_TYPE_PROG_ARRAY ||\n\t    inner_map->map_type == BPF_MAP_TYPE_CGROUP_STORAGE ||\n\t    inner_map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOTSUPP);\n\t}\n\tif (inner_map->inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tinner_map_meta = kzalloc(sizeof(*inner_map_meta), GFP_USER);\n\tif (!inner_map_meta) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinner_map_meta->map_type = inner_map->map_type;\n\tinner_map_meta->key_size = inner_map->key_size;\n\tinner_map_meta->value_size = inner_map->value_size;\n\tinner_map_meta->map_flags = inner_map->map_flags;\n\tinner_map_meta->ops = inner_map->ops;\n\tinner_map_meta->max_entries = inner_map->max_entries;\n\tfdput(f);\n\treturn inner_map_meta;\n}", "target": 1}
{"code": " static int perf_swevent_init(struct perf_event *event)\n {\n\tint event_id = event->attr.config;\n \tif (event->attr.type != PERF_TYPE_SOFTWARE)\n \t\treturn -ENOENT;\n\tif (has_branch_stack(event))\n\t\treturn -EOPNOTSUPP;\n\tswitch (event_id) {\n\tcase PERF_COUNT_SW_CPU_CLOCK:\n\tcase PERF_COUNT_SW_TASK_CLOCK:\n\t\treturn -ENOENT;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (event_id >= PERF_COUNT_SW_MAX)\n\t\treturn -ENOENT;\n\tif (!event->parent) {\n\t\tint err;\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tchar debug_buff[512];\n\tint remaining = sizeof(cmd) - 1;\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);\n\tdebug_print(debug_buff);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\tdebug_print(debug_buff);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_PERMISSION_DENIED;\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifndef DEBUG\n\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\t\tdebug_print(debug_buff);\n#endif\n\t}\n\tfree(inputline);\n\tg_free(proxy_auth);\n\treturn 0;\n}", "target": 1}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "static SDL_Surface *Create_Surface_Blended(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf = NULL;\n    Uint32 bgcolor;\n    bgcolor = (fg.r << 16) | (fg.g << 8) | fg.b;\n    *color = bgcolor | (fg.a << 24);\n    if (width != 0) {\n        Sint64 size;\n        void *pixels, *ptr;\n        Sint64 pitch = (width + alignment) * 4;\n        pitch += alignment;\n        pitch &= ~alignment;\n        size = height * pitch + sizeof (void *) + alignment;\n        if (size < 0 || size > SDL_MAX_SINT32) {\n            return NULL;\n        }\n        ptr = SDL_malloc((size_t)size);\n        if (ptr == NULL) {\n            return NULL;\n        }\n        pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n        ((void **)pixels)[-1] = ptr;\n        textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_ARGB8888);\n        if (textbuf == NULL) {\n            SDL_free(ptr);\n            return NULL;\n        }\n        textbuf->flags &= ~SDL_PREALLOC;\n        textbuf->flags |= SDL_SIMD_ALIGNED;\n        SDL_memset4(pixels, bgcolor, (height * pitch) / 4);\n        if (fg.a != SDL_ALPHA_OPAQUE) {\n            SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);\n        }\n    }\n    return textbuf;", "target": 1}
{"code": "void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,\n                                  int level, int prev_idx, int* src_data_ptr,\n                                  T* dest_data) {\n  if (level == indices.size()) {\n    int orig_rank = dense_shape_.size();\n    std::vector<int> orig_idx;\n    orig_idx.resize(orig_rank);\n    int i = 0;\n    for (; i < orig_idx.size(); i++) {\n      int orig_dim = traversal_order_[i];\n      orig_idx[orig_dim] = indices[i];\n    }\n    for (; i < indices.size(); i++) {\n      const int block_idx = traversal_order_[i] - orig_rank;\n      const int orig_dim = block_map_[block_idx];\n      orig_idx[orig_dim] =\n          orig_idx[orig_dim] * block_size_[block_idx] + indices[i];\n    }\n    dest_data[GetFlattenedIndex(orig_idx, dense_shape_)] =\n        src_data[*src_data_ptr];\n    *src_data_ptr = *src_data_ptr + 1;\n    return;\n  }\n  const int metadata_idx = 2 * level;\n  const int shape_of_level = dim_metadata_[metadata_idx][0];\n  if (format_[level] == kTfLiteDimDense) {\n    for (int i = 0; i < shape_of_level; i++) {\n      indices[level] = i;\n      Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,\n               src_data_ptr, dest_data);\n    }\n  } else {\n    const auto& array_segments = dim_metadata_[metadata_idx];\n    const auto& array_indices = dim_metadata_[metadata_idx + 1];\n    for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];\n         i++) {\n      indices[level] = array_indices[i];\n      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);\n    }\n  }\n}", "target": 1}
{"code": "int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tint ret = 0, bigname = 0;\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_crypt_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\tif (iname->name[0] == '_')\n\t\tbigname = 1;\n\tif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\n\t\treturn -ENOENT;\n\tfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\tret = digest_decode(iname->name + bigname, iname->len - bigname,\n\t\t\t\tfname->crypto_buf.name);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\tif (bigname) {\n\t\tmemcpy(&fname->hash, fname->crypto_buf.name, 4);\n\t\tmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\n\t} else {\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t}\n\treturn 0;\nerrout:\n\tfscrypt_fname_free_buffer(&fname->crypto_buf);\n\treturn ret;\n}", "target": 1}
{"code": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\tif (len < sizeof(sctp_assoc_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sas, optval, len))\n\t\treturn -EFAULT;\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\tasoc->stats.max_obs_rto = asoc->rto_min;\n\tlen = min_t(size_t, len, sizeof(sas));\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "void simplestring_addn(simplestring* target, const char* source, int add_len) {\n   if(target && source) {\n      if(!target->str) {\n         simplestring_init_str(target);\n      }\n      if(target->len + add_len + 1 > target->size) {\n         int newsize = target->len + add_len + 1;\n         int incr = target->size * 2;\n         newsize = newsize - (newsize % incr) + incr;\n         target->str = (char*)realloc(target->str, newsize);\n         target->size = target->str ? newsize : 0;\n      }\n      if(target->str) {\n         if(add_len) {\n            memcpy(target->str + target->len, source, add_len);\n         }\n         target->len += add_len;\n         target->str[target->len] = 0; \n      }\n   }\n}", "target": 1}
{"code": "bool ConstantFolding::SimplifyReshape(const GraphProperties& properties,\n                                      bool use_shape_info, NodeDef* node) {\n  if (!use_shape_info || node->attr().count(\"T\") == 0 ||\n      !IsSimplifiableReshape(*node, properties)) {\n    return false;\n  }\n  DataType output_type = node->attr().at(\"T\").type();\n  node->set_op(\"Identity\");\n  EraseRegularNodeAttributes(node);\n  (*node->mutable_attr())[\"T\"].set_type(output_type);\n  *node->mutable_input(1) = AsControlDependency(node->input(1));\n  return true;\n}", "target": 1}
{"code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\tif(image->numcomps < 4) return;\n\tmax = w * h;\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); \n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); \n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); \n\t}\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n}", "target": 1}
{"code": "static char* ConcatHttpHeaders(HTTP_HEADERS_HANDLE httpHeadersHandle, size_t toAlloc, size_t headersCount)\n{\n    char *result = (char*)malloc(toAlloc * sizeof(char) + 1);\n    size_t i;\n    if (result == NULL)\n    {\n        LogError(\"unable to malloc\");\n    }\n    else\n    {\n        result[0] = '\\0';\n        for (i = 0; i < headersCount; i++)\n        {\n            char* temp;\n            if (HTTPHeaders_GetHeader(httpHeadersHandle, i, &temp) != HTTP_HEADERS_OK)\n            {\n                LogError(\"unable to HTTPHeaders_GetHeader\");\n                break;\n            }\n            else\n            {\n                (void)strcat(result, temp);\n                (void)strcat(result, \"\\r\\n\");\n                free(temp);\n            }\n        }\n        if (i < headersCount)\n        {\n            free(result);\n            result = NULL;\n        }\n        else\n        {\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\tif (l_strnstart(\"MSG\", 4, (const char *)bp, length)) \n\t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(\"RPY \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(\"ERR \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(\"ANS \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(\"NUL \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(\"SEQ \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(\"END\", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP END\"));\n\telse\n\t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}", "target": 1}
{"code": "PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        if (timestamp >= file_info.m_ModificationTime) {\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n    }\n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}", "target": 1}
{"code": "pci_bus_configured(int bus)\n{\n\tassert(bus >= 0 && bus < MAXBUSES);\n\treturn (pci_businfo[bus] != NULL);\n}", "target": 1}
{"code": "static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tunsigned long sp, next_sp;\n\tunsigned long next_ip;\n\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n \tsp = regs->gpr[1];\n \tperf_callchain_store(entry, next_ip);\n\tfor (;;) {\n \t\tfp = (unsigned long __user *) sp;\n \t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n \t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\t\tif (next_sp - sp >= sizeof(struct signal_frame_64) &&\n\t\t    (is_sigreturn_64_address(next_ip, sp) ||\n\t\t     (level <= 1 && is_sigreturn_64_address(lr, sp))) &&\n\t\t    sane_signal_64_frame(sp)) {\n\t\t\tsigframe = (struct signal_frame_64 __user *) sp;\n\t\t\turegs = sigframe->uc.uc_mcontext.gp_regs;\n\t\t\tif (read_user_stack_64(&uregs[PT_NIP], &next_ip) ||\n\t\t\t    read_user_stack_64(&uregs[PT_LNK], &lr) ||\n\t\t\t    read_user_stack_64(&uregs[PT_R1], &sp))\n\t\t\t\treturn;\n\t\t\tlevel = 0;\n\t\t\tperf_callchain_store(entry, PERF_CONTEXT_USER);\n\t\t\tperf_callchain_store(entry, next_ip);\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 0)\n\t\t\tnext_ip = lr;\n\t\tperf_callchain_store(entry, next_ip);\n\t\t++level;\n\t\tsp = next_sp;\n\t}\n}", "target": 1}
{"code": "void nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\tnego->state = NEGO_STATE_FAIL;\n}", "target": 1}
{"code": "const char *jsi_GetHomeDir(Jsi_Interp *interp) {\n    const char *str = NULL;\n    if (interp->homeDir)\n        return interp->homeDir;\n#ifdef __WIN32\n    str = getenv(\"USERPROFILE\"); \n#else\n    if ((str = getenv(\"HOME\")) == NULL) {\n        struct passwd pwd, *pw;\n        char buf[20000];\n        if (getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pw) == 0 && pw->pw_dir)        \n            str = pw->pw_dir;\n    }\n#endif\n    if (!str) {\n        Jsi_LogBug(\"no home dir\");\n        str = \"/\";\n    }\n#ifdef JSI_LITE_ONLY\n    return str;\n#else\n    return (interp->homeDir = Jsi_KeyAdd(interp, str));\n#endif\n}", "target": 1}
{"code": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit;\n\t}\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); \nexit:\n\tspin_unlock(&rx->lock);\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "int kernel_read_file(struct file *file, void **buf, loff_t *size,\n\t\t     loff_t max_size, enum kernel_read_file_id id)\n{\n\tloff_t i_size, pos;\n\tssize_t bytes = 0;\n\tint ret;\n\tif (!S_ISREG(file_inode(file)->i_mode) || max_size < 0)\n\t\treturn -EINVAL;\n\tret = deny_write_access(file);\n\tif (ret)\n\t\treturn ret;\n\tret = security_kernel_read_file(file, id);\n\tif (ret)\n\t\tgoto out;\n\ti_size = i_size_read(file_inode(file));\n\tif (i_size <= 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (i_size > SIZE_MAX || (max_size > 0 && i_size > max_size)) {\n\t\tret = -EFBIG;\n\t\tgoto out;\n\t}\n\tif (id != READING_FIRMWARE_PREALLOC_BUFFER)\n\t\t*buf = vmalloc(i_size);\n\tif (!*buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpos = 0;\n\twhile (pos < i_size) {\n\t\tbytes = kernel_read(file, *buf + pos, i_size - pos, &pos);\n\t\tif (bytes < 0) {\n\t\t\tret = bytes;\n\t\t\tgoto out;\n\t\t}\n\t\tif (bytes == 0)\n\t\t\tbreak;\n\t}\n\tif (pos != i_size) {\n\t\tret = -EIO;\n\t\tgoto out_free;\n\t}\n\tret = security_kernel_post_read_file(file, *buf, i_size, id);\n\tif (!ret)\n\t\t*size = pos;\nout_free:\n\tif (ret < 0) {\n\t\tif (id != READING_FIRMWARE_PREALLOC_BUFFER) {\n\t\t\tvfree(*buf);\n\t\t\t*buf = NULL;\n\t\t}\n\t}\nout:\n\tallow_write_access(file);\n\treturn ret;\n}", "target": 1}
{"code": "skip_short_body (int fd, wgint contlen, bool chunked)\n{\n  enum {\n    SKIP_SIZE = 512,                \n    SKIP_THRESHOLD = 4096        \n  };\n  wgint remaining_chunk_size = 0;\n  char dlbuf[SKIP_SIZE + 1];\n  dlbuf[SKIP_SIZE] = '\\0';        \n  if (contlen > SKIP_THRESHOLD)\n    return false;\n  while (contlen > 0 || chunked)\n    {\n      int ret;\n      if (chunked)\n        {\n          if (remaining_chunk_size == 0)\n            {\n              char *line = fd_read_line (fd);\n              char *endl;\n              if (line == NULL)\n                break;\n              remaining_chunk_size = strtol (line, &endl, 16);\n              xfree (line);\n              if (remaining_chunk_size == 0)\n                {\n                  line = fd_read_line (fd);\n                  xfree (line);\n                  break;\n                }\n            }\n          contlen = MIN (remaining_chunk_size, SKIP_SIZE);\n        }\n      DEBUGP ((\"Skipping %s bytes of body: [\", number_to_static_string (contlen)));\n      ret = fd_read (fd, dlbuf, MIN (contlen, SKIP_SIZE), -1);\n      if (ret <= 0)\n        {\n          DEBUGP ((\"] aborting (%s).\\n\",\n                   ret < 0 ? fd_errstr (fd) : \"EOF received\"));\n          return false;\n        }\n      contlen -= ret;\n      if (chunked)\n        {\n          remaining_chunk_size -= ret;\n          if (remaining_chunk_size == 0)\n            {\n              char *line = fd_read_line (fd);\n              if (line == NULL)\n                return false;\n              else\n                xfree (line);\n            }\n        }\n      DEBUGP ((\"%.*s\", ret, dlbuf));\n    }\n  DEBUGP ((\"] done.\\n\"));\n  return true;\n}", "target": 1}
{"code": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n  if (u2fh_sendrecv\n       (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n        &resplen) == U2FH_OK)\n     {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n \t{\n\t  return U2FH_MEMORY_ERROR;\n \t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n     }\n   else\n     {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "target": 1}
{"code": "scoped_refptr<VideoFrame> CloneVideoFrameWithLayout(\n    const VideoFrame* const src_frame,\n    const VideoFrameLayout& dst_layout) {\n  LOG_ASSERT(src_frame->IsMappable());\n  LOG_ASSERT(src_frame->format() == dst_layout.format());\n  auto dst_frame = VideoFrame::CreateFrameWithLayout(\n      dst_layout, src_frame->visible_rect(), src_frame->natural_size(),\n      src_frame->timestamp(), false );\n  if (!dst_frame) {\n    LOG(ERROR) << \"Failed to create VideoFrame\";\n    return nullptr;\n  }\n  const size_t num_planes = VideoFrame::NumPlanes(dst_layout.format());\n   LOG_ASSERT(dst_layout.planes().size() == num_planes);\n   LOG_ASSERT(src_frame->layout().planes().size() == num_planes);\n   for (size_t i = 0; i < num_planes; ++i) {\n     libyuv::CopyPlane(\n         src_frame->data(i), src_frame->layout().planes()[i].stride,\n         dst_frame->data(i), dst_frame->layout().planes()[i].stride,\n        VideoFrame::Columns(i, dst_frame->format(),\n                            dst_frame->natural_size().width()),\n        VideoFrame::Rows(i, dst_frame->format(),\n                         dst_frame->natural_size().height()));\n   }\n   return dst_frame;\n}", "target": 1}
{"code": "commonio_sort (struct commonio_db *db, int (*cmp) (const void *, const void *))\n{\n\tstruct commonio_entry **entries, *ptr;\n\tsize_t n = 0, i;\n#if KEEP_NIS_AT_END\n\tstruct commonio_entry *nis = NULL;\n#endif\n\tfor (ptr = db->head;\n\t        (NULL != ptr)\n#if KEEP_NIS_AT_END\n\t     && (NULL != ptr->line)\n\t     && (   ('+' != ptr->line[0])\n\t         && ('-' != ptr->line[0]))\n#endif\n\t     ;\n\t     ptr = ptr->next) {\n\t\tn++;\n\t}\n#if KEEP_NIS_AT_END\n\tif ((NULL != ptr) && (NULL != ptr->line)) {\n\t\tnis = ptr;\n\t}\n#endif\n\tif (n <= 1) {\n\t\treturn 0;\n\t}\n\tentries = malloc (n * sizeof (struct commonio_entry *));\n\tif (entries == NULL) {\n\t\treturn -1;\n\t}\n\tn = 0;\n\tfor (ptr = db->head;\n#if KEEP_NIS_AT_END\n\t     nis != ptr;\n#else\n\t     NULL != ptr;\n#endif\n\t     ptr = ptr->next\n\t    ) {\n\t\tentries[n] = ptr;\n\t\tn++;\n\t}\n\tqsort (entries, n, sizeof (struct commonio_entry *), cmp);\n\tdb->head = entries[0];\n\tn--;\n#if KEEP_NIS_AT_END\n\tif (NULL == nis)\n#endif\n\t{\n\t\tdb->tail = entries[n];\n\t}\n\tdb->head->prev = NULL;\n\tdb->head->next = entries[1];\n\tentries[n]->prev = entries[n - 1];\n#if KEEP_NIS_AT_END\n\tentries[n]->next = nis;\n#else\n\tentries[n]->next = NULL;\n#endif\n\tfor (i = 1; i < n; i++) {\n\t\tentries[i]->prev = entries[i - 1];\n\t\tentries[i]->next = entries[i + 1];\n\t}\n\tfree (entries);\n\tdb->changed = true;\n\treturn 0;\n}", "target": 1}
{"code": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\tmutex_lock(&priv->lock);\n \tkfree(priv->ctrl.fname);\n \tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n \tif (p->fname) {\n \t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n \t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n \t}\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\treturn rc;\n}", "target": 1}
{"code": "rfbSendRectEncodingRaw(rfbClientPtr cl,\n                       int x,\n                       int y,\n                       int w,\n                       int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    int nlines;\n    int bytesPerLine = w * (cl->format.bitsPerPixel / 8);\n    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)\n                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));\n    if (cl->ublen > 0) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n    rect.r.x = Swap16IfLE(x);\n    rect.r.y = Swap16IfLE(y);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.encoding = Swap32IfLE(rfbEncodingRaw);\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n    rfbStatRecordEncodingSent(cl, rfbEncodingRaw, sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h,\n        sz_rfbFramebufferUpdateRectHeader + bytesPerLine * h);\n    nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;\n    while (TRUE) {\n        if (nlines > h)\n            nlines = h;\n        (*cl->translateFn)(cl->translateLookupTable,\n\t\t\t   &(cl->screen->serverFormat),\n                           &cl->format, fbptr, &cl->updateBuf[cl->ublen],\n                           cl->scaledScreen->paddedWidthInBytes, w, nlines);\n        cl->ublen += nlines * bytesPerLine;\n        h -= nlines;\n        if (h == 0)     \n            return TRUE;\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n        fbptr += (cl->scaledScreen->paddedWidthInBytes * nlines);\n        nlines = (UPDATE_BUF_SIZE - cl->ublen) / bytesPerLine;\n        if (nlines == 0) {\n            rfbErr(\"rfbSendRectEncodingRaw: send buffer too small for %d \"\n                   \"bytes per line\\n\", bytesPerLine);\n            rfbCloseClient(cl);\n            return FALSE;\n        }\n    }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 5,\n        errors::InvalidArgument(\"out_grad_backprop must be 5-dimensional\"));\n    Pool3dParameters params{context,  ksize_,       stride_,\n                            padding_, data_format_, tensor_in.shape()};\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {2}, 0, tensor_out.shape(), &output));\n    OP_REQUIRES(context, tensor_in.NumElements() > 0,\n                errors::InvalidArgument(\"received empty tensor tensor_in: \",\n                                        tensor_in.DebugString()));\n    OP_REQUIRES(context, tensor_out.NumElements() > 0,\n                errors::InvalidArgument(\"received empty tensor tensor_out: \",\n                                        tensor_out.DebugString()));\n    OP_REQUIRES(\n        context, out_grad_backprop.NumElements() > 0,\n        errors::InvalidArgument(\"received empty tensor out_grad_backprop: \",\n                                out_grad_backprop.DebugString()));\n    LaunchMaxPooling3dGradGradOp<Device, T>::launch(\n        context, params, tensor_in, tensor_out, out_grad_backprop, output);\n  }", "target": 1}
{"code": "std::wstring Utf8ToUtf16(const std::string& utf8_string) {\n  return MB2WC(utf8_string, CP_UTF8);\n}", "target": 1}
{"code": "static bool check_underflow(const struct ipt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->ip))\n\t\treturn false;\n\tt = ipt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "rpl_dio_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dio *dio = (const struct nd_rpl_dio *)bp;\n        const char *dagid_str;\n        ND_TCHECK(*dio);\n        dagid_str = ip6addr_string (ndo, dio->rpl_dagid);\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]\",\n                  dagid_str,\n                  dio->rpl_dtsn,\n                  dio->rpl_instanceid,\n                  EXTRACT_16BITS(&dio->rpl_dagrank),\n                  RPL_DIO_GROUNDED(dio->rpl_mopprf) ? \"grounded,\":\"\",\n                  tok2str(rpl_mop_values, \"mop%u\", RPL_DIO_MOP(dio->rpl_mopprf)),\n                  RPL_DIO_PRF(dio->rpl_mopprf)));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)&dio[1];\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n}", "target": 1}
{"code": "ProcXkbSetMap(ClientPtr client)\n{\n    DeviceIntPtr dev;\n    char *tmp;\n    int rc;\n    REQUEST(xkbSetMapReq);\n    REQUEST_AT_LEAST_SIZE(xkbSetMapReq);\n    if (!(client->xkbClientFlags & _XkbClientInitialized))\n        return BadAccess;\n    CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, DixManageAccess);\n    CHK_MASK_LEGAL(0x01, stuff->present, XkbAllMapComponentsMask);\n    tmp = (char *) &stuff[1];\n    rc = _XkbSetMapChecks(client, dev, stuff, tmp, TRUE);\n    if (rc != Success)\n        return rc;\n    DeviceIntPtr master = GetMaster(dev, MASTER_KEYBOARD);\n    if (stuff->deviceSpec == XkbUseCoreKbd) {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next) {\n            if ((other != dev) && other->key && !IsMaster(other) &&\n                GetMaster(other, MASTER_KEYBOARD) == dev) {\n                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,\n                              DixManageAccess);\n                if (rc == Success) {\n                    rc = _XkbSetMapChecks(client, other, stuff, tmp, FALSE);\n                    if (rc != Success)\n                        return rc;\n                }\n            }\n        }\n    } else {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next) {\n            if (other != dev && GetMaster(other, MASTER_KEYBOARD) != dev &&\n                (other != master || dev != master->lastSlave))\n                continue;\n            rc = _XkbSetMapChecks(client, other, stuff, tmp, FALSE);\n            if (rc != Success)\n                return rc;\n        }\n    }\n    rc = _XkbSetMap(client, dev, stuff, tmp);\n    if (rc != Success)\n        return rc;\n    if (stuff->deviceSpec == XkbUseCoreKbd) {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next) {\n            if ((other != dev) && other->key && !IsMaster(other) &&\n                GetMaster(other, MASTER_KEYBOARD) == dev) {\n                rc = XaceHook(XACE_DEVICE_ACCESS, client, other,\n                              DixManageAccess);\n                if (rc == Success)\n                    _XkbSetMap(client, other, stuff, tmp);\n            }\n        }\n    } else {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next) {\n            if (other != dev && GetMaster(other, MASTER_KEYBOARD) != dev &&\n                (other != master || dev != master->lastSlave))\n                continue;\n            _XkbSetMap(client, other, stuff, tmp); \n        }\n    }\n    return Success;\n}", "target": 1}
{"code": "uint32_t mt_random (mtrand *mt) {\n  uint32_t y;\n  unsigned long mag01[2];\n  mag01[0] = 0;\n  mag01[1] = MATRIX_A;\n  if (mt->mt_index_ >= MT_LEN) {\n    int kk;\n    for (kk = 0; kk < MT_LEN - MT_IA; kk++) {\n      y = (mt->mt_buffer_[kk] & UPPER_MASK) | \n\t(mt->mt_buffer_[kk + 1] & LOWER_MASK);\n      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + MT_IA] ^ \n\t(y >> 1) ^ mag01[y & 0x1UL];\n    }\n    for (;kk < MT_LEN - 1; kk++) {\n      y = (mt->mt_buffer_[kk] & UPPER_MASK) | \n\t(mt->mt_buffer_[kk + 1] & LOWER_MASK);\n      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + (MT_IA - MT_LEN)] ^ \n\t(y >> 1) ^ mag01[y & 0x1UL];\n    }\n    y = (mt->mt_buffer_[MT_LEN - 1] & UPPER_MASK) | \n      (mt->mt_buffer_[0] & LOWER_MASK);\n    mt->mt_buffer_[MT_LEN - 1] = mt->mt_buffer_[MT_IA - 1] ^ \n      (y >> 1) ^ mag01[y & 0x1UL];\n    mt->mt_index_ = 0;\n  }\n  y = mt->mt_buffer_[mt->mt_index_++];\n  y ^= (y >> 11);\n  y ^= (y << 7) & 0x9d2c5680UL;\n  y ^= (y << 15) & 0xefc60000UL;\n  y ^= (y >> 18);\n  return y;\n}", "target": 1}
{"code": "hufDecode\n    (const Int64 * \thcode,\t\n     const HufDec * \thdecod,\t\n     const char* \tin,\t\n     int\t\tni,\t\n     int\t\trlc,\t\n     int\t\tno,\t\n     unsigned short*\tout)\t\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; \n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\t    if (pl.len)\n\t    {\n\t\tlc -= pl.len;\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); \n\t\tint j;\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\t\t    while (lc < l && in < ie)\t\n\t\t\tgetChar (c, lc, in);\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); \n\t    }\n\t}\n    }\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); \n\t}\n    }\n    if (out - outb != no)\n\tnotEnoughData ();\n}", "target": 1}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tcontext->maxPlaneSize = context->maxWidth * context->maxHeight;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->planesBuffer = tmp;\n\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->pTempData = tmp;\n\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->deltaPlanesBuffer = tmp;\n\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);\n\tif (!tmp)\n\t\treturn FALSE;\n\tcontext->rlePlanesBuffer = tmp;\n\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\treturn TRUE;\n}", "target": 1}
{"code": "void MainWindow::on_actionUpgrade_triggered()\n{\n    if (Settings.askUpgradeAutmatic()) {\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"Do you want to automatically check for updates in the future?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"http:\n}", "target": 1}
{"code": "static int do_cmd (xd3_stream *stream, const char *buf)\n{\n  int ret;\n  if ((ret = system (buf)) != 0)\n    {\n      if (WIFEXITED (ret))\n\t{\n\t  stream->msg = \"command exited non-zero\";\n\t  IF_DEBUG1 (XPR(NT \"command was: %s\\n\", buf));\n\t}\n      else\n\t{\n\t  stream->msg = \"abnormal command termination\";\n\t}\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "static u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\tis_eos = gf_feof(bs->stream);\n\tif (!is_eos || bs->cache_read) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n \t\t\tsscanf(szV, \"%x\", &v);\n \t\t\tvalue[i] = v;\n \t\t\ti++;\n \t\t}\n \t}\n \tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "void color_sycc_to_rgb(opj_image_t *img)\n{\n\tif(img->numcomps < 3)\n\t{\n\t\timg->color_space = OPJ_CLRSPC_GRAY;\n\t\treturn;\n\t}\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 2)\n\t&& (img->comps[2].dy == 2))\n  {\n\t\tsycc420_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 2)\n\t&& (img->comps[2].dx == 2)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))\n  {\n\t\tsycc422_to_rgb(img);\n  }\n\telse\n\tif((img->comps[0].dx == 1)\n\t&& (img->comps[1].dx == 1)\n\t&& (img->comps[2].dx == 1)\n\t&& (img->comps[0].dy == 1)\n\t&& (img->comps[1].dy == 1)\n\t&& (img->comps[2].dy == 1))\n  {\n\t\tsycc444_to_rgb(img);\n  }\n\telse\n  {\n\t\tfprintf(stderr,\"%s:%d:color_sycc_to_rgb\\n\\tCAN NOT CONVERT\\n\", __FILE__,__LINE__);\n\t\treturn;\n  }\n\timg->color_space = OPJ_CLRSPC_SRGB;\n}", "target": 1}
{"code": "void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "    bool PamBackend::start(const QString &user) {\n        bool result;\n        QString service = QStringLiteral(\"sddm\");\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n        return result;\n    }", "target": 1}
{"code": "setup_server_realm(struct server_handle *handle, krb5_principal sprinc)\n{\n    kdc_realm_t         *newrealm;\n    kdc_realm_t **kdc_realmlist = handle->kdc_realmlist;\n    int kdc_numrealms = handle->kdc_numrealms;\n    if (kdc_numrealms > 1) {\n        if (!(newrealm = find_realm_data(handle, sprinc->realm.data,\n                                         (krb5_ui_4) sprinc->realm.length)))\n            return NULL;\n        else\n            return newrealm;\n    }\n    else\n        return kdc_realmlist[0];\n}", "target": 1}
{"code": "static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n \t\t\tgoto err;\n \t\t}\n\t\tif (cs > CQSPI_MAX_CHIPSELECT) {\n \t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n \t\t\tgoto err;\n \t\t}\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\t\tmtd->priv = nor;\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tf_pdata->registered = true;\n\t}\n\treturn 0;\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}", "target": 1}
{"code": "static void vmxnet3_complete_packet(VMXNET3State *s, int qidx, uint32_t tx_ridx)\n{\n    struct Vmxnet3_TxCompDesc txcq_descr;\n    PCIDevice *d = PCI_DEVICE(s);\n     VMXNET3_RING_DUMP(VMW_RIPRN, \"TXC\", qidx, &s->txq_descr[qidx].comp_ring);\n     txcq_descr.txdIdx = tx_ridx;\n     txcq_descr.gen = vmxnet3_ring_curr_gen(&s->txq_descr[qidx].comp_ring);\n    smp_wmb();\n    vmxnet3_inc_tx_completion_counter(s, qidx);\n    vmxnet3_trigger_interrupt(s, s->txq_descr[qidx].intr_idx);\n}", "target": 1}
{"code": "Pl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                initializeVector();\n            }\n            else\n\t    {\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    getNext()->write(this->outbuf, bytes);\n    this->offset = 0;\n}", "target": 1}
{"code": "void sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}", "target": 1}
{"code": " WORD32 ih264d_create(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n {\n     ih264d_create_op_t *ps_create_op;\n     WORD32 ret;\n     ps_create_op = (ih264d_create_op_t *)pv_api_op;\n     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;\n     ret = ih264d_allocate_static_bufs(&dec_hdl, pv_api_ip, pv_api_op);\n    if((IV_FAIL == ret) && (NULL != dec_hdl))\n     {\n        ih264d_free_static_bufs(dec_hdl);\n         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;\n         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;\n return IV_FAIL;\n }\n return IV_SUCCESS;\n}", "target": 1}
{"code": "static int usb_host_handle_control(USBHostDevice *s, USBPacket *p)\n{\n    struct usbdevfs_urb *urb;\n    AsyncURB *aurb;\n    int ret, value, index;\n    value = le16_to_cpu(s->ctrl.req.wValue);\n    index = le16_to_cpu(s->ctrl.req.wIndex);\n    dprintf(\"husb: ctrl type 0x%x req 0x%x val 0x%x index %u len %u\\n\",\n        s->ctrl.req.bRequestType, s->ctrl.req.bRequest, value, index, \n        s->ctrl.len);\n    if (s->ctrl.req.bRequestType == 0) {\n        switch (s->ctrl.req.bRequest) {\n        case USB_REQ_SET_ADDRESS:\n            return usb_host_set_address(s, value);\n        case USB_REQ_SET_CONFIGURATION:\n            return usb_host_set_config(s, value & 0xff);\n        }\n    }\n    if (s->ctrl.req.bRequestType == 1 &&\n                  s->ctrl.req.bRequest == USB_REQ_SET_INTERFACE)\n        return usb_host_set_interface(s, index, value);\n    aurb = async_alloc();\n    aurb->hdev   = s;\n    aurb->packet = p;\n    urb = &aurb->urb;\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n    urb->endpoint = p->devep;\n    urb->buffer        = &s->ctrl.req;\n    urb->buffer_length = 8 + s->ctrl.len;\n    urb->usercontext = s;\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n    dprintf(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n    if (ret < 0) {\n        dprintf(\"husb: submit failed. errno %d\\n\", errno);\n        async_free(aurb);\n        switch(errno) {\n        case ETIMEDOUT:\n            return USB_RET_NAK;\n        case EPIPE:\n        default:\n            return USB_RET_STALL;\n        }\n    }\n    usb_defer_packet(p, async_cancel, aurb);\n    return USB_RET_ASYNC;\n}", "target": 1}
{"code": "static bool __init is_skylake_era(void)\n{\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\n\t    boot_cpu_data.x86 == 6) {\n\t\tswitch (boot_cpu_data.x86_model) {\n\t\tcase INTEL_FAM6_SKYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_SKYLAKE_DESKTOP:\n\t\tcase INTEL_FAM6_SKYLAKE_X:\n\t\tcase INTEL_FAM6_KABYLAKE_MOBILE:\n\t\tcase INTEL_FAM6_KABYLAKE_DESKTOP:\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}", "target": 1}
{"code": " static int mct_u232_port_probe(struct usb_serial_port *port)\n {\n \tstruct mct_u232_private *priv;\n \tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n \tif (!priv)\n \t\treturn -ENOMEM;\n\tpriv->read_urb = port->serial->port[1]->interrupt_in_urb;\n \tpriv->read_urb->context = port;\n \tspin_lock_init(&priv->lock);\n\tusb_set_serial_port_data(port, priv);\n\treturn 0;\n}", "target": 1}
{"code": "static int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint i_size_changed = 0;\n\ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (ext4_has_inline_data(inode)) {\n\t\tret = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tput_page(page);\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\treturn ret ? ret : copied;\n}", "target": 1}
{"code": "}\nvoid print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}", "target": 1}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Bogus thumbnail offset (%u) or size (%u).\",\n\t\t\t  o, s);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "get_matching_model_microcode(int cpu, unsigned long start,\n\t\t\t     void *data, size_t size,\n\t\t\t     struct mc_saved_data *mc_saved_data,\n\t\t\t     unsigned long *mc_saved_in_initrd,\n\t\t\t     struct ucode_cpu_info *uci)\n{\n\tu8 *ucode_ptr = data;\n\tunsigned int leftover = size;\n\tenum ucode_state state = UCODE_OK;\n\tunsigned int mc_size;\n\tstruct microcode_header_intel *mc_header;\n\tstruct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];\n\tunsigned int mc_saved_count = mc_saved_data->mc_saved_count;\n\tint i;\n\twhile (leftover) {\n\t\tmc_header = (struct microcode_header_intel *)ucode_ptr;\n\t\tmc_size = get_totalsize(mc_header);\n\t\tif (!mc_size || mc_size > leftover ||\n\t\t\tmicrocode_sanity_check(ucode_ptr, 0) < 0)\n\t\t\tbreak;\n\t\tleftover -= mc_size;\n\t\tif (matching_model_microcode(mc_header, uci->cpu_sig.sig) !=\n\t\t\t UCODE_OK) {\n\t\t\tucode_ptr += mc_size;\n\t\t\tcontinue;\n\t\t}\n\t\t_save_mc(mc_saved_tmp, ucode_ptr, &mc_saved_count);\n\t\tucode_ptr += mc_size;\n\t}\n\tif (leftover) {\n\t\tstate = UCODE_ERROR;\n\t\tgoto out;\n\t}\n\tif (mc_saved_count == 0) {\n\t\tstate = UCODE_NFOUND;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < mc_saved_count; i++)\n\t\tmc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;\n\tmc_saved_data->mc_saved_count = mc_saved_count;\nout:\n\treturn state;\n}", "target": 1}
{"code": "static void on_underlying_io_bytes_received(void* context, const unsigned char* buffer, size_t size)\n{\n    if (context != NULL)\n    {\n        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)context;\n        unsigned char* new_socket_io_read_bytes = (unsigned char*)realloc(tls_io_instance->socket_io_read_bytes, tls_io_instance->socket_io_read_byte_count + size);\n        if (new_socket_io_read_bytes == NULL)\n        {\n            LogError(\"Failed allocating memory for received bytes\");\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else\n        {\n            tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;\n            (void)memcpy(tls_io_instance->socket_io_read_bytes + tls_io_instance->socket_io_read_byte_count, buffer, size);\n            tls_io_instance->socket_io_read_byte_count += size;\n        }\n    }\n    else\n    {\n        LogInfo(\"Supplied context is NULL on bytes_received\");\n    }\n}", "target": 1}
{"code": "jio_vsnprintf(char * str, int n, const char * format, va_list args)\n{\n\tint result;\n\tTrc_SC_vsnprintf_Entry(str, n, format);\n#if defined(WIN32) && !defined(WIN32_IBMC)\n\tresult = _vsnprintf( str, n, format, args );\n#else \n\tresult = vsprintf( str, format, args );\n#endif\n\tTrc_SC_vsnprintf_Exit(result);\n\treturn result;\n}", "target": 1}
{"code": "static void vgacon_scrollback_reset(int vc_num, size_t reset_size)\n{\n\tstruct vgacon_scrollback_info *scrollback = &vgacon_scrollbacks[vc_num];\n\tif (scrollback->data && reset_size > 0)\n\t\tmemset(scrollback->data, 0, reset_size);\n\tscrollback->cnt  = 0;\n\tscrollback->tail = 0;\n\tscrollback->cur  = 0;\n}", "target": 1}
{"code": "static int handle_vmptrst(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\tgva_t vmcs_gva;\n\tstruct x86_exception e;\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (get_vmx_mem_address(vcpu, exit_qualification,\n\t\t\tvmx_instruction_info, true, &vmcs_gva))\n\t\treturn 1;\n\tif (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,\n\t\t\t\t (void *)&to_vmx(vcpu)->nested.current_vmptr,\n\t\t\t\t sizeof(u64), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 1}
{"code": "int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap,\n                             uv_buf_t* bufs,\n                             size_t count,\n                             uv_stream_t* send_handle) {\n  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);\n  int r;\n  if (send_handle == nullptr) {\n    r = w->Dispatch(uv_write, stream(), bufs, count, AfterUvWrite);\n  } else {\n    r = w->Dispatch(uv_write2,\n                    stream(),\n                    bufs,\n                    count,\n                    send_handle,\n                    AfterUvWrite);\n  }\n  if (!r) {\n    size_t bytes = 0;\n    for (size_t i = 0; i < count; i++)\n      bytes += bufs[i].len;\n    if (stream()->type == UV_TCP) {\n      NODE_COUNT_NET_BYTES_SENT(bytes);\n    } else if (stream()->type == UV_NAMED_PIPE) {\n      NODE_COUNT_PIPE_BYTES_SENT(bytes);\n    }\n  }\n  return r;\n}", "target": 1}
{"code": " status_t CameraDeviceClient::dump(int fd, const Vector<String16>& args) {\n     String8 result;\n     result.appendFormat(\"CameraDeviceClient[%d] (%p) PID: %d, dump:\\n\",\n             mCameraId,\n            getRemoteCallback()->asBinder().get(),\n            mClientPid);\n    result.append(\"  State: \");\n    mFrameProcessor->dump(fd, args);\n return dumpDevice(fd, args);\n}", "target": 1}
{"code": "static CURLcode smtp_connect(struct connectdata *conn,\n                             bool *done) \n{\n  CURLcode result;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct SessionHandle *data = conn->data;\n  struct pingpong *pp = &smtpc->pp;\n  const char *path = conn->data->state.path;\n  int len;\n  char localhost[HOSTNAME_MAX + 1];\n  *done = FALSE; \n  Curl_reset_reqproto(conn);\n  result = smtp_init(conn);\n  if(CURLE_OK != result)\n    return result;\n  conn->bits.close = FALSE;\n  pp->response_time = RESP_TIMEOUT; \n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {\n    struct HTTP http_proxy;\n    struct FTP *smtp_save;\n    smtp_save = data->state.proto.smtp;\n    memset(&http_proxy, 0, sizeof(http_proxy));\n    data->state.proto.http = &http_proxy;\n    result = Curl_proxyCONNECT(conn, FIRSTSOCKET,\n                               conn->host.name, conn->remote_port);\n    data->state.proto.smtp = smtp_save;\n    if(CURLE_OK != result)\n      return result;\n  }\n  if((conn->handler->protocol & CURLPROTO_SMTPS) &&\n      data->state.used_interface != Curl_if_multi) {\n    result = Curl_ssl_connect(conn, FIRSTSOCKET);\n    if(result)\n      return result;\n  }\n  Curl_pp_init(pp); \n  pp->response_time = RESP_TIMEOUT; \n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof localhost))\n      path = localhost;\n    else\n      path = \"localhost\";\n  }\n  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n  if(!smtpc->domain)\n    return CURLE_OUT_OF_MEMORY;\n  state(conn, SMTP_SERVERGREET);\n  if(data->state.used_interface == Curl_if_multi)\n    result = smtp_multi_statemach(conn, done);\n  else {\n    result = smtp_easy_statemach(conn);\n    if(!result)\n      *done = TRUE;\n  }\n  return result;\n}", "target": 1}
{"code": "static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n  LClosure *f;\n  StkId fi = index2addr(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  api_check(L, (1 <= n && n <= f->p->sizeupvalues), \"invalid upvalue index\");\n  if (pf) *pf = f;\n  return &f->upvals[n - 1];  \n}", "target": 1}
{"code": "int ossl_policy_cache_set_mapping(X509 *x, POLICY_MAPPINGS *maps)\n{\n    POLICY_MAPPING *map;\n    X509_POLICY_DATA *data;\n    X509_POLICY_CACHE *cache = x->policy_cache;\n    int i;\n    int ret = 0;\n    if (sk_POLICY_MAPPING_num(maps) == 0) {\n        ret = -1;\n        goto bad_mapping;\n    }\n    for (i = 0; i < sk_POLICY_MAPPING_num(maps); i++) {\n        map = sk_POLICY_MAPPING_value(maps, i);\n        if ((OBJ_obj2nid(map->subjectDomainPolicy) == NID_any_policy)\n            || (OBJ_obj2nid(map->issuerDomainPolicy) == NID_any_policy)) {\n            ret = -1;\n            goto bad_mapping;\n        }\n        data = ossl_policy_cache_find_data(cache, map->issuerDomainPolicy);\n        if (data == NULL && !cache->anyPolicy)\n            continue;\n        if (data == NULL) {\n            data = ossl_policy_data_new(NULL, map->issuerDomainPolicy,\n                                        cache->anyPolicy->flags\n                                        & POLICY_DATA_FLAG_CRITICAL);\n            if (data == NULL)\n                goto bad_mapping;\n            data->qualifier_set = cache->anyPolicy->qualifier_set;\n            data->flags |= POLICY_DATA_FLAG_MAPPED_ANY;\n            data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n            if (!sk_X509_POLICY_DATA_push(cache->data, data)) {\n                ossl_policy_data_free(data);\n                goto bad_mapping;\n            }\n        } else\n            data->flags |= POLICY_DATA_FLAG_MAPPED;\n        if (!sk_ASN1_OBJECT_push(data->expected_policy_set,\n                                 map->subjectDomainPolicy))\n            goto bad_mapping;\n        map->subjectDomainPolicy = NULL;\n    }\n    ret = 1;\n bad_mapping:\n    if (ret == -1 && CRYPTO_THREAD_write_lock(x->lock)) {\n        x->ex_flags |= EXFLAG_INVALID_POLICY;\n        CRYPTO_THREAD_unlock(x->lock);\n    }\n    sk_POLICY_MAPPING_pop_free(maps, POLICY_MAPPING_free);\n    return ret;\n}", "target": 1}
{"code": "snmp_ber_encode_type(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  *out-- = type;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "int main()\n{\n   initialize_environment();\n   test_format_wrong_size();\n   test_blit_info_format_check();\n   test_blit_info_format_check_null_format();\n   test_format_is_plain_nullptr_deref_trigger();\n   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();\n   test_format_util_format_is_rgb_nullptr_deref_trigger();\n   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();\n   test_double_free_in_vrend_renderer_blit_int_trigger();\n   test_format_is_has_alpha_nullptr_deref_trigger_original();\n   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();\n   virgl_renderer_context_destroy(ctx_id);\n   virgl_renderer_cleanup(&cookie);\n   virgl_egl_destroy(test_egl);\n   return 0;\n}", "target": 1}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n \thdr = (void*)p - head->iov_base;\n \tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 1}
{"code": "static int libusb_udev_isoch_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,\n                                      UINT32 MessageId, UINT32 RequestId, UINT32 EndpointAddress,\n                                      UINT32 TransferFlags, UINT32 StartFrame, UINT32 ErrorCount,\n                                      BOOL NoAck, const BYTE* packetDescriptorData,\n                                      UINT32 NumberOfPackets, UINT32 BufferSize, const BYTE* Buffer,\n                                      t_isoch_transfer_cb cb, UINT32 Timeout)\n{\n\tUINT32 iso_packet_size;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tstruct libusb_transfer* iso_transfer = NULL;\n\tURBDRC_PLUGIN* urbdrc;\n\tsize_t outSize = (NumberOfPackets * 12);\n\tuint32_t streamID = 0x40000000 | RequestId;\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\turbdrc = pdev->urbdrc;\n\tuser_data = async_transfer_user_data_new(idev, MessageId, 48, BufferSize, Buffer,\n\t                                         outSize + 1024, NoAck, cb, callback);\n\tif (!user_data)\n\t\treturn -1;\n\tuser_data->ErrorCount = ErrorCount;\n\tuser_data->StartFrame = StartFrame;\n\tif (!Buffer)\n\t\tStream_Seek(user_data->data, (NumberOfPackets * 12));\n\tiso_packet_size = BufferSize / NumberOfPackets;\n\tiso_transfer = libusb_alloc_transfer(NumberOfPackets);\n\tif (iso_transfer == NULL)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"Error: libusb_alloc_transfer.\");\n\t\tasync_transfer_user_data_free(user_data);\n\t\treturn -1;\n\t}\n\tlibusb_fill_iso_transfer(iso_transfer, pdev->libusb_handle, EndpointAddress,\n\t                         Stream_Pointer(user_data->data), BufferSize, NumberOfPackets,\n\t                         func_iso_callback, user_data, Timeout);\n\tset_stream_id_for_buffer(iso_transfer, streamID);\n\tlibusb_set_iso_packet_lengths(iso_transfer, iso_packet_size);\n\tif (ArrayList_Add(pdev->request_queue, iso_transfer) < 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"Failed to queue iso transfer, streamID %08\" PRIx32 \" already in use!\",\n\t\t           streamID);\n\t\trequest_free(iso_transfer);\n\t\treturn -1;\n\t}\n\treturn libusb_submit_transfer(iso_transfer);\n}", "target": 1}
{"code": "static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\tif (evtchn_to_irq[row] == NULL) {\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\tevtchn_to_irq[row][col] = irq;\n\treturn 0;\n}", "target": 1}
{"code": "mem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\tif (log_op)\n\t\tfclose(log_op);\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen(log_name, \"a\");\n\tif (log_op == NULL) {\n\t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n\t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\t\tsetlinebuf(log_op);\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\tfree(log_name);\n\tterminate_banner = banner;\n}", "target": 1}
{"code": "Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\tModularArithmetic modn(m_n);\n\tInteger r, rInv;\n\tdo {\t\n\t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n\t\trInv = modn.MultiplicativeInverse(r);\n\t} while (rInv.IsZero());\n\tInteger re = modn.Square(r);\n\tre = modn.Multiply(re, x);\t\t\t\n\tInteger cp=re%m_p, cq=re%m_q;\n\tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n\t{\n\t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n\t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n\t}\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t\tcp = ModularSquareRoot(cp, m_p);\n\t\t\t#pragma omp section\n\t\t\t\tcq = ModularSquareRoot(cq, m_q);\n\t\t}\n\tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n\ty = modn.Multiply(y, rInv);\t\t\t\t\n\ty = STDMIN(y, m_n-y);\n\tif (ApplyFunction(y) != x)\t\t\t\t\n\t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n\treturn y;\n}", "target": 1}
{"code": "void my_output_message( j_common_ptr ) {} ", "target": 1}
{"code": "void ssl_update_cache(SSL_CONNECTION *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_CONNECTION_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_CONNECTION_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(SSL_CONNECTION_GET_SSL(s),\n                                                s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n            reservekey.KeepKey();\n            AddToWallet(wtxNew);\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n        mapRequestCount[wtxNew.GetHash()] = 0;\n        if (!wtxNew.AcceptToMemoryPool())\n        {\n            printf(\"CommitTransaction() : Error: Transaction not valid\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}", "target": 1}
{"code": "static unsigned int stack_maxrandom_size(void)\n {\n\tunsigned int max = 0;\n \tif ((current->flags & PF_RANDOMIZE) &&\n \t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n \t}\n \treturn max;\n}", "target": 1}
{"code": "void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,\n\t\t   unsigned int len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct {\n\t\tstruct ip_options\topt;\n\t\tchar\t\t\tdata[40];\n\t} replyopts;\n\tstruct ipcm_cookie ipc;\n\t__be32 daddr;\n\tstruct rtable *rt = skb_rtable(skb);\n\tif (ip_options_echo(&replyopts.opt, skb))\n\t\treturn;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (replyopts.opt.optlen) {\n\t\tipc.opt = &replyopts.opt;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = replyopts.opt.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4;\n\t\tflowi4_init_output(&fl4, arg->bound_dev_if, 0,\n\t\t\t\t   RT_TOS(ip_hdr(skb)->tos),\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   ip_reply_arg_flowi_flags(arg),\n\t\t\t\t   daddr, rt->rt_spec_dst,\n\t\t\t\t   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\treturn;\n\t}\n\tbh_lock_sock(sk);\n\tinet->tos = ip_hdr(skb)->tos;\n\tsk->sk_priority = skb->priority;\n\tsk->sk_protocol = ip_hdr(skb)->protocol;\n\tsk->sk_bound_dev_if = arg->bound_dev_if;\n\tip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,\n\t\t       &ipc, &rt, MSG_DONTWAIT);\n\tif ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tif (arg->csumoffset >= 0)\n\t\t\t*((__sum16 *)skb_transport_header(skb) +\n\t\t\t  arg->csumoffset) = csum_fold(csum_add(skb->csum,\n\t\t\t\t\t\t\t\targ->csum));\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk);\n\t}\n\tbh_unlock_sock(sk);\n\tip_rt_put(rt);\n}", "target": 1}
{"code": "int dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_A_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_A_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV4HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_A_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_A_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t  struct msghdr *m, size_t total_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\terror = -EIO;\n\t\tgoto end;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &error);\n\tif (error < 0)\n\t\tgoto end;\n\tm->msg_namelen = 0;\n\tif (skb) {\n\t\ttotal_len = min_t(size_t, total_len, skb->len);\n\t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\n\t\tif (error == 0) {\n\t\t\tconsume_skb(skb);\n\t\t\treturn total_len;\n\t\t}\n\t}\n\tkfree_skb(skb);\nend:\n\treturn error;\n}", "target": 1}
{"code": "static void start_auth_request(PgSocket *client, const char *username)\n{\n \tint res;\n \tPktBuf *buf;\n\tclient->auth_user = client->db->auth_user;\n \tclient->pool = get_pool(client->db, client->db->auth_user);\n \tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}", "target": 1}
{"code": "static void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset)\n{\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        return;\n    }\n    if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {\n        DEBUG(\"6lo sfr: ARQ timeout for datagram %u already scheduled\\n\",\n              (uint8_t)fbuf->tag);\n        return;\n    }\n    DEBUG(\"6lo sfr: arming ACK timeout in %lums for datagram %u\\n\",\n          (long unsigned)offset, fbuf->tag);\n    fbuf->sfr.arq_timeout_event.event.offset = offset;\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = fbuf;\n    fbuf->sfr.arq_timeout_event.msg.type = GNRC_SIXLOWPAN_FRAG_SFR_ARQ_TIMEOUT_MSG;\n    evtimer_add_msg(&_arq_timer, &fbuf->sfr.arq_timeout_event,\n                    _getpid());\n}", "target": 1}
{"code": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n    pc->last_index= pc->index;\n     if(next == END_NOT_FOUND){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n             return AVERROR(ENOMEM);\n         pc->buffer = new_buffer;\n         memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n         pc->index += *buf_size;\n        return -1;\n    }\n    *buf_size=\n    pc->overread_index= pc->index + next;\n     if(pc->index){\n         void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n             return AVERROR(ENOMEM);\n         pc->buffer = new_buffer;\n         if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n             memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n    return 0;\n}", "target": 1}
{"code": "static void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tint start, end, count, soff;\n\tif (!lines) {\n\t\tvgacon_restore_screen(c);\n\t\treturn;\n\t}\n\tif (!vgacon_scrollback_cur->data)\n\t\treturn;\n\tif (!vgacon_scrollback_cur->save) {\n\t\tvgacon_cursor(c, CM_ERASE);\n\t\tvgacon_save_screen(c);\n\t\tc->vc_origin = (unsigned long)c->vc_screenbuf;\n\t\tvgacon_scrollback_cur->save = 1;\n\t}\n\tvgacon_scrollback_cur->restore = 0;\n\tstart = vgacon_scrollback_cur->cur + lines;\n\tend = start + abs(lines);\n\tif (start < 0)\n\t\tstart = 0;\n\tif (start > vgacon_scrollback_cur->cnt)\n\t\tstart = vgacon_scrollback_cur->cnt;\n\tif (end < 0)\n\t\tend = 0;\n\tif (end > vgacon_scrollback_cur->cnt)\n\t\tend = vgacon_scrollback_cur->cnt;\n\tvgacon_scrollback_cur->cur = start;\n\tcount = end - start;\n\tsoff = vgacon_scrollback_cur->tail -\n\t\t((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);\n\tsoff -= count * c->vc_size_row;\n\tif (soff < 0)\n\t\tsoff += vgacon_scrollback_cur->size;\n\tcount = vgacon_scrollback_cur->cnt - start;\n\tif (count > c->vc_rows)\n\t\tcount = c->vc_rows;\n\tif (count) {\n\t\tint copysize;\n\t\tint diff = c->vc_rows - count;\n\t\tvoid *d = (void *) c->vc_visible_origin;\n\t\tvoid *s = (void *) c->vc_screenbuf;\n\t\tcount *= c->vc_size_row;\n\t\tcopysize = min(count, vgacon_scrollback_cur->size - soff);\n\t\tscr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);\n\t\td += copysize;\n\t\tcount -= copysize;\n\t\tif (count) {\n\t\t\tscr_memcpyw(d, vgacon_scrollback_cur->data, count);\n\t\t\td += count;\n\t\t}\n\t\tif (diff)\n\t\t\tscr_memcpyw(d, s, diff * c->vc_size_row);\n\t} else\n\t\tvgacon_cursor(c, CM_MOVE);\n}", "target": 1}
{"code": "static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n  if(!pop3c->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n  return CURLE_OK;\n}", "target": 1}
{"code": "init_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n \tOM_uint32 tmpmin;\n \tsize_t i;\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n \tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n \t\t\t       GSS_C_NO_BUFFER);\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}", "target": 1}
{"code": "static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\trc = emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trsp_increment(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\tif (url_len < 1)\n\t\treturn false;\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\tif (port_len) {\n\t\tchar *slash;\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\treturn true;\n}", "target": 1}
{"code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\tret = key_update(key_ref, payload, plen);\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)\n{\n\tstruct hwsim_new_radio_params param = { 0 };\n\tconst char *hwname = NULL;\n\tint ret;\n\tparam.reg_strict = info->attrs[HWSIM_ATTR_REG_STRICT_REG];\n\tparam.p2p_device = info->attrs[HWSIM_ATTR_SUPPORT_P2P_DEVICE];\n\tparam.channels = channels;\n\tparam.destroy_on_close =\n\t\tinfo->attrs[HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE];\n\tif (info->attrs[HWSIM_ATTR_CHANNELS])\n\t\tparam.channels = nla_get_u32(info->attrs[HWSIM_ATTR_CHANNELS]);\n\tif (info->attrs[HWSIM_ATTR_NO_VIF])\n\t\tparam.no_vif = true;\n\tif (info->attrs[HWSIM_ATTR_RADIO_NAME]) {\n\t\thwname = kasprintf(GFP_KERNEL, \"%.*s\",\n\t\t\t\t   nla_len(info->attrs[HWSIM_ATTR_RADIO_NAME]),\n\t\t\t\t   (char *)nla_data(info->attrs[HWSIM_ATTR_RADIO_NAME]));\n\t\tif (!hwname)\n\t\t\treturn -ENOMEM;\n\t\tparam.hwname = hwname;\n\t}\n\tif (info->attrs[HWSIM_ATTR_USE_CHANCTX])\n\t\tparam.use_chanctx = true;\n\telse\n\t\tparam.use_chanctx = (param.channels > 1);\n\tif (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])\n\t\tparam.reg_alpha2 =\n\t\t\tnla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);\n \tif (info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]) {\n \t\tu32 idx = nla_get_u32(info->attrs[HWSIM_ATTR_REG_CUSTOM_REG]);\n\t\tif (idx >= ARRAY_SIZE(hwsim_world_regdom_custom))\n \t\t\treturn -EINVAL;\n \t\tparam.regd = hwsim_world_regdom_custom[idx];\n \t}\n\tret = mac80211_hwsim_new_radio(info, &param);\n\tkfree(hwname);\n\treturn ret;\n}", "target": 1}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\tax25_dev_put(ax25_dev);\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "get_password(const char *prompt, char *input, int capacity)\n{\n#ifdef ENABLE_SYSTEMD\n\tint is_systemd_running;\n\tstruct stat a, b;\n\tis_systemd_running = (lstat(\"/sys/fs/cgroup\", &a) == 0)\n\t\t&& (lstat(\"/sys/fs/cgroup/systemd\", &b) == 0)\n\t\t&& (a.st_dev != b.st_dev);\n\tif (is_systemd_running) {\n\t\tchar *cmd, *ret;\n\t\tFILE *ask_pass_fp = NULL;\n\t\tcmd = ret = NULL;\n\t\tif (asprintf(&cmd, \"systemd-ask-password \\\"%s\\\"\", prompt) >= 0) {\n\t\t\task_pass_fp = popen (cmd, \"re\");\n\t\t\tfree (cmd);\n\t\t}\n\t\tif (ask_pass_fp) {\n\t\t\tret = fgets(input, capacity, ask_pass_fp);\n\t\t\tpclose(ask_pass_fp);\n\t\t}\n\t\tif (ret) {\n\t\t\tint len = strlen(input);\n\t\t\tif (input[len - 1] == '\\n')\n\t\t\t\tinput[len - 1] = '\\0';\n\t\t\treturn input;\n\t\t}\n\t}\n#endif\n\tchar *tmp_pass = getpass(prompt);\n\tif (!tmp_pass)\n\t\treturn NULL;\n\tstrncpy(input, tmp_pass, capacity - 1);\n\tinput[capacity - 1] = '\\0';\n\tmemset(tmp_pass, 0, strlen(tmp_pass));\n\treturn input;\n}", "target": 1}
{"code": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct net *net = sock_net(cb->skb->sk);\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}", "target": 1}
{"code": "int insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tif (v8086_mode(regs))\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (!(desc->type & BIT(3)))\n\t\treturn -EINVAL;\n\tswitch ((desc->l << 1) | desc->d) {\n\tcase 0: \n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "static void do_cmd(ESPState *s)\n{\n    uint8_t busid = fifo8_pop(&s->cmdfifo);\n    s->cmdfifo_cdb_offset--;\n    if (s->cmdfifo_cdb_offset) {\n        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);\n        s->cmdfifo_cdb_offset = 0;\n    }\n    do_busid_cmd(s, busid);\n}", "target": 1}
{"code": "ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tcp_splice_state tss = {\n\t\t.pipe = pipe,\n\t\t.len = len,\n\t\t.flags = flags,\n\t};\n\tlong timeo;\n\tssize_t spliced;\n\tint ret;\n\tsock_rps_record_flow(sk);\n\tif (unlikely(*ppos))\n\t\treturn -ESPIPE;\n\tret = spliced = 0;\n\tlock_sock(sk);\n\ttimeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);\n\twhile (tss.len) {\n\t\tret = __tcp_splice_read(sk, &tss);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (spliced)\n\t\t\t\tbreak;\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_err) {\n\t\t\t\tret = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE))\n\t\t\t\t\tret = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n \t\t\t\tret = -EAGAIN;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t\tsk_wait_data(sk, &timeo, NULL);\n \t\t\tif (signal_pending(current)) {\n \t\t\t\tret = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttss.len -= ret;\n\t\tspliced += ret;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\tlock_sock(sk);\n\t\tif (sk->sk_err || sk->sk_state == TCP_CLOSE ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t    signal_pending(current))\n\t\t\tbreak;\n\t}\n\trelease_sock(sk);\n\tif (spliced)\n\t\treturn spliced;\n\treturn ret;\n}", "target": 1}
{"code": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n\t\t\trdesc[106] == 0x03) {\n\t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n\t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "get_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)\n{\n    static gpols_ret                ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gpols_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST, NULL, NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_policies\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_policies((void *)handle,\n                                       arg->exp, &ret.pols,\n                                       &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_policies\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "addMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}", "target": 1}
{"code": "static request_rec *my_ap_create_request(conn_rec *c)\n{\n    apr_pool_t *p;\n    request_rec *r;\n    apr_pool_create(&p, c->pool);\n    apr_pool_tag(p, \"request\");\n    r = apr_pcalloc(p, sizeof(request_rec));\n    AP_READ_REQUEST_ENTRY((intptr_t)r, (uintptr_t)c);\n    r->pool            = p;\n    r->connection      = c;\n    r->server          = c->base_server;\n    r->user            = NULL;\n    r->ap_auth_type    = NULL;\n    r->allowed_methods = ap_make_method_list(p, 2);\n    r->headers_in      = apr_table_make(r->pool, 5);\n    r->trailers_in     = apr_table_make(r->pool, 5);\n    r->subprocess_env  = apr_table_make(r->pool, 25);\n    r->headers_out     = apr_table_make(r->pool, 12);\n    r->err_headers_out = apr_table_make(r->pool, 5);\n    r->trailers_out    = apr_table_make(r->pool, 5);\n    r->notes           = apr_table_make(r->pool, 5);\n    r->request_config  = ap_create_request_config(r->pool);\n    r->proto_output_filters = c->output_filters;\n    r->output_filters  = r->proto_output_filters;\n    r->proto_input_filters = c->input_filters;\n    r->input_filters   = r->proto_input_filters;\n    ap_run_create_request(r);\n    r->per_dir_config  = r->server->lookup_defaults;\n    r->sent_bodyct     = 0;                      \n    r->read_length     = 0;\n    r->read_body       = REQUEST_NO_BODY;\n    r->status          = HTTP_OK;  \n    r->header_only     = 0;\n    r->the_request     = NULL;\n    r->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n    r->useragent_addr = c->client_addr;\n    r->useragent_ip = c->client_ip;\n    return r;\n}", "target": 1}
{"code": "static int adpt_i2o_online_hba(adpt_hba* pHba)\n{\n\tif (adpt_i2o_systab_send(pHba) < 0)\n\t\treturn -1;\n\tif (adpt_i2o_enable_hba(pHba) < 0)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n\tint retval;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}", "target": 1}
{"code": "int dccp_send_reset(struct sock *sk, enum dccp_reset_codes code)\n{\n\tstruct sk_buff *skb;\n\tint err = inet_sk_rebuild_header(sk);\n\tif (err != 0)\n\t\treturn err;\n\tskb = sock_wmalloc(sk, sk->sk_prot->max_header, 1, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOBUFS;\n\tskb_reserve(skb, sk->sk_prot->max_header);\n\tDCCP_SKB_CB(skb)->dccpd_type\t   = DCCP_PKT_RESET;\n\tDCCP_SKB_CB(skb)->dccpd_reset_code = code;\n\treturn dccp_transmit_skb(sk, skb);\n}", "target": 1}
{"code": "static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,\n                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn FALSE;\n\treturn ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),\n\t                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));\n}", "target": 1}
{"code": "XListFonts(\nregister Display *dpy,\n_Xconst char *pattern,  \nint maxNames,\nint *actualCount)\t\n{\n    register long nbytes;\n    register unsigned i;\n    register int length;\n    char **flist = NULL;\n    char *ch = NULL;\n    char *chend;\n    int count = 0;\n    xListFontsReply rep;\n    register xListFontsReq *req;\n    unsigned long rlen = 0;\n    LockDisplay(dpy);\n    GetReq(ListFonts, req);\n    req->maxNames = maxNames;\n    nbytes = req->nbytes = pattern ? strlen (pattern) : 0;\n    req->length += (nbytes + 3) >> 2;\n    _XSend (dpy, pattern, nbytes);\n    if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) {\n\t*actualCount = 0;\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (char **) NULL;\n    }\n     if (rep.nFonts) {\n \tflist = Xmalloc (rep.nFonts * sizeof(char *));\n\tif (rep.length < (INT_MAX >> 2)) {\n \t    rlen = rep.length << 2;\n \t    ch = Xmalloc(rlen + 1);\n\t}\n\tif ((! flist) || (! ch)) {\n\t    Xfree(flist);\n\t    Xfree(ch);\n\t    _XEatDataWords(dpy, rep.length);\n\t    *actualCount = 0;\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (char **) NULL;\n\t}\n\t_XReadPad (dpy, ch, rlen);\n\tchend = ch + (rlen + 1);\n\tlength = *(unsigned char *)ch;\n\t*ch = 1; \n\tfor (i = 0; i < rep.nFonts; i++) {\n \t    if (ch + length < chend) {\n \t\tflist[i] = ch + 1;  \n \t\tch += length + 1;  \n\t\tlength = *(unsigned char *)ch;\n\t\t*ch = '\\0';  \n\t\tcount++;\n\t    } else\n\t\tflist[i] = NULL;\n \t}\n     }\n     *actualCount = count;\n\t\t\tfor (names = list+1; *names; names++)\n\t\t\t\tXfree (*names);\n\t\t}", "target": 1}
{"code": "xmlXIncludeDoProcess(xmlXIncludeCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr tree,\n                     int skipRoot) {\n    xmlNodePtr cur;\n    int ret = 0;\n    int i, start;\n    if ((doc == NULL) || (tree == NULL) || (tree->type == XML_NAMESPACE_DECL))\n\treturn(-1);\n    if ((skipRoot) && (tree->children == NULL))\n        return(-1);\n    if (ctxt == NULL)\n\treturn(-1);\n    if (doc->URL != NULL) {\n\tret = xmlXIncludeURLPush(ctxt, doc->URL);\n\tif (ret < 0)\n\t    return(-1);\n    }\n    start = ctxt->incNr;\n    if (skipRoot)\n        cur = tree->children;\n    else\n        cur = tree;\n    do {\n        if (xmlXIncludeTestNode(ctxt, cur) == 1) {\n#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n            if (ctxt->incTotal >= 20)\n                return(-1);\n#endif\n            ctxt->incTotal++;\n            xmlXIncludePreProcessNode(ctxt, cur);\n        } else if ((cur->children != NULL) &&\n                   (cur->children->type != XML_ENTITY_DECL) &&\n                   (cur->children->type != XML_XINCLUDE_START) &&\n                   (cur->children->type != XML_XINCLUDE_END)) {\n            cur = cur->children;\n            continue;\n        }\n        do {\n            if (cur == tree)\n                break;\n            if (cur->next != NULL) {\n                cur = cur->next;\n                break;\n            }\n            cur = cur->parent;\n        } while (cur != NULL);\n    } while ((cur != NULL) && (cur != tree));\n    for (i = start;i < ctxt->incNr; i++) {\n        xmlXIncludeLoadNode(ctxt, i);\n\tret++;\n    }\n    for (i = ctxt->incBase;i < ctxt->incNr; i++) {\n\tif ((ctxt->incTab[i]->inc != NULL) ||\n\t    (ctxt->incTab[i]->emptyFb != 0))\t\n\t    xmlXIncludeIncludeNode(ctxt, i);\n    }\n    if (doc->URL != NULL)\n\txmlXIncludeURLPop(ctxt);\n    return(ret);\n}", "target": 1}
{"code": "static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n \tlsa->l2tp_family = AF_INET6;\n \tlsa->l2tp_flowinfo = 0;\n \tlsa->l2tp_scope_id = 0;\n \tif (peer) {\n \t\tif (!lsk->peer_conn_id)\n \t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = np->daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&np->rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = np->rcv_saddr;\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}", "target": 1}
{"code": "TEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButOk) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing();\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtUnknownIssuer);\n}", "target": 1}
{"code": "int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (nsiz > MAX_ARRAY_LIST) {\n        Jsi_LogError(\"array size too large\");\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}", "target": 1}
{"code": "GF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\ts->size += 8;\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\txfrm_policy_walk_done(walk);\n\treturn 0;\n}", "target": 1}
{"code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n \tstruct socket *sock;\n \tint err = 0;\n \tif (!asoc)\n \t\treturn -EINVAL;\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\t*sockp = sock;\n\treturn err;\n}", "target": 1}
{"code": "GURL SanitizeFrontendURL(const GURL& url,\n                         const std::string& scheme,\n                         const std::string& host,\n                         const std::string& path,\n                         bool allow_query_and_fragment) {\n  std::vector<std::string> query_parts;\n  std::string fragment;\n  if (allow_query_and_fragment) {\n    for (net::QueryIterator it(url); !it.IsAtEnd(); it.Advance()) {\n      std::string value = SanitizeFrontendQueryParam(it.GetKey(),\n          it.GetValue());\n      if (!value.empty()) {\n        query_parts.push_back(\n             base::StringPrintf(\"%s=%s\", it.GetKey().c_str(), value.c_str()));\n       }\n     }\n    if (url.has_ref())\n       fragment = '#' + url.ref();\n   }\n   std::string query =\n      query_parts.empty() ? \"\" : \"?\" + base::JoinString(query_parts, \"&\");\n  std::string constructed =\n      base::StringPrintf(\"%s:\n                         path.c_str(), query.c_str(), fragment.c_str());\n  GURL result = GURL(constructed);\n  if (!result.is_valid())\n    return GURL();\n  return result;\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n    stat(options->in_file, &filestats);\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n    free(options);\n    return 0;\n}", "target": 1}
{"code": "mp_obj_t mp_vfs_umount(mp_obj_t mnt_in) {\n    mp_vfs_mount_t *vfs = NULL;\n    size_t mnt_len;\n    const char *mnt_str = NULL;\n    if (mp_obj_is_str(mnt_in)) {\n        mnt_str = mp_obj_str_get_data(mnt_in, &mnt_len);\n    }\n    for (mp_vfs_mount_t **vfsp = &MP_STATE_VM(vfs_mount_table); *vfsp != NULL; vfsp = &(*vfsp)->next) {\n        if ((mnt_str != NULL && !memcmp(mnt_str, (*vfsp)->str, mnt_len + 1)) || (*vfsp)->obj == mnt_in) {\n            vfs = *vfsp;\n            *vfsp = (*vfsp)->next;\n            break;\n        }\n    }\n    if (vfs == NULL) {\n        mp_raise_OSError(MP_EINVAL);\n    }\n    if (MP_STATE_VM(vfs_cur) == vfs) {\n        MP_STATE_VM(vfs_cur) = MP_VFS_ROOT;\n    }\n    mp_vfs_proxy_call(vfs, MP_QSTR_umount, 0, NULL);\n    return mp_const_none;\n}", "target": 1}
{"code": "static void TIFFGetProfiles(TIFF *tiff,Image *image,ExceptionInfo *exception)\n{\n  uint32\n    length;\n  unsigned char\n    *profile;\n  length=0;\n#if defined(TIFFTAG_ICCPROFILE)\n  if ((TIFFGetField(tiff,TIFFTAG_ICCPROFILE,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"icc\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_PHOTOSHOP)\n  if ((TIFFGetField(tiff,TIFFTAG_PHOTOSHOP,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"8bim\",profile,(ssize_t) length,exception);\n#endif\n#if defined(TIFFTAG_RICHTIFFIPTC)\n  if ((TIFFGetField(tiff,TIFFTAG_RICHTIFFIPTC,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      if (TIFFIsByteSwapped(tiff) != 0)\n        TIFFSwabArrayOfLong((uint32 *) profile,(size_t) length);\n      (void) ReadProfile(image,\"iptc\",profile,4L*length,exception);\n    }\n#endif\n#if defined(TIFFTAG_XMLPACKET)\n  if ((TIFFGetField(tiff,TIFFTAG_XMLPACKET,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    {\n      (void) ReadProfile(image,\"xmp\",profile,(ssize_t) length,exception);\n      if (strstr((char *) profile,\"dc:format=\\\"image/dng\\\"\") != (char *) NULL)\n        (void) CopyMagickString(image->magick,\"DNG\",MagickPathExtent);\n    }\n#endif\n  if ((TIFFGetField(tiff,34118,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"tiff:34118\",profile,(ssize_t) length,\n      exception);\n  if ((TIFFGetField(tiff,37724,&length,&profile) == 1) &&\n      (profile != (unsigned char *) NULL))\n    (void) ReadProfile(image,\"tiff:37724\",profile,(ssize_t) length,exception);\n}", "target": 1}
{"code": "static int rsvp_dump(struct tcf_proto *tp, unsigned long fh,\n\t\t     struct sk_buff *skb, struct tcmsg *t)\n{\n\tstruct rsvp_filter *f = (struct rsvp_filter*)fh;\n\tstruct rsvp_session *s;\n\tunsigned char\t *b = skb->tail;\n\tstruct rtattr *rta;\n\tstruct tc_rsvp_pinfo pinfo;\n\tif (f == NULL)\n\t\treturn skb->len;\n\ts = f->sess;\n\tt->tcm_handle = f->handle;\n\trta = (struct rtattr*)b;\n\tRTA_PUT(skb, TCA_OPTIONS, 0, NULL);\n\tRTA_PUT(skb, TCA_RSVP_DST, sizeof(s->dst), &s->dst);\n\tpinfo.dpi = s->dpi;\n\tpinfo.spi = f->spi;\n\tpinfo.protocol = s->protocol;\n\tpinfo.tunnelid = s->tunnelid;\n\tpinfo.tunnelhdr = f->tunnelhdr;\n\tRTA_PUT(skb, TCA_RSVP_PINFO, sizeof(pinfo), &pinfo);\n\tif (f->res.classid)\n\t\tRTA_PUT(skb, TCA_RSVP_CLASSID, 4, &f->res.classid);\n\tif (((f->handle>>8)&0xFF) != 16)\n\t\tRTA_PUT(skb, TCA_RSVP_SRC, sizeof(f->src), f->src);\n\tif (tcf_exts_dump(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\trta->rta_len = skb->tail - b;\n\tif (tcf_exts_dump_stats(skb, &f->exts, &rsvp_ext_map) < 0)\n\t\tgoto rtattr_failure;\n\treturn skb->len;\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "log2vis_utf8 (PyObject * string, int unicode_length,\n\t      FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tFriBidiChar *logical = NULL; \n\tFriBidiChar *visual = NULL;\t \n\tchar *visual_utf8 = NULL;    \n\tFriBidiStrIndex new_len = 0; \n\tPyObject *result = NULL;\t \n\tlogical = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (logical == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\tvisual = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (visual == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\tfribidi_set_reorder_nsm(reordernsm);\n\tfribidi_utf8_to_unicode (PyString_AS_STRING (string),\n\t\t\t\t PyString_GET_SIZE (string), logical);\n\tif (!fribidi_log2vis (logical, unicode_length, &base_direction, visual,\n\t\t\t      NULL, NULL, NULL))\n\t{\n\t\tPyErr_SetString (PyExc_RuntimeError,\n\t\t\t\t \"fribidi failed to order string\");\n\t\tgoto cleanup;\n\t}\n\tif (clean)\n\t\tfribidi_remove_bidi_marks (visual, unicode_length, NULL, NULL, NULL);\n\tvisual_utf8 = PyMem_New(char, (unicode_length * 4)+1);\n\tif (visual_utf8 == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t\"failed to allocate UTF-8 buffer\");\n\t\tgoto cleanup;\n\t}\n\tnew_len = fribidi_unicode_to_utf8 (visual, unicode_length, visual_utf8);\n\tresult = PyString_FromStringAndSize (visual_utf8, new_len);\n\tif (result == NULL)\n\t\tgoto cleanup;\n      cleanup:\n\tPyMem_Del (logical);\n\tPyMem_Del (visual);\n\tPyMem_Del (visual_utf8);\n\treturn result;\n}", "target": 1}
{"code": "static void ipmr_cache_resolve(struct mfc_cache *uc, struct mfc_cache *c)\n{\n\tstruct sk_buff *skb;\n\twhile((skb=__skb_dequeue(&uc->mfc_un.unres.unresolved))) {\n\t\tif (skb->nh.iph->version == 0) {\n\t\t\tint err;\n\t\t\tstruct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct iphdr));\n\t\t\tif (ipmr_fill_mroute(skb, c, NLMSG_DATA(nlh)) > 0) {\n\t\t\t\tnlh->nlmsg_len = skb->tail - (u8*)nlh;\n\t\t\t} else {\n\t\t\t\tnlh->nlmsg_type = NLMSG_ERROR;\n\t\t\t\tnlh->nlmsg_len = NLMSG_LENGTH(sizeof(struct nlmsgerr));\n\t\t\t\tskb_trim(skb, nlh->nlmsg_len);\n\t\t\t\t((struct nlmsgerr*)NLMSG_DATA(nlh))->error = -EMSGSIZE;\n\t\t\t}\n\t\t\terr = netlink_unicast(rtnl, skb, NETLINK_CB(skb).dst_pid, MSG_DONTWAIT);\n\t\t} else\n\t\t\tip_mr_forward(skb, c, 0);\n\t}\n}", "target": 1}
{"code": "bool Mfcc::Initialize(int input_length, double input_sample_rate) {\n  bool initialized = mel_filterbank_.Initialize(\n      input_length, input_sample_rate, filterbank_channel_count_,\n      lower_frequency_limit_, upper_frequency_limit_);\n  initialized &=\n      dct_.Initialize(filterbank_channel_count_, dct_coefficient_count_);\n  initialized_ = initialized;\n  return initialized;\n}", "target": 1}
{"code": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n        g_return_val_if_fail (client != NULL, TRUE);\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n        return TRUE;\n}", "target": 1}
{"code": "void queue_push(register Queue *qp, size_t extra_length, char const *info)\n{\n    register char *cp;\n    size_t memory_length;\n    size_t available_length;\n    size_t begin_length;\n    size_t n_begin;\n    size_t q_length;\n    if (!extra_length)\n        return;\n    memory_length    = qp->d_memory_end - qp->d_memory;\n    q_length = \n        qp->d_read <= qp->d_write ?\n            (size_t)(qp->d_write - qp->d_read)\n        :\n            memory_length - (qp->d_read - qp->d_write);\n    available_length = memory_length - q_length - 1;\n    if (message_show(MSG_INFO))\n        message(\"push_front %u bytes in `%s'\", (unsigned)extra_length, info);\n    if (extra_length > available_length)\n    {\n        memory_length += extra_length - available_length + BLOCK_QUEUE;\n        cp = new_memory(memory_length, sizeof(char));\n        if (message_show(MSG_INFO))\n            message(\"Reallocating queue at %p to %p\", qp->d_memory, cp);\n        if (qp->d_read > qp->d_write)               \n        {\n            size_t tail_len = qp->d_memory_end - qp->d_read;\n            memcpy(cp, qp->d_read, tail_len);       \n            memcpy(cp + tail_len, qp->d_memory, \n                                    (size_t)(qp->d_write - qp->d_memory));\n            qp->d_write = cp + q_length;\n            qp->d_read = cp;\n        }\n        else                                        \n        {\n            memcpy(cp, qp->d_memory, memory_length);\n            qp->d_read = cp + (qp->d_read - qp->d_memory);\n            qp->d_write = cp + (qp->d_write - qp->d_memory);\n        }\n        free(qp->d_memory);                         \n        qp->d_memory_end = cp + memory_length;      \n        qp->d_memory = cp;                          \n    }\n    begin_length = qp->d_read - qp->d_memory;   \n    n_begin = extra_length <= begin_length ?    \n                    extra_length                \n                :\n                    begin_length;\n    memcpy                                      \n    (                                           \n        qp->d_read -= n_begin,\n        info + extra_length - n_begin,\n        n_begin\n    );\n    if (extra_length > begin_length)            \n    {\n        extra_length -= begin_length;           \n        memcpy                                  \n        (                                       \n            qp->d_read = qp->d_memory_end - extra_length,\n            info,\n            extra_length\n        );\n    }\n}", "target": 1}
{"code": "static apr_status_t parse_chunk_size(http_ctx_t *ctx, const char *buffer,\n        apr_size_t len, int linelimit)\n{\n    apr_size_t i = 0;\n    while (i < len) {\n        char c = buffer[i];\n        ap_xlate_proto_from_ascii(&c, 1);\n        if (ctx->state == BODY_CHUNK_END) {\n            if (c == LF) {\n                ctx->state = BODY_CHUNK;\n            }\n            i++;\n            continue;\n        }\n        if (ctx->state == BODY_CHUNK) {\n            if (!apr_isxdigit(c)) {\n                return APR_EGENERAL;\n            }\n            else {\n                ctx->state = BODY_CHUNK_PART;\n            }\n            ctx->remaining = 0;\n            ctx->chunkbits = sizeof(long) * 8;\n            ctx->chunk_used = 0;\n        }\n        if (c == ';' || c == CR) {\n            ctx->state = BODY_CHUNK_EXT;\n        }\n        else if (c == LF) {\n            if (ctx->remaining) {\n                ctx->state = BODY_CHUNK_DATA;\n            }\n            else {\n                ctx->state = BODY_CHUNK_TRAILER;\n            }\n        }\n        else if (ctx->state != BODY_CHUNK_EXT) {\n            int xvalue = 0;\n            if (!ctx->remaining && c == '0') {\n                i++;\n                continue;\n            }\n            if (c >= '0' && c <= '9') {\n                xvalue = c - '0';\n            }\n            else if (c >= 'A' && c <= 'F') {\n                xvalue = c - 'A' + 0xa;\n            }\n            else if (c >= 'a' && c <= 'f') {\n                xvalue = c - 'a' + 0xa;\n            }\n            else {\n                return APR_EGENERAL;\n            }\n            ctx->remaining = (ctx->remaining << 4) | xvalue;\n            ctx->chunkbits -= 4;\n            if (ctx->chunkbits <= 0 || ctx->remaining < 0) {\n                return APR_ENOSPC;\n            }\n        }\n        i++;\n    }\n    ctx->chunk_used += len;\n    if (ctx->chunk_used < 0 || ctx->chunk_used > linelimit) {\n        return APR_ENOSPC;\n    }\n    return APR_SUCCESS;\n}", "target": 1}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": "sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx,\n    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,\n    int *cmnd_status, int pwflag)\n{\n    struct defaults_list *defs = NULL;\n    struct sudoers_parse_tree *parse_tree = NULL;\n    struct cmndspec *cs = NULL;\n    struct sudo_nss *nss;\n    struct cmnd_info info;\n    unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST;\n    int m, match = UNSPEC;\n    debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);\n    if (pwflag) {\n\tdebug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback,\n\t    cb_data, pwflag));\n    }\n    if (!set_perms(ctx, PERM_RUNAS))\n\tdebug_return_uint(validated);\n    TAILQ_FOREACH(nss, snl, entries) {\n\tif (nss->query(ctx, nss, ctx->user.pw) == -1) {\n\t    SET(validated, VALIDATE_ERROR);\n\t    break;\n\t}\n\tm = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,\n\t    cb_data, &cs, &defs);\n\tif (m != UNSPEC) {\n\t    match = m;\n\t    parse_tree = nss->parse_tree;\n\t}\n\tif (!sudo_nss_can_continue(nss, m))\n\t    break;\n    }\n    if (match != UNSPEC) {\n\tif (info.cmnd_path != NULL) {\n\t    free(ctx->user.cmnd);\n\t    ctx->user.cmnd = info.cmnd_path;\n\t    if (ctx->user.cmnd_stat != NULL)\n\t\t*ctx->user.cmnd_stat = info.cmnd_stat;\n\t    *cmnd_status = info.status;\n\t}\n\tif (defs != NULL)\n\t    (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false);\n\tif (!apply_cmndspec(ctx, cs))\n\t    SET(validated, VALIDATE_ERROR);\n\telse if (match == ALLOW)\n\t    SET(validated, VALIDATE_SUCCESS);\n\telse\n\t    SET(validated, VALIDATE_FAILURE);\n    }\n    if (!restore_perms())\n\tSET(validated, VALIDATE_ERROR);\n    debug_return_uint(validated);\n}", "target": 1}
{"code": "int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint id;\n\tint next_id = ids->next_id;\n\tif (size > IPCMNI)\n\t\tsize = IPCMNI;\n\tif (ids->in_use >= size)\n\t\treturn -ENOSPC;\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_init(&new->lock);\n\tnew->deleted = false;\n \trcu_read_lock();\n \tspin_lock(&new->lock);\n \tid = idr_alloc(&ids->ipcs_idr, new,\n \t\t       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,\n \t\t       GFP_NOWAIT);\n\tidr_preload_end();\n\tif (id < 0) {\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn id;\n\t}\n \tids->in_use++;\n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n \tif (next_id < 0) {\n \t\tnew->seq = ids->seq++;\n \t\tif (ids->seq > IPCID_SEQ_MAX)\n\t\t\tids->seq = 0;\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tids->next_id = -1;\n\t}\n\tnew->id = ipc_buildid(id, new->seq);\n\treturn id;\n}", "target": 1}
{"code": "  QUInt8() {}", "target": 1}
{"code": "static int mwifiex_pcie_init_evt_ring(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct mwifiex_evt_buf_desc *desc;\n\tstruct sk_buff *skb;\n\tdma_addr_t buf_pa;\n\tint i;\n\tfor (i = 0; i < MWIFIEX_MAX_EVT_BD; i++) {\n\t\tskb = dev_alloc_skb(MAX_EVENT_SIZE);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"Unable to allocate skb for EVENT buf.\\n\");\n\t\t\tkfree(card->evtbd_ring_vbase);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put(skb, MAX_EVENT_SIZE);\n\t\tif (mwifiex_map_pci_memory(adapter, skb, MAX_EVENT_SIZE,\n\t\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\t\treturn -1;\n\t\tbuf_pa = MWIFIEX_SKB_DMA_ADDR(skb);\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: EVT ring: skb=%p len=%d data=%p buf_pa=%#x:%x\\n\",\n\t\t\t    skb, skb->len, skb->data, (u32)buf_pa,\n\t\t\t    (u32)((u64)buf_pa >> 32));\n\t\tcard->evt_buf_list[i] = skb;\n\t\tcard->evtbd_ring[i] = (void *)(card->evtbd_ring_vbase +\n\t\t\t\t      (sizeof(*desc) * i));\n\t\tdesc = card->evtbd_ring[i];\n\t\tdesc->paddr = buf_pa;\n\t\tdesc->len = (u16)skb->len;\n\t\tdesc->flags = 0;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n}", "target": 1}
{"code": "void InferenceContext::PreInputInit(\n    const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,\n    const std::vector<ShapeHandle>& input_tensors_as_shapes) {\n  const auto ret = full_type::SpecializeType(attrs_, op_def);\n  DCHECK(ret.status().ok()) << \"while instantiating types: \" << ret.status();\n  ret_types_ = ret.ValueOrDie();\n  input_tensors_ = input_tensors;\n  input_tensors_as_shapes_ = input_tensors_as_shapes;\n  construction_status_ =\n      NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);\n  if (!construction_status_.ok()) return;\n  int num_outputs = 0;\n  for (const auto& e : output_name_map_) {\n    num_outputs = std::max(num_outputs, e.second.second);\n  }\n  outputs_.assign(num_outputs, nullptr);\n  output_handle_shapes_and_types_.resize(num_outputs);\n}", "target": 1}
{"code": "sug_filltree(spellinfo_T *spin, slang_T *slang)\n{\n    char_u\t*byts;\n    idx_T\t*idxs;\n    int\t\tdepth;\n    idx_T\tarridx[MAXWLEN];\n    int\t\tcuri[MAXWLEN];\n    char_u\ttword[MAXWLEN];\n    char_u\ttsalword[MAXWLEN];\n    int\t\tc;\n    idx_T\tn;\n    unsigned\twords_done = 0;\n    int\t\twordcount[MAXWLEN];\n    spin->si_foldroot = wordtree_alloc(spin);\n    if (spin->si_foldroot == NULL)\n\treturn FAIL;\n    spin->si_sugtree = TRUE;\n    byts = slang->sl_fbyts;\n    idxs = slang->sl_fidxs;\n    arridx[0] = 0;\n    curi[0] = 1;\n    wordcount[0] = 0;\n    depth = 0;\n    while (depth >= 0 && !got_int)\n    {\n\tif (curi[depth] > byts[arridx[depth]])\n\t{\n\t    idxs[arridx[depth]] = wordcount[depth];\n\t    if (depth > 0)\n\t\twordcount[depth - 1] += wordcount[depth];\n\t    --depth;\n\t    line_breakcheck();\n\t}\n\telse\n\t{\n\t    n = arridx[depth] + curi[depth];\n\t    ++curi[depth];\n\t    c = byts[n];\n\t    if (c == 0)\n\t    {\n\t\ttword[depth] = NUL;\n\t\tspell_soundfold(slang, tword, TRUE, tsalword);\n\t\tif (tree_add_word(spin, tsalword, spin->si_foldroot,\n\t\t\t\twords_done >> 16, words_done & 0xffff,\n\t\t\t\t\t\t\t   0) == FAIL)\n\t\t    return FAIL;\n\t\t++words_done;\n\t\t++wordcount[depth];\n\t\tspin->si_blocks_cnt = 0;\n\t\twhile (n + 1 < slang->sl_fbyts_len && byts[n + 1] == 0)\n\t\t{\n\t\t    ++n;\n\t\t    ++curi[depth];\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\ttword[depth++] = c;\n\t\tarridx[depth] = idxs[n];\n\t\tcuri[depth] = 1;\n\t\twordcount[depth] = 0;\n\t    }\n\t}\n    }\n    smsg(_(\"Total number of words: %d\"), words_done);\n    return OK;\n}", "target": 1}
{"code": "print_prefix(netdissect_options *ndo, const u_char *prefix, u_int max_length)\n{\n    int plenbytes;\n    char buf[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128\")];\n    if (prefix[0] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 &&\n        is_ipv4_mapped_address(&prefix[1])) {\n        struct in_addr addr;\n        u_int plen;\n        plen = prefix[0]-96;\n        if (32 < plen)\n            return -1;\n        max_length -= 1;\n        memset(&addr, 0, sizeof(addr));\n        plenbytes = (plen + 7) / 8;\n        if (max_length < (u_int)plenbytes + IPV4_MAPPED_HEADING_LEN)\n            return -3;\n        memcpy(&addr, &prefix[1 + IPV4_MAPPED_HEADING_LEN], plenbytes);\n        if (plen % 8) {\n\t\t((u_char *)&addr)[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, sizeof(buf), \"%s/%d\", ipaddr_string(ndo, &addr), plen);\n         plenbytes += 1 + IPV4_MAPPED_HEADING_LEN;\n     } else {\n         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));\n     }\n     ND_PRINT((ndo, \"%s\", buf));\n    return plenbytes;\n}", "target": 1}
{"code": "AP4_VisualSampleEntry::ReadFields(AP4_ByteStream& stream)\n{\n    AP4_Result result = AP4_SampleEntry::ReadFields(stream);\n    if (result < 0) return result;\n    stream.ReadUI16(m_Predefined1);\n    stream.ReadUI16(m_Reserved2);\n    stream.Read(m_Predefined2, sizeof(m_Predefined2));\n    stream.ReadUI16(m_Width);\n    stream.ReadUI16(m_Height);\n    stream.ReadUI32(m_HorizResolution);\n    stream.ReadUI32(m_VertResolution);\n    stream.ReadUI32(m_Reserved3);\n    stream.ReadUI16(m_FrameCount);\n    char compressor_name[33];\n    compressor_name[32] = 0;\n    stream.Read(compressor_name, 32);\n    int name_length = compressor_name[0];\n    if (name_length < 32) {\n        compressor_name[name_length+1] = 0; \n        m_CompressorName = &compressor_name[1];\n    }\n    stream.ReadUI16(m_Depth);\n    stream.ReadUI16(m_Predefined3);\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "gopherTimeout(const CommTimeoutCbParams &io)\n{\n    GopherStateData *gopherState = static_cast<GopherStateData *>(io.data);\n    debugs(10, 4, io.conn << \": '\" << gopherState->entry->url() << \"'\" );\n    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, gopherState->fwd->request, gopherState->fwd->al));\n    if (Comm::IsConnOpen(io.conn))\n        io.conn->close();\n}", "target": 1}
{"code": "void ComparisonQuantized(const TfLiteTensor* input1, const TfLiteTensor* input2,\n                         TfLiteTensor* output, bool requires_broadcast) {\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int left_shift = 8;\n    int32 input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(input1->params.scale,\n                                        &input1_multiplier, &input1_shift);\n    int32 input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(input2->params.scale,\n                                        &input2_multiplier, &input2_shift);\n    ComparisonParams op_params;\n    op_params.left_shift = left_shift;\n    op_params.input1_offset = input1_offset;\n    op_params.input1_multiplier = input1_multiplier;\n    op_params.input1_shift = input1_shift;\n    op_params.input2_offset = input2_offset;\n    op_params.input2_multiplier = input2_multiplier;\n    op_params.input2_shift = input2_shift;\n    if (requires_broadcast) {\n      reference_ops::BroadcastComparison4DSlowWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    } else {\n      reference_ops::ComparisonWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    }\n  }\n}", "target": 1}
{"code": "isoclns_print(netdissect_options *ndo,\n              const uint8_t *p, u_int length, u_int caplen)\n{\n\tif (caplen <= 1) { \n\t\tND_PRINT((ndo, \"|OSI\"));\n\t\treturn;\n\t}\n\tif (ndo->ndo_eflag)\n\t\tND_PRINT((ndo, \"OSI NLPID %s (0x%02x): \", tok2str(nlpid_values, \"Unknown\", *p), *p));\n\tswitch (*p) {\n\tcase NLPID_CLNP:\n\t\tif (!clnp_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\tcase NLPID_ESIS:\n\t\tesis_print(ndo, p, length);\n\t\treturn;\n\tcase NLPID_ISIS:\n\t\tif (!isis_print(ndo, p, length))\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\tcase NLPID_NULLNS:\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tbreak;\n\tcase NLPID_Q933:\n\t\tq933_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP:\n\t\tip_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tcase NLPID_PPP:\n\t\tppp_print(ndo, p + 1, length - 1);\n\t\tbreak;\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"OSI NLPID 0x%02x unknown\", *p));\n\t\tND_PRINT((ndo, \"%slength: %u\", ndo->ndo_eflag ? \"\" : \", \", length));\n\t\tif (caplen > 1)\n\t\t\tprint_unknown_data(ndo, p, \"\\n\\t\", caplen);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n \tStream_Read_UINT32(s, scopeCount); \n \tscopeList->count = scopeCount;\n \tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "int processCommand(redisClient *c) {\n    struct redisCommand *cmd;\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= REDIS_CLOSE_AFTER_REPLY;\n        return REDIS_ERR;\n    }\n    cmd = lookupCommand(c->argv[0]->ptr);\n    if (!cmd) {\n        addReplyErrorFormat(c,\"unknown command '%s'\",\n            (char*)c->argv[0]->ptr);\n        return REDIS_OK;\n    } else if ((cmd->arity > 0 && cmd->arity != c->argc) ||\n               (c->argc < -cmd->arity)) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            cmd->name);\n        return REDIS_OK;\n    }\n    if (server.requirepass && !c->authenticated && cmd->proc != authCommand) {\n        addReplyError(c,\"operation not permitted\");\n        return REDIS_OK;\n    }\n    if (server.maxmemory) freeMemoryIfNeeded();\n    if (server.maxmemory && (cmd->flags & REDIS_CMD_DENYOOM) &&\n        zmalloc_used_memory() > server.maxmemory)\n    {\n        addReplyError(c,\"command not allowed when used memory > 'maxmemory'\");\n        return REDIS_OK;\n    }\n    if ((dictSize(c->pubsub_channels) > 0 || listLength(c->pubsub_patterns) > 0)\n        &&\n        cmd->proc != subscribeCommand && cmd->proc != unsubscribeCommand &&\n        cmd->proc != psubscribeCommand && cmd->proc != punsubscribeCommand) {\n        addReplyError(c,\"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context\");\n        return REDIS_OK;\n    }\n    if (server.masterhost && server.replstate != REDIS_REPL_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        cmd->proc != infoCommand && cmd->proc != slaveofCommand)\n    {\n        addReplyError(c,\n            \"link with MASTER is down and slave-serve-stale-data is set to no\");\n        return REDIS_OK;\n    }\n    if (server.loading && cmd->proc != infoCommand) {\n        addReply(c, shared.loadingerr);\n        return REDIS_OK;\n    }\n    if (c->flags & REDIS_MULTI &&\n        cmd->proc != execCommand && cmd->proc != discardCommand &&\n        cmd->proc != multiCommand && cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c,cmd);\n        addReply(c,shared.queued);\n    } else {\n        if (server.vm_enabled && server.vm_max_threads > 0 &&\n            blockClientOnSwappedKeys(c,cmd)) return REDIS_ERR;\n        call(c,cmd);\n    }\n    return REDIS_OK;\n}", "target": 1}
{"code": "static int m88rs2000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[] = { 0x51 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(m88rs2000_attach, &s421_m88rs2000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached RS2000/TS2020!\");\n\t\treturn 0;\n\t}\n\tinfo(\"Failed to attach RS2000/TS2020!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "userlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tif ((matched = user_matches(parse_tree, pw, m)) != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "bool RequestParser::OnHeadersEnd() {\n  bool matched = view_matcher_(request_->method(), request_->url().path(),\n                               &stream_);\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             request_->url().path().c_str());\n  }\n  return matched;\n}", "target": 1}
{"code": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stb_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "int wcall_i_answer(struct wcall *wcall,\n\t\t   int call_type, int audio_cbr)\n{\n\tint err = 0;\n\tbool cbr = audio_cbr != 0;\n\tif (!wcall) {\n\t\twarning(\"wcall; answer: no wcall\\n\");\n\t\treturn EINVAL;\n\t}\n\tcall_type = (call_type == WCALL_CALL_TYPE_FORCED_AUDIO) ?\n\t\t    WCALL_CALL_TYPE_NORMAL : call_type;\n\tinfo(APITAG \"wcall(%p): answer calltype=%s\\n\",\n\t     wcall, wcall_call_type_name(call_type));\n\tif (wcall->disable_audio)\n\t\twcall->disable_audio = false;\n\tif (!wcall->icall) {\n\t\twarning(\"wcall(%p): answer: no call object found\\n\", wcall);\n\t\treturn ENOTSUP;\n\t}\n\tset_state(wcall, WCALL_STATE_ANSWERED);\n\tif (call_type == WCALL_CALL_TYPE_VIDEO) {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STARTED);\n\t}\n\telse {\n\t\tICALL_CALL(wcall->icall,\n\t\t\t   set_video_send_state,\n\t\t\t   ICALL_VIDEO_STATE_STOPPED);\n\t}\n\terr = ICALL_CALLE(wcall->icall, answer,\n\t\t\t  call_type, cbr);\n\treturn err;\n}", "target": 1}
{"code": " static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n {\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n \tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n \tif (!addr || addr->sa_family != AF_BLUETOOTH)\n \t\treturn -EINVAL;\n \tlock_sock(sk);\n \tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n \twrite_lock(&rfcomm_sk_list.lock);\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n \t\terr = -EADDRINUSE;\n \t} else {\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n \t\tsk->sk_state = BT_BOUND;\n \t}\n\twrite_unlock(&rfcomm_sk_list.lock);\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\two = (rbuf == NULL || rlen == 0); \n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "void CMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n    zis.setUnderlying(is, len - 4);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n    zis.removeUnderlying();\n    handler->handleClipboardProvide(flags, lengths, buffers);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}", "target": 1}
{"code": "static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    *base64,\n    message[MagickPathExtent];\n  const MagickInfo\n    *magick_info;\n  Image\n    *write_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  size_t\n    blob_length,\n    encode_length;\n  unsigned char\n    *blob;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(write_info->magick,exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickMimeType(magick_info) == (const char *) NULL))\n    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n  (void) CopyMagickString(image->filename,write_info->filename,\n    MagickPathExtent);\n  blob_length=2048;\n  write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MagickPathExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}", "target": 1}
{"code": "static int __init personal_pci_init(void)\n{\n\tif (machine_is_personal_server())\n\t\tpci_common_init(&personal_server_pci);\n\treturn 0;\n}", "target": 1}
{"code": "static int uac_mixer_unit_get_channels(struct mixer_build *state,\n\t\t\t\t       struct uac_mixer_unit_descriptor *desc)\n{\n\tint mu_channels;\n\tvoid *c;\n\tif (desc->bLength < sizeof(*desc))\n\t\treturn -EINVAL;\n\tif (!desc->bNrInPins)\n\t\treturn -EINVAL;\n\tswitch (state->mixer->protocol) {\n\tcase UAC_VERSION_1:\n\tcase UAC_VERSION_2:\n\tdefault:\n\t\tif (desc->bLength < sizeof(*desc) + desc->bNrInPins + 1)\n\t\t\treturn 0; \n\t\tmu_channels = uac_mixer_unit_bNrChannels(desc);\n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tmu_channels = get_cluster_channels_v3(state,\n\t\t\t\tuac3_mixer_unit_wClusterDescrID(desc));\n\t\tbreak;\n\t}\n\tif (!mu_channels)\n\t\treturn 0;\n\tc = uac_mixer_unit_bmControls(desc, state->mixer->protocol);\n\tif (c - (void *)desc + (mu_channels - 1) / 8 >= desc->bLength)\n\t\treturn 0; \n\treturn mu_channels;\n}", "target": 1}
{"code": "file_rlookup(const char *filename)\t\n{\n  int\t\ti;\t\t\t\n  cache_t\t*wc;\t\t\t\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n    if (!strcmp(wc->name, filename))\n      return (wc->url);\n  return (filename);\n}", "target": 1}
{"code": "isis_print_id(const uint8_t *cp, int id_len)\n{\n     int i;\n     static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n     char *pos = id;\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n         snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n \tpos += strlen(pos);\n \tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}", "target": 1}
{"code": " static int check_mtab(const char *progname, const char *devname,\n                      const char *dir)\n {\n       if (check_newline(progname, devname) == -1 ||\n           check_newline(progname, dir) == -1)\n                return EX_USAGE;\n        return 0;\n }", "target": 1}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\tfree_tga(tga);\n\treturn image;\n}", "target": 1}
{"code": "static int evtchn_fifo_percpu_deinit(unsigned int cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, true);\n\treturn 0;\n}", "target": 1}
{"code": "pci_lintr_request(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint bestpin, bestcount, pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tbestpin = 0;\n\tbestcount = si->si_intpins[0].ii_count;\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tif (si->si_intpins[pin].ii_count < bestcount) {\n\t\t\tbestpin = pin;\n\t\t\tbestcount = si->si_intpins[pin].ii_count;\n\t\t}\n\t}\n\tsi->si_intpins[bestpin].ii_count++;\n\tdev->lintr.pin = bestpin + 1;\n\tpci_set_cfgdata8(dev, PCIR_INTPIN, bestpin + 1);\n}", "target": 1}
{"code": "static int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tuchar\tbyte;\n\tint\tcount;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif ((argc < 4) || (argc > 5))\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tbyte = hextoul(argv[3], NULL);\n\tif (argc == 5)\n\t\tcount = hextoul(argv[4], NULL);\n\telse\n\t\tcount = 1;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_write(dev, addr++, &byte, 1);\n#else\n\t\tret = i2c_write(chip, addr++, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\tudelay(11000);\n#endif\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static INLINE BOOL ensure_capacity(const BYTE* start, const BYTE* end, size_t size, size_t base)\n{\n\tconst size_t available = (uintptr_t)end - (uintptr_t)start;\n\tconst BOOL rc = available >= size * base;\n\treturn rc;\n}", "target": 1}
{"code": "update_notification_destroy(struct update_notification *file)\n{\n\tdoc_data_cleanup(&file->snapshot);\n\tglobal_data_cleanup(&file->global_data);\n\tdeltas_head_destroy(file->deltas_list);\n\tfree(file->uri);\n\tfree(file);\n}", "target": 1}
{"code": "int64_t OpLevelCostEstimator::CalculateOutputSize(const OpInfo& op_info,\n                                                  bool* found_unknown_shapes) {\n  int64_t total_output_size = 0;\n  for (const auto& output : op_info.outputs()) {\n    DataType dt = output.dtype();\n    const auto& original_output_shape = output.shape();\n    int64_t output_size = DataTypeSize(BaseType(dt));\n    int num_dims = std::max(1, original_output_shape.dim_size());\n    auto output_shape = MaybeGetMinimumShape(original_output_shape, num_dims,\n                                             found_unknown_shapes);\n    for (const auto& dim : output_shape.dim()) {\n      output_size *= dim.size();\n    }\n    total_output_size += output_size;\n    VLOG(1) << \"Output Size: \" << output_size\n            << \" Total Output Size:\" << total_output_size;\n  }\n  return total_output_size;\n}", "target": 1}
{"code": "spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "static int adpt_open(struct inode *inode, struct file *file)\n{\n\tint minor;\n\tadpt_hba* pHba;\n\tmutex_lock(&adpt_mutex);\n\tminor = iminor(inode);\n\tif (minor >= hba_count) {\n\t\tmutex_unlock(&adpt_mutex);\n\t\treturn -ENXIO;\n\t}\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->unit == minor) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tif (pHba == NULL) {\n\t\tmutex_unlock(&adpt_configuration_lock);\n\t\tmutex_unlock(&adpt_mutex);\n\t\treturn -ENXIO;\n\t}\n\tpHba->in_use = 1;\n\tmutex_unlock(&adpt_configuration_lock);\n\tmutex_unlock(&adpt_mutex);\n\treturn 0;\n}", "target": 1}
{"code": "netsnmp_mibindex_new( const char *dirname )\n{\n    FILE *fp;\n    char  tmpbuf[300];\n    char *cp;\n    int   i;\n    cp = netsnmp_mibindex_lookup( dirname );\n    if (!cp) {\n        i  = _mibindex_add( dirname, -1 );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                  get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        cp = tmpbuf;\n    }\n    DEBUGMSGTL((\"mibindex\", \"new: %s (%s)\\n\", dirname, cp ));\n    fp = fopen( cp, \"w\" );\n    if (fp)\n        fprintf( fp, \"DIR %s\\n\", dirname );\n    return fp;\n}", "target": 1}
{"code": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n{\n\tstruct file *file = vma->vm_file;\n#ifdef CONFIG_SWAP\n\tif (!file) {\n\t\t*prev = vma;\n\t\tforce_swapin_readahead(vma, start, end);\n\t\treturn 0;\n\t}\n\tif (shmem_mapping(file->f_mapping)) {\n\t\t*prev = vma;\n\t\tforce_shm_swapin_readahead(vma, start, end,\n\t\t\t\t\tfile->f_mapping);\n\t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\tif (IS_DAX(file_inode(file))) {\n\t\treturn 0;\n\t}\n\t*prev = vma;\n\tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tif (end > vma->vm_end)\n\t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}", "target": 1}
{"code": "void ServerSecurityFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--server.harden\",\n                     \"lock down REST APIs that reveal version information or server \"\n                     \"internals for non-admin users\",\n                     new BooleanParameter(&_hardenedRestApi))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                     new BooleanParameter(&_enableFoxxApi),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n  options->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                     new BooleanParameter(&_enableFoxxStore),\n                     arangodb::options::makeFlags(\n                     arangodb::options::Flags::DefaultNoComponents,\n                     arangodb::options::Flags::OnCoordinator,\n                     arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30500);\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &getParameters() const\n    {\n        return parameters();\n    }", "target": 1}
{"code": "static void frag_kfree_skb(struct netns_frags *nf, struct sk_buff *skb)\n{\n\tatomic_sub(skb->truesize, &nf->mem);\n\tkfree_skb(skb);\n}", "target": 1}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 1}
{"code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n \tline += PKT_LEN_SIZE;\n \tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n \t}\n \tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}", "target": 1}
{"code": "const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});\n  input.Push(size);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);\n  auto result = output.next();\n  int klinux_errno = output.next<int>();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n  memcpy(dst, result.data(),\n         std::min(static_cast<size_t>(size),\n                  static_cast<size_t>(INET6_ADDRSTRLEN)));\n  return dst;\n}", "target": 1}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 1}
{"code": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n   char errstr[STRING];\n   struct Buffer err, token;\n   struct ImapMbox mx;\n   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n   {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n     mutt_buffer_init(&err);\n     err.data = errstr;\n     err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n     if (mutt_parse_rc_line(mbox, &token, &err))\n       mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n     FREE(&token.data);\n  }\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}", "target": 1}
{"code": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\ttimr->it_interval = 0;\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}", "target": 1}
{"code": "  StringTableEntry getStringTableEntry(uint32_t index) const override {\n    llvm_unreachable(\"Accessing string table from a lazy module\");\n  }", "target": 1}
{"code": "static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}", "target": 1}
{"code": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->ipv6))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "static int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\treturn 0;\n}", "target": 1}
{"code": "static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)\n{\n\tstruct libmnt_ns *ns_old;\n\tconst char *type = mnt_fs_get_fstype(cxt->fs);\n\tconst char *optstr;\n\tchar *user_id = NULL;\n\tsize_t sz;\n\tuid_t uid;\n\tchar uidstr[sizeof(stringify_value(ULONG_MAX))];\n\t*errsv = 0;\n\tif (!type)\n\t\treturn 0;\n\tif (strcmp(type, \"fuse\") != 0 &&\n\t    strcmp(type, \"fuseblk\") != 0 &&\n\t    strncmp(type, \"fuse.\", 5) != 0 &&\n\t    strncmp(type, \"fuseblk.\", 8) != 0)\n\t\treturn 0;\n\toptstr = mnt_fs_get_fs_options(cxt->fs);\n\tif (!optstr)\n\t\treturn 0;\n\tif (mnt_optstr_get_option(optstr, \"user_id\", &user_id, &sz) != 0)\n\t\treturn 0;\n\tif (sz == 0 || user_id == NULL)\n\t\treturn 0;\n\tns_old = mnt_context_switch_origin_ns(cxt);\n\tif (!ns_old) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tuid = getuid();\n\tif (!mnt_context_switch_ns(cxt, ns_old)) {\n\t\t*errsv = -MNT_ERR_NAMESPACE;\n\t\treturn 0;\n\t}\n\tsnprintf(uidstr, sizeof(uidstr), \"%lu\", (unsigned long) uid);\n\treturn strncmp(user_id, uidstr, sz) == 0;\n}", "target": 1}
{"code": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": "uint64 ReadCodedSizeValue(const binary * InBuffer, uint32 & BufferSize, uint64 & SizeUnknown)\n{\n  binary SizeBitMask = 1 << 7;\n  uint64 Result = 0x7F;\n  unsigned int SizeIdx, PossibleSizeLength = 0;\n  binary PossibleSize[8];\n  memset(PossibleSize, 0, 8);\n  SizeUnknown = 0x7F; \n  for (SizeIdx = 0; SizeIdx < BufferSize && SizeIdx < 8; SizeIdx++) {\n    if (InBuffer[0] & (SizeBitMask >> SizeIdx)) {\n      PossibleSizeLength = SizeIdx + 1;\n      SizeBitMask >>= SizeIdx;\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength; SizeIdx++) {\n        PossibleSize[SizeIdx] = InBuffer[SizeIdx];\n      }\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength - 1; SizeIdx++) {\n        Result <<= 7;\n        Result |= 0xFF;\n      }\n      Result = 0;\n      Result |= PossibleSize[0] & ~SizeBitMask;\n      for (unsigned int i = 1; i<PossibleSizeLength; i++) {\n        Result <<= 8;\n        Result |= PossibleSize[i];\n      }\n      BufferSize = PossibleSizeLength;\n      return Result;\n    }\n    SizeUnknown <<= 7;\n    SizeUnknown |= 0xFF;\n  }\n  BufferSize = 0;\n  return 0;\n}", "target": 1}
{"code": "static plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n     data->type = PLIST_STRING;\n     data->strval = (char *) malloc(sizeof(char) * (size + 1));\n     memcpy(data->strval, *bnode, size);\n     data->strval[size] = '\\0';\n     data->length = strlen(data->strval);\n    return node_create(NULL, data);\n}", "target": 1}
{"code": "static void sctp_auto_asconf_init(struct sctp_sock *sp)\n{\n\tstruct net *net = sock_net(&sp->inet.sk);\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock(&net->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list, &net->sctp.auto_asconf_splist);\n\t\tspin_unlock(&net->sctp.addr_wq_lock);\n\t\tsp->do_auto_asconf = 1;\n\t}\n}", "target": 1}
{"code": "static void rd_release_device_space(struct rd_dev *rd_dev)\n{\n\tu32 i, j, page_count = 0, sg_per_table;\n\tstruct rd_dev_sg_table *sg_table;\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n\t\treturn;\n\tsg_table = rd_dev->sg_table_array;\n\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n\t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n\t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n\t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n\tkfree(sg_table);\n\trd_dev->sg_table_array = NULL;\n\trd_dev->sg_table_count = 0;\n}", "target": 1}
{"code": "void ogs_pfcp_context_init(void)\n{\n    int i;\n    ogs_assert(context_initialized == 0);\n    memset(&self, 0, sizeof(ogs_pfcp_context_t));\n    self.local_recovery = ogs_time_ntp32_now();\n    ogs_log_install_domain(&__ogs_pfcp_domain, \"pfcp\", ogs_core()->log.level);\n    ogs_pool_init(&ogs_pfcp_node_pool, ogs_app()->pool.nf);\n    ogs_pool_init(&ogs_pfcp_sess_pool, ogs_app()->pool.sess);\n    ogs_pool_init(&ogs_pfcp_far_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_FAR);\n    ogs_pool_init(&ogs_pfcp_urr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_URR);\n    ogs_pool_init(&ogs_pfcp_qer_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_QER);\n    ogs_pool_init(&ogs_pfcp_bar_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_BAR);\n    ogs_pool_init(&ogs_pfcp_pdr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_PDR);\n    ogs_pool_init(&ogs_pfcp_pdr_teid_pool, ogs_pfcp_pdr_pool.size);\n    ogs_pool_random_id_generate(&ogs_pfcp_pdr_teid_pool);\n    pdr_random_to_index = ogs_calloc(\n            sizeof(ogs_pool_id_t), ogs_pfcp_pdr_pool.size);\n    ogs_assert(pdr_random_to_index);\n    for (i = 0; i < ogs_pfcp_pdr_pool.size; i++)\n        pdr_random_to_index[ogs_pfcp_pdr_teid_pool.array[i]] = i;\n    ogs_pool_init(&ogs_pfcp_rule_pool,\n            ogs_app()->pool.sess *\n            OGS_MAX_NUM_OF_PDR * OGS_MAX_NUM_OF_FLOW_IN_PDR);\n    ogs_pool_init(&ogs_pfcp_dev_pool, OGS_MAX_NUM_OF_DEV);\n    ogs_pool_init(&ogs_pfcp_subnet_pool, OGS_MAX_NUM_OF_SUBNET);\n    self.object_teid_hash = ogs_hash_make();\n    ogs_assert(self.object_teid_hash);\n    self.far_f_teid_hash = ogs_hash_make();\n    ogs_assert(self.far_f_teid_hash);\n    self.far_teid_hash = ogs_hash_make();\n    ogs_assert(self.far_teid_hash);\n    context_initialized = 1;\n}", "target": 1}
{"code": "static long madvise_willneed(struct vm_area_struct *vma,\n\t\t\t     struct vm_area_struct **prev,\n\t\t\t     unsigned long start, unsigned long end)\n {\n \tstruct file *file = vma->vm_file;\n #ifdef CONFIG_SWAP\n \tif (!file) {\n\t\t*prev = vma;\n \t\tforce_swapin_readahead(vma, start, end);\n \t\treturn 0;\n \t}\n \tif (shmem_mapping(file->f_mapping)) {\n\t\t*prev = vma;\n \t\tforce_shm_swapin_readahead(vma, start, end,\n \t\t\t\t\tfile->f_mapping);\n \t\treturn 0;\n\t}\n#else\n\tif (!file)\n\t\treturn -EBADF;\n#endif\n\tif (IS_DAX(file_inode(file))) {\n \t\treturn 0;\n \t}\n\t*prev = vma;\n \tstart = ((start - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n \tif (end > vma->vm_end)\n \t\tend = vma->vm_end;\n\tend = ((end - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tforce_page_cache_readahead(file->f_mapping, file, start, end - start);\n\treturn 0;\n}", "target": 1}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "void processInputBuffer(client *c) {\n    server.current_client = c;\n    while(sdslen(c->querybuf)) {\n        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;\n        if (c->flags & CLIENT_BLOCKED) break;\n        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;\n        if (!c->reqtype) {\n            if (c->querybuf[0] == '*') {\n                c->reqtype = PROTO_REQ_MULTIBULK;\n            } else {\n                c->reqtype = PROTO_REQ_INLINE;\n            }\n        }\n        if (c->reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;\n        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break;\n        } else {\n            serverPanic(\"Unknown request type\");\n        }\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            if (processCommand(c) == C_OK)\n                resetClient(c);\n            if (server.current_client == NULL) break;\n        }\n    }\n    server.current_client = NULL;\n}", "target": 1}
{"code": "COMPAT_SYSCALL_DEFINE5(waitid,\n\t\tint, which, compat_pid_t, pid,\n\t\tstruct compat_siginfo __user *, infop, int, options,\n\t\tstruct compat_rusage __user *, uru)\n{\n\tstruct rusage ru;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err && uru) {\n\t\tif (COMPAT_USE_64BIT_TIME)\n\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n\t\telse\n\t\t\terr = put_compat_rusage(&ru, uru);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *next;\n\tnvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);\n\tnvkm_memory_unref(&vma->memory);\n\tif (vma->part) {\n\t\tstruct nvkm_vma *prev = node(vma, prev);\n\t\tif (!prev->memory) {\n\t\t\tprev->size += vma->size;\n\t\t\trb_erase(&vma->tree, &vmm->root);\n\t\t\tlist_del(&vma->head);\n\t\t\tkfree(vma);\n\t\t\tvma = prev;\n\t\t}\n\t}\n\tnext = node(vma, next);\n\tif (next && next->part) {\n\t\tif (!next->memory) {\n\t\t\tvma->size += next->size;\n\t\t\trb_erase(&next->tree, &vmm->root);\n\t\t\tlist_del(&next->head);\n\t\t\tkfree(next);\n\t\t}\n\t}\n}", "target": 1}
{"code": "int64_t TensorByteSize(const TensorProto& t) {\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n  return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}", "target": 1}
{"code": "void CxImage::Startup(uint32_t imagetype)\n{\n\tpDib = pSelection = pAlpha = NULL;\n\tppLayers = ppFrames = NULL;\n\tmemset(&head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&info,0,sizeof(CXIMAGEINFO));\n    info.dwType = imagetype;\n\tinfo.fQuality = 90.0f;\n\tinfo.nAlphaMax = 255;\n\tinfo.nBkgndIndex = -1;\n\tinfo.bEnabled = true;\n\tinfo.nJpegScale = 1;\n\tSetXDPI(CXIMAGE_DEFAULT_DPI);\n\tSetYDPI(CXIMAGE_DEFAULT_DPI);\n\tint16_t test = 1;\n\tinfo.bLittleEndianHost = (*((char *) &test) == 1);\n}", "target": 1}
{"code": "static int checkStringLength(client *c, long long size) {\n    if (!mustObeyClient(c) && size > server.proto_max_bulk_len) {\n        addReplyError(c,\"string exceeds maximum allowed size (proto-max-bulk-len)\");\n        return C_ERR;\n    }\n    return C_OK;\n}", "target": 1}
{"code": "Bool gf_sg_proto_field_is_sftime_offset(GF_Node *node, GF_FieldInfo *field)\n{\n\tu32 i;\n\tGF_Route *r;\n\tGF_ProtoInstance *inst;\n\tGF_FieldInfo inf;\n\tif (node->sgprivate->tag != TAG_ProtoNode) return 0;\n\tif (field->fieldType != GF_SG_VRML_SFTIME) return 0;\n\tinst = (GF_ProtoInstance *) node;\n\ti=0;\n\twhile ((r = (GF_Route*)gf_list_enum(inst->proto_interface->sub_graph->Routes, &i))) {\n\t\tif (!r->IS_route) continue;\n\t\tif (r->FromNode || (r->FromField.fieldIndex != field->fieldIndex)) continue;\n\t\tgf_node_get_field(r->ToNode, r->ToField.fieldIndex, &inf);\n\t\tif (r->ToNode->sgprivate->tag == TAG_ProtoNode) return gf_sg_proto_field_is_sftime_offset(r->ToNode, &inf);\n\t\tif (!stricmp(inf.name, \"startTime\") || !stricmp(inf.name, \"stopTime\")) return 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n {\n \tstruct snd_kcontrol *kctl;\n \tlist_for_each_entry(kctl, &card->controls, list) {\n \t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n \t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "comics_remove_dir (gchar *path_name) \n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path = \n\t\t\t\tg_build_filename (path_name, \n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 1}
{"code": "static char *create_output_name(unsigned char *fname, unsigned char *dir,\n\t\t\t int lower, int isunix, int utf8)\n{\n  unsigned char *p, *name, c, *fe, sep, slash;\n  unsigned int x;\n  sep   = (isunix) ? '/'  : '\\\\'; \n  slash = (isunix) ? '\\\\' : '/';  \n  x = strlen((char *) fname);\n  if (utf8) x *= 3;\n  if (dir) x += strlen((char *) dir);\n  if (!(name = (unsigned char *) malloc(x + 2))) {\n    fprintf(stderr, \"out of memory!\\n\");\n    return NULL;\n  }\n  *name = '\\0';\n  if (dir) {\n    strcpy((char *) name, (char *) dir);\n    strcat((char *) name, \"/\");\n  }\n  while (*fname == sep) fname++;\n  p = &name[strlen((char *)name)];\n  fe = &fname[strlen((char *)fname)];\n  if (utf8) {\n    do {\n      if (fname >= fe) {\n\tfree(name);\n\treturn NULL;\n      }\n      if ((c = *fname++) < 0x80) x = c;\n      else {\n\tif ((c >= 0xC0) && (c < 0xE0)) {\n\t  x = (c & 0x1F) << 6;\n\t  x |= *fname++ & 0x3F;\n\t}\n\telse if ((c >= 0xE0) && (c < 0xF0)) {\n\t  x = (c & 0xF) << 12;\n\t  x |= (*fname++ & 0x3F) << 6;\n\t  x |= *fname++ & 0x3F;\n\t}\n\telse x = '?';\n      }\n      if      (x == sep)   x = '/';\n      else if (x == slash) x = '\\\\';\n      else if (lower)      x = (unsigned int) tolower((int) x);\n      if (x < 0x80) {\n\t*p++ = (unsigned char) x;\n      }\n      else if (x < 0x800) {\n\t*p++ = 0xC0 | (x >> 6);   \n\t*p++ = 0x80 | (x & 0x3F);\n      }\n      else {\n\t*p++ = 0xE0 | (x >> 12);\n\t*p++ = 0x80 | ((x >> 6) & 0x3F);\n\t*p++ = 0x80 | (x & 0x3F);\n      }\n    } while (x);\n  }\n  else {\n    do {\n      c = *fname++;\n      if      (c == sep)   c = '/';\n      else if (c == slash) c = '\\\\';\n      else if (lower)      c = (unsigned char) tolower((int) c);\n    } while ((*p++ = c));\n  }\n  return (char *) name;\n}", "target": 1}
{"code": "static int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\tkenter(\"{%d}\", key->serial);\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->reject_error);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\nskipped:\n\treturn ctx->skipped_ret;\n}", "target": 1}
{"code": "avp_enum(struct l2tp_avp *avp, const u_char *pkt, int pktlen, int filldata)\n{\n\tuint16_t flags;\n\tL2TP_SUBR_ASSERT(pktlen >= 6);\n\tif (pktlen < 6)\n\t\treturn -1;\n\tGETSHORT(flags, pkt);\n\tavp->is_mandatory = ((flags & 0x8000) != 0)? 1 : 0;\n\tavp->is_hidden = ((flags & 0x4000) != 0)? 1 : 0;\n\tavp->length = flags & 0x03ff;\n\tGETSHORT(avp->vendor_id, pkt);\n\tavp->attr_type = *pkt << 8;\n\tavp->attr_type |= *(pkt + 1);\n\tpkt += 2;\n\tif (avp->length > pktlen)\n\t\treturn -1;\n\tif (filldata != 0)\n\t\tmemcpy(avp->attr_value, pkt, avp->length - 6);\n\treturn avp->length;\n}", "target": 1}
{"code": "PHP_FUNCTION( msgfmt_parse_message )\n{\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tsize_t      pattern_len = 0;\n\tconst char *slocale = NULL;\n\tsize_t      slocale_len = 0;\n\tchar       *source = NULL;\n\tsize_t      src_len = 0;\n\tMessageFormatter_object mf;\n\tMessageFormatter_object *mfo = &mf;\n\tif( zend_parse_parameters( ZEND_NUM_ARGS(), \"sss\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &source, &src_len ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_parse_message: unable to parse input params\", 0 );\n\t\tRETURN_FALSE;\n\t}\n\tmemset(mfo, 0, sizeof(*mfo));\n\tmsgformat_data_init(&mfo->mf_data);\n\tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_parse_message: error converting pattern to UTF-16\", 0 );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default();\n\t}\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_parse_message: error converting pattern to quote-friendly format\", 0 );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\tmsgfmt_do_parse(mfo, source, src_len, return_value);\n\tmsgformat_data_free(&mfo->mf_data);\n}", "target": 1}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->input,\n                                               sgx_params->input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 1}
{"code": "Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[100];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}", "target": 1}
{"code": "R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut8 *attr_buf = NULL;\n\tint pending = len - offset;\n\tconst ut8 *a_buf = offset + buf;\n\tattr_buf = (ut8 *) calloc (pending + 1, 1);\n\tif (!attr_buf) {\n\t\teprintf (\"Unable to allocate enough bytes (0x%04\"PFMT64x\n\t\t\t\") to read in the attribute.\\n\", sz);\n\t\treturn attr_buf;\n\t}\n\tmemcpy (attr_buf, a_buf, pending); \n\treturn attr_buf;\n}", "target": 1}
{"code": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static int em_call(struct x86_emulate_ctxt *ctxt)\n{\n\tlong rel = ctxt->src.val;\n\tctxt->src.val = (unsigned long)ctxt->_eip;\n\tjmp_rel(ctxt, rel);\n\treturn em_push(ctxt);\n}", "target": 1}
{"code": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\treturn 0;\n}", "target": 1}
{"code": "COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask) {\n\t\terr = compat_get_bitmap(bm, nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, bm, alloc_size);\n\t}\n\tif (err)\n\t\treturn -EFAULT;\n\treturn sys_set_mempolicy(mode, nm, nr_bits+1);\n}", "target": 1}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document,\n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp,\n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 1}
{"code": "TfLiteStatus EvalScatterNd(TfLiteContext* context, const TfLiteTensor* indices,\n                           const TfLiteTensor* updates,\n                           const TfLiteTensor* shape, TfLiteTensor* output) {\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(\n        context, CheckShapes<IndicesT>(\n                     context, GetTensorShape(indices), GetTensorShape(updates),\n                     GetTensorShape(shape), GetTensorData<IndicesT>(shape)));\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor<IndicesT>(context, shape, output));\n  }\n  switch (updates->type) {\n    case kTfLiteFloat32:\n      return ScatterNd<IndicesT, float>(indices, updates, output);\n    case kTfLiteUInt8:\n      return ScatterNd<IndicesT, uint8_t>(indices, updates, output);\n    case kTfLiteBool:\n      return ScatterNd<IndicesT, bool>(indices, updates, output);\n    case kTfLiteInt8:\n      return ScatterNd<IndicesT, int8_t>(indices, updates, output);\n    case kTfLiteInt32:\n      return ScatterNd<IndicesT, int32_t>(indices, updates, output);\n    case kTfLiteInt64:\n      return ScatterNd<IndicesT, int64_t>(indices, updates, output);\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Updates of type '%s' are not supported by scatter_nd.\",\n          TfLiteTypeGetName(updates->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": " bittok2str_internal(register const struct tok *lp, register const char *fmt,\n \t   register u_int v, const char *sep)\n {\n        static char buf[256]; \n        int buflen=0;\n         register u_int rotbit; \n         register u_int tokval;\n         const char * sepstr = \"\";\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   \n            rotbit=1;\n            while (rotbit != 0) {\n \t\tif (tokval == (v&rotbit)) {\n                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, \"%s%s\",\n                                     sepstr, lp->s);\n                     sepstr = sep;\n                     break;\n                 }\n                rotbit=rotbit<<1; \n            }\n             lp++;\n \t}\n        if (buflen == 0)\n             (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n         return (buf);\n}", "target": 1}
{"code": "static int init_die(RzBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tdie->attr_values = calloc(sizeof(RzBinDwarfAttrValue), attr_count);\n\tif (!die->attr_values) {\n\t\treturn -1;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}", "target": 1}
{"code": "MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((MemoryInfo *) NULL);\n  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickCoreSignature;\n  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n    {\n      memory_info->blob=AcquireAlignedMemory(1,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=AlignedVirtualMemory;\n          return(memory_info);\n        }\n    }\n  RelinquishMagickResource(MemoryResource,extent);\n  if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n    {\n      memory_info->blob=MapBlob(-1,IOMode,0,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=MapVirtualMemory;\n          return(memory_info);\n        }\n      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n        {\n          int\n            file;\n          file=AcquireUniqueFileResource(memory_info->filename);\n          if (file != -1)\n            {\n              MagickOffsetType\n                offset;\n              offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);\n              if ((offset == (MagickOffsetType) (extent-1)) &&\n                  (write(file,\"\",1) == 1))\n                {\n                  memory_info->blob=MapBlob(file,IOMode,0,extent);\n                  if (memory_info->blob != NULL)\n                    {\n                      (void) close(file);\n                      memory_info->type=MapVirtualMemory;\n                      return(memory_info);\n                    }\n                }\n              (void) close(file);\n              (void) RelinquishUniqueFileResource(memory_info->filename);\n              *memory_info->filename = '\\0';\n            }\n        }\n      RelinquishMagickResource(DiskResource,extent);\n    }\n  RelinquishMagickResource(MapResource,extent);\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}", "target": 1}
{"code": "static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint id, retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\tmsq = ipc_rcu_alloc(sizeof(*msq));\n\tif (!msq)\n\t\treturn -ENOMEM;\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(msq);\n\tif (retval) {\n\t\tipc_rcu_putref(msq, ipc_rcu_free);\n\t\treturn retval;\n\t}\n\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (id < 0) {\n\t\tipc_rcu_putref(msq, msg_rcu_free);\n\t\treturn id;\n\t}\n\tmsq->q_stime = msq->q_rtime = 0;\n\tmsq->q_ctime = get_seconds();\n\tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = 0;\n\tINIT_LIST_HEAD(&msq->q_messages);\n\tINIT_LIST_HEAD(&msq->q_receivers);\n\tINIT_LIST_HEAD(&msq->q_senders);\n\tipc_unlock_object(&msq->q_perm);\n\trcu_read_unlock();\n\treturn msq->q_perm.id;\n}", "target": 1}
{"code": "__ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh,\n\t\t\t const char *function, unsigned int line)\n{\n\tint error = -EFSCORRUPTED;\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\tif (BHDR(bh)->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||\n\t    BHDR(bh)->h_blocks != cpu_to_le32(1))\n\t\tgoto errout;\n\terror = -EFSBADCRC;\n\tif (!ext4_xattr_block_csum_verify(inode, bh))\n\t\tgoto errout;\n\terror = ext4_xattr_check_entries(BFIRST(bh), bh->b_data + bh->b_size,\n\t\t\t\t\t bh->b_data);\nerrout:\n\tif (error)\n\t\t__ext4_error_inode(inode, function, line, 0,\n\t\t\t\t   \"corrupted xattr block %llu\",\n\t\t\t\t   (unsigned long long) bh->b_blocknr);\n\telse\n\t\tset_buffer_verified(bh);\n\treturn error;\n}", "target": 1}
{"code": "static void bt_tags_for_each(struct blk_mq_tags *tags,\n\t\tstruct blk_mq_bitmap_tags *bt, unsigned int off,\n\t\tbusy_tag_iter_fn *fn, void *data, bool reserved)\n{\n\tstruct request *rq;\n\tint bit, i;\n\tif (!tags->rqs)\n\t\treturn;\n\tfor (i = 0; i < bt->map_nr; i++) {\n\t\tstruct blk_align_bitmap *bm = &bt->map[i];\n\t\tfor (bit = find_first_bit(&bm->word, bm->depth);\n\t\t     bit < bm->depth;\n\t\t     bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {\n\t\t\trq = blk_mq_tag_to_rq(tags, off + bit);\n\t\t\tfn(rq, data, reserved);\n\t\t}\n\t\toff += (1 << bt->bits_per_word);\n\t}\n}", "target": 1}
{"code": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n \t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n \t\t\t\t\t   &xattr_data,\n \t\t\t\t\t   sizeof(xattr_data), 0);\n\t}\n\telse if (rc == -ENODATA)\n \t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n \treturn rc;\n }", "target": 1}
{"code": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\treturn info_for_irq(irq)->evtchn;\n}", "target": 1}
{"code": "static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tvgacon_scrollback_update(c, t, lines);\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}", "target": 1}
{"code": "static void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num > bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; \n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}", "target": 1}
{"code": "static int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}", "target": 1}
{"code": "http_isfiltered(const struct http *fm, unsigned u, unsigned how)\n{\n\tconst char *e;\n\tconst struct http_hdrflg *f;\n\tif (fm->hdf[u] & HDF_FILTER)\n\t\treturn (1);\n\te = strchr(fm->hd[u].b, ':');\n\tif (e == NULL)\n\t\treturn (0);\n\tf = http_hdr_flags(fm->hd[u].b, e);\n\treturn (f != NULL && f->flag & how);\n}", "target": 1}
{"code": "static int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n \tpkt->ref = NULL;\n \tpkt->type = GIT_PKT_NG;\n \tline += 3; \n\tif (!(ptr = strchr(line, ' ')))\n \t\tgoto out_err;\n \tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n \tmemcpy(pkt->ref, line, len);\n \tpkt->ref[len] = '\\0';\n \tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n \t\tgoto out_err;\n \tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\t*out = (git_pkt *)pkt;\n\treturn 0;\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}", "target": 1}
{"code": "spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t\t  int iov_count)\n{\n    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n\t\t\t      iov_count);\n}", "target": 1}
{"code": "static void gprinter_free(struct usb_function *f)\n{\n\tstruct printer_dev *dev = func_to_printer(f);\n\tstruct f_printer_opts *opts;\n\topts = container_of(f->fi, struct f_printer_opts, func_inst);\n\tkfree(dev);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}", "target": 1}
{"code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp->input, 28);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "mysqlnd_switch_to_ssl_if_needed(\n\t\t\tMYSQLND_CONN_DATA * conn,\n\t\t\tconst MYSQLND_PACKET_GREET * const greet_packet,\n\t\t\tconst MYSQLND_OPTIONS * const options,\n\t\t\tunsigned long mysql_flags\n\t\t\tTSRMLS_DC\n\t\t)\n{\n\tenum_func_status ret = FAIL;\n\tconst MYSQLND_CHARSET * charset;\n\tMYSQLND_PACKET_AUTH * auth_packet;\n\tDBG_ENTER(\"mysqlnd_switch_to_ssl_if_needed\");\n\tauth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);\n\tif (!auth_packet) {\n\t\tSET_OOM_ERROR(*conn->error_info);\n\t\tgoto end;\n\t}\n\tauth_packet->client_flags = mysql_flags;\n\tauth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;\n\tif (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {\n\t\tauth_packet->charset_no\t= charset->nr;\n\t} else {\n#if MYSQLND_UNICODE\n\t\tauth_packet->charset_no\t= 200;\n#else\n\t\tauth_packet->charset_no\t= greet_packet->charset_no;\n#endif\n        }\n #ifdef MYSQLND_SSL_SUPPORTED\n       if ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {\n               zend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;\n               DBG_INF(\"Switching to SSL\");\n               if (!PACKET_WRITE(auth_packet, conn)) {\n                       CONN_SET_STATE(conn, CONN_QUIT_SENT);\n                       SET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\n                       goto end;\n               }\n               conn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);\n               if (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {\n                       goto end;\n                }\n        }\n #endif\n        ret = PASS;\n end:\n        PACKET_FREE(auth_packet);\n        DBG_RETURN(ret);\n }", "target": 1}
{"code": "int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)\n{\n  char **atimes, **aranges = NULL;\n  int numtimes=0,i=0,numranges=0;\n  size_t buffer_size = 512;\n  char buffer[512], bufferTmp[512];\n  buffer[0] = '\\0';\n  bufferTmp[0] = '\\0';\n   if (!lp || !timestring || !timefield)\n     return MS_FALSE;\n   if (strstr(timestring, \",\") == NULL &&\n       strstr(timestring, \"/\") == NULL) { \n    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);\n  } else {\n    atimes = msStringSplit (timestring, ',', &numtimes);\n    if (atimes == NULL || numtimes < 1)\n      return MS_FALSE;\n    strlcat(buffer, \"(\", buffer_size);\n    for(i=0; i<numtimes; i++) {\n      if(i!=0) {\n        strlcat(buffer, \" OR \", buffer_size);\n      }\n      strlcat(buffer, \"(\", buffer_size);\n      aranges = msStringSplit(atimes[i],  '/', &numranges);\n      if(!aranges) return MS_FALSE;\n      if(numranges == 1) {\n        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else if(numranges == 2) {\n        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else {\n        return MS_FALSE;\n      }\n      msFreeCharArray(aranges, numranges);\n      strlcat(buffer, \")\", buffer_size);\n    }\n    strlcat(buffer, \")\", buffer_size);\n    msFreeCharArray(atimes, numtimes);\n  }\n  if(!*buffer) {\n    return MS_FALSE;\n  }\n  if(lp->filteritem) free(lp->filteritem);\n  lp->filteritem = msStrdup(timefield);\n  if (&lp->filter) {\n    if (lp->filter.type == MS_EXPRESSION) {\n      snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);\n      loadExpressionString(&lp->filter, bufferTmp);\n    } else {\n      freeExpression(&lp->filter);\n      loadExpressionString(&lp->filter, buffer);\n    }\n  }\n  return MS_TRUE;\n}", "target": 1}
{"code": "mptctl_eventenable (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventenable\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventenable - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventenable struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventenable() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventenable called.\\n\",\n\t    ioc->name));\n\tif (ioc->events == NULL) {\n\t\tint sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\n\t\tioc->events = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->events) {\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t    \": ERROR - Insufficient memory to add adapter!\\n\",\n\t\t\t    ioc->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tioc->alloc_total += sz;\n\t\tioc->eventContext = 0;\n        }\n\tioc->eventTypes = karg.eventTypes;\n\treturn 0;\n}", "target": 1}
{"code": " int __glXDisp_CreateContext(__GLXclientState *cl, GLbyte *pc)\n {\n     xGLXCreateContextReq *req = (xGLXCreateContextReq *) pc;\n     __GLXconfig *config;\n     __GLXscreen *pGlxScreen;\n     int err;\n     if (!validGlxScreen(cl->client, req->screen, &pGlxScreen, &err))\n \treturn err;\n     if (!validGlxVisual(cl->client, pGlxScreen, req->visual, &config, &err))\n\t\t\t   config, pGlxScreen, req->isDirect);\n}", "target": 1}
{"code": "const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}", "target": 1}
{"code": "static int ssl_verify_server_cert(Vio *vio, const char* server_hostname, const char **errptr)\n{\n  SSL *ssl;\n  X509 *server_cert;\n  char *cp1, *cp2;\n  char buf[256];\n  DBUG_ENTER(\"ssl_verify_server_cert\");\n  DBUG_PRINT(\"enter\", (\"server_hostname: %s\", server_hostname));\n  if (!(ssl= (SSL*)vio->ssl_arg))\n  {\n    *errptr= \"No SSL pointer found\";\n    DBUG_RETURN(1);\n  }\n  if (!server_hostname)\n  {\n    *errptr= \"No server hostname supplied\";\n    DBUG_RETURN(1);\n  }\n  if (!(server_cert= SSL_get_peer_certificate(ssl)))\n  {\n    *errptr= \"Could not get server certificate\";\n    DBUG_RETURN(1);\n  }\n  if (X509_V_OK != SSL_get_verify_result(ssl))\n  {\n    *errptr= \"Failed to verify the server certificate\";\n    X509_free(server_cert);\n    DBUG_RETURN(1);\n  }\n  X509_NAME_oneline(X509_get_subject_name(server_cert), buf, sizeof(buf));\n  X509_free (server_cert);\n  DBUG_PRINT(\"info\", (\"hostname in cert: %s\", buf));\n  cp1= strstr(buf, \"/CN=\");\n  if (cp1)\n  {\n    cp1+= 4; \n    cp2= strchr(cp1, '/');\n    if (cp2)\n      *cp2= '\\0';\n    DBUG_PRINT(\"info\", (\"Server hostname in cert: %s\", cp1));\n    if (!strcmp(cp1, server_hostname))\n    {\n      DBUG_RETURN(0);\n    }\n  }\n  *errptr= \"SSL certificate validation failure\";\n  DBUG_RETURN(1);", "target": 1}
{"code": "uint16_t mesg_id (void) {\n\tstatic uint16_t id = 0;\n\tif (!id) {\n\t\tsrandom (time (NULL));\n\t\tid = random ();\n\t}\n\tid++;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", id);\n\treturn id;\n}", "target": 1}
{"code": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}", "target": 1}
{"code": "char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; \n  size_t newlen = alloc;\n  int strindex=0;\n  size_t length;\n  CURLcode res;\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n    if(Curl_isunreserved(in))\n      ns[strindex++]=in;\n    else {\n      newlen += 2; \n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; \n  return ns;\n}", "target": 1}
{"code": "validate_group(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *leader = event->group_leader;\n\tstruct pmu_hw_events fake_pmu;\n\tDECLARE_BITMAP(fake_used_mask, ARMPMU_MAX_HWEVENTS);\n\tmemset(fake_used_mask, 0, sizeof(fake_used_mask));\n\tfake_pmu.used_mask = fake_used_mask;\n\tif (!validate_event(&fake_pmu, leader))\n\t\treturn -EINVAL;\n\tlist_for_each_entry(sibling, &leader->sibling_list, group_entry) {\n\t\tif (!validate_event(&fake_pmu, sibling))\n\t\t\treturn -EINVAL;\n\t}\n\tif (!validate_event(&fake_pmu, event))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static void __attribute__((destructor)) fio_lib_destroy(void) {\n  uint8_t add_eol = fio_is_master();\n  fio_data->active = 0;\n  fio_on_fork();\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_AT_EXIT);\n  fio_state_callback_clear_all();\n  fio_defer_perform();\n  fio_poll_close();\n  fio_timer_clear_all();\n  fio_free(fio_data);\n  fio_mem_destroy();\n  FIO_LOG_DEBUG(\"(%d) facil.io resources released, exit complete.\",\n                (int)getpid());\n  if (add_eol)\n    fprintf(stderr, \"\\n\"); \n}", "target": 1}
{"code": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n        assert(f);\n        assert(ret);\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n        path_simplify(p);\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n                delete_trailing_chars(p, \"/\");\n                p = skip_leading_chars(p, \"/\");\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 1}
{"code": "void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      value.clear();\n    }\n  } else {\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}", "target": 1}
{"code": "TiledInputFile::rawTileData (int &dx, int &dy,\n\t\t\t     int &lx, int &ly,\n                             const char *&pixelData,\n\t\t\t     int &pixelDataSize)\n{\n    try\n    {\n        Lock lock (*_data->_streamData);\n        if (!isValidTile (dx, dy, lx, ly))\n            throw IEX_NAMESPACE::ArgExc (\"Tried to read a tile outside \"\n\t\t\t       \"the image file's data window.\");\n        TileBuffer *tileBuffer = _data->getTileBuffer (0);\n        int old_dx=dx;\n        int old_dy=dy;\n        int old_lx=lx;\n        int old_ly=ly;\n        if(isMultiPart(version()))\n        {\n            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));\n        }\n        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,\n\t\t\t  tileBuffer->buffer,\n                          pixelDataSize);\n        if(isMultiPart(version()))\n        {\n            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)\n            {\n                throw IEX_NAMESPACE::ArgExc (\"rawTileData read the wrong tile\");\n            }\n        }\n        pixelData = tileBuffer->buffer;\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList params_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",\n                                                &params_nested_splits_in));\n    const Tensor& params_dense_values_in =\n        context->input(params_nested_splits_in.size());\n    const Tensor& indices_in =\n        context->input(params_nested_splits_in.size() + 1);\n    DCHECK_GT(params_nested_splits_in.size(), 0);  \n    SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;\n    OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));\n    OP_REQUIRES(context, params_dense_values_in.dims() > 0,\n                errors::InvalidArgument(\"params.rank must be nonzero\"));\n    SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);\n    std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;\n    SPLITS_TYPE num_values = 0;\n    std::vector<std::vector<SPLITS_TYPE>> out_splits;\n    OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,\n                                       num_params_dense_values, &out_splits,\n                                       &value_slices, &num_values));\n    OP_REQUIRES_OK(context, WriteSplits(out_splits, context));\n    OP_REQUIRES_OK(context,\n                   WriteValues(params_dense_values_in, value_slices,\n                               out_splits.size(), num_values, context));\n  }", "target": 1}
{"code": "static int getStrrtokenPos(char* str, int savedPos)\n{\n\tint result =-1;\n\tint i;\n\tfor(i=savedPos-1; i>=0; i--) {\n\t\tif(isIDSeparator(*(str+i)) ){\n\t\t\tif(i>=2 && isIDSeparator(*(str+i-2)) ){\n\t\t\t\tresult = i-2;\n\t\t\t} else {\n\t\t\t\tresult = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(result < 1){\n\t\tresult =-1;\n\t}\n\treturn result;\n}", "target": 1}
{"code": "void vlan_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n\tdev->tx_queue_len\t= 0;\n\tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}", "target": 1}
{"code": "int ipfilter(struct pico_frame *f)\n{\n    struct filter_node temp;\n    struct pico_ipv4_hdr *ipv4_hdr = (struct pico_ipv4_hdr *) f->net_hdr;\n    struct pico_trans *trans;\n    struct pico_icmp4_hdr *icmp_hdr;\n    memset(&temp, 0u, sizeof(struct filter_node));\n    temp.fdev = f->dev;\n    temp.out_addr = ipv4_hdr->dst.addr;\n    temp.in_addr = ipv4_hdr->src.addr;\n    if ((ipv4_hdr->proto == PICO_PROTO_TCP) || (ipv4_hdr->proto == PICO_PROTO_UDP)) {\n        trans = (struct pico_trans *) f->transport_hdr;\n        temp.out_port = short_be(trans->dport);\n        temp.in_port = short_be(trans->sport);\n    }\n    else if(ipv4_hdr->proto == PICO_PROTO_ICMP4) {\n        icmp_hdr = (struct pico_icmp4_hdr *) f->transport_hdr;\n        if(icmp_hdr->type == PICO_ICMP_UNREACH && icmp_hdr->code == PICO_ICMP_UNREACH_FILTER_PROHIB)\n            return 0;\n    }\n    temp.proto = ipv4_hdr->proto;\n    temp.priority = f->priority;\n    temp.tos = ipv4_hdr->tos;\n    return ipfilter_apply_filter(f, &temp);\n}", "target": 1}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;\n    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    char* name = new char[name_size+1];\n    if (name == NULL) return;\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if (name[0] == name_size-1) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 1}
{"code": "static void cli_session_setup_gensec_remote_done(struct tevent_req *subreq)\n{\n\tstruct tevent_req *req =\n\t\ttevent_req_callback_data(subreq,\n\t\tstruct tevent_req);\n\tstruct cli_session_setup_gensec_state *state =\n\t\ttevent_req_data(req,\n\t\tstruct cli_session_setup_gensec_state);\n\tNTSTATUS status;\n\tTALLOC_FREE(state->inbuf);\n\tTALLOC_FREE(state->recv_iov);\n\tstatus = cli_sesssetup_blob_recv(subreq, state, &state->blob_in,\n\t\t\t\t\t &state->inbuf, &state->recv_iov);\n\tTALLOC_FREE(subreq);\n\tdata_blob_free(&state->blob_out);\n\tif (!NT_STATUS_IS_OK(status) &&\n\t    !NT_STATUS_EQUAL(status, NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t{\n\t\ttevent_req_nterror(req, status);\n\t\treturn;\n\t}\n\tif (NT_STATUS_IS_OK(status)) {\n\t\tstruct smbXcli_session *session = NULL;\n\t\tbool is_guest = false;\n\t\tif (smbXcli_conn_protocol(state->cli->conn) >= PROTOCOL_SMB2_02) {\n\t\t\tsession = state->cli->smb2.session;\n\t\t} else {\n\t\t\tsession = state->cli->smb1.session;\n\t\t}\n\t\tis_guest = smbXcli_session_is_guest(session);\n\t\tif (is_guest) {\n\t\t\tstate->blob_in = data_blob_null;\n\t\t\tstate->local_ready = true;\n\t\t}\n\t\tstate->remote_ready = true;\n\t}\n\tif (state->local_ready && state->remote_ready) {\n\t\tcli_session_setup_gensec_ready(req);\n\t\treturn;\n\t}\n\tcli_session_setup_gensec_local_next(req);\n}", "target": 1}
{"code": "static int install_relocation_handler(int num_cpus, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = 1,\n\t\t.handler = smm_do_relocation,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 0);\n\tif (smm_setup_relocation_handler(&smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "archive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\tint n, ret_val = 0;\n\tchar *p;\n\tchar *end;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile (*w != L'\\0' && len > 0) {\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tas->s[as->length] = '\\0';\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n#if HAVE_WCRTOMB\n\t\tn = wcrtomb(p, *w++, &shift_state);\n#else\n\t\tn = wctomb(p, *w++);\n#endif\n\t\tif (n == -1) {\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t*p++ = '?';\n\t\t\t\tret_val = -1;\n\t\t\t} else {\n\t\t\t\tret_val = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tp += n;\n\t\tlen--;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "static int tipc_crypto_key_revoke(struct net *net, u8 tx_key)\n{\n\tstruct tipc_crypto *tx = tipc_net(net)->crypto_tx;\n\tstruct tipc_key key;\n\tspin_lock(&tx->lock);\n\tkey = tx->key;\n\tWARN_ON(!key.active || tx_key != key.active);\n\ttipc_crypto_key_set_state(tx, key.passive, 0, key.pending);\n\ttipc_crypto_key_detach(tx->aead[key.active], &tx->lock);\n\tspin_unlock(&tx->lock);\n\tpr_warn(\"%s: key is revoked\\n\", tx->name);\n\treturn -EKEYREVOKED;\n}", "target": 1}
{"code": "static inline int pmd_none_or_trans_huge_or_clear_bad(pmd_t *pmd)\n{\n\tpmd_t pmdval = *pmd;\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\n\tbarrier();\n#endif\n\tif (pmd_none(pmdval))\n\t\treturn 1;\n\tif (unlikely(pmd_bad(pmdval))) {\n\t\tif (!pmd_trans_huge(pmdval))\n\t\t\tpmd_clear_bad(pmd);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "inline bool loadModule(const char* filename, IR::Module& outModule)\n{\n\tstd::vector<U8> fileBytes;\n\tif(!loadFile(filename, fileBytes)) { return false; }\n\tif(*(U32*)fileBytes.data() == 0x6d736100)\n\t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n\telse\n\t{\n\t\tfileBytes.push_back(0);\n\t\tstd::vector<WAST::Error> parseErrors;\n\t\tif(!WAST::parseModule(\n\t\t\t   (const char*)fileBytes.data(), fileBytes.size(), outModule, parseErrors))\n\t\t{\n\t\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\t\treportParseErrors(filename, parseErrors);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}", "target": 1}
{"code": "void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}", "target": 1}
{"code": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *upayload, *zap;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\tgoto error;\n\tret = -ENOMEM;\n\tupayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);\n\tif (!upayload)\n\t\tgoto error;\n\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\tzap = upayload;\n\tret = key_payload_reserve(key, datalen);\n \tif (ret == 0) {\n\t\tzap = key->payload.data[0];\n \t\trcu_assign_keypointer(key, upayload);\n \t\tkey->expiry = 0;\n \t}\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n{\n\tzend_hash_destroy(&pglobals->ht_rc);\n}", "target": 1}
{"code": "static bool fib6_rule_suppress(struct fib_rule *rule, struct fib_lookup_arg *arg)\n{\n\tstruct fib6_result *res = arg->result;\n\tstruct rt6_info *rt = res->rt6;\n\tstruct net_device *dev = NULL;\n\tif (!rt)\n\t\treturn false;\n\tif (rt->rt6i_idev)\n\t\tdev = rt->rt6i_idev->dev;\n\tif (rt->rt6i_dst.plen <= rule->suppress_prefixlen)\n\t\tgoto suppress_route;\n\tif (rule->suppress_ifgroup != -1 && dev && dev->group == rule->suppress_ifgroup)\n\t\tgoto suppress_route;\n\treturn false;\nsuppress_route:\n\tip6_rt_put(rt);\n\treturn true;\n}", "target": 1}
{"code": "static int read_public_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n \t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n \t\treturn 2;\n \t}\n\tbufsize = file->size;\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_public_key(p, keysize, rsa);\n}", "target": 1}
{"code": "runas_grouplist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *group_list, struct member **matching_group)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    int group_matched = UNSPEC;\n    struct member *m;\n    struct alias *a;\n    debug_decl(runas_grouplist_matches, SUDOERS_DEBUG_MATCH);\n    if (group_list != NULL) {\n\tTAILQ_FOREACH_REVERSE(m, group_list, member_list, entries) {\n\t    switch (m->type) {\n\t\tcase ALL:\n\t\t    group_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t\tcase ALIAS:\n\t\t    a = alias_get(parse_tree, m->name, RUNASALIAS);\n\t\t    if (a != NULL) {\n\t\t\tconst int rc = runas_grouplist_matches(parse_tree,\n\t\t\t    &a->members, matching_group);\n\t\t\tif (rc != UNSPEC) {\n\t\t\t    if (m->negated) {\n\t\t\t\tgroup_matched = rc == ALLOW ? DENY : ALLOW;\n\t\t\t    } else {\n\t\t\t\tgroup_matched = rc;\n\t\t\t    }\n\t\t\t}\n\t\t\talias_put(a);\n\t\t\tbreak;\n\t\t    }\n\t\t    FALLTHROUGH;\n\t\tcase WORD:\n\t\t    if (group_matches(m->name, ctx->runas.gr))\n\t\t\tgroup_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t    }\n\t    if (group_matched != UNSPEC) {\n\t\tif (matching_group != NULL && m->type != ALIAS)\n\t\t    *matching_group = m;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (group_matched == UNSPEC) {\n\tstruct gid_list *runas_groups;\n\tif (ctx->runas.pw->pw_gid == ctx->runas.gr->gr_gid) {\n\t    group_matched = ALLOW;\t\n\t} else if ((runas_groups = runas_getgroups(ctx)) != NULL) {\n\t    int i;\n\t    for (i = 0; i < runas_groups->ngids; i++) {\n\t\tif (runas_groups->gids[i] == ctx->runas.gr->gr_gid) {\n\t\t    group_matched = ALLOW;\t\n\t\t    break;\n\t\t}\n\t    }\n\t    sudo_gidlist_delref(runas_groups);\n\t}\n    }\n    debug_return_int(group_matched);\n}", "target": 1}
{"code": "static int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      void *data)\n{\n\tstruct xcopy_dev_search_info *info = data;\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\tif (!se_dev->dev_attrib.emulate_3pc)\n\t\treturn 0;\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n\trc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0)\n\t\treturn 0;\n\tinfo->found_dev = se_dev;\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\trc = target_depend_item(&se_dev->dev_group.cg_item);\n\tif (rc != 0) {\n\t\tpr_err(\"configfs_depend_item attempt failed: %d for se_dev: %p\\n\",\n\t\t       rc, se_dev);\n\t\treturn rc;\n\t}\n\tpr_debug(\"Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\\n\",\n\t\t se_dev, &se_dev->dev_group);\n\treturn 1;\n}", "target": 1}
{"code": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\tkey->expiry = prep->expiry;\n\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}", "target": 1}
{"code": "v8::Local<v8::Object> V8SchemaRegistry::GetSchema(const std::string& api) {\n  if (schema_cache_ != NULL) {\n    v8::Local<v8::Object> cached_schema = schema_cache_->Get(api);\n    if (!cached_schema.IsEmpty()) {\n      return cached_schema;\n    }\n  }\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::EscapableHandleScope handle_scope(isolate);\n  v8::Local<v8::Context> context = GetOrCreateContext(isolate);\n  v8::Context::Scope context_scope(context);\n  const base::DictionaryValue* schema =\n      ExtensionAPI::GetSharedInstance()->GetSchema(api);\n  CHECK(schema) << api;\n  std::unique_ptr<V8ValueConverter> v8_value_converter(\n      V8ValueConverter::create());\n  v8::Local<v8::Value> value = v8_value_converter->ToV8Value(schema, context);\n   CHECK(!value.IsEmpty());\n   v8::Local<v8::Object> v8_schema(v8::Local<v8::Object>::Cast(value));\n  v8_schema->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);\n   schema_cache_->Set(api, v8_schema);\n   return handle_scope.Escape(v8_schema);\n}", "target": 1}
{"code": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\tif (*vm_flags & (VM_HUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\tif (*vm_flags & (VM_NOHUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int svc_listen(struct socket *sock,int backlog)\n{\n\tDEFINE_WAIT(wait);\n\tstruct sock *sk = sock->sk;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tint error;\n\tpr_debug(\"svc_listen %p\\n\",vcc);\n\tlock_sock(sk);\n\tif (test_bit(ATM_VF_SESSION,&vcc->flags)) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\tvcc_insert_socket(sk);\n\tset_bit(ATM_VF_WAITING, &vcc->flags);\n\tprepare_to_wait(sk->sk_sleep, &wait, TASK_UNINTERRUPTIBLE);\n\tsigd_enq(vcc,as_listen,NULL,NULL,&vcc->local);\n\twhile (test_bit(ATM_VF_WAITING, &vcc->flags) && sigd) {\n\t\tschedule();\n\t\tprepare_to_wait(sk->sk_sleep, &wait, TASK_UNINTERRUPTIBLE);\n\t}\n\tfinish_wait(sk->sk_sleep, &wait);\n\tif (!sigd) {\n\t\terror = -EUNATCH;\n\t\tgoto out;\n\t}\n\tset_bit(ATM_VF_LISTEN,&vcc->flags);\n\tsk->sk_max_ack_backlog = backlog > 0 ? backlog : ATM_BACKLOG_DEFAULT;\n\terror = -sk->sk_err;\nout:\n\trelease_sock(sk);\n\treturn error;\n}", "target": 1}
{"code": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\t\twhile (bytes) {\n\t\t\tint copy = min(bytes, iov->iov_len - base);\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}", "target": 1}
{"code": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc;\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlSchemaParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n  return Qnil;\n}", "target": 1}
{"code": "void CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n  }\n}", "target": 1}
{"code": "static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {\n const size_t kNGroupsOffset = 12;\n const size_t kFirstGroupOffset = 16;\n     const size_t kGroupSize = 12;\n     const size_t kStartCharCodeOffset = 0;\n     const size_t kEndCharCodeOffset = 4;\n     if (kFirstGroupOffset > size) {\n         return false;\n     }\n     uint32_t nGroups = readU32(data, kNGroupsOffset);\n    if (kFirstGroupOffset + nGroups * kGroupSize > size) {\n         return false;\n     }\n     for (uint32_t i = 0; i < nGroups; i++) {\n uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;\n uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);\n uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);\n        addRange(coverage, start, end + 1); \n }\n return true;\n}", "target": 1}
{"code": "static efi_status_t __init phys_efi_set_virtual_address_map(\n\tunsigned long memory_map_size,\n\tunsigned long descriptor_size,\n\tu32 descriptor_version,\n\tefi_memory_desc_t *virtual_map)\n{\n\tefi_status_t status;\n\tunsigned long flags;\n\tpgd_t *save_pgd;\n\tsave_pgd = efi_call_phys_prolog();\n\tlocal_irq_save(flags);\n\tstatus = efi_call_phys(efi_phys.set_virtual_address_map,\n\t\t\t       memory_map_size, descriptor_size,\n\t\t\t       descriptor_version, virtual_map);\n\tlocal_irq_restore(flags);\n\tefi_call_phys_epilog(save_pgd);\n\treturn status;\n}", "target": 1}
{"code": " int extract_status_code(char *buffer, size_t size)\n {\n\tchar *buf_code;\n\tchar *begin;\n \tchar *end = buffer + size;\n\tsize_t inc = 0;\n\tint code;\n\tbuf_code = (char *)MALLOC(10);\n\twhile (buffer < end && *buffer++ != ' ') ;\n\tbegin = buffer;\n\twhile (buffer < end && *buffer++ != ' ')\n\t\tinc++;\n\tstrncat(buf_code, begin, inc);\n\tcode = atoi(buf_code);\n\tFREE(buf_code);\n \treturn code;\n }", "target": 1}
{"code": "_gdata_service_build_session (void)\n{\n\tSoupSession *session = soup_session_sync_new ();\n#ifdef HAVE_GNOME\n\tsoup_session_add_feature_by_type (session, SOUP_TYPE_GNOME_FEATURES_2_26);\n#endif \n\tif (_gdata_service_get_log_level () > GDATA_LOG_MESSAGES) {\n\t\tSoupLoggerLogLevel level;\n\t\tSoupLogger *logger;\n\t\tswitch (_gdata_service_get_log_level ()) {\n\t\t\tcase GDATA_LOG_FULL_UNREDACTED:\n\t\t\tcase GDATA_LOG_FULL:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_BODY;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_HEADERS:\n\t\t\t\tlevel = SOUP_LOGGER_LOG_HEADERS;\n\t\t\t\tbreak;\n\t\t\tcase GDATA_LOG_MESSAGES:\n\t\t\tcase GDATA_LOG_NONE:\n\t\t\tdefault:\n\t\t\t\tg_assert_not_reached ();\n\t\t}\n\t\tlogger = soup_logger_new (level, -1);\n\t\tsoup_logger_set_printer (logger, (SoupLoggerPrinter) soup_log_printer, NULL, NULL);\n\t\tsoup_session_add_feature (session, SOUP_SESSION_FEATURE (logger));\n\t\tg_object_unref (logger);\n\t}\n\treturn session;\n}", "target": 1}
{"code": "struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,\n\t\t\t\t struct udphdr *uh)\n{\n\tstruct udp_offload_priv *uo_priv;\n\tstruct sk_buff *p, **pp = NULL;\n\tstruct udphdr *uh2;\n\tunsigned int off = skb_gro_offset(skb);\n\tint flush = 1;\n\tif (NAPI_GRO_CB(skb)->udp_mark ||\n\t    (skb->ip_summed != CHECKSUM_PARTIAL &&\n\t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n\t     !NAPI_GRO_CB(skb)->csum_valid))\n\t\tgoto out;\n\tNAPI_GRO_CB(skb)->udp_mark = 1;\n\trcu_read_lock();\n\tuo_priv = rcu_dereference(udp_offload_base);\n\tfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\n\t\tif (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&\n\t\t    uo_priv->offload->port == uh->dest &&\n\t\t    uo_priv->offload->callbacks.gro_receive)\n\t\t\tgoto unflush;\n\t}\n\tgoto out_unlock;\nunflush:\n\tflush = 0;\n\tfor (p = *head; p; p = p->next) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\t\tuh2 = (struct udphdr   *)(p->data + off);\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||\n\t\t    (!uh->check ^ !uh2->check)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tskb_gro_pull(skb, sizeof(struct udphdr)); \n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tNAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;\n\tpp = uo_priv->offload->callbacks.gro_receive(head, skb,\n\t\t\t\t\t\t     uo_priv->offload);\nout_unlock:\n\trcu_read_unlock();\nout:\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\treturn pp;\n}", "target": 1}
{"code": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "int qcow2_snapshot_load_tmp(BlockDriverState *bs,\n                            const char *snapshot_id,\n                            const char *name,\n                            Error **errp)\n{\n    int i, snapshot_index;\n    BDRVQcowState *s = bs->opaque;\n    QCowSnapshot *sn;\n    uint64_t *new_l1_table;\n    int new_l1_bytes;\n    int ret;\n    assert(bs->read_only);\n    snapshot_index = find_snapshot_by_id_and_name(bs, snapshot_id, name);\n    if (snapshot_index < 0) {\n        error_setg(errp,\n                   \"Can't find snapshot\");\n        return -ENOENT;\n    }\n     sn = &s->snapshots[snapshot_index];\n    new_l1_bytes = s->l1_size * sizeof(uint64_t);\n     new_l1_table = g_malloc0(align_offset(new_l1_bytes, 512));\n     ret = bdrv_pread(bs->file, sn->l1_table_offset, new_l1_table, new_l1_bytes);\n    if (ret < 0) {\n        error_setg(errp, \"Failed to read l1 table for snapshot\");\n        g_free(new_l1_table);\n        return ret;\n    }\n    g_free(s->l1_table);\n    s->l1_size = sn->l1_size;\n    s->l1_table_offset = sn->l1_table_offset;\n    s->l1_table = new_l1_table;\n    for(i = 0;i < s->l1_size; i++) {\n        be64_to_cpus(&s->l1_table[i]);\n    }\n    return 0;\n}", "target": 1}
{"code": "static int ReadHuffmanCodeLengths(\n    VP8LDecoder* const dec, const int* const code_length_code_lengths,\n    int num_symbols, int* const code_lengths) {\n  int ok = 0;\n  VP8LBitReader* const br = &dec->br_;\n  int symbol;\n  int max_symbol;\n  int prev_code_len = DEFAULT_CODE_LENGTH;\n  HuffmanCode table[1 << LENGTHS_TABLE_BITS];\n  if (!VP8LBuildHuffmanTable(table, LENGTHS_TABLE_BITS,\n                             code_length_code_lengths,\n                             NUM_CODE_LENGTH_CODES)) {\n    goto End;\n  }\n  if (VP8LReadBits(br, 1)) {    \n    const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);\n    max_symbol = 2 + VP8LReadBits(br, length_nbits);\n    if (max_symbol > num_symbols) {\n      goto End;\n    }\n  } else {\n    max_symbol = num_symbols;\n  }\n  symbol = 0;\n  while (symbol < num_symbols) {\n    const HuffmanCode* p;\n    int code_len;\n    if (max_symbol-- == 0) break;\n    VP8LFillBitWindow(br);\n    p = &table[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];\n    VP8LSetBitPos(br, br->bit_pos_ + p->bits);\n    code_len = p->value;\n    if (code_len < kCodeLengthLiterals) {\n      code_lengths[symbol++] = code_len;\n      if (code_len != 0) prev_code_len = code_len;\n    } else {\n      const int use_prev = (code_len == kCodeLengthRepeatCode);\n      const int slot = code_len - kCodeLengthLiterals;\n      const int extra_bits = kCodeLengthExtraBits[slot];\n      const int repeat_offset = kCodeLengthRepeatOffsets[slot];\n      int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;\n      if (symbol + repeat > num_symbols) {\n        goto End;\n      } else {\n        const int length = use_prev ? prev_code_len : 0;\n        while (repeat-- > 0) code_lengths[symbol++] = length;\n      }\n    }\n  }\n  ok = 1;\n End:\n  if (!ok) return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  return ok;\n}", "target": 1}
{"code": "static void do_change_user(FILE *fin, FILE *fout) {\n  std::string uname;\n  lwp_read(fin, uname);\n  if (uname.length() > 0) {\n    struct passwd *pw = getpwnam(uname.c_str());\n    if (pw) {\n      if (pw->pw_gid) {\n        setgid(pw->pw_gid);\n      }\n      if (pw->pw_uid) {\n        setuid(pw->pw_uid);\n      }\n    }\n  }\n}", "target": 1}
{"code": "snmp_ber_decode_unsigned_integer(unsigned char *buf, uint32_t *buff_len, uint8_t expected_type, uint32_t *num)\n{\n  uint8_t i, len, type;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != expected_type) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL || len > 4) {\n    return NULL;\n  }\n  if(*buff_len < len) {\n    return NULL;\n  }\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n  return buf;\n}", "target": 1}
{"code": "void ArthurOutputDev::drawImage(GfxState *state, Object *ref, Stream *str,\n\t\t\t\tint width, int height,\n\t\t\t\tGfxImageColorMap *colorMap,\n\t\t\t\tint *maskColors, GBool inlineImg)\n{\n  unsigned char *buffer;\n  unsigned int *dest;\n  int x, y;\n  ImageStream *imgStr;\n  Guchar *pix;\n  int i;\n  double *ctm;\n   QMatrix matrix;\n   int is_identity_transform;\n  buffer = (unsigned char *)gmalloc (width * height * 4);\n   imgStr = new ImageStream(str, width,\n\t\t\t   colorMap->getNumPixelComps(),\n\t\t\t   colorMap->getBits());\n  imgStr->reset();\n  is_identity_transform = colorMap->getColorSpace()->getMode() == csDeviceRGB ||\n\t\t  (colorMap->getColorSpace()->getMode() == csICCBased && \n\t\t  ((GfxICCBasedColorSpace*)colorMap->getColorSpace())->getAlt()->getMode() == csDeviceRGB);\n  if (maskColors) {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n      for (x = 0; x < width; x++) {\n\tfor (i = 0; i < colorMap->getNumPixelComps(); ++i) {\n\t  if (pix[i] < maskColors[2*i] * 255||\n\t      pix[i] > maskColors[2*i+1] * 255) {\n\t    *dest = *dest | 0xff000000;\n\t    break;\n\t  }\n\t}\n\tpix += colorMap->getNumPixelComps();\n\tdest++;\n      }\n    }\n    m_image = new QImage(buffer, width, height, QImage::Format_ARGB32);\n  }\n  else {\n    for (y = 0; y < height; y++) {\n      dest = (unsigned int *) (buffer + y * 4 * width);\n      pix = imgStr->getLine();\n      colorMap->getRGBLine (pix, dest, width);\n    }\n    m_image = new QImage(buffer, width, height, QImage::Format_RGB32);\n  }\n  if (m_image == NULL || m_image->isNull()) {\n    qDebug() << \"Null image\";\n    delete imgStr;\n    return;\n  }\n  ctm = state->getCTM();\n  matrix.setMatrix(ctm[0] / width, ctm[1] / width, -ctm[2] / height, -ctm[3] / height, ctm[2] + ctm[4], ctm[3] + ctm[5]);\n  m_painter->setMatrix(matrix, true);\n  m_painter->drawImage( QPoint(0,0), *m_image );\n  delete m_image;\n  m_image = 0;\n  free (buffer);\n  delete imgStr;\n}", "target": 1}
{"code": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tut8 *directory_base;\n\tstruct minidump_directory *entry;\n\tdirectory_base = obj->b->buf + obj->hdr->stream_directory_rva;\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tentry = (struct minidump_directory *)(directory_base + (i * sizeof (struct minidump_directory)));\n\t\tr_bin_mdmp_init_directory_entry (obj, entry);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "R_API int r_egg_compile(REgg *egg) {\n\tr_buf_seek (egg->src, 0, R_BUF_SET);\n\tchar b;\n\tint r = r_buf_read (egg->src, (ut8 *)&b, sizeof (b));\n\tif (r != sizeof (b) || !egg->remit) {\n\t\treturn true;\n\t}\n\tr_egg_lang_init (egg);\n\tfor (; b; ) {\n\t\tr_egg_lang_parsechar (egg, b);\n\t\tint r = r_buf_read (egg->src, (ut8 *)&b, sizeof (b));\n\t\tif (r != sizeof (b)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (egg->context>0) {\n\t\teprintf (\"ERROR: expected '}' at the end of the file. %d left\\n\", egg->context);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "ReadNextFunctionHandle(mat_t *mat, matvar_t *matvar)\n{\n    int err;\n    size_t nelems = 1;\n    err = Mat_MulDims(matvar, &nelems);\n    matvar->data_size = sizeof(matvar_t *);\n    err |= Mul(&matvar->nbytes, nelems, matvar->data_size);\n    if ( err )\n        return 0;\n    matvar->data = malloc(matvar->nbytes);\n    if ( matvar->data != NULL ) {\n        size_t i;\n        matvar_t **functions = (matvar_t **)matvar->data;\n        for ( i = 0; i < nelems; i++ ) {\n            functions[i] = Mat_VarReadNextInfo(mat);\n            err = NULL == functions[i];\n            if ( err )\n                break;\n        }\n        if ( err ) {\n            free(matvar->data);\n            matvar->data = NULL;\n            matvar->data_size = 0;\n            matvar->nbytes = 0;\n        }\n    } else {\n        matvar->data_size = 0;\n        matvar->nbytes = 0;\n    }\n    return 0;\n}", "target": 1}
{"code": " void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {\n     uint32_t size = data.readInt32();\n    vector.insertAt((size_t)0, size);\n    data.read(vector.editArray(), size);\n }", "target": 1}
{"code": "_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n    if (!pdu)\n        return NULL;\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n    if (pdu->securityStateRef &&\n        pdu->command == SNMP_MSG_TRAP2) {\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,\n                (struct usmStateReference **) &newpdu->securityStateRef );\n        if (ret)\n        {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&\n        sptr->pdu_clone != NULL) {\n        (*sptr->pdu_clone) (pdu, newpdu);\n    }\n    return newpdu;\n}", "target": 1}
{"code": "PHP_FUNCTION(oci_lob_load)\n{\n\tzval **tmp, *z_descriptor = getThis();\n\tphp_oci_descriptor *descriptor;\n\tchar *buffer = NULL;\n\tub4 buffer_len;\n\tif (!getThis()) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"O\", &z_descriptor, oci_lob_class_entry_ptr) == FAILURE) {\n\t\t\treturn;\n\t\t}\t\n\t}\n\tif (strlen(filename) != filename_len) {\n\t\tRETURN_FALSE;\n\t}\n\tif (zend_hash_find(Z_OBJPROP_P(z_descriptor), \"descriptor\", sizeof(\"descriptor\"), (void **)&tmp) == FAILURE) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to find descriptor property\");\n\t\tRETURN_FALSE;\n\t}\n\tPHP_OCI_ZVAL_TO_DESCRIPTOR(*tmp, descriptor);\n\tif (php_oci_lob_read(descriptor, -1, 0, &buffer, &buffer_len TSRMLS_CC)) {\n\t\tRETURN_FALSE;\n\t}\n\tif (buffer_len > 0) {\n\t\tRETURN_STRINGL(buffer, buffer_len, 0);\n\t}\n\telse {\n\t\tRETURN_EMPTY_STRING();\n\t}\n}", "target": 1}
{"code": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n {\tsf_count_t total = 0 ;\n \tssize_t\tcount ;\n \tif (psf->virtual_io)\n \t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\titems *= bytes ;\n\tif (items <= 0)\n\t\treturn 0 ;\n\twhile (items > 0)\n\t{\t\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\t\tif (count == 0)\n\t\t\tbreak ;\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\treturn total / bytes ;\n} ", "target": 1}
{"code": "static int sclp_ctl_ioctl_sccb(void __user *user_area)\n{\n\tstruct sclp_ctl_sccb ctl_sccb;\n\tstruct sccb_header *sccb;\n\tint rc;\n\tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}", "target": 1}
{"code": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n\t\t\t     unsigned char __user *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}", "target": 1}
{"code": "alloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr, \n             \"%s: Maximum allocation size exceeded \"\n             \"(maxsize = %lu; size = %lu).\\n\",\n             fn_name,\n             (unsigned long)alloc_limit, \n             (unsigned long)size);\n}", "target": 1}
{"code": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n}", "target": 1}
{"code": "AcpiNsTerminate (\n     void)\n {\n     ACPI_STATUS             Status;\n     ACPI_FUNCTION_TRACE (NsTerminate);\n#ifdef ACPI_EXEC_APP\n    {\n        ACPI_OPERAND_OBJECT     *Prev;\n        ACPI_OPERAND_OBJECT     *Next;\n        Next = AcpiGbl_ModuleCodeList;\n        while (Next)\n        {\n            Prev = Next;\n            Next = Next->Method.Mutex;\n            Prev->Method.Mutex = NULL; \n            AcpiUtRemoveReference (Prev);\n        }\n     }\n#endif\n    AcpiNsDeleteNamespaceSubtree (AcpiGbl_RootNode);\n    Status = AcpiUtAcquireMutex (ACPI_MTX_NAMESPACE);\n    if (ACPI_FAILURE (Status))\n    {\n        return_VOID;\n    }\n    AcpiNsDeleteNode (AcpiGbl_RootNode);\n    (void) AcpiUtReleaseMutex (ACPI_MTX_NAMESPACE);\n    ACPI_DEBUG_PRINT ((ACPI_DB_INFO, \"Namespace freed\\n\"));\n    return_VOID;\n}", "target": 1}
{"code": "tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "void Splash::scaleMaskYdXu(SplashImageMaskSource src, void *srcData,\n\t\t\t   int srcWidth, int srcHeight,\n\t\t\t   int scaledWidth, int scaledHeight,\n\t\t\t   SplashBitmap *dest) {\n  Guchar *lineBuf;\n  Guint *pixBuf;\n  Guint pix;\n  Guchar *destPtr;\n  int yp, yq, xp, xq, yt, y, yStep, xt, x, xStep, d;\n  int i, j;\n  yp = srcHeight / scaledHeight;\n  yq = srcHeight % scaledHeight;\n  xp = scaledWidth / srcWidth;\n  xq = scaledWidth % srcWidth;\n  lineBuf = (Guchar *)gmalloc(srcWidth);\n  pixBuf = (Guint *)gmallocn(srcWidth, sizeof(int));\n  yt = 0;\n  destPtr = dest->data;\n  for (y = 0; y < scaledHeight; ++y) {\n    if ((yt += yq) >= scaledHeight) {\n      yt -= scaledHeight;\n      yStep = yp + 1;\n    } else {\n      yStep = yp;\n    }\n    memset(pixBuf, 0, srcWidth * sizeof(int));\n    for (i = 0; i < yStep; ++i) {\n      (*src)(srcData, lineBuf);\n      for (j = 0; j < srcWidth; ++j) {\n\tpixBuf[j] += lineBuf[j];\n      }\n    }\n    xt = 0;\n    d = (255 << 23) / yStep;\n    for (x = 0; x < srcWidth; ++x) {\n      if ((xt += xq) >= srcWidth) {\n\txt -= srcWidth;\n\txStep = xp + 1;\n      } else {\n\txStep = xp;\n      }\n      pix = pixBuf[x];\n      pix = (pix * d) >> 23;\n      for (i = 0; i < xStep; ++i) {\n\t*destPtr++ = (Guchar)pix;\n      }\n    }\n  }\n  gfree(pixBuf);\n  gfree(lineBuf);\n}", "target": 1}
{"code": "static int __init serial_ir_init_module(void)\n{\n\tint result;\n\tswitch (type) {\n\tcase IR_HOMEBREW:\n\tcase IR_IRDEO:\n\tcase IR_IRDEO_REMOTE:\n\tcase IR_ANIMAX:\n\tcase IR_IGOR:\n\t\tio = io ? io : 0x3f8;\n\t\tirq = irq ? irq : 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (!softcarrier) {\n\t\tswitch (type) {\n\t\tcase IR_HOMEBREW:\n\t\tcase IR_IGOR:\n\t\t\thardware[type].set_send_carrier = false;\n\t\t\thardware[type].set_duty_cycle = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (sense != -1)\n\t\tsense = !!sense;\n\tresult = serial_ir_init();\n\tif (!result)\n\t\treturn 0;\n\tserial_ir_exit();\n\treturn result;\n}", "target": 1}
{"code": "udisks_log (UDisksLogLevel     level,\n            const gchar       *function,\n            const gchar       *location,\n            const gchar       *format,\n            ...)\n{\n  va_list var_args;\n  gchar *message;\n  va_start (var_args, format);\n  message = g_strdup_vprintf (format, var_args);\n  va_end (var_args);\n#if GLIB_CHECK_VERSION(2, 50, 0)\n  g_log_structured (\"udisks\", (GLogLevelFlags) level,\n                    \"MESSAGE\", message, \"THREAD_ID\", \"%d\", (gint) syscall (SYS_gettid),\n                    \"CODE_FUNC\", function, \"CODE_FILE\", location);\n#else\n  g_log (\"udisks\", level, \"[%d]: %s [%s, %s()]\", (gint) syscall (SYS_gettid), message, location, function);\n#endif\n  g_free (message);\n}", "target": 1}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n\t    : \"rm\"(div), \"A\"(divs));\n\treturn dum2;\n}", "target": 1}
{"code": "raw_copy_from_user(void *to, const void __user *from, unsigned long n)\n{\n\tif (__builtin_constant_p(n)) {\n\t\tunsigned long ret;\n\t\tswitch (n) {\n\t\tcase 1:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u8 *)to, from, ret,\n\t\t\t\t\t      \"b\", \"b\", \"=q\", 1);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\tcase 2:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u16 *)to, from, ret,\n\t\t\t\t\t      \"w\", \"w\", \"=r\", 2);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\tcase 4:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u32 *)to, from, ret,\n\t\t\t\t\t      \"l\", \"k\", \"=r\", 4);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn __copy_user_ll(to, (__force const void *)from, n);\n}", "target": 1}
{"code": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n#ifdef SO_NOSIGPIPE\n\tif (setsockopt(sfd, SOL_SOCKET, SO_NOSIGPIPE, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n#endif\n \tmemset((void *) &saddr, 0, sizeof(saddr));\n \tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n \tsaddr.sin_port = htons(port);\n \tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\treturn sfd;\n}", "target": 1}
{"code": "static void add_offer_options(uint8_t *option_start_address)\n{\n\tuint8_t *temp_option_addr;\n\ttemp_option_addr = fill_one_option_content(option_start_address,\n\t\t\tDHCP_OPTION_CODE_SUBNET_MASK, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_mask);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_ROUTER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_address);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_DNS_SERVER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_address);\t\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_LEASE_TIME, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcp_option_lease_time);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_SERVER_ID, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&dhcps_local_address);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_BROADCAST_ADDRESS, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&dhcps_subnet_broadcast);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_INTERFACE_MTU, DHCP_OPTION_LENGTH_TWO,\n\t\t\t\t\t(void *) &dhcp_option_interface_mtu);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY, DHCP_OPTION_LENGTH_ONE,\n\t\t\t\t\t\t\t\tNULL);\n\t*temp_option_addr++ = DHCP_OPTION_CODE_END;\n}", "target": 1}
{"code": "static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;\n\tstruct netdev_notifier_info info;\n\tnetdev_notifier_info_init(&info, dev);\n\treturn masq_device_event(this, event, &info);\n}", "target": 1}
{"code": "      JpegInput( String filename ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); \n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               if( infile_ == nullptr ) {\n                  filename_ = FileAddExtension( filename_, \"jpeg\" ); \n                  infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               }\n            }\n         }\n         if( infile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            DIP_THROW_RUNTIME( \"Error reading JPEG file.\" );\n         }\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }", "target": 1}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext *ctx = inlink->dst;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    uint32_t plane_checksum[4] = {0}, checksum = 0;\n    int i, plane, vsub = desc->log2_chroma_h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int64_t linesize = av_image_get_linesize(frame->format, frame->width, plane);\n        uint8_t *data = frame->data[plane];\n        int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink->h, vsub) : inlink->h;\n        if (linesize < 0)\n            return linesize;\n        for (i = 0; i < h; i++) {\n            plane_checksum[plane] = av_adler32_update(plane_checksum[plane], data, linesize);\n            checksum = av_adler32_update(checksum, data, linesize);\n            data += frame->linesize[plane];\n        }\n    }\n    av_log(ctx, AV_LOG_INFO,\n           \"n:%\"PRId64\" pts:%s pts_time:%s pos:%\"PRId64\" \"\n           \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \"\n           \"checksum:%08X plane_checksum:[%08X\",\n           inlink->frame_count,\n           av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base), av_frame_get_pkt_pos(frame),\n           desc->name,\n           frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den,\n           frame->width, frame->height,\n           !frame->interlaced_frame ? 'P' :         \n           frame->top_field_first   ? 'T' : 'B',    \n           frame->key_frame,\n           av_get_picture_type_char(frame->pict_type),\n           checksum, plane_checksum[0]);\n    for (plane = 1; plane < 4 && frame->data[plane]; plane++)\n        av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);\n    av_log(ctx, AV_LOG_INFO, \"]\\n\");\n    return ff_filter_frame(inlink->dst->outputs[0], frame);\n}", "target": 1}
{"code": "  RectangleRequest &operator=(const struct RectangleRequest &req)\n  { \n    memcpy(this,&req,sizeof(struct RectangleRequest));\n    rr_pNext = NULL;\n    return *this;\n  }", "target": 1}
{"code": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}", "target": 1}
{"code": "static int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym, wordsize;\n\tut32 stype;\n\twordsize = MACH0_(get_bits)(bin) / 8;\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case (T / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return false;\n\t}\n#undef CASE\n \tfor (i = 0; i < bin->nsects; i++) {\n \t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n \t\t\t\t\tsym = j;\n \t\t\t\t\tbreak;\n \t\t\t\t}\n \t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n \t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n \t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "OFCondition WlmActivityManager::StartProvidingService()\n{\n  OFCondition cond = EC_Normal;\n  T_ASC_Network *net = NULL;\n  if( !dcmDataDict.isDictionaryLoaded() )\n  {\n    DCMWLM_WARN(\"no data dictionary loaded, check environment variable: \" << DCM_DICT_ENVIRONMENT_VARIABLE);\n  }\n#ifndef DISABLE_PORT_PERMISSION_CHECK\n#ifdef HAVE_GETEUID\n  if( opt_port < 1024 && geteuid() != 0 )\n    return( WLM_EC_InsufficientPortPrivileges );\n#endif\n#endif\n#ifdef _WIN32\n  if (opt_forkedChild)\n  {\n    DUL_markProcessAsForkedChild();\n    char buf[256];\n    DWORD bytesRead = 0;\n    HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);\n    if (ReadFile(hStdIn, buf, sizeof(buf), &bytesRead, NULL))\n    {\n      buf[bytesRead] = '\\0';\n        dcmExternalSocketHandle.set(atoi(buf));\n    }\n    else\n    {\n      DCMWLM_ERROR(\"cannot read socket handle: \" << GetLastError());\n      exit(0);\n    }\n  }\n  else\n  {\n    if (!opt_singleProcess)\n      DUL_requestForkOnTransportConnectionReceipt(cmd_argc, cmd_argv);\n  }\n#endif\n  cond = ASC_initializeNetwork( NET_ACCEPTOR, OFstatic_cast(int, opt_port), opt_acse_timeout, &net );\n  if( cond.bad() ) return( WLM_EC_InitializationOfNetworkConnectionFailed );\n#if defined(HAVE_SETUID) && defined(HAVE_GETUID)\n  setuid( getuid() );\n#endif\n  while( cond.good() )\n  {\n    cond = WaitForAssociation( net );\n#ifdef HAVE_FORK\n    if( !opt_singleProcess )\n      CleanChildren();\n#elif defined(_WIN32)\n    if (DUL_processIsForkedChild()) break;\n#endif\n  }\n  cond = ASC_dropNetwork( &net );\n  if( cond.bad() ) return( WLM_EC_TerminationOfNetworkConnectionFailed );\n  return( EC_Normal );\n}", "target": 1}
{"code": "void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n    header = get_header(fp);\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n    free(header);\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* input,\n                                 const TfLiteTensor* size_splits,\n                                 const TfLiteTensor* axis) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  std::vector<int64_t> size_splits_vector;\n  if (size_splits->type == kTfLiteInt32) {\n    GetSizeSplitsVector<int32_t>(size_splits, &size_splits_vector);\n  } else if (size_splits->type == kTfLiteInt64) {\n    GetSizeSplitsVector<int64_t>(size_splits, &size_splits_vector);\n  } else {\n    context->ReportError(context, \"size_splits only support type int32|int64.\");\n    return kTfLiteError;\n  }\n  int minus_one_index = -1;\n  int64_t size_splits_sum = 0;\n  for (int i = 0; i < size_splits_vector.size(); ++i) {\n    if (size_splits_vector.at(i) == -1) {\n      if (minus_one_index == -1) {\n        minus_one_index = i;\n      } else {\n        context->ReportError(context,\n                             \"The size_splits contains more than one -1.\");\n      }\n    } else {\n      size_splits_sum += size_splits_vector.at(i);\n    }\n  }\n  const int input_size = SizeOfDimension(input, axis_value);\n  if (minus_one_index != -1) {\n    if (size_splits_sum > input_size) {\n      context->ReportError(\n          context,\n          \"The sum of size_splits must be less than the dimension of value.\");\n    } else {\n      size_splits_vector[minus_one_index] = input_size - size_splits_sum;\n    }\n  } else if (size_splits_sum != input_size) {\n    context->ReportError(\n        context,\n        \"The size_splits must sum to the dimension of value along axis.\");\n  }\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = size_splits_vector.at(i);\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "mrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb_free(mrb, p);\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n  return p2;\n}", "target": 1}
{"code": "SProcXIBarrierReleasePointer(ClientPtr client)\n{\n    xXIBarrierReleasePointerInfo *info;\n    REQUEST(xXIBarrierReleasePointerReq);\n    int i;\n    swaps(&stuff->length);\n     REQUEST_AT_LEAST_SIZE(xXIBarrierReleasePointerReq);\n     swapl(&stuff->num_barriers);\n     REQUEST_FIXED_SIZE(xXIBarrierReleasePointerReq, stuff->num_barriers * sizeof(xXIBarrierReleasePointerInfo));\n     info = (xXIBarrierReleasePointerInfo*) &stuff[1];\n        swapl(&info->barrier);\n        swapl(&info->eventid);\n    }", "target": 1}
{"code": "void auth_policy_create_json(struct policy_lookup_ctx *context,\n\tconst char *password, bool include_success)\n{\n\tconst struct var_expand_table *var_table;\n\tcontext->json = str_new(context->pool, 64);\n\tunsigned char *ptr;\n\tconst struct hash_method *digest = hash_method_lookup(context->set->policy_hash_mech);\n\ti_assert(digest != NULL);\n\tvoid *ctx = t_malloc(digest->context_size);\n\tstring_t *buffer = t_str_new(64);\n\tdigest->init(ctx);\n\tdigest->loop(ctx,\n\t\tcontext->set->policy_hash_nonce,\n\t\tstrlen(context->set->policy_hash_nonce));\n\tdigest->loop(ctx, context->request->user, strlen(context->request->user) + 1);\n\tif (password != NULL)\n\t\tdigest->loop(ctx, password, strlen(password));\n\tptr = (unsigned char*)str_c_modifiable(buffer);\n\tdigest->result(ctx, ptr);\n\tstr_truncate(buffer, digest->digest_size);\n\tif (context->set->policy_hash_truncate > 0) {\n\t\tbuffer_truncate_rshift_bits(buffer, context->set->policy_hash_truncate);\n\t}\n\tconst char *hashed_password = binary_to_hex(str_data(buffer), str_len(buffer));\n\tstr_append_c(context->json, '{');\n\tvar_table = policy_get_var_expand_table(context->request, hashed_password);\n\tauth_request_var_expand_with_table(context->json, auth_policy_json_template,\n\t\t\t\t\t   context->request, var_table,\n\t\t\t\t\t   auth_policy_escape_function);\n\tif (include_success) {\n\t\tstr_append(context->json, \",\\\"success\\\":\");\n\t\tif (!context->request->failed && context->request->successful &&\n\t\t    !context->request->internal_failure)\n\t\t\tstr_append(context->json, \"true\");\n\t\telse\n\t\t\tstr_append(context->json, \"false\");\n\t\tstr_append(context->json, \",\\\"policy_reject\\\":\");\n\t\tstr_append(context->json, context->request->policy_refusal ? \"true\" : \"false\");\n\t}\n\tstr_append_c(context->json, '}');\n\tauth_request_log_debug(context->request, \"policy\",\n\t\t\"Policy server request JSON: %s\", str_c(context->json));\n}", "target": 1}
{"code": "Status CompressElement(const std::vector<Tensor>& element,\n                       CompressedElement* out) {\n  std::vector<TensorProto> non_memcpy_components;\n  int64 total_size = 0;\n  for (auto& component : element) {\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      total_size += DMAHelper::buffer(&component)->size();\n    } else {\n      non_memcpy_components.emplace_back();\n      component.AsProtoTensorContent(&non_memcpy_components.back());\n      total_size += non_memcpy_components.back().ByteSizeLong();\n    }\n  }\n  tstring uncompressed;\n  uncompressed.resize_uninitialized(total_size);\n  char* position = uncompressed.mdata();\n  int non_memcpy_component_index = 0;\n  for (auto& component : element) {\n    CompressedComponentMetadata* metadata =\n        out->mutable_component_metadata()->Add();\n    metadata->set_dtype(component.dtype());\n    component.shape().AsProto(metadata->mutable_tensor_shape());\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      const TensorBuffer* buffer = DMAHelper::buffer(&component);\n      memcpy(position, buffer->data(), buffer->size());\n      metadata->set_tensor_size_bytes(buffer->size());\n    } else {\n      TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];\n      proto.SerializeToArray(position, proto.ByteSizeLong());\n      metadata->set_tensor_size_bytes(proto.ByteSizeLong());\n    }\n    position += metadata->tensor_size_bytes();\n  }\n  DCHECK_EQ(position, uncompressed.mdata() + total_size);\n  if (!port::Snappy_Compress(uncompressed.mdata(), total_size,\n                             out->mutable_data())) {\n    return errors::Internal(\"Failed to compress using snappy.\");\n  }\n  VLOG(3) << \"Compressed element from \" << total_size << \" bytes to \"\n          << out->data().size() << \" bytes\";\n  return Status::OK();\n}", "target": 1}
{"code": "static int __do_page_fault(struct mm_struct *mm, unsigned long addr,\n\t\t\t   unsigned int mm_flags, unsigned long vm_flags,\n\t\t\t   struct task_struct *tsk)\n{\n\tstruct vm_area_struct *vma;\n\tint fault;\n\tvma = find_vma(mm, addr);\n\tfault = VM_FAULT_BADMAP;\n\tif (unlikely(!vma))\n\t\tgoto out;\n\tif (unlikely(vma->vm_start > addr))\n\t\tgoto check_stack;\ngood_area:\n\tif (!(vma->vm_flags & vm_flags)) {\n\t\tfault = VM_FAULT_BADACCESS;\n\t\tgoto out;\n\t}\n\treturn handle_mm_fault(mm, vma, addr & PAGE_MASK, mm_flags);\ncheck_stack:\n\tif (vma->vm_flags & VM_GROWSDOWN && !expand_stack(vma, addr))\n\t\tgoto good_area;\nout:\n\treturn fault;\n}", "target": 1}
{"code": "X509_NAME_oneline_ex(X509_NAME * a,\n                     char *buf,\n                     unsigned int *size,\n                     unsigned long flag)\n{\n    BIO *out = NULL;\n    out = BIO_new(BIO_s_mem ());\n    if (X509_NAME_print_ex(out, a, 0, flag) > 0) {\n        if (buf != NULL && (*size) >  (unsigned int) BIO_number_written(out)) {\n            memset(buf, 0, *size);\n            BIO_read(out, buf, (int) BIO_number_written(out));\n        }\n        else {\n            *size = BIO_number_written(out);\n        }\n    }\n    BIO_free(out);\n    return (buf);\n}", "target": 1}
{"code": "function_call(int argc, VALUE argv[], VALUE self)\n{\n    ffi_cif * cif;\n    fiddle_generic retval;\n    fiddle_generic *generic_args;\n    void **values;\n    VALUE cfunc, types, cPointer;\n    int i;\n    cfunc    = rb_iv_get(self, \"@ptr\");\n    types    = rb_iv_get(self, \"@args\");\n    cPointer = rb_const_get(mFiddle, rb_intern(\"Pointer\"));\n    if(argc != RARRAY_LENINT(types)) {\n\trb_raise(rb_eArgError, \"wrong number of arguments (%d for %d)\",\n\t\targc, RARRAY_LENINT(types));\n    }\n    TypedData_Get_Struct(self, ffi_cif, &function_data_type, cif);\n    values = xcalloc((size_t)argc + 1, (size_t)sizeof(void *));\n    generic_args = xcalloc((size_t)argc, (size_t)sizeof(fiddle_generic));\n    for (i = 0; i < argc; i++) {\n\tVALUE type = RARRAY_PTR(types)[i];\n\tVALUE src = argv[i];\n\tif(NUM2INT(type) == TYPE_VOIDP) {\n\t    if(NIL_P(src)) {\n\t\tsrc = INT2FIX(0);\n\t    } else if(cPointer != CLASS_OF(src)) {\n\t\tsrc = rb_funcall(cPointer, rb_intern(\"[]\"), 1, src);\n\t    }\n\t    src = rb_Integer(src);\n\t}\n\tVALUE2GENERIC(NUM2INT(type), src, &generic_args[i]);\n\tvalues[i] = (void *)&generic_args[i];\n    }\n    values[argc] = NULL;\n    ffi_call(cif, NUM2PTR(rb_Integer(cfunc)), &retval, values);\n    rb_funcall(mFiddle, rb_intern(\"last_error=\"), 1, INT2NUM(errno));\n#if defined(_WIN32)\n    rb_funcall(mFiddle, rb_intern(\"win32_last_error=\"), 1, INT2NUM(errno));\n#endif\n    xfree(values);\n    xfree(generic_args);\n    return GENERIC2VALUE(rb_iv_get(self, \"@return_type\"), retval);\n}", "target": 1}
{"code": "static int ghash_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n \tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n \tu8 *buf = dctx->buffer;\n \tghash_flush(ctx, dctx);\n \tmemcpy(dst, buf, GHASH_BLOCK_SIZE);\n\treturn 0;\n}", "target": 1}
{"code": "static int adpt_i2o_activate_hba(adpt_hba* pHba)\n{\n\tint rcode;\n\tif(pHba->initialized ) {\n\t\tif (adpt_i2o_status_get(pHba) < 0) {\n\t\t\tif((rcode = adpt_i2o_reset_hba(pHba)) != 0){\n\t\t\t\tprintk(KERN_WARNING\"%s: Could NOT reset.\\n\", pHba->name);\n\t\t\t\treturn rcode;\n\t\t\t}\n\t\t\tif (adpt_i2o_status_get(pHba) < 0) {\n\t\t\t\tprintk(KERN_INFO \"HBA not responding.\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif(pHba->status_block->iop_state == ADAPTER_STATE_FAULTED) {\n\t\t\tprintk(KERN_CRIT \"%s: hardware fault\\n\", pHba->name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (pHba->status_block->iop_state == ADAPTER_STATE_READY ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_HOLD ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_FAILED) {\n\t\t\tadpt_i2o_reset_hba(pHba);\t\t\t\n\t\t\tif (adpt_i2o_status_get(pHba) < 0 || pHba->status_block->iop_state != ADAPTER_STATE_RESET) {\n\t\t\t\tprintk(KERN_ERR \"%s: Failed to initialize.\\n\", pHba->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif((rcode = adpt_i2o_reset_hba(pHba)) != 0){\n\t\t\tprintk(KERN_WARNING\"%s: Could NOT reset.\\n\", pHba->name);\n\t\t\treturn rcode;\n\t\t}\n\t}\n\tif (adpt_i2o_init_outbound_q(pHba) < 0) {\n\t\treturn -1;\n\t}\n\tif (adpt_i2o_hrt_get(pHba) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "hufUncompress (const char compressed[],\n\t       int nCompressed,\n\t       unsigned short raw[],\n\t       int nRaw)\n{\n    if (nCompressed < 20 )\n    {\n\tif (nRaw != 0)\n\t    notEnoughData();\n\treturn;\n    }\n    int im = readUInt (compressed);\n    int iM = readUInt (compressed + 4);\n    int nBits = readUInt (compressed + 12);\n    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)\n\tinvalidTableSize();\n    const char *ptr = compressed + 20;\n    if ( ptr + (nBits+7 )/8 > compressed+nCompressed)\n    {\n        notEnoughData();\n        return;\n    }\n    if (FastHufDecoder::enabled() && nBits > 128)\n    {\n        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);\n        fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);\n    }\n    else\n    {\n        AutoArray <Int64, HUF_ENCSIZE> freq;\n        AutoArray <HufDec, HUF_DECSIZE> hdec;\n        hufClearDecTable (hdec);\n        hufUnpackEncTable (&ptr,\n                           nCompressed - (ptr - compressed),\n                           im,\n                           iM,\n                           freq);\n        try\n        {\n            if (nBits > 8 * (nCompressed - (ptr - compressed)))\n                invalidNBits();\n            hufBuildDecTable (freq, im, iM, hdec);\n            hufDecode (freq, hdec, ptr, nBits, iM, nRaw, raw);\n        }\n        catch (...)\n        {\n            hufFreeDecTable (hdec);\n            throw;\n        }\n        hufFreeDecTable (hdec);\n    }\n}", "target": 1}
{"code": "static ssize_t clusterip_proc_write(struct file *file, const char __user *input,\n\t\t\t\tsize_t size, loff_t *ofs)\n{\n\tstruct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;\n#define PROC_WRITELEN\t10\n\tchar buffer[PROC_WRITELEN+1];\n\tunsigned long nodenum;\n\tif (copy_from_user(buffer, input, PROC_WRITELEN))\n\t\treturn -EFAULT;\n\tif (*buffer == '+') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL, 10);\n\t\tif (clusterip_add_node(c, nodenum))\n\t\t\treturn -ENOMEM;\n\t} else if (*buffer == '-') {\n\t\tnodenum = simple_strtoul(buffer+1, NULL,10);\n\t\tif (clusterip_del_node(c, nodenum))\n\t\t\treturn -ENOENT;\n\t} else\n\t\treturn -EIO;\n\treturn size;\n}", "target": 1}
{"code": "set_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\tumask_long = strtoll(optarg, &endptr, 0);\n \tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n \t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn;\n \t}\n \tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\tumask_cmdline = true;\n\treturn umask_val;\n}", "target": 1}
{"code": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j;\n    p = buff1;\n    i = ctm->length;\n    str = (char *)ctm->data;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n    } else {\n        if (i < 13)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n    }\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        if (*str == '.') {\n            str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n        }\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n    if (*str == 'Z')\n        offset = 0;\n    else {\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           \n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 \n        return -1;\n    else\n        return i;\n}", "target": 1}
{"code": "host_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member *m)\n{\n    struct alias *a;\n    int matched = UNSPEC;\n    debug_decl(host_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name, lhost, shost,\n\t\tdef_netgroup_tuple ? pw->pw_name : NULL))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NTWKADDR:\n\t    if (addr_matches(m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, HOSTALIAS);\n\t    if (a != NULL) {\n\t\tconst int rc = hostlist_matches_int(parse_tree, pw, lhost,\n\t\t    shost, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (hostname_matches(shost, lhost, m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    sudo_debug_printf(SUDO_DEBUG_DEBUG,\n\t\"host %s (%s) matches sudoers host %s%s: %s\", lhost, shost,\n\tm->negated ? \"!\" : \"\", m->name ? m->name : \"ALL\",\n\tmatched == true ? \"true\" : \"false\");\n    debug_return_int(matched);\n}", "target": 1}
{"code": "bool VaapiJpegDecoder::Initialize(const base::RepeatingClosure& error_uma_cb) {\n  vaapi_wrapper_ = VaapiWrapper::Create(VaapiWrapper::kDecode,\n                                        VAProfileJPEGBaseline, error_uma_cb);\n  if (!vaapi_wrapper_) {\n    VLOGF(1) << \"Failed initializing VAAPI\";\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "int ecall_restore(const char *input, uint64_t input_len, char **output,\n                  uint64_t *output_len) {\n  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,\n                                                              input_len)) {\n    asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"ecall_restore: input found to not be in untrusted memory.\");\n  }\n  int result = 0;\n  size_t tmp_output_len;\n  try {\n    result = asylo::Restore(input, static_cast<size_t>(input_len), output,\n                            &tmp_output_len);\n  } catch (...) {\n    LOG(FATAL) << \"Uncaught exception in enclave\";\n  }\n  if (output_len) {\n    *output_len = static_cast<uint64_t>(tmp_output_len);\n  }\n  return result;\n}", "target": 1}
{"code": "static MagickPixelPacket **AcquirePixelThreadSet(const Image *image)\n {\n   MagickPixelPacket\n     **pixels;\n  register ssize_t\n    i,\n     j;\n   size_t\n     number_threads;\n   number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(MagickPixelPacket **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n   if (pixels == (MagickPixelPacket **) NULL)\n     return((MagickPixelPacket **) NULL);\n   (void) memset(pixels,0,number_threads*sizeof(*pixels));\n   for (i=0; i < (ssize_t) number_threads; i++)\n   {\n    pixels[i]=(MagickPixelPacket *) AcquireQuantumMemory(image->columns,\n       sizeof(**pixels));\n     if (pixels[i] == (MagickPixelPacket *) NULL)\n       return(DestroyPixelThreadSet(pixels));\n    for (j=0; j < (ssize_t) image->columns; j++)\n      GetMagickPixelPacket(image,&pixels[i][j]);\n   }\n   return(pixels);\n }", "target": 1}
{"code": "  Status ValidateInputsGenerateOutputs(\n      OpKernelContext* ctx, const Tensor** inputs, const Tensor** seq_len,\n      Tensor** log_prob, OpOutputList* decoded_indices,\n      OpOutputList* decoded_values, OpOutputList* decoded_shape) const {\n    Status status = ctx->input(\"inputs\", inputs);\n    if (!status.ok()) return status;\n    status = ctx->input(\"sequence_length\", seq_len);\n    if (!status.ok()) return status;\n    const TensorShape& inputs_shape = (*inputs)->shape();\n    if (inputs_shape.dims() != 3) {\n      return errors::InvalidArgument(\"inputs is not a 3-Tensor\");\n    }\n    const int64 max_time = inputs_shape.dim_size(0);\n    const int64 batch_size = inputs_shape.dim_size(1);\n    if (max_time == 0) {\n      return errors::InvalidArgument(\"max_time is 0\");\n    }\n    if (!TensorShapeUtils::IsVector((*seq_len)->shape())) {\n      return errors::InvalidArgument(\"sequence_length is not a vector\");\n    }\n    if (!(batch_size == (*seq_len)->dim_size(0))) {\n      return errors::FailedPrecondition(\n          \"len(sequence_length) != batch_size.  \",\n          \"len(sequence_length):  \", (*seq_len)->dim_size(0),\n          \" batch_size: \", batch_size);\n    }\n    auto seq_len_t = (*seq_len)->vec<int32>();\n    for (int b = 0; b < batch_size; ++b) {\n      if (!(seq_len_t(b) <= max_time)) {\n        return errors::FailedPrecondition(\"sequence_length(\", b,\n                                          \") <= \", max_time);\n      }\n    }\n    Status s = ctx->allocate_output(\n        \"log_probability\", TensorShape({batch_size, top_paths_}), log_prob);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_indices\", decoded_indices);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_values\", decoded_values);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_shape\", decoded_shape);\n    if (!s.ok()) return s;\n    return Status::OK();\n  }", "target": 1}
{"code": "gnutls_session_get_data (gnutls_session_t session,\n                         void *session_data, size_t * session_data_size)\n{\n  gnutls_datum_t psession;\n  int ret;\n  if (session->internals.resumable == RESUME_FALSE)\n    return GNUTLS_E_INVALID_SESSION;\n  psession.data = session_data;\n  ret = _gnutls_session_pack (session, &psession);\n  if (ret < 0)\n    {\n      gnutls_assert ();\n      return ret;\n    }\n   if (psession.size > *session_data_size)\n     {\n       ret = GNUTLS_E_SHORT_MEMORY_BUFFER;\n       goto error;\n     }\n  if (session_data != NULL)\n    memcpy (session_data, psession.data, psession.size);\n  ret = 0;\nerror:\n  _gnutls_free_datum (&psession);\n  return ret;\n}", "target": 1}
{"code": "static int _dns_encode_HTTPS(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tchar target[DNS_MAX_CNAME_LEN] = {0};\n\tunsigned char *rr_len_ptr = NULL;\n\tunsigned char *start = NULL;\n\tunsigned char *rr_start = NULL;\n\tint ttl = 0;\n\tint priority = 0;\n\tstruct dns_https_param *param = NULL;\n\tparam = dns_get_HTTPS_svcparm_start(rrs, domain, DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);\n\tif (param == NULL) {\n\t\ttlog(TLOG_ERROR, \"get https param failed.\");\n\t\treturn -1;\n\t}\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, 0, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\trr_start = context->ptr;\n\tif (_dns_left_len(context) < 2) {\n\t\ttlog(TLOG_ERROR, \"left len is invalid.\");\n\t\treturn -1;\n\t}\n\t_dns_write_short(&context->ptr, priority);\n\tret = _dns_encode_domain(context, target);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\tstart = context->ptr;\n\tfor (; param != NULL; param = dns_get_HTTPS_svcparm_next(rrs, param)) {\n\t\tif (context->ptr - start > rrs->len || _dns_left_len(context) <= 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t_dns_write_short(&context->ptr, param->key);\n\t\t_dns_write_short(&context->ptr, param->len);\n\t\tswitch (param->key) {\n\t\tcase DNS_HTTPS_T_MANDATORY:\n\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN:\n\t\tcase DNS_HTTPS_T_ALPN:\n\t\tcase DNS_HTTPS_T_PORT:\n\t\tcase DNS_HTTPS_T_IPV4HINT:\n\t\tcase DNS_HTTPS_T_ECH:\n\t\tcase DNS_HTTPS_T_IPV6HINT: {\n\t\t\tmemcpy(context->ptr, param->value, param->len);\n\t\t\tcontext->ptr += param->len;\n\t\t} break;\n\t\tdefault:\n\t\t\tcontext->ptr -= 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\t_dns_write_short(&rr_len_ptr, context->ptr - rr_start);\n\treturn 0;\n}", "target": 1}
{"code": "static inline int hpel_motion(MpegEncContext *s,\n                              uint8_t *dest, uint8_t *src,\n                              int src_x, int src_y,\n                              op_pixels_func *pix_op,\n                              int motion_x, int motion_y)\n{\n    int dxy = 0;\n    int emu = 0;\n    src_x += motion_x >> 1;\n    src_y += motion_y >> 1;\n    src_x = av_clip(src_x, -16, s->width); \n    if (src_x != s->width)\n        dxy |= motion_x & 1;\n    src_y = av_clip(src_y, -16, s->height);\n    if (src_y != s->height)\n         dxy |= (motion_y & 1) << 1;\n     src += src_y * s->linesize + src_x;\n    if (s->unrestricted_mv) {\n        if ((unsigned)src_x > FFMAX(s->h_edge_pos - (motion_x & 1) - 8, 0) ||\n            (unsigned)src_y > FFMAX(s->v_edge_pos - (motion_y & 1) - 8, 0)) {\n            s->vdsp.emulated_edge_mc(s->sc.edge_emu_buffer, src,\n                                     s->linesize, s->linesize,\n                                     9, 9,\n                                     src_x, src_y, s->h_edge_pos,\n                                     s->v_edge_pos);\n            src = s->sc.edge_emu_buffer;\n            emu = 1;\n        }\n     }\n     pix_op[dxy](dest, src, s->linesize, 8);\n     return emu;\n    }", "target": 1}
{"code": "bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),\n\t\t\t\tSERVICE_ALL_ACCESS,\t\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\tSERVICE_AUTO_START,\t\n\t\t\t\tSERVICE_ERROR_NORMAL,\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr );\t\t\t\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\t\treturn false;\n\t}\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\treturn true;\n}", "target": 1}
{"code": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}", "target": 1}
{"code": "get_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page;\n\tstruct address_space *mapping;\n\tint err, ro = 0;\n\tkey->both.offset = address % PAGE_SIZE;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -EINVAL;\n\taddress -= key->both.offset;\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -EFAULT;\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  \n\t\treturn 0;\n\t}\nagain:\n\tif (unlikely(should_fail_futex(fshared)))\n\t\treturn -EFAULT;\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\tif (err == -EFAULT && rw == VERIFY_READ) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\tlock_page(page);\n\tmapping = compound_head(page)->mapping;\n\tif (!mapping) {\n\t\tint shmem_swizzled = PageSwapCache(page);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\t\treturn -EFAULT;\n\t}\n\tif (PageAnon(page)) {\n\t\tif (unlikely(should_fail_futex(fshared)) || ro) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkey->both.offset |= FUT_OFF_MMSHARED; \n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t} else {\n\t\tkey->both.offset |= FUT_OFF_INODE; \n\t\tkey->shared.inode = mapping->host;\n\t\tkey->shared.pgoff = basepage_index(page);\n\t}\n\tget_futex_key_refs(key); \nout:\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}", "target": 1}
{"code": "static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,\n\t\t       struct in6_addr *addr, uint32_t *ifindex)\n{\n\tstruct sockaddr_in6 sin6;\n\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n\tstruct iovec iovec;\n\tstruct msghdr msghdr;\n\tstruct cmsghdr *cmsghdr;\n\tssize_t len;\n\tiovec.iov_len = *buflen;\n\tiovec.iov_base = buf;\n\tmemset(&msghdr, 0, sizeof(msghdr));\n\tmsghdr.msg_name = &sin6;\n\tmsghdr.msg_namelen = sizeof(sin6);\n\tmsghdr.msg_iov = &iovec;\n\tmsghdr.msg_iovlen = 1;\n\tmsghdr.msg_control = cbuf;\n\tmsghdr.msg_controllen = sizeof(cbuf);\n\tlen = recvmsg(sockfd, &msghdr, flags);\n\tif (len == -1)\n\t\treturn -errno;\n\t*buflen = len;\n\t*ifindex = sin6.sin6_scope_id;\n        for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;\n\t     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {\n\t\tif (cmsghdr->cmsg_level == IPPROTO_IPV6 &&\n\t\t    cmsghdr->cmsg_type == IPV6_PKTINFO &&\n\t\t    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\tstruct in6_pktinfo *pktinfo;\n\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);\n\t\t\t*ifindex = pktinfo->ipi6_ifindex;\n\t\t}\n\t}\n\t*addr = sin6.sin6_addr;\n\treturn 0;\n}", "target": 1}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "evbuffer_expand(struct evbuffer *buf, size_t datlen)\n{\n\tsize_t need = buf->misalign + buf->off + datlen;\n\tif (buf->totallen >= need)\n\t\treturn (0);\n\tif (buf->misalign >= datlen) {\n\t\tevbuffer_align(buf);\n\t} else {\n\t\tvoid *newbuf;\n\t\tsize_t length = buf->totallen;\n\t\tif (length < 256)\n\t\t\tlength = 256;\n\t\twhile (length < need)\n\t\t\tlength <<= 1;\n\t\tif (buf->orig_buffer != buf->buffer)\n\t\t\tevbuffer_align(buf);\n\t\tif ((newbuf = realloc(buf->buffer, length)) == NULL)\n\t\t\treturn (-1);\n\t\tbuf->orig_buffer = buf->buffer = newbuf;\n\t\tbuf->totallen = length;\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "}\nstatic inline bool f2fs_force_buffered_io(struct inode *inode,\n\t\t\t\tstruct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint rw = iov_iter_rw(iter);\n\tif (f2fs_post_read_required(inode))\n\t\treturn true;\n\tif (f2fs_is_multi_device(sbi))\n\t\treturn true;\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\treturn true;\n\tif (test_opt(sbi, LFS) && (rw == WRITE) &&\n\t\t\t\tblock_unaligned_IO(inode, iocb, iter))\n\t\treturn true;\n\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))\n\t\treturn true;", "target": 1}
{"code": "int am_generate_random_bytes(request_rec *r, void *dest, apr_size_t count)\n{\n    int rc;\n    rc = RAND_pseudo_bytes((unsigned char *)dest, (int)count);\n    if(rc == -1) {\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,\n                      \"Error generating random data: %lu\",\n                      ERR_get_error());\n        return HTTP_INTERNAL_SERVER_ERROR;\n    }\n    if(rc == 0) {\n        ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r,\n                      \"Random data is not cryptographically strong.\");\n    }\n    return OK;\n}", "target": 1}
{"code": "static struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\tkenter(\"\");\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\tconstruct_get_dest_keyring(&dest_keyring);\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_string_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_STRING );\n}", "target": 1}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "static int fuse_do_getattr(struct inode *inode, struct kstat *stat,\n\t\t\t   struct file *file)\n{\n\tint err;\n\tstruct fuse_getattr_in inarg;\n\tstruct fuse_attr_out outarg;\n\tstruct fuse_mount *fm = get_fuse_mount(inode);\n\tFUSE_ARGS(args);\n\tu64 attr_version;\n\tattr_version = fuse_get_attr_version(fm->fc);\n\tmemset(&inarg, 0, sizeof(inarg));\n\tmemset(&outarg, 0, sizeof(outarg));\n\tif (file && S_ISREG(inode->i_mode)) {\n\t\tstruct fuse_file *ff = file->private_data;\n\t\tinarg.getattr_flags |= FUSE_GETATTR_FH;\n\t\tinarg.fh = ff->fh;\n\t}\n\targs.opcode = FUSE_GETATTR;\n\targs.nodeid = get_node_id(inode);\n\targs.in_numargs = 1;\n\targs.in_args[0].size = sizeof(inarg);\n\targs.in_args[0].value = &inarg;\n\targs.out_numargs = 1;\n\targs.out_args[0].size = sizeof(outarg);\n\targs.out_args[0].value = &outarg;\n\terr = fuse_simple_request(fm, &args);\n\tif (!err) {\n\t\tif (fuse_invalid_attr(&outarg.attr) ||\n\t\t    (inode->i_mode ^ outarg.attr.mode) & S_IFMT) {\n\t\t\tmake_bad_inode(inode);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tfuse_change_attributes(inode, &outarg.attr,\n\t\t\t\t\t       attr_timeout(&outarg),\n\t\t\t\t\t       attr_version);\n\t\t\tif (stat)\n\t\t\t\tfuse_fillattr(inode, &outarg.attr, stat);\n\t\t}\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static int nfc_genl_llc_get_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\tif (rc < 0) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\t\treturn rc;\n\t}\n\treturn genlmsg_reply(msg, info);\n}", "target": 1}
{"code": "static TEE_Result do_allocate_publickey(struct ecc_public_key *key,\n\t\t\t\t\tuint32_t type __unused,\n\t\t\t\t\tsize_t size_bits)\n{\n\tECC_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tECC_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "av_cold int ff_vc2enc_init_transforms(VC2TransformContext *s, int p_width, int p_height)\n{\n    s->vc2_subband_dwt[VC2_TRANSFORM_9_7]    = vc2_subband_dwt_97;\n    s->vc2_subband_dwt[VC2_TRANSFORM_5_3]    = vc2_subband_dwt_53;\n    s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));\n    if (!s->buffer)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "void ip6_input(struct mbuf *m)\n{\n    struct ip6 *ip6;\n    Slirp *slirp = m->slirp;\n    if (!slirp->in6_enabled) {\n        goto bad;\n    }\n    DEBUG_CALL(\"ip6_input\");\n    DEBUG_ARG(\"m = %p\", m);\n    DEBUG_ARG(\"m_len = %d\", m->m_len);\n    if (m->m_len < sizeof(struct ip6)) {\n        goto bad;\n    }\n    ip6 = mtod(m, struct ip6 *);\n    if (ip6->ip_v != IP6VERSION) {\n        goto bad;\n    }\n    if (ntohs(ip6->ip_pl) > slirp->if_mtu) {\n        icmp6_send_error(m, ICMP6_TOOBIG, 0);\n        goto bad;\n    }\n    if (ip6->ip_hl == 0) {\n        icmp6_send_error(m, ICMP6_TIMXCEED, ICMP6_TIMXCEED_INTRANS);\n        goto bad;\n    }\n    switch (ip6->ip_nh) {\n    case IPPROTO_TCP:\n        NTOHS(ip6->ip_pl);\n        tcp_input(m, sizeof(struct ip6), (struct socket *)NULL, AF_INET6);\n        break;\n    case IPPROTO_UDP:\n        udp6_input(m);\n        break;\n    case IPPROTO_ICMPV6:\n        icmp6_input(m);\n        break;\n    default:\n        m_free(m);\n    }\n    return;\nbad:\n    m_free(m);\n}", "target": 1}
{"code": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tu64 start = offset >> PAGE_CACHE_SHIFT;\n\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;\n\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\tpgoff_t curr;\n\tstruct page *page;\n\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;\n\tunsigned int from, to;\n\tif (!end_offset)\n\t\tend_offset = PAGE_CACHE_SIZE;\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\tgoto out;\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\tcurr = start;\n\toffset = start << PAGE_CACHE_SHIFT;\n\tfrom = start_offset;\n\tto = PAGE_CACHE_SIZE;\n\twhile (curr <= end) {\n\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,\n\t\t\t\t\t\t   AOP_FLAG_NOFS);\n\t\tif (unlikely(!page)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (curr == end)\n\t\t\tto = end_offset;\n\t\terror = write_empty_blocks(page, from, to, mode);\n\t\tif (!error && offset + to > inode->i_size &&\n\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\t\ti_size_write(inode, offset + to);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tcurr++;\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tfrom = 0;\n\t}\n\tmark_inode_dirty(inode);\n\tbrelse(dibh);\nout:\n\treturn error;\n}", "target": 1}
{"code": "int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)\n{\n    buffer_verify(buffer);\n    if (data == NULL) {\n        return -1;\n    }\n    if (buffer->used + len < len) {\n        return -1;\n    }\n    if (buffer->allocated < (buffer->used + len)) {\n        if (buffer->pos > 0) {\n            buffer_shift(buffer);\n        }\n        if (realloc_buffer(buffer, buffer->used + len) < 0) {\n            return -1;\n        }\n    }\n    memcpy(buffer->data + buffer->used, data, len);\n    buffer->used += len;\n    buffer_verify(buffer);\n    return 0;\n}", "target": 1}
{"code": "static int hva_to_pfn_remapped(struct vm_area_struct *vma,\n\t\t\t       unsigned long addr, bool *async,\n\t\t\t       bool write_fault, bool *writable,\n\t\t\t       kvm_pfn_t *p_pfn)\n{\n\tkvm_pfn_t pfn;\n\tpte_t *ptep;\n\tspinlock_t *ptl;\n\tint r;\n\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\tif (r) {\n\t\tbool unlocked = false;\n\t\tr = fixup_user_fault(current->mm, addr,\n\t\t\t\t     (write_fault ? FAULT_FLAG_WRITE : 0),\n\t\t\t\t     &unlocked);\n\t\tif (unlocked)\n\t\t\treturn -EAGAIN;\n\t\tif (r)\n\t\t\treturn r;\n\t\tr = follow_pte(vma->vm_mm, addr, &ptep, &ptl);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\tif (write_fault && !pte_write(*ptep)) {\n\t\tpfn = KVM_PFN_ERR_RO_FAULT;\n\t\tgoto out;\n\t}\n\tif (writable)\n\t\t*writable = pte_write(*ptep);\n\tpfn = pte_pfn(*ptep);\n\tkvm_get_pfn(pfn);\nout:\n\tpte_unmap_unlock(ptep, ptl);\n\t*p_pfn = pfn;\n\treturn 0;\n}", "target": 1}
{"code": " virtual ssize_t readAt(off64_t offset, void *buffer, size_t size) {\n Parcel data, reply;\n        data.writeInterfaceToken(\n IMediaHTTPConnection::getInterfaceDescriptor());\n        data.writeInt64(offset);\n        data.writeInt32(size);\n status_t err = remote()->transact(READ_AT, data, &reply);\n if (err != OK) {\n            ALOGE(\"remote readAt failed\");\n return UNKNOWN_ERROR;\n }\n int32_t exceptionCode = reply.readExceptionCode();\n if (exceptionCode) {\n             return UNKNOWN_ERROR;\n         }\n        int32_t len = reply.readInt32();\n        if (len > 0) {\n            memcpy(buffer, mMemory->pointer(), len);\n         }\n         return len;\n     }", "target": 1}
{"code": "void track_set_index(Track *track, int i, long ind)\n{\n\tif (i > MAXINDEX) {\n\t\tfprintf(stderr, \"too many indexes\\n\");\n                return;\n        }\n\ttrack->index[i] = ind;\n}", "target": 1}
{"code": "static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_connectinfo ci = {\n\t\t.devnum = ps->dev->devnum,\n\t\t.slow = ps->dev->speed == USB_SPEED_LOW\n\t};\n\tif (copy_to_user(arg, &ci, sizeof(ci)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "\t inline uLONG osdSwap4(uLONG *inLong) {\n\t return *inLong = DPT_Bswapl(*inLong);\n\t }", "target": 1}
{"code": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || \n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n \tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n \t\tverbose(\"Refusing open request in read-only mode\");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}", "target": 1}
{"code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "target": 1}
{"code": "spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n\t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n\t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n{\n    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n\t\t\t\t  iov_count);\n}", "target": 1}
{"code": "void bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tatomic_inc(&map->refcnt);\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n}", "target": 1}
{"code": "static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name TSRMLS_DC)\n{\n\tchar*   key_value \t= NULL;\n\tchar*   cur_key_name\t= NULL;\n\tchar*   token        \t= NULL;\n\tchar*   last_ptr  \t= NULL;\n\tint\tresult\t\t= 0;\n\tint \tcur_result  \t= 0;\n\tint \tcnt  \t\t= 0;\n\tif( strcmp(key_name , LOC_PRIVATE_TAG)==0 ){\n\t\tkey_value = get_private_subtags( loc_name );\n\t\tresult = 1;\n\t} else {\n\t\tkey_value = get_icu_value_internal( loc_name , key_name , &result,1 );\n\t}\n\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || \n\t\t( strcmp(key_name , LOC_VARIANT_TAG)==0) ){\n\t\tif( result > 0 && key_value){\n\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\t\n\t\t\tif( cur_key_name ){\n\t\t\t\tefree( cur_key_name);\n\t\t\t}\n\t\t\tcur_key_name = (char*)ecalloc( 25,  25);\n\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n\t\t\tadd_assoc_string( hash_arr, cur_key_name , token ,TRUE );\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){\n\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n\t\t\t\tadd_assoc_string( hash_arr, cur_key_name , token , TRUE );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif( result == 1 ){\n\t\t\tadd_assoc_string( hash_arr, key_name , key_value , TRUE );\n\t\t\tcur_result = 1;\n\t\t}\n\t}\n\tif( cur_key_name ){\n\t\tefree( cur_key_name);\n\t}\n\tif( key_value){\n\t\tefree(key_value);\t\n\t}\n\treturn cur_result;\n}", "target": 1}
{"code": "static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\tif (error)\n\t\tgoto out_drop_write;\n\tfh_drop_write(fh);\n\tnfserr = fh_getattr(fh, &resp->stat);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}", "target": 1}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  n, sec, min, hour, mday, mon, year, wday, days, leap;\n    n = (ngx_uint_t) t;\n    days = n / 86400;\n    wday = (4 + days) % 7;\n    n %= 86400;\n    hour = n / 3600;\n    n %= 3600;\n    min = n / 60;\n    sec = n % 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 1}
{"code": "static ssize_t write_mem(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t written, sz;\n\tunsigned long copied;\n\tvoid *ptr;\n\tif (p != *ppos)\n\t\treturn -EFBIG;\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\twritten = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n#endif\n\twhile (count > 0) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n\t\t\treturn -EPERM;\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tcopied = copy_from_user(ptr, buf, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (copied) {\n\t\t\twritten += sz - copied;\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n\t*ppos += written;\n\treturn written;\n}", "target": 1}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n#if !ARCHIVE_ACL_LIBRICHACL\n\t(void)mode;\t\n#endif\n#if ARCHIVE_ACL_LIBRICHACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_richacl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#if ARCHIVE_ACL_LIBACL\n\telse\n#endif\n#endif\t\n#if ARCHIVE_ACL_LIBACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t}\n#endif\t\n\treturn (ret);\n}", "target": 1}
{"code": "process_form_int(struct parsed_tag *tag, int fid)\n{\n    char *p, *q, *r, *s, *tg, *n;\n    p = \"get\";\n    parsedtag_get_value(tag, ATTR_METHOD, &p);\n    q = \"!CURRENT_URL!\";\n    parsedtag_get_value(tag, ATTR_ACTION, &q);\n    q = url_encode(remove_space(q), cur_baseURL, cur_document_charset);\n    r = NULL;\n#ifdef USE_M17N\n    if (parsedtag_get_value(tag, ATTR_ACCEPT_CHARSET, &r))\n\tr = check_accept_charset(r);\n    if (!r && parsedtag_get_value(tag, ATTR_CHARSET, &r))\n\tr = check_charset(r);\n#endif\n    s = NULL;\n    parsedtag_get_value(tag, ATTR_ENCTYPE, &s);\n    tg = NULL;\n    parsedtag_get_value(tag, ATTR_TARGET, &tg);\n    n = NULL;\n    parsedtag_get_value(tag, ATTR_NAME, &n);\n    if (fid < 0) {\n\tform_max++;\n\tform_sp++;\n\tfid = form_max;\n    }\n    else {\t\t\t\n\tif (form_max < fid)\n\t    form_max = fid;\n\tform_sp = fid;\n    }\n    if (forms_size == 0) {\n\tforms_size = INITIAL_FORM_SIZE;\n\tforms = New_N(FormList *, forms_size);\n\tform_stack = NewAtom_N(int, forms_size);\n    }\n    else if (forms_size <= form_max) {\n\tforms_size += form_max;\n\tforms = New_Reuse(FormList *, forms, forms_size);\n\tform_stack = New_Reuse(int, form_stack, forms_size);\n    }\n    form_stack[form_sp] = fid;\n    if (w3m_halfdump) {\n\tStr tmp = Sprintf(\"<form_int fid=\\\"%d\\\" action=\\\"%s\\\" method=\\\"%s\\\"\",\n\t\t\t  fid, html_quote(q), html_quote(p));\n\tif (s)\n\t    Strcat(tmp, Sprintf(\" enctype=\\\"%s\\\"\", html_quote(s)));\n\tif (tg)\n\t    Strcat(tmp, Sprintf(\" target=\\\"%s\\\"\", html_quote(tg)));\n\tif (n)\n\t    Strcat(tmp, Sprintf(\" name=\\\"%s\\\"\", html_quote(n)));\n#ifdef USE_M17N\n\tif (r)\n\t    Strcat(tmp, Sprintf(\" accept-charset=\\\"%s\\\"\", html_quote(r)));\n#endif\n\tStrcat_charp(tmp, \">\");\n\treturn tmp;\n    }\n    forms[fid] = newFormList(q, p, r, s, tg, n, NULL);\n    return NULL;\n}", "target": 1}
{"code": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n  free(copy);\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n  return result;\n}", "target": 1}
{"code": "void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint hstartcol;\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\thstartcol = (numrows + 1 - parity) >> 1;\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tsrcptr += stride;\n\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n \t\t\tsockfd_put(nsock);\n \t\t\treturn -EBADFD;\n \t\t}\n \t\terr = bnep_add_connection(&ca, nsock);\n \t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\t\treturn err;\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn bnep_del_connection(&cd);\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringView data = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "static inline int ip_ufo_append_data(struct sock *sk,\n\t\t\tstruct sk_buff_head *queue,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\t       int odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int maxfraglen, unsigned int flags)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif ((skb = skb_peek_tail(queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\t__skb_queue_tail(queue, skb);\n\t}\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}", "target": 1}
{"code": "static void cancel_att_send_op(struct att_send_op *op)\n{\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}", "target": 1}
{"code": "static void l2tp_eth_dev_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n}", "target": 1}
{"code": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\tif (more)\n\t\treturn;\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1}
{"code": " static inline quint32 swapBgrToRgb(quint32 pixel)\n {\n    return ((pixel << 16) & 0xff0000) | ((pixel >> 16) & 0xff) | (pixel & 0xff00ff00);\n }", "target": 1}
{"code": "TerminalUserInfo UserTerminalRouter::getInfoForId(const string &id) {\n  auto it = idInfoMap.find(id);\n  if (it == idInfoMap.end()) {\n    STFATAL << \" Tried to read from an id that no longer exists\";\n  }\n  return it->second;\n}", "target": 1}
{"code": "  TfLiteRegistration OkOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "certstack_destroy(struct cert_stack *stack)\n{\n\tunsigned int stack_size;\n\tstruct metadata_node *meta;\n\tstruct defer_node *post;\n\tstruct repo_level_node *level;\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->defers)) {\n\t\tpost = SLIST_FIRST(&stack->defers);\n\t\tSLIST_REMOVE_HEAD(&stack->defers, next);\n\t\tdefer_destroy(post);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u deferred certificates.\", stack_size);\n\tpr_val_debug(\"Deleting %d stacked x509s.\", sk_X509_num(stack->x509s));\n\tsk_X509_pop_free(stack->x509s, X509_free);\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->metas)) {\n\t\tmeta = SLIST_FIRST(&stack->metas);\n\t\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\t\tmeta_destroy(meta);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u metadatas.\", stack_size);\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->levels)) {\n\t\tlevel = SLIST_FIRST(&stack->levels);\n\t\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\t\tfree(level);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u stacked levels.\", stack_size);\n\tfree(stack);\n}", "target": 1}
{"code": "static long adpt_unlocked_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tstruct inode *inode;\n\tlong ret;\n\tinode = file_inode(file);\n\tmutex_lock(&adpt_mutex);\n\tret = adpt_ioctl(inode, file, cmd, arg);\n\tmutex_unlock(&adpt_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "static void LogOpenCLBuildFailure(MagickCLDevice device,const char *kernel,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    *log;\n  size_t\n    log_size;\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s%s%s\",\n    GetOpenCLCacheDirectory(),DirectorySeparator,\"magick_badcl.cl\");\n  (void) remove_utf8(filename);\n  (void) BlobToFile(filename,kernel,strlen(kernel),exception);\n  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,\n    CL_PROGRAM_BUILD_LOG,0,NULL,&log_size);\n  log=(char*)AcquireMagickMemory(log_size);\n  openCL_library->clGetProgramBuildInfo(device->program,device->deviceID,\n    CL_PROGRAM_BUILD_LOG,log_size,log,&log_size);\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s%s%s\",\n    GetOpenCLCacheDirectory(),DirectorySeparator,\"magick_badcl.log\");\n  (void) remove_utf8(filename);\n  (void) BlobToFile(filename,log,log_size,exception);\n  log=(char*)RelinquishMagickMemory(log);\n}", "target": 1}
{"code": "gdImagePtr gdImageRotateInterpolated(const gdImagePtr src, const float angle, int bgcolor)\n{\n\tconst int angle_rounded = (int)floor(angle * 100);\n\tif (bgcolor < 0 || (!src->trueColor && bgcolor >= gdMaxColors)) {\n\t\treturn NULL;\n\t}\n\tif (src->trueColor == 0) {\n\t\tif (bgcolor >= 0) {\n\t\t\tbgcolor =  gdTrueColorAlpha(src->red[bgcolor], src->green[bgcolor], src->blue[bgcolor], src->alpha[bgcolor]);\n\t\t}\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n\tswitch (angle_rounded) {\n\t\tcase 9000:\n\t\t\treturn gdImageRotate90(src, 0);\n\t\tcase 18000:\n\t\t\treturn gdImageRotate180(src, 0);\n\t\tcase 27000:\n\t\t\treturn gdImageRotate270(src, 0);\n\t}\n\tif (src == NULL || src->interpolation_id < 1 || src->interpolation_id > GD_METHOD_COUNT) {\n\t\treturn NULL;\n\t}\n\tswitch (src->interpolation_id) {\n\t\tcase GD_NEAREST_NEIGHBOUR:\n\t\t\treturn gdImageRotateNearestNeighbour(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BILINEAR_FIXED:\n\t\t\treturn gdImageRotateBilinear(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tcase GD_BICUBIC_FIXED:\n\t\t\treturn gdImageRotateBicubicFixed(src, angle, bgcolor);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn gdImageRotateGeneric(src, angle, bgcolor);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "std::wstring CreateUniqueTempDirectory()\n{\n    wchar_t tmpdir[MAX_PATH+1];\n    if ( GetTempPath(MAX_PATH+1, tmpdir) == 0 )\n        throw Win32Exception(\"Cannot create temporary directory\");\n    for ( ;; )\n    {\n        std::wstring dir(tmpdir);\n        dir += L\"Update-\";\n        UUID uuid;\n        UuidCreate(&uuid);\n        RPC_WSTR uuidStr;\n        RPC_STATUS status = UuidToString(&uuid, &uuidStr);\n        dir += reinterpret_cast<wchar_t*>(uuidStr);\n        RpcStringFree(&uuidStr);\n        if ( CreateDirectory(dir.c_str(), NULL) )\n            return dir;\n        else if ( GetLastError() != ERROR_ALREADY_EXISTS )\n            throw Win32Exception(\"Cannot create temporary directory\");\n    }\n}", "target": 1}
{"code": "void TestDecodeGif(Env* env, DecodeGifTestCase testcase) {\n  string gif;\n  ReadFileToStringOrDie(env, testcase.filepath, &gif);\n  std::unique_ptr<uint8[]> imgdata;\n  int nframes, w, h, c;\n  string error_string;\n  imgdata.reset(gif::Decode(\n      gif.data(), gif.size(),\n      [&](int frame_cnt, int width, int height, int channels) -> uint8* {\n        nframes = frame_cnt;\n        w = width;\n        h = height;\n        c = channels;\n        return new uint8[frame_cnt * height * width * channels];\n      },\n      &error_string));\n  ASSERT_NE(imgdata, nullptr);\n  ASSERT_EQ(nframes, testcase.num_frames);\n  ASSERT_EQ(w, testcase.width);\n  ASSERT_EQ(h, testcase.height);\n  ASSERT_EQ(c, testcase.channels);\n}", "target": 1}
{"code": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n \t\tgoto out;\n \tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n \tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\nout_drop_write:\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}", "target": 1}
{"code": "HttpHeader::chunked() const\n{\n    return has(Http::HdrType::TRANSFER_ENCODING) &&\n           hasListMember(Http::HdrType::TRANSFER_ENCODING, \"chunked\", ',');\n}", "target": 1}
{"code": "R_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char * arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\tr_config_set_i (r->config, \"io.va\",\n\t\t\t(binobj->info)? binobj->info->has_va: 0);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "void LightProcess::closeShadow() {\n  Lock lock(m_procMutex);\n  if (m_shadowProcess) {\n    fprintf(m_fout, \"exit\\n\");\n    fflush(m_fout);\n    fclose(m_fin);\n    fclose(m_fout);\n    ::waitpid(m_shadowProcess, nullptr, 0);\n  }\n  if (!m_afdtFilename.empty()) {\n    remove(m_afdtFilename.c_str());\n  }\n  if (m_afdt_fd >= 0) {\n    ::close(m_afdt_fd);\n    m_afdt_fd = -1;\n  }\n  m_shadowProcess = 0;\n}", "target": 1}
{"code": "static int http1_on_error(http1_parser_s *parser) {\n  FIO_LOG_DEBUG(\"HTTP parser error at HTTP/1.1 buffer position %zu/%zu\",\n                parser->state.next - parser2http(parser)->buf,\n                parser2http(parser)->buf_len);\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}", "target": 1}
{"code": "void Context::onDelete() {\n  if (wasm_->onDelete_) {\n    wasm_->onDelete_(this, id_);\n  }\n}", "target": 1}
{"code": "  t1_parse_font_matrix( T1_Face    face,\n                        T1_Loader  loader )\n  {\n    T1_Parser   parser = &loader->parser;\n    FT_Matrix*  matrix = &face->type1.font_matrix;\n    FT_Vector*  offset = &face->type1.font_offset;\n    FT_Face     root   = (FT_Face)&face->root;\n    FT_Fixed    temp[6];\n    FT_Fixed    temp_scale;\n    FT_Int      result;\n     result = T1_ToFixedArray( parser, 6, temp, 3 );\n    if ( result < 0 )\n     {\n       parser->root.error = FT_THROW( Invalid_File_Format );\n       return;\n    }\n    temp_scale = FT_ABS( temp[3] );\n    if ( temp_scale == 0 )\n    {\n      FT_ERROR(( \"t1_parse_font_matrix: invalid font matrix\\n\" ));\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n    root->units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );\n    if ( temp_scale != 0x10000L )\n    {\n      temp[0] = FT_DivFix( temp[0], temp_scale );\n      temp[1] = FT_DivFix( temp[1], temp_scale );\n      temp[2] = FT_DivFix( temp[2], temp_scale );\n      temp[4] = FT_DivFix( temp[4], temp_scale );\n      temp[5] = FT_DivFix( temp[5], temp_scale );\n      temp[3] = temp[3] < 0 ? -0x10000L : 0x10000L;\n    }\n    matrix->xx = temp[0];\n    matrix->yx = temp[1];\n    matrix->xy = temp[2];\n    matrix->yy = temp[3];\n    offset->x = temp[4] >> 16;\n    offset->y = temp[5] >> 16;\n  }", "target": 1}
{"code": "static char *pool_strdup(const char *s)\n{\n\tchar *r = pool_alloc(strlen(s) + 1);\n\tstrcpy(r, s);\n\treturn r;\n}", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (len > 0 || update) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  if (update) return -1;\n  return len;\n}", "target": 1}
{"code": "char* dexOptGenerateCacheFileName(const char* fileName, const char* subFileName)\n{\n char nameBuf[512];\n char absoluteFile[sizeof(nameBuf)];\n const size_t kBufLen = sizeof(nameBuf) - 1;\n const char* dataRoot;\n char* cp;\n    absoluteFile[0] = '\\0';\n if (fileName[0] != '/') {\n if (getcwd(absoluteFile, kBufLen) == NULL) {\n             ALOGE(\"Can't get CWD while opening jar file\");\n             return NULL;\n         }\n        strncat(absoluteFile, \"/\", kBufLen);\n     }\n    strncat(absoluteFile, fileName, kBufLen);\n     if (subFileName != NULL) {\n        strncat(absoluteFile, \"/\", kBufLen);\n        strncat(absoluteFile, subFileName, kBufLen);\n     }\n    cp = absoluteFile + 1;\n while (*cp != '\\0') {\n if (*cp == '/') {\n *cp = '@';\n }\n        cp++;\n }\n    dataRoot = getenv(\"ANDROID_DATA\");\n if (dataRoot == NULL)\n        dataRoot = \"/data\";\n    snprintf(nameBuf, kBufLen, \"%s/%s\", dataRoot, kCacheDirectoryName);\n if (strcmp(dataRoot, \"/data\") != 0) {\n int result = dexOptMkdir(nameBuf, 0700);\n if (result != 0 && errno != EEXIST) {\n            ALOGE(\"Failed to create dalvik-cache directory %s: %s\", nameBuf, strerror(errno));\n return NULL;\n }\n }\n    snprintf(nameBuf, kBufLen, \"%s/%s/%s\", dataRoot, kCacheDirectoryName, kInstructionSet);\n if (strcmp(dataRoot, \"/data\") != 0) {\n int result = dexOptMkdir(nameBuf, 0700);\n if (result != 0 && errno != EEXIST) {\n            ALOGE(\"Failed to create dalvik-cache directory %s: %s\", nameBuf, strerror(errno));\n return NULL;\n }\n }\n    strncat(nameBuf, absoluteFile, kBufLen);\n     ALOGV(\"Cache file for '%s' '%s' is '%s'\", fileName, subFileName, nameBuf);\n     return strdup(nameBuf);\n}", "target": 1}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n {\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n     return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n }", "target": 1}
{"code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n \t__be32 spi;\n \tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n }", "target": 1}
{"code": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstatic const struct dentry_operations ops = {\n\t\t.d_dname\t= simple_dname,\n\t};\n\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n}", "target": 1}
{"code": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\tif (!commit_transaction)\n\t\treturn;\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}", "target": 1}
{"code": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n     current_element = object->child;\n     if (case_sensitive)\n     {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n         {\n             current_element = current_element->next;\n         }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n         }\n     }\n     return current_element;\n }", "target": 1}
{"code": "\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "smb_com_flush(smb_request_t *sr)\n{\n\tsmb_ofile_t\t*file;\n\tsmb_llist_t\t*flist;\n\tint\t\trc;\n\tif (smb_flush_required == 0) {\n\t\trc = smbsr_encode_empty_result(sr);\n\t\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n\t}\n\tif (sr->smb_fid != 0xffff) {\n\t\tsmbsr_lookup_file(sr);\n\t\tif (sr->fid_ofile == NULL) {\n\t\t\tsmbsr_error(sr, NT_STATUS_INVALID_HANDLE,\n\t\t\t    ERRDOS, ERRbadfid);\n\t\t\treturn (SDRC_ERROR);\n\t\t}\n\t\tsmb_flush_file(sr, sr->fid_ofile);\n\t} else {\n\t\tflist = &sr->tid_tree->t_ofile_list;\n\t\tsmb_llist_enter(flist, RW_READER);\n\t\tfile = smb_llist_head(flist);\n\t\twhile (file) {\n\t\t\tmutex_enter(&file->f_mutex);\n\t\t\tsmb_flush_file(sr, file);\n\t\t\tmutex_exit(&file->f_mutex);\n\t\t\tfile = smb_llist_next(flist, file);\n\t\t}\n\t\tsmb_llist_exit(flist);\n\t}\n\trc = smbsr_encode_empty_result(sr);\n\treturn ((rc == 0) ? SDRC_SUCCESS : SDRC_ERROR);\n}", "target": 1}
{"code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "static void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\treturn;\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\t\tif (can_open_cached(data->state, data->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL)))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(data->state->inode)->delegation);\n\t\tif (delegation != NULL &&\n\t\t    test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) == 0) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_no_action;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tdata->o_arg.id = sp->so_owner_id.id;\n\tdata->o_arg.clientid = sp->so_client->cl_clientid;\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t\tnfs_copy_fh(&data->o_res.fh, data->o_arg.fh);\n\t}\n\tdata->timestamp = jiffies;\n\trpc_call_start(task);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\n}", "target": 1}
{"code": "int main(int argc, char **argv, char **envp)\n{\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    return 0;\n}", "target": 1}
{"code": "static void usage(void)\n{\n  PRINT_VERSION;\n  puts(\"Copyright (c) 2011, Oracle and/or its affiliates. \"\n       \"All rights reserved.\\n\");\n  puts(\"Enable or disable plugins.\");\n  printf(\"\\nUsage: %s [options] <plugin> ENABLE|DISABLE\\n\\nOptions:\\n\",\n     my_progname);\n  my_print_help(my_long_options);\n  puts(\"\\n\");\n}", "target": 1}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  bool indices_has_only_positive_elements = true;\n  const auto* indices_values = GetTensorData<IndicesT>(indices);\n  const size_t num_indices = indices->bytes / sizeof(IndicesT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indices_values[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Params type '%s' are not supported by gather_nd.\",\n                         TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}", "target": 1}
{"code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "static inline bool unconditional(const struct ipt_ip *ip)\n{\n\tstatic const struct ipt_ip uncond;\n\treturn memcmp(ip, &uncond, sizeof(uncond)) == 0;\n#undef FWINV\n}", "target": 1}
{"code": "relay_websocket_decode_frame (const unsigned char *buffer,\n                              unsigned long long buffer_length,\n                              unsigned char *decoded,\n                              unsigned long long *decoded_length)\n{\n    unsigned long long i, index_buffer, length_frame_size, length_frame;\n    unsigned char opcode;\n    *decoded_length = 0;\n    index_buffer = 0;\n    while (index_buffer + 2 <= buffer_length)\n    {\n        opcode = buffer[index_buffer] & 15;\n        if (!(buffer[index_buffer + 1] & 128))\n            return 0;\n        length_frame_size = 1;\n        length_frame = buffer[index_buffer + 1] & 127;\n        index_buffer += 2;\n        if ((length_frame == 126) || (length_frame == 127))\n        {\n            length_frame_size = (length_frame == 126) ? 2 : 8;\n            if (buffer_length < 1 + length_frame_size)\n                return 0;\n            length_frame = 0;\n            for (i = 0; i < length_frame_size; i++)\n            {\n                length_frame += (unsigned long long)buffer[index_buffer + i] << ((length_frame_size - i - 1) * 8);\n            }\n            index_buffer += length_frame_size;\n        }\n        if (buffer_length < 1 + length_frame_size + 4 + length_frame)\n            return 0;\n        int masks[4];\n        for (i = 0; i < 4; i++)\n        {\n            masks[i] = (int)((unsigned char)buffer[index_buffer + i]);\n        }\n        index_buffer += 4;\n        switch (opcode)\n        {\n            case WEBSOCKET_FRAME_OPCODE_PING:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_PING;\n                break;\n            case WEBSOCKET_FRAME_OPCODE_CLOSE:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_CLOSE;\n                break;\n            default:\n                decoded[*decoded_length] = RELAY_CLIENT_MSG_STANDARD;\n                break;\n        }\n        *decoded_length += 1;\n        for (i = 0; i < length_frame; i++)\n        {\n            decoded[*decoded_length + i] = (int)((unsigned char)buffer[index_buffer + i]) ^ masks[i % 4];\n        }\n        decoded[*decoded_length + length_frame] = '\\0';\n        *decoded_length += length_frame + 1;\n        index_buffer += length_frame;\n    }\n    return 1;\n}", "target": 1}
{"code": "void PageFormAnalyserLogger::Flush() {\n  std::string text;\n  for (ConsoleLevel level : {kError, kWarning, kVerbose}) {\n    for (LogEntry& entry : node_buffer_[level]) {\n       text.clear();\n       text += \"[DOM] \";\n       text += entry.message;\n      for (unsigned i = 0; i < entry.nodes.size(); ++i)\n        text += \" %o\";\n       blink::WebConsoleMessage message(level, blink::WebString::FromUTF8(text));\n      message.nodes = std::move(entry.nodes);  \n       frame_->AddMessageToConsole(message);\n     }\n   }\n  node_buffer_.clear();\n}", "target": 1}
{"code": "static void ToPropertyDescriptor(js_State *J, js_Object *obj, const char *name, js_Object *desc)\n{\n\tint haswritable = 0;\n\tint hasvalue = 0;\n\tint enumerable = 0;\n\tint configurable = 0;\n\tint writable = 0;\n\tint atts = 0;\n\tjs_pushobject(J, obj);\n\tjs_pushobject(J, desc);\n\tif (js_hasproperty(J, -1, \"writable\")) {\n\t\thaswritable = 1;\n\t\twritable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"enumerable\")) {\n\t\tenumerable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"configurable\")) {\n\t\tconfigurable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"value\")) {\n\t\thasvalue = 1;\n\t\tjs_setproperty(J, -3, name);\n\t}\n\tif (!writable) atts |= JS_READONLY;\n\tif (!enumerable) atts |= JS_DONTENUM;\n\tif (!configurable) atts |= JS_DONTCONF;\n\tif (js_hasproperty(J, -1, \"get\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\tif (js_hasproperty(J, -2, \"set\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\tjs_defaccessor(J, -4, name, atts);\n\tjs_pop(J, 2);\n}", "target": 1}
{"code": "includeFile(FileInfo *nested, CharsString *includedFile,\n\t\tCharacterClass **characterClasses,\n\t\tTranslationTableCharacterAttributes *characterClassAttribute,\n\t\tshort opcodeLengths[], TranslationTableOffset *newRuleOffset,\n\t\tTranslationTableRule **newRule, RuleName **ruleNames,\n\t\tTranslationTableHeader **table) {\n\tint k;\n\tchar includeThis[MAXSTRING];\n\tchar **tableFiles;\n\tint rv;\n\tfor (k = 0; k < includedFile->length; k++)\n\t\tincludeThis[k] = (char)includedFile->chars[k];\n\tincludeThis[k] = 0;\n\ttableFiles = _lou_resolveTable(includeThis, nested->fileName);\n\tif (tableFiles == NULL) {\n\t\terrorCount++;\n\t\treturn 0;\n\t}\n\tif (tableFiles[1] != NULL) {\n\t\terrorCount++;\n\t\tfree_tablefiles(tableFiles);\n\t\t_lou_logMessage(LOG_ERROR,\n\t\t\t\t\"Table list not supported in include statement: 'include %s'\",\n\t\t\t\tincludeThis);\n\t\treturn 0;\n\t}\n\trv = compileFile(*tableFiles, characterClasses, characterClassAttribute,\n\t\t\topcodeLengths, newRuleOffset, newRule, ruleNames, table);\n\tfree_tablefiles(tableFiles);\n\treturn rv;\n}", "target": 1}
{"code": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const auto& input = context->input(0);\n    auto flat_in = input.flat<tstring>();\n    int fixed_length;\n    const auto& length_input = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                errors::InvalidArgument(\"k must be scalar, got shape \",\n                                        length_input.shape().DebugString()));\n    fixed_length = length_input.scalar<int32>()();\n    OP_REQUIRES(\n        context, fixed_length % sizeof(T) == 0,\n        errors::InvalidArgument(\n            \"fixed_length (\", fixed_length,\n            \") must be a multiple of the size of out_type (\", sizeof(T), \")\"));\n    OP_REQUIRES(context, fixed_length > 0,\n                errors::InvalidArgument(\"fixed_length (\", fixed_length,\n                                        \") must be greater than zero.\"));\n    int width = fixed_length / sizeof(T);\n    TensorShape out_shape = input.shape();\n    out_shape.AddDim(width);\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"output\", out_shape, &output_tensor));\n    if (flat_in.size() == 0) {  \n      return;\n    }\n    auto out = output_tensor->flat_inner_dims<T>();\n    T* out_data = out.data();\n    memset(out_data, 0, fixed_length * flat_in.size());\n    if (!convert_data_endianness_ || sizeof(T) == 1) {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\n        if (flat_in(i).size() > fixed_length) {\n          memcpy(out_data, in_data, fixed_length);\n        } else {\n          memcpy(out_data, in_data, flat_in(i).size());\n        }\n        out_data += fixed_length;\n      }\n    } else {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const char* in_data_bytes =\n            reinterpret_cast<const char*>(flat_in(i).data());\n        char* out_data_bytes = reinterpret_cast<char*>(out_data);\n        const char* p_in = in_data_bytes;\n        char* p_out = out_data_bytes;\n        for (; p_in < in_data_bytes + fixed_length;\n             p_in += sizeof(T), p_out += sizeof(T)) {\n          std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n        }\n        out_data += fixed_length;\n      }\n    }\n  }", "target": 1}
{"code": "TIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n \t\tif (!TIFFAppendToStrip(tif,\n \t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n \t\t    tif->tif_rawdata, tif->tif_rawcc))\n \t\t\treturn (0);\n \t\ttif->tif_rawcc = 0;\n \t\ttif->tif_rawcp = tif->tif_rawdata;\n \t}\n\treturn (1);\n}", "target": 1}
{"code": "Status GetTensorArray(OpKernelContext* ctx, TensorArray** tensor_array) {\n  string container;\n  string ta_handle;\n  if (ctx->input_dtype(0) != DT_RESOURCE) {\n    TF_RETURN_IF_ERROR(GetHandle(ctx, &container, &ta_handle));\n    ResourceMgr* rm = ctx->resource_manager();\n    if (rm == nullptr) return errors::Internal(\"No resource manager.\");\n    TF_RETURN_IF_ERROR(\n        ctx->step_container()->Lookup(rm, container + ta_handle, tensor_array));\n    return OkStatus();\n  } else {\n    return LookupResource(ctx, HandleFromInput(ctx, 0), tensor_array);\n  }\n}", "target": 1}
{"code": "static u32 __ipv6_select_ident(struct net *net,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tconst struct {\n\t\tstruct in6_addr dst;\n\t\tstruct in6_addr src;\n\t} __aligned(SIPHASH_ALIGNMENT) combined = {\n\t\t.dst = *dst,\n\t\t.src = *src,\n\t};\n\tu32 hash, id;\n\tif (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))\n\t\tget_random_bytes(&net->ipv4.ip_id_key,\n\t\t\t\t sizeof(net->ipv4.ip_id_key));\n\thash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\treturn id;\n}", "target": 1}
{"code": "static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n{\n\tint i;\n\tint ret;\n\tret = xen_pcibk_read_config_word(dev, offset, value, data);\n\tif (!pci_is_enabled(dev))\n\t\treturn ret;\n\tfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\n\t\tif (dev->resource[i].flags & IORESOURCE_IO)\n\t\t\t*value |= PCI_COMMAND_IO;\n\t\tif (dev->resource[i].flags & IORESOURCE_MEM)\n\t\t\t*value |= PCI_COMMAND_MEMORY;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n  srcChars += srcStart;\n  if(srcLength < 0) {\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}", "target": 1}
{"code": "static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (mc->id < 0)\n\t\tgoto error;\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\nerror:\n\tkfree(mc);\n\treturn NULL;\n}", "target": 1}
{"code": "inline int NumDimensions(const TfLiteTensor* t) { return t->dims->size; }", "target": 1}
{"code": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n{\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n}", "target": 1}
{"code": "create_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal((void *)handle,\n                                          &arg->rec, arg->mask,\n                                          arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static void sas_destruct_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_DESTRUCT, &port->disc.pending);\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}", "target": 1}
{"code": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\treturn -EACCES;\n}", "target": 1}
{"code": "spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}", "target": 1}
{"code": "static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\tif (ret < 0)\n\t\tgoto exit;\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}", "target": 1}
{"code": "static int vmxnet3_post_load(void *opaque, int version_id)\n{\n    VMXNET3State *s = opaque;\n    PCIDevice *d = PCI_DEVICE(s);\n    vmxnet_tx_pkt_init(&s->tx_pkt, s->max_tx_frags, s->peer_has_vhdr);\n    vmxnet_rx_pkt_init(&s->rx_pkt, s->peer_has_vhdr);\n    if (s->msix_used) {\n        if  (!vmxnet3_use_msix_vectors(s, VMXNET3_MAX_INTRS)) {\n            VMW_WRPRN(\"Failed to re-use MSI-X vectors\");\n            msix_uninit(d, &s->msix_bar, &s->msix_bar);\n            s->msix_used = false;\n            return -1;\n         }\n     }\n     return 0;\n }", "target": 1}
{"code": "MONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i ) {\n    int ds;\n    if ( i->first ) {\n        i->first = 0;\n        return ( bson_type )( *i->cur );\n    }\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_EOO:\n        return BSON_EOO; \n    case BSON_UNDEFINED:\n    case BSON_NULL:\n        ds = 0;\n        break;\n    case BSON_BOOL:\n        ds = 1;\n        break;\n    case BSON_INT:\n        ds = 4;\n        break;\n    case BSON_LONG:\n    case BSON_DOUBLE:\n    case BSON_TIMESTAMP:\n    case BSON_DATE:\n        ds = 8;\n        break;\n    case BSON_OID:\n        ds = 12;\n        break;\n    case BSON_STRING:\n    case BSON_SYMBOL:\n    case BSON_CODE:\n        ds = 4 + bson_iterator_int_raw( i );\n        break;\n    case BSON_BINDATA:\n        ds = 5 + bson_iterator_int_raw( i );\n        break;\n    case BSON_OBJECT:\n    case BSON_ARRAY:\n    case BSON_CODEWSCOPE:\n        ds = bson_iterator_int_raw( i );\n        break;\n    case BSON_DBREF:\n        ds = 4+12 + bson_iterator_int_raw( i );\n        break;\n    case BSON_REGEX: {\n        const char *s = bson_iterator_value( i );\n        const char *p = s;\n        p += strlen( p )+1;\n        p += strlen( p )+1;\n        ds = p-s;\n        break;\n    }\n    default: {\n        char msg[] = \"unknown type: 000000000000\";\n        bson_numstr( msg+14, ( unsigned )( i->cur[0] ) );\n        bson_fatal_msg( 0, msg );\n        return 0;\n    }\n    }\n    i->cur += 1 + strlen( i->cur + 1 ) + 1 + ds;\n    return ( bson_type )( *i->cur );\n}", "target": 1}
{"code": "absl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n  return cached_ip_san_peer_certificate_;\n}", "target": 1}
{"code": "void CIRCSock::ReadLine(const CString& sData) {\n    CString sLine = sData;\n    sLine.TrimRight(\"\\n\\r\");\n    DEBUG(\"(\" << m_pNetwork->GetUser()->GetUserName() << \"/\"\n              << m_pNetwork->GetName() << \") IRC -> ZNC [\" << sLine << \"]\");\n    bool bReturn = false;\n    IRCSOCKMODULECALL(OnRaw(sLine), &bReturn);\n    if (bReturn) return;\n    CMessage Message(sLine);\n    Message.SetNetwork(m_pNetwork);\n    IRCSOCKMODULECALL(OnRawMessage(Message), &bReturn);\n    if (bReturn) return;\n    switch (Message.GetType()) {\n        case CMessage::Type::Account:\n            bReturn = OnAccountMessage(Message);\n            break;\n        case CMessage::Type::Action:\n            bReturn = OnActionMessage(Message);\n            break;\n        case CMessage::Type::Away:\n            bReturn = OnAwayMessage(Message);\n            break;\n        case CMessage::Type::Capability:\n            bReturn = OnCapabilityMessage(Message);\n            break;\n        case CMessage::Type::CTCP:\n            bReturn = OnCTCPMessage(Message);\n            break;\n        case CMessage::Type::Error:\n            bReturn = OnErrorMessage(Message);\n            break;\n        case CMessage::Type::Invite:\n            bReturn = OnInviteMessage(Message);\n            break;\n        case CMessage::Type::Join:\n            bReturn = OnJoinMessage(Message);\n            break;\n        case CMessage::Type::Kick:\n            bReturn = OnKickMessage(Message);\n            break;\n        case CMessage::Type::Mode:\n            bReturn = OnModeMessage(Message);\n            break;\n        case CMessage::Type::Nick:\n            bReturn = OnNickMessage(Message);\n            break;\n        case CMessage::Type::Notice:\n            bReturn = OnNoticeMessage(Message);\n            break;\n        case CMessage::Type::Numeric:\n            bReturn = OnNumericMessage(Message);\n            break;\n        case CMessage::Type::Part:\n            bReturn = OnPartMessage(Message);\n            break;\n        case CMessage::Type::Ping:\n            bReturn = OnPingMessage(Message);\n            break;\n        case CMessage::Type::Pong:\n            bReturn = OnPongMessage(Message);\n            break;\n        case CMessage::Type::Quit:\n            bReturn = OnQuitMessage(Message);\n            break;\n        case CMessage::Type::Text:\n            bReturn = OnTextMessage(Message);\n            break;\n        case CMessage::Type::Topic:\n            bReturn = OnTopicMessage(Message);\n            break;\n        case CMessage::Type::Wallops:\n            bReturn = OnWallopsMessage(Message);\n            break;\n        default:\n            break;\n    }\n    if (bReturn) return;\n    m_pNetwork->PutUser(Message);\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n{\n\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n}", "target": 1}
{"code": "bool PDFiumEngine::HandleEvent(const pp::InputEvent& event) {\n  DCHECK(!defer_page_unload_);\n  defer_page_unload_ = true;\n  bool rv = false;\n  switch (event.GetType()) {\n    case PP_INPUTEVENT_TYPE_MOUSEDOWN:\n      rv = OnMouseDown(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEUP:\n      rv = OnMouseUp(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_MOUSEMOVE:\n      rv = OnMouseMove(pp::MouseInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYDOWN:\n      rv = OnKeyDown(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_KEYUP:\n      rv = OnKeyUp(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_CHAR:\n      rv = OnChar(pp::KeyboardInputEvent(event));\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHSTART: {\n      KillTouchTimer(next_touch_timer_id_);\n      pp::TouchInputEvent touch_event(event);\n      if (touch_event.GetTouchCount(PP_TOUCHLIST_TYPE_TARGETTOUCHES) == 1)\n        ScheduleTouchTimer(touch_event);\n      break;\n    }\n    case PP_INPUTEVENT_TYPE_TOUCHEND:\n      KillTouchTimer(next_touch_timer_id_);\n      break;\n    case PP_INPUTEVENT_TYPE_TOUCHMOVE:\n      KillTouchTimer(next_touch_timer_id_);\n    default:\n      break;\n  }\n   DCHECK(defer_page_unload_);\n   defer_page_unload_ = false;\n  for (int page_index : deferred_page_unloads_)\n     pages_[page_index]->Unload();\n  deferred_page_unloads_.clear();\n   return rv;\n }", "target": 1}
{"code": "void skb_complete_tx_timestamp(struct sk_buff *skb,\n\t\t\t       struct skb_shared_hwtstamps *hwtstamps)\n{\n\tstruct sock *sk = skb->sk;\n\tif (!skb_may_tx_timestamp(sk, false))\n\t\treturn;\n\tif (likely(atomic_inc_not_zero(&sk->sk_refcnt))) {\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\t\t__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);\n\t\tsock_put(sk);\n\t}", "target": 1}
{"code": "static int autosieve_createfolder(const char *userid, const struct auth_state *auth_state,\n                                  const char *internalname, int createsievefolder)\n{\n    const char *subf ;\n    int r = 0;\n    int n;\n    if (userid == NULL || internalname == NULL)\n        return IMAP_MAILBOX_NONEXISTENT;\n    syslog(LOG_DEBUG, \"autosievefolder: autosieve_createfolder() was called for user %s, folder %s\",\n           userid, internalname);\n    if (config_getswitch(IMAPOPT_ANYSIEVEFOLDER)) {\n        createsievefolder = 1;\n    }\n    else if ((subf = config_getstring(IMAPOPT_AUTOCREATE_SIEVE_FOLDERS)) != NULL) {\n        strarray_t *create = strarray_split(subf, SEP, STRARRAY_TRIM);\n        for (n = 0; n < create->count; n++) {\n            const char *name = strarray_nth(create, n);\n            char *foldername = mboxname_user_mbox(userid, name);\n            if (!strcmp(foldername, internalname))\n                createsievefolder = 1;\n            free(foldername);\n            if (createsievefolder) break;\n        }\n        strarray_free(create);\n    }\n    if (!createsievefolder) return IMAP_MAILBOX_NONEXISTENT;\n    struct mboxlock *namespacelock = mboxname_usernamespacelock(internalname);\n    r = mboxlist_lookup(internalname, 0, 0);\n    if (r != IMAP_MAILBOX_NONEXISTENT) goto done;\n    r = mboxlist_createmailbox(internalname, 0, NULL,\n                               1, userid, auth_state, 0, 0, 0, 1, NULL);\n    if (r) {\n        syslog(LOG_ERR, \"autosievefolder: User %s, folder %s creation failed. %s\",\n               userid, internalname, error_message(r));\n        goto done;\n    }\n    mboxlist_changesub(internalname, userid, auth_state, 1, 1, 1);\n    syslog(LOG_DEBUG, \"autosievefolder: User %s, folder %s creation succeeded\",\n           userid, internalname);\ndone:\n    mboxname_release(&namespacelock);\n    return r;\n}", "target": 1}
{"code": "Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    const Tensor* tensor;\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    const bool use_host_memory =\n        is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n               : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      if (!op.is_function() && device != nullptr && device != cpu_device) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": " base::string16 FormatBookmarkURLForDisplay(const GURL& url) {\n  return url_formatter::FormatUrl(\n      url, url_formatter::kFormatUrlOmitAll &\n               ~url_formatter::kFormatUrlOmitUsernamePassword,\n      net::UnescapeRule::SPACES, nullptr, nullptr, nullptr);\n }", "target": 1}
{"code": "\tconsume_count(type)\n\t\tconst char **type;\n{\n\tint count = 0;\n\tif (!isdigit((unsigned char)**type))\n\t\treturn -1;\n\twhile (isdigit((unsigned char)**type)) {\n\t\tcount *= 10;\n\t\tif ((count % 10) != 0) {\n\t\t\twhile (isdigit((unsigned char)**type))\n\t\t\t\t(*type)++;\n\t\t\treturn -1;\n\t\t}\n\t\tcount += **type - '0';\n\t\t(*type)++;\n\t}\n\treturn (count);\n}", "target": 1}
{"code": "struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t *entry;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tut8 b[512];\n\tZERO_FILL (b);\n\tentry = PE_ (r_bin_pe_get_entrypoint) (pe);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\tif (b[367] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);\n\t\treturn entry;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < 512 - 16 ; i++) {\n\t\tif (!memcmp (b + i, \"\\xff\\x15\", 2)) {\n\t\t\tif (b[i + 6] == 0x50) {\n\t\t\t\tif (b[i + 7] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}", "target": 1}
{"code": "static int rm_rf_children_inner(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                _cleanup_close_ int subdir_fd = -1;\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(TAKE_FD(subdir_fd), flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 1}
{"code": "lyd_new_output_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}", "target": 1}
{"code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n \tdevinfo.version_code = COMEDI_VERSION_CODE;\n \tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n \tif (read_subdev)\n \t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,\n                                 const GURL& real_url) {\n  if (real_url.SchemeIs(kGuestScheme))\n    return real_url;\n  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);\n  url::Origin origin = url::Origin::Create(url);\n  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();\n  url::Origin isolated_origin;\n  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))\n    return isolated_origin.GetURL();\n  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {\n    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(\n        origin.host(),\n        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);\n    std::string site = origin.scheme();\n    site += url::kStandardSchemeSeparator;\n    site += domain.empty() ? origin.host() : domain;\n    return GURL(site);\n  }\n   if (!origin.unique()) {\n     DCHECK(!origin.scheme().empty());\n     return GURL(origin.scheme() + \":\");\n   } else if (url.has_scheme()) {\n     DCHECK(!url.scheme().empty());\n     return GURL(url.scheme() + \":\");\n   }\n  DCHECK(!url.is_valid()) << url;\n  return GURL();\n}", "target": 1}
{"code": "static void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.open_flags == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN) {\n\t\t\t\trpc_restart_call(task);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n}", "target": 1}
{"code": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n {\n \tint ret = 0;\n \tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n \tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n \tresp.qp_tab_size = hr_dev->caps.num_qps;\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\treturn &context->ibucontext;\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\nerror_fail_uar_alloc:\n\tkfree(context);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "cib_remote_msg(gpointer data)\n{\n    const char *value = NULL;\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n    command = crm_recv_remote_msg(client->session, client->encrypted);\n    if (command == NULL) {\n        return -1;\n    }\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        goto bail;\n    }\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n  bail:\n    free_xml(command);\n    command = NULL;\n    return 0;\n}", "target": 1}
{"code": "static bool new_idmap_permitted(struct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "win_exchange(long Prenum)\n{\n    frame_T\t*frp;\n    frame_T\t*frp2;\n    win_T\t*wp;\n    win_T\t*wp2;\n    int\t\ttemp;\n    if (ERROR_IF_ANY_POPUP_WINDOW)\n\treturn;\n    if (ONE_WINDOW)\t    \n    {\n\tbeep_flush();\n\treturn;\n    }\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n    if (Prenum)\n    {\n\tfrp = curwin->w_frame->fr_parent->fr_child;\n\twhile (frp != NULL && --Prenum > 0)\n\t    frp = frp->fr_next;\n    }\n    else if (curwin->w_frame->fr_next != NULL)\t\n\tfrp = curwin->w_frame->fr_next;\n    else    \n\tfrp = curwin->w_frame->fr_prev;\n    if (frp == NULL || frp->fr_win == NULL || frp->fr_win == curwin)\n\treturn;\n    wp = frp->fr_win;\n    wp2 = curwin->w_prev;\n    frp2 = curwin->w_frame->fr_prev;\n    if (wp->w_prev != curwin)\n    {\n\twin_remove(curwin, NULL);\n\tframe_remove(curwin->w_frame);\n\twin_append(wp->w_prev, curwin);\n\tframe_insert(frp, curwin->w_frame);\n    }\n    if (wp != wp2)\n    {\n\twin_remove(wp, NULL);\n\tframe_remove(wp->w_frame);\n\twin_append(wp2, wp);\n\tif (frp2 == NULL)\n\t    frame_insert(wp->w_frame->fr_parent->fr_child, wp->w_frame);\n\telse\n\t    frame_append(frp2, wp->w_frame);\n    }\n    temp = curwin->w_status_height;\n    curwin->w_status_height = wp->w_status_height;\n    wp->w_status_height = temp;\n    temp = curwin->w_vsep_width;\n    curwin->w_vsep_width = wp->w_vsep_width;\n    wp->w_vsep_width = temp;\n    frame_fix_height(curwin);\n    frame_fix_height(wp);\n    frame_fix_width(curwin);\n    frame_fix_width(wp);\n    (void)win_comp_pos();\t\t\n    win_enter(wp, TRUE);\n    redraw_all_later(NOT_VALID);\n}", "target": 1}
{"code": "expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  size_t cnt;\n  size_t total;\n  char *result;\n  cnt = DL_DST_COUNT (s, 1);\n  if (cnt == 0)\n    return local_strdup (s);\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n  result = (char *) malloc (total + 1);\n  if (result == NULL)\n    return NULL;\n  return DL_DST_SUBSTITUTE (l, s, result, 1);\n}", "target": 1}
{"code": "static char* get_private_subtags(const char* loc_name)\n{\n\tchar* \tresult =NULL;\n\tint \tsingletonPos = 0;\n\tint \tlen =0; \n\tconst char* \tmod_loc_name =NULL;\n\tif( loc_name && (len = strlen(loc_name)>0 ) ){\n\t\tmod_loc_name = loc_name ; \n\t\tlen   = strlen(mod_loc_name);\n\t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n\t\t\tif( singletonPos!=-1){ \n\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t\n\t\t\t\t\tif( singletonPos + 2 ==  len){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tresult = estrndup(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( singletonPos + 1 >=  len){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmod_loc_name = mod_loc_name + singletonPos +1;\n\t\t\t\t\t\tlen = strlen(mod_loc_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\treturn result;\n}", "target": 1}
{"code": "static int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)\n{\n    int err;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* buf;\n#else\n    byte  buf[ECC_MAXSIZE_GEN];\n#endif\n#ifdef WOLFSSL_SMALL_STACK\n    buf = (byte*)XMALLOC(ECC_MAXSIZE_GEN, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (buf == NULL)\n        return MEMORY_E;\n#endif\n    size += 8;\n    err = wc_RNG_GenerateBlock(rng, buf, size);\n    if (err == 0)\n        err = mp_read_unsigned_bin(k, (byte*)buf, size);\n    if (err == MP_OKAY) {\n        if (mp_iszero(k) == MP_YES)\n          err = MP_ZERO_E;\n    }\n    if (err == MP_OKAY) {\n        if (mp_cmp(k, order) != MP_LT) {\n            err = mp_mod(k, order, k);\n        }\n    }\n    ForceZero(buf, ECC_MAXSIZE);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n    return err;\n}", "target": 1}
{"code": "resolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n    if (expr->expr) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}", "target": 1}
{"code": "void luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {\n  int i;\n  int nextra = ci->u.l.nextraargs;\n  if (wanted < 0) {\n    wanted = nextra;  \n    checkstackp(L, nextra, where);  \n    L->top = where + nextra;  \n  }\n  for (i = 0; i < wanted && i < nextra; i++)\n    setobjs2s(L, where + i, ci->func - nextra + i);\n  for (; i < wanted; i++)   \n    setnilvalue(s2v(where + i));\n}", "target": 1}
{"code": "Pl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    getNext()->write(outbuf, this->pos - 1);\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n}", "target": 1}
{"code": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n \t\t\t\tif(!tmp)\t\n \t\t\t\t{\n \t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n \t\t\t\t\tfree(p);\n \t\t\t\t\treturn 0;\n \t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "pci_emul_alloc_resource(uint64_t *baseptr, uint64_t limit, uint64_t size,\n\t\t\tuint64_t *addr)\n{\n\tuint64_t base;\n\tassert((size & (size - 1)) == 0);\t\n\tbase = roundup2(*baseptr, size);\n\tif (base + size <= limit) {\n\t\t*addr = base;\n\t\t*baseptr = base + size;\n\t\treturn 0;\n\t} else\n\t\treturn -1;\n}", "target": 1}
{"code": "bool Item_equal::create_pushable_equalities(THD *thd,\n                                            List<Item> *equalities,\n                                            Pushdown_checker checker,\n                                            uchar *arg,\n                                            bool clone_const)\n{\n  Item *item;\n  Item *left_item= NULL;\n  Item *right_item = get_const();\n  Item_equal_fields_iterator it(*this);\n  while ((item=it++))\n  {\n    left_item= item;\n    if (checker && !((item->*checker) (arg)))\n      continue;\n    break;\n  }\n  if (!left_item)\n    return false;\n  if (right_item)\n  {\n    Item_func_eq *eq= 0;\n    Item *left_item_clone= left_item->build_clone(thd);\n    Item *right_item_clone= !clone_const ?\n                            right_item : right_item->build_clone(thd);\n    if (!left_item_clone || !right_item_clone)\n      return true;\n    eq= new (thd->mem_root) Item_func_eq(thd,\n                                         left_item_clone,\n                                         right_item_clone);\n    if (!eq ||  equalities->push_back(eq, thd->mem_root))\n      return true;\n    if (!clone_const)\n      right_item->set_extraction_flag(IMMUTABLE_FL);\n  }\n  while ((item=it++))\n  {\n    if (checker && !((item->*checker) (arg)))\n      continue;\n    Item_func_eq *eq= 0;\n    Item *left_item_clone= left_item->build_clone(thd);\n    Item *right_item_clone= item->build_clone(thd);\n    if (!(left_item_clone && right_item_clone))\n      return true;\n    left_item_clone->set_item_equal(NULL);\n    right_item_clone->set_item_equal(NULL);\n    eq= new (thd->mem_root) Item_func_eq(thd,\n                                         right_item_clone,\n                                         left_item_clone);\n    if (!eq || equalities->push_back(eq, thd->mem_root))\n      return true;\n  }\n  return false;\n}", "target": 1}
{"code": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "TRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback,\n                                                    TRIO_CONST char* name)\n{\n\ttrio_userdef_t* def;\n\ttrio_userdef_t* prev = NULL;\n\tif (callback == NULL)\n\t\treturn NULL;\n\tif (name)\n\t{\n\t\tif (name[0] == ':')\n\t\t{\n\t\t\tif (trio_equal(name, \":enter\"))\n\t\t\t{\n\t\t\t\tinternalEnterCriticalRegion = callback;\n\t\t\t}\n\t\t\telse if (trio_equal(name, \":leave\"))\n\t\t\t{\n\t\t\t\tinternalLeaveCriticalRegion = callback;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tif (trio_length(name) >= MAX_USER_NAME)\n\t\t\treturn NULL;\n\t\tdef = TrioFindNamespace(name, &prev);\n\t\tif (def)\n\t\t\treturn NULL;\n\t}\n\tdef = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t));\n\tif (def)\n\t{\n\t\tif (internalEnterCriticalRegion)\n\t\t\t(void)internalEnterCriticalRegion(NULL);\n\t\tif (name)\n\t\t{\n\t\t\tif (prev == NULL)\n\t\t\t\tinternalUserDef = def;\n\t\t\telse\n\t\t\t\tprev->next = def;\n\t\t}\n\t\tdef->callback = callback;\n\t\tdef->name = (name == NULL) ? NULL : trio_duplicate(name);\n\t\tdef->next = NULL;\n\t\tif (internalLeaveCriticalRegion)\n\t\t\t(void)internalLeaveCriticalRegion(NULL);\n\t}\n\treturn (trio_pointer_t)def;\n}", "target": 1}
{"code": "_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n        return NULL;\n     }\n    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))\n        == NULL) {\n        _zip_error_set(error, ZIP_ER_MEMORY, 0);\n        free(cd);\n\treturn NULL;\n    }\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n    return cd;\n}", "target": 1}
{"code": "AVA_Sort( LDAPRDN rdn, int nAVAs )\n{\n\tLDAPAVA\t*ava_i;\n\tint\t\ti;\n\tassert( rdn != NULL );\n\tfor ( i = 1; i < nAVAs; i++ ) {\n\t\tLDAPAVA *ava_j;\n\t\tint j;\n\t\tava_i = rdn[ i ];\n\t\tfor ( j = i-1; j >=0; j-- ) {\n\t\t\tint a;\n\t\t\tava_j = rdn[ j ];\n\t\t\ta = strcmp( ava_i->la_attr.bv_val, ava_j->la_attr.bv_val );\n\t\t\tif ( a == 0 )\n\t\t\t\treturn LDAP_INVALID_DN_SYNTAX;\n\t\t\tif ( a > 0 )\n\t\t\t\tbreak;\n\t\t\trdn[ j+1 ] = rdn[ j ];\n\t\t}\n\t\trdn[ j+1 ] = ava_i;\n\t}\n\treturn LDAP_SUCCESS;\n}", "target": 1}
{"code": "mm_answer_pam_init_ctx(int sock, Buffer *m)\n{\n\tdebug3(\"%s\", __func__);\n\tauthctxt->user = buffer_get_string(m, NULL);\n\tsshpam_ctxt = (sshpam_device.init_ctx)(authctxt);\n\tsshpam_authok = NULL;\n\tbuffer_clear(m);\n\tif (sshpam_ctxt != NULL) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_FREE_CTX, 1);\n\t\tbuffer_put_int(m, 1);\n\t} else {\n\t\tbuffer_put_int(m, 0);\n\t}\n\tmm_request_send(sock, MONITOR_ANS_PAM_INIT_CTX, m);\n\treturn (0);\n}", "target": 1}
{"code": "asmlinkage long sys_setrlimit(unsigned int resource, struct rlimit __user *rlim)\n{\n\tstruct rlimit new_rlim, *old_rlim;\n\tunsigned long it_prof_secs;\n\tint retval;\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tif (copy_from_user(&new_rlim, rlim, sizeof(*rlim)))\n\t\treturn -EFAULT;\n\tif (new_rlim.rlim_cur > new_rlim.rlim_max)\n\t\treturn -EINVAL;\n\told_rlim = current->signal->rlim + resource;\n\tif ((new_rlim.rlim_max > old_rlim->rlim_max) &&\n\t    !capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)\n\t\treturn -EPERM;\n\tretval = security_task_setrlimit(resource, &new_rlim);\n\tif (retval)\n\t\treturn retval;\n\ttask_lock(current->group_leader);\n\t*old_rlim = new_rlim;\n\ttask_unlock(current->group_leader);\n\tif (resource != RLIMIT_CPU)\n\t\tgoto out;\n\tif (new_rlim.rlim_cur == RLIM_INFINITY)\n\t\tgoto out;\n\tit_prof_secs = cputime_to_secs(current->signal->it_prof_expires);\n\tif (it_prof_secs == 0 || new_rlim.rlim_cur <= it_prof_secs) {\n\t\tunsigned long rlim_cur = new_rlim.rlim_cur;\n\t\tcputime_t cputime;\n\t\tif (rlim_cur == 0) {\n\t\t\trlim_cur = 1;\n\t\t}\n\t\tcputime = secs_to_cputime(rlim_cur);\n\t\tread_lock(&tasklist_lock);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tset_process_cpu_timer(current, CPUCLOCK_PROF, &cputime, NULL);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tread_unlock(&tasklist_lock);\n\t}\nout:\n\treturn 0;\n}", "target": 1}
{"code": "bool DecodeResourceHandleList(std::unique_ptr<port::StringListDecoder> d,\n                              ResourceHandle* ps, int64_t n) {\n  std::vector<uint32> sizes(n);\n  if (!d->ReadSizes(&sizes)) return false;\n  ResourceHandleProto proto;\n  for (int i = 0; i < n; ++i) {\n    if (!proto.ParseFromArray(d->Data(sizes[i]), sizes[i])) {\n      return false;\n    }\n    ps[i].FromProto(proto);\n  }\n  return true;\n}", "target": 1}
{"code": "void UncompressElementOp::Compute(OpKernelContext* ctx) {\n  Tensor tensor = ctx->input(0);\n  const Variant& variant = tensor.scalar<Variant>()();\n  const CompressedElement* compressed = variant.get<CompressedElement>();\n  std::vector<Tensor> components;\n  OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n  OP_REQUIRES(ctx, components.size() == output_types_.size(),\n              errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                         \" outputs from uncompress, but got \",\n                                         components.size()));\n  for (int i = 0; i < components.size(); ++i) {\n    OP_REQUIRES(\n        ctx, components[i].dtype() == output_types_[i],\n        errors::FailedPrecondition(\"Expected a tensor of type \",\n                                   DataTypeString(output_types_[i]),\n                                   \" but got a tensor of type \",\n                                   DataTypeString(components[i].dtype())));\n    ctx->set_output(i, components[i]);\n  }\n}", "target": 1}
{"code": "UrlQuery::UrlQuery(const std::string& encoded_str) {\n  if (!encoded_str.empty()) {\n    for (std::size_t i = 0; i != std::string::npos;) {\n      std::size_t j = encoded_str.find_first_of('&', i);\n      std::string kv;\n      if (j == std::string::npos) {\n        kv = encoded_str.substr(i);\n        i = std::string::npos;\n      } else {\n        kv = encoded_str.substr(i, j - i);\n        i = j + 1;\n      }\n      string_view key;\n      string_view value;\n      if (SplitKV(kv, '=', false, &key, &value)) {\n        parameters_.push_back({ DecodeUnsafe(key), DecodeUnsafe(value) });\n      }\n    }\n  }\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); ov = Jsi_ValueNew(interp); }\n        Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);\n    }\n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}", "target": 1}
{"code": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\tif (!addr)\n\t\treturn -ENODEV;\n\tio->io_cleanup = mem_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n\t\tmem_region_cleanup(io, io->io_size);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\tseq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;\n\tseq += keyptr->count;\n\tseq += ktime_to_ns(ktime_get_real()) >> 6;\n\treturn seq;\n}", "target": 1}
{"code": "static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,\n\t\t\t\t\t  u32 *mask)\n{\n\tstruct crypto_attr_type *algt;\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn;\n\tif ((algt->type & CRYPTO_ALG_INTERNAL))\n\t\t*type |= CRYPTO_ALG_INTERNAL;\n\tif ((algt->mask & CRYPTO_ALG_INTERNAL))\n\t\t*mask |= CRYPTO_ALG_INTERNAL;\n}", "target": 1}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n \tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n \t\treturn 0;\n \tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\tNT_ASSERT(size);\n#pragma prefast(suppress : 30030)\t\t\n\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\treturn block->data;\n}", "target": 1}
{"code": "Status KernelAndDeviceOp::Run(\n    ScopedStepContainer* step_container, const EagerKernelArgs& inputs,\n    std::vector<EagerKernelRet>* outputs,\n    CancellationManager* cancellation_manager,\n    const absl::optional<EagerRemoteFunctionParams>& remote_func_params) {\n  OpKernelContext::Params params;\n  params.device = device_;\n  params.frame_iter = FrameAndIter(0, 0);\n  params.inputs = inputs.GetTensorValues();\n  params.op_kernel = kernel_.get();\n  params.resource_manager = device_->resource_manager();\n  params.input_alloc_attrs = &input_alloc_attrs_;\n  params.output_attr_array = output_alloc_attrs_.data();\n  params.function_library = flr_;\n  params.slice_reader_cache = &slice_reader_cache_;\n  params.rendezvous = rendezvous_;\n  OpExecutionState* op_execution_state = nullptr;\n  CancellationManager default_cancellation_manager;\n  if (cancellation_manager) {\n    params.cancellation_manager = cancellation_manager;\n  } else if (kernel_->is_deferred()) {\n    op_execution_state = new OpExecutionState;\n    params.cancellation_manager = &op_execution_state->cancellation_manager;\n    params.inc_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Ref();\n    };\n    params.dec_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Unref();\n    };\n  } else {\n    params.cancellation_manager = &default_cancellation_manager;\n  }\n  params.log_memory = log_memory_;\n  params.runner = get_runner();\n  params.step_container =\n      step_container == nullptr ? &step_container_ : step_container;\n  auto step_container_cleanup = gtl::MakeCleanup([step_container, this] {\n    if (step_container == nullptr) {\n      this->step_container_.CleanUp();\n    }\n  });\n  params.collective_executor =\n      collective_executor_ ? collective_executor_->get() : nullptr;\n  OpKernelContext context(&params);\n  {\n    port::ScopedFlushDenormal flush;\n    port::ScopedSetRound round(FE_TONEAREST);\n    profiler::AnnotatedTraceMe activity(\n        [&] { return kernel_->TraceString(context, false); },\n        profiler::TraceMeLevel::kInfo);\n    device_->Compute(kernel_.get(), &context);\n  }\n  if (op_execution_state != nullptr) {\n    op_execution_state->Unref();\n  }\n  if (!context.status().ok()) return context.status();\n  if (outputs != nullptr) {\n    outputs->clear();\n    for (int i = 0; i < context.num_outputs(); ++i) {\n      outputs->push_back(Tensor(*context.mutable_output(i)));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\topenflags &= ~(O_CREAT|O_EXCL);\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}", "target": 1}
{"code": " search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n \tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n \tstruct search_domain *dom;\n \tfor (dom = state->head; dom; dom = dom->next) {\n \t\tif (!n--) {\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\tEVUTIL_ASSERT(0);\n\treturn NULL; \n}", "target": 1}
{"code": "void rose_start_t3timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t3;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n     _exit(127);\n   }\n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n     uv__write_int(error_fd, -errno);\n     perror(\"setgid()\");\n    _exit(127);\n  }\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}", "target": 1}
{"code": "  bool verify_authorizer(Connection *con, int peer_type, int protocol, bufferlist& auth, bufferlist& auth_reply,\n                         bool& isvalid, CryptoKey& session_key) {\n    return ms_deliver_verify_authorizer(con, peer_type, protocol, auth,\n                                        auth_reply, isvalid, session_key);\n  }", "target": 1}
{"code": "int xfrm_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t struct xfrm_migrate *m, int num_migrate,\n\t\t struct xfrm_kmaddress *k, struct net *net,\n\t\t struct xfrm_encap_tmpl *encap)\n{\n\tint i, err, nx_cur = 0, nx_new = 0;\n\tstruct xfrm_policy *pol = NULL;\n\tstruct xfrm_state *x, *xc;\n\tstruct xfrm_state *x_cur[XFRM_MAX_DEPTH];\n\tstruct xfrm_state *x_new[XFRM_MAX_DEPTH];\n\tstruct xfrm_migrate *mp;\n\tif ((err = xfrm_migrate_check(m, num_migrate)) < 0)\n\t\tgoto out;\n\tif ((pol = xfrm_migrate_policy_find(sel, dir, type, net)) == NULL) {\n\t\terr = -ENOENT;\n\t\tgoto out;\n\t}\n\tfor (i = 0, mp = m; i < num_migrate; i++, mp++) {\n\t\tif ((x = xfrm_migrate_state_find(mp, net))) {\n\t\t\tx_cur[nx_cur] = x;\n\t\t\tnx_cur++;\n\t\t\txc = xfrm_state_migrate(x, mp, encap);\n\t\t\tif (xc) {\n\t\t\t\tx_new[nx_new] = xc;\n\t\t\t\tnx_new++;\n\t\t\t} else {\n\t\t\t\terr = -ENODATA;\n\t\t\t\tgoto restore_state;\n\t\t\t}\n\t\t}\n\t}\n\tif ((err = xfrm_policy_migrate(pol, m, num_migrate)) < 0)\n\t\tgoto restore_state;\n\tif (nx_cur) {\n\t\txfrm_states_put(x_cur, nx_cur);\n\t\txfrm_states_delete(x_cur, nx_cur);\n\t}\n\tkm_migrate(sel, dir, type, m, num_migrate, k, encap);\n\txfrm_pol_put(pol);\n\treturn 0;\nout:\n\treturn err;\nrestore_state:\n\tif (pol)\n\t\txfrm_pol_put(pol);\n\tif (nx_cur)\n\t\txfrm_states_put(x_cur, nx_cur);\n\tif (nx_new)\n\t\txfrm_states_delete(x_new, nx_new);\n\treturn err;\n}", "target": 1}
{"code": "get_caller_uid (GDBusMethodInvocation *context, gint *uid)\n {\n        PolkitSubject *subject;\n        PolkitSubject *process;\n        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));\n        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);\n        if (!process) {\n                g_object_unref (subject);\n                 return FALSE;\n         }\n        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));\n        g_object_unref (subject);\n        g_object_unref (process);\n         return TRUE;\n }", "target": 1}
{"code": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\tif (border < 0) {\n\t\treturn;\n\t}\n\tleftLimit = (-1);\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}", "target": 1}
{"code": "        int          GetU8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];\n        }", "target": 1}
{"code": "void kvm_io_bus_unregister_dev(struct kvm *kvm, enum kvm_bus bus_idx,\n\t\t\t       struct kvm_io_device *dev)\n{\n\tint i;\n\tstruct kvm_io_bus *new_bus, *bus;\n\tbus = kvm_get_bus(kvm, bus_idx);\n\tif (!bus)\n\t\treturn;\n\tfor (i = 0; i < bus->dev_count; i++)\n\t\tif (bus->range[i].dev == dev) {\n\t\t\tbreak;\n\t\t}\n\tif (i == bus->dev_count)\n\t\treturn;\n\tnew_bus = kmalloc(struct_size(bus, range, bus->dev_count - 1),\n\t\t\t  GFP_KERNEL_ACCOUNT);\n\tif (!new_bus)  {\n\t\tpr_err(\"kvm: failed to shrink bus, removing it completely\\n\");\n\t\tgoto broken;\n\t}\n\tmemcpy(new_bus, bus, sizeof(*bus) + i * sizeof(struct kvm_io_range));\n\tnew_bus->dev_count--;\n\tmemcpy(new_bus->range + i, bus->range + i + 1,\n\t       (new_bus->dev_count - i) * sizeof(struct kvm_io_range));\nbroken:\n\trcu_assign_pointer(kvm->buses[bus_idx], new_bus);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\tkfree(bus);\n\treturn;\n}", "target": 1}
{"code": "  String_Obj Parser::parse_ie_keyword_arg()\n  {\n    String_Schema_Ptr kwd_arg = SASS_MEMORY_NEW(String_Schema, pstate, 3);\n    if (lex< variable >()) {\n      kwd_arg->append(SASS_MEMORY_NEW(Variable, pstate, Util::normalize_underscores(lexed)));\n    } else {\n      lex< alternatives< identifier_schema, identifier > >();\n      kwd_arg->append(SASS_MEMORY_NEW(String_Constant, pstate, lexed));\n    }\n    lex< exactly<'='> >();\n    kwd_arg->append(SASS_MEMORY_NEW(String_Constant, pstate, lexed));\n    if (peek< variable >()) kwd_arg->append(parse_list());\n    else if (lex< number >()) {\n      std::string parsed(lexed);\n      Util::normalize_decimals(parsed);\n      kwd_arg->append(lexed_number(parsed));\n    }\n    else if (peek < ie_keyword_arg_value >()) { kwd_arg->append(parse_list()); }\n    return kwd_arg;\n  }", "target": 1}
{"code": "generatePreview (const char inFileName[],\n\t\t float exposure,\n\t\t int previewWidth,\n\t\t int &previewHeight,\n\t\t Array2D <PreviewRgba> &previewPixels)\n{\n    RgbaInputFile in (inFileName);\n    Box2i dw = in.dataWindow();\n    float a = in.pixelAspectRatio();\n    int w = dw.max.x - dw.min.x + 1;\n    int h = dw.max.y - dw.min.y + 1;\n    Array2D <Rgba> pixels (h, w);\n    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n    float fx = (previewWidth  > 0)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\t    preview.r = gamma (pixel.r, m);\n\t    preview.g = gamma (pixel.g, m);\n\t    preview.b = gamma (pixel.b, m);\n\t    preview.a = int (IMATH_NAMESPACE::clamp (pixel.a * 255.f, 0.f, 255.f) + .5f);\n\t}\n    }\n}", "target": 1}
{"code": "static int kvm_s390_get_cmma(struct kvm *kvm, struct kvm_s390_cmma_log *args,\n\t\t\t     u8 *res, unsigned long bufsize)\n{\n\tunsigned long mem_end, cur_gfn, next_gfn, hva, pgstev;\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *ms;\n\tcur_gfn = kvm_s390_next_dirty_cmma(slots, args->start_gfn);\n\tms = gfn_to_memslot(kvm, cur_gfn);\n\targs->count = 0;\n\targs->start_gfn = cur_gfn;\n\tif (!ms)\n\t\treturn 0;\n\tnext_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);\n\tmem_end = slots->memslots[0].base_gfn + slots->memslots[0].npages;\n\twhile (args->count < bufsize) {\n\t\thva = gfn_to_hva(kvm, cur_gfn);\n\t\tif (kvm_is_error_hva(hva))\n\t\t\treturn 0;\n\t\tif (test_and_clear_bit(cur_gfn - ms->base_gfn, kvm_second_dirty_bitmap(ms)))\n\t\t\tatomic64_dec(&kvm->arch.cmma_dirty_pages);\n\t\tif (get_pgste(kvm->mm, hva, &pgstev) < 0)\n\t\t\tpgstev = 0;\n\t\tres[args->count++] = (pgstev >> 24) & 0x43;\n\t\tif (next_gfn > cur_gfn + KVM_S390_MAX_BIT_DISTANCE)\n\t\t\treturn 0;\n\t\tif (cur_gfn == next_gfn)\n\t\t\tnext_gfn = kvm_s390_next_dirty_cmma(slots, cur_gfn + 1);\n\t\tif ((next_gfn >= mem_end) ||\n\t\t    (next_gfn - args->start_gfn >= bufsize))\n\t\t\treturn 0;\n\t\tcur_gfn++;\n\t\tif (cur_gfn - ms->base_gfn >= ms->npages) {\n\t\t\tms = gfn_to_memslot(kvm, cur_gfn);\n\t\t\tif (!ms)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "char *curl_easy_unescape(CURL *handle, const char *string, int length,\n                         int *olen)\n{\n  int alloc = (length?length:(int)strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  int strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return NULL;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  return ns;\n}", "target": 1}
{"code": "bool Router::MatchView(const std::string& method, const std::string& url,\n                       bool* stream) {\n  assert(stream != nullptr);\n  *stream = false;\n  for (auto& route : routes_) {\n    if (std::find(route.methods.begin(), route.methods.end(), method) ==\n        route.methods.end()) {\n      continue;\n    }\n    if (route.url.empty()) {\n      std::smatch match;\n      if (std::regex_match(url, match, route.url_regex)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    } else {\n      if (boost::iequals(route.url, url)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "static int update_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tpjsip_hdr *hdr = NULL;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\tif (!datastore || !datastore->data) {\n\t\tast_log(AST_LOG_ERROR, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\thdr = find_header((struct hdr_list *) datastore->data, data->header_name,\n\t\t\t\t\t  data->header_number);\n\tif (!hdr) {\n\t\tast_log(AST_LOG_ERROR, \"There was no header named %s.\\n\", data->header_name);\n\t\treturn -1;\n\t}\n\tpj_strcpy2(&((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);\n\treturn 0;\n}", "target": 1}
{"code": "static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1}
{"code": "qedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n  if(!data)\n    return CURLE_OK;\n  Curl_expire_clear(data); \n  m = data->multi;\n  if(m)\n     curl_multi_remove_handle(data->multi, data);\n  if(data->multi_easy)\n     curl_multi_cleanup(data->multi_easy);\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n  data->magic = 0; \n  if(data->state.rangestringalloc)\n    free(data->state.range);\n  Curl_free_request_state(data);\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n  Curl_resolver_cleanup(data->state.resolver);\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}", "target": 1}
{"code": "CString CZNC::FixupEncoding(const CString& sEncoding) const {\n    if (sEncoding.empty() && m_uiForceEncoding) {\n        return \"UTF-8\";\n    }\n    return sEncoding;\n}", "target": 1}
{"code": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_realloc called with %x,%zu\\n\", ptr, size));\n\tresult = realloc(ptr, size);\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\n\treturn result;\n}", "target": 1}
{"code": "static int codeCompare(\n  Parse *pParse,    \n  Expr *pLeft,      \n  Expr *pRight,     \n  int opcode,       \n  int in1, int in2, \n  int dest,         \n  int jumpIfNull,   \n  int isCommuted    \n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n  if( isCommuted ){\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft);\n  }else{\n    p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  }\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}", "target": 1}
{"code": "privsep_preauth(Authctxt *authctxt)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\tpmonitor = monitor_init();\n\tpmonitor->m_pkex = &active_state->kex;\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init();\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror(\"Could not get agent socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(authctxt, pmonitor);\n\t\tmonitor_sync(pmonitor);\n\t\twhile (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal(\"%s: preauth child exited with status %d\",\n\t\t\t\t    __func__, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: preauth child terminated by signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\t\tset_log_handler(mm_log_handler, pmonitor);\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\t\treturn 0;\n\t}\n}", "target": 1}
{"code": "void UnbufferedAsioTlsStream::BeforeHandshake(handshake_type type)\n{\n\tnamespace ssl = boost::asio::ssl;\n\tif (!m_Hostname.IsEmpty()) {\n\t\tX509_VERIFY_PARAM_set1_host(SSL_get0_param(native_handle()), m_Hostname.CStr(), m_Hostname.GetLength());\n\t}\n\tset_verify_mode(ssl::verify_peer | ssl::verify_client_once);\n\tset_verify_callback([this](bool preverified, ssl::verify_context& ctx) {\n\t\tif (!preverified) {\n\t\t\tm_VerifyOK = false;\n\t\t\tstd::ostringstream msgbuf;\n\t\t\tint err = X509_STORE_CTX_get_error(ctx.native_handle());\n\t\t\tmsgbuf << \"code \" << err << \": \" << X509_verify_cert_error_string(err);\n\t\t\tm_VerifyError = msgbuf.str();\n\t\t}\n\t\treturn true;\n\t});\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n\tif (type == client && !m_Hostname.IsEmpty()) {\n\t\tString environmentName = Application::GetAppEnvironment();\n\t\tString serverName = m_Hostname;\n\t\tif (!environmentName.IsEmpty())\n\t\t\tserverName += \":\" + environmentName;\n\t\tSSL_set_tlsext_host_name(native_handle(), serverName.CStr());\n\t}\n#endif \n}", "target": 1}
{"code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }", "target": 1}
{"code": "x509_vfy_callback_indicate_success(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}", "target": 1}
{"code": "static Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n{\n\tif (val >> (lsr->coord_bits-1) ) {\n\t\ts32 v = val - (1<<lsr->coord_bits);\n\t\treturn INT2FIX(v) / 256 ;\n\t} else {\n\t\treturn INT2FIX(val) / 256;\n\t}\n}", "target": 1}
{"code": "static inline FILE *xfmkstemp(char **tmpname, char *dir)\n{\n\tint fd;\n\tFILE *ret;\n\tfd = xmkstemp(tmpname, dir);\n\tif (fd == -1)\n\t\treturn NULL;\n\tif (!(ret = fdopen(fd, \"w+\" UL_CLOEXECSTR))) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "  static TfLiteRegistration DynamicCopyOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      TfLiteTensor* output0 = GetOutput(context, node, 0);\n      SetTensorToDynamic(output0);\n      const TfLiteTensor* input = GetInput(context, node, 0);\n      TfLiteTensor* output1 = GetOutput(context, node, 1);\n      TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n          context, output1, TfLiteIntArrayCopy(input->dims)));\n      return kTfLiteOk;\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "char* _multi_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 2 );\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "void CommandData::ProcessCommand()\n{\n#ifndef SFX_MODULE\n  const wchar *SingleCharCommands=L\"FUADPXETK\";\n  if (Command[0]!=0 && Command[1]!=0 && wcschr(SingleCharCommands,Command[0])!=NULL || *ArcName==0)\n    OutHelp(*Command==0 ? RARX_SUCCESS:RARX_USERERROR); \n  const wchar *ArcExt=GetExt(ArcName);\n#ifdef _UNIX\n  if (ArcExt==NULL && (!FileExist(ArcName) || IsDir(GetFileAttr(ArcName))))\n    wcsncatz(ArcName,L\".rar\",ASIZE(ArcName));\n#else\n  if (ArcExt==NULL)\n    wcsncatz(ArcName,L\".rar\",ASIZE(ArcName));\n#endif\n  if (ArcExt!=NULL && wcsnicomp(ArcExt,L\".part\",5)==0 && IsDigit(ArcExt[5]) &&\n      !FileExist(ArcName))\n  {\n    wchar Name[NM];\n    wcsncpyz(Name,ArcName,ASIZE(Name));\n    wcsncatz(Name,L\".rar\",ASIZE(Name));\n    if (FileExist(Name))\n      wcsncpyz(ArcName,Name,ASIZE(ArcName));\n  }\n  if (wcschr(L\"AFUMD\",*Command)==NULL)\n  {\n    if (GenerateArcName)\n      GenerateArchiveName(ArcName,ASIZE(ArcName),GenerateMask,false);\n    StringList ArcMasks;\n    ArcMasks.AddString(ArcName);\n    ScanTree Scan(&ArcMasks,Recurse,SaveSymLinks,SCAN_SKIPDIRS);\n    FindData FindData;\n    while (Scan.GetNext(&FindData)==SCAN_SUCCESS)\n      AddArcName(FindData.Name);\n  }\n  else\n    AddArcName(ArcName);\n#endif\n  switch(Command[0])\n  {\n    case 'P':\n    case 'X':\n    case 'E':\n    case 'T':\n    case 'I':\n      {\n        CmdExtract Extract(this);\n        Extract.DoExtract();\n      }\n      break;\n#ifndef SILENT\n    case 'V':\n    case 'L':\n      ListArchive(this);\n      break;\n    default:\n      OutHelp(RARX_USERERROR);\n#endif\n  }\n  if (!BareOutput)\n    mprintf(L\"\\n\");\n}", "target": 1}
{"code": "static int rose_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rose_sock *rose = rose_sk(sk);\n\tstruct sockaddr_rose *srose = (struct sockaddr_rose *)msg->msg_name;\n\tsize_t copied;\n\tunsigned char *asmptr;\n\tstruct sk_buff *skb;\n\tint n, er, qbit;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL)\n\t\treturn er;\n\tqbit = (skb->data[0] & ROSE_Q_BIT) == ROSE_Q_BIT;\n\tskb_pull(skb, ROSE_MIN_LEN);\n\tif (rose->qbitincl) {\n\t\tasmptr  = skb_push(skb, 1);\n\t\t*asmptr = qbit;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n \tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n \tif (srose != NULL) {\n \t\tsrose->srose_family = AF_ROSE;\n \t\tsrose->srose_addr   = rose->dest_addr;\n \t\tsrose->srose_call   = rose->dest_call;\n\t\tsrose->srose_ndigis = rose->dest_ndigis;\n\t\tif (msg->msg_namelen >= sizeof(struct full_sockaddr_rose)) {\n\t\t\tstruct full_sockaddr_rose *full_srose = (struct full_sockaddr_rose *)msg->msg_name;\n\t\t\tfor (n = 0 ; n < rose->dest_ndigis ; n++)\n\t\t\t\tfull_srose->srose_digis[n] = rose->dest_digis[n];\n\t\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_rose);\n\t\t} else {\n\t\t\tif (rose->dest_ndigis >= 1) {\n\t\t\t\tsrose->srose_ndigis = 1;\n\t\t\t\tsrose->srose_digi = rose->dest_digis[0];\n\t\t\t}\n\t\t\tmsg->msg_namelen = sizeof(struct sockaddr_rose);\n\t\t}\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn copied;\n}", "target": 1}
{"code": "CompositeDeepScanLine::setFrameBuffer(const FrameBuffer& fr)\n{\n    _Data->_channels.resize(3);\n    _Data->_channels[0]=\"Z\";\n    _Data->_channels[1]=_Data->_zback ? \"ZBack\" : \"Z\";\n    _Data->_channels[2]=\"A\";\n    _Data->_bufferMap.resize(0);\n    for(FrameBuffer::ConstIterator q=fr.begin();q!=fr.end();q++)\n    {\n        string name(q.name());\n        if(name==\"ZBack\")\n        {\n            _Data->_bufferMap.push_back(1);\n        }else if(name==\"Z\")\n        {\n            _Data->_bufferMap.push_back(0);\n        }else if(name==\"A\")\n        {\n            _Data->_bufferMap.push_back(2);\n        }else{\n            _Data->_bufferMap.push_back(static_cast<int>(_Data->_channels.size()));\n            _Data->_channels.push_back(name);\n        }\n    }\n  _Data->_outputFrameBuffer=fr;\n}", "target": 1}
{"code": "static void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t index = size > 0? (size - 1) % s: 0;\n\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\tindex = 0;\n\t\t}\n\t\tut64 mask = bitmask_by_width[index];\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\t\tif (shift > 0 && shift < 64) {\n\t\t\tr_strbuf_appendf (sb, \"%d,SWAP,0x%\"PFMT64x\",&,<<,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tshift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);\n\t\t} else {\n\t\t\tint dimsize = size % 64;\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",&,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tmask, REG64 (n), regc, VEC64_MASK (shift, dimsize), REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}", "target": 1}
{"code": "bool ContainerNode::replaceChild(PassRefPtr<Node> newChild, Node* oldChild, ExceptionCode& ec, bool shouldLazyAttach)\n{\n    ASSERT(refCount() || parentOrHostNode());\n    RefPtr<Node> protect(this);\n    ec = 0;\n    if (oldChild == newChild) \n        return true;\n    checkReplaceChild(newChild.get(), oldChild, ec);\n    if (ec)\n        return false;\n    if (!oldChild || oldChild->parentNode() != this) {\n        ec = NOT_FOUND_ERR;\n        return false;\n    }\n#if ENABLE(MUTATION_OBSERVERS)\n    ChildListMutationScope mutation(this);\n#endif\n    RefPtr<Node> next = oldChild->nextSibling();\n    RefPtr<Node> removedChild = oldChild;\n    removeChild(oldChild, ec);\n    if (ec)\n        return false;\n    if (next && (next->previousSibling() == newChild || next == newChild)) \n        return true;\n    checkReplaceChild(newChild.get(), oldChild, ec);\n    if (ec)\n        return false;\n    NodeVector targets;\n    collectChildrenAndRemoveFromOldParent(newChild.get(), targets, ec);\n     if (ec)\n         return false;\n     InspectorInstrumentation::willInsertDOMNode(document(), this);\n    for (NodeVector::const_iterator it = targets.begin(); it != targets.end(); ++it) {\n        Node* child = it->get();\n        if (next && next->parentNode() != this)\n            break;\n        if (child->parentNode())\n            break;\n        treeScope()->adoptIfNeeded(child);\n        forbidEventDispatch();\n        if (next)\n            insertBeforeCommon(next.get(), child);\n        else\n            appendChildToContainer(child, this);\n        allowEventDispatch();\n        updateTreeAfterInsertion(this, child, shouldLazyAttach);\n    }\n    dispatchSubtreeModifiedEvent();\n    return true;\n}", "target": 1}
{"code": "static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\tmutex_lock(&swhash->hlist_mutex);\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\t\thlist = kzalloc(sizeof(*hlist), GFP_KERNEL);\n\t\tif (!hlist) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\treturn err;\n}", "target": 1}
{"code": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\torig_rets = args.rets;\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\treturn rc;\nfail:\n\treturn rc;\n}", "target": 1}
{"code": " static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n \t\tunsigned int *rsize)\n {\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n \t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n \t\trdesc[30] = 0x0c;\n \t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static int io_add_buffers(struct io_provide_buf *pbuf, struct io_buffer **head)\n{\n\tstruct io_buffer *buf;\n\tu64 addr = pbuf->addr;\n\tint i, bid = pbuf->bid;\n\tfor (i = 0; i < pbuf->nbufs; i++) {\n\t\tbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\tbuf->addr = addr;\n\t\tbuf->len = pbuf->len;\n\t\tbuf->bid = bid;\n\t\taddr += pbuf->len;\n\t\tbid++;\n\t\tif (!*head) {\n\t\t\tINIT_LIST_HEAD(&buf->list);\n\t\t\t*head = buf;\n\t\t} else {\n\t\t\tlist_add_tail(&buf->list, &(*head)->list);\n\t\t}\n\t}\n\treturn i ? i : -ENOMEM;\n}", "target": 1}
{"code": "bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        if (h.first == \"Strict-Transport-Security\") {\n            header = h.second;\n            if (parseSTSHeader() && maxAgeFound) {\n                expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge);\n                return true;\n            }\n        }\n    }\n    subDomainsFound = false;\n    return false;\n}", "target": 1}
{"code": "read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n \t\t\t\treturn -2;\n \t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n \t\t}\n \t\tif (ret == 0) {\t\t\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n \t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n \t\t}\n \t\tlen_buf_pos += ret;\n\t}\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\tlen = ntohl(*(uint32_t *)len_buf);\n \tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n \t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n \t}\n \tif (!tmpbuf) {\n \t\tif ((tmpbuf = malloc(len)) == NULL) {\n \t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n \t\t}\n \t}\n \tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n \tif (ret == -1) {\n \t\tif (errno == EINTR || errno == EAGAIN)\n \t\t\treturn -2;\n \t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n \t}\n \tif (ret == 0) {\n \t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n \t}\n \ttmpbuf_pos += ret;\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n \t}\n \treturn -2;\n }", "target": 1}
{"code": "int for_each_problem_in_dir(const char *path,\n                        uid_t caller_uid,\n                        int (*callback)(struct dump_dir *dd, void *arg),\n                        void *arg)\n{\n    DIR *dp = opendir(path);\n    if (!dp)\n    {\n        return 0;\n    }\n    int brk = 0;\n    struct dirent *dent;\n    while ((dent = readdir(dp)) != NULL)\n    {\n        if (dot_or_dotdot(dent->d_name))\n            continue; \n        char *full_name = concat_path_file(path, dent->d_name);\n        if (caller_uid == -1 || dump_dir_accessible_by_uid(full_name, caller_uid))\n        {\n            int sv_logmode = logmode;\n            logmode = 0;\n            struct dump_dir *dd = dd_opendir(full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK);\n            logmode = sv_logmode;\n            if (dd)\n            {\n                brk = callback ? callback(dd, arg) : 0;\n                dd_close(dd);\n            }\n        }\n        free(full_name);\n        if (brk)\n            break;\n    }\n    closedir(dp);\n    return brk;\n}", "target": 1}
{"code": "static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)\n{\n    ASSERT(!(n < 4));\n    auto predecessor = n.minus({ 1 });\n    auto d = predecessor;\n    size_t r = 0;\n    {\n        auto div_result = d.divided_by(2);\n        while (div_result.remainder == 0) {\n            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        return n == 2;\n    }\n    for (auto a : tests) {\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {\n                skip_this_witness = true;\n                break;\n            }\n        }\n        if (skip_this_witness)\n            continue;\n        return false; \n    }\n    return true; \n}", "target": 1}
{"code": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}", "target": 1}
{"code": "nfs4_state_set_mode_locked(struct nfs4_state *state, mode_t mode)\n{\n\tif (state->state == mode)\n\t\treturn;\n\tif ((mode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (mode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = mode;\n}", "target": 1}
{"code": "void big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\tkey_payload_reserve(key, 0);\n\tif (key_is_instantiated(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}", "target": 1}
{"code": "unknown_layer_handler(TSS2_RC rc)\n{\n    static __thread char buf[32];\n    clearbuf(buf);\n    catbuf(buf, \"0x%X\", tpm2_error_get(rc));\n    return buf;\n}", "target": 1}
{"code": "copy_thread(unsigned long clone_flags, unsigned long stack_start,\n\t    unsigned long stk_sz, struct task_struct *p)\n{\n\tstruct thread_info *thread = task_thread_info(p);\n\tstruct pt_regs *childregs = task_pt_regs(p);\n\tmemset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));\n\tif (likely(!(p->flags & PF_KTHREAD))) {\n\t\t*childregs = *current_pt_regs();\n\t\tchildregs->ARM_r0 = 0;\n\t\tif (stack_start)\n\t\t\tchildregs->ARM_sp = stack_start;\n\t} else {\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\tclear_ptrace_hw_breakpoint(p);\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value = childregs->ARM_r3;\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\treturn 0;\n}", "target": 1}
{"code": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "yy_symbol_value_print (FILE *yyo,\n                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  FILE *yyoutput = yyo;\n  YY_USE (yyoutput);\n  YY_USE (yylocationp);\n  YY_USE (parm);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yykind < YYNTOKENS)\n    YYPRINT (yyo, yytoknum[yykind], *yyvaluep);\n# endif\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YY_USE (yykind);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}", "target": 1}
{"code": "void pjsua_init_tpselector(pjsua_transport_id tp_id,\n\t\t\t   pjsip_tpselector *sel)\n{\n    pjsua_transport_data *tpdata;\n    unsigned flag;\n    pj_bzero(sel, sizeof(*sel));\n    if (tp_id == PJSUA_INVALID_ID)\n\treturn;\n    pj_assert(tp_id >= 0 && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata));\n    tpdata = &pjsua_var.tpdata[tp_id];\n    flag = pjsip_transport_get_flag_from_type(tpdata->type);\n    if (flag & PJSIP_TRANSPORT_DATAGRAM) {\n\tsel->type = PJSIP_TPSELECTOR_TRANSPORT;\n\tsel->u.transport = tpdata->data.tp;\n    } else {\n\tsel->type = PJSIP_TPSELECTOR_LISTENER;\n\tsel->u.listener = tpdata->data.factory;\n    }\n}", "target": 1}
{"code": "int oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\t} else if (oidc_is_discovery_response(r, c)) {\n\t\treturn oidc_handle_discovery_response(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"logout\")) {\n\t\treturn oidc_handle_logout(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"jwks\")) {\n\t\treturn oidc_handle_jwks(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"session\")) {\n\t\treturn oidc_handle_session_management(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"refresh\")) {\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"request_uri\")) {\n\t\treturn oidc_handle_request_uri(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"remove_at_cache\")) {\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\tif (oidc_util_request_has_parameter(r, \"error\")) {\n\t\toidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request: %s\",\n\t\t\t\t\tr->args), HTTP_INTERNAL_SERVER_ERROR);\n}", "target": 1}
{"code": "static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n\tstruct ddpehdr *ddp;\n\tint copied = 0;\n\tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n\tif (!err) {\n\t\tif (sat) {\n\t\t\tsat->sat_family      = AF_APPLETALK;\n\t\t\tsat->sat_port        = ddp->deh_sport;\n\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*sat);\n\t}\n\tskb_free_datagram(sk, skb);\t\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, Stream_Pointer(irp->input), Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "hstoreArrayToPairs(ArrayType *a, int *npairs)\n{\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tPairs\t   *key_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tdeconstruct_array(a,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\tif (key_count == 0)\n\t{\n\t\t*npairs = 0;\n \t\treturn NULL;\n \t}\n \tkey_pairs = palloc(sizeof(Pairs) * key_count);\n \tfor (i = 0, j = 0; i < key_count; i++)\n\t{\n\t\tif (!key_nulls[i])\n\t\t{\n\t\t\tkey_pairs[j].key = VARDATA(key_datums[i]);\n\t\t\tkey_pairs[j].keylen = VARSIZE(key_datums[i]) - VARHDRSZ;\n\t\t\tkey_pairs[j].val = NULL;\n\t\t\tkey_pairs[j].vallen = 0;\n\t\t\tkey_pairs[j].needfree = 0;\n\t\t\tkey_pairs[j].isnull = 1;\n\t\t\tj++;\n\t\t}\n\t}\n\t*npairs = hstoreUniquePairs(key_pairs, j, &bufsiz);\n\treturn key_pairs;\n}", "target": 1}
{"code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n    if( n < 1 || n > 65535 || *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n    *p += n;\n    return( 0 );\n}", "target": 1}
{"code": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;\n}", "target": 1}
{"code": "struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"%s\", name);\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"%s-all\", name);\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\treturn crypto_larval_add(name, type, mask);\n}", "target": 1}
{"code": "static void test_jwt_token_escape(void)\n{\n\tstruct test_case {\n\t\tconst char *azp;\n\t\tconst char *alg;\n\t\tconst char *kid;\n\t\tconst char *esc_azp;\n\t\tconst char *esc_kid;\n\t} test_cases[] = {\n\t\t{ \"\", \"hs256\", \"\", \"default\", \"default\" },\n\t\t{ \"\", \"hs256\", \"test\", \"default\", \"test\" },\n\t\t{ \"test\", \"hs256\", \"test\", \"test\", \"test\" },\n\t\t{\n\t\t\t\"http:\n\t\t\t\"hs256\",\n\t\t\t\"http:\n\t\t\t\"http:%2f%2ftest%2eunit%2flocal%25key\",\n\t\t\t\"http:%2f%2ftest%2eunit%2flocal%25key\"\n\t\t},\n\t\t{ \"../\", \"hs256\", \"../\", \"%2e%2e%2f\", \"%2e%2e%2f\" },\n\t};\n\tbuffer_t *b64_key =\n\t\tt_base64_encode(0, SIZE_MAX, hs_sign_key->data, hs_sign_key->used);\n\tARRAY_TYPE(oauth2_field) fields;\n\tt_array_init(&fields, 8);\n\tfor (size_t i = 0; i < N_ELEMENTS(test_cases); i++) {\n\t\tconst struct test_case *test_case = &test_cases[i];\n\t\tarray_clear(&fields);\n\t\tstruct oauth2_field *field = array_append_space(&fields);\n\t\tfield->name = \"sub\";\n\t\tfield->value = \"testuser\";\n\t\tif (*test_case->azp != '\\0') {\n\t\t\tfield = array_append_space(&fields);\n\t\t\tfield->name = \"azp\";\n\t\t\tfield->value = test_case->azp;\n\t\t}\n\t\tif (*test_case->kid != '\\0') {\n\t\t\tfield = array_append_space(&fields);\n\t\t\tfield->name = \"kid\";\n\t\t\tfield->value = test_case->kid;\n\t\t}\n\t\tsave_key_azp_to(test_case->alg, test_case->esc_azp, test_case->esc_kid,\n\t\t\t\tstr_c(b64_key));\n\t\tbuffer_t *token = create_jwt_token_fields_kid(test_case->alg,\n\t\t\t\t\t\t\t      test_case->kid,\n\t\t\t\t\t\t\t      time(NULL)+500,\n\t\t\t\t\t\t\t      time(NULL)-500,\n\t\t\t\t\t\t\t      0, &fields);\n\t\tsign_jwt_token_hs256(token, hs_sign_key);\n\t\ttest_jwt_token(str_c(token));\n\t}\n}", "target": 1}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n \t\t.index_key.type\t\t= type,\n \t\t.index_key.description\t= description,\n \t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n \t\t.match_data.raw_data\t= description,\n \t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n \t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n \t};\n \tkey_ref_t key;\n \tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n \tif (type->match_preparse) {\n \t\tret = type->match_preparse(&ctx.match_data);\n \t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "static int valid_entry_name(const char *filename)\n{\n\treturn *filename != '\\0' &&\n\t\tstrchr(filename, '/') == NULL &&\n\t\t(*filename != '.' ||\n\t\t (strcmp(filename, \".\") != 0 &&\n\t\t  strcmp(filename, \"..\") != 0 &&\n\t\t  strcmp(filename, DOT_GIT) != 0));\n}", "target": 1}
{"code": "  Compound_Selector_Ptr Simple_Selector::unify_with(Compound_Selector_Ptr rhs)\n  {\n    for (size_t i = 0, L = rhs->length(); i < L; ++i)\n    { if (to_string() == rhs->at(i)->to_string()) return rhs; }\n    size_t i, L;\n    bool found = false;\n    if (typeid(*this) == typeid(Pseudo_Selector) || typeid(*this) == typeid(Wrapped_Selector))\n    {\n      for (i = 0, L = rhs->length(); i < L; ++i)\n      {\n        if ((Cast<Pseudo_Selector>((*rhs)[i]) || Cast<Wrapped_Selector>((*rhs)[i])) && (*rhs)[L-1]->is_pseudo_element())\n        { found = true; break; }\n      }\n    }\n    else\n    {\n      for (i = 0, L = rhs->length(); i < L; ++i)\n      {\n        if (Cast<Pseudo_Selector>((*rhs)[i]) || Cast<Wrapped_Selector>((*rhs)[i]))\n        { found = true; break; }\n      }\n    }\n    if (!found)\n    {\n      rhs->append(this);\n      return rhs;\n    }\n    rhs->elements().insert(rhs->elements().begin() + i, this);\n    return rhs;\n  }", "target": 1}
{"code": "static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk)\n{\n\tconst struct net *net = sock_net(sk);\n\tint mss;\n\tif (!net->ipv4.sysctl_tcp_mtu_probing)\n\t\treturn;\n\tif (!icsk->icsk_mtup.enabled) {\n\t\ticsk->icsk_mtup.enabled = 1;\n\t\ticsk->icsk_mtup.probe_timestamp = tcp_jiffies32;\n\t} else {\n\t\tmss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1;\n\t\tmss = min(net->ipv4.sysctl_tcp_base_mss, mss);\n\t\tmss = max(mss, 68 - tcp_sk(sk)->tcp_header_len);\n\t\ticsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss);\n\t}\n\ttcp_sync_mss(sk, icsk->icsk_pmtu_cookie);\n}", "target": 1}
{"code": "deltas_head_for_each(struct deltas_head *deltas, unsigned long max_serial,\n    unsigned long from_serial, delta_head_cb cb, void *arg)\n{\n\tsize_t index;\n\tsize_t from;\n\tint error;\n\tif (deltas->capacity == 0) {\n\t\tpr_val_warn(\"There's no delta list to process.\");\n\t\treturn -ENOENT;\n\t}\n\tpr_val_debug(\"Getting RRDP deltas from serial %lu to %lu.\", from_serial,\n\t    max_serial);\n\tfrom = deltas->capacity - (max_serial - from_serial);\n\tfor (index = from; index < deltas->capacity; index++) {\n\t\terror = cb(deltas->array[index], arg);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct l2tp_session *session;\n\tstruct l2tp_tunnel *tunnel;\n\tstruct pppol2tp_session *ps;\n\tint val;\n\tint err;\n\tif (level != SOL_PPPOL2TP)\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\terr = -ENOTCONN;\n\tif (sk->sk_user_data == NULL)\n\t\tgoto end;\n\terr = -EBADF;\n\tsession = pppol2tp_sock_to_session(sk);\n\tif (session == NULL)\n\t\tgoto end;\n\tps = l2tp_session_priv(session);\n\tif ((session->session_id == 0) &&\n\t    (session->peer_session_id == 0)) {\n\t\terr = -EBADF;\n\t\ttunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n\t\tif (tunnel == NULL)\n\t\t\tgoto end_put_sess;\n\t\terr = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\n\t\tsock_put(ps->tunnel_sock);\n\t} else\n\t\terr = pppol2tp_session_setsockopt(sk, session, optname, val);\n\terr = 0;\nend_put_sess:\n\tsock_put(sk);\nend:\n\treturn err;\n}", "target": 1}
{"code": "static void read_version(struct pbap_data *pbap, GObexApparam *apparam)\n{\n\tconst guint8 *data;\n\tuint8_t value[16];\n\tgsize len;\n\tif (!(pbap->supported_features & FOLDER_VERSION_FEATURE))\n\t\treturn;\n\tif (!g_obex_apparam_get_bytes(apparam, PRIMARY_COUNTER_TAG, &data,\n\t\t\t\t\t\t\t\t&len)) {\n\t\tlen = sizeof(value);\n\t\tmemset(value, 0, len);\n\t\tdata = value;\n\t}\n\tif (memcmp(pbap->primary, data, len)) {\n\t\tmemcpy(pbap->primary, data, len);\n\t\tg_dbus_emit_property_changed(conn,\n\t\t\t\t\tobc_session_get_path(pbap->session),\n\t\t\t\t\tPBAP_INTERFACE, \"PrimaryCounter\");\n\t}\n\tif (!g_obex_apparam_get_bytes(apparam, SECONDARY_COUNTER_TAG, &data,\n\t\t\t\t\t\t\t\t&len)) {\n\t\tlen = sizeof(value);\n\t\tmemset(value, 0, len);\n\t\tdata = value;\n\t}\n\tif (memcmp(pbap->secondary, data, len)) {\n\t\tmemcpy(pbap->secondary, data, len);\n\t\tg_dbus_emit_property_changed(conn,\n\t\t\t\t\tobc_session_get_path(pbap->session),\n\t\t\t\t\tPBAP_INTERFACE, \"SecondaryCounter\");\n\t}\n}", "target": 1}
{"code": "hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[0], regs[1]);\n    regs += 2;\n  }\n  return hash;\n}", "target": 1}
{"code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\tunsigned short iport, rport;\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n \trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n \tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\tif (!int_port || !ext_port || !protocol)\n \t{\n \t\tClearNameValueList(&data);\n \t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\tr = -1;\n\tswitch(r)\n\t{\n\t\tcase 1:\t\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "target": 1}
{"code": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tdown_read(&keyring_key->sem);\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\n\tup_read(&keyring_key->sem);\n\tif (res)\n\t\tgoto out;\n\tcrypt_info->ci_keyring_key = keyring_key;\n\treturn 0;\nout:\n\tkey_put(keyring_key);\n\treturn res;\n}", "target": 1}
{"code": "char *get_56_lenc_string(char **buffer,\n                         size_t *max_bytes_available,\n                         size_t *string_length)\n{\n  static char empty_string[1]= { '\\0' };\n  char *begin= *buffer;\n  if (*max_bytes_available == 0)\n    return NULL;\n  if (*begin == 0)\n  {\n    *string_length= 0;\n    --*max_bytes_available;\n    ++*buffer;\n    return empty_string;\n  }\n  *string_length= (size_t)net_field_length_ll((uchar **)buffer);\n  DBUG_EXECUTE_IF(\"sha256_password_scramble_too_long\",\n                  *string_length= SIZE_T_MAX;\n  );\n  size_t len_len= (size_t)(*buffer - begin);\n  if (*string_length > *max_bytes_available - len_len)\n    return NULL;\n  *max_bytes_available -= *string_length;\n  *max_bytes_available -= len_len;\n  *buffer += *string_length;\n  return (char *)(begin + len_len);\n}", "target": 1}
{"code": "static int aac_sync(uint64_t state, AACAC3ParseContext *hdr_info,\n        int *need_next_header, int *new_frame_start)\n{\n    GetBitContext bits;\n    AACADTSHeaderInfo hdr;\n     int size;\n     union {\n         uint64_t u64;\n        uint8_t  u8[8];\n     } tmp;\n     tmp.u64 = av_be2ne64(state);\n    init_get_bits(&bits, tmp.u8+8-AAC_ADTS_HEADER_SIZE, AAC_ADTS_HEADER_SIZE * 8);\n    if ((size = avpriv_aac_parse_header(&bits, &hdr)) < 0)\n        return 0;\n    *need_next_header = 0;\n    *new_frame_start  = 1;\n    hdr_info->sample_rate = hdr.sample_rate;\n    hdr_info->channels    = ff_mpeg4audio_channels[hdr.chan_config];\n    hdr_info->samples     = hdr.samples;\n    hdr_info->bit_rate    = hdr.bit_rate;\n    return size;\n}", "target": 1}
{"code": "unsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (tgt_clobbers & ~site_clobbers)\n\t\treturn len;\t\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe8; \n\tb->delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\treturn 5;\n}", "target": 1}
{"code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n \tconst char *correct;\n \tPgUser *user = client->auth_user;\n \tif (!*passwd || !*user->passwd)\n \t\treturn false;\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "void macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}", "target": 1}
{"code": "static void timer_enter_running(Timer *t) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        int r;\n        assert(t);\n        if (unit_stop_pending(UNIT(t)))\n                return;\n        r = manager_add_job(UNIT(t)->manager, JOB_START, UNIT_TRIGGER(UNIT(t)),\n                            JOB_REPLACE, true, &error, NULL);\n        if (r < 0)\n                goto fail;\n        dual_timestamp_get(&t->last_trigger);\n        if (t->stamp_path)\n                touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, 0);\n        timer_set_state(t, TIMER_RUNNING);\n        return;\nfail:\n        log_unit_warning(UNIT(t), \"Failed to queue unit startup job: %s\", bus_error_message(&error, r));\n        timer_enter_dead(t, TIMER_FAILURE_RESOURCES);\n}", "target": 1}
{"code": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}", "target": 1}
{"code": "alloc_limit_assert (char *fn_name, size_t size)\n{\n    if (alloc_limit && size > alloc_limit)\n    {\n\talloc_limit_failure (fn_name, size);\n\texit (-1);\n    }\n}", "target": 1}
{"code": "static int udp_v6_push_pending_frames(struct sock *sk)\n{\n\tstruct sk_buff *skb;\n\tstruct udphdr *uh;\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi6 *fl6 = &inet->cork.fl.u.ip6;\n\tint err = 0;\n\tint is_udplite = IS_UDPLITE(sk);\n\t__wsum csum = 0;\n\tif ((skb = skb_peek(&sk->sk_write_queue)) == NULL)\n\t\tgoto out;\n\tuh = udp_hdr(skb);\n\tuh->source = fl6->fl6_sport;\n\tuh->dest = fl6->fl6_dport;\n\tuh->len = htons(up->len);\n\tuh->check = 0;\n\tif (is_udplite)\n\t\tcsum = udplite_csum_outgoing(sk, skb);\n\telse if (skb->ip_summed == CHECKSUM_PARTIAL) { \n\t\tudp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,\n\t\t\t\t     up->len);\n\t\tgoto send;\n\t} else\n\t\tcsum = udp_csum_outgoing(sk, skb);\n\tuh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,\n\t\t\t\t    up->len, fl6->flowi6_proto, csum);\n\tif (uh->check == 0)\n\t\tuh->check = CSUM_MANGLED_0;\nsend:\n\terr = ip6_push_pending_frames(sk);\n\tif (err) {\n\t\tif (err == -ENOBUFS && !inet6_sk(sk)->recverr) {\n\t\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t    UDP_MIB_SNDBUFERRORS, is_udplite);\n\t\t\terr = 0;\n\t\t}\n\t} else\n\t\tUDP6_INC_STATS_USER(sock_net(sk),\n\t\t\t\t    UDP_MIB_OUTDATAGRAMS, is_udplite);\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}", "target": 1}
{"code": "main(int argc, char *argv[])\n{\n  int cnt,rc,cc;\n  char cmnd[255];\n  strcpy(cmnd, CMD);\n  if (argc > 1)\n  {\n    for (cnt = 1; cnt < argc; cnt++)\n    {\n      strcat(cmnd, \" \");\n      strcat(cmnd, argv[cnt]);\n    }\n  }\n  else\n  {\n    fprintf(stderr, \"__ %s:  failed %d  %d\\n\", argv[0], rc, cc);\n    return 255;\n  }\n  cc = setuid(UID);\n  rc = system(cmnd);\n  if ((rc != 0) || (cc != 0))\n  {\n    fprintf(stderr, \"__ %s:  failed %d  %d\\n\", argv[0], rc, cc);\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "messageFindArgument(const message *m, const char *variable)\n{\n\tint i;\n\tsize_t len;\n\tassert(m != NULL);\n\tassert(variable != NULL);\n\tlen = strlen(variable);\n\tfor(i = 0; i < m->numberOfArguments; i++) {\n\t\tconst char *ptr;\n\t\tptr = messageGetArgument(m, i);\n\t\tif((ptr == NULL) || (*ptr == '\\0'))\n\t\t\tcontinue;\n#ifdef\tCL_DEBUG\n\t\tcli_dbgmsg(\"messageFindArgument: compare %lu bytes of %s with %s\\n\",\n\t\t\t(unsigned long)len, variable, ptr);\n#endif\n\t\tif(strncasecmp(ptr, variable, len) == 0) {\n\t\t\tptr = &ptr[len];\n\t\t\twhile(isspace(*ptr))\n\t\t\t\tptr++;\n\t\t\tif(*ptr != '=') {\n\t\t\t\tcli_dbgmsg(\"messageFindArgument: no '=' sign found in MIME header '%s' (%s)\\n\", variable, messageGetArgument(m, i));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif((*++ptr == '\"') && (strchr(&ptr[1], '\"') != NULL)) {\n\t\t\t\tchar *ret = cli_strdup(++ptr);\n\t\t\t\tchar *p;\n\t\t\t\tif(ret == NULL)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif((p = strchr(ret, '\"')) != NULL) {\n\t\t\t\t\tret[strlen(ret) - 1] = '\\0';\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn cli_strdup(ptr);\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "int rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,\n                               int64_t i_pts )\n{\n    if (fmtp == NULL)\n        return VLC_EGENERIC;\n    char *start = strstr(fmtp, \"configuration=\");\n    assert(start != NULL);\n    start += sizeof(\"configuration=\") - 1;\n    char *end = strchr(start, ';');\n    assert(end != NULL);\n    size_t len = end - start;\n    char b64[len + 1];\n    memcpy(b64, start, len);\n    b64[len] = '\\0';\n    int     i_max   = rtp_mtu (id) - 6; \n    uint8_t *p_orig, *p_data;\n    int i_data;\n    i_data = vlc_b64_decode_binary(&p_orig, b64);\n    if (i_data <= 9)\n    {\n        free(p_orig);\n        return VLC_EGENERIC;\n    }\n    p_data = p_orig + 9;\n    i_data -= 9;\n    int i_count = ( i_data + i_max - 1 ) / i_max;\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (1 << 4) | numpkts;\n        rtp_packetize_common( id, out, 0, i_pts );\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n        out->i_dts    = i_pts;\n        rtp_packetize_send( id, out );\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n    free(p_orig);\n    return VLC_SUCCESS;\n}", "target": 1}
{"code": "bool DoResolveRelativeHost(const char* base_url,\n                           const url_parse::Parsed& base_parsed,\n                           const CHAR* relative_url,\n                           const url_parse::Component& relative_component,\n                           CharsetConverter* query_converter,\n                           CanonOutput* output,\n                           url_parse::Parsed* out_parsed) {\n   url_parse::Parsed relative_parsed;  \n  url_parse::ParseAfterScheme(&relative_url[relative_component.begin],\n                              relative_component.len, relative_component.begin,\n                              &relative_parsed);\n  Replacements<CHAR> replacements;\n  replacements.SetUsername(relative_url, relative_parsed.username);\n  replacements.SetPassword(relative_url, relative_parsed.password);\n  replacements.SetHost(relative_url, relative_parsed.host);\n  replacements.SetPort(relative_url, relative_parsed.port);\n  replacements.SetPath(relative_url, relative_parsed.path);\n  replacements.SetQuery(relative_url, relative_parsed.query);\n  replacements.SetRef(relative_url, relative_parsed.ref);\n  return ReplaceStandardURL(base_url, base_parsed, replacements,\n                            query_converter, output, out_parsed);\n}", "target": 1}
{"code": "inline void aligned_free(void* ptr) {\n  folly::detail::aligned_free(ptr);\n}", "target": 1}
{"code": "void CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||\n                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}", "target": 1}
{"code": "static MagickBooleanType WriteMSLImage(const ImageInfo *image_info,Image *image,\n  ExceptionInfo *exception)\n{\n  Image\n    *msl_image;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  msl_image=CloneImage(image,0,0,MagickTrue,exception);\n  return(ProcessMSLScript(image_info,&msl_image,exception));\n}", "target": 1}
{"code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   \n    size_t dsize;                  \n    unsigned char *buf = 0;\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}", "target": 1}
{"code": "brcmf_wowl_nd_results(struct brcmf_if *ifp, const struct brcmf_event_msg *e,\n\t\t      void *data)\n{\n\tstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\n\tstruct wiphy *wiphy = cfg_to_wiphy(cfg);\n\tstruct brcmf_pno_scanresults_le *pfn_result;\n\tstruct brcmf_pno_net_info_le *netinfo;\n\tbrcmf_dbg(SCAN, \"Enter\\n\");\n\tif (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) {\n\t\tbrcmf_dbg(SCAN, \"Event data to small. Ignore\\n\");\n\t\treturn 0;\n\t}\n\tpfn_result = (struct brcmf_pno_scanresults_le *)data;\n\tif (e->event_code == BRCMF_E_PFN_NET_LOST) {\n\t\tbrcmf_dbg(SCAN, \"PFN NET LOST event. Ignore\\n\");\n\t\treturn 0;\n\t}\n\tif (le32_to_cpu(pfn_result->count) < 1) {\n\t\tbphy_err(wiphy, \"Invalid result count, expected 1 (%d)\\n\",\n\t\t\t le32_to_cpu(pfn_result->count));\n\t\treturn -EINVAL;\n\t}\n\tnetinfo = brcmf_get_netinfo_array(pfn_result);\n\tmemcpy(cfg->wowl.nd->ssid.ssid, netinfo->SSID, netinfo->SSID_len);\n\tcfg->wowl.nd->ssid.ssid_len = netinfo->SSID_len;\n\tcfg->wowl.nd->n_channels = 1;\n\tcfg->wowl.nd->channels[0] =\n\t\tieee80211_channel_to_frequency(netinfo->channel,\n\t\t\tnetinfo->channel <= CH_MAX_2G_CHANNEL ?\n\t\t\t\t\tNL80211_BAND_2GHZ : NL80211_BAND_5GHZ);\n\tcfg->wowl.nd_info->n_matches = 1;\n\tcfg->wowl.nd_info->matches[0] = cfg->wowl.nd;\n\tcfg->wowl.nd_data_completed = true;\n\twake_up(&cfg->wowl.nd_data_wait);\n\treturn 0;\n}", "target": 1}
{"code": "Field *create_tmp_field_from_field(THD *thd, Field *org_field,\n                                   const char *name, TABLE *table,\n                                   Item_field *item)\n{\n  Field *new_field;\n  new_field= org_field->make_new_field(thd->mem_root, table,\n                                       table == org_field->table);\n  if (new_field)\n  {\n    new_field->init(table);\n    new_field->orig_table= org_field->orig_table;\n    if (item)\n      item->result_field= new_field;\n    else\n      new_field->field_name= name;\n    new_field->flags|= (org_field->flags & NO_DEFAULT_VALUE_FLAG);\n    if (org_field->maybe_null() || (item && item->maybe_null))\n      new_field->flags&= ~NOT_NULL_FLAG;\t\n    if (org_field->type() == MYSQL_TYPE_VAR_STRING ||\n        org_field->type() == MYSQL_TYPE_VARCHAR)\n      table->s->db_create_options|= HA_OPTION_PACK_RECORD;\n    else if (org_field->type() == FIELD_TYPE_DOUBLE)\n      ((Field_double *) new_field)->not_fixed= TRUE;\n    new_field->vcol_info= 0;\n    new_field->cond_selectivity= 1.0;\n    new_field->next_equal_field= NULL;\n    new_field->option_list= NULL;\n    new_field->option_struct= NULL;\n  }\n  return new_field;\n}", "target": 1}
{"code": "void DCR_CLASS dcr_cam_xyz_coeff (DCRAW* p, double cam_xyz[4][3])\n{\n\tdouble cam_rgb[4][3], inverse[4][3], num;\n\tint i, j, k;\n\tfor (i=0; i < p->colors; i++)\t\t\n\t\tfor (j=0; j < 3; j++)\n\t\t\tfor (cam_rgb[i][j] = k=0; k < 3; k++)\n\t\t\t\tcam_rgb[i][j] += cam_xyz[i][k] * xyz_rgb[k][j];\n\tfor (i=0; i < p->colors; i++) {\t\t\n\t\tfor (num=j=0; j < 3; j++)\t\t\n\t\t\tnum += cam_rgb[i][j];\n\t\tfor (j=0; j < 3; j++)\n\t\t\tcam_rgb[i][j] /= num;\n\t\tp->pre_mul[i] = 1 / (float)num;\n\t}\n\tdcr_pseudoinverse (cam_rgb, inverse, p->colors);\n\tfor (p->raw_color = i=0; i < 3; i++)\n\t\tfor (j=0; j < p->colors; j++)\n\t\t\tp->rgb_cam[i][j] = (float)inverse[j][i];\n}", "target": 1}
{"code": "static int rds_ib_laddr_check(__be32 addr)\n{\n\tint ret;\n\tstruct rdma_cm_id *cm_id;\n\tstruct sockaddr_in sin;\n\tcm_id = rdma_create_id(NULL, NULL, RDMA_PS_TCP, IB_QPT_RC);\n\tif (IS_ERR(cm_id))\n\t\treturn PTR_ERR(cm_id);\n\tmemset(&sin, 0, sizeof(sin));\n\tsin.sin_family = AF_INET;\n\tsin.sin_addr.s_addr = addr;\n \tret = rdma_bind_addr(cm_id, (struct sockaddr *)&sin);\n\tif (ret || cm_id->device->node_type != RDMA_NODE_IB_CA)\n \t\tret = -EADDRNOTAVAIL;\n \trdsdebug(\"addr %pI4 ret %d node type %d\\n\",\n\t\t&addr, ret,\n\t\tcm_id->device ? cm_id->device->node_type : -1);\n\trdma_destroy_id(cm_id);\n\treturn ret;\n}", "target": 1}
{"code": "static void br_multicast_del_pg(struct net_bridge *br,\n\t\t\t\tstruct net_bridge_port_group *pg)\n{\n\tstruct net_bridge_mdb_htable *mdb;\n\tstruct net_bridge_mdb_entry *mp;\n\tstruct net_bridge_port_group *p;\n\tstruct net_bridge_port_group __rcu **pp;\n\tmdb = mlock_dereference(br->mdb, br);\n\tmp = br_mdb_ip_get(mdb, &pg->addr);\n\tif (WARN_ON(!mp))\n\t\treturn;\n\tfor (pp = &mp->ports;\n\t     (p = mlock_dereference(*pp, br)) != NULL;\n\t     pp = &p->next) {\n\t\tif (p != pg)\n\t\t\tcontinue;\n\t\trcu_assign_pointer(*pp, p->next);\n\t\thlist_del_init(&p->mglist);\n \t\tdel_timer(&p->timer);\n \t\tcall_rcu_bh(&p->rcu, br_multicast_free_pg);\n\t\tif (!mp->ports && !mp->mglist &&\n \t\t    netif_running(br->dev))\n \t\t\tmod_timer(&mp->timer, jiffies);\n\t\treturn;\n\t}\n\tWARN_ON(1);\n}", "target": 1}
{"code": "static int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tstruct ip_tunnel *t;\n\tint err;\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\tsitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;\n\tsitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\n\terr = register_netdev(sitn->fb_tunnel_dev);\n\tif (err)\n\t\tgoto err_reg_dev;\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\tt = netdev_priv(sitn->fb_tunnel_dev);\n\tstrcpy(t->parms.name, sitn->fb_tunnel_dev->name);\n\treturn 0;\n err_reg_dev:\n \tipip6_dev_free(sitn->fb_tunnel_dev);\n err_alloc_dev:\n \treturn err;\n }", "target": 1}
{"code": "bool PlatformFontSkia::InitDefaultFont() {\n  if (g_default_font.Get())\n    return true;\n   bool success = false;\n   std::string family = kFallbackFontFamilyName;\n  int size_pixels = 12;\n   int style = Font::NORMAL;\n   Font::Weight weight = Font::Weight::NORMAL;\n   FontRenderParams params;\n  const SkiaFontDelegate* delegate = SkiaFontDelegate::instance();\n  if (delegate) {\n    delegate->GetDefaultFontDescription(&family, &size_pixels, &style, &weight,\n                                        &params);\n  } else if (default_font_description_) {\n#if defined(OS_CHROMEOS)\n    FontRenderParamsQuery query;\n    CHECK(FontList::ParseDescription(*default_font_description_,\n                                     &query.families, &query.style,\n                                     &query.pixel_size, &query.weight))\n        << \"Failed to parse font description \" << *default_font_description_;\n    params = gfx::GetFontRenderParams(query, &family);\n    size_pixels = query.pixel_size;\n    style = query.style;\n    weight = query.weight;\n#else\n    NOTREACHED();\n#endif\n  }\n  sk_sp<SkTypeface> typeface =\n      CreateSkTypeface(style & Font::ITALIC, weight, &family, &success);\n  if (!success)\n    return false;\n  g_default_font.Get() = new PlatformFontSkia(\n      std::move(typeface), family, size_pixels, style, weight, params);\n  return true;\n}", "target": 1}
{"code": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; \n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval) return retval; \n\tbprm->argc++;\n\tbprm->interp = interp;\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}", "target": 1}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n \t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n \t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n \t\t\t}\n \t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n \t\tch = (sctp_chunkhdr_t *) ch_end;\n \t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n \t\treturn -ENOTCONN;\n \t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n \taddr = (struct sockaddr_atmpvc *)sockaddr;\n \taddr->sap_family = AF_ATMPVC;\n \taddr->sap_addr.itf = vcc->dev->number;\n \taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}", "target": 1}
{"code": "QPDFWriter::enqueueObject(QPDFObjectHandle object)\n{\n    if (object.isIndirect())\n    {\n        if (object.getOwningQPDF() != &(this->pdf))\n        {\n            QTC::TC(\"qpdf\", \"QPDFWriter foreign object\");\n            throw std::logic_error(\n                \"QPDFObjectHandle from different QPDF found while writing.\"\n                \"  Use QPDF::copyForeignObject to add objects from\"\n                \" another file.\");\n        }\n\tQPDFObjGen og = object.getObjGen();\n\tif (obj_renumber.count(og) == 0)\n\t{\n\t    if (this->object_to_object_stream.count(og))\n\t    {\n\t\tint stream_id = this->object_to_object_stream[og];\n\t\tenqueueObject(this->pdf.getObjectByID(stream_id, 0));\n\t    }\n\t    else\n\t    {\n\t\tobject_queue.push_back(object);\n\t\tobj_renumber[og] = next_objid++;\n\t\tif ((og.getGen() == 0) &&\n                    this->object_stream_to_objects.count(og.getObj()))\n\t\t{\n\t\t    if (! this->linearized)\n\t\t    {\n\t\t\tassignCompressedObjectNumbers(og);\n\t\t    }\n\t\t}\n\t\telse if ((! this->direct_stream_lengths) && object.isStream())\n\t\t{\n\t\t    ++next_objid;\n\t\t}\n\t    }\n\t}\n    }\n    else if (object.isArray())\n    {\n\tint n = object.getArrayNItems();\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getArrayItem(i));\n\t    }\n\t}\n    }\n    else if (object.isDictionary())\n    {\n\tstd::set<std::string> keys = object.getKeys();\n\tfor (std::set<std::string>::iterator iter = keys.begin();\n\t     iter != keys.end(); ++iter)\n\t{\n\t    if (! this->linearized)\n\t    {\n\t\tenqueueObject(object.getKey(*iter));\n\t    }\n\t}\n    }\n    else\n    {\n    }\n}", "target": 1}
{"code": "void AICast_ScriptLoad( void ) {\n\tchar filename[MAX_QPATH];\n\tvmCvar_t mapname;\n\tfileHandle_t f;\n\tint len;\n\tlevel.scriptAI = NULL;\n\ttrap_Cvar_VariableStringBuffer( \"ai_scriptName\", filename, sizeof( filename ) );\n\tif ( strlen( filename ) > 0 ) {\n\t\ttrap_Cvar_Register( &mapname, \"ai_scriptName\", \"\", CVAR_ROM );\n\t} else {\n\t\ttrap_Cvar_Register( &mapname, \"mapname\", \"\", CVAR_SERVERINFO | CVAR_ROM );\n\t}\n\tQ_strncpyz( filename, \"maps/\", sizeof( filename ) );\n\tQ_strcat( filename, sizeof( filename ), mapname.string );\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tQ_strcat( filename, sizeof( filename ), \".coop.ai\" );\n\t} else {\n\t\tQ_strcat( filename, sizeof( filename ), \".ai\" );\n\t}\n\tlen = trap_FS_FOpenFile( filename, &f, FS_READ );\n\tG_Printf( \"Loading: %s\\n\", filename );\n\tif ( len < 0 ) {\n\t\treturn;\n\t}\n\tlevel.scriptAI = G_Alloc( len );\n\ttrap_FS_Read( level.scriptAI, len, f );\n\ttrap_FS_FCloseFile( f );\n\treturn;\n}", "target": 1}
{"code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; id->name[i] && i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "target": 1}
{"code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tR_FREE (bb);\n}", "target": 1}
{"code": "static int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\twrite_lock(&rfcomm_sk_list.lock);\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\twrite_unlock(&rfcomm_sk_list.lock);\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 1}
{"code": "int CLASS ljpeg_start (struct jhead *jh, int info_only)\n{\n  int c, tag, len;\n  uchar data[0x10000];\n  const uchar *dp;\n  memset (jh, 0, sizeof *jh);\n  jh->restart = INT_MAX;\n  fread (data, 2, 1, ifp);\n  if (data[1] != 0xd8) return 0;\n  do {\n    fread (data, 2, 2, ifp);\n    tag =  data[0] << 8 | data[1];\n    len = (data[2] << 8 | data[3]) - 2;\n    if (tag <= 0xff00) return 0;\n    fread (data, 1, len, ifp);\n    switch (tag) {\n      case 0xffc3:\n\tjh->sraw = ((data[7] >> 4) * (data[7] & 15) - 1) & 3;\n      case 0xffc0:\n\tjh->bits = data[0];\n\tjh->high = data[1] << 8 | data[2];\n\tjh->wide = data[3] << 8 | data[4];\n\tjh->clrs = data[5] + jh->sraw;\n\tif (len == 9 && !dng_version) getc(ifp);\n\tbreak;\n      case 0xffc4:\n\tif (info_only) break;\n\tfor (dp = data; dp < data+len && (c = *dp++) < 4; )\n\t  jh->free[c] = jh->huff[c] = make_decoder_ref (&dp);\n\tbreak;\n      case 0xffda:\n\tjh->psv = data[1+data[0]*2];\n\tjh->bits -= data[3+data[0]*2] & 15;\n\tbreak;\n      case 0xffdd:\n\tjh->restart = data[0] << 8 | data[1];\n    }\n  } while (tag != 0xffda);\n  if (info_only) return 1;\n  if (jh->clrs > 6 || !jh->huff[0]) return 0;\n  FORC(5) if (!jh->huff[c+1]) jh->huff[c+1] = jh->huff[c];\n  if (jh->sraw) {\n    FORC(4)        jh->huff[2+c] = jh->huff[1];\n    FORC(jh->sraw) jh->huff[1+c] = jh->huff[0];\n  }\n  jh->row = (ushort *) calloc (jh->wide*jh->clrs, 4);\n  merror (jh->row, \"ljpeg_start()\");\n  return zero_after_ff = 1;\n}", "target": 1}
{"code": "netdutils::Status XfrmController::ipSecSetEncapSocketOwner(const android::base::unique_fd& socket,\n int newUid, uid_t callerUid) {\n    ALOGD(\"XfrmController:%s, line=%d\", __FUNCTION__, __LINE__);\n const int fd = socket.get();\n struct stat info;\n if (fstat(fd, &info)) {\n return netdutils::statusFromErrno(errno, \"Failed to stat socket file descriptor\");\n }\n if (info.st_uid != callerUid) {\n return netdutils::statusFromErrno(EPERM, \"fchown disabled for non-owner calls\");\n }\n if (S_ISSOCK(info.st_mode) == 0) {\n return netdutils::statusFromErrno(EINVAL, \"File descriptor was not a socket\");\n     }\n     int optval;\n    socklen_t optlen;\n     netdutils::Status status =\n         getSyscallInstance().getsockopt(Fd(socket), IPPROTO_UDP, UDP_ENCAP, &optval, &optlen);\n     if (status != netdutils::status::ok) {\n return status;\n }\n if (optval != UDP_ENCAP_ESPINUDP && optval != UDP_ENCAP_ESPINUDP_NON_IKE) {\n return netdutils::statusFromErrno(EINVAL, \"Socket did not have UDP-encap sockopt set\");\n }\n if (fchown(fd, newUid, -1)) {\n return netdutils::statusFromErrno(errno, \"Failed to fchown socket file descriptor\");\n }\n return netdutils::status::ok;\n}", "target": 1}
{"code": "const char *osdp_reply_name(int reply_id)\n{\n\tconst char *name;\n\tstatic const char * const names[] = {\n\t\t[REPLY_ACK       - REPLY_ACK] = \"ACK\",\n\t\t[REPLY_NAK       - REPLY_ACK] = \"NAK\",\n\t\t[REPLY_PDID      - REPLY_ACK] = \"PDID\",\n\t\t[REPLY_PDCAP     - REPLY_ACK] = \"PDCAP\",\n\t\t[REPLY_LSTATR    - REPLY_ACK] = \"LSTATR\",\n\t\t[REPLY_ISTATR    - REPLY_ACK] = \"ISTATR\",\n\t\t[REPLY_OSTATR    - REPLY_ACK] = \"OSTATR\",\n\t\t[REPLY_RSTATR    - REPLY_ACK] = \"RSTATR\",\n\t\t[REPLY_RAW       - REPLY_ACK] = \"RAW\",\n\t\t[REPLY_FMT       - REPLY_ACK] = \"FMT\",\n\t\t[REPLY_KEYPPAD   - REPLY_ACK] = \"KEYPPAD\",\n\t\t[REPLY_COM       - REPLY_ACK] = \"COM\",\n\t\t[REPLY_BIOREADR  - REPLY_ACK] = \"BIOREADR\",\n\t\t[REPLY_BIOMATCHR - REPLY_ACK] = \"BIOMATCHR\",\n\t\t[REPLY_CCRYPT    - REPLY_ACK] = \"CCRYPT\",\n\t\t[REPLY_RMAC_I    - REPLY_ACK] = \"RMAC_I\",\n\t\t[REPLY_FTSTAT    - REPLY_ACK] = \"FTSTAT\",\n\t\t[REPLY_MFGREP    - REPLY_ACK] = \"MFGREP\",\n\t\t[REPLY_BUSY      - REPLY_ACK] = \"BUSY\",\n\t\t[REPLY_PIVDATAR  - REPLY_ACK] = \"PIVDATA\",\n\t\t[REPLY_CRAUTHR   - REPLY_ACK] = \"CRAUTH\",\n\t\t[REPLY_MFGSTATR  - REPLY_ACK] = \"MFGSTATR\",\n\t\t[REPLY_MFGERRR   - REPLY_ACK] = \"MFGERR\",\n\t\t[REPLY_XRD       - REPLY_ACK] = \"XRD\",\n\t};\n\tif (reply_id < REPLY_ACK || reply_id > REPLY_XRD) {\n\t\treturn \"INVALID\";\n\t}\n\tname = names[reply_id - REPLY_ACK];\n\tif (name[0] == '\\0') {\n\t\treturn \"UNKNOWN\";\n\t}\n\treturn name;\n}", "target": 1}
{"code": "static int hash__init_new_context(struct mm_struct *mm)\n{\n\tint index;\n\tindex = hash__alloc_context_id();\n\tif (index < 0)\n\t\treturn index;\n\tif (mm->context.id == 0)\n\t\tslice_init_new_context_exec(mm);\n\tsubpage_prot_init_new_context(mm);\n\tpkey_mm_init(mm);\n\treturn index;\n}", "target": 1}
{"code": "bool SoftVPX::outputBufferSafe(OMX_BUFFERHEADERTYPE *outHeader) {\n uint32_t width = outputBufferWidth();\n uint32_t height = outputBufferHeight();\n     uint64_t nFilledLen = width;\n     nFilledLen *= height;\n     if (nFilledLen > UINT32_MAX / 3) {\n        ALOGE(\"b/29421675, nFilledLen overflow %llu w %u h %u\", nFilledLen, width, height);\n         android_errorWriteLog(0x534e4554, \"29421675\");\n         return false;\n     } else if (outHeader->nAllocLen < outHeader->nFilledLen) {\n        ALOGE(\"b/27597103, buffer too small\");\n        android_errorWriteLog(0x534e4554, \"27597103\");\n return false;\n }\n return true;\n}", "target": 1}
{"code": "i915_gem_execbuffer2_ioctl(struct drm_device *dev, void *data,\n\t\t\t   struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list;\n\tstruct drm_syncobj **fences = NULL;\n\tconst size_t count = args->buffer_count;\n\tint err;\n\tif (!check_buffer_count(count)) {\n\t\tDRM_DEBUG(\"execbuf2 with %zd buffers\\n\", count);\n\t\treturn -EINVAL;\n\t}\n\tif (!i915_gem_check_execbuffer(args))\n\t\treturn -EINVAL;\n\texec2_list = kvmalloc_array(count + 1, eb_element_size(),\n\t\t\t\t    __GFP_NOWARN | GFP_KERNEL);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %zd buffers\\n\",\n\t\t\t  count);\n\t\treturn -ENOMEM;\n\t}\n\tif (copy_from_user(exec2_list,\n\t\t\t   u64_to_user_ptr(args->buffers_ptr),\n\t\t\t   sizeof(*exec2_list) * count)) {\n\t\tDRM_DEBUG(\"copy %zd exec entries failed\\n\", count);\n\t\tkvfree(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\tif (args->flags & I915_EXEC_FENCE_ARRAY) {\n\t\tfences = get_fence_array(args, file);\n\t\tif (IS_ERR(fences)) {\n\t\t\tkvfree(exec2_list);\n\t\t\treturn PTR_ERR(fences);\n\t\t}\n\t}\n\terr = i915_gem_do_execbuffer(dev, file, args, exec2_list, fences);\n\tif (args->flags & __EXEC_HAS_RELOC) {\n\t\tstruct drm_i915_gem_exec_object2 __user *user_exec_list =\n\t\t\tu64_to_user_ptr(args->buffers_ptr);\n\t\tunsigned int i;\n\t\tuser_access_begin();\n\t\tfor (i = 0; i < args->buffer_count; i++) {\n\t\t\tif (!(exec2_list[i].offset & UPDATE))\n\t\t\t\tcontinue;\n\t\t\texec2_list[i].offset =\n\t\t\t\tgen8_canonical_addr(exec2_list[i].offset & PIN_OFFSET_MASK);\n\t\t\tunsafe_put_user(exec2_list[i].offset,\n\t\t\t\t\t&user_exec_list[i].offset,\n\t\t\t\t\tend_user);\n\t\t}\nend_user:\n\t\tuser_access_end();\n\t}\n\targs->flags &= ~__I915_EXEC_UNKNOWN_FLAGS;\n\tput_fence_array(args, fences);\n\tkvfree(exec2_list);\n\treturn err;\n}", "target": 1}
{"code": "bool ResourceDispatcherHostImpl::AcceptAuthRequest(\n    ResourceLoader* loader,\n    net::AuthChallengeInfo* auth_info) {\n  if (delegate_ && !delegate_->AcceptAuthRequest(loader->request(), auth_info))\n    return false;\n  if (!auth_info->is_proxy) {\n    HttpAuthResourceType resource_type =\n        HttpAuthResourceTypeOf(loader->request());\n    UMA_HISTOGRAM_ENUMERATION(\"Net.HttpAuthResource\",\n                               resource_type,\n                               HTTP_AUTH_RESOURCE_LAST);\n    if (resource_type == HTTP_AUTH_RESOURCE_BLOCKED_CROSS)\n      return false;\n   }\n   return true;\n}", "target": 1}
{"code": " scoped_refptr<Image> CSSPaintValue::GetImage(\n     const ImageResourceObserver& client,\n     const Document& document,\n    const ComputedStyle&,\n     const FloatSize& target_size) {\n   if (!generator_) {\n     generator_ = CSSPaintImageGenerator::Create(\n         GetName(), document, paint_image_generator_observer_);\n  }\n  if (!ParseInputArguments(document))\n    return nullptr;\n  return generator_->Paint(client, RoundedIntSize(target_size),\n                           parsed_input_arguments_);\n}", "target": 1}
{"code": "static inline void authenticate_post(void)\n{\n\tchar buffer[MAX_AUTHENTICATION_POST_BYTES];\n\tint len;\n\topen_auth_filter(\"authenticate-post\");\n\tlen = ctx.env.content_length;\n\tif (len > MAX_AUTHENTICATION_POST_BYTES)\n\t\tlen = MAX_AUTHENTICATION_POST_BYTES;\n\tif (read(STDIN_FILENO, buffer, len) < 0)\n\t\tdie_errno(\"Could not read POST from stdin\");\n\tif (write(STDOUT_FILENO, buffer, len) < 0)\n\t\tdie_errno(\"Could not write POST to stdout\");\n\tcgit_close_filter(ctx.cfg.auth_filter);\n\texit(0);\n}", "target": 1}
{"code": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}", "target": 1}
{"code": "bool FontData::Bound(int32_t offset) {\nif (offset > Size() || offset < 0)\n    return false;\n  bound_offset_ += offset;\n  return true;\n}", "target": 1}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": "  bool DoTouchScroll(const gfx::Point& point,\n                     const gfx::Vector2d& distance,\n                     bool wait_until_scrolled) {\n    EXPECT_EQ(0, GetScrollTop());\n    int scrollHeight = ExecuteScriptAndExtractInt(\n        \"document.documentElement.scrollHeight\");\n    EXPECT_EQ(1200, scrollHeight);\n    scoped_refptr<FrameWatcher> frame_watcher(new FrameWatcher());\n    frame_watcher->AttachTo(shell()->web_contents());\n    SyntheticSmoothScrollGestureParams params;\n    params.gesture_source_type = SyntheticGestureParams::TOUCH_INPUT;\n    params.anchor = gfx::PointF(point);\n    params.distances.push_back(-distance);\n    runner_ = new MessageLoopRunner();\n    std::unique_ptr<SyntheticSmoothScrollGesture> gesture(\n        new SyntheticSmoothScrollGesture(params));\n    GetWidgetHost()->QueueSyntheticGesture(\n        std::move(gesture),\n        base::Bind(&TouchActionBrowserTest::OnSyntheticGestureCompleted,\n                   base::Unretained(this)));\n    runner_->Run();\n    runner_ = NULL;\n     while (wait_until_scrolled &&\n           frame_watcher->LastMetadata().root_scroll_offset.y() <= 0) {\n       frame_watcher->WaitFrames(1);\n     }\n    int scrollTop = GetScrollTop();\n    if (scrollTop == 0)\n      return false;\n    EXPECT_EQ(distance.y(), scrollTop);\n    return true;\n  }", "target": 1}
{"code": "static void dhcps_initialize_message(struct dhcp_msg *dhcp_message_repository)\n{\n        dhcp_message_repository->op = DHCP_MESSAGE_OP_REPLY;\n        dhcp_message_repository->htype = DHCP_MESSAGE_HTYPE;\n        dhcp_message_repository->hlen = DHCP_MESSAGE_HLEN; \n        dhcp_message_repository->hops = 0;\t\t\n        memcpy((char *)dhcp_recorded_xid, (char *) dhcp_message_repository->xid,\n\t\t\t\t\tsizeof(dhcp_message_repository->xid));\n        dhcp_message_repository->secs = 0;\n        dhcp_message_repository->flags = htons(BOOTP_BROADCAST);         \n\tmemcpy((char *)dhcp_message_repository->yiaddr,\n\t\t\t(char *)&dhcps_allocated_client_address,\n\t\t\t\tsizeof(dhcp_message_repository->yiaddr));\n\tmemset((char *)dhcp_message_repository->ciaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->ciaddr));\n        memset((char *)dhcp_message_repository->siaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->siaddr));\n        memset((char *)dhcp_message_repository->giaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->giaddr));\n        memset((char *)dhcp_message_repository->sname,  0,\n\t\t\t\t\tsizeof(dhcp_message_repository->sname));\n        memset((char *)dhcp_message_repository->file,   0,\n\t\t\t\t\tsizeof(dhcp_message_repository->file));\n        memset((char *)dhcp_message_repository->options, 0,\n\t\t\t\t\tdhcp_message_total_options_lenth);\n        memcpy((char *)dhcp_message_repository->options, (char *)dhcp_magic_cookie,\n\t\t\t\t\tsizeof(dhcp_magic_cookie));\n}", "target": 1}
{"code": "ecryptfs_write_metadata_to_contents(struct ecryptfs_crypt_stat *crypt_stat,\n\t\t\t\t    struct dentry *ecryptfs_dentry,\n\t\t\t\t    char *virt)\n{\n\tint rc;\n\trc = ecryptfs_write_lower(ecryptfs_dentry->d_inode, virt,\n\t\t\t\t  0, crypt_stat->num_header_bytes_at_front);\n\tif (rc)\n\t\tprintk(KERN_ERR \"%s: Error attempting to write header \"\n\t\t       \"information to lower file; rc = [%d]\\n\", __func__,\n\t\t       rc);\n\treturn rc;\n}", "target": 1}
{"code": "de_dotdot( char* file )\n    {\n    char* cp;\n    char* cp2;\n    int l;\n    while ( ( cp = strstr( file, \"\n\t{\n\tfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\n\t    continue;\n\t(void) strcpy( cp + 1, cp2 );\n\t}\n     while ( strncmp( file, \"./\", 2 ) == 0 )\n \t(void) memmove( file, file + 2, strlen( file ) - 1 );\n     while ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n\t(void) memmove( cp, cp + 2, strlen( file ) - 1 );\n     for (;;)\n\t{\n\twhile ( strncmp( file, \"../\", 3 ) == 0 )\n\t    (void) memmove( file, file + 3, strlen( file ) - 2 );\n\tcp = strstr( file, \"/../\" );\n\tif ( cp == (char*) 0 )\n\t    break;\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\t(void) strcpy( cp2 + 1, cp + 4 );\n\t}\n    while ( ( l = strlen( file ) ) > 3 &&\n\t    strcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n\t{\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\tif ( cp2 < file )\n\t    break;\n\t*cp2 = '\\0';\n\t}\n    }", "target": 1}
{"code": "static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n\t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n\t\trdesc[11] = rdesc[16] = 0xff;\n\t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n \tdown_write(&tty->termios_rwsem);\n \ttty->termios.c_line = num;\n \tup_write(&tty->termios_rwsem);\n }", "target": 1}
{"code": "static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,\n  int texel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,\n                                        const char *userp,\n                                        const char *passwdp,\n                                        char **outptr, size_t *outlen)\n{\n  CURLcode result;\n  char *plainauth;\n  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n  if((ulen > SIZE_T_MAX/2) || (plen > (SIZE_T_MAX/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';\n  memcpy(plainauth + ulen + 1, userp, ulen);\n  plainauth[2 * ulen + 1] = '\\0';\n  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);\n  result = Curl_base64_encode(data, plainauth, plainlen, outptr, outlen);\n  free(plainauth);\n  return result;\n}", "target": 1}
{"code": "static void arc_emac_tx_clean(struct net_device *ndev)\n{\n\tstruct arc_emac_priv *priv = netdev_priv(ndev);\n\tstruct net_device_stats *stats = &ndev->stats;\n\tunsigned int i;\n\tfor (i = 0; i < TX_BD_NUM; i++) {\n\t\tunsigned int *txbd_dirty = &priv->txbd_dirty;\n\t\tstruct arc_emac_bd *txbd = &priv->txbd[*txbd_dirty];\n\t\tstruct buffer_state *tx_buff = &priv->tx_buff[*txbd_dirty];\n\t\tstruct sk_buff *skb = tx_buff->skb;\n\t\tunsigned int info = le32_to_cpu(txbd->info);\n\t\tif ((info & FOR_EMAC) || !txbd->data)\n\t\t\tbreak;\n\t\tif (unlikely(info & (DROP | DEFR | LTCL | UFLO))) {\n\t\t\tstats->tx_errors++;\n\t\t\tstats->tx_dropped++;\n\t\t\tif (info & DEFR)\n\t\t\t\tstats->tx_carrier_errors++;\n\t\t\tif (info & LTCL)\n\t\t\t\tstats->collisions++;\n\t\t\tif (info & UFLO)\n\t\t\t\tstats->tx_fifo_errors++;\n\t\t} else if (likely(info & FIRST_OR_LAST_MASK)) {\n\t\t\tstats->tx_packets++;\n\t\t\tstats->tx_bytes += skb->len;\n\t\t}\n\t\tdma_unmap_single(&ndev->dev, dma_unmap_addr(tx_buff, addr),\n\t\t\t\t dma_unmap_len(tx_buff, len), DMA_TO_DEVICE);\n\t\tdev_kfree_skb_irq(skb);\n\t\ttxbd->data = 0;\n\t\ttxbd->info = 0;\n\t\t*txbd_dirty = (*txbd_dirty + 1) % TX_BD_NUM;\n\t}\n\tsmp_mb();\n\tif (netif_queue_stopped(ndev) && arc_emac_tx_avail(priv))\n\t\tnetif_wake_queue(ndev);\n}", "target": 1}
{"code": "static inline void xen_evtchn_handle_events(unsigned cpu)\n{\n\treturn evtchn_ops->handle_events(cpu);\n}", "target": 1}
{"code": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timespec(up, &kts);\n\treturn err;\n}", "target": 1}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n    mpz_as_bytes(&self->mpz, big_endian, len, buf);\n}", "target": 1}
{"code": " static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n \tint i;\n\tut8 *directory_base;\n\tstruct minidump_directory *entry;\n\tdirectory_base = obj->b->buf + obj->hdr->stream_directory_rva;\n \tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n \t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n \t\t\t\"(mdmp_location_descriptor)Location\", 0);\n \tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tentry = (struct minidump_directory *)(directory_base + (i * sizeof (struct minidump_directory)));\n\t\tr_bin_mdmp_init_directory_entry (obj, entry);\n \t}\n \treturn true;\n}", "target": 1}
{"code": "header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\t} ;\n} ", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.rtv_annotations_attr.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n    l_data_size = 26 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}", "target": 1}
{"code": " static int get_int32_le(QEMUFile *f, void *pv, size_t size)\n {\n    int32_t loaded;\n     int32_t loaded;\n     qemu_get_sbe32s(f, &loaded);\n    if (loaded <= *cur) {\n         *cur = loaded;\n         return 0;\n     }\n}", "target": 1}
{"code": " FilePath ExtensionPrefs::GetExtensionPath(const std::string& extension_id) {\n   const DictionaryValue* dict = GetExtensionPref(extension_id);\n   std::string path;\n   if (!dict->GetString(kPrefPath, &path))\n     return FilePath();\n  return install_directory_.Append(FilePath::FromWStringHack(UTF8ToWide(path)));\n}", "target": 1}
{"code": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n \tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n \tbsg_set_block(bd, file);\n \tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\t*ppos = bytes_written;\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}", "target": 1}
{"code": "  llvh::ArrayRef<hbc::HBCExceptionHandlerInfo> getExceptionTable(\n      uint32_t) const override {\n    llvm_unreachable(\"Accessing exception info from a lazy module\");\n  }", "target": 1}
{"code": "tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp, unsigned long fh,\n\t      u32 pid, u32 seq, u16 flags, int event)\n{\n\tstruct tcmsg *tcm;\n\tstruct nlmsghdr  *nlh;\n\tunsigned char\t *b = skb->tail;\n\tnlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*tcm), flags);\n\ttcm = NLMSG_DATA(nlh);\n\ttcm->tcm_family = AF_UNSPEC;\n\ttcm->tcm_ifindex = tp->q->dev->ifindex;\n\ttcm->tcm_parent = tp->classid;\n\ttcm->tcm_info = TC_H_MAKE(tp->prio, tp->protocol);\n\tRTA_PUT(skb, TCA_KIND, IFNAMSIZ, tp->ops->kind);\n\ttcm->tcm_handle = fh;\n\tif (RTM_DELTFILTER != event) {\n\t\ttcm->tcm_handle = 0;\n\t\tif (tp->ops->dump && tp->ops->dump(tp, fh, skb, tcm) < 0)\n\t\t\tgoto rtattr_failure;\n\t}\n\tnlh->nlmsg_len = skb->tail - b;\n\treturn skb->len;\nnlmsg_failure:\nrtattr_failure:\n\tskb_trim(skb, b - skb->data);\n\treturn -1;\n}", "target": 1}
{"code": "static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}", "target": 1}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if(length == SIZE_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 1}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 1}
{"code": "show_tree(tree_t *t,                    \n          int    indent)                \n{\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n    if (t->child)\n      show_tree(t->child, indent + 2);\n    t = t->next;\n  }\n}", "target": 1}
{"code": "void SetGray(double grayscale,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f G\",grayscale);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f g\",grayscale);\n    }\n}", "target": 1}
{"code": "void mark_files_ro(struct super_block *sb)\n{\n\tstruct file *f;\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, f) {\n\t\tif (!file_count(f))\n\t\t\tcontinue;\n\t\tif (!(f->f_mode & FMODE_WRITE))\n\t\t\tcontinue;\n\t\tspin_lock(&f->f_lock);\n\t\tf->f_mode &= ~FMODE_WRITE;\n\t\tspin_unlock(&f->f_lock);\n\t\tif (file_check_writeable(f) != 0)\n\t\t\tcontinue;\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t\tfile_release_write(f);\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n}", "target": 1}
{"code": "static inline int unicode_cp_is_allowed(unsigned uni_cp, int document_type)\n{\n\tswitch (document_type) {\n\tcase ENT_HTML_DOC_HTML401:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF);\n\tcase ENT_HTML_DOC_HTML5:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0x7E) ||\n\t\t\t(uni_cp >= 0x09 && uni_cp <= 0x0D && uni_cp != 0x0B) || \n\t\t\t(uni_cp >= 0xA0 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF &&\n\t\t\t\t((uni_cp & 0xFFFF) < 0xFFFE) && \n\t\t\t\t(uni_cp < 0xFDD0 || uni_cp > 0xFDEF)); \n\tcase ENT_HTML_DOC_XHTML:\n\tcase ENT_HTML_DOC_XML1:\n\t\treturn (uni_cp >= 0x20 && uni_cp <= 0xD7FF) ||\n\t\t\t(uni_cp == 0x0A || uni_cp == 0x09 || uni_cp == 0x0D) ||\n\t\t\t(uni_cp >= 0xE000 && uni_cp <= 0x10FFFF && uni_cp != 0xFFFE && uni_cp != 0xFFFF);\n\tdefault:\n\t\treturn 1;\n\t}\n}", "target": 1}
{"code": "rpmRC rpmReadPackageFile(rpmts ts, FD_t fd, const char * fn, Header * hdrp)\n{\n    char *msg = NULL;\n    Header h = NULL;\n    Header sigh = NULL;\n    hdrblob blob = NULL;\n    hdrblob sigblob = NULL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = loghdrmsg,\n\t.fn = fn ? fn : Fdescr(fd),\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n    if (hdrp)\n\t*hdrp = NULL;\n    rpmRC rc = rpmpkgRead(vs, fd, &sigblob, &blob, &msg);\n    if (rc)\n\tgoto exit;\n    rc = RPMRC_FAIL;\n    if (!rpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata)) {\n\tif (hdrp) {\n\t    if (hdrblobImport(sigblob, 0, &sigh, &msg))\n\t\tgoto exit;\n\t    if (hdrblobImport(blob, 0, &h, &msg))\n\t\tgoto exit;\n\t    headerMergeLegacySigs(h, sigh);\n\t    applyRetrofits(h);\n\t    *hdrp = headerLink(h);\n\t}\n\trc = RPMRC_OK;\n    }\n    if (rc == RPMRC_OK && pkgdata.rc)\n\trc = pkgdata.rc;\nexit:\n    if (rc && msg)\n\trpmlog(RPMLOG_ERR, \"%s: %s\\n\", Fdescr(fd), msg);\n    hdrblobFree(sigblob);\n    hdrblobFree(blob);\n    headerFree(sigh);\n    headerFree(h);\n    rpmKeyringFree(keyring);\n    rpmvsFree(vs);\n    free(msg);\n    return rc;\n}", "target": 1}
{"code": "soup_ntlm_parse_challenge (const char *challenge,\n\t\t\t   char      **nonce,\n\t\t\t   char      **default_domain,\n\t\t\t   gboolean   *ntlmv2_session)\n{\n\tgsize clen;\n\tNTLMString domain;\n\tguchar *chall;\n\tguint32 flags;\n\tchall = g_base64_decode (challenge, &clen);\n\tif (clen < NTLM_CHALLENGE_DOMAIN_STRING_OFFSET ||\n\t    clen < NTLM_CHALLENGE_NONCE_OFFSET + NTLM_CHALLENGE_NONCE_LENGTH) {\n\t\tg_free (chall);\n\t\treturn FALSE;\n\t}\n\tmemcpy (&flags, chall + NTLM_CHALLENGE_FLAGS_OFFSET, sizeof(flags));\n\tflags = GUINT_FROM_LE (flags);\n\t*ntlmv2_session = (flags & NTLM_FLAGS_NEGOTIATE_NTLMV2) ? TRUE : FALSE;\n\tif (default_domain) {\n\t\tmemcpy (&domain, chall + NTLM_CHALLENGE_DOMAIN_STRING_OFFSET, sizeof (domain));\n\t\tdomain.length = GUINT16_FROM_LE (domain.length);\n\t\tdomain.offset = GUINT16_FROM_LE (domain.offset);\n\t\tif (clen < domain.length + domain.offset) {\n\t\t\tg_free (chall);\n\t\t\treturn FALSE;\n\t\t}\n\t\t*default_domain = g_convert ((char *)chall + domain.offset,\n\t\t\t\t\t     domain.length, \"UTF-8\", \"UCS-2LE\",\n\t\t\t\t\t     NULL, NULL, NULL);\n\t}\n\tif (nonce) {\n\t\t*nonce = g_memdup (chall + NTLM_CHALLENGE_NONCE_OFFSET,\n\t\t\t\t   NTLM_CHALLENGE_NONCE_LENGTH);\n\t}\n\tg_free (chall);\n\treturn TRUE;\n}", "target": 1}
{"code": "modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static bool ShouldAutofocus(const HTMLFormControlElement* element) {\n  if (!element->isConnected())\n    return false;\n  if (!element->IsAutofocusable())\n    return false;\n   Document& doc = element->GetDocument();\n  if (doc.IsSandboxed(WebSandboxFlags::kAutomaticFeatures)) {\n    doc.AddConsoleMessage(ConsoleMessage::Create(\n        mojom::ConsoleMessageSource::kSecurity,\n        mojom::ConsoleMessageLevel::kError,\n        \"Blocked autofocusing on a form control because the form's frame is \"\n        \"sandboxed and the 'allow-scripts' permission is not set.\"));\n    return false;\n  }\n  if (!doc.IsInMainFrame() &&\n      !doc.TopFrameOrigin()->CanAccess(doc.GetSecurityOrigin())) {\n    doc.AddConsoleMessage(ConsoleMessage::Create(\n        mojom::ConsoleMessageSource::kSecurity,\n        mojom::ConsoleMessageLevel::kError,\n        \"Blocked autofocusing on a form control in a cross-origin subframe.\"));\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "disable_priv_mode ()\n{\n  int e;\n  if (setuid (current_user.uid) < 0)\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n  if (setgid (current_user.gid) < 0)\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}", "target": 1}
{"code": " static bool parse_reconnect(struct pool *pool, json_t *val)\n {\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n \tif (opt_disable_client_reconnect) {\n\t\tapplog(LOG_WARNING, \"Stratum client.reconnect forbidden, aborting.\");\n \t\treturn false;\n \t}\n\tmemset(address, 0, 255);\n \turl = (char *)json_string_value(json_array_get(val, 0));\n \tif (!url)\n \t\turl = pool->sockaddr_url;\n\tport = (char *)json_string_value(json_array_get(val, 1));\n \tif (!port)\n \t\tport = pool->stratum_port;\n\tsprintf(address, \"%s:%s\", url, port);\n \tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n \t\treturn false;\n\tapplog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);\n\tclear_pool_work(pool);\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t      bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                                              EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,  uint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n  if (!authorizer_data.length()) {\n    ldout(cct, 1) << \"verify authorizer, authorizer_data.length()=0\" << dendl;\n    return false;\n  }\n  CephXServiceTicketInfo auth_ticket_info;\n  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, authorizer_reply);\n  if (isvalid) {\n    caps_info = auth_ticket_info.ticket.caps;\n    entity_name = auth_ticket_info.ticket.name;\n    global_id = auth_ticket_info.ticket.global_id;\n    session_key = auth_ticket_info.session_key;\n    if (auid) *auid = auth_ticket_info.ticket.auid;\n  }\n  return isvalid;\n}", "target": 1}
{"code": "gopherStateFree(const CommCloseCbParams &params)\n{\n    GopherStateData *gopherState = (GopherStateData *)params.data;\n    delete gopherState;\n}", "target": 1}
{"code": "pci_emul_add_capability(struct pci_vdev *dev, u_char *capdata, int caplen)\n{\n\tint i, capoff, reallen;\n\tuint16_t sts;\n\tassert(caplen > 0);\n\treallen = roundup2(caplen, 4);\t\t\n\tsts = pci_get_cfgdata16(dev, PCIR_STATUS);\n\tif ((sts & PCIM_STATUS_CAPPRESENT) == 0)\n\t\tcapoff = CAP_START_OFFSET;\n\telse\n\t\tcapoff = dev->capend + 1;\n\tif (capoff + reallen > PCI_REGMAX + 1)\n\t\treturn -1;\n\tif ((sts & PCIM_STATUS_CAPPRESENT) == 0) {\n\t\tpci_set_cfgdata8(dev, PCIR_CAP_PTR, capoff);\n\t\tpci_set_cfgdata16(dev, PCIR_STATUS, sts|PCIM_STATUS_CAPPRESENT);\n\t} else\n\t\tpci_set_cfgdata8(dev, dev->prevcap + 1, capoff);\n\tfor (i = 0; i < caplen; i++)\n\t\tpci_set_cfgdata8(dev, capoff + i, capdata[i]);\n\tpci_set_cfgdata8(dev, capoff + 1, 0);\n\tdev->prevcap = capoff;\n\tdev->capend = capoff + reallen - 1;\n\treturn 0;\n}", "target": 1}
{"code": "check_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    iterate_rc4(O_data, key_bytes, key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;\n}", "target": 1}
{"code": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n \t\tgoto drop;\n \t}\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n \t\treturn 0;\n\t}\n \topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n \tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\treturn 0;\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}", "target": 1}
{"code": "R_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout) {\n\tfd_set read_fds;\n\tfd_set except_fds;\n\tFD_ZERO (&read_fds);\n\tFD_SET (s->fd, &read_fds);\n\tFD_ZERO (&except_fds);\n\tFD_SET (s->fd, &except_fds);\n\tstruct timeval t;\n\tt.tv_sec = timeout;\n\tt.tv_usec = 0;\n\tint r = select (s->fd + 1, &read_fds, NULL, &except_fds, &t);\n\tif(r < 0) {\n\t\tperror (\"select\");\n\t} else if (r > 0 && FD_ISSET (s->fd, &read_fds)) {\n\t\treturn r_socket_accept (s);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}", "target": 1}
{"code": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}", "target": 1}
{"code": "TfLiteStatus GatherNd(const TfLiteEvalTensor* params,\n                      const TfLiteEvalTensor* indices,\n                      TfLiteEvalTensor* output) {\n  const int indices_dims = indices->dims->size;\n  const int indices_nd = indices->dims->data[indices_dims - 1];\n  const int params_dims = params->dims->size;\n  const IndicesT* index_data = tflite::micro::GetTensorData<IndicesT>(indices);\n  const ParamsT* param_data = tflite::micro::GetTensorData<ParamsT>(params);\n  ParamsT* output_data = tflite::micro::GetTensorData<ParamsT>(output);\n  int n_slices = 1;\n  for (int i = 0; i < indices_dims - 1; ++i) {\n    n_slices *= indices->dims->data[i];\n  }\n  int slice_size = 1;\n  for (int i = indices_nd; i < params_dims; ++i) {\n    slice_size *= params->dims->data[i];\n  }\n  int remain_flat_size = ElementCount(*params->dims);\n  int dims_to_count[MAX_INDICES_ND];\n  for (int i = 0; i < indices_nd; ++i) {\n    dims_to_count[i] = remain_flat_size / params->dims->data[i];\n    remain_flat_size = dims_to_count[i];\n  }\n  for (int i = 0; i < n_slices; ++i) {\n    int from_pos = 0;\n    for (int j = 0; j < indices_nd; ++j) {\n      int offset = i * indices_nd + j;\n      IndicesT index = index_data[offset];\n      from_pos += index * dims_to_count[j];\n    }\n    std::memcpy(output_data + i * slice_size, param_data + from_pos,\n                sizeof(ParamsT) * slice_size);\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "  explicit HashContext(const HashContext* ctx) {\n    assert(ctx->ops);\n    assert(ctx->ops->context_size >= 0);\n    ops = ctx->ops;\n    context = malloc(ops->context_size);\n    ops->hash_copy(context, ctx->context);\n    options = ctx->options;\n    key = ctx->key ? strdup(ctx->key) : nullptr;\n  }", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *out;\n    int needs_copy = frame_needs_copy(s, in);\n    if (needs_copy) {\n        av_log(inlink->dst, AV_LOG_DEBUG, \"Direct padding impossible allocating new frame\\n\");\n        out = ff_get_video_buffer(inlink->dst->outputs[0],\n                                  FFMAX(inlink->w, s->w),\n                                  FFMAX(inlink->h, s->h));\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    } else {\n        int i;\n        out = in;\n        for (i = 0; i < 4 && out->data[i]; i++) {\n            int hsub = s->draw.hsub[i];\n            int vsub = s->draw.vsub[i];\n            out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] +\n                            (s->y >> vsub) * out->linesize[i];\n        }\n    }\n    if (s->y) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, 0, s->w, s->y);\n    }\n    if (s->h > s->y + s->in_h) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, s->y + s->in_h, s->w, s->h - s->y - s->in_h);\n    }\n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      0, s->y, s->x, in->height);\n    if (needs_copy) {\n        ff_copy_rectangle2(&s->draw,\n                          out->data, out->linesize, in->data, in->linesize,\n                          s->x, s->y, 0, 0, in->width, in->height);\n    }\n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      s->x + s->in_w, s->y, s->w - s->x - s->in_w,\n                      in->height);\n    out->width  = s->w;\n    out->height = s->h;\n    if (in != out)\n        av_frame_free(&in);\n    return ff_filter_frame(inlink->dst->outputs[0], out);\n}", "target": 1}
{"code": "StatusOr<unsigned> GraphDefImporter::ArgNumType(const NamedAttrList &attrs,\n                                                const OpDef::ArgDef &arg_def,\n                                                SmallVectorImpl<Type> &types) {\n  if (!arg_def.type_list_attr().empty()) {\n    if (auto v = attrs.get(arg_def.type_list_attr()).dyn_cast<ArrayAttr>()) {\n      for (Attribute attr : v) {\n        if (auto dtype = attr.dyn_cast<TypeAttr>()) {\n          types.push_back(UnrankedTensorType::get(dtype.getValue()));\n        } else {\n          return InvalidArgument(\"Expected '\", arg_def.type_list_attr(),\n                                 \"' to be a list of types\");\n        }\n      }\n      return v.size();\n    }\n    return NotFound(\"Type attr not found: \", arg_def.type_list_attr());\n  }\n  unsigned num = 1;\n  if (!arg_def.number_attr().empty()) {\n    if (auto v = attrs.get(arg_def.number_attr()).dyn_cast<IntegerAttr>()) {\n      num = v.getValue().getZExtValue();\n    } else {\n      return NotFound(\"Type attr not found: \", arg_def.number_attr());\n    }\n  }\n  Type dtype;\n  if (arg_def.type() != DataType::DT_INVALID) {\n    TF_RETURN_IF_ERROR(ConvertDataType(arg_def.type(), b_, &dtype));\n  } else if (arg_def.type_attr().empty()) {\n    return InvalidArgument(\"Arg '\", arg_def.name(),\n                           \"' has invalid type and no type attribute\");\n  } else {\n    if (auto v = attrs.get(arg_def.type_attr()).dyn_cast<TypeAttr>()) {\n      dtype = v.getValue();\n    } else {\n      return NotFound(\"Type attr not found: \", arg_def.type_attr());\n    }\n  }\n  types.append(num, UnrankedTensorType::get(dtype));\n  return num;\n}", "target": 1}
{"code": "static NETWORK_INTERFACE_DESCRIPTION* create_network_interface_description(struct ifreq *ifr, NETWORK_INTERFACE_DESCRIPTION* previous_nid)\n{\n    NETWORK_INTERFACE_DESCRIPTION* result;\n    if ((result = (NETWORK_INTERFACE_DESCRIPTION*)malloc(sizeof(NETWORK_INTERFACE_DESCRIPTION))) == NULL)\n    {\n        LogError(\"Failed allocating NETWORK_INTERFACE_DESCRIPTION\");\n    }\n    else if ((result->name = (char*)malloc(sizeof(char) * (strlen(ifr->ifr_name) + 1))) == NULL)\n    {\n        LogError(\"failed setting interface description name (malloc failed)\");\n        destroy_network_interface_descriptions(result);\n        result = NULL;\n    }\n    else\n    {\n        strcpy(result->name, ifr->ifr_name);\n        char* ip_address;\n        unsigned char* mac = (unsigned char*)ifr->ifr_hwaddr.sa_data;\n        if ((result->mac_address = (char*)malloc(sizeof(char) * MAC_ADDRESS_STRING_LENGTH)) == NULL)\n        {\n            LogError(\"failed formatting mac address (malloc failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if (sprintf(result->mac_address, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]) <= 0)\n        {\n            LogError(\"failed formatting mac address (sprintf failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((ip_address = inet_ntoa(((struct sockaddr_in*)&ifr->ifr_addr)->sin_addr)) == NULL)\n        {\n            LogError(\"failed setting the ip address (inet_ntoa failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((result->ip_address = (char*)malloc(sizeof(char) * (strlen(ip_address) + 1))) == NULL)\n        {\n            LogError(\"failed setting the ip address (malloc failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else\n        {\n            strcpy(result->ip_address, ip_address);\n            result->next = NULL;\n            if (previous_nid != NULL)\n            {\n                previous_nid->next = result;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": " void ServerWrapper::OnHttpRequest(int connection_id,\n                                   const net::HttpServerRequestInfo& info) {\n   server_->SetSendBufferSize(connection_id, kSendBufferSizeForDevTools);\n   if (base::StartsWith(info.path, \"/json\", base::CompareCase::SENSITIVE)) {\n    BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                            base::BindOnce(&DevToolsHttpHandler::OnJsonRequest,\n                                           handler_, connection_id, info));\n    return;\n  }\n  if (info.path.empty() || info.path == \"/\") {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnDiscoveryPageRequest, handler_,\n                       connection_id));\n    return;\n  }\n  if (!base::StartsWith(info.path, \"/devtools/\",\n                        base::CompareCase::SENSITIVE)) {\n    server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n  std::string filename = PathWithoutParams(info.path.substr(10));\n  std::string mime_type = GetMimeType(filename);\n  if (!debug_frontend_dir_.empty()) {\n    base::FilePath path = debug_frontend_dir_.AppendASCII(filename);\n    std::string data;\n    base::ReadFileToString(path, &data);\n    server_->Send200(connection_id, data, mime_type,\n                     kDevtoolsHttpHandlerTrafficAnnotation);\n    return;\n  }\n  if (bundles_resources_) {\n    BrowserThread::PostTask(\n        BrowserThread::UI, FROM_HERE,\n        base::BindOnce(&DevToolsHttpHandler::OnFrontendResourceRequest,\n                       handler_, connection_id, filename));\n    return;\n  }\n  server_->Send404(connection_id, kDevtoolsHttpHandlerTrafficAnnotation);\n}", "target": 1}
{"code": "bool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}", "target": 1}
{"code": "static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\tstrlcpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\n\t\t    sizeof(struct crypto_report_kpp), &rkpp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "modify_bar_registration(struct pci_vdev *dev, int idx, int registration)\n{\n\tint error;\n\tstruct inout_port iop;\n\tstruct mem_range mr;\n\tif (is_pci_gvt(dev)) {\n\t\tprintf(\"modify_bar_registration: bypass for pci-gvt\\n\");\n\t\treturn;\n\t}\n\tswitch (dev->bar[idx].type) {\n\tcase PCIBAR_IO:\n\t\tbzero(&iop, sizeof(struct inout_port));\n\t\tiop.name = dev->name;\n\t\tiop.port = dev->bar[idx].addr;\n\t\tiop.size = dev->bar[idx].size;\n\t\tif (registration) {\n\t\t\tiop.flags = IOPORT_F_INOUT;\n\t\t\tiop.handler = pci_emul_io_handler;\n\t\t\tiop.arg = dev;\n\t\t\terror = register_inout(&iop);\n\t\t} else\n\t\t\terror = unregister_inout(&iop);\n\t\tbreak;\n\tcase PCIBAR_MEM32:\n\tcase PCIBAR_MEM64:\n\t\tbzero(&mr, sizeof(struct mem_range));\n\t\tmr.name = dev->name;\n\t\tmr.base = dev->bar[idx].addr;\n\t\tmr.size = dev->bar[idx].size;\n\t\tif (registration) {\n\t\t\tmr.flags = MEM_F_RW;\n\t\t\tmr.handler = pci_emul_mem_handler;\n\t\t\tmr.arg1 = dev;\n\t\t\tmr.arg2 = idx;\n\t\t\terror = register_mem(&mr);\n\t\t} else\n\t\t\terror = unregister_mem(&mr);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tassert(error == 0);\n}", "target": 1}
{"code": "folly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes,\n    std::unique_ptr<HTTPMessage>& msg) {\n  Cursor headerCursor(curHeaderBlock_.front());\n  bool isReq = false;\n  if (promisedStream) {\n    isReq = true;\n  } else if (exAttributes) {\n    isReq = isRequest(curHeader_.stream);\n  } else {\n    isReq = transportDirection_ == TransportDirection::DOWNSTREAM;\n  }\n  decodeInfo_.init(isReq, parsingDownstreamTrailers_);\n  if (priority) {\n    if (curHeader_.stream == priority->streamDependency) {\n      streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                    curHeader_.stream),\n                  ErrorCode::PROTOCOL_ERROR,\n                  curHeader_.type == http2::FrameType::HEADERS);\n      return ErrorCode::NO_ERROR;\n    }\n    decodeInfo_.msg->setHTTP2Priority(\n        std::make_tuple(priority->streamDependency,\n                        priority->exclusive,\n                        priority->weight));\n  }\n  headerCodec_.decodeStreaming(\n      headerCursor, curHeaderBlock_.chainLength(), this);\n  msg = std::move(decodeInfo_.msg);\n  auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });\n  if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {\n    static const std::string decodeErrorMessage =\n        \"Failed decoding header block for stream=\";\n    if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream\n                 << \" header block=\";\n      VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    } else {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream;\n    }\n    if (msg) {\n      msg->dumpMessage(3);\n    }\n    return ErrorCode::COMPRESSION_ERROR;\n  }\n  if (decodeInfo_.parsingError != \"\") {\n    LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream\n               << \", error=\" << decodeInfo_.parsingError << \", header block=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    HTTPException err(HTTPException::Direction::INGRESS,\n                      folly::to<std::string>(\"HTTP2Codec stream error: \",\n                                             \"stream=\",\n                                             curHeader_.stream,\n                                             \" status=\",\n                                             400,\n                                             \" error: \",\n                                             decodeInfo_.parsingError));\n    err.setHttpStatusCode(400);\n    callback_->onError(curHeader_.stream, err, true);\n    return ErrorCode::NO_ERROR;\n  }\n  return folly::Optional<ErrorCode>();\n}", "target": 1}
{"code": "static int ieee80211_fragment(struct ieee80211_tx_data *tx,\n\t\t\t      struct sk_buff *skb, int hdrlen,\n\t\t\t      int frag_threshold)\n{\n\tstruct ieee80211_local *local = tx->local;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *tmp;\n\tint per_fragm = frag_threshold - hdrlen - FCS_LEN;\n\tint pos = hdrlen + per_fragm;\n\tint rem = skb->len - hdrlen - per_fragm;\n\tif (WARN_ON(rem < 0))\n\t\treturn -EINVAL;\n\twhile (rem) {\n\t\tint fraglen = per_fragm;\n\t\tif (fraglen > rem)\n\t\t\tfraglen = rem;\n\t\trem -= fraglen;\n\t\ttmp = dev_alloc_skb(local->tx_headroom +\n\t\t\t\t    frag_threshold +\n\t\t\t\t    tx->sdata->encrypt_headroom +\n\t\t\t\t    IEEE80211_ENCRYPT_TAILROOM);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t\t__skb_queue_tail(&tx->skbs, tmp);\n\t\tskb_reserve(tmp,\n\t\t\t    local->tx_headroom + tx->sdata->encrypt_headroom);\n\t\tmemcpy(tmp->cb, skb->cb, sizeof(tmp->cb));\n\t\tinfo = IEEE80211_SKB_CB(tmp);\n\t\tinfo->flags &= ~(IEEE80211_TX_CTL_CLEAR_PS_FILT |\n\t\t\t\t IEEE80211_TX_CTL_FIRST_FRAGMENT);\n\t\tif (rem)\n\t\t\tinfo->flags |= IEEE80211_TX_CTL_MORE_FRAMES;\n\t\tskb_copy_queue_mapping(tmp, skb);\n\t\ttmp->priority = skb->priority;\n\t\ttmp->dev = skb->dev;\n\t\tmemcpy(skb_put(tmp, hdrlen), skb->data, hdrlen);\n\t\tmemcpy(skb_put(tmp, fraglen), skb->data + pos, fraglen);\n\t\tpos += fraglen;\n \t}\n\tskb->len = hdrlen + per_fragm;\n \treturn 0;\n }", "target": 1}
{"code": "static int ras_getcmap(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap)\n{\n\tint i;\n\tint j;\n\tint x;\n\tint c;\n\tint numcolors;\n\tint actualnumcolors;\n\tswitch (hdr->maptype) {\n\tcase RAS_MT_NONE:\n\t\tbreak;\n\tcase RAS_MT_EQUALRGB:\n\t\t{\n\t\tjas_eprintf(\"warning: palettized images not fully supported\\n\");\n\t\tnumcolors = 1 << hdr->depth;\n\t\tassert(numcolors <= RAS_CMAP_MAXSIZ);\n\t\tactualnumcolors = hdr->maplength / 3;\n\t\tfor (i = 0; i < numcolors; i++) {\n\t\t\tcmap->data[i] = 0;\n\t\t}\n\t\tif ((hdr->maplength % 3) || hdr->maplength < 0 ||\n\t\t  hdr->maplength > 3 * numcolors) {\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tfor (j = 0; j < actualnumcolors; j++) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tx = 0;\n\t\t\t\tswitch (i) {\n\t\t\t\tcase 0:\n\t\t\t\t\tx = RAS_RED(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tx = RAS_GREEN(c);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tx = RAS_BLUE(c);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmap->data[j] |= x;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "size_t mptsas_config_ioc_0(MPTSASState *s, uint8_t **data, int address)\n{\n    PCIDeviceClass *pcic = PCI_DEVICE_GET_CLASS(s);\n     return MPTSAS_CONFIG_PACK(0, MPI_CONFIG_PAGETYPE_IOC, 0x01,\n                               \"*l*lwwb*b*b*blww\",\n                               pcic->vendor_id, pcic->device_id, pcic->revision,\n                              pcic->subsystem_vendor_id,\n                               pcic->subsystem_id);\n }", "target": 1}
{"code": "do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n            const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t       &dec_tables);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t     &dec_tables);\n#else\n  return do_decrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const\n{\n  std::string image_type = m_heif_file->get_item_type(id);\n  if (image_type==\"grid\" ||\n      image_type==\"iden\" ||\n      image_type==\"iovl\") {\n    auto iref_box = m_heif_file->get_iref_box();\n    std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(\"dimg\"));\n    if (image_references.empty()) {\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_No_item_data,\n                   \"Derived image does not reference any other image items\");\n    }\n    else {\n      return get_id_of_non_virtual_child_image(image_references[0], out);\n    }\n  }\n  else {\n    out = id;\n    return Error::Ok;\n  }\n}", "target": 1}
{"code": "static void fix_hostname(struct SessionHandle *data,\n                         struct connectdata *conn, struct hostname *host)\n{\n  size_t len;\n#ifndef USE_LIBIDN\n  (void)data;\n  (void)conn;\n#elif defined(CURL_DISABLE_VERBOSE_STRINGS)\n  (void)conn;\n#endif\n  host->dispname = host->name;\n  len = strlen(host->name);\n  if(host->name[len-1] == '.')\n    host->name[len-1]=0;\n  if(!is_ASCII_name(host->name)) {\n#ifdef USE_LIBIDN\n  if(stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {\n    char *ace_hostname = NULL;\n    int rc = idna_to_ascii_lz(host->name, &ace_hostname, 0);\n    infof (data, \"Input domain encoded as `%s'\\n\",\n           stringprep_locale_charset ());\n    if(rc != IDNA_SUCCESS)\n      infof(data, \"Failed to convert %s to ACE; %s\\n\",\n            host->name, Curl_idn_strerror(conn, rc));\n    else {\n      (void)tld_check_name(data, ace_hostname);\n      host->encalloc = ace_hostname;\n      host->name = host->encalloc;\n    }\n  }\n#elif defined(USE_WIN32_IDN)\n    char *ace_hostname = NULL;\n    int rc = curl_win32_idn_to_ascii(host->name, &ace_hostname);\n    if(rc == 0)\n      infof(data, \"Failed to convert %s to ACE;\\n\",\n            host->name);\n    else {\n      host->encalloc = ace_hostname;\n      host->name = host->encalloc;\n    }\n#else\n    infof(data, \"IDN support not present, can't parse Unicode domains\\n\");\n#endif\n  }\n}", "target": 1}
{"code": "static inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return((image->columns+7)/8);\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}", "target": 1}
{"code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n    ld->bytes_left = ld->buffer_size - words*4;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n    ld->error = 0;\n}", "target": 1}
{"code": "void Bezier(double x1,double y1,double x2,double y2,double x3,double y3) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f %12.3f %12.3f %12.3f %12.3f c\",x1,y1,x2,y2,x3,y3);\n}", "target": 1}
{"code": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = numrows - hstartcol;\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "static inline u32 dma_high(dma_addr_t addr)\n{\n\treturn upper_32_bits(addr);\n}", "target": 1}
{"code": "void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}\n\t}\n\tif (!node) {\n\t\t*ch = 0;\n\t\treturn;\n\t}\n\t*ch = node->symbol;\n\t*offset = bloc;\n}", "target": 1}
{"code": "  Field *get_tmp_table_field() { return 0; }", "target": 1}
{"code": "static void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n {\n \tUINT32 len;\n \tUINT32 left;\n\tBYTE value;\n\tleft = originalSize;\n\twhile (left > 4)\n\t{\n\t\tvalue = *in++;\n \t\tif (left == 5)\n \t\t{\n \t\t\t*out++ = value;\n \t\t\tleft--;\n \t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32) * in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = *((UINT32*) in);\n \t\t\t\tin += 4;\n \t\t\t}\n \t\t\tFillMemory(out, len, value);\n \t\t\tout += len;\n \t\t\tleft -= len;\n \t\t}\n \t\telse\n \t\t{\n \t\t\t*out++ = value;\n \t\t\tleft--;\n \t\t}\n \t}\n\t*((UINT32*)out) = *((UINT32*)in);\n }", "target": 1}
{"code": "messageAddArgument(message *m, const char *arg)\n{\n\tint offset;\n\tchar *p;\n\tassert(m != NULL);\n\tif(arg == NULL)\n\t\treturn;\t\n\twhile(isspace(*arg))\n\t\targ++;\n\tif(*arg == '\\0')\n\t\treturn;\n\tcli_dbgmsg(\"messageAddArgument, arg='%s'\\n\", arg);\n\tif(!usefulArg(arg))\n\t\treturn;\n\tfor(offset = 0; offset < m->numberOfArguments; offset++)\n\t\tif(m->mimeArguments[offset] == NULL)\n\t\t\tbreak;\n\t\telse if(strcasecmp(arg, m->mimeArguments[offset]) == 0)\n\t\t\treturn;\t\n\tif(offset == m->numberOfArguments) {\n\t\tchar **q;\n\t\tm->numberOfArguments++;\n\t\tq = (char **)cli_realloc(m->mimeArguments, m->numberOfArguments * sizeof(char *));\n\t\tif(q == NULL) {\n\t\t\tm->numberOfArguments--;\n\t\t\treturn;\n\t\t}\n\t\tm->mimeArguments = q;\n\t}\n\tp = m->mimeArguments[offset] = rfc2231(arg);\n\tif(!p) {\n\t\tcli_dbgmsg(\"messageAddArgument, error from rfc2231()\\n\");\n\t\treturn;\n\t}\n\tif(strchr(p, '=') == NULL) {\n\t\tif(strncmp(p, \"filename\", 8) == 0) {\n\t\t\tcli_dbgmsg(\"Possible data corruption fixed\\n\");\n\t\t\tp[8] = '=';\n\t\t} else {\n\t\t\tif(*p)\n\t\t\t\tcli_dbgmsg(\"messageAddArgument, '%s' contains no '='\\n\", p);\n\t\t\tfree(m->mimeArguments[offset]);\n\t\t\tm->mimeArguments[offset] = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\tif((strncasecmp(p, \"filename=\", 9) == 0) || (strncasecmp(p, \"name=\", 5) == 0))\n\t\tif(messageGetMimeType(m) == NOMIME) {\n\t\t\tcli_dbgmsg(\"Force mime encoding to application\\n\");\n\t\t\tmessageSetMimeType(m, \"application\");\n\t\t}\n}", "target": 1}
{"code": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n {\n \tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n \t\treturn -EINVAL;\n \tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n \t\treturn kvm_irqfd_deassign(kvm, args);\n\treturn kvm_irqfd_assign(kvm, args);\n}", "target": 1}
{"code": "  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    output.setConstant(InitialValueF()());\n    if (data_size == 0) {\n      return;\n    }\n    const int64 N = segment_ids.dimension(0);\n    ReductionF reduction;\n    auto data_flat = typename TTypes<T, 2>::ConstTensor(data, N, data_size / N);\n    for (int64 i = 0; i < N; ++i) {\n      Index j = internal::SubtleMustCopy(segment_ids(i));\n      if (j < 0) {\n        continue;\n      }\n      OP_REQUIRES(ctx, FastBoundsCheck(j, num_segments),\n                  errors::InvalidArgument(\n                      \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                      \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n      reduction(data_flat.template chip<0>(i), output.template chip<0>(j));\n    }\n  }", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &parameters()\n        const override\n    {\n        parseParametersOnce();\n        return parameters_;\n    }", "target": 1}
{"code": "static void fio_worker_cleanup(void) {\n  if (fio_data->is_worker)\n    FIO_LOG_INFO(\"(%d) detected exit signal.\", (int)getpid());\n  else\n    FIO_LOG_INFO(\"Server Detected exit signal.\");\n  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol) {\n      fio_defer_push_task(deferred_on_shutdown, (void *)fd2uuid(i), NULL);\n    }\n  }\n  fio_defer_push_task(fio_cycle_unwind, NULL, NULL);\n  fio_defer_perform();\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol || fd_data(i).open) {\n      fio_force_close(fd2uuid(i));\n    }\n  }\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_ON_FINISH);\n  fio_defer_perform();\n  if (!fio_data->is_worker) {\n    fio_cluster_signal_children();\n    while (wait(NULL) != -1)\n      ;\n  }\n  fio_defer_perform();\n  fio_signal_handler_reset();\n  if (fio_data->parent == getpid()) {\n    FIO_LOG_INFO(\"   ---  Shutdown Complete  ---\\n\");\n  } else {\n    FIO_LOG_INFO(\"(%d) cleanup complete.\", (int)getpid());\n  }\n}", "target": 1}
{"code": "ResourceHandle::ResourceHandle(const ResourceHandleProto& proto) {\n  FromProto(proto);\n}", "target": 1}
{"code": "void yajl_string_decode(yajl_buf buf, const unsigned char * str,\n                        unsigned int len)\n{\n    unsigned int beg = 0;\n    unsigned int end = 0;    \n    while (end < len) {\n        if (str[end] == '\\\\') {\n            char utf8Buf[5];\n            const char * unescaped = \"?\";\n            yajl_buf_append(buf, str + beg, end - beg);\n            switch (str[++end]) {\n                case 'r': unescaped = \"\\r\"; break;\n                case 'n': unescaped = \"\\n\"; break;\n                case '\\\\': unescaped = \"\\\\\"; break;\n                case '/': unescaped = \"/\"; break;\n                case '\"': unescaped = \"\\\"\"; break;\n                case 'f': unescaped = \"\\f\"; break;\n                case 'b': unescaped = \"\\b\"; break;\n                case 't': unescaped = \"\\t\"; break;\n                case 'u': {\n                    unsigned int codepoint = 0;\n                    hexToDigit(&codepoint, str + ++end);\n                    end+=3;\n                    if ((codepoint & 0xFC00) == 0xD800) {\n                        end++;\n                        if (str[end] == '\\\\' && str[end + 1] == 'u') {\n                            unsigned int surrogate = 0;\n                            hexToDigit(&surrogate, str + end + 2);\n                            codepoint =\n                                (((codepoint & 0x3F) << 10) | \n                                 ((((codepoint >> 6) & 0xF) + 1) << 16) | \n                                 (surrogate & 0x3FF));\n                            end += 5;\n                        } else {\n                            unescaped = \"?\";\n                            break;\n                        }\n                    }\n                    Utf32toUtf8(codepoint, utf8Buf);\n                    unescaped = utf8Buf;\n                    if (codepoint == 0) {\n                        yajl_buf_append(buf, unescaped, 1);\n                        beg = ++end;\n                        continue;\n                    }\n                    break;\n                }\n                default:\n                    assert(\"this should never happen\" == NULL);\n            }\n            yajl_buf_append(buf, unescaped, (unsigned int)strlen(unescaped));\n            beg = ++end;\n        } else {\n            end++;\n        }\n    }\n    yajl_buf_append(buf, str + beg, end - beg);\n}", "target": 1}
{"code": "static void fanout_init_data(struct packet_fanout *f)\n{\n\tswitch (f->type) {\n\tcase PACKET_FANOUT_LB:\n\t\tatomic_set(&f->rr_cur, 0);\n\t\tbreak;\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tRCU_INIT_POINTER(f->bpf_prog, NULL);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "void EditorClientBlackBerry::handleKeyboardEvent(KeyboardEvent* event)\n{\n    ASSERT(event);\n    const PlatformKeyboardEvent* platformEvent = event->keyEvent();\n    if (!platformEvent)\n        return;\n    ASSERT(event->target()->toNode());\n    Frame* frame = event->target()->toNode()->document()->frame();\n    ASSERT(frame);\n    String commandName = interpretKeyEvent(event);\n    ASSERT(!(event->type() == eventNames().keydownEvent && frame->editor()->command(commandName).isTextInsertion()));\n    if (!commandName.isEmpty()) {\n        if (commandName != \"DeleteBackward\")\n            m_webPagePrivate->m_inputHandler->setProcessingChange(false);\n        if (frame->editor()->command(commandName).execute())\n            event->setDefaultHandled();\n        return;\n    }\n    if (!frame->editor()->canEdit())\n        return;\n    if (event->type() != eventNames().keypressEvent)\n        return;\n    if (event->charCode() < ' ')\n        return;\n    if (event->ctrlKey() || event->altKey())\n        return;\n    if (!platformEvent->text().isEmpty()) {\n        if (frame->editor()->insertText(platformEvent->text(), event))\n            event->setDefaultHandled();\n    }\n}", "target": 0}
{"code": "static struct dma_pte *pfn_to_dma_pte(struct dmar_domain *domain,\n\t\t\t\t      unsigned long pfn, int *target_level)\n{\n\tstruct dma_pte *parent, *pte;\n\tint level = agaw_to_level(domain->agaw);\n\tint offset;\n\tBUG_ON(!domain->pgd);\n\tif (!domain_pfn_supported(domain, pfn))\n\t\treturn NULL;\n\tparent = domain->pgd;\n\twhile (1) {\n\t\tvoid *tmp_page;\n\t\toffset = pfn_level_offset(pfn, level);\n\t\tpte = &parent[offset];\n\t\tif (!*target_level && (dma_pte_superpage(pte) || !dma_pte_present(pte)))\n\t\t\tbreak;\n\t\tif (level == *target_level)\n\t\t\tbreak;\n\t\tif (!dma_pte_present(pte)) {\n\t\t\tuint64_t pteval;\n\t\t\ttmp_page = alloc_pgtable_page(domain->nid);\n\t\t\tif (!tmp_page)\n\t\t\t\treturn NULL;\n\t\t\tdomain_flush_cache(domain, tmp_page, VTD_PAGE_SIZE);\n\t\t\tpteval = ((uint64_t)virt_to_dma_pfn(tmp_page) << VTD_PAGE_SHIFT) | DMA_PTE_READ | DMA_PTE_WRITE;\n\t\t\tif (cmpxchg64(&pte->val, 0ULL, pteval))\n\t\t\t\tfree_pgtable_page(tmp_page);\n\t\t\telse\n\t\t\t\tdomain_flush_cache(domain, pte, sizeof(*pte));\n\t\t}\n\t\tif (level == 1)\n\t\t\tbreak;\n\t\tparent = phys_to_virt(dma_pte_addr(pte));\n\t\tlevel--;\n\t}\n\tif (!*target_level)\n\t\t*target_level = level;\n\treturn pte;\n}", "target": 0}
{"code": "    CImg<Tfloat> get_tanh() const {\n      return CImg<Tfloat>(*this,false).tanh();", "target": 0}
{"code": "int bio_associate_current(struct bio *bio)\n{\n\tstruct io_context *ioc;\n\tif (bio->bi_css)\n\t\treturn -EBUSY;\n\tioc = current->io_context;\n\tif (!ioc)\n\t\treturn -ENOENT;\n\tget_io_context_active(ioc);\n\tbio->bi_ioc = ioc;\n\tbio->bi_css = task_get_css(current, io_cgrp_id);\n\treturn 0;\n}", "target": 0}
{"code": "  void StartOnIOThread(const base::Closure& done,\n                       ServiceWorkerStatusCode* result) {\n    ASSERT_TRUE(BrowserThread::CurrentlyOn(BrowserThread::IO));\n    version_->StartWorker(CreateReceiver(BrowserThread::UI, done, result));\n  }", "target": 0}
{"code": "static void virtio_net_set_status(struct VirtIODevice *vdev, uint8_t status)\n{\n    VirtIONet *n = VIRTIO_NET(vdev);\n    VirtIONetQueue *q;\n    int i;\n    uint8_t queue_status;\n    virtio_net_vnet_endian_status(n, status);\n    virtio_net_vhost_status(n, status);\n    for (i = 0; i < n->max_queues; i++) {\n        NetClientState *ncs = qemu_get_subqueue(n->nic, i);\n        bool queue_started;\n        q = &n->vqs[i];\n        if ((!n->multiqueue && i != 0) || i >= n->curr_queues) {\n            queue_status = 0;\n        } else {\n            queue_status = status;\n        }\n        queue_started =\n            virtio_net_started(n, queue_status) && !n->vhost_started;\n        if (queue_started) {\n            qemu_flush_queued_packets(ncs);\n        }\n        if (!q->tx_waiting) {\n            continue;\n        }\n        if (queue_started) {\n            if (q->tx_timer) {\n                timer_mod(q->tx_timer,\n                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + n->tx_timeout);\n            } else {\n                qemu_bh_schedule(q->tx_bh);\n            }\n        } else {\n            if (q->tx_timer) {\n                timer_del(q->tx_timer);\n            } else {\n                qemu_bh_cancel(q->tx_bh);\n            }\n            if ((n->status & VIRTIO_NET_S_LINK_UP) == 0 &&\n                (queue_status & VIRTIO_CONFIG_S_DRIVER_OK) &&\n                vdev->vm_running) {\n                q->tx_waiting = 0;\n                virtio_queue_set_notification(q->tx_vq, 1);\n                virtio_net_drop_tx_queue_data(vdev, q->tx_vq);\n            }\n        }\n    }\n}", "target": 0}
{"code": "ZEND_API int zend_update_static_property_bool(zend_class_entry *scope, const char *name, int name_length, long value TSRMLS_DC) \n{\n\tzval *tmp;\n\tALLOC_ZVAL(tmp);\n\tZ_UNSET_ISREF_P(tmp);\n\tZ_SET_REFCOUNT_P(tmp, 0);\n\tZVAL_BOOL(tmp, value);\n\treturn zend_update_static_property(scope, name, name_length, tmp TSRMLS_CC);\n}", "target": 0}
{"code": "void HTMLInputElement::setChecked(bool nowChecked, TextFieldEventBehavior eventBehavior)\n{\n    if (checked() == nowChecked)\n        return;\n    m_reflectsCheckedAttribute = false;\n    m_isChecked = nowChecked;\n    setNeedsStyleRecalc();\n    if (CheckedRadioButtons* buttons = checkedRadioButtons())\n            buttons->updateCheckedState(this);\n    if (renderer() && renderer()->style()->hasAppearance())\n        RenderTheme::theme().stateChanged(renderer(), CheckedState);\n    setNeedsValidityCheck();\n    if (renderer()) {\n        if (AXObjectCache* cache = renderer()->document().existingAXObjectCache())\n            cache->checkedStateChanged(this);\n    }\n    if (eventBehavior != DispatchNoEvent && inDocument() && m_inputType->shouldSendChangeEventAfterCheckedChanged()) {\n        setTextAsOfLastFormControlChangeEvent(String());\n        dispatchFormControlChangeEvent();\n    }\n    didAffectSelector(AffectedSelectorChecked);\n}", "target": 0}
{"code": "_client_list_free_node(t_client *client)\n{\n\tchar *msg;\n\tchar *cidinfo;\n\tif (client->cid) {\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\tfree(client->token);\n\tfree(client->hid);\n\tfree(client->custom);\n\tfree(client->client_type);\n\tfree(client->cid);\n\tif (strcmp(client->cpi_query, \"\") == 0) {\n\t\tfree(client->cpi_query);\n\t}\n\tfree(client);\n}", "target": 0}
{"code": "static struct vmcs *alloc_vmcs_cpu(int cpu)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\tpages = alloc_pages_exact_node(node, GFP_KERNEL, vmcs_config.order);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\tvmcs->revision_id = vmcs_config.revision_id; \n\treturn vmcs;\n}", "target": 0}
{"code": "static void *smm_stub_place_stacks(char *base, size_t size,\n\t\t\t\t   struct smm_loader_params *params)\n{\n\tsize_t total_stack_size;\n\tchar *stacks_top;\n\ttotal_stack_size = params->per_cpu_stack_size *\n\t\t\t   params->num_concurrent_stacks;\n\tprintk(BIOS_DEBUG, \"%s: cpus: %zx : stack space: needed -> %zx\\n\",\n\t\t__func__, params->num_concurrent_stacks,\n\t\ttotal_stack_size);\n\tprintk(BIOS_DEBUG, \"  available -> %zx : per_cpu_stack_size : %zx\\n\",\n\t\tsize, params->per_cpu_stack_size);\n\tif (params->num_concurrent_stacks < 1)\n\t\treturn NULL;\n\tif (total_stack_size > size)\n\t\treturn NULL;\n\tstacks_top = &base[total_stack_size];\n\tprintk(BIOS_DEBUG, \"%s: exit, stack_top %p\\n\", __func__, stacks_top);\n\treturn stacks_top;\n}", "target": 0}
{"code": "create_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\tcheck_spnego_options(spnego_ctx);\n\treturn (spnego_ctx);\n}", "target": 0}
{"code": "Suite *cjose_jwe_suite()\n{\n    Suite *suite = suite_create(\"jwe\");\n    TCase *tc_jwe = tcase_create(\"core\");\n    tcase_set_timeout(tc_jwe, 120.0);\n    tcase_add_test(tc_jwe, test_cjose_jwe_node_jose_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_iv);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_short);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_empty);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_large);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_many);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes_gcm);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_rsa);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_header);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_key);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_content);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_export_compare);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_invalid_serialization);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_bad_params);\n    tcase_add_test(tc_jwe, test_cjose_jwe_multiple_recipients);\n    suite_add_tcase(suite, tc_jwe);\n    return suite;\n}", "target": 0}
{"code": "void NetworkActionPredictor::AddRow(\n    const DBCacheKey& key,\n    const NetworkActionPredictorDatabase::Row& row) {\n  if (!initialized_)\n    return;\n  DBCacheValue value = { row.number_of_hits, row.number_of_misses };\n  db_cache_[key] = value;\n  db_id_cache_[key] = row.id;\n  content::BrowserThread::PostTask(content::BrowserThread::DB, FROM_HERE,\n      base::Bind(&NetworkActionPredictorDatabase::AddRow, db_, row));\n}", "target": 0}
{"code": "static int fts3LcsIteratorAdvance(LcsIterator *pIter){\n  char *pRead = pIter->pRead;\n  sqlite3_int64 iRead;\n  int rc = 0;\n  pRead += sqlite3Fts3GetVarint(pRead, &iRead);\n  if( iRead==0 || iRead==1 ){\n    pRead = 0;\n    rc = 1;\n  }else{\n    pIter->iPos += (int)(iRead-2);\n  }\n  pIter->pRead = pRead;\n  return rc;\n}", "target": 0}
{"code": "njs_encode_hex_length(const njs_str_t *src, size_t *out_size)\n{\n    size_t  size;\n    size = src->length * 2;\n    if (out_size != NULL) {\n        *out_size = size;\n    }\n    return size;\n}", "target": 0}
{"code": "static bool torture_winbind_struct_domain_name(struct torture_context *torture)\n{\n\tconst char *expected;\n\tchar *domain;\n\ttorture_comment(torture, \"Running WINBINDD_DOMAIN_NAME (struct based)\\n\");\n\texpected = torture_setting_string(torture,\n\t\t\t\t\t  \"winbindd_netbios_domain\",\n\t\t\t\t\t  lpcfg_workgroup(torture->lp_ctx));\n\tget_winbind_domain(torture, &domain);\n\ttorture_assert_str_equal(torture, domain, expected,\n\t\t\t\t \"winbindd's netbios domain doesn't match\");\n\treturn true;\n}", "target": 0}
{"code": "static inline unsigned char *skb_network_header(const struct sk_buff *skb)\n{\n\treturn skb->head + skb->network_header;\n}", "target": 0}
{"code": "gs_heap_resize_string(gs_memory_t * mem, byte * data, uint old_num, uint new_num,\n                      client_name_t cname)\n{\n    if (gs_heap_object_type(mem, data) != &st_bytes)\n        lprintf2(\"%s: resizing non-string 0x%lx!\\n\",\n                 client_name_string(cname), (ulong) data);\n    return gs_heap_resize_object(mem, data, new_num, cname);\n}", "target": 0}
{"code": "GF_Err gf_isom_get_watermark(GF_ISOFile *mov, bin128 UUID, u8** data, u32* length)\n{\n\tGF_UserDataMap *map;\n\tGF_UnknownUUIDBox *wm;\n\tif (!mov) return GF_BAD_PARAM;\n\tif (!mov->moov || !mov->moov->udta) return GF_NOT_SUPPORTED;\n\tmap = udta_getEntry(mov->moov->udta, GF_ISOM_BOX_TYPE_UUID, (bin128 *) & UUID);\n\tif (!map) return GF_NOT_SUPPORTED;\n\twm = (GF_UnknownUUIDBox*)gf_list_get(map->boxes, 0);\n\tif (!wm) return GF_NOT_SUPPORTED;\n\t*data = (u8 *) gf_malloc(sizeof(char)*wm->dataSize);\n\tif (! *data) return GF_OUT_OF_MEM;\n\tmemcpy(*data, wm->data, wm->dataSize);\n\t*length = wm->dataSize;\n\treturn GF_OK;\n}", "target": 0}
{"code": "storagePoolDelete(virStoragePoolPtr pool,\n                  unsigned int flags)\n{\n    virStoragePoolObj *obj;\n    virStoragePoolDef *def;\n    virStorageBackend *backend;\n    virObjectEvent *event = NULL;\n    int ret = -1;\n    g_autofree char *stateFile = NULL;\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return -1;\n    def = virStoragePoolObjGetDef(obj);\n    if (virStoragePoolDeleteEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n    if ((backend = virStorageBackendForType(def->type)) == NULL)\n        goto cleanup;\n    VIR_INFO(\"Deleting storage pool '%s'\", def->name);\n    if (virStoragePoolObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is still active\"),\n                       def->name);\n        goto cleanup;\n    }\n    if (virStoragePoolObjIsStarting(obj)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"storage pool '%s' is starting up\"),\n                       def->name);\n        goto cleanup;\n    }\n    if (virStoragePoolObjGetAsyncjobs(obj) > 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"pool '%s' has asynchronous jobs running.\"),\n                       def->name);\n        goto cleanup;\n    }\n    if (!(stateFile = virFileBuildPath(driver->stateDir, def->name, \".xml\")))\n        goto cleanup;\n    unlink(stateFile);\n    if (!backend->deletePool) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       \"%s\", _(\"pool does not support pool deletion\"));\n        goto cleanup;\n    }\n    if (backend->deletePool(obj, flags) < 0)\n        goto cleanup;\n    event = virStoragePoolEventLifecycleNew(def->name,\n                                            def->uuid,\n                                            VIR_STORAGE_POOL_EVENT_DELETED,\n                                            0);\n    ret = 0;\n cleanup:\n    virObjectEventStateQueue(driver->storageEventState, event);\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}", "target": 0}
{"code": "        void PngChunk::zlibUncompress(const byte* compressedText, unsigned int compressedTextSize, DataBuf& arr)\n        {\n            uLongf uncompressedLen = compressedTextSize * 2;  \n            int zlibResult;\n            int dos = 0;\n            do {\n                arr.alloc(uncompressedLen);\n                zlibResult = uncompress((Bytef*)arr.pData_, &uncompressedLen, compressedText, compressedTextSize);\n                if (zlibResult == Z_OK) {\n                    assert((uLongf)arr.size_ >= uncompressedLen);\n                    arr.size_ = uncompressedLen;\n                } else if (zlibResult == Z_BUF_ERROR) {\n                    uncompressedLen *= 2;\n                    if (uncompressedLen > 131072) {\n                        if (++dos > 1)\n                            break;\n                        uncompressedLen = 131072;\n                    }\n                } else {\n                    throw Error(kerFailedToReadImageData);\n                }\n            } while (zlibResult == Z_BUF_ERROR);\n            if (zlibResult != Z_OK) {\n                throw Error(kerFailedToReadImageData);\n            }\n        }  ", "target": 0}
{"code": "void RGWListBuckets_ObjStore_S3::send_response_data(rgw::sal::RGWBucketList& buckets)\n{\n  if (!sent_data)\n    return;\n  map<string, rgw::sal::RGWBucket*>& m = buckets.get_buckets();\n  map<string, rgw::sal::RGWBucket*>::iterator iter;\n  for (iter = m.begin(); iter != m.end(); ++iter) {\n    rgw::sal::RGWBucket* obj = iter->second;\n    dump_bucket(s, *obj);\n  }\n  rgw_flush_formatter(s, s->formatter);\n}", "target": 0}
{"code": "ev_archive_init (EvArchive *archive)\n{\n}", "target": 0}
{"code": "  const base::CommandLine& command_line() const {\n    return command_line_;\n  }", "target": 0}
{"code": "static int wcd9335_codec_set_sysclk(struct snd_soc_component *comp,\n\t\t\t\t    int clk_id, int source,\n\t\t\t\t    unsigned int freq, int dir)\n{\n\tstruct wcd9335_codec *wcd = dev_get_drvdata(comp->dev);\n\twcd->mclk_rate = freq;\n\tif (wcd->mclk_rate == WCD9335_MCLK_CLK_12P288MHZ)\n\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\tWCD9335_CODEC_RPM_CLK_MCLK_CFG,\n\t\t\t\tWCD9335_CODEC_RPM_CLK_MCLK_CFG_MCLK_MASK,\n\t\t\t\tWCD9335_CODEC_RPM_CLK_MCLK_CFG_12P288MHZ);\n\telse if (wcd->mclk_rate == WCD9335_MCLK_CLK_9P6MHZ)\n\t\tsnd_soc_component_update_bits(comp,\n\t\t\t\tWCD9335_CODEC_RPM_CLK_MCLK_CFG,\n\t\t\t\tWCD9335_CODEC_RPM_CLK_MCLK_CFG_MCLK_MASK,\n\t\t\t\tWCD9335_CODEC_RPM_CLK_MCLK_CFG_9P6MHZ);\n\treturn clk_set_rate(wcd->mclk, freq);\n}", "target": 0}
{"code": "static int process_output(unsigned char c, struct tty_struct *tty)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace, retval;\n\tmutex_lock(&ldata->output_lock);\n\tspace = tty_write_room(tty);\n\tretval = do_output_char(c, tty, space);\n\tmutex_unlock(&ldata->output_lock);\n\tif (retval < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}", "target": 0}
{"code": "ZEND_INI_MH(OnUpdateEncode)\n{\n\tif (new_value && ZSTR_LEN(new_value)) {\n\t\tconst zend_encoding **return_list;\n\t\tsize_t return_size;\n\t\tif (FAILURE == zend_multibyte_parse_encoding_list(ZSTR_VAL(new_value), ZSTR_LEN(new_value),\n\t&return_list, &return_size, 0)) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Illegal encoding ignored: '%s'\", ZSTR_VAL(new_value));\n\t\t\treturn FAILURE;\n\t\t}\n\t\tpefree((void *) return_list, 0);\n\t}\n\treturn OnUpdateString(entry, new_value, mh_arg1, mh_arg2, mh_arg3, stage);\n}", "target": 0}
{"code": "vte_sequence_handler_screen_alignment_test (VteTerminal *terminal, GValueArray *params)\n{\n\tlong row;\n\tVteRowData *rowdata, *old_row;\n\tVteScreen *screen;\n\tstruct vte_charcell cell;\n\tscreen = terminal->pvt->screen;\n\tfor (row = terminal->pvt->screen->insert_delta;\n\t     row < terminal->pvt->screen->insert_delta + terminal->row_count;\n\t     row++) {\n\t\told_row = terminal->pvt->free_row;\n\t\twhile (_vte_ring_next(screen->row_data) <= row) {\n\t\t\tif (old_row) {\n\t\t\t\trowdata = _vte_reset_row_data (terminal, old_row, FALSE);\n\t\t\t} else {\n\t\t\t\trowdata = _vte_new_row_data(terminal);\n\t\t\t}\n\t\t\told_row = _vte_ring_append(screen->row_data, rowdata);\n\t\t}\n\t\tterminal->pvt->free_row = old_row;\n\t\t_vte_terminal_adjust_adjustments(terminal);\n\t\trowdata = _vte_ring_index(screen->row_data, VteRowData *, row);\n\t\tg_assert(rowdata != NULL);\n\t\tif (rowdata->cells->len > 0) {\n\t\t\tg_array_set_size(rowdata->cells, 0);\n\t\t}\n\t\t_vte_terminal_emit_text_deleted(terminal);\n\t\tcell.c = 'E';\n\t\tcell.attr = screen->basic_defaults.attr;\n\t\tcell.attr.columns = 1;\n\t\tvte_g_array_fill(rowdata->cells, &cell, terminal->column_count);\n\t\t_vte_terminal_emit_text_inserted(terminal);\n\t}\n\t_vte_invalidate_all(terminal);\n\tterminal->pvt->text_modified_flag = TRUE;\n}", "target": 0}
{"code": "string_is_ip_address(uschar *s, int *maskptr)\n{\nint i;\nint yield = 4;\nif (maskptr != NULL)\n  {\n  uschar *ss = s + Ustrlen(s);\n  *maskptr = 0;\n  if (s != ss && isdigit(*(--ss)))\n    {\n    while (ss > s && isdigit(ss[-1])) ss--;\n    if (ss > s && *(--ss) == '/') *maskptr = ss - s;\n    }\n  }\nif (Ustrchr(s, ':') != NULL)\n  {\n  BOOL had_double_colon = FALSE;\n  BOOL v4end = FALSE;\n  int count = 0;\n  yield = 6;\n  if (*s == ':' && *(++s) != ':') return 0;\n  for (count = 0; count < 8; count++)\n    {\n    if (*s == 0 || *s == '%' || *s == '/') return had_double_colon? yield : 0;\n    if (*s == ':')\n      {\n      if (had_double_colon) return 0;\n      had_double_colon = TRUE;\n      s++;\n      continue;\n      }\n    if (Ustrchr(s, ':') == NULL && Ustrchr(s, '.') != NULL)\n      {\n      if ((!had_double_colon && count != 6) ||\n          (had_double_colon && count > 6)) return 0;\n      v4end = TRUE;\n      yield = 6;\n      break;\n      }\n    if (!isxdigit(*s++)) return 0;\n    if (isxdigit(*s) && isxdigit(*(++s)) && isxdigit(*(++s))) s++;\n    if (*s == ':' && *(++s) == 0) return 0;\n    }\n  if (!v4end)\n    return (*s == 0 || *s == '%' ||\n           (*s == '/' && maskptr != NULL && *maskptr != 0))? yield : 0;\n  }\nfor (i = 0; i < 4; i++)\n  {\n  if (i != 0 && *s++ != '.') return 0;\n  if (!isdigit(*s++)) return 0;\n  if (isdigit(*s) && isdigit(*(++s))) s++;\n  }\nreturn (*s == 0 || (*s == '/' && maskptr != NULL && *maskptr != 0))?\n  yield : 0;\n}", "target": 0}
{"code": "static void __exit exit_udf_fs(void)\n{\n\tunregister_filesystem(&udf_fstype);\n\tdestroy_inodecache();\n}", "target": 0}
{"code": "bool WasmBinaryBuilder::maybeVisitConst(Expression*& out, uint8_t code) {\n  Const* curr;\n  BYN_TRACE(\"zz node: Const, code \" << code << std::endl);\n  switch (code) {\n    case BinaryConsts::I32Const:\n      curr = allocator.alloc<Const>();\n      curr->value = Literal(getS32LEB());\n      break;\n    case BinaryConsts::I64Const:\n      curr = allocator.alloc<Const>();\n      curr->value = Literal(getS64LEB());\n      break;\n    case BinaryConsts::F32Const:\n      curr = allocator.alloc<Const>();\n      curr->value = getFloat32Literal();\n      break;\n    case BinaryConsts::F64Const:\n      curr = allocator.alloc<Const>();\n      curr->value = getFloat64Literal();\n      break;\n    default:\n      return false;\n  }\n  curr->type = curr->value.type;\n  out = curr;\n  return true;\n}", "target": 0}
{"code": "static struct sctp_chunk *sctp_make_data(const struct sctp_association *asoc,\n\t\t\t\t\t __u8 flags, int paylen)\n{\n\treturn _sctp_make_chunk(asoc, SCTP_CID_DATA, flags, paylen);\n}", "target": 0}
{"code": "static __exit void hardware_unsetup(void)\n{\n\tfree_kvm_area();\n}", "target": 0}
{"code": "  Value* Parser::color_or_string(const std::string& lexed) const\n  {\n    if (auto color = name_to_color(lexed)) {\n      auto c = SASS_MEMORY_NEW(Color_RGBA, color);\n      c->is_delayed(true);\n      c->pstate(pstate);\n      c->disp(lexed);\n      return c;\n    } else {\n      return SASS_MEMORY_NEW(String_Constant, pstate, lexed);\n    }\n  }", "target": 0}
{"code": "uint32 SoftwareFrameManager::GetCurrentFrameOutputSurfaceId() const {\n  DCHECK(HasCurrentFrame());\n  return current_frame_->output_surface_id_;\n}", "target": 0}
{"code": "static int lua_ap_some_auth_required(request_rec *r)\n{\n    return ap_some_auth_required(r);\n}", "target": 0}
{"code": "static long sched_group_rt_runtime(struct task_group *tg)\n{\n\tu64 rt_runtime_us;\n\tif (tg->rt_bandwidth.rt_runtime == RUNTIME_INF)\n\t\treturn -1;\n\trt_runtime_us = tg->rt_bandwidth.rt_runtime;\n\tdo_div(rt_runtime_us, NSEC_PER_USEC);\n\treturn rt_runtime_us;\n}", "target": 0}
{"code": "static struct page *nested_get_page(struct kvm_vcpu *vcpu, gpa_t addr)\n{\n\tstruct page *page = gfn_to_page(vcpu->kvm, addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn NULL;\n\treturn page;\n}", "target": 0}
{"code": "dict_param_read(iparam_list * plist, const ref * pkey, iparam_loc * ploc)\n{\n    ref const *spdict = &((dict_param_list *) plist)->dict;\n    int code = dict_find(spdict, pkey, &ploc->pvalue);\n    if (code != 1)\n        return 1;\n    ploc->presult =\n        &plist->results[dict_value_index(spdict, ploc->pvalue)];\n    *ploc->presult = 1;\n    return 0;\n}", "target": 0}
{"code": "AP_DECLARE(apr_size_t) ap_get_limit_xml_body(const request_rec *r)\n{\n    core_dir_config *conf;\n    conf = ap_get_core_module_config(r->per_dir_config);\n    if (conf->limit_xml_body == AP_LIMIT_UNSET)\n        return AP_DEFAULT_LIMIT_XML_BODY;\n    return (apr_size_t)conf->limit_xml_body;\n}", "target": 0}
{"code": "static int get_capture_buffer(struct file *file)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tstruct v4l2_loopback_opener *opener = file->private_data;\n\tint pos, ret;\n\tint timeout_happened;\n\tif ((file->f_flags & O_NONBLOCK) &&\n\t    (dev->write_position <= opener->read_position &&\n\t     dev->reread_count <= opener->reread_count && !dev->timeout_happened))\n\t\treturn -EAGAIN;\n\twait_event_interruptible(dev->read_event, can_read(dev, opener));\n\tspin_lock_bh(&dev->lock);\n\tif (dev->write_position == opener->read_position) {\n\t\tif (dev->reread_count > opener->reread_count + 2)\n\t\t\topener->reread_count = dev->reread_count - 1;\n\t\t++opener->reread_count;\n\t\tpos = (opener->read_position + dev->used_buffers - 1) % dev->used_buffers;\n\t} else {\n\t\topener->reread_count = 0;\n\t\tif (dev->write_position > opener->read_position + 2)\n\t\t\topener->read_position = dev->write_position - 1;\n\t\tpos = opener->read_position % dev->used_buffers;\n\t\t++opener->read_position;\n\t}\n\ttimeout_happened = dev->timeout_happened;\n\tdev->timeout_happened = 0;\n\tspin_unlock_bh(&dev->lock);\n\tret = dev->bufpos2index[pos];\n\tif (timeout_happened) {\n\t\tmemcpy(dev->image + dev->buffers[ret].buffer.m.offset,\n\t\t       dev->timeout_image, dev->buffer_size);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static int em_test(struct x86_emulate_ctxt *ctxt)\n{\n\temulate_2op_SrcV(ctxt, \"test\");\n\tctxt->dst.type = OP_NONE;\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "  static void loadFromJson(const std::string& json, Protobuf::Message& message,\n                           bool preserve_original_type = false, bool avoid_boosting = false) {\n    MessageUtil::loadFromJson(json, message, ProtobufMessage::getStrictValidationVisitor(),\n                              !avoid_boosting);\n    if (!preserve_original_type) {\n      Config::VersionConverter::eraseOriginalTypeInformation(message);\n    }\n  }", "target": 0}
{"code": "int LibRaw::getwords(char *line, char *words[], int maxwords, int maxlen)\n{\n  line[maxlen - 1] = 0;\n  char *p = line;\n  int nwords = 0;\n  while (1)\n  {\n    while (isspace(*p))\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    words[nwords++] = p;\n    while (!isspace(*p) && *p != '\\0')\n      p++;\n    if (*p == '\\0')\n      return nwords;\n    *p++ = '\\0';\n    if (nwords >= maxwords)\n      return nwords;\n  }\n}", "target": 0}
{"code": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}", "target": 0}
{"code": "learn_min_len(uint16_t header)\n{\n    int n_bits = header & NX_LEARN_N_BITS_MASK;\n    int src_type = header & NX_LEARN_SRC_MASK;\n    int dst_type = header & NX_LEARN_DST_MASK;\n    unsigned int min_len;\n    min_len = 0;\n    if (src_type == NX_LEARN_SRC_FIELD) {\n        min_len += sizeof(ovs_be32); \n        min_len += sizeof(ovs_be16); \n    } else {\n        min_len += 2 * DIV_ROUND_UP(n_bits, 16);\n    }\n    if (dst_type == NX_LEARN_DST_MATCH ||\n        dst_type == NX_LEARN_DST_LOAD) {\n        min_len += sizeof(ovs_be32); \n        min_len += sizeof(ovs_be16); \n    }\n    return min_len;\n}", "target": 0}
{"code": "dirserv_has_measured_bw(const char *node_id)\n{\n  return dirserv_query_measured_bw_cache_kb(node_id, NULL, NULL);\n}", "target": 0}
{"code": "void close_thread_table(THD *thd, TABLE **table_ptr)\n{\n  TABLE *table= *table_ptr;\n  DBUG_ENTER(\"close_thread_table\");\n  DBUG_PRINT(\"tcache\", (\"table: '%s'.'%s' %p\", table->s->db.str,\n                        table->s->table_name.str, table));\n  DBUG_ASSERT(!table->file->keyread_enabled());\n  DBUG_ASSERT(!table->file || table->file->inited == handler::NONE);\n  DBUG_ASSERT(thd->mdl_context.is_lock_owner(MDL_key::TABLE,\n                                             table->s->db.str,\n                                             table->s->table_name.str,\n                                             MDL_SHARED));\n  table->mdl_ticket= NULL;\n  if (table->file)\n  {\n    table->file->update_global_table_stats();\n    table->file->update_global_index_stats();\n  }\n  mysql_mutex_lock(&thd->LOCK_thd_data);\n  *table_ptr=table->next;\n  mysql_mutex_unlock(&thd->LOCK_thd_data);\n  if (! table->needs_reopen())\n  {\n    table->file->extra(HA_EXTRA_DETACH_CHILDREN);\n    free_field_buffers_larger_than(table, MAX_TDC_BLOB_SIZE);\n    table->file->ha_reset();\n  }\n  MYSQL_UNBIND_TABLE(table->file);\n  tc_release_table(table);\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "static void FUNC(pred_angular_2)(uint8_t *src, const uint8_t *top,\n                                 const uint8_t *left,\n                                 ptrdiff_t stride, int c_idx, int mode)\n{\n    FUNC(pred_angular)(src, top, left, stride, c_idx, mode, 1 << 4);\n}", "target": 0}
{"code": "static void try_to_wake_up_local(struct task_struct *p)\n{\n\tstruct rq *rq = task_rq(p);\n\tif (WARN_ON_ONCE(rq != this_rq()) ||\n\t    WARN_ON_ONCE(p == current))\n\t\treturn;\n\tlockdep_assert_held(&rq->lock);\n\tif (!raw_spin_trylock(&p->pi_lock)) {\n\t\tlockdep_unpin_lock(&rq->lock);\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_lock(&p->pi_lock);\n\t\traw_spin_lock(&rq->lock);\n\t\tlockdep_pin_lock(&rq->lock);\n\t}\n\tif (!(p->state & TASK_NORMAL))\n\t\tgoto out;\n\ttrace_sched_waking(p);\n\tif (!task_on_rq_queued(p))\n\t\tttwu_activate(rq, p, ENQUEUE_WAKEUP);\n\tttwu_do_wakeup(rq, p, 0);\n\tif (schedstat_enabled())\n\t\tttwu_stat(p, smp_processor_id(), 0);\nout:\n\traw_spin_unlock(&p->pi_lock);\n}", "target": 0}
{"code": "struct tipc_crypto *tipc_node_crypto_rx(struct tipc_node *__n)\n{\n\treturn (__n) ? __n->crypto_rx : NULL;\n}", "target": 0}
{"code": "static inline int route4_hash_to(u32 id)\n{\n\treturn id & 0xFF;\n}", "target": 0}
{"code": "static void gluster_free_server(gluster_server **hosts)\n{\n\tif (!*hosts)\n\t\treturn;\n\tfree((*hosts)->volname);\n\tfree((*hosts)->path);\n\tgluster_free_host((*hosts)->server);\n\tfree((*hosts)->server);\n\t(*hosts)->server = NULL;\n\tfree(*hosts);\n\t*hosts = NULL;\n}", "target": 0}
{"code": "static int sg_proc_single_open_version(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, sg_proc_seq_show_version, NULL);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::ShowContextMenuAtPoint(const gfx::Point& point) {\n  Send(new ViewMsg_ShowContextMenu(\n      GetRoutingID(), ui::MENU_SOURCE_MOUSE, point));\n}", "target": 0}
{"code": "  pin(std::string pin, std::string name) {\n    pt::ptree tree;\n    if (map_id_sess.empty()) {\n      return false;\n    }\n    if (pin.size() != 4) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\n        \"root.<xmlattr>.status_message\", \"Pin must be 4 digits, \" + std::to_string(pin.size()) + \" provided\");\n      return false;\n    }\n    if (!std::all_of(pin.begin(), pin.end(), ::isdigit)) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\"root.<xmlattr>.status_message\", \"Pin must be numeric\");\n      return false;\n    }\n    auto &sess = std::begin(map_id_sess)->second;\n    getservercert(sess, tree, pin);\n    sess.client.name = name;\n    std::ostringstream data;\n    pt::write_xml(data, tree);\n    auto &async_response = sess.async_insert_pin.response;\n    if (async_response.has_left() && async_response.left()) {\n      async_response.left()->write(data.str());\n    }\n    else if (async_response.has_right() && async_response.right()) {\n      async_response.right()->write(data.str());\n    }\n    else {\n      return false;\n    }\n    async_response = std::decay_t<decltype(async_response.left())>();\n    return true;\n  }", "target": 0}
{"code": "static int kvm_vm_ioctl_get_nr_mmu_pages(struct kvm *kvm)\n{\n\treturn kvm->arch.n_max_mmu_pages;\n}", "target": 0}
{"code": "SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\tunsigned int, size, unsigned int, flags)\n{\n\tstruct sched_attr attr = {\n\t\t.size = sizeof(struct sched_attr),\n\t};\n\tstruct task_struct *p;\n\tint retval;\n\tif (!uattr || pid < 0 || size > PAGE_SIZE ||\n\t    size < SCHED_ATTR_SIZE_VER0 || flags)\n\t\treturn -EINVAL;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -ESRCH;\n\tif (!p)\n\t\tgoto out_unlock;\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\tattr.sched_policy = p->policy;\n\tif (p->sched_reset_on_fork)\n\t\tattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;\n\tif (task_has_dl_policy(p))\n\t\t__getparam_dl(p, &attr);\n\telse if (task_has_rt_policy(p))\n\t\tattr.sched_priority = p->rt_priority;\n\telse\n\t\tattr.sched_nice = task_nice(p);\n\trcu_read_unlock();\n\tretval = sched_read_attr(uattr, &attr, size);\n\treturn retval;\nout_unlock:\n\trcu_read_unlock();\n\treturn retval;\n}", "target": 0}
{"code": "static inline int __pskb_trim(struct sk_buff *skb, unsigned int len)\n{\n\tif (skb->data_len)\n\t\treturn ___pskb_trim(skb, len);\n\t__skb_trim(skb, len);\n\treturn 0;\n}", "target": 0}
{"code": "fill_extra_data(conn c)\n{\n    int extra_bytes, job_data_bytes = 0, cmd_bytes;\n    if (!c->fd) return; \n    if (!c->cmd_len) return; \n    extra_bytes = c->cmd_read - c->cmd_len;\n    if (c->in_job) {\n        job_data_bytes = min(extra_bytes, c->in_job->body_size);\n        memcpy(c->in_job->body, c->cmd + c->cmd_len, job_data_bytes);\n        c->in_job_read = job_data_bytes;\n    } else if (c->in_job_read) {\n        job_data_bytes = min(extra_bytes, c->in_job_read);\n        c->in_job_read -= job_data_bytes;\n    }\n    cmd_bytes = extra_bytes - job_data_bytes;\n    memmove(c->cmd, c->cmd + c->cmd_len + job_data_bytes, cmd_bytes);\n    c->cmd_read = cmd_bytes;\n    c->cmd_len = 0; \n}", "target": 0}
{"code": "TEST(QuantizedUInt8PoolingOpTest, MaxPoolActivationRelu) {\n  QuantizedPoolingOpModel m(\n      BuiltinOperator_MAX_POOL_2D,\n      {TensorType_UINT8, {1, 2, 4, 1}, -15.9375, 15.9375},\n      2, 2,\n      {TensorType_UINT8, {}, -15.9375, 15.9375}, Padding_VALID, 2, 2,\n      ActivationFunctionType_RELU);\n  m.SetInput({\n      -1.5, -6, 2, 4,  \n      -3, -2, 10, 7,   \n  });\n  m.Invoke();\n  EXPECT_THAT(m.GetDequantizedOutput(),\n              ElementsAreArray(ArrayFloatNear({0, 10})));\n  EXPECT_THAT(m.GetOutput(), ElementsAreArray({128, 208}));\n}", "target": 0}
{"code": "RenderObject* HTMLTextAreaElement::createRenderer(RenderStyle*)\n{\n    return new RenderTextControlMultiLine(this);\n}", "target": 0}
{"code": "static int fts3FunctionArg(\n  sqlite3_context *pContext,      \n  const char *zFunc,              \n  sqlite3_value *pVal,            \n  Fts3Cursor **ppCsr              \n){\n  Fts3Cursor *pRet;\n  if( sqlite3_value_type(pVal)!=SQLITE_BLOB \n   || sqlite3_value_bytes(pVal)!=sizeof(Fts3Cursor *)\n  ){\n    char *zErr = sqlite3_mprintf(\"illegal first argument to %s\", zFunc);\n    sqlite3_result_error(pContext, zErr, -1);\n    sqlite3_free(zErr);\n    return SQLITE_ERROR;\n  }\n  memcpy(&pRet, sqlite3_value_blob(pVal), sizeof(Fts3Cursor *));\n  *ppCsr = pRet;\n  return SQLITE_OK;\n}", "target": 0}
{"code": "url_valid_scheme (const char *url)\n{\n  enum url_scheme scheme = url_scheme (url);\n  return scheme != SCHEME_INVALID;\n}", "target": 0}
{"code": "void RenderView::spellCheck(const WebString& text,\n                            int& misspelled_offset,\n                            int& misspelled_length) {\n  EnsureDocumentTag();\n  string16 word(text);\n  RenderThread* thread = RenderThread::current();\n  if (thread) {\n    thread->spellchecker()->SpellCheckWord(\n        word.c_str(), word.size(), document_tag_,\n        &misspelled_offset, &misspelled_length, NULL);\n  }\n}", "target": 0}
{"code": "Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    const Tensor* tensor;\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    if (tensor->NumElements() == 0) {\n      return errors::InvalidArgument(\"Empty resource handle\");\n    }\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    const bool use_host_memory =\n        is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n               : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      if (!op.is_function() && device != nullptr && device != cpu_device) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "SWFInput_buffer_getChar(SWFInput input)\n{\n\tif ( input->offset >= input->length )\n\t\treturn EOF;\n\telse\n\t\treturn ((unsigned char *)input->data)[input->offset++];\n}", "target": 0}
{"code": "parse_ipsecrequest(struct xfrm_policy *xp, struct sadb_x_ipsecrequest *rq)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_tmpl *t = xp->xfrm_vec + xp->xfrm_nr;\n\tint mode;\n\tif (xp->xfrm_nr >= XFRM_MAX_DEPTH)\n\t\treturn -ELOOP;\n\tif (rq->sadb_x_ipsecrequest_mode == 0)\n\t\treturn -EINVAL;\n\tif (!xfrm_id_proto_valid(rq->sadb_x_ipsecrequest_proto))\n\t\treturn -EINVAL;\n\tt->id.proto = rq->sadb_x_ipsecrequest_proto;\n\tif ((mode = pfkey_mode_to_xfrm(rq->sadb_x_ipsecrequest_mode)) < 0)\n\t\treturn -EINVAL;\n\tt->mode = mode;\n\tif (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_USE)\n\t\tt->optional = 1;\n\telse if (rq->sadb_x_ipsecrequest_level == IPSEC_LEVEL_UNIQUE) {\n\t\tt->reqid = rq->sadb_x_ipsecrequest_reqid;\n\t\tif (t->reqid > IPSEC_MANUAL_REQID_MAX)\n\t\t\tt->reqid = 0;\n\t\tif (!t->reqid && !(t->reqid = gen_reqid(net)))\n\t\t\treturn -ENOBUFS;\n\t}\n\tif (t->mode == XFRM_MODE_TUNNEL) {\n\t\tint err;\n\t\terr = parse_sockaddr_pair(\n\t\t\t(struct sockaddr *)(rq + 1),\n\t\t\trq->sadb_x_ipsecrequest_len - sizeof(*rq),\n\t\t\t&t->saddr, &t->id.daddr, &t->encap_family);\n\t\tif (err)\n\t\t\treturn err;\n\t} else\n\t\tt->encap_family = xp->family;\n\tt->allalgs = 1;\n\txp->xfrm_nr++;\n\treturn 0;\n}", "target": 0}
{"code": "void InstanceKlass::ensure_space_for_methodids(int start_offset) {\n  int new_jmeths = 0;\n  int length = methods()->length();\n  for (int index = start_offset; index < length; index++) {\n    Method* m = methods()->at(index);\n    jmethodID id = m->find_jmethod_id_or_null();\n    if (id == NULL) {\n      new_jmeths++;\n    }\n  }\n  if (new_jmeths != 0) {\n    Method::ensure_jmethod_ids(class_loader_data(), new_jmeths);\n  }\n}", "target": 0}
{"code": "static __net_exit void ppp_exit_net(struct net *net)\n{\n\tstruct ppp_net *pn;\n\tpn = net_generic(net, ppp_net_id);\n\tidr_destroy(&pn->units_idr);\n\tnet_assign_generic(net, ppp_net_id, NULL);\n\tkfree(pn);\n}", "target": 0}
{"code": "void LibRaw::process_Sony_0x940c(uchar *buf, ushort len)\n{\n  if ((imSony.CameraType != LIBRAW_SONY_ILCE) &&\n      (imSony.CameraType != LIBRAW_SONY_NEX))\n    return;\n  if (len <= 0x000a)\n    return;\n  ushort lid2;\n  if ((ilm.LensMount != LIBRAW_MOUNT_Canon_EF) &&\n      (ilm.LensMount != LIBRAW_MOUNT_Sigma_X3F))\n  {\n    switch (SonySubstitution[buf[0x0008]])\n    {\n    case 1:\n    case 5:\n      ilm.LensMount = LIBRAW_MOUNT_Minolta_A;\n      break;\n    case 4:\n      ilm.LensMount = LIBRAW_MOUNT_Sony_E;\n      break;\n    }\n  }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]]) << 8) |\n         ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) &&\n      ((lid2 < 32784) || (ilm.LensID == 0x1999) || (ilm.LensID == 0xffff)))\n    parseSonyLensType2(\n        SonySubstitution[buf[0x000a]], \n        SonySubstitution[buf[0x0009]]);\n  if ((lid2 == 44) || (lid2 == 78) || (lid2 == 184) || (lid2 == 234) ||\n      (lid2 == 239))\n    ilm.AdapterID = lid2;\n  return;\n}", "target": 0}
{"code": "get_section_vma (UINTN section_num,\n\t\t char *buffer, size_t bufsz UNUSED,\n\t\t PE_COFF_LOADER_IMAGE_CONTEXT *context,\n\t\t char **basep, size_t *sizep,\n\t\t EFI_IMAGE_SECTION_HEADER **sectionp)\n{\n\tEFI_IMAGE_SECTION_HEADER *sections = context->FirstSection;\n\tEFI_IMAGE_SECTION_HEADER *section;\n\tchar *base = NULL, *end = NULL;\n\tif (section_num >= context->NumberOfSections)\n\t\treturn EFI_NOT_FOUND;\n\tif (context->FirstSection == NULL) {\n\t\tperror(L\"Invalid section %d requested\\n\", section_num);\n\t\treturn EFI_UNSUPPORTED;\n\t}\n\tsection = &sections[section_num];\n\tbase = ImageAddress (buffer, context->ImageSize, section->VirtualAddress);\n\tend = ImageAddress (buffer, context->ImageSize,\n\t\t\t    section->VirtualAddress + section->Misc.VirtualSize - 1);\n\tif (!(section->Characteristics & EFI_IMAGE_SCN_MEM_DISCARDABLE)) {\n\t\tif (!base) {\n\t\t\tperror(L\"Section %d has invalid base address\\n\", section_num);\n\t\t\treturn EFI_UNSUPPORTED;\n\t\t}\n\t\tif (!end) {\n\t\t\tperror(L\"Section %d has zero size\\n\", section_num);\n\t\t\treturn EFI_UNSUPPORTED;\n\t\t}\n\t}\n\tif (!(section->Characteristics & EFI_IMAGE_SCN_CNT_UNINITIALIZED_DATA) &&\n\t    (section->VirtualAddress < context->SizeOfHeaders ||\n\t     section->PointerToRawData < context->SizeOfHeaders)) {\n\t\tperror(L\"Section %d is inside image headers\\n\", section_num);\n\t\treturn EFI_UNSUPPORTED;\n\t}\n\tif (end < base) {\n\t\tperror(L\"Section %d has negative size\\n\", section_num);\n\t\treturn EFI_UNSUPPORTED;\n\t}\n\t*basep = base;\n\t*sizep = end - base;\n\t*sectionp = section;\n\treturn EFI_SUCCESS;\n}", "target": 0}
{"code": "uint32_t PDFiumEngine::QuerySupportedPrintOutputFormats() {\n  if (!HasPermission(PDFEngine::PERMISSION_PRINT_LOW_QUALITY))\n    return 0;\n  return PP_PRINTOUTPUTFORMAT_PDF;\n}", "target": 0}
{"code": "static int handle_ept_violation(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tgpa_t gpa;\n\tu32 error_code;\n\tint gla_validity;\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tgla_validity = (exit_qualification >> 7) & 0x3;\n\tif (gla_validity != 0x3 && gla_validity != 0x1 && gla_validity != 0) {\n\t\tprintk(KERN_ERR \"EPT: Handling EPT violation failed!\\n\");\n\t\tprintk(KERN_ERR \"EPT: GPA: 0x%lx, GVA: 0x%lx\\n\",\n\t\t\t(long unsigned int)vmcs_read64(GUEST_PHYSICAL_ADDRESS),\n\t\t\tvmcs_readl(GUEST_LINEAR_ADDRESS));\n\t\tprintk(KERN_ERR \"EPT: Exit qualification is 0x%lx\\n\",\n\t\t\t(long unsigned int)exit_qualification);\n\t\tvcpu->run->exit_reason = KVM_EXIT_UNKNOWN;\n\t\tvcpu->run->hw.hardware_exit_reason = EXIT_REASON_EPT_VIOLATION;\n\t\treturn 0;\n\t}\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tcpu_has_virtual_nmis() &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\ttrace_kvm_page_fault(gpa, exit_qualification);\n\terror_code = exit_qualification & PFERR_WRITE_MASK;\n\terror_code |= (exit_qualification << 2) & PFERR_FETCH_MASK;\n\terror_code |= (exit_qualification >> 3) & PFERR_PRESENT_MASK;\n\tvcpu->arch.exit_qualification = exit_qualification;\n\treturn kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);\n}", "target": 0}
{"code": "void CLASS process_Sony_0x940c (uchar * buf)\n{\n  ushort lid2;\n  if (imgdata.lens.makernotes.LensMount != Canon_EF)\n    {\n      switch (SonySubstitution[buf[0x0008]]) {\n      case 1:\n      case 5:\n        imgdata.lens.makernotes.LensMount = Minolta_A;\n        break;\n      case 4:\n        imgdata.lens.makernotes.LensMount = Sony_E;\n        break;\n      }\n    }\n  lid2 = (((ushort)SonySubstitution[buf[0x000a]])<<8) |\n    ((ushort)SonySubstitution[buf[0x0009]]);\n  if ((lid2 > 0) && (lid2 < 32784))\n    parseSonyLensType2 (SonySubstitution[buf[0x000a]],\t\n                        SonySubstitution[buf[0x0009]]);\n  return;\n}", "target": 0}
{"code": "void HttpStreamParser::GetSSLInfo(SSLInfo* ssl_info) {\n  if (request_->url.SchemeIs(\"https\") && connection_->socket()) {\n    SSLClientSocket* ssl_socket =\n        static_cast<SSLClientSocket*>(connection_->socket());\n    ssl_socket->GetSSLInfo(ssl_info);\n  }\n}", "target": 0}
{"code": "long keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_set_timeout(key, timeout);\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "STACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)\n{\n    STACK_OF(PKCS7) *p7s;\n    PKCS7_CTX *p7ctx;\n    PKCS7 *p7;\n    int i;\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p12->authsafes->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    p7ctx = &p12->authsafes->ctx;\n    p7s = ASN1_item_unpack_ex(p12->authsafes->d.data,\n                              ASN1_ITEM_rptr(PKCS12_AUTHSAFES),\n                              ossl_pkcs7_ctx_get0_libctx(p7ctx),\n                              ossl_pkcs7_ctx_get0_propq(p7ctx));\n    if (p7s != NULL) {\n        for (i = 0; i < sk_PKCS7_num(p7s); i++) {\n            p7 = sk_PKCS7_value(p7s, i);\n            if (!ossl_pkcs7_ctx_propagate(p12->authsafes, p7))\n                goto err;\n        }\n    }\n    return p7s;\nerr:\n    sk_PKCS7_free(p7s);\n    return NULL;\n}", "target": 0}
{"code": "static void ahci_unmap_clb_address(AHCIDevice *ad)\n{\n    if (ad->lst == NULL) {\n        DPRINTF(ad->port_no, \"Attempt to unmap NULL CLB address\\n\");\n        return;\n    }\n    ad->port_regs.cmd &= ~PORT_CMD_LIST_ON;\n    dma_memory_unmap(ad->hba->as, ad->lst, 1024,\n                     DMA_DIRECTION_FROM_DEVICE, 1024);\n    ad->lst = NULL;\n}", "target": 0}
{"code": "ff_layout_prepare_layoutstats(struct nfs42_layoutstat_args *args)\n{\n\tstruct nfs4_flexfile_layout *ff_layout;\n\tconst int dev_count = PNFS_LAYOUTSTATS_MAXDEV;\n\targs->devinfo = kmalloc_array(dev_count, sizeof(*args->devinfo), GFP_NOIO);\n\tif (!args->devinfo)\n\t\treturn -ENOMEM;\n\tspin_lock(&args->inode->i_lock);\n\tff_layout = FF_LAYOUT_FROM_HDR(NFS_I(args->inode)->layout);\n\targs->num_dev = ff_layout_mirror_prepare_stats(&ff_layout->generic_hdr,\n\t\t\t&args->devinfo[0], dev_count);\n\tspin_unlock(&args->inode->i_lock);\n\tif (!args->num_dev) {\n\t\tkfree(args->devinfo);\n\t\targs->devinfo = NULL;\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "xsltNumber(xsltTransformContextPtr ctxt, xmlNodePtr node,\n\t   xmlNodePtr inst, xsltStylePreCompPtr castedComp)\n{\n#ifdef XSLT_REFACTORED\n    xsltStyleItemNumberPtr comp = (xsltStyleItemNumberPtr) castedComp;\n#else\n    xsltStylePreCompPtr comp = castedComp;\n#endif\n    if (comp == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t     \"xsl:number : compilation failed\\n\");\n\treturn;\n    }\n    if ((ctxt == NULL) || (node == NULL) || (inst == NULL) || (comp == NULL))\n\treturn;\n    comp->numdata.doc = inst->doc;\n    comp->numdata.node = inst;\n    xsltNumberFormat(ctxt, &comp->numdata, node);\n}", "target": 0}
{"code": "divide_look_behind_alternatives(Node* node)\n{\n  Node *head, *np, *insert_node;\n  AnchorNode* an = NANCHOR(node);\n  int anc_type = an->type;\n  head = an->target;\n  np = NCAR(head);\n  swap_node(node, head);\n  NCAR(node) = head;\n  NANCHOR(head)->target = np;\n  np = node;\n  while ((np = NCDR(np)) != NULL_NODE) {\n    insert_node = onig_node_new_anchor(anc_type);\n    CHECK_NULL_RETURN_MEMERR(insert_node);\n    NANCHOR(insert_node)->target = NCAR(np);\n    NCAR(np) = insert_node;\n  }\n  if (anc_type == ANCHOR_LOOK_BEHIND_NOT) {\n    np = node;\n    do {\n      SET_NTYPE(np, NT_LIST);  \n    } while ((np = NCDR(np)) != NULL_NODE);\n  }\n  return 0;\n}", "target": 0}
{"code": "Item_cond::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                          uint *and_level, table_map usable_tables,\n                          SARGABLE_PARAM **sargables)\n{\n  List_iterator_fast<Item> li(*argument_list());\n  KEY_FIELD *org_key_fields= *key_fields;\n  (*and_level)++;\n  (li++)->add_key_fields(join, key_fields, and_level, usable_tables,\n                         sargables);\n  Item *item;\n  while ((item=li++))\n  {\n    KEY_FIELD *start_key_fields= *key_fields;\n    (*and_level)++;\n    item->add_key_fields(join, key_fields, and_level, usable_tables,\n                         sargables);\n    *key_fields= merge_key_fields(org_key_fields,start_key_fields,\n                                  *key_fields, ++(*and_level));\n  }\n}", "target": 0}
{"code": "static int mov_write_uuidusmt_tag(AVIOContext *pb, AVFormatContext *s)\n{\n    AVDictionaryEntry *title = av_dict_get(s->metadata, \"title\", NULL, 0);\n    int64_t pos, pos2;\n    if (title) {\n        pos = avio_tell(pb);\n        avio_wb32(pb, 0); \n        ffio_wfourcc(pb, \"uuid\");\n        ffio_wfourcc(pb, \"USMT\");\n        avio_wb32(pb, 0x21d24fce); \n        avio_wb32(pb, 0xbb88695c);\n        avio_wb32(pb, 0xfac9c740);\n        pos2 = avio_tell(pb);\n        avio_wb32(pb, 0); \n        ffio_wfourcc(pb, \"MTDT\");\n        avio_wb16(pb, 4);\n        avio_wb16(pb, 0x0C);                 \n        avio_wb32(pb, 0x0B);                 \n        avio_wb16(pb, language_code(\"und\")); \n        avio_wb16(pb, 0x0);                  \n        avio_wb16(pb, 0x021C);               \n        if (!(s->flags & AVFMT_FLAG_BITEXACT))\n            mov_write_psp_udta_tag(pb, LIBAVCODEC_IDENT,      \"eng\", 0x04);\n        mov_write_psp_udta_tag(pb, title->value,          \"eng\", 0x01);\n        mov_write_psp_udta_tag(pb, \"2006/04/01 11:11:11\", \"und\", 0x03);\n        update_size(pb, pos2);\n        return update_size(pb, pos);\n    }\n    return 0;\n}", "target": 0}
{"code": "static void ldapsrv_terminate_connection(struct ldapsrv_connection *conn,\n\t\t\t\t\t const char *reason)\n{\n\tstruct tevent_req *subreq;\n\tif (conn->limits.reason) {\n\t\treturn;\n\t}\n\tDLIST_REMOVE(conn->service->connections, conn);\n\tconn->limits.endtime = timeval_current_ofs(0, 500);\n\ttevent_queue_stop(conn->sockets.send_queue);\n\tTALLOC_FREE(conn->sockets.read_req);\n\tTALLOC_FREE(conn->deferred_expire_disconnect);\n\tif (conn->active_call) {\n\t\ttevent_req_cancel(conn->active_call);\n\t\tconn->active_call = NULL;\n\t}\n\tconn->limits.reason = talloc_strdup(conn, reason);\n\tif (conn->limits.reason == NULL) {\n\t\tTALLOC_FREE(conn->sockets.tls);\n\t\tTALLOC_FREE(conn->sockets.sasl);\n\t\tTALLOC_FREE(conn->sockets.raw);\n\t\tstream_terminate_connection(conn->connection, reason);\n\t\treturn;\n\t}\n\tsubreq = tstream_disconnect_send(conn,\n\t\t\t\t\t conn->connection->event.ctx,\n\t\t\t\t\t conn->sockets.active);\n\tif (subreq == NULL) {\n\t\tTALLOC_FREE(conn->sockets.tls);\n\t\tTALLOC_FREE(conn->sockets.sasl);\n\t\tTALLOC_FREE(conn->sockets.raw);\n\t\tstream_terminate_connection(conn->connection, reason);\n\t\treturn;\n\t}\n\ttevent_req_set_endtime(subreq,\n\t\t\t       conn->connection->event.ctx,\n\t\t\t       conn->limits.endtime);\n\ttevent_req_set_callback(subreq, ldapsrv_terminate_connection_done, conn);\n}", "target": 0}
{"code": "clientPackRangeHdr(const HttpReply * rep, const HttpHdrRangeSpec * spec, String boundary, MemBuf * mb)\n{\n    HttpHeader hdr(hoReply);\n    assert(rep);\n    assert(spec);\n    debugs(33, 5, \"appending boundary: \" << boundary);\n    mb->appendf(\"\\r\\n--\" SQUIDSTRINGPH \"\\r\\n\", SQUIDSTRINGPRINT(boundary));\n    if (rep->header.has(Http::HdrType::CONTENT_TYPE))\n        hdr.putStr(Http::HdrType::CONTENT_TYPE, rep->header.getStr(Http::HdrType::CONTENT_TYPE));\n    httpHeaderAddContRange(&hdr, *spec, rep->content_length);\n    hdr.packInto(mb);\n    hdr.clean();\n    mb->append(\"\\r\\n\", 2);\n}", "target": 0}
{"code": "void AAHD::refine_hv_dirs()\n{\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_hv_dirs(i, i & 1);\n  }\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_hv_dirs(i, (i & 1) ^ 1);\n  }\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_ihv_dirs(i);\n  }\n}", "target": 0}
{"code": "int fuse_fs_read(struct fuse_fs *fs, const char *path, char *buf, size_t size,\n                 off_t off, struct fuse_file_info *fi)\n{\n    fuse_get_context()->private_data = fs->user_data;\n    if (fs->op.read)\n        return fs->op.read(path, buf, size, off, fi);\n    else\n        return -ENOSYS;\n}", "target": 0}
{"code": "static int jpc_sot_getparms(jpc_ms_t *ms, jpc_cstate_t *cstate, jas_stream_t *in)\n{\n\tjpc_sot_t *sot = &ms->parms.sot;\n\tcstate = 0;\n\tif (jpc_getuint16(in, &sot->tileno) ||\n\t  jpc_getuint32(in, &sot->len) ||\n\t  jpc_getuint8(in, &sot->partno) ||\n\t  jpc_getuint8(in, &sot->numparts)) {\n\t\treturn -1;\n\t}\n\tif (sot->tileno > 65534 || sot->len < 12 || sot->partno > 254 ||\n\t  sot->numparts > 255) {\n\t\treturn -1;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "vte_sequence_handler_md (VteTerminal *terminal, GValueArray *params)\n{\n\tterminal->pvt->screen->defaults.attr.bold = 1;\n\tterminal->pvt->screen->defaults.attr.half = 0;\n}", "target": 0}
{"code": "linux_lvm2_lv_create_completed_cb (DBusGMethodInvocation *context,\n                                   Device *device,\n                                   gboolean job_was_cancelled,\n                                   int status,\n                                   const char *stderr,\n                                   const char *stdout,\n                                   gpointer user_data)\n{\n  CreateLvm2LVData *data = user_data;\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      Device *d;\n      d = lvm2_lv_create_has_lv (data);\n      if (d != NULL)\n        {\n          lvm2_lv_create_found_device (device, data);\n        }\n      else\n        {\n          data->device_added_signal_handler_id = g_signal_connect_after (data->daemon,\n                                                                         \"device-added\",\n                                                                         G_CALLBACK (lvm2_lv_create_device_added_cb),\n                                                                         data);\n          data->device_changed_signal_handler_id = g_signal_connect_after (data->daemon,\n                                                                           \"device-changed\",\n                                                                         G_CALLBACK (lvm2_lv_create_device_changed_cb),\n                                                                           data);\n          data->device_added_timeout_id = g_timeout_add (10 * 1000,\n                                                         lvm2_lv_create_device_not_seen_cb,\n                                                         data);\n          lvm2_lv_create_data_ref (data);\n        }\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error creating LVM2 Logical Volume: lvcreate exited with exit code %d: %s\",\n                       WEXITSTATUS (status),\n                       stderr);\n        }\n    }\n}", "target": 0}
{"code": "static int mxf_parse_klv(MXFContext *mxf, KLVPacket klv, MXFMetadataReadFunc *read,\n                                     int ctx_size, enum MXFMetadataSetType type)\n{\n    AVFormatContext *s = mxf->fc;\n    int res;\n    if (klv.key[5] == 0x53) {\n        res = mxf_read_local_tags(mxf, &klv, read, ctx_size, type);\n    } else {\n        uint64_t next = avio_tell(s->pb) + klv.length;\n        res = read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n        if (avio_tell(s->pb) > next) {\n            av_log(s, AV_LOG_ERROR, \"read past end of KLV @ %#\"PRIx64\"\\n\",\n                   klv.offset);\n            return AVERROR_INVALIDDATA;\n        }\n        avio_seek(s->pb, next, SEEK_SET);\n    }\n    if (res < 0) {\n        av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n        return res;\n    }\n    return 0;\n}", "target": 0}
{"code": "TimeRanges* HTMLMediaElement::played() {\n  if (playing_) {\n    double time = currentTime();\n    if (time > last_seek_time_)\n      AddPlayedRange(last_seek_time_, time);\n  }\n  if (!played_time_ranges_)\n    played_time_ranges_ = TimeRanges::Create();\n  return played_time_ranges_->Copy();\n}", "target": 0}
{"code": "int acpi_unmap_lsapic(int cpu)\n{\n\tint i;\n\tfor_each_possible_cpu(i) {\n\t\tif (x86_acpiid_to_apicid[i] == x86_cpu_to_apicid[cpu]) {\n\t\t\tx86_acpiid_to_apicid[i] = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tx86_cpu_to_apicid[cpu] = -1;\n\tcpu_clear(cpu, cpu_present_map);\n\tnum_processors--;\n\treturn (0);\n}", "target": 0}
{"code": "static int sched_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\tWARN_ON(!inode);\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_show_task(p, m);\n\tput_task_struct(p);\n\treturn 0;\n}", "target": 0}
{"code": "device_resolve_type_and_icon (Device1 *device, BluetoothType *type, const char **icon)\n{\n\tg_return_if_fail (type);\n\tg_return_if_fail (icon);\n\t*type = bluetooth_appearance_to_type (device1_get_appearance (device));\n\tif (*type == 0 || *type == BLUETOOTH_TYPE_ANY)\n\t\t*type = bluetooth_class_to_type (device1_get_class (device));\n\t*icon = icon_override (device1_get_address (device), *type);\n\tif (!*icon)\n\t\t*icon = device1_get_icon (device);\n\tif (!*icon)\n\t\t*icon = \"bluetooth\";\n}", "target": 0}
{"code": "Eina_Bool ewk_view_editable_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_editable_get(smartData->main_frame);\n}", "target": 0}
{"code": "STATIC void\nS_populate_ANYOF_from_invlist(pTHX_ regnode *node, SV** invlist_ptr)\n{\n    dVAR;\n    PERL_ARGS_ASSERT_POPULATE_ANYOF_FROM_INVLIST;\n    assert(PL_regkind[OP(node)] == ANYOF);\n    if (OP(node) == ANYOFH) {\n        return;\n    }\n    ANYOF_BITMAP_ZERO(node);\n    if (*invlist_ptr) {\n\tbool change_invlist = FALSE;\n\tUV start, end;\n\tinvlist_iterinit(*invlist_ptr);\n\twhile (invlist_iternext(*invlist_ptr, &start, &end)) {\n\t    UV high;\n\t    int i;\n            if (end == UV_MAX && start <= NUM_ANYOF_CODE_POINTS) {\n                ANYOF_FLAGS(node) |= ANYOF_MATCHES_ALL_ABOVE_BITMAP;\n            }\n\t    if (start >= NUM_ANYOF_CODE_POINTS) {\n\t\tbreak;\n\t    }\n\t    change_invlist = TRUE;\n\t    high = (end < NUM_ANYOF_CODE_POINTS - 1)\n                   ? end\n                   : NUM_ANYOF_CODE_POINTS - 1;\n\t    for (i = start; i <= (int) high; i++) {\n\t\tif (! ANYOF_BITMAP_TEST(node, i)) {\n\t\t    ANYOF_BITMAP_SET(node, i);\n\t\t}\n\t    }\n\t}\n\tinvlist_iterfinish(*invlist_ptr);\n\tif (change_invlist) {\n\t    _invlist_subtract(*invlist_ptr, PL_InBitmap, invlist_ptr);\n\t}\n        if (ANYOF_FLAGS(node) & ANYOF_MATCHES_ALL_ABOVE_BITMAP) {\n\t    _invlist_intersection(*invlist_ptr, PL_InBitmap, invlist_ptr);\n\t}\n\tif (_invlist_len(*invlist_ptr) == 0) {\n\t    SvREFCNT_dec_NN(*invlist_ptr);\n\t    *invlist_ptr = NULL;\n\t}\n    }", "target": 0}
{"code": "static void   _clean_var(VAR *var)\n{\n    if (var->name) {\n      free(var->name);\n    }\n    if (var->defval && (&quote != var->defval)) {\n      free(var->defval);\n    }\n    if (var->override && (&quote != var->override)) {\n      free(var->override);\n    }\n    var->name = NULL;\n    var->value = NULL;    \n    var->defval = NULL;\n    var->override = NULL;\n    return;\n}", "target": 0}
{"code": "static netdev_tx_t mctp_serial_tx(struct sk_buff *skb, struct net_device *ndev)\n{\n\tstruct mctp_serial *dev = netdev_priv(ndev);\n\tunsigned long flags;\n\tWARN_ON(dev->txstate != STATE_IDLE);\n\tif (skb->len > MCTP_SERIAL_MTU) {\n\t\tdev->netdev->stats.tx_dropped++;\n\t\tgoto out;\n\t}\n\tspin_lock_irqsave(&dev->lock, flags);\n\tnetif_stop_queue(dev->netdev);\n\tskb_copy_bits(skb, 0, dev->txbuf, skb->len);\n\tdev->txpos = 0;\n\tdev->txlen = skb->len;\n\tdev->txstate = STATE_START;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tset_bit(TTY_DO_WRITE_WAKEUP, &dev->tty->flags);\n\tschedule_work(&dev->tx_work);\nout:\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}", "target": 0}
{"code": "static inline int fd_copyin(void __user *param, void *address,\n\t\t\t    unsigned long size)\n{\n\treturn copy_from_user(address, param, size) ? -EFAULT : 0;\n}", "target": 0}
{"code": "rb_reg_backref_number(VALUE match, VALUE backref)\n{\n    return match_backref_number(match, backref);\n}", "target": 0}
{"code": "void RenderView::OnMediaPlayerActionAt(const gfx::Point& location,\n                                       const WebMediaPlayerAction& action) {\n  if (webview())\n    webview()->performMediaPlayerAction(action, location);\n}", "target": 0}
{"code": "static void __mark_reg_not_init(const struct bpf_verifier_env *env,\n\t\t\t\tstruct bpf_reg_state *reg)\n{\n\t__mark_reg_unknown(env, reg);\n\treg->type = NOT_INIT;\n}", "target": 0}
{"code": "void ring_buffer_reset(struct ring_buffer *buffer)\n{\n\tint cpu;\n\tfor_each_buffer_cpu(buffer, cpu)\n\t\tring_buffer_reset_cpu(buffer, cpu);\n}", "target": 0}
{"code": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n    if (SMALL_OBJ(lb))\n        return(GC_generic_malloc((word)lb, k));\n    lg = ROUNDED_UP_GRANULES(lb);\n    lb_rounded = GRANULES_TO_BYTES(lg);\n    if (lb_rounded < lb)\n        return((*GC_get_oom_fn())(lb));\n    n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n    init = GC_obj_kinds[k].ok_init;\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}", "target": 0}
{"code": "static void mov_update_dts_shift(MOVStreamContext *sc, int duration, void *logctx)\n{\n    if (duration < 0) {\n        if (duration == INT_MIN) {\n            av_log(logctx, AV_LOG_WARNING, \"mov_update_dts_shift(): dts_shift set to %d\\n\", INT_MAX);\n            duration++;\n        }\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n    }\n}", "target": 0}
{"code": "    ByteOrder TiffHeaderBase::byteOrder() const\n    {\n        return byteOrder_;\n    }", "target": 0}
{"code": "static int check_pkt_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t\t   const struct bpf_reg_state *reg,\n\t\t\t\t   int off, int size, bool strict)\n{\n\tstruct tnum reg_off;\n\tint ip_align;\n\tif (!strict || size == 1)\n\t\treturn 0;\n\tip_align = 2;\n\treg_off = tnum_add(reg->var_off, tnum_const(ip_align + reg->off + off));\n\tif (!tnum_is_aligned(reg_off, size)) {\n\t\tchar tn_buf[48];\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), reg->var_off);\n\t\tverbose(env,\n\t\t\t\"misaligned packet access off %d+%s+%d+%d size %d\\n\",\n\t\t\tip_align, tn_buf, reg->off, off, size);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "save_dead_message (mu_message_t msg)\n{\n  if (mailvar_is_true (mailvar_name_save))\n    {\n      mu_stream_t dead_letter, str;\n      int rc;\n      time_t t;\n      struct tm *tm;\n      const char *name = getenv (\"DEAD\");\n      char *sender;\n      rc = mu_file_stream_create (&dead_letter, name,\n\t\t\t\t  MU_STREAM_CREAT|MU_STREAM_WRITE);\n      if (rc)\n\t{\n\t  mu_error (_(\"Cannot open file %s: %s\"), name, strerror (rc));\n\t  return 1;\n\t}\n      if (mailvar_is_true (mailvar_name_appenddeadletter))\n\tmu_stream_seek (dead_letter, 0, MU_SEEK_END, NULL);\n      else\n\tmu_stream_truncate (dead_letter, 0);\n      time (&t);\n      tm = gmtime (&t);\n      sender = mu_get_user_email (NULL);\n      if (!sender)\n\tsender = mu_strdup (\"UNKNOWN\");\n      mu_stream_printf (dead_letter, \"From %s \", sender);\n      free (sender);\n      mu_c_streamftime (dead_letter, \"%c%n\", tm, NULL);\n      if (mu_message_get_streamref (msg, &str) == 0)\n\t{\n\t  mu_stream_copy (dead_letter, str, 0, NULL);\n\t  mu_stream_unref (str);\n\t}\n      mu_stream_write (dead_letter, \"\\n\", 1, NULL);\n      mu_stream_destroy (&dead_letter);\n    }\n  return 0;\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, EqWithTwoFieldPathsMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: {$eq: ['$x', '$y']}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 2 << \"y\" << 2)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 2 << \"y\" << 3)));\n    ASSERT_FALSE(matches(BSON(\"x\" << 2)));\n}", "target": 0}
{"code": "epass2003_create_file(struct sc_card *card, sc_file_t * file)\n{\n\tint r;\n\tsize_t len;\n\tu8 sbuf[SC_MAX_APDU_BUFFER_SIZE] = { 0 };\n\tstruct sc_apdu apdu;\n\tlen = SC_MAX_APDU_BUFFER_SIZE;\n\tepass2003_hook_file(file, 1);\n\tif (card->ops->construct_fci == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\tr = epass2003_construct_fci(card, file, sbuf, &len);\n\tLOG_TEST_RET(card->ctx, r, \"construct_fci() failed\");\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xE0, 0x00, 0x00);\n\tapdu.lc = len;\n\tapdu.datalen = len;\n\tapdu.data = sbuf;\n\tr = sc_transmit_apdu_t(card, &apdu);\n\tLOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_TEST_RET(card->ctx, r, \"APDU sw1/2 wrong\");\n\tepass2003_hook_file(file, 0);\n\treturn r;\n}", "target": 0}
{"code": "    **/\n    CImg<T>& operator&=(const char *const expression) {\n      return *this&=(+*this)._fill(expression,true,true,0,0,\"operator&=\",this);", "target": 0}
{"code": "static int64_t get_frag_time(AVFormatContext *s, AVStream *dst_st,\n                             MOVFragmentIndex *frag_index, int index)\n{\n    MOVFragmentStreamInfo * frag_stream_info;\n    MOVStreamContext *sc = dst_st->priv_data;\n    int64_t timestamp;\n    int i, j;\n    if (sc->has_sidx) {\n        frag_stream_info = get_frag_stream_info(frag_index, index, dst_st->id);\n        if (frag_stream_info->sidx_pts != AV_NOPTS_VALUE)\n            return frag_stream_info->sidx_pts;\n        if (frag_stream_info->first_tfra_pts != AV_NOPTS_VALUE)\n            return frag_stream_info->first_tfra_pts;\n        return frag_stream_info->sidx_pts;\n    }\n    for (i = 0; i < frag_index->item[index].nb_stream_info; i++) {\n        AVStream *frag_stream = NULL;\n        frag_stream_info = &frag_index->item[index].stream_info[i];\n        for (j = 0; j < s->nb_streams; j++)\n            if (s->streams[j]->id == frag_stream_info->id)\n                frag_stream = s->streams[j];\n        if (!frag_stream) {\n            av_log(s, AV_LOG_WARNING, \"No stream matching sidx ID found.\\n\");\n            continue;\n        }\n        timestamp = get_stream_info_time(frag_stream_info);\n        if (timestamp != AV_NOPTS_VALUE)\n            return av_rescale_q(timestamp, frag_stream->time_base, dst_st->time_base);\n    }\n    return AV_NOPTS_VALUE;\n}", "target": 0}
{"code": "check_SET_IP_DSCP(const struct ofpact_dscp *a OVS_UNUSED,\n                  struct ofpact_check_params *cp)\n{\n    return check_set_ip(cp);\n}", "target": 0}
{"code": "static Eina_Bool _ewk_view_smart_key_down(Ewk_View_Smart_Data* smartData, const Evas_Event_Key_Down* downEvent)\n{\n    Evas_Object* frame = ewk_view_frame_focused_get(smartData->self);\n    if (!frame)\n        frame = smartData->main_frame;\n    return ewk_frame_feed_key_down(frame, downEvent);\n}", "target": 0}
{"code": "static int mxf_read_source_clip(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFStructuralComponent *source_clip = arg;\n    switch(tag) {\n    case 0x0202:\n        source_clip->duration = avio_rb64(pb);\n        break;\n    case 0x1201:\n        source_clip->start_position = avio_rb64(pb);\n        break;\n    case 0x1101:\n        avio_skip(pb, 16);\n        avio_read(pb, source_clip->source_package_uid, 16);\n        break;\n    case 0x1102:\n        source_clip->source_track_id = avio_rb32(pb);\n        break;\n    }\n    return 0;\n}", "target": 0}
{"code": "do_sigaltstack (const stack_t __user *uss, stack_t __user *uoss, unsigned long sp)\n{\n\tstack_t oss;\n\tint error;\n\toss.ss_sp = (void __user *) current->sas_ss_sp;\n\toss.ss_size = current->sas_ss_size;\n\toss.ss_flags = sas_ss_flags(sp);\n\tif (uss) {\n\t\tvoid __user *ss_sp;\n\t\tsize_t ss_size;\n\t\tint ss_flags;\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_READ, uss, sizeof(*uss))\n\t\t    || __get_user(ss_sp, &uss->ss_sp)\n\t\t    || __get_user(ss_flags, &uss->ss_flags)\n\t\t    || __get_user(ss_size, &uss->ss_size))\n\t\t\tgoto out;\n\t\terror = -EPERM;\n\t\tif (on_sig_stack(sp))\n\t\t\tgoto out;\n\t\terror = -EINVAL;\n\t\tif (ss_flags != SS_DISABLE && ss_flags != SS_ONSTACK && ss_flags != 0)\n\t\t\tgoto out;\n\t\tif (ss_flags == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\terror = -ENOMEM;\n\t\t\tif (ss_size < MINSIGSTKSZ)\n\t\t\t\tgoto out;\n\t\t}\n\t\tcurrent->sas_ss_sp = (unsigned long) ss_sp;\n\t\tcurrent->sas_ss_size = ss_size;\n\t}\n\terror = 0;\n\tif (uoss) {\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_WRITE, uoss, sizeof(*uoss)))\n\t\t\tgoto out;\n\t\terror = __put_user(oss.ss_sp, &uoss->ss_sp) |\n\t\t\t__put_user(oss.ss_size, &uoss->ss_size) |\n\t\t\t__put_user(oss.ss_flags, &uoss->ss_flags);\n\t}\nout:\n\treturn error;\n}", "target": 0}
{"code": "static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize)\n{\n  size_t i, j, numdeflateblocks = (datasize + 65534) / 65535;\n  unsigned datapos = 0;\n  for(i = 0; i < numdeflateblocks; i++)\n  {\n    unsigned BFINAL, BTYPE, LEN, NLEN;\n    unsigned char firstbyte;\n    BFINAL = (i == numdeflateblocks - 1);\n    BTYPE = 0;\n    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1) << 1) + ((BTYPE & 2) << 1));\n    if (!ucvector_push_back(out, firstbyte)) return 83;\n    LEN = 65535;\n    if(datasize - datapos < 65535) LEN = (unsigned)datasize - datapos;\n    NLEN = 65535 - LEN;\n    if (!ucvector_push_back(out, (unsigned char)(LEN % 256))) return 83;\n    if (!ucvector_push_back(out, (unsigned char)(LEN / 256))) return 83;\n    if (!ucvector_push_back(out, (unsigned char)(NLEN % 256))) return 83;\n    if (!ucvector_push_back(out, (unsigned char)(NLEN / 256))) return 83;\n    for(j = 0; j < 65535 && datapos < datasize; j++)\n    {\n      if (!ucvector_push_back(out, data[datapos++])) return 83;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, IntersectElemMatch) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN | QueryPlannerParams::INDEX_INTERSECTION;\n    addIndex(BSON(\"a.b\" << 1));\n    addIndex(BSON(\"a.c\" << 1));\n    runQuery(fromjson(\"{a : {$elemMatch: {b:1, c:1}}}\"));\n    assertSolutionExists(\n        \"{fetch: {filter: {a:{$elemMatch:{b:1, c:1}}},\"\n        \"node: {andSorted: {nodes: [\"\n        \"{ixscan: {filter: null, pattern: {'a.b':1}}},\"\n        \"{ixscan: {filter: null, pattern: {'a.c':1}}}]}}}}\");\n}", "target": 0}
{"code": "static int avrcp_target_probe(struct btd_service *service)\n{\n\tstruct btd_device *dev = btd_service_get_device(service);\n\tDBG(\"path %s\", device_get_path(dev));\n\treturn control_init_target(service);\n}", "target": 0}
{"code": "static int decode_opaque_fixed(struct xdr_stream *xdr, void *buf, size_t len)\n{\n\t__be32 *p;\n\tp = xdr_inline_decode(xdr, len);\n\tif (likely(p)) {\n\t\tmemcpy(buf, p, len);\n\t\treturn 0;\n\t}\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "static inline void __set_open_fd(unsigned int fd, struct fdtable *fdt)\n{\n\t__set_bit(fd, fdt->open_fds);\n\tfd /= BITS_PER_LONG;\n\tif (!~fdt->open_fds[fd])\n\t\t__set_bit(fd, fdt->full_fds_bits);\n}", "target": 0}
{"code": "mono_class_is_constraint_compatible (MonoClass *candidate, MonoClass *target)\n{\n\tif (candidate == target)\n\t\treturn TRUE;\n\tif (target == mono_defaults.object_class)\n\t\t\treturn TRUE;\n\tmono_class_setup_supertypes (candidate);\n\tmono_class_setup_supertypes (target);\n\tif (mono_class_has_parent (candidate, target))\n\t\treturn TRUE;\n\tif (!MONO_CLASS_IS_INTERFACE (target))\n\t\t\treturn FALSE;\n\tif (candidate->image->dynamic && !candidate->wastypebuilder) {\n\t\tMonoReflectionTypeBuilder *tb = candidate->reflection_info;\n\t\tint j;\n\t\tif (tb->interfaces) {\n\t\t\tfor (j = mono_array_length (tb->interfaces) - 1; j >= 0; --j) {\n\t\t\t\tMonoReflectionType *iface = mono_array_get (tb->interfaces, MonoReflectionType*, j);\n\t\t\t\tMonoClass *ifaceClass = mono_class_from_mono_type (iface->type);\n\t\t\t\tif (mono_class_is_constraint_compatible (ifaceClass, target)) {\n\t\t\t\t\treturn TRUE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn FALSE;\n\t}\n\treturn mono_class_interface_implements_interface (candidate, target);\n}", "target": 0}
{"code": "static MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *magick_unused(encoding),const PointInfo *offset,\n  TypeMetric *metrics,ExceptionInfo *exception)\n{\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"'%s' (Freetype)\",\n    draw_info->font != (char *) NULL ? draw_info->font : \"none\");\n  return(RenderPostscript(image,draw_info,offset,metrics,exception));\n}", "target": 0}
{"code": "    TestSameDocumentWebFrameClient()\n        : m_frameLoadTypeSameSeen(false)\n    {\n    }", "target": 0}
{"code": "log_create_as_exim(uschar *name)\n{\npid_t pid = fork();\nint status = 1;\nint fd = -1;\nif (pid == 0)\n  {\n  if (setgid(exim_gid) < 0)\n    die(US\"exim: setgid for log-file creation failed, aborting\",\n      US\"Unexpected log failure, please try later\");\n  if (setuid(exim_uid) < 0)\n    die(US\"exim: setuid for log-file creation failed, aborting\",\n      US\"Unexpected log failure, please try later\");\n  _exit((log_create(name) < 0)? 1 : 0);\n  }\nwhile (pid > 0 && waitpid(pid, &status, 0) != pid);\nif (status == 0) fd = Uopen(name,\n#ifdef O_CLOEXEC\n\t\t\tO_CLOEXEC |\n#endif\n\t\t       \tO_APPEND|O_WRONLY, LOG_MODE);\nreturn fd;\n}", "target": 0}
{"code": "void HeaderString::setInteger(uint64_t value) {\n  char inner_buffer[MaxIntegerLength];\n  const uint32_t int_length = StringUtil::itoa(inner_buffer, MaxIntegerLength, value);\n  if (type() == Type::Reference) {\n    buffer_ = InlineHeaderVector();\n  }\n  ASSERT((getInVec(buffer_).capacity()) > MaxIntegerLength);\n  getInVec(buffer_).assign(inner_buffer, inner_buffer + int_length);\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DeleteTexturesHelper(\n    GLsizei n, const GLuint* client_ids) {\n  for (GLsizei ii = 0; ii < n; ++ii) {\n    TextureManager::TextureInfo* info = GetTextureInfo(client_ids[ii]);\n    if (info) {\n      GLuint service_id = info->service_id();\n      glDeleteTextures(1, &service_id);\n      RemoveTextureInfo(client_ids[ii]);\n    }\n  }\n}", "target": 0}
{"code": "void test_readlink(const char *path)\n{\n\tchar *dest = alloca(2 * strlen(path));\n\tif (readlink(path, dest, 2 * strlen(path)) >= 0) {\n\t\tfprintf(stderr, \"leak at readlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at readlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "void _af_printid (uint32_t id)\n{\n\tprintf(\"%c%c%c%c\",\n\t\t(id >> 24) & 0xff,\n\t\t(id >> 16) & 0xff,\n\t\t(id >> 8) & 0xff,\n\t\tid & 0xff);\n}", "target": 0}
{"code": "gs_pattern2_get_pattern(const gs_pattern_instance_t *pinst)\n{\n    return (const gs_pattern_template_t *)\n        &((const gs_pattern2_instance_t *)pinst)->templat;\n}", "target": 0}
{"code": "const SerializedAnchor ScrollAnchor::GetSerializedAnchor() {\n  if (!saved_selector_.IsEmpty()) {\n    DCHECK(anchor_object_);\n    return SerializedAnchor(\n        saved_selector_,\n        ComputeRelativeOffset(anchor_object_, scroller_, corner_));\n  }\n  if (!anchor_object_) {\n    FindAnchor();\n    if (!anchor_object_)\n      return SerializedAnchor();\n  }\n  DCHECK(anchor_object_->GetNode());\n  SerializedAnchor new_anchor(\n      ComputeUniqueSelector(anchor_object_->GetNode()),\n      ComputeRelativeOffset(anchor_object_, scroller_, corner_));\n  if (new_anchor.IsValid()) {\n    saved_selector_ = new_anchor.selector;\n  }\n  return new_anchor;\n}", "target": 0}
{"code": "source_wait_cb(gint fd, GIOCondition condition, gpointer user_data)\n{\n    VuGpu *g = user_data;\n    if (!vg_recv_msg(g, VHOST_USER_GPU_DMABUF_UPDATE, 0, NULL)) {\n        return G_SOURCE_CONTINUE;\n    }\n    g->wait_in = 0;\n    vg_handle_ctrl(&g->dev.parent, 0);\n    return G_SOURCE_REMOVE;\n}", "target": 0}
{"code": "static int rds_next_incoming(struct rds_sock *rs, struct rds_incoming **inc)\n{\n\tunsigned long flags;\n\tif (!*inc) {\n\t\tread_lock_irqsave(&rs->rs_recv_lock, flags);\n\t\tif (!list_empty(&rs->rs_recv_queue)) {\n\t\t\t*inc = list_entry(rs->rs_recv_queue.next,\n\t\t\t\t\t  struct rds_incoming,\n\t\t\t\t\t  i_item);\n\t\t\trds_inc_addref(*inc);\n\t\t}\n\t\tread_unlock_irqrestore(&rs->rs_recv_lock, flags);\n\t}\n\treturn *inc != NULL;\n}", "target": 0}
{"code": "TEST(MatchHeadersTest, HeaderExactMatchInverse) {\n  TestRequestHeaderMapImpl matching_headers{{\"match-header\", \"other-value\"},\n                                            {\"other-header\", \"match-value\"}};\n  TestRequestHeaderMapImpl unmatching_headers{{\"match-header\", \"match-value\"}};\n  const std::string yaml = R\"EOF(\nname: match-header\nexact_match: match-value\ninvert_match: true\n  )EOF\";\n  std::vector<HeaderUtility::HeaderDataPtr> header_data;\n  header_data.push_back(\n      std::make_unique<HeaderUtility::HeaderData>(parseHeaderMatcherFromYaml(yaml)));\n  EXPECT_TRUE(HeaderUtility::matchHeaders(matching_headers, header_data));\n  EXPECT_FALSE(HeaderUtility::matchHeaders(unmatching_headers, header_data));\n}", "target": 0}
{"code": "DLLIMPORT cfg_t *cfg_opt_gettsec(cfg_opt_t *opt, const char *title)\n{\n\tlong int i;\n\tif (!opt || !title) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\tif (!is_set(CFGF_TITLE, opt->flags)) {\n\t\terrno = EINVAL;\n\t\treturn NULL;\n\t}\n\ti = cfg_opt_gettsecidx(opt, title);\n\tif (i >= 0)\n\t\treturn cfg_opt_getnsec(opt, i);\n\terrno = ENOENT;\n\treturn NULL;\n}", "target": 0}
{"code": "bool InstanceKlass::verify_code(bool throw_verifyerror, TRAPS) {\n  Verifier::Mode mode =\n    throw_verifyerror ? Verifier::ThrowException : Verifier::NoException;\n  return Verifier::verify(this, mode, should_verify_class(), THREAD);\n}", "target": 0}
{"code": "htp_status_t htp_tx_req_set_headers_clear(htp_tx_t *tx) {\n    if ((tx == NULL) || (tx->request_headers == NULL)) return HTP_ERROR;\n    htp_header_t *h = NULL;\n    for (size_t i = 0, n = htp_table_size(tx->request_headers); i < n; i++) {\n        h = htp_table_get_index(tx->request_headers, i, NULL);\n        bstr_free(h->name);\n        bstr_free(h->value);\n        free(h);\n    }\n    htp_table_destroy(tx->request_headers);\n    tx->request_headers = htp_table_create(32);\n    if (tx->request_headers == NULL) return HTP_ERROR;\n    return HTP_OK;\n}", "target": 0}
{"code": "make_err_msg(const char *name)\n{\n\tgss_buffer_desc buffer;\n\tif (name == NULL) {\n\t\tbuffer.length = 0;\n\t\tbuffer.value = NULL;\n\t} else {\n\t\tbuffer.length = strlen(name)+1;\n\t\tbuffer.value = make_spnego_token(name);\n\t}\n\treturn (buffer);\n}", "target": 0}
{"code": "static int xennet_count_skb_slots(struct sk_buff *skb)\n{\n\tint i, frags = skb_shinfo(skb)->nr_frags;\n\tint slots;\n\tslots = gnttab_count_grant(offset_in_page(skb->data),\n\t\t\t\t   skb_headlen(skb));\n\tfor (i = 0; i < frags; i++) {\n\t\tskb_frag_t *frag = skb_shinfo(skb)->frags + i;\n\t\tunsigned long size = skb_frag_size(frag);\n\t\tunsigned long offset = skb_frag_off(frag);\n\t\toffset &= ~PAGE_MASK;\n\t\tslots += gnttab_count_grant(offset, size);\n\t}\n\treturn slots;\n}", "target": 0}
{"code": "static inline int input_available_p(struct tty_struct *tty, int poll)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint amt = poll && !TIME_CHAR(tty) && MIN_CHAR(tty) ? MIN_CHAR(tty) : 1;\n\tif (ldata->icanon && !L_EXTPROC(tty))\n\t\treturn ldata->canon_head != ldata->read_tail;\n\telse\n\t\treturn read_cnt(ldata) >= amt;\n}", "target": 0}
{"code": "mm_answer_pty(int socket, Buffer *m)\n{\n\textern struct monitor *pmonitor;\n\tSession *s;\n\tint res, fd0;\n\tdebug3(\"%s entering\", __func__);\n\tbuffer_clear(m);\n\ts = session_new();\n\tif (s == NULL)\n\t\tgoto error;\n\ts->authctxt = authctxt;\n\ts->pw = authctxt->pw;\n\ts->pid = pmonitor->m_pid;\n\tres = pty_allocate(&s->ptyfd, &s->ttyfd, s->tty, sizeof(s->tty));\n\tif (res == 0)\n\t\tgoto error;\n\tfatal_add_cleanup(session_pty_cleanup2, (void *)s);\n\tpty_setowner(authctxt->pw, s->tty);\n\tbuffer_put_int(m, 1);\n\tbuffer_put_cstring(m, s->tty);\n\tmm_request_send(socket, MONITOR_ANS_PTY, m);\n\tmm_send_fd(socket, s->ptyfd);\n\tmm_send_fd(socket, s->ttyfd);\n\tif (dup2(s->ttyfd, 0) == -1)\n\t\tfatal(\"%s: dup2\", __func__);\n\tmm_record_login(s, authctxt->pw);\n\tclose(0);\n\tif ((fd0 = open(_PATH_DEVNULL, O_RDONLY)) < 0)\n\t\tfatal(\"%s: open(/dev/null): %s\", __func__, strerror(errno));\n\tif (fd0 != 0)\n\t\terror(\"%s: fd0 %d != 0\", __func__, fd0);\n\tclose(s->ttyfd);\n\ts->ttyfd = s->ptyfd;\n\ts->ptymaster = s->ptyfd;\n\tdebug3(\"%s: tty %s ptyfd %d\",  __func__, s->tty, s->ttyfd);\n\treturn (0);\n error:\n\tif (s != NULL)\n\t\tmm_session_close(s);\n\tbuffer_put_int(m, 0);\n\tmm_request_send(socket, MONITOR_ANS_PTY, m);\n\treturn (0);\n}", "target": 0}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if ((EncCP1252_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code = ENC_CP1252_TO_LOWER_CASE(code);\n    }\n    else if (code == 0x83 || code == 0xAA || code == 0xBA || code == 0xB5)\n      ;\n    else if ((EncCP1252_CtypeTable[code]&BIT_CTYPE_LOWER)\n\t     && (flags & ONIGENC_CASE_UPCASE)) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      if (code == 0x9A || code == 0x9C || code == 0x9E)\n\tcode -= 0x10;\n      else if (code == 0xFF)\n\tcode -= 0x60;\n      else\n\tcode -= 0x20;\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "HeaderLookupTable_t::HeaderLookupTable_t()\n{\n    initCache();\n}", "target": 0}
{"code": "real_disconnect (NMVpnServicePlugin *plugin, GError **error)\n{\n\tvpnc_cleanup (NM_VPNC_PLUGIN (plugin), TRUE);\n\treturn TRUE;\n}", "target": 0}
{"code": "util_curl_unsetopt(CurlObject *self, int option)\n{\n    int res;\n#define SETOPT2(o,x) \\\n    if ((res = curl_easy_setopt(self->handle, (o), (x))) != CURLE_OK) goto error\n#define SETOPT(x)   SETOPT2((CURLoption)option, (x))\n    switch (option)\n    {\n    case CURLOPT_SHARE:\n        SETOPT((CURLSH *) NULL);\n        Py_XDECREF(self->share);\n        self->share = NULL;\n        break;\n    case CURLOPT_HTTPPOST:\n        SETOPT((void *) 0);\n        curl_formfree(self->httppost);\n        util_curl_xdecref(self, PYCURL_MEMGROUP_HTTPPOST, self->handle);\n        self->httppost = NULL;\n        break;\n    case CURLOPT_INFILESIZE:\n        SETOPT((long) -1);\n        break;\n    case CURLOPT_WRITEHEADER:\n        SETOPT((void *) 0);\n        Py_CLEAR(self->writeheader_fp);\n        break;\n    case CURLOPT_CAINFO:\n    case CURLOPT_CAPATH:\n    case CURLOPT_COOKIE:\n    case CURLOPT_COOKIEJAR:\n    case CURLOPT_CUSTOMREQUEST:\n    case CURLOPT_EGDSOCKET:\n    case CURLOPT_FTPPORT:\n    case CURLOPT_PROXYUSERPWD:\n#ifdef HAVE_CURLOPT_PROXYUSERNAME\n    case CURLOPT_PROXYUSERNAME:\n    case CURLOPT_PROXYPASSWORD:\n#endif\n    case CURLOPT_RANDOM_FILE:\n    case CURLOPT_SSL_CIPHER_LIST:\n    case CURLOPT_USERPWD:\n#ifdef HAVE_CURLOPT_USERNAME\n    case CURLOPT_USERNAME:\n    case CURLOPT_PASSWORD:\n#endif\n    case CURLOPT_RANGE:\n#if LIBCURL_VERSION_NUM >= 0x072b00 \n    case CURLOPT_SERVICE_NAME:\n    case CURLOPT_PROXY_SERVICE_NAME:\n#endif\n        SETOPT((char *) 0);\n        break;\n#ifdef HAVE_CURLOPT_CERTINFO\n    case CURLOPT_CERTINFO:\n        SETOPT((long) 0);\n        break;\n#endif\n    case CURLOPT_COOKIEFILE:\n    default:\n        PyErr_SetString(PyExc_TypeError, \"unsetopt() is not supported for this option\");\n        return NULL;\n    }\n    Py_RETURN_NONE;\nerror:\n    CURLERROR_RETVAL();\n#undef SETOPT\n#undef SETOPT2\n}", "target": 0}
{"code": "static int sco_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (!sk)\n\t\treturn 0;\n\tsco_sock_close(sk);\n\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t    !(current->flags & PF_EXITING)) {\n\t\tlock_sock(sk);\n\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t\trelease_sock(sk);\n\t}\n\tsock_orphan(sk);\n\tsco_sock_kill(sk);\n\treturn err;\n}", "target": 0}
{"code": "     **/\n    CImg<T> get_matrix_at(const unsigned int x=0, const unsigned int y=0, const unsigned int z=0) const {\n      const int n = (int)std::sqrt((double)_spectrum);\n      const T *ptrs = data(x,y,z,0);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      CImg<T> res(n,n);\n      T *ptrd = res._data;\n      cimg_forC(*this,c) { *(ptrd++) = *ptrs; ptrs+=whd; }\n      return res;", "target": 0}
{"code": "static void reset_terminal(struct vc_data *vc, int do_clear)\n{\n\tvc->vc_top\t\t= 0;\n\tvc->vc_bottom\t\t= vc->vc_rows;\n\tvc->vc_state\t\t= ESnormal;\n\tvc->vc_priv\t\t= EPecma;\n\tvc->vc_translate\t= set_translate(LAT1_MAP, vc);\n\tvc->vc_G0_charset\t= LAT1_MAP;\n\tvc->vc_G1_charset\t= GRAF_MAP;\n\tvc->vc_charset\t\t= 0;\n\tvc->vc_need_wrap\t= 0;\n\tvc->vc_report_mouse\t= 0;\n\tvc->vc_utf              = default_utf8;\n\tvc->vc_utf_count\t= 0;\n\tvc->vc_disp_ctrl\t= 0;\n\tvc->vc_toggle_meta\t= 0;\n\tvc->vc_decscnm\t\t= 0;\n\tvc->vc_decom\t\t= 0;\n\tvc->vc_decawm\t\t= 1;\n\tvc->vc_deccm\t\t= global_cursor_default;\n\tvc->vc_decim\t\t= 0;\n\tvt_reset_keyboard(vc->vc_num);\n\tvc->vc_cursor_type = cur_default;\n\tvc->vc_complement_mask = vc->vc_s_complement_mask;\n\tdefault_attr(vc);\n\tupdate_attr(vc);\n\tvc->vc_tab_stop[0]\t=\n\tvc->vc_tab_stop[1]\t=\n\tvc->vc_tab_stop[2]\t=\n\tvc->vc_tab_stop[3]\t=\n\tvc->vc_tab_stop[4]\t=\n\tvc->vc_tab_stop[5]\t=\n\tvc->vc_tab_stop[6]\t=\n\tvc->vc_tab_stop[7]\t= 0x01010101;\n\tvc->vc_bell_pitch = DEFAULT_BELL_PITCH;\n\tvc->vc_bell_duration = DEFAULT_BELL_DURATION;\n\tvc->vc_cur_blink_ms = DEFAULT_CURSOR_BLINK_MS;\n\tgotoxy(vc, 0, 0);\n\tsave_cur(vc);\n\tif (do_clear)\n\t    csi_J(vc, 2);\n}", "target": 0}
{"code": "ZEND_API void zend_extension_dispatch_message(int message, void *arg)\n{\n\tTSRMLS_FETCH();\n\tzend_llist_apply_with_arguments(&zend_extensions, (llist_apply_with_args_func_t) zend_extension_message_dispatcher TSRMLS_CC, 2, message, arg);\n}", "target": 0}
{"code": "static void add_full(struct kmem_cache_node *n, struct page *page)\n{\n\tspin_lock(&n->list_lock);\n\tlist_add(&page->lru, &n->full);\n\tspin_unlock(&n->list_lock);\n}", "target": 0}
{"code": "int gnutls_x509_ext_import_proxy(const gnutls_datum_t * ext, int *pathlen,\n\t\t\t      char **policyLanguage, char **policy,\n\t\t\t      size_t * sizeof_policy)\n{\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tint result;\n\tgnutls_datum_t value = { NULL, 0 };\n\tif ((result = asn1_create_element\n\t     (_gnutls_get_pkix(), \"PKIX1.ProxyCertInfo\",\n\t      &c2)) != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tresult = asn1_der_decoding(&c2, ext->data, ext->size, NULL);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\tresult = _gnutls_asn2err(result);\n\t\tgoto cleanup;\n\t}\n\tif (pathlen) {\n\t\tresult = _gnutls_x509_read_uint(c2, \"pCPathLenConstraint\",\n\t\t\t\t\t\t(unsigned int *)\n\t\t\t\t\t\tpathlen);\n\t\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND)\n\t\t\t*pathlen = -1;\n\t\telse if (result != GNUTLS_E_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tresult = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tresult = _gnutls_x509_read_value(c2, \"proxyPolicy.policyLanguage\",\n\t\t\t\t\t &value);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tif (policyLanguage) {\n\t\t*policyLanguage = (char *)value.data;\n\t} else {\n\t\tgnutls_free(value.data);\n\t\tvalue.data = NULL;\n\t}\n\tresult = _gnutls_x509_read_value(c2, \"proxyPolicy.policy\", &value);\n\tif (result == GNUTLS_E_ASN1_ELEMENT_NOT_FOUND) {\n\t\tif (policy)\n\t\t\t*policy = NULL;\n\t\tif (sizeof_policy)\n\t\t\t*sizeof_policy = 0;\n\t} else if (result < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t} else {\n\t\tif (policy) {\n\t\t\t*policy = (char *)value.data;\n\t\t\tvalue.data = NULL;\n\t\t}\n\t\tif (sizeof_policy)\n\t\t\t*sizeof_policy = value.size;\n\t}\n\tresult = 0;\n cleanup:\n\tgnutls_free(value.data);\n\tasn1_delete_structure(&c2);\n\treturn result;\n}", "target": 0}
{"code": "Item_param::set_out_param_info(Send_field *info)\n{\n  m_out_param_info= info;\n  param_type= m_out_param_info->type;\n}", "target": 0}
{"code": "LIR_Opr LIRGenerator::rlock_byte(BasicType type) {\n  LIR_Opr reg = new_register(T_INT);\n  set_vreg_flag(reg, LIRGenerator::byte_reg);\n  return reg;\n}", "target": 0}
{"code": "static struct page *alloc_migrate_huge_page(struct hstate *h, gfp_t gfp_mask,\n\t\t\t\t     int nid, nodemask_t *nmask)\n{\n\tstruct page *page;\n\tif (hstate_is_gigantic(h))\n\t\treturn NULL;\n\tpage = alloc_fresh_huge_page(h, gfp_mask, nid, nmask, NULL);\n\tif (!page)\n\t\treturn NULL;\n\tSetHPageTemporary(page);\n\treturn page;\n}", "target": 0}
{"code": "void gdImageSetClip (gdImagePtr im, int x1, int y1, int x2, int y2)\n{\n\tif (x1 < 0) {\n\t\tx1 = 0;\n\t}\n\tif (x1 >= im->sx) {\n\t\tx1 = im->sx - 1;\n\t}\n\tif (x2 < 0) {\n\t\tx2 = 0;\n\t}\n\tif (x2 >= im->sx) {\n\t\tx2 = im->sx - 1;\n\t}\n\tif (y1 < 0) {\n\t\ty1 = 0;\n\t}\n\tif (y1 >= im->sy) {\n\t\ty1 = im->sy - 1;\n\t}\n\tif (y2 < 0) {\n\t\ty2 = 0;\n\t}\n\tif (y2 >= im->sy) {\n\t\ty2 = im->sy - 1;\n\t}\n\tim->cx1 = x1;\n\tim->cy1 = y1;\n\tim->cx2 = x2;\n\tim->cy2 = y2;\n}", "target": 0}
{"code": "isdn_ppp_release(int min, struct file *file)\n{\n\tint i;\n\tstruct ippp_struct *is;\n\tif (min < 0 || min >= ISDN_MAX_CHANNELS)\n\t\treturn;\n\tis = file->private_data;\n\tif (!is) {\n\t\tprintk(KERN_ERR \"%s: no file->private_data\\n\", __func__);\n\t\treturn;\n\t}\n\tif (is->debug & 0x1)\n\t\tprintk(KERN_DEBUG \"ippp: release, minor: %d %lx\\n\", min, (long) is->lp);\n\tif (is->lp) {           \n\t\tisdn_net_dev *p = is->lp->netdev;\n\t\tif (!p) {\n\t\t\tprintk(KERN_ERR \"%s: no lp->netdev\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tis->state &= ~IPPP_CONNECT;\t\n\t\tisdn_net_hangup(p->dev);\n\t}\n\tfor (i = 0; i < NUM_RCV_BUFFS; i++) {\n\t\tkfree(is->rq[i].buf);\n\t\tis->rq[i].buf = NULL;\n\t}\n\tis->first = is->rq + NUM_RCV_BUFFS - 1;\t\n\tis->last = is->rq;\n#ifdef CONFIG_ISDN_PPP_VJ\n\tslhc_free(is->slcomp);\n\tis->slcomp = NULL;\n#endif\n#ifdef CONFIG_IPPP_FILTER\n\tif (is->pass_filter) {\n\t\tbpf_prog_destroy(is->pass_filter);\n\t\tis->pass_filter = NULL;\n\t}\n\tif (is->active_filter) {\n\t\tbpf_prog_destroy(is->active_filter);\n\t\tis->active_filter = NULL;\n\t}\n#endif\n\tif (is->comp_stat)\n\t\tis->compressor->free(is->comp_stat);\n\tif (is->link_comp_stat)\n\t\tis->link_compressor->free(is->link_comp_stat);\n\tif (is->link_decomp_stat)\n\t\tis->link_decompressor->free(is->link_decomp_stat);\n\tif (is->decomp_stat)\n\t\tis->decompressor->free(is->decomp_stat);\n\tis->compressor   = is->link_compressor   = NULL;\n\tis->decompressor = is->link_decompressor = NULL;\n\tis->comp_stat    = is->link_comp_stat    = NULL;\n\tis->decomp_stat  = is->link_decomp_stat  = NULL;\n\tif (is->reset)\n\t\tisdn_ppp_ccp_reset_free(is);\n\tis->state = 0;\n}", "target": 0}
{"code": "static void __nft_unregister_flowtable_net_hooks(struct net *net,\n\t\t\t\t\t\t struct list_head *hook_list,\n\t\t\t\t\t         bool release_netdev)\n{\n\tstruct nft_hook *hook, *next;\n\tlist_for_each_entry_safe(hook, next, hook_list, list) {\n\t\tnf_unregister_net_hook(net, &hook->ops);\n\t\tif (release_netdev) {\n\t\t\tlist_del(&hook->list);\n\t\t\tkfree_rcu(hook, rcu);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void bnx2x_init_dropless_fc(struct bnx2x *bp)\n{\n\tu32 pause_enabled = 0;\n\tif (!CHIP_IS_E1(bp) && bp->dropless_fc && bp->link_vars.link_up) {\n\t\tif (bp->link_vars.flow_ctrl & BNX2X_FLOW_CTRL_TX)\n\t\t\tpause_enabled = 1;\n\t\tREG_WR(bp, BAR_USTRORM_INTMEM +\n\t\t\t   USTORM_ETH_PAUSE_ENABLED_OFFSET(BP_PORT(bp)),\n\t\t       pause_enabled);\n\t}\n\tDP(NETIF_MSG_IFUP | NETIF_MSG_LINK, \"dropless_fc is %s\\n\",\n\t   pause_enabled ? \"enabled\" : \"disabled\");\n}", "target": 0}
{"code": "static void btrfs_rm_dev_replace_unblocked(struct btrfs_fs_info *fs_info)\n{\n\tclear_bit(BTRFS_FS_STATE_DEV_REPLACING, &fs_info->fs_state);\n\twake_up(&fs_info->dev_replace.replace_wait);\n}", "target": 0}
{"code": "sc_pkcs15emu_add_object(sc_pkcs15_card_t *p15card, int type,\n\t\tconst char *label, void *data,\n\t\tconst sc_pkcs15_id_t *auth_id, int obj_flags)\n{\n\tsc_pkcs15_object_t *obj;\n\tint\t\tdf_type;\n\tobj = calloc(1, sizeof(*obj));\n\tobj->type  = type;\n\tobj->data  = data;\n\tif (label)\n\t\tstrncpy(obj->label, label, sizeof(obj->label)-1);\n\tobj->flags = obj_flags;\n\tif (auth_id)\n\t\tobj->auth_id = *auth_id;\n\tswitch (type & SC_PKCS15_TYPE_CLASS_MASK) {\n\tcase SC_PKCS15_TYPE_AUTH:\n\t\tdf_type = SC_PKCS15_AODF;\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PRKEY:\n\t\tdf_type = SC_PKCS15_PRKDF;\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_PUBKEY:\n\t\tdf_type = SC_PKCS15_PUKDF;\n\t\tbreak;\n\tcase SC_PKCS15_TYPE_CERT:\n\t\tdf_type = SC_PKCS15_CDF;\n\t\tbreak;\n\tdefault:\n\t\tsc_log(p15card->card->ctx, \"Unknown PKCS15 object type %d\", type);\n\t\tfree(obj);\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\tobj->df = sc_pkcs15emu_get_df(p15card, df_type);\n\tsc_pkcs15_add_object(p15card, obj);\n\treturn 0;\n}", "target": 0}
{"code": "g_markup_parse_context_get_user_data (GMarkupParseContext *context)\n{\n  return context->user_data;\n}", "target": 0}
{"code": "onig_statistics_init(void)\n{\n  int i;\n  for (i = 0; i < 256; i++) {\n    OpCounter[i] = OpPrevCounter[i] = 0; OpTime[i] = 0;\n  }\n  MaxStackDepth = 0;\n# ifdef _WIN32\n  QueryPerformanceFrequency(&freq);\n# endif\n}", "target": 0}
{"code": "static jboolean Region_quickRejectIIII(JNIEnv* env, jobject region, jint left, jint top, jint right, jint bottom) {\n SkIRect ir;\n    ir.set(left, top, right, bottom);\n bool result = GetSkRegion(env, region)->quickReject(ir);\n return boolTojboolean(result);\n}", "target": 0}
{"code": "smb2_dump_share_caps(struct seq_file *m, struct cifs_tcon *tcon)\n{\n\tseq_puts(m, \"\\n\\tShare Capabilities:\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_DFS)\n\t\tseq_puts(m, \" DFS,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_CONTINUOUS_AVAILABILITY)\n\t\tseq_puts(m, \" CONTINUOUS AVAILABILITY,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_SCALEOUT)\n\t\tseq_puts(m, \" SCALEOUT,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_CLUSTER)\n\t\tseq_puts(m, \" CLUSTER,\");\n\tif (tcon->capabilities & SMB2_SHARE_CAP_ASYMMETRIC)\n\t\tseq_puts(m, \" ASYMMETRIC,\");\n\tif (tcon->capabilities == 0)\n\t\tseq_puts(m, \" None\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_ALIGNED_DEVICE)\n\t\tseq_puts(m, \" Aligned,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE)\n\t\tseq_puts(m, \" Partition Aligned,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_NO_SEEK_PENALTY)\n\t\tseq_puts(m, \" SSD,\");\n\tif (tcon->ss_flags & SSINFO_FLAGS_TRIM_ENABLED)\n\t\tseq_puts(m, \" TRIM-support,\");\n\tseq_printf(m, \"\\tShare Flags: 0x%x\", tcon->share_flags);\n\tseq_printf(m, \"\\n\\ttid: 0x%x\", tcon->tid);\n\tif (tcon->perf_sector_size)\n\t\tseq_printf(m, \"\\tOptimal sector size: 0x%x\",\n\t\t\t   tcon->perf_sector_size);\n\tseq_printf(m, \"\\tMaximal Access: 0x%x\", tcon->maximal_access);\n}", "target": 0}
{"code": "bool OtherInstanceOf(Napi::Object source, const char* object_type) {\n    if (strncmp(object_type, \"Date\", 4) == 0) {\n        return source.InstanceOf(source.Env().Global().Get(\"Date\").As<Function>());\n    } else if (strncmp(object_type, \"RegExp\", 6) == 0) {\n        return source.InstanceOf(source.Env().Global().Get(\"RegExp\").As<Function>());\n    }\n    return false;\n}", "target": 0}
{"code": "static int decode_attr_symlink_support(struct xdr_stream *xdr, uint32_t *bitmap, uint32_t *res)\n{\n\t__be32 *p;\n\t*res = 0;\n\tif (unlikely(bitmap[0] & (FATTR4_WORD0_SYMLINK_SUPPORT - 1U)))\n\t\treturn -EIO;\n\tif (likely(bitmap[0] & FATTR4_WORD0_SYMLINK_SUPPORT)) {\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (unlikely(!p))\n\t\t\tgoto out_overflow;\n\t\t*res = be32_to_cpup(p);\n\t\tbitmap[0] &= ~FATTR4_WORD0_SYMLINK_SUPPORT;\n\t}\n\tdprintk(\"%s: symlink support=%s\\n\", __func__, *res == 0 ? \"false\" : \"true\");\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "void RGWGetBucketVersioning_ObjStore_S3::send_response()\n{\n  dump_errno(s);\n  end_header(s, this, \"application/xml\");\n  dump_start(s);\n  s->formatter->open_object_section_in_ns(\"VersioningConfiguration\", XMLNS_AWS_S3);\n  if (versioned) {\n    const char *status = (versioning_enabled ? \"Enabled\" : \"Suspended\");\n    s->formatter->dump_string(\"Status\", status);\n    const char *mfa_status = (mfa_enabled ? \"Enabled\" : \"Disabled\");\n    s->formatter->dump_string(\"MfaDelete\", mfa_status);\n  }\n  s->formatter->close_section();\n  rgw_flush_formatter_and_reset(s, s->formatter);\n}", "target": 0}
{"code": "void HTMLMediaElement::RejectPlayPromisesInternal(DOMExceptionCode code,\n                                                  const String& message) {\n  DCHECK(code == DOMExceptionCode::kAbortError ||\n         code == DOMExceptionCode::kNotSupportedError);\n  for (auto& resolver : play_promise_reject_list_)\n    resolver->Reject(DOMException::Create(code, message));\n  play_promise_reject_list_.clear();\n}", "target": 0}
{"code": "void tag_database_dirty(PgDatabase *db)\n{\n\tstruct List *item;\n\tPgPool *pool;\n\tstatlist_for_each(item, &pool_list) {\n\t\tpool = container_of(item, PgPool, head);\n\t\tif (pool->db == db)\n\t\t\ttag_pool_dirty(pool);\n\t}\n}", "target": 0}
{"code": "static struct nfs4_opendata *nfs4_opendata_alloc(struct dentry *dentry,\n\t\tstruct nfs4_state_owner *sp, fmode_t fmode, int flags,\n\t\tconst struct iattr *attrs,\n\t\tgfp_t gfp_mask)\n{\n\tstruct dentry *parent = dget_parent(dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\tp = kzalloc(sizeof(*p), gfp_mask);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid, gfp_mask);\n\tif (p->o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tnfs_sb_active(dentry->d_sb);\n\tp->dentry = dget(dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.fh = NFS_FH(dir);\n\tp->o_arg.open_flags = flags;\n\tp->o_arg.fmode = fmode & (FMODE_READ|FMODE_WRITE);\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id.create_time = ktime_to_ns(sp->so_seqid.create_time);\n\tp->o_arg.id.uniquifier = sp->so_seqid.owner_id;\n\tp->o_arg.name = &dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = server->attr_bitmask;\n\tp->o_arg.open_bitmap = &nfs4_fattr_bitmap[0];\n\tp->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (attrs != NULL && attrs->ia_valid != 0) {\n\t\t__be32 verf[2];\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\t\tverf[0] = jiffies;\n\t\tverf[1] = current->pid;\n\t\tmemcpy(p->o_arg.u.verifier.data, verf,\n\t\t\t\tsizeof(p->o_arg.u.verifier.data));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}", "target": 0}
{"code": "KCleanup::worksFor( KFileInfo *item ) const\n{\n    if ( ! _enabled || ! item )\n\treturn false;\n    if ( worksLocalOnly() && ! item->tree()->isFileProtocol() )\n\treturn false;\n    if\t( item->isDotEntry() )\treturn worksForDotEntry();\n    if\t( item->isDir() )\treturn worksForDir();\n    return worksForFile();\n}", "target": 0}
{"code": "static void tcp_dsack_set(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tcp_is_sack(tp) && sysctl_tcp_dsack) {\n\t\tint mib_idx;\n\t\tif (before(seq, tp->rcv_nxt))\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOLDSENT;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOFOSENT;\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\t\ttp->rx_opt.dsack = 1;\n\t\ttp->duplicate_sack[0].start_seq = seq;\n\t\ttp->duplicate_sack[0].end_seq = end_seq;\n\t}\n}", "target": 0}
{"code": "XML_SetExternalEntityRefHandlerArg(XML_Parser parser, void *arg) {\n  if (parser == NULL)\n    return;\n  if (arg)\n    parser->m_externalEntityRefHandlerArg = (XML_Parser)arg;\n  else\n    parser->m_externalEntityRefHandlerArg = parser;\n}", "target": 0}
{"code": "void OmniboxViewWin::OnRButtonDown(UINT , const CPoint& point) {\n  TrackMousePosition(kRight, point);\n  tracking_double_click_ = false;\n  possible_drag_ = false;\n  gaining_focus_.reset();\n  SetMsgHandled(false);\n}", "target": 0}
{"code": "irc_server_outqueue_free (struct t_irc_server *server,\n                          int priority,\n                          struct t_irc_outqueue *outqueue)\n{\n    struct t_irc_outqueue *new_outqueue;\n    if (!server || !outqueue)\n        return;\n    if (server->last_outqueue[priority] == outqueue)\n        server->last_outqueue[priority] = outqueue->prev_outqueue;\n    if (outqueue->prev_outqueue)\n    {\n        (outqueue->prev_outqueue)->next_outqueue = outqueue->next_outqueue;\n        new_outqueue = server->outqueue[priority];\n    }\n    else\n        new_outqueue = outqueue->next_outqueue;\n    if (outqueue->next_outqueue)\n        (outqueue->next_outqueue)->prev_outqueue = outqueue->prev_outqueue;\n    if (outqueue->command)\n        free (outqueue->command);\n    if (outqueue->message_before_mod)\n        free (outqueue->message_before_mod);\n    if (outqueue->message_after_mod)\n        free (outqueue->message_after_mod);\n    if (outqueue->tags)\n        free (outqueue->tags);\n    free (outqueue);\n    server->outqueue[priority] = new_outqueue;\n}", "target": 0}
{"code": "iasecc_chv_verify(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd, unsigned char *scbs,\n\t\t  int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char scb = scbs[IASECC_ACLS_CHV_VERIFY];\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Verify CHV PIN(ref:%i,len:%i,scb:%X)\", pin_cmd->pin_reference, pin_cmd->pin1.len,\n\t       scb);\n\tif (scb & IASECC_SCB_METHOD_SM) {\n\t\trv = iasecc_sm_pin_verify(card, scb & IASECC_SCB_METHOD_MASK_REF, pin_cmd, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\trv = iso_ops->pin_cmd(card, pin_cmd, tries_left);\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "static __inline__ void isdn_net_dec_frame_cnt(isdn_net_local *lp)\n{\n\tatomic_dec(&lp->frame_cnt);\n\tif (!(isdn_net_device_busy(lp))) {\n\t\tif (!skb_queue_empty(&lp->super_tx_queue)) {\n\t\t\tschedule_work(&lp->tqueue);\n\t\t} else {\n\t\t\tisdn_net_device_wake_queue(lp);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int get_msr_hyperv(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tint r;\n\t\tstruct kvm_vcpu *v;\n\t\tkvm_for_each_vcpu(r, v, vcpu->kvm)\n\t\t\tif (v == vcpu)\n\t\t\t\tdata = r;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tcase HV_X64_MSR_APIC_ASSIST_PAGE:\n\t\tdata = vcpu->arch.hv_vapic;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}", "target": 0}
{"code": "  int get_diag_rbg(int x, int y, int hc)\n  {\n    float dlurd = calc_dist(\n        nraw[nr_offset(y - 1, x - 1)][1] * nraw[nr_offset(y + 1, x + 1)][1],\n        nraw[nr_offset(y, x)][1] * nraw[nr_offset(y, x)][1]);\n    float druld = calc_dist(\n        nraw[nr_offset(y - 1, x + 1)][1] * nraw[nr_offset(y + 1, x - 1)][1],\n        nraw[nr_offset(y, x)][1] * nraw[nr_offset(y, x)][1]);\n    float e = calc_dist(dlurd, druld);\n    char d =\n        druld < dlurd ? (e > T() ? RULDSH : RULD) : (e > T() ? LURDSH : LURD);\n    return d;\n  }", "target": 0}
{"code": "int mbedtls_x509_crt_check_extended_key_usage( const mbedtls_x509_crt *crt,\n                                       const char *usage_oid,\n                                       size_t usage_len )\n{\n    const mbedtls_x509_sequence *cur;\n    if( ( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE ) == 0 )\n        return( 0 );\n    for( cur = &crt->ext_key_usage; cur != NULL; cur = cur->next )\n    {\n        const mbedtls_x509_buf *cur_oid = &cur->buf;\n        if( cur_oid->len == usage_len &&\n            memcmp( cur_oid->p, usage_oid, usage_len ) == 0 )\n        {\n            return( 0 );\n        }\n        if( MBEDTLS_OID_CMP( MBEDTLS_OID_ANY_EXTENDED_KEY_USAGE, cur_oid ) == 0 )\n            return( 0 );\n    }\n    return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n}", "target": 0}
{"code": "static int zipfileCommit(sqlite3_vtab *pVtab){\n  ZipfileTab *pTab = (ZipfileTab*)pVtab;\n  int rc = SQLITE_OK;\n  if( pTab->pWriteFd ){\n    i64 iOffset = pTab->szCurrent;\n    ZipfileEntry *p;\n    ZipfileEOCD eocd;\n    int nEntry = 0;\n    for(p=pTab->pFirstEntry; rc==SQLITE_OK && p; p=p->pNext){\n      int n = zipfileSerializeCDS(p, pTab->aBuffer);\n      rc = zipfileAppendData(pTab, pTab->aBuffer, n);\n      nEntry++;\n    }\n    eocd.iDisk = 0;\n    eocd.iFirstDisk = 0;\n    eocd.nEntry = (u16)nEntry;\n    eocd.nEntryTotal = (u16)nEntry;\n    eocd.nSize = (u32)(pTab->szCurrent - iOffset);\n    eocd.iOffset = (u32)iOffset;\n    rc = zipfileAppendEOCD(pTab, &eocd);\n    zipfileCleanupTransaction(pTab);\n  }\n  return rc;\n}", "target": 0}
{"code": "void WebContentsImpl::OnBrowserPluginMessage(const IPC::Message& message) {\n  CHECK(!browser_plugin_embedder_.get());\n  browser_plugin_embedder_.reset(BrowserPluginEmbedder::Create(this));\n  browser_plugin_embedder_->OnMessageReceived(message);\n}", "target": 0}
{"code": "bool Item_splocal::set_value(THD *thd, sp_rcontext *ctx, Item **it)\n{\n  return ctx->set_variable(thd, get_var_idx(), it);\n}", "target": 0}
{"code": "static void r_coresym_cache_element_lined_symbol_fini(RCoreSymCacheElementLinedSymbol *sym) {\n\tif (sym) {\n\t\tr_coresym_cache_element_symbol_fini (&sym->sym);\n\t\tr_coresym_cache_element_flc_fini (&sym->flc);\n\t}\n}", "target": 0}
{"code": "yang_parse_ext_substatement(struct lys_module *module, struct unres_schema *unres, const char *data,\n                            char *ext_name, struct lys_ext_instance_complex *ext)\n{\n    unsigned int size;\n    YY_BUFFER_STATE bp;\n    yyscan_t scanner = NULL;\n    int ret = 0;\n    struct yang_parameter param;\n    struct lys_node *node = NULL;\n    if (!data) {\n        return EXIT_SUCCESS;\n    }\n    size = strlen(data) + 2;\n    yylex_init(&scanner);\n    bp = yy_scan_buffer((char *)data, size, scanner);\n    yy_switch_to_buffer(bp, scanner);\n    memset(&param, 0, sizeof param);\n    param.module = module;\n    param.unres = unres;\n    param.node = &node;\n    param.actual_node = (void **)ext;\n    param.data_node = (void **)ext_name;\n    param.flags |= EXT_INSTANCE_SUBSTMT;\n    if (yyparse(scanner, &param)) {\n        yang_free_nodes(module->ctx, node);\n        ret = -1;\n    } else {\n        if (node && yang_check_nodes(module, (struct lys_node *)ext, node, LYS_PARSE_OPT_CFG_NOINHERIT, unres)) {\n            ret = -1;\n        }\n    }\n    yy_delete_buffer(bp, scanner);\n    yylex_destroy(scanner);\n    return ret;\n}", "target": 0}
{"code": "    bool TiffBinaryArray::updOrigDataBuf(const byte* pData, uint32_t size)\n    {\n        assert(pData != 0);\n        if (origSize_ != size) return false;\n        if (origData_ == pData) return true;\n        memcpy(origData_, pData, origSize_);\n        return true;\n    }", "target": 0}
{"code": "GF_Err elst_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 entries;\n\ts32 tr;\n\tu32 nb_entries;\n\tGF_EditListBox *ptr = (GF_EditListBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tnb_entries = gf_bs_read_u32(bs);\n\tif (ptr->version == 1) {\n\t\tif (nb_entries > ptr->size / 20) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t} else {\n\t\tif (nb_entries > ptr->size / 12) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid number of entries %d in ctts\\n\", nb_entries));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\tfor (entries = 0; entries < nb_entries; entries++) {\n\t\tGF_EdtsEntry *p = (GF_EdtsEntry *) gf_malloc(sizeof(GF_EdtsEntry));\n\t\tif (!p) return GF_OUT_OF_MEM;\n\t\tif (ptr->version == 1) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\tp->segmentDuration = gf_bs_read_u64(bs);\n\t\t\tp->mediaTime = (s64) gf_bs_read_u64(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 8);\n\t\t\tp->segmentDuration = gf_bs_read_u32(bs);\n\t\t\ttr = gf_bs_read_u32(bs);\n\t\t\tp->mediaTime = (s64) tr;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tp->mediaRate = gf_bs_read_u16(bs);\n\t\tgf_bs_read_u16(bs);\n\t\tgf_list_add(ptr->entryList, p);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "inline double _af_byteswap_float64 (double x)\n{\n\tunion\n\t{\n\t\tuint64_t i;\n\t\tdouble f;\n\t} u;\n\tu.f = x;\n\tu.i = _af_byteswap_int64(u.i);\n\treturn u.f;\n}", "target": 0}
{"code": "static void bad_page(struct page *page, const char *reason,\n\t\tunsigned long bad_flags)\n{\n\tstatic unsigned long resume;\n\tstatic unsigned long nr_shown;\n\tstatic unsigned long nr_unshown;\n\tif (nr_shown == 60) {\n\t\tif (time_before(jiffies, resume)) {\n\t\t\tnr_unshown++;\n\t\t\tgoto out;\n\t\t}\n\t\tif (nr_unshown) {\n\t\t\tpr_alert(\n\t\t\t      \"BUG: Bad page state: %lu messages suppressed\\n\",\n\t\t\t\tnr_unshown);\n\t\t\tnr_unshown = 0;\n\t\t}\n\t\tnr_shown = 0;\n\t}\n\tif (nr_shown++ == 0)\n\t\tresume = jiffies + 60 * HZ;\n\tpr_alert(\"BUG: Bad page state in process %s  pfn:%05lx\\n\",\n\t\tcurrent->comm, page_to_pfn(page));\n\t__dump_page(page, reason);\n\tbad_flags &= page->flags;\n\tif (bad_flags)\n\t\tpr_alert(\"bad because of flags: %#lx(%pGp)\\n\",\n\t\t\t\t\t\tbad_flags, &bad_flags);\n\tdump_page_owner(page);\n\tprint_modules();\n\tdump_stack();\nout:\n\tpage_mapcount_reset(page); \n\tadd_taint(TAINT_BAD_PAGE, LOCKDEP_NOW_UNRELIABLE);\n}", "target": 0}
{"code": "static inline void RelinquishPixelCachePixels(CacheInfo *cache_info)\n{\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    {\n#if defined(MAGICKCORE_OPENCL_SUPPORT)\n      if (cache_info->opencl != (MagickCLCacheInfo) NULL)\n        {\n          cache_info->opencl=RelinquishMagickCLCacheInfo(cache_info->opencl,\n            MagickTrue);\n          cache_info->pixels=(Quantum *) NULL;\n          break;\n        }\n#endif\n      if (cache_info->mapped == MagickFalse)\n        cache_info->pixels=(Quantum *) RelinquishAlignedMemory(\n          cache_info->pixels);\n      else\n        (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n      break;\n    }\n    case MapCache:\n    {\n      (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);\n      cache_info->pixels=(Quantum *) NULL;\n      if ((cache_info->mode != ReadMode) && (cache_info->mode != PersistMode))\n        (void) RelinquishUniqueFileResource(cache_info->cache_filename);\n      *cache_info->cache_filename='\\0';\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n    case DiskCache:\n    {\n      if (cache_info->file != -1)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      if ((cache_info->mode != ReadMode) && (cache_info->mode != PersistMode))\n        (void) RelinquishUniqueFileResource(cache_info->cache_filename);\n      *cache_info->cache_filename='\\0';\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      break;\n    }\n    case DistributedCache:\n    {\n      *cache_info->cache_filename='\\0';\n      (void) RelinquishDistributePixelCache((DistributeCacheInfo *)\n        cache_info->server_info);\n      break;\n    }\n    default:\n      break;\n  }\n  cache_info->type=UndefinedCache;\n  cache_info->mapped=MagickFalse;\n  cache_info->metacontent=(void *) NULL;\n}", "target": 0}
{"code": "static void reds_send_link_result(RedLinkInfo *link, uint32_t error)\n{\n    error = GUINT32_TO_LE(error);\n    red_stream_write_all(link->stream, &error, sizeof(error));\n}", "target": 0}
{"code": "__weak unsigned long vma_mmu_pagesize(struct vm_area_struct *vma)\n{\n\treturn vma_kernel_pagesize(vma);\n}", "target": 0}
{"code": "void ewk_view_paint_context_scale(Ewk_View_Paint_Context* context, float scaleX, float scaleY)\n{\n    EINA_SAFETY_ON_NULL_RETURN(context);\n    context->graphicContext->scale(WebCore::FloatSize(scaleX, scaleY));\n}", "target": 0}
{"code": "bgp_attr_as4_path (struct bgp_attr_parser_args *args, struct aspath **as4_path)\n{\n  struct peer *const peer = args->peer; \n  struct attr *const attr = args->attr;\n  const bgp_size_t length = args->length;\n  *as4_path = aspath_parse (peer->ibuf, length, 1);\n  if (!*as4_path)\n    {\n      zlog (peer->log, LOG_ERR,\n            \"Malformed AS4 path from %s, length is %d\",\n            peer->host, length);\n      return bgp_attr_malformed (args,\n                                 BGP_NOTIFY_UPDATE_MAL_AS_PATH,\n                                 0);\n    }\n  if (as4_path)\n    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS4_PATH);\n  return BGP_ATTR_PARSE_PROCEED;\n}", "target": 0}
{"code": "static bool io_wq_worker_wake(struct io_worker *worker, void *data)\n{\n\tset_notify_signal(worker->task);\n\twake_up_process(worker->task);\n\treturn false;\n}", "target": 0}
{"code": "void CLASS sony_decrypt (unsigned *data, int len, int start, int key)\n{\n#ifndef LIBRAW_NOTHREADS\n#define pad tls->sony_decrypt.pad\n#define p   tls->sony_decrypt.p\n#else\n  static unsigned pad[128], p;\n#endif\n  if (start) {\n    for (p=0; p < 4; p++)\n      pad[p] = key = key * 48828125 + 1;\n    pad[3] = pad[3] << 1 | (pad[0]^pad[2]) >> 31;\n    for (p=4; p < 127; p++)\n      pad[p] = (pad[p-4]^pad[p-2]) << 1 | (pad[p-3]^pad[p-1]) >> 31;\n    for (p=0; p < 127; p++)\n      pad[p] = htonl(pad[p]);\n  }\n  while (len--)\n    {\n      *data++ ^= pad[p & 127] = pad[(p+1) & 127] ^ pad[(p+65) & 127];\n      p++;     \n    }\n#ifndef LIBRAW_NOTHREADS\n#undef pad\n#undef p\n#endif\n}", "target": 0}
{"code": "SYSCALL_DEFINE2(umount, char __user *, name, int, flags)\n{\n\tstruct path path;\n\tstruct mount *mnt;\n\tint retval;\n\tint lookup_flags = 0;\n\tif (flags & ~(MNT_FORCE | MNT_DETACH | MNT_EXPIRE | UMOUNT_NOFOLLOW))\n\t\treturn -EINVAL;\n\tif (!may_mount())\n\t\treturn -EPERM;\n\tif (!(flags & UMOUNT_NOFOLLOW))\n\t\tlookup_flags |= LOOKUP_FOLLOW;\n\tretval = user_path_mountpoint_at(AT_FDCWD, name, lookup_flags, &path);\n\tif (retval)\n\t\tgoto out;\n\tmnt = real_mount(path.mnt);\n\tretval = -EINVAL;\n\tif (path.dentry != path.mnt->mnt_root)\n\t\tgoto dput_and_out;\n\tif (!check_mnt(mnt))\n\t\tgoto dput_and_out;\n\tif (mnt->mnt.mnt_flags & MNT_LOCKED)\n\t\tgoto dput_and_out;\n\tretval = do_umount(mnt, flags);\ndput_and_out:\n\tdput(path.dentry);\n\tmntput_no_expire(mnt);\nout:\n\treturn retval;\n}", "target": 0}
{"code": "construct_filtered_key(const char *repos_name,\n                       const char *user,\n                       const svn_membuf_t *authz_id,\n                       apr_pool_t *result_pool)\n{\n  svn_membuf_t *result = apr_pcalloc(result_pool, sizeof(*result));\n  size_t repos_len = strlen(repos_name);\n  size_t user_len = user ? strlen(user) : 1;\n  const char *nullable_user = user ? user : \"\\0\";\n  size_t size = authz_id->size + repos_len + 1 + user_len + 1;\n  svn_membuf__create(result, size, result_pool);\n  result->size = size;\n  memcpy(result->data, repos_name, repos_len + 1);\n  size = repos_len + 1;\n  memcpy((char *)result->data + size, nullable_user, user_len + 1);\n  size += user_len + 1;\n  memcpy((char *)result->data + size, authz_id->data, authz_id->size);\n  return result;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, BasicCovering) {\n    addIndex(BSON(\"x\" << 1));\n    runQuerySortProj(fromjson(\"{ x : {$gt: 1}}\"), BSONObj(), fromjson(\"{_id: 0, x: 1}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, x: 1}, node: {ixscan: \"\n        \"{filter: null, pattern: {x: 1}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, x: 1}, node: \"\n        \"{cscan: {dir: 1, filter: {x:{$gt:1}}}}}}\");\n}", "target": 0}
{"code": "static size_t consume_u7_r(RBuffer *b, ut64 bound, ut8 *out) {\n\tsize_t n = 0;\n\tut32 tmp = consume_r (b, bound, &n, read_u32_leb128);\n\tif (out) {\n\t\t*out = (ut8) (tmp & 0x7f);\n\t}\n\treturn n;\n}", "target": 0}
{"code": "slhc_compress(struct slcompress *comp, unsigned char *icp, int isize,\n\tunsigned char *ocp, unsigned char **cpp, int compress_cid)\n{\n  printk(KERN_DEBUG \"Called IP function on non IP-system: slhc_compress\");\n  return -EINVAL;\n}", "target": 0}
{"code": "const AtomicString& SpeechSynthesis::interfaceName() const\n{\n    return EventTargetNames::SpeechSynthesisUtterance;\n}", "target": 0}
{"code": "int mempool_create(size_t pool_item_size, size_t pool_initial_size,\n                   size_t pool_expansion_size, size_t pool_max_threshold_size,\n                   func_log_callback_type log_callback_func, int flags,\n                   MemoryPoolHandle *handle) {\n  int rc;\n  int bufs_to_allocate;\n  struct mempool *pool = NULL;\n  if (pool_item_size == 0 || pool_expansion_size == 0 || handle == NULL) {\n    return S3_MEMPOOL_INVALID_ARG;\n  }\n  if (pool_item_size < sizeof(struct memory_pool_element)) {\n    pool_item_size = sizeof(struct memory_pool_element);\n  }\n  *handle = NULL;\n  pool = (struct mempool *)calloc(1, sizeof(struct mempool));\n  if (pool == NULL) {\n    return S3_MEMPOOL_ERROR;\n  }\n  pool->flags |= flags;\n  pool->mempool_item_size = pool_item_size;\n  if (flags & CREATE_ALIGNED_MEMORY) {\n    pool->alignment = MEMORY_ALIGNMENT;\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    rc = pthread_mutex_init(&pool->lock, NULL);\n    if (rc != 0) {\n      free(pool);\n      return S3_MEMPOOL_ERROR;\n    }\n  }\n  *handle = (MemoryPoolHandle)pool;\n  pool->log_callback_func = log_callback_func;\n  pool->expandable_size = pool_expansion_size;\n  pool->max_memory_threshold = pool_max_threshold_size;\n  bufs_to_allocate = pool_initial_size / pool_item_size;\n  if (bufs_to_allocate > 0) {\n    rc = freelist_allocate(pool, bufs_to_allocate);\n    if (rc != 0) {\n      goto fail;\n    }\n  }\n  return 0;\nfail:\n  mempool_destroy(handle);\n  *handle = NULL;\n  return S3_MEMPOOL_ERROR;\n}", "target": 0}
{"code": "    Loader::UniquePtr createLoaderExifJpeg(PreviewId id, const Image &image, int parIdx)\n    {\n        return Loader::UniquePtr(new LoaderExifJpeg(id, image, parIdx));\n    }", "target": 0}
{"code": "cdf_read_dir(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_dir_t *dir)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h), ns, nd;\n\tchar *buf;\n\tcdf_secid_t sid = h->h_secid_first_directory;\n\tns = cdf_count_chain(sat, sid, ss);\n\tif (ns == (size_t)-1)\n\t\treturn -1;\n\tnd = ss / CDF_DIRECTORY_SIZE;\n\tdir->dir_len = ns * nd;\n\tdir->dir_tab = CAST(cdf_directory_t *,\n\t    calloc(dir->dir_len, sizeof(dir->dir_tab[0])));\n\tif (dir->dir_tab == NULL)\n\t\treturn -1;\n\tif ((buf = CAST(char *, malloc(ss))) == NULL) {\n\t\tfree(dir->dir_tab);\n\t\treturn -1;\n\t}\n\tfor (j = i = 0; i < ns; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read dir loop limit\"));\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, buf, 0, ss, h, sid) != (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading directory sector %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tfor (j = 0; j < nd; j++) {\n\t\t\tcdf_unpack_dir(&dir->dir_tab[i * nd + j],\n\t\t\t    &buf[j * CDF_DIRECTORY_SIZE]);\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\tif (NEED_SWAP)\n\t\tfor (i = 0; i < dir->dir_len; i++)\n\t\t\tcdf_swap_dir(&dir->dir_tab[i]);\n\tfree(buf);\n\treturn 0;\nout:\n\tfree(dir->dir_tab);\n\tfree(buf);\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_select)\n{\n\tzval *pgsql_link, *ids;\n\tchar *table;\n\tsize_t table_len;\n\tzend_ulong option = PGSQL_DML_EXEC;\n\tPGconn *pg_link;\n\tzend_string *sql = NULL;\n\tint id = -1, argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc, \"rsa|l\",\n\t\t\t\t\t\t\t  &pgsql_link, &table, &table_len, &ids, &option) == FAILURE) {\n\t\treturn;\n\t}\n\tif (option & ~(PGSQL_CONV_FORCE_NULL|PGSQL_DML_NO_CONV|PGSQL_DML_EXEC|PGSQL_DML_ASYNC|PGSQL_DML_STRING|PGSQL_DML_ESCAPE)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Invalid option is specified\");\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE2(pg_link, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tif (php_pgsql_flush_query(pg_link)) {\n\t\tphp_error_docref(NULL, E_NOTICE, \"Detected unhandled result(s) in connection\");\n\t}\n\tarray_init(return_value);\n\tif (php_pgsql_select(pg_link, table, ids, return_value, option, &sql) == FAILURE) {\n\t\tzval_ptr_dtor(return_value);\n\t\tRETURN_FALSE;\n\t}\n\tif (option & PGSQL_DML_STRING) {\n\t\tzval_ptr_dtor(return_value);\n\t\tRETURN_STR(sql);\n\t}\n\treturn;\n}", "target": 0}
{"code": "static int rpza_decode_frame(AVCodecContext *avctx,\n                             void *data, int *got_frame,\n                             AVPacket *avpkt)\n{\n    RpzaContext *s = avctx->priv_data;\n    int ret;\n    bytestream2_init(&s->gb, avpkt->data, avpkt->size);\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n        return ret;\n    }\n    rpza_decode_stream(s);\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n        return ret;\n    *got_frame      = 1;\n    return avpkt->size;\n}", "target": 0}
{"code": "struct lruvec *mem_cgroup_lru_add_list(struct zone *zone, struct page *page,\n\t\t\t\t       enum lru_list lru)\n{\n\tstruct mem_cgroup_per_zone *mz;\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc;\n\tif (mem_cgroup_disabled())\n\t\treturn &zone->lruvec;\n\tpc = lookup_page_cgroup(page);\n\tmemcg = pc->mem_cgroup;\n\tmz = page_cgroup_zoneinfo(memcg, page);\n\tMEM_CGROUP_ZSTAT(mz, lru) += 1 << compound_order(page);\n\treturn &mz->lruvec;\n}", "target": 0}
{"code": "static void early_kmem_cache_node_alloc(int node)\n{\n\tstruct page *page;\n\tstruct kmem_cache_node *n;\n\tBUG_ON(kmem_cache_node->size < sizeof(struct kmem_cache_node));\n\tpage = new_slab(kmem_cache_node, GFP_NOWAIT, node);\n\tBUG_ON(!page);\n\tif (page_to_nid(page) != node) {\n\t\tpr_err(\"SLUB: Unable to allocate memory from node %d\\n\", node);\n\t\tpr_err(\"SLUB: Allocating a useless per node structure in order to be able to continue\\n\");\n\t}\n\tn = page->freelist;\n\tBUG_ON(!n);\n#ifdef CONFIG_SLUB_DEBUG\n\tinit_object(kmem_cache_node, n, SLUB_RED_ACTIVE);\n\tinit_tracking(kmem_cache_node, n);\n#endif\n\tn = kasan_kmalloc(kmem_cache_node, n, sizeof(struct kmem_cache_node),\n\t\t      GFP_KERNEL);\n\tpage->freelist = get_freepointer(kmem_cache_node, n);\n\tpage->inuse = 1;\n\tpage->frozen = 0;\n\tkmem_cache_node->node[node] = n;\n\tinit_kmem_cache_node(n);\n\tinc_slabs_node(kmem_cache_node, node, page->objects);\n\t__add_partial(n, page, DEACTIVATE_TO_HEAD);\n}", "target": 0}
{"code": "    uint32_t TiffBinaryArray::doWrite(IoWrapper& ioWrapper,\n                                      ByteOrder byteOrder,\n                                      int32_t   offset,\n                                      uint32_t  valueIdx,\n                                      uint32_t  dataIdx,\n                                      uint32_t& imageIdx)\n    {\n        if (cfg() == 0 || !decoded()) return TiffEntryBase::doWrite(ioWrapper,\n                                                                    byteOrder,\n                                                                    offset,\n                                                                    valueIdx,\n                                                                    dataIdx,\n                                                                    imageIdx);\n        if (cfg()->byteOrder_ != invalidByteOrder) byteOrder = cfg()->byteOrder_;\n        std::sort(elements_.begin(), elements_.end(), cmpTagLt);\n        uint32_t idx = 0;\n        MemIo mio;\n        IoWrapper mioWrapper(mio, 0, 0, 0);\n        if (cfg()->hasSize_) {\n            byte buf[4];\n            long elSize = TypeInfo::typeSize(toTypeId(cfg()->elTiffType_, 0, cfg()->group_));\n            switch (elSize) {\n            case 2:\n                idx += us2Data(buf, size(), byteOrder);\n                break;\n            case 4:\n                idx += ul2Data(buf, size(), byteOrder);\n                break;\n            default:\n                assert(false);\n            }\n            mioWrapper.write(buf, elSize);\n        }\n        for (Components::const_iterator i = elements_.begin(); i != elements_.end(); ++i) {\n            if (cfg()->hasSize_ && (*i)->tag() == 0) continue;\n            uint32_t newIdx = (*i)->tag() * cfg()->tagStep();\n            idx += fillGap(mioWrapper, idx, newIdx);\n            idx += (*i)->write(mioWrapper, byteOrder, offset + newIdx, valueIdx, dataIdx, imageIdx);\n        }\n        if (cfg()->hasFillers_ && def()) {\n            const ArrayDef* lastDef = def() + defSize() - 1;\n            uint16_t lastTag = static_cast<uint16_t>(lastDef->idx_ / cfg()->tagStep());\n            idx += fillGap(mioWrapper, idx, lastDef->idx_ + lastDef->size(lastTag, cfg()->group_));\n        }\n        DataBuf buf;\n        if (cfg()->cryptFct_) {\n            buf = cfg()->cryptFct_(tag(), mio.mmap(), static_cast<uint32_t>(mio.size()), pRoot_);\n        }\n        if (buf.size_ > 0) {\n            ioWrapper.write(buf.pData_, buf.size_);\n        }\n        else {\n            ioWrapper.write(mio.mmap(), static_cast<uint32_t>(mio.size()));\n        }\n        return idx;\n    } ", "target": 0}
{"code": "static bool qpf_cmp_func(const void *obj, const void *userp)\n{\n    const QpfEntry *e1 = obj, *e2 = userp;\n    return e1->dev == e2->dev && e1->ino == e2->ino;\n}", "target": 0}
{"code": "static int handle_eviocgbit(struct input_dev *dev,\n\t\t\t    unsigned int type, unsigned int size,\n\t\t\t    void __user *p, int compat_mode)\n{\n\tunsigned long *bits;\n\tint len;\n\tswitch (type) {\n\tcase      0: bits = dev->evbit;  len = EV_MAX;  break;\n\tcase EV_KEY: bits = dev->keybit; len = KEY_MAX; break;\n\tcase EV_REL: bits = dev->relbit; len = REL_MAX; break;\n\tcase EV_ABS: bits = dev->absbit; len = ABS_MAX; break;\n\tcase EV_MSC: bits = dev->mscbit; len = MSC_MAX; break;\n\tcase EV_LED: bits = dev->ledbit; len = LED_MAX; break;\n\tcase EV_SND: bits = dev->sndbit; len = SND_MAX; break;\n\tcase EV_FF:  bits = dev->ffbit;  len = FF_MAX;  break;\n\tcase EV_SW:  bits = dev->swbit;  len = SW_MAX;  break;\n\tdefault: return -EINVAL;\n\t}\n\treturn bits_to_user(bits, len, size, p, compat_mode);\n}", "target": 0}
{"code": "static inline size_t read_cnt(struct n_tty_data *ldata)\n{\n\treturn ldata->read_head - ldata->read_tail;\n}", "target": 0}
{"code": "void set_position(JOIN *join,uint idx,JOIN_TAB *table,KEYUSE *key)\n{\n  join->positions[idx].table= table;\n  join->positions[idx].key=key;\n  join->positions[idx].records_read=1.0;\t\n  join->positions[idx].cond_selectivity= 1.0;\n  join->positions[idx].ref_depend_map= 0;\n  join->positions[idx].sj_strategy= SJ_OPT_NONE;\n  join->positions[idx].use_join_buffer= FALSE;\n  JOIN_TAB **pos=join->best_ref+idx+1;\n  JOIN_TAB *next=join->best_ref[idx];\n  for (;next != table ; pos++)\n  {\n    JOIN_TAB *tmp=pos[0];\n    pos[0]=next;\n    next=tmp;\n  }\n  join->best_ref[idx]=table;\n}", "target": 0}
{"code": "flatpak_run_get_cups_server_name (void)\n{\n  g_autofree char * cups_server = NULL;\n  g_autofree char * cups_config_path = NULL;\n  cups_server = g_strdup (g_getenv (\"CUPS_SERVER\"));\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n  cups_config_path = g_build_filename (g_get_home_dir (), \".cups/client.conf\", NULL);\n  cups_server = flatpak_run_get_cups_server_name_config (cups_config_path);\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n  cups_server = flatpak_run_get_cups_server_name_config (\"/etc/cups/client.conf\");\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  return g_strdup (\"/var/run/cups/cups.sock\");\n}", "target": 0}
{"code": "static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) \n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)object;\n\tif (intern->oth_handler && intern->oth_handler->dtor) {\n\t\tintern->oth_handler->dtor(intern TSRMLS_CC);\n\t}\n\tzend_object_std_dtor(&intern->std TSRMLS_CC);\n\tif (intern->_path) {\n\t\tefree(intern->_path);\n\t}\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\tswitch(intern->type) {\n\tcase SPL_FS_INFO:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.dirp) {\n\t\t\tphp_stream_close(intern->u.dir.dirp);\n\t\t\tintern->u.dir.dirp = NULL;\n\t\t}\n\t\tif (intern->u.dir.sub_path) {\n\t\t\tefree(intern->u.dir.sub_path);\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tif (intern->u.file.stream) {\n\t\t\tif (intern->u.file.zcontext) {\n\t\t\t}\n\t\t\tif (!intern->u.file.stream->is_persistent) {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);\n\t\t\t} else {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);\n\t\t\t}\n\t\t\tif (intern->u.file.open_mode) {\n\t\t\t\tefree(intern->u.file.open_mode);\n\t\t\t}\n\t\t\tif (intern->orig_path) {\n\t\t\t\tefree(intern->orig_path);\n\t\t\t}\n\t\t}\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tbreak;\n\t}\n\t{\n\t\tzend_object_iterator *iterator;\n\t\titerator = (zend_object_iterator*)\n\t\t\t\tspl_filesystem_object_to_iterator(intern);\n\t\tif (iterator->data != NULL) {\n\t\t\titerator->data = NULL;\n\t\t\titerator->funcs->dtor(iterator TSRMLS_CC);\n\t\t}\n\t}\n\tefree(object);\n} ", "target": 0}
{"code": "PHP_FUNCTION(curl_error)\n{\n\tzval\t\t*zid;\n\tphp_curl\t*ch;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"r\", &zid) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(ch, php_curl *, &zid, -1, le_curl_name, le_curl);\n\tch->err.str[CURL_ERROR_SIZE] = 0;\n\tRETURN_STRING(ch->err.str, 1);\n}", "target": 0}
{"code": "int32_t FontData::BoundLength(int32_t offset, int32_t length) {\n  return std::min<int32_t>(length, bound_length_ - offset);\n}", "target": 0}
{"code": "static unsigned long *alloc_thread_stack_node(struct task_struct *tsk, int node)\n{\n#ifdef CONFIG_VMAP_STACK\n\tvoid *stack;\n\tint i;\n\tfor (i = 0; i < NR_CACHED_STACKS; i++) {\n\t\tstruct vm_struct *s;\n\t\ts = this_cpu_xchg(cached_stacks[i], NULL);\n\t\tif (!s)\n\t\t\tcontinue;\n\t\ttsk->stack_vm_area = s;\n\t\treturn s->addr;\n\t}\n\tstack = __vmalloc_node_range(THREAD_SIZE, THREAD_ALIGN,\n\t\t\t\t     VMALLOC_START, VMALLOC_END,\n\t\t\t\t     THREADINFO_GFP,\n\t\t\t\t     PAGE_KERNEL,\n\t\t\t\t     0, node, __builtin_return_address(0));\n\tif (stack)\n\t\ttsk->stack_vm_area = find_vm_area(stack);\n\treturn stack;\n#else\n\tstruct page *page = alloc_pages_node(node, THREADINFO_GFP,\n\t\t\t\t\t     THREAD_SIZE_ORDER);\n\treturn page ? page_address(page) : NULL;\n#endif\n}", "target": 0}
{"code": "void auth_client_request_continue(struct auth_client_request *request,\n                                  const char *data_base64)\n{\n\tstruct const_iovec iov[3];\n\tconst char *prefix;\n\tprefix = t_strdup_printf(\"CONT\\t%u\\t\", request->id);\n\tiov[0].iov_base = prefix;\n\tiov[0].iov_len = strlen(prefix);\n\tiov[1].iov_base = data_base64;\n\tiov[1].iov_len = strlen(data_base64);\n\tiov[2].iov_base = \"\\n\";\n\tiov[2].iov_len = 1;\n\tif (o_stream_sendv(request->conn->output, iov, 3) < 0)\n\t\ti_error(\"Error sending continue request to auth server: %m\");\n}", "target": 0}
{"code": "bool ChildProcessSecurityPolicyImpl::IsWebSafeScheme(\n    const std::string& scheme) {\n  base::AutoLock lock(lock_);\n  return (web_safe_schemes_.find(scheme) != web_safe_schemes_.end());\n}", "target": 0}
{"code": "static void vcc_destroy_socket(struct sock *sk)\n{\n\tstruct atm_vcc *vcc = atm_sk(sk);\n\tstruct sk_buff *skb;\n\tset_bit(ATM_VF_CLOSE, &vcc->flags);\n\tclear_bit(ATM_VF_READY, &vcc->flags);\n\tif (vcc->dev) {\n\t\tif (vcc->dev->ops->close)\n\t\t\tvcc->dev->ops->close(vcc);\n\t\tif (vcc->push)\n\t\t\tvcc->push(vcc, NULL); \n\t\tmodule_put(vcc->owner);\n\t\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\t\tatm_return(vcc, skb->truesize);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\tmodule_put(vcc->dev->ops->owner);\n\t\tatm_dev_put(vcc->dev);\n\t}\n\tvcc_remove_socket(sk);\n}", "target": 0}
{"code": "GfxColorSpace *GfxIndexedColorSpace::copy() const\n{\n    GfxIndexedColorSpace *cs;\n    cs = new GfxIndexedColorSpace(base->copy(), indexHigh);\n    memcpy(cs->lookup, lookup, (indexHigh + 1) * base->getNComps() * sizeof(unsigned char));\n    return cs;\n}", "target": 0}
{"code": "  Return_Obj Parser::parse_return_directive()\n  {\n    if (peek_css < alternatives < exactly < ';' >, exactly < '}' >, end_of_file > >())\n    { css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \"); }\n    return SASS_MEMORY_NEW(Return, pstate, parse_list());\n  }", "target": 0}
{"code": "void decoder_context::set_image_allocation_functions(de265_image_allocation* allocfunc,\n                                                     void* userdata)\n{\n  if (allocfunc) {\n    param_image_allocation_functions = *allocfunc;\n    param_image_allocation_userdata  = userdata;\n  }\n  else {\n    assert(false); \n    param_image_allocation_functions = de265_image::default_image_allocation;\n    param_image_allocation_userdata  = NULL;\n  }\n}", "target": 0}
{"code": "bool HTMLTextAreaElement::appendFormData(FormDataList& encoding, bool)\n{\n    if (name().isEmpty())\n        return false;\n    document().updateLayout();\n    const String& text = (m_wrap == HardWrap) ? valueWithHardLineBreaks() : value();\n    encoding.appendData(name(), text);\n    const AtomicString& dirnameAttrValue = fastGetAttribute(dirnameAttr);\n    if (!dirnameAttrValue.isNull())\n        encoding.appendData(dirnameAttrValue, directionForFormData());\n    return true;\n}", "target": 0}
{"code": "__xfs_icache_free_eofblocks(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_eofblocks\t*eofb,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\ttag)\n{\n\tint flags = SYNC_TRYLOCK;\n\tif (eofb && (eofb->eof_flags & XFS_EOF_FLAGS_SYNC))\n\t\tflags = SYNC_WAIT;\n\treturn xfs_inode_ag_iterator_tag(mp, execute, flags,\n\t\t\t\t\t eofb, tag);\n}", "target": 0}
{"code": "static inline int imgCoordMungeUpper(SplashCoord x) {\n  return splashFloor(x) + 1;\n}", "target": 0}
{"code": "  FunctionInstantiationHelper(GetFunctionSignature get_function,\n                              InstantiationResult* result)\n      : get_function_(std ::move(get_function)), result_(*result) {\n    result_.nodes.clear();\n  }", "target": 0}
{"code": "void ConnectDialog::startDns(ServerItem *si) {\n\tif (!bAllowHostLookup) {\n\t\treturn;\n\t}\n\tQString hostname = si->qsHostname.toLower();\n\tunsigned short port = si->usPort;\n\tUnresolvedServerAddress unresolved(hostname, port);\n\tif (si->qlAddresses.isEmpty()) {\n\t\tQHostAddress qha(si->qsHostname);\n\t\tbool hostnameIsIPAddress = !qha.isNull();\n\t\tif (hostnameIsIPAddress) {\n\t\t\tsi->qlAddresses.append(ServerAddress(HostAddress(qha), port));\n\t\t} else {\n\t\t\tsi->qlAddresses = qhDNSCache.value(unresolved);\n\t\t}\n\t}\n\tif (qtwServers->currentItem() == si)\n\t\tqdbbButtonBox->button(QDialogButtonBox::Ok)->setEnabled(! si->qlAddresses.isEmpty());\n\tif (! si->qlAddresses.isEmpty()) {\n\t\tforeach(const ServerAddress &addr, si->qlAddresses) {\n\t\t\tqhPings[addr].insert(si);\n\t\t}\n\t\treturn;\n\t}\n#ifdef USE_BONJOUR\n\tif (bAllowBonjour && si->qsHostname.isEmpty() && ! si->brRecord.serviceName.isEmpty()) {\n\t\tif (! qlBonjourActive.contains(si->brRecord)) {\n\t\t\tg.bc->bsrResolver->resolveBonjourRecord(si->brRecord);\n\t\t\tqlBonjourActive.append(si->brRecord);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\tif (! qhDNSWait.contains(unresolved)) {\n\t\tif (si->itType == ServerItem::PublicType)\n\t\t\tqlDNSLookup.append(unresolved);\n\t\telse\n\t\t\tqlDNSLookup.prepend(unresolved);\n\t}\n\tqhDNSWait[unresolved].insert(si);\n}", "target": 0}
{"code": "static void ff_layout_write_prepare_v3(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\tif (ff_layout_write_prepare_common(task, hdr))\n\t\treturn;\n\trpc_call_start(task);\n}", "target": 0}
{"code": "mm_auth_krb4(Authctxt *authctxt, void *_auth, char **client, void *_reply)\n{\n\tKTEXT auth, reply;\n \tBuffer m;\n\tu_int rlen;\n\tint success = 0;\n\tchar *p;\n\tdebug3(\"%s entering\", __func__);\n\tauth = _auth;\n\treply = _reply;\n\tbuffer_init(&m);\n\tbuffer_put_string(&m, auth->dat, auth->length);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_KRB4, &m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_KRB4, &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success) {\n\t\t*client = buffer_get_string(&m, NULL);\n\t\tp = buffer_get_string(&m, &rlen);\n\t\tif (rlen >= MAX_KTXT_LEN)\n\t\t\tfatal(\"%s: reply from monitor too large\", __func__);\n\t\treply->length = rlen;\n\t\tmemcpy(reply->dat, p, rlen);\n\t\tmemset(p, 0, rlen);\n\t\txfree(p);\n\t}\n\tbuffer_free(&m);\n\treturn (success);\n}", "target": 0}
{"code": "static void try_to_free_low(struct hstate *h, unsigned long count,\n\t\t\t\t\t\tnodemask_t *nodes_allowed)\n{\n\tint i;\n\tLIST_HEAD(page_list);\n\tlockdep_assert_held(&hugetlb_lock);\n\tif (hstate_is_gigantic(h))\n\t\treturn;\n\tfor_each_node_mask(i, *nodes_allowed) {\n\t\tstruct page *page, *next;\n\t\tstruct list_head *freel = &h->hugepage_freelists[i];\n\t\tlist_for_each_entry_safe(page, next, freel, lru) {\n\t\t\tif (count >= h->nr_huge_pages)\n\t\t\t\tgoto out;\n\t\t\tif (PageHighMem(page))\n\t\t\t\tcontinue;\n\t\t\tremove_hugetlb_page(h, page, false);\n\t\t\tlist_add(&page->lru, &page_list);\n\t\t}\n\t}\nout:\n\tspin_unlock_irq(&hugetlb_lock);\n\tupdate_and_free_pages_bulk(h, &page_list);\n\tspin_lock_irq(&hugetlb_lock);\n}", "target": 0}
{"code": "static void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\tif (!msrs)\n\t\treturn;\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host);\n}", "target": 0}
{"code": "void bnx2x_igu_clear_sb_gen(struct bnx2x *bp, u8 func, u8 idu_sb_id, bool is_pf)\n{\n\tu32 data, ctl, cnt = 100;\n\tu32 igu_addr_data = IGU_REG_COMMAND_REG_32LSB_DATA;\n\tu32 igu_addr_ctl = IGU_REG_COMMAND_REG_CTRL;\n\tu32 igu_addr_ack = IGU_REG_CSTORM_TYPE_0_SB_CLEANUP + (idu_sb_id/32)*4;\n\tu32 sb_bit =  1 << (idu_sb_id%32);\n\tu32 func_encode = func | (is_pf ? 1 : 0) << IGU_FID_ENCODE_IS_PF_SHIFT;\n\tu32 addr_encode = IGU_CMD_E2_PROD_UPD_BASE + idu_sb_id;\n\tif (CHIP_INT_MODE_IS_BC(bp))\n\t\treturn;\n\tdata = (IGU_USE_REGISTER_cstorm_type_0_sb_cleanup\n\t\t\t<< IGU_REGULAR_CLEANUP_TYPE_SHIFT)\t|\n\t\tIGU_REGULAR_CLEANUP_SET\t\t\t\t|\n\t\tIGU_REGULAR_BCLEANUP;\n\tctl = addr_encode << IGU_CTRL_REG_ADDRESS_SHIFT\t\t|\n\t      func_encode << IGU_CTRL_REG_FID_SHIFT\t\t|\n\t      IGU_CTRL_CMD_TYPE_WR << IGU_CTRL_REG_TYPE_SHIFT;\n\tDP(NETIF_MSG_HW, \"write 0x%08x to IGU(via GRC) addr 0x%x\\n\",\n\t\t\t data, igu_addr_data);\n\tREG_WR(bp, igu_addr_data, data);\n\tmmiowb();\n\tbarrier();\n\tDP(NETIF_MSG_HW, \"write 0x%08x to IGU(via GRC) addr 0x%x\\n\",\n\t\t\t  ctl, igu_addr_ctl);\n\tREG_WR(bp, igu_addr_ctl, ctl);\n\tmmiowb();\n\tbarrier();\n\twhile (!(REG_RD(bp, igu_addr_ack) & sb_bit) && --cnt)\n\t\tmsleep(20);\n\tif (!(REG_RD(bp, igu_addr_ack) & sb_bit)) {\n\t\tDP(NETIF_MSG_HW,\n\t\t   \"Unable to finish IGU cleanup: idu_sb_id %d offset %d bit %d (cnt %d)\\n\",\n\t\t\t  idu_sb_id, idu_sb_id/32, idu_sb_id%32, cnt);\n\t}\n}", "target": 0}
{"code": "ProcCopyPlane(ClientPtr client)\n{\n    DrawablePtr psrcDraw, pdstDraw;\n    GC *pGC;\n    REQUEST(xCopyPlaneReq);\n    RegionPtr pRgn;\n    int rc;\n    REQUEST_SIZE_MATCH(xCopyPlaneReq);\n    VALIDATE_DRAWABLE_AND_GC(stuff->dstDrawable, pdstDraw, DixWriteAccess);\n    if (stuff->dstDrawable != stuff->srcDrawable) {\n        rc = dixLookupDrawable(&psrcDraw, stuff->srcDrawable, client, 0,\n                               DixReadAccess);\n        if (rc != Success)\n            return rc;\n        if (pdstDraw->pScreen != psrcDraw->pScreen) {\n            client->errorValue = stuff->dstDrawable;\n            return BadMatch;\n        }\n    }\n    else\n        psrcDraw = pdstDraw;\n    if (stuff->bitPlane == 0 || (stuff->bitPlane & (stuff->bitPlane - 1)) ||\n        (stuff->bitPlane > (1L << (psrcDraw->depth - 1)))) {\n        client->errorValue = stuff->bitPlane;\n        return BadValue;\n    }\n    pRgn =\n        (*pGC->ops->CopyPlane) (psrcDraw, pdstDraw, pGC, stuff->srcX,\n                                stuff->srcY, stuff->width, stuff->height,\n                                stuff->dstX, stuff->dstY, stuff->bitPlane);\n    if (pGC->graphicsExposures) {\n        SendGraphicsExpose(client, pRgn, stuff->dstDrawable, X_CopyPlane, 0);\n        if (pRgn)\n            RegionDestroy(pRgn);\n    }\n    return Success;\n}", "target": 0}
{"code": "static void get_cgdir_and_path(const char *cg, char **dir, char **file)\n{\n\tchar *p;\n\tdo {\n\t\t*dir = strdup(cg);\n\t} while (!*dir);\n\t*file = strrchr(cg, '/');\n\tif (!*file) {\n\t\t*file = NULL;\n\t\treturn;\n\t}\n\tp = strrchr(*dir, '/');\n\t*p = '\\0';\n}", "target": 0}
{"code": "static int show_stat_exec(const char *cmd, char * const *fields, int fields_cnt, void *client)\n{\n\tcli_send(client, \"pptp:\\r\\n\");\n\tcli_sendv(client,\"  starting: %u\\r\\n\", stat_starting);\n\tcli_sendv(client,\"  active: %u\\r\\n\", stat_active);\n\treturn CLI_CMD_OK;\n}", "target": 0}
{"code": "int zmq::stream_engine_t::process_identity_msg (msg_t *msg_)\n{\n    if (options.recv_identity) {\n        msg_->set_flags (msg_t::identity);\n        int rc = session->push_msg (msg_);\n        errno_assert (rc == 0);\n    }\n    else {\n        int rc = msg_->close ();\n        errno_assert (rc == 0);\n        rc = msg_->init ();\n        errno_assert (rc == 0);\n    }\n    if (subscription_required)\n        process_msg = &stream_engine_t::write_subscription_msg;\n    else\n        process_msg = &stream_engine_t::push_msg_to_session;\n    return 0;\n}", "target": 0}
{"code": "static ssize_t proc_fdinfo_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t len, loff_t *ppos)\n{\n\tchar tmp[PROC_FDINFO_MAX];\n\tint err = proc_fd_info(file->f_path.dentry->d_inode, NULL, NULL, tmp);\n\tif (!err)\n\t\terr = simple_read_from_buffer(buf, len, ppos, tmp, strlen(tmp));\n\treturn err;\n}", "target": 0}
{"code": "void SWFShape_useVersion(SWFShape shape, int version)\n{\n\tif(shape->useVersion >= version)\n\t\treturn;\n\tif(version > SWF_SHAPE4)\n\t\treturn;\n\tshape->useVersion = version;\n}", "target": 0}
{"code": "static bool nested_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tunsigned long always_on = VMXON_CR0_ALWAYSON;\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tif (to_vmx(vcpu)->nested.nested_vmx_secondary_ctls_high &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))\n\t\talways_on &= ~(X86_CR0_PE | X86_CR0_PG);\n\treturn (val & always_on) == always_on;\n}", "target": 0}
{"code": "SAPI_API int sapi_register_input_filter(unsigned int (*input_filter)(int arg, char *var, char **val, unsigned int val_len, unsigned int *new_val_len TSRMLS_DC), unsigned int (*input_filter_init)(TSRMLS_D) TSRMLS_DC)\n{\n\tif (SG(sapi_started) && EG(in_execution)) {\n\t\treturn FAILURE;\n\t}\n\tsapi_module.input_filter = input_filter;\n\tsapi_module.input_filter_init = input_filter_init;\n\treturn SUCCESS;\n}", "target": 0}
{"code": "static HashTable *date_object_get_gc(zval *object, zval ***table, int *n TSRMLS_DC)\n{\n\t*table = NULL;\n\t*n = 0;\n\treturn zend_std_get_properties(object TSRMLS_CC);", "target": 0}
{"code": "GF_Err trik_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_TrickPlayBox *ptr = (GF_TrickPlayBox *) s;\n\tptr->entry_count = (u32) ptr->size;\n\tif ((u64)ptr->entry_count > (u64)SIZE_MAX/sizeof(GF_TrickPlayBoxEntry)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Invalid size %llu in trik\\n\", ptr->size));\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tptr->entries = (GF_TrickPlayBoxEntry *) gf_malloc(ptr->entry_count * sizeof(GF_TrickPlayBoxEntry) );\n\tif (!ptr->entries) return GF_OUT_OF_MEM;\n\tfor (i=0; i< ptr->entry_count; i++) {\n\t\tptr->entries[i].pic_type = gf_bs_read_int(bs, 2);\n\t\tptr->entries[i].dependency_level = gf_bs_read_int(bs, 6);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "cd_device_db_remove (CdDeviceDb *ddb,\n\t\t     const gchar *device_id,\n\t\t     GError  **error)\n{\n\tCdDeviceDbPrivate *priv = GET_PRIVATE (ddb);\n\tgboolean ret = TRUE;\n\tgchar *error_msg = NULL;\n\tgchar *statement1 = NULL;\n\tgchar *statement2 = NULL;\n\tgint rc;\n\tg_return_val_if_fail (CD_IS_DEVICE_DB (ddb), FALSE);\n\tg_return_val_if_fail (priv->db != NULL, FALSE);\n\tg_debug (\"CdDeviceDb: remove device %s\", device_id);\n\tstatement1 = sqlite3_mprintf (\"DELETE FROM devices WHERE \"\n\t\t\t\t     \"device_id = '%q';\",\n\t\t\t\t     device_id);\n\trc = sqlite3_exec (priv->db, statement1, NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tg_set_error (error,\n\t\t\t     CD_CLIENT_ERROR,\n\t\t\t     CD_CLIENT_ERROR_INTERNAL,\n\t\t\t     \"SQL error: %s\",\n\t\t\t     error_msg);\n\t\tsqlite3_free (error_msg);\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\n\tstatement2 = sqlite3_mprintf (\"DELETE FROM properties_v2 WHERE \"\n\t\t\t\t     \"device_id = '%q';\",\n\t\t\t\t     device_id);\n\trc = sqlite3_exec (priv->db, statement2, NULL, NULL, &error_msg);\n\tif (rc != SQLITE_OK) {\n\t\tg_set_error (error,\n\t\t\t     CD_CLIENT_ERROR,\n\t\t\t     CD_CLIENT_ERROR_INTERNAL,\n\t\t\t     \"SQL error: %s\",\n\t\t\t     error_msg);\n\t\tsqlite3_free (error_msg);\n\t\tret = FALSE;\n\t\tgoto out;\n\t}\nout:\n\tsqlite3_free (statement1);\n\tsqlite3_free (statement2);\n\treturn ret;\n}", "target": 0}
{"code": "static void avrcp_handle_get_total_number_of_items(struct avrcp *session,\n\t\t\t\tstruct avrcp_browsing_header *pdu,\n\t\t\t\tuint8_t transaction)\n{\n\tuint8_t scope;\n\tuint8_t status = AVRCP_STATUS_SUCCESS;\n\tif (ntohs(pdu->param_len) != 1) {\n\t\tstatus = AVRCP_STATUS_INVALID_PARAM;\n\t\tgoto failed;\n\t}\n\tscope = pdu->params[0];\n\tswitch (scope) {\n\tcase AVRCP_SCOPE_MEDIA_PLAYER_LIST:\n\t\tavrcp_handle_media_player_list_num_items(session, pdu);\n\t\tbreak;\n\tcase AVRCP_SCOPE_MEDIA_PLAYER_VFS:\n\tcase AVRCP_SCOPE_SEARCH:\n\tcase AVRCP_SCOPE_NOW_PLAYING:\n\tdefault:\n\t\tstatus = AVRCP_STATUS_INVALID_SCOPE;\n\t\tgoto failed;\n\t}\n\treturn;\nfailed:\n\tpdu->params[0] = status;\n\tpdu->param_len = htons(1);\n}", "target": 0}
{"code": "vte_sequence_handler_ce (VteTerminal *terminal, GValueArray *params)\n{\n\tVteRowData *rowdata;\n\tVteScreen *screen;\n\tscreen = terminal->pvt->screen;\n\trowdata = _vte_terminal_ensure_row(terminal);\n\tg_assert(rowdata != NULL);\n\tif ((glong) _vte_row_data_length (rowdata) > screen->cursor_current.col) {\n\t\t_vte_row_data_shrink (rowdata, screen->cursor_current.col);\n\t\tterminal->pvt->text_deleted_flag = TRUE;\n\t}\n\tif (screen->fill_defaults.attr.back != VTE_DEF_BG) {\n\t\t_vte_row_data_fill (rowdata, &screen->fill_defaults, terminal->column_count);\n\t}\n\trowdata->attr.soft_wrapped = 0;\n\t_vte_invalidate_cells(terminal,\n\t\t\t      screen->cursor_current.col,\n\t\t\t      terminal->column_count -\n\t\t\t      screen->cursor_current.col,\n\t\t\t      screen->cursor_current.row, 1);\n}", "target": 0}
{"code": "bool use_server_socket(int fd, PgAddr *addr,\n\t\t       const char *dbname, const char *username,\n\t\t       uint64_t ckey, int oldfd, int linkfd,\n\t\t       const char *client_enc, const char *std_string,\n\t\t       const char *datestyle, const char *timezone)\n{\n\tPgDatabase *db = find_database(dbname);\n\tPgUser *user;\n\tPgPool *pool;\n\tPgSocket *server;\n\tPktBuf tmp;\n\tbool res;\n\tif (!db) {\n\t\tdb = register_auto_database(dbname);\n\t\tif (!db)\n\t\t\treturn true;\n\t}\n\tif (db->forced_user)\n\t\tuser = db->forced_user;\n\telse\n\t\tuser = find_user(username);\n\tpool = get_pool(db, user);\n\tif (!pool)\n\t\treturn false;\n\tserver = slab_alloc(server_cache);\n\tif (!server)\n\t\treturn false;\n\tres = sbuf_accept(&server->sbuf, fd, pga_is_unix(addr));\n\tif (!res)\n\t\treturn false;\n\tserver->suspended = 1;\n\tserver->pool = pool;\n\tserver->auth_user = user;\n\tserver->connect_time = server->request_time = get_cached_time();\n\tserver->query_start = 0;\n\tfill_remote_addr(server, fd, pga_is_unix(addr));\n\tfill_local_addr(server, fd, pga_is_unix(addr));\n\tif (linkfd) {\n\t\tserver->ready = 0;\n\t\tchange_server_state(server, SV_ACTIVE);\n\t} else {\n\t\tserver->ready = 1;\n\t\tchange_server_state(server, SV_IDLE);\n\t}\n\tpktbuf_static(&tmp, server->cancel_key, 8);\n\tpktbuf_put_uint64(&tmp, ckey);\n\tserver->tmp_sk_oldfd = oldfd;\n\tserver->tmp_sk_linkfd = linkfd;\n\tvarcache_set(&server->vars, \"client_encoding\", client_enc);\n\tvarcache_set(&server->vars, \"standard_conforming_strings\", std_string);\n\tvarcache_set(&server->vars, \"datestyle\", datestyle);\n\tvarcache_set(&server->vars, \"timezone\", timezone);\n\treturn true;\n}", "target": 0}
{"code": "static int ldb_match_present(struct ldb_context *ldb, \n\t\t\t     const struct ldb_message *msg,\n\t\t\t     const struct ldb_parse_tree *tree,\n\t\t\t     enum ldb_scope scope, bool *matched)\n{\n\tconst struct ldb_schema_attribute *a;\n\tstruct ldb_message_element *el;\n\tif (ldb_attr_dn(tree->u.present.attr) == 0) {\n\t\t*matched = true;\n\t\treturn LDB_SUCCESS;\n\t}\n\tel = ldb_msg_find_element(msg, tree->u.present.attr);\n\tif (el == NULL) {\n\t\t*matched = false;\n\t\treturn LDB_SUCCESS;\n\t}\n\ta = ldb_schema_attribute_by_name(ldb, el->name);\n\tif (!a) {\n\t\treturn LDB_ERR_INVALID_ATTRIBUTE_SYNTAX;\n\t}\n\tif (a->syntax->operator_fn) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < el->num_values; i++) {\n\t\t\tint ret = a->syntax->operator_fn(ldb, LDB_OP_PRESENT, a, &el->values[i], NULL, matched);\n\t\t\tif (ret != LDB_SUCCESS) return ret;\n\t\t\tif (*matched) return LDB_SUCCESS;\n\t\t}\n\t\t*matched = false;\n\t\treturn LDB_SUCCESS;\n\t}\n\t*matched = true;\n\treturn LDB_SUCCESS;\n}", "target": 0}
{"code": "static int resolve_map_arg_type(struct bpf_verifier_env *env,\n\t\t\t\t const struct bpf_call_arg_meta *meta,\n\t\t\t\t enum bpf_arg_type *arg_type)\n{\n\tif (!meta->map_ptr) {\n\t\tverbose(env, \"invalid map_ptr to access map->type\\n\");\n\t\treturn -EACCES;\n\t}\n\tswitch (meta->map_ptr->map_type) {\n\tcase BPF_MAP_TYPE_SOCKMAP:\n\tcase BPF_MAP_TYPE_SOCKHASH:\n\t\tif (*arg_type == ARG_PTR_TO_MAP_VALUE) {\n\t\t\t*arg_type = ARG_PTR_TO_BTF_ID_SOCK_COMMON;\n\t\t} else {\n\t\t\tverbose(env, \"invalid arg_type for sockmap/sockhash\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase BPF_MAP_TYPE_BLOOM_FILTER:\n\t\tif (meta->func_id == BPF_FUNC_map_peek_elem)\n\t\t\t*arg_type = ARG_PTR_TO_MAP_VALUE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "HiiValueToUINT64 (\n  IN EFI_HII_VALUE      *Value\n  )\n{\n  UINT64  RetVal;\n  RetVal = 0;\n  switch (Value->Type) {\n  case EFI_IFR_TYPE_NUM_SIZE_8:\n    RetVal = Value->Value.u8;\n    break;\n  case EFI_IFR_TYPE_NUM_SIZE_16:\n    RetVal = Value->Value.u16;\n    break;\n  case EFI_IFR_TYPE_NUM_SIZE_32:\n    RetVal = Value->Value.u32;\n    break;\n  case EFI_IFR_TYPE_BOOLEAN:\n    RetVal = Value->Value.b;\n    break;\n  case EFI_IFR_TYPE_DATE:\n    RetVal = *(UINT64*) &Value->Value.date;\n    break;\n  case EFI_IFR_TYPE_TIME:\n    RetVal = (*(UINT64*) &Value->Value.time) & 0xffffff;\n    break;\n  default:\n    RetVal = Value->Value.u64;\n    break;\n  }\n  return RetVal;\n}", "target": 0}
{"code": "static RELOC_PTRS_WITH(epo_reloc_ptrs, gx_device *dev)\n{\n    dev->parent = gx_device_reloc_ptr(dev->parent, gcst);\n    dev->child = gx_device_reloc_ptr(dev->child, gcst);\n}RELOC_PTRS_END", "target": 0}
{"code": "void RGWGetObjLayout_ObjStore_S3::send_response()\n{\n  if (op_ret)\n    set_req_state_err(s, op_ret);\n  dump_errno(s);\n  end_header(s, this, \"application/json\");\n  JSONFormatter f;\n  if (op_ret < 0) {\n    return;\n  }\n  f.open_object_section(\"result\");\n  ::encode_json(\"head\", head_obj, &f);\n  ::encode_json(\"manifest\", *manifest, &f);\n  f.open_array_section(\"data_location\");\n  for (auto miter = manifest->obj_begin(); miter != manifest->obj_end(); ++miter) {\n    f.open_object_section(\"obj\");\n    rgw_raw_obj raw_loc = miter.get_location().get_raw_obj(store->getRados());\n    uint64_t ofs = miter.get_ofs();\n    uint64_t left = manifest->get_obj_size() - ofs;\n    ::encode_json(\"ofs\", miter.get_ofs(), &f);\n    ::encode_json(\"loc\", raw_loc, &f);\n    ::encode_json(\"loc_ofs\", miter.location_ofs(), &f);\n    uint64_t loc_size = miter.get_stripe_size();\n    if (loc_size > left) {\n      loc_size = left;\n    }\n    ::encode_json(\"loc_size\", loc_size, &f);\n    f.close_section();\n    rgw_flush_formatter(s, &f);\n  }\n  f.close_section();\n  f.close_section();\n  rgw_flush_formatter(s, &f);\n}", "target": 0}
{"code": "bool PngImg::InBounds_(png_uint_32 offsetX, png_uint_32 offsetY, png_uint_32 width, png_uint_32 height) const\n{\n    return width != 0\n        && height != 0\n        && width <= info_.width\n        && height <= info_.height\n        && offsetX < info_.width\n        && offsetY < info_.height\n        && offsetX + width <= info_.width\n        && offsetY + height <= info_.height;\n}", "target": 0}
{"code": "static inline void skb_set_tail_pointer(struct sk_buff *skb, const int offset)\n{\n\tskb_reset_tail_pointer(skb);\n\tskb->tail += offset;\n}", "target": 0}
{"code": "static int opnot(RAsm *a, ut8 * data, const Opcode *op) {\n\tint l = 0;\n\tif(op->operands[0].reg == X86R_UNDEFINED)  {\n\t\treturn -1;\n\t}\n\tdata[l++] = 0xf7;\n\tdata[l++] = 0xd0 | op->operands[0].reg;\n\treturn l;\n}", "target": 0}
{"code": "bool generate_derived_keys(DYNAMIC_ARRAY *keyuse_array)\n{\n  KEYUSE *keyuse= dynamic_element(keyuse_array, 0, KEYUSE*);\n  uint elements= keyuse_array->elements;\n  TABLE *prev_table= 0;\n  for (uint i= 0; i < elements; i++, keyuse++)\n  {\n    if (!keyuse->table)\n      break;\n    KEYUSE *first_table_keyuse= NULL;\n    table_map last_used_tables= 0;\n    uint count= 0;\n    uint keys= 0;\n    TABLE_LIST *derived= NULL;\n    if (keyuse->table != prev_table)\n      derived= keyuse->table->pos_in_table_list;\n    while (derived && derived->is_materialized_derived())\n    {\n      if (keyuse->table != prev_table)\n      {\n        prev_table= keyuse->table;\n        while (keyuse->table == prev_table && keyuse->key != MAX_KEY)\n\t{\n          keyuse++;\n          i++;\n        }\n        if (keyuse->table != prev_table)\n\t{\n          keyuse--;\n          i--;\n          derived= NULL;\n          continue;\n        }\n        first_table_keyuse= keyuse;\n        last_used_tables= keyuse->used_tables;\n        count= 0;\n        keys= 0;\n      }\n      else if (keyuse->used_tables != last_used_tables)\n      {\n        keys++;\n        last_used_tables= keyuse->used_tables;\n      }\n      count++;\n      keyuse++;\n      i++;\n      if (keyuse->table != prev_table)\n      {\n        if (generate_derived_keys_for_table(first_table_keyuse, count, ++keys))\n          return TRUE;\n        keyuse--;\n        i--;\n\tderived= NULL;\n      }\n    }\n  }\n  return FALSE;\n}", "target": 0}
{"code": "static MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *magick_unused(encoding),const PointInfo *offset,\n  TypeMetric *metrics)\n{\n  (void) ThrowMagickException(&image->exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (Freetype)\",\n    draw_info->font != (char *) NULL ? draw_info->font : \"none\");\n  return(RenderPostscript(image,draw_info,offset,metrics));\n}", "target": 0}
{"code": "static int rfcomm_sock_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct sock *sk;\n\tstruct hlist_node *node;\n\tread_lock(&rfcomm_sk_list.lock);\n\tsk_for_each(sk, node, &rfcomm_sk_list.head) {\n\t\tseq_printf(f, \"%s %s %d %d\\n\",\n\t\t\t\tbatostr(&bt_sk(sk)->src),\n\t\t\t\tbatostr(&bt_sk(sk)->dst),\n\t\t\t\tsk->sk_state, rfcomm_pi(sk)->channel);\n\t}\n\tread_unlock(&rfcomm_sk_list.lock);\n\treturn 0;\n}", "target": 0}
{"code": "reset_state_machine (int is_stmt)\n{\n  state_machine_regs.address = 0;\n  state_machine_regs.view = 0;\n  state_machine_regs.op_index = 0;\n  state_machine_regs.file = 1;\n  state_machine_regs.line = 1;\n  state_machine_regs.column = 0;\n  state_machine_regs.is_stmt = is_stmt;\n  state_machine_regs.basic_block = 0;\n  state_machine_regs.end_sequence = 0;\n  state_machine_regs.last_file_entry = 0;\n}", "target": 0}
{"code": "void AutoFillManager::RegisterUserPrefs(PrefService* prefs) {\n  prefs->RegisterBooleanPref(prefs::kAutoFillEnabled, true);\n#if defined(OS_MACOSX)\n  prefs->RegisterBooleanPref(prefs::kAutoFillAuxiliaryProfilesEnabled, true);\n#else\n  prefs->RegisterBooleanPref(prefs::kAutoFillAuxiliaryProfilesEnabled, false);\n#endif\n  prefs->RegisterRealPref(prefs::kAutoFillPositiveUploadRate,\n                          kAutoFillPositiveUploadRateDefaultValue);\n  prefs->RegisterRealPref(prefs::kAutoFillNegativeUploadRate,\n                          kAutoFillNegativeUploadRateDefaultValue);\n}", "target": 0}
{"code": "nsim_xdp_set_prog(struct netdevsim *ns, struct netdev_bpf *bpf,\n\t\t  struct xdp_attachment_info *xdp)\n{\n\tint err;\n\tif (bpf->command == XDP_SETUP_PROG && !ns->bpf_xdpdrv_accept) {\n\t\tNSIM_EA(bpf->extack, \"driver XDP disabled in DebugFS\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (bpf->command == XDP_SETUP_PROG_HW && !ns->bpf_xdpoffload_accept) {\n\t\tNSIM_EA(bpf->extack, \"XDP offload disabled in DebugFS\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (bpf->command == XDP_SETUP_PROG_HW) {\n\t\terr = nsim_xdp_offload_prog(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\txdp_attachment_setup(xdp, bpf);\n\treturn 0;\n}", "target": 0}
{"code": "static const char *req_user_field(request_rec *r)\n{\n    return r->user;\n}", "target": 0}
{"code": "static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n\t\t\tdev_put(llc->dev);\n\t\t\tllc->dev = NULL;\n\t\t}\n\t} else\n\t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; \n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\tif (rc) {\n\t\tdev_put_track(llc->dev, &llc->dev_tracker);\n\t\tllc->dev = NULL;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "dissect_ac_if_hdr_body(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,\n        proto_tree *tree, usb_conv_info_t *usb_conv_info)\n{\n    gint     offset_start;\n    guint16  bcdADC;\n    guint8   ver_major;\n    double   ver;\n    guint8   if_in_collection, i;\n    audio_conv_info_t *audio_conv_info;\n    offset_start = offset;\n    bcdADC = tvb_get_letohs(tvb, offset);\n    ver_major = USB_AUDIO_BCD44_TO_DEC(bcdADC>>8);\n    ver = ver_major + USB_AUDIO_BCD44_TO_DEC(bcdADC&0xFF) / 100.0;\n    proto_tree_add_double_format_value(tree, hf_ac_if_hdr_ver,\n            tvb, offset, 2, ver, \"%2.2f\", ver);\n    audio_conv_info = (audio_conv_info_t *)usb_conv_info->class_data;\n    if(!audio_conv_info) {\n        audio_conv_info = wmem_new(wmem_file_scope(), audio_conv_info_t);\n        usb_conv_info->class_data = audio_conv_info;\n        usb_conv_info->class_data_type = USB_CONV_AUDIO;\n    } else if (usb_conv_info->class_data_type != USB_CONV_AUDIO) {\n        return 0;\n    }\n    audio_conv_info->ver_major = ver_major;\n    offset += 2;\n    if (ver_major==1) {\n        proto_tree_add_item(tree, hf_ac_if_hdr_total_len,\n                tvb, offset, 2, ENC_LITTLE_ENDIAN);\n        offset += 2;\n        if_in_collection = tvb_get_guint8(tvb, offset);\n        proto_tree_add_item(tree, hf_ac_if_hdr_bInCollection,\n                tvb, offset, 1, ENC_LITTLE_ENDIAN);\n        offset++;\n        for (i=0; i<if_in_collection; i++) {\n            proto_tree_add_item(tree, hf_ac_if_hdr_if_num,\n                    tvb, offset, 1, ENC_LITTLE_ENDIAN);\n            offset++;\n        }\n    }\n    return offset-offset_start;\n}", "target": 0}
{"code": "void NetworkActionPredictor::DeleteOldIdsFromCaches(\n    history::URLDatabase* url_db,\n    std::vector<NetworkActionPredictorDatabase::Row::Id>* id_list) {\n  CHECK(content::BrowserThread::CurrentlyOn(content::BrowserThread::UI));\n  DCHECK(url_db);\n  DCHECK(id_list);\n  id_list->clear();\n  for (DBCacheMap::iterator it = db_cache_.begin(); it != db_cache_.end();) {\n    history::URLRow url_row;\n    if ((url_db->GetRowForURL(it->first.url, &url_row) == 0) ||\n        ((base::Time::Now() - url_row.last_visit()).InDays() >\n         kMaximumDaysToKeepEntry)) {\n      const DBIdCacheMap::iterator id_it = db_id_cache_.find(it->first);\n      DCHECK(id_it != db_id_cache_.end());\n      id_list->push_back(id_it->second);\n      db_id_cache_.erase(id_it);\n      db_cache_.erase(it++);\n    } else {\n      ++it;\n    }\n  }\n}", "target": 0}
{"code": "GF_Err csgp_box_size(GF_Box *s)\n{\n\tu32 i, bits;\n\tGF_CompactSampleGroupBox *ptr = (GF_CompactSampleGroupBox*)s;\n\tu32 pattern_size = get_size_by_code( ((ptr->flags>>4) & 0x3) );\n\tu32 scount_size = get_size_by_code( ((ptr->flags>>2) & 0x3) );\n\tu32 index_size = get_size_by_code( (ptr->flags & 0x3) );\n\tptr->size += 12; \n\tif (ptr->flags & (1<<6))\n\t\tptr->size+=4;\n\tptr->size += ptr->pattern_count * (pattern_size + scount_size) / 8;\n\tbits=0;\n\tfor (i=0; i<ptr->pattern_count; i++)\n\t\tbits += ptr->patterns[i].length * index_size;\n\tptr->size += bits/8;\n\tif (bits % 8) ptr->size++;\n\treturn GF_OK;\n}", "target": 0}
{"code": "build_overlap_sched_groups(struct sched_domain *sd, int cpu)\n{\n\tstruct sched_group *first = NULL, *last = NULL, *groups = NULL, *sg;\n\tconst struct cpumask *span = sched_domain_span(sd);\n\tstruct cpumask *covered = sched_domains_tmpmask;\n\tstruct sd_data *sdd = sd->private;\n\tstruct sched_domain *sibling;\n\tint i;\n\tcpumask_clear(covered);\n\tfor_each_cpu(i, span) {\n\t\tstruct cpumask *sg_span;\n\t\tif (cpumask_test_cpu(i, covered))\n\t\t\tcontinue;\n\t\tsibling = *per_cpu_ptr(sdd->sd, i);\n\t\tif (!cpumask_test_cpu(i, sched_domain_span(sibling)))\n\t\t\tcontinue;\n\t\tsg = kzalloc_node(sizeof(struct sched_group) + cpumask_size(),\n\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\t\tif (!sg)\n\t\t\tgoto fail;\n\t\tsg_span = sched_group_cpus(sg);\n\t\tif (sibling->child)\n\t\t\tcpumask_copy(sg_span, sched_domain_span(sibling->child));\n\t\telse\n\t\t\tcpumask_set_cpu(i, sg_span);\n\t\tcpumask_or(covered, covered, sg_span);\n\t\tsg->sgc = *per_cpu_ptr(sdd->sgc, i);\n\t\tif (atomic_inc_return(&sg->sgc->ref) == 1)\n\t\t\tbuild_group_mask(sd, sg);\n\t\tsg->sgc->capacity = SCHED_CAPACITY_SCALE * cpumask_weight(sg_span);\n\t\tif ((!groups && cpumask_test_cpu(cpu, sg_span)) ||\n\t\t    group_balance_cpu(sg) == cpu)\n\t\t\tgroups = sg;\n\t\tif (!first)\n\t\t\tfirst = sg;\n\t\tif (last)\n\t\t\tlast->next = sg;\n\t\tlast = sg;\n\t\tlast->next = first;\n\t}\n\tsd->groups = groups;\n\treturn 0;\nfail:\n\tfree_sched_groups(first, 0);\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "    float getGamma() const CV_OVERRIDE { return gamma; }", "target": 0}
{"code": "static int vmci_transport_dgram_bind(struct vsock_sock *vsk,\n\t\t\t\t     struct sockaddr_vm *addr)\n{\n\tu32 port;\n\tu32 flags;\n\tint err;\n\tport = addr->svm_port == VMADDR_PORT_ANY ?\n\t\t\tVMCI_INVALID_ID : addr->svm_port;\n\tif (port <= LAST_RESERVED_PORT && !capable(CAP_NET_BIND_SERVICE))\n\t\treturn -EACCES;\n\tflags = addr->svm_cid == VMADDR_CID_ANY ?\n\t\t\t\tVMCI_FLAG_ANYCID_DG_HND : 0;\n\terr = vmci_transport_datagram_create_hnd(port, flags,\n\t\t\t\t\t\t vmci_transport_recv_dgram_cb,\n\t\t\t\t\t\t &vsk->sk,\n\t\t\t\t\t\t &vmci_trans(vsk)->dg_handle);\n\tif (err < VMCI_SUCCESS)\n\t\treturn vmci_transport_error_to_vsock_error(err);\n\tvsock_addr_init(&vsk->local_addr, addr->svm_cid,\n\t\t\tvmci_trans(vsk)->dg_handle.resource);\n\treturn 0;\n}", "target": 0}
{"code": "void qemu_flush_or_purge_queued_packets(NetClientState *nc, bool purge)\n{\n    nc->receive_disabled = 0;\n    if (nc->peer && nc->peer->info->type == NET_CLIENT_DRIVER_HUBPORT) {\n        if (net_hub_flush(nc->peer)) {\n            qemu_notify_event();\n        }\n    }\n    if (qemu_net_queue_flush(nc->incoming_queue)) {\n        qemu_notify_event();\n    } else if (purge) {\n        qemu_net_queue_purge(nc->incoming_queue, nc);\n    }\n}", "target": 0}
{"code": "static int rxrpc_krb5_decode_tagged_array(struct krb5_tagged_data **_td,\n\t\t\t\t\t  u8 *_n_elem,\n\t\t\t\t\t  u8 max_n_elem,\n\t\t\t\t\t  size_t max_elem_size,\n\t\t\t\t\t  const __be32 **_xdr,\n\t\t\t\t\t  unsigned int *_toklen)\n{\n\tstruct krb5_tagged_data *td;\n\tconst __be32 *xdr = *_xdr;\n\tunsigned int toklen = *_toklen, n_elem, loop;\n\tint ret;\n\tif (toklen < 4)\n\t\treturn -EINVAL;\n\t_enter(\",,%u,%zu,{%x},%u\",\n\t       max_n_elem, max_elem_size, ntohl(xdr[0]), toklen);\n\tn_elem = ntohl(*xdr++);\n\ttoklen -= 4;\n\tif (n_elem < 0 || n_elem > max_n_elem)\n\t\treturn -EINVAL;\n\t*_n_elem = n_elem;\n\tif (n_elem > 0) {\n\t\tif (toklen <= (n_elem + 1) * 4)\n\t\t\treturn -EINVAL;\n\t\t_debug(\"n_elem %d\", n_elem);\n\t\ttd = kcalloc(n_elem, sizeof(struct krb5_tagged_data),\n\t\t\t     GFP_KERNEL);\n\t\tif (!td)\n\t\t\treturn -ENOMEM;\n\t\t*_td = td;\n\t\tfor (loop = 0; loop < n_elem; loop++) {\n\t\t\tret = rxrpc_krb5_decode_tagged_data(&td[loop],\n\t\t\t\t\t\t\t    max_elem_size,\n\t\t\t\t\t\t\t    &xdr, &toklen);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\t*_xdr = xdr;\n\t*_toklen = toklen;\n\t_leave(\" = 0 [toklen=%u]\", toklen);\n\treturn 0;\n}", "target": 0}
{"code": "static void vnc_zrle_start(VncState *vs)\n{\n    buffer_reset(&vs->zrle->zrle);\n    vs->zrle->tmp = vs->output;\n    vs->output = vs->zrle->zrle;\n}", "target": 0}
{"code": "coolkey_make_new_id(unsigned long object_id, unsigned long id_type)\n{ return ((object_id  & 0x00ffffffUL)|(id_type << 24)); }", "target": 0}
{"code": "void RenderView::OnToggleSpellCheck() {\n  if (!webview())\n    return;\n  WebFrame* frame = webview()->focusedFrame();\n  frame->enableContinuousSpellChecking(\n      !frame->isContinuousSpellCheckingEnabled());\n}", "target": 0}
{"code": "entering_window(win_T *win)\n{\n    if (!bt_prompt(win->w_buffer))\n\treturn;\n    if (win->w_buffer->b_prompt_insert != NUL)\n\tstop_insert_mode = FALSE;\n    if ((State & INSERT) == 0)\n\trestart_edit = win->w_buffer->b_prompt_insert;\n}", "target": 0}
{"code": "ha_rows JOIN_TAB::get_examined_rows()\n{\n  double examined_rows;\n  SQL_SELECT *sel= filesort? filesort->select : this->select;\n  if (sel && sel->quick && use_quick != 2)\n    examined_rows= (double)sel->quick->records;\n  else if (type == JT_NEXT || type == JT_ALL ||\n           type == JT_HASH || type ==JT_HASH_NEXT)\n  {\n    if (limit)\n    {\n      examined_rows= (double)limit;\n    }\n    else\n    {\n      if (table->is_filled_at_execution())\n        examined_rows= (double)records;\n      else\n      {\n        examined_rows= (double)table->stat_records();\n      }\n    }\n  }\n  else\n    examined_rows= records_read;\n  if (examined_rows >= (double) HA_ROWS_MAX)\n    return HA_ROWS_MAX;\n  return (ha_rows) examined_rows;\n}", "target": 0}
{"code": "struct pending_message_list *get_open_deferred_message(uint16 mid)\n{\n\tstruct pending_message_list *pml;\n\tfor (pml = deferred_open_queue; pml; pml = pml->next) {\n\t\tif (SVAL(pml->buf.data,smb_mid) == mid) {\n\t\t\treturn pml;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "ipa_get_jf_pass_through_result (struct ipa_jump_func *jfunc, tree input,\n\t\t\t\ttree res_type)\n{\n  return ipa_get_jf_arith_result (ipa_get_jf_pass_through_operation (jfunc),\n\t\t\t\t  input,\n\t\t\t\t  ipa_get_jf_pass_through_operand (jfunc),\n\t\t\t\t  res_type);\n}", "target": 0}
{"code": "static void fuse_lib_flush(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    char *path;\n    int err;\n    pthread_rwlock_rdlock(&f->tree_lock);\n    path = get_path(f, ino);\n    if (path && f->conf.debug)\n        fprintf(stderr, \"FLUSH[%llu]\\n\", (unsigned long long) fi->fh);\n    err = fuse_flush_common(f, req, ino, path, fi);\n    free(path);\n    pthread_rwlock_unlock(&f->tree_lock);\n    reply_err(req, err);\n}", "target": 0}
{"code": "int vcc_setsockopt(struct socket *sock, int level, int optname,\n\t\t   char __user *optval, unsigned int optlen)\n{\n\tstruct atm_vcc *vcc;\n\tunsigned long value;\n\tint error;\n\tif (__SO_LEVEL_MATCH(optname, level) && optlen != __SO_SIZE(optname))\n\t\treturn -EINVAL;\n\tvcc = ATM_SD(sock);\n\tswitch (optname) {\n\tcase SO_ATMQOS:\n\t{\n\t\tstruct atm_qos qos;\n\t\tif (copy_from_user(&qos, optval, sizeof(qos)))\n\t\t\treturn -EFAULT;\n\t\terror = check_qos(&qos);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (sock->state == SS_CONNECTED)\n\t\t\treturn atm_change_qos(vcc, &qos);\n\t\tif (sock->state != SS_UNCONNECTED)\n\t\t\treturn -EBADFD;\n\t\tvcc->qos = qos;\n\t\tset_bit(ATM_VF_HASQOS, &vcc->flags);\n\t\treturn 0;\n\t}\n\tcase SO_SETCLP:\n\t\tif (get_user(value, (unsigned long __user *)optval))\n\t\t\treturn -EFAULT;\n\t\tif (value)\n\t\t\tvcc->atm_options |= ATM_ATMOPT_CLP;\n\t\telse\n\t\t\tvcc->atm_options &= ~ATM_ATMOPT_CLP;\n\t\treturn 0;\n\tdefault:\n\t\tif (level == SOL_SOCKET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tif (!vcc->dev || !vcc->dev->ops->setsockopt)\n\t\treturn -EINVAL;\n\treturn vcc->dev->ops->setsockopt(vcc, level, optname, optval, optlen);\n}", "target": 0}
{"code": "static void dp8393x_do_stop_timer(dp8393xState *s)\n{\n    s->regs[SONIC_CR] &= ~SONIC_CR_ST;\n    dp8393x_update_wt_regs(s);\n}", "target": 0}
{"code": "XML_SetUnparsedEntityDeclHandler(XML_Parser parser,\n                                 XML_UnparsedEntityDeclHandler handler) {\n  if (parser != NULL)\n    parser->m_unparsedEntityDeclHandler = handler;\n}", "target": 0}
{"code": "static void _pam_log(struct pwb_context *r, int err, const char *format, ...)\n{\n\tva_list args;\n\tif (_pam_log_is_silent(r->ctrl)) {\n\t\treturn;\n\t}\n\tva_start(args, format);\n\t_pam_log_int(r->pamh, err, format, args);\n\tva_end(args);\n}", "target": 0}
{"code": "const AtomicString& HTMLKeygenElement::formControlType() const\n{\n    DEFINE_STATIC_LOCAL(const AtomicString, keygen, (\"keygen\", AtomicString::ConstructFromLiteral));\n    return keygen;\n}", "target": 0}
{"code": "void wake_up_q(struct wake_q_head *head)\n{\n\tstruct wake_q_node *node = head->first;\n\twhile (node != WAKE_Q_TAIL) {\n\t\tstruct task_struct *task;\n\t\ttask = container_of(node, struct task_struct, wake_q);\n\t\tBUG_ON(!task);\n\t\tnode = node->next;\n\t\ttask->wake_q.next = NULL;\n\t\twake_up_process(task);\n\t\tput_task_struct(task);\n\t}\n}", "target": 0}
{"code": "zxcheck(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    check_op(1);\n    make_bool(op, (r_has_attr(ACCESS_REF(op), a_executable) ? 1 : 0));\n    return 0;\n}", "target": 0}
{"code": "static void vmci_transport_set_max_buffer_size(struct vsock_sock *vsk,\n\t\t\t\t\t       u64 val)\n{\n\tif (val < vmci_trans(vsk)->queue_pair_size)\n\t\tvmci_trans(vsk)->queue_pair_size = val;\n\tvmci_trans(vsk)->queue_pair_max_size = val;\n}", "target": 0}
{"code": "static void intel_engine_context_in(struct intel_engine_cs *engine)\n{\n\tunsigned long flags;\n\tif (READ_ONCE(engine->stats.enabled) == 0)\n\t\treturn;\n\twrite_seqlock_irqsave(&engine->stats.lock, flags);\n\tif (engine->stats.enabled > 0) {\n\t\tif (engine->stats.active++ == 0)\n\t\t\tengine->stats.start = ktime_get();\n\t\tGEM_BUG_ON(engine->stats.active == 0);\n\t}\n\twrite_sequnlock_irqrestore(&engine->stats.lock, flags);\n}", "target": 0}
{"code": "void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,4);\n                l_src_data+=sizeof(OPJ_INT32);\n                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;\n        }\n}", "target": 0}
{"code": "void OmniboxViewWin::PasteAndGo(const string16& text) {\n  if (CanPasteAndGo(text))\n    model_->PasteAndGo();\n}", "target": 0}
{"code": "read_pri(unsigned int *pri, const char *buf, char **end)\n{\n    char *tend;\n    unsigned int tpri;\n    errno = 0;\n    while (buf[0] == ' ') buf++;\n    if (!isdigit(buf[0])) return -1;\n    tpri = strtoul(buf, &tend, 10);\n    if (tend == buf) return -1;\n    if (errno && errno != ERANGE) return -1;\n    if (!end && tend[0] != '\\0') return -1;\n    if (pri) *pri = tpri;\n    if (end) *end = tend;\n    return 0;\n}", "target": 0}
{"code": "GF_DefaultSampleGroupDescriptionEntry * gf_isom_get_sample_group_info_entry(GF_ISOFile *the_file, GF_TrackBox *trak, u32 grouping_type, u32 sample_group_description_index, u32 *default_index, GF_SampleGroupDescriptionBox **out_sgdp)\n{\n\tu32 i, count;\n\tif (!trak || !sample_group_description_index) return NULL;\n\tif (!trak->Media->information->sampleTable->sampleGroupsDescription) return NULL;\n\tcount = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription);\n\tfor (i=0; i<count; i++) {\n\t\tGF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i);\n\t\tif (sgdesc->grouping_type != grouping_type) continue;\n\t\tif (sgdesc->default_description_index && !sample_group_description_index) sample_group_description_index = sgdesc->default_description_index;\n\t\tif (default_index) *default_index = sgdesc->default_description_index ;\n\t\tif (out_sgdp) *out_sgdp = sgdesc;\n\t\tif (!sample_group_description_index) return NULL;\n\t\treturn (GF_DefaultSampleGroupDescriptionEntry*)gf_list_get(sgdesc->group_descriptions, sample_group_description_index-1);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "asmlinkage long sys_settimeofday(struct timeval __user *tv,\n\t\t\t\tstruct timezone __user *tz)\n{\n\tstruct timeval user_tv;\n\tstruct timespec\tnew_ts;\n\tstruct timezone new_tz;\n\tif (tv) {\n\t\tif (copy_from_user(&user_tv, tv, sizeof(*tv)))\n\t\t\treturn -EFAULT;\n\t\tnew_ts.tv_sec = user_tv.tv_sec;\n\t\tnew_ts.tv_nsec = user_tv.tv_usec * NSEC_PER_USEC;\n\t}\n\tif (tz) {\n\t\tif (copy_from_user(&new_tz, tz, sizeof(*tz)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn do_sys_settimeofday(tv ? &new_ts : NULL, tz ? &new_tz : NULL);\n}", "target": 0}
{"code": "  void addCopy(const LowerCaseString& key, uint64_t value) override {\n    HeaderMapImpl::addCopy(key, value);\n  }", "target": 0}
{"code": "DECLAREContigPutFunc(putcontig8bitYCbCr21tile)\n{\n\t(void) y;\n\tfromskew = (fromskew * 4) / 2;\n\tdo {\n\t\tx = w>>1;\n\t\twhile(x>0) {\n\t\t\tint32 Cb = pp[2];\n\t\t\tint32 Cr = pp[3];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tYCbCrtoRGB(cp[1], pp[1]);\n\t\t\tcp += 2;\n\t\t\tpp += 4;\n\t\t\tx --;\n\t\t}\n\t\tif( (w&1) != 0 )\n\t\t{\n\t\t\tint32 Cb = pp[2];\n\t\t\tint32 Cr = pp[3];\n\t\t\tYCbCrtoRGB(cp[0], pp[0]);\n\t\t\tcp += 1;\n\t\t\tpp += 4;\n\t\t}\n\t\tcp += toskew;\n\t\tpp += fromskew;\n\t} while (--h);\n}", "target": 0}
{"code": "envoy::config::cluster::v3::Cluster ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits(\n    const std::string& name, int port, const std::string& address, const std::string& lb_policy) {\n  return TestUtility::parseYaml<envoy::config::cluster::v3::Cluster>(\n      fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 50s\n      type: STATIC\n      circuit_breakers:\n        thresholds:\n        - priority: DEFAULT\n          max_connections: 10000\n          max_pending_requests: 10000\n          max_requests: 10000\n          max_retries: 10000\n      load_assignment:\n        cluster_name: {}\n        endpoints:\n        - lb_endpoints:\n          - endpoint:\n              address:\n                socket_address:\n                  address: {}\n                  port_value: {}\n      lb_policy: {}\n    )EOF\",\n                  name, name, address, port, lb_policy));\n}", "target": 0}
{"code": "static void bnx2x_period_task(struct work_struct *work)\n{\n\tstruct bnx2x *bp = container_of(work, struct bnx2x, period_task.work);\n\tif (!netif_running(bp->dev))\n\t\tgoto period_task_exit;\n\tif (CHIP_REV_IS_SLOW(bp)) {\n\t\tBNX2X_ERR(\"period task called on emulation, ignoring\\n\");\n\t\tgoto period_task_exit;\n\t}\n\tbnx2x_acquire_phy_lock(bp);\n\tsmp_mb();\n\tif (bp->port.pmf) {\n\t\tbnx2x_period_func(&bp->link_params, &bp->link_vars);\n\t\tqueue_delayed_work(bnx2x_wq, &bp->period_task, 1*HZ);\n\t}\n\tbnx2x_release_phy_lock(bp);\nperiod_task_exit:\n\treturn;\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_values,\n                         const Variant& input) {\n  return tvReturn(array_values(input));\n}", "target": 0}
{"code": "  void dumpState(std::ostream& os, int indent_level = 0) const override {\n    HeaderMapImpl::dumpState(os, indent_level);\n  }", "target": 0}
{"code": "void cql_server::connection::handle_error(future<>&& f) {\n    try {\n        f.get();\n    } catch (const exceptions::cassandra_exception& ex) {\n        try { ++_server._stats.errors[ex.code()]; } catch(...) {}\n        write_response(make_error(0, ex.code(), ex.what(), tracing::trace_state_ptr()));\n    } catch (std::exception& ex) {\n        try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}\n        write_response(make_error(0, exceptions::exception_code::SERVER_ERROR, ex.what(), tracing::trace_state_ptr()));\n    } catch (...) {\n        try { ++_server._stats.errors[exceptions::exception_code::SERVER_ERROR]; } catch(...) {}\n        write_response(make_error(0, exceptions::exception_code::SERVER_ERROR, \"unknown error\", tracing::trace_state_ptr()));\n    }\n}", "target": 0}
{"code": "lvm2_lv_create_found_device (Device *device,\n                             CreateLvm2LVData *data)\n{\n  if (strlen (data->fstype) > 0)\n    {\n      device_filesystem_create_internal (device,\n                                         data->fstype,\n                                         data->fsoptions,\n                                         lvm2_lv_create_filesystem_create_hook,\n                                         NULL,\n                                         data->context);\n    }\n  else\n    {\n      dbus_g_method_return (data->context, device->priv->object_path);\n    }\n}", "target": 0}
{"code": "SPL_METHOD(SplObjectStorage, serialize)\n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_SplObjectStorageElement *element;\n\tzval members, *pmembers, *flags;\n\tHashPosition      pos;\n\tphp_serialize_data_t var_hash;\n\tsmart_str buf = {0};\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tPHP_VAR_SERIALIZE_INIT(var_hash);\n\tsmart_str_appendl(&buf, \"x:\", 2);\n\tMAKE_STD_ZVAL(flags);\n\tZVAL_LONG(flags, zend_hash_num_elements(&intern->storage));\n\tphp_var_serialize(&buf, &flags, &var_hash TSRMLS_CC);\n\tzval_ptr_dtor(&flags);\n\tzend_hash_internal_pointer_reset_ex(&intern->storage, &pos);\n\twhile(zend_hash_has_more_elements_ex(&intern->storage, &pos) == SUCCESS) {\n\t\tif (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &pos) == FAILURE) {\n\t\t\tsmart_str_free(&buf);\n\t\t\tPHP_VAR_SERIALIZE_DESTROY(var_hash);\n\t\t\tRETURN_NULL();\n\t\t}\n\t\tphp_var_serialize(&buf, &element->obj, &var_hash TSRMLS_CC);\n\t\tsmart_str_appendc(&buf, ',');\n\t\tphp_var_serialize(&buf, &element->inf, &var_hash TSRMLS_CC);\n\t\tsmart_str_appendc(&buf, ';');\n\t\tzend_hash_move_forward_ex(&intern->storage, &pos);\n\t}\n\tsmart_str_appendl(&buf, \"m:\", 2);\n\tINIT_PZVAL(&members);\n\tZ_ARRVAL(members) = zend_std_get_properties(getThis() TSRMLS_CC);\n\tZ_TYPE(members) = IS_ARRAY;\n\tpmembers = &members;\n\tphp_var_serialize(&buf, &pmembers, &var_hash TSRMLS_CC); \n\tPHP_VAR_SERIALIZE_DESTROY(var_hash);\n\tif (buf.c) {\n\t\tRETURN_STRINGL(buf.c, buf.len, 0);\n\t} else {\n\t\tRETURN_NULL();\n\t}\n} ", "target": 0}
{"code": "static int vhost_user_set_log_fd(struct virtio_net **pdev __rte_unused,\n\t\t\tstruct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tif (validate_msg_fds(msg, 1) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\tclose(msg->fds[0]);\n\tVHOST_LOG_CONFIG(INFO, \"not implemented.\\n\");\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "  void set_simulator_i_cache(HashMap* hash_map) {\n    simulator_i_cache_ = hash_map;\n  }", "target": 0}
{"code": "memen(struct pci_vdev *dev)\n{\n\tuint16_t cmd;\n\tcmd = pci_get_cfgdata16(dev, PCIR_COMMAND);\n\treturn (cmd & PCIM_CMD_MEMEN);\n}", "target": 0}
{"code": "Item* Item::cache_const_expr_transformer(uchar *arg)\n{\n  if (*(bool*)arg)\n  {\n    *((bool*)arg)= FALSE;\n    Item_cache *cache= Item_cache::get_cache(this);\n    if (!cache)\n      return NULL;\n    cache->setup(this);\n    cache->store(this);\n    return cache;\n  }\n  return this;\n}", "target": 0}
{"code": "vmci_transport_datagram_create_hnd(u32 resource_id,\n\t\t\t\t   u32 flags,\n\t\t\t\t   vmci_datagram_recv_cb recv_cb,\n\t\t\t\t   void *client_data,\n\t\t\t\t   struct vmci_handle *out_handle)\n{\n\tint err = 0;\n\terr = vmci_datagram_create_handle_priv(resource_id, flags,\n\t\t\t\t\t       VMCI_PRIVILEGE_FLAG_TRUSTED,\n\t\t\t\t\t       recv_cb,\n\t\t\t\t\t       client_data, out_handle);\n\tif (err == VMCI_ERROR_NO_ACCESS)\n\t\terr = vmci_datagram_create_handle(resource_id, flags,\n\t\t\t\t\t\t  recv_cb, client_data,\n\t\t\t\t\t\t  out_handle);\n\treturn err;\n}", "target": 0}
{"code": "static int hunk_cb(\n\tconst git_diff_delta *delta,\n\tconst git_diff_hunk *hunk,\n\tvoid *payload)\n{\n\tGIT_UNUSED(delta);\n\tGIT_UNUSED(hunk);\n\tGIT_UNUSED(payload);\n\tcl_fail(\"did not expect hunk callback\");\n\treturn 0;\n}", "target": 0}
{"code": "int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,\n\t\t     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)\n{\n\tint8_t etype;\n\tunsigned int indirections = 0;\n\twhile ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==\n\t       (EXT_NEXT_EXTENT_ALLOCDESCS >> 30)) {\n\t\tudf_pblk_t block;\n\t\tif (++indirections > UDF_MAX_INDIR_EXTS) {\n\t\t\tudf_err(inode->i_sb,\n\t\t\t\t\"too many indirect extents in inode %lu\\n\",\n\t\t\t\tinode->i_ino);\n\t\t\treturn -1;\n\t\t}\n\t\tepos->block = *eloc;\n\t\tepos->offset = sizeof(struct allocExtDesc);\n\t\tbrelse(epos->bh);\n\t\tblock = udf_get_lb_pblock(inode->i_sb, &epos->block, 0);\n\t\tepos->bh = udf_tread(inode->i_sb, block);\n\t\tif (!epos->bh) {\n\t\t\tudf_debug(\"reading block %u failed!\\n\", block);\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn etype;\n}", "target": 0}
{"code": "  HttpNetworkSession* CreateNetworkSession() {\n    return SpdySessionDependencies::SpdyCreateSessionDeterministic(\n        &session_deps_);\n  }", "target": 0}
{"code": "static GF_DownloadManager *gf_fs_get_download_manager(GF_FilterSession *fs)\n{\n\tif (!fs->download_manager) {\n\t\tfs->download_manager = gf_dm_new(fs);\n\t\tgf_dm_set_auth_callback(fs->download_manager, gf_fsess_get_user_pass, fs);\n\t}\n\treturn fs->download_manager;\n}", "target": 0}
{"code": "bool LIRGenerator::can_inline_as_constant(LIR_Const* c) const {\n  if (c->type() == T_LONG) return false;\n  return c->type() != T_OBJECT || c->as_jobject() == NULL;\n}", "target": 0}
{"code": "static inline void var_push(php_unserialize_data_t *var_hashx, zval *rval)\n{\n\tvar_entries *var_hash = (*var_hashx)->last;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_push(%ld): %d\\n\", var_hash?var_hash->used_slots:-1L, Z_TYPE_PP(rval));\n#endif\n\tif (!var_hash || var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tvar_hash = emalloc(sizeof(var_entries));\n\t\tvar_hash->used_slots = 0;\n\t\tvar_hash->next = 0;\n\t\tif (!(*var_hashx)->first) {\n\t\t\t(*var_hashx)->first = var_hash;\n\t\t} else {\n\t\t\t((var_entries *) (*var_hashx)->last)->next = var_hash;\n\t\t}\n\t\t(*var_hashx)->last = var_hash;\n\t}\n\tvar_hash->data[var_hash->used_slots++] = rval;\n}", "target": 0}
{"code": "ref_param_requested(const gs_param_list * plist, gs_param_name pkey)\n{\n    const iparam_list *const ciplist = (const iparam_list *)plist;\n    ref kref;\n    ref *ignore_value;\n    if (!r_has_type(&ciplist->u.w.wanted, t_dictionary))\n        return -1;\n    if (ref_param_key(ciplist, pkey, &kref) < 0)\n        return -1;\t\t\n    return (dict_find(&ciplist->u.w.wanted, &kref, &ignore_value) > 0);\n}", "target": 0}
{"code": "static NetworkTechnology ParseNetworkTechnology(\n    const std::string& technology) {\n    if (technology == kNetworkTechnology1Xrtt)\n    return NETWORK_TECHNOLOGY_1XRTT;\n  if (technology == kNetworkTechnologyEvdo)\n    return NETWORK_TECHNOLOGY_EVDO;\n  if (technology == kNetworkTechnologyGprs)\n    return NETWORK_TECHNOLOGY_GPRS;\n  if (technology == kNetworkTechnologyEdge)\n    return NETWORK_TECHNOLOGY_EDGE;\n  if (technology == kNetworkTechnologyUmts)\n    return NETWORK_TECHNOLOGY_UMTS;\n  if (technology == kNetworkTechnologyHspa)\n    return NETWORK_TECHNOLOGY_HSPA;\n  if (technology == kNetworkTechnologyHspaPlus)\n    return NETWORK_TECHNOLOGY_HSPA_PLUS;\n  if (technology == kNetworkTechnologyLte)\n    return NETWORK_TECHNOLOGY_LTE;\n  if (technology == kNetworkTechnologyLteAdvanced)\n    return NETWORK_TECHNOLOGY_LTE_ADVANCED;\n  return NETWORK_TECHNOLOGY_UNKNOWN;\n}", "target": 0}
{"code": "static int pfkey_dump_sa(struct pfkey_sock *pfk)\n{\n\tstruct net *net = sock_net(&pfk->sk);\n\treturn xfrm_state_walk(net, &pfk->dump.u.state, dump_sa, (void *) pfk);\n}", "target": 0}
{"code": "static int vgacon_resize(struct vc_data *c, unsigned int width,\n\t\t\t unsigned int height, unsigned int user)\n{\n\tif ((width << 1) * height > vga_vram_size)\n\t\treturn -EINVAL;\n\tif (width % 2 || width > screen_info.orig_video_cols ||\n\t    height > (screen_info.orig_video_lines * vga_default_font_height)/\n\t    c->vc_font.height)\n\t\treturn (user) ? 0 : -EINVAL;\n\tif (con_is_visible(c) && !vga_is_gfx) \n\t\tvgacon_doresize(c, width, height);\n\treturn 0;\n}", "target": 0}
{"code": "    void subtractOp(void *src1, void *src2, void *dst)\n    {\n        subtract(*(Mat *)src1, *(Mat *)src2, *(Mat *)dst, noArray(), CV_32F);\n    }", "target": 0}
{"code": "advance_to_name_end (GMarkupParseContext *context)\n{\n  do\n    {\n      if (IS_COMMON_NAME_END_CHAR (*(context->iter)))\n        return;\n      if (xml_isspace (*(context->iter)))\n        return;\n    }\n  while (advance_char (context));\n}", "target": 0}
{"code": "static TypedValue* add_vars_helper(ActRec* ar) {\n  int start_index = 1;\n  Resource packet_id{getArg<KindOfResource>(ar, 0)};\n  auto wddxPacket = cast<WddxPacket>(packet_id);\n  for (int i = start_index; i < ar->numArgs(); i++) {\n    auto const tv = getArg(ar, i);\n    find_var_recursive(tv, wddxPacket);\n  }\n  return arReturn(ar, true);\n}", "target": 0}
{"code": "struct gendisk *get_gendisk(dev_t devt, int *partno)\n{\n\tstruct gendisk *disk = NULL;\n\tif (MAJOR(devt) != BLOCK_EXT_MAJOR) {\n\t\tstruct kobject *kobj;\n\t\tkobj = kobj_lookup(bdev_map, devt, partno);\n\t\tif (kobj)\n\t\t\tdisk = dev_to_disk(kobj_to_dev(kobj));\n\t} else {\n\t\tstruct hd_struct *part;\n\t\tspin_lock_bh(&ext_devt_lock);\n\t\tpart = idr_find(&ext_devt_idr, blk_mangle_minor(MINOR(devt)));\n\t\tif (part && get_disk(part_to_disk(part))) {\n\t\t\t*partno = part->partno;\n\t\t\tdisk = part_to_disk(part);\n\t\t}\n\t\tspin_unlock_bh(&ext_devt_lock);\n\t}\n\treturn disk;\n}", "target": 0}
{"code": "  static std::unique_ptr<ResponseHeaderMapImpl> create() {\n    return std::unique_ptr<ResponseHeaderMapImpl>(new (inlineHeadersSize())\n                                                      ResponseHeaderMapImpl());\n  }", "target": 0}
{"code": "ui::EventTarget* Shell::GetParentTarget() {\n  return aura::Env::GetInstance();\n}", "target": 0}
{"code": "rb_is_head_page(struct ring_buffer_per_cpu *cpu_buffer,\n\t\tstruct buffer_page *page, struct list_head *list)\n{\n\tunsigned long val;\n\tval = (unsigned long)list->next;\n\tif ((val & ~RB_FLAG_MASK) != (unsigned long)&page->list)\n\t\treturn RB_PAGE_MOVED;\n\treturn val & RB_FLAG_MASK;\n}", "target": 0}
{"code": "void InlineTextBox::attachLine()\n{\n    if (!m_extracted)\n        return;\n    toRenderText(renderer())->attachTextBox(this);\n}", "target": 0}
{"code": "static int fsck_walk_tag(struct tag *tag, void *data, struct fsck_options *options)\n{\n\tchar *name = get_object_name(options, &tag->object);\n\tif (parse_tag(tag))\n\t\treturn -1;\n\tif (name)\n\t\tput_object_name(options, tag->tagged, \"%s\", name);\n\treturn options->walk(tag->tagged, OBJ_ANY, data, options);\n}", "target": 0}
{"code": "static const char *set_enable_mmap(cmd_parms *cmd, void *d_,\n                                   const char *arg)\n{\n    core_dir_config *d = d_;\n    if (ap_cstr_casecmp(arg, \"on\") == 0) {\n        d->enable_mmap = ENABLE_MMAP_ON;\n    }\n    else if (ap_cstr_casecmp(arg, \"off\") == 0) {\n        d->enable_mmap = ENABLE_MMAP_OFF;\n    }\n    else {\n        return \"parameter must be 'on' or 'off'\";\n    }\n    return NULL;\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_do_9_2_shut_ctsn(struct net *net,\n\t\t\t\t\t   const struct sctp_endpoint *ep,\n\t\t\t\t\t   const struct sctp_association *asoc,\n\t\t\t\t\t   const sctp_subtype_t type,\n\t\t\t\t\t   void *arg,\n\t\t\t\t\t   sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tsctp_shutdownhdr_t *sdh;\n\t__u32 ctsn;\n\tif (!sctp_vtag_verify(chunk, asoc))\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\tif (!sctp_chunk_length_valid(chunk,\n\t\t\t\t      sizeof(struct sctp_shutdown_chunk_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tsdh = (sctp_shutdownhdr_t *)chunk->skb->data;\n\tctsn = ntohl(sdh->cum_tsn_ack);\n\tif (TSN_lt(ctsn, asoc->ctsn_ack_point)) {\n\t\tSCTP_DEBUG_PRINTK(\"ctsn %x\\n\", ctsn);\n\t\tSCTP_DEBUG_PRINTK(\"ctsn_ack_point %x\\n\", asoc->ctsn_ack_point);\n\t\treturn SCTP_DISPOSITION_DISCARD;\n\t}\n\tif (!TSN_lt(ctsn, asoc->next_tsn))\n\t\treturn sctp_sf_violation_ctsn(net, ep, asoc, type, arg, commands);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_PROCESS_CTSN,\n\t\t\tSCTP_BE32(sdh->cum_tsn_ack));\n\treturn SCTP_DISPOSITION_CONSUME;\n}", "target": 0}
{"code": "smp_fetch_cookie_val(struct proxy *px, struct session *l4, void *l7, unsigned int opt,\n                     const struct arg *args, struct sample *smp)\n{\n\tint ret = smp_fetch_cookie(px, l4, l7, opt, args, smp);\n\tif (ret > 0) {\n\t\tsmp->type = SMP_T_UINT;\n\t\tsmp->data.uint = strl2ic(smp->data.str.str, smp->data.str.len);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static void InsertNode(CPpmd8 *p, void *node, unsigned indx)\n{\n  ((CPpmd8_Node *)node)->Stamp = EMPTY_NODE;\n  ((CPpmd8_Node *)node)->Next = (CPpmd8_Node_Ref)p->FreeList[indx];\n  ((CPpmd8_Node *)node)->NU = I2U(indx);\n  p->FreeList[indx] = REF(node);\n  p->Stamps[indx]++;\n}", "target": 0}
{"code": "handle_invalid_input(pesignd_cmd cmd, context *ctx,\n\t\t     struct pollfd *pollfd UNUSED,\n\t\t     socklen_t size UNUSED)\n{\n\t\tctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,\n\t\t\t\"got unexpected command 0x%x\", cmd);\n\t\tctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,\n\t\t\t\"possible exploit attempt\");\n}", "target": 0}
{"code": "MagickExport void ConvertRGBToHSV(const Quantum red,const Quantum green,\n  const Quantum blue,double *hue,double *saturation,double *value)\n{\n  double\n    c,\n    max,\n    min;\n  assert(hue != (double *) NULL);\n  assert(saturation != (double *) NULL);\n  assert(value != (double *) NULL);\n  max=MagickMax(QuantumScale*red,MagickMax(QuantumScale*green,\n    QuantumScale*blue));\n  min=MagickMin(QuantumScale*red,MagickMin(QuantumScale*green,\n    QuantumScale*blue));\n  c=max-min;\n  *value=max;\n  if (c <= 0.0)\n    {\n      *hue=0.0;\n      *saturation=0.0;\n      return;\n    }\n  if (fabs(max-QuantumScale*red) < MagickEpsilon)\n    {\n      *hue=(QuantumScale*green-QuantumScale*blue)/c;\n      if ((QuantumScale*green) < (QuantumScale*blue))\n        *hue+=6.0;\n    }\n  else\n    if (fabs(max-QuantumScale*green) < MagickEpsilon)\n      *hue=2.0+(QuantumScale*blue-QuantumScale*red)/c;\n    else\n      *hue=4.0+(QuantumScale*red-QuantumScale*green)/c;\n  *hue*=60.0/360.0;\n  *saturation=c*PerceptibleReciprocal(max);\n}", "target": 0}
{"code": "static OPENSSL_LH_NODE **getrn(OPENSSL_LHASH *lh,\n                               const void *data, unsigned long *rhash)\n{\n    OPENSSL_LH_NODE **ret, *n1;\n    unsigned long hash, nn;\n    OPENSSL_LH_COMPFUNC cf;\n    hash = (*(lh->hash)) (data);\n    *rhash = hash;\n    nn = hash % lh->pmax;\n    if (nn < lh->p)\n        nn = hash % lh->num_alloc_nodes;\n    cf = lh->comp;\n    ret = &(lh->b[(int)nn]);\n    for (n1 = *ret; n1 != NULL; n1 = n1->next) {\n        if (n1->hash != hash) {\n            ret = &(n1->next);\n            continue;\n        }\n        if (cf(n1->data, data) == 0)\n            break;\n        ret = &(n1->next);\n    }\n    return ret;\n}", "target": 0}
{"code": "static inline void vm_entry_controls_clearbit(struct vcpu_vmx *vmx, u32 val)\n{\n\tvm_entry_controls_set(vmx, vm_entry_controls_get(vmx) & ~val);\n}", "target": 0}
{"code": "static unsigned long xol_get_insn_slot(struct uprobe *uprobe)\n{\n\tstruct xol_area *area;\n\tunsigned long xol_vaddr;\n\tarea = get_xol_area();\n\tif (!area)\n\t\treturn 0;\n\txol_vaddr = xol_take_insn_slot(area);\n\tif (unlikely(!xol_vaddr))\n\t\treturn 0;\n\tarch_uprobe_copy_ixol(area->pages[0], xol_vaddr,\n\t\t\t      &uprobe->arch.ixol, sizeof(uprobe->arch.ixol));\n\treturn xol_vaddr;\n}", "target": 0}
{"code": "bool _AudioFormat::isCompressed() const\n{\n\treturn compressionType != AF_COMPRESSION_NONE;\n}", "target": 0}
{"code": "R_API RIOBank *r_io_bank_new(const char *name) {\n\tr_return_val_if_fail (name, NULL);\n\tRIOBank *bank = R_NEW0 (RIOBank);\n\tif (!bank) {\n\t\treturn NULL;\n\t}\n\tbank->name = strdup (name);\n\tbank->submaps = r_crbtree_new (free);\n\tif (!bank->submaps) {\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\tbank->maprefs = r_list_newf (free);\n\tif (!bank->maprefs) {\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\tbank->todo = r_queue_new (8);\n\tif (!bank->todo) {\n\t\tr_list_free (bank->maprefs);\n\t\tr_crbtree_free (bank->submaps);\n\t\tfree (bank);\n\t\treturn NULL;\n\t}\n\treturn bank;\n}", "target": 0}
{"code": "static bool mac_table_fits(void *opaque, int version_id)\n{\n    return VIRTIO_NET(opaque)->mac_table.in_use <= MAC_TABLE_ENTRIES;\n}", "target": 0}
{"code": "SWFOutput_writeGlyphShape(SWFOutput out, SWFShape shape)\n{\n\tunsigned char c;\n\tint styleDone = 0;\n\tint i;\n\tc = 1<<4;\n\tSWFOutput_writeUInt8(out, c);\n\tshape->nFills = 1;\n\tshape->nLines = 0;\t\t\n\tfor ( i=0; i<shape->nRecords; ++i )\n\t{\n\t\tif(!styleDone && shape->records[i].type == SHAPERECORD_STATECHANGE)\n\t\t{\n\t\t\tshape->records[i].record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\t\tshape->records[i].record.stateChange->leftFill = 1;\n\t\t\tstyleDone = 1;\n\t\t}\t\n\t\tif ( i < shape->nRecords-1 ||\n\t\t\t\t shape->records[i].type != SHAPERECORD_STATECHANGE )\n\t\t{\n\t\t\tSWFShape_writeShapeRecord(shape, shape->records[i], out);\n\t\t}\n\t}\n\tSWFOutput_writeBits(out, 0, 6); \n\tSWFOutput_byteAlign(out);\n}", "target": 0}
{"code": "void RenderView::ForEach(RenderViewVisitor* visitor) {\n  ViewMap* views = Singleton<ViewMap>::get();\n  for (ViewMap::iterator it = views->begin(); it != views->end(); ++it) {\n    if (!visitor->Visit(it->second))\n      return;\n  }\n}", "target": 0}
{"code": "findtags_in_help_init(findtags_state_T *st)\n{\n    int\t\ti;\n    char_u\t*s;\n    if (st->is_txt)\n\tSTRCPY(st->help_lang, \"en\");\n    else\n    {\n\ti = (int)STRLEN(st->tag_fname);\n\tif (i > 3 && st->tag_fname[i - 3] == '-')\n\t    vim_strncpy(st->help_lang, st->tag_fname + i - 2, 2);\n\telse\n\t    STRCPY(st->help_lang, \"en\");\n    }\n    if (st->help_lang_find != NULL\n\t    && STRICMP(st->help_lang, st->help_lang_find) != 0)\n\treturn FALSE;\n    if ((st->flags & TAG_KEEP_LANG)\n\t    && st->help_lang_find == NULL\n\t    && curbuf->b_fname != NULL\n\t    && (i = (int)STRLEN(curbuf->b_fname)) > 4\n\t    && curbuf->b_fname[i - 1] == 'x'\n\t    && curbuf->b_fname[i - 4] == '.'\n\t    && STRNICMP(curbuf->b_fname + i - 3, st->help_lang, 2) == 0)\n\tst->help_pri = 0;\n    else\n    {\n\tst->help_pri = 1;\n\tfor (s = p_hlg; *s != NUL; ++s)\n\t{\n\t    if (STRNICMP(s, st->help_lang, 2) == 0)\n\t\tbreak;\n\t    ++st->help_pri;\n\t    if ((s = vim_strchr(s, ',')) == NULL)\n\t\tbreak;\n\t}\n\tif (s == NULL || *s == NUL)\n\t{\n\t    ++st->help_pri;\n\t    if (STRICMP(st->help_lang, \"en\") != 0)\n\t\t++st->help_pri;\n\t}\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "static void smbd_idle_event_handler(struct event_context *ctx,\n\t\t\t\t    struct timed_event *te,\n\t\t\t\t    struct timeval now,\n\t\t\t\t    void *private_data)\n{\n\tstruct idle_event *event =\n\t\ttalloc_get_type_abort(private_data, struct idle_event);\n\tTALLOC_FREE(event->te);\n\tDEBUG(10,(\"smbd_idle_event_handler: %s %p called\\n\",\n\t\t  event->name, event->te));\n\tif (!event->handler(&now, event->private_data)) {\n\t\tDEBUG(10,(\"smbd_idle_event_handler: %s %p stopped\\n\",\n\t\t\t  event->name, event->te));\n\t\tTALLOC_FREE(event);\n\t\treturn;\n\t}\n\tDEBUG(10,(\"smbd_idle_event_handler: %s %p rescheduled\\n\",\n\t\t  event->name, event->te));\n\tevent->te = event_add_timed(ctx, event,\n\t\t\t\t    timeval_sum(&now, &event->interval),\n\t\t\t\t    smbd_idle_event_handler, event);\n\tSMB_ASSERT(event->te != NULL);\n}", "target": 0}
{"code": "  List_Obj Parser::parse_media_queries()\n  {\n    advanceToNextToken();\n    List_Obj queries = SASS_MEMORY_NEW(List, pstate, 0, SASS_COMMA);\n    if (!peek_css < exactly <'{'> >()) queries->append(parse_media_query());\n    while (lex_css < exactly <','> >()) queries->append(parse_media_query());\n    queries->update_pstate(pstate);\n    return queries.detach();\n  }", "target": 0}
{"code": "longlong Item_param::val_int() \n{ \n  switch (state) {\n  case REAL_VALUE:\n    return (longlong) rint(value.real);\n  case INT_VALUE:\n    return value.integer;\n  case DECIMAL_VALUE:\n  {\n    longlong i;\n    my_decimal2int(E_DEC_FATAL_ERROR, &decimal_value, unsigned_flag, &i);\n    return i;\n  }\n  case STRING_VALUE:\n  case LONG_DATA_VALUE:\n    {\n      int dummy_err;\n      return my_strntoll(str_value.charset(), str_value.ptr(),\n                         str_value.length(), 10, (char**) 0, &dummy_err);\n    }\n  case TIME_VALUE:\n    return (longlong) TIME_to_ulonglong(&value.time);\n  case NULL_VALUE:\n    return 0; \n  default:\n    DBUG_ASSERT(0);\n  }\n  return 0;\n}", "target": 0}
{"code": "u32 gf_isom_get_constant_sample_size(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !trak->Media->information || !trak->Media->information->sampleTable || !trak->Media->information->sampleTable->SampleSize) return 0;\n\treturn trak->Media->information->sampleTable->SampleSize->sampleSize;\n}", "target": 0}
{"code": "vte_sequence_handler_decset (VteTerminal *terminal, GValueArray *params)\n{\n\tGValue *value;\n\tlong setting;\n\tguint i;\n\tif ((params == NULL) || (params->n_values == 0)) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < params->n_values; i++) {\n\t\tvalue = g_value_array_get_nth(params, i);\n\t\tif (!G_VALUE_HOLDS_LONG(value)) {\n\t\t\tcontinue;\n\t\t}\n\t\tsetting = g_value_get_long(value);\n\t\tvte_sequence_handler_decset_internal(terminal, setting, FALSE, FALSE, TRUE);\n\t}\n}", "target": 0}
{"code": "static unsigned long count_partial(struct kmem_cache_node *n,\n\t\t\t\t\tint (*get_count)(struct page *))\n{\n\tunsigned long flags;\n\tunsigned long x = 0;\n\tstruct page *page;\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tlist_for_each_entry(page, &n->partial, lru)\n\t\tx += get_count(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\treturn x;\n}", "target": 0}
{"code": "fbStore_x8r8g8b8 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    CARD32 *pixel = (CARD32 *)bits + x;\n    for (i = 0; i < width; ++i)\n        WRITE(pixel++, READ(values + i) & 0xffffff);\n}", "target": 0}
{"code": "static HashTable* spl_heap_object_get_debug_info(zval *obj, int *is_temp TSRMLS_DC) \n{\n\treturn spl_heap_object_get_debug_info_helper(spl_ce_SplHeap, obj, is_temp TSRMLS_CC);\n}", "target": 0}
{"code": "list_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\tif (event->group_leader == event) {\n\t\tstruct list_head *list;\n\t\tif (is_software_event(event))\n\t\t\tevent->group_flags |= PERF_GROUP_SOFTWARE;\n\t\tlist = ctx_group_list(event, ctx);\n\t\tlist_add_tail(&event->group_entry, list);\n\t}\n\tif (is_cgroup_event(event))\n\t\tctx->nr_cgroups++;\n\tif (has_branch_stack(event))\n\t\tctx->nr_branch_stack++;\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tif (!ctx->nr_events)\n\t\tperf_pmu_rotate_start(ctx->pmu);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n}", "target": 0}
{"code": "GF_AVCConfig *gf_isom_avc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_avc_svc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_AVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->avc_config) return NULL;\n\treturn AVC_DuplicateConfig(entry->avc_config->config);\n}", "target": 0}
{"code": "static int ti_do_config(struct edgeport_port *port, int feature, int on)\n{\n\tint port_number = port->port->port_number;\n\ton = !!on;\t\n\treturn send_cmd(port->port->serial->dev,\n\t\t\tfeature, (__u8)(UMPM_UART1_PORT + port_number),\n\t\t\ton, NULL, 0);\n}", "target": 0}
{"code": "static void php_array_merge(Array &arr1, const Array& arr2) {\n  arr1.merge(arr2);\n}", "target": 0}
{"code": "generate_authvar_signer_info(cms_context *cms, SpcSignerInfo *sip)\n{\n\tSpcSignerInfo si;\n\tSECItem buf;\n\tif (!sip)\n\t\treturn -1;\n\tmemset(&si, '\\0', sizeof (si));\n\tif (SEC_ASN1EncodeInteger(cms->arena, &si.CMSVersion, 1) == NULL) {\n\t\tcms->log(cms, LOG_ERR, \"could not encode CMSVersion: %s\",\n\t\t\tPORT_ErrorToString(PORT_GetError()));\n\t\tgoto err;\n\t}\n\tsi.sid.signerType = signerTypeIssuerAndSerialNumber;\n\tsi.sid.signerValue.iasn.issuer = cms->cert->derIssuer;\n\tsi.sid.signerValue.iasn.serial = cms->cert->serialNumber;\n\tif (generate_algorithm_id(cms, &si.digestAlgorithm,\n\t\t\tdigest_get_digest_oid(cms)) < 0)\n\t\tgoto err;\n\tsi.signedAttrs.len = 0;\n\tsi.signedAttrs.data = NULL;\n\tbuf.len = cms->authbuf_len;\n\tbuf.data = cms->authbuf;\n\tif (sign_blob(cms, &si.signature, &buf) < 0)\n\t\tgoto err;\n\tif (generate_algorithm_id(cms, &si.signatureAlgorithm,\n\t\t\t\tdigest_get_encryption_oid(cms)) < 0)\n\t\tgoto err;\n\tsi.unsignedAttrs.len = 0;\n\tsi.unsignedAttrs.data = NULL;\n\tmemcpy(sip, &si, sizeof(si));\n\treturn 0;\nerr:\n\treturn -1;\n}", "target": 0}
{"code": "asyncFork() {\n\t#if defined(__linux__)\n\t\t#if defined(SYS_fork)\n\t\t\treturn (pid_t) syscall(SYS_fork);\n\t\t#else\n\t\t\treturn syscall(SYS_clone, SIGCHLD, 0, 0, 0, 0);\n\t\t#endif\n\t#elif defined(__APPLE__)\n\t\treturn __fork();\n\t#else\n\t\treturn fork();\n\t#endif\n}", "target": 0}
{"code": "      _cimg_math_parser():\n        code(_code),p_code_end(0),p_break((CImg<ulongT>*)0 - 2),\n        imgin(CImg<T>::const_empty()),listin(CImgList<T>::const_empty()),\n        imgout(CImg<T>::empty()),listout(CImgList<T>::empty()),\n        img_stats(_img_stats),list_stats(_list_stats),list_median(_list_median),debug_indent(0),\n        result_dim(0),break_type(0),constcache_size(0),is_parallelizable(true),is_fill(false),need_input_copy(false),\n        calling_function(0) {\n        mem.assign(1 + _cimg_mp_slot_c,1,1,1,0); \n        result = mem._data;", "target": 0}
{"code": "static bool virtio_net_set_vnet_endian(VirtIODevice *vdev, NetClientState *ncs,\n                                       int queues, bool enable)\n{\n    int i;\n    for (i = 0; i < queues; i++) {\n        if (virtio_net_set_vnet_endian_one(vdev, ncs[i].peer, enable) < 0 &&\n            enable) {\n            while (--i >= 0) {\n                virtio_net_set_vnet_endian_one(vdev, ncs[i].peer, false);\n            }\n            return true;\n        }\n    }\n    return false;\n}", "target": 0}
{"code": "static irqreturn_t vhost_vdpa_config_cb(void *private)\n{\n\tstruct vhost_vdpa *v = private;\n\tstruct eventfd_ctx *config_ctx = v->config_ctx;\n\tif (config_ctx)\n\t\teventfd_signal(config_ctx, 1);\n\treturn IRQ_HANDLED;\n}", "target": 0}
{"code": "TEST(RegexMatchExpression, MatchesElementWrongType) {\n    BSONObj notMatchInt = BSON(\"x\" << 1);\n    BSONObj notMatchBool = BSON(\"x\" << true);\n    RegexMatchExpression regex(\"\", \"1\", \"\");\n    ASSERT(!regex.matchesSingleElement(notMatchInt.firstElement()));\n    ASSERT(!regex.matchesSingleElement(notMatchBool.firstElement()));\n}", "target": 0}
{"code": "ospf_hello_send_sub (struct ospf_interface *oi, in_addr_t addr)\n{\n  struct ospf_packet *op;\n  u_int16_t length = OSPF_HEADER_SIZE;\n  op = ospf_packet_new (oi->ifp->mtu);\n  ospf_make_header (OSPF_MSG_HELLO, oi, op->s);\n  length += ospf_make_hello (oi, op->s);\n  ospf_fill_header (oi, op->s, length);\n  op->length = length;\n  op->dst.s_addr = addr;\n  ospf_packet_add_top (oi, op);\n  OSPF_ISM_WRITE_ON (oi->ospf);\n}", "target": 0}
{"code": "static int gen_d(RSA *rsa)\n{\n\tBN_CTX *bnctx;\n\tBIGNUM *r0, *r1, *r2;\n\tconst BIGNUM *rsa_p, *rsa_q, *rsa_n, *rsa_e, *rsa_d;\n\tBIGNUM *rsa_n_new, *rsa_e_new, *rsa_d_new;\n\tbnctx = BN_CTX_new();\n\tif (bnctx == NULL)\n\t\treturn -1;\n\tBN_CTX_start(bnctx);\n\tr0 = BN_CTX_get(bnctx);\n\tr1 = BN_CTX_get(bnctx);\n\tr2 = BN_CTX_get(bnctx);\n\tRSA_get0_key(rsa, &rsa_n, &rsa_e, &rsa_d);\n\tRSA_get0_factors(rsa, &rsa_p, &rsa_q);\n\tBN_sub(r1, rsa_p, BN_value_one());\n\tBN_sub(r2, rsa_q, BN_value_one());\n\tBN_mul(r0, r1, r2, bnctx);\n\tif ((rsa_d_new = BN_mod_inverse(NULL, rsa_e, r0, bnctx)) == NULL) {\n\t\tfprintf(stderr, \"BN_mod_inverse() failed.\\n\");\n\t\treturn -1;\n\t}\n\trsa_n_new = BN_dup(rsa_n);\n\trsa_e_new = BN_dup(rsa_e);\n\tif (RSA_set0_key(rsa, rsa_n_new, rsa_e_new, rsa_d_new) != 1)\n\t\treturn -1;\n\tBN_CTX_end(bnctx);\n\tBN_CTX_free(bnctx);\n\treturn 0;\n}", "target": 0}
{"code": "void *kmem_cache_alloc_trace(struct kmem_cache *s, gfp_t gfpflags, size_t size)\n{\n\tvoid *ret = slab_alloc(s, gfpflags, _RET_IP_);\n\ttrace_kmalloc(_RET_IP_, ret, size, s->size, gfpflags);\n\tret = kasan_kmalloc(s, ret, size, gfpflags);\n\treturn ret;\n}", "target": 0}
{"code": "    void Image::setMetadata(const Image& image)\n    {\n        if (checkMode(mdExif) & amWrite) {\n            setExifData(image.exifData());\n        }\n        if (checkMode(mdIptc) & amWrite) {\n            setIptcData(image.iptcData());\n        }\n        if (checkMode(mdIccProfile) & amWrite && iccProfile()) {\n            setIccProfile(*iccProfile());\n        }\n        if (checkMode(mdXmp) & amWrite) {\n            setXmpPacket(image.xmpPacket());\n            setXmpData(image.xmpData());\n        }\n        if (checkMode(mdComment) & amWrite) {\n            setComment(image.comment());\n        }\n    }", "target": 0}
{"code": "int DNS::PruneCache()\n{\n\tint n = 0;\n\tdnscache* newcache = new dnscache();\n\tfor (dnscache::iterator i = this->cache->begin(); i != this->cache->end(); i++)\n\t\tif (i->second.CalcTTLRemaining())\n\t\t\tnewcache->insert(*i);\n\t\telse\n\t\t\tn++;\n\tdelete this->cache;\n\tthis->cache = newcache;\n\treturn n;\n}", "target": 0}
{"code": "  template<typename T>\n  inline CImg<_cimg_Tfloat> exp(const CImg<T>& instance) {\n    return instance.get_exp();", "target": 0}
{"code": "\tstatic void convertSignedToUnsigned(const void *src, void *dst, size_t count)\n\t{\n\t\ttransform<typename signConverter<Format>::signedToUnsigned>(src, dst, count);\n\t}", "target": 0}
{"code": "globexp1(const Char *pattern, glob_t *pglob, struct glob_lim *limitp,\n         int recursion)\n{\n    const Char* ptr = pattern;\n    if (pglob->gl_maxdepth > 0 && recursion > pglob->gl_maxdepth) {\n        errno = 0;\n        return 0;\n    }\n    if (pattern[0] == LBRACE && pattern[1] == RBRACE && pattern[2] == EOS) {\n        return glob0(pattern, pglob, limitp);\n    }\n    if ((ptr = (const Char *) g_strchr(ptr, LBRACE)) != NULL) {\n        return globexp2(ptr, pattern, pglob, limitp, recursion + 1);\n    }\n    return glob0(pattern, pglob, limitp);\n}", "target": 0}
{"code": "static int mpeg4_get_block_length(MpegEncContext *s,\n                                  int16_t *block, int n,\n                                  int intra_dc, uint8_t *scan_table)\n{\n    int i, last_non_zero;\n    uint8_t *len_tab;\n    const int last_index = s->block_last_index[n];\n    int len = 0;\n    if (s->mb_intra) {  \n        len += mpeg4_get_dc_length(intra_dc, n);\n        if (last_index < 1)\n            return len;\n        i = 1;\n        len_tab = uni_mpeg4_intra_rl_len;\n    } else {\n        if (last_index < 0)\n            return 0;\n        i = 0;\n        len_tab = uni_mpeg4_inter_rl_len;\n    }\n    last_non_zero = i - 1;\n    for (; i < last_index; i++) {\n        int level = block[scan_table[i]];\n        if (level) {\n            int run = i - last_non_zero - 1;\n            level += 64;\n            if ((level & (~127)) == 0) {\n                const int index = UNI_MPEG4_ENC_INDEX(0, run, level);\n                len += len_tab[index];\n            } else {  \n                len += 7 + 2 + 1 + 6 + 1 + 12 + 1;\n            }\n            last_non_zero = i;\n        }\n    }\n     {\n        int level = block[scan_table[i]];\n        int run   = i - last_non_zero - 1;\n        level += 64;\n        if ((level & (~127)) == 0) {\n            const int index = UNI_MPEG4_ENC_INDEX(1, run, level);\n            len += len_tab[index];\n        } else {  \n            len += 7 + 2 + 1 + 6 + 1 + 12 + 1;\n        }\n    }\n    return len;\n}", "target": 0}
{"code": "static int tipc_nl_compat_bearer_disable(struct tipc_nl_compat_cmd_doit *cmd,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t struct tipc_nl_compat_msg *msg)\n{\n\tchar *name;\n\tstruct nlattr *bearer;\n\tname = (char *)TLV_DATA(msg->req);\n\tbearer = nla_nest_start(skb, TIPC_NLA_BEARER);\n\tif (!bearer)\n\t\treturn -EMSGSIZE;\n\tif (nla_put_string(skb, TIPC_NLA_BEARER_NAME, name))\n\t\treturn -EMSGSIZE;\n\tnla_nest_end(skb, bearer);\n\treturn 0;\n}", "target": 0}
{"code": "void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,\n\t\t\t      struct net_device *netdev, const u8 *bssid,\n\t\t\t      const u8 *replay_ctr, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tstruct nlattr *rekey_attr;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_REKEY_OFFLOAD);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid))\n\t\tgoto nla_put_failure;\n\trekey_attr = nla_nest_start(msg, NL80211_ATTR_REKEY_DATA);\n\tif (!rekey_attr)\n\t\tgoto nla_put_failure;\n\tif (nla_put(msg, NL80211_REKEY_DATA_REPLAY_CTR,\n\t\t    NL80211_REPLAY_CTR_LEN, replay_ctr))\n\t\tgoto nla_put_failure;\n\tnla_nest_end(msg, rekey_attr);\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}", "target": 0}
{"code": "void ParamTraits<ListValue>::Log(const param_type& p, std::string* l) {\n  std::string json;\n  base::JSONWriter::Write(&p, &json);\n  l->append(json);\n}", "target": 0}
{"code": "void OmniboxViewWin::OnRevertTemporaryText() {\n  SetSelectionRange(original_selection_);\n  TextChanged();\n}", "target": 0}
{"code": "static MagickBooleanType EncodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n  MagickBooleanType\n    status;\n  ssize_t\n    y;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n    register ssize_t\n      x;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n      a=QuantumScale*GetPixela(image,q)-0.5;\n      if (a < 0.0)\n        a+=1.0;\n      b=QuantumScale*GetPixelb(image,q)-0.5;\n      if (b < 0.0)\n        b+=1.0;\n      SetPixela(image,QuantumRange*a,q);\n      SetPixelb(image,QuantumRange*b,q);\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}", "target": 0}
{"code": "static int kvm_iommu_unmap_memslots(struct kvm *kvm)\n{\n\tint idx;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tidx = srcu_read_lock(&kvm->srcu);\n\tslots = kvm_memslots(kvm);\n\tkvm_for_each_memslot(memslot, slots)\n\t\tkvm_iommu_unmap_pages(kvm, memslot);\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\tif (kvm->arch.iommu_noncoherent)\n\t\tkvm_arch_unregister_noncoherent_dma(kvm);\n\treturn 0;\n}", "target": 0}
{"code": "static int lua_ivm_set(lua_State *L) \n{\n    const char *key, *raw_key;\n    const char *value = NULL;\n    apr_pool_t *pool;\n    size_t str_len;\n    lua_ivm_object *object = NULL;\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    key = luaL_checkstring(L, 2);\n    luaL_checkany(L, 3);\n    raw_key = apr_pstrcat(r->pool, \"lua_ivm_\", key, NULL);\n    apr_global_mutex_lock(lua_ivm_mutex);\n    pool = *((apr_pool_t**) apr_shm_baseaddr_get(lua_ivm_shm));\n    apr_pool_userdata_get((void **)&object, raw_key, pool);\n    if (!object) {\n        object = apr_pcalloc(pool, sizeof(lua_ivm_object));\n        ap_varbuf_init(pool, &object->vb, 2);\n        object->size = 1;\n        object->vb_size = 1;\n    }\n    object->type = lua_type(L, 3);\n    if (object->type == LUA_TNUMBER) object->number = lua_tonumber(L, 3);\n    else if (object->type == LUA_TBOOLEAN) object->number = lua_tonumber(L, 3);\n    else if (object->type == LUA_TSTRING) {\n        value = lua_tolstring(L, 3, &str_len);\n        str_len++; \n        if ( str_len > object->vb_size) {\n            ap_varbuf_grow(&object->vb, str_len);\n            object->vb_size = str_len;\n        }\n        object->size = str_len-1;\n        memset(object->vb.buf, 0, str_len);\n        memcpy(object->vb.buf, value, str_len-1);\n    }\n    apr_pool_userdata_set(object, raw_key, NULL, pool);\n    apr_global_mutex_unlock(lua_ivm_mutex);\n    return 0;\n}", "target": 0}
{"code": "static int nfs41_check_session_ready(struct nfs_client *clp)\n{\n\tint ret;\n\tif (clp->cl_cons_state == NFS_CS_SESSION_INITING) {\n\t\tret = nfs4_client_recover_expired_lease(clp);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (clp->cl_cons_state < NFS_CS_READY)\n\t\treturn -EPROTONOSUPPORT;\n\tsmp_rmb();\n\treturn 0;\n}", "target": 0}
{"code": "TEST(GtOp, MatchesWholeArray) {\n    BSONObj operand = BSON(\"$gt\" << BSON_ARRAY(5));\n    GTMatchExpression gt(\"a\", operand[\"$gt\"]);\n    ASSERT(!gt.matchesBSON(BSON(\"a\" << BSON_ARRAY(4)), NULL));\n    ASSERT(!gt.matchesBSON(BSON(\"a\" << BSON_ARRAY(5)), NULL));\n    ASSERT(gt.matchesBSON(BSON(\"a\" << BSON_ARRAY(6)), NULL));\n    ASSERT(gt.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON_ARRAY(4))), NULL));\n    ASSERT(gt.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON_ARRAY(5))), NULL));\n    ASSERT(gt.matchesBSON(BSON(\"a\" << BSON_ARRAY(BSON_ARRAY(6))), NULL));\n}", "target": 0}
{"code": "STATIC void\nS_invlist_extend(pTHX_ SV* const invlist, const UV new_max)\n{\n    PERL_ARGS_ASSERT_INVLIST_EXTEND;\n    assert(is_invlist(invlist));\n    SvGROW((SV *)invlist, TO_INTERNAL_SIZE(new_max + 1));", "target": 0}
{"code": "static inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}", "target": 0}
{"code": "ospf_packet_dup (struct ospf_packet *op)\n{\n  struct ospf_packet *new;\n  if (stream_get_endp(op->s) != op->length)\n    zlog_warn (\"ospf_packet_dup stream %lu ospf_packet %u size mismatch\",\n\t       (u_long)STREAM_SIZE(op->s), op->length);\n  new = ospf_packet_new (stream_get_endp(op->s) + OSPF_AUTH_MD5_SIZE);\n  stream_copy (new->s, op->s);\n  new->dst = op->dst;\n  new->length = op->length;\n  return new;\n}", "target": 0}
{"code": "static void vmx_set_supported_cpuid(u32 func, struct kvm_cpuid_entry2 *entry)\n{\n\tif (func == 1 && nested)\n\t\tentry->ecx |= bit(X86_FEATURE_VMX);\n}", "target": 0}
{"code": "static void bnx2x_set_mf_bw(struct bnx2x *bp)\n{\n\tbnx2x_config_mf_bw(bp);\n\tbnx2x_fw_command(bp, DRV_MSG_CODE_SET_MF_BW_ACK, 0);\n}", "target": 0}
{"code": "void RenderView::DidDownloadImage(ImageResourceFetcher* fetcher,\n                                  const SkBitmap& image) {\n  Send(new ViewHostMsg_DidDownloadFavIcon(routing_id_,\n                                          fetcher->id(),\n                                          fetcher->image_url(),\n                                          image.isNull(),\n                                          image));\n  DCHECK(image_fetchers_.find(fetcher) != image_fetchers_.end());\n  image_fetchers_.erase(fetcher);\n  MessageLoop::current()->DeleteSoon(FROM_HERE, fetcher);\n}", "target": 0}
{"code": "int bdev_read_only(struct block_device *bdev)\n{\n\tif (!bdev)\n\t\treturn 0;\n\treturn bdev->bd_part->policy;\n}", "target": 0}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (layout_type >= LAYOUT_TYPE_MAX ||\n\t    !(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 0}
{"code": "static bool complete_word(char ***result, char *start, char *end, size_t *cap, size_t *cnt)\n{\n\tint r;\n\tr = lxc_grow_array((void ***)result, cap, 2 + *cnt, 16);\n\tif (r < 0)\n\t\treturn false;\n\t(*result)[*cnt] = strndup(start, end - start);\n\tif (!(*result)[*cnt])\n\t\treturn false;\n\t(*cnt)++;\n\treturn true;\n}", "target": 0}
{"code": "void kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.nmi_pending = 1;\n}", "target": 0}
{"code": "xfs_attr3_leaf_inactive(\n\tstruct xfs_trans\t**trans,\n\tstruct xfs_inode\t*dp,\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_attr_inactive_list *list;\n\tstruct xfs_attr_inactive_list *lp;\n\tint\t\t\terror;\n\tint\t\t\tcount;\n\tint\t\t\tsize;\n\tint\t\t\ttmp;\n\tint\t\t\ti;\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tcount = 0;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\tif (count == 0) {\n\t\txfs_trans_brelse(*trans, bp);\n\t\treturn 0;\n\t}\n\tsize = count * sizeof(xfs_attr_inactive_list_t);\n\tlist = kmem_alloc(size, KM_SLEEP);\n\tlp = list;\n\tentry = xfs_attr3_leaf_entryp(leaf);\n\tfor (i = 0; i < ichdr.count; entry++, i++) {\n\t\tif (be16_to_cpu(entry->nameidx) &&\n\t\t    ((entry->flags & XFS_ATTR_LOCAL) == 0)) {\n\t\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, i);\n\t\t\tif (name_rmt->valueblk) {\n\t\t\t\tlp->valueblk = be32_to_cpu(name_rmt->valueblk);\n\t\t\t\tlp->valuelen = XFS_B_TO_FSB(dp->i_mount,\n\t\t\t\t\t\t    be32_to_cpu(name_rmt->valuelen));\n\t\t\t\tlp++;\n\t\t\t}\n\t\t}\n\t}\n\txfs_trans_brelse(*trans, bp);\t\n\terror = 0;\n\tfor (lp = list, i = 0; i < count; i++, lp++) {\n\t\ttmp = xfs_attr3_leaf_freextent(trans, dp,\n\t\t\t\tlp->valueblk, lp->valuelen);\n\t\tif (error == 0)\n\t\t\terror = tmp;\t\n\t}\n\tkmem_free(list);\n\treturn error;\n}", "target": 0}
{"code": "int InlineFlowBox::computeUnderAnnotationAdjustment(int allowedPosition) const\n{\n    int result = 0;\n    for (InlineBox* curr = firstChild(); curr; curr = curr->nextOnLine()) {\n        if (curr->renderer()->isPositioned())\n            continue; \n        if (curr->isInlineFlowBox())\n            result = max(result, static_cast<InlineFlowBox*>(curr)->computeUnderAnnotationAdjustment(allowedPosition));\n        if (curr->isInlineTextBox()) {\n            RenderStyle* style = curr->renderer()->style(m_firstLine);\n            if (style->textEmphasisMark() != TextEmphasisMarkNone && style->textEmphasisPosition() == TextEmphasisPositionUnder) {\n                if (!style->isFlippedLinesWritingMode()) {\n                    int bottomOfEmphasisMark = curr->logicalBottom() + style->font().emphasisMarkHeight(style->textEmphasisMarkString());\n                    result = max(result, bottomOfEmphasisMark - allowedPosition);\n                } else {\n                    int topOfEmphasisMark = curr->logicalTop() - style->font().emphasisMarkHeight(style->textEmphasisMarkString());\n                    result = max(result, allowedPosition - topOfEmphasisMark);\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "    int Adjust::run(const std::string& path) try {\n        adjustment_ = Params::instance().adjustment_;\n        yearAdjustment_ = Params::instance().yodAdjust_[Params::yodYear].adjustment_;\n        monthAdjustment_ = Params::instance().yodAdjust_[Params::yodMonth].adjustment_;\n        dayAdjustment_ = Params::instance().yodAdjust_[Params::yodDay].adjustment_;\n        if (!Exiv2::fileExists(path, true)) {\n            std::cerr << path << \": \" << _(\"Failed to open the file\\n\");\n            return -1;\n        }\n        Timestamp ts;\n        if (Params::instance().preserve_)\n            ts.read(path);\n        Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open(path);\n        image->readMetadata();\n        Exiv2::ExifData& exifData = image->exifData();\n        if (exifData.empty()) {\n            std::cerr << path << \": \" << _(\"No Exif data found in the file\\n\");\n            return -3;\n        }\n        int rc = adjustDateTime(exifData, \"Exif.Image.DateTime\", path);\n        rc += adjustDateTime(exifData, \"Exif.Photo.DateTimeOriginal\", path);\n        rc += adjustDateTime(exifData, \"Exif.Image.DateTimeOriginal\", path);\n        rc += adjustDateTime(exifData, \"Exif.Photo.DateTimeDigitized\", path);\n        if (rc == 0) {\n            image->writeMetadata();\n            if (Params::instance().preserve_)\n                ts.touch(path);\n        }\n        return rc ? 1 : 0;\n    } catch (const Exiv2::AnyError& e) {", "target": 0}
{"code": "ZEND_API int _zend_ts_hash_index_update_or_next_insert(TsHashTable *ht, ulong h, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC)\n{\n\tint retval;\n\tbegin_write(ht);\n\tretval = _zend_hash_index_update_or_next_insert(TS_HASH(ht), h, pData, nDataSize, pDest, flag ZEND_FILE_LINE_RELAY_CC);\n\tend_write(ht);\n\treturn retval;\n}", "target": 0}
{"code": "static bool has_cpu_slab(int cpu, void *info)\n{\n\tstruct kmem_cache *s = info;\n\tstruct kmem_cache_cpu *c = per_cpu_ptr(s->cpu_slab, cpu);\n\treturn c->page || slub_percpu_partial(c);\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::EnsureCaretInRect(const gfx::Rect& rect) {\n  gfx::Rect intersected_rect(\n      gfx::IntersectRects(rect, window_->GetBoundsInScreen()));\n  if (intersected_rect.IsEmpty())\n    return;\n  host_->ScrollFocusedEditableNodeIntoRect(\n      ConvertRectFromScreen(intersected_rect));\n}", "target": 0}
{"code": "hugetlb_resv_map_add(struct resv_map *map, struct file_region *rg, long from,\n\t\t     long to, struct hstate *h, struct hugetlb_cgroup *cg,\n\t\t     long *regions_needed)\n{\n\tstruct file_region *nrg;\n\tif (!regions_needed) {\n\t\tnrg = get_file_region_entry_from_cache(map, from, to);\n\t\trecord_hugetlb_cgroup_uncharge_info(cg, h, map, nrg);\n\t\tlist_add(&nrg->link, rg->link.prev);\n\t\tcoalesce_file_region(map, nrg);\n\t} else\n\t\t*regions_needed += 1;\n\treturn to - from;\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_replace,\n                         const Variant& array1,\n                         const Variant& array2 ,\n                         const Array& args ) {\n  getCheckedArray(array1);\n  Array ret = Array::Create();\n  php_array_replace(ret, arr_array1);\n  if (UNLIKELY(array2.isNull() && args.empty())) {\n    return tvReturn(std::move(ret));\n  }\n  getCheckedArray(array2);\n  php_array_replace(ret, arr_array2);\n  for (ArrayIter iter(args); iter; ++iter) {\n    const Variant& v = iter.secondRef();\n    getCheckedArray(v);\n    php_array_replace(ret, arr_v);\n  }\n  return tvReturn(std::move(ret));\n}", "target": 0}
{"code": "WebContents* WebContents::CreateWithSessionStorage(\n    const WebContents::CreateParams& params,\n    const SessionStorageNamespaceMap& session_storage_namespace_map) {\n  WebContentsImpl* new_contents = new WebContentsImpl(\n      params.browser_context, NULL);\n  for (SessionStorageNamespaceMap::const_iterator it =\n           session_storage_namespace_map.begin();\n       it != session_storage_namespace_map.end();\n       ++it) {\n    new_contents->GetController()\n        .SetSessionStorageNamespace(it->first, it->second.get());\n  }\n  new_contents->Init(params);\n  return new_contents;\n}", "target": 0}
{"code": "      static double mp_matrix_svd(_cimg_math_parser& mp) {\n        double *ptrd = &_mp_arg(1) + 1;\n        const double *ptr1 = &_mp_arg(2) + 1;\n        const unsigned int\n          k = (unsigned int)mp.opcode[3],\n          l = (unsigned int)mp.opcode[4];\n        CImg<doubleT> U, S, V;\n        CImg<doubleT>(ptr1,k,l,1,1,true).SVD(U,S,V);\n        CImg<doubleT>(ptrd,k,l,1,1,true) = U;\n        CImg<doubleT>(ptrd + k*l,1,k,1,1,true) = S;\n        CImg<doubleT>(ptrd + k*l + k,k,k,1,1,true) = V;\n        return cimg::type<double>::nan();", "target": 0}
{"code": "node_new_enclosure(enum EnclosureType type)\n{\n  Node* node = node_new();\n  CHECK_NULL_RETURN(node);\n  NODE_SET_TYPE(node, NODE_ENCLOSURE);\n  ENCLOSURE_(node)->type = type;\n  switch (type) {\n  case ENCLOSURE_MEMORY:\n    ENCLOSURE_(node)->m.regnum       =  0;\n    ENCLOSURE_(node)->m.called_addr  = -1;\n    ENCLOSURE_(node)->m.entry_count  =  1;\n    ENCLOSURE_(node)->m.called_state =  0;\n    break;\n  case ENCLOSURE_OPTION:\n    ENCLOSURE_(node)->o.options =  0;\n    break;\n  case ENCLOSURE_STOP_BACKTRACK:\n    break;\n  case ENCLOSURE_IF_ELSE:\n    ENCLOSURE_(node)->te.Then = 0;\n    ENCLOSURE_(node)->te.Else = 0;\n    break;\n  }\n  ENCLOSURE_(node)->opt_count = 0;\n  return node;\n}", "target": 0}
{"code": "static int check_id_allowed(char *id, long what)\n{\n\tif (what & PHP_DATE_TIMEZONE_GROUP_AFRICA     && strncasecmp(id, \"Africa/\",      7) == 0) return 1;\n\tif (what & PHP_DATE_TIMEZONE_GROUP_AMERICA    && strncasecmp(id, \"America/\",     8) == 0) return 1;\n\tif (what & PHP_DATE_TIMEZONE_GROUP_ANTARCTICA && strncasecmp(id, \"Antarctica/\", 11) == 0) return 1;\n\tif (what & PHP_DATE_TIMEZONE_GROUP_ARCTIC     && strncasecmp(id, \"Arctic/\",      7) == 0) return 1;\n\tif (what & PHP_DATE_TIMEZONE_GROUP_ASIA       && strncasecmp(id, \"Asia/\",        5) == 0) return 1;\n\tif (what & PHP_DATE_TIMEZONE_GROUP_ATLANTIC   && strncasecmp(id, \"Atlantic/\",    9) == 0) return 1;\n\tif (what & PHP_DATE_TIMEZONE_GROUP_AUSTRALIA  && strncasecmp(id, \"Australia/\",  10) == 0) return 1;\n\tif (what & PHP_DATE_TIMEZONE_GROUP_EUROPE     && strncasecmp(id, \"Europe/\",      7) == 0) return 1;\n\tif (what & PHP_DATE_TIMEZONE_GROUP_INDIAN     && strncasecmp(id, \"Indian/\",      7) == 0) return 1;\n\tif (what & PHP_DATE_TIMEZONE_GROUP_PACIFIC    && strncasecmp(id, \"Pacific/\",     8) == 0) return 1;\n\tif (what & PHP_DATE_TIMEZONE_GROUP_UTC        && strncasecmp(id, \"UTC\",          3) == 0) return 1;\n\treturn 0;", "target": 0}
{"code": "void PacketReader::xfr48BitInt(uint64_t& ret)\n{\n  ret=0;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n  ret<<=8;\n  ret+=d_content.at(d_pos++);\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageCharUp (gdImagePtr im, gdFontPtr f, int x, int y, int c, int color)\n{\n\tint cx, cy;\n\tint px, py;\n\tint fline;\n\tcx = 0;\n\tcy = 0;\n#ifdef CHARSET_EBCDIC\n\tc = ASC (c);\n#endif \n\tif ((c < f->offset) || (c >= (f->offset + f->nchars))) {\n\t\treturn;\n\t}\n\tfline = (c - f->offset) * f->h * f->w;\n\tfor (py = y; (py > (y - f->w)); py--) {\n\t\tfor (px = x; (px < (x + f->h)); px++) {\n\t\t\tif (f->data[fline + cy * f->w + cx]) {\n\t\t\t\tgdImageSetPixel (im, px, py, color);\n\t\t\t}\n\t\t\tcy++;\n\t\t}\n\t\tcy = 0;\n\t\tcx++;\n\t}\n}", "target": 0}
{"code": "uint32_t address_space_ldub(AddressSpace *as, hwaddr addr,\n                            MemTxAttrs attrs, MemTxResult *result)\n{\n    uint8_t val;\n    MemTxResult r;\n    r = address_space_rw(as, addr, attrs, &val, 1, 0);\n    if (result) {\n        *result = r;\n    }\n    return val;\n}", "target": 0}
{"code": "static void __init floppy_set_flags(int *ints, int param, int param2)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(default_drive_params); i++) {\n\t\tif (param)\n\t\t\tdefault_drive_params[i].params.flags |= param2;\n\t\telse\n\t\t\tdefault_drive_params[i].params.flags &= ~param2;\n\t}\n\tDPRINT(\"%s flag 0x%x\\n\", param2 ? \"Setting\" : \"Clearing\", param);\n}", "target": 0}
{"code": "    void MnHeader::setByteOrder(ByteOrder )\n    {\n    }", "target": 0}
{"code": "static void svm_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\tvar->base = s->base;\n\tvar->limit = s->limit;\n\tvar->selector = s->selector;\n\tvar->type = s->attrib & SVM_SELECTOR_TYPE_MASK;\n\tvar->s = (s->attrib >> SVM_SELECTOR_S_SHIFT) & 1;\n\tvar->dpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\tvar->present = (s->attrib >> SVM_SELECTOR_P_SHIFT) & 1;\n\tvar->avl = (s->attrib >> SVM_SELECTOR_AVL_SHIFT) & 1;\n\tvar->l = (s->attrib >> SVM_SELECTOR_L_SHIFT) & 1;\n\tvar->db = (s->attrib >> SVM_SELECTOR_DB_SHIFT) & 1;\n\tvar->g = s->limit > 0xfffff;\n\tvar->unusable = !var->present || (var->type == 0);\n\tswitch (seg) {\n\tcase VCPU_SREG_TR:\n\t\tvar->type |= 0x2;\n\t\tbreak;\n\tcase VCPU_SREG_DS:\n\tcase VCPU_SREG_ES:\n\tcase VCPU_SREG_FS:\n\tcase VCPU_SREG_GS:\n\t\tif (!var->unusable)\n\t\t\tvar->type |= 0x1;\n\t\tbreak;\n\tcase VCPU_SREG_SS:\n\t\tif (var->unusable)\n\t\t\tvar->db = 0;\n\t\tvar->dpl = to_svm(vcpu)->vmcb->save.cpl;\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "ignorecase_getter(void)\n{\n    rb_warn(\"variable $= is no longer effective\");\n    return Qfalse;\n}", "target": 0}
{"code": "static inline void skb_set_inner_transport_header(struct sk_buff *skb,\n\t\t\t\t\t\t   const int offset)\n{\n\tskb_reset_inner_transport_header(skb);\n\tskb->inner_transport_header += offset;\n}", "target": 0}
{"code": "_vte_terminal_scroll_text (VteTerminal *terminal, int scroll_amount)\n{\n\tVteRowData *row, *old_row;\n\tlong start, end, i;\n\tVteScreen *screen;\n\tscreen = terminal->pvt->screen;\n\tif (screen->scrolling_restricted) {\n\t\tstart = screen->insert_delta + screen->scrolling_region.start;\n\t\tend = screen->insert_delta + screen->scrolling_region.end;\n\t} else {\n\t\tstart = screen->insert_delta;\n\t\tend = start + terminal->row_count - 1;\n\t}\n\told_row = terminal->pvt->free_row;\n\twhile (_vte_ring_next(screen->row_data) <= end) {\n\t\tif (old_row) {\n\t\t\trow = _vte_reset_row_data (terminal, old_row, FALSE);\n\t\t} else {\n\t\t\trow = _vte_new_row_data_sized(terminal, FALSE);\n\t\t}\n\t\told_row = _vte_ring_append(terminal->pvt->screen->row_data, row);\n\t}\n\tterminal->pvt->free_row = old_row;\n\tif (scroll_amount > 0) {\n\t\tfor (i = 0; i < scroll_amount; i++) {\n\t\t\tvte_remove_line_internal(terminal, end);\n\t\t\tvte_insert_line_internal(terminal, start);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < -scroll_amount; i++) {\n\t\t\tvte_remove_line_internal(terminal, start);\n\t\t\tvte_insert_line_internal(terminal, end);\n\t\t}\n\t}\n\t_vte_terminal_scroll_region(terminal, start, end - start + 1,\n\t\t\t\t   scroll_amount);\n\t_vte_terminal_adjust_adjustments(terminal);\n\tterminal->pvt->text_inserted_flag = TRUE;\n\tterminal->pvt->text_deleted_flag = TRUE;\n}", "target": 0}
{"code": "static void vmx_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tu32 ar = vmx_read_guest_seg_ar(to_vmx(vcpu), VCPU_SREG_CS);\n\t*db = (ar >> 14) & 1;\n\t*l = (ar >> 13) & 1;\n}", "target": 0}
{"code": "static inline bool sctp_peer_needs_update(struct sctp_association *asoc)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_ESTABLISHED:\n\tcase SCTP_STATE_SHUTDOWN_PENDING:\n\tcase SCTP_STATE_SHUTDOWN_RECEIVED:\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\tif ((asoc->rwnd > asoc->a_rwnd) &&\n\t\t    ((asoc->rwnd - asoc->a_rwnd) >= max_t(__u32,\n\t\t\t   (asoc->base.sk->sk_rcvbuf >> net->sctp.rwnd_upd_shift),\n\t\t\t   asoc->pathmtu)))\n\t\t\treturn true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt) {\n    xmlChar start[4];\n    xmlCharEncoding enc;\n    if ((ctxt == NULL) || (ctxt->input == NULL))\n        return(-1);\n    xmlDefaultSAXHandlerInit();\n    xmlDetectSAX2(ctxt);\n    GROW;\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);\n    if ((ctxt->input->end - ctxt->input->cur) >= 4) {\n\tstart[0] = RAW;\n\tstart[1] = NXT(1);\n\tstart[2] = NXT(2);\n\tstart[3] = NXT(3);\n\tenc = xmlDetectCharEncoding(start, 4);\n\tif (enc != XML_CHAR_ENCODING_NONE) {\n\t    xmlSwitchEncoding(ctxt, enc);\n\t}\n    }\n    if (CUR == 0) {\n\txmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n    }\n    GROW;\n    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {\n\txmlParseXMLDecl(ctxt);\n\tif (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n\t    return(-1);\n\t}\n\tSKIP_BLANKS;\n    } else {\n\tctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n    }\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n        ctxt->sax->startDocument(ctxt->userData);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n    ctxt->instate = XML_PARSER_CONTENT;\n    ctxt->validate = 0;\n    ctxt->loadsubset = 0;\n    ctxt->depth = 0;\n    xmlParseContent(ctxt);\n    if (ctxt->instate == XML_PARSER_EOF)\n\treturn(-1);\n    if ((RAW == '<') && (NXT(1) == '/')) {\n\txmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    } else if (RAW != 0) {\n\txmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n    }\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n    if (! ctxt->wellFormed) return(-1);\n    return(0);\n}", "target": 0}
{"code": "void cma_dev_get(struct cma_device *cma_dev)\n{\n\trefcount_inc(&cma_dev->refcount);\n}", "target": 0}
{"code": "rdp_out_order_caps(STREAM s)\n{\n\tuint8 order_caps[32];\n\tmemset(order_caps, 0, 32);\n\torder_caps[0] = 1;\t\n\torder_caps[1] = 1;\t\n\torder_caps[2] = 1;\t\n\torder_caps[3] = (g_bitmap_cache ? 1 : 0);\t\n\torder_caps[4] = 0;\t\n\torder_caps[8] = 1;\t\n\torder_caps[9] = 1;\t\n\torder_caps[10] = 1;\t\n\torder_caps[11] = (g_desktop_save ? 1 : 0);\t\n\torder_caps[13] = 1;\t\n\torder_caps[14] = 1;\t\n\torder_caps[20] = (g_polygon_ellipse_orders ? 1 : 0);\t\n\torder_caps[21] = (g_polygon_ellipse_orders ? 1 : 0);\t\n\torder_caps[22] = 1;\t\n\torder_caps[25] = (g_polygon_ellipse_orders ? 1 : 0);\t\n\torder_caps[26] = (g_polygon_ellipse_orders ? 1 : 0);\t\n\torder_caps[27] = 1;\t\n\tout_uint16_le(s, RDP_CAPSET_ORDER);\n\tout_uint16_le(s, RDP_CAPLEN_ORDER);\n\tout_uint8s(s, 20);\t\n\tout_uint16_le(s, 1);\t\n\tout_uint16_le(s, 20);\t\n\tout_uint16(s, 0);\t\n\tout_uint16_le(s, 1);\t\n\tout_uint16_le(s, 0x147);\t\n\tout_uint16_le(s, 0x2a);\t\n\tout_uint8p(s, order_caps, 32);\t\n\tout_uint16_le(s, 0x6a1);\t\n\tout_uint8s(s, 6);\t\n\tout_uint32_le(s, g_desktop_save == False ? 0 : 0x38400);\t\n\tout_uint32(s, 0);\t\n\tout_uint32_le(s, 0x4e4);\t\n}", "target": 0}
{"code": "static apr_status_t php_apache_child_shutdown(void *tmp)\n{\n\tapache2_sapi_module.shutdown(&apache2_sapi_module);\n#if defined(ZTS) && !defined(PHP_WIN32)\n\ttsrm_shutdown();\n#endif\n\treturn APR_SUCCESS;\n}", "target": 0}
{"code": "PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned vaddr = get_te32(&phdr->p_vaddr);\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    unsigned align = get_te32(&phdr->p_align);\n    if (s < t || (u32_t)file_size < s\n    ||  (3 & t) || (7 & (filesz | memsz))  \n    ||  (-1+ align) & (t ^ vaddr)\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_trace)\n{\n\tchar *z_filename, *mode = \"w\";\n\tsize_t z_filename_len, mode_len;\n\tzval *pgsql_link = NULL;\n\tint id = -1, argc = ZEND_NUM_ARGS();\n\tPGconn *pgsql;\n\tFILE *fp = NULL;\n\tphp_stream *stream;\n\tid = FETCH_DEFAULT_LINK();\n\tif (zend_parse_parameters(argc, \"s|sr\", &z_filename, &z_filename_len, &mode, &mode_len, &pgsql_link) == FAILURE) {\n\t\treturn;\n\t}\n\tif (argc < 3) {\n\t\tCHECK_DEFAULT_LINK(id);\n\t}\n\tif (pgsql_link == NULL && id == -1) {\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE2(pgsql, PGconn *, pgsql_link, id, \"PostgreSQL link\", le_link, le_plink);\n\tstream = php_stream_open_wrapper(z_filename, mode, REPORT_ERRORS, NULL);\n\tif (!stream) {\n\t\tRETURN_FALSE;\n\t}\n\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS))\t{\n\t\tphp_stream_close(stream);\n\t\tRETURN_FALSE;\n\t}\n\tphp_stream_auto_cleanup(stream);\n\tPQtrace(pgsql, fp);\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "static int perf_release(struct inode *inode, struct file *file)\n{\n\tput_event(file->private_data);\n\treturn 0;\n}", "target": 0}
{"code": "impl_permission_manager_list (EphyPermissionManager *manager,\n                              const char *type)\n{\n  GList *list = NULL;\n  return list;\n}", "target": 0}
{"code": "static uint make_join_orderinfo(JOIN *join)\n{\n  DBUG_ASSERT(0);\n  JOIN_TAB *tab;\n  if (join->need_tmp)\n    return join->table_count;\n  tab= join->get_sort_by_join_tab();\n  return tab ? (uint)(tab-join->join_tab) : join->table_count;\n}", "target": 0}
{"code": "static ut64 baddr(RBinFile *bf) {\n\treturn 0LL;\n}", "target": 0}
{"code": "    Image::UniquePtr newExvInstance(BasicIo::UniquePtr io, bool create)\n    {\n        Image::UniquePtr image;\n        image = Image::UniquePtr(new ExvImage(std::move(io), create));\n        if (!image->good()) image.reset();\n        return image;\n    }", "target": 0}
{"code": "void ecryptfs_destroy_kthread(void)\n{\n\tstruct ecryptfs_open_req *req, *tmp;\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tecryptfs_kthread_ctl.flags |= ECRYPTFS_KTHREAD_ZOMBIE;\n\tlist_for_each_entry_safe(req, tmp, &ecryptfs_kthread_ctl.req_list,\n\t\t\t\t kthread_ctl_list) {\n\t\tlist_del(&req->kthread_ctl_list);\n\t\t*req->lower_file = ERR_PTR(-EIO);\n\t\tcomplete(&req->done);\n\t}\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\tkthread_stop(ecryptfs_kthread);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n}", "target": 0}
{"code": "gdk_pixbuf__tiff_is_save_option_supported (const gchar *option_key)\n{\n        if (g_strcmp0 (option_key, \"bits-per-sample\") == 0 ||\n            g_strcmp0 (option_key, \"compression\") == 0 ||\n            g_strcmp0 (option_key, \"icc-profile\") == 0 ||\n            g_strcmp0 (option_key, \"x-dpi\") == 0 ||\n            g_strcmp0 (option_key, \"y-dpi\") == 0)\n                return TRUE;\n        return FALSE;\n}", "target": 0}
{"code": "static int get_raid56_logic_offset(u64 physical, int num,\n\t\t\t\t   struct map_lookup *map, u64 *offset,\n\t\t\t\t   u64 *stripe_start)\n{\n\tint i;\n\tint j = 0;\n\tu64 stripe_nr;\n\tu64 last_offset;\n\tu32 stripe_index;\n\tu32 rot;\n\tlast_offset = (physical - map->stripes[num].physical) *\n\t\t      nr_data_stripes(map);\n\tif (stripe_start)\n\t\t*stripe_start = last_offset;\n\t*offset = last_offset;\n\tfor (i = 0; i < nr_data_stripes(map); i++) {\n\t\t*offset = last_offset + i * map->stripe_len;\n\t\tstripe_nr = div64_u64(*offset, map->stripe_len);\n\t\tstripe_nr = div_u64(stripe_nr, nr_data_stripes(map));\n\t\tstripe_nr = div_u64_rem(stripe_nr, map->num_stripes, &rot);\n\t\trot += i;\n\t\tstripe_index = rot % map->num_stripes;\n\t\tif (stripe_index == num)\n\t\t\treturn 0;\n\t\tif (stripe_index < num)\n\t\t\tj++;\n\t}\n\t*offset = last_offset + j * map->stripe_len;\n\treturn 1;\n}", "target": 0}
{"code": "static char * php_zip_make_relative_path(char *path, int path_len) \n{\n\tchar *path_begin = path;\n\tsize_t i;\n\tif (path_len < 1 || path == NULL) {\n\t\treturn NULL;\n\t}\n\tif (IS_SLASH(path[0])) {\n\t\treturn path + 1;\n\t}\n\ti = path_len;\n\twhile (1) {\n\t\twhile (i > 0 && !IS_SLASH(path[i])) {\n\t\t\ti--;\n\t\t}\n\t\tif (!i) {\n\t\t\treturn path;\n\t\t}\n\t\tif (i >= 2 && (path[i -1] == '.' || path[i -1] == ':')) {\n\t\t\tpath_begin = path + i + 1;\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t}\n\treturn path_begin;\n}", "target": 0}
{"code": "ns_client_checkacl(ns_client_t *client, isc_sockaddr_t *sockaddr,\n\t\t   const char *opname, dns_acl_t *acl,\n\t\t   bool default_allow, int log_level)\n{\n\tisc_result_t result;\n\tisc_netaddr_t netaddr;\n\tif (sockaddr != NULL)\n\t\tisc_netaddr_fromsockaddr(&netaddr, sockaddr);\n\tresult = ns_client_checkaclsilent(client, sockaddr ? &netaddr : NULL,\n\t\t\t\t\t  acl, default_allow);\n\tif (result == ISC_R_SUCCESS)\n\t\tns_client_log(client, DNS_LOGCATEGORY_SECURITY,\n\t\t\t      NS_LOGMODULE_CLIENT, ISC_LOG_DEBUG(3),\n\t\t\t      \"%s approved\", opname);\n\telse\n\t\tns_client_log(client, DNS_LOGCATEGORY_SECURITY,\n\t\t\t      NS_LOGMODULE_CLIENT,\n\t\t\t      log_level, \"%s denied\", opname);\n\treturn (result);\n}", "target": 0}
{"code": "static const char *pp_getenv(const Token *t, bool warn)\n{\n    const char *txt = tok_text(t);\n    const char *v;\n    char *buf = NULL;\n    bool is_string = false;\n    if (!t)\n\treturn NULL;\n    switch (t->type) {\n    case TOK_ENVIRON:\n\ttxt += 2;\t\t\n\tis_string = nasm_isquote(*txt);\n\tbreak;\n    case TOK_STRING:\n\tis_string = true;\n\tbreak;\n    case TOK_INTERNAL_STRING:\n    case TOK_NAKED_STRING:\n    case TOK_ID:\n\tis_string = false;\n\tbreak;\n    default:\n\treturn NULL;\n    }\n    if (is_string) {\n\tbuf = nasm_strdup(txt);\n\tnasm_unquote_cstr(buf, NULL);\n\ttxt = buf;\n    }\n    v = getenv(txt);\n    if (warn && !v) {\n\tnasm_warn(WARN_ENVIRONMENT, \"nonexistent environment variable `%s'\", txt);\n\tv = \"\";\n    }\n    if (buf)\n\tnasm_free(buf);\n    return v;\n}", "target": 0}
{"code": "static int nsim_setup_prog_checks(struct netdevsim *ns, struct netdev_bpf *bpf)\n{\n\tif (bpf->prog && bpf->prog->aux->offload) {\n\t\tNSIM_EA(bpf->extack, \"attempt to load offloaded prog to drv\");\n\t\treturn -EINVAL;\n\t}\n\tif (ns->netdev->mtu > NSIM_XDP_MAX_MTU) {\n\t\tNSIM_EA(bpf->extack, \"MTU too large w/ XDP enabled\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ContainedOrOfAndCollapseIndenticalScansWithFilter) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    runQuery(fromjson(\"{c: 1, $or: [{a:1, b:2}, {a:1, b:2, d:3}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {c: 1}, node: {ixscan: {pattern: {a: 1, b: 1}},\"\n        \"bounds: {a: [[1,1,true,true]], b: [[2,2,true,true]]},\"\n        \"filter: null}}}\");\n}", "target": 0}
{"code": "TEST_F(HeaderToMetadataTest, HeaderRemovedTest) {\n  const std::string response_config_yaml = R\"EOF(\nresponse_rules:\n  - header: x-authenticated\n    on_header_present:\n      key: auth\n      type: STRING\n    remove: true\n)EOF\";\n  initializeFilter(response_config_yaml);\n  Http::TestResponseHeaderMapImpl incoming_headers{{\"x-authenticated\", \"1\"}};\n  std::map<std::string, std::string> expected = {{\"auth\", \"1\"}};\n  Http::TestResponseHeaderMapImpl empty_headers;\n  EXPECT_CALL(encoder_callbacks_, streamInfo()).WillRepeatedly(ReturnRef(req_info_));\n  EXPECT_CALL(req_info_,\n              setDynamicMetadata(HttpFilterNames::get().HeaderToMetadata, MapEq(expected)));\n  Http::TestResponseHeaderMapImpl continue_response{{\":status\", \"100\"}};\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue,\n            filter_->encode100ContinueHeaders(continue_response));\n  EXPECT_EQ(Http::FilterHeadersStatus::Continue, filter_->encodeHeaders(incoming_headers, false));\n  EXPECT_EQ(empty_headers, incoming_headers);\n  Http::MetadataMap metadata_map{{\"metadata\", \"metadata\"}};\n  EXPECT_EQ(Http::FilterMetadataStatus::Continue, filter_->encodeMetadata(metadata_map));\n  Buffer::OwnedImpl data(\"data\");\n  EXPECT_EQ(Http::FilterDataStatus::Continue, filter_->encodeData(data, false));\n  Http::TestResponseTrailerMapImpl incoming_trailers;\n  EXPECT_EQ(Http::FilterTrailersStatus::Continue, filter_->encodeTrailers(incoming_trailers));\n}", "target": 0}
{"code": "static int init_rr_cache(THD *thd, READ_RECORD *info)\n{\n  uint rec_cache_size;\n  DBUG_ENTER(\"init_rr_cache\");\n  info->struct_length= 3+MAX_REFLENGTH;\n  info->reclength= ALIGN_SIZE(info->table->s->reclength+1);\n  if (info->reclength < info->struct_length)\n    info->reclength= ALIGN_SIZE(info->struct_length);\n  info->error_offset= info->table->s->reclength;\n  info->cache_records= (thd->variables.read_rnd_buff_size /\n                        (info->reclength+info->struct_length));\n  rec_cache_size= info->cache_records*info->reclength;\n  info->rec_cache_size= info->cache_records*info->ref_length;\n  if (info->cache_records <= 2 ||\n      !(info->cache=(uchar*) my_malloc_lock(rec_cache_size+info->cache_records*\n\t\t\t\t\t   info->struct_length+1,\n\t\t\t\t\t   MYF(MY_THREAD_SPECIFIC))))\n    DBUG_RETURN(1);\n#ifdef HAVE_valgrind\n  bzero(info->cache,rec_cache_size+info->cache_records* info->struct_length+1);\n#endif\n  DBUG_PRINT(\"info\",(\"Allocated buffert for %d records\",info->cache_records));\n  info->read_positions=info->cache+rec_cache_size;\n  info->cache_pos=info->cache_end=info->cache;\n  DBUG_RETURN(0);\n} ", "target": 0}
{"code": "String FrameLoader::encoding() const\n{\n    if (m_encodingWasChosenByUser && !m_encoding.isEmpty())\n        return m_encoding;\n    if (m_decoder && m_decoder->encoding().isValid())\n        return m_decoder->encoding().name();\n    Settings* settings = m_frame->settings();\n    return settings ? settings->defaultTextEncodingName() : String();\n}", "target": 0}
{"code": "static int inet6_netconf_msgsize_devconf(int type)\n{\n\tint size =  NLMSG_ALIGN(sizeof(struct netconfmsg))\n\t\t    + nla_total_size(4);\t\n\tif (type == -1 || type == NETCONFA_FORWARDING)\n\t\tsize += nla_total_size(4);\n#ifdef CONFIG_IPV6_MROUTE\n\tif (type == -1 || type == NETCONFA_MC_FORWARDING)\n\t\tsize += nla_total_size(4);\n#endif\n\treturn size;\n}", "target": 0}
{"code": "ImageLoader::~ImageLoader() {}", "target": 0}
{"code": "gimp_channel_set_opacity (GimpChannel *channel,\n                          gdouble      opacity,\n                          gboolean     push_undo)\n{\n  g_return_if_fail (GIMP_IS_CHANNEL (channel));\n  opacity = CLAMP (opacity, GIMP_OPACITY_TRANSPARENT, GIMP_OPACITY_OPAQUE);\n  if (channel->color.a != opacity)\n    {\n      if (push_undo && gimp_item_is_attached (GIMP_ITEM (channel)))\n        {\n          GimpImage *image = gimp_item_get_image (GIMP_ITEM (channel));\n          gimp_image_undo_push_channel_color (image, C_(\"undo-type\", \"Set Channel Opacity\"),\n                                              channel);\n        }\n      channel->color.a = opacity;\n      if (gimp_filter_peek_node (GIMP_FILTER (channel)))\n        {\n          gimp_gegl_node_set_color (channel->color_node,\n                                    &channel->color);\n        }\n      gimp_drawable_update (GIMP_DRAWABLE (channel), 0, 0, -1, -1);\n      g_signal_emit (channel, channel_signals[COLOR_CHANGED], 0);\n    }\n}", "target": 0}
{"code": "void Shell::SetShelfAlignment(ShelfAlignment alignment,\n                              aura::Window* root_window) {\n  ShelfWidget* shelf_widget = GetRootWindowController(root_window)->shelf();\n  if (shelf_widget->shelf_layout_manager()->SetAlignment(alignment)) {\n    FOR_EACH_OBSERVER(\n        ShellObserver, observers_, OnShelfAlignmentChanged(root_window));\n  }\n}", "target": 0}
{"code": "extractBaseName(const StaticString &path) {\n\tchar *path_copy = strdup(path.c_str());\n\tstring result_string = basename(path_copy);\n\tfree(path_copy);\n\treturn result_string;\n}", "target": 0}
{"code": "bool WasmBinaryBuilder::maybeVisitArraySet(Expression*& out, uint32_t code) {\n  if (code != BinaryConsts::ArraySet) {\n    return false;\n  }\n  auto heapType = getIndexedHeapType();\n  auto* value = popNonVoidExpression();\n  auto* index = popNonVoidExpression();\n  auto* ref = popNonVoidExpression();\n  validateHeapTypeUsingChild(ref, heapType);\n  out = Builder(wasm).makeArraySet(ref, index, value);\n  return true;\n}", "target": 0}
{"code": "PassRefPtr<AccessibilityUIElement> AccessibilityUIElement::disclosedRowAtIndex(unsigned index)\n{\n    return 0;\n}", "target": 0}
{"code": "diff_sorted_lists (GList *list1,\n                   GList *list2,\n                   GCompareFunc compare,\n                   GList **added,\n                   GList **removed)\n{\n  int order;\n  *added = *removed = NULL;\n  while (list1 != NULL && list2 != NULL)\n    {\n      order = (*compare) (list1->data, list2->data);\n      if (order < 0)\n        {\n          *removed = g_list_prepend (*removed, list1->data);\n          list1 = list1->next;\n        }\n      else if (order > 0)\n        {\n          *added = g_list_prepend (*added, list2->data);\n          list2 = list2->next;\n        }\n      else\n        { \n          list1 = list1->next;\n          list2 = list2->next;\n        }\n    }\n  while (list1 != NULL)\n    {\n      *removed = g_list_prepend (*removed, list1->data);\n      list1 = list1->next;\n    }\n  while (list2 != NULL)\n    {\n      *added = g_list_prepend (*added, list2->data);\n      list2 = list2->next;\n    }\n}", "target": 0}
{"code": "  virtual std::string GetHtmlInfo(int refresh) { return std::string(); }", "target": 0}
{"code": "static int addstring(JF, const char *value)\n{\n\tint i;\n\tfor (i = 0; i < F->strlen; ++i)\n\t\tif (!strcmp(F->strtab[i], value))\n\t\t\treturn i;\n\tif (F->strlen >= F->strcap) {\n\t\tF->strcap = F->strcap ? F->strcap * 2 : 16;\n\t\tF->strtab = js_realloc(J, F->strtab, F->strcap * sizeof *F->strtab);\n\t}\n\tF->strtab[F->strlen] = value;\n\treturn F->strlen++;\n}", "target": 0}
{"code": "static void ept_set_mmio_spte_mask(void)\n{\n\tkvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);\n}", "target": 0}
{"code": "static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,\n                               Jpeg2000Component *comp,\n                               Jpeg2000T1Context *t1, Jpeg2000Band *band)\n{\n    int i, j;\n    int w = cblk->coord[0][1] - cblk->coord[0][0];\n    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {\n        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];\n        int *src = t1->data[j];\n        for (i = 0; i < w; ++i)\n            datap[i] = (src[i] * band->i_stepsize + (1 << 14)) >> 15;\n    }\n}", "target": 0}
{"code": "GtkClipboard* Clipboard::LookupBackingClipboard(Buffer clipboard) const {\n  switch (clipboard) {\n    case BUFFER_STANDARD:\n      return clipboard_;\n    case BUFFER_SELECTION:\n      return primary_selection_;\n    default:\n      NOTREACHED();\n      return NULL;\n  }\n}", "target": 0}
{"code": "void nl80211_send_roamed(struct cfg80211_registered_device *rdev,\n\t\t\t struct net_device *netdev, const u8 *bssid,\n\t\t\t const u8 *req_ie, size_t req_ie_len,\n\t\t\t const u8 *resp_ie, size_t resp_ie_len, gfp_t gfp)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, gfp);\n\tif (!msg)\n\t\treturn;\n\thdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_ROAM);\n\tif (!hdr) {\n\t\tnlmsg_free(msg);\n\t\treturn;\n\t}\n\tif (nla_put_u32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx) ||\n\t    nla_put_u32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex) ||\n\t    nla_put(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid) ||\n\t    (req_ie &&\n\t     nla_put(msg, NL80211_ATTR_REQ_IE, req_ie_len, req_ie)) ||\n\t    (resp_ie &&\n\t     nla_put(msg, NL80211_ATTR_RESP_IE, resp_ie_len, resp_ie)))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,\n\t\t\t\tnl80211_mlme_mcgrp.id, gfp);\n\treturn;\n nla_put_failure:\n\tgenlmsg_cancel(msg, hdr);\n\tnlmsg_free(msg);\n}", "target": 0}
{"code": "static int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (emulate_instruction(vcpu, 0) == EMULATE_DONE) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_emulate_halt(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}", "target": 0}
{"code": "ScopedFrameBufferBinder::~ScopedFrameBufferBinder() {\n  ScopedGLErrorSuppressor suppressor(decoder_);\n  FramebufferManager::FramebufferInfo* info =\n      decoder_->bound_framebuffer_.get();\n  GLuint framebuffer_id = info ? info->service_id() : 0;\n  if (framebuffer_id == 0 &&\n      decoder_->offscreen_target_frame_buffer_.get()) {\n    glBindFramebufferEXT(GL_FRAMEBUFFER,\n                         decoder_->offscreen_target_frame_buffer_->id());\n  } else {\n    glBindFramebufferEXT(GL_FRAMEBUFFER, framebuffer_id);\n  }\n}", "target": 0}
{"code": "static inline void ok_jpg_dump_bits(ok_jpg_decoder *decoder) {\n    decoder->input_buffer_bits = 0;\n    decoder->input_buffer_bit_count = 0;\n}", "target": 0}
{"code": "jint InstanceKlass::compute_modifier_flags(TRAPS) const {\n  jint access = access_flags().as_int();\n  InnerClassesIterator iter(this);\n  for (; !iter.done(); iter.next()) {\n    int ioff = iter.inner_class_info_index();\n    if (ioff == 0) continue;\n    Symbol* inner_name = constants()->klass_name_at(ioff);\n    if (name() == inner_name) {\n      access = iter.inner_access_flags();\n      break;\n    }\n  }\n  return (access & (~JVM_ACC_SUPER)) & JVM_ACC_WRITTEN_FLAGS;\n}", "target": 0}
{"code": "bool PrintWebViewHelper::InitPrintSettingsAndPrepareFrame(\n    WebKit::WebFrame* frame, const WebKit::WebNode& node,\n    scoped_ptr<PrepareFrameAndViewForPrint>* prepare) {\n  if (!InitPrintSettings(frame, node))\n    return false;\n  DCHECK(!prepare->get());\n  prepare->reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,\n                                                 frame, node));\n  UpdatePrintableSizeInPrintParameters(frame, node, prepare->get(),\n                                       &print_pages_params_->params);\n  Send(new PrintHostMsg_DidGetDocumentCookie(\n        routing_id(), print_pages_params_->params.document_cookie));\n  return true;\n}", "target": 0}
{"code": "void WebProcessProxy::addBackForwardItem(uint64_t itemID, const String& originalURL, const String& url, const String& title, const CoreIPC::DataReference& backForwardData)\n{\n    MESSAGE_CHECK_URL(originalURL);\n    MESSAGE_CHECK_URL(url);\n    WebBackForwardListItemMap::AddResult result = m_backForwardListItemMap.add(itemID, 0);\n    if (result.isNewEntry) {\n        result.iterator->value = WebBackForwardListItem::create(originalURL, url, title, backForwardData.data(), backForwardData.size(), itemID);\n        return;\n    }\n    result.iterator->value->setOriginalURL(originalURL);\n    result.iterator->value->setURL(url);\n    result.iterator->value->setTitle(title);\n    result.iterator->value->setBackForwardData(backForwardData.data(), backForwardData.size());\n}", "target": 0}
{"code": "static int ok_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ok *pkt;\n\tconst char *ptr;\n\tsize_t alloc_len;\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_OK;\n\tline += 3; \n\tif (!(ptr = strchr(line, '\\n'))) {\n\t\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\t\tgit__free(pkt);\n\t\treturn -1;\n\t}\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tpkt->ref = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}", "target": 0}
{"code": "HeaderUtility::getAllOfHeaderAsString(const HeaderMap& headers, const Http::LowerCaseString& key) {\n  GetAllOfHeaderAsStringResult result;\n  const auto header_value = headers.getAll(key);\n  if (header_value.empty()) {\n  } else if (header_value.size() == 1 ||\n             !Runtime::runtimeFeatureEnabled(\n                 \"envoy.reloadable_features.http_match_on_all_headers\")) {\n    result.result_ = header_value[0]->value().getStringView();\n  } else {\n    absl::InlinedVector<absl::string_view, 3> string_view_vector;\n    string_view_vector.reserve(header_value.size());\n    for (size_t i = 0; i < header_value.size(); i++) {\n      string_view_vector.push_back(header_value[i]->value().getStringView());\n    }\n    result.result_backing_string_ = absl::StrJoin(string_view_vector, \",\");\n  }\n  return result;\n}", "target": 0}
{"code": "void PasswordAutofillAgent::UpdateStateForTextChange(\n    const blink::WebInputElement& element) {\n  blink::WebInputElement mutable_element = element;  \n  if (element.isTextField())\n    nonscript_modified_values_[element] = element.value();\n  blink::WebFrame* const element_frame = element.document().frame();\n  if (!element_frame)\n    return;\n  DCHECK_EQ(element_frame, render_frame()->GetWebFrame());\n  std::unique_ptr<PasswordForm> password_form;\n  if (element.form().isNull()) {\n    password_form = CreatePasswordFormFromUnownedInputElements(\n        *element_frame, &nonscript_modified_values_, &form_predictions_);\n  } else {\n    password_form = CreatePasswordFormFromWebForm(\n        element.form(), &nonscript_modified_values_, &form_predictions_);\n  }\n  ProvisionallySavePassword(std::move(password_form), RESTRICTION_NONE);\n  if (element.isPasswordField()) {\n    PasswordToLoginMap::iterator iter = password_to_username_.find(element);\n    if (iter != password_to_username_.end()) {\n      web_input_to_password_info_[iter->second].password_was_edited_last = true;\n      mutable_element.setAutofilled(false);\n    }\n  }\n}", "target": 0}
{"code": "bm_search_notrev(regex_t* reg, const UChar* target, const UChar* target_end,\n\t\t const UChar* text, const UChar* text_end,\n\t\t const UChar* text_range)\n{\n  const UChar *s, *se, *t, *p, *end;\n  const UChar *tail;\n  ptrdiff_t skip, tlen1;\n# ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"bm_search_notrev: text: %\"PRIuPTR\" (%p), text_end: %\"PRIuPTR\" (%p), text_range: %\"PRIuPTR\" (%p)\\n\",\n\t  text, text, text_end, text_end, text_range, text_range);\n# endif\n  tail = target_end - 1;\n  tlen1 = tail - target;\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n  s = text;\n  if (IS_NULL(reg->int_map)) {\n    while (s < end) {\n      p = se = s + tlen1;\n      t = tail;\n      while (*p == *t) {\n\tif (t == target) return (UChar* )s;\n\tp--; t--;\n      }\n      skip = reg->map[*se];\n      t = s;\n      do {\n\ts += enclen(reg->enc, s, end);\n      } while ((s - t) < skip && s < end);\n    }\n  }\n  else {\n# if OPT_EXACT_MAXLEN >= ONIG_CHAR_TABLE_SIZE\n    while (s < end) {\n      p = se = s + tlen1;\n      t = tail;\n      while (*p == *t) {\n\tif (t == target) return (UChar* )s;\n\tp--; t--;\n      }\n      skip = reg->int_map[*se];\n      t = s;\n      do {\n\ts += enclen(reg->enc, s, end);\n      } while ((s - t) < skip && s < end);\n    }\n# endif\n  }\n  return (UChar* )NULL;\n}", "target": 0}
{"code": "static inline unsigned last_fd(struct fdtable *fdt)\n{\n\treturn fdt->max_fds - 1;\n}", "target": 0}
{"code": "static u64 compute_guest_tsc(struct kvm_vcpu *vcpu, s64 kernel_ns)\n{\n\tu64 tsc = pvclock_scale_delta(kernel_ns-vcpu->arch.last_tsc_nsec,\n\t\t\t\t      vcpu->kvm->arch.virtual_tsc_mult,\n\t\t\t\t      vcpu->kvm->arch.virtual_tsc_shift);\n\ttsc += vcpu->arch.last_tsc_write;\n\treturn tsc;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, EnumerateNestedOr2) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    addIndex(BSON(\"c\" << 1));\n    addIndex(BSON(\"d\" << 1));\n    addIndex(BSON(\"e\" << 1));\n    addIndex(BSON(\"f\" << 1));\n    runQuery(fromjson(\"{a: 1, b: 1, $or: [{c: 1, d: 1}, {e: 1, f: 1}]}\"));\n    assertNumSolutions(6U);\n    assertSolutionExists(\n        \"{fetch: {filter: {a: 1, b: 1}, node: {or: {nodes: [\"\n        \"{fetch: {filter: {d: 1}, node: {ixscan: {pattern: {c: 1}}}}},\"\n        \"{fetch: {filter: {f: 1}, node: {ixscan: {pattern: {e: 1}}}}}\"\n        \"]}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a: 1, b: 1}, node: {or: {nodes: [\"\n        \"{fetch: {filter: {c: 1}, node: {ixscan: {pattern: {d: 1}}}}},\"\n        \"{fetch: {filter: {f: 1}, node: {ixscan: {pattern: {e: 1}}}}}\"\n        \"]}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a: 1, b: 1}, node: {or: {nodes: [\"\n        \"{fetch: {filter: {d: 1}, node: {ixscan: {pattern: {c: 1}}}}},\"\n        \"{fetch: {filter: {e: 1}, node: {ixscan: {pattern: {f: 1}}}}}\"\n        \"]}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {a: 1, b: 1}, node: {or: {nodes: [\"\n        \"{fetch: {filter: {c: 1}, node: {ixscan: {pattern: {d: 1}}}}},\"\n        \"{fetch: {filter: {e: 1}, node: {ixscan: {pattern: {f: 1}}}}}\"\n        \"]}}}}\");\n    assertSolutionExists(\"{fetch: {node: {ixscan: {pattern: {a: 1}}}}}\");\n    assertSolutionExists(\"{fetch: {node: {ixscan: {pattern: {b: 1}}}}}\");\n}", "target": 0}
{"code": "theme_adium_highlight (EmpathyChatView *view,\n\t\t       const gchar     *text,\n\t\t       gboolean         match_case)\n{\n\twebkit_web_view_unmark_text_matches (WEBKIT_WEB_VIEW (view));\n\twebkit_web_view_mark_text_matches (WEBKIT_WEB_VIEW (view),\n\t\t\t\t\t   text, match_case, 0);\n\twebkit_web_view_set_highlight_text_matches (WEBKIT_WEB_VIEW (view),\n\t\t\t\t\t\t    TRUE);\n}", "target": 0}
{"code": "static Item **get_sargable_cond(JOIN *join, TABLE *table)\n{\n  Item **retval;\n  if (table->pos_in_table_list->on_expr)\n  {\n    retval= &table->pos_in_table_list->on_expr;\n  }\n  else if (table->pos_in_table_list->embedding &&\n           !table->pos_in_table_list->embedding->sj_on_expr)\n  {\n    retval= &(table->pos_in_table_list->embedding->on_expr);\n  }\n  else\n  {\n    retval= &join->conds;\n  }\n  return retval;\n}", "target": 0}
{"code": "SPICE_GNUC_VISIBLE const char *spice_server_get_video_codecs(SpiceServer *reds)\n{\n    return video_codecs_to_string(reds_get_video_codecs(reds), \";\");\n}", "target": 0}
{"code": "int zend_spprintf(char **message, int max_len, char *format, ...) \n{\n\tva_list arg;\n\tint len;\n\tva_start(arg, format);\n\tlen = zend_vspprintf(message, max_len, format, arg);\n\tva_end(arg);\n\treturn len;\n}", "target": 0}
{"code": "SV*\nPerl__new_invlist(pTHX_ IV initial_size)\n{\n    SV* new_list;\n    if (initial_size < 0) {\n\tinitial_size = 10;\n    }\n    new_list = newSV_type(SVt_INVLIST);\n    initialize_invlist_guts(new_list, initial_size);\n    return new_list;", "target": 0}
{"code": "ScriptPromise ImageLoader::Decode(ScriptState* script_state,\n                                  ExceptionState& exception_state) {\n  if (!script_state->ContextIsValid()) {\n    exception_state.ThrowDOMException(kEncodingError,\n                                      \"The source image cannot be decoded.\");\n    return ScriptPromise();\n  }\n  UseCounter::Count(GetElement()->GetDocument(), WebFeature::kImageDecodeAPI);\n  auto* request =\n      new DecodeRequest(this, ScriptPromiseResolver::Create(script_state));\n  Microtask::EnqueueMicrotask(\n      WTF::Bind(&DecodeRequest::ProcessForTask, WrapWeakPersistent(request)));\n  decode_requests_.push_back(request);\n  return request->promise();\n}", "target": 0}
{"code": "static ImageEventSender& loadEventSender() {\n  DEFINE_STATIC_LOCAL(ImageEventSender, sender,\n                      (ImageEventSender::create(EventTypeNames::load)));\n  return sender;\n}", "target": 0}
{"code": "uint32_t g_dhcpv6_client_get_iaid(GDHCPClient *dhcp_client)\n{\n\tif (!dhcp_client || dhcp_client->type != G_DHCP_IPV6)\n\t\treturn 0;\n\treturn dhcp_client->iaid;\n}", "target": 0}
{"code": "PHP_FUNCTION(tan)\n{\n\tdouble num;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d\", &num) == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_DOUBLE(tan(num));\n}", "target": 0}
{"code": "bool Item_field::find_item_in_field_list_processor(uchar *arg)\n{\n  KEY_PART_INFO *first_non_group_part= *((KEY_PART_INFO **) arg);\n  KEY_PART_INFO *last_part= *(((KEY_PART_INFO **) arg) + 1);\n  KEY_PART_INFO *cur_part;\n  for (cur_part= first_non_group_part; cur_part != last_part; cur_part++)\n  {\n    if (field->eq(cur_part->field))\n      return TRUE;\n  }\n  return FALSE;\n}", "target": 0}
{"code": "sc_pkcs15emu_add_cert(sc_pkcs15_card_t *p15card,\n\t\tint type, int authority,\n\t\tconst sc_path_t *path,\n\t\tconst sc_pkcs15_id_t *id,\n                const char *label, int obj_flags)\n{\n\tsc_pkcs15_cert_info_t *info;\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t{\n\t\tLOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\tinfo->id\t\t= *id;\n\tinfo->authority\t\t= authority;\n\tif (path)\n\t\tinfo->path = *path;\n\treturn sc_pkcs15emu_add_object(p15card, type, label, info, NULL, obj_flags);\n}", "target": 0}
{"code": "SWFInput_file_seek(SWFInput input, long offset, int whence)\n{\n\tif ( fseek((FILE *)input->data, offset, whence) == -1 )\n\t{\n\t\tif ( errno == EBADF )\n\t\t\tSWF_error(\"This is not a seekable stream- use newSWFInput_stream instead\");\n\t\telse if ( errno == EINVAL )\n\t\t\tSWF_error(\"Invalid whence argument\");\n\t\telse\n\t\t\tSWF_error(\"Unknown error\");\n\t}\n\tif ( whence == SEEK_SET )\n\t\tinput->offset = offset;\n\telse if ( whence == SEEK_END )\n\t\tinput->offset = input->length - offset;\n\telse if ( whence == SEEK_CUR )\n\t\tinput->offset += offset;\n}", "target": 0}
{"code": "place_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int initial)\n{\n\tu64 vruntime;\n\tif (first_fair(cfs_rq)) {\n\t\tvruntime = min_vruntime(cfs_rq->min_vruntime,\n\t\t\t\t__pick_next_entity(cfs_rq)->vruntime);\n\t} else\n\t\tvruntime = cfs_rq->min_vruntime;\n\tif (sched_feat(TREE_AVG)) {\n\t\tstruct sched_entity *last = __pick_last_entity(cfs_rq);\n\t\tif (last) {\n\t\t\tvruntime += last->vruntime;\n\t\t\tvruntime >>= 1;\n\t\t}\n\t} else if (sched_feat(APPROX_AVG) && cfs_rq->nr_running)\n\t\tvruntime += sched_vslice(cfs_rq)/2;\n\tif (initial && sched_feat(START_DEBIT))\n\t\tvruntime += sched_vslice_add(cfs_rq, se);\n\tif (!initial) {\n\t\tif (sched_feat(NEW_FAIR_SLEEPERS)) {\n\t\t\tvruntime -= calc_delta_fair(sysctl_sched_latency,\n\t\t\t\t\t\t    &cfs_rq->load);\n\t\t}\n\t\tvruntime = max_vruntime(se->vruntime, vruntime);\n\t}\n\tse->vruntime = vruntime;\n}", "target": 0}
{"code": "void test_parser_hvi(void) {\n\ttest_parser_param(1);\n}", "target": 0}
{"code": "  Selector_Schema_Obj Parser::parse_selector_schema(const char* end_of_selector, bool chroot)\n  {\n    NESTING_GUARD(nestings);\n    lex< optional_spaces >();\n    const char* i = position;\n    String_Schema* schema = SASS_MEMORY_NEW(String_Schema, pstate);\n    Selector_Schema_Obj selector_schema = SASS_MEMORY_NEW(Selector_Schema, pstate, schema);\n    selector_schema->connect_parent(chroot == false);\n    selector_schema->media_block(last_media_block);\n    while (i < end_of_selector) {\n      if (const char* p = find_first_in_interval< exactly<hash_lbrace>, block_comment >(i, end_of_selector)) {\n        if (i < p) {\n          std::string parsed(i, p);\n          String_Constant_Obj str = SASS_MEMORY_NEW(String_Constant, pstate, parsed);\n          pstate += Offset(parsed);\n          str->update_pstate(pstate);\n          schema->append(str);\n        }\n        const char* j = skip_over_scopes< exactly<hash_lbrace>, exactly<rbrace> >(p + 2, end_of_selector);\n        if (!j || peek < sequence < optional_spaces, exactly<rbrace> > >(p+2)) {\n          position = p+2;\n          css_error(\"Invalid CSS\", \" after \", \": expected expression (e.g. 1px, bold), was \");\n        }\n        pstate.add(p, p+2);\n        Expression_Obj interpolant = Parser::from_c_str(p+2, j, ctx, traces, pstate).parse_list();\n        interpolant->is_interpolant(true);\n        schema->append(interpolant);\n        pstate.add(p+2, j);\n        i = j;\n      }\n      else {\n        if (i < end_of_selector) {\n          std::string parsed(i, end_of_selector);\n          String_Constant_Obj str = SASS_MEMORY_NEW(String_Constant, pstate, parsed);\n          pstate += Offset(parsed);\n          str->update_pstate(pstate);\n          i = end_of_selector;\n          schema->append(str);\n        }\n      }\n    }\n    position = i;\n    selector_schema->update_pstate(pstate);\n    schema->update_pstate(pstate);\n    after_token = before_token = pstate;\n    return selector_schema.detach();\n  }", "target": 0}
{"code": "static int sr9700_set_mac_address(struct net_device *netdev, void *p)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\tstruct sockaddr *addr = p;\n\tif (!is_valid_ether_addr(addr->sa_data)) {\n\t\tnetdev_err(netdev, \"not setting invalid mac address %pM\\n\",\n\t\t\t   addr->sa_data);\n\t\treturn -EINVAL;\n\t}\n\teth_hw_addr_set(netdev, addr->sa_data);\n\tsr_write_async(dev, SR_PAR, 6, netdev->dev_addr);\n\treturn 0;\n}", "target": 0}
{"code": "void FrameLoader::clearProvisionalLoad()\n{\n    setProvisionalDocumentLoader(0);\n    if (Page* page = m_frame->page())\n        page->progress()->progressCompleted(m_frame);\n    setState(FrameStateComplete);\n}", "target": 0}
{"code": "static int16 TIFFClampDoubleToInt16( double val )\n{\n    if( val > 32767 )\n        return 32767;\n    if( val < -32768 || val != val )\n        return -32768;\n    return (int16)val;\n}", "target": 0}
{"code": "GF_GlobalLock * gf_create_PID_file( const char * resourceName )\n{\n\tconst char * prefix = \"/gpac_lock_\";\n\tconst char * dir = gf_get_default_cache_directory();\n\tchar * pidfile;\n\tint flags;\n\tint status;\n\tpidfile = gf_malloc(strlen(dir)+strlen(prefix)+strlen(resourceName)+1);\n\tstrcpy(pidfile, dir);\n\tstrcat(pidfile, prefix);\n\t{\n\t\tconst char *res;\n\t\tchar * pid = &(pidfile[strlen(pidfile)]);\n\t\tfor (res = resourceName; *res ; res++) {\n\t\t\tif (*res >= 'A' && *res <= 'z')\n\t\t\t\t*pid = * res;\n\t\t\telse\n\t\t\t\t*pid = '_';\n\t\t\tpid++;\n\t\t}\n\t\t*pid = '\\0';\n\t}\n\tint fd = open(pidfile, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n\tif (fd == -1)\n\t\tgoto exit;\n\tflags = fcntl(fd, F_GETFD);\n\tif (flags == -1) {\n\t\tgoto exit;\n\t}\n\tflags |= FD_CLOEXEC;\n\tif (fcntl(fd, F_SETFD, flags) == -1) {\n\t\tgoto exit;\n\t}\n\t{\n\t\tstruct flock fl;\n\t\tfl.l_type = F_WRLCK;\n\t\tfl.l_whence = SEEK_SET;\n\t\tfl.l_start = fl.l_len = 0;\n\t\tstatus = fcntl(fd, F_SETLK, &fl);\n\t}\n\tif (status == -1) {\n\t\tgoto exit;\n\t}\n\tif (ftruncate(fd, 0) == -1) {\n\t\tgoto exit;\n\t}\n\t{\n\t\tint sz = 100;\n\t\tchar * buf = gf_malloc( sz );\n\t\tsz = snprintf(buf, sz, \"%ld\\n\", (long) getpid());\n\t\tif (write(fd, buf, sz) != sz) {\n\t\t\tgf_free(buf);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tsync();\n\t{\n\t\tGF_GlobalLock * lock = gf_malloc( sizeof(GF_GlobalLock));\n\t\tlock->resourceName = gf_strdup(resourceName);\n\t\tlock->pidFile = pidfile;\n\t\tlock->fd = fd;\n\t\treturn lock;\n\t}\nexit:\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn NULL;\n}", "target": 0}
{"code": "struct Qdisc *qdisc_alloc(struct net_device *dev, struct Qdisc_ops *ops)\n{\n\tvoid *p;\n\tstruct Qdisc *sch;\n\tunsigned int size;\n\tint err = -ENOBUFS;\n\tsize = QDISC_ALIGN(sizeof(*sch));\n\tsize += ops->priv_size + (QDISC_ALIGNTO - 1);\n\tp = kzalloc(size, GFP_KERNEL);\n\tif (!p)\n\t\tgoto errout;\n\tsch = (struct Qdisc *) QDISC_ALIGN((unsigned long) p);\n\tsch->padded = (char *) sch - (char *) p;\n\tINIT_LIST_HEAD(&sch->list);\n\tskb_queue_head_init(&sch->q);\n\tsch->ops = ops;\n\tsch->enqueue = ops->enqueue;\n\tsch->dequeue = ops->dequeue;\n\tsch->dev = dev;\n\tdev_hold(dev);\n\tatomic_set(&sch->refcnt, 1);\n\treturn sch;\nerrout:\n\treturn ERR_PTR(-err);\n}", "target": 0}
{"code": "NTSTATUS change_notify_add_request(struct smb_request *req,\n\t\t\t\tuint32_t max_param,\n\t\t\t\tuint32_t filter, bool recursive,\n\t\t\t\tstruct files_struct *fsp,\n\t\t\t\tvoid (*reply_fn)(struct smb_request *req,\n\t\t\t\t\tNTSTATUS error_code,\n\t\t\t\t\tuint8_t *buf, size_t len))\n{\n\tstruct notify_change_request *request = NULL;\n\tstruct notify_mid_map *map = NULL;\n\tstruct smbd_server_connection *sconn = req->sconn;\n\tDEBUG(10, (\"change_notify_add_request: Adding request for %s: \"\n\t\t   \"max_param = %d\\n\", fsp_str_dbg(fsp), (int)max_param));\n\tif (!(request = talloc(NULL, struct notify_change_request))\n\t    || !(map = talloc(request, struct notify_mid_map))) {\n\t\tTALLOC_FREE(request);\n\t\treturn NT_STATUS_NO_MEMORY;\n\t}\n\trequest->mid_map = map;\n\tmap->req = request;\n\trequest->req = talloc_move(request, &req);\n\trequest->max_param = max_param;\n\trequest->filter = filter;\n\trequest->fsp = fsp;\n\trequest->reply_fn = reply_fn;\n\trequest->backend_data = NULL;\n\tDLIST_ADD_END(fsp->notify->requests, request);\n\tmap->mid = request->req->mid;\n\tDLIST_ADD(sconn->smb1.notify_mid_maps, map);\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "QemuOpts *vnc_parse(const char *str, Error **errp)\n{\n    QemuOptsList *olist = qemu_find_opts(\"vnc\");\n    QemuOpts *opts = qemu_opts_parse(olist, str, true, errp);\n    const char *id;\n    if (!opts) {\n        return NULL;\n    }\n    id = qemu_opts_id(opts);\n    if (!id) {\n        vnc_auto_assign_id(olist, opts);\n    }\n    return opts;\n}", "target": 0}
{"code": "static av_always_inline void snow_interleave_line_footer(int * i, IDWTELEM * low, IDWTELEM * high){\n    for (; (*i)>=0; (*i)-=2){\n        low[(*i)+1] = high[(*i)>>1];\n        low[*i] = low[(*i)>>1];\n    }\n}", "target": 0}
{"code": "crypt_block (unsigned char *buffer, size_t length, char *salt, size_t saltlen,\n             int iter, const void *iv, size_t ivlen,\n             const char *pw, int cipher_algo, int encrypt)\n{\n  gcry_cipher_hd_t chd;\n  int rc;\n  rc = gcry_cipher_open (&chd, cipher_algo, GCRY_CIPHER_MODE_CBC, 0);\n  if (rc)\n    {\n      log_error ( \"gcry_cipher_open failed: %s\\n\", gpg_strerror(rc));\n      wipememory (buffer, length);\n      return;\n    }\n  if (cipher_algo == GCRY_CIPHER_AES128\n      ? set_key_iv_pbes2 (chd, salt, saltlen, iter, iv, ivlen, pw, cipher_algo)\n      : set_key_iv (chd, salt, saltlen, iter, pw,\n                    cipher_algo == GCRY_CIPHER_RFC2268_40? 5:24))\n    {\n      wipememory (buffer, length);\n      goto leave;\n    }\n  rc = encrypt? gcry_cipher_encrypt (chd, buffer, length, NULL, 0)\n              : gcry_cipher_decrypt (chd, buffer, length, NULL, 0);\n  if (rc)\n    {\n      wipememory (buffer, length);\n      log_error ( \"en/de-crytion failed: %s\\n\", gpg_strerror (rc));\n      goto leave;\n    }\n leave:\n  gcry_cipher_close (chd);\n}", "target": 0}
{"code": "static void php_date_sub(zval *object, zval *interval, zval *return_value TSRMLS_DC)\n{\n\tphp_date_obj     *dateobj;\n\tphp_interval_obj *intobj;\n\ttimelib_time     *new_time;\n\tdateobj = (php_date_obj *) zend_object_store_get_object(object TSRMLS_CC);\n\tDATE_CHECK_INITIALIZED(dateobj->time, DateTime);\n\tintobj = (php_interval_obj *) zend_object_store_get_object(interval TSRMLS_CC);\n\tDATE_CHECK_INITIALIZED(intobj->initialized, DateInterval);\n\tif (intobj->diff->have_special_relative) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Only non-special relative time specifications are supported for subtraction\");\n\t\treturn;\n\t}\n\tnew_time = timelib_sub(dateobj->time, intobj->diff);\n\ttimelib_time_dtor(dateobj->time);\n\tdateobj->time = new_time;", "target": 0}
{"code": "static MagickBooleanType CorrectPSDAlphaBlend(const ImageInfo *image_info,\n  Image *image,ExceptionInfo* exception)\n{\n  const char\n    *option;\n  MagickBooleanType\n    status;\n  ssize_t\n    y;\n  if (image->alpha_trait != BlendPixelTrait || image->colorspace != sRGBColorspace)\n    return(MagickTrue);\n  option=GetImageOption(image_info,\"psd:alpha-unblend\");\n  if (IsStringFalse(option) != MagickFalse)\n    return(MagickTrue);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#pragma omp parallel for schedule(static,4) shared(status) \\\n  magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n    register ssize_t\n      x;\n    if (status == MagickFalse)\n      continue;\n    q=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n    {\n      status=MagickFalse;\n      continue;\n    }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        gamma;\n      register ssize_t\n        i;\n      gamma=QuantumScale*GetPixelAlpha(image, q);\n      if (gamma != 0.0 && gamma != 1.0)\n        {\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            if (channel != AlphaPixelChannel)\n              q[i]=ClampToQuantum((q[i]-((1.0-gamma)*QuantumRange))/gamma);\n          }\n        }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  return(status);\n}", "target": 0}
{"code": "  Address has_pending_message_address() {\n    return reinterpret_cast<Address>(&thread_local_top_.has_pending_message_);\n  }", "target": 0}
{"code": "gen_int(codegen_scope *s, uint16_t dst, mrb_int i)\n{\n  if (i < 0) {\n    if (i == -1) genop_1(s, OP_LOADI__1, dst);\n    else if (i >= -0xff) genop_2(s, OP_LOADINEG, dst, (uint16_t)-i);\n    else if (i >= INT16_MIN) genop_2S(s, OP_LOADI16, dst, (uint16_t)i);\n    else if (i >= INT32_MIN) genop_2SS(s, OP_LOADI32, dst, (uint32_t)i);\n    else goto int_lit;\n  }\n  else if (i < 8) genop_1(s, OP_LOADI_0 + (uint8_t)i, dst);\n  else if (i <= 0xff) genop_2(s, OP_LOADI, dst, (uint16_t)i);\n  else if (i <= INT16_MAX) genop_2S(s, OP_LOADI16, dst, (uint16_t)i);\n  else if (i <= INT32_MAX) genop_2SS(s, OP_LOADI32, dst, (uint32_t)i);\n  else {\n  int_lit:\n    genop_2(s, OP_LOADL, dst, new_lit(s, mrb_int_value(s->mrb, i)));\n  }\n}", "target": 0}
{"code": "LogData::~LogData() {\n}", "target": 0}
{"code": "void stri_box_del(GF_Box *s)\n{\n\tGF_SubTrackInformationBox *ptr = (GF_SubTrackInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->attribute_list) gf_free(ptr->attribute_list);\n\tgf_free(ptr);\n}", "target": 0}
{"code": "virSecuritySELinuxLXCInitialize(virSecurityManager *mgr)\n{\n    g_autoptr(virConf) selinux_conf = NULL;\n    virSecuritySELinuxData *data = virSecurityManagerGetPrivateData(mgr);\n    data->skipAllLabel = true;\n    data->label_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);\n    if (!data->label_handle) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot open SELinux label_handle\"));\n        return -1;\n    }\n    if (!(selinux_conf = virConfReadFile(selinux_lxc_contexts_path(), 0)))\n        goto error;\n    if (virConfGetValueString(selinux_conf, \"process\", &data->domain_context) < 0)\n        goto error;\n    if (!data->domain_context) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'process' value in selinux lxc contexts file '%s'\"),\n                       selinux_lxc_contexts_path());\n        goto error;\n    }\n    if (virConfGetValueString(selinux_conf, \"file\", &data->file_context) < 0)\n        goto error;\n    if (!data->file_context) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'file' value in selinux lxc contexts file '%s'\"),\n                       selinux_lxc_contexts_path());\n        goto error;\n    }\n    if (virConfGetValueString(selinux_conf, \"content\", &data->content_context) < 0)\n        goto error;\n    if (!data->content_context) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing 'content' value in selinux lxc contexts file '%s'\"),\n                       selinux_lxc_contexts_path());\n        goto error;\n    }\n    if (!(data->mcs = virHashNew(NULL)))\n        goto error;\n    return 0;\n error:\n    selabel_close(data->label_handle);\n    data->label_handle = NULL;\n    VIR_FREE(data->domain_context);\n    VIR_FREE(data->file_context);\n    VIR_FREE(data->content_context);\n    virHashFree(data->mcs);\n    return -1;\n}", "target": 0}
{"code": "static void ResetPixelList(PixelList *pixel_list)\n{\n  int\n    level;\n  SkipNode\n    *root;\n  SkipList\n    *p;\n  p=(&pixel_list->skip_list);\n  root=p->nodes+65536UL;\n  p->level=0;\n  for (level=0; level < 9; level++)\n    root->next[level]=65536UL;\n  pixel_list->seed=pixel_list->signature++;\n}", "target": 0}
{"code": "TEST_P(RBACIntegrationTest, DeniedWithDenyAction) {\n  useAccessLog(\"%RESPONSE_CODE_DETAILS%\");\n  config_helper_.addFilter(RBAC_CONFIG_WITH_DENY_ACTION);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response = codec_client_->makeRequestWithBody(\n      Http::TestRequestHeaderMapImpl{\n          {\":method\", \"GET\"},\n          {\":path\", \"/\"},\n          {\":scheme\", \"http\"},\n          {\":authority\", \"host\"},\n          {\"x-forwarded-for\", \"10.0.0.1\"},\n      },\n      1024);\n  response->waitForEndStream();\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"403\", response->headers().getStatusValue());\n  EXPECT_THAT(waitForAccessLog(access_log_name_),\n              testing::HasSubstr(\"rbac_access_denied_matched_policy[deny_policy]\"));\n}", "target": 0}
{"code": "String BaseAudioContext::state() const {\n  switch (context_state_) {\n    case kSuspended:\n      return \"suspended\";\n    case kRunning:\n      return \"running\";\n    case kClosed:\n      return \"closed\";\n  }\n  NOTREACHED();\n  return \"\";\n}", "target": 0}
{"code": "static int send_sub_rect(VncState *vs, int x, int y, int w, int h)\n{\n    uint32_t bg = 0, fg = 0;\n    int colors;\n    int ret = 0;\n#ifdef CONFIG_VNC_JPEG\n    bool force_jpeg = false;\n    bool allow_jpeg = true;\n#endif\n    if (!color_count_palette) {\n        color_count_palette = g_malloc(sizeof(VncPalette));\n        vnc_tight_cleanup_notifier.notify = vnc_tight_cleanup;\n        qemu_thread_atexit_add(&vnc_tight_cleanup_notifier);\n    }\n    vnc_framebuffer_update(vs, x, y, w, h, vs->tight->type);\n    vnc_tight_start(vs);\n    vnc_raw_send_framebuffer_update(vs, x, y, w, h);\n    vnc_tight_stop(vs);\n#ifdef CONFIG_VNC_JPEG\n    if (!vs->vd->non_adaptive && vs->tight->quality != (uint8_t)-1) {\n        double freq = vnc_update_freq(vs, x, y, w, h);\n        if (freq < tight_jpeg_conf[vs->tight->quality].jpeg_freq_min) {\n            allow_jpeg = false;\n        }\n        if (freq >= tight_jpeg_conf[vs->tight->quality].jpeg_freq_threshold) {\n            force_jpeg = true;\n            vnc_sent_lossy_rect(vs, x, y, w, h);\n        }\n    }\n#endif\n    colors = tight_fill_palette(vs, x, y, w * h, &bg, &fg, color_count_palette);\n#ifdef CONFIG_VNC_JPEG\n    if (allow_jpeg && vs->tight->quality != (uint8_t)-1) {\n        ret = send_sub_rect_jpeg(vs, x, y, w, h, bg, fg, colors,\n                                 color_count_palette, force_jpeg);\n    } else {\n        ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors,\n                                   color_count_palette);\n    }\n#else\n    ret = send_sub_rect_nojpeg(vs, x, y, w, h, bg, fg, colors,\n                               color_count_palette);\n#endif\n    return ret;\n}", "target": 0}
{"code": "static uint32_t ok_png_get_width_for_pass(const ok_png_decoder *decoder) {\n    const uint32_t w = decoder->png->width;\n    if (decoder->interlace_method == 0) {\n        return w;\n    }\n    switch (decoder->interlace_pass) {\n        case 1: return (w + 7) / 8;\n        case 2: return (w + 3) / 8;\n        case 3: return (w + 3) / 4;\n        case 4: return (w + 1) / 4;\n        case 5: return (w + 1) / 2;\n        case 6: return w / 2;\n        case 7: return w;\n        default: return 0;\n    }\n}", "target": 0}
{"code": "generate_ava(cms_context *cms, SECItem *der, CERTAVA *certava)\n{\n\tava ava;\n\tSECOidData *oid;\n\tvoid *arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n\tif (arena == NULL)\n\t\tcmsreterr(-1, cms, \"could not create arena\");\n\tvoid *real_arena = cms->arena;\n\tcms->arena = arena;\n\toid = SECOID_FindOID(&certava->type);\n\tif (!oid) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcmsreterr(-1, cms, \"could not find OID\");\n\t}\n\tint rc = generate_object_id(cms, &ava.type, oid->offset);\n\tif (rc < 0) {\n\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\tcms->arena = real_arena;\n\t\treturn -1;\n\t}\n\tmemcpy(&ava.value, &certava->value, sizeof (ava.value));\n\tvoid *ret;\n\tSECItem tmp;\n\tret = SEC_ASN1EncodeItem(arena, &tmp, &ava, AVATemplate);\n\tif (ret == NULL) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcmsreterr(-1, cms, \"could not encode AVA\");\n\t}\n\tder->type = tmp.type;\n\tder->len = tmp.len;\n\tder->data = PORT_ArenaAlloc(real_arena, tmp.len);\n\tif (!der->data) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcmsreterr(-1, cms, \"could not allocate AVA\");\n\t}\n\tmemcpy(der->data, tmp.data, tmp.len);\n\tPORT_FreeArena(arena, PR_TRUE);\n\tcms->arena = real_arena;\n\treturn 0;\n}", "target": 0}
{"code": "static int __tipc_nl_compat_link_set(struct sk_buff *skb,\n\t\t\t\t     struct tipc_nl_compat_msg *msg)\n{\n\tstruct nlattr *prop;\n\tstruct nlattr *link;\n\tstruct tipc_link_config *lc;\n\tlc = (struct tipc_link_config *)TLV_DATA(msg->req);\n\tlink = nla_nest_start(skb, TIPC_NLA_LINK);\n\tif (!link)\n\t\treturn -EMSGSIZE;\n\tif (nla_put_string(skb, TIPC_NLA_LINK_NAME, lc->name))\n\t\treturn -EMSGSIZE;\n\tprop = nla_nest_start(skb, TIPC_NLA_LINK_PROP);\n\tif (!prop)\n\t\treturn -EMSGSIZE;\n\t__tipc_add_link_prop(skb, msg, lc);\n\tnla_nest_end(skb, prop);\n\tnla_nest_end(skb, link);\n\treturn 0;\n}", "target": 0}
{"code": "static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(vcpu);\n}", "target": 0}
{"code": "    ~FrameProgressTracker()\n    {\n        ASSERT(!m_inProgress || m_frame->page());\n        if (m_inProgress)\n            m_frame->page()->progress().progressCompleted(m_frame);\n    }", "target": 0}
{"code": "static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tbreak;\n\t}\n\tcs_sel |= SELECTOR_RPL_MASK;\n\tss_sel |= SELECTOR_RPL_MASK;\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->_eip = ctxt->regs[VCPU_REGS_RDX];\n\tctxt->regs[VCPU_REGS_RSP] = ctxt->regs[VCPU_REGS_RCX];\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static void nfs4_xdr_enc_getattr(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t const struct nfs4_getattr_arg *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_getfattr(xdr, args->bitmask, &hdr);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "  explicit SparseFillEmptyRowsGradOp(OpKernelConstruction* context)\n      : OpKernel(context) {}", "target": 0}
{"code": "static uint16_t nvme_map_addr_cmb(NvmeCtrl *n, QEMUIOVector *iov, hwaddr addr,\n                                  size_t len)\n{\n    if (!len) {\n        return NVME_SUCCESS;\n    }\n    trace_pci_nvme_map_addr_cmb(addr, len);\n    if (!nvme_addr_is_cmb(n, addr) || !nvme_addr_is_cmb(n, addr + len - 1)) {\n        return NVME_DATA_TRAS_ERROR;\n    }\n    qemu_iovec_add(iov, nvme_addr_to_cmb(n, addr), len);\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "base::string16 Browser::GetWindowTitleForTab(bool include_app_name,\n                                             int index) const {\n  return GetWindowTitleFromWebContents(\n      include_app_name, tab_strip_model_->GetWebContentsAt(index));\n}", "target": 0}
{"code": "DECLAREcpFunc(cpSeparateTiles2SeparateStrips)\n{\n\treturn cpImage(in, out,\n\t    readSeparateTilesIntoBuffer,\n\t    writeBufferToSeparateStrips,\n\t    imagelength, imagewidth, spp);\n}", "target": 0}
{"code": "void LinkResolver::resolve_dynamic_call(CallInfo& result,\n                                        BootstrapInfo& bootstrap_specifier,\n                                        TRAPS) {\n  SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);\n  Exceptions::wrap_dynamic_exception( true, THREAD);\n  if (HAS_PENDING_EXCEPTION) {\n    if (!PENDING_EXCEPTION->is_a(vmClasses::LinkageError_klass())) {\n      return;\n    }\n     bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);\n     if (!recorded_res_status) {\n       bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);\n       if (is_done) return;\n     }\n     assert(bootstrap_specifier.invokedynamic_cp_cache_entry()->indy_resolution_failed(),\n            \"Resolution failure flag wasn't set\");\n  }\n  bootstrap_specifier.resolve_newly_linked_invokedynamic(result, CHECK);\n}", "target": 0}
{"code": "  void *malloc(size_t sz)\n  {\n#ifdef LIBRAW_USE_CALLOC_INSTEAD_OF_MALLOC\n    void *ptr = ::calloc(sz + extra_bytes, 1);\n#else\n    void *ptr = ::malloc(sz + extra_bytes);\n#endif\n    mem_ptr(ptr);\n    return ptr;\n  }", "target": 0}
{"code": "XML_UseForeignDTD(XML_Parser parser, XML_Bool useDTD) {\n  if (parser == NULL)\n    return XML_ERROR_INVALID_ARGUMENT;\n#ifdef XML_DTD\n  if (parser->m_parsingStatus.parsing == XML_PARSING\n      || parser->m_parsingStatus.parsing == XML_SUSPENDED)\n    return XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING;\n  parser->m_useForeignDTD = useDTD;\n  return XML_ERROR_NONE;\n#else\n  UNUSED_P(useDTD);\n  return XML_ERROR_FEATURE_REQUIRES_XML_DTD;\n#endif\n}", "target": 0}
{"code": "void cgit_print_filemode(unsigned short mode)\n{\n\tif (S_ISDIR(mode))\n\t\thtml(\"d\");\n\telse if (S_ISLNK(mode))\n\t\thtml(\"l\");\n\telse if (S_ISGITLINK(mode))\n\t\thtml(\"m\");\n\telse\n\t\thtml(\"-\");\n\thtml_fileperm(mode >> 6);\n\thtml_fileperm(mode >> 3);\n\thtml_fileperm(mode);\n}", "target": 0}
{"code": "static int __init setup_acpi_sci(char *s)\n{\n\tif (!s)\n\t\treturn -EINVAL;\n\tif (!strcmp(s, \"edge\"))\n\t\tacpi_sci_flags.trigger = 1;\n\telse if (!strcmp(s, \"level\"))\n\t\tacpi_sci_flags.trigger = 3;\n\telse if (!strcmp(s, \"high\"))\n\t\tacpi_sci_flags.polarity = 1;\n\telse if (!strcmp(s, \"low\"))\n\t\tacpi_sci_flags.polarity = 3;\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "theme_adium_scroll (EmpathyChatView *view,\n\t\t    gboolean         allow_scrolling)\n{\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (view);\n\tpriv->allow_scrolling = allow_scrolling;\n\tif (allow_scrolling) {\n\t\tempathy_chat_view_scroll_down (view);\n\t}\n}", "target": 0}
{"code": "static inline void skb_reset_inner_mac_header(struct sk_buff *skb)\n{\n\tskb->inner_mac_header = skb->data - skb->head;\n}", "target": 0}
{"code": "imapx_untagged_list (CamelIMAPXServer *is,\n                     GInputStream *input_stream,\n                     GCancellable *cancellable,\n                     GError **error)\n{\n\tCamelIMAPXListResponse *response;\n\tCamelIMAPXStore *imapx_store;\n\tconst gchar *mailbox_name;\n\tgchar separator;\n\tg_return_val_if_fail (CAMEL_IS_IMAPX_SERVER (is), FALSE);\n\tresponse = camel_imapx_list_response_new (\n\t\tCAMEL_IMAPX_INPUT_STREAM (input_stream), cancellable, error);\n\tif (response == NULL)\n\t\treturn FALSE;\n\tmailbox_name = camel_imapx_list_response_get_mailbox_name (response);\n\tseparator = camel_imapx_list_response_get_separator (response);\n\tif (camel_imapx_mailbox_is_inbox (mailbox_name))\n\t\tis->priv->inbox_separator = separator;\n\timapx_store = camel_imapx_server_ref_store (is);\n\tcamel_imapx_store_handle_list_response (imapx_store, is, response);\n\tg_clear_object (&imapx_store);\n\tg_clear_object (&response);\n\treturn TRUE;\n}", "target": 0}
{"code": "cgraph_edge_brings_value_p (cgraph_edge *cs, ipcp_value_source<tree> *src,\n\t\t\t    cgraph_node *dest, ipcp_value<tree> *dest_val)\n{\n  class ipa_node_params *caller_info = IPA_NODE_REF (cs->caller);\n  enum availability availability;\n  cgraph_node *real_dest = cs->callee->function_symbol (&availability);\n  if (availability <= AVAIL_INTERPOSABLE\n      || !same_node_or_its_all_contexts_clone_p (real_dest, dest)\n      || caller_info->node_dead)\n    return false;\n  if (!src->val)\n    return true;\n  if (caller_info->ipcp_orig_node)\n    {\n      tree t;\n      if (src->offset == -1)\n\tt = caller_info->known_csts[src->index];\n      else\n\tt = get_clone_agg_value (cs->caller, src->offset, src->index);\n      return (t != NULL_TREE\n\t      && values_equal_for_ipcp_p (src->val->value, t));\n    }\n  else\n    {\n      if (src->val == dest_val)\n\treturn true;\n      struct ipcp_agg_lattice *aglat;\n      class ipcp_param_lattices *plats = ipa_get_parm_lattices (caller_info,\n\t\t\t\t\t\t\t\t src->index);\n      if (src->offset == -1)\n\treturn (plats->itself.is_single_const ()\n\t\t&& values_equal_for_ipcp_p (src->val->value,\n\t\t\t\t\t    plats->itself.values->value));\n      else\n\t{\n\t  if (plats->aggs_bottom || plats->aggs_contain_variable)\n\t    return false;\n\t  for (aglat = plats->aggs; aglat; aglat = aglat->next)\n\t    if (aglat->offset == src->offset)\n\t      return  (aglat->is_single_const ()\n\t\t       && values_equal_for_ipcp_p (src->val->value,\n\t\t\t\t\t\t   aglat->values->value));\n\t}\n      return false;\n    }\n}", "target": 0}
{"code": "void dump_bucket(struct req_state *s, RGWBucketEnt& obj)\n{\n  s->formatter->open_object_section(\"Bucket\");\n  s->formatter->dump_string(\"Name\", obj.bucket.name);\n  dump_time(s, \"CreationDate\", &obj.creation_time);\n  s->formatter->close_section();\n}", "target": 0}
{"code": "static bool bpf_map_is_rdonly(const struct bpf_map *map)\n{\n\treturn (map->map_flags & BPF_F_RDONLY_PROG) &&\n\t       READ_ONCE(map->frozen) &&\n\t       !bpf_map_write_active(map);\n}", "target": 0}
{"code": "static void tcp_clamp_window(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\ticsk->icsk_ack.quick = 0;\n\tif (sk->sk_rcvbuf < sysctl_tcp_rmem[2] &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK) &&\n\t    !tcp_under_memory_pressure(sk) &&\n\t    sk_memory_allocated(sk) < sk_prot_mem_limits(sk, 0)) {\n\t\tsk->sk_rcvbuf = min(atomic_read(&sk->sk_rmem_alloc),\n\t\t\t\t    sysctl_tcp_rmem[2]);\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)\n\t\ttp->rcv_ssthresh = min(tp->window_clamp, 2U * tp->advmss);\n}", "target": 0}
{"code": "void RenderView::OnAutoFillFormDataFilled(int query_id,\n                                          const webkit_glue::FormData& form) {\n  autofill_helper_.FormDataFilled(query_id, form);\n}", "target": 0}
{"code": "time_t auth_client_request_get_create_time(struct auth_client_request *request)\n{\n\treturn request->created;\n}", "target": 0}
{"code": "GF_Err dmlp_box_size(GF_Box *s)\n{\n\ts->size += 10;\n\treturn GF_OK;\n}", "target": 0}
{"code": "void ieee80211_rx_irqsafe(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_local *local = hw_to_local(hw);\n\tBUILD_BUG_ON(sizeof(struct ieee80211_rx_status) > sizeof(skb->cb));\n\tskb->pkt_type = IEEE80211_RX_MSG;\n\tskb_queue_tail(&local->skb_queue, skb);\n\ttasklet_schedule(&local->tasklet);\n}", "target": 0}
{"code": "void gnutls_x509_aki_deinit(gnutls_x509_aki_t aki)\n{\n\tgnutls_free(aki->serial.data);\n\tgnutls_free(aki->id.data);\n\tsubject_alt_names_deinit(&aki->cert_issuer);\n\tgnutls_free(aki);\n}", "target": 0}
{"code": "  ~ArraySortTmp() {\n    if (m_ad != m_arr.get()) {\n      m_arr = Array::attach(m_ad);\n    }\n  }", "target": 0}
{"code": "static void change_font_size(ASS_Renderer *render_priv, double sz)\n{\n    render_priv->state.font_size = sz;\n}", "target": 0}
{"code": "acl_fetch_chdr_ip(struct proxy *px, struct session *l4, void *l7, int dir,\n\t\t   struct acl_expr *expr, struct acl_test *test)\n{\n\tstruct http_txn *txn = l7;\n\tif (!txn)\n\t\treturn 0;\n\tif (txn->req.msg_state < HTTP_MSG_BODY)\n\t\treturn 0;\n\tif (txn->rsp.msg_state != HTTP_MSG_RPBEFORE)\n\t\treturn 0;\n\treturn acl_fetch_hdr_ip(px, l4, txn, txn->req.sol, expr, test);\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::OnGestureEvent(ui::GestureEvent* event) {\n  TRACE_EVENT0(\"input\", \"RenderWidgetHostViewAura::OnGestureEvent\");\n  if ((event->type() == ui::ET_GESTURE_PINCH_BEGIN ||\n      event->type() == ui::ET_GESTURE_PINCH_UPDATE ||\n      event->type() == ui::ET_GESTURE_PINCH_END) && !ShouldSendPinchGesture()) {\n    event->SetHandled();\n    return;\n  }\n  if (touch_editing_client_ && touch_editing_client_->HandleInputEvent(event))\n    return;\n  RenderViewHostDelegate* delegate = NULL;\n  if (popup_type_ == blink::WebPopupTypeNone && !is_fullscreen_)\n    delegate = RenderViewHost::From(host_)->GetDelegate();\n  if (delegate && event->type() == ui::ET_GESTURE_BEGIN &&\n      event->details().touch_points() == 1) {\n    delegate->HandleGestureBegin();\n  }\n  blink::WebGestureEvent gesture = MakeWebGestureEvent(event);\n  if (event->type() == ui::ET_GESTURE_TAP_DOWN) {\n    blink::WebGestureEvent fling_cancel = gesture;\n    fling_cancel.type = blink::WebInputEvent::GestureFlingCancel;\n    fling_cancel.sourceDevice = blink::WebGestureEvent::Touchscreen;\n    host_->ForwardGestureEvent(fling_cancel);\n  }\n  if (gesture.type != blink::WebInputEvent::Undefined) {\n    host_->ForwardGestureEventWithLatencyInfo(gesture, *event->latency());\n    if (event->type() == ui::ET_GESTURE_SCROLL_BEGIN ||\n        event->type() == ui::ET_GESTURE_SCROLL_UPDATE ||\n        event->type() == ui::ET_GESTURE_SCROLL_END) {\n      RecordAction(base::UserMetricsAction(\"TouchscreenScroll\"));\n    } else if (event->type() == ui::ET_SCROLL_FLING_START) {\n      RecordAction(base::UserMetricsAction(\"TouchscreenScrollFling\"));\n    }\n  }\n  if (delegate && event->type() == ui::ET_GESTURE_END &&\n      event->details().touch_points() == 1) {\n    delegate->HandleGestureEnd();\n  }\n  event->SetHandled();\n}", "target": 0}
{"code": "static int max_sectors_bytes(struct request_queue *q)\n{\n\tunsigned int max_sectors = queue_max_sectors(q);\n\tmax_sectors = min_t(unsigned int, max_sectors, INT_MAX >> 9);\n\treturn max_sectors << 9;\n}", "target": 0}
{"code": "SYSCALL_DEFINE4(request_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst char __user *, _callout_info,\n\t\tkey_serial_t, destringid)\n{\n\tstruct key_type *ktype;\n\tstruct key *key;\n\tkey_ref_t dest_ref;\n\tsize_t callout_len;\n\tchar type[32], *description, *callout_info;\n\tlong ret;\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\tdescription = strndup_user(_description, PAGE_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\tcallout_info = NULL;\n\tcallout_len = 0;\n\tif (_callout_info) {\n\t\tcallout_info = strndup_user(_callout_info, PAGE_SIZE);\n\t\tif (IS_ERR(callout_info)) {\n\t\t\tret = PTR_ERR(callout_info);\n\t\t\tgoto error2;\n\t\t}\n\t\tcallout_len = strlen(callout_info);\n\t}\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\tkey = request_key_and_link(ktype, description, callout_info,\n\t\t\t\t   callout_len, NULL, key_ref_to_ptr(dest_ref),\n\t\t\t\t   KEY_ALLOC_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error5;\n\t}\n\tret = wait_for_key_construction(key, 1);\n\tif (ret < 0)\n\t\tgoto error6;\n\tret = key->serial;\nerror6:\n \tkey_put(key);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkfree(callout_info);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "void SimpleSoftOMXComponent::onChangeState(OMX_STATETYPE state) {\n    CHECK_EQ((int)mState, (int)mTargetState);\n switch (mState) {\n case OMX_StateLoaded:\n            CHECK_EQ((int)state, (int)OMX_StateIdle);\n break;\n case OMX_StateIdle:\n            CHECK(state == OMX_StateLoaded || state == OMX_StateExecuting);\n break;\n case OMX_StateExecuting:\n {\n            CHECK_EQ((int)state, (int)OMX_StateIdle);\n for (size_t i = 0; i < mPorts.size(); ++i) {\n                onPortFlush(i, false );\n }\n            mState = OMX_StateIdle;\n            notify(OMX_EventCmdComplete, OMX_CommandStateSet, state, NULL);\n break;\n }\n default:\n            TRESPASS();\n }\n    mTargetState = state;\n    checkTransitions();\n}", "target": 0}
{"code": "int lcc_network_buffer_finalize (lcc_network_buffer_t *nb) \n{\n  if (nb == NULL)\n    return (EINVAL);\n#if HAVE_LIBGCRYPT\n  if (nb->seclevel == SIGN)\n    nb_add_signature (nb);\n  else if (nb->seclevel == ENCRYPT)\n    nb_add_encryption (nb);\n#endif\n  return (0);\n} ", "target": 0}
{"code": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}", "target": 0}
{"code": "bool HttpStreamParser::ShouldMergeRequestHeadersAndBody(\n    const std::string& request_headers,\n    const UploadDataStream* request_body) {\n  if (request_body != NULL &&\n      request_body->IsInMemory() &&\n      request_body->size() > 0) {\n    size_t merged_size = request_headers.size() + request_body->size();\n    if (merged_size <= kMaxMergedHeaderAndBodySize)\n      return true;\n  }\n  return false;\n}", "target": 0}
{"code": "mysql_connect(MYSQL *mysql,const char *host,\n\t      const char *user, const char *passwd)\n{\n  MYSQL *res;\n  mysql=mysql_init(mysql);\t\t\t\n  {\n    DBUG_ENTER(\"mysql_connect\");\n    if (!(res=mysql_real_connect(mysql,host,user,passwd,NullS,0,NullS,0)))\n    {\n      if (mysql->free_me)\n\tmy_free(mysql);\n    }\n    mysql->reconnect= 1;\n    DBUG_RETURN(res);\n  }\n}", "target": 0}
{"code": "MenuCacheItem *menu_cache_find_child_by_id(MenuCacheDir *dir, const char *id)\n{\n    GSList *child;\n    MenuCacheItem *item = NULL;\n    if (MENU_CACHE_ITEM(dir)->type != MENU_CACHE_TYPE_DIR || id == NULL)\n        return NULL;\n    MENU_CACHE_LOCK;\n    for (child = dir->children; child; child = child->next)\n        if (g_strcmp0(MENU_CACHE_ITEM(child->data)->id, id) == 0)\n        {\n            item = menu_cache_item_ref(child->data);\n            break;\n        }\n    MENU_CACHE_UNLOCK;\n    return item;\n}", "target": 0}
{"code": "ConnStateData::splice()\n{\n    if (fd_table[clientConnection->fd].ssl.get()) {\n        fd_table[clientConnection->fd].read_method = &default_read_method;\n        fd_table[clientConnection->fd].write_method = &default_write_method;\n    }\n    transferProtocol = Http::ProtocolVersion();\n    assert(!pipeline.empty());\n    Http::StreamPointer context = pipeline.front();\n    Must(context);\n    Must(context->http);\n    ClientHttpRequest *http = context->http;\n    HttpRequest::Pointer request = http->request;\n    context->finished();\n    if (transparent()) {\n        return fakeAConnectRequest(\"splice\", preservedClientData);\n    } else {\n        return initiateTunneledRequest(request, Http::METHOD_CONNECT, \"splice\", preservedClientData);\n    }\n}", "target": 0}
{"code": "int zmq::stream_engine_t::next_handshake_command (msg_t *msg_)\n{\n    zmq_assert (mechanism != NULL);\n    if (mechanism->status () == mechanism_t::ready) {\n        mechanism_ready ();\n        return pull_and_encode (msg_);\n    }\n    else\n    if (mechanism->status () == mechanism_t::error) {\n        errno = EPROTO;\n        return -1;\n    }\n    else {\n        const int rc = mechanism->next_handshake_command (msg_);\n        if (rc == 0)\n            msg_->set_flags (msg_t::command);\n        return rc;\n    }\n}", "target": 0}
{"code": "u32 gf_isom_get_track_count(GF_ISOFile *movie)\n{\n\tif (!movie || !movie->moov) return 0;\n\tif (!movie->moov->trackList) {\n\t\tmovie->LastError = GF_ISOM_INVALID_FILE;\n\t\treturn 0;\n\t}\n\treturn gf_list_count(movie->moov->trackList);\n}", "target": 0}
{"code": "static struct page *__rmqueue_pcplist(struct zone *zone, int migratetype,\n\t\t\tstruct per_cpu_pages *pcp,\n\t\t\tstruct list_head *list)\n{\n\tstruct page *page;\n\tdo {\n\t\tif (list_empty(list)) {\n\t\t\tpcp->count += rmqueue_bulk(zone, 0,\n\t\t\t\t\tpcp->batch, list,\n\t\t\t\t\tmigratetype);\n\t\t\tif (unlikely(list_empty(list)))\n\t\t\t\treturn NULL;\n\t\t}\n\t\tpage = list_first_entry(list, struct page, lru);\n\t\tlist_del(&page->lru);\n\t\tpcp->count--;\n\t} while (check_new_pcp(page));\n\treturn page;\n}", "target": 0}
{"code": "static void pp_cleanup_session(void)\n{\n    nasm_free(use_loaded);\n    free_llist(predef);\n    predef = NULL;\n    delete_Blocks();\n    ipath_list = NULL;\n}", "target": 0}
{"code": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n    if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n        return (NULL);\n    }\n    if (midisize < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n    } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}", "target": 0}
{"code": "gen8_emit_fini_breadcrumb_footer(struct i915_request *request,\n\t\t\t\t u32 *cs)\n{\n\t*cs++ = MI_USER_INTERRUPT;\n\t*cs++ = MI_ARB_ON_OFF | MI_ARB_ENABLE;\n\tif (intel_engine_has_semaphores(request->engine))\n\t\tcs = emit_preempt_busywait(request, cs);\n\trequest->tail = intel_ring_offset(request, cs);\n\tassert_ring_tail_valid(request->ring, request->tail);\n\treturn gen8_emit_wa_tail(request, cs);\n}", "target": 0}
{"code": "static void vendor_disable_error_reporting(void)\n{\n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL ||\n\t    boot_cpu_data.x86_vendor == X86_VENDOR_AMD)\n\t\treturn;\n\tmce_disable_error_reporting();\n}", "target": 0}
{"code": "static void ssd0323_invalidate_display(void * opaque)\n{\n    ssd0323_state *s = (ssd0323_state *)opaque;\n    s->redraw = 1;\n}", "target": 0}
{"code": "GF_Err leva_box_size(GF_Box *s)\n{\n\tu32 i;\n\tGF_LevelAssignmentBox *ptr = (GF_LevelAssignmentBox*)s;\n\tptr->size += 1;\n\tfor (i = 0; i < ptr->level_count; i++) {\n\t\tptr->size += 5;\n\t\tif (ptr->levels[i].type == 0 || ptr->levels[i].type == 4) {\n\t\t\tptr->size += 4;\n\t\t}\n\t\telse if (ptr->levels[i].type == 1) {\n\t\t\tptr->size += 8;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "_PUBLIC_ bool large_file_support(const char *path)\n{\n\tint fd;\n\tssize_t ret;\n\tchar c;\n\tfd = open(path, O_RDWR|O_CREAT, 0600);\n\tunlink(path);\n\tif (fd == -1) {\n\t\treturn true;\n\t}\n\tret = pread(fd, &c, 1, ((uint64_t)1)<<32);\n\tclose(fd);\n\treturn ret == 0;\n}", "target": 0}
{"code": "rndpush(const void *s)\n{\n\tregister uint32_t h = qh_state;\n\tBAFHUpdateStr_reg(h, s);\n\tBAFHUpdateOctet_reg(h, 0);\n\tqh_state = h;\n}", "target": 0}
{"code": "static void reds_start_auth_sasl(RedLinkInfo *link)\n{\n    if (!red_sasl_start_auth(link->stream, reds_handle_sasl_result, link)) {\n        reds_link_free(link);\n    }\n}", "target": 0}
{"code": "cdf_read_ssat(const cdf_info_t *info, const cdf_header_t *h,\n    const cdf_sat_t *sat, cdf_sat_t *ssat)\n{\n\tsize_t i, j;\n\tsize_t ss = CDF_SEC_SIZE(h);\n\tcdf_secid_t sid = h->h_secid_first_sector_in_short_sat;\n\tssat->sat_len = cdf_count_chain(sat, sid, CDF_SEC_SIZE(h));\n\tif (ssat->sat_len == (size_t)-1)\n\t\treturn -1;\n\tssat->sat_tab = CAST(cdf_secid_t *, calloc(ssat->sat_len, ss));\n\tif (ssat->sat_tab == NULL)\n\t\treturn -1;\n\tfor (j = i = 0; sid >= 0; i++, j++) {\n\t\tif (j >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Read short sat sector loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (i >= ssat->sat_len) {\n\t\t\tDPRINTF((\"Out of bounds reading short sector chain \"\n\t\t\t    \"%\" SIZE_T_FORMAT \"u > %\" SIZE_T_FORMAT \"u\\n\", i,\n\t\t\t    ssat->sat_len));\n\t\t\terrno = EFTYPE;\n\t\t\tgoto out;\n\t\t}\n\t\tif (cdf_read_sector(info, ssat->sat_tab, i * ss, ss, h, sid) !=\n\t\t    (ssize_t)ss) {\n\t\t\tDPRINTF((\"Reading short sat sector %d\", sid));\n\t\t\tgoto out;\n\t\t}\n\t\tsid = CDF_TOLE4((uint32_t)sat->sat_tab[sid]);\n\t}\n\treturn 0;\nout:\n\tfree(ssat->sat_tab);\n\treturn -1;\n}", "target": 0}
{"code": "expect_numeric(VALUE x)\n{\n    if (!k_numeric_p(x))\n\trb_raise(rb_eTypeError, \"expected numeric\");\n}", "target": 0}
{"code": "static void php_libxml_internal_error_handler(int error_type, void *ctx, const char **msg, va_list ap)\n{\n\tchar *buf;\n\tint len, len_iter, output = 0;\n\tTSRMLS_FETCH();\n\tlen = vspprintf(&buf, 0, *msg, ap);\n\tlen_iter = len;\n\twhile (len_iter && buf[--len_iter] == '\\n') {\n\t\tbuf[len_iter] = '\\0';\n\t\toutput = 1;\n\t}\n\tsmart_str_appendl(&LIBXML(error_buffer), buf, len);\n\tefree(buf);\n\tif (output == 1) {\n\t\tif (LIBXML(error_list)) {\n\t\t\t_php_list_set_error_structure(NULL, LIBXML(error_buffer).c);\n\t\t} else {\n\t\t\tswitch (error_type) {\n\t\t\t\tcase PHP_LIBXML_CTX_ERROR:\n\t\t\t\t\tphp_libxml_ctx_error_level(E_WARNING, ctx, LIBXML(error_buffer).c TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PHP_LIBXML_CTX_WARNING:\n\t\t\t\t\tphp_libxml_ctx_error_level(E_NOTICE, ctx, LIBXML(error_buffer).c TSRMLS_CC);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"%s\", LIBXML(error_buffer).c);\n\t\t\t}\n\t\t}\n\t\tsmart_str_free(&LIBXML(error_buffer));\n\t}\n}", "target": 0}
{"code": "int pam_sm_close_session(pam_handle_t *pamh, int flags,\n\t\t\t int argc, const char **argv)\n{\n\tint ret = PAM_SUCCESS;\n\tstruct pwb_context *ctx = NULL;\n\tret = _pam_winbind_init_context(pamh, flags, argc, argv, &ctx);\n\tif (ret) {\n\t\tgoto out;\n\t}\n\t_PAM_LOG_FUNCTION_ENTER(\"pam_sm_close_session\", ctx);\nout:\n\t_PAM_LOG_FUNCTION_LEAVE(\"pam_sm_close_session\", ctx, ret);\n\tTALLOC_FREE(ctx);\n\treturn ret;\n}", "target": 0}
{"code": "static void ldapsrv_disconnect_ticket_expired(struct tevent_req *subreq)\n{\n\tstruct ldapsrv_connection *conn = tevent_req_callback_data(\n\t\tsubreq, struct ldapsrv_connection);\n\tbool ok;\n\tok = tevent_wakeup_recv(subreq);\n\tTALLOC_FREE(subreq);\n\tif (!ok) {\n\t\tDBG_WARNING(\"tevent_wakeup_recv failed\\n\");\n\t}\n\tconn->deferred_expire_disconnect = NULL;\n\tldapsrv_terminate_connection(conn, \"network session expired\");\n}", "target": 0}
{"code": "void fz_cmm_fin_profile(fz_context *ctx, fz_iccprofile *profile)\n{\n\tif (ctx && ctx->colorspace && ctx->colorspace->cmm && ctx->cmm_instance)\n\t\tif (profile && profile->cmm_handle != NULL)\n\t\t\tctx->colorspace->cmm->fin_profile(ctx->cmm_instance, profile);\n}", "target": 0}
{"code": "SplashError Splash::xorFill(SplashPath *path, GBool eo) {\n  SplashPipe pipe;\n  SplashXPath *xPath;\n  SplashXPathScanner *scanner;\n  int xMinI, yMinI, xMaxI, yMaxI, x0, x1, y;\n  SplashClipResult clipRes, clipRes2;\n  SplashBlendFunc origBlendFunc;\n  if (path->length == 0) {\n    return splashErrEmptyPath;\n  }\n  xPath = new SplashXPath(path, state->matrix, state->flatness, gTrue);\n  xPath->sort();\n  scanner = new SplashXPathScanner(xPath, eo, state->clip->getYMinI(),\n\t\t\t\t   state->clip->getYMaxI());\n  scanner->getBBox(&xMinI, &yMinI, &xMaxI, &yMaxI);\n  if ((clipRes = state->clip->testRect(xMinI, yMinI, xMaxI, yMaxI))\n      != splashClipAllOutside) {\n    if (scanner->hasPartialClip()) {\n      clipRes = splashClipPartial;\n    }\n    origBlendFunc = state->blendFunc;\n    state->blendFunc = &blendXor;\n    pipeInit(&pipe, 0, yMinI, state->fillPattern, NULL, 255, gFalse, gFalse);\n    for (y = yMinI; y <= yMaxI; ++y) {\n      while (scanner->getNextSpan(y, &x0, &x1)) {\n\tif (clipRes == splashClipAllInside) {\n\t  drawSpan(&pipe, x0, x1, y, gTrue);\n\t} else {\n\t  if (x0 < state->clip->getXMinI()) {\n\t    x0 = state->clip->getXMinI();\n\t  }\n\t  if (x1 > state->clip->getXMaxI()) {\n\t    x1 = state->clip->getXMaxI();\n\t  }\n\t  clipRes2 = state->clip->testSpan(x0, x1, y);\n\t  drawSpan(&pipe, x0, x1, y, clipRes2 == splashClipAllInside);\n\t}\n      }\n    }\n    state->blendFunc = origBlendFunc;\n  }\n  opClipRes = clipRes;\n  delete scanner;\n  delete xPath;\n  return splashOk;\n}", "target": 0}
{"code": "int OmniboxViewWin::OnPerformDrop(const views::DropTargetEvent& event) {\n  return OnPerformDropImpl(event, false);\n}", "target": 0}
{"code": "static void unuse_table(struct ctl_table_header *p)\n{\n\tif (!--p->used)\n\t\tif (unlikely(p->unregistering))\n\t\t\tcomplete(p->unregistering);\n}", "target": 0}
{"code": "callbacks_show_color_picker_dialog (gint index){\n\tscreen.win.colorSelectionDialog = NULL;\n\tGtkColorSelectionDialog *cs= (GtkColorSelectionDialog *) gtk_color_selection_dialog_new (_(\"Select a color\"));\n\tGtkColorSelection *colorsel = (GtkColorSelection *) cs->colorsel;\n\tscreen.win.colorSelectionDialog = (GtkWidget *) cs;\n\tscreen.win.colorSelectionIndex = index;\n\tif (index >= 0)\n\t\tgtk_color_selection_set_current_color (colorsel, &mainProject->file[index]->color);\n\telse\n\t\tgtk_color_selection_set_current_color (colorsel, &mainProject->background);\n\tif ((screenRenderInfo.renderType >= GERBV_RENDER_TYPE_CAIRO_NORMAL)&&(index >= 0)) {\n\t\tgtk_color_selection_set_has_opacity_control (colorsel, TRUE);\n\t\tgtk_color_selection_set_current_alpha (colorsel, mainProject->file[index]->alpha);\n\t}\n\tgtk_widget_show_all((GtkWidget *)cs);\n\tif (gtk_dialog_run ((GtkDialog*)cs) == GTK_RESPONSE_OK) {\n\t\tGtkColorSelection *colorsel = (GtkColorSelection *) cs->colorsel;\n\t\tgint rowIndex = screen.win.colorSelectionIndex;\n\t\tif (index >= 0) {\n\t\t\tgtk_color_selection_get_current_color (colorsel, &mainProject->file[rowIndex]->color);\n\t\t\tgdk_colormap_alloc_color(gdk_colormap_get_system(), &mainProject->file[rowIndex]->color, FALSE, TRUE);\n\t\t}\n\t\telse {\n\t\t\tgtk_color_selection_get_current_color (colorsel, &mainProject->background);\n\t\t\tgdk_colormap_alloc_color(gdk_colormap_get_system(), &mainProject->background, FALSE, TRUE);\n\t\t}\n\t\tif ((screenRenderInfo.renderType >= GERBV_RENDER_TYPE_CAIRO_NORMAL)&&(index >= 0)) {\n\t\t\tmainProject->file[rowIndex]->alpha = gtk_color_selection_get_current_alpha (colorsel);\n\t\t}\n\t\tcallbacks_update_layer_tree ();\n\t\trender_refresh_rendered_image_on_screen();\n\t}\n\tgtk_widget_destroy ((GtkWidget *)cs);\n\tscreen.win.colorSelectionDialog = NULL;\n}", "target": 0}
{"code": "static void update_pmu_context(struct pmu *pmu, struct pmu *old_pmu)\n{\n\tint cpu;\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\tif (cpuctx->unique_pmu == old_pmu)\n\t\t\tcpuctx->unique_pmu = pmu;\n\t}\n}", "target": 0}
{"code": "bool __init __attribute((weak)) arch_hugetlb_valid_size(unsigned long size)\n{\n\treturn size == HPAGE_SIZE;\n}", "target": 0}
{"code": "void check_device_compatible_encoding(gx_device *dev)\n{\n    gx_device_color_info * pinfo = &(dev->color_info);\n    int num_components = pinfo->num_components;\n    gx_color_index mul, color_index;\n    int i, j;\n    gx_color_value colorants[GX_DEVICE_COLOR_MAX_COMPONENTS];\n    if (pinfo->separable_and_linear == GX_CINFO_UNKNOWN_SEP_LIN)\n        check_device_separable(dev);\n    if (pinfo->separable_and_linear != GX_CINFO_SEP_LIN)\n        return;\n    if (dev_proc(dev, ret_devn_params)(dev) != NULL) {\n        pinfo->separable_and_linear = GX_CINFO_SEP_LIN_STANDARD;\n        return;\n    }\n    for (i = 0; i < num_components; i++) {\n        int shift = (num_components-1-i)*8;\n        if (pinfo->comp_shift[i] != shift)\n            goto bad;\n        if (pinfo->comp_bits[i] != 8)\n            goto bad;\n        if (pinfo->comp_mask[i] != ((gx_color_index)255)<<shift)\n            goto bad;\n    }\n    mul = 0;\n    for (i = 0; i < num_components; i++) {\n        mul = (mul<<8) | 1;\n    }\n    for (i = 0; i < 255; i++) {\n        for (j = 0; j < num_components; j++)\n            colorants[j] = i*257;\n        color_index = dev_proc(dev, encode_color)(dev, colorants);\n        if (color_index != i*mul && (i*mul != gx_no_color_index_value))\n            goto bad;\n    }\n    if ((color_index | mul) != 255*mul)\n        goto bad;\n    pinfo->separable_and_linear = GX_CINFO_SEP_LIN_STANDARD;\n    return;\nbad:\n    pinfo->separable_and_linear = GX_CINFO_SEP_LIN_NON_STANDARD;\n}", "target": 0}
{"code": "vte_sequence_handler_delete_lines (VteTerminal *terminal, GValueArray *params)\n{\n\tGValue *value;\n\tVteScreen *screen;\n\tlong param, end, row;\n\tint i;\n\tscreen = terminal->pvt->screen;\n\tparam = 1;\n\tif ((params != NULL) && (params->n_values > 0)) {\n\t\tvalue = g_value_array_get_nth(params, 0);\n\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\tparam = g_value_get_long(value);\n\t\t}\n\t}\n\trow = screen->cursor_current.row;\n\tif (screen->scrolling_restricted) {\n\t\tend = screen->insert_delta + screen->scrolling_region.end;\n\t} else {\n\t\tend = screen->insert_delta + terminal->row_count - 1;\n\t}\n\tfor (i = 0; i < param; i++) {\n\t\t_vte_terminal_ring_remove (terminal, row);\n\t\t_vte_terminal_ring_insert (terminal, end, TRUE);\n\t}\n\t_vte_terminal_scroll_region(terminal, row, end - row + 1, -param);\n\t_vte_terminal_adjust_adjustments(terminal);\n\tterminal->pvt->text_deleted_flag = TRUE;\n}", "target": 0}
{"code": "void set_pfnblock_flags_mask(struct page *page, unsigned long flags,\n\t\t\t\t\tunsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\tunsigned long *bitmap;\n\tunsigned long bitidx, word_bitidx;\n\tunsigned long old_word, word;\n\tBUILD_BUG_ON(NR_PAGEBLOCK_BITS != 4);\n\tbitmap = get_pageblock_bitmap(page, pfn);\n\tbitidx = pfn_to_bitidx(page, pfn);\n\tword_bitidx = bitidx / BITS_PER_LONG;\n\tbitidx &= (BITS_PER_LONG-1);\n\tVM_BUG_ON_PAGE(!zone_spans_pfn(page_zone(page), pfn), page);\n\tbitidx += end_bitidx;\n\tmask <<= (BITS_PER_LONG - bitidx - 1);\n\tflags <<= (BITS_PER_LONG - bitidx - 1);\n\tword = READ_ONCE(bitmap[word_bitidx]);\n\tfor (;;) {\n\t\told_word = cmpxchg(&bitmap[word_bitidx], word, (word & ~mask) | flags);\n\t\tif (word == old_word)\n\t\t\tbreak;\n\t\tword = old_word;\n\t}\n}", "target": 0}
{"code": "device_filesystem_check_authorized_cb (Daemon *daemon,\n                                       Device *device,\n                                       DBusGMethodInvocation *context,\n                                       const gchar *action_id,\n                                       guint num_user_data,\n                                       gpointer *user_data_elements)\n{\n  int n;\n  char *argv[16];\n  GError *error;\n  if (device->priv->device_is_mounted)\n    {\n      throw_error (context, ERROR_BUSY, \"Device is mounted and no online capability in fsck tool for file system\");\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"fsck\";\n  argv[n++] = \"-a\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  error = NULL;\n  if (!job_new (context, \"FilesystemCheck\", FALSE, device, argv, NULL, filesystem_check_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "static inline struct page * __pure pgv_to_page(void *addr)\n{\n\tif (is_vmalloc_addr(addr))\n\t\treturn vmalloc_to_page(addr);\n\treturn virt_to_page(addr);\n}", "target": 0}
{"code": "static int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\treturn 0;\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tumount_tree(child, 0);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\treturn err;\n}", "target": 0}
{"code": "Eina_Bool ewk_view_zoom_animated_mark_current(Evas_Object* ewkView, float zoom)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    smartData->animated_zoom.zoom.current = zoom;\n    return true;\n}", "target": 0}
{"code": "static void set_addressed_player(struct avrcp *session,\n\t\t\t\t\tstruct avrcp_player *player)\n{\n\tif (!player || !player->id || player->addressed ||\n\t\t\t\tsession->controller->version < 0x0104)\n\t\treturn;\n\tavrcp_set_addressed_player(session, player);\n}", "target": 0}
{"code": "    std::ostream& StringValueBase::write(std::ostream& os) const\n    {\n        return os << value_;\n    }", "target": 0}
{"code": "static int __init vhost_vdpa_init(void)\n{\n\tint r;\n\tr = alloc_chrdev_region(&vhost_vdpa_major, 0, VHOST_VDPA_DEV_MAX,\n\t\t\t\t\"vhost-vdpa\");\n\tif (r)\n\t\tgoto err_alloc_chrdev;\n\tr = vdpa_register_driver(&vhost_vdpa_driver);\n\tif (r)\n\t\tgoto err_vdpa_register_driver;\n\treturn 0;\nerr_vdpa_register_driver:\n\tunregister_chrdev_region(vhost_vdpa_major, VHOST_VDPA_DEV_MAX);\nerr_alloc_chrdev:\n\treturn r;\n}", "target": 0}
{"code": "u64 swap_pte_to_pagemap_entry(pte_t pte)\n{\n\tswp_entry_t e = pte_to_swp_entry(pte);\n\treturn PM_SWAP | swp_type(e) | (swp_offset(e) << MAX_SWAPFILES_SHIFT);\n}", "target": 0}
{"code": "static void bgr_to_rgb(fz_context *ctx, const fz_colorspace *cs, const float *bgr, float *rgb)\n{\n\trgb[0] = bgr[2];\n\trgb[1] = bgr[1];\n\trgb[2] = bgr[0];\n}", "target": 0}
{"code": "authz_status oidc_authz_checker_claim(request_rec *r, const char *require_args,\n\t\tconst void *parsed_require_args) {\n\treturn oidc_authz_checker(r, require_args, parsed_require_args,\n\t\t\toidc_authz_match_claim);\n}", "target": 0}
{"code": "static void kvmclock_sync_fn(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct kvm_arch *ka = container_of(dwork, struct kvm_arch,\n\t\t\t\t\t   kvmclock_sync_work);\n\tstruct kvm *kvm = container_of(ka, struct kvm, arch);\n\tschedule_delayed_work(&kvm->arch.kvmclock_update_work, 0);\n\tschedule_delayed_work(&kvm->arch.kvmclock_sync_work,\n\t\t\t\t\tKVMCLOCK_SYNC_PERIOD);\n}", "target": 0}
{"code": "static u64 normal_pmc_alternative(u64 ev, unsigned long flags)\n{\n\tu64 alt[MAX_EVENT_ALTERNATIVES];\n\tint n;\n\tflags &= ~(PPMU_LIMITED_PMC_OK | PPMU_LIMITED_PMC_REQD);\n\tn = ppmu->get_alternatives(ev, flags, alt);\n\tif (!n)\n\t\treturn 0;\n\treturn alt[0];\n}", "target": 0}
{"code": "des_decrypt_cbc(const unsigned char *key, int keysize, unsigned char iv[EVP_MAX_IV_LENGTH],\n\t\tconst unsigned char *input, size_t length, unsigned char *output)\n{\n\treturn openssl_dec(EVP_des_cbc(), key, iv, input, length, output);\n}", "target": 0}
{"code": "int sftp_reply_handle(sftp_client_message msg, ssh_string handle){\n  ssh_buffer out;\n  out = ssh_buffer_new();\n  if (out == NULL) {\n    return -1;\n  }\n  if (ssh_buffer_add_u32(out, msg->id) < 0 ||\n      ssh_buffer_add_ssh_string(out, handle) < 0 ||\n      sftp_packet_write(msg->sftp, SSH_FXP_HANDLE, out) < 0) {\n    SSH_BUFFER_FREE(out);\n    return -1;\n  }\n  SSH_BUFFER_FREE(out);\n  return 0;\n}", "target": 0}
{"code": "static void set_page_hwpoison_huge_page(struct page *hpage)\n{\n\tint i;\n\tint nr_pages = 1 << compound_order(hpage);\n\tfor (i = 0; i < nr_pages; i++)\n\t\tSetPageHWPoison(hpage + i);\n}", "target": 0}
{"code": "    bool isJpegType(BasicIo& iIo, bool advance)\n    {\n        bool result = true;\n        byte tmpBuf[2];\n        iIo.read(tmpBuf, 2);\n        if (iIo.error() || iIo.eof()) return false;\n        if (0xff != tmpBuf[0] || JpegImage::soi_ != tmpBuf[1]) {\n            result = false;\n        }\n        if (!advance || !result ) iIo.seek(-2, BasicIo::cur);\n        return result;\n    }", "target": 0}
{"code": "spnego_gss_release_cred(OM_uint32 *minor_status,\n\t\t\tgss_cred_id_t *cred_handle)\n{\n\tspnego_gss_cred_id_t spcred = NULL;\n\tdsyslog(\"Entering spnego_gss_release_cred\\n\");\n\tif (minor_status == NULL || cred_handle == NULL)\n\t\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\t*minor_status = 0;\n\tif (*cred_handle == GSS_C_NO_CREDENTIAL)\n\t\treturn (GSS_S_COMPLETE);\n\tspcred = (spnego_gss_cred_id_t)*cred_handle;\n\t*cred_handle = GSS_C_NO_CREDENTIAL;\n\tgss_release_oid_set(minor_status, &spcred->neg_mechs);\n\tgss_release_cred(minor_status, &spcred->mcred);\n\tfree(spcred);\n\tdsyslog(\"Leaving spnego_gss_release_cred\\n\");\n\treturn (GSS_S_COMPLETE);\n}", "target": 0}
{"code": "    int32_t getLong(const byte* buf, ByteOrder byteOrder)\n    {\n        if (byteOrder == littleEndian) {\n            return   (byte)buf[3] << 24 | (byte)buf[2] << 16\n                   | (byte)buf[1] <<  8 | (byte)buf[0];\n        }\n        else {\n            return   (byte)buf[0] << 24 | (byte)buf[1] << 16\n                   | (byte)buf[2] <<  8 | (byte)buf[3];\n        }\n    }", "target": 0}
{"code": "auth_ice_connection (IceConn ice_conn)\n{\n        GIOChannel            *channel;\n        GsmIceConnectionWatch *data;\n        int                    fd;\n        g_debug (\"GsmXsmpServer: auth_ice_connection()\");\n        fd = IceConnectionNumber (ice_conn);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        data = g_new0 (GsmIceConnectionWatch, 1);\n        ice_conn->context = data;\n        data->protocol_timeout = g_timeout_add_seconds (5,\n                                                        (GSourceFunc)ice_protocol_timeout,\n                                                        ice_conn);\n        data->watch_id = g_io_add_watch (channel,\n                                         G_IO_IN | G_IO_ERR,\n                                         (GIOFunc)auth_iochannel_watch,\n                                         ice_conn);\n        g_io_channel_unref (channel);\n}", "target": 0}
{"code": "gbk_is_allowed_reverse_match(const UChar* s, const UChar* end ARG_UNUSED, OnigEncoding enc ARG_UNUSED)\n{\n  const UChar c = *s;\n  return (GBK_ISMB_TRAIL(c) ? FALSE : TRUE);\n}", "target": 0}
{"code": "static bool pp_get_boolean_option(Token *tline, bool defval)\n{\n    static const char * const noyes[] = {\n        \"no\", \"yes\",\n        \"false\", \"true\",\n        \"off\", \"on\"\n    };\n    struct ppscan pps;\n    struct tokenval tokval;\n    expr *evalresult;\n    tline = skip_white(tline);\n    if (!tline)\n        return true;\n    if (tline->type == TOK_ID) {\n        size_t i;\n\tconst char *txt = tok_text(tline);\n        for (i = 0; i < ARRAY_SIZE(noyes); i++)\n            if (!nasm_stricmp(txt, noyes[i]))\n                return i & 1;\n    }\n    pps.tptr = NULL;\n    pps.tptr = tline;\n    pps.ntokens = -1;\n    tokval.t_type = TOKEN_INVALID;\n    evalresult = evaluate(ppscan, &pps, &tokval, NULL, true, NULL);\n    if (!evalresult)\n        return true;\n    if (tokval.t_type)\n        nasm_warn(WARN_OTHER, \"trailing garbage after expression ignored\");\n    if (!is_really_simple(evalresult)) {\n        nasm_nonfatal(\"boolean flag expression must be a constant\");\n        return defval;\n    }\n    return reloc_value(evalresult) != 0;\n}", "target": 0}
{"code": "  virtual bool cellular_enabled() const { return false; }", "target": 0}
{"code": "void CalculatePageLayoutFromPrintParams(\n    const PrintMsg_Print_Params& params,\n    PageSizeMargins* page_layout_in_points) {\n  int dpi = GetDPI(&params);\n  int content_width = params.content_size.width();\n  int content_height = params.content_size.height();\n  int margin_bottom =\n      params.page_size.height() - content_height - params.margin_top;\n  int margin_right =\n      params.page_size.width() - content_width - params.margin_left;\n  page_layout_in_points->content_width =\n      ConvertUnit(content_width, dpi, kPointsPerInch);\n  page_layout_in_points->content_height =\n      ConvertUnit(content_height, dpi, kPointsPerInch);\n  page_layout_in_points->margin_top =\n      ConvertUnit(params.margin_top, dpi, kPointsPerInch);\n  page_layout_in_points->margin_right =\n      ConvertUnit(margin_right, dpi, kPointsPerInch);\n  page_layout_in_points->margin_bottom =\n      ConvertUnit(margin_bottom, dpi, kPointsPerInch);\n  page_layout_in_points->margin_left =\n      ConvertUnit(params.margin_left, dpi, kPointsPerInch);\n}", "target": 0}
{"code": "aura::Window* Shell::GetAppListWindow() {\n  return app_list_controller_.get() ? app_list_controller_->GetWindow()\n                                    : nullptr;\n}", "target": 0}
{"code": "compare_vote_rs(const vote_routerstatus_t *a, const vote_routerstatus_t *b)\n{\n  int r;\n  tor_assert(a);\n  tor_assert(b);\n  if ((r = fast_memcmp(a->status.identity_digest, b->status.identity_digest,\n                  DIGEST_LEN)))\n    return r;\n  if ((r = fast_memcmp(a->status.descriptor_digest,\n                       b->status.descriptor_digest,\n                       DIGEST_LEN)))\n    return r;\n#define CMP_FIELD(utype, itype, field) do {                             \\\n    utype aval = (utype) (itype) a->status.field;                       \\\n    utype bval = (utype) (itype) b->status.field;                       \\\n    utype u = bval - aval;                                              \\\n    itype r2 = (itype) u;                                               \\\n    if (r2 < 0) {                                                       \\\n      return -1;                                                        \\\n    } else if (r2 > 0) {                                                \\\n      return 1;                                                         \\\n    }                                                                   \\\n  } while (0)\n  CMP_FIELD(uint64_t, int64_t, published_on);\n  if ((r = strcmp(b->status.nickname, a->status.nickname)))\n    return r;\n  CMP_FIELD(unsigned, int, addr);\n  CMP_FIELD(unsigned, int, or_port);\n  CMP_FIELD(unsigned, int, dir_port);\n  return 0;\n}", "target": 0}
{"code": "static struct sock *__udp4_lib_mcast_demux_lookup(struct net *net,\n\t\t\t\t\t\t  __be16 loc_port, __be32 loc_addr,\n\t\t\t\t\t\t  __be16 rmt_port, __be32 rmt_addr,\n\t\t\t\t\t\t  int dif)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(loc_port);\n\tunsigned int count, slot = udp_hashfn(net, hnum, udp_table.mask);\n\tstruct udp_hslot *hslot = &udp_table.hash[slot];\n\tif (hslot->count > 10)\n\t\treturn NULL;\n\trcu_read_lock();\nbegin:\n\tcount = 0;\n\tresult = NULL;\n\tsk_nulls_for_each_rcu(sk, node, &hslot->head) {\n\t\tif (__udp_is_mcast_sock(net, sk,\n\t\t\t\t\tloc_port, loc_addr,\n\t\t\t\t\trmt_port, rmt_addr,\n\t\t\t\t\tdif, hnum)) {\n\t\t\tresult = sk;\n\t\t\t++count;\n\t\t}\n\t}\n\tif (get_nulls_value(node) != slot)\n\t\tgoto begin;\n\tif (result) {\n\t\tif (count != 1 ||\n\t\t    unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(!__udp_is_mcast_sock(net, result,\n\t\t\t\t\t\t       loc_port, loc_addr,\n\t\t\t\t\t\t       rmt_port, rmt_addr,\n\t\t\t\t\t\t       dif, hnum))) {\n\t\t\tsock_put(result);\n\t\t\tresult = NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn result;\n}", "target": 0}
{"code": "int sldns_str2wire_ilnp64_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tunsigned int a, b, c, d;\n\tuint16_t shorts[4];\n\tint l;\n\tif(*len < sizeof(shorts))\n\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\tif (sscanf(str, \"%4x:%4x:%4x:%4x%n\", &a, &b, &c, &d, &l) != 4 ||\n\t\t\tl != (int)strlen(str) || \n\t\t\tstrpbrk(str, \"+-\")       \n\t\t\t)\n\t\treturn LDNS_WIREPARSE_ERR_SYNTAX_ILNP64;\n\tshorts[0] = htons(a);\n\tshorts[1] = htons(b);\n\tshorts[2] = htons(c);\n\tshorts[3] = htons(d);\n\tmemmove(rd, &shorts, sizeof(shorts));\n\t*len = sizeof(shorts);\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "void avsubtitle_free(AVSubtitle *sub)\n{\n    int i;\n    for (i = 0; i < sub->num_rects; i++) {\n        av_freep(&sub->rects[i]->pict.data[0]);\n        av_freep(&sub->rects[i]->pict.data[1]);\n        av_freep(&sub->rects[i]->pict.data[2]);\n        av_freep(&sub->rects[i]->pict.data[3]);\n        av_freep(&sub->rects[i]->text);\n        av_freep(&sub->rects[i]->ass);\n        av_freep(&sub->rects[i]);\n    }\n    av_freep(&sub->rects);\n    memset(sub, 0, sizeof(AVSubtitle));\n}", "target": 0}
{"code": "ring_addr_to_vva(struct virtio_net *dev, struct vhost_virtqueue *vq,\n\t\tuint64_t ra, uint64_t size)\n{\n\tif (dev->features & (1ULL << VIRTIO_F_IOMMU_PLATFORM)) {\n\t\tuint64_t vva;\n\t\tvva = vhost_user_iotlb_cache_find(vq, ra,\n\t\t\t\t\t&size, VHOST_ACCESS_RW);\n\t\tif (!vva)\n\t\t\tvhost_user_iotlb_miss(dev, ra, VHOST_ACCESS_RW);\n\t\treturn vva;\n\t}\n\treturn qva_to_vva(dev, ra);\n}", "target": 0}
{"code": "int InstanceKlass::vtable_index_of_interface_method(Method* intf_method) {\n  assert(is_linked(), \"required\");\n  assert(intf_method->method_holder()->is_interface(), \"not an interface method\");\n  assert(is_subtype_of(intf_method->method_holder()), \"interface not implemented\");\n  int vtable_index = Method::invalid_vtable_index;\n  Symbol* name = intf_method->name();\n  Symbol* signature = intf_method->signature();\n  if (!intf_method->is_abstract() && default_methods() != NULL) {\n    int index = find_method_index(default_methods(),\n                                  name, signature,\n                                  Klass::OverpassLookupMode::find,\n                                  Klass::StaticLookupMode::find,\n                                  Klass::PrivateLookupMode::find);\n    if (index >= 0) {\n      vtable_index = default_vtable_indices()->at(index);\n    }\n  }\n  if (vtable_index == Method::invalid_vtable_index) {\n    klassVtable vt = vtable();\n    vtable_index = vt.index_of_miranda(name, signature);\n  }\n  return vtable_index;\n}", "target": 0}
{"code": "nfsd4_getdeviceinfo_release(union nfsd4_op_u *u)\n{\n\tkfree(u->getdeviceinfo.gd_device);\n}", "target": 0}
{"code": "static int create_yamaha_midi_quirk(struct snd_usb_audio *chip,\n\t\t\t\t    struct usb_interface *iface,\n\t\t\t\t    struct usb_driver *driver,\n\t\t\t\t    struct usb_host_interface *alts)\n{\n\tstatic const struct snd_usb_audio_quirk yamaha_midi_quirk = {\n\t\t.type = QUIRK_MIDI_YAMAHA\n\t};\n\tstruct usb_midi_in_jack_descriptor *injd;\n\tstruct usb_midi_out_jack_descriptor *outjd;\n\tinjd = snd_usb_find_csint_desc(alts->extra, alts->extralen,\n\t\t\t\t       NULL, USB_MS_MIDI_IN_JACK);\n\toutjd = snd_usb_find_csint_desc(alts->extra, alts->extralen,\n\t\t\t\t\tNULL, USB_MS_MIDI_OUT_JACK);\n\tif (!injd && !outjd)\n\t\treturn -ENODEV;\n\tif (injd && (injd->bLength < 5 ||\n\t\t     (injd->bJackType != USB_MS_EMBEDDED &&\n\t\t      injd->bJackType != USB_MS_EXTERNAL)))\n\t\treturn -ENODEV;\n\tif (outjd && (outjd->bLength < 6 ||\n\t\t      (outjd->bJackType != USB_MS_EMBEDDED &&\n\t\t       outjd->bJackType != USB_MS_EXTERNAL)))\n\t\treturn -ENODEV;\n\treturn create_any_midi_quirk(chip, iface, driver, &yamaha_midi_quirk);\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoTexParameteri(\n    GLenum target, GLenum pname, GLint param) {\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glTexParameteri: unknown texture\");\n    return;\n  }\n  if (!texture_manager()->SetParameter(info, pname, param)) {\n    SetGLError(GL_INVALID_ENUM, \"glTexParameteri: param GL_INVALID_ENUM\");\n    return;\n  }\n  glTexParameteri(target, pname, param);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NegationAndIndexOnEqualityAndNegationBranches) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    runQuerySortProj(fromjson(\"{$and: [{a: 1}, {b: 2}, {b: {$ne: 1}}]}\"), BSONObj(), BSONObj());\n    assertNumSolutions(3U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {a: 1}, \"\n        \"bounds: {a: [[1,1,true,true]]}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {ixscan: {pattern: {b: 1}, \"\n        \"bounds: {b: [[2,2,true,true]]}}}}}\");\n}", "target": 0}
{"code": "static int isofs_readpage(struct file *file, struct page *page)\n{\n\treturn mpage_readpage(page, isofs_get_block);\n}", "target": 0}
{"code": "PHP_FUNCTION(locale_lookup)\n{\n\tchar*      \tfallback_loc  \t\t= NULL;\n\tint        \tfallback_loc_len\t= 0;\n\tconst char*    \tloc_range      \t\t= NULL;\n\tint        \tloc_range_len  \t\t= 0;\n\tzval*\t\tarr\t\t\t\t= NULL;\n\tHashTable*\thash_arr\t\t= NULL;\n\tzend_bool\tboolCanonical\t= 0;\n\tchar*\t \tresult\t\t\t=NULL;\n\tintl_error_reset( NULL TSRMLS_CC );\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, \"as|bs\", &arr, &loc_range, &loc_range_len,\n\t\t&boolCanonical,\t&fallback_loc, &fallback_loc_len) == FAILURE) {\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\t\"locale_lookup: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tif(loc_range_len == 0) {\n\t\tloc_range = intl_locale_get_default(TSRMLS_C);\n\t}\n\thash_arr = HASH_OF(arr);\n\tif( !hash_arr || zend_hash_num_elements( hash_arr ) == 0 ) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tresult = lookup_loc_range(loc_range, hash_arr, boolCanonical TSRMLS_CC);\n\tif(result == NULL || result[0] == '\\0') {\n\t\tif( fallback_loc ) {\n\t\t\tresult = estrndup(fallback_loc, fallback_loc_len);\n\t\t} else {\n\t\t\tRETURN_EMPTY_STRING();\n\t\t}\n\t}\n\tRETVAL_STRINGL(result, strlen(result), 0);\n}", "target": 0}
{"code": "YCbCr_tables_init (void)\n{\n\tg_mutex_lock (&Tables_Mutex);\n\tif (YCbCr_R_Cr_Tab == NULL) {\n\t\tint i, v;\n\t\tYCbCr_R_Cr_Tab = g_new (int, 256);\n\t\tYCbCr_G_Cb_Tab = g_new (int, 256);\n\t\tYCbCr_G_Cr_Tab = g_new (int, 256);\n\t\tYCbCr_B_Cb_Tab = g_new (int, 256);\n\t\tfor (i = 0, v = -128; i <= 255; i++, v++) {\n\t\t\tYCbCr_R_Cr_Tab[i] = SCALE_DOWN (SCALE_UP (1.402) * v + ONE_HALF);\n\t\t\tYCbCr_G_Cb_Tab[i] = - SCALE_UP (0.34414) * v;\n\t\t\tYCbCr_G_Cr_Tab[i] = - SCALE_UP (0.71414) * v + ONE_HALF;\n\t\t\tYCbCr_B_Cb_Tab[i] = SCALE_DOWN (SCALE_UP (1.77200) * v + ONE_HALF);\n\t\t}\n\t}\n\tg_mutex_unlock (&Tables_Mutex);\n}", "target": 0}
{"code": "_asn1_ltostr (long v, char str[LTOSTR_MAX_SIZE])\n{\n  long d, r;\n  char temp[LTOSTR_MAX_SIZE];\n  int count, k, start;\n  if (v < 0)\n    {\n      str[0] = '-';\n      start = 1;\n      v = -v;\n    }\n  else\n    start = 0;\n  count = 0;\n  do\n    {\n      d = v / 10;\n      r = v - d * 10;\n      temp[start + count] = '0' + (char) r;\n      count++;\n      v = d;\n    }\n  while (v && ((start+count) < LTOSTR_MAX_SIZE-1));\n  for (k = 0; k < count; k++)\n    str[k + start] = temp[start + count - k - 1];\n  str[count + start] = 0;\n  return str;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, CoveredOrUniqueIndexLookup) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN;\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    addIndex(BSON(\"a\" << 1),\n             false,  \n             false,  \n             true);  \n    runQuerySortProj(fromjson(\"{a: 1, b: 1}\"), BSONObj(), fromjson(\"{_id: 0, a: 1}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{fetch: {filter: {b: 1}, node: {ixscan: {pattern: {a: 1}}}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{ixscan: {filter: null, pattern: {a: 1, b: 1}}}}}\");\n}", "target": 0}
{"code": "TEST(TensorSliceReaderTest, MissingTensorData) {\n  const string fname =\n      io::JoinPath(testing::TmpDir(), \"missing_data_checkpoint\");\n  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  TF_ASSERT_OK(writer.Add(\"test\", TensorShape({4, 5}),\n                          TensorSlice::ParseOrDie(\"0,2:-\"), data));\n  TF_ASSERT_OK(writer.Finish());\n  MutateSavedTensorSlices(fname, [&](SavedTensorSlices sts) {\n    if (sts.has_data()) {\n      Fill(data, 4, sts.mutable_data()->mutable_data());\n    }\n    return sts.SerializeAsString();\n  });\n  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n  TF_ASSERT_OK(reader.status());\n  EXPECT_TRUE(reader.HasTensor(\"test\", nullptr, nullptr));\n  std::unique_ptr<Tensor> tensor;\n  EXPECT_FALSE(reader.GetTensor(\"test\", &tensor).ok());\n}", "target": 0}
{"code": "  HeaderEntryImpl** inlineHeaders() override { return inline_headers_; }", "target": 0}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[rindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[gindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = 0xFF;\n    ptr += ps;\n  }\n  return 1;\n}", "target": 0}
{"code": "static void rgb_to_gray(fz_context *ctx, const fz_colorspace *cs, const float *rgb, float *gray)\n{\n\tfloat r = rgb[0];\n\tfloat g = rgb[1];\n\tfloat b = rgb[2];\n\tgray[0] = r * 0.3f + g * 0.59f + b * 0.11f;\n}", "target": 0}
{"code": "ok_png ok_png_read(FILE *file, ok_png_decode_flags decode_flags) {\n    return ok_png_read_with_allocator(file, decode_flags, OK_PNG_DEFAULT_ALLOCATOR, NULL);\n}", "target": 0}
{"code": "int ssl3_get_cert_status(SSL *s)\n{\n    int ok, al;\n    unsigned long resplen, n;\n    const unsigned char *p;\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_CR_CERT_STATUS_A,\n                                   SSL3_ST_CR_CERT_STATUS_B,\n                                   -1, 16384, &ok);\n    if (!ok)\n        return ((int)n);\n    if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE_STATUS) {\n        s->s3->tmp.reuse_message = 1;\n    } else {\n        if (n < 4) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_LENGTH_MISMATCH);\n            goto f_err;\n        }\n        p = (unsigned char *)s->init_msg;\n        if (*p++ != TLSEXT_STATUSTYPE_ocsp) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_UNSUPPORTED_STATUS_TYPE);\n            goto f_err;\n        }\n        n2l3(p, resplen);\n        if (resplen + 4 != n) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_LENGTH_MISMATCH);\n            goto f_err;\n        }\n        s->tlsext_ocsp_resp = BUF_memdup(p, resplen);\n        if (s->tlsext_ocsp_resp == NULL) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_STATUS, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n        s->tlsext_ocsp_resplen = resplen;\n    }\n    if (s->ctx->tlsext_status_cb) {\n        int ret;\n        ret = s->ctx->tlsext_status_cb(s, s->ctx->tlsext_status_arg);\n        if (ret == 0) {\n            al = SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE;\n            SSLerr(SSL_F_SSL3_GET_CERT_STATUS, SSL_R_INVALID_STATUS_RESPONSE);\n            goto f_err;\n        }\n        if (ret < 0) {\n            al = SSL_AD_INTERNAL_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CERT_STATUS, ERR_R_MALLOC_FAILURE);\n            goto f_err;\n        }\n    }\n    return 1;\n f_err:\n    ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    s->state = SSL_ST_ERR;\n    return (-1);\n}", "target": 0}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->allgc, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  g->gcstate = GCSswpallgc;\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 0}
{"code": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\twhile (isspace(*numstr))\n\t\tnumstr++;\n\tif (*numstr == '-')\n\t\treturn -EINVAL;\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno == ERANGE && uli == ULONG_MAX)\n\t\treturn -ERANGE;\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}", "target": 0}
{"code": "static compat_clock_t clock_t_to_compat_clock_t(clock_t x)\n{\n\treturn compat_jiffies_to_clock_t(clock_t_to_jiffies(x));\n}", "target": 0}
{"code": "bool AudioManagerBase::CanShowAudioInputSettings() {\n  return false;\n}", "target": 0}
{"code": "fire_sched_out_preempt_notifiers(struct task_struct *curr,\n\t\t\t\t struct task_struct *next)\n{\n\tif (static_key_false(&preempt_notifier_key))\n\t\t__fire_sched_out_preempt_notifiers(curr, next);\n}", "target": 0}
{"code": "noname_disable_map(Node** plink, GroupNumRemap* map, int* counter)\n{\n  int r = 0;\n  Node* node = *plink;\n  switch (NTYPE(node)) {\n  case NT_LIST:\n  case NT_ALT:\n    do {\n      r = noname_disable_map(&(NCAR(node)), map, counter);\n    } while (r == 0 && IS_NOT_NULL(node = NCDR(node)));\n    break;\n  case NT_QTFR:\n    {\n      Node** ptarget = &(NQTFR(node)->target);\n      Node*  old = *ptarget;\n      r = noname_disable_map(ptarget, map, counter);\n      if (*ptarget != old && NTYPE(*ptarget) == NT_QTFR) {\n\tonig_reduce_nested_quantifier(node, *ptarget);\n      }\n    }\n    break;\n  case NT_ENCLOSE:\n    {\n      EncloseNode* en = NENCLOSE(node);\n      if (en->type == ENCLOSE_MEMORY) {\n\tif (IS_ENCLOSE_NAMED_GROUP(en)) {\n\t  (*counter)++;\n\t  map[en->regnum].new_val = *counter;\n\t  en->regnum = *counter;\n\t}\n\telse if (en->regnum != 0) {\n\t  *plink = en->target;\n\t  en->target = NULL_NODE;\n\t  onig_node_free(node);\n\t  r = noname_disable_map(plink, map, counter);\n\t  break;\n\t}\n      }\n      r = noname_disable_map(&(en->target), map, counter);\n    }\n    break;\n  case NT_ANCHOR:\n    if (NANCHOR(node)->target)\n      r = noname_disable_map(&(NANCHOR(node)->target), map, counter);\n    break;\n  default:\n    break;\n  }\n  return r;\n}", "target": 0}
{"code": "redraw_later_clear(void)\n{\n    redraw_all_later(CLEAR);\n    reset_screen_attr();\n}", "target": 0}
{"code": "static void addWhereTerm(\n  Parse *pParse,                  \n  SrcList *pSrc,                  \n  int iLeft,                      \n  int iColLeft,                   \n  int iRight,                     \n  int iColRight,                  \n  int isOuterJoin,                \n  Expr **ppWhere                  \n){\n  sqlite3 *db = pParse->db;\n  Expr *pE1;\n  Expr *pE2;\n  Expr *pEq;\n  assert( iLeft<iRight );\n  assert( pSrc->nSrc>iRight );\n  assert( pSrc->a[iLeft].pTab );\n  assert( pSrc->a[iRight].pTab );\n  pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);\n  pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);\n  pEq = sqlite3PExpr(pParse, TK_EQ, pE1, pE2);\n  if( pEq && isOuterJoin ){\n    ExprSetProperty(pEq, EP_FromJoin);\n    assert( !ExprHasProperty(pEq, EP_TokenOnly|EP_Reduced) );\n    ExprSetVVAProperty(pEq, EP_NoReduce);\n    pEq->iRightJoinTable = (i16)pE2->iTable;\n  }\n  *ppWhere = sqlite3ExprAnd(pParse, *ppWhere, pEq);\n}", "target": 0}
{"code": "static int count_total(struct page *page)\n{\n\treturn page->objects;\n}", "target": 0}
{"code": "static int pit_get_gate(struct kvm *kvm, int channel)\n{\n\tWARN_ON(!mutex_is_locked(&kvm->arch.vpit->pit_state.lock));\n\treturn kvm->arch.vpit->pit_state.channels[channel].gate;\n}", "target": 0}
{"code": "void RenderViewTest::SimulateUserInputChangeForElement(\n    blink::WebInputElement* input,\n    const std::string& new_value) {\n  ASSERT_TRUE(base::IsStringASCII(new_value));\n  while (!input->Focused())\n    input->GetDocument().GetFrame()->View()->AdvanceFocus(false);\n  size_t previous_length = input->Value().length();\n  for (size_t i = 0; i < previous_length; ++i)\n    SimulateUserTypingASCIICharacter(ui::VKEY_BACK, false);\n  EXPECT_TRUE(input->Value().Utf8().empty());\n  for (size_t i = 0; i < new_value.size(); ++i)\n    SimulateUserTypingASCIICharacter(new_value[i], false);\n  EXPECT_EQ(new_value, input->Value().Utf8().substr(0, new_value.length()));\n  base::RunLoop().RunUntilIdle();\n}", "target": 0}
{"code": "Curl_conncache_find_bundle(struct Curl_easy *data,\n                           struct connectdata *conn,\n                           struct conncache *connc,\n                           const char **hostp)\n{\n  struct connectbundle *bundle = NULL;\n  CONNCACHE_LOCK(data);\n  if(connc) {\n    char key[HASHKEY_SIZE];\n    hashkey(conn, key, sizeof(key), hostp);\n    bundle = Curl_hash_pick(&connc->hash, key, strlen(key));\n  }\n  return bundle;\n}", "target": 0}
{"code": "smtp_quit_handler(uschar ** user_msgp, uschar ** log_msgp)\n{\nHAD(SCH_QUIT);\nincomplete_transaction_log(US\"QUIT\");\nif (acl_smtp_quit)\n  {\n  int rc = acl_check(ACL_WHERE_QUIT, NULL, acl_smtp_quit, user_msgp, log_msgp);\n  if (rc == ERROR)\n    log_write(0, LOG_MAIN|LOG_PANIC, \"ACL for QUIT returned ERROR: %s\",\n      *log_msgp);\n  }\nif (*user_msgp)\n  smtp_respond(US\"221\", 3, TRUE, *user_msgp);\nelse\n  smtp_printf(\"221 %s closing connection\\r\\n\", FALSE, smtp_active_hostname);\n#ifdef SUPPORT_TLS\ntls_close(NULL, TLS_SHUTDOWN_NOWAIT);\n#endif\nlog_write(L_smtp_connection, LOG_MAIN, \"%s closed by QUIT\",\n  smtp_get_connection_info());\n}", "target": 0}
{"code": "int jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_gobble\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}", "target": 0}
{"code": "void atm_dev_release_vccs(struct atm_dev *dev)\n{\n\tint i;\n\twrite_lock_irq(&vcc_sklist_lock);\n\tfor (i = 0; i < VCC_HTABLE_SIZE; i++) {\n\t\tstruct hlist_head *head = &vcc_hash[i];\n\t\tstruct hlist_node *tmp;\n\t\tstruct sock *s;\n\t\tstruct atm_vcc *vcc;\n\t\tsk_for_each_safe(s, tmp, head) {\n\t\t\tvcc = atm_sk(s);\n\t\t\tif (vcc->dev == dev) {\n\t\t\t\tvcc_release_async(vcc, -EPIPE);\n\t\t\t\tsk_del_node_init(s);\n\t\t\t}\n\t\t}\n\t}\n\twrite_unlock_irq(&vcc_sklist_lock);\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  auto* params = reinterpret_cast<TfLiteAddParams*>(node->builtin_data);\n  TF_LITE_ENSURE_STATUS(\n      CalculateOpData(context, params, input1, input2, output, data));\n  return kTfLiteOk;\n}", "target": 0}
{"code": "vhost_user_set_protocol_features(struct virtio_net **pdev,\n\t\t\tstruct VhostUserMsg *msg,\n\t\t\tint main_fd __rte_unused)\n{\n\tstruct virtio_net *dev = *pdev;\n\tuint64_t protocol_features = msg->payload.u64;\n\tuint64_t slave_protocol_features = 0;\n\tif (validate_msg_fds(msg, 0) != 0)\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\trte_vhost_driver_get_protocol_features(dev->ifname,\n\t\t\t&slave_protocol_features);\n\tif (protocol_features & ~slave_protocol_features) {\n\t\tVHOST_LOG_CONFIG(ERR,\n\t\t\t\"(%d) received invalid protocol features.\\n\",\n\t\t\tdev->vid);\n\t\treturn RTE_VHOST_MSG_RESULT_ERR;\n\t}\n\tdev->protocol_features = protocol_features;\n\tVHOST_LOG_CONFIG(INFO,\n\t\t\"negotiated Vhost-user protocol features: 0x%\" PRIx64 \"\\n\",\n\t\tdev->protocol_features);\n\treturn RTE_VHOST_MSG_RESULT_OK;\n}", "target": 0}
{"code": "static int nl80211_parse_key(struct genl_info *info, struct key_parse *k)\n{\n\tint err;\n\tmemset(k, 0, sizeof(*k));\n\tk->idx = -1;\n\tk->type = -1;\n\tif (info->attrs[NL80211_ATTR_KEY])\n\t\terr = nl80211_parse_key_new(info->attrs[NL80211_ATTR_KEY], k);\n\telse\n\t\terr = nl80211_parse_key_old(info, k);\n\tif (err)\n\t\treturn err;\n\tif (k->def && k->defmgmt)\n\t\treturn -EINVAL;\n\tif (k->defmgmt) {\n\t\tif (k->def_uni || !k->def_multi)\n\t\t\treturn -EINVAL;\n\t}\n\tif (k->idx != -1) {\n\t\tif (k->defmgmt) {\n\t\t\tif (k->idx < 4 || k->idx > 5)\n\t\t\t\treturn -EINVAL;\n\t\t} else if (k->def) {\n\t\t\tif (k->idx < 0 || k->idx > 3)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (k->idx < 0 || k->idx > 5)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "GF_ItemListBox *gf_isom_locate_box(GF_List *list, u32 boxType, bin128 UUID)\n{\n\tu32 i;\n\tGF_Box *box;\n\ti=0;\n\twhile ((box = (GF_Box *)gf_list_enum(list, &i))) {\n\t\tif (box->type == boxType) {\n\t\t\tGF_UUIDBox* box2 = (GF_UUIDBox* )box;\n\t\t\tif (boxType != GF_ISOM_BOX_TYPE_UUID) return (GF_ItemListBox *)box;\n\t\t\tif (!memcmp(box2->uuid, UUID, 16)) return (GF_ItemListBox *)box;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "    CiffComponent* CiffComponent::findComponent(uint16_t crwTagId,\n                                                uint16_t crwDir) const\n    {\n        return doFindComponent(crwTagId, crwDir);\n    } ", "target": 0}
{"code": "callbacks_live_edit (GtkWidget *button, gpointer user_data){\n\tGtkDialog *toplevel = GTK_DIALOG(gtk_widget_get_toplevel (button));\n\tgtk_dialog_response(toplevel, GTK_RESPONSE_APPLY);\n}", "target": 0}
{"code": "fmtchar(int value, int leftjust, int minlen, PrintfTarget *target)\n{\n\tint\t\t\tpadlen = 0;\t\t\n\tadjust_padlen(minlen, 1, leftjust, &padlen);\n\twhile (padlen > 0)\n\t{\n\t\tdopr_outch(' ', target);\n\t\t--padlen;\n\t}\n\tdopr_outch(value, target);\n\ttrailing_pad(&padlen, target);\n}", "target": 0}
{"code": "utf16be_get_case_fold_codes_by_str(OnigCaseFoldType flag,\n\t\t\t\t   const OnigUChar* p, const OnigUChar* end,\n\t\t\t\t   OnigCaseFoldCodeItem items[],\n\t\t\t\t   OnigEncoding enc)\n{\n  return onigenc_unicode_get_case_fold_codes_by_str(enc,\n\t\t\t\t\t\t    flag, p, end, items);\n}", "target": 0}
{"code": "  const Extension* GetExtension() {\n    const ExtensionSet* extensions = extensions::ExtensionSystem::Get(\n        browser()->profile())->extension_service()->extensions();\n    for (ExtensionSet::const_iterator it = extensions->begin();\n         it != extensions->end(); ++it) {\n      if ((*it)->name() == \"App Test\")\n        return it->get();\n    }\n    NOTREACHED();\n    return NULL;\n  }", "target": 0}
{"code": "DEFINE_TEST(test_read_format_zip_bzip2_one_file)\n{\n\tconst char *refname = \"test_read_format_zip_bzip2.zipx\";\n\tstruct archive *a;\n\tstruct archive_entry *ae;\n\textract_reference_file(refname);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_zip(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_open_filename(a, refname, 37));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));\n\tassertEqualString(\"ZIP 4.6 (bzip)\", archive_format_name(a));\n\tassertEqualString(\"vimrc\", archive_entry_pathname(ae));\n\tassertEqualIntA(a, 0, extract_one(a, ae, 0xBA8E3BAA));\n\tassertEqualIntA(a, ARCHIVE_EOF, archive_read_next_header(a, &ae));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_close(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_free(a));\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_text_set_streaming_mode(GF_ISOFile *movie, Bool do_convert)\n{\n\tif (!movie) return GF_BAD_PARAM;\n\tmovie->convert_streaming_text = do_convert;\n\treturn GF_OK;", "target": 0}
{"code": "int set_git_dir(const char *path)\n{\n\tif (setenv(GIT_DIR_ENVIRONMENT, path, 1))\n\t\treturn error(\"Could not set GIT_DIR to '%s'\", path);\n\tsetup_git_env();\n\treturn 0;\n}", "target": 0}
{"code": "void CallInfo::set_virtual(Klass* resolved_klass,\n                           const methodHandle& resolved_method,\n                           const methodHandle& selected_method,\n                           int vtable_index, TRAPS) {\n  assert(vtable_index >= 0 || vtable_index == Method::nonvirtual_vtable_index, \"valid index\");\n  assert(vtable_index < 0 || !resolved_method->has_vtable_index() || vtable_index == resolved_method->vtable_index(), \"\");\n  CallKind kind = (vtable_index >= 0 && !resolved_method->can_be_statically_bound() ? CallInfo::vtable_call : CallInfo::direct_call);\n  set_common(resolved_klass, resolved_method, selected_method, kind, vtable_index, CHECK);\n}\n", "target": 0}
{"code": "xsltNewDecimalFormat(xmlChar *name)\n{\n    xsltDecimalFormatPtr self;\n    static const xmlChar permille[4] = {0xe2, 0x80, 0xb0, 0};\n    self = xmlMalloc(sizeof(xsltDecimalFormat));\n    if (self != NULL) {\n\tself->next = NULL;\n\tself->name = name;\n\tself->digit = xmlStrdup(BAD_CAST(\"#\"));\n\tself->patternSeparator = xmlStrdup(BAD_CAST(\";\"));\n\tself->decimalPoint = xmlStrdup(BAD_CAST(\".\"));\n\tself->grouping = xmlStrdup(BAD_CAST(\",\"));\n\tself->percent = xmlStrdup(BAD_CAST(\"%\"));\n\tself->permille = xmlStrdup(BAD_CAST(permille));\n\tself->zeroDigit = xmlStrdup(BAD_CAST(\"0\"));\n\tself->minusSign = xmlStrdup(BAD_CAST(\"-\"));\n\tself->infinity = xmlStrdup(BAD_CAST(\"Infinity\"));\n\tself->noNumber = xmlStrdup(BAD_CAST(\"NaN\"));\n    }\n    return self;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      result.release();  \n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }", "target": 0}
{"code": "nfs4_ff_layout_stat_io_start_write(struct inode *inode,\n\t\tstruct nfs4_ff_layout_mirror *mirror,\n\t\t__u64 requested, ktime_t now)\n{\n\tbool report;\n\tspin_lock(&mirror->lock);\n\treport = nfs4_ff_layoutstat_start_io(mirror , &mirror->write_stat, now);\n\tnfs4_ff_layout_stat_io_update_requested(&mirror->write_stat, requested);\n\tset_bit(NFS4_FF_MIRROR_STAT_AVAIL, &mirror->flags);\n\tspin_unlock(&mirror->lock);\n\tif (report)\n\t\tpnfs_report_layoutstat(inode, GFP_NOIO);\n}", "target": 0}
{"code": "    int Exifdatum::setDataArea(const byte* buf, long len)\n    {\n        return value_.get() == 0 ? -1 : value_->setDataArea(buf, len);\n    }", "target": 0}
{"code": "void __init kvm_spinlock_init(void)\n{\n\tif (!kvm_para_available())\n\t\treturn;\n\tif (!kvm_para_has_feature(KVM_FEATURE_PV_UNHALT))\n\t\treturn;\n\tpv_lock_ops.lock_spinning = PV_CALLEE_SAVE(kvm_lock_spinning);\n\tpv_lock_ops.unlock_kick = kvm_unlock_kick;\n}", "target": 0}
{"code": "Clipboard::FormatType Clipboard::GetWebKitSmartPasteFormatType() {\n  return std::string(kMimeTypeWebkitSmartPaste);\n}", "target": 0}
{"code": "void SandboxedExtensionUnpacker::OnUnpackExtensionFailed(\n    const std::string& error) {\n  DCHECK(BrowserThread::CurrentlyOn(thread_identifier_));\n  got_response_ = true;\n  ReportFailure(error);\n}", "target": 0}
{"code": "int JPXStream::lookChar() {\n  if (unlikely(priv->inited == false)) { init(); }\n  return doLookChar(priv);\n}", "target": 0}
{"code": "void cgit_log_link(const char *name, const char *title, const char *class,\n\t\t   const char *head, const char *rev, const char *path,\n\t\t   int ofs, const char *grep, const char *pattern, int showmsg,\n\t\t   int follow)\n{\n\tchar *delim;\n\tdelim = repolink(title, class, \"log\", head, path);\n\tif (rev && ctx.qry.head && strcmp(rev, ctx.qry.head)) {\n\t\thtml(delim);\n\t\thtml(\"id=\");\n\t\thtml_url_arg(rev);\n\t\tdelim = \"&amp;\";\n\t}\n\tif (grep && pattern) {\n\t\thtml(delim);\n\t\thtml(\"qt=\");\n\t\thtml_url_arg(grep);\n\t\tdelim = \"&amp;\";\n\t\thtml(delim);\n\t\thtml(\"q=\");\n\t\thtml_url_arg(pattern);\n\t}\n\tif (ofs > 0) {\n\t\thtml(delim);\n\t\thtml(\"ofs=\");\n\t\thtmlf(\"%d\", ofs);\n\t\tdelim = \"&amp;\";\n\t}\n\tif (showmsg) {\n\t\thtml(delim);\n\t\thtml(\"showmsg=1\");\n\t\tdelim = \"&amp;\";\n\t}\n\tif (follow) {\n\t\thtml(delim);\n\t\thtml(\"follow=1\");\n\t}\n\thtml(\"'>\");\n\thtml_txt(name);\n\thtml(\"</a>\");\n}", "target": 0}
{"code": "static int __kvm_io_bus_read(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,\n\t\t\t     struct kvm_io_range *range, void *val)\n{\n\tint idx;\n\tidx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);\n\tif (idx < 0)\n\t\treturn -EOPNOTSUPP;\n\twhile (idx < bus->dev_count &&\n\t\tkvm_io_bus_cmp(range, &bus->range[idx]) == 0) {\n\t\tif (!kvm_iodevice_read(vcpu, bus->range[idx].dev, range->addr,\n\t\t\t\t       range->len, val))\n\t\t\treturn idx;\n\t\tidx++;\n\t}\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "void pasp_box_del(GF_Box *s)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox*)s;\n\tif (ptr == NULL) return;\n\tgf_free(ptr);\n}", "target": 0}
{"code": "extract_unix_path_from_dbus_address (const char *address)\n{\n  const char *path, *path_end;\n  if (address == NULL)\n    return NULL;\n  if (!g_str_has_prefix (address, \"unix:\"))\n    return NULL;\n  path = strstr (address, \"path=\");\n  if (path == NULL)\n    return NULL;\n  path += strlen (\"path=\");\n  path_end = path;\n  while (*path_end != 0 && *path_end != ',')\n    path_end++;\n  return g_strndup (path, path_end - path);\n}", "target": 0}
{"code": "storageRegisterAll(void)\n{\n    return storageRegisterFull(true);\n}", "target": 0}
{"code": "static void kvm_pv_guest_cpu_reboot(void *unused)\n{\n\tif (kvm_para_has_feature(KVM_FEATURE_PV_EOI))\n\t\twrmsrl(MSR_KVM_PV_EOI_EN, 0);\n\tkvm_pv_disable_apf();\n\tkvm_disable_steal_time();\n}", "target": 0}
{"code": "crm_remote_tcp_connect(const char *host, int port)\n{\n    struct addrinfo *res;\n    struct addrinfo *rp;\n    struct addrinfo hints;\n    const char *server = host;\n    int ret_ga;\n    int sock;\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;    \n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_CANONNAME;\n    crm_debug(\"Looking up %s\", server);\n    ret_ga = getaddrinfo(server, NULL, &hints, &res);\n    if (ret_ga) {\n        crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));\n        return -1;\n    }\n    if (!res || !res->ai_addr) {\n        crm_err(\"getaddrinfo failed\");\n        return -1;\n    }\n    for (rp = res; rp != NULL; rp = rp->ai_next) {\n        struct sockaddr *addr = rp->ai_addr;\n        int flag = 0;\n        if (!addr) {\n            continue;\n        }\n        if (rp->ai_canonname) {\n            server = res->ai_canonname;\n        }\n        crm_debug(\"Got address %s for %s\", server, host);\n        sock = socket(rp->ai_family, SOCK_STREAM, IPPROTO_TCP);\n        if (sock == -1) {\n            crm_err(\"Socket creation failed for remote client connection.\");\n            continue;\n        }\n        if (addr->sa_family == AF_INET6) {\n            struct sockaddr_in6 *addr_in = (struct sockaddr_in6 *) addr;\n            addr_in->sin6_port = htons(port);\n        } else {\n            struct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n            addr_in->sin_port = htons(port);\n            crm_info(\"Attempting to connect to remote server at %s:%d\", inet_ntoa(addr_in->sin_addr), port);\n        }\n        if (connect(sock, rp->ai_addr, rp->ai_addrlen) == 0) {\n            if ((flag = fcntl(sock, F_GETFL)) >= 0) {\n                if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) < 0) {\n                    crm_err( \"fcntl() write failed\");\n                    close(sock);\n                    sock = -1;\n                    continue;\n                }\n            }\n            break;                  \n        }\n        close(sock);\n        sock = -1;\n    }\n    freeaddrinfo(res);\n    return sock;\n}", "target": 0}
{"code": "void RootWindowHostLinux::UnConfineCursor() {\n#if XFIXES_MAJOR >= 5\n  if (pointer_barriers_.get()) {\n    XFixesDestroyPointerBarrier(xdisplay_, pointer_barriers_[0]);\n    XFixesDestroyPointerBarrier(xdisplay_, pointer_barriers_[1]);\n    XFixesDestroyPointerBarrier(xdisplay_, pointer_barriers_[2]);\n    XFixesDestroyPointerBarrier(xdisplay_, pointer_barriers_[3]);\n    pointer_barriers_.reset();\n  }\n#endif\n}", "target": 0}
{"code": "    template<typename tp, typename tf, typename tc, typename to, typename tz>\n    CImg<T>& draw_object3d(LibBoard::Board& board,\n                           const float x0, const float y0, const float z0,\n                           const CImg<tp>& vertices, const CImgList<tf>& primitives,\n                           const CImgList<tc>& colors,\n                           const unsigned int render_type,\n                           const bool is_double_sided, const float focale,\n                           const float lightx, const float lighty, const float lightz,\n                           const float specular_lightness, const float specular_shininess,\n                           CImg<tz>& zbuffer) {\n      return draw_object3d(x0,y0,z0,vertices,primitives,colors,CImg<floatT>::const_empty(),\n                           render_type,is_double_sided,focale,lightx,lighty,lightz,\n                           specular_lightness,specular_shininess,zbuffer);", "target": 0}
{"code": "libxlDomainJobUpdateTime(struct libxlDomainJobObj *job)\n{\n    virDomainJobInfoPtr jobInfo = job->current;\n    unsigned long long now;\n    if (!job->started)\n        return 0;\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n    if (now < job->started) {\n        job->started = 0;\n        return 0;\n    }\n    jobInfo->timeElapsed = now - job->started;\n    return 0;\n}", "target": 0}
{"code": "map_md_devices(guestfs_h *g, Hash_table **map)\n{\n  CLEANUP_HASH_FREE Hash_table *app_map = NULL;\n  CLEANUP_FREE_STRING_LIST char **matches = NULL;\n  ssize_t n_app_md_devices;\n  *map = NULL;\n  n_app_md_devices = map_app_md_devices (g, &app_map);\n  if (n_app_md_devices == -1) goto error;\n  if (n_app_md_devices == 0)\n    return 0;\n  matches = guestfs_aug_match(g, \"/files/etc/mdadm.conf/array\");\n  if (!matches) goto error;\n  if (matches[0] == NULL) {\n    debug(g, \"Appliance has MD devices, but augeas returned no array matches \"\n             \"in mdadm.conf\");\n    return 0;\n  }\n  *map = hash_initialize(16, NULL, mdadm_app_hash, mdadm_app_cmp,\n                                   mdadm_app_free);\n  if (!*map) g->abort_cb();\n  for (char **m = matches; *m != NULL; m++) {\n    CLEANUP_FREE char *dev_path = safe_asprintf (g, \"%s/devicename\", *m);\n    char *dev = guestfs_aug_get (g, dev_path);\n    if (!dev) goto error;\n    CLEANUP_FREE char *uuid_path = safe_asprintf (g, \"%s/uuid\", *m);\n    CLEANUP_FREE char *uuid = guestfs_aug_get (g, uuid_path);\n    if (!uuid) {\n      free (dev);\n      continue;\n    }\n    md_uuid mdadm;\n    mdadm.path = dev;\n    if (parse_uuid(uuid, mdadm.uuid) == -1) {\n      debug(g, \"inspect-os: mdadm.conf contains invalid uuid for %s: %s\",\n            dev, uuid);\n      free (dev);\n      continue;\n    }\n    md_uuid *app = hash_lookup(app_map, &mdadm);\n    if (app) {\n      mdadm_app *entry = safe_malloc(g, sizeof(mdadm_app));\n      entry->mdadm = dev;\n      entry->app = safe_strdup(g, app->path);\n      switch (hash_insert_if_absent(*map, entry, NULL)) {\n        case -1:\n          g->abort_cb();\n        case 0:\n          debug(g, \"inspect-os: mdadm.conf contains multiple entries for %s\",\n                app->path);\n          mdadm_app_free(entry);\n          continue;\n      }\n    } else\n      free (dev);\n  }\n  return 0;\nerror:\n  if (*map) hash_free (*map);\n  return -1;\n}", "target": 0}
{"code": "DLLIMPORT signed long cfg_opt_getnint(cfg_opt_t *opt, unsigned int index)\n{\n\tif (!opt || opt->type != CFGT_INT) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\tif (opt->values && index < opt->nvalues)\n\t\treturn opt->values[index]->number;\n\tif (opt->simple_value.number)\n\t\treturn *opt->simple_value.number;\n\treturn 0;\n}", "target": 0}
{"code": "void EditorClientBlackBerry::getGuessesForWord(const String&, const String&, Vector<String>&)\n{\n    notImplemented();\n}", "target": 0}
{"code": "static gboolean avrcp_list_player_attributes_rsp(struct avctp *conn,\n\t\t\t\t\tuint8_t code, uint8_t subunit,\n\t\t\t\t\tuint8_t transaction, uint8_t *operands,\n\t\t\t\t\tsize_t operand_count, void *user_data)\n{\n\tuint8_t attrs[AVRCP_ATTRIBUTE_LAST];\n\tstruct avrcp *session = user_data;\n\tstruct avrcp_header *pdu = (void *) operands;\n\tuint8_t len, count = 0;\n\tint i;\n\tif (code == AVC_CTYPE_REJECTED || code == AVC_CTYPE_NOT_IMPLEMENTED)\n\t\treturn FALSE;\n\tlen = pdu->params[0];\n\tif (ntohs(pdu->params_len) < count) {\n\t\terror(\"Invalid parameters\");\n\t\treturn FALSE;\n\t}\n\tfor (i = 0; len > 0; len--, i++) {\n\t\tif (pdu->params[i + 1] == AVRCP_ATTRIBUTE_ILEGAL ||\n\t\t\t\tpdu->params[i + 1] > AVRCP_ATTRIBUTE_LAST)\n\t\t\tcontinue;\n\t\tattrs[count++] = pdu->params[i + 1];\n\t}\n\tavrcp_get_current_player_value(session, attrs, count);\n\treturn FALSE;\n}", "target": 0}
{"code": "static inline struct xfrm_user_sec_ctx *pfkey_sadb2xfrm_user_sec_ctx(const struct sadb_x_sec_ctx *sec_ctx,\n\t\t\t\t\t\t\t\t     gfp_t gfp)\n{\n\tstruct xfrm_user_sec_ctx *uctx = NULL;\n\tint ctx_size = sec_ctx->sadb_x_ctx_len;\n\tuctx = kmalloc((sizeof(*uctx)+ctx_size), gfp);\n\tif (!uctx)\n\t\treturn NULL;\n\tuctx->len = pfkey_sec_ctx_len(sec_ctx);\n\tuctx->exttype = sec_ctx->sadb_x_sec_exttype;\n\tuctx->ctx_doi = sec_ctx->sadb_x_ctx_doi;\n\tuctx->ctx_alg = sec_ctx->sadb_x_ctx_alg;\n\tuctx->ctx_len = sec_ctx->sadb_x_ctx_len;\n\tmemcpy(uctx + 1, sec_ctx + 1,\n\t       uctx->ctx_len);\n\treturn uctx;\n}", "target": 0}
{"code": "static void bprm_fill_uid(struct linux_binprm *bprm)\n{\n\tstruct inode *inode;\n\tunsigned int mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)\n\t\treturn;\n\tif (task_no_new_privs(current))\n\t\treturn;\n\tinode = file_inode(bprm->file);\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\tmutex_lock(&inode->i_mutex);\n\tmode = inode->i_mode;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmutex_unlock(&inode->i_mutex);\n\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n\t\treturn;\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = uid;\n\t}\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = gid;\n\t}\n}", "target": 0}
{"code": "static void reds_handle_other_links(RedsState *reds, RedLinkInfo *link)\n{\n    RedChannel *channel;\n    RedClient *client = NULL;\n    SpiceLinkMess *link_mess;\n    RedsMigTargetClient *mig_client;\n    link_mess = link->link_mess;\n    if (reds->main_channel) {\n        client = reds->main_channel->get_client_by_link_id(link_mess->connection_id);\n    }\n    if (!client) {\n        reds_send_link_result(link, SPICE_LINK_ERR_BAD_CONNECTION_ID);\n        return;\n    }\n    if (!(channel = reds_find_channel(reds, link_mess->channel_type,\n                                      link_mess->channel_id))) {\n        reds_send_link_result(link, SPICE_LINK_ERR_CHANNEL_NOT_AVAILABLE);\n        return;\n    }\n    reds_send_link_result(link, SPICE_LINK_ERR_OK);\n    reds_info_new_channel(link, link_mess->connection_id);\n    mig_client = reds_mig_target_client_find(reds, client);\n    if (client->during_migrate_at_target() && !reds->dst_do_seamless_migrate) {\n        spice_assert(mig_client);\n        reds_mig_target_client_add_pending_link(mig_client, link_mess, link->stream);\n        link->link_mess = NULL;\n    } else {\n        spice_assert(!mig_client);\n        reds_channel_do_link(channel, client, link_mess, link->stream);\n    }\n    link->stream = NULL;\n}", "target": 0}
{"code": "static void ibwdt_shutdown(struct platform_device *dev)\n{\n\tibwdt_disable();\n}", "target": 0}
{"code": "void InstanceKlass::link_class(TRAPS) {\n  assert(is_loaded(), \"must be loaded\");\n  if (!is_linked()) {\n    link_class_impl(CHECK);\n  }\n}", "target": 0}
{"code": "void test_chroot(const char *path)\n{\n\tif (chroot(path) == 0) {\n\t\tfprintf(stderr, \"leak at chroot of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chroot of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "compileError(FileInfo *nested, char *format, ...) {\n#ifndef __SYMBIAN32__\n\tchar buffer[MAXSTRING];\n\tva_list arguments;\n\tva_start(arguments, format);\n\tvsnprintf(buffer, sizeof(buffer), format, arguments);\n\tva_end(arguments);\n\tif (nested)\n\t\t_lou_logMessage(LOG_ERROR, \"%s:%d: error: %s\", nested->fileName,\n\t\t\t\tnested->lineNumber, buffer);\n\telse\n\t\t_lou_logMessage(LOG_ERROR, \"error: %s\", buffer);\n\terrorCount++;\n#endif\n}", "target": 0}
{"code": "\tvoid setInChunk(Chunk *chunk) { m_inChunk = chunk; }", "target": 0}
{"code": "static struct sk_buff *tcp_maybe_skipping_dsack(struct sk_buff *skb,\n\t\t\t\t\t\tstruct sock *sk,\n\t\t\t\t\t\tstruct tcp_sack_block *next_dup,\n\t\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\t\tu32 skip_to_seq)\n{\n\tif (!next_dup)\n\t\treturn skb;\n\tif (before(next_dup->start_seq, skip_to_seq)) {\n\t\tskb = tcp_sacktag_skip(skb, sk, state, next_dup->start_seq);\n\t\tskb = tcp_sacktag_walk(skb, sk, NULL, state,\n\t\t\t\t       next_dup->start_seq, next_dup->end_seq,\n\t\t\t\t       1);\n\t}\n\treturn skb;\n}", "target": 0}
{"code": "int pidfile_set_fd(int newpidfilefd)\n{\n    pidfilefd = newpidfilefd;\n    return 0;\n}", "target": 0}
{"code": "void ogs_nas_5gs_nas_guti_to_mobility_identity_guti(\n        ogs_nas_5gs_guti_t *nas_guti,\n        ogs_nas_5gs_mobile_identity_guti_t *mobile_identity_guti)\n{\n    ogs_assert(nas_guti);\n    ogs_assert(mobile_identity_guti);\n    memset(mobile_identity_guti, 0, sizeof(*mobile_identity_guti));\n    mobile_identity_guti->h.supi_format = 0xf;\n    mobile_identity_guti->h.type = OGS_NAS_5GS_MOBILE_IDENTITY_GUTI;\n    memcpy(&mobile_identity_guti->nas_plmn_id,\n            &nas_guti->nas_plmn_id, OGS_PLMN_ID_LEN);\n    memcpy(&mobile_identity_guti->amf_id,\n            &nas_guti->amf_id, sizeof(ogs_amf_id_t));\n    mobile_identity_guti->m_tmsi = htobe32(nas_guti->m_tmsi);\n}", "target": 0}
{"code": "static inline int GetFirstGlobbingEntry(const std::vector<std::string>& dirs) {\n  int i = 0;\n  for (const auto& d : dirs) {\n    if (IsGlobbingPattern(d)) {\n      break;\n    }\n    i++;\n  }\n  return i;\n}", "target": 0}
{"code": "I_I16B(UINT8 *out, const UINT8 *in_, int xsize) {\n    int x, v;\n    for (x = 0; x < xsize; x++, in_ += 4) {\n        INT32 i;\n        memcpy(&i, in_, sizeof(i));\n        v = CLIP16(i);\n        *out++ = (UINT8)(v >> 8);\n        *out++ = (UINT8)v;\n    }\n}", "target": 0}
{"code": "void mlock_vma_page(struct page *page)\n{\n\tBUG_ON(!PageLocked(page));\n\tif (!TestSetPageMlocked(page)) {\n\t\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t\tif (!isolate_lru_page(page))\n\t\t\tputback_lru_page(page);\n\t}\n}", "target": 0}
{"code": "void DHT::make_greens()\n{\n#if defined(LIBRAW_USE_OPENMP)\n#pragma omp parallel for schedule(guided)\n#endif\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    make_gline(i);\n  }\n}", "target": 0}
{"code": "int tty_unregister_ldisc(int disc)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\tif (disc < N_TTY || disc >= NR_LDISCS)\n\t\treturn -EINVAL;\n\traw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\n\tif (tty_ldiscs[disc]->refcount)\n\t\tret = -EBUSY;\n\telse\n\t\ttty_ldiscs[disc] = NULL;\n\traw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\n\treturn ret;\n}", "target": 0}
{"code": "int btrfs_map_block(struct btrfs_fs_info *fs_info, enum btrfs_map_op op,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, op, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}", "target": 0}
{"code": "    TypeId toTypeId(TiffType tiffType, uint16_t tag, IfdId group)\n    {\n        TypeId ti = TypeId(tiffType);\n        if (tag == 0x9286 && group == exifId && ti == undefined) {\n            ti = comment;\n        }\n        if ( ti == Exiv2::unsignedByte ) {\n            if ( (tag == 0x0002 && group == nikonAFTId ) || (tag == 0x0047 && group == pentaxId) ) {\n                ti = Exiv2::signedByte;\n            }\n        }\n        return ti;\n    }", "target": 0}
{"code": "tiff_document_get_n_pages (EvDocument  *document)\n{\n\tTiffDocument *tiff_document = TIFF_DOCUMENT (document);\n\tg_return_val_if_fail (TIFF_IS_DOCUMENT (document), 0);\n\tg_return_val_if_fail (tiff_document->tiff != NULL, 0);\n\tif (tiff_document->n_pages == -1) {\n\t\tpush_handlers ();\n\t\ttiff_document->n_pages = 0;\n\t\tdo {\n\t\t\ttiff_document->n_pages ++;\n\t\t}\n\t\twhile (TIFFReadDirectory (tiff_document->tiff));\n\t\tpop_handlers ();\n\t}\n\treturn tiff_document->n_pages;\n}", "target": 0}
{"code": "void WebContentsImpl::SetHistoryLengthAndPrune(\n    const SiteInstance* site_instance,\n    int history_length,\n    int32 minimum_page_id) {\n  if (render_manager_.pending_render_view_host()) {\n    NOTREACHED();\n    return;\n  }\n  RenderViewHostImpl* rvh = GetRenderViewHostImpl();\n  if (!rvh) {\n    NOTREACHED();\n    return;\n  }\n  if (site_instance && rvh->GetSiteInstance() != site_instance) {\n    NOTREACHED();\n    return;\n  }\n  Send(new ViewMsg_SetHistoryLengthAndPrune(GetRoutingID(),\n                                            history_length,\n                                            minimum_page_id));\n}", "target": 0}
{"code": "__releases(&files->file_lock)\n{\n\tstruct file *tofree;\n\tstruct fdtable *fdt;\n\tfdt = files_fdtable(files);\n\ttofree = fdt->fd[fd];\n\tif (!tofree && fd_is_open(fd, fdt))\n\t\tgoto Ebusy;\n\tget_file(file);\n\trcu_assign_pointer(fdt->fd[fd], file);\n\t__set_open_fd(fd, fdt);\n\tif (flags & O_CLOEXEC)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n\tif (tofree)\n\t\tfilp_close(tofree, files);\n\treturn fd;\nEbusy:\n\tspin_unlock(&files->file_lock);\n\treturn -EBUSY;\n}", "target": 0}
{"code": "DocumentSource::GetModPathsReturn DocumentSourceGroup::getModifiedPaths() const {\n    StringMap<std::string> renames;\n    for (std::size_t i = 0; i < _idExpressions.size(); ++i) {\n        auto idExp = _idExpressions[i];\n        auto pathToPutResultOfExpression =\n            _idFieldNames.empty() ? \"_id\" : \"_id.\" + _idFieldNames[i];\n        auto computedPaths = idExp->getComputedPaths(pathToPutResultOfExpression);\n        for (auto&& rename : computedPaths.renames) {\n            renames[rename.first] = rename.second;\n        }\n    }\n    return {DocumentSource::GetModPathsReturn::Type::kAllExcept,\n            std::set<std::string>{},  \n            std::move(renames)};\n}", "target": 0}
{"code": "ChannelSplitterNode* BaseAudioContext::createChannelSplitter(\n    uint32_t number_of_outputs,\n    ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  return ChannelSplitterNode::Create(*this, number_of_outputs, exception_state);\n}", "target": 0}
{"code": "static unsigned long shm_get_unmapped_area(struct file *file,\n\tunsigned long addr, unsigned long len, unsigned long pgoff,\n\tunsigned long flags)\n{\n\tstruct shm_file_data *sfd = shm_file_data(file);\n\treturn sfd->file->f_op->get_unmapped_area(sfd->file, addr, len,\n\t\t\t\t\t\tpgoff, flags);\n}", "target": 0}
{"code": "getline (char **lineptr, size_t *n, FILE *stream)\n{\n  return getdelim (lineptr, n, '\\n', stream);\n}", "target": 0}
{"code": "    std::list<HeaderEntryImpl>::const_iterator begin() const { return headers_.begin(); }", "target": 0}
{"code": "void ImageLoader::ClearImage() {\n  SetImageWithoutConsideringPendingLoadEvent(nullptr);\n}", "target": 0}
{"code": "connection_discard_blank_line (chunkqueue * const cq, uint32_t header_len)\n{\n    chunkqueue_mark_written(cq, header_len);\n    return cq->first; \n}", "target": 0}
{"code": "static void qrtr_port_remove(struct qrtr_sock *ipc)\n{\n\tstruct qrtr_ctrl_pkt *pkt;\n\tstruct sk_buff *skb;\n\tint port = ipc->us.sq_port;\n\tstruct sockaddr_qrtr to;\n\tto.sq_family = AF_QIPCRTR;\n\tto.sq_node = QRTR_NODE_BCAST;\n\tto.sq_port = QRTR_PORT_CTRL;\n\tskb = qrtr_alloc_ctrl_packet(&pkt, GFP_KERNEL);\n\tif (skb) {\n\t\tpkt->cmd = cpu_to_le32(QRTR_TYPE_DEL_CLIENT);\n\t\tpkt->client.node = cpu_to_le32(ipc->us.sq_node);\n\t\tpkt->client.port = cpu_to_le32(ipc->us.sq_port);\n\t\tskb_set_owner_w(skb, &ipc->sk);\n\t\tqrtr_bcast_enqueue(NULL, skb, QRTR_TYPE_DEL_CLIENT, &ipc->us,\n\t\t\t\t   &to);\n\t}\n\tif (port == QRTR_PORT_CTRL)\n\t\tport = 0;\n\t__sock_put(&ipc->sk);\n\tmutex_lock(&qrtr_port_lock);\n\tidr_remove(&qrtr_ports, port);\n\tmutex_unlock(&qrtr_port_lock);\n\tsynchronize_rcu();\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::GetAttribLocationHelper(\n    GLuint client_id, uint32 location_shm_id, uint32 location_shm_offset,\n    const std::string& name_str) {\n  if (!StringIsValidForGLES(name_str.c_str())) {\n    SetGLError(GL_INVALID_VALUE, \"glGetAttribLocation: Invalid character\");\n    return error::kNoError;\n  }\n  ProgramManager::ProgramInfo* info = GetProgramInfoNotShader(\n      client_id, \"glGetAttribLocation\");\n  if (!info) {\n    return error::kNoError;\n  }\n  if (!info->IsValid()) {\n    SetGLError(GL_INVALID_OPERATION, \"glGetAttribLocation: program not linked\");\n    return error::kNoError;\n  }\n  GLint* location = GetSharedMemoryAs<GLint*>(\n      location_shm_id, location_shm_offset, sizeof(GLint));\n  if (!location) {\n    return error::kOutOfBounds;\n  }\n  if (*location != -1) {\n    return error::kGenericError;\n  }\n  *location = info->GetAttribLocation(name_str);\n  return error::kNoError;\n}", "target": 0}
{"code": "DocumentSourceGroup::rewriteGroupAsTransformOnFirstDocument() const {\n    if (_idExpressions.size() != 1) {\n        return nullptr;\n    }\n    auto fieldPathExpr = dynamic_cast<ExpressionFieldPath*>(_idExpressions.front().get());\n    if (!fieldPathExpr || fieldPathExpr->isVariableReference()) {\n        return nullptr;\n    }\n    const auto fieldPath = fieldPathExpr->getFieldPath();\n    if (fieldPath.getPathLength() == 1) {\n        invariant(fieldPath.getFieldName(0) == \"CURRENT\" || fieldPath.getFieldName(0) == \"ROOT\");\n        return nullptr;\n    }\n    const auto groupId = fieldPath.tail().fullPath();\n    for (auto&& accumulator : _accumulatedFields) {\n        if (AccumulatorDocumentsNeeded::kFirstDocument !=\n            accumulator.makeAccumulator()->documentsNeeded()) {\n            return nullptr;\n        }\n    }\n    std::vector<std::pair<std::string, boost::intrusive_ptr<Expression>>> fields;\n    boost::intrusive_ptr<Expression> idField;\n    if (_idFieldNames.empty()) {\n        idField = ExpressionFieldPath::deprecatedCreate(pExpCtx.get(), groupId);\n    } else {\n        invariant(_idFieldNames.size() == 1);\n        idField = ExpressionObject::create(pExpCtx.get(),\n                                           {{_idFieldNames.front(), _idExpressions.front()}});\n    }\n    fields.push_back(std::make_pair(\"_id\", idField));\n    for (auto&& accumulator : _accumulatedFields) {\n        fields.push_back(std::make_pair(accumulator.fieldName, accumulator.expr.argument));\n    }\n    return GroupFromFirstDocumentTransformation::create(pExpCtx, groupId, std::move(fields));\n}", "target": 0}
{"code": "static int kvm_vm_release(struct inode *inode, struct file *filp)\n{\n\tstruct kvm *kvm = filp->private_data;\n\tkvm_irqfd_release(kvm);\n\tkvm_put_kvm(kvm);\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t disk_events_poll_msecs_store(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct gendisk *disk = dev_to_disk(dev);\n\tlong intv;\n\tif (!count || !sscanf(buf, \"%ld\", &intv))\n\t\treturn -EINVAL;\n\tif (intv < 0 && intv != -1)\n\t\treturn -EINVAL;\n\tdisk_block_events(disk);\n\tdisk->ev->poll_msecs = intv;\n\t__disk_unblock_events(disk, true);\n\treturn count;\n}", "target": 0}
{"code": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n{\n\tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n\t\treturn -EINVAL;\n\tif (args->gsi >= KVM_MAX_IRQ_ROUTES)\n\t\treturn -EINVAL;\n\tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n\t\treturn kvm_irqfd_deassign(kvm, args);\n\treturn kvm_irqfd_assign(kvm, args);\n}", "target": 0}
{"code": "void SoftwareFrameManager::EvictCurrentFrame() {\n  DCHECK(HasCurrentFrame());\n  DiscardCurrentFrame();\n  if (client_)\n    client_->ReleaseReferencesToSoftwareFrame();\n}", "target": 0}
{"code": "static int xol_add_vma(struct mm_struct *mm, struct xol_area *area)\n{\n\tstruct vm_area_struct *vma;\n\tint ret;\n\tif (down_write_killable(&mm->mmap_sem))\n\t\treturn -EINTR;\n\tif (mm->uprobes_state.xol_area) {\n\t\tret = -EALREADY;\n\t\tgoto fail;\n\t}\n\tif (!area->vaddr) {\n\t\tarea->vaddr = get_unmapped_area(NULL, TASK_SIZE - PAGE_SIZE,\n\t\t\t\t\t\tPAGE_SIZE, 0, 0);\n\t\tif (area->vaddr & ~PAGE_MASK) {\n\t\t\tret = area->vaddr;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tvma = _install_special_mapping(mm, area->vaddr, PAGE_SIZE,\n\t\t\t\tVM_EXEC|VM_MAYEXEC|VM_DONTCOPY|VM_IO,\n\t\t\t\t&area->xol_mapping);\n\tif (IS_ERR(vma)) {\n\t\tret = PTR_ERR(vma);\n\t\tgoto fail;\n\t}\n\tret = 0;\n\tsmp_wmb();\t\n\tmm->uprobes_state.xol_area = area;\n fail:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}", "target": 0}
{"code": "void RenderView::ReportNoFindInPageResults(int request_id) {\n  Send(new ViewHostMsg_Find_Reply(routing_id_,\n                                  request_id,\n                                  0,\n                                  gfx::Rect(),\n                                  0,\n                                  true));\n}", "target": 0}
{"code": "static int fanout_set_data(struct packet_sock *po, char __user *data,\n\t\t\t   unsigned int len)\n{\n\tswitch (po->fanout->type) {\n\tcase PACKET_FANOUT_CBPF:\n\t\treturn fanout_set_data_cbpf(po, data, len);\n\tcase PACKET_FANOUT_EBPF:\n\t\treturn fanout_set_data_ebpf(po, data, len);\n\tdefault:\n\t\treturn -EINVAL;\n\t};\n}", "target": 0}
{"code": "imapx_uidset_add (struct _uidset_state *ss,\n                  CamelIMAPXCommand *ic,\n                  const gchar *uid)\n{\n\tguint32 uidn;\n\tuidn = strtoul (uid, NULL, 10);\n\tif (uidn == 0)\n\t\treturn -1;\n\tss->uids++;\n\te (ic->is->priv->tagprefix, \"uidset add '%s'\\n\", uid);\n\tif (ss->last == 0) {\n\t\te (ic->is->priv->tagprefix, \" start\\n\");\n\t\tss->start = uidn;\n\t\tss->last = uidn;\n\t} else {\n\t\tif (ss->start - 1 == uidn) {\n\t\t\tss->start = uidn;\n\t\t} else {\n\t\t\tif (ss->last != uidn - 1) {\n\t\t\t\tif (ss->last == ss->start) {\n\t\t\t\t\te (ic->is->priv->tagprefix, \" ,next\\n\");\n\t\t\t\t\tif (ss->entries > 0)\n\t\t\t\t\t\tcamel_imapx_command_add (ic, \",\");\n\t\t\t\t\tcamel_imapx_command_add (ic, \"%d\", ss->start);\n\t\t\t\t\tss->entries++;\n\t\t\t\t} else {\n\t\t\t\t\te (ic->is->priv->tagprefix, \" :range\\n\");\n\t\t\t\t\tif (ss->entries > 0)\n\t\t\t\t\t\tcamel_imapx_command_add (ic, \",\");\n\t\t\t\t\tcamel_imapx_command_add (ic, \"%d:%d\", ss->start, ss->last);\n\t\t\t\t\tss->entries += 2;\n\t\t\t\t}\n\t\t\t\tss->start = uidn;\n\t\t\t}\n\t\t\tss->last = uidn;\n\t\t}\n\t}\n\tif ((ss->limit && ss->entries >= ss->limit)\n\t    || (ss->limit && ss->uids >= ss->limit)\n\t    || (ss->total && ss->uids >= ss->total)) {\n\t\te (ic->is->priv->tagprefix, \" done, %d entries, %d uids\\n\", ss->entries, ss->uids);\n\t\tif (!imapx_uidset_done (ss, ic))\n\t\t\treturn -1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "property_name_to_ctype(OnigEncoding enc, UChar* p, UChar* end)\n{\n  hash_data_type ctype;\n  UChar *s, *e;\n  PROPERTY_LIST_INIT_CHECK;\n  s = e = ALLOCA_N(UChar, end-p+1);\n  for (; p < end; p++) {\n    *e++ = ONIGENC_ASCII_CODE_TO_LOWER_CASE(*p);\n  }\n  if (onig_st_lookup_strend(PropertyNameTable, s, e, &ctype) == 0) {\n    return onigenc_minimum_property_name_to_ctype(enc, s, e);\n  }\n  return (int)ctype;\n}", "target": 0}
{"code": "static int nfc_genl_llc_get_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\tif (rc < 0) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\t\treturn rc;\n\t}\n\treturn genlmsg_reply(msg, info);\n}", "target": 0}
{"code": "void LinkResolver::resolve_field_access(fieldDescriptor& fd, const constantPoolHandle& pool, int index, const methodHandle& method, Bytecodes::Code byte, TRAPS) {\n  LinkInfo link_info(pool, index, method, CHECK);\n  resolve_field(fd, link_info, byte, true, CHECK);\n}", "target": 0}
{"code": "static int btrfs_del_sys_chunk(struct btrfs_fs_info *fs_info, u64 chunk_offset)\n{\n\tstruct btrfs_super_block *super_copy = fs_info->super_copy;\n\tstruct btrfs_disk_key *disk_key;\n\tstruct btrfs_chunk *chunk;\n\tu8 *ptr;\n\tint ret = 0;\n\tu32 num_stripes;\n\tu32 array_size;\n\tu32 len = 0;\n\tu32 cur;\n\tstruct btrfs_key key;\n\tmutex_lock(&fs_info->chunk_mutex);\n\tarray_size = btrfs_super_sys_array_size(super_copy);\n\tptr = super_copy->sys_chunk_array;\n\tcur = 0;\n\twhile (cur < array_size) {\n\t\tdisk_key = (struct btrfs_disk_key *)ptr;\n\t\tbtrfs_disk_key_to_cpu(&key, disk_key);\n\t\tlen = sizeof(*disk_key);\n\t\tif (key.type == BTRFS_CHUNK_ITEM_KEY) {\n\t\t\tchunk = (struct btrfs_chunk *)(ptr + len);\n\t\t\tnum_stripes = btrfs_stack_chunk_num_stripes(chunk);\n\t\t\tlen += btrfs_chunk_item_size(num_stripes);\n\t\t} else {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tif (key.objectid == BTRFS_FIRST_CHUNK_TREE_OBJECTID &&\n\t\t    key.offset == chunk_offset) {\n\t\t\tmemmove(ptr, ptr + len, array_size - (cur + len));\n\t\t\tarray_size -= len;\n\t\t\tbtrfs_set_super_sys_array_size(super_copy, array_size);\n\t\t} else {\n\t\t\tptr += len;\n\t\t\tcur += len;\n\t\t}\n\t}\n\tmutex_unlock(&fs_info->chunk_mutex);\n\treturn ret;\n}", "target": 0}
{"code": "GfxSubpath::GfxSubpath(const GfxSubpath *subpath)\n{\n    size = subpath->size;\n    n = subpath->n;\n    x = (double *)gmallocn(size, sizeof(double));\n    y = (double *)gmallocn(size, sizeof(double));\n    curve = (bool *)gmallocn(size, sizeof(bool));\n    memcpy(x, subpath->x, n * sizeof(double));\n    memcpy(y, subpath->y, n * sizeof(double));\n    memcpy(curve, subpath->curve, n * sizeof(bool));\n    closed = subpath->closed;\n}", "target": 0}
{"code": "void ImageLoader::elementDidMoveToNewDocument() {\n  if (m_loadDelayCounter)\n    m_loadDelayCounter->documentChanged(m_element->document());\n  clearFailedLoadURL();\n  setImage(0);\n}", "target": 0}
{"code": "    void CiffHeader::decode(Image& image) const\n    {\n        if (pRootDir_) pRootDir_->decode(image, byteOrder_);\n    } ", "target": 0}
{"code": "static CURLcode gzip_init_writer(struct Curl_easy *data,\n                                 struct contenc_writer *writer)\n{\n  struct zlib_params *zp = (struct zlib_params *) &writer->params;\n  z_stream *z = &zp->z;     \n  if(!writer->downstream)\n    return CURLE_WRITE_ERROR;\n  z->zalloc = (alloc_func) zalloc_cb;\n  z->zfree = (free_func) zfree_cb;\n  if(strcmp(zlibVersion(), \"1.2.0.4\") >= 0) {\n    if(inflateInit2(z, MAX_WBITS + 32) != Z_OK) {\n      return process_zlib_error(data, z);\n    }\n    zp->zlib_init = ZLIB_INIT_GZIP; \n  }\n  else {\n    if(inflateInit2(z, -MAX_WBITS) != Z_OK) {\n      return process_zlib_error(data, z);\n    }\n    zp->trailerlen = 8; \n    zp->zlib_init = ZLIB_INIT; \n  }\n  return CURLE_OK;\n}", "target": 0}
{"code": "static int vhost_poll_wakeup(wait_queue_t *wait, unsigned mode, int sync,\n\t\t\t     void *key)\n{\n\tstruct vhost_poll *poll = container_of(wait, struct vhost_poll, wait);\n\tif (!((unsigned long)key & poll->mask))\n\t\treturn 0;\n\tvhost_poll_queue(poll);\n\treturn 0;\n}", "target": 0}
{"code": "cms_context_alloc(cms_context **cmsp)\n{\n\tcms_context *cms = calloc(1, sizeof (*cms));\n\tif (!cms)\n\t\treturn -1;\n\tint rc = cms_context_init(cms);\n\tif (rc < 0) {\n\t\tset_errno_guard();\n\t\txfree(cms);\n\t\tcms = NULL;\n\t\treturn -1;\n\t}\n\t*cmsp = cms;\n\treturn 0;\n}", "target": 0}
{"code": "bool GLES2DecoderImpl::BoundFramebufferHasStencilAttachment() {\n  FramebufferManager::FramebufferInfo* framebuffer =\n      GetFramebufferInfoForTarget(GL_DRAW_FRAMEBUFFER);\n  if (framebuffer) {\n    return framebuffer->HasStencilAttachment();\n  }\n  if (offscreen_target_frame_buffer_.get()) {\n    return offscreen_target_stencil_format_ != 0 ||\n           offscreen_target_depth_format_ == GL_DEPTH24_STENCIL8;\n  }\n  return back_buffer_has_stencil_;\n}", "target": 0}
{"code": "OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k,\n                                opj_stream_private_t *p_stream,\n                                opj_event_mgr_t * p_manager\n                                )\n{\n    (void)p_j2k;\n    (void)p_stream;\n    (void)p_manager;\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "bqarr_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *buf = (char *) PG_GETARG_POINTER(0);\n\tWORKSTATE\tstate;\n\tint32\t\ti;\n\tQUERYTYPE  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n#ifdef BS_DEBUG\n\tStringInfoData pbuf;\n#endif\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"empty query\")));\n\tif (state.num > QUERYTYPEMAXITEMS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\terrmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",\n\t\t\t   state.num, (int) QUERYTYPEMAXITEMS)));\n\tcommonlen = COMPUTESIZE(state.num);\n\tquery = (QUERYTYPE *) palloc(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = state.num;\n\tptr = GETQUERY(query);\n\tfor (i = state.num - 1; i >= 0; i--)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\tpos = query->size - 1;\n\tfindoprnd(ptr, &pos);\n#ifdef BS_DEBUG\n\tinitStringInfo(&pbuf);\n\tfor (i = 0; i < query->size; i++)\n\t{\n\t\tif (ptr[i].type == OPR)\n\t\t\tappendStringInfo(&pbuf, \"%c(%d) \", ptr[i].val, ptr[i].left);\n\t\telse\n\t\t\tappendStringInfo(&pbuf, \"%d \", ptr[i].val);\n\t}\n\telog(DEBUG3, \"POR: %s\", pbuf.data);\n\tpfree(pbuf.data);\n#endif\n\tPG_RETURN_POINTER(query);\n}", "target": 0}
{"code": "bool want_pmd_share(struct vm_area_struct *vma, unsigned long addr)\n{\n#ifdef CONFIG_USERFAULTFD\n\tif (uffd_disable_huge_pmd_share(vma))\n\t\treturn false;\n#endif\n\treturn vma_shareable(vma, addr);\n}", "target": 0}
{"code": "void smp_proc_master_id(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t* p = p_data->p_data;\n  tBTM_LE_PENC_KEYS le_key;\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n if (p_cb->rcvd_cmd_len < 11) { \n    android_errorWriteLog(0x534e4554, \"111937027\");\n    SMP_TRACE_ERROR(\"%s: Invalid command length: %d, should be at least 11\",\n                    __func__, p_cb->rcvd_cmd_len);\n return;\n }\n  smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ENC, true);\n  STREAM_TO_UINT16(le_key.ediv, p);\n  STREAM_TO_ARRAY(le_key.rand, p, BT_OCTET8_LEN);\n  memcpy(le_key.ltk, p_cb->ltk, BT_OCTET16_LEN);\n  le_key.sec_level = p_cb->sec_level;\n  le_key.key_size = p_cb->loc_enc_size;\n if ((p_cb->peer_auth_req & SMP_AUTH_BOND) &&\n (p_cb->loc_auth_req & SMP_AUTH_BOND))\n    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_PENC,\n (tBTM_LE_KEY_VALUE*)&le_key, true);\n  smp_key_distribution(p_cb, NULL);\n }", "target": 0}
{"code": "int epo_get_bits(gx_device *dev, int y, byte *data, byte **actual_data)\n{\n    int code = epo_handle_erase_page(dev);\n    if (code != 0)\n        return code;\n    return dev_proc(dev, get_bits)(dev, y, data, actual_data);\n}", "target": 0}
{"code": "\tvoid lazy_entry::clear()\n\t{\n\t\tswitch (m_type)\n\t\t{\n\t\t\tcase list_t: delete[] m_data.list; break;\n\t\t\tcase dict_t: delete[] m_data.dict; break;\n\t\t\tdefault: break;\n\t\t}\n\t\tm_data.start = 0;\n\t\tm_size = 0;\n\t\tm_capacity = 0;\n\t\tm_type = none_t;\n\t}", "target": 0}
{"code": "static unsigned int count_open_files(struct fdtable *fdt)\n{\n\tunsigned int size = fdt->max_fds;\n\tunsigned int i;\n\tfor (i = size / BITS_PER_LONG; i > 0; ) {\n\t\tif (fdt->open_fds[--i])\n\t\t\tbreak;\n\t}\n\ti = (i + 1) * BITS_PER_LONG;\n\treturn i;\n}", "target": 0}
{"code": " static int ohci_bus_start(OHCIState *ohci)\n {\n     trace_usb_ohci_start(ohci->name);", "target": 0}
{"code": "static inline bool is_class_loader(const Symbol* class_name,\n                                   const ClassFileParser& parser) {\n  assert(class_name != NULL, \"invariant\");\n  if (class_name == vmSymbols::java_lang_ClassLoader()) {\n    return true;\n  }\n  if (vmClasses::ClassLoader_klass_loaded()) {\n    const Klass* const super_klass = parser.super_klass();\n    if (super_klass != NULL) {\n      if (super_klass->is_subtype_of(vmClasses::ClassLoader_klass())) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "target": 0}
{"code": "Eina_Bool ewk_view_back_possible(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_back_possible(smartData->main_frame);\n}", "target": 0}
{"code": "INT AirPDcapDestroyContext(\n    PAIRPDCAP_CONTEXT ctx)\n{\n    AIRPDCAP_DEBUG_TRACE_START(\"AirPDcapDestroyContext\");\n    if (ctx==NULL) {\n        AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"NULL context\", AIRPDCAP_DEBUG_LEVEL_5);\n        AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\n        return AIRPDCAP_RET_UNSUCCESS;\n    }\n    AirPDcapCleanKeys(ctx);\n    AirPDcapCleanSecAssoc(ctx);\n    ctx->first_free_index=0;\n    ctx->index=-1;\n    ctx->sa_index=-1;\n    AIRPDCAP_DEBUG_PRINT_LINE(\"AirPDcapDestroyContext\", \"Context destroyed!\", AIRPDCAP_DEBUG_LEVEL_5);\n    AIRPDCAP_DEBUG_TRACE_END(\"AirPDcapDestroyContext\");\n    return AIRPDCAP_RET_SUCCESS;\n}", "target": 0}
{"code": "void btrfs_rm_dev_replace_free_srcdev(struct btrfs_fs_info *fs_info,\n\t\t\t\t      struct btrfs_device *srcdev)\n{\n\tstruct btrfs_fs_devices *fs_devices = srcdev->fs_devices;\n\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &srcdev->dev_state)) {\n\t\tbtrfs_scratch_superblocks(srcdev->bdev, srcdev->name->str);\n\t}\n\tbtrfs_close_bdev(srcdev);\n\tcall_rcu(&srcdev->rcu, free_device_rcu);\n\tif (!fs_devices->num_devices) {\n\t\tstruct btrfs_fs_devices *tmp_fs_devices;\n\t\tASSERT(fs_devices->seeding);\n\t\ttmp_fs_devices = fs_info->fs_devices;\n\t\twhile (tmp_fs_devices) {\n\t\t\tif (tmp_fs_devices->seed == fs_devices) {\n\t\t\t\ttmp_fs_devices->seed = fs_devices->seed;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttmp_fs_devices = tmp_fs_devices->seed;\n\t\t}\n\t\tfs_devices->seed = NULL;\n\t\tclose_fs_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n}", "target": 0}
{"code": "int sc_pkcs15emu_sc_hsm_get_curve(struct ec_curve **curve, u8 *oid, size_t oidlen)\n{\n\tint i;\n\tfor (i = 0; curves[i].oid.value; i++) {\n\t\tif ((curves[i].oid.len == oidlen) && !memcmp(curves[i].oid.value, oid, oidlen)) {\n\t\t\t*curve = &curves[i];\n\t\t\treturn SC_SUCCESS;\n\t\t}\n\t}\n\treturn SC_ERROR_INVALID_DATA;\n}", "target": 0}
{"code": "static void svm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr,\n\t\t\t\tbool has_error_code, u32 error_code,\n\t\t\t\tbool reinject)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif (!reinject &&\n\t    nested_svm_check_exception(svm, nr, has_error_code, error_code))\n\t\treturn;\n\tif (nr == BP_VECTOR && !static_cpu_has(X86_FEATURE_NRIPS)) {\n\t\tunsigned long rip, old_rip = kvm_rip_read(&svm->vcpu);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t\trip = kvm_rip_read(&svm->vcpu);\n\t\tsvm->int3_rip = rip + svm->vmcb->save.cs.base;\n\t\tsvm->int3_injected = rip - old_rip;\n\t}\n\tsvm->vmcb->control.event_inj = nr\n\t\t| SVM_EVTINJ_VALID\n\t\t| (has_error_code ? SVM_EVTINJ_VALID_ERR : 0)\n\t\t| SVM_EVTINJ_TYPE_EXEPT;\n\tsvm->vmcb->control.event_inj_err = error_code;\n}", "target": 0}
{"code": "static int sp_set_mac_address(struct net_device *dev, void *addr)\n{\n\tstruct sockaddr_ax25 *sa = addr;\n\tnetif_tx_lock_bh(dev);\n\tnetif_addr_lock(dev);\n\tmemcpy(dev->dev_addr, &sa->sax25_call, AX25_ADDR_LEN);\n\tnetif_addr_unlock(dev);\n\tnetif_tx_unlock_bh(dev);\n\treturn 0;\n}", "target": 0}
{"code": "  MaybeObject* pending_exception() {\n    ASSERT(has_pending_exception());\n    return thread_local_top_.pending_exception_;\n  }", "target": 0}
{"code": "static void cassignforin(JF, js_Ast *stm)\n{\n\tjs_Ast *lhs = stm->a;\n\tif (stm->type == STM_FOR_IN_VAR) {\n\t\tif (lhs->b)\n\t\t\tjsC_error(J, lhs->b, \"more than one loop variable in for-in statement\");\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs->a->a); \n\t\temit(J, F, OP_POP);\n\t\treturn;\n\t}\n\tswitch (lhs->type) {\n\tcase EXP_IDENTIFIER:\n\t\temitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tcase EXP_INDEX:\n\t\tcexp(J, F, lhs->a);\n\t\tcexp(J, F, lhs->b);\n\t\temit(J, F, OP_ROT3);\n\t\temit(J, F, OP_SETPROP);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tcase EXP_MEMBER:\n\t\tcexp(J, F, lhs->a);\n\t\temit(J, F, OP_ROT2);\n\t\temitstring(J, F, OP_SETPROP_S, lhs->b->string);\n\t\temit(J, F, OP_POP);\n\t\tbreak;\n\tdefault:\n\t\tjsC_error(J, lhs, \"invalid l-value in for-in loop assignment\");\n\t}\n}", "target": 0}
{"code": "dns_resolver_match(const struct key *key,\nstatic int dns_resolver_cmp(const struct key *key,\n\t\t\t    const struct key_match_data *match_data)\n {\n \tint slen, dlen, ret = 0;\n \tconst char *src = key->description, *dsp = match_data->raw_data;\n\tkenter(\"%s,%s\", src, dsp);\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n \treturn ret;\n }", "target": 0}
{"code": "static void ctrn_write_ctso(GF_TrackFragmentRunBox *ctrn, GF_BitStream *bs, u32 ctso, u32 field_size)\n{\n\tif (!field_size) return;\n\tif (ctrn->ctso_multiplier) {\n\t\tgf_bs_write_int(bs, ctso / ctrn->ctso_multiplier, field_size);\n\t} else {\n\t\tgf_bs_write_int(bs, ctso, field_size);\n\t}\n}", "target": 0}
{"code": "xfs_ioc_ag_geometry(\n\tstruct xfs_mount\t*mp,\n\tvoid\t\t\t__user *arg)\n{\n\tstruct xfs_ag_geometry\tageo;\n\tint\t\t\terror;\n\tif (copy_from_user(&ageo, arg, sizeof(ageo)))\n\t\treturn -EFAULT;\n\tif (ageo.ag_flags)\n\t\treturn -EINVAL;\n\tif (memchr_inv(&ageo.ag_reserved, 0, sizeof(ageo.ag_reserved)))\n\t\treturn -EINVAL;\n\terror = xfs_ag_get_geometry(mp, ageo.ag_number, &ageo);\n\tif (error)\n\t\treturn error;\n\tif (copy_to_user(arg, &ageo, sizeof(ageo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "void ring_buffer_iter_reset(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tunsigned long flags;\n\tif (!iter)\n\t\treturn;\n\tcpu_buffer = iter->cpu_buffer;\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\trb_iter_reset(iter);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n}", "target": 0}
{"code": "static void load_firmware_cb(const struct firmware *fw,\n\t\t\t     void *context)\n{\n\tstruct dvb_frontend *fe = context;\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\ttuner_dbg(\"request_firmware_nowait(): %s\\n\", fw ? \"OK\" : \"error\");\n\tif (!fw) {\n\t\ttuner_err(\"Could not load firmware %s.\\n\", priv->fname);\n\t\tpriv->state = XC2028_NODEV;\n\t\treturn;\n\t}\n\trc = load_all_firmwares(fe, fw);\n\trelease_firmware(fw);\n\tif (rc < 0)\n\t\treturn;\n\tpriv->state = XC2028_ACTIVE;\n}", "target": 0}
{"code": "static void my_output_message( j_common_ptr ) {} ", "target": 0}
{"code": "acpi_status __init acpi_os_initialize(void)\n{\n\tacpi_os_map_generic_address(&acpi_gbl_FADT.xpm1a_event_block);\n\tacpi_os_map_generic_address(&acpi_gbl_FADT.xpm1b_event_block);\n\tacpi_os_map_generic_address(&acpi_gbl_FADT.xgpe0_block);\n\tacpi_os_map_generic_address(&acpi_gbl_FADT.xgpe1_block);\n\tif (acpi_gbl_FADT.flags & ACPI_FADT_RESET_REGISTER) {\n\t\tint rv;\n\t\trv = acpi_os_map_generic_address(&acpi_gbl_FADT.reset_register);\n\t\tpr_debug(PREFIX \"%s: map reset_reg status %d\\n\", __func__, rv);\n\t}\n\tacpi_os_initialized = true;\n\treturn AE_OK;\n}", "target": 0}
{"code": "encode_DECAP(const struct ofpact_decap *decap,\n                enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)\n{\n    struct nx_action_decap *nad = put_NXAST_DECAP(out);\n    nad->len = htons(sizeof(struct nx_action_decap));\n    nad->new_pkt_type = decap->new_pkt_type;\n}", "target": 0}
{"code": "event_set_no_set_filter_flag(struct trace_event_file *file)\n{\n\tfile->flags |= EVENT_FILE_FL_NO_SET_FILTER;\n}", "target": 0}
{"code": "static inline void kvm_inject_gp(struct kvm_vcpu *vcpu, u32 error_code)\n{\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n}", "target": 0}
{"code": "setNewLineString(const char* ch)\n{\n\tnewlinestring = ch;\n}", "target": 0}
{"code": "vte_sequence_handler_al (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tVteRowData *rowdata;\n\tlong start, end, param, i;\n\tGValue *value;\n\tscreen = terminal->pvt->screen;\n\tstart = screen->cursor_current.row;\n\tif (screen->scrolling_restricted) {\n\t\tend = screen->insert_delta + screen->scrolling_region.end;\n\t} else {\n\t\tend = screen->insert_delta + terminal->row_count - 1;\n\t}\n\tparam = 1;\n\tif ((params != NULL) && (params->n_values > 0)) {\n\t\tvalue = g_value_array_get_nth(params, 0);\n\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\tparam = g_value_get_long(value);\n\t\t}\n\t}\n\tfor (i = 0; i < param; i++) {\n\t\tvte_remove_line_internal(terminal, end);\n\t\tvte_insert_line_internal(terminal, start);\n\t\trowdata = _vte_ring_index(screen->row_data,\n\t\t\t\t\t  VteRowData *, start);\n\t\tg_assert(rowdata != NULL);\n\t\tvte_g_array_fill(rowdata->cells, &screen->fill_defaults,\n\t\t\t\t terminal->column_count);\n\t\t_vte_terminal_adjust_adjustments(terminal);\n\t}\n\t_vte_terminal_scroll_region(terminal, start, end - start + 1, param);\n\tterminal->pvt->text_deleted_flag = TRUE;\n}", "target": 0}
{"code": "static inline void svm_inject_irq(struct vcpu_svm *svm, int irq)\n{\n\tstruct vmcb_control_area *control;\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = irq;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t(( 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}", "target": 0}
{"code": "Method* InstanceKlass::find_instance_method(const Array<Method*>* methods,\n                                            const Symbol* name,\n                                            const Symbol* signature,\n                                            PrivateLookupMode private_mode) {\n  Method* const meth = InstanceKlass::find_method_impl(methods,\n                                                 name,\n                                                 signature,\n                                                 find_overpass,\n                                                 skip_static,\n                                                 private_mode);\n  assert(((meth == NULL) || !meth->is_static()),\n    \"find_instance_method should have skipped statics\");\n  return meth;\n}", "target": 0}
{"code": "  Warning_Obj Parser::parse_warning()\n  {\n    if (stack.back() != Scope::Root &&\n        stack.back() != Scope::Function &&\n        stack.back() != Scope::Mixin &&\n        stack.back() != Scope::Control &&\n        stack.back() != Scope::Rules) {\n      error(\"Illegal nesting: Only properties may be nested beneath properties.\");\n    }\n    return SASS_MEMORY_NEW(Warning, pstate, parse_list(DELAYED));\n  }", "target": 0}
{"code": "mcs_recv_aucf(uint16 * mcs_userid)\n{\n\tuint8 opcode, result;\n\tSTREAM s;\n\ts = iso_recv(NULL);\n\tif (s == NULL)\n\t\treturn False;\n\tin_uint8(s, opcode);\n\tif ((opcode >> 2) != MCS_AUCF)\n\t{\n\t\terror(\"expected AUcf, got %d\\n\", opcode);\n\t\treturn False;\n\t}\n\tin_uint8(s, result);\n\tif (result != 0)\n\t{\n\t\terror(\"AUrq: %d\\n\", result);\n\t\treturn False;\n\t}\n\tif (opcode & 2)\n\t\tin_uint16_be(s, *mcs_userid);\n\treturn s_check_end(s);\n}", "target": 0}
{"code": "static void __reg_bound_offset(struct bpf_reg_state *reg)\n{\n\tstruct tnum var64_off = tnum_intersect(reg->var_off,\n\t\t\t\t\t       tnum_range(reg->umin_value,\n\t\t\t\t\t\t\t  reg->umax_value));\n\tstruct tnum var32_off = tnum_intersect(tnum_subreg(reg->var_off),\n\t\t\t\t\t\ttnum_range(reg->u32_min_value,\n\t\t\t\t\t\t\t   reg->u32_max_value));\n\treg->var_off = tnum_or(tnum_clear_subreg(var64_off), var32_off);\n}", "target": 0}
{"code": "static int verify_headers(const void *data, unsigned long size,\n\t\t\t  struct object *obj, struct fsck_options *options)\n{\n\tconst char *buffer = (const char *)data;\n\tunsigned long i;\n\tfor (i = 0; i < size; i++) {\n\t\tswitch (buffer[i]) {\n\t\tcase '\\0':\n\t\t\treturn report(options, obj,\n\t\t\t\tFSCK_MSG_NUL_IN_HEADER,\n\t\t\t\t\"unterminated header: NUL at offset %ld\", i);\n\t\tcase '\\n':\n\t\t\tif (i + 1 < size && buffer[i + 1] == '\\n')\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\tif (size && buffer[size - 1] == '\\n')\n\t\treturn 0;\n\treturn report(options, obj,\n\t\tFSCK_MSG_UNTERMINATED_HEADER, \"unterminated header\");\n}", "target": 0}
{"code": "void ConvolverNode::reset()\n{\n    MutexLocker locker(m_processLock);\n    if (m_reverb.get())\n        m_reverb->reset();\n}", "target": 0}
{"code": "get_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\treturn extensions;\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_read_cbd (      opj_j2k_t *p_j2k,\n                                                                OPJ_BYTE * p_header_data,\n                                                                OPJ_UINT32 p_header_size,\n                                                                opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_nb_comp,l_num_comp;\n        OPJ_UINT32 l_comp_def;\n        OPJ_UINT32 i;\n        opj_image_comp_t * l_comp = 00;\n        assert(p_header_data != 00);\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        l_num_comp = p_j2k->m_private_image->numcomps;\n        if (p_header_size != (p_j2k->m_private_image->numcomps + 2)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Crror reading CBD marker\\n\");\n                return OPJ_FALSE;\n        }\n        opj_read_bytes(p_header_data,&l_nb_comp,2);                             \n        p_header_data+=2;\n        if (l_nb_comp != l_num_comp) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Crror reading CBD marker\\n\");\n                return OPJ_FALSE;\n        }\n        l_comp = p_j2k->m_private_image->comps;\n        for (i=0;i<l_num_comp;++i) {\n                opj_read_bytes(p_header_data,&l_comp_def,1);                    \n                ++p_header_data;\n        l_comp->sgnd = (l_comp_def>>7) & 1;\n                l_comp->prec = (l_comp_def&0x7f) + 1;\n                ++l_comp;\n        }\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::WasHidden() {\n  if (!host_ || host_->is_hidden())\n    return;\n  host_->WasHidden();\n  software_frame_manager_->SetVisibility(false);\n  delegated_frame_evictor_->SetVisible(false);\n  released_front_lock_ = NULL;\n#if defined(OS_WIN)\n  constrained_rects_.clear();\n  aura::WindowEventDispatcher* dispatcher = window_->GetDispatcher();\n  if (dispatcher) {\n    HWND parent = dispatcher->host()->GetAcceleratedWidget();\n    LPARAM lparam = reinterpret_cast<LPARAM>(this);\n    EnumChildWindows(parent, HideWindowsCallback, lparam);\n  }\n  if (::IsWindow(plugin_parent_window_))\n    ::SetWindowPos(plugin_parent_window_, NULL, 0, 0, 0, 0, 0);\n#endif\n}", "target": 0}
{"code": "int gnutls_x509_ext_export_key_purposes(gnutls_x509_key_purposes_t p,\n\t\t\t\t     gnutls_datum_t * ext)\n{\n\tint result, ret;\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tunsigned i;\n\tresult = asn1_create_element\n\t    (_gnutls_get_pkix(), \"PKIX1.ExtKeyUsageSyntax\", &c2);\n\tif (result != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(result);\n\t}\n\tfor (i=0;i<p->size;i++) {\n\t\tresult = asn1_write_value(c2, \"\", \"NEW\", 1);\n\t\tif (result != ASN1_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tret = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tresult = asn1_write_value(c2, \"?LAST\", p->oid[i].data, 1);\n\t\tif (result != ASN1_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tret = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tret = _gnutls_x509_der_encode(c2, \"\", ext, 0);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n\tret = 0;\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "DLLEXPORT unsigned char *DLLCALL tjAlloc(int bytes)\n{\n\treturn (unsigned char *)malloc(bytes);\n}", "target": 0}
{"code": "static void mark_used_tables_as_free_for_reuse(THD *thd, TABLE *table)\n{\n  for (; table ; table= table->next)\n  {\n    DBUG_ASSERT(table->pos_in_locked_tables == NULL ||\n                table->pos_in_locked_tables->table == table);\n    if (table->query_id == thd->query_id)\n    {\n      table->query_id= 0;\n      table->file->ha_reset();\n    }\n    else if (table->file->check_table_binlog_row_based_done)\n      table->file->clear_cached_table_binlog_row_based_flag();\n  }\n}", "target": 0}
{"code": "static int set_next_request(void)\n{\n\tstruct request_queue *q;\n\tint old_pos = fdc_queue;\n\tdo {\n\t\tq = disks[fdc_queue]->queue;\n\t\tif (++fdc_queue == N_DRIVE)\n\t\t\tfdc_queue = 0;\n\t\tif (q) {\n\t\t\tcurrent_req = blk_fetch_request(q);\n\t\t\tif (current_req)\n\t\t\t\tbreak;\n\t\t}\n\t} while (fdc_queue != old_pos);\n\treturn current_req != NULL;\n}", "target": 0}
{"code": "void zend_register_default_exception(TSRMLS_D) \n{\n\tzend_class_entry ce;\n\tINIT_CLASS_ENTRY(ce, \"Exception\", default_exception_functions);\n\tdefault_exception_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tdefault_exception_ce->create_object = zend_default_exception_new;\n\tmemcpy(&default_exception_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tdefault_exception_handlers.clone_obj = NULL;\n\tzend_declare_property_string(default_exception_ce, \"message\", sizeof(\"message\")-1, \"\", ZEND_ACC_PROTECTED TSRMLS_CC);\n\tzend_declare_property_string(default_exception_ce, \"string\", sizeof(\"string\")-1, \"\", ZEND_ACC_PRIVATE TSRMLS_CC);\n\tzend_declare_property_long(default_exception_ce, \"code\", sizeof(\"code\")-1, 0, ZEND_ACC_PROTECTED TSRMLS_CC);\n\tzend_declare_property_null(default_exception_ce, \"file\", sizeof(\"file\")-1, ZEND_ACC_PROTECTED TSRMLS_CC);\n\tzend_declare_property_null(default_exception_ce, \"line\", sizeof(\"line\")-1, ZEND_ACC_PROTECTED TSRMLS_CC);\n\tzend_declare_property_null(default_exception_ce, \"trace\", sizeof(\"trace\")-1, ZEND_ACC_PRIVATE TSRMLS_CC);\n\tzend_declare_property_null(default_exception_ce, \"previous\", sizeof(\"previous\")-1, ZEND_ACC_PRIVATE TSRMLS_CC);\n\tINIT_CLASS_ENTRY(ce, \"ErrorException\", error_exception_functions);\n\terror_exception_ce = zend_register_internal_class_ex(&ce, default_exception_ce, NULL TSRMLS_CC);\n\terror_exception_ce->create_object = zend_error_exception_new;\n\tzend_declare_property_long(error_exception_ce, \"severity\", sizeof(\"severity\")-1, E_ERROR, ZEND_ACC_PROTECTED TSRMLS_CC);\n}", "target": 0}
{"code": "static void encode_free_stateid(struct xdr_stream *xdr,\n\t\t\t\tstruct nfs41_free_stateid_args *args,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_FREE_STATEID, decode_free_stateid_maxsz, hdr);\n\tencode_nfs4_stateid(xdr, args->stateid);\n}", "target": 0}
{"code": "void RenderThreadImpl::IdleHandler() {\n  bool run_in_foreground_tab = (widget_count_ > hidden_widget_count_) &&\n                               GetContentClient()->renderer()->\n                                   RunIdleHandlerWhenWidgetsHidden();\n  if (run_in_foreground_tab) {\n    IdleHandlerInForegroundTab();\n    return;\n  }\n  base::allocator::ReleaseFreeMemory();\n  bool continue_timer = !webkit_shared_timer_suspended_;\n  if (blink::mainThreadIsolate() &&\n      !blink::mainThreadIsolate()->IdleNotification(1000)) {\n    continue_timer = true;\n  }\n  if (!base::DiscardableMemory::ReduceMemoryUsage()) {\n    continue_timer = true;\n  }\n  if (continue_timer) {\n    ScheduleIdleHandler(\n        std::max(kLongIdleHandlerDelayMs,\n                 idle_notification_delay_in_ms_ +\n                 1000000 / (idle_notification_delay_in_ms_ + 2000)));\n  } else {\n    idle_timer_.Stop();\n  }\n  FOR_EACH_OBSERVER(RenderProcessObserver, observers_, IdleNotification());\n}", "target": 0}
{"code": "void AccessibilityUIElement::takeSelection()\n{\n}", "target": 0}
{"code": "flatpak_context_load_for_deploy (FlatpakDeploy *deploy,\n                                 GError       **error)\n{\n  g_autoptr(FlatpakContext) context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  metakey = flatpak_deploy_get_metadata (deploy);\n  context = flatpak_app_compute_permissions (metakey, NULL, error);\n  if (context == NULL)\n    return NULL;\n  overrides = flatpak_deploy_get_overrides (deploy);\n  flatpak_context_merge (context, overrides);\n  return g_steal_pointer (&context);\n}", "target": 0}
{"code": "static inline Quantum ScaleShortToQuantum(const unsigned short value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) ((value+128U)/257U));\n#else\n  return((Quantum) (value/257.0));\n#endif\n}", "target": 0}
{"code": "void CLASS parseSonyLensType2 (uchar a, uchar b) {\n  ushort lid2;\n  lid2 = (((ushort)a)<<8) | ((ushort)b);\n  if (!lid2) return;\n  if (lid2 < 0x100)\n    {\n      imgdata.lens.makernotes.AdapterID = lid2;\n      switch (lid2) {\n      case 1:\n      case 2:\n      case 3:\n      case 6:\n        imgdata.lens.makernotes.LensMount = Minolta_A;\n        break;\n      case 44:\n      case 78:\n      case 239:\n        imgdata.lens.makernotes.LensMount = Canon_EF;\n        break;\n      }\n    }\n  else\n    imgdata.lens.makernotes.LensID = lid2;\n  return;\n}", "target": 0}
{"code": "bool AccessibilityUIElement::isMultiSelectable() const\n{\n    return checkElementState(m_element, ATK_STATE_MULTISELECTABLE);\n}", "target": 0}
{"code": "static inline unsigned int xt_write_recseq_begin(void)\n{\n\tunsigned int addend;\n\taddend = (__this_cpu_read(xt_recseq.sequence) + 1) & 1;\n\t__this_cpu_add(xt_recseq.sequence, addend);\n\tsmp_mb();\n\treturn addend;\n}", "target": 0}
{"code": "void RenderView::Init(gfx::NativeViewId parent_hwnd,\n                      int32 opener_id,\n                      const RendererPreferences& renderer_prefs,\n                      SharedRenderViewCounter* counter,\n                      int32 routing_id,\n                      const string16& frame_name) {\n  DCHECK(!webview());\n  if (opener_id != MSG_ROUTING_NONE)\n    opener_id_ = opener_id;\n  if (counter) {\n    shared_popup_counter_ = counter;\n    shared_popup_counter_->data++;\n    decrement_shared_popup_at_destruction_ = true;\n  } else {\n    shared_popup_counter_ = new SharedRenderViewCounter(0);\n    decrement_shared_popup_at_destruction_ = false;\n  }\n  devtools_agent_.reset(new DevToolsAgent(routing_id, this));\n  webwidget_ = WebView::create(this, devtools_agent_.get());\n  Singleton<ViewMap>::get()->insert(std::make_pair(webview(), this));\n  webkit_preferences_.Apply(webview());\n  webview()->initializeMainFrame(this);\n  if (!frame_name.empty())\n    webview()->mainFrame()->setName(frame_name);\n  OnSetRendererPrefs(renderer_prefs);\n  routing_id_ = routing_id;\n  render_thread_->AddRoute(routing_id_, this);\n  AddRef();\n  if (opener_id == MSG_ROUTING_NONE) {\n    did_show_ = true;\n    CompleteInit(parent_hwnd);\n  }\n  host_window_ = parent_hwnd;\n  const CommandLine& command_line = *CommandLine::ForCurrentProcess();\n  if (command_line.HasSwitch(switches::kDomAutomationController))\n    enabled_bindings_ |= BindingsPolicy::DOM_AUTOMATION;\n  audio_message_filter_ = new AudioMessageFilter(routing_id_);\n  render_thread_->AddFilter(audio_message_filter_);\n}", "target": 0}
{"code": "void FrameLoader::addExtraFieldsToMainResourceRequest(ResourceRequest& request)\n{\n    addExtraFieldsToRequest(request, m_loadType, true, false);\n}", "target": 0}
{"code": "rb_backref_set_string(VALUE string, long pos, long len)\n{\n    VALUE match = rb_backref_get();\n    if (NIL_P(match) || FL_TEST(match, MATCH_BUSY)) {\n\tmatch = match_alloc(rb_cMatch);\n    }\n    match_set_string(match, string, pos, len);\n    rb_backref_set(match);\n}", "target": 0}
{"code": "static std::string WrapWithTD(std::string text) {\n  return \"<td>\" + text + \"</td>\";\n}", "target": 0}
{"code": "static int sev_launch_secret(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_secret *data;\n\tstruct kvm_sev_launch_secret params;\n\tstruct page **pages;\n\tvoid *blob, *hdr;\n\tunsigned long n;\n\tint ret, offset;\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\tpages = sev_pin_memory(kvm, params.guest_uaddr, params.guest_len, &n, 1);\n\tif (IS_ERR(pages))\n\t\treturn PTR_ERR(pages);\n\tif (get_num_contig_pages(0, pages, n) != n) {\n\t\tret = -EINVAL;\n\t\tgoto e_unpin_memory;\n\t}\n\tret = -ENOMEM;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto e_unpin_memory;\n\toffset = params.guest_uaddr & (PAGE_SIZE - 1);\n\tdata->guest_address = __sme_page_pa(pages[0]) + offset;\n\tdata->guest_len = params.guest_len;\n\tblob = psp_copy_user_blob(params.trans_uaddr, params.trans_len);\n\tif (IS_ERR(blob)) {\n\t\tret = PTR_ERR(blob);\n\t\tgoto e_free;\n\t}\n\tdata->trans_address = __psp_pa(blob);\n\tdata->trans_len = params.trans_len;\n\thdr = psp_copy_user_blob(params.hdr_uaddr, params.hdr_len);\n\tif (IS_ERR(hdr)) {\n\t\tret = PTR_ERR(hdr);\n\t\tgoto e_free_blob;\n\t}\n\tdata->hdr_address = __psp_pa(hdr);\n\tdata->hdr_len = params.hdr_len;\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_SECRET, data, &argp->error);\n\tkfree(hdr);\ne_free_blob:\n\tkfree(blob);\ne_free:\n\tkfree(data);\ne_unpin_memory:\n\tsev_unpin_memory(kvm, pages, n);\n\treturn ret;\n}", "target": 0}
{"code": "vte_sequence_handler_al (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tlong start, end, param, i;\n\tGValue *value;\n\tscreen = terminal->pvt->screen;\n\tstart = screen->cursor_current.row;\n\tif (screen->scrolling_restricted) {\n\t\tend = screen->insert_delta + screen->scrolling_region.end;\n\t} else {\n\t\tend = screen->insert_delta + terminal->row_count - 1;\n\t}\n\tparam = 1;\n\tif ((params != NULL) && (params->n_values > 0)) {\n\t\tvalue = g_value_array_get_nth(params, 0);\n\t\tif (G_VALUE_HOLDS_LONG(value)) {\n\t\t\tparam = g_value_get_long(value);\n\t\t}\n\t}\n\tfor (i = 0; i < param; i++) {\n\t\t_vte_terminal_ring_remove (terminal, end);\n\t\t_vte_terminal_ring_insert (terminal, start, TRUE);\n\t\t_vte_terminal_adjust_adjustments(terminal);\n\t}\n\t_vte_terminal_scroll_region(terminal, start, end - start + 1, param);\n\tterminal->pvt->text_deleted_flag = TRUE;\n}", "target": 0}
{"code": "void RGWDeleteBucketReplication_ObjStore_S3::update_sync_policy(rgw_sync_policy_info *policy)\n{\n  policy->groups.erase(enabled_group_id);\n  policy->groups.erase(disabled_group_id);\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::OnWindowDestroying() {\n#if defined(OS_WIN)\n  HWND parent = NULL;\n  if (!window_->GetRootWindow() || host_->is_hidden()) {\n    parent = ui::GetHiddenWindow();\n  } else {\n    parent = window_->GetDispatcher()->host()->GetAcceleratedWidget();\n  }\n  LPARAM lparam = reinterpret_cast<LPARAM>(this);\n  EnumChildWindows(parent, WindowDestroyingCallback, lparam);\n#endif\n  ui::InputMethod* input_method = GetInputMethod();\n  if (input_method)\n    input_method->DetachTextInputClient(this);\n}", "target": 0}
{"code": "int sc_concatenate_path(sc_path_t *d, const sc_path_t *p1, const sc_path_t *p2)\n{\n\tsc_path_t tpath;\n\tif (d == NULL || p1 == NULL || p2 == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (p1->type == SC_PATH_TYPE_DF_NAME || p2->type == SC_PATH_TYPE_DF_NAME)\n\t\treturn SC_ERROR_NOT_SUPPORTED;\n\tif (p1->len + p2->len > SC_MAX_PATH_SIZE)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tmemset(&tpath, 0, sizeof(sc_path_t));\n\tmemcpy(tpath.value, p1->value, p1->len);\n\tmemcpy(tpath.value + p1->len, p2->value, p2->len);\n\ttpath.len  = p1->len + p2->len;\n\ttpath.type = SC_PATH_TYPE_PATH;\n\ttpath.index = p2->index;\n\ttpath.count = p2->count;\n\ttpath.type  = SC_PATH_TYPE_PATH;\n\t*d = tpath;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "const void *rdma_consumer_reject_data(struct rdma_cm_id *id,\n\t\t\t\t      struct rdma_cm_event *ev, u8 *data_len)\n{\n\tconst void *p;\n\tif (rdma_is_consumer_reject(id, ev->status)) {\n\t\t*data_len = ev->param.conn.private_data_len;\n\t\tp = ev->param.conn.private_data;\n\t} else {\n\t\t*data_len = 0;\n\t\tp = NULL;\n\t}\n\treturn p;\n}", "target": 0}
{"code": "mech_requires_mechlistMIC(spnego_gss_ctx_id_t sc)\n{\n\tOM_uint32 major, minor;\n\tgss_ctx_id_t ctx = sc->ctx_handle;\n\tgss_OID oid = (gss_OID)&spnego_req_mechlistMIC_oid;\n\tgss_buffer_set_t bufs;\n\tint result;\n\tmajor = gss_inquire_sec_context_by_oid(&minor, ctx, oid, &bufs);\n\tif (major != GSS_S_COMPLETE)\n\t\treturn 0;\n\tresult = (bufs != NULL && bufs->count == 1 &&\n\t\t  bufs->elements[0].length == 1 &&\n\t\t  memcmp(bufs->elements[0].value, \"\\1\", 1) == 0);\n\t(void) gss_release_buffer_set(&minor, &bufs);\n\treturn result;\n}", "target": 0}
{"code": "TEST(BasicFlatBufferModel, TestSetNumThreads) {\n  TestErrorReporter reporter;\n  auto model = FlatBufferModel::BuildFromFile(\n      \"tensorflow/lite/testdata/test_model.bin\", &reporter);\n  ASSERT_TRUE(model);\n  std::unique_ptr<Interpreter> interpreter;\n  TrivialResolver resolver(&dummy_reg);\n  InterpreterBuilder builder(*model, resolver);\n  ASSERT_EQ(builder.SetNumThreads(42), kTfLiteOk);\n  interpreter.reset();\n  ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_EQ(builder.SetNumThreads(0), kTfLiteOk);\n  interpreter.reset();\n  ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_EQ(builder.SetNumThreads(-1), kTfLiteOk);\n  interpreter.reset();\n  ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_EQ(reporter.num_calls(), 0);\n  ASSERT_EQ(builder.SetNumThreads(-2), kTfLiteError);\n  interpreter.reset();\n  ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_EQ(reporter.num_calls(), 1);\n  ASSERT_PRED_FORMAT2(testing::IsSubstring,\n                      \"num_threads should be >= 0 or just -1\",\n                      reporter.error_messages());\n}", "target": 0}
{"code": "scoped_ptr<ui::EventTargetIterator> Shell::GetChildIterator() const {\n  return scoped_ptr<ui::EventTargetIterator>();\n}", "target": 0}
{"code": "static void __free_fdtable(struct fdtable *fdt)\n{\n\tkvfree(fdt->fd);\n\tkvfree(fdt->open_fds);\n\tkfree(fdt);\n}", "target": 0}
{"code": "format_256(const u_char *data)\n{\n    static char buf[4][sizeof(\"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\")];\n    static int i = 0;\n    i = (i + 1) % 4;\n    snprintf(buf[i], sizeof(buf[i]), \"%016\" PRIx64 \"%016\" PRIx64 \"%016\" PRIx64 \"%016\" PRIx64,\n         EXTRACT_64BITS(data),\n         EXTRACT_64BITS(data + 8),\n         EXTRACT_64BITS(data + 16),\n         EXTRACT_64BITS(data + 24)\n    );\n    return buf[i];\n}", "target": 0}
{"code": "isdn_net_rmallphone(isdn_net_dev *p)\n{\n\tisdn_net_phone *n;\n\tisdn_net_phone *m;\n\tint i;\n\tfor (i = 0; i < 2; i++) {\n\t\tn = p->local->phone[i];\n\t\twhile (n) {\n\t\t\tm = n->next;\n\t\t\tkfree(n);\n\t\t\tn = m;\n\t\t}\n\t\tp->local->phone[i] = NULL;\n\t}\n\tp->local->dial = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "void RtmpProtocol::send_complex_S0S1S2(int schemeType,const string &digest){\n    char handshake_head = HANDSHAKE_PLAINTEXT;\n    onSendRawData(obtainBuffer(&handshake_head, 1));\n    RtmpHandshake s1(0);\n    memcpy(s1.zero, \"\\x04\\x05\\x00\\x01\", 4);\n    char *digestPos;\n    if (schemeType == 0) {\n        get_C1_digest(s1.random + C1_SCHEMA_SIZE, &digestPos);\n    } else {\n        get_C1_digest(s1.random, &digestPos);\n    }\n    char *s1_start = (char *) &s1;\n    string s1_joined(s1_start, sizeof(s1));\n    s1_joined.erase(digestPos - s1_start, C1_DIGEST_SIZE);\n    string s1_digest = openssl_HMACsha256(FMSKey, S1_FMS_KEY_SIZE, s1_joined.data(), s1_joined.size());\n    memcpy(digestPos, s1_digest.data(), s1_digest.size());\n    onSendRawData(obtainBuffer((char *) &s1, sizeof(s1)));\n    string s2_key = openssl_HMACsha256(FMSKey, S2_FMS_KEY_SIZE, digest.data(), digest.size());\n    RtmpHandshake s2(0);\n    s2.random_generate((char *) &s2, 8);\n    string s2_digest = openssl_HMACsha256(s2_key.data(), s2_key.size(), &s2, sizeof(s2) - C1_DIGEST_SIZE);\n    memcpy((char *) &s2 + C1_HANDSHARK_SIZE - C1_DIGEST_SIZE, s2_digest.data(), C1_DIGEST_SIZE);\n    onSendRawData(obtainBuffer((char *) &s2, sizeof(s2)));\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_C2(data, len);\n    };\n}", "target": 0}
{"code": "epass2003_restore_security_env(struct sc_card *card, int se_num)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}", "target": 0}
{"code": "MagickExport int LocaleCompare(const char *p,const char *q)\n{\n  if (p == (char *) NULL)\n    {\n      if (q == (char *) NULL)\n        return(0);\n      return(-1);\n    }\n  if (q == (char *) NULL)\n    return(1);\n#if defined(MAGICKCORE_HAVE_STRCASECMP)\n  return(strcasecmp(p,q));\n#else\n  {\n    register int\n      c,\n      d;\n    for ( ; ; )\n    {\n      c=(int) *((unsigned char *) p);\n      d=(int) *((unsigned char *) q);\n      if ((c == 0) || (AsciiMap[c] != AsciiMap[d]))\n        break;\n      p++;\n      q++;\n    }\n    return(AsciiMap[c]-(int) AsciiMap[d]);\n  }\n#endif\n}", "target": 0}
{"code": "iasecc_init_oberthur(struct sc_card *card)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned int flags;\n\tint rv = 0;\n\tLOG_FUNC_CALLED(ctx);\n\tflags = IASECC_CARD_DEFAULT_FLAGS;\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0x10001);\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0x10001);\n\tcard->caps = SC_CARD_CAP_RNG;\n\tcard->caps |= SC_CARD_CAP_APDU_EXT;\n\tcard->caps |= SC_CARD_CAP_USE_FCI_AC;\n\tiasecc_parse_ef_atr(card);\n\tif (gp_select_card_manager(card)) {\n\t\tgp_select_isd_rid(card);\n\t}\n\trv = iasecc_oberthur_match(card);\n\tLOG_TEST_RET(ctx, rv, \"unknown Oberthur's IAS/ECC card\");\n\trv = iasecc_select_mf(card, NULL);\n\tLOG_TEST_RET(ctx, rv, \"MF selection error\");\n\trv = iasecc_parse_ef_atr(card);\n\tLOG_TEST_RET(ctx, rv, \"EF.ATR read or parse error\");\n\tsc_log(ctx, \"EF.ATR(aid:'%s')\", sc_dump_hex(card->ef_atr->aid.value, card->ef_atr->aid.len));\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "void RenderView::OnDelete() {\n  if (!webview())\n    return;\n  webview()->focusedFrame()->executeCommand(WebString::fromUTF8(\"Delete\"));\n  UserMetricsRecordAction(\"DeleteSelection\");\n}", "target": 0}
{"code": "static int projid_m_show(struct seq_file *seq, void *v)\n{\n\tstruct user_namespace *ns = seq->private;\n\tstruct uid_gid_extent *extent = v;\n\tstruct user_namespace *lower_ns;\n\tprojid_t lower;\n\tlower_ns = seq_user_ns(seq);\n\tif ((lower_ns == ns) && lower_ns->parent)\n\t\tlower_ns = lower_ns->parent;\n\tlower = from_kprojid(lower_ns, KPROJIDT_INIT(extent->lower_first));\n\tseq_printf(seq, \"%10u %10u %10u\\n\",\n\t\textent->first,\n\t\tlower,\n\t\textent->count);\n\treturn 0;\n}", "target": 0}
{"code": "bool HHVM_FUNCTION(arsort,\n                   VRefParam array,\n                   int sort_flags ) {\n  bool use_zend_sort = RuntimeOption::EnableZendSorting;\n  return php_asort(array, sort_flags, false, use_zend_sort);\n}", "target": 0}
{"code": "void ThreadWatcher::OnCheckResponsiveness(uint64 ping_sequence_number) {\n  DCHECK(WatchDogThread::CurrentlyOnWatchDogThread());\n  if (!active_) {\n    responsive_ = true;\n    return;\n  }\n  if (ping_sequence_number_ != ping_sequence_number) {\n    ResetHangCounters();\n    responsive_ = true;\n    return;\n  }\n  GotNoResponse();\n  base::ThreadTaskRunnerHandle::Get()->PostDelayedTask(\n      FROM_HERE,\n      base::Bind(&ThreadWatcher::OnCheckResponsiveness,\n                 weak_ptr_factory_.GetWeakPtr(), ping_sequence_number_),\n      unresponsive_time_);\n  responsive_ = false;\n}", "target": 0}
{"code": "bool JOIN_TAB::preread_init()\n{\n  TABLE_LIST *derived= table->pos_in_table_list;\n  DBUG_ENTER(\"JOIN_TAB::preread_init\");\n  if (!derived || !derived->is_materialized_derived())\n  {\n    preread_init_done= TRUE;\n    DBUG_RETURN(FALSE);\n  }\n  if ((!derived->get_unit()->executed  ||\n       derived->is_recursive_with_table()) &&\n      mysql_handle_single_derived(join->thd->lex,\n                                    derived, DT_CREATE | DT_FILL))\n      DBUG_RETURN(TRUE);\n  preread_init_done= TRUE;\n  if (select && select->quick)\n    select->quick->replace_handler(table->file);\n  DBUG_EXECUTE_IF(\"show_explain_probe_join_tab_preread\", \n                  if (dbug_user_var_equals_int(join->thd, \n                                               \"show_explain_probe_select_id\", \n                                               join->select_lex->select_number))\n                        dbug_serve_apcs(join->thd, 1);\n                 );\n  if (table->fulltext_searched)\n    init_ftfuncs(join->thd, join->select_lex, MY_TEST(join->order));\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "static phys_addr_t intel_iommu_iova_to_phys(struct iommu_domain *domain,\n\t\t\t\t\t    dma_addr_t iova)\n{\n\tstruct dmar_domain *dmar_domain = to_dmar_domain(domain);\n\tstruct dma_pte *pte;\n\tint level = 0;\n\tu64 phys = 0;\n\tpte = pfn_to_dma_pte(dmar_domain, iova >> VTD_PAGE_SHIFT, &level);\n\tif (pte)\n\t\tphys = dma_pte_addr(pte);\n\treturn phys;\n}", "target": 0}
{"code": "static void __exit vmx_exit(void)\n{\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy_x2apic);\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode_x2apic);\n\tfree_page((unsigned long)vmx_msr_bitmap_legacy);\n\tfree_page((unsigned long)vmx_msr_bitmap_longmode);\n\tfree_page((unsigned long)vmx_io_bitmap_b);\n\tfree_page((unsigned long)vmx_io_bitmap_a);\n\tfree_page((unsigned long)vmx_vmwrite_bitmap);\n\tfree_page((unsigned long)vmx_vmread_bitmap);\n#ifdef CONFIG_KEXEC\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\tkvm_exit();\n}", "target": 0}
{"code": "init_dwarf_regnames_riscv (void)\n{\n  dwarf_regnames = NULL;\n  dwarf_regnames_count = 8192;\n  dwarf_regnames_lookup_func = regname_internal_riscv;\n}", "target": 0}
{"code": "static inline void verify_mm_writelocked(struct mm_struct *mm)\n{\n#ifdef CONFIG_DEBUG_VM\n\tif (unlikely(down_read_trylock(&mm->mmap_sem))) {\n\t\tWARN_ON(1);\n\t\tup_read(&mm->mmap_sem);\n\t}\n#endif\n}", "target": 0}
{"code": "bool PDFiumEngine::IsPageVisible(int index) const {\n  return base::ContainsValue(visible_pages_, index);\n}", "target": 0}
{"code": "int InstanceKlass::find_method_index(const Array<Method*>* methods,\n                                     const Symbol* name,\n                                     const Symbol* signature,\n                                     OverpassLookupMode overpass_mode,\n                                     StaticLookupMode static_mode,\n                                     PrivateLookupMode private_mode) {\n  const bool skipping_overpass = (overpass_mode == OverpassLookupMode::skip);\n  const bool skipping_static = (static_mode == StaticLookupMode::skip);\n  const bool skipping_private = (private_mode == PrivateLookupMode::skip);\n  const int hit = quick_search(methods, name);\n  if (hit != -1) {\n    const Method* const m = methods->at(hit);\n    if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {\n      return hit;\n    }\n    int i;\n    for (i = hit - 1; i >= 0; --i) {\n        const Method* const m = methods->at(i);\n        assert(m->is_method(), \"must be method\");\n        if (m->name() != name) {\n          break;\n        }\n        if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {\n          return i;\n        }\n    }\n    for (i = hit + 1; i < methods->length(); ++i) {\n        const Method* const m = methods->at(i);\n        assert(m->is_method(), \"must be method\");\n        if (m->name() != name) {\n          break;\n        }\n        if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {\n          return i;\n        }\n    }\n#ifdef ASSERT\n    const int index = (skipping_overpass || skipping_static || skipping_private) ? -1 :\n      linear_search(methods, name, signature);\n    assert(-1 == index, \"binary search should have found entry %d\", index);\n#endif\n  }\n  return -1;\n}", "target": 0}
{"code": "bool format_time(time_t time, char *dest, size_t max_size)\n{\n\ttm tm;\n\tlocaltime_r(&time, &tm);\n\treturn strftime(dest, max_size,\n\t\t \"%Y-%m-%d %H:%M:%S\", &tm) != 0;\n}", "target": 0}
{"code": "struct resv_map *resv_map_alloc(void)\n{\n\tstruct resv_map *resv_map = kmalloc(sizeof(*resv_map), GFP_KERNEL);\n\tstruct file_region *rg = kmalloc(sizeof(*rg), GFP_KERNEL);\n\tif (!resv_map || !rg) {\n\t\tkfree(resv_map);\n\t\tkfree(rg);\n\t\treturn NULL;\n\t}\n\tkref_init(&resv_map->refs);\n\tspin_lock_init(&resv_map->lock);\n\tINIT_LIST_HEAD(&resv_map->regions);\n\tresv_map->adds_in_progress = 0;\n\tresv_map_set_hugetlb_cgroup_uncharge_info(resv_map, NULL, NULL);\n\tINIT_LIST_HEAD(&resv_map->region_cache);\n\tlist_add(&rg->link, &resv_map->region_cache);\n\tresv_map->region_cache_count = 1;\n\treturn resv_map;\n}", "target": 0}
{"code": "static u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\n{\n\treturn i;\n}", "target": 0}
{"code": "isdn_ciscohdlck_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tunsigned long len = 0;\n\tunsigned long expires = 0;\n\tint tmp = 0;\n\tint period = lp->cisco_keepalive_period;\n\ts8 debserint = lp->cisco_debserint;\n\tint rc = 0;\n\tif (lp->p_encap != ISDN_NET_ENCAP_CISCOHDLCK)\n\t\treturn -EINVAL;\n\tswitch (cmd) {\n\tcase SIOCGKEEPPERIOD:\n\t\tlen = (unsigned long)sizeof(lp->cisco_keepalive_period);\n\t\tif (copy_to_user(ifr->ifr_data,\n\t\t\t\t &lp->cisco_keepalive_period, len))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\tcase SIOCSKEEPPERIOD:\n\t\ttmp = lp->cisco_keepalive_period;\n\t\tlen = (unsigned long)sizeof(lp->cisco_keepalive_period);\n\t\tif (copy_from_user(&period, ifr->ifr_data, len))\n\t\t\trc = -EFAULT;\n\t\tif ((period > 0) && (period <= 32767))\n\t\t\tlp->cisco_keepalive_period = period;\n\t\telse\n\t\t\trc = -EINVAL;\n\t\tif (!rc && (tmp != lp->cisco_keepalive_period)) {\n\t\t\texpires = (unsigned long)(jiffies +\n\t\t\t\t\t\t  lp->cisco_keepalive_period * HZ);\n\t\t\tmod_timer(&lp->cisco_timer, expires);\n\t\t\tprintk(KERN_INFO \"%s: Keepalive period set \"\n\t\t\t       \"to %d seconds.\\n\",\n\t\t\t       dev->name, lp->cisco_keepalive_period);\n\t\t}\n\t\tbreak;\n\tcase SIOCGDEBSERINT:\n\t\tlen = (unsigned long)sizeof(lp->cisco_debserint);\n\t\tif (copy_to_user(ifr->ifr_data,\n\t\t\t\t &lp->cisco_debserint, len))\n\t\t\trc = -EFAULT;\n\t\tbreak;\n\tcase SIOCSDEBSERINT:\n\t\tlen = (unsigned long)sizeof(lp->cisco_debserint);\n\t\tif (copy_from_user(&debserint,\n\t\t\t\t   ifr->ifr_data, len))\n\t\t\trc = -EFAULT;\n\t\tif ((debserint >= 0) && (debserint <= 64))\n\t\t\tlp->cisco_debserint = debserint;\n\t\telse\n\t\t\trc = -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\trc = -EINVAL;\n\t\tbreak;\n\t}\n\treturn (rc);\n}", "target": 0}
{"code": "static long vhost_set_memory(struct vhost_dev *d, struct vhost_memory __user *m)\n{\n\tstruct vhost_memory mem, *newmem, *oldmem;\n\tunsigned long size = offsetof(struct vhost_memory, regions);\n\tif (copy_from_user(&mem, m, size))\n\t\treturn -EFAULT;\n\tif (mem.padding)\n\t\treturn -EOPNOTSUPP;\n\tif (mem.nregions > VHOST_MEMORY_MAX_NREGIONS)\n\t\treturn -E2BIG;\n\tnewmem = kmalloc(size + mem.nregions * sizeof *m->regions, GFP_KERNEL);\n\tif (!newmem)\n\t\treturn -ENOMEM;\n\tmemcpy(newmem, &mem, size);\n\tif (copy_from_user(newmem->regions, m->regions,\n\t\t\t   mem.nregions * sizeof *m->regions)) {\n\t\tkfree(newmem);\n\t\treturn -EFAULT;\n\t}\n\tif (!memory_access_ok(d, newmem,\n\t\t\t      vhost_has_feature(d, VHOST_F_LOG_ALL))) {\n\t\tkfree(newmem);\n\t\treturn -EFAULT;\n\t}\n\toldmem = rcu_dereference_protected(d->memory,\n\t\t\t\t\t   lockdep_is_held(&d->mutex));\n\trcu_assign_pointer(d->memory, newmem);\n\tsynchronize_rcu();\n\tkfree(oldmem);\n\treturn 0;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::StartNewContentRenderingTimeout() {\n  if (received_paint_after_load_) {\n    received_paint_after_load_ = false;\n    return;\n  }\n  new_content_rendering_timeout_->Start(new_content_rendering_delay_);\n}", "target": 0}
{"code": "static int coolkey_check_sw(sc_card_t *card, unsigned int sw1, unsigned int sw2)\n{\n\tsc_log(card->ctx, \n\t\t\"sw1 = 0x%02x, sw2 = 0x%02x\\n\", sw1, sw2);\n\tif (sw1 == 0x90 && sw2 == 0x00)\n\t\treturn SC_SUCCESS;\n\tif (sw1 == 0x9c) {\n\t\tif (sw2 == 0xff) {\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tif (sw2 >= coolkey_number_of_error_codes) {\n\t\t\treturn SC_ERROR_UNKNOWN;\n\t\t}\n\t\treturn coolkey_error_codes[sw2].sc_error;\n\t}\n        return sc_get_iso7816_driver()->ops->check_sw(card, sw1, sw2);\n}", "target": 0}
{"code": "static void ppp_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &ppp_netdev_ops;\n\tdev->hard_header_len = PPP_HDRLEN;\n\tdev->mtu = PPP_MRU;\n\tdev->addr_len = 0;\n\tdev->tx_queue_len = 3;\n\tdev->type = ARPHRD_PPP;\n\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\tnetif_keep_dst(dev);\n}", "target": 0}
{"code": "static inline void crash_disable_local_vmclear(int cpu)\n{\n\tcpumask_clear_cpu(cpu, &crash_vmclear_enabled_bitmap);\n}", "target": 0}
{"code": "static size_t vnc_client_write_plain(VncState *vs)\n{\n    size_t offset;\n    size_t ret;\n#ifdef CONFIG_VNC_SASL\n    VNC_DEBUG(\"Write Plain: Pending output %p size %zd offset %zd. Wait SSF %d\\n\",\n              vs->output.buffer, vs->output.capacity, vs->output.offset,\n              vs->sasl.waitWriteSSF);\n    if (vs->sasl.conn &&\n        vs->sasl.runSSF &&\n        vs->sasl.waitWriteSSF) {\n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->sasl.waitWriteSSF);\n        if (ret)\n            vs->sasl.waitWriteSSF -= ret;\n    } else\n#endif \n        ret = vnc_client_write_buf(vs, vs->output.buffer, vs->output.offset);\n    if (!ret)\n        return 0;\n    if (ret >= vs->force_update_offset) {\n        if (vs->force_update_offset != 0) {\n            trace_vnc_client_unthrottle_forced(vs, vs->ioc);\n        }\n        vs->force_update_offset = 0;\n    } else {\n        vs->force_update_offset -= ret;\n    }\n    offset = vs->output.offset;\n    buffer_advance(&vs->output, ret);\n    if (offset >= vs->throttle_output_offset &&\n        vs->output.offset < vs->throttle_output_offset) {\n        trace_vnc_client_unthrottle_incremental(vs, vs->ioc, vs->output.offset);\n    }\n    if (vs->output.offset == 0) {\n        if (vs->ioc_tag) {\n            g_source_remove(vs->ioc_tag);\n        }\n        vs->ioc_tag = qio_channel_add_watch(\n            vs->ioc, G_IO_IN, vnc_client_io, vs, NULL);\n    }\n    return ret;\n}", "target": 0}
{"code": "static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *hdr;\n\tu16 crc;\n\tint ret;\n\tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = NCI_SPI_CRC_ENABLED;\n\thdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;\n\thdr[3] = 0;\n\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\tskb_put_u8(skb, crc >> 8);\n\tskb_put_u8(skb, crc & 0xFF);\n\tret = __nci_spi_send(nspi, skb, 0);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "static inline void ModulateHCL(const double percent_hue,\n  const double percent_chroma,const double percent_luma,double *red,\n  double *green,double *blue)\n{\n  double\n    hue,\n    luma,\n    chroma;\n  ConvertRGBToHCL(*red,*green,*blue,&hue,&chroma,&luma);\n  hue+=fmod((percent_hue-100.0),200.0)/200.0;\n  chroma*=0.01*percent_chroma;\n  luma*=0.01*percent_luma;\n  ConvertHCLToRGB(hue,chroma,luma,red,green,blue);\n}", "target": 0}
{"code": "  SegmentSumOpModel(const TensorData& data, const TensorData& segment_ids) {\n    data_id_ = AddInput(data);\n    segment_ids_id_ = AddInput(segment_ids);\n    output_id_ = AddOutput(data.type);\n    SetBuiltinOp(BuiltinOperator_SEGMENT_SUM, BuiltinOptions_NONE, 0);\n    BuildInterpreter({GetShape(data_id_), GetShape(segment_ids_id_)});\n  }", "target": 0}
{"code": "string Print(const NodeDef& n) {\n  string out;\n  strings::StrAppend(&out, n.name(), \" = \", n.op());\n  if (n.attr_size() > 0) {\n    std::vector<string> entries;\n    for (auto& a : n.attr()) {\n      entries.push_back(strings::StrCat(a.first, \"=\", Print(a.second)));\n    }\n    std::sort(entries.begin(), entries.end());\n    if (!n.device().empty()) {\n      DeviceNameUtils::ParsedName parsed;\n      if (DeviceNameUtils::ParseFullName(n.device(), &parsed)) {\n        entries.push_back(\n            strings::StrCat(\"device=\", parsed.type, \":\", parsed.id));\n      } else {\n        entries.push_back(\"device=<FAILED_TO_PARSE>\");\n      }\n    }\n    strings::StrAppend(&out, \"[\", absl::StrJoin(entries, \", \"), \"]\");\n  }\n  strings::StrAppend(&out, \"(\");\n  std::vector<StringPiece> dat;\n  std::vector<string> dep;\n  for (StringPiece s : n.input()) {\n    if (absl::ConsumePrefix(&s, \"^\")) {\n      dep.emplace_back(s);\n    } else {\n      dat.push_back(s);\n    }\n  }\n  strings::StrAppend(&out, absl::StrJoin(dat, \", \"), \")\");\n  if (!dep.empty()) {\n    strings::StrAppend(&out, \" @ \", absl::StrJoin(dep, \", \"));\n  }\n  return out;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::InitForFrame() {\n  DCHECK(process_->HasConnection());\n  renderer_initialized_ = true;\n}", "target": 0}
{"code": "static size_t consume_s7_r(RBuffer *b, ut64 bound, st8 *out) {\n\tsize_t n = 0;\n\tut32 tmp = consume_r (b, bound, &n, (ConsumeFcn)read_i32_leb128);\n\tif (out) {\n\t\t*out = (st8) (((tmp & 0x10000000) << 7) | (tmp & 0x7f));\n\t}\n\treturn n;\n}", "target": 0}
{"code": "bool Item_outer_ref::check_inner_refs_processor(uchar *arg)\n{\n  List_iterator_fast<Item_outer_ref> *it=\n    ((List_iterator_fast<Item_outer_ref> *) arg);\n  Item_outer_ref *ref;\n  while ((ref= (*it)++))\n  {\n    if (ref == this)\n    {\n      ref->found_in_group_by= 1;\n      break;\n    }\n  }\n  (*it).rewind();\n  return FALSE;\n}", "target": 0}
{"code": "  GLint ComputeImageDataSize(GLint width, GLint height) const {\n    GLint row_size = width * bytes_per_pixel_;\n    if (height > 1) {\n      GLint temp = row_size + pack_alignment_;\n      GLint padded_row_size = (temp / pack_alignment_) * pack_alignment_;\n      GLint size_of_all_but_last_row = (height - 1) * padded_row_size;\n      return size_of_all_but_last_row + row_size;\n    } else {\n      return height * row_size;\n    }\n  }", "target": 0}
{"code": "static inline void SetAssociatedAlpha(const Image *image,CubeInfo *cube_info)\n{\n  MagickBooleanType\n    associate_alpha;\n  associate_alpha=image->alpha_trait == BlendPixelTrait ? MagickTrue :\n    MagickFalse;\n  if ((cube_info->quantize_info->number_colors == 2) &&\n      ((cube_info->quantize_info->colorspace == LinearGRAYColorspace) ||\n       (cube_info->quantize_info->colorspace == GRAYColorspace)))\n    associate_alpha=MagickFalse;\n  cube_info->associate_alpha=associate_alpha;\n}", "target": 0}
{"code": "bool base64Decode(const UChar* data, unsigned length, Vector<char>& out, CharacterMatchFunctionPtr shouldIgnoreCharacter, Base64DecodePolicy policy)\n{\n    return base64DecodeInternal<UChar>(data, length, out, shouldIgnoreCharacter, policy);\n}", "target": 0}
{"code": "ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\tlockdep_unpin_lock(&rq->lock);\n\t\tp->sched_class->task_woken(rq, p);\n\t\tlockdep_pin_lock(&rq->lock);\n\t}\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\t\tupdate_avg(&rq->avg_idle, delta);\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}", "target": 0}
{"code": "parse_SET_L4_DST_PORT(char *arg, const struct ofpact_parse_params *pp)\n{\n    return str_to_u16(arg, \"destination port\",\n                      &ofpact_put_SET_L4_DST_PORT(pp->ofpacts)->port);\n}", "target": 0}
{"code": "static xmlEntityPtr getXHTMLEntity(const xmlChar* name)\n{\n    UChar c = decodeNamedEntity(reinterpret_cast<const char*>(name));\n    if (!c)\n        return 0;\n    CString value = String(&c, 1).utf8();\n    ASSERT(value.length() < 5);\n    xmlEntityPtr entity = sharedXHTMLEntity();\n    entity->length = value.length();\n    entity->name = name;\n    memcpy(sharedXHTMLEntityResult, value.data(), entity->length + 1);\n    return entity;\n}", "target": 0}
{"code": "static void nfs4_xdr_enc_readlink(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\t  const struct nfs4_readlink *args)\n{\n\tstruct compound_hdr hdr = {\n\t\t.minorversion = nfs4_xdr_minorversion(&args->seq_args),\n\t};\n\tencode_compound_hdr(xdr, req, &hdr);\n\tencode_sequence(xdr, &args->seq_args, &hdr);\n\tencode_putfh(xdr, args->fh, &hdr);\n\tencode_readlink(xdr, args, req, &hdr);\n\txdr_inline_pages(&req->rq_rcv_buf, hdr.replen << 2, args->pages,\n\t\t\targs->pgbase, args->pglen);\n\tencode_nops(&hdr);\n}", "target": 0}
{"code": "Suite *xml_load_suite(void)\n{\n\tSuite *suite;\n\tTCase *validate;\n\tvalidate = tcase_create(\"Validate\");\n\ttcase_add_test(validate, test_deltas_head_sort);\n\tsuite = suite_create(\"xml_test()\");\n\tsuite_add_tcase(suite, validate);\n\treturn suite;\n}", "target": 0}
{"code": "static void show_version(void)\n{\n    printf(\"NASM version %s compiled on %s%s\\n\",\n           nasm_version, nasm_date, nasm_compile_options);\n    exit(0);\n}", "target": 0}
{"code": "static int copy_verifier_state(struct bpf_verifier_state *dst_state,\n\t\t\t       const struct bpf_verifier_state *src)\n{\n\tstruct bpf_func_state *dst;\n\tint i, err;\n\tdst_state->jmp_history = copy_array(dst_state->jmp_history, src->jmp_history,\n\t\t\t\t\t    src->jmp_history_cnt, sizeof(struct bpf_idx_pair),\n\t\t\t\t\t    GFP_USER);\n\tif (!dst_state->jmp_history)\n\t\treturn -ENOMEM;\n\tdst_state->jmp_history_cnt = src->jmp_history_cnt;\n\tfor (i = src->curframe + 1; i <= dst_state->curframe; i++) {\n\t\tfree_func_state(dst_state->frame[i]);\n\t\tdst_state->frame[i] = NULL;\n\t}\n\tdst_state->speculative = src->speculative;\n\tdst_state->curframe = src->curframe;\n\tdst_state->active_spin_lock = src->active_spin_lock;\n\tdst_state->branches = src->branches;\n\tdst_state->parent = src->parent;\n\tdst_state->first_insn_idx = src->first_insn_idx;\n\tdst_state->last_insn_idx = src->last_insn_idx;\n\tfor (i = 0; i <= src->curframe; i++) {\n\t\tdst = dst_state->frame[i];\n\t\tif (!dst) {\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\t\t\tif (!dst)\n\t\t\t\treturn -ENOMEM;\n\t\t\tdst_state->frame[i] = dst;\n\t\t}\n\t\terr = copy_func_state(dst, src->frame[i]);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t new_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)\n{\n\tstruct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };\n\tstruct kiocb kiocb;\n\tstruct iov_iter iter;\n\tssize_t ret;\n\tinit_sync_kiocb(&kiocb, filp);\n\tkiocb.ki_pos = *ppos;\n\tiov_iter_init(&iter, WRITE, &iov, 1, len);\n\tret = filp->f_op->write_iter(&kiocb, &iter);\n\tBUG_ON(ret == -EIOCBQUEUED);\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}", "target": 0}
{"code": "rrinternal_get_quoted(sldns_buffer* strbuf, const char** delimiters,\n\tsldns_rdf_type rdftype)\n{\n\tif(sldns_rdf_type_maybe_quoted(rdftype) &&\n\t\tsldns_buffer_remaining(strbuf) > 0) {\n\t\twhile(sldns_buffer_remaining(strbuf) > 0 &&\n\t\t\t*(sldns_buffer_current(strbuf)) == ' ') {\n\t\t\tsldns_buffer_skip(strbuf, 1);\n\t\t}\n\t\tif(sldns_buffer_remaining(strbuf) > 0 &&\n\t\t\t*(sldns_buffer_current(strbuf)) == '\\\"') {\n\t\t\t*delimiters = \"\\\"\\0\";\n\t\t\tsldns_buffer_skip(strbuf, 1);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline int vmcs_field_readonly(unsigned long field)\n{\n\treturn (((field >> 10) & 0x3) == 1);\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleGetShaderSource(\n    uint32 immediate_data_size, const gles2::GetShaderSource& c) {\n  GLuint shader = c.shader;\n  uint32 bucket_id = static_cast<uint32>(c.bucket_id);\n  Bucket* bucket = CreateBucket(bucket_id);\n  ShaderManager::ShaderInfo* info = GetShaderInfoNotProgram(\n      shader, \"glGetShaderSource\");\n  if (!info) {\n    bucket->SetSize(0);\n    return error::kNoError;\n  }\n  bucket->SetFromString(info->source());\n  return error::kNoError;\n}", "target": 0}
{"code": "const char *Module::name() const { return \"\"; }", "target": 0}
{"code": "void GfxPatchMeshShading::getParameterizedColor(double t, GfxColor *color) const\n{\n    double out[gfxColorMaxComps] = {};\n    for (unsigned int j = 0; j < funcs.size(); ++j) {\n        funcs[j]->transform(&t, &out[j]);\n    }\n    for (int j = 0; j < gfxColorMaxComps; ++j) {\n        color->c[j] = dblToCol(out[j]);\n    }\n}", "target": 0}
{"code": "    uint32_t TiffSubIfd::doWriteData(IoWrapper& ioWrapper,\n                                     ByteOrder byteOrder,\n                                     int32_t   offset,\n                                     uint32_t  dataIdx,\n                                     uint32_t& imageIdx) const\n    {\n        uint32_t len = 0;\n        for (Ifds::const_iterator i = ifds_.begin(); i != ifds_.end(); ++i) {\n            len  += (*i)->write(ioWrapper, byteOrder, offset + dataIdx + len, uint32_t(-1), uint32_t(-1), imageIdx);\n        }\n        uint32_t align = (len & 1);\n        if (align) ioWrapper.putb(0x0);\n        return len + align;\n    } ", "target": 0}
{"code": "static int ok_inflater_decode_literal(ok_inflater *inflater, const uint16_t *tree_lookup_table,\n                                      unsigned int tree_bits) {\n    if (!ok_inflater_load_bits(inflater, tree_bits)) {\n        return -1;\n    }\n    uint32_t p = ok_inflater_peek_bits(inflater, tree_bits);\n    uint16_t value = tree_lookup_table[p];\n    ok_inflater_read_bits(inflater, value >> VALUE_BITS);\n    return value & VALUE_BIT_MASK;\n}", "target": 0}
{"code": "static int vcpu_mmio_read(struct kvm_vcpu *vcpu, gpa_t addr, int len, void *v)\n{\n\tif (vcpu->arch.apic &&\n\t    !kvm_iodevice_read(&vcpu->arch.apic->dev, addr, len, v))\n\t\treturn 0;\n\treturn kvm_io_bus_read(vcpu->kvm, KVM_MMIO_BUS, addr, len, v);\n}", "target": 0}
{"code": "    template<typename t, typename ti>\n    CImg<T>& _solve(const CImg<t>& A, const CImg<ti>& indx) {\n      typedef _cimg_Ttfloat Ttfloat;\n      const int N = (int)size();\n      int ii = -1;\n      Ttfloat sum;\n      for (int i = 0; i<N; ++i) {\n        const int ip = (int)indx[i];\n        Ttfloat sum = (*this)(ip);\n        (*this)(ip) = (*this)(i);\n        if (ii>=0) for (int j = ii; j<=i - 1; ++j) sum-=A(j,i)*(*this)(j);\n        else if (sum!=0) ii = i;\n        (*this)(i) = (T)sum;\n      }\n      for (int i = N - 1; i>=0; --i) {\n        sum = (*this)(i);\n        for (int j = i + 1; j<N; ++j) sum-=A(j,i)*(*this)(j);\n        (*this)(i) = (T)(sum/A(i,i));\n      }\n      return *this;", "target": 0}
{"code": "cin_isscopedecl(char_u *s)\n{\n    int\t\ti;\n    s = cin_skipcomment(s);\n    if (STRNCMP(s, \"public\", 6) == 0)\n\ti = 6;\n    else if (STRNCMP(s, \"protected\", 9) == 0)\n\ti = 9;\n    else if (STRNCMP(s, \"private\", 7) == 0)\n\ti = 7;\n    else\n\treturn FALSE;\n    return (*(s = cin_skipcomment(s + i)) == ':' && s[1] != ':');\n}", "target": 0}
{"code": "static void fts3EvalTokenCosts(\n  Fts3Cursor *pCsr,               \n  Fts3Expr *pRoot,                \n  Fts3Expr *pExpr,                \n  Fts3TokenAndCost **ppTC,        \n  Fts3Expr ***ppOr,               \n  int *pRc                        \n){\n  if( *pRc==SQLITE_OK ){\n    if( pExpr->eType==FTSQUERY_PHRASE ){\n      Fts3Phrase *pPhrase = pExpr->pPhrase;\n      int i;\n      for(i=0; *pRc==SQLITE_OK && i<pPhrase->nToken; i++){\n        Fts3TokenAndCost *pTC = (*ppTC)++;\n        pTC->pPhrase = pPhrase;\n        pTC->iToken = i;\n        pTC->pRoot = pRoot;\n        pTC->pToken = &pPhrase->aToken[i];\n        pTC->iCol = pPhrase->iColumn;\n        *pRc = sqlite3Fts3MsrOvfl(pCsr, pTC->pToken->pSegcsr, &pTC->nOvfl);\n      }\n    }else if( pExpr->eType!=FTSQUERY_NOT ){\n      assert( pExpr->eType==FTSQUERY_OR\n           || pExpr->eType==FTSQUERY_AND\n           || pExpr->eType==FTSQUERY_NEAR\n      );\n      assert( pExpr->pLeft && pExpr->pRight );\n      if( pExpr->eType==FTSQUERY_OR ){\n        pRoot = pExpr->pLeft;\n        **ppOr = pRoot;\n        (*ppOr)++;\n      }\n      fts3EvalTokenCosts(pCsr, pRoot, pExpr->pLeft, ppTC, ppOr, pRc);\n      if( pExpr->eType==FTSQUERY_OR ){\n        pRoot = pExpr->pRight;\n        **ppOr = pRoot;\n        (*ppOr)++;\n      }\n      fts3EvalTokenCosts(pCsr, pRoot, pExpr->pRight, ppTC, ppOr, pRc);\n    }\n  }\n}", "target": 0}
{"code": "static void spl_ptr_heap_zval_ctor(spl_ptr_heap_element elem TSRMLS_DC) { \n\tZ_ADDREF_P((zval *)elem);\n}", "target": 0}
{"code": "static int nf_tables_fill_table_info(struct sk_buff *skb, struct net *net,\n\t\t\t\t     u32 portid, u32 seq, int event, u32 flags,\n\t\t\t\t     int family, const struct nft_table *table)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct nfgenmsg *nfmsg;\n\tevent |= NFNL_SUBSYS_NFTABLES << 8;\n\tnlh = nlmsg_put(skb, portid, seq, event, sizeof(struct nfgenmsg), flags);\n\tif (nlh == NULL)\n\t\tgoto nla_put_failure;\n\tnfmsg = nlmsg_data(nlh);\n\tnfmsg->nfgen_family\t= family;\n\tnfmsg->version\t\t= NFNETLINK_V0;\n\tnfmsg->res_id\t\t= htons(net->nft.base_seq & 0xffff);\n\tif (nla_put_string(skb, NFTA_TABLE_NAME, table->name) ||\n\t    nla_put_be32(skb, NFTA_TABLE_FLAGS, htonl(table->flags)) ||\n\t    nla_put_be32(skb, NFTA_TABLE_USE, htonl(table->use)))\n\t\tgoto nla_put_failure;\n\treturn nlmsg_end(skb, nlh);\nnla_put_failure:\n\tnlmsg_trim(skb, nlh);\n\treturn -1;\n}", "target": 0}
{"code": "static int _sqlite_commit_txn(void *db, const sasl_utils_t *utils)\n{\n    return _sqlite_exec(db, \"COMMIT TRANSACTION\", NULL, 0, NULL, utils);\n}", "target": 0}
{"code": "_dbus_generate_random_bytes (DBusString *str,\n                             int         n_bytes)\n{\n  int old_len;\n  char *p;\n  HCRYPTPROV hprov;\n  old_len = _dbus_string_get_length (str);\n  if (!_dbus_string_lengthen (str, n_bytes))\n    return FALSE;\n  p = _dbus_string_get_data_len (str, old_len, n_bytes);\n  if (!CryptAcquireContext (&hprov, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n    return FALSE;\n  if (!CryptGenRandom (hprov, n_bytes, p))\n    {\n      CryptReleaseContext (hprov, 0);\n      return FALSE;\n    }\n  CryptReleaseContext (hprov, 0);\n  return TRUE;\n}", "target": 0}
{"code": "    bool isXmpType(BasicIo& iIo, bool advance)\n    {\n        const int32_t len = 80;\n        byte buf[len];\n        iIo.read(buf, xmlHdrCnt + 1);\n        if (   iIo.eof()\n            && 0 == strncmp(reinterpret_cast<const char*>(buf), xmlHeader, xmlHdrCnt)) {\n            return true;\n        }\n        if (iIo.error() || iIo.eof()) {\n            return false;\n        }\n        iIo.read(buf + xmlHdrCnt + 1, len - xmlHdrCnt - 1);\n        if (iIo.error() || iIo.eof()) {\n            return false;\n        }\n        int32_t start = 0;\n        if (0 == strncmp(reinterpret_cast<const char*>(buf), \"\\xef\\xbb\\xbf\", 3)) {\n            start = 3;\n        }\n        bool rc = false;\n        std::string head(reinterpret_cast<const char*>(buf + start), len - start);\n        if (head.substr(0, 5)  == \"<?xml\") {\n            for (unsigned i = 5; i < head.size(); ++i) {\n                if (head[i] == '<') {\n                    head = head.substr(i);\n                    break;\n                }\n            }\n        }\n        if (   head.size() > 9\n            && (   head.substr(0, 9)  == \"<?xpacket\"\n                || head.substr(0, 10) == \"<x:xmpmeta\")) {\n            rc = true;\n        }\n        if (!advance || !rc) {\n            iIo.seek(-(len - start), BasicIo::cur); \n        }\n        return rc;\n    }", "target": 0}
{"code": "long keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkenter(\"%d\", id);\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\t\tgoto error;\n\t}\ninvalidate:\n\tkey_invalidate(key_ref_to_ptr(key_ref));\n\tret = 0;\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "void uprobe_dup_mmap(struct mm_struct *oldmm, struct mm_struct *newmm)\n{\n\tif (test_bit(MMF_HAS_UPROBES, &oldmm->flags)) {\n\t\tset_bit(MMF_HAS_UPROBES, &newmm->flags);\n\t\tset_bit(MMF_RECALC_UPROBES, &newmm->flags);\n\t}\n}", "target": 0}
{"code": "static int lua_ap_set_keepalive(lua_State *L)\n{\n    int returnValue;\n    request_rec    *r;\n    luaL_checktype(L, 1, LUA_TUSERDATA);\n    r = ap_lua_check_request_rec(L, 1);\n    returnValue = ap_set_keepalive(r);\n    lua_pushboolean(L, returnValue);\n    return 1;\n}", "target": 0}
{"code": "GF_Err metx_box_size(GF_Box *s)\n{\n\tGF_MetaDataSampleEntryBox *ptr = (GF_MetaDataSampleEntryBox *)s;\n\tptr->size += 8;\n\tif (ptr->type!=GF_ISOM_BOX_TYPE_STPP) {\n\t\tif (ptr->content_encoding)\n\t\t\tptr->size += strlen(ptr->content_encoding);\n\t\tptr->size++;\n\t}\n\tif ((ptr->type==GF_ISOM_BOX_TYPE_METX) || (ptr->type==GF_ISOM_BOX_TYPE_STPP)) {\n\t\tif (ptr->xml_namespace)\n\t\t\tptr->size += strlen(ptr->xml_namespace);\n\t\tptr->size++;\n\t\tif (ptr->xml_schema_loc)\n\t\t\tptr->size += strlen(ptr->xml_schema_loc);\n\t\tptr->size++;\n\t\tif (ptr->type==GF_ISOM_BOX_TYPE_STPP) {\n\t\t\tif (ptr->mime_type)\n\t\t\t\tptr->size += strlen(ptr->mime_type);\n\t\t\tptr->size++;\n\t\t}\n\t}\n\telse {\n\t\tif (ptr->mime_type)\n\t\t\tptr->size += strlen(ptr->mime_type);\n\t\tptr->size++;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void _af_setup_free_loops (AFfilesetup setup, int instno)\n{\n\tif (setup->instruments[instno].loops)\n\t{\n\t\tfree(setup->instruments[instno].loops);\n\t}\n\tsetup->instruments[instno].loops = NULL;\n\tsetup->instruments[instno].loopCount = 0;\n}", "target": 0}
{"code": "extra_last_record(struct isoent *isoent)\n{\n\tif (isoent->extr_rec_list.first == NULL)\n\t\treturn (NULL);\n\treturn ((struct extr_rec *)(void *)\n\t\t((char *)(isoent->extr_rec_list.last)\n\t\t    - offsetof(struct extr_rec, next)));\n}", "target": 0}
{"code": "ModuleEntry* InstanceKlass::module() const {\n  if (is_hidden() &&\n      in_unnamed_package() &&\n      class_loader_data()->has_class_mirror_holder()) {\n    if (class_loader_data()->is_boot_class_loader_data()) {\n      return ClassLoaderData::the_null_class_loader_data()->unnamed_module();\n    } else {\n      oop module = java_lang_ClassLoader::unnamedModule(class_loader_data()->class_loader());\n      assert(java_lang_Module::is_instance(module), \"Not an instance of java.lang.Module\");\n      return java_lang_Module::module_entry(module);\n    }\n  }\n  if (!in_unnamed_package()) {\n    return _package_entry->module();\n  }\n  return class_loader_data()->unnamed_module();\n}", "target": 0}
{"code": "OPJ_BOOL opj_j2k_post_write_tile (      opj_j2k_t * p_j2k,\n                                                                opj_stream_private_t *p_stream,\n                                                                opj_event_mgr_t * p_manager )\n{\n        OPJ_UINT32 l_nb_bytes_written;\n        OPJ_BYTE * l_current_data = 00;\n        OPJ_UINT32 l_tile_size = 0;\n        OPJ_UINT32 l_available_data;\n        assert(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);\n        l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;\n        l_available_data = l_tile_size;\n        l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;\n        l_nb_bytes_written = 0;\n        if (! opj_j2k_write_first_tile_part(p_j2k,l_current_data,&l_nb_bytes_written,l_available_data,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n        l_current_data += l_nb_bytes_written;\n        l_available_data -= l_nb_bytes_written;\n        l_nb_bytes_written = 0;\n        if (! opj_j2k_write_all_tile_parts(p_j2k,l_current_data,&l_nb_bytes_written,l_available_data,p_stream,p_manager)) {\n                return OPJ_FALSE;\n        }\n        l_available_data -= l_nb_bytes_written;\n        l_nb_bytes_written = l_tile_size - l_available_data;\n        if ( opj_stream_write_data(     p_stream,\n                                                                p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,\n                                                                l_nb_bytes_written,p_manager) != l_nb_bytes_written) {\n                return OPJ_FALSE;\n        }\n        ++p_j2k->m_current_tile_number;\n        return OPJ_TRUE;\n}", "target": 0}
{"code": "rdp_out_general_caps(STREAM s)\n{\n\tout_uint16_le(s, RDP_CAPSET_GENERAL);\n\tout_uint16_le(s, RDP_CAPLEN_GENERAL);\n\tout_uint16_le(s, 1);\t\n\tout_uint16_le(s, 3);\t\n\tout_uint16_le(s, 0x200);\t\n\tout_uint16(s, 0);\t\n\tout_uint16(s, 0);\t\n\tout_uint16_le(s, (g_rdp_version >= RDP_V5) ? 0x40d : 0);\n\tout_uint16(s, 0);\t\n\tout_uint16(s, 0);\t\n\tout_uint16(s, 0);\t\n\tout_uint16(s, 0);\t\n}", "target": 0}
{"code": "node_new_enclosure_if_else(Node* cond, Node* Then, Node* Else)\n{\n  Node* n;\n  n = node_new_enclosure(ENCLOSURE_IF_ELSE);\n  CHECK_NULL_RETURN(n);\n  NODE_BODY(n) = cond;\n  ENCLOSURE_(n)->te.Then = Then;\n  ENCLOSURE_(n)->te.Else = Else;\n  return n;\n}", "target": 0}
{"code": "static void zynq_slcr_compute_clocks(ZynqSLCRState *s)\n{\n    uint64_t ps_clk = clock_get(s->ps_clk);\n    if (device_is_in_reset(DEVICE(s))) {\n        ps_clk = 0;\n    }\n    uint64_t io_pll = zynq_slcr_compute_pll(ps_clk, s->regs[R_IO_PLL_CTRL]);\n    uint64_t arm_pll = zynq_slcr_compute_pll(ps_clk, s->regs[R_ARM_PLL_CTRL]);\n    uint64_t ddr_pll = zynq_slcr_compute_pll(ps_clk, s->regs[R_DDR_PLL_CTRL]);\n    uint64_t uart_mux[4] = {io_pll, io_pll, arm_pll, ddr_pll};\n    clock_set(s->uart0_ref_clk,\n              ZYNQ_COMPUTE_CLK(s, uart_mux, R_UART_CLK_CTRL, CLKACT0));\n    clock_set(s->uart1_ref_clk,\n              ZYNQ_COMPUTE_CLK(s, uart_mux, R_UART_CLK_CTRL, CLKACT1));\n}", "target": 0}
{"code": "static inline bool RuleMatchCandidateTxArrayHasSpace(const DetectEngineThreadCtx *det_ctx,\n        const uint32_t need)\n{\n    if (det_ctx->tx_candidates_size >= need)\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "input_exit_osc(struct input_ctx *ictx)\n{\n\tu_char\t*p = ictx->input_buf;\n\tu_int\t option;\n\tif (ictx->flags & INPUT_DISCARD)\n\t\treturn;\n\tif (ictx->input_len < 1 || *p < '0' || *p > '9')\n\t\treturn;\n\tlog_debug(\"%s: \\\"%s\\\"\", __func__, p);\n\toption = 0;\n\twhile (*p >= '0' && *p <= '9')\n\t\toption = option * 10 + *p++ - '0';\n\tif (*p == ';')\n\t\tp++;\n\tswitch (option) {\n\tcase 0:\n\tcase 2:\n\t\tscreen_set_title(ictx->ctx.s, p);\n\t\tserver_status_window(ictx->wp->window);\n\t\tbreak;\n\tcase 12:\n\t\tif (*p != '?') \n\t\t\tscreen_set_cursor_colour(ictx->ctx.s, p);\n\t\tbreak;\n\tcase 112:\n\t\tif (*p == '\\0') \n\t\t\tscreen_set_cursor_colour(ictx->ctx.s, \"\");\n\t\tbreak;\n\tdefault:\n\t\tlog_debug(\"%s: unknown '%u'\", __func__, option);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "int RGWPutObjRetention_ObjStore_S3::get_params()\n{\n  const char *bypass_gov_header = s->info.env->get(\"HTTP_X_AMZ_BYPASS_GOVERNANCE_RETENTION\");\n  if (bypass_gov_header) {\n    std::string bypass_gov_decoded = url_decode(bypass_gov_header);\n    bypass_governance_mode = boost::algorithm::iequals(bypass_gov_decoded, \"true\");\n  }\n  const auto max_size = s->cct->_conf->rgw_max_put_param_size;\n  std::tie(op_ret, data) = rgw_rest_read_all_input(s, max_size, false);\n  return op_ret;\n}", "target": 0}
{"code": "static int pfkey_spdflush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct km_event c;\n\tint err, err2;\n\terr = xfrm_policy_flush(net, XFRM_POLICY_TYPE_MAIN, true);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) \n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tc.data.type = XFRM_POLICY_TYPE_MAIN;\n\tc.event = XFRM_MSG_FLUSHPOLICY;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.net = net;\n\tkm_policy_notify(NULL, 0, &c);\n\treturn 0;\n}", "target": 0}
{"code": "bool Item_param::convert_str_value(THD *thd)\n{\n  bool rc= FALSE;\n  if (state == STRING_VALUE || state == LONG_DATA_VALUE)\n  {\n    if (value.cs_info.final_character_set_of_str_value !=\n        value.cs_info.character_set_of_placeholder)\n    {\n      rc= thd->convert_string(&str_value,\n                              value.cs_info.character_set_of_placeholder,\n                              value.cs_info.final_character_set_of_str_value);\n    }\n    else\n      str_value.set_charset(value.cs_info.final_character_set_of_str_value);\n    max_length= str_value.numchars() * str_value.charset()->mbmaxlen;\n    decimals= NOT_FIXED_DEC;\n    str_value_ptr.set(str_value.ptr(), str_value.length(),\n                      str_value.charset());\n    collation.set(str_value.charset(), DERIVATION_COERCIBLE);\n  }\n  return rc;\n}", "target": 0}
{"code": "static inline char * _php_pgsql_trim_result(PGconn * pgsql, char **buf)\n{\n\treturn *buf = _php_pgsql_trim_message(PQerrorMessage(pgsql), NULL);\n}", "target": 0}
{"code": "double vnc_update_freq(VncState *vs, int x, int y, int w, int h)\n{\n    int i, j;\n    double total = 0;\n    int num = 0;\n    x =  QEMU_ALIGN_DOWN(x, VNC_STAT_RECT);\n    y =  QEMU_ALIGN_DOWN(y, VNC_STAT_RECT);\n    for (j = y; j <= y + h; j += VNC_STAT_RECT) {\n        for (i = x; i <= x + w; i += VNC_STAT_RECT) {\n            total += vnc_stat_rect(vs->vd, i, j)->freq;\n            num++;\n        }\n    }\n    if (num) {\n        return total / num;\n    } else {\n        return 0;\n    }\n}", "target": 0}
{"code": "void GfxICCBasedColorSpace::getDefaultRanges(double *decodeLow, double *decodeRange, int maxImgPixel) const\n{\n    alt->getDefaultRanges(decodeLow, decodeRange, maxImgPixel);\n#if 0\n  int i;\n  for (i = 0; i < nComps; ++i) {\n    decodeLow[i] = rangeMin[i];\n    decodeRange[i] = rangeMax[i] - rangeMin[i];\n  }\n#endif\n}", "target": 0}
{"code": "rb_reg_new_ary(VALUE ary, int opt)\n{\n    return rb_reg_new_str(rb_reg_preprocess_dregexp(ary, opt), opt);\n}", "target": 0}
{"code": "void CSoundFile::SetAGC(BOOL b)\n{\n\tif (b)\n\t{\n\t\tif (!(gdwSoundSetup & SNDMIX_AGC))\n\t\t{\n\t\t\tgdwSoundSetup |= SNDMIX_AGC;\n\t\t\tgnAGC = AGC_UNITY;\n\t\t}\n\t} else gdwSoundSetup &= ~SNDMIX_AGC;\n}", "target": 0}
{"code": "  QuotaCallback* NewWaitableGlobalQuotaCallback() {\n    ++waiting_callbacks_;\n    return callback_factory_.NewCallback(\n            &UsageAndQuotaDispatcherTask::DidGetGlobalQuota);\n  }", "target": 0}
{"code": "SiteInstance* WebContentsImpl::GetPendingSiteInstance() const {\n  RenderViewHost* dest_rvh = render_manager_.pending_render_view_host() ?\n      render_manager_.pending_render_view_host() :\n      render_manager_.current_host();\n  return dest_rvh->GetSiteInstance();\n}", "target": 0}
{"code": "void free_http_req_rules(struct list *r) {\n\tstruct http_req_rule *tr, *pr;\n\tlist_for_each_entry_safe(pr, tr, r, list) {\n\t\tLIST_DEL(&pr->list);\n\t\tif (pr->action == HTTP_REQ_ACT_AUTH)\n\t\t\tfree(pr->arg.auth.realm);\n\t\tfree(pr);\n\t}\n}", "target": 0}
{"code": "static int lua_loadstring(lua_State *ls)\n{\n    const auto lua = luaL_checkstring(ls, 1);\n    if (lua[0] == 0x1b)\n        abort();\n    lua_settop(ls, 0);\n    if (luaL_loadstring(ls, lua))\n    {\n        lua_pushnil(ls);\n        lua_insert(ls, 1);\n    }\n    return lua_gettop(ls);\n}", "target": 0}
{"code": "bool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_register_read(vcpu, VCPU_REGS_RCX);\n\tu64 data;\n\tint err;\n\terr = kvm_pmu_read_pmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_register_write(vcpu, VCPU_REGS_RAX, (u32)data);\n\tkvm_register_write(vcpu, VCPU_REGS_RDX, data >> 32);\n\treturn err;\n}", "target": 0}
{"code": "int PDFiumEngine::GetDuplexType() {\n  return static_cast<int>(FPDF_VIEWERREF_GetDuplex(doc_));\n}", "target": 0}
{"code": "int jpc_pi_addpchg(jpc_pi_t *pi, jpc_pocpchg_t *pchg)\n{\n\treturn jpc_pchglist_insert(pi->pchglist, -1, pchg);\n}", "target": 0}
{"code": "static int ml_get_combo_effect(struct ml_device *ml,\n\t\t\t       unsigned long *effect_handled,\n\t\t\t       struct ff_effect *combo_effect)\n{\n\tstruct ff_effect *effect;\n\tstruct ml_effect_state *state;\n\tint effect_type;\n\tint i;\n\tmemset(combo_effect, 0, sizeof(struct ff_effect));\n\tfor (i = 0; i < FF_MEMLESS_EFFECTS; i++) {\n\t\tif (__test_and_set_bit(i, effect_handled))\n\t\t\tcontinue;\n\t\tstate = &ml->states[i];\n\t\teffect = state->effect;\n\t\tif (!test_bit(FF_EFFECT_STARTED, &state->flags))\n\t\t\tcontinue;\n\t\tif (time_before(jiffies, state->play_at))\n\t\t\tcontinue;\n\t\teffect_type = get_compatible_type(ml->dev->ff, effect->type);\n\t\tif (combo_effect->type != effect_type) {\n\t\t\tif (combo_effect->type != 0) {\n\t\t\t\t__clear_bit(i, effect_handled);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcombo_effect->type = effect_type;\n\t\t}\n\t\tif (__test_and_clear_bit(FF_EFFECT_ABORTING, &state->flags)) {\n\t\t\t__clear_bit(FF_EFFECT_PLAYING, &state->flags);\n\t\t\t__clear_bit(FF_EFFECT_STARTED, &state->flags);\n\t\t} else if (effect->replay.length &&\n\t\t\t   time_after_eq(jiffies, state->stop_at)) {\n\t\t\t__clear_bit(FF_EFFECT_PLAYING, &state->flags);\n\t\t\tif (--state->count <= 0) {\n\t\t\t\t__clear_bit(FF_EFFECT_STARTED, &state->flags);\n\t\t\t} else {\n\t\t\t\tstate->play_at = jiffies +\n\t\t\t\t\tmsecs_to_jiffies(effect->replay.delay);\n\t\t\t\tstate->stop_at = state->play_at +\n\t\t\t\t\tmsecs_to_jiffies(effect->replay.length);\n\t\t\t}\n\t\t} else {\n\t\t\t__set_bit(FF_EFFECT_PLAYING, &state->flags);\n\t\t\tstate->adj_at = jiffies;\n\t\t\tml_combine_effects(combo_effect, state, ml->gain);\n\t\t}\n\t}\n\treturn combo_effect->type != 0;\n}", "target": 0}
{"code": "static int smaps_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\t   void *private)\n{\n\tstruct mem_size_stats *mss = private;\n\tstruct vm_area_struct *vma = mss->vma;\n\tpte_t *pte, ptent;\n\tspinlock_t *ptl;\n\tstruct page *page;\n\tint mapcount;\n\tpte = pte_offset_map_lock(vma->vm_mm, pmd, addr, &ptl);\n\tfor (; addr != end; pte++, addr += PAGE_SIZE) {\n\t\tptent = *pte;\n\t\tif (!pte_present(ptent))\n\t\t\tcontinue;\n\t\tmss->resident += PAGE_SIZE;\n\t\tpage = vm_normal_page(vma, addr, ptent);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tif (pte_young(ptent) || PageReferenced(page))\n\t\t\tmss->referenced += PAGE_SIZE;\n\t\tmapcount = page_mapcount(page);\n\t\tif (mapcount >= 2) {\n\t\t\tif (pte_dirty(ptent))\n\t\t\t\tmss->shared_dirty += PAGE_SIZE;\n\t\t\telse\n\t\t\t\tmss->shared_clean += PAGE_SIZE;\n\t\t\tmss->pss += (PAGE_SIZE << PSS_SHIFT) / mapcount;\n\t\t} else {\n\t\t\tif (pte_dirty(ptent))\n\t\t\t\tmss->private_dirty += PAGE_SIZE;\n\t\t\telse\n\t\t\t\tmss->private_clean += PAGE_SIZE;\n\t\t\tmss->pss += (PAGE_SIZE << PSS_SHIFT);\n\t\t}\n\t}\n\tpte_unmap_unlock(pte - 1, ptl);\n\tcond_resched();\n\treturn 0;\n}", "target": 0}
{"code": "void CSoundFile::FrequencyToTranspose(MODINSTRUMENT *psmp)\n{\n\tint f2t = FrequencyToTranspose(psmp->nC4Speed);\n\tint transp = f2t >> 7;\n\tint ftune = f2t & 0x7F;\n\tif (ftune > 80)\n\t{\n\t\ttransp++;\n\t\tftune -= 128;\n\t}\n\tif (transp > 127) transp = 127;\n\tif (transp < -127) transp = -127;\n\tpsmp->RelativeTone = transp;\n\tpsmp->nFineTune = ftune;\n}", "target": 0}
{"code": "static void vmx_sync_pir_to_irr_dummy(struct kvm_vcpu *vcpu)\n{\n\treturn;\n}", "target": 0}
{"code": "g2cmyk(fz_context *ctx, fz_color_converter *cc, float *dv, const float *sv)\n{\n\tdv[0] = 0;\n\tdv[1] = 0;\n\tdv[2] = 0;\n\tdv[3] = 1 - sv[0];\n}", "target": 0}
{"code": "AP_DECLARE(void) ap_random_insecure_bytes(void *buf, apr_size_t size)\n{\n#if APR_HAS_THREADS\n    if (rng_mutex)\n        apr_thread_mutex_lock(rng_mutex);\n#endif\n    apr_random_insecure_bytes(rng, buf, size);\n#if APR_HAS_THREADS\n    if (rng_mutex)\n        apr_thread_mutex_unlock(rng_mutex);\n#endif\n}", "target": 0}
{"code": "  JSObject::SpillInformation* js_spill_information() {\n    return &js_spill_information_;\n  }", "target": 0}
{"code": "static inline struct epitem *ep_item_from_wait(wait_queue_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait)->base;\n}", "target": 0}
{"code": "static MemTxResult watch_mem_write(void *opaque, hwaddr addr,\n                                   uint64_t val, unsigned size,\n                                   MemTxAttrs attrs)\n{\n    MemTxResult res;\n    check_watchpoint(addr & ~TARGET_PAGE_MASK, size, attrs, BP_MEM_WRITE);\n    switch (size) {\n    case 1:\n        address_space_stb(&address_space_memory, addr, val, attrs, &res);\n        break;\n    case 2:\n        address_space_stw(&address_space_memory, addr, val, attrs, &res);\n        break;\n    case 4:\n        address_space_stl(&address_space_memory, addr, val, attrs, &res);\n        break;\n    default: abort();\n    }\n    return res;\n}", "target": 0}
{"code": "Opal::Call::OnOpenMediaStream (OpalMediaStream & stream)\n{\n  StreamType type = (stream.GetMediaFormat().GetMediaType() == OpalMediaType::Audio ()) ? Audio : Video;\n  bool is_transmitting = false;\n  std::string stream_name;\n  stream_name = std::string ((const char *) stream.GetMediaFormat ().GetEncodingName ());\n  std::transform (stream_name.begin (), stream_name.end (), stream_name.begin (), (int (*) (int)) toupper);\n  is_transmitting = !stream.IsSource ();\n  Ekiga::Runtime::run_in_main (boost::bind (boost::ref (stream_opened), stream_name, type, is_transmitting));\n}", "target": 0}
{"code": "Value ExpressionBinarySize::evaluate(const Document& root, Variables* variables) const {\n    Value arg = _children[0]->evaluate(root, variables);\n    if (arg.nullish()) {\n        return Value(BSONNULL);\n    }\n    uassert(51276,\n            str::stream() << \"$binarySize requires a string or BinData argument, found: \"\n                          << typeName(arg.getType()),\n            arg.getType() == BSONType::BinData || arg.getType() == BSONType::String);\n    if (arg.getType() == BSONType::String) {\n        return strLenBytes(arg.getStringData());\n    }\n    BSONBinData binData = arg.getBinData();\n    return Value(binData.length);\n}", "target": 0}
{"code": "RenderViewHostDelegate::View* InterstitialPage::GetViewDelegate() {\n  return rvh_view_delegate_.get();\n}", "target": 0}
{"code": "static void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}", "target": 0}
{"code": "static ssize_t bad_inode_getxattr(struct dentry *dentry, const char *name,\n\t\t\tvoid *buffer, size_t size)\n{\n\treturn -EIO;\n}", "target": 0}
{"code": "static int xennet_change_mtu(struct net_device *dev, int mtu)\n{\n\tint max = xennet_can_sg(dev) ? XEN_NETIF_MAX_TX_SIZE : ETH_DATA_LEN;\n\tif (mtu > max)\n\t\treturn -EINVAL;\n\tdev->mtu = mtu;\n\treturn 0;\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_get_audio_layout(GF_ISOFile *movie, u32 trackNumber, u32 StreamDescriptionIndex, GF_AudioChannelLayout *layout)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_SampleDescriptionBox *stsd;\n\tGF_ChannelLayoutBox *chnl;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !layout) return GF_BAD_PARAM;\n\tmemset(layout, 0, sizeof(GF_AudioChannelLayout));\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd) return movie->LastError = GF_ISOM_INVALID_FILE;\n\tif (!StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) return movie->LastError = GF_BAD_PARAM;\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (entry == NULL) return GF_BAD_PARAM;\n\tif (entry->internal_type != GF_ISOM_SAMPLE_ENTRY_AUDIO) return GF_BAD_PARAM;\n\tchnl = (GF_ChannelLayoutBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_CHNL);\n\tif (!chnl) return GF_NOT_FOUND;\n\tmemcpy(layout, &chnl->layout, sizeof(GF_AudioChannelLayout));\n\treturn GF_OK;", "target": 0}
{"code": "bool NetworkActionPredictor::TryDeleteOldEntries(HistoryService* service) {\n  if (!service)\n    return false;\n  history::URLDatabase* url_db = service->InMemoryDatabase();\n  if (!url_db)\n    return false;\n  DeleteOldEntries(url_db);\n  return true;\n}", "target": 0}
{"code": "void blk_free_flush_queue(struct blk_flush_queue *fq)\n{\n\tif (!fq)\n\t\treturn;\n\tkfree(fq->flush_rq);\n\tkfree(fq);\n}", "target": 0}
{"code": "free_link_refs(struct link_ref **references)\n{\n\tsize_t i;\n\tfor (i = 0; i < REF_TABLE_SIZE; ++i) {\n\t\tstruct link_ref *r = references[i];\n\t\tstruct link_ref *next;\n\t\twhile (r) {\n\t\t\tnext = r->next;\n\t\t\tbufrelease(r->label);\n\t\t\tbufrelease(r->link);\n\t\t\tbufrelease(r->title);\n\t\t\tfree(r);\n\t\t\tr = next;\n\t\t}\n\t}\n}", "target": 0}
{"code": "isofile_new(struct archive_write *a, struct archive_entry *entry)\n{\n\tstruct isofile *file;\n\tfile = calloc(1, sizeof(*file));\n\tif (file == NULL)\n\t\treturn (NULL);\n\tif (entry != NULL)\n\t\tfile->entry = archive_entry_clone(entry);\n\telse\n\t\tfile->entry = archive_entry_new2(&a->archive);\n\tif (file->entry == NULL) {\n\t\tfree(file);\n\t\treturn (NULL);\n\t}\n\tarchive_string_init(&(file->parentdir));\n\tarchive_string_init(&(file->basename));\n\tarchive_string_init(&(file->basename_utf16));\n\tarchive_string_init(&(file->symlink));\n\tfile->cur_content = &(file->content);\n\treturn (file);\n}", "target": 0}
{"code": "generate_string(cms_context *cms, SECItem *der, char *str)\n{\n\tSECItem input;\n\tinput.data = (void *)str;\n\tinput.len = strlen(str);\n\tinput.type = siBMPString;\n\tvoid *ret;\n\tret = SEC_ASN1EncodeItem(cms->arena, der, &input,\n\t\t\t\t\t\tSEC_PrintableStringTemplate);\n\tif (ret == NULL)\n\t\tcmsreterr(-1, cms, \"could not encode string\");\n\treturn 0;\n}", "target": 0}
{"code": "gx_default_include_color_space(gx_device *pdev, gs_color_space *cspace,\n        const byte *res_name, int name_length)\n{\n    return 0;\n}", "target": 0}
{"code": "smb2_set_credits(struct TCP_Server_Info *server, const int val)\n{\n\tint scredits, in_flight;\n\tspin_lock(&server->req_lock);\n\tserver->credits = val;\n\tif (val == 1)\n\t\tserver->reconnect_instance++;\n\tscredits = server->credits;\n\tin_flight = server->in_flight;\n\tspin_unlock(&server->req_lock);\n\ttrace_smb3_set_credits(server->CurrentMid,\n\t\t\tserver->conn_id, server->hostname, scredits, val, in_flight);\n\tcifs_dbg(FYI, \"%s: set %u credits\\n\", __func__, val);\n\tif (val == 1)\n\t\tcifs_dbg(FYI, \"set credits to 1 due to smb2 reconnect\\n\");\n}", "target": 0}
{"code": "WebMediaPlayer::TrackId HTMLMediaElement::GetSelectedVideoTrackId() {\n  DCHECK(HasSelectedVideoTrack());\n  int selected_track_index = video_tracks_->selectedIndex();\n  VideoTrack* track =\n      video_tracks_->AnonymousIndexedGetter(selected_track_index);\n  return track->id();\n}", "target": 0}
{"code": "xmlCtxtReadIO(xmlParserCtxtPtr ctxt, xmlInputReadCallback ioread,\n              xmlInputCloseCallback ioclose, void *ioctx,\n\t      const char *URL,\n              const char *encoding, int options)\n{\n    xmlParserInputBufferPtr input;\n    xmlParserInputPtr stream;\n    if (ioread == NULL)\n        return (NULL);\n    if (ctxt == NULL)\n        return (NULL);\n    xmlCtxtReset(ctxt);\n    input = xmlParserInputBufferCreateIO(ioread, ioclose, ioctx,\n                                         XML_CHAR_ENCODING_NONE);\n    if (input == NULL)\n        return (NULL);\n    stream = xmlNewIOInputStream(ctxt, input, XML_CHAR_ENCODING_NONE);\n    if (stream == NULL) {\n        xmlFreeParserInputBuffer(input);\n        return (NULL);\n    }\n    inputPush(ctxt, stream);\n    return (xmlDoRead(ctxt, URL, encoding, options, 1));\n}", "target": 0}
{"code": "static int copy_reference_state(struct bpf_func_state *dst, const struct bpf_func_state *src)\n{\n\tdst->refs = copy_array(dst->refs, src->refs, src->acquired_refs,\n\t\t\t       sizeof(struct bpf_reference_state), GFP_KERNEL);\n\tif (!dst->refs)\n\t\treturn -ENOMEM;\n\tdst->acquired_refs = src->acquired_refs;\n\treturn 0;\n}", "target": 0}
{"code": "  RTCVideoDecoderTest() {\n    decoder_ = new RTCVideoDecoder(&message_loop_, kUrl);\n    renderer_ = new MockVideoRenderer();\n    read_cb_ = base::Bind(&RTCVideoDecoderTest::FrameReady,\n                          base::Unretained(this));\n    DCHECK(decoder_);\n    EXPECT_CALL(statistics_cb_, OnStatistics(_))\n        .Times(AnyNumber());\n  }", "target": 0}
{"code": "void JOIN::clear()\n{\n  clear_tables(this, 0);\n  copy_fields(&tmp_table_param);\n  if (sum_funcs)\n  {\n    Item_sum *func, **func_ptr= sum_funcs;\n    while ((func= *(func_ptr++)))\n      func->clear();\n  }\n}", "target": 0}
{"code": "AudioFlinger::EffectHandle::EffectHandle(const sp<EffectModule>& effect,\n const sp<AudioFlinger::Client>& client,\n const sp<IEffectClient>& effectClient,\n int32_t priority)\n : BnEffect(),\n    mEffect(effect), mEffectClient(effectClient), mClient(client), mCblk(NULL),\n    mPriority(priority), mHasControl(false), mEnabled(false), mDestroyed(false)\n{\n    ALOGV(\"constructor %p\", this);\n if (client == 0) {\n return;\n }\n int bufOffset = ((sizeof(effect_param_cblk_t) - 1) / sizeof(int) + 1) * sizeof(int);\n    mCblkMemory = client->heap()->allocate(EFFECT_PARAM_BUFFER_SIZE + bufOffset);\n if (mCblkMemory == 0 ||\n (mCblk = static_cast<effect_param_cblk_t *>(mCblkMemory->pointer())) == NULL) {\n        ALOGE(\"not enough memory for Effect size=%u\", EFFECT_PARAM_BUFFER_SIZE +\n sizeof(effect_param_cblk_t));\n        mCblkMemory.clear();\n return;\n }\n new(mCblk) effect_param_cblk_t();\n    mBuffer = (uint8_t *)mCblk + bufOffset;\n}", "target": 0}
{"code": "void PDFiumEngine::Form_DisplayCaret(FPDF_FORMFILLINFO* param,\n                                     FPDF_PAGE page,\n                                     FPDF_BOOL visible,\n                                     double left,\n                                     double top,\n                                     double right,\n                                     double bottom) {\n  PDFiumEngine* engine = static_cast<PDFiumEngine*>(param);\n  engine->client_->UpdateCursor(PP_CURSORTYPE_IBEAM);\n  std::vector<pp::Rect> tickmarks;\n  pp::Rect rect(left, top, right, bottom);\n  tickmarks.push_back(rect);\n  engine->client_->UpdateTickMarks(tickmarks);\n}", "target": 0}
{"code": "void CSoundFile::FreePattern(LPVOID pat)\n{\n\tif (pat) delete [] (signed char*)pat;\n}", "target": 0}
{"code": "static void __exit af_unix_exit(void)\n{\n\tsock_unregister(PF_UNIX);\n\tproto_unregister(&unix_proto);\n\tunregister_pernet_subsys(&unix_net_ops);\n}", "target": 0}
{"code": "inline void ImageLoader::enqueueImageLoadingMicroTask(\n    UpdateFromElementBehavior updateBehavior,\n    ReferrerPolicy referrerPolicy) {\n  std::unique_ptr<Task> task =\n      Task::create(this, updateBehavior, referrerPolicy);\n  m_pendingTask = task->createWeakPtr();\n  Microtask::enqueueMicrotask(\n      WTF::bind(&Task::run, WTF::passed(std::move(task))));\n  m_loadDelayCounter =\n      IncrementLoadEventDelayCount::create(m_element->document());\n}", "target": 0}
{"code": "Variant HHVM_FUNCTION(imageaffinematrixconcat,\n                      const Array& m1,\n                      const Array& m2) {\n  int nelem1 = m1.size();\n  int nelem2 = m2.size();\n  int i;\n  double dm1[6];\n  double dm2[6];\n  double dmr[6];\n  Array ret = Array::Create();\n  if (nelem1 != 6 || nelem2 != 6) {\n    raise_warning(\"imageaffinematrixconcat(): Affine array must \"\n                  \"have six elements\");\n    return false;\n  }\n  for (i = 0; i < 6; i++) {\n    if (m1[i].isInteger()) {\n      dm1[i] = m1[i].toInt64();\n    } else if (m1[i].isDouble() || m1[i].isString()) {\n      dm1[i] = m1[i].toDouble();\n    } else {\n      raise_warning(\"imageaffinematrixconcat(): Invalid type for \"\n                    \"element %i\", i);\n      return false;\n    }\n    if (m2[i].isInteger()) {\n      dm2[i] = m2[i].toInt64();\n    } else if (m2[i].isDouble() || m2[i].isString()) {\n      dm2[i] = m2[i].toDouble();\n    } else {\n      raise_warning(\"imageaffinematrixconcat():Invalid type for\"\n                    \"element %i\", i);\n      return false;\n    }\n  }\n  if (gdAffineConcat(dmr, dm1, dm2) != GD_TRUE) {\n    return false;\n  }\n  for (i = 0; i < 6; i++) {\n    ret.set(String(i, CopyString), dmr[i]);\n  }\n  return ret;\n}", "target": 0}
{"code": "TABLE *open_n_lock_single_table(THD *thd, TABLE_LIST *table_l,\n                                thr_lock_type lock_type, uint flags,\n                                Prelocking_strategy *prelocking_strategy)\n{\n  TABLE_LIST *save_next_global;\n  DBUG_ENTER(\"open_n_lock_single_table\");\n  save_next_global= table_l->next_global;\n  table_l->next_global= NULL;\n  table_l->lock_type= lock_type;\n  table_l->required_type= FRMTYPE_TABLE;\n  if (open_and_lock_tables(thd, table_l, FALSE, flags,\n                           prelocking_strategy))\n    table_l->table= NULL; \n  table_l->next_global= save_next_global;\n  DBUG_RETURN(table_l->table);\n}", "target": 0}
{"code": "zend_object_iterator *spl_heap_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC) \n{\n\tspl_heap_it     *iterator;\n\tspl_heap_object *heap_object = (spl_heap_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tif (by_ref) {\n\t\tzend_throw_exception(spl_ce_RuntimeException, \"An iterator cannot be used with foreach by reference\", 0 TSRMLS_CC);\n\t\treturn NULL;\n\t}\n\tZ_ADDREF_P(object);\n\titerator                  = emalloc(sizeof(spl_heap_it));\n\titerator->intern.it.data  = (void*)object;\n\titerator->intern.it.funcs = &spl_heap_it_funcs;\n\titerator->intern.ce       = ce;\n\titerator->intern.value    = NULL;\n\titerator->flags           = heap_object->flags;\n\titerator->object          = heap_object;\n\treturn (zend_object_iterator*)iterator;\n}", "target": 0}
{"code": "static int _mapref_priority_cmp(RIOBank *bank, RIOMapRef *mr0, RIOMapRef *mr1) {\n\tif (mr0->id == mr1->id) {\n\t\treturn 0;\n\t}\n\tRListIter *iter;\n\tRIOMapRef *mapref;\n\tr_list_foreach_prev (bank->maprefs, iter, mapref) {\n\t\tif (mapref->id == mr0->id) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (mapref->id == mr1->id) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\t\n}", "target": 0}
{"code": "static int fts3CursorSeek(sqlite3_context *pContext, Fts3Cursor *pCsr){\n  int rc = SQLITE_OK;\n  if( pCsr->isRequireSeek ){\n    sqlite3_stmt *pStmt = 0;\n    rc = fts3CursorSeekStmt(pCsr, &pStmt);\n    if( rc==SQLITE_OK ){\n      sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iPrevId);\n      pCsr->isRequireSeek = 0;\n      if( SQLITE_ROW==sqlite3_step(pCsr->pStmt) ){\n        return SQLITE_OK;\n      }else{\n        rc = sqlite3_reset(pCsr->pStmt);\n        if( rc==SQLITE_OK && ((Fts3Table *)pCsr->base.pVtab)->zContentTbl==0 ){\n          rc = FTS_CORRUPT_VTAB;\n          pCsr->isEof = 1;\n        }\n      }\n    }\n  }\n  if( rc!=SQLITE_OK && pContext ){\n    sqlite3_result_error_code(pContext, rc);\n  }\n  return rc;\n}", "target": 0}
{"code": "update_char_offset(VALUE match)\n{\n    struct rmatch *rm = RMATCH(match)->rmatch;\n    struct re_registers *regs;\n    int i, num_regs, num_pos;\n    long c;\n    char *s, *p, *q;\n    rb_encoding *enc;\n    pair_t *pairs;\n    if (rm->char_offset_updated)\n        return;\n    regs = &rm->regs;\n    num_regs = rm->regs.num_regs;\n    if (rm->char_offset_num_allocated < num_regs) {\n        REALLOC_N(rm->char_offset, struct rmatch_offset, num_regs);\n        rm->char_offset_num_allocated = num_regs;\n    }\n    enc = rb_enc_get(RMATCH(match)->str);\n    if (rb_enc_mbmaxlen(enc) == 1) {\n        for (i = 0; i < num_regs; i++) {\n            rm->char_offset[i].beg = BEG(i);\n            rm->char_offset[i].end = END(i);\n        }\n        rm->char_offset_updated = 1;\n        return;\n    }\n    pairs = ALLOCA_N(pair_t, num_regs*2);\n    num_pos = 0;\n    for (i = 0; i < num_regs; i++) {\n        if (BEG(i) < 0)\n            continue;\n        pairs[num_pos++].byte_pos = BEG(i);\n        pairs[num_pos++].byte_pos = END(i);\n    }\n    qsort(pairs, num_pos, sizeof(pair_t), pair_byte_cmp);\n    s = p = RSTRING_PTR(RMATCH(match)->str);\n    c = 0;\n    for (i = 0; i < num_pos; i++) {\n        q = s + pairs[i].byte_pos;\n        c += rb_enc_strlen(p, q, enc);\n        pairs[i].char_pos = c;\n        p = q;\n    }\n    for (i = 0; i < num_regs; i++) {\n        pair_t key, *found;\n        if (BEG(i) < 0) {\n            rm->char_offset[i].beg = -1;\n            rm->char_offset[i].end = -1;\n            continue;\n        }\n        key.byte_pos = BEG(i);\n        found = bsearch(&key, pairs, num_pos, sizeof(pair_t), pair_byte_cmp);\n        rm->char_offset[i].beg = found->char_pos;\n        key.byte_pos = END(i);\n        found = bsearch(&key, pairs, num_pos, sizeof(pair_t), pair_byte_cmp);\n        rm->char_offset[i].end = found->char_pos;\n    }\n    rm->char_offset_updated = 1;\n}", "target": 0}
{"code": "bool switch_to_ns(pid_t pid, const char *ns) {\n\tint fd, ret;\n\tchar nspath[MAXPATHLEN];\n\tret = snprintf(nspath, MAXPATHLEN, \"/proc/%d/ns/%s\", pid, ns);\n\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\treturn false;\n\tfd = open(nspath, O_RDONLY);\n\tif (fd < 0) {\n\t\tSYSERROR(\"Failed to open %s\", nspath);\n\t\treturn false;\n\t}\n\tret = setns(fd, 0);\n\tif (ret) {\n\t\tSYSERROR(\"Failed to set process %d to %s of %d.\", pid, ns, fd);\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tclose(fd);\n\treturn true;\n}", "target": 0}
{"code": "static struct ea_list *ea_list_union(struct ea_list *name_list, struct ea_list *file_list, size_t *total_ea_len)\n{\n\tstruct ea_list *nlistp, *flistp;\n\tfor (nlistp = name_list; nlistp; nlistp = nlistp->next) {\n\t\tfor (flistp = file_list; flistp; flistp = flistp->next) {\n\t\t\tif (strequal(nlistp->ea.name, flistp->ea.name)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flistp) {\n\t\t\tnlistp->ea.flags = flistp->ea.flags;\n\t\t\tnlistp->ea.value = flistp->ea.value;\n\t\t} else {\n\t\t\tnlistp->ea.flags = 0;\n\t\t\tZERO_STRUCT(nlistp->ea.value);\n\t\t}\n\t}\n\t*total_ea_len = ea_list_size(name_list);\n\treturn name_list;\n}", "target": 0}
{"code": "    **/\n    CImg<T>& abs() {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=524288))\n      cimg_rof(*this,ptrd,T) *ptrd = cimg::abs(*ptrd);\n      return *this;", "target": 0}
{"code": "bool setCtbAddrFromTS(thread_context* tctx)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n  if (tctx->CtbAddrInTS < sps.PicSizeInCtbsY) {\n    tctx->CtbAddrInRS = tctx->img->get_pps().CtbAddrTStoRS[tctx->CtbAddrInTS];\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return false;\n  }\n  else {\n    tctx->CtbAddrInRS = sps.PicSizeInCtbsY;\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return true;\n  }\n}", "target": 0}
{"code": "int64_t OpLevelCostEstimator::CalculateTensorElementCount(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  VLOG(2) << \"   with \" << DataTypeString(tensor.dtype()) << \" tensor of shape \"\n          << tensor.shape().DebugString();\n  int64_t tensor_size = 1;\n  int num_dims = std::max(1, tensor.shape().dim_size());\n  auto tensor_shape =\n      MaybeGetMinimumShape(tensor.shape(), num_dims, found_unknown_shapes);\n  for (const auto& dim : tensor_shape.dim()) {\n    tensor_size *= dim.size();\n  }\n  return tensor_size;\n}", "target": 0}
{"code": "static int find_cc(Token * t)\n{\n    Token *tt;\n    if (!t)\n        return -1;              \n    t = skip_white(t);\n    if (!tok_type(t, TOK_ID))\n        return -1;\n    tt = t->next;\n    tt = skip_white(tt);\n    if (tok_isnt(tt, ','))\n        return -1;\n    return bsii(tok_text(t), (const char **)conditions,\n\t\tARRAY_SIZE(conditions));\n}", "target": 0}
{"code": "static int __init mb2cache_init(void)\n{\n\tmb2_entry_cache = kmem_cache_create(\"mbcache\",\n\t\t\t\tsizeof(struct mb2_cache_entry), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tBUG_ON(!mb2_entry_cache);\n\treturn 0;\n}", "target": 0}
{"code": "ciField* ciEnv::get_field_by_index(ciInstanceKlass* accessor,\n                                   int index) {\n  GUARDED_VM_ENTRY(return get_field_by_index_impl(accessor, index);)\n}", "target": 0}
{"code": "stdmac_file(const SMacro *s, Token **params, int nparams)\n{\n    (void)s;\n    (void)params;\n    (void)nparams;\n    return make_tok_qstr(NULL, src_get_fname());\n}", "target": 0}
{"code": "catch (const AnyError& e) {\n    std::cout << e << \"\\n\";\n}", "target": 0}
{"code": "TfLiteStatus Subgraph::PrepareOpsAndTensors() {\n  if (!memory_planner_) {\n    memory_planner_.reset(new ArenaPlanner(\n        &context_, std::unique_ptr<GraphInfo>(new InterpreterInfo(this)),\n        preserve_all_tensors_, kDefaultTensorAlignment));\n    memory_planner_->PlanAllocations();\n  }\n  bool prepare_original_plan = false;\n  if (!pre_delegation_execution_plan_.empty()) {\n    for (int i = 0; i < delegates_applied_.size(); ++i) {\n      if ((delegates_applied_[i]->flags &\n           kTfLiteDelegateFlagsRequirePropagatedShapes)) {\n        prepare_original_plan = true;\n        break;\n      }\n    }\n  }\n  if (prepare_original_plan) {\n    int last_original_exec_plan_index_prepared = 0;\n    TF_LITE_ENSURE_STATUS(PrepareOpsStartingAt(\n        next_execution_plan_index_to_prepare_, pre_delegation_execution_plan_,\n        &last_original_exec_plan_index_prepared));\n    next_original_execution_plan_index_to_prepare_ =\n        last_original_exec_plan_index_prepared + 1;\n  }\n  int last_exec_plan_index_prepared = 0;\n  TF_LITE_ENSURE_STATUS(\n      PrepareOpsStartingAt(next_execution_plan_index_to_prepare_,\n                           execution_plan_, &last_exec_plan_index_prepared));\n  next_execution_plan_index_to_prepare_ = last_exec_plan_index_prepared + 1;\n  TF_LITE_ENSURE_STATUS(memory_planner_->ExecuteAllocations(\n      next_execution_plan_index_to_plan_allocation_,\n      last_exec_plan_index_prepared));\n  for (int i = 0; i < custom_allocations_.size(); ++i) {\n    auto index_and_alloc = custom_allocations_[i];\n    TfLiteTensor* tensor_at_index = tensor(index_and_alloc.first);\n    const auto& alloc = index_and_alloc.second;\n    TF_LITE_ENSURE_EQ(context(), tensor_at_index->allocation_type,\n                      kTfLiteCustom);\n    if (alloc.bytes < tensor_at_index->bytes) {\n      ReportError(\"Custom allocation is too small for tensor idx: %d\",\n                  index_and_alloc.first);\n      return kTfLiteError;\n    }\n  }\n  next_execution_plan_index_to_plan_allocation_ =\n      last_exec_plan_index_prepared + 1;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int ftrace_function_set_filter(struct perf_event *event,\n\t\t\t\t      struct event_filter *filter)\n{\n\treturn -ENODEV;\n}", "target": 0}
{"code": "char *must_concat(const char *first, ...)\n{\n\tva_list args;\n\tchar *cur, *dest;\n\tsize_t cur_len, it_len;\n\tdest = must_copy_string(first);\n\tcur_len = it_len = strlen(first);\n\tva_start(args, first);\n\twhile ((cur = va_arg(args, char *)) != NULL) {\n\t\tit_len = strlen(cur);\n\t\tdest = must_realloc(dest, cur_len + it_len + 1);\n\t\t(void)memcpy(dest + cur_len, cur, it_len);\n\t\tcur_len += it_len;\n\t}\n\tva_end(args);\n\tdest[cur_len] = 0;\n\treturn dest;\n}", "target": 0}
{"code": "static int mov_write_dref_tag(AVIOContext *pb)\n{\n    avio_wb32(pb, 28); \n    ffio_wfourcc(pb, \"dref\");\n    avio_wb32(pb, 0); \n    avio_wb32(pb, 1); \n    avio_wb32(pb, 0xc); \n    ffio_wfourcc(pb, \"url \");\n    avio_wb32(pb, 1); \n    return 28;\n}", "target": 0}
{"code": "    int printStructure(std::ostream& out, Exiv2::PrintStructureOption option, const std::string& path)\n    {\n        if (!Exiv2::fileExists(path, true)) {\n            std::cerr << path << \": \" << _(\"Failed to open the file\\n\");\n            return -1;\n        }\n        Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open(path);\n        image->printStructure(out, option);\n        return 0;\n    }", "target": 0}
{"code": "ref_stack_store_check(const ref_stack_t *pstack, ref *parray, uint count,\n                      uint skip)\n{\n    uint space = r_space(parray);\n    if (space != avm_local) {\n        uint left = count, pass = skip;\n        ref_stack_enum_t rsenum;\n        ref_stack_enum_begin(&rsenum, pstack);\n        do {\n            ref *ptr = rsenum.ptr;\n            uint size = rsenum.size;\n            if (size <= pass)\n                pass -= size;\n            else {\n                int code;\n                if (pass != 0)\n                    size -= pass, pass = 0;\n                ptr += size;\n                if (size > left)\n                    size = left;\n                left -= size;\n                code = refs_check_space(ptr - size, size, space);\n                if (code < 0)\n                    return code;\n                if (left == 0)\n                    break;\n            }\n        } while (ref_stack_enum_next(&rsenum));\n    }\n    return 0;\n}", "target": 0}
{"code": "static void tcp_incr_quickack(struct sock *sk)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tunsigned int quickacks = tcp_sk(sk)->rcv_wnd / (2 * icsk->icsk_ack.rcv_mss);\n\tif (quickacks == 0)\n\t\tquickacks = 2;\n\tif (quickacks > icsk->icsk_ack.quick)\n\t\ticsk->icsk_ack.quick = min(quickacks, TCP_MAX_QUICKACKS);\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int kLeftShift = 8;\n    int32_t input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(\n        static_cast<double>(input1->params.scale), &input1_multiplier,\n        &input1_shift);\n    int32_t input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(\n        static_cast<double>(input2->params.scale), &input2_multiplier,\n        &input2_shift);\n    data->params.left_shift = kLeftShift;\n    data->params.input1_offset = input1_offset;\n    data->params.input1_multiplier = input1_multiplier;\n    data->params.input1_shift = input1_shift;\n    data->params.input2_offset = input2_offset;\n    data->params.input2_multiplier = input2_multiplier;\n    data->params.input2_shift = input2_shift;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void mxf_handle_small_eubc(AVFormatContext *s)\n{\n    MXFContext *mxf = s->priv_data;\n    if (mxf->op != OPAtom)\n        return;\n    if (s->nb_streams != 1                                     ||\n        s->streams[0]->codec->codec_type != AVMEDIA_TYPE_AUDIO ||\n        !is_pcm(s->streams[0]->codec->codec_id)                ||\n        mxf->nb_index_tables != 1                              ||\n        mxf->index_tables[0].nb_segments != 1                  ||\n        mxf->index_tables[0].segments[0]->edit_unit_byte_count >= 32)\n        return;\n    mxf->edit_units_per_packet = 1920;\n}", "target": 0}
{"code": "s32 gf_gettimeofday(struct timeval *tp, void *tz) {\n\treturn gettimeofday(tp, tz);\n}", "target": 0}
{"code": "EGLConfig GLSurfaceOzoneSurfaceless::GetConfig() {\n  if (!config_) {\n    ui::EglConfigCallbacks callbacks = GetEglConfigCallbacks(GetDisplay());\n    config_ = ozone_surface_->GetEGLSurfaceConfig(callbacks);\n  }\n  if (config_)\n    return config_;\n  return SurfacelessEGL::GetConfig();\n}", "target": 0}
{"code": "handle_event(context *ctx, struct pollfd *pollfd)\n{\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tssize_t n;\n\tpesignd_msghdr pm;\n\tmsg.msg_name = NULL;\n\tmsg.msg_namelen = 0;\n\tiov.iov_base = &pm;\n\tiov.iov_len = sizeof(pm);\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tchar control[1024];\n\tmsg.msg_controllen = 1024;\n\tmsg.msg_control = control;\n\tn = recvmsg(pollfd->fd, &msg, MSG_WAITALL);\n\tif (n < 0) {\n\t\tctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_WARNING,\n\t\t\t\"recvmsg failed: %m\");\n\t\treturn n;\n\t}\n\tif (n == 0)\n\t\treturn n;\n\tif (n < (long long)sizeof (pm)) {\n\t\tctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,\n\t\t\t\"got message with invalid size %zu\", n);\n\t\tctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,\n\t\t\t\"possible exploit attempt.  closing.\");\n\t\tclose(pollfd->fd);\n\t\treturn -1;\n\t}\n\tif (pm.version != PESIGND_VERSION) {\n\t\tctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,\n\t\t\t\"got version %#x, expected version %#x\",\n\t\t\tpm.version, PESIGND_VERSION);\n\t\tctx->backup_cms->log(ctx->backup_cms, ctx->priority|LOG_ERR,\n\t\t\t\"possible exploit attempt.  closing.\");\n\t\tclose(pollfd->fd);\n\t\treturn -1;\n\t}\n\tfor (int i = 0; cmd_table[i].cmd != CMD_LIST_END; i++) {\n\t\tif (cmd_table[i].cmd == pm.command) {\n\t\t\tif (cmd_table[i].func == NULL) {\n\t\t\t\thandle_invalid_input(pm.command, ctx, pollfd,\n\t\t\t\t\t\t\tpm.size);\n\t\t\t\tclose(pollfd->fd);\n\t\t\t}\n\t\t\tcmd_table[i].func(ctx, pollfd, pm.size);\n\t\t\treturn 0;\n\t\t}\n\t}\n\thandle_invalid_input(pm.command, ctx, pollfd, pm.size);\n\tclose(pollfd->fd);\n\treturn 0;\n}", "target": 0}
{"code": "GfxColorSpace *GfxCalRGBColorSpace::copy() const\n{\n    GfxCalRGBColorSpace *cs;\n    int i;\n    cs = new GfxCalRGBColorSpace();\n    cs->whiteX = whiteX;\n    cs->whiteY = whiteY;\n    cs->whiteZ = whiteZ;\n    cs->blackX = blackX;\n    cs->blackY = blackY;\n    cs->blackZ = blackZ;\n    cs->gammaR = gammaR;\n    cs->gammaG = gammaG;\n    cs->gammaB = gammaB;\n    cs->kr = kr;\n    cs->kg = kg;\n    cs->kb = kb;\n    for (i = 0; i < 9; ++i) {\n        cs->mat[i] = mat[i];\n    }\n#ifdef USE_CMS\n    cs->transform = transform;\n#endif\n    return cs;\n}", "target": 0}
{"code": "static int check_pkt(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVMuxContext *mov = s->priv_data;\n    MOVTrack *trk = &mov->tracks[pkt->stream_index];\n    int64_t ref;\n    uint64_t duration;\n    if (trk->entry) {\n        ref = trk->cluster[trk->entry - 1].dts;\n    } else if (   trk->start_dts != AV_NOPTS_VALUE\n               && !trk->frag_discont) {\n        ref = trk->start_dts + trk->track_duration;\n    } else\n        ref = pkt->dts; \n    duration = pkt->dts - ref;\n    if (pkt->dts < ref || duration >= INT_MAX) {\n        av_log(s, AV_LOG_ERROR, \"Application provided duration: %\"PRId64\" / timestamp: %\"PRId64\" is out of range for mov/mp4 format\\n\",\n            duration, pkt->dts\n        );\n        pkt->dts = ref + 1;\n        pkt->pts = AV_NOPTS_VALUE;\n    }\n    if (pkt->duration < 0 || pkt->duration > INT_MAX) {\n        av_log(s, AV_LOG_ERROR, \"Application provided duration: %\"PRId64\" is invalid\\n\", pkt->duration);\n        return AVERROR(EINVAL);\n    }\n    return 0;\n}", "target": 0}
{"code": "    AsciiValue::AsciiValue(const std::string& buf)\n        : StringValueBase(asciiString, buf)\n    {\n    }", "target": 0}
{"code": "    SshIo::SshImpl::SshImpl(const std::wstring& wurl, size_t blockSize):Impl(wurl, blockSize)\n    {\n        std::string url;\n        url.assign(wurl.begin(), wurl.end());\n        path_ = url;\n        hostInfo_ = Exiv2::Uri::Parse(url);\n        Exiv2::Uri::Decode(hostInfo_);\n        if (hostInfo_.Path[0] == '/') {\n            hostInfo_.Path = hostInfo_.Path.substr(1);\n        }\n        ssh_ = new SSH(hostInfo_.Host, hostInfo_.Username, hostInfo_.Password, hostInfo_.Port);\n        if (protocol_ == pSftp) {\n            ssh_->getFileSftp(hostInfo_.Path, fileHandler_);\n            if (fileHandler_ == nullptr) throw Error(kerErrorMessage, \"Unable to open the file\");\n        } else {\n            fileHandler_ = nullptr;\n        }\n    }", "target": 0}
{"code": "static RGBType * HWB_to_RGB (HWBType HWB, RGBType * RGB)\n{\n\tfloat h = HWB.H, w = HWB.W, b = HWB.B, v, n, f;\n\tint i;\n\tv = 1 - b;\n\tif (h == HWB_UNDEFINED) {\n\t\tRETURN_RGB(v, v, v);\n\t}\n\ti = floor(h);\n\tf = h - i;\n\tif (i & 1) {\n\t\tf = 1 - f; \n\t}\n\tn = w + f * (v - w);\t\t\n\tswitch (i) {\n\t\tcase 6:\n\t\tcase 0:\n\t\t\tRETURN_RGB(v, n, w);\n\t\tcase 1:\n\t\t\tRETURN_RGB(n, v, w);\n\t\tcase 2:\n\t\t\tRETURN_RGB(w, v, n);\n\t\tcase 3:\n\t\t\tRETURN_RGB(w, n, v);\n\t\tcase 4:\n\t\t\tRETURN_RGB(n, w, v);\n\t\tcase 5:\n\t\t\tRETURN_RGB(v, w, n);\n\t}\n\treturn RGB;\n}", "target": 0}
{"code": "void ewk_view_paint_context_translate(Ewk_View_Paint_Context* context, float x, float y)\n{\n    EINA_SAFETY_ON_NULL_RETURN(context);\n    context->graphicContext->translate(x, y);\n}", "target": 0}
{"code": "xfs_lock_inumorder(int lock_mode, int subclass)\n{\n\tint\tclass = 0;\n\tASSERT(!(lock_mode & (XFS_ILOCK_PARENT | XFS_ILOCK_RTBITMAP |\n\t\t\t      XFS_ILOCK_RTSUM)));\n\tASSERT(xfs_lockdep_subclass_ok(subclass));\n\tif (lock_mode & (XFS_IOLOCK_SHARED|XFS_IOLOCK_EXCL)) {\n\t\tASSERT(subclass <= XFS_IOLOCK_MAX_SUBCLASS);\n\t\tclass += subclass << XFS_IOLOCK_SHIFT;\n\t}\n\tif (lock_mode & (XFS_MMAPLOCK_SHARED|XFS_MMAPLOCK_EXCL)) {\n\t\tASSERT(subclass <= XFS_MMAPLOCK_MAX_SUBCLASS);\n\t\tclass += subclass << XFS_MMAPLOCK_SHIFT;\n\t}\n\tif (lock_mode & (XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)) {\n\t\tASSERT(subclass <= XFS_ILOCK_MAX_SUBCLASS);\n\t\tclass += subclass << XFS_ILOCK_SHIFT;\n\t}\n\treturn (lock_mode & ~XFS_LOCK_SUBCLASS_MASK) | class;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::DecrementInFlightEventCount(\n    InputEventAckSource ack_source) {\n  --in_flight_event_count_;\n  if (in_flight_event_count_ <= 0) {\n    StopHangMonitorTimeout();\n  } else {\n    if (ack_source == InputEventAckSource::MAIN_THREAD)\n      RestartHangMonitorTimeoutIfNecessary();\n  }\n}", "target": 0}
{"code": "FunctionCallFrame::~FunctionCallFrame() {}", "target": 0}
{"code": "seamless_send(const char *command, const char *format, ...)\n{\n\tSTREAM s;\n\tsize_t len;\n\tva_list argp;\n\tchar *escaped, buf[1025];\n\tlen = snprintf(buf, sizeof(buf) - 1, \"%s,%u,\", command, seamless_serial);\n\tassert(len < (sizeof(buf) - 1));\n\tva_start(argp, format);\n\tlen += vsnprintf(buf + len, sizeof(buf) - len - 1, format, argp);\n\tva_end(argp);\n\tassert(len < (sizeof(buf) - 1));\n\tescaped = utils_string_escape(buf);\n\tlen = snprintf(buf, sizeof(buf), \"%s\", escaped);\n\tfree(escaped);\n\tassert(len < (sizeof(buf) - 1));\n\tbuf[len] = '\\n';\n\tbuf[len + 1] = '\\0';\n\tlen++;\n\ts = channel_init(seamless_channel, len);\n\tout_uint8p(s, buf, len) s_mark_end(s);\n\tDEBUG_SEAMLESS((\"seamlessrdp sending:%s\", buf));\n#if 0\n\tprintf(\"seamless send:\\n\");\n\thexdump(s->channel_hdr + 8, s->end - s->channel_hdr - 8);\n#endif\n\tchannel_send(s, seamless_channel);\n\treturn seamless_serial++;\n}", "target": 0}
{"code": "static bool name_is_in_list(const char *name, char **list)\n{\n\tuint32_t count;\n\tfor (count = 0; list && list[count]; count++) {\n\t\tif (strequal(name, list[count])) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,\n\t\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tu8 *buffer, *alignbuffer;\n\tunsigned long absize;\n\tint ret;\n\tabsize = keylen + alignmask;\n\tbuffer = kmalloc(absize, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\talignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\n\tmemcpy(alignbuffer, key, keylen);\n\tret = cipher->setkey(tfm, alignbuffer, keylen);\n\tkzfree(buffer);\n\treturn ret;\n}", "target": 0}
{"code": "gfx::NativeViewAccessible WebContentsImpl::GetParentNativeViewAccessible() {\n  return accessible_parent_;\n}", "target": 0}
{"code": "static int nested_vmx_check_msr_bitmap_controls(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tstruct vmcs12 *vmcs12)\n{\n\tint maxphyaddr;\n\tu64 addr;\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n\t\treturn 0;\n\tif (vmcs12_read_any(vcpu, MSR_BITMAP, &addr)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tmaxphyaddr = cpuid_maxphyaddr(vcpu);\n\tif (!PAGE_ALIGNED(vmcs12->msr_bitmap) ||\n\t   ((addr + PAGE_SIZE) >> maxphyaddr))\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "void* r_bin_dyldcache_free(struct r_bin_dyldcache_obj_t* bin) {\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tr_buf_free (bin->b);\n\tfree (bin);\n\treturn NULL;\n}", "target": 0}
{"code": "static char winbind_separator(struct torture_context *torture)\n{\n\tstruct winbindd_response rep;\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_INFO, NULL, &rep);\n\treturn rep.data.info.winbind_separator;\n}", "target": 0}
{"code": "RenderViewImpl::~RenderViewImpl() {\n  history_page_ids_.clear();\n  if (decrement_shared_popup_at_destruction_)\n    shared_popup_counter_->data--;\n  while (!file_chooser_completions_.empty()) {\n    if (file_chooser_completions_.front()->completion) {\n      file_chooser_completions_.front()->completion->didChooseFile(\n          WebVector<WebString>());\n    }\n    file_chooser_completions_.pop_front();\n  }\n#if defined(OS_MACOSX)\n  while (!fake_plugin_window_handles_.empty()) {\n    DCHECK(*fake_plugin_window_handles_.begin());\n    DestroyFakePluginWindowHandle(*fake_plugin_window_handles_.begin());\n  }\n#endif\n#ifndef NDEBUG\n  ViewMap* views = g_view_map.Pointer();\n  for (ViewMap::iterator it = views->begin(); it != views->end(); ++it)\n    DCHECK_NE(this, it->second) << \"Failed to call Close?\";\n  RoutingIDViewMap* routing_id_views = g_routing_id_view_map.Pointer();\n  for (RoutingIDViewMap::iterator it = routing_id_views->begin();\n       it != routing_id_views->end(); ++it)\n    DCHECK_NE(this, it->second) << \"Failed to call Close?\";\n#endif\n  FOR_EACH_OBSERVER(RenderViewObserver, observers_, RenderViewGone());\n  FOR_EACH_OBSERVER(RenderViewObserver, observers_, OnDestruct());\n}", "target": 0}
{"code": "static WebProcessProxy::WebPageProxyMap& globalPageMap()\n{\n    ASSERT(isMainThread());\n    DEFINE_STATIC_LOCAL(WebProcessProxy::WebPageProxyMap, pageMap, ());\n    return pageMap;\n}", "target": 0}
{"code": "static zval *var_access(php_unserialize_data_t *var_hashx, zend_long id)\n{\n\tvar_entries *var_hash = (*var_hashx)->first;\n#if VAR_ENTRIES_DBG\n\tfprintf(stderr, \"var_access(%ld): %ld\\n\", var_hash?var_hash->used_slots:-1L, id);\n#endif\n\twhile (id >= VAR_ENTRIES_MAX && var_hash && var_hash->used_slots == VAR_ENTRIES_MAX) {\n\t\tvar_hash = var_hash->next;\n\t\tid -= VAR_ENTRIES_MAX;\n\t}\n\tif (!var_hash) return NULL;\n\tif (id < 0 || id >= var_hash->used_slots) return NULL;\n\treturn var_hash->data[id];\n}", "target": 0}
{"code": "void smp_send_id_info(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n  tBTM_LE_KEY_VALUE le_key;\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  smp_update_key_mask(p_cb, SMP_SEC_KEY_TYPE_ID, false);\n  smp_send_cmd(SMP_OPCODE_IDENTITY_INFO, p_cb);\n  smp_send_cmd(SMP_OPCODE_ID_ADDR, p_cb);\n if ((p_cb->peer_auth_req & SMP_AUTH_BOND) &&\n (p_cb->loc_auth_req & SMP_AUTH_BOND))\n    btm_sec_save_le_key(p_cb->pairing_bda, BTM_LE_KEY_LID, &le_key, true);\n  SMP_TRACE_WARNING(\"%s\", __func__);\n  smp_key_distribution_by_transport(p_cb, NULL);\n}", "target": 0}
{"code": "smtp_connect(smtp_connect_args * sc, const blob * early_data)\n{\nint port = sc->host->port;\nsmtp_transport_options_block * ob = sc->ob;\ncallout_address = string_sprintf(\"[%s]:%d\", sc->host->address, port);\nHDEBUG(D_transport|D_acl|D_v)\n  {\n  uschar * s = US\" \";\n  if (sc->interface) s = string_sprintf(\" from %s \", sc->interface);\n#ifdef SUPPORT_SOCKS\n  if (ob->socks_proxy) s = string_sprintf(\"%svia proxy \", s);\n#endif\n  debug_printf_indent(\"Connecting to %s %s%s... \", sc->host->name, callout_address, s);\n  }\n#ifdef SUPPORT_SOCKS\nif (ob->socks_proxy)\n  {\n  int sock = socks_sock_connect(sc->host, sc->host_af, port, sc->interface,\n\t\t\t\tsc->tblock, ob->connect_timeout);\n  if (sock >= 0)\n    {\n    if (early_data && early_data->data && early_data->len)\n      if (send(sock, early_data->data, early_data->len, 0) < 0)\n\t{\n\tint save_errno = errno;\n\tHDEBUG(D_transport|D_acl|D_v)\n\t  {\n\t  debug_printf_indent(\"failed: %s\", CUstrerror(save_errno));\n\t  if (save_errno == ETIMEDOUT)\n\t    debug_printf(\" (timeout=%s)\", readconf_printtime(ob->connect_timeout));\n\t  debug_printf(\"\\n\");\n\t  }\n\t(void)close(sock);\n\tsock = -1;\n\terrno = save_errno;\n\t}\n    }\n  return sock;\n  }\n#endif\nreturn smtp_sock_connect(sc->host, sc->host_af, port, sc->interface,\n\t\t\t  sc->tblock, ob->connect_timeout, early_data);\n}", "target": 0}
{"code": "void ZlibInStream::flushUnderlying()\n{\n  ptr = end = start;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  setUnderlying(NULL, 0);\n}", "target": 0}
{"code": "static int acl_parse_meth(const char **text, struct acl_pattern *pattern, int *opaque)\n{\n\tint len, meth;\n\tlen  = strlen(*text);\n\tmeth = find_http_meth(*text, len);\n\tpattern->val.i = meth;\n\tif (meth == HTTP_METH_OTHER) {\n\t\tpattern->ptr.str = strdup(*text);\n\t\tif (!pattern->ptr.str)\n\t\t\treturn 0;\n\t\tpattern->len = len;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "    uint32_t ArrayDef::size(uint16_t tag, IfdId group) const\n    {\n        TypeId typeId = toTypeId(tiffType_, tag, group);\n        return count_ * TypeInfo::typeSize(typeId);\n    }", "target": 0}
{"code": "    vector<string> get_zone_names_from_ids(rgw::sal::RGWRadosStore *store,\n                                           const set<rgw_zone_id>& zone_ids) const {\n      vector<string> names;\n      for (auto& id : zone_ids) {\n        RGWZone *zone;\n        if (store->svc()->zone->find_zone(id, &zone)) {\n          names.emplace_back(zone->name);\n        }\n      }\n      return names;\n    }", "target": 0}
{"code": "int svm_mem_enc_op(struct kvm *kvm, void __user *argp)\n{\n\tstruct kvm_sev_cmd sev_cmd;\n\tint r;\n\tif (!svm_sev_enabled())\n\t\treturn -ENOTTY;\n\tif (!argp)\n\t\treturn 0;\n\tif (copy_from_user(&sev_cmd, argp, sizeof(struct kvm_sev_cmd)))\n\t\treturn -EFAULT;\n\tmutex_lock(&kvm->lock);\n\tswitch (sev_cmd.id) {\n\tcase KVM_SEV_INIT:\n\t\tr = sev_guest_init(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_START:\n\t\tr = sev_launch_start(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_UPDATE_DATA:\n\t\tr = sev_launch_update_data(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_MEASURE:\n\t\tr = sev_launch_measure(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_FINISH:\n\t\tr = sev_launch_finish(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_GUEST_STATUS:\n\t\tr = sev_guest_status(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_DBG_DECRYPT:\n\t\tr = sev_dbg_crypt(kvm, &sev_cmd, true);\n\t\tbreak;\n\tcase KVM_SEV_DBG_ENCRYPT:\n\t\tr = sev_dbg_crypt(kvm, &sev_cmd, false);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_SECRET:\n\t\tr = sev_launch_secret(kvm, &sev_cmd);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (copy_to_user(argp, &sev_cmd, sizeof(struct kvm_sev_cmd)))\n\t\tr = -EFAULT;\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}", "target": 0}
{"code": "void WebContentsImpl::RenderViewTerminated(RenderViewHost* rvh,\n                                           base::TerminationStatus status,\n                                           int error_code) {\n  if (rvh != GetRenderViewHost()) {\n    return;\n  }\n  ClearPowerSaveBlockers(rvh);\n  SetIsLoading(false, NULL);\n  NotifyDisconnected();\n  SetIsCrashed(status, error_code);\n  GetView()->OnTabCrashed(GetCrashedStatus(), crashed_error_code_);\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    RenderProcessGone(GetCrashedStatus()));\n}", "target": 0}
{"code": "int afGetVirtualByteOrder (AFfilehandle handle, int track)\n{\n\t_Track *currentTrack;\n\tif (!_af_filehandle_ok(handle))\n\t\treturn -1;\n\tif ((currentTrack = _af_filehandle_get_track(handle, track)) == NULL)\n\t\treturn -1;\n\treturn (currentTrack->v.byteOrder);\n}", "target": 0}
{"code": "static inline char *tok_text_buf(struct Token *t)\n{\n    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;\n}", "target": 0}
{"code": "static FILE *inc_fopen_search(const char *file, char **slpath,\n                              enum incopen_mode omode, enum file_flags fmode)\n{\n    const struct strlist_entry *ip = strlist_head(ipath_list);\n    FILE *fp;\n    const char *prefix = \"\";\n    char *sp;\n    bool found;\n    while (1) {\n        sp = nasm_catfile(prefix, file);\n        if (omode == INC_PROBE) {\n            fp = NULL;\n            found = nasm_file_exists(sp);\n        } else {\n            fp = nasm_open_read(sp, fmode);\n            found = (fp != NULL);\n        }\n        if (found) {\n            *slpath = sp;\n            return fp;\n        }\n        nasm_free(sp);\n        if (!ip) {\n            *slpath = NULL;\n            return NULL;\n        }\n        prefix = ip->str;\n        ip = ip->next;\n    }\n}", "target": 0}
{"code": "void EmbeddedWorkerContextClient::workerContextStarted(\n    blink::WebServiceWorkerContextProxy* proxy) {\n  DCHECK(!worker_task_runner_);\n  worker_task_runner_ = new WorkerThreadTaskRunner(\n      WorkerTaskRunner::Instance()->CurrentWorkerId());\n  DCHECK_NE(0, WorkerTaskRunner::Instance()->CurrentWorkerId());\n  DCHECK(g_worker_client_tls.Pointer()->Get() == NULL);\n  DCHECK(!script_context_);\n  g_worker_client_tls.Pointer()->Set(this);\n  script_context_.reset(new ServiceWorkerScriptContext(this, proxy));\n  worker_task_runner_->PostTask(\n      FROM_HERE,\n      base::Bind(&EmbeddedWorkerContextClient::SendWorkerStarted,\n                 weak_factory_.GetWeakPtr()));\n}", "target": 0}
{"code": "load_cache (GeglProperties *op_magick_load)\n{\n  if (!op_magick_load->user_data)\n    {\n      gchar    *filename;\n      GeglNode *graph, *sink, *loader;\n      GeglBuffer *newbuf = NULL;\n      char     *argv[4]  = {\"convert\", NULL, NULL, NULL};\n      filename = g_build_filename (g_get_tmp_dir (), \"gegl-magick.png\", NULL);\n      argv[1] = g_strdup_printf (\"%s[0]\", op_magick_load->path);\n      argv[2] = filename;\n      if (!g_spawn_sync (NULL, argv, NULL, G_SPAWN_DEFAULT, \n                         NULL, NULL, NULL, NULL, NULL, NULL))\n        g_warning (\"Error executing ImageMagick convert program\");\n      g_free (argv[1]);\n      graph = gegl_node_new ();\n      sink = gegl_node_new_child (graph,\n                                 \"operation\", \"gegl:buffer-sink\",\n                                 \"buffer\", &newbuf, NULL);\n      loader = gegl_node_new_child (graph,\n                                    \"operation\", \"gegl:png-load\",\n                                    \"path\", filename, NULL);\n      gegl_node_link_many (loader, sink, NULL);\n      gegl_node_process (sink);\n      op_magick_load->user_data = (gpointer) newbuf;\n      g_object_unref (graph);\n      g_free (filename);\n    }\n}", "target": 0}
{"code": "static plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_STRING;\n    data->strval = (char *) malloc(sizeof(char) * (size + 1));\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(char) * (size + 1));\n        return NULL;\n    }\n    memcpy(data->strval, *bnode, size);\n    data->strval[size] = '\\0';\n    data->length = strlen(data->strval);\n    return node_create(NULL, data);\n}", "target": 0}
{"code": "static void ext4_wait_for_tail_page_commit(struct inode *inode)\n{\n\tstruct page *page;\n\tunsigned offset;\n\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\ttid_t commit_tid = 0;\n\tint ret;\n\toffset = inode->i_size & (PAGE_SIZE - 1);\n\tif (offset > PAGE_SIZE - i_blocksize(inode))\n\t\treturn;\n\twhile (1) {\n\t\tpage = find_lock_page(inode->i_mapping,\n\t\t\t\t      inode->i_size >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\treturn;\n\t\tret = __ext4_journalled_invalidatepage(page, offset,\n\t\t\t\t\t\tPAGE_SIZE - offset);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (ret != -EBUSY)\n\t\t\treturn;\n\t\tcommit_tid = 0;\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_committing_transaction)\n\t\t\tcommit_tid = journal->j_committing_transaction->t_tid;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tif (commit_tid)\n\t\t\tjbd2_log_wait_commit(journal, commit_tid);\n\t}\n}", "target": 0}
{"code": "FF_SYMVER(void, av_fast_malloc, (void *ptr, unsigned int *size, size_t min_size), LIBNAME)\n{\n    av_fast_malloc(ptr, size, min_size);\n}", "target": 0}
{"code": "static u8 bnx2x_fp_cl_id(struct bnx2x_fastpath *fp)\n{\n\tif (CHIP_IS_E1x(fp->bp))\n\t\treturn BP_L_ID(fp->bp) + fp->index;\n\telse\t\n\t\treturn bnx2x_fp_igu_sb_id(fp);\n}", "target": 0}
{"code": "GF_Err tenc_box_size(GF_Box *s)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*)s;\n\tptr->size += 3;\n\tptr->size += 17;\n\tif ((ptr->isProtected == 1) && ! ptr->key_info[3]) {\n\t\tptr->size += 1 + ptr->key_info[20];\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "MagickPrivate const Quantum *GetVirtualPixelsNexus(const Cache cache,\n  NexusInfo *magick_restrict nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickCoreSignature);\n  if (cache_info->storage_class == UndefinedClass)\n    return((Quantum *) NULL);\n  return((const Quantum *) nexus_info->pixels);\n}", "target": 0}
{"code": "static MemTxResult watch_mem_read(void *opaque, hwaddr addr, uint64_t *pdata,\n                                  unsigned size, MemTxAttrs attrs)\n{\n    MemTxResult res;\n    uint64_t data;\n    check_watchpoint(addr & ~TARGET_PAGE_MASK, size, attrs, BP_MEM_READ);\n    switch (size) {\n    case 1:\n        data = address_space_ldub(&address_space_memory, addr, attrs, &res);\n        break;\n    case 2:\n        data = address_space_lduw(&address_space_memory, addr, attrs, &res);\n        break;\n    case 4:\n        data = address_space_ldl(&address_space_memory, addr, attrs, &res);\n        break;\n    default: abort();\n    }\n    *pdata = data;\n    return res;\n}", "target": 0}
{"code": "static int mov_auto_flush_fragment(AVFormatContext *s, int force)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int had_moov = mov->moov_written;\n    int ret = mov_flush_fragment(s, force);\n    if (ret < 0)\n        return ret;\n    if (!had_moov && mov->flags & FF_MOV_FLAG_DELAY_MOOV)\n        ret = mov_flush_fragment(s, force);\n    return ret;\n}", "target": 0}
{"code": "open_exfile(\n    char_u\t*fname,\n    int\t\tforceit,\n    char\t*mode)\t    \n{\n    FILE\t*fd;\n#ifdef UNIX\n    if (mch_isdir(fname))\n    {\n\tsemsg(_(e_str_is_directory), fname);\n\treturn NULL;\n    }\n#endif\n    if (!forceit && *mode != 'a' && vim_fexists(fname))\n    {\n\tsemsg(_(e_str_exists_add_bang_to_override), fname);\n\treturn NULL;\n    }\n    if ((fd = mch_fopen((char *)fname, mode)) == NULL)\n\tsemsg(_(e_cannot_open_str_for_writing_2), fname);\n    return fd;\n}", "target": 0}
{"code": "SPL_METHOD(RecursiveDirectoryIterator, getChildren)\n{\n\tzval *zpath, *zflags;\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_filesystem_object *subdir;\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\tMAKE_STD_ZVAL(zflags);\n\tMAKE_STD_ZVAL(zpath);\n\tZVAL_LONG(zflags, intern->flags);\n\tZVAL_STRINGL(zpath, intern->file_name, intern->file_name_len, 1);\n\tspl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, zpath, zflags TSRMLS_CC);\n\tzval_ptr_dtor(&zpath);\n\tzval_ptr_dtor(&zflags);\n\tsubdir = (spl_filesystem_object*)zend_object_store_get_object(return_value TSRMLS_CC);\n\tif (subdir) {\n\t\tif (intern->u.dir.sub_path && intern->u.dir.sub_path[0]) {\n\t\t\tsubdir->u.dir.sub_path_len = spprintf(&subdir->u.dir.sub_path, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\t} else {\n\t\t\tsubdir->u.dir.sub_path_len = strlen(intern->u.dir.entry.d_name);\n\t\t\tsubdir->u.dir.sub_path = estrndup(intern->u.dir.entry.d_name, subdir->u.dir.sub_path_len);\n\t\t}\n\t\tsubdir->info_class = intern->info_class;\n\t\tsubdir->file_class = intern->file_class;\n\t\tsubdir->oth = intern->oth;\n\t}\n}", "target": 0}
{"code": "void InlineFlowBox::setVisualOverflow(const IntRect& rect)\n{\n    IntRect frameBox = enclosingIntRect(FloatRect(x(), y(), width(), height()));\n    if (frameBox == rect || rect.isEmpty())\n        return;\n    if (!m_overflow)\n        m_overflow.set(new RenderOverflow(frameBox, frameBox));\n    m_overflow->setVisualOverflow(rect);\n}", "target": 0}
{"code": "static int vcpu_stat_get(void *_offset, u64 *val)\n{\n\tunsigned offset = (long)_offset;\n\tstruct kvm *kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\t*val = 0;\n\traw_spin_lock(&kvm_lock);\n\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\t*val += *(u32 *)((void *)vcpu + offset);\n\traw_spin_unlock(&kvm_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static void FNAME(invlpg)(struct kvm_vcpu *vcpu, gva_t gva, hpa_t root_hpa)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tint level;\n\tu64 *sptep;\n\tvcpu_clear_mmio_info(vcpu, gva);\n\tmmu_topup_memory_caches(vcpu);\n\tif (!VALID_PAGE(root_hpa)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tfor_each_shadow_entry_using_root(vcpu, root_hpa, gva, iterator) {\n\t\tlevel = iterator.level;\n\t\tsptep = iterator.sptep;\n\t\tsp = page_header(__pa(sptep));\n\t\tif (is_last_spte(*sptep, level)) {\n\t\t\tpt_element_t gpte;\n\t\t\tgpa_t pte_gpa;\n\t\t\tif (!sp->unsync)\n\t\t\t\tbreak;\n\t\t\tpte_gpa = FNAME(get_level1_sp_gpa)(sp);\n\t\t\tpte_gpa += (sptep - sp->spt) * sizeof(pt_element_t);\n\t\t\tif (mmu_page_zap_pte(vcpu->kvm, sp, sptep))\n\t\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm,\n\t\t\t\t\tsp->gfn, KVM_PAGES_PER_HPAGE(sp->role.level));\n\t\t\tif (!rmap_can_add(vcpu))\n\t\t\t\tbreak;\n\t\t\tif (kvm_vcpu_read_guest_atomic(vcpu, pte_gpa, &gpte,\n\t\t\t\t\t\t       sizeof(pt_element_t)))\n\t\t\t\tbreak;\n\t\t\tFNAME(update_pte)(vcpu, sp, sptep, &gpte);\n\t\t}\n\t\tif (!is_shadow_present_pte(*sptep) || !sp->unsync_children)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}", "target": 0}
{"code": "int DynamicMetadataMapWrapper::luaGet(lua_State* state) {\n  const char* filter_name = luaL_checkstring(state, 2);\n  const auto& metadata = streamInfo().dynamicMetadata().filter_metadata();\n  const auto filter_it = metadata.find(filter_name);\n  if (filter_it == metadata.end()) {\n    return 0;\n  }\n  Filters::Common::Lua::MetadataMapHelper::createTable(state, filter_it->second.fields());\n  return 1;\n}", "target": 0}
{"code": "static void ff_layout_read_prepare_v3(struct rpc_task *task, void *data)\n{\n\tstruct nfs_pgio_header *hdr = data;\n\tif (ff_layout_read_prepare_common(task, hdr))\n\t\treturn;\n\trpc_call_start(task);\n}", "target": 0}
{"code": "void ClientUsageTracker::NoopHostUsageCallback(\n    const std::string& host,  StorageType type, int64 usage) {\n}", "target": 0}
{"code": "parse_mime(struct magic_set *ms, struct magic_entry *me, const char *line)\n{\n\tsize_t i;\n\tconst char *l = line;\n\tstruct magic *m = &me->mp[me->cont_count == 0 ? 0 : me->cont_count - 1];\n\tif (m->mimetype[0] != '\\0') {\n\t\tfile_magwarn(ms, \"Current entry already has a MIME type `%s',\"\n\t\t    \" new type `%s'\", m->mimetype, l);\n\t\treturn -1;\n\t}\t\n\tEATAB;\n\tfor (i = 0; *l && ((isascii((unsigned char)*l) &&\n\t    isalnum((unsigned char)*l)) || strchr(\"-+/.\", *l)) &&\n\t    i < sizeof(m->mimetype); m->mimetype[i++] = *l++)\n\t\tcontinue;\n\tif (i == sizeof(m->mimetype)) {\n\t\tm->mimetype[sizeof(m->mimetype) - 1] = '\\0';\n\t\tif (ms->flags & MAGIC_CHECK)\n\t\t\tfile_magwarn(ms, \"MIME type `%s' truncated %\"\n\t\t\t    SIZE_T_FORMAT \"u\", m->mimetype, i);\n\t} else\n\t\tm->mimetype[i] = '\\0';\n\tif (i > 0)\n\t\treturn 0;\n\telse\n\t\treturn -1;\n}", "target": 0}
{"code": "static void sev_clflush_pages(struct page *pages[], unsigned long npages)\n{\n\tuint8_t *page_virtual;\n\tunsigned long i;\n\tif (this_cpu_has(X86_FEATURE_SME_COHERENT) || npages == 0 ||\n\t    pages == NULL)\n\t\treturn;\n\tfor (i = 0; i < npages; i++) {\n\t\tpage_virtual = kmap_atomic(pages[i]);\n\t\tclflush_cache_range(page_virtual, PAGE_SIZE);\n\t\tkunmap_atomic(page_virtual);\n\t}\n}", "target": 0}
{"code": "d_lite_day_fraction(VALUE self)\n{\n    get_d1(self);\n    if (simple_dat_p(dat))\n\treturn INT2FIX(0);\n    return m_fr(dat);\n}", "target": 0}
{"code": "static void fuse_lib_getlk(fuse_req_t req, fuse_ino_t ino,\n                           struct fuse_file_info *fi, struct flock *lock)\n{\n    int err;\n    struct lock l;\n    struct lock *conflict;\n    struct fuse *f = req_fuse(req);\n    flock_to_lock(lock, &l);\n    l.owner = fi->lock_owner;\n    pthread_mutex_lock(&f->lock);\n    conflict = locks_conflict(get_node(f, ino), &l);\n    if (conflict)\n        lock_to_flock(conflict, lock);\n    pthread_mutex_unlock(&f->lock);\n    if (!conflict)\n        err = fuse_lock_common(req, ino, fi, lock, F_GETLK);\n    else\n        err = 0;\n    if (!err)\n        fuse_reply_lock(req, lock);\n    else\n        reply_err(req, err);\n}", "target": 0}
{"code": "int kvm_vcpu_yield_to(struct kvm_vcpu *target)\n{\n\tstruct pid *pid;\n\tstruct task_struct *task = NULL;\n\tint ret = 0;\n\trcu_read_lock();\n\tpid = rcu_dereference(target->pid);\n\tif (pid)\n\t\ttask = get_pid_task(pid, PIDTYPE_PID);\n\trcu_read_unlock();\n\tif (!task)\n\t\treturn ret;\n\tret = yield_to(task, 1);\n\tput_task_struct(task);\n\treturn ret;\n}", "target": 0}
{"code": "rb_memsearch_qs_utf8_hash(const unsigned char *x)\n{\n    register const unsigned int mix = 8353;\n    register unsigned int h = *x;\n    if (h < 0xC0) {\n\treturn h + 256;\n    }\n    else if (h < 0xE0) {\n\th *= mix;\n\th += x[1];\n    }\n    else if (h < 0xF0) {\n\th *= mix;\n\th += x[1];\n\th *= mix;\n\th += x[2];\n    }\n    else if (h < 0xF5) {\n\th *= mix;\n\th += x[1];\n\th *= mix;\n\th += x[2];\n\th *= mix;\n\th += x[3];\n    }\n    else {\n\treturn h + 256;\n    }\n    return (unsigned char)h;\n}", "target": 0}
{"code": "void PDFiumEngine::UpdateTickMarks() {\n  std::vector<pp::Rect> tickmarks;\n  GetAllScreenRectsUnion(&find_results_, pp::Point(0, 0), &tickmarks);\n  client_->UpdateTickMarks(tickmarks);\n}", "target": 0}
{"code": "void mysql_set_local_infile_default(MYSQL *mysql)\n{\n  mysql->options.local_infile_init=  default_local_infile_init;\n  mysql->options.local_infile_read=  default_local_infile_read;\n  mysql->options.local_infile_end=   default_local_infile_end;\n  mysql->options.local_infile_error= default_local_infile_error;\n}", "target": 0}
{"code": "scoped_ptr<EdgeEffectBase> OverscrollControllerAndroid::CreateEdgeEffect() {\n  return CreateGlowEdgeEffect(&compositor_->GetResourceManager(), dpi_scale_);\n}", "target": 0}
{"code": "Item *Item_hex_constant::safe_charset_converter(CHARSET_INFO *tocs)\n{\n  Item_string *conv;\n  String tmp, *str= val_str(&tmp);\n  if (!(conv= new Item_string(str->ptr(), str->length(), tocs)))\n    return NULL;\n  conv->str_value.copy();\n  conv->str_value.mark_as_const();\n  return conv;\n}", "target": 0}
{"code": "static void phys_page_compact_all(AddressSpaceDispatch *d, int nodes_nb)\n{\n    DECLARE_BITMAP(compacted, nodes_nb);\n    if (d->phys_map.skip) {\n        phys_page_compact(&d->phys_map, d->map.nodes, compacted);\n    }\n}", "target": 0}
{"code": "      void decode_xml(XMLObj *obj) {\n        RGWXMLDecoder::decode_xml(\"AccessControlTranslation\", acl_translation, obj);\n        RGWXMLDecoder::decode_xml(\"Account\", account, obj);\n        if (account && account->empty()) {\n          account.reset();\n        }\n        RGWXMLDecoder::decode_xml(\"Bucket\", bucket, obj);\n        RGWXMLDecoder::decode_xml(\"StorageClass\", storage_class, obj);\n        if (storage_class && storage_class->empty()) {\n          storage_class.reset();\n        }\n        RGWXMLDecoder::decode_xml(\"Zone\", zone_names, obj); \n      }", "target": 0}
{"code": "bool GLSurfaceOzoneEGL::Initialize(gfx::GLSurface::Format format) {\n  format_ = format;\n  return Initialize(ozone_surface_->CreateVSyncProvider());\n}", "target": 0}
{"code": "tagstack_clear(win_T *wp)\n{\n    int i;\n    for (i = 0; i < wp->w_tagstacklen; ++i)\n\ttagstack_clear_entry(&wp->w_tagstack[i]);\n    wp->w_tagstacklen = 0;\n    wp->w_tagstackidx = 0;\n}", "target": 0}
{"code": "GainNode* AudioContext::createGain()\n{\n    ASSERT(isMainThread());\n    return GainNode::create(this, m_destinationNode->sampleRate());\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::DidReceiveFirstFrameAfterNavigation() {\n  DCHECK(enable_surface_synchronization_);\n  if (!new_content_rendering_timeout_ ||\n      !new_content_rendering_timeout_->IsRunning()) {\n    return;\n  }\n   new_content_rendering_timeout_->Stop();\n }", "target": 0}
{"code": "init_seps (enum url_scheme scheme)\n{\n  static char seps[8] = \":/\";\n  char *p = seps + 2;\n  int flags = supported_schemes[scheme].flags;\n  if (flags & scm_has_params)\n    *p++ = ';';\n  if (flags & scm_has_query)\n    *p++ = '?';\n  if (flags & scm_has_fragment)\n    *p++ = '#';\n  *p = '\\0';\n  return seps;\n}", "target": 0}
{"code": "static MagickBooleanType GetTIFFInfo(const ImageInfo *image_info,\n  TIFF *tiff,TIFFInfo *tiff_info)\n{\n  const char\n    *option;\n  MagickStatusType\n    flags;\n  uint32\n    tile_columns,\n    tile_rows;\n  assert(tiff_info != (TIFFInfo *) NULL);\n  (void) memset(tiff_info,0,sizeof(*tiff_info));\n  option=GetImageOption(image_info,\"tiff:tile-geometry\");\n  if (option == (const char *) NULL)\n    {\n      uint32\n        rows_per_strip;\n      option=GetImageOption(image_info,\"tiff:rows-per-strip\");\n      if (option != (const char *) NULL)\n        rows_per_strip=(size_t) strtol(option,(char **) NULL,10);\n      else\n        if (TIFFGetField(tiff,TIFFTAG_IMAGELENGTH,&rows_per_strip) == 0)\n          rows_per_strip=0;  \n      rows_per_strip=TIFFDefaultStripSize(tiff,rows_per_strip);\n      (void) TIFFSetField(tiff,TIFFTAG_ROWSPERSTRIP,rows_per_strip);\n      return(MagickTrue);\n    }\n  flags=ParseAbsoluteGeometry(option,&tiff_info->tile_geometry);\n  if ((flags & HeightValue) == 0)\n    tiff_info->tile_geometry.height=tiff_info->tile_geometry.width;\n  tile_columns=(uint32) tiff_info->tile_geometry.width;\n  tile_rows=(uint32) tiff_info->tile_geometry.height;\n  TIFFDefaultTileSize(tiff,&tile_columns,&tile_rows);\n  (void) TIFFSetField(tiff,TIFFTAG_TILEWIDTH,tile_columns);\n  (void) TIFFSetField(tiff,TIFFTAG_TILELENGTH,tile_rows);\n  tiff_info->tile_geometry.width=tile_columns;\n  tiff_info->tile_geometry.height=tile_rows;\n  if ((TIFFScanlineSize(tiff) <= 0) || (TIFFTileSize(tiff) <= 0))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  tiff_info->scanlines=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFScanlineSize(tiff),sizeof(*tiff_info->scanlines));\n  tiff_info->pixels=(unsigned char *) AcquireQuantumMemory((size_t)\n    tile_rows*TIFFTileSize(tiff),sizeof(*tiff_info->scanlines));\n  if ((tiff_info->scanlines == (unsigned char *) NULL) ||\n      (tiff_info->pixels == (unsigned char *) NULL))\n    {\n      DestroyTIFFInfo(tiff_info);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}", "target": 0}
{"code": "static void hardware_disable_all(void)\n{\n\traw_spin_lock(&kvm_lock);\n\thardware_disable_all_nolock();\n\traw_spin_unlock(&kvm_lock);\n}", "target": 0}
{"code": "internal_sanitize_pin_info(struct sc_pin_cmd_pin *pin, unsigned int num)\n{\n\tpin->encoding = SC_PIN_ENCODING_ASCII;\n\tpin->min_length = 4;\n\tpin->max_length = 16;\n\tpin->pad_length = 16;\n\tpin->offset = 5 + num * 16;\n\tpin->pad_char = 0x00;\n}", "target": 0}
{"code": "find_control(const uschar * name, control_def * ol, int last)\n{\nint first = 0;\nwhile (last > first)\n  {\n  int middle = (first + last)/2;\n  uschar * s =  ol[middle].name;\n  int c = Ustrncmp(name, s, Ustrlen(s));\n  if (c == 0) return middle;\n  else if (c > 0) first = middle + 1;\n  else last = middle;\n  }\nreturn -1;\n}", "target": 0}
{"code": "static int parsedecBN(BIGNUM **out, const char *in)\n{\n    *out = NULL;\n    return BN_dec2bn(out, in);\n}", "target": 0}
{"code": "DECLARESepPutFunc(putRGBUAseparate8bittile)\n{\n\t(void) img; (void) y;\n\twhile (h-- > 0) {\n\t\tuint32 rv, gv, bv, av;\n\t\tuint8* m;\n\t\tfor (x = w; x-- > 0;) {\n\t\t\tav = *a++;\n\t\t\tm = img->UaToAa+(av<<8);\n\t\t\trv = m[*r++];\n\t\t\tgv = m[*g++];\n\t\t\tbv = m[*b++];\n\t\t\t*cp++ = PACK4(rv,gv,bv,av);\n\t\t}\n\t\tSKEW4(r, g, b, a, fromskew);\n\t\tcp += toskew;\n\t}\n}", "target": 0}
{"code": "loff_t default_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct inode *inode = file_inode(file);\n\tloff_t retval;\n\tmutex_lock(&inode->i_mutex);\n\tswitch (whence) {\n\t\tcase SEEK_END:\n\t\t\toffset += i_size_read(inode);\n\t\t\tbreak;\n\t\tcase SEEK_CUR:\n\t\t\tif (offset == 0) {\n\t\t\t\tretval = file->f_pos;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset += file->f_pos;\n\t\t\tbreak;\n\t\tcase SEEK_DATA:\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SEEK_HOLE:\n\t\t\tif (offset >= inode->i_size) {\n\t\t\t\tretval = -ENXIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset = inode->i_size;\n\t\t\tbreak;\n\t}\n\tretval = -EINVAL;\n\tif (offset >= 0 || unsigned_offsets(file)) {\n\t\tif (offset != file->f_pos) {\n\t\t\tfile->f_pos = offset;\n\t\t\tfile->f_version = 0;\n\t\t}\n\t\tretval = offset;\n\t}\nout:\n\tmutex_unlock(&inode->i_mutex);\n\treturn retval;\n}", "target": 0}
{"code": "vte_sequence_handler_mp (VteTerminal *terminal, GValueArray *params)\n{\n}", "target": 0}
{"code": "static void GetMedianPixelList(PixelList *pixel_list,MagickPixelPacket *pixel)\n{\n  SkipList\n    *list;\n  ssize_t\n    channel;\n  size_t\n    color;\n  ssize_t\n    count;\n  unsigned short\n    channels[ListChannels];\n  for (channel=0; channel < 5; channel++)\n  {\n    list=pixel_list->lists+channel;\n    color=65536L;\n    count=0;\n    do\n    {\n      color=list->nodes[color].next[0];\n      count+=list->nodes[color].count;\n    } while (count <= (ssize_t) (pixel_list->length >> 1));\n    channels[channel]=(unsigned short) color;\n  }\n  GetMagickPixelPacket((const Image *) NULL,pixel);\n  pixel->red=(MagickRealType) ScaleShortToQuantum(channels[0]);\n  pixel->green=(MagickRealType) ScaleShortToQuantum(channels[1]);\n  pixel->blue=(MagickRealType) ScaleShortToQuantum(channels[2]);\n  pixel->opacity=(MagickRealType) ScaleShortToQuantum(channels[3]);\n  pixel->index=(MagickRealType) ScaleShortToQuantum(channels[4]);\n}", "target": 0}
{"code": "static VirtioNetRscChain *virtio_net_rsc_lookup_chain(VirtIONet *n,\n                                                      NetClientState *nc,\n                                                      uint16_t proto)\n{\n    VirtioNetRscChain *chain;\n    if ((proto != (uint16_t)ETH_P_IP) && (proto != (uint16_t)ETH_P_IPV6)) {\n        return NULL;\n    }\n    QTAILQ_FOREACH(chain, &n->rsc_chains, next) {\n        if (chain->proto == proto) {\n            return chain;\n        }\n    }\n    chain = g_malloc(sizeof(*chain));\n    chain->n = n;\n    chain->proto = proto;\n    if (proto == (uint16_t)ETH_P_IP) {\n        chain->max_payload = VIRTIO_NET_MAX_IP4_PAYLOAD;\n        chain->gso_type = VIRTIO_NET_HDR_GSO_TCPV4;\n    } else {\n        chain->max_payload = VIRTIO_NET_MAX_IP6_PAYLOAD;\n        chain->gso_type = VIRTIO_NET_HDR_GSO_TCPV6;\n    }\n    chain->drain_timer = timer_new_ns(QEMU_CLOCK_HOST,\n                                      virtio_net_rsc_purge, chain);\n    memset(&chain->stat, 0, sizeof(chain->stat));\n    QTAILQ_INIT(&chain->buffers);\n    QTAILQ_INSERT_TAIL(&n->rsc_chains, chain, next);\n    return chain;\n}", "target": 0}
{"code": "int kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP |\n\t\t\t\t    X86_CR0_CD | X86_CR0_NW;\n\tcr0 |= X86_CR0_ET;\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\tcr0 &= ~CR0_RESERVED_BITS;\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\tkvm_x86_ops->set_cr0(vcpu, cr0);\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\treturn 0;\n}", "target": 0}
{"code": "xfs_attr_shortform_add(xfs_da_args_t *args, int forkoff)\n{\n\txfs_attr_shortform_t *sf;\n\txfs_attr_sf_entry_t *sfe;\n\tint i, offset, size;\n\txfs_mount_t *mp;\n\txfs_inode_t *dp;\n\txfs_ifork_t *ifp;\n\ttrace_xfs_attr_sf_add(args);\n\tdp = args->dp;\n\tmp = dp->i_mount;\n\tdp->i_d.di_forkoff = forkoff;\n\tifp = dp->i_afp;\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = &sf->list[0];\n\tfor (i = 0; i < sf->hdr.count; sfe = XFS_ATTR_SF_NEXTENTRY(sfe), i++) {\n#ifdef DEBUG\n\t\tif (sfe->namelen != args->namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(args->name, sfe->nameval, args->namelen) != 0)\n\t\t\tcontinue;\n\t\tif (!xfs_attr_namesp_match(args->flags, sfe->flags))\n\t\t\tcontinue;\n\t\tASSERT(0);\n#endif\n\t}\n\toffset = (char *)sfe - (char *)sf;\n\tsize = XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\n\tsf = (xfs_attr_shortform_t *)ifp->if_u1.if_data;\n\tsfe = (xfs_attr_sf_entry_t *)((char *)sf + offset);\n\tsfe->namelen = args->namelen;\n\tsfe->valuelen = args->valuelen;\n\tsfe->flags = XFS_ATTR_NSP_ARGS_TO_ONDISK(args->flags);\n\tmemcpy(sfe->nameval, args->name, args->namelen);\n\tmemcpy(&sfe->nameval[args->namelen], args->value, args->valuelen);\n\tsf->hdr.count++;\n\tbe16_add_cpu(&sf->hdr.totsize, size);\n\txfs_trans_log_inode(args->trans, dp, XFS_ILOG_CORE | XFS_ILOG_ADATA);\n\txfs_sbversion_add_attr2(mp, args->trans);\n}", "target": 0}
{"code": "void WasmBinaryBuilder::readFunctionSignatures() {\n  BYN_TRACE(\"== readFunctionSignatures\\n\");\n  size_t num = getU32LEB();\n  BYN_TRACE(\"num: \" << num << std::endl);\n  for (size_t i = 0; i < num; i++) {\n    BYN_TRACE(\"read one\\n\");\n    auto index = getU32LEB();\n    functionTypes.push_back(getTypeByIndex(index));\n    getSignatureByTypeIndex(index);\n  }\n}", "target": 0}
{"code": "static void AddInstanceStatsToMap(\n    const int32_t instance, const int32_t feature_dim, const int32_t bucket_id,\n    const int32_t logits_dims, const int32_t stats_dims,\n    StatsPartitionMap* stats_map, const TTypes<float>::ConstMatrix& gradients,\n    const TTypes<float>::ConstMatrix& hessians,\n    const TTypes<int32>::ConstVec& node_ids) {\n  const int32_t node_id = node_ids(instance);\n  const auto key = StatsPartitionKey(node_id, feature_dim, bucket_id);\n  std::pair<StatsPartitionIterator, bool> const& insert_result =\n      stats_map->insert(StatsPartitionIterator::value_type(\n          key, std::vector<float>(stats_dims, 0.0f)));\n  auto& stats = insert_result.first->second;\n  for (int stat_dim = 0; stat_dim < logits_dims; ++stat_dim) {\n    stats[stat_dim] += gradients(instance, stat_dim);\n  }\n  for (int stat_dim = logits_dims; stat_dim < stats_dims; ++stat_dim) {\n    stats[stat_dim] += hessians(instance, stat_dim - logits_dims);\n  }\n}", "target": 0}
{"code": "static int getFillIdx(SWFShape shape, SWFFillStyle fill)\n{\n\tint i;\n\tfor ( i=0; i<shape->nFills; ++i )\n\t{\n\t\tif ( SWFFillStyle_equals(fill, shape->fills[i]) )\n\t\t\treturn (i+1);\n\t}\n\treturn 0; \n}", "target": 0}
{"code": "TEST_F(ZNCTest, Modpython) {\n    if (QProcessEnvironment::systemEnvironment().value(\n            \"DISABLED_ZNC_PERL_PYTHON_TEST\") == \"1\") {\n        return;\n    }\n    auto znc = Run();\n    znc->CanLeak();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"znc loadmod modpython\");\n    client.Write(\"znc loadmod pyeval\");\n    client.Write(\"PRIVMSG *pyeval :2+2\");\n    client.ReadUntil(\":*pyeval!znc@znc.in PRIVMSG nick :4\");\n    client.Write(\"PRIVMSG *pyeval :module.GetUser().GetUserName()\");\n    client.ReadUntil(\"nick :'user'\");\n    ircd.Write(\":server 001 nick :Hello\");\n    ircd.Write(\":n!u@h PRIVMSG nick :Hi\\xF0, github issue #1229\");\n    client.ReadUntil(\"Hi\\xEF\\xBF\\xBD, github issue\");\n    client.Write(\"PRIVMSG *controlpanel :Set ClientEncoding $me Western\");\n    client.Write(\"JOIN #a\\342\");\n    client.ReadUntil(\n        \":*controlpanel!znc@znc.in PRIVMSG nick :ClientEncoding = UTF-8\");\n    ircd.ReadUntil(\"JOIN #a\\xEF\\xBF\\xBD\");\n}", "target": 0}
{"code": "static int check_excludes(struct perf_event **ctrs, unsigned int cflags[],\n\t\t\t  int n_prev, int n_new)\n{\n\tint eu = 0, ek = 0, eh = 0;\n\tint i, n, first;\n\tstruct perf_event *event;\n\tn = n_prev + n_new;\n\tif (n <= 1)\n\t\treturn 0;\n\tfirst = 1;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (cflags[i] & PPMU_LIMITED_PMC_OK) {\n\t\t\tcflags[i] &= ~PPMU_LIMITED_PMC_REQD;\n\t\t\tcontinue;\n\t\t}\n\t\tevent = ctrs[i];\n\t\tif (first) {\n\t\t\teu = event->attr.exclude_user;\n\t\t\tek = event->attr.exclude_kernel;\n\t\t\teh = event->attr.exclude_hv;\n\t\t\tfirst = 0;\n\t\t} else if (event->attr.exclude_user != eu ||\n\t\t\t   event->attr.exclude_kernel != ek ||\n\t\t\t   event->attr.exclude_hv != eh) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\tif (eu || ek || eh)\n\t\tfor (i = 0; i < n; ++i)\n\t\t\tif (cflags[i] & PPMU_LIMITED_PMC_OK)\n\t\t\t\tcflags[i] |= PPMU_LIMITED_PMC_REQD;\n\treturn 0;\n}", "target": 0}
{"code": "d_lite_downto(VALUE self, VALUE min)\n{\n    VALUE date;\n    RETURN_ENUMERATOR(self, 1, &min);\n    date = self;\n    while (FIX2INT(d_lite_cmp(date, min)) >= 0) {\n\trb_yield(date);\n\tdate = d_lite_plus(date, INT2FIX(-1));\n    }\n    return self;\n}", "target": 0}
{"code": "static inline void tcp_rcv_rtt_measure(struct tcp_sock *tp)\n{\n\tif (tp->rcv_rtt_est.time == 0)\n\t\tgoto new_measure;\n\tif (before(tp->rcv_nxt, tp->rcv_rtt_est.seq))\n\t\treturn;\n\ttcp_rcv_rtt_update(tp, jiffies - tp->rcv_rtt_est.time, 1);\nnew_measure:\n\ttp->rcv_rtt_est.seq = tp->rcv_nxt + tp->rcv_wnd;\n\ttp->rcv_rtt_est.time = tcp_time_stamp;\n}", "target": 0}
{"code": "find_slot_for_token(cms_context *cms, PK11SlotInfo **slot)\n{\n\tif (!cms->tokenname) {\n\t\tcms->log(cms, LOG_ERR, \"no token name specified\");\n\t\treturn -1;\n\t}\n\tPK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);\n\tPK11SlotList *slots = NULL;\n\tslots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, cms);\n\tif (!slots)\n\t\tcmsreterr(-1, cms, \"could not get pk11 token list\");\n\tPK11SlotListElement *psle = NULL;\n\tpsle = PK11_GetFirstSafe(slots);\n\tif (!psle) {\n\t\tsave_port_err() {\n\t\t\tPK11_FreeSlotList(slots);\n\t\t}\n\t\tcmsreterr(-1, cms, \"could not get pk11 safe\");\n\t}\n\twhile (psle) {\n\t\tif (!strcmp(cms->tokenname, PK11_GetTokenName(psle->slot)))\n\t\t\tbreak;\n\t\tpsle = PK11_GetNextSafe(slots, psle, PR_FALSE);\n\t}\n\tif (!psle) {\n\t\tsave_port_err() {\n\t\t\tPK11_FreeSlotList(slots);\n\t\t}\n\t\tnssreterr(-1, \"Could not find token \\\"%s\\\"\", cms->tokenname);\n\t}\n\tSECStatus status;\n\tif (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, cms)) {\n\t\tstatus = PK11_Authenticate(psle->slot, PR_TRUE, cms);\n\t\tif (status != SECSuccess) {\n\t\t\tsave_port_err() {\n\t\t\t\tPK11_DestroySlotListElement(slots, &psle);\n\t\t\t\tPK11_FreeSlotList(slots);\n\t\t\t\tcms->log(cms, LOG_ERR,\n\t\t\t\t\t \"authentication failed for token \\\"%s\\\"\",\n\t\t\t\t\t cms->tokenname);\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\t*slot = psle->slot;\n\treturn 0;\n}", "target": 0}
{"code": "do_encrypt(gcry_mpi_t a, gcry_mpi_t b, gcry_mpi_t input, ELG_public_key *pkey )\n{\n  gcry_mpi_t k;\n  k = gen_k( pkey->p, 1 );\n  mpi_powm (a, pkey->g, k, pkey->p);\n  mpi_powm (b, pkey->y, k, pkey->p);\n  mpi_mulm (b, b, input, pkey->p);\n#if 0\n  if( DBG_CIPHER )\n    {\n      log_mpidump(\"elg encrypted y\", pkey->y);\n      log_mpidump(\"elg encrypted p\", pkey->p);\n      log_mpidump(\"elg encrypted k\", k);\n      log_mpidump(\"elg encrypted M\", input);\n      log_mpidump(\"elg encrypted a\", a);\n      log_mpidump(\"elg encrypted b\", b);\n    }\n#endif\n  mpi_free(k);\n}", "target": 0}
{"code": "static int netsnmp_session_set_security(struct snmp_session *session, char *sec_level, char *auth_protocol, char *auth_passphrase, char *priv_protocol, char *priv_passphrase, char *contextName, char *contextEngineID)\n{\n\tif (netsnmp_session_set_sec_level(session, sec_level)) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Invalid security level '%s'\", sec_level);\n\t\treturn (-1);\n\t}\n\tif (session->securityLevel == SNMP_SEC_LEVEL_AUTHNOPRIV || session->securityLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n\t\tif (netsnmp_session_set_auth_protocol(session, auth_protocol)) {\n\t\t\treturn (-1);\n\t\t}\n\t\tif (netsnmp_session_gen_auth_key(session, auth_passphrase)) {\n\t\t\treturn (-1);\n\t\t}\n\t\tif (session->securityLevel == SNMP_SEC_LEVEL_AUTHPRIV) {\n\t\t\tif (netsnmp_session_set_sec_protocol(session, priv_protocol)) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t\tif (netsnmp_session_gen_sec_key(session, priv_passphrase)) {\n\t\t\t\treturn (-1);\n\t\t\t}\n\t\t}\n\t}\n\tif (contextName) {\n\t\tsession->contextName = contextName;\n\t\tsession->contextNameLen = strlen(contextName);\n\t}\n\tif (contextEngineID && strlen(contextEngineID) && netsnmp_session_set_contextEngineID(session, contextEngineID)) {\n\t\treturn (-1);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "gx_dc_pattern2_get_color_space(const gx_device_color * pdevc)\n{\n    gs_pattern2_instance_t *pinst =\n        (gs_pattern2_instance_t *)pdevc->ccolor.pattern;\n    const gs_shading_t *psh = pinst->templat.Shading;\n    return psh->params.ColorSpace;\n}", "target": 0}
{"code": "void stat_init_node(RedStatNode *node, SpiceServer *reds, const RedStatNode *parent,\n                    const char *name, int visible)\n{\n    StatNodeRef parent_ref = parent ? parent->ref : INVALID_STAT_REF;\n    node->ref = stat_file_add_node(reds->stat_file, parent_ref, name, visible);\n}", "target": 0}
{"code": "uint64_t HeaderMapImpl::byteSizeInternal() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 0}
{"code": "static struct btrfs_fs_devices *find_fsid_inprogress(\n\t\t\t\t\tstruct btrfs_super_block *disk_super)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tlist_for_each_entry(fs_devices, &fs_uuids, fs_list) {\n\t\tif (memcmp(fs_devices->metadata_uuid, fs_devices->fsid,\n\t\t\t   BTRFS_FSID_SIZE) != 0 &&\n\t\t    memcmp(fs_devices->metadata_uuid, disk_super->fsid,\n\t\t\t   BTRFS_FSID_SIZE) == 0 && !fs_devices->fsid_change) {\n\t\t\treturn fs_devices;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "inline SVGFEColorMatrixElement::SVGFEColorMatrixElement(Document& document)\n    : SVGFilterPrimitiveStandardAttributes(SVGNames::feColorMatrixTag, document)\n    , m_values(SVGAnimatedNumberList::create(this, SVGNames::valuesAttr, SVGNumberList::create()))\n    , m_in1(SVGAnimatedString::create(this, SVGNames::inAttr, SVGString::create()))\n    , m_type(SVGAnimatedEnumeration<ColorMatrixType>::create(this, SVGNames::typeAttr, FECOLORMATRIX_TYPE_MATRIX))\n{\n    addToPropertyMap(m_values);\n    addToPropertyMap(m_in1);\n    addToPropertyMap(m_type);\n}", "target": 0}
{"code": "static inline Quantum ScaleShortToQuantum(const unsigned short value)\n{\n  return((Quantum) (281479271743489.0*value));\n}", "target": 0}
{"code": "static int unix_dgram_peer_wake_me(struct sock *sk, struct sock *other)\n{\n\tint connected;\n\tconnected = unix_dgram_peer_wake_connect(sk, other);\n\tif (unix_recvq_full(other))\n\t\treturn 1;\n\tif (connected)\n\t\tunix_dgram_peer_wake_disconnect(sk, other);\n\treturn 0;\n}", "target": 0}
{"code": "static int kvm_vm_ioctl_set_tss_addr(struct kvm *kvm, unsigned long addr)\n{\n\tint ret;\n\tif (addr > (unsigned int)(-3 * PAGE_SIZE))\n\t\treturn -EINVAL;\n\tret = kvm_x86_ops->set_tss_addr(kvm, addr);\n\treturn ret;\n}", "target": 0}
{"code": "set_num_721(unsigned char *p, uint16_t value)\n{\n\tarchive_le16enc(p, value);\n}", "target": 0}
{"code": "match_highlight(const char *teststr, zattr *on_var)\n{\n    int found = 1;\n    *on_var = 0;\n    while (found && *teststr) {\n\tconst struct highlight *hl;\n\tfound = 0;\n\tif (strpfx(\"fg=\", teststr) || strpfx(\"bg=\", teststr)) {\n\t    int is_fg = (teststr[0] == 'f');\n\t    zattr atr;\n\t    teststr += 3;\n\t    atr = match_colour(&teststr, is_fg, 0);\n\t    if (*teststr == ',')\n\t\tteststr++;\n\t    else if (*teststr)\n\t\tbreak;\n\t    found = 1;\n\t    if (atr != TXT_ERROR)\n\t\t*on_var |= atr;\n\t} else {\n\t    for (hl = highlights; hl->name; hl++) {\n\t\tif (strpfx(hl->name, teststr)) {\n\t\t    const char *val = teststr + strlen(hl->name);\n\t\t    if (*val == ',')\n\t\t\tval++;\n\t\t    else if (*val)\n\t\t\tbreak;\n\t\t    *on_var |= hl->mask_on;\n\t\t    *on_var &= ~hl->mask_off;\n\t\t    teststr = val;\n\t\t    found = 1;\n\t\t}\n\t    }\n\t}\n    }\n}", "target": 0}
{"code": "void sk_stop_timer(struct sock *sk, struct timer_list* timer)\n{\n\tif (timer_pending(timer) && del_timer(timer))\n\t\t__sock_put(sk);\n}", "target": 0}
{"code": "static int bnx2x_set_spio(struct bnx2x *bp, int spio, u32 mode)\n{\n\tu32 spio_reg;\n\tif ((spio != MISC_SPIO_SPIO4) && (spio != MISC_SPIO_SPIO5)) {\n\t\tBNX2X_ERR(\"Invalid SPIO 0x%x\\n\", spio);\n\t\treturn -EINVAL;\n\t}\n\tbnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_SPIO);\n\tspio_reg = (REG_RD(bp, MISC_REG_SPIO) & MISC_SPIO_FLOAT);\n\tswitch (mode) {\n\tcase MISC_SPIO_OUTPUT_LOW:\n\t\tDP(NETIF_MSG_HW, \"Set SPIO 0x%x -> output low\\n\", spio);\n\t\tspio_reg &= ~(spio << MISC_SPIO_FLOAT_POS);\n\t\tspio_reg |=  (spio << MISC_SPIO_CLR_POS);\n\t\tbreak;\n\tcase MISC_SPIO_OUTPUT_HIGH:\n\t\tDP(NETIF_MSG_HW, \"Set SPIO 0x%x -> output high\\n\", spio);\n\t\tspio_reg &= ~(spio << MISC_SPIO_FLOAT_POS);\n\t\tspio_reg |=  (spio << MISC_SPIO_SET_POS);\n\t\tbreak;\n\tcase MISC_SPIO_INPUT_HI_Z:\n\t\tDP(NETIF_MSG_HW, \"Set SPIO 0x%x -> input\\n\", spio);\n\t\tspio_reg |= (spio << MISC_SPIO_FLOAT_POS);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tREG_WR(bp, MISC_REG_SPIO, spio_reg);\n\tbnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_SPIO);\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err akey_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_full_box_write(s, bs);\n}", "target": 0}
{"code": "static void inet6_ifa_notify(int event, struct inet6_ifaddr *ifa)\n{\n\tstruct sk_buff *skb;\n\tstruct net *net = dev_net(ifa->idev->dev);\n\tint err = -ENOBUFS;\n\tskb = nlmsg_new(inet6_ifaddr_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\tgoto errout;\n\terr = inet6_fill_ifaddr(skb, ifa, 0, 0, event, 0);\n\tif (err < 0) {\n\t\tWARN_ON(err == -EMSGSIZE);\n\t\tkfree_skb(skb);\n\t\tgoto errout;\n\t}\n\trtnl_notify(skb, net, 0, RTNLGRP_IPV6_IFADDR, NULL, GFP_ATOMIC);\n\treturn;\nerrout:\n\tif (err < 0)\n\t\trtnl_set_sk_err(net, RTNLGRP_IPV6_IFADDR, err);\n}", "target": 0}
{"code": "void __free_pages(struct page *page, unsigned int order)\n{\n\tif (put_page_testzero(page)) {\n\t\tif (order == 0)\n\t\t\tfree_unref_page(page);\n\t\telse\n\t\t\t__free_pages_ok(page, order);\n\t}\n}", "target": 0}
{"code": "TextTrackContainer& HTMLMediaElement::EnsureTextTrackContainer() {\n  ShadowRoot& shadow_root = EnsureUserAgentShadowRoot();\n  AssertShadowRootChildren(shadow_root);\n  Node* first_child = shadow_root.firstChild();\n  if (first_child && first_child->IsTextTrackContainer())\n    return ToTextTrackContainer(*first_child);\n  Node* to_be_inserted = first_child;\n  if (first_child && (first_child->IsMediaRemotingInterstitial() ||\n                      first_child->IsPictureInPictureInterstitial())) {\n    Node* second_child = first_child->nextSibling();\n    if (second_child && second_child->IsTextTrackContainer())\n      return ToTextTrackContainer(*second_child);\n    to_be_inserted = second_child;\n  }\n  TextTrackContainer* text_track_container = TextTrackContainer::Create(*this);\n  shadow_root.InsertBefore(text_track_container, to_be_inserted);\n  AssertShadowRootChildren(shadow_root);\n  return *text_track_container;\n}", "target": 0}
{"code": "void AudioContext::removeMarkedAudioNodeOutput(AudioNodeOutput* output)\n{\n    ASSERT(isGraphOwner());\n    ASSERT(isMainThread());\n    m_dirtyAudioNodeOutputs.remove(output);\n}", "target": 0}
{"code": "static HashTable *spl_array_get_gc(zval *object, zval ***gc_data, int *gc_data_count TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\t*gc_data = &intern->array;\n\t*gc_data_count = 1;\n\treturn zend_std_get_properties(object);\n}", "target": 0}
{"code": "void __init sk_init(void)\n{\n\tif (totalram_pages <= 4096) {\n\t\tsysctl_wmem_max = 32767;\n\t\tsysctl_rmem_max = 32767;\n\t\tsysctl_wmem_default = 32767;\n\t\tsysctl_rmem_default = 32767;\n\t} else if (totalram_pages >= 131072) {\n\t\tsysctl_wmem_max = 131071;\n\t\tsysctl_rmem_max = 131071;\n\t}\n}", "target": 0}
{"code": "void Browser::RegisterProtocolHandler(WebContents* web_contents,\n                                      const std::string& protocol,\n                                      const GURL& url,\n                                      bool user_gesture) {\n  content::BrowserContext* context = web_contents->GetBrowserContext();\n  if (context->IsOffTheRecord())\n    return;\n  ProtocolHandler handler =\n      ProtocolHandler::CreateProtocolHandler(protocol, url);\n  ProtocolHandlerRegistry* registry =\n      ProtocolHandlerRegistryFactory::GetForBrowserContext(context);\n  if (registry->SilentlyHandleRegisterHandlerRequest(handler))\n    return;\n  TabSpecificContentSettings* tab_content_settings =\n      TabSpecificContentSettings::FromWebContents(web_contents);\n  if (!user_gesture && window_) {\n    tab_content_settings->set_pending_protocol_handler(handler);\n    tab_content_settings->set_previous_protocol_handler(\n        registry->GetHandlerFor(handler.protocol()));\n    window_->GetLocationBar()->UpdateContentSettingsIcons();\n    return;\n  }\n  if (window_) {\n    tab_content_settings->ClearPendingProtocolHandler();\n    window_->GetLocationBar()->UpdateContentSettingsIcons();\n  }\n  PermissionRequestManager* permission_request_manager =\n      PermissionRequestManager::FromWebContents(web_contents);\n  if (permission_request_manager) {\n    permission_request_manager->AddRequest(\n        new RegisterProtocolHandlerPermissionRequest(registry, handler,\n                                                     url, user_gesture));\n  }\n}", "target": 0}
{"code": "static void pageset_update(struct per_cpu_pages *pcp, unsigned long high,\n\t\tunsigned long batch)\n{\n\tpcp->batch = 1;\n\tsmp_wmb();\n\tpcp->high = high;\n\tsmp_wmb();\n\tpcp->batch = batch;\n}", "target": 0}
{"code": "static bool tcp_fast_parse_options(const struct sk_buff *skb,\n\t\t\t\t   const struct tcphdr *th, struct tcp_sock *tp)\n{\n\tif (th->doff == (sizeof(*th) / 4)) {\n\t\ttp->rx_opt.saw_tstamp = 0;\n\t\treturn false;\n\t} else if (tp->rx_opt.tstamp_ok &&\n\t\t   th->doff == ((sizeof(*th) + TCPOLEN_TSTAMP_ALIGNED) / 4)) {\n\t\tif (tcp_parse_aligned_timestamp(tp, th))\n\t\t\treturn true;\n\t}\n\ttcp_parse_options(skb, &tp->rx_opt, 1, NULL);\n\tif (tp->rx_opt.saw_tstamp && tp->rx_opt.rcv_tsecr)\n\t\ttp->rx_opt.rcv_tsecr -= tp->tsoffset;\n\treturn true;\n}", "target": 0}
{"code": "static int add_mount(const char *source, const char *mnt, const char *type,\n\t\t     const char *opts)\n{\n\t(void) source;\n\t(void) mnt;\n\t(void) type;\n\t(void) opts;\n\treturn 0;\n}", "target": 0}
{"code": "void __init kmem_cache_init(void)\n{\n\tint i;\n\tint caches = 0;\n\tinit_alloc_cpu();\n#ifdef CONFIG_NUMA\n\tcreate_kmalloc_cache(&kmalloc_caches[0], \"kmem_cache_node\",\n\t\tsizeof(struct kmem_cache_node), GFP_KERNEL);\n\tkmalloc_caches[0].refcount = -1;\n\tcaches++;\n\thotplug_memory_notifier(slab_memory_callback, SLAB_CALLBACK_PRI);\n#endif\n\tslab_state = PARTIAL;\n\tif (KMALLOC_MIN_SIZE <= 64) {\n\t\tcreate_kmalloc_cache(&kmalloc_caches[1],\n\t\t\t\t\"kmalloc-96\", 96, GFP_KERNEL);\n\t\tcaches++;\n\t}\n\tif (KMALLOC_MIN_SIZE <= 128) {\n\t\tcreate_kmalloc_cache(&kmalloc_caches[2],\n\t\t\t\t\"kmalloc-192\", 192, GFP_KERNEL);\n\t\tcaches++;\n\t}\n\tfor (i = KMALLOC_SHIFT_LOW; i <= PAGE_SHIFT; i++) {\n\t\tcreate_kmalloc_cache(&kmalloc_caches[i],\n\t\t\t\"kmalloc\", 1 << i, GFP_KERNEL);\n\t\tcaches++;\n\t}\n\tBUILD_BUG_ON(KMALLOC_MIN_SIZE > 256 ||\n\t\t(KMALLOC_MIN_SIZE & (KMALLOC_MIN_SIZE - 1)));\n\tfor (i = 8; i < KMALLOC_MIN_SIZE; i += 8)\n\t\tsize_index[(i - 1) / 8] = KMALLOC_SHIFT_LOW;\n\tslab_state = UP;\n\tfor (i = KMALLOC_SHIFT_LOW; i <= PAGE_SHIFT; i++)\n\t\tkmalloc_caches[i]. name =\n\t\t\tkasprintf(GFP_KERNEL, \"kmalloc-%d\", 1 << i);\n#ifdef CONFIG_SMP\n\tregister_cpu_notifier(&slab_notifier);\n\tkmem_size = offsetof(struct kmem_cache, cpu_slab) +\n\t\t\t\tnr_cpu_ids * sizeof(struct kmem_cache_cpu *);\n#else\n\tkmem_size = sizeof(struct kmem_cache);\n#endif\n\tprintk(KERN_INFO\n\t\t\"SLUB: Genslabs=%d, HWalign=%d, Order=%d-%d, MinObjects=%d,\"\n\t\t\" CPUs=%d, Nodes=%d\\n\",\n\t\tcaches, cache_line_size(),\n\t\tslub_min_order, slub_max_order, slub_min_objects,\n\t\tnr_cpu_ids, nr_node_ids);\n}", "target": 0}
{"code": "xmlParseStringCharRef(xmlParserCtxtPtr ctxt, const xmlChar **str) {\n    const xmlChar *ptr;\n    xmlChar cur;\n    unsigned int val = 0;\n    unsigned int outofrange = 0;\n    if ((str == NULL) || (*str == NULL)) return(0);\n    ptr = *str;\n    cur = *ptr;\n    if ((cur == '&') && (ptr[1] == '#') && (ptr[2] == 'x')) {\n\tptr += 3;\n\tcur = *ptr;\n\twhile (cur != ';') { \n\t    if ((cur >= '0') && (cur <= '9'))\n\t        val = val * 16 + (cur - '0');\n\t    else if ((cur >= 'a') && (cur <= 'f'))\n\t        val = val * 16 + (cur - 'a') + 10;\n\t    else if ((cur >= 'A') && (cur <= 'F'))\n\t        val = val * 16 + (cur - 'A') + 10;\n\t    else {\n\t\txmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);\n\t\tval = 0;\n\t\tbreak;\n\t    }\n\t    if (val > 0x10FFFF)\n\t        outofrange = val;\n\t    ptr++;\n\t    cur = *ptr;\n\t}\n\tif (cur == ';')\n\t    ptr++;\n    } else if  ((cur == '&') && (ptr[1] == '#')){\n\tptr += 2;\n\tcur = *ptr;\n\twhile (cur != ';') { \n\t    if ((cur >= '0') && (cur <= '9'))\n\t        val = val * 10 + (cur - '0');\n\t    else {\n\t\txmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);\n\t\tval = 0;\n\t\tbreak;\n\t    }\n\t    if (val > 0x10FFFF)\n\t        outofrange = val;\n\t    ptr++;\n\t    cur = *ptr;\n\t}\n\tif (cur == ';')\n\t    ptr++;\n    } else {\n\txmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);\n\treturn(0);\n    }\n    *str = ptr;\n    if ((IS_CHAR(val) && (outofrange == 0))) {\n        return(val);\n    } else {\n        xmlFatalErrMsgInt(ctxt, XML_ERR_INVALID_CHAR,\n\t\t\t  \"xmlParseStringCharRef: invalid xmlChar value %d\\n\",\n\t\t\t  val);\n    }\n    return(0);\n}", "target": 0}
{"code": "ok_png ok_png_read_from_input(ok_png_decode_flags decode_flags,\n                              ok_png_input input_callbacks, void *input_callbacks_user_data,\n                              ok_png_allocator allocator, void *allocator_user_data) {\n    ok_png png = { 0 };\n    ok_png_decode(&png, decode_flags, input_callbacks, input_callbacks_user_data,\n                  allocator, allocator_user_data);\n    return png;\n}", "target": 0}
{"code": "size_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPHeaders& trailers) {\n  VLOG(4) << \"generating TRAILERS for stream=\" << stream;\n  std::vector<compress::Header> allHeaders;\n  CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n  HTTPHeaderSize size;\n  auto out = encodeHeaders(trailers, allHeaders, &size);\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto remainingFrameSize = maxFrameSize;\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n    bool endHeaders = queue.chainLength() == 0;\n    generateHeaderCallbackWrapper(stream,\n                                  http2::FrameType::HEADERS,\n                                  http2::writeHeaders(writeBuf,\n                                                      std::move(chunk),\n                                                      stream,\n                                                      pri,\n                                                      http2::kNoPadding,\n                                                      true ,\n                                                      endHeaders));\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n  return size.compressed;\n}", "target": 0}
{"code": "void btrfs_free_extra_devids(struct btrfs_fs_devices *fs_devices, int step)\n{\n\tstruct btrfs_device *device, *next;\n\tstruct btrfs_device *latest_dev = NULL;\n\tmutex_lock(&uuid_mutex);\nagain:\n\tlist_for_each_entry_safe(device, next, &fs_devices->devices, dev_list) {\n\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t\t\t\t&device->dev_state)) {\n\t\t\tif (!test_bit(BTRFS_DEV_STATE_REPLACE_TGT,\n\t\t\t     &device->dev_state) &&\n\t\t\t     (!latest_dev ||\n\t\t\t      device->generation > latest_dev->generation)) {\n\t\t\t\tlatest_dev = device;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (device->devid == BTRFS_DEV_REPLACE_DEVID) {\n\t\t\tif (step == 0 || test_bit(BTRFS_DEV_STATE_REPLACE_TGT,\n\t\t\t\t\t\t  &device->dev_state)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (device->bdev) {\n\t\t\tblkdev_put(device->bdev, device->mode);\n\t\t\tdevice->bdev = NULL;\n\t\t\tfs_devices->open_devices--;\n\t\t}\n\t\tif (test_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state)) {\n\t\t\tlist_del_init(&device->dev_alloc_list);\n\t\t\tclear_bit(BTRFS_DEV_STATE_WRITEABLE, &device->dev_state);\n\t\t\tif (!test_bit(BTRFS_DEV_STATE_REPLACE_TGT,\n\t\t\t\t      &device->dev_state))\n\t\t\t\tfs_devices->rw_devices--;\n\t\t}\n\t\tlist_del_init(&device->dev_list);\n\t\tfs_devices->num_devices--;\n\t\tbtrfs_free_device(device);\n\t}\n\tif (fs_devices->seed) {\n\t\tfs_devices = fs_devices->seed;\n\t\tgoto again;\n\t}\n\tfs_devices->latest_bdev = latest_dev->bdev;\n\tmutex_unlock(&uuid_mutex);\n}", "target": 0}
{"code": "static void create_pit_timer(struct kvm_kpit_state *ps, u32 val, int is_period)\n{\n\tstruct kvm_timer *pt = &ps->pit_timer;\n\ts64 interval;\n\tinterval = muldiv64(val, NSEC_PER_SEC, KVM_PIT_FREQ);\n\tpr_debug(\"create pit timer, interval is %llu nsec\\n\", interval);\n\thrtimer_cancel(&pt->timer);\n\tpt->period = interval;\n\tps->is_periodic = is_period;\n\tpt->timer.function = kvm_timer_fn;\n\tpt->t_ops = &kpit_ops;\n\tpt->kvm = ps->pit->kvm;\n\tpt->vcpu = pt->kvm->bsp_vcpu;\n\tatomic_set(&pt->pending, 0);\n\tps->irq_ack = 1;\n\thrtimer_start(&pt->timer, ktime_add_ns(ktime_get(), interval),\n\t\t      HRTIMER_MODE_ABS);\n}", "target": 0}
{"code": "bool tipc_node_get_id(struct net *net, u32 addr, u8 *id)\n{\n\tu8 *own_id = tipc_own_id(net);\n\tstruct tipc_node *n;\n\tif (!own_id)\n\t\treturn true;\n\tif (addr == tipc_own_addr(net)) {\n\t\tmemcpy(id, own_id, TIPC_NODEID_LEN);\n\t\treturn true;\n\t}\n\tn = tipc_node_find(net, addr);\n\tif (!n)\n\t\treturn false;\n\tmemcpy(id, &n->peer_id, TIPC_NODEID_LEN);\n\ttipc_node_put(n);\n\treturn true;\n}", "target": 0}
{"code": "    int16_t getShort(const byte* buf, ByteOrder byteOrder)\n    {\n        if (byteOrder == littleEndian) {\n            return (byte)buf[1] << 8 | (byte)buf[0];\n        }\n        else {\n            return (byte)buf[0] << 8 | (byte)buf[1];\n        }\n    }", "target": 0}
{"code": "static av_cold int decode_init(AVCodecContext *avctx)\n{\n    VmncContext * const c = avctx->priv_data;\n    c->avctx  = avctx;\n    c->width  = avctx->width;\n    c->height = avctx->height;\n    c->bpp    = avctx->bits_per_coded_sample;\n    c->bpp2   = c->bpp / 8;\n    switch (c->bpp) {\n    case 8:\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        break;\n    case 16:\n        avctx->pix_fmt = AV_PIX_FMT_RGB555;\n        break;\n    case 32:\n        avctx->pix_fmt = AV_PIX_FMT_RGB32;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported bitdepth %i\\n\", c->bpp);\n        return AVERROR_INVALIDDATA;\n    }\n    c->pic = av_frame_alloc();\n    if (!c->pic)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 0}
{"code": " void SVGDocumentExtensions::pauseAnimations()\n{\n    WillBeHeapHashSet<RawPtrWillBeMember<SVGSVGElement> >::iterator end = m_timeContainers.end();\n    for (WillBeHeapHashSet<RawPtrWillBeMember<SVGSVGElement> >::iterator itr = m_timeContainers.begin(); itr != end; ++itr)\n        (*itr)->pauseAnimations();\n}", "target": 0}
{"code": "ref_stack_cleanup(ref_stack_t *pstack)\n{\n    ref_stack_block *pblock =\n        (ref_stack_block *) pstack->current.value.refs;\n    refset_null_new(pstack->p + 1, pstack->top - pstack->p, 0);\n    pblock->used = pstack->current;\t\n    pblock->used.value.refs = pstack->bot;\n    r_set_size(&pblock->used, pstack->p + 1 - pstack->bot);\n}", "target": 0}
{"code": "static void print_pack_info(void)\n{\n\tstruct packed_git *pack;\n\tchar *offset;\n\tctx.page.mimetype = \"text/plain\";\n\tctx.page.filename = \"objects/info/packs\";\n\tcgit_print_http_headers();\n\treprepare_packed_git(the_repository);\n\tfor (pack = get_packed_git(the_repository); pack; pack = pack->next) {\n\t\tif (pack->pack_local) {\n\t\t\toffset = strrchr(pack->pack_name, '/');\n\t\t\tif (offset && offset[1] != '\\0')\n\t\t\t\t++offset;\n\t\t\telse\n\t\t\t\toffset = pack->pack_name;\n\t\t\thtmlf(\"P %s\\n\", offset);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static int vhost_vdpa_probe(struct vdpa_device *vdpa)\n{\n\tconst struct vdpa_config_ops *ops = vdpa->config;\n\tstruct vhost_vdpa *v;\n\tint minor;\n\tint r;\n\tif (ops->get_device_id(vdpa) != VIRTIO_ID_NET)\n\t\treturn -ENOTSUPP;\n\tv = kzalloc(sizeof(*v), GFP_KERNEL | __GFP_RETRY_MAYFAIL);\n\tif (!v)\n\t\treturn -ENOMEM;\n\tminor = ida_simple_get(&vhost_vdpa_ida, 0,\n\t\t\t       VHOST_VDPA_DEV_MAX, GFP_KERNEL);\n\tif (minor < 0) {\n\t\tkfree(v);\n\t\treturn minor;\n\t}\n\tatomic_set(&v->opened, 0);\n\tv->minor = minor;\n\tv->vdpa = vdpa;\n\tv->nvqs = vdpa->nvqs;\n\tv->virtio_id = ops->get_device_id(vdpa);\n\tdevice_initialize(&v->dev);\n\tv->dev.release = vhost_vdpa_release_dev;\n\tv->dev.parent = &vdpa->dev;\n\tv->dev.devt = MKDEV(MAJOR(vhost_vdpa_major), minor);\n\tv->vqs = kmalloc_array(v->nvqs, sizeof(struct vhost_virtqueue),\n\t\t\t       GFP_KERNEL);\n\tif (!v->vqs) {\n\t\tr = -ENOMEM;\n\t\tgoto err;\n\t}\n\tr = dev_set_name(&v->dev, \"vhost-vdpa-%u\", minor);\n\tif (r)\n\t\tgoto err;\n\tcdev_init(&v->cdev, &vhost_vdpa_fops);\n\tv->cdev.owner = THIS_MODULE;\n\tr = cdev_device_add(&v->cdev, &v->dev);\n\tif (r)\n\t\tgoto err;\n\tinit_completion(&v->completion);\n\tvdpa_set_drvdata(vdpa, v);\n\treturn 0;\nerr:\n\tput_device(&v->dev);\n\treturn r;\n}", "target": 0}
{"code": "static int wcd9335_codec_probe(struct snd_soc_component *component)\n{\n\tstruct wcd9335_codec *wcd = dev_get_drvdata(component->dev);\n\tint i;\n\tsnd_soc_component_init_regmap(component, wcd->regmap);\n\twcd->clsh_ctrl = wcd_clsh_ctrl_alloc(component, wcd->version);\n\tif (IS_ERR(wcd->clsh_ctrl))\n\t\treturn PTR_ERR(wcd->clsh_ctrl);\n\twcd->hph_mode = CLS_H_HIFI;\n\twcd->component = component;\n\twcd9335_codec_init(component);\n\tfor (i = 0; i < NUM_CODEC_DAIS; i++)\n\t\tINIT_LIST_HEAD(&wcd->dai[i].slim_ch_list);\n\treturn wcd9335_setup_irqs(wcd);\n}", "target": 0}
{"code": "string lua_text_pattern::new_fn_name()\n{\n    return make_stringf(\"__ch_stash_search_%u\", lfndx++);\n}", "target": 0}
{"code": "  bool WasAutoplayInitiated() { return Media()->WasAutoplayInitiated(); }", "target": 0}
{"code": "isdn_net_init(struct net_device *ndev)\n{\n\tushort max_hlhdr_len = 0;\n\tint drvidx;\n\tfor (drvidx = 0; drvidx < ISDN_MAX_DRIVERS; drvidx++)\n\t\tif (dev->drv[drvidx])\n\t\t\tif (max_hlhdr_len < dev->drv[drvidx]->interface->hl_hdrlen)\n\t\t\t\tmax_hlhdr_len = dev->drv[drvidx]->interface->hl_hdrlen;\n\tndev->hard_header_len = ETH_HLEN + max_hlhdr_len;\n\treturn 0;\n}", "target": 0}
{"code": "image_unit::~image_unit()\n{\n  for (int i=0;i<slice_units.size();i++) {\n    delete slice_units[i];\n  }\n  for (int i=0;i<tasks.size();i++) {\n    delete tasks[i];\n  }\n}", "target": 0}
{"code": "static void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\treturn;\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\t\tif (can_open_cached(data->state, data->o_arg.fmode, data->o_arg.open_flags))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(data->state->inode)->delegation);\n\t\tif (data->o_arg.claim != NFS4_OPEN_CLAIM_DELEGATE_CUR &&\n\t\t    can_open_delegated(delegation, data->o_arg.fmode))\n\t\t\tgoto unlock_no_action;\n\t\trcu_read_unlock();\n\t}\n\tdata->o_arg.clientid = sp->so_server->nfs_client->cl_clientid;\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t\tnfs_copy_fh(&data->o_res.fh, data->o_arg.fh);\n\t}\n\tdata->timestamp = jiffies;\n\tif (nfs4_setup_sequence(data->o_arg.server,\n\t\t\t\t&data->o_arg.seq_args,\n\t\t\t\t&data->o_res.seq_res, task))\n\t\treturn;\n\trpc_call_start(task);\n\treturn;\nunlock_no_action:\n\trcu_read_unlock();\nout_no_action:\n\ttask->tk_action = NULL;\n}", "target": 0}
{"code": "    CImg<floatT> get_object3dtoCImg3d(const bool full_check=true) const {\n      CImgList<T> opacities, colors;\n      CImgList<uintT> primitives(width(),1,1,1,1);\n      cimglist_for(primitives,p) primitives(p,0) = p;\n      return get_object3dtoCImg3d(primitives,colors,opacities,full_check);", "target": 0}
{"code": "krb5_decode_histkey(krb5_context context, struct berval **bvalues,\n                    osa_princ_ent_rec *princ_ent)\n{\n    krb5_error_code err = 0;\n    krb5_int16 i, n_keysets = 0;\n    ldap_seqof_key_data *keysets = NULL;\n    err = decode_keys(bvalues, &keysets, &n_keysets, NULL);\n    if (err != 0) {\n        k5_prependmsg(context, err,\n                      _(\"unable to decode stored principal pw history\"));\n        goto cleanup;\n    }\n    princ_ent->old_keys = k5calloc(n_keysets, sizeof(osa_pw_hist_ent), &err);\n    if (princ_ent->old_keys == NULL)\n        goto cleanup;\n    princ_ent->old_key_len = n_keysets;\n    if (n_keysets > 0)\n        princ_ent->admin_history_kvno = keysets[0].mkvno;\n    for (i = 0; i < n_keysets; i++) {\n        princ_ent->old_keys[i].n_key_data = keysets[i].n_key_data;\n        princ_ent->old_keys[i].key_data = keysets[i].key_data;\n        keysets[i].n_key_data = 0;\n        keysets[i].key_data = NULL;\n    }\n    qsort(princ_ent->old_keys, princ_ent->old_key_len, sizeof(osa_pw_hist_ent),\n          &compare_osa_pw_hist_ent);\n    princ_ent->aux_attributes |= KADM5_KEY_HIST;\n    princ_ent->old_key_next = princ_ent->old_key_len;\ncleanup:\n    free_ldap_seqof_key_data(keysets, n_keysets);\n    return err;\n}", "target": 0}
{"code": "int PDFiumEngine::StartPaint(int page_index, const pp::Rect& dirty) {\n  ProgressivePaint progressive;\n  progressive.rect = dirty;\n  progressive.page_index = page_index;\n  progressive.bitmap = nullptr;\n  progressive.painted_ = false;\n  progressive_paints_.push_back(progressive);\n  return progressive_paints_.size() - 1;\n}", "target": 0}
{"code": "storageConnectListDefinedStoragePools(virConnectPtr conn,\n                                      char **const names,\n                                      int maxnames)\n{\n    if (virConnectListDefinedStoragePoolsEnsureACL(conn) < 0)\n        return -1;\n    return virStoragePoolObjGetNames(driver->pools, conn, false,\n                                     virConnectListDefinedStoragePoolsCheckACL,\n                                     names, maxnames);\n}", "target": 0}
{"code": "static const char *set_protocol(cmd_parms *cmd, void *dummy,\n                                const char *arg)\n{\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    char* proto;\n    if (err != NULL) {\n        return err;\n    }\n    proto = apr_pstrdup(cmd->pool, arg);\n    ap_str_tolower(proto);\n    conf->protocol = proto;\n    return NULL;\n}", "target": 0}
{"code": "goto_tabpage(int n)\n{\n    tabpage_T\t*tp = NULL;  \n    tabpage_T\t*ttp;\n    int\t\ti;\n    if (text_locked())\n    {\n\ttext_locked_msg();\n\treturn;\n    }\n    if (first_tabpage->tp_next == NULL)\n    {\n\tif (n > 1)\n\t    beep_flush();\n\treturn;\n    }\n    if (n == 0)\n    {\n\tif (curtab->tp_next == NULL)\n\t    tp = first_tabpage;\n\telse\n\t    tp = curtab->tp_next;\n    }\n    else if (n < 0)\n    {\n\tttp = curtab;\n\tfor (i = n; i < 0; ++i)\n\t{\n\t    for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;\n\t\t    tp = tp->tp_next)\n\t\t;\n\t    ttp = tp;\n\t}\n    }\n    else if (n == 9999)\n    {\n\tfor (tp = first_tabpage; tp->tp_next != NULL; tp = tp->tp_next)\n\t    ;\n    }\n    else\n    {\n\ttp = find_tabpage(n);\n\tif (tp == NULL)\n\t{\n\t    beep_flush();\n\t    return;\n\t}\n    }\n    goto_tabpage_tp(tp, TRUE, TRUE);\n#ifdef FEAT_GUI_TABLINE\n    if (gui_use_tabline())\n\tgui_mch_set_curtab(tabpage_index(curtab));\n#endif\n}", "target": 0}
{"code": "int rr_sequential_and_unpack(READ_RECORD *info)\n{\n  int error;\n  if (unlikely((error= rr_sequential(info))))\n    return error;\n  for (Copy_field *cp= info->copy_field; cp != info->copy_field_end; cp++)\n    (*cp->do_copy)(cp);\n  return error;\n}", "target": 0}
{"code": "static int tipc_nl_compat_bearer_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t      struct nlattr **attrs)\n{\n\tstruct nlattr *bearer[TIPC_NLA_BEARER_MAX + 1];\n\tint err;\n\tif (!attrs[TIPC_NLA_BEARER])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(bearer, TIPC_NLA_BEARER_MAX,\n\t\t\t       attrs[TIPC_NLA_BEARER], NULL);\n\tif (err)\n\t\treturn err;\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_BEARER_NAME,\n\t\t\t    nla_data(bearer[TIPC_NLA_BEARER_NAME]),\n\t\t\t    nla_len(bearer[TIPC_NLA_BEARER_NAME]));\n}", "target": 0}
{"code": "static noinline void btrfs_schedule_bio(struct btrfs_device *device,\n\t\t\t\t\tstruct bio *bio)\n{\n\tstruct btrfs_fs_info *fs_info = device->fs_info;\n\tint should_queue = 1;\n\tstruct btrfs_pending_bios *pending_bios;\n\tif (bio_op(bio) == REQ_OP_READ) {\n\t\tbtrfsic_submit_bio(bio);\n\t\treturn;\n\t}\n\tWARN_ON(bio->bi_next);\n\tbio->bi_next = NULL;\n\tspin_lock(&device->io_lock);\n\tif (op_is_sync(bio->bi_opf))\n\t\tpending_bios = &device->pending_sync_bios;\n\telse\n\t\tpending_bios = &device->pending_bios;\n\tif (pending_bios->tail)\n\t\tpending_bios->tail->bi_next = bio;\n\tpending_bios->tail = bio;\n\tif (!pending_bios->head)\n\t\tpending_bios->head = bio;\n\tif (device->running_pending)\n\t\tshould_queue = 0;\n\tspin_unlock(&device->io_lock);\n\tif (should_queue)\n\t\tbtrfs_queue_work(fs_info->submit_workers, &device->work);\n}", "target": 0}
{"code": "theme_adium_clear (EmpathyChatView *view)\n{\n\tEmpathyThemeAdiumPriv *priv = GET_PRIV (view);\n\ttheme_adium_load_template (EMPATHY_THEME_ADIUM (view));\n\tif (priv->last_contact) {\n\t\tg_object_unref (priv->last_contact);\n\t\tpriv->last_contact = NULL;\n\t}\n}", "target": 0}
{"code": " NGColumnLayoutAlgorithm::NGColumnLayoutAlgorithm(\n    const NGLayoutAlgorithmParams& params)\n    : NGLayoutAlgorithm(params),\n      border_padding_(params.fragment_geometry.border +\n                      params.fragment_geometry.padding),\n      border_scrollbar_padding_(border_padding_ +\n                                params.fragment_geometry.scrollbar) {\n  container_builder_.SetIsNewFormattingContext(\n      params.space.IsNewFormattingContext());\n  container_builder_.SetInitialFragmentGeometry(params.fragment_geometry);\n}", "target": 0}
{"code": "int page_name_is_good(char* page_name)\n{\n    if (!page_name)\n        return FALSE;\n    if (!isalnum(page[0]))\n        return FALSE;\n    if (strstr(page, \"..\"))\n        return FALSE;\n    return TRUE;\n}", "target": 0}
{"code": "  OriginDataDeleter(QuotaManager* manager,\n                    const GURL& origin,\n                    StorageType type,\n                    StatusCallback* callback)\n      : QuotaTask(manager),\n        origin_(origin),\n        type_(type),\n        error_count_(0),\n        remaining_clients_(-1),\n        callback_(callback),\n        callback_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {}", "target": 0}
{"code": "int tipc_node_add_conn(struct net *net, u32 dnode, u32 port, u32 peer_port)\n{\n\tstruct tipc_node *node;\n\tstruct tipc_sock_conn *conn;\n\tint err = 0;\n\tif (in_own_node(net, dnode))\n\t\treturn 0;\n\tnode = tipc_node_find(net, dnode);\n\tif (!node) {\n\t\tpr_warn(\"Connecting sock to node 0x%x failed\\n\", dnode);\n\t\treturn -EHOSTUNREACH;\n\t}\n\tconn = kmalloc(sizeof(*conn), GFP_ATOMIC);\n\tif (!conn) {\n\t\terr = -EHOSTUNREACH;\n\t\tgoto exit;\n\t}\n\tconn->peer_node = dnode;\n\tconn->port = port;\n\tconn->peer_port = peer_port;\n\ttipc_node_write_lock(node);\n\tlist_add_tail(&conn->list, &node->conn_sks);\n\ttipc_node_write_unlock(node);\nexit:\n\ttipc_node_put(node);\n\treturn err;\n}", "target": 0}
{"code": "static ssize_t oom_adjust_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint oom_adjust;\n\tif (!task)\n\t\treturn -ESRCH;\n\toom_adjust = task->oomkilladj;\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", oom_adjust);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}", "target": 0}
{"code": "int idr_for_each(struct idr *idp,\n\t\t int (*fn)(int id, void *p, void *data), void *data)\n{\n\tint n, id, max, error = 0;\n\tstruct idr_layer *p;\n\tstruct idr_layer *pa[MAX_LEVEL];\n\tstruct idr_layer **paa = &pa[0];\n\tn = idp->layers * IDR_BITS;\n\tp = rcu_dereference_raw(idp->top);\n\tmax = 1 << n;\n\tid = 0;\n\twhile (id < max) {\n\t\twhile (n > 0 && p) {\n\t\t\tn -= IDR_BITS;\n\t\t\t*paa++ = p;\n\t\t\tp = rcu_dereference_raw(p->ary[(id >> n) & IDR_MASK]);\n\t\t}\n\t\tif (p) {\n\t\t\terror = fn(id, (void *)p, data);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t}\n\t\tid += 1 << n;\n\t\twhile (n < fls(id)) {\n\t\t\tn += IDR_BITS;\n\t\t\tp = *--paa;\n\t\t}\n\t}\n\treturn error;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NonPrefixRegexCovering) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySortProj(fromjson(\"{a: /foo/}\"), BSONObj(), fromjson(\"{_id: 0, a: 1}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{cscan: {dir: 1, filter: {a: /foo/}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{ixscan: {filter: {a: /foo/}, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "    FujiMnHeader::~FujiMnHeader()\n    {\n    }", "target": 0}
{"code": "DesktopNativeWidgetHelperAura::DesktopNativeWidgetHelperAura(\n    NativeWidgetAura* widget)\n    : widget_(widget),\n      root_window_event_filter_(NULL),\n      is_embedded_window_(false) {\n}", "target": 0}
{"code": "static void reload_tss(void)\n{\n\tstruct desc_ptr *gdt = this_cpu_ptr(&host_gdt);\n\tstruct desc_struct *descs;\n\tdescs = (void *)gdt->address;\n\tdescs[GDT_ENTRY_TSS].type = 9; \n\tload_TR_desc();\n}", "target": 0}
{"code": "static int netlink_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\tint addr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *nladdr = (struct sockaddr_nl *)addr;\n\tint err = 0;\n\tlong unsigned int groups = nladdr->nl_groups;\n\tbool bound;\n\tif (addr_len < sizeof(struct sockaddr_nl))\n\t\treturn -EINVAL;\n\tif (nladdr->nl_family != AF_NETLINK)\n\t\treturn -EINVAL;\n\tif (groups) {\n\t\tif (!netlink_allowed(sock, NL_CFG_F_NONROOT_RECV))\n\t\t\treturn -EPERM;\n\t\terr = netlink_realloc_groups(sk);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\tbound = nlk->bound;\n\tif (bound) {\n\t\tsmp_rmb();\n\t\tif (nladdr->nl_pid != nlk->portid)\n\t\t\treturn -EINVAL;\n\t}\n\tnetlink_lock_table();\n\tif (nlk->netlink_bind && groups) {\n\t\tint group;\n\t\tfor (group = 0; group < nlk->ngroups; group++) {\n\t\t\tif (!test_bit(group, &groups))\n\t\t\t\tcontinue;\n\t\t\terr = nlk->netlink_bind(net, group + 1);\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\t\t\tnetlink_undo_bind(group, groups, sk);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tif (!bound) {\n\t\terr = nladdr->nl_pid ?\n\t\t\tnetlink_insert(sk, nladdr->nl_pid) :\n\t\t\tnetlink_autobind(sock);\n\t\tif (err) {\n\t\t\tnetlink_undo_bind(nlk->ngroups, groups, sk);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tif (!groups && (nlk->groups == NULL || !(u32)nlk->groups[0]))\n\t\tgoto unlock;\n\tnetlink_unlock_table();\n\tnetlink_table_grab();\n\tnetlink_update_subscriptions(sk, nlk->subscriptions +\n\t\t\t\t\t hweight32(groups) -\n\t\t\t\t\t hweight32(nlk->groups[0]));\n\tnlk->groups[0] = (nlk->groups[0] & ~0xffffffffUL) | groups;\n\tnetlink_update_listeners(sk);\n\tnetlink_table_ungrab();\n\treturn 0;\nunlock:\n\tnetlink_unlock_table();\n\treturn err;\n}", "target": 0}
{"code": "ip_heuristic_guess(netdissect_options *ndo,\n                   register const u_char *p, u_int length)\n{\n    switch(p[0]) {\n    case 0x45:\n    case 0x46:\n    case 0x47:\n    case 0x48:\n    case 0x49:\n    case 0x4a:\n    case 0x4b:\n    case 0x4c:\n    case 0x4d:\n    case 0x4e:\n    case 0x4f:\n\t    ip_print(ndo, p, length);\n\t    break;\n    case 0x60:\n    case 0x61:\n    case 0x62:\n    case 0x63:\n    case 0x64:\n    case 0x65:\n    case 0x66:\n    case 0x67:\n    case 0x68:\n    case 0x69:\n    case 0x6a:\n    case 0x6b:\n    case 0x6c:\n    case 0x6d:\n    case 0x6e:\n    case 0x6f:\n        ip6_print(ndo, p, length);\n        break;\n    default:\n        return 0; \n        break;\n    }\n    return 1; \n}", "target": 0}
{"code": "static size_t curl_write_nothing(char *data, size_t size, size_t nmemb, void *ctx)\n{\n\treturn size * nmemb;\n}", "target": 0}
{"code": "void  opj_j2k_read_int16_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)\n{\n        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;\n        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;\n        OPJ_UINT32 i;\n        OPJ_UINT32 l_temp;\n        for (i=0;i<p_nb_elem;++i) {\n                opj_read_bytes(l_src_data,&l_temp,2);\n                l_src_data+=sizeof(OPJ_INT16);\n                *(l_dest_data++) = (OPJ_INT32) l_temp;\n        }\n}", "target": 0}
{"code": "epass2003_erase_card(struct sc_card *card)\n{\n\tint r;\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_invalidate_cache(card);\n\tr = sc_delete_file(card, sc_get_mf_path());\n\tLOG_TEST_RET(card->ctx, r, \"delete MF failed\");\n\tLOG_FUNC_RETURN(card->ctx, r);\n}", "target": 0}
{"code": "const Ewk_Scroll_Request* ewk_view_scroll_requests_get(const Ewk_View_Private_Data* priv, size_t* count)\n{\n    if (count)\n        *count = 0;\n    EINA_SAFETY_ON_NULL_RETURN_VAL(priv, 0);\n    if (count)\n        *count = priv->scrolls.count;\n    return priv->scrolls.array;\n}", "target": 0}
{"code": "static void copy_shadow_to_vmcs12(struct vcpu_vmx *vmx)\n{\n\tint i;\n\tunsigned long field;\n\tu64 field_value;\n\tstruct vmcs *shadow_vmcs = vmx->nested.current_shadow_vmcs;\n\tconst unsigned long *fields = shadow_read_write_fields;\n\tconst int num_fields = max_shadow_read_write_fields;\n\tvmcs_load(shadow_vmcs);\n\tfor (i = 0; i < num_fields; i++) {\n\t\tfield = fields[i];\n\t\tswitch (vmcs_field_type(field)) {\n\t\tcase VMCS_FIELD_TYPE_U16:\n\t\t\tfield_value = vmcs_read16(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_U32:\n\t\t\tfield_value = vmcs_read32(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_U64:\n\t\t\tfield_value = vmcs_read64(field);\n\t\t\tbreak;\n\t\tcase VMCS_FIELD_TYPE_NATURAL_WIDTH:\n\t\t\tfield_value = vmcs_readl(field);\n\t\t\tbreak;\n\t\t}\n\t\tvmcs12_write_any(&vmx->vcpu, field, field_value);\n\t}\n\tvmcs_clear(shadow_vmcs);\n\tvmcs_load(vmx->loaded_vmcs->vmcs);\n}", "target": 0}
{"code": "static int release_reference_state(struct bpf_func_state *state, int ptr_id)\n{\n\tint i, last_idx;\n\tlast_idx = state->acquired_refs - 1;\n\tfor (i = 0; i < state->acquired_refs; i++) {\n\t\tif (state->refs[i].id == ptr_id) {\n\t\t\tif (last_idx && i != last_idx)\n\t\t\t\tmemcpy(&state->refs[i], &state->refs[last_idx],\n\t\t\t\t       sizeof(*state->refs));\n\t\t\tmemset(&state->refs[last_idx], 0, sizeof(*state->refs));\n\t\t\tstate->acquired_refs--;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "txid_current_snapshot(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap;\n\tuint32\t\tnxip,\n\t\t\t\ti,\n\t\t\t\tsize;\n\tTxidEpoch\tstate;\n\tSnapshot\tcur;\n\tcur = GetActiveSnapshot();\n\tif (cur == NULL)\n\t\telog(ERROR, \"no active snapshot set\");\n\tload_xid_epoch(&state);\n\tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,\n\t\t\t\t\t \"possible overflow in txid_current_snapshot()\");\n\tnxip = cur->xcnt;\n\tsize = TXID_SNAPSHOT_SIZE(nxip);\n\tsnap = palloc(size);\n\tSET_VARSIZE(snap, size);\n\tsnap->xmin = convert_xid(cur->xmin, &state);\n\tsnap->xmax = convert_xid(cur->xmax, &state);\n\tsnap->nxip = nxip;\n\tfor (i = 0; i < nxip; i++)\n\t\tsnap->xip[i] = convert_xid(cur->xip[i], &state);\n\tsort_snapshot(snap);\n\tPG_RETURN_POINTER(snap);\n}", "target": 0}
{"code": "static void cma_exit_net(struct net *net)\n{\n\tstruct cma_pernet *pernet = cma_pernet(net);\n\tWARN_ON(!xa_empty(&pernet->tcp_ps));\n\tWARN_ON(!xa_empty(&pernet->udp_ps));\n\tWARN_ON(!xa_empty(&pernet->ipoib_ps));\n\tWARN_ON(!xa_empty(&pernet->ib_ps));\n}", "target": 0}
{"code": "int udp6_output(struct socket *so, struct mbuf *m, struct sockaddr_in6 *saddr,\n                struct sockaddr_in6 *daddr)\n{\n    Slirp *slirp = m->slirp;\n    M_DUP_DEBUG(slirp, m, 0, sizeof(struct ip6) + sizeof(struct udphdr));\n    struct ip6 *ip;\n    struct udphdr *uh;\n    DEBUG_CALL(\"udp6_output\");\n    DEBUG_ARG(\"so = %p\", so);\n    DEBUG_ARG(\"m = %p\", m);\n    m->m_data -= sizeof(struct udphdr);\n    m->m_len += sizeof(struct udphdr);\n    uh = mtod(m, struct udphdr *);\n    m->m_data -= sizeof(struct ip6);\n    m->m_len += sizeof(struct ip6);\n    ip = mtod(m, struct ip6 *);\n    ip->ip_pl = htons(m->m_len - sizeof(struct ip6));\n    ip->ip_nh = IPPROTO_UDP;\n    ip->ip_src = saddr->sin6_addr;\n    ip->ip_dst = daddr->sin6_addr;\n    uh->uh_sport = saddr->sin6_port;\n    uh->uh_dport = daddr->sin6_port;\n    uh->uh_ulen = ip->ip_pl;\n    uh->uh_sum = 0;\n    uh->uh_sum = ip6_cksum(m);\n    if (uh->uh_sum == 0) {\n        uh->uh_sum = 0xffff;\n    }\n    return ip6_output(so, m, 0);\n}", "target": 0}
{"code": "static int coolkey_write_binary(sc_card_t *card, unsigned int idx,\n\t\tconst u8 *buf, size_t count, unsigned long flags)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n}", "target": 0}
{"code": "BOOL CSoundFile::Destroy()\n{\n\tint i;\n\tfor (i=0; i<MAX_PATTERNS; i++) if (Patterns[i])\n\t{\n\t\tFreePattern(Patterns[i]);\n\t\tPatterns[i] = NULL;\n\t}\n\tm_nPatternNames = 0;\n\tif (m_lpszPatternNames)\n\t{\n\t\tdelete m_lpszPatternNames;\n\t\tm_lpszPatternNames = NULL;\n\t}\n\tif (m_lpszSongComments)\n\t{\n\t\tdelete m_lpszSongComments;\n\t\tm_lpszSongComments = NULL;\n\t}\n\tfor (i=1; i<MAX_SAMPLES; i++)\n\t{\n\t\tMODINSTRUMENT *pins = &Ins[i];\n\t\tif (pins->pSample)\n\t\t{\n\t\t\tFreeSample(pins->pSample);\n\t\t\tpins->pSample = NULL;\n\t\t}\n\t}\n\tfor (i=0; i<MAX_INSTRUMENTS; i++)\n\t{\n\t\tif (Headers[i])\n\t\t{\n\t\t\tdelete Headers[i];\n\t\t\tHeaders[i] = NULL;\n\t\t}\n\t}\n\tfor (i=0; i<MAX_MIXPLUGINS; i++)\n\t{\n\t\tif ((m_MixPlugins[i].nPluginDataSize) && (m_MixPlugins[i].pPluginData))\n\t\t{\n\t\t\tm_MixPlugins[i].nPluginDataSize = 0;\n\t\t\tdelete [] (signed char*)m_MixPlugins[i].pPluginData;\n\t\t\tm_MixPlugins[i].pPluginData = NULL;\n\t\t}\n\t\tm_MixPlugins[i].pMixState = NULL;\n\t\tif (m_MixPlugins[i].pMixPlugin)\n\t\t{\n\t\t\tm_MixPlugins[i].pMixPlugin->Release();\n\t\t\tm_MixPlugins[i].pMixPlugin = NULL;\n\t\t}\n\t}\n\tm_nType = MOD_TYPE_NONE;\n\tm_nChannels = m_nSamples = m_nInstruments = 0;\n\treturn TRUE;\n}", "target": 0}
{"code": "static struct nfc_llcp_local *nfc_llcp_remove_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local, *tmp;\n\tspin_lock(&llcp_devices_lock);\n\tlist_for_each_entry_safe(local, tmp, &llcp_devices, list)\n\t\tif (local->dev == dev) {\n\t\t\tlist_del(&local->list);\n\t\t\tspin_unlock(&llcp_devices_lock);\n\t\t\treturn local;\n\t\t}\n\tspin_unlock(&llcp_devices_lock);\n\tpr_warn(\"Shutting down device not found\\n\");\n\treturn NULL;\n}", "target": 0}
{"code": "void Item_cache_wrapper::save_val(Field *to)\n{\n  Item *cached_value;\n  DBUG_ENTER(\"Item_cache_wrapper::val_int\");\n  if (!expr_cache)\n  {\n    orig_item->save_val(to);\n    null_value= orig_item->null_value;\n    DBUG_VOID_RETURN;\n  }\n  if ((cached_value= check_cache()))\n  {\n    cached_value->save_val(to);\n    null_value= cached_value->null_value;\n    DBUG_VOID_RETURN;\n  }\n  cache();\n  null_value= expr_value->null_value;\n  expr_value->save_val(to);\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "find_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    for (pl2 = plist; *pl2; pl2++);\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}", "target": 0}
{"code": "struct sctp_ulpq *sctp_ulpq_init(struct sctp_ulpq *ulpq,\n\t\t\t\t struct sctp_association *asoc)\n{\n\tmemset(ulpq, 0, sizeof(struct sctp_ulpq));\n\tulpq->asoc = asoc;\n\tskb_queue_head_init(&ulpq->reasm);\n\tskb_queue_head_init(&ulpq->lobby);\n\tulpq->pd_mode  = 0;\n\tulpq->malloced = 0;\n\treturn ulpq;\n}", "target": 0}
{"code": "void mem_cgroup_replace_page_cache(struct page *oldpage,\n\t\t\t\t  struct page *newpage)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct page_cgroup *pc;\n\tenum charge_type type = MEM_CGROUP_CHARGE_TYPE_CACHE;\n\tif (mem_cgroup_disabled())\n\t\treturn;\n\tpc = lookup_page_cgroup(oldpage);\n\tlock_page_cgroup(pc);\n\tmemcg = pc->mem_cgroup;\n\tmem_cgroup_charge_statistics(memcg, PageCgroupCache(pc), -1);\n\tClearPageCgroupUsed(pc);\n\tunlock_page_cgroup(pc);\n\tif (PageSwapBacked(oldpage))\n\t\ttype = MEM_CGROUP_CHARGE_TYPE_SHMEM;\n\t__mem_cgroup_commit_charge_lrucare(newpage, memcg, type);\n}", "target": 0}
{"code": "eb_destroy(struct eb_objects *eb)\n{\n\twhile (!list_empty(&eb->objects)) {\n\t\tstruct drm_i915_gem_object *obj;\n\t\tobj = list_first_entry(&eb->objects,\n\t\t\t\t       struct drm_i915_gem_object,\n\t\t\t\t       exec_list);\n\t\tlist_del_init(&obj->exec_list);\n\t\tdrm_gem_object_unreference(&obj->base);\n\t}\n\tkfree(eb);\n}", "target": 0}
{"code": "flatpak_filesystem_key_in_home (const char *filesystem)\n{\n  if (strcmp (filesystem, \"home\") == 0)\n    return TRUE;\n  if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||\n      g_str_has_prefix (filesystem, \"/\"))\n    return FALSE;\n  if (g_str_has_prefix (filesystem, \"xdg-run\"))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "static bool vma_shareable(struct vm_area_struct *vma, unsigned long addr)\n{\n\tunsigned long base = addr & PUD_MASK;\n\tunsigned long end = base + PUD_SIZE;\n\tif (vma->vm_flags & VM_MAYSHARE && range_in_vma(vma, base, end))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "static int php_ifd_get32s(void *value, int motorola_intel)\n{\n\tif (motorola_intel) {\n\t\treturn  (((char  *)value)[0] << 24)\n\t\t\t  | (((uchar *)value)[1] << 16)\n\t\t\t  | (((uchar *)value)[2] << 8 )\n\t\t\t  | (((uchar *)value)[3]      );\n\t} else {\n\t\treturn  (((char  *)value)[3] << 24)\n\t\t\t  | (((uchar *)value)[2] << 16)\n\t\t\t  | (((uchar *)value)[1] << 8 )\n\t\t\t  | (((uchar *)value)[0]      );\n\t}\n}", "target": 0}
{"code": "Status LoadSavedModel(const SessionOptions& session_options,\n                      const RunOptions& run_options, const string& export_dir,\n                      const std::unordered_set<string>& tags,\n                      SavedModelBundle* const bundle) {\n  const uint64 start_microseconds = Env::Default()->NowMicros();\n  const Status status = LoadSavedModelInternal(session_options, run_options,\n                                               export_dir, tags, bundle);\n  auto log_and_count = [&](const string& status_str) {\n    LOG(INFO) << \"SavedModel load for tags { \" << absl::StrJoin(tags, \" \")\n              << \" }; Status: \" << status_str << \": \" << status << \". Took \"\n              << GetLatencyMicroseconds(start_microseconds) << \" microseconds.\";\n    load_attempt_count->GetCell(export_dir, status_str)->IncrementBy(1);\n  };\n  if (status.ok()) {\n    log_and_count(kLoadAttemptSuccess);\n  } else {\n    log_and_count(kLoadAttemptFail);\n  }\n  load_latency->GetCell(export_dir)\n      ->IncrementBy(GetLatencyMicroseconds(start_microseconds));\n  return status;\n}", "target": 0}
{"code": "findugid(address_item *addr, transport_instance *tp, uid_t *uidp, gid_t *gidp,\n  BOOL *igfp)\n{\nuschar *nuname;\nBOOL gid_set = FALSE;\n*igfp = tp->initgroups;\nif (tp->gid_set)\n  {\n  *gidp = tp->gid;\n  gid_set = TRUE;\n  }\nelse if (tp->expand_gid)\n  {\n  if (!route_find_expanded_group(tp->expand_gid, tp->name, US\"transport\", gidp,\n    &(addr->message)))\n    {\n    common_error(FALSE, addr, ERRNO_GIDFAIL, NULL);\n    return FALSE;\n    }\n  gid_set = TRUE;\n  }\nif (!gid_set && testflag(addr, af_gid_set))\n  {\n  *gidp = addr->gid;\n  gid_set = TRUE;\n  }\nif (tp->uid_set) *uidp = tp->uid;\nelse if (tp->expand_uid)\n  {\n  struct passwd *pw;\n  if (!route_find_expanded_user(tp->expand_uid, tp->name, US\"transport\", &pw,\n       uidp, &(addr->message)))\n    {\n    common_error(FALSE, addr, ERRNO_UIDFAIL, NULL);\n    return FALSE;\n    }\n  if (!gid_set && pw)\n    {\n    *gidp = pw->pw_gid;\n    gid_set = TRUE;\n    }\n  }\nelse if (tp->deliver_as_creator)\n  {\n  *uidp = originator_uid;\n  if (!gid_set)\n    {\n    *gidp = originator_gid;\n    gid_set = TRUE;\n    }\n  }\nelse if (testflag(addr, af_uid_set))\n  {\n  *uidp = addr->uid;\n  *igfp = testflag(addr, af_initgroups);\n  }\nelse\n  {\n  *uidp = exim_uid;\n  if (!gid_set)\n    {\n    *gidp = exim_gid;\n    gid_set = TRUE;\n    }\n  }\nif (!gid_set)\n  {\n  common_error(TRUE, addr, ERRNO_GIDFAIL, US\"User set without group for \"\n    \"%s transport\", tp->name);\n  return FALSE;\n  }\nnuname = check_never_users(*uidp, never_users)\n  ? US\"never_users\"\n  : check_never_users(*uidp, fixed_never_users)\n  ? US\"fixed_never_users\"\n  : NULL;\nif (nuname)\n  {\n  common_error(TRUE, addr, ERRNO_UIDFAIL, US\"User %ld set for %s transport \"\n    \"is on the %s list\", (long int)(*uidp), tp->name, nuname);\n  return FALSE;\n  }\nreturn TRUE;\n}", "target": 0}
{"code": "static int decode_server_caps(struct xdr_stream *xdr, struct nfs4_server_caps_res *res)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_supported(xdr, bitmap, res->attr_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fh_expire_type(xdr, bitmap,\n\t\t\t\t\t\t &res->fh_expire_type)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_link_support(xdr, bitmap, &res->has_links)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_symlink_support(xdr, bitmap, &res->has_symlinks)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_aclsupport(xdr, bitmap, &res->acl_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}", "target": 0}
{"code": "void kvm_arch_flush_shadow_all(struct kvm *kvm)\n{\n\tkvm_mmu_invalidate_zap_all_pages(kvm);\n}", "target": 0}
{"code": "  void SetInput(std::initializer_list<float> data) {\n    QuantizeAndPopulate<int8_t>(input_, data);\n  }", "target": 0}
{"code": "idmap_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\n{\n\tstruct rpc_inode *rpci = RPC_I(file_inode(filp));\n\tstruct idmap *idmap = (struct idmap *)rpci->private;\n\tstruct key_construction *cons;\n\tstruct idmap_msg im;\n\tsize_t namelen_in;\n\tint ret = -ENOKEY;\n\tif (idmap->idmap_upcall_data == NULL)\n\t\tgoto out_noupcall;\n\tcons = idmap->idmap_upcall_data->key_cons;\n\tif (mlen != sizeof(im)) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\tif (copy_from_user(&im, src, mlen) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (!(im.im_status & IDMAP_STATUS_SUCCESS)) {\n\t\tret = -ENOKEY;\n\t\tgoto out;\n\t}\n\tnamelen_in = strnlen(im.im_name, IDMAP_NAMESZ);\n\tif (namelen_in == 0 || namelen_in == IDMAP_NAMESZ) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n}\n\tret = nfs_idmap_read_and_verify_message(&im,\n\t\t\t&idmap->idmap_upcall_data->idmap_msg,\n\t\t\tcons->key, cons->authkey);\n\tif (ret >= 0) {\n\t\tkey_set_timeout(cons->key, nfs_idmap_cache_timeout);\n\t\tret = mlen;\n\t}\nout:\n\tnfs_idmap_complete_pipe_upcall_locked(idmap, ret);\nout_noupcall:\n\treturn ret;\n}", "target": 0}
{"code": "void set_normalized_timespec(struct timespec *ts, time_t sec, long nsec)\n{\n\twhile (nsec >= NSEC_PER_SEC) {\n\t\tnsec -= NSEC_PER_SEC;\n\t\t++sec;\n\t}\n\twhile (nsec < 0) {\n\t\tnsec += NSEC_PER_SEC;\n\t\t--sec;\n\t}\n\tts->tv_sec = sec;\n\tts->tv_nsec = nsec;\n}", "target": 0}
{"code": "static int vsock_stream_setsockopt(struct socket *sock,\n\t\t\t\t   int level,\n\t\t\t\t   int optname,\n\t\t\t\t   char __user *optval,\n\t\t\t\t   unsigned int optlen)\n{\n\tint err;\n\tstruct sock *sk;\n\tstruct vsock_sock *vsk;\n\tu64 val;\n\tif (level != AF_VSOCK)\n\t\treturn -ENOPROTOOPT;\n#define COPY_IN(_v)                                       \\\n\tdo {\t\t\t\t\t\t  \\\n\t\tif (optlen < sizeof(_v)) {\t\t  \\\n\t\t\terr = -EINVAL;\t\t\t  \\\n\t\t\tgoto exit;\t\t\t  \\\n\t\t}\t\t\t\t\t  \\\n\t\tif (copy_from_user(&_v, optval, sizeof(_v)) != 0) {\t\\\n\t\t\terr = -EFAULT;\t\t\t\t\t\\\n\t\t\tgoto exit;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\terr = 0;\n\tsk = sock->sk;\n\tvsk = vsock_sk(sk);\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase SO_VM_SOCKETS_BUFFER_SIZE:\n\t\tCOPY_IN(val);\n\t\ttransport->set_buffer_size(vsk, val);\n\t\tbreak;\n\tcase SO_VM_SOCKETS_BUFFER_MAX_SIZE:\n\t\tCOPY_IN(val);\n\t\ttransport->set_max_buffer_size(vsk, val);\n\t\tbreak;\n\tcase SO_VM_SOCKETS_BUFFER_MIN_SIZE:\n\t\tCOPY_IN(val);\n\t\ttransport->set_min_buffer_size(vsk, val);\n\t\tbreak;\n\tcase SO_VM_SOCKETS_CONNECT_TIMEOUT: {\n\t\tstruct timeval tv;\n\t\tCOPY_IN(tv);\n\t\tif (tv.tv_sec >= 0 && tv.tv_usec < USEC_PER_SEC &&\n\t\t    tv.tv_sec < (MAX_SCHEDULE_TIMEOUT / HZ - 1)) {\n\t\t\tvsk->connect_timeout = tv.tv_sec * HZ +\n\t\t\t    DIV_ROUND_UP(tv.tv_usec, (1000000 / HZ));\n\t\t\tif (vsk->connect_timeout == 0)\n\t\t\t\tvsk->connect_timeout =\n\t\t\t\t    VSOCK_DEFAULT_CONNECT_TIMEOUT;\n\t\t} else {\n\t\t\terr = -ERANGE;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n#undef COPY_IN\nexit:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static int cpu_rt_period_write_uint(struct cgroup_subsys_state *css,\n\t\t\t\t    struct cftype *cftype, u64 rt_period_us)\n{\n\treturn sched_group_set_rt_period(css_tg(css), rt_period_us);\n}", "target": 0}
{"code": "nfsd4_getdeviceinfo(struct svc_rqst *rqstp,\n\t\tstruct nfsd4_compound_state *cstate, union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getdeviceinfo *gdp = &u->getdeviceinfo;\n\tconst struct nfsd4_layout_ops *ops;\n\tstruct nfsd4_deviceid_map *map;\n\tstruct svc_export *exp;\n\t__be32 nfserr;\n\tdprintk(\"%s: layout_type %u dev_id [0x%llx:0x%x] maxcnt %u\\n\",\n\t       __func__,\n\t       gdp->gd_layout_type,\n\t       gdp->gd_devid.fsid_idx, gdp->gd_devid.generation,\n\t       gdp->gd_maxcount);\n\tmap = nfsd4_find_devid_map(gdp->gd_devid.fsid_idx);\n\tif (!map) {\n\t\tdprintk(\"%s: couldn't find device ID to export mapping!\\n\",\n\t\t\t__func__);\n\t\treturn nfserr_noent;\n\t}\n\texp = rqst_exp_find(rqstp, map->fsid_type, map->fsid);\n\tif (IS_ERR(exp)) {\n\t\tdprintk(\"%s: could not find device id\\n\", __func__);\n\t\treturn nfserr_noent;\n\t}\n\tnfserr = nfserr_layoutunavailable;\n\tops = nfsd4_layout_verify(exp, gdp->gd_layout_type);\n\tif (!ops)\n\t\tgoto out;\n\tnfserr = nfs_ok;\n\tif (gdp->gd_maxcount != 0) {\n\t\tnfserr = ops->proc_getdeviceinfo(exp->ex_path.mnt->mnt_sb,\n\t\t\t\trqstp, cstate->session->se_client, gdp);\n\t}\n\tgdp->gd_notify_types &= ops->notify_types;\nout:\n\texp_put(exp);\n\treturn nfserr;\n}", "target": 0}
{"code": "static void validate_slab(struct kmem_cache *s, struct page *page)\n{\n\tvoid *p;\n\tvoid *addr = page_address(page);\n\tunsigned long *map;\n\tslab_lock(page);\n\tif (!check_slab(s, page) || !on_freelist(s, page, NULL))\n\t\tgoto unlock;\n\tmap = get_map(s, page);\n\tfor_each_object(p, s, addr, page->objects) {\n\t\tu8 val = test_bit(slab_index(p, s, addr), map) ?\n\t\t\t SLUB_RED_INACTIVE : SLUB_RED_ACTIVE;\n\t\tif (!check_object(s, page, p, val))\n\t\t\tbreak;\n\t}\n\tput_map(map);\nunlock:\n\tslab_unlock(page);\n}", "target": 0}
{"code": "check_ENQUEUE(const struct ofpact_enqueue *a,\n              const struct ofpact_check_params *cp)\n{\n    if (ofp_to_u16(a->port) >= ofp_to_u16(cp->max_ports)\n        && a->port != OFPP_IN_PORT\n        && a->port != OFPP_LOCAL) {\n        return OFPERR_OFPBAC_BAD_OUT_PORT;\n    }\n    return 0;\n}", "target": 0}
{"code": "void WebProcessProxy::didDestroyFrame(uint64_t frameID)\n{\n    ASSERT(isGoodKey<WebFrameProxyMap>(frameID));\n    m_frameMap.remove(frameID);\n}", "target": 0}
{"code": "void sctp_assoc_rwnd_decrease(struct sctp_association *asoc, unsigned int len)\n{\n\tint rx_count;\n\tint over = 0;\n\tif (unlikely(!asoc->rwnd || asoc->rwnd_over))\n\t\tpr_debug(\"%s: association:%p has asoc->rwnd:%u, \"\n\t\t\t \"asoc->rwnd_over:%u!\\n\", __func__, asoc,\n\t\t\t asoc->rwnd, asoc->rwnd_over);\n\tif (asoc->ep->rcvbuf_policy)\n\t\trx_count = atomic_read(&asoc->rmem_alloc);\n\telse\n\t\trx_count = atomic_read(&asoc->base.sk->sk_rmem_alloc);\n\tif (rx_count >= asoc->base.sk->sk_rcvbuf)\n\t\tover = 1;\n\tif (asoc->rwnd >= len) {\n\t\tasoc->rwnd -= len;\n\t\tif (over) {\n\t\t\tasoc->rwnd_press += asoc->rwnd;\n\t\t\tasoc->rwnd = 0;\n\t\t}\n\t} else {\n\t\tasoc->rwnd_over = len - asoc->rwnd;\n\t\tasoc->rwnd = 0;\n\t}\n\tpr_debug(\"%s: asoc:%p rwnd decreased by %d to (%u, %u, %u)\\n\",\n\t\t __func__, asoc, len, asoc->rwnd, asoc->rwnd_over,\n\t\t asoc->rwnd_press);\n}", "target": 0}
{"code": "int sc_mutex_lock(const sc_context_t *ctx, void *mutex)\n{\n\tif (ctx == NULL)\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\tif (ctx->thread_ctx != NULL && ctx->thread_ctx->lock_mutex != NULL)\n\t\treturn ctx->thread_ctx->lock_mutex(mutex);\n\telse\n\t\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "void dane_state_deinit(dane_state_t s)\n{\n\tub_ctx_delete(s->ctx);\n\tfree(s);\n}", "target": 0}
{"code": "int WebContentsImpl::GetZoomPercent(bool* enable_increment,\n                                    bool* enable_decrement) const {\n  *enable_decrement = *enable_increment = false;\n  int percent = static_cast<int>(\n      ZoomLevelToZoomFactor(GetZoomLevel()) * 100 + 0.5);\n  *enable_decrement = percent > minimum_zoom_percent_;\n  *enable_increment = percent < maximum_zoom_percent_;\n  return percent;\n}", "target": 0}
{"code": "void reply_outbuf(struct smb_request *req, uint8 num_words, uint32 num_bytes)\n{\n\tchar *outbuf;\n\tif (!create_outbuf(req, req, (char *)req->inbuf, &outbuf, num_words,\n\t\t\t   num_bytes)) {\n\t\tsmb_panic(\"could not allocate output buffer\\n\");\n\t}\n\treq->outbuf = (uint8_t *)outbuf;\n}", "target": 0}
{"code": "void GfxPath::moveTo(double x, double y)\n{\n    justMoved = true;\n    firstX = x;\n    firstY = y;\n}", "target": 0}
{"code": "print_tree(FILE* f, Node* node)\n{\n  print_indent_tree(f, node, 0);\n}", "target": 0}
{"code": "static void packet_dec_pending(struct packet_ring_buffer *rb)\n{\n\tthis_cpu_dec(*rb->pending_refcnt);\n}", "target": 0}
{"code": "  const char *libraw_unpack_function_name(libraw_data_t *lr)\n  {\n    if (!lr)\n      return \"NULL parameter passed\";\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    return ip->unpack_function_name();\n  }", "target": 0}
{"code": "static bool urlchar_needs_escaping(int c)\n{\n  return !(ISCNTRL(c) || ISSPACE(c) || ISGRAPH(c));\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, OrWithAndChild) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{$or: [{a: 20}, {$and: [{a:1}, {b:7}]}]}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {or: {nodes: [\"\n        \"{ixscan: {filter: null, pattern: {a: 1}}}, \"\n        \"{fetch: {filter: {b: 7}, node: {ixscan: \"\n        \"{filter: null, pattern: {a: 1}}}}}]}}}}\");\n}", "target": 0}
{"code": "static inline bool cpu_has_virtual_nmis(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_VIRTUAL_NMIS;\n}", "target": 0}
{"code": "static int nlmsg_populate_fdb(struct sk_buff *skb,\n\t\t\t      struct netlink_callback *cb,\n\t\t\t      struct net_device *dev,\n\t\t\t      int *idx,\n\t\t\t      struct netdev_hw_addr_list *list)\n{\n\tstruct netdev_hw_addr *ha;\n\tint err;\n\tu32 portid, seq;\n\tportid = NETLINK_CB(cb->skb).portid;\n\tseq = cb->nlh->nlmsg_seq;\n\tlist_for_each_entry(ha, &list->list, list) {\n\t\tif (*idx < cb->args[0])\n\t\t\tgoto skip;\n\t\terr = nlmsg_populate_fdb_fill(skb, dev, ha->addr, 0,\n\t\t\t\t\t      portid, seq,\n\t\t\t\t\t      RTM_NEWNEIGH, NTF_SELF,\n\t\t\t\t\t      NLM_F_MULTI, NUD_PERMANENT);\n\t\tif (err < 0)\n\t\t\treturn err;\nskip:\n\t\t*idx += 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void fz_init_cached_color_converter(fz_context *ctx, fz_color_converter *cc, fz_colorspace *is, fz_colorspace *ds, fz_colorspace *ss, const fz_color_params *params)\n{\n\tint n = ss->n;\n\tfz_cached_color_converter *cached = fz_malloc_struct(ctx, fz_cached_color_converter);\n\tcc->opaque = cached;\n\tcc->convert = fz_cached_color_convert;\n\tcc->ds = ds ? ds : fz_device_gray(ctx);\n\tcc->ss = ss;\n\tcc->is = is;\n\tfz_try(ctx)\n\t{\n\t\tfz_find_color_converter(ctx, &cached->base, is, cc->ds, ss, params);\n\t\tcached->hash = fz_new_hash_table(ctx, 256, n * sizeof(float), -1, fz_free);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tfz_drop_color_converter(ctx, &cached->base);\n\t\tfz_drop_hash_table(ctx, cached->hash);\n\t\tfz_free(ctx, cached);\n\t\tcc->opaque = NULL;\n\t\tfz_rethrow(ctx);\n\t}\n}", "target": 0}
{"code": "void PrintWebViewHelper::PrintPreviewContext::FinalizePrintReadyDocument() {\n  DCHECK(IsRendering());\n  base::TimeTicks begin_time = base::TimeTicks::Now();\n  metafile_->FinishDocument();\n  if (print_ready_metafile_page_count_ <= 0) {\n    NOTREACHED();\n    return;\n  }\n  UMA_HISTOGRAM_MEDIUM_TIMES(\"PrintPreview.RenderToPDFTime\",\n                             document_render_time_);\n  base::TimeDelta total_time =\n      (base::TimeTicks::Now() - begin_time) + document_render_time_;\n  UMA_HISTOGRAM_MEDIUM_TIMES(\"PrintPreview.RenderAndGeneratePDFTime\",\n                             total_time);\n  UMA_HISTOGRAM_MEDIUM_TIMES(\"PrintPreview.RenderAndGeneratePDFTimeAvgPerPage\",\n                             total_time / pages_to_render_.size());\n}", "target": 0}
{"code": "static int decode_access(struct xdr_stream *xdr, struct nfs4_accessres *access)\n{\n\t__be32 *p;\n\tuint32_t supp, acc;\n\tint status;\n\tstatus = decode_op_hdr(xdr, OP_ACCESS);\n\tif (status)\n\t\treturn status;\n\tp = xdr_inline_decode(xdr, 8);\n\tif (unlikely(!p))\n\t\tgoto out_overflow;\n\tsupp = be32_to_cpup(p++);\n\tacc = be32_to_cpup(p);\n\taccess->supported = supp;\n\taccess->access = acc;\n\treturn 0;\nout_overflow:\n\tprint_overflow_msg(__func__, xdr);\n\treturn -EIO;\n}", "target": 0}
{"code": "bool Archive::Open(const wchar *Name,uint Mode)\n{\n#ifdef USE_QOPEN\n  QOpen.Unload();\n#endif\n#ifdef USE_ARCMEM\n  if (Cmd->ArcInMem)\n  {\n    wcsncpyz(FileName,Name,ASIZE(FileName));\n    ArcMem.Load(Cmd->ArcMemData,Cmd->ArcMemSize);\n    Cmd->SetArcInMem(NULL,0); \n    return true;\n  }\n#endif\n  return File::Open(Name,Mode);\n}", "target": 0}
{"code": "void HTMLButtonElement::setType(const AtomicString& type)\n{\n    setAttribute(typeAttr, type);\n}", "target": 0}
{"code": "RGWOp *RGWHandler_REST_Obj_S3::op_get()\n{\n  if (is_acl_op()) {\n    return new RGWGetACLs_ObjStore_S3;\n  } else if (s->info.args.exists(\"uploadId\")) {\n    return new RGWListMultipart_ObjStore_S3;\n  } else if (s->info.args.exists(\"layout\")) {\n    return new RGWGetObjLayout_ObjStore_S3;\n  } else if (is_tagging_op()) {\n    return new RGWGetObjTags_ObjStore_S3;\n  } else if (is_obj_retention_op()) {\n    return new RGWGetObjRetention_ObjStore_S3;\n  } else if (is_obj_legal_hold_op()) {\n    return new RGWGetObjLegalHold_ObjStore_S3;\n  }\n  return get_obj_op(true);\n}", "target": 0}
{"code": "  size_t removeIf(const HeaderMap::HeaderMatchPredicate& predicate) override {\n    return HeaderMapImpl::removeIf(predicate);\n  }", "target": 0}
{"code": "static ssize_t driver_override_show(struct device *_dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct amba_device *dev = to_amba_device(_dev);\n\tif (!dev->driver_override)\n\t\treturn 0;\n\treturn sprintf(buf, \"%s\\n\", dev->driver_override);\n}", "target": 0}
{"code": "static int clone_finish_inode_update(struct btrfs_trans_handle *trans,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u64 endoff,\n\t\t\t\t     const u64 destoff,\n\t\t\t\t     const u64 olen,\n\t\t\t\t     int no_time_update)\n{\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tint ret;\n\tinode_inc_iversion(inode);\n\tif (!no_time_update)\n\t\tinode->i_mtime = inode->i_ctime = current_time(inode);\n\tif (endoff > destoff + olen)\n\t\tendoff = destoff + olen;\n\tif (endoff > inode->i_size)\n\t\tbtrfs_i_size_write(BTRFS_I(inode), endoff);\n\tret = btrfs_update_inode(trans, root, inode);\n\tif (ret) {\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_end_transaction(trans);\n\t\tgoto out;\n\t}\n\tret = btrfs_end_transaction(trans);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static void *rose_neigh_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\t++*pos;\n\treturn (v == SEQ_START_TOKEN) ? rose_neigh_list\n\t\t: ((struct rose_neigh *)v)->next;\n}", "target": 0}
{"code": "void replace_strings_append(REPLACE *rep, DYNAMIC_STRING* ds,\n                            const char *str,\n                            int len __attribute__((unused)))\n{\n  reg1 REPLACE *rep_pos;\n  reg2 REPLACE_STRING *rep_str;\n  const char *start, *from;\n  DBUG_ENTER(\"replace_strings_append\");\n  start= from= str;\n  rep_pos=rep+1;\n  for (;;)\n  {\n    DBUG_PRINT(\"info\", (\"Looping through states\"));\n    while (!rep_pos->found)\n      rep_pos= rep_pos->next[(uchar) *from++];\n    if (!(rep_str = ((REPLACE_STRING*) rep_pos))->replace_string)\n    {\n      dynstr_append_mem(ds, start, from - start - 1);\n      DBUG_PRINT(\"exit\", (\"Found no more string to replace, appended: %s\", start));\n      DBUG_VOID_RETURN;\n    }\n    DBUG_PRINT(\"info\", (\"found: %d, to_offset: %u, from_offset: %d, string: %s\",\n                        rep_str->found, rep_str->to_offset,\n                        rep_str->from_offset, rep_str->replace_string));\n    dynstr_append_mem(ds, start, (from - rep_str->to_offset) - start);\n    dynstr_append_mem(ds, rep_str->replace_string,\n                      strlen(rep_str->replace_string));\n    if (!*(from-=rep_str->from_offset) && rep_pos->found != 2)\n    {\n      DBUG_PRINT(\"exit\", (\"Found end of from string\"));\n      DBUG_VOID_RETURN;\n    }\n    DBUG_ASSERT(from <= str+len);\n    start= from;\n    rep_pos=rep;\n  }\n}", "target": 0}
{"code": "    Xmpdatum& Xmpdatum::operator=(const Value& value)\n    {\n        setValue(&value);\n        return *this;\n    }", "target": 0}
{"code": "static int _mysql_rollback_txn(void *conn, const sasl_utils_t *utils)\n{\n    return _mysql_exec(conn, \"ROLLBACK\", NULL, 0, NULL, utils);\n}", "target": 0}
{"code": "decode_OFPAT_RAW11_SET_NW_TTL(uint8_t ttl,\n                              enum ofp_version ofp_version OVS_UNUSED,\n                              struct ofpbuf *out)\n{\n    ofpact_put_SET_IP_TTL(out)->ttl = ttl;\n    return 0;\n}", "target": 0}
{"code": "void memory_failure_queue(unsigned long pfn, int flags)\n{\n\tstruct memory_failure_cpu *mf_cpu;\n\tunsigned long proc_flags;\n\tstruct memory_failure_entry entry = {\n\t\t.pfn =\t\tpfn,\n\t\t.flags =\tflags,\n\t};\n\tmf_cpu = &get_cpu_var(memory_failure_cpu);\n\tspin_lock_irqsave(&mf_cpu->lock, proc_flags);\n\tif (kfifo_put(&mf_cpu->fifo, entry))\n\t\tschedule_work_on(smp_processor_id(), &mf_cpu->work);\n\telse\n\t\tpr_err(\"Memory failure: buffer overflow when queuing memory failure at %#lx\\n\",\n\t\t       pfn);\n\tspin_unlock_irqrestore(&mf_cpu->lock, proc_flags);\n\tput_cpu_var(memory_failure_cpu);\n}", "target": 0}
{"code": "void sock_prot_inuse_add(struct net *net, struct proto *prot, int val)\n{\n\t__this_cpu_add(prot_inuse.val[prot->inuse_idx], val);\n}", "target": 0}
{"code": "static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\t*data = &iterator->current;\n}", "target": 0}
{"code": "void my_coll_agg_error(DTCollation &c1, DTCollation &c2, DTCollation &c3,\n                       const char *fname)\n{\n  my_error(ER_CANT_AGGREGATE_3COLLATIONS,MYF(0),\n  \t   c1.collation->name,c1.derivation_name(),\n\t   c2.collation->name,c2.derivation_name(),\n\t   c3.collation->name,c3.derivation_name(),\n\t   fname);\n}", "target": 0}
{"code": "zstatus(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    switch (r_type(op)) {\n        case t_file:\n            {\n                stream *s;\n                make_bool(op, (file_is_valid(s, op) ? 1 : 0));\n            }\n            return 0;\n        case t_string:\n            {\n                gs_parsed_file_name_t pname;\n                struct stat fstat;\n                int code = parse_file_name(op, &pname,\n                                           i_ctx_p->LockFilePermissions, imemory);\n                if (code < 0) {\n                    if (code == gs_error_undefinedfilename) {\n                        make_bool(op, 0);\n                        code = 0;\n                    }\n                    return code;\n                }\n                code = gs_terminate_file_name(&pname, imemory, \"status\");\n                if (code < 0)\n                    return code;\n                if ((code = check_file_permissions(i_ctx_p, pname.fname, pname.len,\n                                       pname.iodev, \"PermitFileReading\")) >= 0) {\n                    code = (*pname.iodev->procs.file_status)(pname.iodev,\n                                                       pname.fname, &fstat);\n                }\n                switch (code) {\n                    case 0:\n                        check_ostack(4);\n                        push(4);\n                        make_int(op - 4, stat_blocks(&fstat));\n                        make_int(op - 3, fstat.st_size);\n                        if ((double)op[-4].value.intval !=\n                              (double)stat_blocks(&fstat) ||\n                            (double)op[-3].value.intval !=\n                              (double)fstat.st_size\n                            )\n                            return_error(gs_error_limitcheck);\n                        make_int(op - 2, fstat.st_mtime);\n                        make_int(op - 1, fstat.st_ctime);\n                        make_bool(op, 1);\n                        break;\n                    case gs_error_undefinedfilename:\n                        make_bool(op, 0);\n                        code = 0;\n                }\n                gs_free_file_name(&pname, \"status\");\n                return code;\n            }\n        default:\n            return_op_typecheck(op);\n    }\n}", "target": 0}
{"code": "smtp_command_timeout_exit(void)\n{\nlog_write(L_lost_incoming_connection,\n\t  LOG_MAIN, \"SMTP command timeout on%s connection from %s\",\n\t  tls_in.active.sock >= 0 ? \" TLS\" : \"\", host_and_ident(FALSE));\nif (smtp_batched_input)\n  moan_smtp_batch(NULL, \"421 SMTP command timeout\"); \nsmtp_notquit_exit(US\"command-timeout\", US\"421\",\n  US\"%s: SMTP command timeout - closing connection\",\n  smtp_active_hostname);\nexim_exit(EXIT_FAILURE, US\"receiving\");\n}", "target": 0}
{"code": "static int get_qcx(Jpeg2000DecoderContext *s, int n, Jpeg2000QuantStyle *q)\n{\n    int i, x;\n    if (bytestream2_get_bytes_left(&s->g) < 1)\n        return AVERROR_INVALIDDATA;\n    x = bytestream2_get_byteu(&s->g); \n    q->nguardbits = x >> 5;\n    q->quantsty   = x & 0x1f;\n    if (q->quantsty == JPEG2000_QSTY_NONE) {\n        n -= 3;\n        if (bytestream2_get_bytes_left(&s->g) < n ||\n            n > JPEG2000_MAX_DECLEVELS*3)\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < n; i++)\n            q->expn[i] = bytestream2_get_byteu(&s->g) >> 3;\n    } else if (q->quantsty == JPEG2000_QSTY_SI) {\n        if (bytestream2_get_bytes_left(&s->g) < 2)\n            return AVERROR_INVALIDDATA;\n        x          = bytestream2_get_be16u(&s->g);\n        q->expn[0] = x >> 11;\n        q->mant[0] = x & 0x7ff;\n        for (i = 1; i < JPEG2000_MAX_DECLEVELS * 3; i++) {\n            int curexpn = FFMAX(0, q->expn[0] - (i - 1) / 3);\n            q->expn[i] = curexpn;\n            q->mant[i] = q->mant[0];\n        }\n    } else {\n        n = (n - 3) >> 1;\n        if (bytestream2_get_bytes_left(&s->g) < 2 * n ||\n            n > JPEG2000_MAX_DECLEVELS*3)\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < n; i++) {\n            x          = bytestream2_get_be16u(&s->g);\n            q->expn[i] = x >> 11;\n            q->mant[i] = x & 0x7ff;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "get_env(const char *name)\n{\n\tchar *value;\n\tvalue = secure_getenv(name);\n\tif (value)\n\t\tvalue = strdup(value);\n\treturn value;\n}", "target": 0}
{"code": "int ipmi_request_settime(struct ipmi_user *user,\n\t\t\t struct ipmi_addr *addr,\n\t\t\t long             msgid,\n\t\t\t struct kernel_ipmi_msg  *msg,\n\t\t\t void             *user_msg_data,\n\t\t\t int              priority,\n\t\t\t int              retries,\n\t\t\t unsigned int     retry_time_ms)\n{\n\tunsigned char saddr = 0, lun = 0;\n\tint rv, index;\n\tif (!user)\n\t\treturn -EINVAL;\n\tuser = acquire_ipmi_user(user, &index);\n\tif (!user)\n\t\treturn -ENODEV;\n\trv = check_addr(user->intf, addr, &saddr, &lun);\n\tif (!rv)\n\t\trv = i_ipmi_request(user,\n\t\t\t\t    user->intf,\n\t\t\t\t    addr,\n\t\t\t\t    msgid,\n\t\t\t\t    msg,\n\t\t\t\t    user_msg_data,\n\t\t\t\t    NULL, NULL,\n\t\t\t\t    priority,\n\t\t\t\t    saddr,\n\t\t\t\t    lun,\n\t\t\t\t    retries,\n\t\t\t\t    retry_time_ms);\n\trelease_ipmi_user(user, index);\n\treturn rv;\n}", "target": 0}
{"code": "join_tab_cmp(const void *dummy, const void* ptr1, const void* ptr2)\n{\n  JOIN_TAB *jt1= *(JOIN_TAB**) ptr1;\n  JOIN_TAB *jt2= *(JOIN_TAB**) ptr2;\n  int cmp;\n  if ((cmp= compare_embedding_subqueries(jt1, jt2)) != 0)\n    return cmp;\n  if (jt1->dependent & jt2->table->map)\n    return 1;\n  if (jt2->dependent & jt1->table->map)\n    return -1;  \n  if (jt1->found_records > jt2->found_records)\n    return 1;\n  if (jt1->found_records < jt2->found_records)\n    return -1; \n  return jt1 > jt2 ? 1 : (jt1 < jt2 ? -1 : 0);\n}", "target": 0}
{"code": "static bool imap_is_valid_tag(const char *tag)\n{\n\tfor (; *tag != '\\0'; tag++) {\n\t\tswitch (*tag) {\n\t\tcase '+':\n\t\tcase '(':\n\t\tcase ')':\n\t\tcase '{':\n\t\tcase '/':\n\t\tcase ' ':\n\t\tcase '%':\n\t\tcase '*':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\t\treturn FALSE;\n\t\tdefault:\n\t\t\tif (*tag < ' ') \n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "nfs4_proc_lookup_mountpoint(struct inode *dir, struct qstr *name,\n\t\t\t    struct nfs_fh *fhandle, struct nfs_fattr *fattr)\n{\n\tint status;\n\tstruct rpc_clnt *client = rpc_clone_client(NFS_CLIENT(dir));\n\tstatus = nfs4_proc_lookup_common(&client, dir, name, fhandle, fattr);\n\tif (status < 0) {\n\t\trpc_shutdown_client(client);\n\t\treturn ERR_PTR(status);\n\t}\n\treturn client;\n}", "target": 0}
{"code": "unlock_encryption_data_unref (UnlockEncryptionData *data)\n{\n  data->refcount--;\n  if (data->refcount == 0)\n    {\n      g_object_unref (data->device);\n      g_free (data);\n    }\n}", "target": 0}
{"code": "m_real_cwyear(union DateData *x)\n{\n    VALUE nth, ry;\n    int year;\n    nth = m_nth(x);\n    year = m_cwyear(x);\n    if (f_zero_p(nth))\n\treturn INT2FIX(year);\n    encode_year(nth, year,\n\t\tm_gregorian_p(x) ? -1 : +1,\n\t\t&ry);\n    return ry;\n}", "target": 0}
{"code": "d_lite_gc_mark(void *ptr)\n{\n    union DateData *dat = ptr;\n    if (simple_dat_p(dat))\n\trb_gc_mark(dat->s.nth);\n    else {\n\trb_gc_mark(dat->c.nth);\n\trb_gc_mark(dat->c.sf);\n    }\n}", "target": 0}
{"code": "static bool arg_type_is_int_ptr(enum bpf_arg_type type)\n{\n\treturn type == ARG_PTR_TO_INT ||\n\t       type == ARG_PTR_TO_LONG;\n}", "target": 0}
{"code": "void smp_move_to_secure_connections_phase2(tSMP_CB* p_cb,\n                                           tSMP_INT_DATA* p_data) {\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  smp_sm_event(p_cb, SMP_SC_PHASE1_CMPLT_EVT, NULL);\n}", "target": 0}
{"code": "yang_check_string(struct lys_module *module, const char **target, char *what,\n                  char *where, char *value, struct lys_node *node)\n{\n    if (*target) {\n        LOGVAL(module->ctx, LYE_TOOMANY, (node) ? LY_VLOG_LYS : LY_VLOG_NONE, node, what, where);\n        free(value);\n        return 1;\n    } else {\n        *target = lydict_insert_zc(module->ctx, value);\n        return 0;\n    }\n}", "target": 0}
{"code": "ModuleExport size_t RegisterPS3Image(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"PS3\",\"EPS3\",\"Level III Encapsulated PostScript\");\n  entry->encoder=(EncodeImageHandler *) WritePS3Image;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS3\",\"PS3\",\"Level III PostScript\");\n  entry->encoder=(EncodeImageHandler *) WritePS3Image;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderEncoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false);\n}", "target": 0}
{"code": "*/\nPHP_METHOD(DateTimeImmutable, setTimestamp)\n{\n\tzval *object, *new_object;\n\tlong  timestamp;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"Ol\", &object, date_ce_immutable, &timestamp) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tnew_object = date_clone_immutable(object TSRMLS_CC);\n\tphp_date_timestamp_set(new_object, timestamp, return_value TSRMLS_CC);\n\tRETURN_ZVAL(new_object, 0, 1);", "target": 0}
{"code": "scoped_refptr<GLSurface> CreateViewGLSurfaceOzoneSurfacelessSurfaceImpl(\n    gfx::AcceleratedWidget window) {\n  std::unique_ptr<ui::SurfaceOzoneEGL> surface_ozone =\n      ui::OzonePlatform::GetInstance()\n          ->GetSurfaceFactoryOzone()\n          ->CreateSurfacelessEGLSurfaceForWidget(window);\n  if (!surface_ozone)\n    return nullptr;\n  scoped_refptr<GLSurface> surface = new GLSurfaceOzoneSurfacelessSurfaceImpl(\n      std::move(surface_ozone), window);\n  if (!surface->Initialize())\n    return nullptr;\n  return surface;\n}", "target": 0}
{"code": "static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "static uint32_t U24_AT(const uint8_t *ptr) {\n return ptr[0] << 16 | ptr[1] << 8 | ptr[2];\n}", "target": 0}
{"code": "prologInitProcessor(XML_Parser parser, const char *s, const char *end,\n                    const char **nextPtr) {\n  enum XML_Error result = initializeEncoding(parser);\n  if (result != XML_ERROR_NONE)\n    return result;\n  parser->m_processor = prologProcessor;\n  return prologProcessor(parser, s, end, nextPtr);\n}", "target": 0}
{"code": "_XkbWriteAtoms(char *wire,Atom *atoms,int maxAtoms,int swap)\n{\nregister unsigned int i;\nAtom *atm;\n    atm = (Atom *)wire;\n    for (i=0;i<maxAtoms;i++) {\n\tif (atoms[i]!=None) {\n\t    *atm= atoms[i];\n\t    if (swap) {\n\t\tregister int n;\n\t\tswapl(atm,n);\n\t    }\n\t    atm++;\n\t}\n    }\n    return (char *)atm;\n}", "target": 0}
{"code": "gfx::ColorSpace HTMLMediaElement::TargetColorSpace() {\n  const LocalFrame* frame = GetDocument().GetFrame();\n  if (!frame)\n    return gfx::ColorSpace();\n  return frame->GetPage()->GetChromeClient().GetScreenInfo().color_space;\n}", "target": 0}
{"code": "static bool bnx2x_get_load_status(struct bnx2x *bp, int engine)\n{\n\tu32 mask = (engine ? BNX2X_PATH1_LOAD_CNT_MASK :\n\t\t\t     BNX2X_PATH0_LOAD_CNT_MASK);\n\tu32 shift = (engine ? BNX2X_PATH1_LOAD_CNT_SHIFT :\n\t\t\t     BNX2X_PATH0_LOAD_CNT_SHIFT);\n\tu32 val = REG_RD(bp, BNX2X_RECOVERY_GLOB_REG);\n\tDP(NETIF_MSG_HW | NETIF_MSG_IFUP, \"GLOB_REG=0x%08x\\n\", val);\n\tval = (val & mask) >> shift;\n\tDP(NETIF_MSG_HW | NETIF_MSG_IFUP, \"load mask for engine %d = 0x%x\\n\",\n\t   engine, val);\n\treturn val != 0;\n}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleGetShaderInfoLog(\n    uint32 immediate_data_size, const gles2::GetShaderInfoLog& c) {\n  GLuint shader = c.shader;\n  uint32 bucket_id = static_cast<uint32>(c.bucket_id);\n  Bucket* bucket = CreateBucket(bucket_id);\n  ShaderManager::ShaderInfo* info = GetShaderInfoNotProgram(\n      shader, \"glGetShaderInfoLog\");\n  if (!info) {\n    bucket->SetSize(0);\n    return error::kNoError;\n  }\n  bucket->SetFromString(info->log_info());\n  return error::kNoError;\n}", "target": 0}
{"code": "static inline uint8_t ide_atapi_set_profile(uint8_t *buf, uint8_t *index,\n                                            uint16_t profile)\n{\n    uint8_t *buf_profile = buf + 12; \n    buf_profile += ((*index) * 4); \n    cpu_to_ube16 (buf_profile, profile);\n    buf_profile[2] = ((buf_profile[0] == buf[6]) && (buf_profile[1] == buf[7]));\n    (*index)++;\n    buf[11] += 4; \n    return 4;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, SortElimTrailingFieldsReverse) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1 << \"c\" << 1 << \"d\" << 1));\n    runQuerySortProj(fromjson(\"{a: 5, b: 6}\"), BSON(\"c\" << -1), BSONObj());\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {c: -1}, limit: 0, node: {sortKeyGen: \"\n        \"{node: {cscan: {dir: 1, filter: {a: 5, b: 6}}}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: \"\n        \"{filter: null, dir: -1, pattern: {a: 1, b: 1, c: 1, d: 1}}}}}\");\n}", "target": 0}
{"code": "static int memory_access_size(MemoryRegion *mr, unsigned l, hwaddr addr)\n{\n    unsigned access_size_max = mr->ops->valid.max_access_size;\n    if (access_size_max == 0) {\n        access_size_max = 4;\n    }\n    if (!mr->ops->impl.unaligned) {\n        unsigned align_size_max = addr & -addr;\n        if (align_size_max != 0 && align_size_max < access_size_max) {\n            access_size_max = align_size_max;\n        }\n    }\n    if (l > access_size_max) {\n        l = access_size_max;\n    }\n    if (l & (l - 1)) {\n        l = 1 << (qemu_fls(l) - 1);\n    }\n    return l;\n}", "target": 0}
{"code": "parse_char_property(Node** np, OnigToken* tok, UChar** src, UChar* end,\n\t\t    ScanEnv* env)\n{\n  int r, ctype;\n  CClassNode* cc;\n  ctype = fetch_char_property_to_ctype(src, end, env);\n  if (ctype < 0) return ctype;\n  *np = node_new_cclass();\n  CHECK_NULL_RETURN_MEMERR(*np);\n  cc = NCCLASS(*np);\n  r = add_ctype_to_cc(cc, ctype, 0, 0, env);\n  if (r != 0) return r;\n  if (tok->u.prop.not != 0) NCCLASS_SET_NOT(cc);\n  if (IS_IGNORECASE(env->option)) {\n    if (ctype != ONIGENC_CTYPE_ASCII)\n      r = cclass_case_fold(np, cc, cc, env);\n  }\n  return r;\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_do_5_2_1_siminit(struct net *net,\n\t\t\t\t    const struct sctp_endpoint *ep,\n\t\t\t\t    const struct sctp_association *asoc,\n\t\t\t\t    const sctp_subtype_t type,\n\t\t\t\t    void *arg,\n\t\t\t\t    sctp_cmd_seq_t *commands)\n{\n\treturn sctp_sf_do_unexpected_init(net, ep, asoc, type, arg, commands);\n}", "target": 0}
{"code": "u32 tipc_node_get_addr(struct tipc_node *node)\n{\n\treturn (node) ? node->addr : 0;\n}", "target": 0}
{"code": "int lcc_network_buffer_add_value (lcc_network_buffer_t *nb, \n    const lcc_value_list_t *vl)\n{\n  int status;\n  if ((nb == NULL) || (vl == NULL))\n    return (EINVAL);\n  status = nb_add_value_list (nb, vl);\n  return (status);\n} ", "target": 0}
{"code": "Bool gf_avc_slice_is_intra(AVCState *avc)\n{\n\tswitch (avc->s_info.slice_type) {\n\tcase GF_AVC_TYPE_I:\n\tcase GF_AVC_TYPE2_I:\n\tcase GF_AVC_TYPE_SI:\n\tcase GF_AVC_TYPE2_SI:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "unsigned long get_zeroed_page(gfp_t gfp_mask)\n{\n\treturn __get_free_pages(gfp_mask | __GFP_ZERO, 0);\n}", "target": 0}
{"code": "void HTMLMediaElement::FlingingStopped() {\n  if (GetWebMediaPlayer())\n    GetWebMediaPlayer()->FlingingStopped();\n}", "target": 0}
{"code": "absl::optional<CelValue> ResponseWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Code) {\n    auto code = info_.responseCode();\n    if (code.has_value()) {\n      return CelValue::CreateInt64(code.value());\n    }\n    return {};\n  } else if (value == Size) {\n    return CelValue::CreateInt64(info_.bytesSent());\n  } else if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Trailers) {\n    return CelValue::CreateMap(&trailers_);\n  } else if (value == Flags) {\n    return CelValue::CreateInt64(info_.responseFlags());\n  } else if (value == GrpcStatus) {\n    auto const& optional_status = Grpc::Common::getGrpcStatus(\n        trailers_.value_ ? *trailers_.value_ : *Http::StaticEmptyHeaders::get().response_trailers,\n        headers_.value_ ? *headers_.value_ : *Http::StaticEmptyHeaders::get().response_headers,\n        info_);\n    if (optional_status.has_value()) {\n      return CelValue::CreateInt64(optional_status.value());\n    }\n    return {};\n  } else if (value == TotalSize) {\n    return CelValue::CreateInt64(info_.bytesSent() +\n                                 (headers_.value_ ? headers_.value_->byteSize() : 0) +\n                                 (trailers_.value_ ? trailers_.value_->byteSize() : 0));\n  } else if (value == CodeDetails) {\n    const absl::optional<std::string>& details = info_.responseCodeDetails();\n    if (details.has_value()) {\n      return CelValue::CreateString(&details.value());\n    }\n    return {};\n  }\n  return {};\n}", "target": 0}
{"code": "irc_server_get_alternate_nick (struct t_irc_server *server)\n{\n    static char nick[64];\n    char str_number[64];\n    int nick_index, length_nick, length_number;\n    nick[0] = '\\0';\n    if (server->nick_alternate_number < 0)\n    {\n        nick_index = irc_server_get_nick_index (server);\n        if (nick_index < 0)\n            nick_index = 0;\n        else\n        {\n            nick_index = (nick_index + 1) % server->nicks_count;\n            if ((nick_index == 0) && (server->nick_first_tried < 0))\n                server->nick_first_tried = 0;\n        }\n        if (nick_index != server->nick_first_tried)\n        {\n            snprintf (nick, sizeof (nick),\n                      \"%s\", server->nicks_array[nick_index]);\n            return nick;\n        }\n        if (!IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_NICKS_ALTERNATE))\n            return NULL;\n        server->nick_alternate_number = 0;\n        snprintf (nick, sizeof (nick), \"%s\", server->nicks_array[0]);\n    }\n    else\n        snprintf (nick, sizeof (nick), \"%s\", server->nick);\n    if (strlen (nick) < 9)\n    {\n        strcat (nick, \"_\");\n        return nick;\n    }\n    server->nick_alternate_number++;\n    if (server->nick_alternate_number > 99)\n        return NULL;\n    nick[9] = '\\0';\n    snprintf (str_number, sizeof (str_number),\n              \"%d\", server->nick_alternate_number);\n    length_nick = strlen (nick);\n    length_number = strlen (str_number);\n    if (length_number > length_nick)\n        return NULL;\n    memcpy (nick + length_nick - length_number, str_number, length_number);\n    return nick;\n}", "target": 0}
{"code": "onig_get_options(const regex_t* reg)\n{\n  return reg->options;\n}", "target": 0}
{"code": "int __weak phys_mem_access_prot_allowed(struct file *file,\n\tunsigned long pfn, unsigned long size, pgprot_t *vma_prot)\n{\n\treturn 1;\n}", "target": 0}
{"code": "static bool is_suppressed_warning(int severity)\n{\n    if (is_valid_warning(severity) && !(severity & ERR_USAGE))\n        return !(warning_state[WARN_IDX(severity)] & WARN_ST_ENABLED);\n    else\n        return false;\n}", "target": 0}
{"code": "struct task_struct *curr_task(int cpu)\n{\n\treturn cpu_curr(cpu);\n}", "target": 0}
{"code": "FrameLoadType FrameLoader::loadType() const\n{\n    return m_loadType;\n}", "target": 0}
{"code": "SWFRect SWFShape_getEdgeBounds(SWFShape shape)\n{\n\tif(shape->useVersion == SWF_SHAPE4)\n\t\treturn shape->edgeBounds;\n\telse\n\t\treturn NULL;\n}", "target": 0}
{"code": "bool OmniboxViewWin::CanPasteAndGo(const string16& text) const {\n  return !popup_window_mode_ && model_->CanPasteAndGo(text);\n}", "target": 0}
{"code": "    int Erase::eraseXmpData(Exiv2::Image* image) const\n    {\n        if (Params::instance().verbose_ && image->xmpData().count() > 0) {\n            std::cout << _(\"Erasing XMP data from the file\") << std::endl;\n        }\n        image->clearXmpData();  \n        image->clearXmpPacket();\n        return 0;\n    }", "target": 0}
{"code": "void RenderView::OnDragSourceEndedOrMoved(const gfx::Point& client_point,\n                                          const gfx::Point& screen_point,\n                                          bool ended,\n                                          WebDragOperation op) {\n  if (ended) {\n    webview()->dragSourceEndedAt(client_point, screen_point, op);\n  } else {\n    webview()->dragSourceMovedTo(client_point, screen_point, op);\n  }\n}", "target": 0}
{"code": "TEST_F(ExtractorTest, TestWrongParamToken) {\n  auto headers = TestRequestHeaderMapImpl{{\":path\", \"/path?wrong_token=jwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 0);\n}", "target": 0}
{"code": "static void add_prefix(smart_str* loc_name, char* key_name)\n{\n\tif( strncmp(key_name , LOC_PRIVATE_TAG , 7) == 0 ){\n\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);\n\t\tsmart_str_appendl(loc_name, PRIVATE_PREFIX , sizeof(PRIVATE_PREFIX)-1);\n\t}\n}", "target": 0}
{"code": "  virtual ~RootWindowScreenPositionClient() {}", "target": 0}
{"code": "static int jpc_cox_getcompparms(jpc_ms_t *ms, jpc_cstate_t *cstate,\n  jas_stream_t *in, int prtflag, jpc_coxcp_t *compparms)\n{\n\tuint_fast8_t tmp;\n\tint i;\n\tms = 0;\n\tcstate = 0;\n\tif (jpc_getuint8(in, &compparms->numdlvls) ||\n\t  jpc_getuint8(in, &compparms->cblkwidthval) ||\n\t  jpc_getuint8(in, &compparms->cblkheightval) ||\n\t  jpc_getuint8(in, &compparms->cblksty) ||\n\t  jpc_getuint8(in, &compparms->qmfbid)) {\n\t\treturn -1;\n\t}\n\tcompparms->numrlvls = compparms->numdlvls + 1;\n\tif (compparms->numrlvls > JPC_MAXRLVLS) {\n\t\tgoto error;\n\t}\n\tif (prtflag) {\n\t\tfor (i = 0; i < compparms->numrlvls; ++i) {\n\t\t\tif (jpc_getuint8(in, &tmp)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tcompparms->rlvls[i].parwidthval = tmp & 0xf;\n\t\t\tcompparms->rlvls[i].parheightval = (tmp >> 4) & 0xf;\n\t\t}\n\t\tcompparms->csty |= JPC_COX_PRT;\n\t}\n\tif (jas_stream_eof(in)) {\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tif (compparms) {\n\t\tjpc_cox_destroycompparms(compparms);\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "static void be16_to_cpu_n(const u8 *_source, u8 *_target, u32 n)\n{\n\tconst __be16 *source = (const __be16 *)_source;\n\tu16 *target = (u16 *)_target;\n\tu32 i;\n\tfor (i = 0; i < n/2; i++)\n\t\ttarget[i] = be16_to_cpu(source[i]);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    if (out_shape.num_elements() == 0) return;  \n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "int PDFiumEngine::Form_GetRotation(FPDF_FORMFILLINFO* param, FPDF_PAGE page) {\n  return 0;\n}", "target": 0}
{"code": "static ssize_t write_mem(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t written, sz;\n\tunsigned long copied;\n\tvoid *ptr;\n\tif (p != *ppos)\n\t\treturn -EFBIG;\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\twritten = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n #endif\n \twhile (count > 0) {\n\t\tint allowed;\n \t\tsz = size_inside_page(p, count);\n\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n\t\tif (!allowed)\n \t\t\treturn -EPERM;\n\t\tif (allowed == 1) {\n\t\t\tptr = xlate_dev_mem_ptr(p);\n\t\t\tif (!ptr) {\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tcopied = copy_from_user(ptr, buf, sz);\n\t\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\t\tif (copied) {\n\t\t\t\twritten += sz - copied;\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n \t\t}\n \t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n\t*ppos += written;\n\treturn written;\n}", "target": 0}
{"code": "PassRefPtr<AccessibilityUIElement> AccessibilityUIElement::elementAtPoint(int x, int y)\n{\n    return 0;\n}", "target": 0}
{"code": "int ipmi_create_user(unsigned int          if_num,\n\t\t     const struct ipmi_user_hndl *handler,\n\t\t     void                  *handler_data,\n\t\t     struct ipmi_user      **user)\n{\n\tunsigned long flags;\n\tstruct ipmi_user *new_user;\n\tint           rv, index;\n\tstruct ipmi_smi *intf;\n\tif (handler == NULL)\n\t\treturn -EINVAL;\n\trv = ipmi_init_msghandler();\n\tif (rv)\n\t\treturn rv;\n\tnew_user = kmalloc(sizeof(*new_user), GFP_KERNEL);\n\tif (!new_user)\n\t\treturn -ENOMEM;\n\tindex = srcu_read_lock(&ipmi_interfaces_srcu);\n\tlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\n\t\tif (intf->intf_num == if_num)\n\t\t\tgoto found;\n\t}\n\trv = -EINVAL;\n\tgoto out_kfree;\n found:\n\tINIT_WORK(&new_user->remove_work, free_user_work);\n\trv = init_srcu_struct(&new_user->release_barrier);\n\tif (rv)\n\t\tgoto out_kfree;\n\tif (!try_module_get(intf->owner)) {\n\t\trv = -ENODEV;\n\t\tgoto out_kfree;\n\t}\n\tkref_get(&intf->refcount);\n\tkref_init(&new_user->refcount);\n\tnew_user->handler = handler;\n\tnew_user->handler_data = handler_data;\n\tnew_user->intf = intf;\n\tnew_user->gets_events = false;\n\trcu_assign_pointer(new_user->self, new_user);\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tlist_add_rcu(&new_user->link, &intf->users);\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\tif (handler->ipmi_watchdog_pretimeout)\n\t\tsmi_add_watch(intf, IPMI_WATCH_MASK_CHECK_WATCHDOG);\n\tsrcu_read_unlock(&ipmi_interfaces_srcu, index);\n\t*user = new_user;\n\treturn 0;\nout_kfree:\n\tsrcu_read_unlock(&ipmi_interfaces_srcu, index);\n\tkfree(new_user);\n\treturn rv;\n}", "target": 0}
{"code": "SPL_METHOD(Array, __construct)\n{\n\tzval *object = getThis();\n\tspl_array_object *intern;\n\tzval **array;\n\tlong ar_flags = 0;\n\tzend_class_entry *ce_get_iterator = spl_ce_Iterator;\n\tzend_error_handling error_handling;\n\tif (ZEND_NUM_ARGS() == 0) {\n\t\treturn; \n\t}\n\tzend_replace_error_handling(EH_THROW, spl_ce_InvalidArgumentException, &error_handling TSRMLS_CC);\n\tintern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z|lC\", &array, &ar_flags, &ce_get_iterator) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\tif (ZEND_NUM_ARGS() > 2) {\n\t\tintern->ce_get_iterator = ce_get_iterator;\n\t}\n\tar_flags &= ~SPL_ARRAY_INT_MASK;\n\tspl_array_set_array(object, intern, array, ar_flags, ZEND_NUM_ARGS() == 1 TSRMLS_CC);\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 0}
{"code": "client_send_reply_raw(struct client *client,\n\t\t      const char *prefix, const char *resp_code,\n\t\t      const char *text, bool tagged)\n{\n\tstruct imap_client *imap_client = (struct imap_client *)client;\n\tT_BEGIN {\n\t\tstring_t *line = t_str_new(256);\n\t\tif (tagged)\n\t\t\tstr_append(line, imap_client->cmd_tag);\n\t\telse\n\t\t\tstr_append_c(line, '*');\n\t\tstr_append_c(line, ' ');\n\t\tstr_append(line, prefix);\n\t\tstr_append_c(line, ' ');\n\t\tif (resp_code != NULL)\n\t\t\tstr_printfa(line, \"[%s] \", resp_code);\n\t\tstr_append(line, text);\n\t\tstr_append(line, \"\\r\\n\");\n\t\tclient_send_raw_data(client, str_data(line), str_len(line));\n\t} T_END;\n}", "target": 0}
{"code": "int sldns_str2wire_long_str_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tuint8_t ch = 0;\n\tconst char* pstr = str;\n\tsize_t length = 0;\n\twhile (sldns_parse_char(&ch, &pstr)) {\n\t\tif(*len < length+1)\n\t\t\treturn LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL;\n\t\trd[length++] = ch;\n\t}\n\tif(!pstr)\n\t\treturn LDNS_WIREPARSE_ERR_SYNTAX_BAD_ESCAPE;\n\t*len = length;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "static int elf_fdpic_fetch_phdrs(struct elf_fdpic_params *params,\n\t\t\t\t struct file *file)\n{\n\tstruct elf32_phdr *phdr;\n\tunsigned long size;\n\tint retval, loop;\n\tif (params->hdr.e_phentsize != sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\tif (params->hdr.e_phnum > 65536U / sizeof(struct elf_phdr))\n\t\treturn -ENOMEM;\n\tsize = params->hdr.e_phnum * sizeof(struct elf_phdr);\n\tparams->phdrs = kmalloc(size, GFP_KERNEL);\n\tif (!params->phdrs)\n\t\treturn -ENOMEM;\n\tretval = kernel_read(file, params->hdr.e_phoff,\n\t\t\t     (char *) params->phdrs, size);\n\tif (retval < 0)\n\t\treturn retval;\n\tphdr = params->phdrs;\n\tfor (loop = 0; loop < params->hdr.e_phnum; loop++, phdr++) {\n\t\tif (phdr->p_type != PT_GNU_STACK)\n\t\t\tcontinue;\n\t\tif (phdr->p_flags & PF_X)\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_EXEC_STACK;\n\t\telse\n\t\t\tparams->flags |= ELF_FDPIC_FLAG_NOEXEC_STACK;\n\t\tparams->stack_size = phdr->p_memsz;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageColorTransparent (gdImagePtr im, int color)\n{\n\tif (color < 0) {\n\t\treturn;\n\t}\n\tif (!im->trueColor) {\n\t\tif (color >= gdMaxColors) {\n\t\t\treturn;\n\t\t}\n\t\tif (im->transparent != -1) {\n\t\t\tim->alpha[im->transparent] = gdAlphaOpaque;\n\t\t}\n\t\tim->alpha[color] = gdAlphaTransparent;\n\t}\n\tim->transparent = color;\n}", "target": 0}
{"code": "  virtual void DisconnectFromWirelessNetwork(const WirelessNetwork* network) {\n    DCHECK(network);\n    if (!EnsureCrosLoaded() || !network)\n      return;\n    if (DisconnectFromNetwork(network->service_path().c_str())) {\n      if (network->type() == TYPE_WIFI) {\n        WifiNetwork* wifi = GetWirelessNetworkByPath(\n            wifi_networks_, network->service_path());\n        if (wifi) {\n          wifi->set_connected(false);\n          wifi_ = NULL;\n        }\n      } else if (network->type() == TYPE_CELLULAR) {\n        CellularNetwork* cellular = GetWirelessNetworkByPath(\n            cellular_networks_, network->service_path());\n        if (cellular) {\n          cellular->set_connected(false);\n          cellular_ = NULL;\n        }\n      }\n      NotifyNetworkManagerChanged();\n    }\n  }", "target": 0}
{"code": "void NumberFormatTest::Test20037_ScientificIntegerOverflow() {\n    IcuTestErrorCode status(*this, \"Test20037_ScientificIntegerOverflow\");\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat instance.\");\n        return;\n    }\n    Formattable result;\n    nf->parse(u\"1E-2147483648\", result, status);\n    StringPiece sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should snap to zero\",\n                 u\"0\",\n                 {sp.data(), sp.length(), US_INV});\n    result = Formattable();\n    nf->parse(u\"1E-2147483647E-1\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow and should parse only the first exponent\",\n                 u\"1E-2147483647\",\n                 {sp.data(), sp.length(), US_INV});\n    result = Formattable();\n    nf->parse(u\".0003e-2147483644\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow\",\n                 u\"3E-2147483648\",\n                 {sp.data(), sp.length(), US_INV});\n}", "target": 0}
{"code": "static struct nft_rule *nf_tables_rule_lookup(const struct nft_chain *chain,\n\t\t\t\t\t      const struct nlattr *nla)\n{\n\tif (nla == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn __nf_tables_rule_lookup(chain, be64_to_cpu(nla_get_be64(nla)));\n}", "target": 0}
{"code": "static void build_zonelists(pg_data_t *pgdat)\n{\n\tstatic int node_order[MAX_NUMNODES];\n\tint node, load, nr_nodes = 0;\n\tnodemask_t used_mask;\n\tint local_node, prev_node;\n\tlocal_node = pgdat->node_id;\n\tload = nr_online_nodes;\n\tprev_node = local_node;\n\tnodes_clear(used_mask);\n\tmemset(node_order, 0, sizeof(node_order));\n\twhile ((node = find_next_best_node(local_node, &used_mask)) >= 0) {\n\t\tif (node_distance(local_node, node) !=\n\t\t    node_distance(local_node, prev_node))\n\t\t\tnode_load[node] = load;\n\t\tnode_order[nr_nodes++] = node;\n\t\tprev_node = node;\n\t\tload--;\n\t}\n\tbuild_zonelists_in_node_order(pgdat, node_order, nr_nodes);\n\tbuild_thisnode_zonelists(pgdat);\n}", "target": 0}
{"code": "static inline bool spectre_v2_in_eibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 0}
{"code": "create_new_image (const gchar         *filename,\n                  guint                width,\n                  guint                height,\n                  GimpImageBaseType    type,\n                  GimpImageType        gdtype,\n                  gint32              *layer_ID,\n                  GeglBuffer         **buffer)\n{\n  gint32 image_ID;\n  image_ID = gimp_image_new (width, height, type);\n  gimp_image_set_filename (image_ID, filename);\n  *layer_ID = gimp_layer_new (image_ID, \"Background\", width, height,\n                              gdtype, 100, GIMP_NORMAL_MODE);\n  gimp_image_insert_layer (image_ID, *layer_ID, -1, 0);\n  *buffer = gimp_drawable_get_buffer (*layer_ID);\n  return image_ID;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, OrCollapsesToSingleScan2) {\n    addIndex(BSON(\"a\" << 1));\n    runQuery(fromjson(\"{$or: [{a:{$lt:2}}, {a:{$lt:4}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {ixscan: {pattern: {a:1}, \"\n        \"bounds: {a: [[-Infinity,4,true,false]]}}}}}\");\n}", "target": 0}
{"code": "ScriptController::ScriptController(Frame* frame)\n    : m_frame(frame)\n    , m_sourceURL(0)\n    , m_isolate(v8::Isolate::GetCurrent())\n    , m_windowShell(V8WindowShell::create(frame, mainThreadNormalWorld(), m_isolate))\n    , m_paused(false)\n    , m_windowScriptNPObject(0)\n{\n}", "target": 0}
{"code": "void WebGraphicsContext3DDefaultImpl::deleteFramebuffer(unsigned framebuffer)\n{\n    makeContextCurrent();\n    glDeleteFramebuffersEXT(1, &framebuffer);\n}", "target": 0}
{"code": "static int serialize_alloc(struct usbredirparser_priv *parser,\n                           uint8_t **state, uint8_t **pos,\n                           uint32_t *remain, uint32_t needed)\n{\n    uint8_t *old_state = *state;\n    uint32_t used, size;\n    if (*remain >= needed)\n        return 0;\n    used = *pos - *state;\n    size = (used + needed + USBREDIRPARSER_SERIALIZE_BUF_SIZE - 1) &\n           ~(USBREDIRPARSER_SERIALIZE_BUF_SIZE - 1);\n    *state = realloc(*state, size);\n    if (!*state) {\n        free(old_state);\n        ERROR(\"Out of memory allocating serialization buffer\");\n        return -1;\n    }\n    *pos = *state + used;\n    *remain = size - used;\n    return 0;\n}", "target": 0}
{"code": "void vhost_poll_start(struct vhost_poll *poll, struct file *file)\n{\n\tunsigned long mask;\n\tmask = file->f_op->poll(file, &poll->table);\n\tif (mask)\n\t\tvhost_poll_wakeup(&poll->wait, 0, 0, (void *)mask);\n}", "target": 0}
{"code": "Http::FilterHeadersStatus HeaderToMetadataFilter::decodeHeaders(Http::RequestHeaderMap& headers,\n                                                                bool) {\n  const auto* config = getConfig();\n  if (config->doRequest()) {\n    writeHeaderToMetadata(headers, config->requestRules(), *decoder_callbacks_);\n  }\n  return Http::FilterHeadersStatus::Continue;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, ShardFilterHashProjNotCovered) {\n    params.options = QueryPlannerParams::INCLUDE_SHARD_FILTER;\n    params.shardKey = BSON(\"a\"\n                           << \"hashed\");\n    addIndex(BSON(\"a\"\n                  << \"hashed\"));\n    runQuerySortProj(fromjson(\"{a: 1}\"), BSONObj(), fromjson(\"{_id : 0, a : 1}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0,a: 1}, type: 'simple', node: \"\n        \"{sharding_filter : {node: \"\n        \"{fetch: {node: \"\n        \"{ixscan: {pattern: {a: 'hashed'}}}}}}}}}\");\n}", "target": 0}
{"code": "void RuleMatchCandidateTxArrayInit(DetectEngineThreadCtx *det_ctx, uint32_t size)\n{\n    DEBUG_VALIDATE_BUG_ON(det_ctx->tx_candidates);\n    det_ctx->tx_candidates = SCCalloc(size, sizeof(RuleMatchCandidateTx));\n    if (det_ctx->tx_candidates == NULL) {\n        FatalError(SC_ERR_MEM_ALLOC, \"failed to allocate %\"PRIu64\" bytes\",\n                (uint64_t)(size * sizeof(RuleMatchCandidateTx)));\n    }\n    det_ctx->tx_candidates_size = size;\n    SCLogDebug(\"array initialized to %u elements (%\"PRIu64\" bytes)\",\n            size, (uint64_t)(size * sizeof(RuleMatchCandidateTx)));\n}", "target": 0}
{"code": "static int update_info_packs(int force)\n{\n\tchar infofile[PATH_MAX];\n\tchar name[PATH_MAX];\n\tint namelen;\n\tFILE *fp;\n\tnamelen = sprintf(infofile, \"%s/info/packs\", get_object_directory());\n\tstrcpy(name, infofile);\n\tstrcpy(name + namelen, \"+\");\n\tinit_pack_info(infofile, force);\n\tsafe_create_leading_directories(name);\n\tfp = fopen(name, \"w\");\n\tif (!fp)\n\t\treturn error(\"cannot open %s\", name);\n\twrite_pack_info_file(fp);\n\tfclose(fp);\n\tadjust_shared_perm(name);\n\trename(name, infofile);\n\treturn 0;\n}", "target": 0}
{"code": "OsVendorInit(void)\n{\n    static Bool beenHere = FALSE;\n    signal(SIGCHLD, SIG_DFL);   \n    if (!beenHere) {\n        umask(022);\n        xf86LogInit();\n    }\n#ifndef O_NONBLOCK\n#if defined(FNDELAY)\n#define O_NONBLOCK FNDELAY\n#elif defined(O_NDELAY)\n#define O_NONBLOCK O_NDELAY\n#endif\n#ifdef O_NONBLOCK\n    if (!beenHere) {\n        if (xf86PrivsElevated()) {\n            int status;\n            status = fcntl(fileno(stderr), F_GETFL, 0);\n            if (status != -1) {\n                fcntl(fileno(stderr), F_SETFL, status | O_NONBLOCK);\n            }\n        }\n    }\n#endif\n#endif\n    beenHere = TRUE;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::OnUnexpectedEventAck(UnexpectedEventAckType type) {\n  if (type == BAD_ACK_MESSAGE) {\n    bad_message::ReceivedBadMessage(process_, bad_message::RWH_BAD_ACK_MESSAGE);\n  } else if (type == UNEXPECTED_EVENT_TYPE) {\n    suppress_next_char_events_ = false;\n  }\n}", "target": 0}
{"code": "static void destroy_inodecache(void)\n{\n\tkmem_cache_destroy(udf_inode_cachep);\n}", "target": 0}
{"code": "authority_cert_dup(authority_cert_t *cert)\n{\n  authority_cert_t *out = tor_malloc(sizeof(authority_cert_t));\n  tor_assert(cert);\n  memcpy(out, cert, sizeof(authority_cert_t));\n  out->cache_info.signed_descriptor_body =\n    tor_strndup(cert->cache_info.signed_descriptor_body,\n                cert->cache_info.signed_descriptor_len);\n  out->cache_info.saved_location = SAVED_NOWHERE;\n  out->identity_key = crypto_pk_dup_key(cert->identity_key);\n  out->signing_key = crypto_pk_dup_key(cert->signing_key);\n  return out;\n}", "target": 0}
{"code": "GF_Err mhac_box_size(GF_Box *s)\n{\n\tGF_MHAConfigBox *ptr = (GF_MHAConfigBox *) s;\n\ts->size += 5;\n\tif (ptr->mha_config_size && ptr->mha_config) s->size += ptr->mha_config_size;\n\treturn GF_OK;\n}", "target": 0}
{"code": "GF_Err fdsa_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_HintSample *ptr = (GF_HintSample *) s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\te = gf_isom_box_array_write(s, ptr->packetTable, bs);\n\tif (e) return e;\n\tif (ptr->extra_data) {\n\t\te = gf_isom_box_write((GF_Box *)ptr->extra_data, bs);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static inline gpa_t hc_gpa(struct kvm_vcpu *vcpu, unsigned long a0,\n\t\t\t   unsigned long a1)\n{\n\tif (is_long_mode(vcpu))\n\t\treturn a0;\n\telse\n\t\treturn a0 | ((gpa_t)a1 << 32);\n}", "target": 0}
{"code": "zisofs_finish_entry(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tstruct isofile *file = iso9660->cur_file;\n\tunsigned char buff[16];\n\tsize_t s;\n\tint64_t tail;\n\tarchive_entry_set_size(file->entry, iso9660->zisofs.total_size);\n\ttail = wb_offset(a);\n\tmemcpy(buff, zisofs_magic, 8);\n\tset_num_731(buff+8, file->zisofs.uncompressed_size);\n\tbuff[12] = file->zisofs.header_size;\n\tbuff[13] = file->zisofs.log2_bs;\n\tbuff[14] = buff[15] = 0;\n\twb_set_offset(a, file->content.offset_of_temp);\n\tif (wb_write_to_temp(a, buff, 16) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\ts = iso9660->zisofs.block_pointers_cnt *\n\t    sizeof(iso9660->zisofs.block_pointers[0]);\n\tif (wb_write_to_temp(a, iso9660->zisofs.block_pointers, s)\n\t    != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\twb_set_offset(a, tail);\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "GF_Err mdia_on_child_box(GF_Box *s, GF_Box *a)\n{\n\tGF_MediaBox *ptr = (GF_MediaBox *)s;\n\tswitch(a->type) {\n\tcase GF_ISOM_BOX_TYPE_MDHD:\n\t\tif (ptr->mediaHeader) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->mediaHeader = (GF_MediaHeaderBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_HDLR:\n\t\tif (ptr->handler) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->handler = (GF_HandlerBox *)a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_MINF:\n\t\tif (ptr->information) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->information = (GF_MediaInformationBox *)a;\n\t\treturn GF_OK;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "nfsd4_readlink(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t       union nfsd4_op_u *u)\n{\n\tu->readlink.rl_rqstp = rqstp;\n\tu->readlink.rl_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}", "target": 0}
{"code": "void GfxImageColorMap::getColor(const unsigned char *x, GfxColor *color)\n{\n    int maxPixel, i;\n    maxPixel = (1 << bits) - 1;\n    for (i = 0; i < nComps; ++i) {\n        color->c[i] = dblToCol(decodeLow[i] + (x[i] * decodeRange[i]) / maxPixel);\n    }\n}", "target": 0}
{"code": "bool Browser::ShouldCloseWindow() {\n  if (!CanCloseWithInProgressDownloads())\n    return false;\n  if (IsFastTabUnloadEnabled())\n    return fast_unload_controller_->ShouldCloseWindow();\n  return unload_controller_->ShouldCloseWindow();\n}", "target": 0}
{"code": "static int inet6_rtm_newroute(struct sk_buff *skb, struct nlmsghdr* nlh, void *arg)\n{\n\tstruct fib6_config cfg;\n\tint err;\n\terr = rtm_to_fib6_config(skb, nlh, &cfg);\n\tif (err < 0)\n\t\treturn err;\n\tif (cfg.fc_mp)\n\t\treturn ip6_route_multipath(&cfg, 1);\n\telse\n\t\treturn ip6_route_add(&cfg);\n}", "target": 0}
{"code": "static CURLUcode parseurl_and_replace(const char *url, CURLU *u,\n                                      unsigned int flags)\n{\n  CURLUcode result;\n  CURLU tmpurl;\n  memset(&tmpurl, 0, sizeof(tmpurl));\n  result = parseurl(url, &tmpurl, flags);\n  if(!result) {\n    free_urlhandle(u);\n    *u = tmpurl;\n  }\n  else\n    free_urlhandle(&tmpurl);\n  return result;\n}", "target": 0}
{"code": "    void CrwMap::encodeBasic(const Image&      image,\n                             const CrwMapping* pCrwMapping,\n                                   CiffHeader* pHead)\n    {\n        assert(pCrwMapping != 0);\n        assert(pHead != 0);\n        ExifKey ek(pCrwMapping->tag_, Internal::groupName(pCrwMapping->ifdId_));\n        ExifData::const_iterator ed = image.exifData().findKey(ek);\n        if (ed != image.exifData().end()) {\n            DataBuf buf(ed->size());\n            ed->copy(buf.pData_, pHead->byteOrder());\n            pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf);\n        }\n        else {\n            pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_);\n        }\n    } ", "target": 0}
{"code": "check_OUTPUT(const struct ofpact_output *a,\n             const struct ofpact_check_params *cp)\n{\n    return ofpact_check_output_port(a->port, cp->max_ports);\n}", "target": 0}
{"code": "    OlympusMnHeader::~OlympusMnHeader()\n    {\n    }", "target": 0}
{"code": "static void restore_median_il(uint8_t *src, int step, int stride,\n                              int width, int height, int slices, int rmode)\n{\n    int i, j, slice;\n    int A, B, C;\n    uint8_t *bsrc;\n    int slice_start, slice_height;\n    const int cmask   = ~(rmode ? 3 : 1);\n    const int stride2 = stride << 1;\n    for (slice = 0; slice < slices; slice++) {\n        slice_start    = ((slice * height) / slices) & cmask;\n        slice_height   = ((((slice + 1) * height) / slices) & cmask) -\n                         slice_start;\n        slice_height >>= 1;\n        if (!slice_height)\n            continue;\n        bsrc = src + slice_start * stride;\n        bsrc[0] += 0x80;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            bsrc[i] += A;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            bsrc[stride + i] += A;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        if (slice_height <= 1)\n            continue;\n        C        = bsrc[-stride2];\n        bsrc[0] += C;\n        A        = bsrc[0];\n        for (i = step; i < width * step; i += step) {\n            B        = bsrc[i - stride2];\n            bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C        = B;\n            A        = bsrc[i];\n        }\n        for (i = 0; i < width * step; i += step) {\n            B                 = bsrc[i - stride];\n            bsrc[stride + i] += mid_pred(A, B, (uint8_t)(A + B - C));\n            C                 = B;\n            A                 = bsrc[stride + i];\n        }\n        bsrc += stride2;\n        for (j = 2; j < slice_height; j++) {\n            for (i = 0; i < width * step; i += step) {\n                B        = bsrc[i - stride2];\n                bsrc[i] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C        = B;\n                A        = bsrc[i];\n            }\n            for (i = 0; i < width * step; i += step) {\n                B                 = bsrc[i - stride];\n                bsrc[i + stride] += mid_pred(A, B, (uint8_t)(A + B - C));\n                C                 = B;\n                A                 = bsrc[i + stride];\n            }\n            bsrc += stride2;\n        }\n    }\n}", "target": 0}
{"code": "static inline struct net_device *xt_in(const struct xt_action_param *par)\n{\n\treturn par->state->in;\n}", "target": 0}
{"code": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL, true);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}", "target": 0}
{"code": "GF_Err vwid_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tu32 i;\n\tGF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s;\n\tISOM_DECREASE_SIZE(s, 3)\n\tgf_bs_read_int(bs, 2);\n\tptr->min_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->max_temporal_id = gf_bs_read_int(bs, 3);\n\tptr->num_views = gf_bs_read_u16(bs);\n\tif (ptr->num_views > ptr->size / 6)\n\t\treturn GF_ISOM_INVALID_FILE;\n\tptr->views = gf_malloc(sizeof(ViewIDEntry)*ptr->num_views);\n\tmemset(ptr->views, 0, sizeof(ViewIDEntry)*ptr->num_views);\n\tfor (i=0; i<ptr->num_views; i++) {\n\t\tu32 j;\n\t\tISOM_DECREASE_SIZE(s, 6)\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_id = gf_bs_read_int(bs, 10);\n\t\tgf_bs_read_int(bs, 6);\n\t\tptr->views[i].view_order_index = gf_bs_read_int(bs, 10);\n\t\tptr->views[i].texture_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].texture_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_stream = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].depth_in_track = gf_bs_read_int(bs, 1);\n\t\tptr->views[i].base_view_type = gf_bs_read_int(bs, 2);\n\t\tptr->views[i].num_ref_views = gf_bs_read_int(bs, 10);\n\t\tif (ptr->views[i].num_ref_views > ptr->size / 2)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->views[i].view_refs = gf_malloc(sizeof(ViewIDRefViewEntry)*ptr->views[i].num_ref_views);\n\t\tfor (j=0; j<ptr->views[i].num_ref_views; j++) {\n\t\t\tISOM_DECREASE_SIZE(s, 2)\n\t\t\tgf_bs_read_int(bs, 4);\n\t\t\tptr->views[i].view_refs[j].dep_comp_idc = gf_bs_read_int(bs, 2);\n\t\t\tptr->views[i].view_refs[j].ref_view_id = gf_bs_read_int(bs, 10);\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicyImpl::GrantReadDirectory(\n    int child_id, const FilePath& directory) {\n  GrantPermissionsForFile(child_id, directory, kEnumerateDirectoryPermissions);\n}", "target": 0}
{"code": "decode_labeled_vpn_prefix6(netdissect_options *ndo,\n                           const u_char *pptr, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen;\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \n\tif ((24+64) > plen)\n\t\treturn -1;\n        plen-=(24+64); \n\tif (128 < plen)\n\t\treturn -1;\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr.s6_addr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\treturn 12 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 0}
{"code": " */\nstatic void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_BINARY:\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN(ent->data) == 0) {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tZVAL_STRINGL(&ent->data, (char *)s, len);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STR(ent->data) = zend_string_extend(Z_STR(ent->data), Z_STRLEN(ent->data) + len, 0);\n\t\t\t\t\tmemcpy(Z_STRVAL(ent->data) + Z_STRLEN(ent->data) - len, (char *)s, len);\n\t\t\t\t\tZ_STRVAL(ent->data)[Z_STRLEN(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZVAL_STRINGL(&ent->data, (char *)s, len);\n\t\t\t\tconvert_scalar_to_number(&ent->data);\n\t\t\t\tbreak;\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif (!strcmp((char *)s, \"true\")) {\n\t\t\t\t\tZ_LVAL(ent->data) = 1;\n\t\t\t\t} else if (!strcmp((char *)s, \"false\")) {\n\t\t\t\t\tZ_LVAL(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tstack->top--;\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname)\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\tefree(ent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\tmemcpy(tmp, (char *)s, len);\n\t\t\t\ttmp[len] = '\\0';\n\t\t\t\tZ_LVAL(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\tif (Z_LVAL(ent->data) == -1) {\n\t\t\t\t\tZVAL_STRINGL(&ent->data, (char *)s, len);\n\t\t\t\t}\n\t\t\t\tefree(tmp);\n\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}", "target": 0}
{"code": "static unsigned short calc_crc_flex(unsigned char *cp, int size)\n{\n\tunsigned short crc = 0xffff;\n\twhile (size--)\n\t\tcrc = (crc << 8) ^ crc_flex_table[((crc >> 8) ^ *cp++) & 0xff];\n\treturn crc;\n}", "target": 0}
{"code": "static void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\tif (var->unusable)\n\t\ts->attrib = 0;\n\telse {\n\t\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\t\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\t\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\t\ts->attrib |= (var->present & 1) << SVM_SELECTOR_P_SHIFT;\n\t\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\t\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\t\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\t\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\t}\n\tif (seg == VCPU_SREG_SS)\n\t\tsvm->vmcb->save.cpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\tmark_dirty(svm->vmcb, VMCB_SEG);\n}", "target": 0}
{"code": "s64 gf_isom_get_cts_to_dts_shift(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionToDecode) return 0;\n\treturn trak->Media->information->sampleTable->CompositionToDecode->compositionToDTSShift;\n}", "target": 0}
{"code": "void RenderView::OnRevertTranslation(int page_id) {\n  translate_helper_.RevertTranslation(page_id);\n}", "target": 0}
{"code": "int inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\tif ((skb = xchg(&np->pktoptions, NULL)) != NULL)\n\t\tkfree_skb(skb);\n\tfl6_free_socklist(sk);\n\tif ((opt = xchg(&np->opt, NULL)) != NULL)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n\treturn 0;\n}", "target": 0}
{"code": "AFfilehandle afOpenFile (const char *filename, const char *mode, AFfilesetup setup)\n{\n\tFILE\t\t*fp;\n\tAFvirtualfile\t*vf;\n\tAFfilehandle\tfilehandle;\n\tint\t\taccess;\n\tif (mode == NULL)\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"null access mode\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\tif (mode[0] == 'r')\n\t\taccess = _AF_READ_ACCESS;\n\telse if (mode[0] == 'w')\n\t\taccess = _AF_WRITE_ACCESS;\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode '%s'\", mode);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\tvf = File::open(filename,\n\t\taccess == _AF_READ_ACCESS ? File::ReadAccess : File::WriteAccess);\n\tif (vf == NULL)\n\t{\n\t\t_af_error(AF_BAD_OPEN, \"could not open file '%s'\", filename);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\tif (_afOpenFile(access, vf, filename, &filehandle, setup) != AF_SUCCEED)\n\t\taf_fclose(vf);\n\treturn filehandle;\n}", "target": 0}
{"code": "gx_no_create_compositor(gx_device * dev, gx_device ** pcdev,\n                        const gs_composite_t * pcte,\n                        gs_gstate * pgs, gs_memory_t * memory,\n                        gx_device *cdev)\n{\n    return_error(gs_error_unknownerror);\t\n}", "target": 0}
{"code": "static void vp9_segmentation_params(GF_BitStream *bs)\n{\n\tBool segmentation_enabled = gf_bs_read_int_log(bs, 1, \"segmentation_enabled\");\n\tif (segmentation_enabled == 1) {\n\t\tint i;\n\t\tBool segmentation_update_map = gf_bs_read_int_log(bs, 1, \"segmentation_update_map\");\n\t\tif (segmentation_update_map) {\n\t\t\tfor (i = 0; i < 7; i++) {\n\t\t\t\tvp9_read_prob(bs);\n\t\t\t}\n\t\t\tBool segmentation_temporal_update = gf_bs_read_int_log(bs, 1, \"segmentation_temporal_update\");\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tif (segmentation_temporal_update) {\n\t\t\t\t\tvp9_read_prob(bs);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tBool segmentation_update_data = gf_bs_read_int_log(bs, 1, \"segmentation_update_data\");\n\t\tif (segmentation_update_data == 1) {\n\t\t\t gf_bs_read_int_log(bs, 1, \"segmentation_abs_or_delta_update\");\n\t\t\tfor (i = 0; i < VP9_MAX_SEGMENTS; i++) {\n\t\t\t\tint j;\n\t\t\t\tfor (j = 0; j < VP9_SEG_LVL_MAX; j++) {\n\t\t\t\t\tBool feature_enabled = gf_bs_read_int_log(bs, 1, \"feature_enabled\");\n\t\t\t\t\tif (feature_enabled) {\n\t\t\t\t\t\tint bits_to_read = segmentation_feature_bits[j];\n\t\t\t\t\t\t gf_bs_read_int_log(bs, bits_to_read, \"feature_value\");\n\t\t\t\t\t\tif (segmentation_feature_signed[j] == 1) {\n\t\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"feature_sign\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "tor_version_is_obsolete(const char *myversion, const char *versionlist)\n{\n  tor_version_t mine, other;\n  int found_newer = 0, found_older = 0, found_newer_in_series = 0,\n    found_any_in_series = 0, r, same;\n  version_status_t ret = VS_UNRECOMMENDED;\n  smartlist_t *version_sl;\n  log_debug(LD_CONFIG,\"Checking whether version '%s' is in '%s'\",\n            myversion, versionlist);\n  if (tor_version_parse(myversion, &mine)) {\n    log_err(LD_BUG,\"I couldn't parse my own version (%s)\", myversion);\n    tor_assert(0);\n  }\n  version_sl = smartlist_new();\n  smartlist_split_string(version_sl, versionlist, \",\", SPLIT_SKIP_SPACE, 0);\n  if (!strlen(versionlist)) { \n    ret = VS_EMPTY;\n    goto done;\n  }\n  SMARTLIST_FOREACH_BEGIN(version_sl, const char *, cp) {\n    if (!strcmpstart(cp, \"Tor \"))\n      cp += 4;\n    if (tor_version_parse(cp, &other)) {\n    } else {\n      same = tor_version_same_series(&mine, &other);\n      if (same)\n        found_any_in_series = 1;\n      r = tor_version_compare(&mine, &other);\n      if (r==0) {\n        ret = VS_RECOMMENDED;\n        goto done;\n      } else if (r<0) {\n        found_newer = 1;\n        if (same)\n          found_newer_in_series = 1;\n      } else if (r>0) {\n        found_older = 1;\n      }\n    }\n  } SMARTLIST_FOREACH_END(cp);\n  if (found_any_in_series && !found_newer_in_series && found_newer) {\n    ret = VS_NEW_IN_SERIES;\n  } else if (found_newer && !found_older) {\n    ret = VS_OLD;\n  } else if (found_older && !found_newer) {\n    ret = VS_NEW;\n  } else {\n    ret = VS_UNRECOMMENDED;\n  }\n done:\n  SMARTLIST_FOREACH(version_sl, char *, version, tor_free(version));\n  smartlist_free(version_sl);\n  return ret;\n}", "target": 0}
{"code": "static inline void ip6_frags_ns_sysctl_unregister(struct net *net)\n{\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& weights = context->input(1);\n    bool use_weights = weights.NumElements() > 0;\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(data.shape()) ||\n                    TensorShapeUtils::IsMatrix(data.shape()),\n                errors::InvalidArgument(\n                    \"Input must be a 1 or 2-dimensional tensor. Got: \",\n                    data.shape().DebugString()));\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == data.shape(),\n          errors::InvalidArgument(\n              \"Weights and data must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; data shape: \", data.shape().DebugString()));\n    }\n    bool is_1d = TensorShapeUtils::IsVector(data.shape());\n    int negative_valued_axis = -1;\n    int num_batch_dimensions = (data.shape().dims() + negative_valued_axis);\n    int num_batch_elements = 1;\n    for (int i = 0; i < num_batch_dimensions; ++i) {\n      OP_REQUIRES(context, data.shape().dim_size(i) != 0,\n                  errors::InvalidArgument(\n                      \"Invalid input: Shapes dimension cannot be 0.\"));\n      num_batch_elements *= data.shape().dim_size(i);\n    }\n    int num_value_elements = data.shape().num_elements() / num_batch_elements;\n    auto per_batch_counts = BatchedMap<W>(num_batch_elements);\n    T max_value = 0;\n    const auto data_values = data.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int i = 0;\n    for (int b = 0; b < num_batch_elements; ++b) {\n      for (int v = 0; v < num_value_elements; ++v) {\n        const auto& value = data_values(i);\n        if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n          if (binary_output_) {\n            per_batch_counts[b][value] = 1;\n          } else if (use_weights) {\n            per_batch_counts[b][value] += weight_values(i);\n          } else {\n            per_batch_counts[b][value]++;\n          }\n          if (value > max_value) {\n            max_value = value;\n          }\n        }\n        ++i;\n      }\n    }\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }", "target": 0}
{"code": "static void mark_key_instantiated(struct key *key, int reject_error)\n{\n\tsmp_store_release(&key->state,\n\t\t\t  (reject_error < 0) ? reject_error : KEY_IS_POSITIVE);\n}", "target": 0}
{"code": "static int klv_read_packet(KLVPacket *klv, AVIOContext *pb)\n{\n    if (!mxf_read_sync(pb, mxf_klv_key, 4))\n        return AVERROR_INVALIDDATA;\n    klv->offset = avio_tell(pb) - 4;\n    memcpy(klv->key, mxf_klv_key, 4);\n    avio_read(pb, klv->key + 4, 12);\n    klv->length = klv_decode_ber_length(pb);\n    return klv->length == -1 ? -1 : 0;\n}", "target": 0}
{"code": "uint find_shortest_key(TABLE *table, const key_map *usable_keys)\n{\n  double min_cost= DBL_MAX;\n  uint best= MAX_KEY;\n  if (!usable_keys->is_clear_all())\n  {\n    for (uint nr=0; nr < table->s->keys ; nr++)\n    {\n      if (usable_keys->is_set(nr))\n      {\n        double cost= table->file->keyread_time(nr, 1, table->file->records());\n        if (cost < min_cost)\n        {\n          min_cost= cost;\n          best=nr;\n        }\n        DBUG_ASSERT(best < MAX_KEY);\n      }\n    }\n  }\n  return best;\n}", "target": 0}
{"code": "        std::string readExiv2Config(const std::string& section,const std::string& value,const std::string& def)\n        {\n            std::string result = def;\n            Exiv2::INIReader reader(Exiv2::Internal::getExiv2ConfigPath());\n            if (reader.ParseError() == 0) {\n                result = reader.Get(section,value,def);\n            }\n            return result;\n        }", "target": 0}
{"code": "int setup_ftfuncs(SELECT_LEX *select_lex)\n{\n  List_iterator<Item_func_match> li(*(select_lex->ftfunc_list)),\n                                 lj(*(select_lex->ftfunc_list));\n  Item_func_match *ftf, *ftf2;\n  while ((ftf=li++))\n  {\n    if (ftf->fix_index())\n      return 1;\n    lj.rewind();\n    while ((ftf2=lj++) != ftf)\n    {\n      if (ftf->eq(ftf2,1) && !ftf2->master)\n        ftf2->master=ftf;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "bool Item_ident::collect_outer_ref_processor(uchar *param)\n{\n  Collect_deps_prm *prm= (Collect_deps_prm *)param;\n  if (depended_from && \n      depended_from->nest_level_base == prm->nest_level_base &&\n      depended_from->nest_level < prm->nest_level)\n    prm->parameters->add_unique(this, &cmp_items);\n  return FALSE;\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, ExprLtDoesNotUseTypeBracketing) {\n    createMatcher(fromjson(\"{$expr: {$lt: ['$x', true]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << false)));\n    ASSERT_TRUE(matches(BSON(\"x\" << BSON(\"y\" << 1))));\n    ASSERT_TRUE(matches(BSONObj()));\n    ASSERT_FALSE(matches(BSON(\"x\" << Timestamp(0, 1))));\n}", "target": 0}
{"code": "void GLES2DecoderImpl::ClearUnclearedRenderbuffers(\n    FramebufferManager::FramebufferInfo* info) {\n  GLbitfield clear_bits = 0;\n  if (info->HasUnclearedAttachment(GL_COLOR_ATTACHMENT0)) {\n    glClearColor(0, 0, 0, 0);\n    glColorMask(true, true, true, true);\n    clear_bits |= GL_COLOR_BUFFER_BIT;\n  }\n  if (info->HasUnclearedAttachment(GL_STENCIL_ATTACHMENT) ||\n      info->HasUnclearedAttachment(GL_DEPTH_STENCIL_ATTACHMENT)) {\n    glClearStencil(0);\n    glStencilMask(-1);\n    clear_bits |= GL_STENCIL_BUFFER_BIT;\n  }\n  if (info->HasUnclearedAttachment(GL_DEPTH_ATTACHMENT) ||\n      info->HasUnclearedAttachment(GL_DEPTH_STENCIL_ATTACHMENT)) {\n    glClearDepth(1.0f);\n    glDepthMask(true);\n    clear_bits |= GL_DEPTH_BUFFER_BIT;\n  }\n  glDisable(GL_SCISSOR_TEST);\n  glClear(clear_bits);\n  info->MarkAttachedRenderbuffersAsCleared();\n  glClearColor(clear_red_, clear_green_, clear_blue_, clear_alpha_);\n  glColorMask(mask_red_, mask_green_, mask_blue_, mask_alpha_);\n  glClearStencil(clear_stencil_);\n  glStencilMaskSeparate(GL_FRONT, mask_stencil_front_);\n  glStencilMaskSeparate(GL_BACK, mask_stencil_back_);\n  glClearDepth(clear_depth_);\n  glDepthMask(mask_depth_);\n  if (enable_scissor_test_) {\n    glEnable(GL_SCISSOR_TEST);\n  }\n}", "target": 0}
{"code": "static void fuse_lib_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    int res;\n    if (size) {\n        char *list = (char *) malloc(size);\n        if (list == NULL) {\n            reply_err(req, -ENOMEM);\n            return;\n        }\n        res = common_listxattr(f, req, ino, list, size);\n        if (res > 0)\n            fuse_reply_buf(req, list, res);\n        else\n            reply_err(req, res);\n        free(list);\n    } else {\n        res = common_listxattr(f, req, ino, NULL, 0);\n        if (res >= 0)\n            fuse_reply_xattr(req, res);\n        else\n            reply_err(req, res);\n    }\n}", "target": 0}
{"code": "static void rose_idletimer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, idletimer);\n\tstruct sock *sk = &rose->sock;\n\tbh_lock_sock(sk);\n\trose_clear_queues(sk);\n\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\trose_sk(sk)->state = ROSE_STATE_2;\n\trose_start_t3timer(sk);\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = 0;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "private int\nprint_sep(struct magic_set *ms, int firstline)\n{\n\tif (firstline)\n\t\treturn 0;", "target": 0}
{"code": "String HTMLInputElement::selectionDirectionForBinding(ExceptionState& exceptionState) const\n{\n    if (!m_inputType->supportsSelectionAPI()) {\n        exceptionState.throwDOMException(InvalidStateError, \"The input element's type ('\" + m_inputType->formControlType() + \"') does not support selection.\");\n        return String();\n    }\n    return HTMLTextFormControlElement::selectionDirection();\n}", "target": 0}
{"code": "static void select_describe(JOIN *join, bool need_tmp_table, bool need_order,\n\t\t\t    bool distinct,const char *message)\n{\n  THD *thd=join->thd;\n  select_result *result=join->result;\n  DBUG_ENTER(\"select_describe\");\n  for (SELECT_LEX_UNIT *unit= join->select_lex->first_inner_unit();\n       unit;\n       unit= unit->next_unit())\n  {\n    if (unit->item && !unit->item->fixed)\n    {\n      Item *ref= unit->item;\n      if (unit->item->fix_fields(thd, &ref))\n        DBUG_VOID_RETURN;\n      DBUG_ASSERT(ref == unit->item);\n    }\n    if (!(unit->item && unit->item->eliminated) &&                     \n        !(unit->derived && unit->derived->merged_for_insert) &&        \n        (!unit->with_element ||\n          (unit->derived &&\n           unit->derived->derived_result &&\n           !unit->with_element->is_hanging_recursive())))              \n    {\n      if (mysql_explain_union(thd, unit, result))\n        DBUG_VOID_RETURN;\n    }\n  }\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "int sftp_reply_attr(sftp_client_message msg, sftp_attributes attr) {\n  ssh_buffer out;\n  out = ssh_buffer_new();\n  if (out == NULL) {\n    return -1;\n  }\n  if (ssh_buffer_add_u32(out, msg->id) < 0 ||\n      buffer_add_attributes(out, attr) < 0 ||\n      sftp_packet_write(msg->sftp, SSH_FXP_ATTRS, out) < 0) {\n    SSH_BUFFER_FREE(out);\n    return -1;\n  }\n  SSH_BUFFER_FREE(out);\n  return 0;\n}", "target": 0}
{"code": "static void reds_client_monitors_config(RedsState *reds, VDAgentMonitorsConfig *monitors_config)\n{\n    FOREACH_QXL_INSTANCE(reds, qxl) {\n        if (!red_qxl_client_monitors_config(qxl, monitors_config)) {\n            spice_debug(\"QXLInterface::client_monitors_config failed\");\n        }\n    }\n}", "target": 0}
{"code": "NCR_Finalise(void)\n{\n  unsigned int i;\n  if (server_sock_fd4 != INVALID_SOCK_FD)\n    NIO_CloseServerSocket(server_sock_fd4);\n  if (server_sock_fd6 != INVALID_SOCK_FD)\n    NIO_CloseServerSocket(server_sock_fd6);\n  for (i = 0; i < ARR_GetSize(broadcasts); i++)\n    NIO_CloseServerSocket(((BroadcastDestination *)ARR_GetElement(broadcasts, i))->local_addr.sock_fd);\n  ARR_DestroyInstance(broadcasts);\n  ADF_DestroyTable(access_auth_table);\n}", "target": 0}
{"code": "void InstanceKlass::check_valid_for_instantiation(bool throwError, TRAPS) {\n  if (is_interface() || is_abstract()) {\n    ResourceMark rm(THREAD);\n    THROW_MSG(throwError ? vmSymbols::java_lang_InstantiationError()\n              : vmSymbols::java_lang_InstantiationException(), external_name());\n  }\n  if (this == SystemDictionary::Class_klass()) {\n    ResourceMark rm(THREAD);\n    THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()\n              : vmSymbols::java_lang_IllegalAccessException(), external_name());\n  }\n}", "target": 0}
{"code": "void RootWindowHostWin::OnClose() {\n  MessageLoopForUI::current()->Quit();\n}", "target": 0}
{"code": "void setup_defaults(THD *thd, List<Item> &fields, List<Item> &values)\n{\n  List_iterator<Item> fit(fields);\n  List_iterator<Item> vit(values);\n  for (Item *value= vit++, *f_item= fit++; value; value= vit++, f_item= fit++)\n  {\n    value->walk(&Item::enchant_default_with_arg_processor, false, f_item);\n  }\n}", "target": 0}
{"code": "bool JankTimeBomb::IsEnabled() const {\n  version_info::Channel channel = chrome::GetChannel();\n  return channel == version_info::Channel::UNKNOWN ||\n      channel == version_info::Channel::CANARY ||\n      channel == version_info::Channel::DEV;\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, ConstantNumberZeroExpressionMatchesCorrectly) {\n    createMatcher(fromjson(\"{$expr: 0}\"));\n    ASSERT_FALSE(matches(BSON(\"x\" << 2)));\n}", "target": 0}
{"code": "static int llc_ui_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t int kern)\n{\n\tstruct sock *sk;\n\tint rc = -ESOCKTNOSUPPORT;\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tif (likely(sock->type == SOCK_DGRAM || sock->type == SOCK_STREAM)) {\n\t\trc = -ENOMEM;\n\t\tsk = llc_sk_alloc(net, PF_LLC, GFP_KERNEL, &llc_proto);\n\t\tif (sk) {\n\t\t\trc = 0;\n\t\t\tllc_ui_sk_init(sock, sk);\n\t\t}\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "valid_weeknum_p(VALUE y, int w, int d, int f, double sg,\n\t\tVALUE *nth, int *ry,\n\t\tint *rw, int *rd, int *rjd,\n\t\tint *ns)\n{\n    double style = guess_style(y, sg);\n    int r;\n    if (style == 0) {\n\tint jd;\n\tr = c_valid_weeknum_p(FIX2INT(y), w, d, f, sg, rw, rd, &jd, ns);\n\tif (!r)\n\t    return 0;\n\tdecode_jd(INT2FIX(jd), nth, rjd);\n\tif (f_zero_p(*nth))\n\t    *ry = FIX2INT(y);\n\telse {\n\t    VALUE nth2;\n\t    decode_year(y, *ns ? -1 : +1, &nth2, ry);\n\t}\n    }\n    else {\n\tdecode_year(y, style, nth, ry);\n\tr = c_valid_weeknum_p(*ry, w, d, f, style, rw, rd, rjd, ns);\n    }\n    return r;\n}", "target": 0}
{"code": "static int queue_prio(const struct intel_engine_execlists *execlists)\n{\n\tstruct i915_priolist *p;\n\tstruct rb_node *rb;\n\trb = rb_first_cached(&execlists->queue);\n\tif (!rb)\n\t\treturn INT_MIN;\n\tp = to_priolist(rb);\n\treturn ((p->priority + 1) << I915_USER_PRIORITY_SHIFT) - ffs(p->used);\n}", "target": 0}
{"code": "static int wait_while_ack(gitno_buffer *buf)\n{\n\tint error;\n\tgit_pkt_ack *pkt = NULL;\n\twhile (1) {\n\t\tgit__free(pkt);\n\t\tif ((error = recv_pkt((git_pkt **)&pkt, buf)) < 0)\n\t\t\treturn error;\n\t\tif (pkt->type == GIT_PKT_NAK)\n\t\t\tbreak;\n\t\tif (pkt->type == GIT_PKT_ACK &&\n\t\t    (pkt->status != GIT_ACK_CONTINUE &&\n\t\t     pkt->status != GIT_ACK_COMMON)) {\n\t\t\tgit__free(pkt);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tgit__free(pkt);\n\treturn 0;\n}", "target": 0}
{"code": "callbacks_move_objects_clicked (GtkButton *button, gpointer   user_data){\n\tgerbv_image_move_selected_objects (screen.selectionInfo.selectedNodeArray, -0.050, 0.050);\n\tcallbacks_update_layer_tree();\n\tselection_clear (&screen.selectionInfo);\n\tupdate_selected_object_message (FALSE);\n\trender_refresh_rendered_image_on_screen ();\n}", "target": 0}
{"code": "static void vhost_vdpa_va_unmap(struct vhost_vdpa *v, u64 start, u64 last)\n{\n\tstruct vhost_dev *dev = &v->vdev;\n\tstruct vhost_iotlb *iotlb = dev->iotlb;\n\tstruct vhost_iotlb_map *map;\n\tstruct vdpa_map_file *map_file;\n\twhile ((map = vhost_iotlb_itree_first(iotlb, start, last)) != NULL) {\n\t\tmap_file = (struct vdpa_map_file *)map->opaque;\n\t\tfput(map_file->file);\n\t\tkfree(map_file);\n\t\tvhost_iotlb_map_free(iotlb, map);\n\t}\n}", "target": 0}
{"code": "Section_t * FindSection(int SectionType)\n{\n    int a;\n    for (a=0;a<SectionsRead;a++){\n        if (Sections[a].Type == SectionType){\n            return &Sections[a];\n        }\n    }\n    return NULL;\n}", "target": 0}
{"code": "PHPAPI php_url *php_url_parse_ex(char const *str, size_t length)\n{\n\tzend_bool has_port;\n\treturn php_url_parse_ex2(str, length, &has_port);\n}", "target": 0}
{"code": "static int pio_in_emulated(struct x86_emulate_ctxt *ctxt,\n\t\t\t   unsigned int size, unsigned short port,\n\t\t\t   void *dest)\n{\n\tstruct read_cache *rc = &ctxt->io_read;\n\tif (rc->pos == rc->end) { \n\t\tunsigned int in_page, n;\n\t\tunsigned int count = ctxt->rep_prefix ?\n\t\t\taddress_mask(ctxt, ctxt->regs[VCPU_REGS_RCX]) : 1;\n\t\tin_page = (ctxt->eflags & EFLG_DF) ?\n\t\t\toffset_in_page(ctxt->regs[VCPU_REGS_RDI]) :\n\t\t\tPAGE_SIZE - offset_in_page(ctxt->regs[VCPU_REGS_RDI]);\n\t\tn = min(min(in_page, (unsigned int)sizeof(rc->data)) / size,\n\t\t\tcount);\n\t\tif (n == 0)\n\t\t\tn = 1;\n\t\trc->pos = rc->end = 0;\n\t\tif (!ctxt->ops->pio_in_emulated(ctxt, size, port, rc->data, n))\n\t\t\treturn 0;\n\t\trc->end = n * size;\n\t}\n\tmemcpy(dest, rc->data + rc->pos, size);\n\trc->pos += size;\n\treturn 1;\n}", "target": 0}
{"code": "static void ff_layout_io_track_ds_error(struct pnfs_layout_segment *lseg,\n\t\t\t\t\tu32 idx, u64 offset, u64 length,\n\t\t\t\t\tu32 *op_status, int opnum, int error)\n{\n\tstruct nfs4_ff_layout_mirror *mirror;\n\tu32 status = *op_status;\n\tint err;\n\tif (status == 0) {\n\t\tswitch (error) {\n\t\tcase -ETIMEDOUT:\n\t\tcase -EPFNOSUPPORT:\n\t\tcase -EPROTONOSUPPORT:\n\t\tcase -EOPNOTSUPP:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ECONNRESET:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ENETUNREACH:\n\t\tcase -EADDRINUSE:\n\t\tcase -ENOBUFS:\n\t\tcase -EPIPE:\n\t\tcase -EPERM:\n\t\t\t*op_status = status = NFS4ERR_NXIO;\n\t\t\tbreak;\n\t\tcase -EACCES:\n\t\t\t*op_status = status = NFS4ERR_ACCESS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn;\n\t\t}\n\t}\n\tmirror = FF_LAYOUT_COMP(lseg, idx);\n\terr = ff_layout_track_ds_error(FF_LAYOUT_FROM_HDR(lseg->pls_layout),\n\t\t\t\t       mirror, offset, length, status, opnum,\n\t\t\t\t       GFP_NOIO);\n\tswitch (status) {\n\tcase NFS4ERR_DELAY:\n\tcase NFS4ERR_GRACE:\n\t\tbreak;\n\tcase NFS4ERR_NXIO:\n\t\tff_layout_mark_ds_unreachable(lseg, idx);\n\t\tif (opnum == OP_READ)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tpnfs_error_mark_layout_for_return(lseg->pls_layout->plh_inode,\n\t\t\t\t\t\t  lseg);\n\t}\n\tdprintk(\"%s: err %d op %d status %u\\n\", __func__, err, opnum, status);\n}", "target": 0}
{"code": "__execlists_update_reg_state(const struct intel_context *ce,\n\t\t\t     const struct intel_engine_cs *engine)\n{\n\tstruct intel_ring *ring = ce->ring;\n\tu32 *regs = ce->lrc_reg_state;\n\tGEM_BUG_ON(!intel_ring_offset_valid(ring, ring->head));\n\tGEM_BUG_ON(!intel_ring_offset_valid(ring, ring->tail));\n\tregs[CTX_RING_BUFFER_START] = i915_ggtt_offset(ring->vma);\n\tregs[CTX_RING_HEAD] = ring->head;\n\tregs[CTX_RING_TAIL] = ring->tail;\n\tif (engine->class == RENDER_CLASS) {\n\t\tregs[CTX_R_PWR_CLK_STATE] =\n\t\t\tintel_sseu_make_rpcs(engine->i915, &ce->sseu);\n\t\ti915_oa_init_reg_state(ce, engine);\n\t}\n}", "target": 0}
{"code": "NAN_METHOD(TxnWrap::abort) {\n    Nan::HandleScope scope;\n    TxnWrap *tw = Nan::ObjectWrap::Unwrap<TxnWrap>(info.This());\n    if (!tw->txn) {\n        return Nan::ThrowError(\"The transaction is already closed.\");\n    }\n    mdb_txn_abort(tw->txn);\n    tw->removeFromEnvWrap();\n    tw->txn = nullptr;\n}", "target": 0}
{"code": "format_DEBUG_RECIRC(const struct ofpact_null *a OVS_UNUSED,\n                    const struct ofpact_format_params *fp)\n{\n    ds_put_format(fp->s, \"%sdebug_recirc%s\", colors.value, colors.end);\n}", "target": 0}
{"code": "static int parse_msg_id(const char *text)\n{\n\tint i;\n\tif (!msg_id_info[0].downcased) {\n\t\tfor (i = 0; i < FSCK_MSG_MAX; i++) {\n\t\t\tconst char *p = msg_id_info[i].id_string;\n\t\t\tint len = strlen(p);\n\t\t\tchar *q = xmalloc(len);\n\t\t\tmsg_id_info[i].downcased = q;\n\t\t\twhile (*p)\n\t\t\t\tif (*p == '_')\n\t\t\t\t\tp++;\n\t\t\t\telse\n\t\t\t\t\t*(q)++ = tolower(*(p)++);\n\t\t\t*q = '\\0';\n\t\t}\n\t}\n\tfor (i = 0; i < FSCK_MSG_MAX; i++)\n\t\tif (!strcmp(text, msg_id_info[i].downcased))\n\t\t\treturn i;\n\treturn -1;\n}", "target": 0}
{"code": "TEST(EqOp, MatchesNull) {\n    BSONObj operand = BSON(\"a\" << BSONNULL);\n    EqualityMatchExpression eq(\"a\", operand[\"a\"]);\n    ASSERT(eq.matchesBSON(BSONObj(), NULL));\n    ASSERT(eq.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n    ASSERT(!eq.matchesBSON(BSON(\"a\" << 4), NULL));\n    ASSERT(eq.matchesBSON(BSON(\"b\" << 4), NULL));\n}", "target": 0}
{"code": "PHP_LIBXML_API int php_libxml_decrement_doc_ref(php_libxml_node_object *object TSRMLS_DC)\n{\n\tint ret_refcount = -1;\n\tif (object != NULL && object->document != NULL) {\n\t\tret_refcount = --object->document->refcount;\n\t\tif (ret_refcount == 0) {\n\t\t\tif (object->document->ptr != NULL) {\n\t\t\t\txmlFreeDoc((xmlDoc *) object->document->ptr);\n\t\t\t}\n\t\t\tif (object->document->doc_props != NULL) {\n\t\t\t\tif (object->document->doc_props->classmap) {\n\t\t\t\t\tzend_hash_destroy(object->document->doc_props->classmap);\n\t\t\t\t\tFREE_HASHTABLE(object->document->doc_props->classmap);\n\t\t\t\t}\n\t\t\t\tefree(object->document->doc_props);\n\t\t\t}\n\t\t\tefree(object->document);\n\t\t\tobject->document = NULL;\n\t\t}\n\t}\n\treturn ret_refcount;\n}", "target": 0}
{"code": "    std::unique_ptr<Extract> Extract::clone() const\n    {\n        return std::unique_ptr<Extract>(clone_());\n    }", "target": 0}
{"code": "void JOIN::clear()\n{\n  clear_tables(this);\n  copy_fields(&tmp_table_param);\n  if (sum_funcs)\n  {\n    Item_sum *func, **func_ptr= sum_funcs;\n    while ((func= *(func_ptr++)))\n      func->clear();\n  }\n}", "target": 0}
{"code": "    const CImg<T>& save_ascii(std::FILE *const file) const {\n      return _save_ascii(file,0);", "target": 0}
{"code": "skip_spaces (GMarkupParseContext *context)\n{\n  do\n    {\n      if (!xml_isspace (*context->iter))\n        return;\n    }\n  while (advance_char (context));\n}", "target": 0}
{"code": "SWFInput_stream_getChar(SWFInput input)\n{\n\tstruct SWFInputStreamData *data = (struct SWFInputStreamData *) input->data;\n\tif (input->offset >= MAX_INPUTSTREAM)\n\t\treturn EOF;\n\tif ( input->offset == input->length )\n\t{\n\t\tFILE *f = data->file;\n\t\tint c = fgetc(f);\n\t\t++input->offset;\n\t\tif ( c != EOF )\n\t\t{\n\t\t\tif ( input->length % INPUTSTREAM_INCREMENT == 0 )\n\t\t\t{\n\t\t\t\tdata->buffer = (unsigned char*) realloc(data->buffer,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t sizeof(unsigned char) *\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (input->length + INPUTSTREAM_INCREMENT));\n\t\t\t}\n\t\t\tdata->buffer[input->length] = c;\n\t\t\t++input->length;\n\t\t}\n\t\treturn c;\n\t}\n\telse if ( input->offset < input->length )\n\t{\n\t\treturn data->buffer[input->offset++];\n\t}\n\telse\n\t\treturn EOF;\n}", "target": 0}
{"code": "storagePoolLookupByUUID(virConnectPtr conn,\n                        const unsigned char *uuid)\n{\n    virStoragePoolObj *obj;\n    virStoragePoolDef *def;\n    virStoragePoolPtr pool = NULL;\n    obj = storagePoolObjFindByUUID(uuid, NULL);\n    if (!obj)\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n    if (virStoragePoolLookupByUUIDEnsureACL(conn, def) < 0)\n        goto cleanup;\n    pool = virGetStoragePool(conn, def->name, def->uuid, NULL, NULL);\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return pool;\n}", "target": 0}
{"code": "void ssl_free( ssl_context *ssl )\n{\n    SSL_DEBUG_MSG( 2, ( \"=> free\" ) );\n    if( ssl->out_ctr != NULL )\n    {\n        memset( ssl->out_ctr, 0, SSL_BUFFER_LEN );\n          free( ssl->out_ctr );\n    }\n    if( ssl->in_ctr != NULL )\n    {\n        memset( ssl->in_ctr, 0, SSL_BUFFER_LEN );\n          free( ssl->in_ctr );\n    }\n#if defined(POLARSSL_DHM_C)\n    mpi_free( &ssl->dhm_P );\n    mpi_free( &ssl->dhm_G );\n#endif\n    if( ssl->transform )\n    {\n        ssl_transform_free( ssl->transform );\n        free( ssl->transform );\n    }\n    if( ssl->handshake )\n    {\n        ssl_handshake_free( ssl->handshake );\n        ssl_transform_free( ssl->transform_negotiate );\n        ssl_session_free( ssl->session_negotiate );\n        free( ssl->handshake );\n        free( ssl->transform_negotiate );\n        free( ssl->session_negotiate );\n    }\n    if ( ssl->hostname != NULL)\n    {\n        memset( ssl->hostname, 0, ssl->hostname_len );\n        free( ssl->hostname );\n        ssl->hostname_len = 0;\n    }\n#if defined(POLARSSL_SSL_HW_RECORD_ACCEL)\n    if( ssl_hw_record_finish != NULL )\n    {\n        SSL_DEBUG_MSG( 2, ( \"going for ssl_hw_record_finish()\" ) );\n        ssl_hw_record_finish( ssl );\n    }\n#endif\n    SSL_DEBUG_MSG( 2, ( \"<= free\" ) );\n    memset( ssl, 0, sizeof( ssl_context ) );\n}", "target": 0}
{"code": "static int rtnetlink_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tswitch (event) {\n\tcase NETDEV_UP:\n\tcase NETDEV_DOWN:\n\tcase NETDEV_PRE_UP:\n\tcase NETDEV_POST_INIT:\n\tcase NETDEV_REGISTER:\n\tcase NETDEV_CHANGE:\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\tcase NETDEV_GOING_DOWN:\n\tcase NETDEV_UNREGISTER:\n\tcase NETDEV_UNREGISTER_FINAL:\n\tcase NETDEV_RELEASE:\n\tcase NETDEV_JOIN:\n\tcase NETDEV_BONDING_INFO:\n\t\tbreak;\n\tdefault:\n\t\trtmsg_ifinfo(RTM_NEWLINK, dev, 0, GFP_KERNEL);\n\t\tbreak;\n\t}\n\treturn NOTIFY_DONE;\n}", "target": 0}
{"code": "static int __kvm_io_bus_write(struct kvm_vcpu *vcpu, struct kvm_io_bus *bus,\n\t\t\t      struct kvm_io_range *range, const void *val)\n{\n\tint idx;\n\tidx = kvm_io_bus_get_first_dev(bus, range->addr, range->len);\n\tif (idx < 0)\n\t\treturn -EOPNOTSUPP;\n\twhile (idx < bus->dev_count &&\n\t\tkvm_io_bus_cmp(range, &bus->range[idx]) == 0) {\n\t\tif (!kvm_iodevice_write(vcpu, bus->range[idx].dev, range->addr,\n\t\t\t\t\trange->len, val))\n\t\t\treturn idx;\n\t\tidx++;\n\t}\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "u8 *ushort2bebytes(u8 *buf, unsigned short x)\n{\n\tif (buf != NULL) {\n\t\tbuf[1] = (u8) (x & 0xff);\n\t\tbuf[0] = (u8) ((x >> 8) & 0xff);\n\t}\n\treturn buf;\n}", "target": 0}
{"code": "bool GLES2DecoderImpl::SimulateAttrib0(\n    GLuint max_vertex_accessed, bool* simulated) {\n  DCHECK(simulated);\n  *simulated = false;\n  if (gfx::GetGLImplementation() == gfx::kGLImplementationEGLGLES2)\n    return true;\n  const VertexAttribManager::VertexAttribInfo* info =\n      vertex_attrib_manager_->GetVertexAttribInfo(0);\n  bool attrib_0_used = current_program_->GetAttribInfoByLocation(0) != NULL;\n  if (info->enabled() && attrib_0_used) {\n    return true;\n  }\n  typedef VertexAttribManager::VertexAttribInfo::Vec4 Vec4;\n  GLuint num_vertices = max_vertex_accessed + 1;\n  GLuint size_needed = 0;\n  if (num_vertices == 0 ||\n      !SafeMultiply(num_vertices, static_cast<GLuint>(sizeof(Vec4)),\n                    &size_needed) ||\n      size_needed > 0x7FFFFFFFU) {\n    SetGLError(GL_OUT_OF_MEMORY, \"glDrawXXX: Simulating attrib 0\");\n    return false;\n  }\n   CopyRealGLErrorsToWrapper();\n   glBindBuffer(GL_ARRAY_BUFFER, attrib_0_buffer_id_);\n  bool new_buffer = static_cast<GLsizei>(size_needed) > attrib_0_size_;\n  if (new_buffer) {\n     glBufferData(GL_ARRAY_BUFFER, size_needed, NULL, GL_DYNAMIC_DRAW);\n     GLenum error = glGetError();\n     if (error != GL_NO_ERROR) {\n       SetGLError(GL_OUT_OF_MEMORY, \"glDrawXXX: Simulating attrib 0\");\n       return false;\n     }\n  }\n  if (new_buffer ||\n      (attrib_0_used &&\n       (!attrib_0_buffer_matches_value_ ||\n        (info->value().v[0] != attrib_0_value_.v[0] ||\n         info->value().v[1] != attrib_0_value_.v[1] ||\n         info->value().v[2] != attrib_0_value_.v[2] ||\n         info->value().v[3] != attrib_0_value_.v[3])))) {\n     std::vector<Vec4> temp(num_vertices, info->value());\n     glBufferSubData(GL_ARRAY_BUFFER, 0, size_needed, &temp[0].v[0]);\n     attrib_0_buffer_matches_value_ = true;\n    attrib_0_value_ = info->value();\n    attrib_0_size_ = size_needed;\n  }\n  glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 0, NULL);\n  if (info->divisor())\n    glVertexAttribDivisorANGLE(0, 0);\n  *simulated = true;\n  return true;\n}", "target": 0}
{"code": "ProcAllocColorCells(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xAllocColorCellsReq);\n    REQUEST_SIZE_MATCH(xAllocColorCellsReq);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,\n                                 client, DixAddAccess);\n    if (rc == Success) {\n        int npixels, nmasks;\n        long length;\n        Pixel *ppixels, *pmasks;\n        npixels = stuff->colors;\n        if (!npixels) {\n            client->errorValue = npixels;\n            return BadValue;\n        }\n        if (stuff->contiguous != xTrue && stuff->contiguous != xFalse) {\n            client->errorValue = stuff->contiguous;\n            return BadValue;\n        }\n        nmasks = stuff->planes;\n        length = ((long) npixels + (long) nmasks) * sizeof(Pixel);\n        ppixels = malloc(length);\n        if (!ppixels)\n            return BadAlloc;\n        pmasks = ppixels + npixels;\n        if ((rc = AllocColorCells(client->index, pcmp, npixels, nmasks,\n                                  (Bool) stuff->contiguous, ppixels, pmasks))) {\n            free(ppixels);\n            return rc;\n        }\n#ifdef PANORAMIX\n        if (noPanoramiXExtension || !pcmp->pScreen->myNum)\n#endif\n        {\n            xAllocColorCellsReply accr = {\n                .type = X_Reply,\n                .sequenceNumber = client->sequence,\n                .length = bytes_to_int32(length),\n                .nPixels = npixels,\n                .nMasks = nmasks\n            };\n            WriteReplyToClient(client, sizeof(xAllocColorCellsReply), &accr);\n            client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;\n            WriteSwappedDataToClient(client, length, ppixels);\n        }\n        free(ppixels);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "xsltCleanupStylesheetTree(xmlDocPtr doc ATTRIBUTE_UNUSED,\n\t\t\t  xmlNodePtr rootElem ATTRIBUTE_UNUSED)\n{    \n#if 0 \n    xmlNodePtr cur;\n    if ((doc == NULL) || (rootElem == NULL) ||\n\t(rootElem->type != XML_ELEMENT_NODE) ||\n\t(doc != rootElem->doc))\n\treturn(-1);\n    cur = rootElem;\n    while (cur != NULL) {\n\tif (cur->type == XML_ELEMENT_NODE) {\n\t    cur->psvi = NULL;\n\t    if (cur->children) {\n\t\tcur = cur->children;\n\t\tcontinue;\n\t    }\n\t}\nleave_node:\n\tif (cur == rootElem)\n\t    break;\n\tif (cur->next != NULL)\n\t    cur = cur->next;\n\telse {\n\t    cur = cur->parent;\n\t    if (cur == NULL)\n\t\tbreak;\n\t    goto leave_node;\n\t}\n    }\n#endif \n    return(0);\n}", "target": 0}
{"code": "void PageClickTracker::StopTrackingFrame(WebFrame* frame, bool frame_detached) {\n  FrameList::iterator iter =\n      std::find(tracked_frames_.begin(), tracked_frames_.end(), frame);\n  if (iter == tracked_frames_.end()) {\n    return;\n  }\n  tracked_frames_.erase(iter);\n  if (!frame_detached)\n    frame->document().removeEventListener(\"mousedown\", this, false);\n}", "target": 0}
{"code": "SYSCALL_DEFINE1(epoll_create1, int, flags)\n{\n\tint error, fd;\n\tstruct eventpoll *ep = NULL;\n\tstruct file *file;\n\tBUILD_BUG_ON(EPOLL_CLOEXEC != O_CLOEXEC);\n\tif (flags & ~EPOLL_CLOEXEC)\n\t\treturn -EINVAL;\n\terror = ep_alloc(&ep);\n\tif (error < 0)\n\t\treturn error;\n\tfd = get_unused_fd_flags(O_RDWR | (flags & O_CLOEXEC));\n\tif (fd < 0) {\n\t\terror = fd;\n\t\tgoto out_free_ep;\n\t}\n\tfile = anon_inode_getfile(\"[eventpoll]\", &eventpoll_fops, ep,\n\t\t\t\t O_RDWR | (flags & O_CLOEXEC));\n\tif (IS_ERR(file)) {\n\t\terror = PTR_ERR(file);\n\t\tgoto out_free_fd;\n\t}\n\tfd_install(fd, file);\n\tep->file = file;\n\treturn fd;\nout_free_fd:\n\tput_unused_fd(fd);\nout_free_ep:\n\tep_free(ep);\n\treturn error;\n}", "target": 0}
{"code": "GF_Err gf_isom_get_pssh(GF_ISOFile *file, u32 pssh_index, u8 **pssh_data, u32 *pssh_size)\n{\n\tGF_Err e;\n\tu32 i=0;\n\tGF_BitStream *bs;\n\tu32 count=1;\n\tGF_Box *pssh;\n\twhile ((pssh = (GF_Box *)gf_list_enum(file->moov->child_boxes, &i))) {\n\t\tif (pssh->type != GF_ISOM_BOX_TYPE_PSSH) continue;\n\t\tif (count == pssh_index) break;\n\t\tcount++;\n\t}\n\tif (!pssh) return GF_BAD_PARAM;\n\tbs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\te = gf_isom_box_write(pssh, bs);\n\tif (!e) {\n\t\tgf_bs_get_content(bs, pssh_data, pssh_size);\n\t}\n\tgf_bs_del(bs);\n\treturn e;\n}", "target": 0}
{"code": "CMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\tif ((parv[1][0] == ':') || strchr(parv[1], ' '))\n\t{\n\t\tsendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, \"*\", \"AUTHENTICATE\", \"Invalid parameter\");\n\t\treturn 0;\n\t}\n\tif (strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\tsptr->local->sasl_out++;\n\treturn 0;\n}", "target": 0}
{"code": "static int __init platform_optin_force_iommu(void)\n{\n\tstruct pci_dev *pdev = NULL;\n\tbool has_untrusted_dev = false;\n\tif (!dmar_platform_optin() || no_platform_optin)\n\t\treturn 0;\n\tfor_each_pci_dev(pdev) {\n\t\tif (pdev->untrusted) {\n\t\t\thas_untrusted_dev = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!has_untrusted_dev)\n\t\treturn 0;\n\tif (no_iommu || dmar_disabled)\n\t\tpr_info(\"Intel-IOMMU force enabled due to platform opt in\\n\");\n\tif (dmar_disabled)\n\t\tiommu_identity_mapping |= IDENTMAP_ALL;\n\tdmar_disabled = 0;\n#if defined(CONFIG_X86) && defined(CONFIG_SWIOTLB)\n\tswiotlb = 0;\n#endif\n\tno_iommu = 0;\n\treturn 1;\n}", "target": 0}
{"code": "DocumentSourceUnionWith::~DocumentSourceUnionWith() {\n    if (_pipeline && _pipeline->getContext()->explain) {\n        _pipeline->dispose(pExpCtx->opCtx);\n        _pipeline.reset();\n    }\n}", "target": 0}
{"code": "    WebViewImpl* webViewImpl() const { return toWebViewImpl(m_webView); }", "target": 0}
{"code": "static void scrub_block_put(struct scrub_block *sblock)\n{\n\tif (refcount_dec_and_test(&sblock->refs)) {\n\t\tint i;\n\t\tif (sblock->sparity)\n\t\t\tscrub_parity_put(sblock->sparity);\n\t\tfor (i = 0; i < sblock->page_count; i++)\n\t\t\tscrub_page_put(sblock->pagev[i]);\n\t\tkfree(sblock);\n\t}\n}", "target": 0}
{"code": "static struct inet6_ifaddr *if6_get_first(struct seq_file *seq, loff_t pos)\n{\n\tstruct inet6_ifaddr *ifa = NULL;\n\tstruct if6_iter_state *state = seq->private;\n\tstruct net *net = seq_file_net(seq);\n\tint p = 0;\n\tif (pos == 0) {\n\t\tstate->bucket = 0;\n\t\tstate->offset = 0;\n\t}\n\tfor (; state->bucket < IN6_ADDR_HSIZE; ++state->bucket) {\n\t\thlist_for_each_entry_rcu_bh(ifa, &inet6_addr_lst[state->bucket],\n\t\t\t\t\t addr_lst) {\n\t\t\tif (!net_eq(dev_net(ifa->idev->dev), net))\n\t\t\t\tcontinue;\n\t\t\tif (p < state->offset) {\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstate->offset++;\n\t\t\treturn ifa;\n\t\t}\n\t\tstate->offset = 0;\n\t\tp = 0;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "_XkbCheckTypeName(Atom name,int typeNdx)\n{\nchar *\tstr;\n    str= NameForAtom(name);\n    if ((strcmp(str,\"ONE_LEVEL\")==0)||(strcmp(str,\"TWO_LEVEL\")==0)||\n\t(strcmp(str,\"ALPHABETIC\")==0)||(strcmp(str,\"KEYPAD\")==0))\n\treturn False;\n    return True;\n}", "target": 0}
{"code": "static void inet_get_ping_group_range_net(struct net *net, kgid_t *low,\n\t\t\t\t\t  kgid_t *high)\n{\n\tkgid_t *data = net->ipv4.ping_group_range.range;\n\tunsigned int seq;\n\tdo {\n\t\tseq = read_seqbegin(&net->ipv4.ping_group_range.lock);\n\t\t*low = data[0];\n\t\t*high = data[1];\n\t} while (read_seqretry(&net->ipv4.ping_group_range.lock, seq));\n}", "target": 0}
{"code": "static double php_log1p(double x)\n{\n#ifdef HAVE_LOG1P\n\treturn(log1p(x));\n#else\n\treturn(log(1 + x));\n#endif\n}", "target": 0}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             TfLiteMulParams* params, OpData* data) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInput1Tensor);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInput2Tensor);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n    double real_multiplier = static_cast<double>(input1->params.scale) *\n                             static_cast<double>(input2->params.scale) /\n                             static_cast<double>(output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier,\n                       &data->output_shift);\n    data->input1_zero_point = input1->params.zero_point;\n    data->input2_zero_point = input2->params.zero_point;\n    data->output_zero_point = output->params.zero_point;\n  } else {\n    CalculateActivationRange(params->activation,\n                             &data->output_activation_min_f32,\n                             &data->output_activation_max_f32);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "\tif (datasize > SumOfBytesHashed) {\n\t\thashbase = data + SumOfBytesHashed;\n\t\thashsize = datasize - SumOfBytesHashed;\n\t\tcheck_size(data, datasize, hashbase, hashsize);\n\t\tif (!(Sha256Update(sha256ctx, hashbase, hashsize)) ||\n\t\t    !(Sha1Update(sha1ctx, hashbase, hashsize))) {\n\t\t\tperror(L\"Unable to generate hash\\n\");\n\t\t\tefi_status = EFI_OUT_OF_RESOURCES;\n\t\t\tgoto done;\n\t\t}\n\t\tSumOfBytesHashed += hashsize;\n\t}", "target": 0}
{"code": "camel_imapx_server_list_sync (CamelIMAPXServer *is,\n\t\t\t      const gchar *pattern,\n\t\t\t      CamelStoreGetFolderInfoFlags flags,\n\t\t\t      GCancellable *cancellable,\n\t\t\t      GError **error)\n{\n\tCamelIMAPXCommand *ic;\n\tgboolean success;\n\tg_return_val_if_fail (CAMEL_IS_IMAPX_SERVER (is), FALSE);\n\tg_return_val_if_fail (pattern != NULL, FALSE);\n\tif (is->priv->list_return_opts != NULL) {\n\t\tic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_LIST, \"LIST \\\"\\\" %s RETURN (%t)\",\n\t\t\tpattern, is->priv->list_return_opts);\n\t} else {\n\t\tic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_LIST, \"LIST \\\"\\\" %s\",\n\t\t\tpattern);\n\t}\n\tsuccess = camel_imapx_server_process_command_sync (is, ic, _(\"Error fetching folders\"), cancellable, error);\n\tcamel_imapx_command_unref (ic);\n\tif (!success)\n\t\treturn FALSE;\n\tif (!is->priv->list_return_opts) {\n\t\tic = camel_imapx_command_new (is, CAMEL_IMAPX_JOB_LSUB, \"LSUB \\\"\\\" %s\",\n\t\t\tpattern);\n\t\tsuccess = camel_imapx_server_process_command_sync (is, ic, _(\"Error fetching subscribed folders\"), cancellable, error);\n\t\tcamel_imapx_command_unref (ic);\n\t}\n\treturn success;\n}", "target": 0}
{"code": "int __close_fd_get_file(unsigned int fd, struct file **res)\n{\n\tstruct files_struct *files = current->files;\n\tstruct file *file;\n\tstruct fdtable *fdt;\n\tfdt = files_fdtable(files);\n\tif (fd >= fdt->max_fds)\n\t\tgoto out_err;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_err;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tget_file(file);\n\t*res = file;\n\treturn 0;\nout_err:\n\t*res = NULL;\n\treturn -ENOENT;\n}", "target": 0}
{"code": "static int posix_get_hrtimer_res(clockid_t which_clock, struct timespec64 *tp)\n{\n\ttp->tv_sec = 0;\n\ttp->tv_nsec = hrtimer_resolution;\n\treturn 0;\n}", "target": 0}
{"code": "AFfilehandle afOpenVirtualFile (AFvirtualfile *vfile, const char *mode,\n\tAFfilesetup setup)\n{\n\tAFfilehandle\tfilehandle;\n\tint\t\taccess; \n\tif (vfile == NULL)\n\t{\n\t\t_af_error(AF_BAD_FILEHANDLE, \"null virtual filehandle\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\tif (mode == NULL)\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"null access mode\");\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\tif (mode[0] == 'r')\n\t\taccess = _AF_READ_ACCESS;\n\telse if (mode[0] == 'w')\n\t\taccess = _AF_WRITE_ACCESS;\n\telse\n\t{\n\t\t_af_error(AF_BAD_ACCMODE, \"unrecognized access mode '%s'\", mode);\n\t\treturn AF_NULL_FILEHANDLE;\n\t}\n\tif (_afOpenFile(access, vfile, NULL, &filehandle, setup) != AF_SUCCEED)\n\t\taf_fclose(vfile);\n\treturn filehandle;\n}", "target": 0}
{"code": "void *malloc(size_t size)\n{\n\tstruct free_arena_header *fp;\n\tstruct free_arena_header *pah;\n\tsize_t fsize;\n\tif (size == 0)\n\t\treturn NULL;\n\tif (size > PTRDIFF_MAX) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tsize = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;\n\tfor (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;\n\t     fp = fp->next_free) {\n\t\tif (fp->a.size >= size) {\n\t\t\treturn __malloc_from_block(fp, size);\n\t\t}\n\t}\n\tfsize = (size + MALLOC_CHUNK_MASK) & ~MALLOC_CHUNK_MASK;\n#if _KLIBC_MALLOC_USES_SBRK\n\tfp = (struct free_arena_header *)sbrk(fsize);\n#else\n\tfp = (struct free_arena_header *)\n\t    mmap(NULL, fsize, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n#endif\n\tif (fp == (struct free_arena_header *)MAP_FAILED) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\t\n\t}\n\tfp->a.type = ARENA_TYPE_FREE;\n\tfp->a.size = fsize;\n\tfor (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;\n\t     pah = pah->a.prev) {\n\t\tif (pah < fp)\n\t\t\tbreak;\n\t}\n\tfp->a.next = pah->a.next;\n\tfp->a.prev = pah;\n\tpah->a.next = fp;\n\tfp->a.next->a.prev = fp;\n\tfp = __free_block(fp);\n\treturn __malloc_from_block(fp, size);\n}", "target": 0}
{"code": "void opj_j2k_write_qcc_in_memory(   opj_j2k_t *p_j2k,\n                                                                OPJ_UINT32 p_comp_no,\n                                                                OPJ_BYTE * p_data,\n                                                                OPJ_UINT32 * p_data_written,\n                                                                opj_event_mgr_t * p_manager\n                                    )\n{\n        OPJ_UINT32 l_qcc_size,l_remaining_size;\n        OPJ_BYTE * l_current_data = 00;\n        assert(p_j2k != 00);\n        assert(p_manager != 00);\n        l_qcc_size = 6 + opj_j2k_get_SQcd_SQcc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);\n        l_remaining_size = l_qcc_size;\n        l_current_data = p_data;\n        opj_write_bytes(l_current_data,J2K_MS_QCC,2);           \n        l_current_data += 2;\n        if (p_j2k->m_private_image->numcomps <= 256) {\n                --l_qcc_size;\n                opj_write_bytes(l_current_data,l_qcc_size-2,2);         \n                l_current_data += 2;\n                opj_write_bytes(l_current_data, p_comp_no, 1);  \n                ++l_current_data;\n                l_remaining_size -= 6;\n        }\n        else {\n                opj_write_bytes(l_current_data,l_qcc_size-2,2);         \n                l_current_data += 2;\n                opj_write_bytes(l_current_data, p_comp_no, 2);  \n                l_current_data+=2;\n                l_remaining_size -= 6;\n        }\n        opj_j2k_write_SQcd_SQcc(p_j2k,p_j2k->m_current_tile_number,p_comp_no,l_current_data,&l_remaining_size,p_manager);\n        *p_data_written = l_qcc_size;\n}", "target": 0}
{"code": "void InstanceKlass::notify_unload_class(InstanceKlass* ik) {\n  if (JvmtiExport::should_post_class_unload()) {\n    JvmtiExport::post_class_unload(ik);\n  }\n  ClassLoadingService::notify_class_unloaded(ik);\n}", "target": 0}
{"code": "static int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,\n\t\t\t     struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct packet_fanout *f = pt->af_packet_priv;\n\tunsigned int num = READ_ONCE(f->num_members);\n\tstruct net *net = read_pnet(&f->net);\n\tstruct packet_sock *po;\n\tunsigned int idx;\n\tif (!net_eq(dev_net(dev), net) || !num) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\tif (fanout_has_flag(f, PACKET_FANOUT_FLAG_DEFRAG)) {\n\t\tskb = ip_check_defrag(net, skb, IP_DEFRAG_AF_PACKET);\n\t\tif (!skb)\n\t\t\treturn 0;\n\t}\n\tswitch (f->type) {\n\tcase PACKET_FANOUT_HASH:\n\tdefault:\n\t\tidx = fanout_demux_hash(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_LB:\n\t\tidx = fanout_demux_lb(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_CPU:\n\t\tidx = fanout_demux_cpu(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_RND:\n\t\tidx = fanout_demux_rnd(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_QM:\n\t\tidx = fanout_demux_qm(f, skb, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_ROLLOVER:\n\t\tidx = fanout_demux_rollover(f, skb, 0, false, num);\n\t\tbreak;\n\tcase PACKET_FANOUT_CBPF:\n\tcase PACKET_FANOUT_EBPF:\n\t\tidx = fanout_demux_bpf(f, skb, num);\n\t\tbreak;\n\t}\n\tif (fanout_has_flag(f, PACKET_FANOUT_FLAG_ROLLOVER))\n\t\tidx = fanout_demux_rollover(f, skb, idx, true, num);\n\tpo = pkt_sk(f->arr[idx]);\n\treturn po->prot_hook.func(skb, dev, &po->prot_hook, orig_dev);\n}", "target": 0}
{"code": "static struct xen_netif_tx_request *xennet_make_first_txreq(\n\tstruct xennet_gnttab_make_txreq *info,\n\tunsigned int offset, unsigned int len)\n{\n\tinfo->size = 0;\n\tgnttab_for_one_grant(info->page, offset, len, xennet_tx_setup_grant, info);\n\treturn info->tx;\n}", "target": 0}
{"code": "int gnutls_x509_aki_get_id(gnutls_x509_aki_t aki, gnutls_datum_t * id)\n{\n\tif (aki->id.size == 0)\n\t\treturn gnutls_assert_val(GNUTLS_E_REQUESTED_DATA_NOT_AVAILABLE);\n\tmemcpy(id, &aki->id, sizeof(gnutls_datum_t));\n\treturn 0;\n}", "target": 0}
{"code": "CustomDrawButton* BrowserTitlebar::BuildTitlebarButton(int image,\n    int image_pressed, int image_hot, GtkWidget* box, int tooltip) {\n  CustomDrawButton* button = new CustomDrawButton(image, image_pressed,\n                                                  image_hot, 0);\n  gtk_widget_add_events(GTK_WIDGET(button->widget()), GDK_POINTER_MOTION_MASK);\n  g_signal_connect(button->widget(), \"clicked\", G_CALLBACK(OnButtonClicked),\n                   this);\n  g_signal_connect(button->widget(), \"motion-notify-event\",\n                   G_CALLBACK(OnMouseMoveEvent), browser_window_);\n  std::string localized_tooltip = l10n_util::GetStringUTF8(tooltip);\n  gtk_widget_set_tooltip_text(button->widget(),\n                              localized_tooltip.c_str());\n  gtk_box_pack_end(GTK_BOX(box), button->widget(), FALSE, FALSE, 0);\n  return button;\n}", "target": 0}
{"code": "        std::vector<char*> pop_list(const std::string& name, bool use_brackets = true)\n        {\n            std::vector<char*> ret = get_list(name, use_brackets);\n            if (!ret.empty())\n            {\n                for (unsigned int i = 0; i < key_value_pairs_.size(); i++)\n                {\n                    std::string str_item(key_value_pairs_[i]);\n                    if ((use_brackets ? (str_item.substr(0, name.size() + 3) == name + \"[]=\") : (str_item.substr(0, name.size() + 1) == name + '=')))\n                    {\n                        key_value_pairs_.erase(key_value_pairs_.begin() + i--);\n                    }\n                }\n            }\n            return ret;\n        }", "target": 0}
{"code": "static int ldb_match_substring(struct ldb_context *ldb, \n\t\t\t       const struct ldb_message *msg,\n\t\t\t       const struct ldb_parse_tree *tree,\n\t\t\t       enum ldb_scope scope, bool *matched)\n{\n\tunsigned int i;\n\tstruct ldb_message_element *el;\n\tel = ldb_msg_find_element(msg, tree->u.substring.attr);\n\tif (el == NULL) {\n\t\t*matched = false;\n\t\treturn LDB_SUCCESS;\n\t}\n\tfor (i = 0; i < el->num_values; i++) {\n\t\tint ret;\n\t\tret = ldb_wildcard_compare(ldb, tree, el->values[i], matched);\n\t\tif (ret != LDB_SUCCESS) return ret;\n\t\tif (*matched) return LDB_SUCCESS;\n\t}\n\t*matched = false;\n\treturn LDB_SUCCESS;\n}", "target": 0}
{"code": " bool PpapiPluginProcessHost::OnMessageReceived(const IPC::Message& msg) {\n   bool handled = true;\n   IPC_BEGIN_MESSAGE_MAP(PpapiPluginProcessHost, msg)\n    IPC_MESSAGE_HANDLER(PpapiHostMsg_ChannelCreated,\n                        OnRendererPluginChannelCreated)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n  DCHECK(handled);\n  return handled;\n}", "target": 0}
{"code": "static void ok_png_decode_filter(uint8_t * RESTRICT curr, const uint8_t * RESTRICT prev,\n                                 size_t length, int filter, uint8_t bpp) {\n    switch (filter) {\n        case OK_PNG_FILTER_NONE:\n            break;\n        case OK_PNG_FILTER_SUB: {\n            for (size_t i = bpp; i < length; i++) {\n                curr[i] = curr[i] + curr[i - bpp];\n            }\n            break;\n        }\n        case OK_PNG_FILTER_UP: {\n            for (size_t i = 0; i < length; i++) {\n                curr[i] = curr[i] + prev[i];\n            }\n            break;\n        }\n        case OK_PNG_FILTER_AVG: {\n            for (size_t i = 0; i < bpp; i++) {\n                curr[i] = curr[i] + (prev[i] >> 1);\n            }\n            for (size_t j = bpp; j < length; j++) {\n                curr[j] = curr[j] + ((curr[j - bpp] + prev[j]) >> 1);\n            }\n            break;\n        }\n        case OK_PNG_FILTER_PAETH: {\n            for (size_t i = 0; i < bpp; i++) {\n                curr[i] += prev[i];\n            }\n            for (size_t j = bpp; j < length; j++) {\n                curr[j] += ok_png_paeth_predictor(curr[j - bpp], prev[j], prev[j - bpp]);\n            }\n            break;\n        }\n    }\n}", "target": 0}
{"code": "void *_af_calloc (size_t nmemb, size_t size)\n{\n\tvoid\t*p;\n\tif (nmemb <= 0 || size <= 0)\n\t{\n\t\t_af_error(AF_BAD_MALLOC, \"bad memory allocation size request \"\n\t\t\t\"%d elements of %d bytes each\", nmemb, size);\n\t\treturn NULL;\n\t}\n\tp = calloc(nmemb, size);\n\tif (p == NULL)\n\t{\n\t\t_af_error(AF_BAD_MALLOC, \"allocation of %d bytes failed\",\n\t\t\tnmemb*size);\n\t\treturn NULL;\n\t}\n\treturn p;\n}", "target": 0}
{"code": "gfx::Rect RenderViewTest::GetElementBounds(const std::string& element_id) {\n  static constexpr char kGetCoordinatesScript[] =\n      \"(function() {\"\n      \"  function GetCoordinates(elem) {\"\n      \"    if (!elem)\"\n      \"      return [ 0, 0];\"\n      \"    var coordinates = [ elem.offsetLeft, elem.offsetTop];\"\n      \"    var parent_coordinates = GetCoordinates(elem.offsetParent);\"\n      \"    coordinates[0] += parent_coordinates[0];\"\n      \"    coordinates[1] += parent_coordinates[1];\"\n      \"    return [ Math.round(coordinates[0]),\"\n      \"             Math.round(coordinates[1])];\"\n      \"  };\"\n      \"  var elem = document.getElementById('$1');\"\n      \"  if (!elem)\"\n      \"    return null;\"\n      \"  var bounds = GetCoordinates(elem);\"\n      \"  bounds[2] = Math.round(elem.offsetWidth);\"\n      \"  bounds[3] = Math.round(elem.offsetHeight);\"\n      \"  return bounds;\"\n      \"})();\";\n  std::vector<std::string> params;\n  params.push_back(element_id);\n  std::string script =\n      base::ReplaceStringPlaceholders(kGetCoordinatesScript, params, nullptr);\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope handle_scope(isolate);\n  v8::Local<v8::Value> value = GetMainFrame()->ExecuteScriptAndReturnValue(\n      WebScriptSource(WebString::FromUTF8(script)));\n  if (value.IsEmpty() || !value->IsArray())\n    return gfx::Rect();\n  v8::Local<v8::Array> array = value.As<v8::Array>();\n  if (array->Length() != 4)\n    return gfx::Rect();\n  std::vector<int> coords;\n  for (int i = 0; i < 4; ++i) {\n    v8::Local<v8::Number> index = v8::Number::New(isolate, i);\n    v8::Local<v8::Value> value = array->Get(index);\n    if (value.IsEmpty() || !value->IsInt32())\n      return gfx::Rect();\n    coords.push_back(value->Int32Value());\n  }\n  return gfx::Rect(coords[0], coords[1], coords[2], coords[3]);\n}", "target": 0}
{"code": "GF_Box *mhap_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MHACompatibleProfilesBox, GF_ISOM_BOX_TYPE_MHAP);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "void HTMLMediaElement::Trace(blink::Visitor* visitor) {\n  visitor->Trace(viewport_intersection_observer_);\n  visitor->Trace(played_time_ranges_);\n  visitor->Trace(async_event_queue_);\n  visitor->Trace(error_);\n  visitor->Trace(current_source_node_);\n  visitor->Trace(next_child_node_to_consider_);\n  visitor->Trace(media_source_);\n  visitor->Trace(audio_tracks_);\n  visitor->Trace(video_tracks_);\n  visitor->Trace(cue_timeline_);\n  visitor->Trace(text_tracks_);\n  visitor->Trace(text_tracks_when_resource_selection_began_);\n  visitor->Trace(play_promise_resolvers_);\n  visitor->Trace(play_promise_resolve_list_);\n  visitor->Trace(play_promise_reject_list_);\n  visitor->Trace(audio_source_provider_);\n  visitor->Trace(src_object_);\n  visitor->Trace(autoplay_policy_);\n  visitor->Trace(media_controls_);\n  visitor->Trace(controls_list_);\n  visitor->Trace(lazy_load_visibility_observer_);\n  visitor->template RegisterWeakMembers<HTMLMediaElement,\n                                        &HTMLMediaElement::ClearWeakMembers>(\n      this);\n  Supplementable<HTMLMediaElement>::Trace(visitor);\n  HTMLElement::Trace(visitor);\n  PausableObject::Trace(visitor);\n}", "target": 0}
{"code": "static int ssi_sd_load(QEMUFile *f, void *opaque, int version_id)\n{\n    SSISlave *ss = SSI_SLAVE(opaque);\n    ssi_sd_state *s = (ssi_sd_state *)opaque;\n    int i;\n    if (version_id != 1)\n        return -EINVAL;\n    s->mode = qemu_get_be32(f);\n    s->cmd = qemu_get_be32(f);\n    for (i = 0; i < 4; i++)\n        s->cmdarg[i] = qemu_get_be32(f);\n     for (i = 0; i < 5; i++)\n         s->response[i] = qemu_get_be32(f);\n     s->arglen = qemu_get_be32(f);\n    if (s->mode == SSI_SD_CMDARG &&\n        (s->arglen < 0 || s->arglen >= ARRAY_SIZE(s->cmdarg))) {\n        return -EINVAL;\n    }\n     s->response_pos = qemu_get_be32(f);\n     s->stopping = qemu_get_be32(f);\n    if (s->mode == SSI_SD_RESPONSE &&\n        (s->response_pos < 0 || s->response_pos >= ARRAY_SIZE(s->response) ||\n        (!s->stopping && s->arglen > ARRAY_SIZE(s->response)))) {\n        return -EINVAL;\n    }\n     ss->cs = qemu_get_be32(f);\n    s->mode = SSI_SD_CMD;\n    dinfo = drive_get_next(IF_SD);\n    s->sd = sd_init(dinfo ? dinfo->bdrv : NULL, true);\n    if (s->sd == NULL) {\n        return -1;\n    }\n    register_savevm(dev, \"ssi_sd\", -1, 1, ssi_sd_save, ssi_sd_load, s);\n    return 0;\n}", "target": 0}
{"code": "void WebContentsImpl::WasOccluded() {\n  const Visibility previous_visibility = GetVisibility();\n  if (!IsBeingCaptured()) {\n    for (RenderWidgetHostView* view : GetRenderWidgetHostViewsInTree())\n      view->WasOccluded();\n  }\n  should_normally_be_occluded_ = true;\n  NotifyVisibilityChanged(previous_visibility);\n}", "target": 0}
{"code": "void RenderView::OnDisassociateFromPopupCount() {\n  if (decrement_shared_popup_at_destruction_)\n    shared_popup_counter_->data--;\n  shared_popup_counter_ = new SharedRenderViewCounter(0);\n  decrement_shared_popup_at_destruction_ = false;\n}", "target": 0}
{"code": "static void *conn_timeout_thread(void *arg) {\n    int i;\n    conn *c;\n    char buf[TIMEOUT_MSG_SIZE];\n    rel_time_t oldest_last_cmd;\n    int sleep_time;\n    int sleep_slice = max_fds / CONNS_PER_SLICE;\n    if (sleep_slice == 0)\n        sleep_slice = CONNS_PER_SLICE;\n    useconds_t timeslice = 1000000 / sleep_slice;\n    while(do_run_conn_timeout_thread) {\n        if (settings.verbose > 2)\n            fprintf(stderr, \"idle timeout thread at top of connection list\\n\");\n        oldest_last_cmd = current_time;\n        for (i = 0; i < max_fds; i++) {\n            if ((i % CONNS_PER_SLICE) == 0) {\n                if (settings.verbose > 2)\n                    fprintf(stderr, \"idle timeout thread sleeping for %ulus\\n\",\n                        (unsigned int)timeslice);\n                usleep(timeslice);\n            }\n            if (!conns[i])\n                continue;\n            c = conns[i];\n            if (!IS_TCP(c->transport))\n                continue;\n            if (c->state != conn_new_cmd && c->state != conn_read)\n                continue;\n            if ((current_time - c->last_cmd_time) > settings.idle_timeout) {\n                buf[0] = 't';\n                memcpy(&buf[1], &i, sizeof(int));\n                if (write(c->thread->notify_send_fd, buf, TIMEOUT_MSG_SIZE)\n                    != TIMEOUT_MSG_SIZE)\n                    perror(\"Failed to write timeout to notify pipe\");\n            } else {\n                if (c->last_cmd_time < oldest_last_cmd)\n                    oldest_last_cmd = c->last_cmd_time;\n            }\n        }\n        sleep_time = settings.idle_timeout - (current_time - oldest_last_cmd) + 1;\n        if (sleep_time <= 0)\n            sleep_time = 1;\n        if (settings.verbose > 2)\n            fprintf(stderr,\n                    \"idle timeout thread finished pass, sleeping for %ds\\n\",\n                    sleep_time);\n        usleep((useconds_t) sleep_time * 1000000);\n    }\n    return NULL;\n}", "target": 0}
{"code": "void AudioContext::handlePostRenderTasks()\n{\n    ASSERT(isAudioThread());\n    if (tryLock()) {\n        updateChangedChannelCountMode();\n        handleDeferredAudioNodeTasks();\n        derefFinishedSourceNodes();\n        handleDirtyAudioSummingJunctions();\n        handleDirtyAudioNodeOutputs();\n        updateAutomaticPullNodes();\n        resolvePromisesForSuspend();\n        unlock();\n    }\n}", "target": 0}
{"code": "static void enqueue_huge_page(struct hstate *h, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tlockdep_assert_held(&hugetlb_lock);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\tlist_move(&page->lru, &h->hugepage_freelists[nid]);\n\th->free_huge_pages++;\n\th->free_huge_pages_node[nid]++;\n\tSetHPageFreed(page);\n}", "target": 0}
{"code": "PHP_FUNCTION(snmpgetnext)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, SNMP_CMD_GETNEXT, SNMP_VERSION_1);\n}", "target": 0}
{"code": "srs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}", "target": 0}
{"code": "static ssize_t demote_size_store(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct hstate *h, *demote_hstate;\n\tunsigned long demote_size;\n\tunsigned int demote_order;\n\tint nid;\n\tdemote_size = (unsigned long)memparse(buf, NULL);\n\tdemote_hstate = size_to_hstate(demote_size);\n\tif (!demote_hstate)\n\t\treturn -EINVAL;\n\tdemote_order = demote_hstate->order;\n\tif (demote_order < HUGETLB_PAGE_ORDER)\n\t\treturn -EINVAL;\n\th = kobj_to_hstate(kobj, &nid);\n\tif (demote_order >= h->order)\n\t\treturn -EINVAL;\n\tmutex_lock(&h->resize_lock);\n\th->demote_order = demote_order;\n\tmutex_unlock(&h->resize_lock);\n\treturn count;\n}", "target": 0}
{"code": "mm_answer_pam_query(int socket, Buffer *m)\n{\n\tchar *name, *info, **prompts;\n\tu_int num, *echo_on;\n\tint i, ret;\n\tdebug3(\"%s\", __func__);\n\tsshpam_authok = NULL;\n\tret = (sshpam_device.query)(sshpam_ctxt, &name, &info, &num, &prompts, &echo_on);\n\tif (ret == 0 && num == 0)\n\t\tsshpam_authok = sshpam_ctxt;\n\tif (num > 1 || name == NULL || info == NULL)\n\t\tret = -1;\n\tbuffer_clear(m);\n\tbuffer_put_int(m, ret);\n\tbuffer_put_cstring(m, name);\n\txfree(name);\n\tbuffer_put_cstring(m, info);\n\txfree(info);\n\tbuffer_put_int(m, num);\n\tfor (i = 0; i < num; ++i) {\n\t\tbuffer_put_cstring(m, prompts[i]);\n\t\txfree(prompts[i]);\n\t\tbuffer_put_int(m, echo_on[i]);\n\t}\n\tif (prompts != NULL)\n\t\txfree(prompts);\n\tif (echo_on != NULL)\n\t\txfree(echo_on);\n\tmm_request_send(socket, MONITOR_ANS_PAM_QUERY, m);\n\treturn (0);\n}", "target": 0}
{"code": "IsTypeInUINT64 (\n  IN  EFI_HII_VALUE   *Value\n  )\n{\n  switch (Value->Type) {\n  case EFI_IFR_TYPE_NUM_SIZE_8:\n  case EFI_IFR_TYPE_NUM_SIZE_16:\n  case EFI_IFR_TYPE_NUM_SIZE_32:\n  case EFI_IFR_TYPE_NUM_SIZE_64:\n  case EFI_IFR_TYPE_BOOLEAN:\n    return TRUE;\n  default:\n    return FALSE;\n  }\n}", "target": 0}
{"code": "bool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work_t *pubkey) {\n  ecc_25519_work_t s2, work;\n  ecc_int256_t w, tmp;\n  if (ecc_25519_gf_is_zero(&ctx->r))\n    return false;\n  ecc_25519_scalarmult(&s2, &ctx->u2, pubkey);\n  ecc_25519_add(&work, &ctx->s1, &s2);\n  ecc_25519_store_xy_legacy(&w, NULL, &work);\n  ecc_25519_gf_sub(&tmp, &ctx->r, &w);\n  return ecc_25519_gf_is_zero(&tmp);\n}", "target": 0}
{"code": "JSRetainPtr<JSStringRef> AccessibilityUIElement::stringForTextMarkerRange(AccessibilityTextMarkerRange* markerRange)\n{\n    return JSStringCreateWithCharacters(0, 0);\n}", "target": 0}
{"code": "static void *get_partial_node(struct kmem_cache *s, struct kmem_cache_node *n,\n\t\t\t\tstruct kmem_cache_cpu *c, gfp_t flags)\n{\n\tstruct page *page, *page2;\n\tvoid *object = NULL;\n\tunsigned int available = 0;\n\tint objects;\n\tif (!n || !n->nr_partial)\n\t\treturn NULL;\n\tspin_lock(&n->list_lock);\n\tlist_for_each_entry_safe(page, page2, &n->partial, slab_list) {\n\t\tvoid *t;\n\t\tif (!pfmemalloc_match(page, flags))\n\t\t\tcontinue;\n\t\tt = acquire_slab(s, n, page, object == NULL, &objects);\n\t\tif (!t)\n\t\t\tbreak;\n\t\tavailable += objects;\n\t\tif (!object) {\n\t\t\tc->page = page;\n\t\t\tstat(s, ALLOC_FROM_PARTIAL);\n\t\t\tobject = t;\n\t\t} else {\n\t\t\tput_cpu_partial(s, page, 0);\n\t\t\tstat(s, CPU_PARTIAL_NODE);\n\t\t}\n\t\tif (!kmem_cache_has_cpu_partial(s)\n\t\t\t|| available > slub_cpu_partial(s) / 2)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&n->list_lock);\n\treturn object;\n}", "target": 0}
{"code": "Value ExpressionFirst::evaluate(const Document& root, Variables* variables) const {\n    const Value array = _children[0]->evaluate(root, variables);\n    return arrayElemAt(this, array, Value(0));\n}", "target": 0}
{"code": "static int domain_context_mapped_cb(struct pci_dev *pdev,\n\t\t\t\t    u16 alias, void *opaque)\n{\n\tstruct intel_iommu *iommu = opaque;\n\treturn !device_context_mapped(iommu, PCI_BUS_NUM(alias), alias & 0xff);\n}", "target": 0}
{"code": "TransportDIB::Handle RenderView::AcceleratedSurfaceAllocTransportDIB(\n    size_t size) {\n  TransportDIB::Handle dib_handle;\n  if (Send(new ViewHostMsg_AllocTransportDIB(size, true, &dib_handle)))\n    return dib_handle;\n  return TransportDIB::DefaultHandleValue();\n}", "target": 0}
{"code": "static unsigned long xol_take_insn_slot(struct xol_area *area)\n{\n\tunsigned long slot_addr;\n\tint slot_nr;\n\tdo {\n\t\tslot_nr = find_first_zero_bit(area->bitmap, UINSNS_PER_PAGE);\n\t\tif (slot_nr < UINSNS_PER_PAGE) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->bitmap))\n\t\t\t\tbreak;\n\t\t\tslot_nr = UINSNS_PER_PAGE;\n\t\t\tcontinue;\n\t\t}\n\t\twait_event(area->wq, (atomic_read(&area->slot_count) < UINSNS_PER_PAGE));\n\t} while (slot_nr >= UINSNS_PER_PAGE);\n\tslot_addr = area->vaddr + (slot_nr * UPROBE_XOL_SLOT_BYTES);\n\tatomic_inc(&area->slot_count);\n\treturn slot_addr;\n}", "target": 0}
{"code": "void mark_join_nest_as_const(JOIN *join,\n                             TABLE_LIST *join_nest,\n                             table_map *found_const_table_map,\n                             uint *const_count)\n{\n  List_iterator<TABLE_LIST> it(join_nest->nested_join->join_list);\n  TABLE_LIST *tbl;\n  while ((tbl= it++))\n  {\n    if (tbl->nested_join)\n    {\n      mark_join_nest_as_const(join, tbl, found_const_table_map, const_count);\n      continue;\n    }\n    JOIN_TAB *tab= tbl->table->reginfo.join_tab;\n    if (!(join->const_table_map & tab->table->map))\n    {\n      tab->type= JT_CONST;\n      tab->info= ET_IMPOSSIBLE_ON_CONDITION;\n      tab->table->const_table= 1;\n      join->const_table_map|= tab->table->map;\n      *found_const_table_map|= tab->table->map;\n      set_position(join,(*const_count)++,tab,(KEYUSE*) 0);\n      mark_as_null_row(tab->table);\t\t\n    }\n  }\n}", "target": 0}
{"code": "void cgit_clone_head(void)\n{\n\tsend_file(git_path(\"%s\", \"HEAD\"));\n}", "target": 0}
