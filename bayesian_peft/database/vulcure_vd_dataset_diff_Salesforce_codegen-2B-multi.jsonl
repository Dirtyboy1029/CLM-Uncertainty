{"code": "static int er_supported(ERContext *s)\n{\n    if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||\n       !s->cur_pic.f                                                  ||\n       s->cur_pic.field_picture                                       ||\n       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO\n    )\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input()) {\n      if (input.empty())\n        return InvalidArgument(\"Node '\", node.name(), \"' has an empty input\");\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    }\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr type,\n                          ConvertAttribute(node.experimental_type(), builder));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return ::tensorflow::OkStatus();\n}", "target": 1}
{"code": "static int complete_emulated_mmio(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_run *run = vcpu->run;\n\tstruct kvm_mmio_fragment *frag;\n\tunsigned len;\n\tBUG_ON(!vcpu->mmio_needed);\n\tfrag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];\n\tlen = min(8u, frag->len);\n\tif (!vcpu->mmio_is_write)\n\t\tmemcpy(frag->data, run->mmio.data, len);\n\tif (frag->len <= 8) {\n\t\tfrag++;\n\t\tvcpu->mmio_cur_fragment++;\n\t} else {\n\t\tfrag->data += len;\n\t\tfrag->gpa += len;\n\t\tfrag->len -= len;\n\t}\n\tif (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {\n\t\tvcpu->mmio_needed = 0;\n\t\tif (vcpu->mmio_is_write)\n\t\t\treturn 1;\n\t\tvcpu->mmio_read_completed = 1;\n\t\treturn complete_emulated_io(vcpu);\n\t}\n\trun->exit_reason = KVM_EXIT_MMIO;\n\trun->mmio.phys_addr = frag->gpa;\n\tif (vcpu->mmio_is_write)\n\t\tmemcpy(run->mmio.data, frag->data, min(8u, frag->len));\n\trun->mmio.len = min(8u, frag->len);\n\trun->mmio.is_write = vcpu->mmio_is_write;\n\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\treturn 0;\n}", "target": 1}
{"code": "static struct sk_buff **ipip_gro_receive(struct sk_buff **head,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\treturn inet_gro_receive(head, skb);\n}", "target": 0}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCropThreshold(gdImagePtr im, const unsigned int color, const float threshold)\n{\n\tconst int width = gdImageSX(im);\n\tconst int height = gdImageSY(im);\n\tint x,y;\n\tint match;\n\tgdRect crop;\n\tcrop.x = 0;\n\tcrop.y = 0;\n\tcrop.width = 0;\n\tcrop.height = 0;\n\tif (threshold > 100.0) {\n\t\treturn NULL;\n\t}\n\tif (color < 0 || (!gdImageTrueColor(im) && color >= gdImageColorsTotal(im))) {\n\t\treturn NULL;\n\t}\n\tmatch = 1;\n\tfor (y = 0; match && y < height; y++) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == height - 1) {\n\t\treturn NULL;\n\t}\n\tcrop.y = y -1;\n\tmatch = 1;\n\tfor (y = height - 1; match && y >= 0; y--) {\n\t\tfor (x = 0; match && x < width; x++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x, y), threshold)) > 0;\n\t\t}\n\t}\n\tif (y == 0) {\n\t\tcrop.height = height - crop.y + 1;\n\t} else {\n\t\tcrop.height = y - crop.y + 2;\n\t}\n\tmatch = 1;\n\tfor (x = 0; match && x < width; x++) {\n\t\tfor (y = 0; match && y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.x = x - 1;\n\tmatch = 1;\n\tfor (x = width - 1; match && x >= 0; x--) {\n\t\tfor (y = 0; match &&  y < crop.y + crop.height - 1; y++) {\n\t\t\tmatch = (gdColorMatch(im, color, gdImageGetPixel(im, x,y), threshold)) > 0;\n\t\t}\n\t}\n\tcrop.width = x - crop.x + 2;\n\treturn gdImageCrop(im, &crop);\n}", "target": 0}
{"code": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}", "target": 1}
{"code": "errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n                            const char *input,\n                            char **sanitized)\n{\n    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n}", "target": 1}
{"code": "static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input,\n                           const TfLiteTensor* positions,\n                           TfLiteTensor* output) {\n  DynamicBuffer buffer;\n  const PositionT* indexes = GetTensorData<PositionT>(positions);\n  bool indices_has_only_positive_elements = true;\n  const size_t num_indices = positions->bytes / sizeof(PositionT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indexes[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  const PositionT num_strings = GetStringCount(input);\n  const int num_indexes = NumElements(positions);\n  for (int i = 0; i < num_indexes; ++i) {\n    const PositionT pos = indexes[i];\n    TF_LITE_ENSURE(context, pos < num_strings);\n    const auto string_ref = GetString(input, pos);\n    buffer.AddString(string_ref.str, string_ref.len);\n  }\n  buffer.WriteToTensor(output, nullptr);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static inline int event2keytype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELSA:\n\t\treturn SADB_DELETE;\n\tcase XFRM_MSG_NEWSA:\n\t\treturn SADB_ADD;\n\tcase XFRM_MSG_UPDSA:\n\t\treturn SADB_UPDATE;\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn SADB_EXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", event);\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline void arch_dup_mmap(struct mm_struct *oldmm,\n\t\t\t\t struct mm_struct *mm)\n{\n\tif (oldmm->context.asce_limit < mm->context.asce_limit)\n\t\tcrst_table_downgrade(mm, oldmm->context.asce_limit);\n}", "target": 1}
{"code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n\tif (nb_bits>=32) return 0;\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n\t\treturn ((Fixed)neg) / lsr->res_factor;\n\t} else {\n\t\treturn ((Fixed)val) / lsr->res_factor;\n\t}\n#endif\n}", "target": 0}
{"code": "static struct mnt_namespace *create_mnt_ns(struct vfsmount *m)\n{\n\tstruct mnt_namespace *new_ns = alloc_mnt_ns(&init_user_ns);\n\tif (!IS_ERR(new_ns)) {\n\t\tstruct mount *mnt = real_mount(m);\n\t\tmnt->mnt_ns = new_ns;\n\t\tnew_ns->root = mnt;\n\t\tnew_ns->mounts++;\n\t\tlist_add(&mnt->mnt_list, &new_ns->list);\n\t} else {\n\t\tmntput(m);\n\t}\n\treturn new_ns;\n}", "target": 0}
{"code": "bool DefaultCertValidator::matchSubjectAltName(\n    X509* cert,\n    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n        subject_alt_name_matchers) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return false;\n  }\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    const std::string san = Utility::generalNameAsString(general_name);\n    for (auto& config_san_matcher : subject_alt_name_matchers) {\n      if (general_name->type == GEN_DNS &&\n                  config_san_matcher.matcher().match_pattern_case() ==\n                      envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n              ? Utility::dnsNameMatch(config_san_matcher.matcher().exact(), absl::string_view(san))\n              : config_san_matcher.match(san)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}", "target": 1}
{"code": "ArgParser::parseServerArgs(ServerArgs& args, int argc, const char* const* argv)\n{\n    setArgsBase(args);\n    updateCommonArgs(argv);\n    for (int i = 1; i < argc; ++i) {\n        if (parsePlatformArg(args, argc, argv, i)) {\n            continue;\n        }\n        else if (parseGenericArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (parseDeprecatedArgs(argc, argv, i)) {\n            continue;\n        }\n        else if (isArg(i, argc, argv, \"-a\", \"--address\", 1)) {\n            args.m_barrierAddress = argv[++i];\n        }\n        else if (isArg(i, argc, argv, \"-c\", \"--config\", 1)) {\n            args.m_configFile = argv[++i];\n        }\n        else if (isArg(i, argc, argv, NULL, \"--screen-change-script\", 1)) {\n            args.m_screenChangeScript = argv[++i];\n        }\n        else {\n            LOG((CLOG_PRINT \"%s: unrecognized option `%s'\" BYE, args.m_exename.c_str(), argv[i], args.m_exename.c_str()));\n            return false;\n        }\n    }\n    if (checkUnexpectedArgs()) {\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "static int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\t\tmemset(up, 0, sizeof(*up));\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}", "target": 0}
{"code": "ldap_pvt_tls_init( void )\n{\n\treturn tls_init( tls_imp );\n}", "target": 0}
{"code": "static void *__dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  struct dma_attrs *attrs)\n{\n\tif (dev == NULL) {\n\t\tWARN_ONCE(1, \"Use an actual device structure for DMA allocation\\n\");\n\t\treturn NULL;\n\t}\n\tif (IS_ENABLED(CONFIG_ZONE_DMA) &&\n\t    dev->coherent_dma_mask <= DMA_BIT_MASK(32))\n\t\tflags |= GFP_DMA;\n\tif (IS_ENABLED(CONFIG_DMA_CMA) && (flags & __GFP_WAIT)) {\n\t\tstruct page *page;\n\t\tvoid *addr;\n\t\tsize = PAGE_ALIGN(size);\n\t\tpage = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,\n\t\t\t\t\t\t\tget_order(size));\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\t*dma_handle = phys_to_dma(dev, page_to_phys(page));\n\t\taddr = page_address(page);\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(addr, 0, size);\n\t\treturn addr;\n\t} else {\n\t\treturn swiotlb_alloc_coherent(dev, size, dma_handle, flags);\n\t}\n}", "target": 1}
{"code": "static void __lo_release(struct loop_device *lo)\n{\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 0}
{"code": "static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)\n{\n\tmemset(task, 0, sizeof(*task));\n\tatomic_set(&task->tk_count, 1);\n\ttask->tk_flags  = task_setup_data->flags;\n\ttask->tk_ops = task_setup_data->callback_ops;\n\ttask->tk_calldata = task_setup_data->callback_data;\n\tINIT_LIST_HEAD(&task->tk_task);\n\ttask->tk_garb_retry = 2;\n\ttask->tk_cred_retry = 2;\n\ttask->tk_rebind_retry = 2;\n\ttask->tk_priority = task_setup_data->priority - RPC_PRIORITY_LOW;\n\ttask->tk_owner = current->tgid;\n\ttask->tk_workqueue = task_setup_data->workqueue;\n\tif (task->tk_ops->rpc_call_prepare != NULL)\n\t\ttask->tk_action = rpc_prepare_task;\n\ttask->tk_start = ktime_get();\n\tdprintk(\"RPC:       new task initialized, procpid %u\\n\",\n\t\t\t\ttask_pid_nr(current));\n}", "target": 0}
{"code": "static int _dns_encode_HTTPS(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tchar target[DNS_MAX_CNAME_LEN] = {0};\n\tunsigned char *rr_len_ptr = NULL;\n\tunsigned char *start = NULL;\n\tunsigned char *rr_start = NULL;\n\tint ttl = 0;\n\tint priority = 0;\n\tstruct dns_https_param *param = NULL;\n\tparam = dns_get_HTTPS_svcparm_start(rrs, domain, DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);\n\tif (param == NULL) {\n\t\ttlog(TLOG_ERROR, \"get https param failed.\");\n\t\treturn -1;\n\t}\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, 0, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\trr_start = context->ptr;\n\tif (_dns_left_len(context) < 2) {\n\t\ttlog(TLOG_ERROR, \"left len is invalid.\");\n\t\treturn -1;\n\t}\n\t_dns_write_short(&context->ptr, priority);\n\tret = _dns_encode_domain(context, target);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\tstart = context->ptr;\n\tfor (; param != NULL; param = dns_get_HTTPS_svcparm_next(rrs, param)) {\n\t\tif (context->ptr - start > rrs->len || _dns_left_len(context) <= 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t_dns_write_short(&context->ptr, param->key);\n\t\t_dns_write_short(&context->ptr, param->len);\n\t\tswitch (param->key) {\n\t\tcase DNS_HTTPS_T_MANDATORY:\n\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN:\n\t\tcase DNS_HTTPS_T_ALPN:\n\t\tcase DNS_HTTPS_T_PORT:\n\t\tcase DNS_HTTPS_T_IPV4HINT:\n\t\tcase DNS_HTTPS_T_ECH:\n\t\tcase DNS_HTTPS_T_IPV6HINT: {\n\t\t\tmemcpy(context->ptr, param->value, param->len);\n\t\t\tcontext->ptr += param->len;\n\t\t} break;\n\t\tdefault:\n\t\t\tcontext->ptr -= 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\t_dns_write_short(&rr_len_ptr, context->ptr - rr_start);\n\treturn 0;\n}", "target": 1}
{"code": "lt_dlhandle_fetch (lt_dlinterface_id iface, const char *module_name)\n{\n  lt_dlhandle handle = 0;\n  assert (iface); \n  while ((handle = lt_dlhandle_iterate (iface, handle)))\n    {\n      lt_dlhandle cur = handle;\n      if (cur && cur->info.name && streq (cur->info.name, module_name))\n\tbreak;\n    }\n  return handle;\n}", "target": 0}
{"code": "struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)\n{\n\tstruct scm_fp_list *new_fpl;\n\tint i;\n\tif (!fpl)\n\t\treturn NULL;\n\tnew_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),\n\t\t\t  GFP_KERNEL);\n\tif (new_fpl) {\n\t\tfor (i = 0; i < fpl->count; i++)\n\t\t\tget_file(fpl->fp[i]);\n\t\tnew_fpl->max = new_fpl->count;\n\t\tnew_fpl->user = get_uid(fpl->user);\n\t}\n\treturn new_fpl;\n}", "target": 0}
{"code": "static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn 0;\n}", "target": 0}
{"code": "gvdb_table_write_contents_async (GHashTable          *table,\n                                 const gchar         *filename,\n                                 gboolean             byteswap,\n                                 GCancellable        *cancellable,\n                                 GAsyncReadyCallback  callback,\n                                 gpointer             user_data)\n{\n  struct gvdb_pointer root;\n  FileBuilder *fb;\n  WriteContentsData *data;\n  GString *str;\n  GBytes *bytes;\n  GFile *file;\n  GTask *task;\n  g_return_if_fail (table != NULL);\n  g_return_if_fail (filename != NULL);\n  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));\n  fb = file_builder_new (byteswap);\n  file_builder_add_hash (fb, table, &root);\n  str = file_builder_serialise (fb, root);\n  bytes = g_string_free_to_bytes (str);\n  file_builder_free (fb);\n  file = g_file_new_for_path (filename);\n  data = write_contents_data_new (bytes, file);\n  task = g_task_new (NULL, cancellable, callback, user_data);\n  g_task_set_task_data (task, data, (GDestroyNotify)write_contents_data_free);\n  g_task_set_source_tag (task, gvdb_table_write_contents_async);\n  g_file_replace_contents_async (file, str->str, str->len,\n                                 NULL, FALSE,\n                                 G_FILE_CREATE_PRIVATE | G_FILE_CREATE_REPLACE_DESTINATION,\n                                 cancellable, replace_contents_cb, g_steal_pointer (&task));\n  g_bytes_unref (bytes);\n  g_object_unref (file);\n}", "target": 1}
{"code": "DLLIMPORT unsigned int cfg_opt_size(cfg_opt_t *opt)\n{\n\tif (opt)\n\t\treturn opt->nvalues;\n\treturn 0;\n}", "target": 0}
{"code": "__attribute__((__always_inline__)) static inline int send_icmp4_too_big(\n    struct xdp_md* xdp) {\n  int headroom = (int)sizeof(struct iphdr) + (int)sizeof(struct icmphdr);\n  if (bpf_xdp_adjust_head(xdp, 0 - headroom)) {\n    return XDP_DROP;\n  }\n  void* data = (void*)(long)xdp->data;\n  void* data_end = (void*)(long)xdp->data_end;\n  if (data + (ICMP_TOOBIG_SIZE + headroom) > data_end) {\n    return XDP_DROP;\n  }\n  struct iphdr *iph, *orig_iph;\n  struct ethhdr* orig_eth;\n  struct icmphdr* icmp_hdr;\n  __u64 csum = 0;\n  __u64 off = 0;\n  orig_eth = data + headroom;\n  swap_mac(data, orig_eth);\n  off += sizeof(struct ethhdr);\n  iph = data + off;\n  off += sizeof(struct iphdr);\n  icmp_hdr = data + off;\n  off += sizeof(struct icmphdr);\n  orig_iph = data + off;\n  icmp_hdr->type = ICMP_DEST_UNREACH;\n  icmp_hdr->code = ICMP_FRAG_NEEDED;\n  icmp_hdr->un.frag.mtu = bpf_htons(MAX_PCKT_SIZE - sizeof(struct ethhdr));\n  icmp_hdr->un.frag.__unused = 0;\n  icmp_hdr->checksum = 0;\n  ipv4_csum(icmp_hdr, ICMP_TOOBIG_PAYLOAD_SIZE, &csum);\n  icmp_hdr->checksum = csum;\n  iph->ttl = DEFAULT_TTL;\n  iph->daddr = orig_iph->saddr;\n  iph->saddr = orig_iph->daddr;\n  iph->frag_off = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->protocol = IPPROTO_ICMP;\n  iph->tos = 0;\n  iph->tot_len = bpf_htons(ICMP_TOOBIG_SIZE + headroom - sizeof(struct ethhdr));\n  iph->id = 0;\n  iph->check = 0;\n  csum = 0;\n  ipv4_csum(iph, sizeof(struct iphdr), &csum);\n  iph->check = csum;\n  return XDP_TX;\n}", "target": 0}
{"code": "static av_cold int xpm_decode_close(AVCodecContext *avctx)\n{\n    XPMDecContext *x = avctx->priv_data;\n    av_freep(&x->pixels);\n    av_freep(&x->buf);\n    x->buf_size = 0;\n    return 0;\n}", "target": 0}
{"code": "int JOIN::optimize()\n{\n  int res= 0;\n  create_explain_query_if_not_exists(thd->lex, thd->mem_root);\n  join_optimization_state init_state= optimization_state;\n  if (select_lex->pushdown_select)\n  {\n    if (!(select_options & SELECT_DESCRIBE))\n    {\n      res= select_lex->pushdown_select->init();\n    }\n    with_two_phase_optimization= false;\n  }\n  else if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)\n    res= optimize_stage2();\n  else\n  {\n    if (optimization_state != JOIN::NOT_OPTIMIZED)\n      return FALSE;\n    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;\n    res= optimize_inner();\n  }\n  if (!with_two_phase_optimization ||\n      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)\n  {\n    if (!res && have_query_plan != QEP_DELETED)\n      res= build_explain();\n    optimization_state= JOIN::OPTIMIZATION_DONE;\n  }\n  return res;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* epsilon_t;\n    OP_REQUIRES_OK(context, context->input(kEpsilonName, &epsilon_t));\n    float epsilon = epsilon_t->scalar<float>()();\n    OP_REQUIRES(\n        context, epsilon > 0,\n        errors::InvalidArgument(\"An epsilon value of zero is not allowed.\"));\n    const Tensor* num_streams_t;\n    OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));\n    int64_t num_streams = num_streams_t->scalar<int64>()();\n    OP_REQUIRES(context, num_streams >= 0,\n                errors::InvalidArgument(\n                    \"Num_streams input cannot be a negative integer\"));\n    auto result =\n        new QuantileStreamResource(epsilon, max_elements_, num_streams);\n    auto status = CreateResource(context, HandleFromInput(context, 0), result);\n    if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES(context, false, status);\n    }\n  }", "target": 0}
{"code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n        tr_variantInitDict(&node->sorted, n);\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n        node->sorted.val.l.count = n;\n        tr_free(tmp);\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}", "target": 1}
{"code": "int rtnl_dump_request_n(struct rtnl_handle *rth, struct nlmsghdr *n)\n{\n\tstruct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };\n\tstruct iovec iov = {\n\t\t.iov_base = n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tn->nlmsg_flags = NLM_F_DUMP|NLM_F_REQUEST;\n\tn->nlmsg_pid = 0;\n\tn->nlmsg_seq = rth->dump = ++rth->seq;\n\treturn sendmsg(rth->fd, &msg, 0);\n}", "target": 0}
{"code": "TfLiteStatus PrepareSimple(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  const TfLiteTensor* axis = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, axis != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, axis->type, kTfLiteInt32);\n  if (input->type == kTfLiteInt8) {\n    OpData* data = static_cast<OpData*>(node->user_data);\n    const TfLiteTensor* output = GetOutput(context, node, 0);\n    const double real_multiplier = static_cast<double>(input->params.scale) /\n                                   static_cast<double>(output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->multiplier, &data->shift);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void FormatConverter<T>::InitSparseToDenseConverter(\n    std::vector<int> shape, std::vector<int> traversal_order,\n    std::vector<TfLiteDimensionType> format, std::vector<int> dense_size,\n    std::vector<std::vector<int>> segments,\n    std::vector<std::vector<int>> indices, std::vector<int> block_map) {\n  dense_shape_ = std::move(shape);\n  traversal_order_ = std::move(traversal_order);\n  block_map_ = std::move(block_map);\n  format_ = std::move(format);\n  dense_size_ = 1;\n  for (int i = 0; i < dense_shape_.size(); i++) {\n    dense_size_ *= dense_shape_[i];\n  }\n  dim_metadata_.resize(2 * format_.size());\n  for (int i = 0; i < format_.size(); i++) {\n    if (format_[i] == kTfLiteDimDense) {\n      dim_metadata_[2 * i] = {dense_size[i]};\n    } else {\n      dim_metadata_[2 * i] = std::move(segments[i]);\n      dim_metadata_[2 * i + 1] = std::move(indices[i]);\n    }\n  }\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}", "target": 1}
{"code": "absl::optional<CelValue> RequestWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Time) {\n    return CelValue::CreateTimestamp(absl::FromChrono(info_.startTime()));\n  } else if (value == Size) {\n    if (headers_.value_ != nullptr && headers_.value_->ContentLength() != nullptr) {\n      int64_t length;\n      if (absl::SimpleAtoi(headers_.value_->ContentLength()->value().getStringView(), &length)) {\n        return CelValue::CreateInt64(length);\n      }\n    } else {\n      return CelValue::CreateInt64(info_.bytesReceived());\n    }\n  } else if (value == Duration) {\n    auto duration = info_.requestComplete();\n    if (duration.has_value()) {\n      return CelValue::CreateDuration(absl::FromChrono(duration.value()));\n    }\n  }\n  if (headers_.value_ != nullptr) {\n    if (value == Path) {\n      return convertHeaderEntry(headers_.value_->Path());\n    } else if (value == UrlPath) {\n      absl::string_view path = headers_.value_->Path()->value().getStringView();\n      size_t query_offset = path.find('?');\n      if (query_offset == absl::string_view::npos) {\n        return CelValue::CreateString(path);\n      }\n      return CelValue::CreateString(path.substr(0, query_offset));\n    } else if (value == Host) {\n      return convertHeaderEntry(headers_.value_->Host());\n    } else if (value == Scheme) {\n      return convertHeaderEntry(headers_.value_->Scheme());\n    } else if (value == Method) {\n      return convertHeaderEntry(headers_.value_->Method());\n    } else if (value == Referer) {\n      return convertHeaderEntry(headers_.value_->Referer());\n    } else if (value == ID) {\n      return convertHeaderEntry(headers_.value_->RequestId());\n    } else if (value == UserAgent) {\n      return convertHeaderEntry(headers_.value_->UserAgent());\n    } else if (value == TotalSize) {\n      return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize());\n    }\n  }\n  return {};\n}", "target": 1}
{"code": "  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }", "target": 0}
{"code": "raptor_libxml_resolveEntity(void* user_data, \n                            const xmlChar *publicId, const xmlChar *systemId) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_resolveEntity(sax2->xc, publicId, systemId);\n}", "target": 1}
{"code": "static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)\n{\n\tswitch (mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (l2cap_mode_supported(mode, remote_feat_mask))\n\t\t\treturn mode;\n\tdefault:\n\t\treturn L2CAP_MODE_BASIC;\n\t}\n}", "target": 0}
{"code": "static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n{\n    size_t realsize = 0;\n    connection_t *conn = NULL;\n    char *ptr = NULL;\n    conn = data;\n    ogs_assert(conn);\n    realsize = size * nmemb;\n    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n    if(!ptr) {\n        ogs_fatal(\"not enough memory (realloc returned NULL)\");\n        ogs_assert_if_reached();\n        return 0;\n    }\n    conn->memory = ptr;\n    memcpy(&(conn->memory[conn->size]), contents, realsize);\n    conn->size += realsize;\n    conn->memory[conn->size] = 0;\n    return realsize;\n}", "target": 1}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\nout:\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "int tls_free_buffers(OSSL_RECORD_LAYER *rl)\n{\n    if (rl->direction == OSSL_RECORD_DIRECTION_WRITE) {\n        if (rl->nextwbuf < rl->numwpipes) {\n            if (rl->nextwbuf != 0\n                    || rl->numwpipes != 1\n                    || TLS_BUFFER_get_left(&rl->wbuf[0]) != 0)\n                return 0;\n        }\n        tls_release_write_buffer(rl);\n        return 1;\n    }\n    if (rl->curr_rec < rl->num_recs || TLS_BUFFER_get_left(&rl->rbuf) != 0)\n        return 0;\n    return tls_release_read_buffer(rl);\n}", "target": 1}
{"code": "internalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n  entity = openEntity->entity;\n  textStart = ((char *)entity->textPtr) + entity->processed;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE);\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (char *)entity->textPtr);\n    return result;\n  } else {\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  } else\n#endif \n  {\n    parser->m_processor = contentProcessor;\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  }\n}", "target": 1}
{"code": "nfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n                 int flags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct nfs4_state *state;\n\tstruct rpc_cred *cred;\n\tint status = 0;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred)) {\n\t\tstatus = PTR_ERR(cred);\n\t\tgoto out;\n\t}\n\tstate = nfs4_do_open(dir, &path, flags, sattr, cred);\n\td_drop(dentry);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out_putcred;\n\t}\n\td_add(dentry, igrab(state->inode));\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tif (flags & O_EXCL) {\n\t\tstruct nfs_fattr fattr;\n\t\tstatus = nfs4_do_setattr(state->inode, cred, &fattr, sattr, state);\n\t\tif (status == 0)\n\t\t\tnfs_setattr_update_inode(state->inode, sattr);\n\t\tnfs_post_op_update_inode(state->inode, &fattr);\n\t}\n\tif (status == 0 && (nd->flags & LOOKUP_OPEN) != 0)\n\t\tstatus = nfs4_intent_set_file(nd, &path, state);\n\telse\n\t\tnfs4_close_sync(&path, state, flags);\nout_putcred:\n\tput_rpccred(cred);\nout:\n\treturn status;\n}", "target": 1}
{"code": "static int pcd_detect(void)\n{\n\tchar id[18];\n\tint k, unit;\n\tstruct pcd_unit *cd;\n\tprintk(\"%s: %s version %s, major %d, nice %d\\n\",\n\t       name, name, PCD_VERSION, major, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pcd_drive_count == 0) { \n\t\tcd = pcd;\n\t\tif (pi_init(cd->pi, 1, -1, -1, -1, -1, -1, pcd_buffer,\n\t\t\t    PI_PCD, verbose, cd->name)) {\n\t\t\tif (!pcd_probe(cd, -1, id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t} else {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (!pi_init(cd->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t     conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t     pcd_buffer, PI_PCD, verbose, cd->name)) \n\t\t\t\tcontinue;\n\t\t\tif (!pcd_probe(cd, conf[D_SLV], id) && cd->disk) {\n\t\t\t\tcd->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(cd->pi);\n\t\t}\n\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No CD-ROM drive found\\n\", name);\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (!cd->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(cd->disk->queue);\n\t\tcd->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\tput_disk(cd->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}", "target": 1}
{"code": "static void read_version(struct pbap_data *pbap, GObexApparam *apparam)\n{\n\tconst guint8 *data;\n\tuint8_t value[16];\n\tgsize len;\n\tif (!(pbap->supported_features & FOLDER_VERSION_FEATURE))\n\t\treturn;\n\tif (!g_obex_apparam_get_bytes(apparam, PRIMARY_COUNTER_TAG, &data,\n\t\t\t\t\t\t\t\t&len)) {\n\t\tlen = sizeof(value);\n\t\tmemset(value, 0, len);\n\t\tdata = value;\n\t}\n\tif (memcmp(pbap->primary, data, len)) {\n\t\tmemcpy(pbap->primary, data, len);\n\t\tg_dbus_emit_property_changed(conn,\n\t\t\t\t\tobc_session_get_path(pbap->session),\n\t\t\t\t\tPBAP_INTERFACE, \"PrimaryCounter\");\n\t}\n\tif (!g_obex_apparam_get_bytes(apparam, SECONDARY_COUNTER_TAG, &data,\n\t\t\t\t\t\t\t\t&len)) {\n\t\tlen = sizeof(value);\n\t\tmemset(value, 0, len);\n\t\tdata = value;\n\t}\n\tif (memcmp(pbap->secondary, data, len)) {\n\t\tmemcpy(pbap->secondary, data, len);\n\t\tg_dbus_emit_property_changed(conn,\n\t\t\t\t\tobc_session_get_path(pbap->session),\n\t\t\t\t\tPBAP_INTERFACE, \"SecondaryCounter\");\n\t}\n}", "target": 1}
{"code": "bool CmdExtract::ExtrCreateFile(Archive &Arc,File &CurFile)\n{\n  bool Success=true;\n  wchar Command=Cmd->Command[0];\n#if !defined(SFX_MODULE)\n  if (Command=='P')\n    CurFile.SetHandleType(FILE_HANDLESTD);\n#endif\n  if ((Command=='E' || Command=='X') && !Cmd->Test)\n  {\n    bool UserReject;\n    if (!FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n    {\n      Success=false;\n      if (!UserReject)\n      {\n        ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        if (FileExist(DestFileName) && IsDir(GetFileAttr(DestFileName)))\n          uiMsg(UIERROR_DIRNAMEEXISTS);\n#ifdef RARDLL\n        Cmd->DllError=ERAR_ECREATE;\n#endif\n        if (!IsNameUsable(DestFileName))\n        {\n          uiMsg(UIMSG_CORRECTINGNAME,Arc.FileName);\n          wchar OrigName[ASIZE(DestFileName)];\n          wcsncpyz(OrigName,DestFileName,ASIZE(OrigName));\n          MakeNameUsable(DestFileName,true);\n          if (!Cmd->AbsoluteLinks && UpLinkExtracted)\n            LinksToDirs(DestFileName,Cmd->ExtrPath,LastCheckedSymlink);\n          CreatePath(DestFileName,true,Cmd->DisableNames);\n          if (FileCreate(Cmd,&CurFile,DestFileName,ASIZE(DestFileName),&UserReject,Arc.FileHead.UnpSize,&Arc.FileHead.mtime,true))\n          {\n#ifndef SFX_MODULE\n            uiMsg(UIERROR_RENAMING,Arc.FileName,OrigName,DestFileName);\n#endif\n            Success=true;\n          }\n          else\n            ErrHandler.CreateErrorMsg(Arc.FileName,DestFileName);\n        }\n      }\n    }\n  }\n  return Success;\n}", "target": 0}
{"code": "usage (void)\n{\n  g_print (\"%s\\n\", _(\"Usage: exo-open [URLs...]\"));\n  g_print (\"%s\\n\", _(\"       exo-open --launch TYPE [PARAMETERs...]\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  -?, --help                          Print this help message and exit\"));\n  g_print (\"%s\\n\", _(\"  -V, --version                       Print version information and exit\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  --launch TYPE [PARAMETERs...]       Launch the preferred application of\\n\"\n                     \"                                      TYPE with the optional PARAMETERs, where\\n\"\n                     \"                                      TYPE is one of the following values.\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  --working-directory DIRECTORY       Default working directory for applications\\n\"\n                     \"                                      when using the --launch option.\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"The following TYPEs are supported for the --launch command:\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  WebBrowser       - The preferred Web Browser.\\n\"\n                     \"  MailReader       - The preferred Mail Reader.\\n\"\n                     \"  FileManager      - The preferred File Manager.\\n\"\n                     \"  TerminalEmulator - The preferred Terminal Emulator.\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"If you don't specify the --launch option, exo-open will open all specified\\n\"\n                     \"URLs with their preferred URL handlers. Else, if you specify the --launch\\n\"\n                     \"option, you can select which preferred application you want to run, and\\n\"\n                     \"pass additional parameters to the application (i.e. for TerminalEmulator\\n\"\n                     \"you can pass the command line that should be run in the terminal).\"));\n  g_print (\"\\n\");\n}", "target": 0}
{"code": "uipbuf_add_ext_hdr(int16_t len)\n{\n  if(len + uip_len <= UIP_LINK_MTU && len + uip_len >= 0 && len + uip_ext_len >= 0) {\n    uip_ext_len += len;\n    uip_len += len;\n    return true;\n  } else {\n    return false;\n  }\n}", "target": 0}
{"code": "static inline void nft_reg_store64(u32 *dreg, u64 val)\n{\n\tput_unaligned(val, (u64 *)dreg);\n}", "target": 1}
{"code": "njs_json_parse_iterator_call(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_json_state_t *state)\n{\n    njs_int_t          ret;\n    njs_value_t        arguments[3], *value;\n    njs_object_prop_t  *prop;\n    prop = state->prop;\n    arguments[0] = state->value;\n    arguments[1] = state->keys->start[state->index++];\n    switch (prop->type) {\n    case NJS_PROPERTY:\n        arguments[2] = prop->value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            prop->type = NJS_WHITEOUT;\n        } else {\n            prop->value = parse->retval;\n        }\n        break;\n    case NJS_PROPERTY_REF:\n        value = prop->value.data.u.value;\n        arguments[2] = *value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            ret = njs_value_property_i64_delete(vm, &state->value,\n                                                state->index - 1, NULL);\n        } else {\n            ret = njs_value_property_i64_set(vm, &state->value,\n                                             state->index - 1, &parse->retval);\n        }\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NJS_ERROR;\n        }\n        break;\n    default:\n        njs_internal_error(vm, \"njs_json_parse_iterator_call() unexpected \"\n                         \"property type:%s\", njs_prop_type_string(prop->type));\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "TRIO_PRIVATE void TrioWriteString TRIO_ARGS5((self, string, flags, width, precision),\n                                             trio_class_t* self, TRIO_CONST char* string,\n                                             trio_flags_t flags, int width, int precision)\n{\n\tint length;\n\tint ch;\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\tif (string == NULL)\n\t{\n\t\tstring = internalNullString;\n\t\tlength = sizeof(internalNullString) - 1;\n#if TRIO_FEATURE_QUOTE\n\t\tflags &= (~FLAGS_QUOTE);\n#endif\n\t\twidth = 0;\n\t}\n\telse\n\t{\n\t\tif (precision == 0)\n\t\t{\n\t\t\tlength = trio_length(string);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlength = trio_length_max(string, precision);\n\t\t}\n\t}\n\tif ((NO_PRECISION != precision) && (precision < length))\n\t{\n\t\tlength = precision;\n\t}\n\twidth -= length;\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n\tif (!(flags & FLAGS_LEFTADJUST))\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\twhile (length-- > 0)\n\t{\n\t\tch = (int)((unsigned char)(*string++));\n\t\tTrioWriteStringCharacter(self, ch, flags);\n\t}\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n}", "target": 1}
{"code": "int test_sqr(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,c,d,e;\n\tint i;\n\tBN_init(&a);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(&a,40+i*10,0,0);\n\t\ta.neg=rand_neg();\n\t\tBN_sqr(&c,&a,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(&d,&e,&c,&a,ctx);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n\t\t    {\n\t\t    fprintf(stderr,\"Square test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\treturn(1);\n\t}", "target": 1}
{"code": "void CScreencopyPortal::queueNextShareFrame(CScreencopyPortal::SSession* pSession) {\n    const auto PSTREAM = m_pPipewire->streamFromSession(pSession);\n    if (PSTREAM && !PSTREAM->streamState)\n        return;\n    const auto FRAMETOOKMS           = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - pSession->sharingData.begunFrame).count() / 1000.0;\n    const auto MSTILNEXTREFRESH      = 1000.0 / (pSession->sharingData.framerate) - FRAMETOOKMS;\n    pSession->sharingData.begunFrame = std::chrono::system_clock::now();\n    Debug::log(TRACE, \"[screencopy] set fps {}, frame took {:.2f}ms, ms till next refresh {:.2f}, estimated actual fps: {:.2f}\", pSession->sharingData.framerate, FRAMETOOKMS,\n               MSTILNEXTREFRESH, std::clamp(1000.0 / FRAMETOOKMS, 1.0, (double)pSession->sharingData.framerate));\n    g_pPortalManager->addTimer({std::clamp(MSTILNEXTREFRESH - 1.0 , 6.0, 1000.0), [pSession]() { g_pPortalManager->m_sPortals.screencopy->startFrameCopy(pSession); }});\n}", "target": 1}
{"code": "PHP_FUNCTION(radius_get_vendor_attr)\n{\n\tint res;\n\tconst void *data;\n\tint len;\n\tu_int32_t vendor;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "static struct mnt_namespace *alloc_mnt_ns(struct user_namespace *user_ns)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct ucounts *ucounts;\n\tint ret;\n\tucounts = inc_mnt_namespaces(user_ns);\n\tif (!ucounts)\n\t\treturn ERR_PTR(-ENOSPC);\n\tnew_ns = kmalloc(sizeof(struct mnt_namespace), GFP_KERNEL);\n\tif (!new_ns) {\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tret = ns_alloc_inum(&new_ns->ns);\n\tif (ret) {\n\t\tkfree(new_ns);\n\t\tdec_mnt_namespaces(ucounts);\n\t\treturn ERR_PTR(ret);\n\t}\n\tnew_ns->ns.ops = &mntns_operations;\n\tnew_ns->seq = atomic64_add_return(1, &mnt_ns_seq);\n\tatomic_set(&new_ns->count, 1);\n\tnew_ns->root = NULL;\n\tINIT_LIST_HEAD(&new_ns->list);\n\tinit_waitqueue_head(&new_ns->poll);\n\tnew_ns->event = 0;\n\tnew_ns->user_ns = get_user_ns(user_ns);\n\tnew_ns->ucounts = ucounts;\n\tnew_ns->mounts = 0;\n\tnew_ns->pending_mounts = 0;\n\treturn new_ns;\n}", "target": 0}
{"code": "TEE_Result syscall_cipher_init(unsigned long state, const void *iv,\n\t\t\tsize_t iv_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key1;\n\tstruct user_ta_ctx *utc;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tutc = to_user_ta_ctx(sess->ctx);\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_CIPHER)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tres = tee_mmu_check_access_rights(utc,\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) iv, iv_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(utc, cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tkey1 = o->attr;\n\tif (tee_obj_get(utc, cs->key2, &o) == TEE_SUCCESS) {\n\t\tstruct tee_cryp_obj_secret *key2 = o->attr;\n\t\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t (uint8_t *)(key2 + 1), key2->key_size,\n\t\t\t\t\t iv, iv_len);\n\t} else {\n\t\tres = crypto_cipher_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\t (uint8_t *)(key1 + 1), key1->key_size,\n\t\t\t\t\t NULL, 0, iv, iv_len);\n\t}\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcs->ctx_finalize = crypto_cipher_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "R_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n\tif (!s) {\n\t\treturn -1;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\tif (s->bio) {\n\t\t\treturn BIO_read (s->bio, buf, len);\n\t\t}\n\t\treturn SSL_read (s->sfd, buf, len);\n\t}\n#endif\n#if __WINDOWS__\nrep:\n\t{\n\tint ret = recv (s->fd, (void *)buf, len, 0);\n\tif (ret == -1) {\n\t\tgoto rep;\n\t}\n\treturn ret;\n\t}\n#else\n\tint r = recv (s->fd, buf, len, 0);\n\tD { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }\n\treturn r;\n#endif\n}", "target": 1}
{"code": "bool ArcMemory::Seek(int64 Offset,int Method)\n{\n  if (!Loaded)\n    return false;\n  if (Method==SEEK_SET)\n    SeekPos=Min(Offset,ArcData.Size());\n  else\n    if (Method==SEEK_CUR || Method==SEEK_END)\n    {\n      if (Method==SEEK_END)\n        SeekPos=ArcData.Size();\n      SeekPos+=(uint64)Offset;\n      if (SeekPos>ArcData.Size())\n        SeekPos=Offset<0 ? 0 : ArcData.Size();\n    }\n  return true;\n}", "target": 0}
{"code": "void LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            delete receivedPacket;\n            continue;\n        }\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n        if (tcpPort < MIN_TCP_PORT || tcpPort > MAX_TCP_PORT) {\n            qCDebug(KDECONNECT_CORE) << \"TCP port outside of kdeconnect's range\";\n            delete receivedPacket;\n            continue;\n        }\n        if (m_receivedIdentityPackets.size() > MAX_REMEMBERED_IDENTITY_PACKETS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many remembered identities, ignoring\" << receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) << \"received via UDP\";\n            delete receivedPacket;\n            continue;\n        }\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}", "target": 0}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "EXPORTED int examine_request(struct transaction_t *txn, const char *uri)\n{\n    int ret = 0, sasl_result = 0;\n    const char *query;\n    const struct namespace_t *namespace;\n    struct request_line_t *req_line = &txn->req_line;\n    if (!uri) uri = req_line->uri;\n    if ((ret = check_method(txn))) return ret;\n    if (!(txn->req_uri = parse_uri(txn->meth, uri, 1, &txn->error.desc))) {\n        return HTTP_BAD_REQUEST;\n    }\n    if ((ret = preauth_check_hdrs(txn))) return ret;\n    if ((ret = check_namespace(txn))) return ret;\n    ret = auth_check_hdrs(txn, &sasl_result);\n    if (ret && ret != HTTP_UNAUTHORIZED) return ret;\n    namespace = txn->req_tgt.namespace;\n    buf_printf(&txn->buf, \"%s%s\", config_ident,\n               namespace->well_known ? strrchr(namespace->well_known, '/') :\n               namespace->prefix);\n    proc_register(buf_cstring(&txn->buf), txn->conn->clienthost, httpd_userid,\n                  txn->req_tgt.path, txn->req_line.meth);\n    buf_reset(&txn->buf);\n    if (!httpd_userid && namespace->need_auth(txn)) {\n        ret = HTTP_UNAUTHORIZED;\n    }\n    if (ret) return client_need_auth(txn, sasl_result);\n    construct_hash_table(&txn->req_qparams, 10, 1);\n    query = URI_QUERY(txn->req_uri);\n    if (query) parse_query_params(txn, query);\n    postauth_check_hdrs(txn);\n    return 0;\n}", "target": 0}
{"code": "static int dir_contains_only_dotgit(const char *path)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *e;\n\tint ret = 1;\n\tif (!dir)\n\t\treturn 0;\n\te = readdir_skip_dot_and_dotdot(dir);\n\tif (!e)\n\t\tret = 0;\n\telse if (strcmp(DEFAULT_GIT_DIR_ENVIRONMENT, e->d_name) ||\n\t\t (e = readdir_skip_dot_and_dotdot(dir))) {\n\t\terror(\"unexpected item '%s' in '%s'\", e->d_name, path);\n\t\tret = 0;\n\t}\n\tclosedir(dir);\n\treturn ret;\n}", "target": 0}
{"code": "hphp_libxml_input_buffer_noload(const char *URI, xmlCharEncoding enc) {\n  return nullptr;\n}", "target": 1}
{"code": "  QInt16() {}", "target": 1}
{"code": "fr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\treturn capabilities;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, 1, output->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, 1, input->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, 1, input->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, 1, output->dims->data[2]);\n  TF_LITE_ENSURE_EQ(context, 1, input->dims->data[2]);\n  TF_LITE_ENSURE_EQ(context, output->dims->data[3], input->dims->data[3]);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteInt8);\n  TFLITE_DCHECK_LE(op_data_counter, kMaxOpDataSize);\n  OpData* op_data = &op_data_array[op_data_counter++];\n  if (output->dims->data[1] == 5) {\n    op_data->cycles_max = 1;\n  } else {\n    op_data->cycles_max = 2;\n  }\n  op_data->cycles_until_run = op_data->cycles_max;\n  node->user_data = op_data;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n}", "target": 0}
{"code": "void log_flush(LOG_MODE new_mode) {\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_MODE]);\n    if(log_mode!=LOG_MODE_CONFIGURED || new_mode!=LOG_MODE_ERROR)\n        log_mode=new_mode;\n    if(new_mode!=LOG_MODE_BUFFER) {\n        CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_BUFFER]);\n        while(head) {\n            struct LIST *tmp=head;\n            head=head->next;\n            log_raw(tmp->opt, tmp->level, tmp->stamp, tmp->id, tmp->text);\n            str_free(tmp);\n        }\n        head=tail=NULL;\n        CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_BUFFER]);\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_MODE]);\n}", "target": 1}
{"code": "static void vc_uniscr_insert(struct vc_data *vc, unsigned int nr)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr) {\n\t\tchar32_t *ln = uniscr->lines[vc->vc_y];\n\t\tunsigned int x = vc->vc_x, cols = vc->vc_cols;\n\t\tmemmove(&ln[x + nr], &ln[x], (cols - x - nr) * sizeof(*ln));\n\t\tmemset32(&ln[x], ' ', nr);\n\t}\n}", "target": 0}
{"code": "bool allowed_new_user_problem_entry(uid_t uid, const char *name, const char *value)\n{\n    if (uid == 0)\n        return true;\n    if (strcmp(name, FILENAME_ANALYZER) != 0\n     && strcmp(name, FILENAME_TYPE) != 0\n     && strcmp(name, \"basename\") != 0)\n        return true;\n     if (strcmp(value, \"CCpp\") != 0\n      && strcmp(value, \"Kerneloops\") != 0\n      && strcmp(value, \"vmcore\") != 0\n      && strcmp(value, \"xorg\") != 0)\n        return true;\n    error_msg(\"Only root is permitted to create element '%s' containing '%s'\", name, value);\n    return false;\n}", "target": 0}
{"code": "static int sock_close(struct inode *inode, struct file *filp)\n{\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}", "target": 1}
{"code": "bool RenderViewImpl::isPointerLocked() {\n  return mouse_lock_dispatcher_->IsMouseLockedTo(\n      webwidget_mouse_lock_target_.get());\n }", "target": 0}
{"code": "struct torture_suite *torture_winbind_struct_init(TALLOC_CTX *ctx)\n{\n\tstruct torture_suite *suite = torture_suite_create(ctx, \"struct\");\n\ttorture_suite_add_simple_test(suite, \"interface_version\", torture_winbind_struct_interface_version);\n\ttorture_suite_add_simple_test(suite, \"ping\", torture_winbind_struct_ping);\n\ttorture_suite_add_simple_test(suite, \"info\", torture_winbind_struct_info);\n\ttorture_suite_add_simple_test(suite, \"priv_pipe_dir\", torture_winbind_struct_priv_pipe_dir);\n\ttorture_suite_add_simple_test(suite, \"netbios_name\", torture_winbind_struct_netbios_name);\n\ttorture_suite_add_simple_test(suite, \"domain_name\", torture_winbind_struct_domain_name);\n\ttorture_suite_add_simple_test(suite, \"check_machacc\", torture_winbind_struct_check_machacc);\n\ttorture_suite_add_simple_test(suite, \"list_trustdom\", torture_winbind_struct_list_trustdom);\n\ttorture_suite_add_simple_test(suite, \"domain_info\", torture_winbind_struct_domain_info);\n\ttorture_suite_add_simple_test(suite, \"getdcname\", torture_winbind_struct_getdcname);\n\ttorture_suite_add_simple_test(suite, \"dsgetdcname\", torture_winbind_struct_dsgetdcname);\n\ttorture_suite_add_simple_test(suite, \"list_users\", torture_winbind_struct_list_users);\n\ttorture_suite_add_simple_test(suite, \"list_groups\", torture_winbind_struct_list_groups);\n\ttorture_suite_add_simple_test(suite, \"show_sequence\", torture_winbind_struct_show_sequence);\n\ttorture_suite_add_simple_test(suite, \"setpwent\", torture_winbind_struct_setpwent);\n\ttorture_suite_add_simple_test(suite, \"getpwent\", torture_winbind_struct_getpwent);\n\ttorture_suite_add_simple_test(suite, \"endpwent\", torture_winbind_struct_endpwent);\n\ttorture_suite_add_simple_test(suite, \"lookup_name_sid\", torture_winbind_struct_lookup_name_sid);\n\ttorture_suite_add_simple_test(\n\t\tsuite,\n\t\t\"lookup_sids_invalid\",\n\t\ttorture_winbind_struct_lookup_sids_invalid);\n\tsuite->description = talloc_strdup(suite, \"WINBIND - struct based protocol tests\");\n\treturn suite;\n}", "target": 0}
{"code": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        sshu->session = NULL;\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n    lua_settop(L, 3);\n    return 1;\n}", "target": 0}
{"code": "static void *HTPStateGetTx(void *alstate, uint64_t tx_id)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL)\n        return htp_list_get(http_state->conn->transactions, tx_id);\n    else\n        return NULL;\n}", "target": 1}
{"code": "BigInt EC_Group::square_mod_order(const BigInt& x) const\n   {\n   return data().square_mod_order(x);\n   }", "target": 0}
{"code": "int migrate_task_to(struct task_struct *p, int target_cpu)\n{\n\tstruct migration_arg arg = { p, target_cpu };\n\tint curr_cpu = task_cpu(p);\n\tif (curr_cpu == target_cpu)\n\t\treturn 0;\n\tif (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p)))\n\t\treturn -EINVAL;\n\ttrace_sched_move_numa(p, curr_cpu, target_cpu);\n\treturn stop_one_cpu(curr_cpu, migration_cpu_stop, &arg);\n}", "target": 0}
{"code": "nautilus_file_mark_desktop_file_trusted (GFile              *file,\n                                         GtkWindow          *parent_window,\n                                         gboolean            interactive,\n                                         NautilusOpCallback  done_callback,\n                                         gpointer            done_callback_data)\n{\n    GTask *task;\n    MarkTrustedJob *job;\n    job = op_job_new (MarkTrustedJob, parent_window);\n    job->file = g_object_ref (file);\n    job->interactive = interactive;\n    job->done_callback = done_callback;\n    job->done_callback_data = done_callback_data;\n    task = g_task_new (NULL, NULL, mark_trusted_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, mark_trusted_task_thread_func);\n    g_object_unref (task);\n}", "target": 1}
{"code": "format_fractional_part_nsecs(gchar *buf, size_t buflen, guint32 nsecs, const char *decimal_point, int precision)\n{\n\tgsize decimal_point_len;\n\tgint8 num_buf[CHARS_NANOSECONDS];\n\tgint8 *num_end = &num_buf[CHARS_NANOSECONDS];\n\tgint8 *num_ptr;\n\tsize_t num_len;\n\tws_assert(precision != 0);\n\tif (buflen == 0) {\n\t\treturn;\n\t}\n\tdecimal_point_len = g_strlcpy(buf, decimal_point, buflen);\n\tif (decimal_point_len >= buflen) {\n\t\treturn;\n\t}\n\tbuf += decimal_point_len;\n\tbuflen -= decimal_point_len;\n\tswitch (precision) {\n\tcase 1:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100000000, precision);\n\t\tbreak;\n\tcase 2:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10000000, precision);\n\t\tbreak;\n\tcase 3:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 1000000, precision);\n\t\tbreak;\n\tcase 4:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100000, precision);\n\t\tbreak;\n\tcase 5:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10000, precision);\n\t\tbreak;\n\tcase 6:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 1000, precision);\n\t\tbreak;\n\tcase 7:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100, precision);\n\t\tbreak;\n\tcase 8:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10, precision);\n\t\tbreak;\n\tcase 9:\n\t\tnum_ptr = uint_to_str_back_len(num_end, nsecs,\n\t\t    precision);\n\t\tbreak;\n\tdefault:\n\t\tws_assert_not_reached();\n\t\tbreak;\n\t}\n\tnum_len = MIN((size_t)(num_end - num_ptr), buflen - 1);\n\tif (num_len == 0) {\n\t\treturn;\n\t}\n\tmemcpy(buf, num_ptr, num_len);\n\t*(buf + num_len) = '\\0';\n}", "target": 1}
{"code": "static TEE_Result do_alloc_publickey(struct rsa_public_key *s,\n\t\t\t\t     size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n)) {\n\t\tcrypto_bignum_free(s->e);\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "static void fuse_lib_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n    struct fuse *f = req_fuse_prepare(req);\n    int res;\n    if (size) {\n        char *list = (char *) malloc(size);\n        if (list == NULL) {\n            reply_err(req, -ENOMEM);\n            return;\n        }\n        res = common_listxattr(f, req, ino, list, size);\n        if (res > 0)\n            fuse_reply_buf(req, list, res);\n        else\n            reply_err(req, res);\n        free(list);\n    } else {\n        res = common_listxattr(f, req, ino, NULL, 0);\n        if (res >= 0)\n            fuse_reply_xattr(req, res);\n        else\n            reply_err(req, res);\n    }\n}", "target": 0}
{"code": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n    emit newLogPeer(temp);\n}", "target": 1}
{"code": "static void cmd_sdbk(Sdb *db, const char *input) {\n\tchar *out = (input[0] == ' ')\n\t\t? sdb_querys (db, NULL, 0, input + 1)\n\t\t: sdb_querys (db, NULL, 0, \"*\");\n\tif (out) {\n\t\tr_cons_println (out);\n\t\tfree (out);\n\t} else {\n\t\tR_LOG_ERROR (\"Usage: ask [query]\");\n\t}\n}", "target": 1}
{"code": "luks_unlock_start_waiting_for_cleartext_device (UnlockEncryptionData *data)\n{\n  Device *cleartext_device;\n  cleartext_device = find_cleartext_device (data->device);\n  if (cleartext_device != NULL)\n    {\n      update_info (data->device);\n      drain_pending_changes (data->device, FALSE);\n      if (data->hook_func != NULL)\n        {\n          data->hook_func (data->context, cleartext_device, data->hook_user_data);\n        }\n      else\n        {\n          dbus_g_method_return (data->context, cleartext_device->priv->object_path);\n        }\n      unlock_encryption_data_unref (data);\n    }\n  else\n    {\n      data->device_added_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                     \"device-added\",\n                                                                     (GCallback) luks_unlock_device_added_cb,\n                                                                     data);\n      data->device_changed_signal_handler_id = g_signal_connect_after (data->device->priv->daemon,\n                                                                       \"device-changed\",\n                                                                       (GCallback) luks_unlock_device_added_cb,\n                                                                       data);\n      data->device_added_timeout_id = g_timeout_add (15 * 1000, luks_unlock_device_not_seen_cb, data);\n    }\n}", "target": 0}
{"code": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc;\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlRelaxNGParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "void ext4_es_remove_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t   ext4_lblk_t len)\n{\n\text4_lblk_t end;\n\tint err = 0;\n\tint reserved = 0;\n\tstruct extent_status *es = NULL;\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\ttrace_ext4_es_remove_extent(inode, lblk, len);\n\tes_debug(\"remove [%u/%u) from extent status tree of inode %lu\\n\",\n\t\t lblk, len, inode->i_ino);\n\tif (!len)\n\t\treturn;\n\tend = lblk + len - 1;\n\tBUG_ON(end < lblk);\nretry:\n\tif (err && !es)\n\t\tes = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, &reserved, es);\n\tif (es && !es->es_len)\n\t\t__es_free_extent(es);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err)\n\t\tgoto retry;\n\text4_es_print_tree(inode);\n\text4_da_release_space(inode, reserved);\n\treturn;\n}", "target": 1}
{"code": "static int mov_write_vpcc_tag(AVFormatContext *s, AVIOContext *pb, MOVTrack *track)\n{\n    int64_t pos = avio_tell(pb);\n    avio_wb32(pb, 0);\n    ffio_wfourcc(pb, \"vpcC\");\n    avio_wb32(pb, 0); \n    ff_isom_write_vpcc(s, pb, track->par);\n    return update_size(pb, pos);\n}", "target": 0}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n        if (parents)\n                mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY, mode > 0 ? mode : 0644);\n        if (fd < 0)\n                return -errno;\n        if (mode > 0) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "inline typename V::VariantType FBUnserializer<V>::unserialize(\n  folly::StringPiece serialized) {\n  FBUnserializer<V> unserializer(serialized);\n  return unserializer.unserializeThing();\n}", "target": 1}
{"code": "EncryptingStream::Create(const AP4_UI08* key, const AP4_UI08* iv, AP4_ByteStream* output, EncryptingStream*& stream) {\n    stream = NULL;\n    AP4_BlockCipher* block_cipher = NULL;\n    AP4_Result result = AP4_DefaultBlockCipherFactory::Instance.CreateCipher(AP4_BlockCipher::AES_128,\n                                                                             AP4_BlockCipher::ENCRYPT,\n                                                                             AP4_BlockCipher::CBC,\n                                                                             NULL,\n                                                                             key,\n                                                                             16,\n                                                                             block_cipher);\n    if (AP4_FAILED(result)) return result;\n    AP4_CbcStreamCipher* stream_cipher = new AP4_CbcStreamCipher(block_cipher);\n    stream_cipher->SetIV(iv);\n    stream = new EncryptingStream(stream_cipher, output);\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "static inline void sem_getref_and_unlock(struct sem_array *sma)\n{\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "int64_t TensorByteSize(const TensorProto& t) {\n  int64_t num_elems = TensorShape(t.tensor_shape()).num_elements();\n  return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype());\n}", "target": 1}
{"code": "  Status CalculateOutputIndexRowSplit(\n      const RowPartitionTensor& row_split,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    INDEX_TYPE row_split_size = row_split.size();\n    if (row_split_size > 0) {\n      result->reserve(row_split(row_split_size - 1));\n    }\n    for (INDEX_TYPE i = 0; i < row_split_size - 1; ++i) {\n      INDEX_TYPE row_length = row_split(i + 1) - row_split(i);\n      INDEX_TYPE real_length = std::min(output_size, row_length);\n      INDEX_TYPE parent_output_index_current = parent_output_index[i];\n      if (parent_output_index_current == -1) {\n        real_length = 0;\n      }\n      for (INDEX_TYPE j = 0; j < real_length; ++j) {\n        result->push_back(parent_output_index_current);\n        parent_output_index_current += output_index_multiplier;\n      }\n      for (INDEX_TYPE j = 0; j < row_length - real_length; ++j) {\n        result->push_back(-1);\n      }\n    }\n    if (row_split_size > 0 && result->size() != row_split(row_split_size - 1)) {\n      return errors::InvalidArgument(\"Invalid row split size.\");\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}", "target": 1}
{"code": "static void netbk_fatal_tx_err(struct xenvif *vif)\n{\n\tnetdev_err(vif->dev, \"fatal error; disabling device\\n\");\n\txenvif_carrier_off(vif);\n\txenvif_put(vif);\n}", "target": 0}
{"code": "int afGetFileFormat (AFfilehandle file, int *version)\n{\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\tif (version != NULL)\n\t{\n\t\tif (_af_units[file->fileFormat].getversion)\n\t\t\t*version = _af_units[file->fileFormat].getversion(file);\n\t\telse\n\t\t\t*version = 0;\n\t}\n\treturn file->fileFormat;\n}", "target": 0}
{"code": "static void Sp_split_regexp(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint limit, len, k;\n\tconst char *p, *a, *b, *c, *e;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tre = js_toregexp(J, 1);\n\tlimit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;\n\tjs_newarray(J);\n\tlen = 0;\n\te = text + strlen(text);\n\tif (e == text) {\n\t\tif (js_regexec(re->prog, text, &m, 0)) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushliteral(J, \"\");\n\t\t\tjs_setindex(J, -2, 0);\n\t\t}\n\t\treturn;\n\t}\n\tp = a = text;\n\twhile (a < e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak; \n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\t\tif (b == p) {\n\t\t\t++a;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len == limit) return;\n\t\tjs_pushlstring(J, p, b - p);\n\t\tjs_setindex(J, -2, len++);\n\t\tfor (k = 1; k < m.nsub; ++k) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);\n\t\t\tjs_setindex(J, -2, len++);\n\t\t}\n\t\ta = p = c;\n\t}\n\tif (len == limit) return;\n\tjs_pushstring(J, p);\n\tjs_setindex(J, -2, len);\n}", "target": 1}
{"code": "Ztring& Ztring::Date_From_Seconds_1970_Local (const int32u Value)\n{\n    time_t Time=(time_t)Value;\n    #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE\n    struct tm Gmt_Temp;\n    struct tm *Gmt=localtime_r(&Time, &Gmt_Temp);\n    #elif defined(_MSC_VER)\n    struct tm Gmt_Temp;\n    errno_t localtime_s_Result=localtime_s(&Gmt_Temp , &Time);\n    struct tm* Gmt=localtime_s_Result?NULL:&Gmt_Temp;\n    #else\n    struct tm *Gmt=localtime(&Time);\n    #endif\n    Ztring DateT;\n    Ztring Date;\n    if (Gmt)\n    {\n    Date+=Ztring::ToZtring((Gmt->tm_year+1900));\n    Date+=__T(\"-\");\n    DateT.From_Number(Gmt->tm_mon+1); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mon+1);}\n    Date+=DateT;\n    Date+=__T(\"-\");\n    DateT.From_Number(Gmt->tm_mday); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mday);}\n    Date+=DateT;\n    Date+=__T(\" \");\n    DateT.From_Number(Gmt->tm_hour); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_hour);}\n    Date+=DateT;\n    Date+=__T(\":\");\n    DateT=Ztring::ToZtring(Gmt->tm_min); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_min);}\n    Date+=DateT;\n    Date+=__T(\":\");\n    DateT.From_Number(Gmt->tm_sec); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_sec);}\n    Date+=DateT;\n    assign (Date.c_str());\n    }\n    return *this;\n}", "target": 0}
{"code": "static int region_list_contains_offset(struct fdt_region_state *info,\n\t\t\t\t       const void *fdt, int target)\n{\n\tstruct fdt_region *reg;\n\tint num;\n\ttarget += fdt_off_dt_struct(fdt);\n\tfor (reg = info->region, num = 0; num < info->count; reg++, num++) {\n\t\tif (target >= reg->offset && target < reg->offset + reg->size)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void tiny_dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)\n{\n    if (!pb_parse(entry, msg, msg_size, msg_tiny)) {\n        call_msg_failure_handler(FailureType_Failure_UnexpectedMessage,\n                                 \"Could not parse tiny protocol buffer message\");\n        return;\n    }\n    msg_tiny_id = entry->msg_id;\n}", "target": 1}
{"code": "Status SpectrogramShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input));\n  int32_t window_size;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"window_size\", &window_size));\n  if (window_size <= 1) {\n    return errors::InvalidArgument(\"window size must be > 1, got \",\n                                   window_size);\n  }\n  int32_t stride;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"stride\", &stride));\n  if (stride <= 0) {\n    return errors::InvalidArgument(\"stride must be strictly positive, got \",\n                                   stride);\n  }\n  DimensionHandle input_length = c->Dim(input, 0);\n  DimensionHandle input_channels = c->Dim(input, 1);\n  DimensionHandle output_length;\n  if (!c->ValueKnown(input_length)) {\n    output_length = c->UnknownDim();\n  } else {\n    const int64_t input_length_value = c->Value(input_length);\n    const int64_t length_minus_window = (input_length_value - window_size);\n    int64_t output_length_value;\n    if (length_minus_window < 0) {\n      output_length_value = 0;\n    } else {\n      output_length_value = 1 + (length_minus_window / stride);\n    }\n    output_length = c->MakeDim(output_length_value);\n  }\n  DimensionHandle output_channels =\n      c->MakeDim(1 + NextPowerOfTwo(window_size) / 2);\n  c->set_output(0,\n                c->MakeShape({input_channels, output_length, output_channels}));\n  return OkStatus();\n}", "target": 0}
{"code": "void QuotaManager::DidGetDatabaseLRUOrigin(const GURL& origin) {\n  if (origins_in_use_.find(origin) != origins_in_use_.end() ||\n      access_notified_origins_.find(origin) != access_notified_origins_.end())\n    lru_origin_callback_->Run(GURL());\n  else\n    lru_origin_callback_->Run(origin);\n  access_notified_origins_.clear();\n  lru_origin_callback_.reset();\n}", "target": 0}
{"code": "static void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}", "target": 1}
{"code": "  int Bind(const Node& node, int max_retry) override {\n    receiver_ = zmq_socket(context_, ZMQ_ROUTER);\n    CHECK(receiver_ != NULL)\n        << \"create receiver socket failed: \" << zmq_strerror(errno);\n    int local = GetEnv(\"DMLC_LOCAL\", 0);\n    std::string addr = local ? \"ipc:\n    int port = node.port;\n    unsigned seed = static_cast<unsigned>(time(NULL)+port);\n    for (int i = 0; i < max_retry+1; ++i) {\n      auto address = addr + std::to_string(port);\n      if (zmq_bind(receiver_, address.c_str()) == 0) break;\n      if (i == max_retry) {\n        port = -1;\n      } else {\n        port = 10000 + rand_r(&seed) % 40000;\n      }\n    }\n    return port;\n  }", "target": 1}
{"code": "void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n  w = r.width();\n  h = r.height();\n  b = format.bpp/8;\n  if (h == 0)\n    return;\n  buf = getBufferRW(r, &stride);\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n    }\n  } else {\n    U8 *start;\n    int w1;\n    start = buf;\n    w1 = w;\n    while (w1--) {\n      memcpy(buf, pix, b);\n      buf += b;\n    }\n    buf += (stride - w) * b;\n    h--;\n    while (h--) {\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n  commitBufferRW(r);\n}", "target": 1}
{"code": "makepol(QPRS_STATE *state)\n{\n\tint32\t\tval = 0,\n\t\t\t\ttype;\n\tint32\t\tlenval = 0;\n\tchar\t   *strval = NULL;\n\tint32\t\tstack[STACKDEPTH];\n\tint32\t\tlenstack = 0;\n\tuint16\t\tflag = 0;\n\tcheck_stack_depth();\n\twhile ((type = gettoken_query(state, &val, &lenval, &strval, &flag)) != END)\n\t{\n\t\tswitch (type)\n\t\t{\n\t\t\tcase VAL:\n\t\t\t\tpushval_asis(state, VAL, strval, lenval, flag);\n\t\t\t\twhile (lenstack && (stack[lenstack - 1] == (int32) '&' ||\n\t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) '!'))\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OPR:\n\t\t\t\tif (lenstack && val == (int32) '|')\n\t\t\t\t\tpushquery(state, OPR, val, 0, 0, 0);\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (lenstack == STACKDEPTH)\n\t\t\t\t\t\telog(ERROR, \"stack too short\");\n\t\t\t\t\tstack[lenstack] = val;\n\t\t\t\t\tlenstack++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase OPEN:\n\t\t\t\tif (makepol(state) == ERR)\n\t\t\t\t\treturn ERR;\n\t\t\t\twhile (lenstack && (stack[lenstack - 1] == (int32) '&' ||\n\t\t\t\t\t\t\t\t\tstack[lenstack - 1] == (int32) '!'))\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CLOSE:\n\t\t\t\twhile (lenstack)\n\t\t\t\t{\n\t\t\t\t\tlenstack--;\n\t\t\t\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t\t\t\t};\n\t\t\t\treturn END;\n\t\t\t\tbreak;\n\t\t\tcase ERR:\n\t\t\tdefault:\n\t\t\t\tereport(ERROR,\n\t\t\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t\t\t errmsg(\"syntax error\")));\n\t\t\t\treturn ERR;\n\t\t}\n\t}\n\twhile (lenstack)\n\t{\n\t\tlenstack--;\n\t\tpushquery(state, OPR, stack[lenstack], 0, 0, 0);\n\t};\n\treturn END;\n}", "target": 0}
{"code": "devzvol_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,\n    int mode, struct vnode **vpp, struct cred *cred, int flag,\n    caller_context_t *ct, vsecattr_t *vsecp)\n{\n\tint error;\n\tstruct vnode *vp;\n\t*vpp = NULL;\n\terror = devzvol_lookup(dvp, nm, &vp, NULL, 0, NULL, cred, ct, NULL,\n\t    NULL);\n\tif (error == 0) {\n\t\tif (excl == EXCL)\n\t\t\terror = EEXIST;\n\t\telse if (vp->v_type == VDIR && (mode & VWRITE))\n\t\t\terror = EISDIR;\n\t\telse\n\t\t\terror = VOP_ACCESS(vp, mode, 0, cred, ct);\n\t\tif (error) {\n\t\t\tVN_RELE(vp);\n\t\t} else\n\t\t\t*vpp = vp;\n\t} else if (error == ENOENT) {\n\t\terror = EROFS;\n\t}\n\treturn (error);\n}", "target": 0}
{"code": "static inline int nlmsg_parse(struct nlmsghdr *nlh, int hdrlen,\n\t\t\t      struct nlattr *tb[], int maxtype,\n\t\t\t      const struct nla_policy *policy)\n{\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\treturn nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),\n\t\t\t nlmsg_attrlen(nlh, hdrlen), policy);\n}", "target": 0}
{"code": "int crypto_scrypt(const uint8_t* password, size_t pwlen, const uint8_t* salt,\n                  size_t saltlen, uint64_t N, uint32_t r, uint32_t p,\n                  uint8_t* buf, size_t buflen) {\n  return crypto_pwhash_scryptsalsa208sha256_ll(password, pwlen, salt, saltlen,\n                                               N, r, p, buf, buflen);\n}", "target": 0}
{"code": "int siphash_test(void) {\n    uint8_t in[64], k[16];\n    int i;\n    int fails = 0;\n    for (i = 0; i < 16; ++i)\n        k[i] = i;\n    for (i = 0; i < 64; ++i) {\n        in[i] = i;\n        uint64_t hash = siphash(in, i, k);\n        const uint8_t *v = NULL;\n        v = (uint8_t *)vectors_sip64;\n        if (memcmp(&hash, v + (i * 8), 8)) {\n            fails++;\n        }\n    }\n    uint64_t h1, h2;\n    h1 = siphash((uint8_t*)\"hello world\",11,(uint8_t*)\"1234567812345678\");\n    h2 = siphash_nocase((uint8_t*)\"hello world\",11,(uint8_t*)\"1234567812345678\");\n    if (h1 != h2) fails++;\n    h1 = siphash((uint8_t*)\"hello world\",11,(uint8_t*)\"1234567812345678\");\n    h2 = siphash_nocase((uint8_t*)\"HELLO world\",11,(uint8_t*)\"1234567812345678\");\n    if (h1 != h2) fails++;\n    h1 = siphash((uint8_t*)\"HELLO world\",11,(uint8_t*)\"1234567812345678\");\n    h2 = siphash_nocase((uint8_t*)\"HELLO world\",11,(uint8_t*)\"1234567812345678\");\n    if (h1 == h2) fails++;\n    if (!fails) return 0;\n    return 1;\n}", "target": 0}
{"code": "static void ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "smix(uint8_t * B, size_t r, uint64_t N, uint32_t * V, uint32_t * XY)\n{\n  uint32_t * X = XY;\n  uint32_t * Y = &XY[32 * r];\n  uint32_t * Z = &XY[64 * r];\n  uint64_t i;\n  uint64_t j;\n  size_t k;\n  for (k = 0; k < 32 * r; k++) {\n    X[k] = folly::Endian::little32(*((uint32_t *) &B[4 * k]));\n  }\n  for (i = 0; i < N; i += 2) {\n    blkcpy(&V[i * (32 * r)], X, 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    blkcpy(&V[(i + 1) * (32 * r)], Y, 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (i = 0; i < N; i += 2) {\n    j = integerify(X, r) & (N - 1);\n    blkxor(X, &V[j * (32 * r)], 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    j = integerify(Y, r) & (N - 1);\n    blkxor(Y, &V[j * (32 * r)], 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (k = 0; k < 32 * r; k++) {\n    *((uint32_t *) &B[4 * k]) = folly::Endian::little32(X[k]);\n  }\n}", "target": 1}
{"code": "R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (curl_env && *curl_env) {\n\t\tchar *encoded_url = r_str_escape (url);\n\t\tchar *res = r_sys_cmd_strf (\"curl '%s'\", encoded_url);\n\t\tfree (encoded_url);\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = strlen (res);\n\t\t\t}\n\t\t}\n\t\tfree (curl_env);\n\t\treturn res;\n\t}\n\tfree (curl_env);\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https:\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\thost = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: *", "target": 1}
{"code": "  Status ValidateInputTensor(const Tensor& tensor,\n                             const std::string& tensor_name,\n                             const Tensor& rhs) {\n    const int ndims = rhs.dims();\n    if (tensor.dims() != ndims) {\n      return errors::InvalidArgument(tensor_name,\n                                     \" must have same rank as rhs, but got \",\n                                     tensor.dims(), \" and \", ndims);\n    }\n    for (int i = 0; i < ndims - 2; i++) {\n      if (tensor.dim_size(i) != rhs.dim_size(i)) {\n        return errors::InvalidArgument(\n            tensor_name,\n            \" must have same outer dimensions as rhs, but for index \", i,\n            \", got \", tensor.dim_size(i), \" and \", rhs.dim_size(i));\n      }\n    }\n    if (tensor.dim_size(ndims - 2) != 1) {\n      return errors::InvalidArgument(\n          tensor_name, \"'s second-to-last dimension must be 1, but got \",\n          tensor.dim_size(ndims - 2));\n    }\n    if (tensor.dim_size(ndims - 1) != rhs.dim_size(ndims - 2)) {\n      return errors::InvalidArgument(tensor_name,\n                                     \"'s last dimension size must be rhs's \"\n                                     \"second-to-last dimension size, but got \",\n                                     tensor.dim_size(ndims - 1), \" and \",\n                                     rhs.dim_size(ndims - 2));\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "  void operator()(OpKernelContext* context, const Tensor& input_tensor,\n                  Tensor& output_tensor, int n, bool reverse) {\n    const T* input = input_tensor.flat<T>().data();\n    T* output = output_tensor.flat<T>().data();\n    const int num_rows = output_tensor.NumElements();\n    const int last_dim = input_tensor.dim_size(input_tensor.dims() - 1);\n    auto SubNthElement = [&, input, output, last_dim, n](int start, int limit) {\n      std::vector<T> buf(last_dim);\n      for (int b = start; b < limit; ++b) {\n        const T* input_start = input + b * last_dim;\n        const T* input_end = input + (b + 1) * last_dim;\n        std::copy(input_start, input_end, buf.begin());\n        std::nth_element(buf.begin(), buf.begin() + n, buf.end());\n        output[b] = buf[n];\n      }\n    };\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n    Shard(worker_threads.num_threads, worker_threads.workers, num_rows,\n          20 * last_dim, SubNthElement);\n  }", "target": 1}
{"code": "int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n\t\t\t   sector_t block)\n{\n\tstruct mb2_cache_entry *entry, *dup;\n\tstruct hlist_bl_node *dup_node;\n\tstruct hlist_bl_head *head;\n\tentry = kmem_cache_alloc(mb2_entry_cache, mask);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&entry->e_lru_list);\n\tatomic_set(&entry->e_refcnt, 1);\n\tentry->e_key = key;\n\tentry->e_block = block;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\tentry->e_hash_list_head = head;\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\n\t\tif (dup->e_key == key && dup->e_block == block) {\n\t\t\thlist_bl_unlock(head);\n\t\t\tkmem_cache_free(mb2_entry_cache, entry);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\thlist_bl_add_head(&entry->e_hash_list, head);\n\thlist_bl_unlock(head);\n\tspin_lock(&cache->c_lru_list_lock);\n\tlist_add_tail(&entry->e_lru_list, &cache->c_lru_list);\n\tatomic_inc(&entry->e_refcnt);\n\tcache->c_entry_count++;\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static void vgacon_scrollback_init(int vc_num)\n{\n\tint pitch = vga_video_num_columns * 2;\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tint rows = size / pitch;\n\tvoid *data;\n\tdata = kmalloc_array(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024,\n\t\t\t     GFP_NOWAIT);\n\tvgacon_scrollbacks[vc_num].data = data;\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\tvgacon_scrollback_cur->rows = rows - 1;\n\tvgacon_scrollback_cur->size = rows * pitch;\n\tvgacon_scrollback_reset(vc_num, size);\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteTensor* hits;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 1, &hits));\n  const TfLiteTensor* lookup;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &lookup));\n  const TfLiteTensor* key;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &key));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &value));\n  const int num_rows = SizeOfDimension(value, 0);\n  TF_LITE_ENSURE(context, num_rows != 0);\n  const int row_bytes = value->bytes / num_rows;\n  void* pointer = nullptr;\n  DynamicBuffer buf;\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = -1;\n    pointer = bsearch(&(lookup->data.i32[i]), key->data.i32, num_rows,\n                      sizeof(int32_t), greater);\n    if (pointer != nullptr) {\n      idx = (reinterpret_cast<char*>(pointer) - (key->data.raw)) /\n            sizeof(int32_t);\n    }\n    if (idx >= num_rows || idx < 0) {\n      if (output->type == kTfLiteString) {\n        buf.AddString(nullptr, 0);\n      } else {\n        memset(output->data.raw + i * row_bytes, 0, row_bytes);\n      }\n      hits->data.uint8[i] = 0;\n    } else {\n      if (output->type == kTfLiteString) {\n        buf.AddString(GetString(value, idx));\n      } else {\n        memcpy(output->data.raw + i * row_bytes,\n               value->data.raw + idx * row_bytes, row_bytes);\n      }\n      hits->data.uint8[i] = 1;\n    }\n  }\n  if (output->type == kTfLiteString) {\n    buf.WriteToTensorAsVector(output);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int get_tp_trap(struct pt_regs *regs, unsigned int instr)\n{\n\tint reg = (instr >> 12) & 15;\n\tif (reg == 15)\n\t\treturn 1;\n\tregs->uregs[reg] = current_thread_info()->tp_value;\n\tregs->ARM_pc += 4;\n\treturn 0;\n}", "target": 1}
{"code": "int acpi_register_debugger(struct module *owner,\n\t\t\t   const struct acpi_debugger_ops *ops)\n{\n\tint ret = 0;\n\tmutex_lock(&acpi_debugger.lock);\n\tif (acpi_debugger.ops) {\n\t\tret = -EBUSY;\n\t\tgoto err_lock;\n\t}\n\tacpi_debugger.owner = owner;\n\tacpi_debugger.ops = ops;\nerr_lock:\n\tmutex_unlock(&acpi_debugger.lock);\n\treturn ret;\n}", "target": 0}
{"code": "R_API char *r_str_escape_sh(const char *buf) {\n\tr_return_val_if_fail (buf, NULL);\n\tchar *new_buf = malloc (1 + strlen (buf) * 2);\n\tif (!new_buf) {\n\t\treturn NULL;\n\t}\n\tconst char *p = buf;\n\tchar *q = new_buf;\n\twhile (*p) {\n\t\tswitch (*p) {\n#if __UNIX__\n\t\tcase '$':\n\t\tcase '`':\n#endif\n\t\tcase '\\\\':\n\t\tcase '\"':\n\t\t\t*q++ = '\\\\';\n\t\tdefault:\n\t\t\t*q++ = *p++;\n\t\t\tbreak;\n\t\t}\n\t}\n\t*q = '\\0';\n\treturn new_buf;\n}", "target": 0}
{"code": "static uint32_t buf_to_uint32(char *data) {\n    size_t i;\n    uint32_t result = 0;\n    for (i = 0; i < sizeof(uint32_t); i++)\n        result = (result << 8) | (unsigned char)data[i];\n    return result;\n}", "target": 0}
{"code": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\treturn 0;\n}", "target": 1}
{"code": "unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\n{\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);\n}", "target": 0}
{"code": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n    FreeStmt((ParseCommon *) &append);\n    return expr;\n}", "target": 1}
{"code": "void gf_isom_sample_entry_init(GF_SampleEntryBox *ent)\n{\n\tent->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n}", "target": 0}
{"code": "pte_t *huge_pmd_share(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t      unsigned long addr, pud_t *pud)\n{\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tpgoff_t idx = ((addr - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\tvma->vm_pgoff;\n\tstruct vm_area_struct *svma;\n\tunsigned long saddr;\n\tpte_t *spte = NULL;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\ti_mmap_assert_locked(mapping);\n\tvma_interval_tree_foreach(svma, &mapping->i_mmap, idx, idx) {\n\t\tif (svma == vma)\n\t\t\tcontinue;\n\t\tsaddr = page_table_shareable(svma, vma, addr, idx);\n\t\tif (saddr) {\n\t\t\tspte = huge_pte_offset(svma->vm_mm, saddr,\n\t\t\t\t\t       vma_mmu_pagesize(svma));\n\t\t\tif (spte) {\n\t\t\t\tget_page(virt_to_page(spte));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!spte)\n\t\tgoto out;\n\tptl = huge_pte_lock(hstate_vma(vma), mm, spte);\n\tif (pud_none(*pud)) {\n\t\tpud_populate(mm, pud,\n\t\t\t\t(pmd_t *)((unsigned long)spte & PAGE_MASK));\n\t\tmm_inc_nr_pmds(mm);\n\t} else {\n\t\tput_page(virt_to_page(spte));\n\t}\n\tspin_unlock(ptl);\nout:\n\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\treturn pte;\n}", "target": 0}
{"code": "int nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols)\n{\n\tint rc;\n\tpr_debug(\"dev_name %s initiator protocols 0x%x target protocols 0x%x\\n\",\n\t\t dev_name(&dev->dev), im_protocols, tm_protocols);\n\tif (!im_protocols && !tm_protocols)\n\t\treturn -EINVAL;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc) {\n\t\tdev->polling = true;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    LutContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    AVFrame *out;\n    uint8_t *inrow, *outrow, *inrow0, *outrow0;\n    int i, j, plane, direct = 0;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    if (s->is_rgb) {\n        inrow0  = in ->data[0];\n        outrow0 = out->data[0];\n        for (i = 0; i < in->height; i ++) {\n            int w = inlink->w;\n            const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;\n            inrow  = inrow0;\n            outrow = outrow0;\n            for (j = 0; j < w; j++) {\n                switch (s->step) {\n                case 4:  outrow[3] = tab[3][inrow[3]]; \n                case 3:  outrow[2] = tab[2][inrow[2]]; \n                case 2:  outrow[1] = tab[1][inrow[1]]; \n                default: outrow[0] = tab[0][inrow[0]];\n                }\n                outrow += s->step;\n                inrow  += s->step;\n            }\n            inrow0  += in ->linesize[0];\n            outrow0 += out->linesize[0];\n        }\n    } else {\n        for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n            int vsub = plane == 1 || plane == 2 ? s->vsub : 0;\n            int hsub = plane == 1 || plane == 2 ? s->hsub : 0;\n            int h = FF_CEIL_RSHIFT(inlink->h, vsub);\n            int w = FF_CEIL_RSHIFT(inlink->w, hsub);\n            inrow  = in ->data[plane];\n            outrow = out->data[plane];\n            for (i = 0; i < h; i++) {\n                const uint8_t *tab = s->lut[plane];\n                for (j = 0; j < w; j++)\n                    outrow[j] = tab[inrow[j]];\n                inrow  += in ->linesize[plane];\n                outrow += out->linesize[plane];\n            }\n        }\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "static inline void sem_unlock(struct sem_array *sma, int locknum)\n{\n\tif (locknum == -1) {\n\t\tspin_unlock(&sma->sem_perm.lock);\n\t} else {\n\t\tstruct sem *sem = sma->sem_base + locknum;\n\t\tspin_unlock(&sem->lock);\n\t}\n\trcu_read_unlock();\n}", "target": 0}
{"code": "update_notification_destroy(struct update_notification *file)\n{\n\tdoc_data_cleanup(&file->snapshot);\n\tglobal_data_cleanup(&file->global_data);\n\tdeltas_head_destroy(file->deltas_list);\n\tfree(file->uri);\n\tfree(file);\n}", "target": 1}
{"code": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = numrows - hstartcol;\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\t\tunsigned int len;\n\t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\tlen = ipv6_optlen(exthdr);\n\t\tif (len + offset >= IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\toffset += len;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\tif (card->last_numid >= UINT_MAX - count)\n\t\tcard->last_numid = 0;\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": " static void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)\n {\n\tUINT32 front;\n\tif (count <= 0)\n\t\treturn;\n\tif (count > zgfx->HistoryBufferSize)\n\t{\n\t\tconst size_t residue = count - zgfx->HistoryBufferSize;\n\t\tcount = zgfx->HistoryBufferSize;\n\t\tsrc += residue;\n\t\tzgfx->HistoryIndex = (zgfx->HistoryIndex + residue) % zgfx->HistoryBufferSize;\n\t}\n\tif (zgfx->HistoryIndex + count <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, count);\n\t\tif ((zgfx->HistoryIndex += count) == zgfx->HistoryBufferSize)\n\t\t\tzgfx->HistoryIndex = 0;\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - zgfx->HistoryIndex;\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, front);\n\t\tCopyMemory(zgfx->HistoryBuffer, &src[front], count - front);\n\t\tzgfx->HistoryIndex = count - front;\n\t}\n}", "target": 0}
{"code": "int razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max)\n{\n    uint request = HID_REQ_GET_REPORT; \n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN; \n    uint value = 0x300;\n    uint size = RAZER_USB_REPORT_LEN; \n    int len;\n    int retval;\n    int result = 0;\n    char *buf;\n    buf = kzalloc(sizeof(struct razer_report), GFP_KERNEL);\n    if (buf == NULL)\n        return -ENOMEM;\n    retval = razer_send_control_msg(usb_dev, request_report, report_index, wait_min, wait_max);\n    len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n                          request,         \n                          request_type,    \n                          value,           \n                          response_index,  \n                          buf,             \n                          size,\n                          USB_CTRL_SET_TIMEOUT);\n    memcpy(response_report, buf, sizeof(struct razer_report));\n    kfree(buf);\n    if(len != 90) {\n        printk(KERN_WARNING \"razer driver: Invalid USB response. USB Report length: %d\\n\", len);\n        result = 1;\n    }\n    if (WARN_ONCE(response_report->data_size > ARRAY_SIZE(response_report->arguments),\n                  \"Field data_size %d in response is bigger than arguments\\n\",\n                  response_report->data_size)) {\n        response_report->data_size = ARRAY_SIZE(response_report->arguments);\n        return -EINVAL;\n    }\n    return result;\n}", "target": 0}
{"code": "GF_Err stsz_box_size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) {\n\t\t}\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t\treturn GF_OK;\n\t}\n\tif (fieldSize == 32) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int av_hwframe_ctx_init(AVBufferRef *ref)\n{\n    AVHWFramesContext *ctx = (AVHWFramesContext*)ref->data;\n    const enum AVPixelFormat *pix_fmt;\n    int ret;\n    if (ctx->internal->source_frames) {\n        return 0;\n    }\n    for (pix_fmt = ctx->internal->hw_type->pix_fmts; *pix_fmt != AV_PIX_FMT_NONE; pix_fmt++) {\n        if (*pix_fmt == ctx->format)\n            break;\n    }\n    if (*pix_fmt == AV_PIX_FMT_NONE) {\n        av_log(ctx, AV_LOG_ERROR,\n               \"The hardware pixel format '%s' is not supported by the device type '%s'\\n\",\n               av_get_pix_fmt_name(ctx->format), ctx->internal->hw_type->name);\n        return AVERROR(ENOSYS);\n    }\n    ret = av_image_check_size(ctx->width, ctx->height, 0, ctx);\n    if (ret < 0)\n        return ret;\n    if (ctx->internal->hw_type->frames_init) {\n        ret = ctx->internal->hw_type->frames_init(ctx);\n        if (ret < 0)\n            goto fail;\n    }\n    if (ctx->internal->pool_internal && !ctx->pool)\n        ctx->pool = ctx->internal->pool_internal;\n    if (ctx->initial_pool_size > 0) {\n        ret = hwframe_pool_prealloc(ref);\n        if (ret < 0)\n            goto fail;\n    }\n    return 0;\nfail:\n    if (ctx->internal->hw_type->frames_uninit)\n        ctx->internal->hw_type->frames_uninit(ctx);\n    return ret;\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    BoxBlurContext *s = ctx->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int plane;\n    int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);\n    int w[4] = { inlink->w, cw, cw, inlink->w };\n    int h[4] = { in->height, ch, ch, in->height };\n    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n    if (!out) {\n        av_frame_free(&in);\n        return AVERROR(ENOMEM);\n    }\n    av_frame_copy_props(out, in);\n    for (plane = 0; in->data[plane] && plane < 4; plane++)\n        hblur(out->data[plane], out->linesize[plane],\n              in ->data[plane], in ->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n    for (plane = 0; in->data[plane] && plane < 4; plane++)\n        vblur(out->data[plane], out->linesize[plane],\n              out->data[plane], out->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n    av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}", "target": 1}
{"code": "static int em_call(struct x86_emulate_ctxt *ctxt)\n{\n\tlong rel = ctxt->src.val;\n\tctxt->src.val = (unsigned long)ctxt->_eip;\n\tjmp_rel(ctxt, rel);\n\treturn em_push(ctxt);\n}", "target": 1}
{"code": "static bool is_valid_guid(const char *guid) {\n\tif (!guid) {\n\t\treturn false;\n\t}\n\tsize_t i;\n\tfor (i = 0; guid[i]; i++) {\n\t\tif (!isxdigit (guid[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn i >= 33; \n}", "target": 0}
{"code": "static void esp_do_nodma(ESPState *s)\n{\n    int to_device = ((s->rregs[ESP_RSTAT] & 7) == STAT_DO);\n    uint32_t cmdlen;\n    int len;\n    if (s->do_cmd) {\n        cmdlen = fifo8_num_used(&s->cmdfifo);\n        trace_esp_handle_ti_cmd(cmdlen);\n        s->ti_size = 0;\n        if ((s->rregs[ESP_RSTAT] & 7) == STAT_CD) {\n            if (s->cmdfifo_cdb_offset == fifo8_num_used(&s->cmdfifo)) {\n                return;\n            }\n            s->do_cmd = 0;\n            do_cmd(s);\n        } else {\n            s->cmdfifo_cdb_offset = fifo8_num_used(&s->cmdfifo);\n            s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;\n            s->rregs[ESP_RSEQ] = SEQ_CD;\n            s->rregs[ESP_RINTR] |= INTR_BS;\n            esp_raise_irq(s);\n        }\n        return;\n    }\n    if (!s->current_req) {\n        return;\n    }\n    if (s->async_len == 0) {\n        return;\n    }\n    if (to_device) {\n        len = MIN(fifo8_num_used(&s->fifo), ESP_FIFO_SZ);\n        esp_fifo_pop_buf(&s->fifo, s->async_buf, len);\n        s->async_buf += len;\n        s->async_len -= len;\n        s->ti_size += len;\n    } else {\n        if (fifo8_is_empty(&s->fifo)) {\n            fifo8_push(&s->fifo, s->async_buf[0]);\n            s->async_buf++;\n            s->async_len--;\n            s->ti_size--;\n        }\n    }\n    if (s->async_len == 0) {\n        scsi_req_continue(s->current_req);\n        return;\n    }\n    s->rregs[ESP_RINTR] |= INTR_BS;\n    esp_raise_irq(s);\n}", "target": 1}
{"code": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\treturn 0;\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}", "target": 1}
{"code": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError    error        = OT_ERROR_NONE;\n    const char saltPrefix[] = \"Thread\";\n    uint8_t    salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t   saltLen = 0;\n    uint16_t   passphraseLen;\n    uint8_t    networkNameLen;\n    passphraseLen  = static_cast<uint16_t>(strnlen(aPassPhrase, OT_COMMISSIONING_PASSPHRASE_MAX_SIZE + 1));\n    networkNameLen = static_cast<uint8_t>(strnlen(aNetworkName, OT_NETWORK_NAME_MAX_SIZE + 1));\n    VerifyOrExit((passphraseLen >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (passphraseLen <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (networkNameLen <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, sizeof(saltPrefix) - 1);\n    saltLen += static_cast<uint16_t>(sizeof(saltPrefix) - 1);\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n    memcpy(salt + saltLen, aNetworkName, networkNameLen);\n    saltLen += networkNameLen;\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), passphraseLen, reinterpret_cast<const uint8_t *>(salt),\n                 saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\nexit:\n    return error;\n}", "target": 0}
{"code": "static int stv06xx_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tmin_packet_size = sd->sensor->min_packet_size[gspca_dev->curr_mode];\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tgspca_err(gspca_dev, \"set alt 1 err %d\\n\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *)urb->setup_packet;\n\t\t\tunsigned wvalue = le16_to_cpu(setup->wValue);\n\t\t\tif (oz_enqueue_ep_urb(port, 0, 0, urb, req_id))\n\t\t\t\terr = -ENOMEM;\n\t\t\telse if (oz_usb_get_desc_req(port->hpd, req_id,\n\t\t\t\t\tsetup->bRequestType, (u8)(wvalue>>8),\n\t\t\t\t\t(u8)wvalue, setup->wIndex, offset,\n\t\t\t\t\trequired_size-offset)) {\n\t\t\t\toz_dequeue_ep_urb(port, 0, 0, urb);\n\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\t\t\tif (err == 0)\n\t\t\t\treturn;\n\t\t}\n\t}\n\turb->actual_length = total_size;\n\toz_complete_urb(port->ozhcd->hcd, urb, 0);\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const CTCBeamSearchDecoderParams* option =\n      reinterpret_cast<CTCBeamSearchDecoderParams*>(node->user_data);\n  const int top_paths = option->top_paths;\n  TF_LITE_ENSURE(context, option->beam_width >= top_paths);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 3 * top_paths + 1);\n  const TfLiteTensor* inputs = GetInput(context, node, kInputsTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(inputs), 3);\n  TF_LITE_ENSURE_EQ(context, inputs->type, kTfLiteFloat32);\n  const int batch_size = SizeOfDimension(inputs, 1);\n  const TfLiteTensor* sequence_length =\n      GetInput(context, node, kSequenceLengthTensor);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(sequence_length), 1);\n  TF_LITE_ENSURE_EQ(context, NumElements(sequence_length), batch_size);\n  TF_LITE_ENSURE_EQ(context, sequence_length->type, kTfLiteInt32);\n  for (int i = 0; i < top_paths; ++i) {\n    TfLiteTensor* indices = GetOutput(context, node, i);\n    SetTensorToDynamic(indices);\n    TfLiteTensor* values = GetOutput(context, node, i + top_paths);\n    SetTensorToDynamic(values);\n    TfLiteTensor* output_shape = GetOutput(context, node, i + 2 * top_paths);\n    SetTensorToDynamic(output_shape);\n  }\n  TfLiteTensor* log_probability_output =\n      GetOutput(context, node, top_paths * 3);\n  TfLiteIntArray* log_probability_output_shape_array = TfLiteIntArrayCreate(2);\n  log_probability_output_shape_array->data[0] = batch_size;\n  log_probability_output_shape_array->data[1] = top_paths;\n  return context->ResizeTensor(context, log_probability_output,\n                               log_probability_output_shape_array);\n}", "target": 1}
{"code": "processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}", "target": 1}
{"code": "jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}", "target": 1}
{"code": "static bool bt_att_disc_cancel(struct bt_att *att, unsigned int id)\n{\n\tstruct att_send_op *op;\n\top = queue_find(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_find(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_find(att->write_queue, match_op_id, UINT_TO_PTR(id));\ndone:\n\tif (!op)\n\t\treturn false;\n\tcancel_att_send_op(op);\n\treturn true;\n}", "target": 0}
{"code": "void bnx2x_setup_cnic_irq_info(struct bnx2x *bp)\n{\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\tif (bp->flags & USING_MSIX_FLAG) {\n\t\tcp->drv_state |= CNIC_DRV_STATE_USING_MSIX;\n\t\tcp->irq_arr[0].irq_flags |= CNIC_IRQ_FL_MSIX;\n\t\tcp->irq_arr[0].vector = bp->msix_table[1].vector;\n\t} else {\n\t\tcp->drv_state &= ~CNIC_DRV_STATE_USING_MSIX;\n\t\tcp->irq_arr[0].irq_flags &= ~CNIC_IRQ_FL_MSIX;\n\t}\n\tif (!CHIP_IS_E1x(bp))\n\t\tcp->irq_arr[0].status_blk = (void *)bp->cnic_sb.e2_sb;\n\telse\n\t\tcp->irq_arr[0].status_blk = (void *)bp->cnic_sb.e1x_sb;\n\tcp->irq_arr[0].status_blk_num =  bnx2x_cnic_fw_sb_id(bp);\n\tcp->irq_arr[0].status_blk_num2 = bnx2x_cnic_igu_sb_id(bp);\n\tcp->irq_arr[1].status_blk = bp->def_status_blk;\n\tcp->irq_arr[1].status_blk_num = DEF_SB_ID;\n\tcp->irq_arr[1].status_blk_num2 = DEF_SB_IGU_ID;\n\tcp->num_irq = 2;\n}", "target": 0}
{"code": "int fscrypt_process_policy(struct inode *inode,\n\t\t\t\tconst struct fscrypt_policy *policy)\n{\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\tif (policy->version != 0)\n\t\treturn -EINVAL;\n\tif (!inode_has_encryption_context(inode)) {\n\t\tif (!inode->i_sb->s_cop->empty_dir)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!inode->i_sb->s_cop->empty_dir(inode))\n\t\t\treturn -ENOTEMPTY;\n\t\treturn create_encryption_context_from_policy(inode, policy);\n\t}\n\tif (is_encryption_context_consistent_with_policy(inode, policy))\n\t\treturn 0;\n\tprintk(KERN_WARNING \"%s: Policy inconsistent with encryption context\\n\",\n\t       __func__);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "doIgnoreSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n                const char *end, const char **nextPtr, XML_Bool haveMore) {\n  const char *next = *startPtr; \n  int tok;\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n  tok = XmlIgnoreSectionTok(enc, s, end, &next);\n#  ifdef XML_DTD\n  if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#  endif\n  *eventEndPP = next;\n  switch (tok) {\n  case XML_TOK_IGNORE_SECT:\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n    *startPtr = next;\n    *nextPtr = next;\n    if (parser->m_parsingStatus.parsing == XML_FINISHED)\n      return XML_ERROR_ABORTED;\n    else\n      return XML_ERROR_NONE;\n  case XML_TOK_INVALID:\n    *eventPP = next;\n    return XML_ERROR_INVALID_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  case XML_TOK_PARTIAL:\n  case XML_TOK_NONE:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_SYNTAX; \n  default:\n    *eventPP = next;\n    return XML_ERROR_UNEXPECTED_STATE;\n  }\n}", "target": 1}
{"code": "decode_NXAST_RAW_ENCAP(const struct nx_action_encap *nae,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       struct ofpbuf *out)\n{\n    struct ofpact_encap *encap;\n    const struct ofp_ed_prop_header *ofp_prop;\n    const size_t encap_ofs = out->size;\n    size_t props_len;\n    uint16_t n_props = 0;\n    int err;\n    encap = ofpact_put_ENCAP(out);\n    encap->ofpact.raw = NXAST_RAW_ENCAP;\n    switch (ntohl(nae->new_pkt_type)) {\n    case PT_ETH:\n    case PT_NSH:\n        break;\n    default:\n        return OFPERR_NXBAC_BAD_HEADER_TYPE;\n    }\n    encap->new_pkt_type = nae->new_pkt_type;\n    encap->hdr_size = ntohs(nae->hdr_size);\n    ofp_prop = nae->props;\n    props_len = ntohs(nae->len) - offsetof(struct nx_action_encap, props);\n    n_props = 0;\n    while (props_len > 0) {\n        err = decode_ed_prop(&ofp_prop, out, &props_len);\n        if (err) {\n            return err;\n        }\n        n_props++;\n    }\n    encap = ofpbuf_at_assert(out, encap_ofs, sizeof *encap);\n    encap->n_props = n_props;\n    out->header = &encap->ofpact;\n    ofpact_finish_ENCAP(out, &encap);\n    return 0;\n}", "target": 0}
{"code": "int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *stream)\n{\n\tchar * start,*end;\n\tif( !s )\n\t\treturn 1;\n\tstart = s;\n\tend  = s;\n\twhile(*start != '\\n' && start > stream->body.s)\n\t\tstart--;\n\tstart++;\n\twhile(*end != '\\n' && end < (stream->body.s+stream->body.len) )\n\t\tend++;\n\tif ( *end == '\\n')\n\t\tend++;\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "static int __tail_onwire_len(int front_len, int middle_len, int data_len,\n\t\t\t     bool secure)\n{\n\tBUG_ON(front_len < 0 || front_len > CEPH_MSG_MAX_FRONT_LEN ||\n\t       middle_len < 0 || middle_len > CEPH_MSG_MAX_MIDDLE_LEN ||\n\t       data_len < 0 || data_len > CEPH_MSG_MAX_DATA_LEN);\n\tif (!front_len && !middle_len && !data_len)\n\t\treturn 0;\n\tif (!secure)\n\t\treturn front_len + middle_len + data_len +\n\t\t       CEPH_EPILOGUE_PLAIN_LEN;\n\treturn padded_len(front_len) + padded_len(middle_len) +\n\t       padded_len(data_len) + CEPH_EPILOGUE_SECURE_LEN;\n}", "target": 0}
{"code": "Status MakeArgTuple(const PyCall* call, TFE_Context* ctx, PyObject** tuple) {\n  int64_t n = call->ins.size();\n  PyObject* lst = PyList_New(n);\n  CHECK(lst);\n  const char* device_name = nullptr;\n  if (call->device != nullptr && !IsCPUDevice(call->device))\n    device_name = call->device->name().c_str();\n  for (int64_t i = 0; i < n; ++i) {\n    PyObject* arg = nullptr;\n    if (call->eager) {\n      Tensor t = call->ins[i];\n      arg = EagerTensorFromHandle(tensorflow::wrap(\n          tensorflow::unwrap(ctx)->CreateLocalHandleFromTFTensor(t,\n                                                                 device_name)));\n      if (arg == nullptr) {\n        Py_DECREF(lst);\n        return errors::Internal(\"Unable to procure EagerTensor from Tensor.\");\n      }\n    } else {\n      Status s = TensorToNdarray(call->ins[i], &arg);\n      if (!s.ok()) {\n        Py_DECREF(lst);\n        return s;\n      }\n      arg = PyArray_Return(reinterpret_cast<PyArrayObject*>(arg));\n    }\n    PyList_SetItem(lst, i, arg);\n  }\n  *tuple = Py_BuildValue(\"(ssN)\", call->token.c_str(), device_name, lst);\n  CHECK(*tuple);\n  return OkStatus();\n}", "target": 1}
{"code": "static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t  void (*get)(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t\t      struct desc_ptr *ptr))\n{\n\tstruct desc_ptr desc_ptr;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tctxt->op_bytes = 8;\n\tget(ctxt, &desc_ptr);\n\tif (ctxt->op_bytes == 2) {\n\t\tctxt->op_bytes = 4;\n\t\tdesc_ptr.address &= 0x00ffffff;\n\t}\n\tctxt->dst.type = OP_NONE;\n\treturn segmented_write(ctxt, ctxt->dst.addr.mem,\n\t\t\t       &desc_ptr, 2 + ctxt->op_bytes);\n}", "target": 1}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, indices_t.dim_size(0) == values_t.dim_size(0),\n      errors::InvalidArgument(\"The length of `values` (\", values_t.dim_size(0),\n                              \") must match the first dimension of `indices` (\",\n                              indices_t.dim_size(0), \").\"),\n      done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 0}
{"code": "bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n            reservekey.KeepKey();\n            AddToWallet(wtxNew);\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n        mapRequestCount[wtxNew.GetHash()] = 0;\n        if (!wtxNew.AcceptToMemoryPool())\n        {\n            printf(\"CommitTransaction() : Error: Transaction not valid\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}", "target": 1}
{"code": "cmd_len(conn c)\n{\n    return scan_line_end(c->cmd, c->cmd_read);\n}", "target": 0}
{"code": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; \n\tconst char *mntsrc = src;\n\tif (!rootfs)\n\t\trootfs = \"\";\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\treturn destfd;\n\t}\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int credential_from_url_gently(struct credential *c, const char *url,\n\t\t\t       int quiet)\n{\n\tconst char *at, *colon, *cp, *slash, *host, *proto_end;\n\tcredential_clear(c);\n\tproto_end = strstr(url, \":\n\tif (!proto_end)\n\t\treturn 0;\n\tcp = proto_end + 3;\n\tat = strchr(cp, '@');\n\tcolon = strchr(cp, ':');\n\tslash = strchrnul(cp, '/');\n\tif (!at || slash <= at) {\n\t\thost = cp;\n\t}\n\telse if (!colon || at <= colon) {\n\t\tc->username = url_decode_mem(cp, at - cp);\n\t\thost = at + 1;\n\t} else {\n\t\tc->username = url_decode_mem(cp, colon - cp);\n\t\tc->password = url_decode_mem(colon + 1, at - (colon + 1));\n\t\thost = at + 1;\n\t}\n\tif (proto_end - url > 0)\n\t\tc->protocol = xmemdupz(url, proto_end - url);\n\tc->host = url_decode_mem(host, slash - host);\n\twhile (*slash == '/')\n\t\tslash++;\n\tif (*slash) {\n\t\tchar *p;\n\t\tc->path = url_decode(slash);\n\t\tp = c->path + strlen(c->path) - 1;\n\t\twhile (p > c->path && *p == '/')\n\t\t\t*p-- = '\\0';\n\t}\n\tif (check_url_component(url, quiet, \"username\", c->username) < 0 ||\n\t    check_url_component(url, quiet, \"password\", c->password) < 0 ||\n\t    check_url_component(url, quiet, \"protocol\", c->protocol) < 0 ||\n\t    check_url_component(url, quiet, \"host\", c->host) < 0 ||\n\t    check_url_component(url, quiet, \"path\", c->path) < 0)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "static void ext_session_lock_surface_v1_handle_configure(void *data,\n\t\tstruct ext_session_lock_surface_v1 *lock_surface, uint32_t serial,\n\t\tuint32_t width, uint32_t height) {\n\tstruct swaylock_surface *surface = data;\n\tsurface->width = width;\n\tsurface->height = height;\n\tsurface->indicator_width = 0;\n\tsurface->indicator_height = 0;\n\text_session_lock_surface_v1_ack_configure(lock_surface, serial);\n\trender_frame_background(surface);\n\trender_frame(surface);\n}", "target": 0}
{"code": "xfs_iunlink_free_item(\n\tvoid\t\t\t*ptr,\n\tvoid\t\t\t*arg)\n{\n\tstruct xfs_iunlink\t*iu = ptr;\n\tbool\t\t\t*freed_anything = arg;\n\t*freed_anything = true;\n\tkmem_free(iu);\n}", "target": 0}
{"code": "xmlValidNormalizeString(xmlChar *str) {\n    xmlChar *dst;\n    const xmlChar *src;\n    if (str == NULL)\n        return;\n    src = str;\n    dst = str;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n}", "target": 0}
{"code": "static void __exit adpt_exit(void)\n{\n\tadpt_hba\t*pHba, *next;\n\tfor (pHba = hba_chain; pHba; pHba = next) {\n\t\tnext = pHba->next;\n\t\tadpt_release(pHba);\n\t}\n}", "target": 1}
{"code": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tdevice_unregister(&clt->dev);\n}", "target": 1}
{"code": "int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\tif (error < 0)\n\t\t\treturn 0;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t}\n\tinode->i_ctime = current_time(inode);\n\tset_cached_acl(inode, type, acl);\n\treturn 0;\n}", "target": 1}
{"code": "static uint64_t unpack_timestamp(const struct efi_time *timestamp)\n{\n\tuint64_t val = 0;\n\tuint16_t year = le32_to_cpu(timestamp->year);\n\tval |= ((uint64_t) timestamp->pad1 & 0xFF) << 0;\n\tval |= ((uint64_t) timestamp->second & 0xFF) << (1*8);\n\tval |= ((uint64_t) timestamp->minute & 0xFF) << (2*8);\n\tval |= ((uint64_t) timestamp->hour & 0xFF) << (3*8);\n\tval |= ((uint64_t) timestamp->day & 0xFF) << (4*8);\n\tval |= ((uint64_t) timestamp->month & 0xFF) << (5*8);\n\tval |= ((uint64_t) year) << (6*8);\n\treturn val;\n}", "target": 1}
{"code": "dirserv_remove_old_statuses(smartlist_t *fps, time_t cutoff)\n{\n  int found_any = 0;\n  SMARTLIST_FOREACH(fps, char *, digest,\n  {\n    cached_dir_t *d = lookup_cached_dir_by_fp(digest);\n    if (!d)\n      continue;\n    found_any = 1;\n    if (d->published <= cutoff) {\n      tor_free(digest);\n      SMARTLIST_DEL_CURRENT(fps, digest);\n    }\n  });\n  return found_any;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(4, context->num_inputs());\n    const Tensor& gradient = context->input(0);\n    const Tensor& input = context->input(1);\n    OP_REQUIRES(context, input.IsSameSize(gradient),\n                InvalidArgument(\"gradient and input must be the same size\"));\n    const int depth = input.dim_size(input.dims() - 1);  \n    const Tensor& min = context->input(2);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(min.shape()),\n        InvalidArgument(\"`min` must be rank 1 but is rank \", min.dims()));\n    OP_REQUIRES(context, min.dim_size(0) == depth,\n                InvalidArgument(\"min has incorrect size, expected \", depth,\n                                \" was \", min.dim_size(0)));\n    const Tensor& max = context->input(3);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(max.shape()),\n        InvalidArgument(\"`max` must be rank 1 but is rank \", max.dims()));\n    OP_REQUIRES(context, max.dim_size(0) == depth,\n                InvalidArgument(\"max has incorrect size, expected \", depth,\n                                \" was \", max.dim_size(0)));\n    Tensor* grad_wrt_input;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &grad_wrt_input));\n    TensorShape min_max_shape({input.dim_size(input.dims() - 1)});\n    Tensor* grad_wrt_min;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, min_max_shape, &grad_wrt_min));\n    Tensor* grad_wrt_max;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, min_max_shape, &grad_wrt_max));\n    FakeQuantWithMinMaxVarsPerChannelGradientFunctor<Device> functor;\n    functor(\n        context->eigen_device<Device>(), gradient.flat_inner_dims<float, 2>(),\n        input.flat_inner_dims<float, 2>(), min.vec<float>(), max.vec<float>(),\n        quant_min_, quant_max_, grad_wrt_input->flat_inner_dims<float, 2>(),\n        grad_wrt_min->vec<float>(), grad_wrt_max->vec<float>());\n  }", "target": 0}
{"code": "OGRKMLLayer::OGRKMLLayer( const char * pszName,\n                          OGRSpatialReference *poSRSIn, bool bWriterIn,\n                          OGRwkbGeometryType eReqType,\n                          OGRKMLDataSource *poDSIn ) :\n    poDS_(poDSIn),\n    poSRS_(poSRSIn ? new OGRSpatialReference(nullptr) : nullptr),\n    poCT_(nullptr),\n    poFeatureDefn_(new OGRFeatureDefn( pszName )),\n    iNextKMLId_(0),\n    nTotalKMLCount_(-1),\n    bWriter_(bWriterIn),\n    nLayerNumber_(0),\n    nWroteFeatureCount_(0),\n    bSchemaWritten_(false),\n    pszName_(CPLStrdup(pszName)),\n    nLastAsked(-1),\n    nLastCount(-1)\n{\n    if( poSRSIn != nullptr )\n    {\n        poSRS_->SetWellKnownGeogCS( \"WGS84\" );\n        poSRS_->SetAxisMappingStrategy(OAMS_TRADITIONAL_GIS_ORDER);\n        if( !poSRS_->IsSame(poSRSIn) )\n        {\n            poCT_ = OGRCreateCoordinateTransformation( poSRSIn, poSRS_ );\n            if( poCT_ == nullptr && poDSIn->IsFirstCTError() )\n            {\n                char *pszWKT = nullptr;\n                poSRSIn->exportToPrettyWkt( &pszWKT, FALSE );\n                CPLError(\n                    CE_Warning, CPLE_AppDefined,\n                    \"Failed to create coordinate transformation between the \"\n                    \"input coordinate system and WGS84.  This may be because \"\n                    \"they are not transformable.  \"\n                    \"KML geometries may not render correctly.  \"\n                    \"This message will not be issued any more.\"\n                    \"\\nSource:\\n%s\\n\",\n                    pszWKT );\n                CPLFree( pszWKT );\n                poDSIn->IssuedFirstCTError();\n            }\n        }\n    }\n    SetDescription( poFeatureDefn_->GetName() );\n    poFeatureDefn_->Reference();\n    poFeatureDefn_->SetGeomType( eReqType );\n    if( poFeatureDefn_->GetGeomFieldCount() != 0 )\n        poFeatureDefn_->GetGeomFieldDefn(0)->SetSpatialRef(poSRS_);\n    OGRFieldDefn oFieldName( \"Name\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldName );\n    OGRFieldDefn oFieldDesc( \"Description\", OFTString );\n    poFeatureDefn_->AddFieldDefn( &oFieldDesc );\n    bClosedForWriting = !bWriterIn;\n}", "target": 0}
{"code": "Status OpLevelCostEstimator::PredictAvgPool(const OpContext& op_context,\n                                            NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * dims.kx * dims.ky;\n  node_costs->num_compute_ops = ops;\n  int64_t input_size;\n  if (dims.ky >= dims.sy) {\n    input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  } else {  \n    const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype()));\n    input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz;\n  }\n  node_costs->num_input_bytes_accessed = {input_size};\n  const int64_t output_size =\n      CalculateOutputSize(op_info, &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "kdc_process_s4u2proxy_req(kdc_realm_t *kdc_active_realm,\n                          krb5_kdc_req *request,\n                          const krb5_enc_tkt_part *t2enc,\n                          const krb5_db_entry *server,\n                          krb5_const_principal server_princ,\n                          krb5_const_principal proxy_princ,\n                          const char **status)\n{\n    krb5_error_code errcode;\n    if (request->kdc_options & (NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY)) {\n        *status = \"INVALID_S4U2PROXY_OPTIONS\";\n        return KRB5KDC_ERR_BADOPTION;\n    }\n    if (!krb5_principal_compare(kdc_context,\n                                server->princ, \n                                server_princ)) {\n        *status = \"EVIDENCE_TICKET_MISMATCH\";\n        return KRB5KDC_ERR_SERVER_NOMATCH;\n    }\n    if (!isflagset(t2enc->flags, TKT_FLG_FORWARDABLE)) {\n        *status = \"EVIDENCE_TKT_NOT_FORWARDABLE\";\n        return KRB5_TKT_NOT_FORWARDABLE;\n    }\n    errcode = check_allowed_to_delegate_to(kdc_context,\n                                           t2enc->client,\n                                           server,\n                                           proxy_princ);\n    if (errcode) {\n        *status = \"NOT_ALLOWED_TO_DELEGATE\";\n        return errcode;\n    }\n    return 0;\n}", "target": 0}
{"code": "static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tstruct sem_array *sma;\n\trcu_read_lock();\n\tipcp = ipc_obtain_object(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp)) {\n\t\tsma = ERR_CAST(ipcp);\n\t\tgoto err;\n\t}\n\tspin_lock(&ipcp->lock);\n\tif (!ipcp->deleted)\n\t\treturn container_of(ipcp, struct sem_array, sem_perm);\n\tspin_unlock(&ipcp->lock);\n\tsma = ERR_PTR(-EINVAL);\nerr:\n\trcu_read_unlock();\n\treturn sma;\n}", "target": 1}
{"code": "static inline void sem_getref(struct sem_array *sma)\n{\n\tspin_lock(&(sma)->sem_perm.lock);\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "init_syntax_once ()\n{\n   register int c;\n   static int done;\n   if (done)\n     return;\n   bzero (re_syntax_table, sizeof re_syntax_table);\n   for (c = 'a'; c <= 'z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = 'A'; c <= 'Z'; c++)\n     re_syntax_table[c] = Sword;\n   for (c = '0'; c <= '9'; c++)\n     re_syntax_table[c] = Sword;\n   re_syntax_table['_'] = Sword;\n   done = 1;\n}", "target": 1}
{"code": "gboolean menu_cache_item_unref(MenuCacheItem* item)\n{\n    MENU_CACHE_LOCK; \n    if( g_atomic_int_dec_and_test( &item->n_ref ) )\n    {\n        g_free( item->id );\n        g_free( item->name );\n        g_free( item->comment );\n        g_free( item->icon );\n        menu_cache_file_dir_unref(item->file_dir);\n        if( item->file_name && item->file_name != item->id )\n            g_free( item->file_name );\n        if( item->parent )\n        {\n            item->parent->children = g_slist_remove(item->parent->children, item);\n        }\n        if( item->type == MENU_CACHE_TYPE_DIR )\n        {\n            MenuCacheDir* dir = MENU_CACHE_DIR(item);\n            GSList* l;\n            for(l = dir->children; l; )\n            {\n                MenuCacheItem* child = MENU_CACHE_ITEM(l->data);\n                child->parent = NULL;\n                l = l->next;\n                menu_cache_item_unref(child);\n            }\n            g_slist_free( dir->children );\n            g_slice_free( MenuCacheDir, dir );\n        }\n        else\n        {\n            MenuCacheApp* app = MENU_CACHE_APP(item);\n            g_free( app->exec );\n            g_free(app->try_exec);\n            g_free(app->working_dir);\n            g_free(app->categories);\n            g_free(app->keywords);\n            g_slice_free( MenuCacheApp, app );\n        }\n    }\n    MENU_CACHE_UNLOCK;\n    return FALSE;\n}", "target": 0}
{"code": "static int xennet_get_sset_count(struct net_device *dev, int string_set)\n{\n\tswitch (string_set) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(xennet_stats);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "static inline u16 skb_get_queue_mapping(const struct sk_buff *skb)\n{\n\treturn skb->queue_mapping;\n}", "target": 0}
{"code": "static int fetch_objects(struct repository *repo,\n\t\t\t const char *remote_name,\n\t\t\t const struct object_id *oids,\n\t\t\t int oid_nr)\n{\n\tstruct child_process child = CHILD_PROCESS_INIT;\n\tint i;\n\tFILE *child_in;\n\tif (git_env_bool(\"GIT_NO_LAZY_FETCH\", 0)) {\n\t\tstatic int warning_shown;\n\t\tif (!warning_shown) {\n\t\t\twarning_shown = 1;\n\t\t\twarning(_(\"lazy fetching disabled; some objects may not be available\"));\n\t\t}\n\t\treturn -1;\n\t}\n\tchild.git_cmd = 1;\n\tchild.in = -1;\n\tif (repo != the_repository)\n\t\tprepare_other_repo_env(&child.env, repo->gitdir);\n\tstrvec_pushl(&child.args, \"-c\", \"fetch.negotiationAlgorithm=noop\",\n\t\t     \"fetch\", remote_name, \"--no-tags\",\n\t\t     \"--no-write-fetch-head\", \"--recurse-submodules=no\",\n\t\t     \"--filter=blob:none\", \"--stdin\", NULL);\n\tif (start_command(&child))\n\t\tdie(_(\"promisor-remote: unable to fork off fetch subprocess\"));\n\tchild_in = xfdopen(child.in, \"w\");\n\ttrace2_data_intmax(\"promisor\", repo, \"fetch_count\", oid_nr);\n\tfor (i = 0; i < oid_nr; i++) {\n\t\tif (fputs(oid_to_hex(&oids[i]), child_in) < 0)\n\t\t\tdie_errno(_(\"promisor-remote: could not write to fetch subprocess\"));\n\t\tif (fputc('\\n', child_in) < 0)\n\t\t\tdie_errno(_(\"promisor-remote: could not write to fetch subprocess\"));\n\t}\n\tif (fclose(child_in) < 0)\n\t\tdie_errno(_(\"promisor-remote: could not close stdin to fetch subprocess\"));\n\treturn finish_command(&child) ? -1 : 0;\n}", "target": 0}
{"code": "zisofs_rewind_boot_file(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tif (iso9660->el_torito.boot->file->zisofs.header_size != 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"We cannot extract the zisofs imaged boot file;\"\n\t\t    \" this may not boot in being zisofs imaged\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static void singlevar (LexState *ls, expdesc *var) {\n  TString *varname = str_checkname(ls);\n  FuncState *fs = ls->fs;\n  singlevaraux(fs, varname, var, 1);\n  if (var->k == VVOID) {  \n    expdesc key;\n    singlevaraux(fs, ls->envn, var, 1);  \n    lua_assert(var->k != VVOID);  \n    luaK_exp2anyregup(fs, var);  \n    codestring(&key, varname);  \n    luaK_indexed(fs, var, &key);  \n  }\n}", "target": 0}
{"code": "    uint32_t TiffIfdMakernote::doSizeImage() const\n    {\n        return ifd_.sizeImage();\n    } ", "target": 0}
{"code": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n        set_description (client);\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}", "target": 1}
{"code": "static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,\n\t\t\t      int nsops)\n{\n\tint locknum;\n again:\n\tif (nsops == 1 && !sma->complex_count) {\n\t\tstruct sem *sem = sma->sem_base + sops->sem_num;\n\t\tspin_lock(&sem->lock);\n\t\tif (unlikely(sma->complex_count)) {\n\t\t\tspin_unlock(&sem->lock);\n\t\t\tgoto lock_array;\n\t\t}\n\t\tif (unlikely(spin_is_locked(&sma->sem_perm.lock))) {\n\t\t\tspin_unlock(&sem->lock);\n\t\t\tspin_unlock_wait(&sma->sem_perm.lock);\n\t\t\tgoto again;\n\t\t}\n\t\tlocknum = sops->sem_num;\n\t} else {\n\t\tint i;\n lock_array:\n\t\tspin_lock(&sma->sem_perm.lock);\n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tstruct sem *sem = sma->sem_base + i;\n\t\t\tspin_unlock_wait(&sem->lock);\n\t\t}\n\t\tlocknum = -1;\n\t}\n\treturn locknum;\n}", "target": 0}
{"code": "static inline int copy_regset_to_user(struct task_struct *target,\n\t\t\t\t      const struct user_regset_view *view,\n\t\t\t\t      unsigned int setno,\n\t\t\t\t      unsigned int offset, unsigned int size,\n\t\t\t\t      void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\tif (!regset->get)\n\t\treturn -EOPNOTSUPP;\n\tif (!access_ok(VERIFY_WRITE, data, size))\n\t\treturn -EIO;\n\treturn regset->get(target, regset, offset, size, NULL, data);\n}", "target": 0}
{"code": "assegment_dup_all (struct assegment *seg)\n{\n  struct assegment *new = NULL;\n  struct assegment *head = NULL;\n  while (seg)\n    {\n      if (head)\n        {\n          new->next = assegment_dup (seg);\n          new = new->next;\n        }\n      else\n        head = new = assegment_dup (seg);\n      seg = seg->next;\n    }\n  return head;\n}", "target": 0}
{"code": "static __exit void sctp_exit(void)\n{\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\tunregister_pernet_subsys(&sctp_net_ops);\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\trcu_barrier(); \n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}", "target": 1}
{"code": "static int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t   unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timespec(up, &kts);\n\treturn err;\n}", "target": 1}
{"code": "static void process_event_record(MYSQL_THD thd, LEX_CSTRING event_name,\n                                 const char *data, size_t data_length)\n{\n  const char *record_str = (const char *)THDVAR(thd, event_record_def);\n  LEX_CSTRING record_begin = get_token(&record_str);\n  LEX_CSTRING record_end = get_token(&record_str);\n  if (record_str == NULL)\n  {\n    return;\n  }\n  if (record_end.length == 0)\n  {\n    const char *buffer= THDVAR(thd, event_record);\n    add_event(thd, buffer, event_name, data, data_length);\n    my_free((void *)(buffer));\n    if (!my_charset_latin1.coll->strnncoll(&my_charset_latin1,\n                                           (const uchar *)record_begin.str,\n                                           record_begin.length,\n                                           (const uchar *)event_name.str,\n                                           event_name.length, FALSE))\n    {\n      THDVAR(thd, event_record_def)= 0;\n    }\n  }\n  else\n  {\n    const char *buffer;\n    if (my_charset_latin1.coll->strnncoll(&my_charset_latin1,\n                                          (const uchar *)record_begin.str,\n                                          record_begin.length,\n                                          (const uchar *)event_name.str,\n                                          event_name.length, FALSE))\n    {\n      return;\n    }\n    buffer= THDVAR(thd, event_record);\n    my_free((void *)(buffer));\n    THDVAR(thd, event_record)= 0;\n    add_event(thd, \"\", event_name, data, data_length);\n    record_str = (const char *)THDVAR(thd, event_record_def);\n    memmove((char *)record_str, (void *)record_end.str, record_end.length + 1);\n  }\n}", "target": 0}
{"code": "setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "deltas_head_destroy(struct deltas_head *deltas)\n{\n\tdeltas_head_cleanup(deltas);\n\tfree(deltas);\n}", "target": 1}
{"code": "Status TensorSlice::BuildTensorSlice(const TensorSliceProto& proto,\n                                     TensorSlice* output) {\n  output->Clear();\n  output->starts_.reserve(proto.extent_size());\n  output->lengths_.reserve(proto.extent_size());\n  for (const auto& e : proto.extent()) {\n    int64_t l = GetExtentLength(e);\n    if (e.start() != 0 || l != kFullExtent) {\n      if (e.start() < 0 || l <= 0) {\n        return errors::InvalidArgument(\n            \"Expected non-negative start and positive length but got start = \",\n            e.start(), \", length = \", l, \": extent = \", e.ShortDebugString());\n      }\n      if (static_cast<uint64_t>(e.start()) + static_cast<uint64_t>(e.length()) >\n          std::numeric_limits<int64_t>::max()) {\n        return errors::InvalidArgument(\n            \"Extent end exceeds the maximum possible size: extent = \",\n            e.ShortDebugString());\n      }\n    }\n    output->starts_.push_back(e.start());\n    output->lengths_.push_back(l);\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "  TfLiteRegistration CopyOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n      TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n      TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n      return context->ResizeTensor(context, tensor1, newSize);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      CallReporting* call_reporting =\n          static_cast<CallReporting*>(node->builtin_data);\n      const TfLiteTensor* a0 = GetInput(context, node, 0);\n      TfLiteTensor* a1 = GetOutput(context, node, 0);\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        a1->data.f[i] = a0->data.f[i];\n      }\n      call_reporting->Record();\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "void mp_encode_lua_table_as_array(lua_State *L, mp_buf *buf, int level) {\n#if LUA_VERSION_NUM < 502\n    size_t len = lua_objlen(L,-1), j;\n#else\n    size_t len = lua_rawlen(L,-1), j;\n#endif\n    mp_encode_array(L,buf,len);\n    luaL_checkstack(L, 1, \"in function mp_encode_lua_table_as_array\");\n    for (j = 1; j <= len; j++) {\n        lua_pushnumber(L,j);\n        lua_gettable(L,-2);\n        mp_encode_lua_type(L,buf,level+1);\n    }\n}", "target": 0}
{"code": "static void make_response(struct xen_blkif_ring *ring, u64 id,\n\t\t\t  unsigned short op, int st)\n{\n\tstruct blkif_response  resp;\n\tunsigned long     flags;\n\tunion blkif_back_rings *blk_rings;\n\tint notify;\n\tresp.id        = id;\n\tresp.operation = op;\n\tresp.status    = st;\n\tspin_lock_irqsave(&ring->blk_ring_lock, flags);\n\tblk_rings = &ring->blk_rings;\n\tswitch (ring->blkif->blk_protocol) {\n\tcase BLKIF_PROTOCOL_NATIVE:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->native, blk_rings->native.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_32:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_32, blk_rings->x86_32.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tcase BLKIF_PROTOCOL_X86_64:\n\t\tmemcpy(RING_GET_RESPONSE(&blk_rings->x86_64, blk_rings->x86_64.rsp_prod_pvt),\n\t\t       &resp, sizeof(resp));\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tblk_rings->common.rsp_prod_pvt++;\n\tRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);\n\tspin_unlock_irqrestore(&ring->blk_ring_lock, flags);\n\tif (notify)\n\t\tnotify_remote_via_irq(ring->irq);\n}", "target": 1}
{"code": "static int discovery_stop(struct discovery_client *client)\n{\n\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\tif (adapter->discovery_discoverable)\n\t\tset_discovery_discoverable(adapter, false);\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");\n\t\ttrigger_passive_scanning(adapter);\n\t\treturn 0;\n\t}\n\tcp.type = adapter->discovery_type;\n\tadapter->client = client;\n\tmgmt_send(adapter->mgmt, MGMT_OP_STOP_DISCOVERY,\n\t\t\tadapter->dev_id, sizeof(cp), &cp,\n\t\t\tstop_discovery_complete, adapter, NULL);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "const char *GetClipboardText(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return glfwGetClipboardString(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script_string(\"navigator.clipboard.readText() \\\n        .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\\n        .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"\n    );\n    return NULL;\n#endif\n    return NULL;\n}", "target": 1}
{"code": "error::Error GLES2DecoderImpl::HandleGetUniformfv(\n    uint32 immediate_data_size, const gles2::GetUniformfv& c) {\n  GLuint program = c.program;\n  GLint fake_location = program_manager()->UnswizzleLocation(c.location);\n  GLuint service_id;\n  GLint real_location = -1;\n  Error error;\n  typedef gles2::GetUniformfv::Result Result;\n  Result* result;\n  GLenum result_type;\n  if (GetUniformSetup(\n      program, fake_location, c.params_shm_id, c.params_shm_offset,\n      &error, &real_location, &service_id,\n      reinterpret_cast<void**>(&result), &result_type)) {\n    if (result_type == GL_BOOL || result_type == GL_BOOL_VEC2 ||\n        result_type == GL_BOOL_VEC3 || result_type == GL_BOOL_VEC4) {\n      GLsizei num_values = result->GetNumResults();\n      scoped_array<GLint> temp(new GLint[num_values]);\n      glGetUniformiv(service_id, real_location, temp.get());\n      GLfloat* dst = result->GetData();\n      for (GLsizei ii = 0; ii < num_values; ++ii) {\n        dst[ii] = (temp[ii] != 0);\n      }\n    } else {\n      glGetUniformfv(service_id, real_location, result->GetData());\n    }\n  }\n  return error;\n}", "target": 0}
{"code": "l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tprint_16bits_val(ndo, (const uint16_t *)dat);\n\tND_PRINT((ndo, \", %02x\", dat[2]));\n\tif (length > 3) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, dat+3, length-3);\n\t}\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.rtv_annotations_attr.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "int DynamicMetadataMapIterator::luaPairsIterator(lua_State* state) {\n  if (current_ == parent_.streamInfo().dynamicMetadata().filter_metadata().end()) {\n    parent_.iterator_.reset();\n    return 0;\n  }\n  lua_pushstring(state, current_->first.c_str());\n  Filters::Common::Lua::MetadataMapHelper::createTable(state, current_->second.fields());\n  current_++;\n  return 2;\n}", "target": 0}
{"code": "static int __init dev_prepare_static_identity_mapping(struct device *dev, int hw)\n{\n\tint ret;\n\tif (!iommu_should_identity_map(dev, 1))\n\t\treturn 0;\n\tret = domain_add_dev_info(si_domain, dev);\n\tif (!ret)\n\t\tdev_info(dev, \"%s identity mapping\\n\",\n\t\t\t hw ? \"Hardware\" : \"Software\");\n\telse if (ret == -ENODEV)\n\t\tret = 0;\n\treturn ret;\n}", "target": 0}
{"code": "sshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tgoto fail;\n\t}\n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n\t\treturn ret;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tversion = ret->sk_api_version();\n\tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,\n\t    (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}", "target": 1}
{"code": "TfLiteStatus EvalHashtableFind(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* default_value_tensor =\n      GetInput(context, node, kDefaultValueTensor);\n  TfLiteTensor* output_tensor = GetOutput(context, node, 0);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      lookup->CheckKeyAndValueTypes(context, key_tensor, output_tensor));\n  auto result =\n      lookup->Lookup(context, key_tensor, output_tensor, default_value_tensor);\n  return result;\n}", "target": 1}
{"code": "static int sd_compat_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct scsi_device *sdev = scsi_disk(bdev->bd_disk)->device;\n\tif (!scsi_block_when_processing_errors(sdev))\n\t\treturn -ENODEV;\n\tif (sdev->host->hostt->compat_ioctl) {\n\t\tint ret;\n\t\tret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);\n\t\treturn ret;\n\t}\n\treturn -ENOIOCTLCMD; \n}", "target": 1}
{"code": "char *reds_get_video_codec_fullname(RedVideoCodec *codec)\n{\n    int i;\n    const char *encoder_name = NULL;\n    const char *codec_name = get_index_name(video_codec_names, codec->type);\n    spice_assert(codec_name);\n    for (i = 0; i < G_N_ELEMENTS(video_encoder_procs); i++) {\n        if (video_encoder_procs[i] == codec->create) {\n            encoder_name = get_index_name(video_encoder_names, i);\n            break;\n        }\n    }\n    spice_assert(encoder_name);\n    return g_strdup_printf(\"%s:%s\", encoder_name, codec_name);\n}", "target": 0}
{"code": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}", "target": 1}
{"code": "static void simple_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                              int bits, int row, int row_stride)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n  if (row*row_stride > ID->data_size - (ID->columns*sizeof(uint32_t)))\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  uint32_t *data = (uint32_t *)((unsigned char *)ID->data + row * row_stride);\n  uint16_t c[3] = {0, 0, 0};\n  int col;\n  uint32_t mask = 0;\n  switch (bits)\n  {\n  case 8:\n    mask = 0x0ff;\n    break;\n  case 9:\n    mask = 0x1ff;\n    break;\n  case 10:\n    mask = 0x3ff;\n    break;\n  case 11:\n    mask = 0x7ff;\n    break;\n  case 12:\n    mask = 0xfff;\n    break;\n  default:\n    mask = 0;\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    break;\n  }\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n    uint32_t val = data[col];\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n      c[color] += get_simple_diff(HUF, (val >> (color * bits)) & mask);\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        c_fix = (int16_t)c[color] > 0 ? c[color] : 0;\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] = c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        c_fix = (int8_t)c[color] > 0 ? c[color] : 0;\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = c_fix;\n        break;\n      default:\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}", "target": 0}
{"code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\tkey_ref = lookup_user_key(id, 0, KEY_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\tret = key_update(key_ref, payload, plen);\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)\n{\n    ap_mutex_init(pconf);\n    if (!saved_server_config_defines)\n        init_config_defines(pconf);\n    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,\n                              apr_pool_cleanup_null);\n    mpm_common_pre_config(pconf);\n    return OK;\n}", "target": 0}
{"code": "bool use_client_socket(int fd, PgAddr *addr,\n\t\t       const char *dbname, const char *username,\n\t\t       uint64_t ckey, int oldfd, int linkfd,\n\t\t       const char *client_enc, const char *std_string,\n\t\t       const char *datestyle, const char *timezone)\n{\n\tPgSocket *client;\n\tPktBuf tmp;\n\tclient = accept_client(fd, pga_is_unix(addr));\n\tif (client == NULL)\n\t\treturn false;\n\tclient->suspended = 1;\n\tif (!set_pool(client, dbname, username))\n\t\treturn false;\n\tchange_client_state(client, CL_ACTIVE);\n\tpktbuf_static(&tmp, client->cancel_key, 8);\n\tpktbuf_put_uint64(&tmp, ckey);\n\tclient->tmp_sk_oldfd = oldfd;\n\tclient->tmp_sk_linkfd = linkfd;\n\tvarcache_set(&client->vars, \"client_encoding\", client_enc);\n\tvarcache_set(&client->vars, \"standard_conforming_strings\", std_string);\n\tvarcache_set(&client->vars, \"datestyle\", datestyle);\n\tvarcache_set(&client->vars, \"timezone\", timezone);\n\treturn true;\n}", "target": 0}
{"code": "coolkey_get_attribute_bytes(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE type, u8 *data, size_t *data_len, size_t max_data_len)\n{\n\tconst u8 *val;\n\tsize_t val_len;\n\tint r;\n\tr = coolkey_get_attribute(card, obj, type, &val, &val_len, NULL);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tif (val_len > max_data_len) {\n\t\tval_len = max_data_len;\n\t}\n\tmemcpy(data, val, val_len);\n\t*data_len = val_len;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 3>::ConstTensor input,\n                  bool signed_input, int num_bits, bool range_given,\n                  Tensor* input_min_tensor, Tensor* input_max_tensor,\n                  QuantizerRoundMode round_mode, bool narrow_range,\n                  typename TTypes<T, 3>::Tensor out) {\n    QuantizeAndDequantizePerChannelImpl<CPUDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }", "target": 1}
{"code": "TEST_F(QuantizeDownAndShrinkRangeTest, HandCrafted) {\n  TF_ASSERT_OK(NodeDefBuilder(\"quantize_down_and_shrink_range_op\",\n                              \"QuantizeDownAndShrinkRange\")\n                   .Input(FakeInput(DT_QINT32))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Input(FakeInput(DT_FLOAT))\n                   .Attr(\"Tinput\", DataTypeToEnum<qint32>::v())\n                   .Attr(\"out_type\", DataTypeToEnum<quint8>::v())\n                   .Finalize(node_def()));\n  TF_ASSERT_OK(InitOp());\n  const int value_count = 3;\n  AddInputFromArray<qint32>(TensorShape({value_count}),\n                            {-(1 << 23), 0, (1 << 23)});\n  AddInputFromArray<float>(TensorShape({1}), {-256.0f});\n  AddInputFromArray<float>(TensorShape({1}), {256.0f});\n  TF_ASSERT_OK(RunOpKernel());\n  Tensor expected(allocator(), DT_QUINT8, TensorShape({value_count}));\n  test::FillValues<quint8>(&expected, {0, 128, 255});\n  test::ExpectTensorEqual<quint8>(expected, *GetOutput(0));\n  Tensor expected_min(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_min, {-1.0f});\n  test::ExpectTensorEqual<float>(expected_min, *GetOutput(1));\n  Tensor expected_max(allocator(), DT_FLOAT, TensorShape({}));\n  test::FillValues<float>(&expected_max, {1.0f});\n  test::ExpectTensorEqual<float>(expected_max, *GetOutput(2));\n}", "target": 1}
{"code": "DLLIMPORT const char *cfg_title(cfg_t *cfg)\n{\n\tif (cfg)\n\t\treturn cfg->title;\n\treturn NULL;\n}", "target": 0}
{"code": "static int __init pcd_init(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpcd_init_units();\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\tpcd_probe_capabilities();\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n\t\t\tput_disk(cd->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int bcm_delete_rx_op(struct list_head *ops, struct bcm_msg_head *mh,\n\t\t\t    int ifindex)\n{\n\tstruct bcm_op *op, *n;\n\tlist_for_each_entry_safe(op, n, ops, list) {\n\t\tif ((op->can_id == mh->can_id) && (op->ifindex == ifindex) &&\n\t\t    (op->flags & CAN_FD_FRAME) == (mh->flags & CAN_FD_FRAME)) {\n\t\t\tif (op->ifindex) {\n\t\t\t\tif (op->rx_reg_dev) {\n\t\t\t\t\tstruct net_device *dev;\n\t\t\t\t\tdev = dev_get_by_index(sock_net(op->sk),\n\t\t\t\t\t\t\t       op->ifindex);\n\t\t\t\t\tif (dev) {\n\t\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\t\tdev_put(dev);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcan_rx_unregister(sock_net(op->sk), NULL,\n\t\t\t\t\t\t  op->can_id,\n\t\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t\t  bcm_rx_handler, op);\n\t\t\tlist_del(&op->list);\n\t\t\tsynchronize_rcu();\n\t\t\tbcm_remove_op(op);\n\t\t\treturn 1; \n\t\t}\n\t}\n\treturn 0; \n}", "target": 0}
{"code": "ppp_unregister_channel(struct ppp_channel *chan)\n{\n\tstruct channel *pch = chan->ppp;\n\tstruct ppp_net *pn;\n\tif (!pch)\n\t\treturn;\t\t\n\tchan->ppp = NULL;\n\tdown_write(&pch->chan_sem);\n\tspin_lock_bh(&pch->downl);\n\tpch->chan = NULL;\n\tspin_unlock_bh(&pch->downl);\n\tup_write(&pch->chan_sem);\n\tppp_disconnect_channel(pch);\n\tpn = ppp_pernet(pch->chan_net);\n\tspin_lock_bh(&pn->all_channels_lock);\n\tlist_del(&pch->list);\n\tspin_unlock_bh(&pn->all_channels_lock);\n\tput_net(pch->chan_net);\n\tpch->chan_net = NULL;\n\tpch->file.dead = 1;\n\twake_up_interruptible(&pch->file.rwait);\n\tif (atomic_dec_and_test(&pch->file.refcnt))\n\t\tppp_destroy_channel(pch);\n}", "target": 0}
{"code": "static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\tif ((unsigned long)key & POLLFREE) {\n\t\tep_pwq_from_wait(wait)->whead = NULL;\n\t\tlist_del_init(&wait->task_list);\n\t}\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\tif (key && !((unsigned long) key & epi->event.events))\n\t\tgoto out_unlock;\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\tif (!ep_is_linked(&epi->rdllink))\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\tif (waitqueue_active(&ep->wq))\n\t\twake_up_locked(&ep->wq);\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\nout_unlock:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\treturn 1;\n}", "target": 0}
{"code": "call_handler (SoupMessage *req, SoupClientContext *client)\n{\n\tSoupServer *server = client->server;\n\tSoupServerHandler *hand;\n\tSoupURI *uri;\n\tg_signal_emit (server, signals[REQUEST_READ], 0, req, client);\n\tif (req->status_code != 0)\n\t\treturn;\n\turi = soup_message_get_uri (req);\n\thand = soup_server_get_handler (server, uri->path);\n\tif (!hand) {\n\t\tsoup_message_set_status (req, SOUP_STATUS_NOT_FOUND);\n\t\treturn;\n\t}\n\tif (hand->callback) {\n\t\tGHashTable *form_data_set;\n\t\tif (uri->query)\n\t\t\tform_data_set = soup_form_decode (uri->query);\n\t\telse\n\t\t\tform_data_set = NULL;\n\t\t(*hand->callback) (server, req,\n\t\t\t\t   uri->path, form_data_set,\n\t\t\t\t   client, hand->user_data);\n\t\tif (form_data_set)\n\t\t\tg_hash_table_destroy (form_data_set);\n\t}\n}", "target": 0}
{"code": "static int jp2_pclr_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_pclr_t *pclr = &box->data.pclr;\n\tint lutsize;\n\tunsigned int i;\n\tunsigned int j;\n\tint_fast32_t x;\n\tpclr->lutdata = 0;\n\tpclr->bpc = 0;\n\tif (jp2_getuint16(in, &pclr->numlutents) ||\n\t  jp2_getuint8(in, &pclr->numchans)) {\n\t\treturn -1;\n\t}\n\tlutsize = pclr->numlutents * pclr->numchans;\n\tif (!(pclr->lutdata = jas_alloc2(lutsize, sizeof(int_fast32_t)))) {\n\t\treturn -1;\n\t}\n\tif (!(pclr->bpc = jas_alloc2(pclr->numchans, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < pclr->numchans; ++i) {\n\t\tif (jp2_getuint8(in, &pclr->bpc[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = 0; i < pclr->numlutents; ++i) {\n\t\tfor (j = 0; j < pclr->numchans; ++j) {\n\t\t\tif (jp2_getint(in, (pclr->bpc[j] & 0x80) != 0,\n\t\t\t  (pclr->bpc[j] & 0x7f) + 1, &x)) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tpclr->lutdata[i * pclr->numchans + j] = x;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "exim_tvcmp(struct timeval *t1, struct timeval *t2)\n{\nif (t1->tv_sec > t2->tv_sec) return +1;\nif (t1->tv_sec < t2->tv_sec) return -1;\nif (t1->tv_usec > t2->tv_usec) return +1;\nif (t1->tv_usec < t2->tv_usec) return -1;\nreturn 0;\n}", "target": 0}
{"code": "GopherStateData::DelayAwareRead(GopherStateData *gopherState)\n{\n    const auto &conn = gopherState->serverConn;\n    if (!Comm::IsConnOpen(conn) || fd_table[conn->fd].closing()) {\n        debugs(10, 3, \"will not read from \" << conn);\n        return;\n    }\n    const auto amountToRead = gopherState->entry->bytesWanted(Range<size_t>(0, BUFSIZ));\n    if (amountToRead <= 0) {\n        AsyncCall::Pointer delayCall = asyncCall(10, 3, \"GopherStateData::DelayAwareRead\",\n                                       cbdataDialer(&GopherStateData::DelayAwareRead, gopherState));\n        gopherState->entry->mem().delayRead(delayCall);\n        return;\n    }\n    AsyncCall::Pointer readCall = commCbCall(5, 5, \"gopherReadReply\", CommIoCbPtrFun(gopherReadReply, gopherState));\n    comm_read(conn, gopherState->replybuf, amountToRead, readCall);\n}", "target": 1}
{"code": "  QInt32() {}", "target": 1}
{"code": "static int head_onwire_len(int ctrl_len, bool secure)\n{\n\tint head_len;\n\tint rem_len;\n\tBUG_ON(ctrl_len < 0 || ctrl_len > CEPH_MSG_MAX_CONTROL_LEN);\n\tif (secure) {\n\t\thead_len = CEPH_PREAMBLE_SECURE_LEN;\n\t\tif (ctrl_len > CEPH_PREAMBLE_INLINE_LEN) {\n\t\t\trem_len = ctrl_len - CEPH_PREAMBLE_INLINE_LEN;\n\t\t\thead_len += padded_len(rem_len) + CEPH_GCM_TAG_LEN;\n\t\t}\n\t} else {\n\t\thead_len = CEPH_PREAMBLE_PLAIN_LEN;\n\t\tif (ctrl_len)\n\t\t\thead_len += ctrl_len + CEPH_CRC_LEN;\n\t}\n\treturn head_len;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, output->quantization.type,\n                    kTfLiteAffineQuantization);\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(output->quantization.params);\n  TF_LITE_ENSURE(context, affine_quantization);\n  TF_LITE_ENSURE(context, affine_quantization->scale);\n  TF_LITE_ENSURE(context, affine_quantization->scale->size == 1);\n  TF_LITE_ENSURE(context, input->type == kTfLiteFloat32 ||\n                              input->type == kTfLiteInt16 ||\n                              input->type == kTfLiteInt8);\n  TF_LITE_ENSURE(context, output->type == kTfLiteUInt8 ||\n                              output->type == kTfLiteInt8 ||\n                              output->type == kTfLiteInt16);\n  if (((input->type == kTfLiteInt16 || input->type == kTfLiteInt8) &&\n       output->type == kTfLiteInt8) ||\n      (input->type == kTfLiteInt16 && output->type == kTfLiteInt16)) {\n    double effective_scale = static_cast<double>(input->params.scale) /\n                             static_cast<double>(output->params.scale);\n    QuantizeMultiplier(effective_scale, &data->output_multiplier,\n                       &data->output_shift);\n  }\n  data->quantization_params.zero_point = output->params.zero_point;\n  data->quantization_params.scale = static_cast<double>(output->params.scale);\n  data->input_zero_point = input->params.zero_point;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void nft_byteorder_eval(const struct nft_expr *expr,\n\t\t\tstruct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 *src = &regs->data[priv->sreg];\n\tu32 *dst = &regs->data[priv->dreg];\n\tu16 *s16, *d16;\n\tunsigned int i;\n\ts16 = (void *)src;\n\td16 = (void *)dst;\n\tswitch (priv->size) {\n\tcase 8: {\n\t\tu64 src64;\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = nft_reg_load64(&src[i]);\n\t\t\t\tnft_reg_store64(&dst[i],\n\t\t\t\t\t\tbe64_to_cpu((__force __be64)src64));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = (__force __u64)\n\t\t\t\t\tcpu_to_be64(nft_reg_load64(&src[i]));\n\t\t\t\tnft_reg_store64(&dst[i], src64);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = ntohl((__force __be32)src[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = (__force __u32)htonl(src[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = ntohs((__force __be16)s16[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = (__force __u16)htons(s16[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "void rdp_read_flow_control_pdu(wStream* s, UINT16* type)\n{\n\tUINT8 pduType;\n\tStream_Read_UINT8(s, pduType); \n\t*type = pduType;\n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT8(s);  \n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, addr, R_BUF_SET);\n\tmodule->base_of_image = r_buf_read_le64 (b);\n\tmodule->size_of_image = r_buf_read_le32 (b);\n\tmodule->check_sum = r_buf_read_le32 (b);\n\tmodule->time_date_stamp = r_buf_read_le32 (b);\n\tmodule->module_name_rva = r_buf_read_le32 (b);\n\tmodule->version_info.dw_signature = r_buf_read_le32 (b);\n\tmodule->version_info.dw_struc_version = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags_mask = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_os = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_type = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_subtype = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ls = r_buf_read_le32 (b);\n\tmodule->cv_record.data_size = r_buf_read_le32 (b);\n\tmodule->cv_record.rva = r_buf_read_le32 (b);\n\tmodule->misc_record.data_size = r_buf_read_le32 (b);\n\tmodule->misc_record.rva = r_buf_read_le32 (b);\n\tmodule->reserved_0 = r_buf_read_le64 (b);\n\tmodule->reserved_1 = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}", "target": 1}
{"code": "TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index) {\n  TfLiteTensor* tensor = GetMutableInput(context, node, index);\n  if (tensor == nullptr) return nullptr;\n  return tensor->is_variable ? tensor : nullptr;\n}", "target": 0}
{"code": "static Sdb *get_gnu_verneed(ELFOBJ *bin) {\n\tut64 verneed_addr;\n\tut64 verneed_num;\n\tif (!Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEED, &verneed_addr) || !Elf_(rz_bin_elf_get_dt_info)(bin, DT_VERNEEDNUM, &verneed_num)) {\n\t\treturn NULL;\n\t}\n\tut64 verneed_offset = Elf_(rz_bin_elf_v2p(bin, verneed_addr));\n\tif (verneed_offset == UT64_MAX) {\n\t\tRZ_LOG_WARN(\"Failed to convert verneed virtual address to physical address.\\n\");\n\t\treturn NULL;\n\t}\n\tSdb *sdb = sdb_new0();\n\tif (!sdb) {\n\t\treturn NULL;\n\t}\n\tif (!sdb_num_set(sdb, \"num_entries\", verneed_num, 0) ||\n\t\t!sdb_num_set(sdb, \"addr\", verneed_addr, 0) ||\n\t\t!sdb_num_set(sdb, \"offset\", verneed_offset, 0)) {\n\t\tsdb_free(sdb);\n\t\treturn NULL;\n\t}\n\tfor (size_t i = 0; i < verneed_num; i++) {\n\t\tElf_(Verneed) verneed_entry;\n\t\tif (!get_verneed_entry(bin, verneed_offset, &verneed_entry)) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tSdb *sdb_version = get_verneed_entry_sdb(bin, verneed_entry, verneed_offset);\n\t\tif (!sdb_version) {\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tchar key[32];\n\t\tif (!sdb_ns_set(sdb, rz_strf(key, \"version%zu\", i), sdb_version)) {\n\t\t\tsdb_free(sdb_version);\n\t\t\tsdb_free(sdb);\n\t\t\treturn NULL;\n\t\t}\n\t\tsdb_free(sdb_version);\n\t\tif (!verneed_entry.vn_next) {\n\t\t\tbreak;\n\t\t}\n\t\tverneed_offset += verneed_entry.vn_next;\n\t}\n\treturn sdb;\n}", "target": 0}
{"code": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\treturn result;\n}", "target": 1}
{"code": "static void vm_unlock_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_node)) {\n\t\tif (!__test_and_clear_bit(0, (unsigned long *)\n\t\t\t\t\t  &anon_vma->root->rb_root.rb_node))\n\t\t\tBUG();\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n}", "target": 0}
{"code": "int mnt_fs_is_deleted(struct libmnt_fs *fs)\n{\n\treturn mnt_fs_get_flags(fs) & MNT_FS_DELETED;\n}", "target": 1}
{"code": "void hostap_setup_dev(struct net_device *dev, local_info_t *local,\n\t\t      int type)\n{\n\tstruct hostap_interface *iface;\n\tiface = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tif (iface) {\n\t\tiface->wireless_data.spy_data = &iface->spy_data;\n\t\tdev->wireless_data = &iface->wireless_data;\n\t}\n\tdev->wireless_handlers = &hostap_iw_handler_def;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\tswitch(type) {\n\tcase HOSTAP_INTERFACE_AP:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_mgmt_netdev_ops;\n\t\tdev->type = ARPHRD_IEEE80211;\n\t\tdev->header_ops = &hostap_80211_ops;\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_MASTER:\n\t\tdev->netdev_ops = &hostap_master_ops;\n\t\tbreak;\n\tdefault:\n\t\tdev->tx_queue_len = 0;\t\n\t\tdev->netdev_ops = &hostap_netdev_ops;\n\t}\n\tdev->mtu = local->mtu;\n\tSET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);\n}", "target": 0}
{"code": "raw_copy_from_user(void *to, const void __user *from, unsigned long n)\n{\n\tif (__builtin_constant_p(n)) {\n\t\tunsigned long ret;\n\t\tswitch (n) {\n\t\tcase 1:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u8 *)to, from, ret,\n\t\t\t\t\t      \"b\", \"b\", \"=q\", 1);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\tcase 2:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u16 *)to, from, ret,\n\t\t\t\t\t      \"w\", \"w\", \"=r\", 2);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\tcase 4:\n\t\t\tret = 0;\n\t\t\t__uaccess_begin_nospec();\n\t\t\t__get_user_asm_nozero(*(u32 *)to, from, ret,\n\t\t\t\t\t      \"l\", \"k\", \"=r\", 4);\n\t\t\t__uaccess_end();\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn __copy_user_ll(to, (__force const void *)from, n);\n}", "target": 1}
{"code": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "int password_equal(const char *user_input, const char *secret) {\n    size_t i = 0;\n    size_t j = 0;\n    char out = 0;\n    while (1) {\n        out |= user_input[i] ^ secret[j];\n        if (user_input[i] == 0) break;\n        i++;\n        if (secret[j] != 0) j++;\n    }\n    out |= (i != j); \n    out |= (secret[j] != 0); \n    return out == 0;\n}", "target": 0}
{"code": "handle_mlppp(netdissect_options *ndo,\n             const u_char *p, int length)\n{\n    if (!ndo->ndo_eflag)\n        ND_PRINT((ndo, \"MLPPP, \"));\n    if (length < 2) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    if (!ND_TTEST_16BITS(p)) {\n        ND_PRINT((ndo, \"[|mlppp]\"));\n        return;\n    }\n    ND_PRINT((ndo, \"seq 0x%03x, Flags [%s], length %u\",\n           (EXTRACT_16BITS(p))&0x0fff, \n           bittok2str(ppp_ml_flag_values, \"none\", *p & 0xc0),\n           length));\n}", "target": 0}
{"code": "void CSecurityTLS::shutdown(bool needbye)\n{\n  if (session && needbye)\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS)\n      vlog.error(\"gnutls_bye failed\");\n  if (anon_cred) {\n    gnutls_anon_free_client_credentials(anon_cred);\n    anon_cred = 0;\n  }\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n    gnutls_global_deinit();\n  }\n}", "target": 1}
{"code": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\tdvb_usbv2_exit(d);\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n}", "target": 1}
{"code": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\tkey->expiry = prep->expiry;\n\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}", "target": 1}
{"code": "bool Mfcc::Initialize(int input_length, double input_sample_rate) {\n  bool initialized = mel_filterbank_.Initialize(\n      input_length, input_sample_rate, filterbank_channel_count_,\n      lower_frequency_limit_, upper_frequency_limit_);\n  initialized &=\n      dct_.Initialize(filterbank_channel_count_, dct_coefficient_count_);\n  initialized_ = initialized;\n  return initialized;\n}", "target": 1}
{"code": "static bool is_legal_file(const std::string &filename)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn false;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn false;\n\t}\n\tif (looks_like_pbl(filename)) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "rb_decrement_entry(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t   struct ring_buffer_event *event)\n{\n\tunsigned long addr = (unsigned long)event;\n\tstruct buffer_page *bpage = cpu_buffer->commit_page;\n\tstruct buffer_page *start;\n\taddr &= PAGE_MASK;\n\tif (likely(bpage->page == (void *)addr)) {\n\t\tlocal_dec(&bpage->entries);\n\t\treturn;\n\t}\n\trb_inc_page(cpu_buffer, &bpage);\n\tstart = bpage;\n\tdo {\n\t\tif (bpage->page == (void *)addr) {\n\t\t\tlocal_dec(&bpage->entries);\n\t\t\treturn;\n\t\t}\n\t\trb_inc_page(cpu_buffer, &bpage);\n\t} while (bpage != start);\n\tRB_WARN_ON(cpu_buffer, 1);\n}", "target": 0}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->input,\n                                               sgx_params->input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 1}
{"code": "GF_Err Media_CheckDataEntry(GF_MediaBox *mdia, u32 dataEntryIndex)\n{\n\tGF_DataEntryURLBox *entry;\n\tGF_DataMap *map;\n\tGF_Err e;\n\tif (!mdia || !dataEntryIndex || dataEntryIndex > gf_list_count(mdia->information->dataInformation->dref->child_boxes)) return GF_BAD_PARAM;\n\tentry = (GF_DataEntryURLBox*)gf_list_get(mdia->information->dataInformation->dref->child_boxes, dataEntryIndex - 1);\n\tif (!entry) return GF_ISOM_INVALID_FILE;\n\tif (entry->flags == 1) return GF_OK;\n\tif (entry->type == GF_ISOM_BOX_TYPE_URN) return GF_NOT_SUPPORTED;\n\tif (mdia->mediaTrack->moov->mov->openMode == GF_ISOM_OPEN_WRITE) {\n\t\te = gf_isom_datamap_new(entry->location, NULL, GF_ISOM_DATA_MAP_READ, &map);\n\t} else {\n\t\te = gf_isom_datamap_new(entry->location, mdia->mediaTrack->moov->mov->fileName, GF_ISOM_DATA_MAP_READ, &map);\n\t}\n\tif (e) return e;\n\tgf_isom_datamap_del(map);\n\treturn GF_OK;\n}", "target": 1}
{"code": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}", "target": 1}
{"code": "int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tu32 tsk_portid = cb->args[0];\n\tu32 last_publ = cb->args[1];\n\tu32 done = cb->args[2];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_sock *tsk;\n\tif (!tsk_portid) {\n\t\tstruct nlattr **attrs;\n\t\tstruct nlattr *sock[TIPC_NLA_SOCK_MAX + 1];\n\t\terr = tipc_nlmsg_parse(cb->nlh, &attrs);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!attrs[TIPC_NLA_SOCK])\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX,\n\t\t\t\t       attrs[TIPC_NLA_SOCK],\n\t\t\t\t       tipc_nl_sock_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!sock[TIPC_NLA_SOCK_REF])\n\t\t\treturn -EINVAL;\n\t\ttsk_portid = nla_get_u32(sock[TIPC_NLA_SOCK_REF]);\n\t}\n\tif (done)\n\t\treturn 0;\n\ttsk = tipc_sk_lookup(net, tsk_portid);\n\tif (!tsk)\n\t\treturn -EINVAL;\n\tlock_sock(&tsk->sk);\n\terr = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);\n\tif (!err)\n\t\tdone = 1;\n\trelease_sock(&tsk->sk);\n\tsock_put(&tsk->sk);\n\tcb->args[0] = tsk_portid;\n\tcb->args[1] = last_publ;\n\tcb->args[2] = done;\n\treturn skb->len;\n}", "target": 0}
{"code": "void CommandData::ProcessCommand()\n{\n#ifndef SFX_MODULE\n  const wchar *SingleCharCommands=L\"FUADPXETK\";\n  if (Command[0]!=0 && Command[1]!=0 && wcschr(SingleCharCommands,Command[0])!=NULL || *ArcName==0)\n    OutHelp(*Command==0 ? RARX_SUCCESS:RARX_USERERROR); \n  const wchar *ArcExt=GetExt(ArcName);\n#ifdef _UNIX\n  if (ArcExt==NULL && (!FileExist(ArcName) || IsDir(GetFileAttr(ArcName))))\n    wcsncatz(ArcName,L\".rar\",ASIZE(ArcName));\n#else\n  if (ArcExt==NULL)\n    wcsncatz(ArcName,L\".rar\",ASIZE(ArcName));\n#endif\n  if (ArcExt!=NULL && wcsnicomp(ArcExt,L\".part\",5)==0 && IsDigit(ArcExt[5]) &&\n      !FileExist(ArcName))\n  {\n    wchar Name[NM];\n    wcsncpyz(Name,ArcName,ASIZE(Name));\n    wcsncatz(Name,L\".rar\",ASIZE(Name));\n    if (FileExist(Name))\n      wcsncpyz(ArcName,Name,ASIZE(ArcName));\n  }\n  if (wcschr(L\"AFUMD\",*Command)==NULL)\n  {\n    if (GenerateArcName)\n      GenerateArchiveName(ArcName,ASIZE(ArcName),GenerateMask,false);\n    StringList ArcMasks;\n    ArcMasks.AddString(ArcName);\n    ScanTree Scan(&ArcMasks,Recurse,SaveSymLinks,SCAN_SKIPDIRS);\n    FindData FindData;\n    while (Scan.GetNext(&FindData)==SCAN_SUCCESS)\n      AddArcName(FindData.Name);\n  }\n  else\n    AddArcName(ArcName);\n#endif\n  switch(Command[0])\n  {\n    case 'P':\n    case 'X':\n    case 'E':\n    case 'T':\n    case 'I':\n      {\n        CmdExtract Extract(this);\n        Extract.DoExtract();\n      }\n      break;\n#ifndef SILENT\n    case 'V':\n    case 'L':\n      ListArchive(this);\n      break;\n    default:\n      OutHelp(RARX_USERERROR);\n#endif\n  }\n  if (!BareOutput)\n    mprintf(L\"\\n\");\n}", "target": 1}
{"code": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\tif (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\tif (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static bool range_within(struct bpf_reg_state *old,\n\t\t\t struct bpf_reg_state *cur)\n{\n\treturn old->umin_value <= cur->umin_value &&\n\t       old->umax_value >= cur->umax_value &&\n\t       old->smin_value <= cur->smin_value &&\n\t       old->smax_value >= cur->smax_value;\n}", "target": 0}
{"code": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\tINFO(\"Mounting container /dev\");\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn false;\n\t}\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "runas_grouplist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *group_list, struct member **matching_group)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    int group_matched = UNSPEC;\n    struct member *m;\n    struct alias *a;\n    debug_decl(runas_grouplist_matches, SUDOERS_DEBUG_MATCH);\n    if (group_list != NULL) {\n\tTAILQ_FOREACH_REVERSE(m, group_list, member_list, entries) {\n\t    switch (m->type) {\n\t\tcase ALL:\n\t\t    group_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t\tcase ALIAS:\n\t\t    a = alias_get(parse_tree, m->name, RUNASALIAS);\n\t\t    if (a != NULL) {\n\t\t\tconst int rc = runas_grouplist_matches(parse_tree,\n\t\t\t    &a->members, matching_group);\n\t\t\tif (rc != UNSPEC) {\n\t\t\t    if (m->negated) {\n\t\t\t\tgroup_matched = rc == ALLOW ? DENY : ALLOW;\n\t\t\t    } else {\n\t\t\t\tgroup_matched = rc;\n\t\t\t    }\n\t\t\t}\n\t\t\talias_put(a);\n\t\t\tbreak;\n\t\t    }\n\t\t    FALLTHROUGH;\n\t\tcase WORD:\n\t\t    if (group_matches(m->name, ctx->runas.gr))\n\t\t\tgroup_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t    }\n\t    if (group_matched != UNSPEC) {\n\t\tif (matching_group != NULL && m->type != ALIAS)\n\t\t    *matching_group = m;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (group_matched == UNSPEC) {\n\tstruct gid_list *runas_groups;\n\tif (ctx->runas.pw->pw_gid == ctx->runas.gr->gr_gid) {\n\t    group_matched = ALLOW;\t\n\t} else if ((runas_groups = runas_getgroups(ctx)) != NULL) {\n\t    int i;\n\t    for (i = 0; i < runas_groups->ngids; i++) {\n\t\tif (runas_groups->gids[i] == ctx->runas.gr->gr_gid) {\n\t\t    group_matched = ALLOW;\t\n\t\t    break;\n\t\t}\n\t    }\n\t    sudo_gidlist_delref(runas_groups);\n\t}\n    }\n    debug_return_int(group_matched);\n}", "target": 1}
{"code": "static int picolcd_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *raw_data, int size)\n{\n\tstruct picolcd_data *data = hid_get_drvdata(hdev);\n\tunsigned long flags;\n\tint ret = 0;\n\tif (!data)\n\t\treturn 1;\n\tif (size > 64) {\n\t\thid_warn(hdev, \"invalid size value (%d) for picolcd raw event\\n\",\n\t\t\t\tsize);\n\t\treturn 0;\n\t}\n\tif (report->id == REPORT_KEY_STATE) {\n\t\tif (data->input_keys)\n\t\t\tret = picolcd_raw_keypad(data, report, raw_data+1, size-1);\n\t} else if (report->id == REPORT_IR_DATA) {\n\t\tret = picolcd_raw_cir(data, report, raw_data+1, size-1);\n\t} else {\n\t\tspin_lock_irqsave(&data->lock, flags);\n\t\tif (data->pending) {\n\t\t\tmemcpy(data->pending->raw_data, raw_data+1, size-1);\n\t\t\tdata->pending->raw_size  = size-1;\n\t\t\tdata->pending->in_report = report;\n\t\t\tcomplete(&data->pending->ready);\n\t\t}\n\t\tspin_unlock_irqrestore(&data->lock, flags);\n\t}\n\tpicolcd_debug_raw_event(data, hdev, report, raw_data, size);\n\treturn 1;\n}", "target": 0}
{"code": "int validated_offset(uint32_t addr, uint32_t start, uint32_t end){\n    return addr <= end && addr >= start? 0:-1;\n}", "target": 0}
{"code": "  bool add_challenge(CephContext *cct, bufferlist& ch) override { return true; }", "target": 0}
{"code": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n}", "target": 1}
{"code": "init_level(struct cert_stack *stack, unsigned int *_result)\n{\n\tstruct metadata_node *head_meta;\n\tunsigned int work_repo_level;\n\tunsigned int result;\n\tresult = 0;\n\twork_repo_level = working_repo_peek_level();\n\thead_meta = SLIST_FIRST(&stack->metas);\n\tif (head_meta != NULL && work_repo_level > head_meta->level)\n\t\tresult = work_repo_level;\n\t*_result = result;\n\treturn 0;\n}", "target": 0}
{"code": "static void save_quoted(const char *data, FILE *file)\n{\n\tconst char *p;\n\tfputc('\"', file);\n\tfor (p = data; p && *p; p++) {\n\t\tif ((unsigned char) *p == 0x22 ||\t\t\n\t\t    (unsigned char) *p == 0x5c)\t\t\t\n\t\t\tfputc('\\\\', file);\n\t\tfputc(*p, file);\n\t}\n\tfputc('\"', file);\n}", "target": 0}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "static int lua_ap_usleep(lua_State *L)\n{\n    apr_interval_time_t msec;\n    luaL_checktype(L, 1, LUA_TNUMBER);\n    msec = (apr_interval_time_t)lua_tonumber(L, 1);\n    apr_sleep(msec);\n    return 0;\n}", "target": 0}
{"code": "static inline void SMTPTransactionComplete(SMTPState *state)\n{\n    DEBUG_VALIDATE_BUG_ON(state->curr_tx == NULL);\n    if (state->curr_tx)\n        state->curr_tx->done = 1;\n}", "target": 1}
{"code": "left_is_superset(DTCollation *left, DTCollation *right)\n{\n  if (left->collation->state & MY_CS_UNICODE &&\n      (left->derivation < right->derivation ||\n       (left->derivation == right->derivation &&\n        (!(right->collation->state & MY_CS_UNICODE) ||\n         (left->collation->state & MY_CS_UNICODE_SUPPLEMENT &&\n          !(right->collation->state & MY_CS_UNICODE_SUPPLEMENT) &&\n          left->collation->mbmaxlen > right->collation->mbmaxlen &&\n          left->collation->mbminlen == right->collation->mbminlen)))))\n    return TRUE;\n  if (right->repertoire == MY_REPERTOIRE_ASCII &&\n      (left->derivation < right->derivation ||\n       (left->derivation == right->derivation &&\n        !(left->repertoire == MY_REPERTOIRE_ASCII))))\n    return TRUE;\n  return FALSE;\n}", "target": 0}
{"code": "static int install_thread_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tBUG_ON(new->thread_keyring);\n\tret = install_thread_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}", "target": 1}
{"code": "static inline void sem_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "static apr_byte_t oidc_validate_post_logout_url(request_rec *r, const char *url,\n\t\tchar **err_str, char **err_desc) {\n\tapr_uri_t uri;\n\tconst char *c_host = NULL;\n\tif (apr_uri_parse(r->pool, url, &uri) != APR_SUCCESS) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc = apr_psprintf(r->pool, \"Logout URL malformed: %s\", url);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tc_host = oidc_get_current_url_host(r);\n\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\tif (((strstr(url, \"\\n\") != NULL) || strstr(url, \"\\r\") != NULL)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" contains illegal \\\"\\n\\\" or \\\"\\r\\\" character(s)\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\t__ceph_setattr(inode, &newattrs);\n\t\t}\n\t\tgoto out_free;\n\t}\n\tceph_set_cached_acl(inode, type, acl);\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "ConnectionManagerImpl::ActiveStream::~ActiveStream() {\n  stream_info_.onRequestComplete();\n  if (!stream_info_.hasAnyResponseFlag() && !stream_info_.responseCode()) {\n    stream_info_.setResponseFlag(StreamInfo::ResponseFlag::DownstreamConnectionTermination);\n  }\n  connection_manager_.stats_.named_.downstream_rq_active_.dec();\n  if (request_headers_ != nullptr) {\n    request_headers_->refreshByteSize();\n  }\n  if (response_headers_ != nullptr) {\n    response_headers_->refreshByteSize();\n  }\n  if (response_trailers_ != nullptr) {\n    response_trailers_->refreshByteSize();\n  }\n  for (const AccessLog::InstanceSharedPtr& access_log : connection_manager_.config_.accessLogs()) {\n    access_log->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                    stream_info_);\n  }\n  for (const auto& log_handler : access_log_handlers_) {\n    log_handler->log(request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n                     stream_info_);\n  }\n  if (stream_info_.healthCheck()) {\n    connection_manager_.config_.tracingStats().health_check_.inc();\n  }\n  if (active_span_) {\n    Tracing::HttpTracerUtility::finalizeDownstreamSpan(\n        *active_span_, request_headers_.get(), response_headers_.get(), response_trailers_.get(),\n        stream_info_, *this);\n  }\n  if (state_.successful_upgrade_) {\n    connection_manager_.stats_.named_.downstream_cx_upgrades_active_.dec();\n  }\n  ASSERT(state_.filter_call_state_ == 0);\n}", "target": 0}
{"code": "static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint rc;\n\tpr_debug(\"sock=%p sk=%p len=%zu flags=%d\\n\", sock, sk, len, flags);\n\tskb = skb_recv_datagram(sk, flags, noblock, &rc);\n\tif (!skb)\n\t\treturn rc;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tskb_free_datagram(sk, skb);\n\treturn rc ? : copied;\n}", "target": 1}
{"code": "static avifBool avifParseImageGridBox(avifImageGrid * grid, const uint8_t * raw, size_t rawLen)\n{\n    BEGIN_STREAM(s, raw, rawLen);\n    uint8_t version, flags;\n    CHECK(avifROStreamRead(&s, &version, 1)); \n    if (version != 0) {\n        return AVIF_FALSE;\n    }\n    CHECK(avifROStreamRead(&s, &flags, 1));         \n    CHECK(avifROStreamRead(&s, &grid->rows, 1));    \n    CHECK(avifROStreamRead(&s, &grid->columns, 1)); \n    ++grid->rows;\n    ++grid->columns;\n    uint32_t fieldLength = ((flags & 1) + 1) * 16;\n    if (fieldLength == 16) {\n        uint16_t outputWidth16, outputHeight16;\n        CHECK(avifROStreamReadU16(&s, &outputWidth16));  \n        CHECK(avifROStreamReadU16(&s, &outputHeight16)); \n        grid->outputWidth = outputWidth16;\n        grid->outputHeight = outputHeight16;\n    } else {\n        if (fieldLength != 32) {\n            return AVIF_FALSE;\n        }\n        CHECK(avifROStreamReadU32(&s, &grid->outputWidth));  \n        CHECK(avifROStreamReadU32(&s, &grid->outputHeight)); \n    }\n    if (grid->outputWidth > AVIF_MAX_IMAGE_SIZE / grid->outputHeight) {\n        return AVIF_FALSE;\n    }\n    return AVIF_TRUE;\n}", "target": 0}
{"code": "compute_U_value_R2(std::string const& user_password,\n\t\t   QPDF::EncryptionData const& data)\n{\n    std::string k1 = QPDF::compute_encryption_key(user_password, data);\n    char udata[key_bytes];\n    pad_or_truncate_password_V4(\"\", udata);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(QUtil::unsigned_char_pointer(udata), key_bytes,\n\t\tQUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(), 1, false);\n    return std::string(udata, key_bytes);\n}", "target": 0}
{"code": "static int activate(AVFilterContext *ctx)\n{\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    AudioFWTDNContext *s = ctx->priv;\n    AVFrame *in = NULL;\n    int ret, status;\n    int64_t pts;\n    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\n    ret = ff_inlink_consume_samples(inlink, s->nb_samples, s->nb_samples, &in);\n    if (ret < 0)\n        return ret;\n    if (ret > 0)\n        return filter_frame(inlink, in);\n    if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {\n        if (status == AVERROR_EOF) {\n            while (s->padd_samples != 0) {\n                ret = filter_frame(inlink, NULL);\n                if (ret < 0)\n                    return ret;\n            }\n            ff_outlink_set_status(outlink, status, pts);\n            return ret;\n        }\n    }\n    FF_FILTER_FORWARD_WANTED(outlink, inlink);\n    return FFERROR_NOT_READY;\n}", "target": 1}
{"code": "bool InstanceKlass::remove_osr_nmethod(nmethod* n) {\n  MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);\n  assert(n->is_osr_method(), \"wrong kind of nmethod\");\n  nmethod* last = NULL;\n  nmethod* cur  = osr_nmethods_head();\n  int max_level = CompLevel_none;  \n  Method* m = n->method();\n  bool found = false;\n  while(cur != NULL && cur != n) {\n    if (TieredCompilation && m == cur->method()) {\n      max_level = MAX2(max_level, cur->comp_level());\n    }\n    last = cur;\n    cur = cur->osr_link();\n  }\n  nmethod* next = NULL;\n  if (cur == n) {\n    found = true;\n    next = cur->osr_link();\n    if (last == NULL) {\n      set_osr_nmethods_head(next);\n    } else {\n      last->set_osr_link(next);\n    }\n  }\n  n->set_osr_link(NULL);\n  if (TieredCompilation) {\n    cur = next;\n    while (cur != NULL) {\n      if (m == cur->method()) {\n        max_level = MAX2(max_level, cur->comp_level());\n      }\n      cur = cur->osr_link();\n    }\n    m->set_highest_osr_comp_level(max_level);\n  }\n  return found;\n}", "target": 0}
{"code": "static void dns_resolver_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key)) {\n\t\tint err = PTR_ERR(key->payload.data[dns_key_error]);\n\t\tif (err)\n\t\t\tseq_printf(m, \": %d\", err);\n\t\telse\n\t\t\tseq_printf(m, \": %u\", key->datalen);\n\t}\n}", "target": 1}
{"code": "static ssize_t ppp_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ppp_file *pf = file->private_data;\n\tDECLARE_WAITQUEUE(wait, current);\n\tssize_t ret;\n\tstruct sk_buff *skb = NULL;\n\tstruct iovec iov;\n\tstruct iov_iter to;\n\tret = count;\n\tif (!pf)\n\t\treturn -ENXIO;\n\tadd_wait_queue(&pf->rwait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tskb = skb_dequeue(&pf->rq);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tret = 0;\n\t\tif (pf->dead)\n\t\t\tbreak;\n\t\tif (pf->kind == INTERFACE) {\n\t\t\tstruct ppp *ppp = PF_TO_PPP(pf);\n\t\t\tif (ppp->n_channels == 0 &&\n\t\t\t    (ppp->flags & SC_LOOP_TRAFFIC) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tret = -EAGAIN;\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\t\tret = -ERESTARTSYS;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&pf->rwait, &wait);\n\tif (!skb)\n\t\tgoto out;\n\tret = -EOVERFLOW;\n\tif (skb->len > count)\n\t\tgoto outf;\n\tret = -EFAULT;\n\tiov.iov_base = buf;\n\tiov.iov_len = count;\n\tiov_iter_init(&to, READ, &iov, 1, count);\n\tif (skb_copy_datagram_iter(skb, 0, &to, skb->len))\n\t\tgoto outf;\n\tret = skb->len;\n outf:\n\tkfree_skb(skb);\n out:\n\treturn ret;\n}", "target": 0}
{"code": "spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "g_file_set_contents_full(const gchar *filename,\n\t\t\t const gchar *contents,\n\t\t\t gssize length,\n\t\t\t GFileSetContentsFlags flags,\n\t\t\t int mode,\n\t\t\t GError **error)\n{\n\tgint fd;\n\tgssize wrote;\n\tif (length < 0)\n\t\tlength = strlen(contents);\n\tfd = g_open(filename, O_CREAT, mode);\n\tif (fd <= 0) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"could not open %s file\",\n\t\t\t    filename);\n\t\treturn FALSE;\n\t}\n\twrote = write(fd, contents, length);\n\tif (wrote != length) {\n\t\tg_set_error(error,\n\t\t\t    G_IO_ERROR,\n\t\t\t    G_IO_ERROR_FAILED,\n\t\t\t    \"did not write %s file\",\n\t\t\t    filename);\n\t\tg_close(fd, NULL);\n\t\treturn FALSE;\n\t}\n\treturn g_close(fd, error);\n}", "target": 0}
{"code": "void mb2_cache_entry_delete_block(struct mb2_cache *cache, u32 key,\n\t\t\t\t  sector_t block)\n{\n\tstruct hlist_bl_node *node;\n\tstruct hlist_bl_head *head;\n\tstruct mb2_cache_entry *entry;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(entry, node, head, e_hash_list) {\n\t\tif (entry->e_key == key && entry->e_block == block) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\thlist_bl_unlock(head);\n\t\t\tspin_lock(&cache->c_lru_list_lock);\n\t\t\tif (!list_empty(&entry->e_lru_list)) {\n\t\t\t\tlist_del_init(&entry->e_lru_list);\n\t\t\t\tcache->c_entry_count--;\n\t\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t\t}\n\t\t\tspin_unlock(&cache->c_lru_list_lock);\n\t\t\tmb2_cache_entry_put(cache, entry);\n\t\t\treturn;\n\t\t}\n\t}\n\thlist_bl_unlock(head);\n}", "target": 0}
{"code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"path\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \"disallowed submodule path: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\treturn 0;\n}", "target": 0}
{"code": "init_rc(void)\n{\n    int i;\n    struct stat st;\n    FILE *f;\n    if (rc_dir != NULL)\n\tgoto open_rc;\n    rc_dir = expandPath(RC_DIR);\n    i = strlen(rc_dir);\n    if (i > 1 && rc_dir[i - 1] == '/')\n\trc_dir[i - 1] = '\\0';\n#ifdef USE_M17N\n    display_charset_str = wc_get_ces_list();\n    document_charset_str = display_charset_str;\n    system_charset_str = display_charset_str;\n#endif\n    if (stat(rc_dir, &st) < 0) {\n\tif (errno == ENOENT) {\t\n\t    if (do_mkdir(rc_dir, 0700) < 0) {\n\t\tgoto rc_dir_err;\n\t    }\n\t    else {\n\t\tstat(rc_dir, &st);\n\t    }\n\t}\n\telse {\n\t    goto rc_dir_err;\n\t}\n    }\n    if (!S_ISDIR(st.st_mode)) {\n\tgoto rc_dir_err;\n    }\n    if (!(st.st_mode & S_IWUSR)) {\n\tgoto rc_dir_err;\n    }\n    no_rc_dir = FALSE;\n    tmp_dir = rc_dir;\n    if (config_file == NULL)\n\tconfig_file = rcFile(CONFIG_FILE);\n    create_option_search_table();\n  open_rc:\n    if ((f = fopen(etcFile(W3MCONFIG), \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    if ((f = fopen(confFile(CONFIG_FILE), \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    if (config_file && (f = fopen(config_file, \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    return;\n  rc_dir_err:\n    no_rc_dir = TRUE;\n    if (((tmp_dir = getenv(\"TMPDIR\")) == NULL || *tmp_dir == '\\0') &&\n\t((tmp_dir = getenv(\"TMP\")) == NULL || *tmp_dir == '\\0') &&\n\t((tmp_dir = getenv(\"TEMP\")) == NULL || *tmp_dir == '\\0'))\n\ttmp_dir = \"/tmp\";\n#ifdef HAVE_MKDTEMP\n    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, \"/w3m-XXXXXX\", NULL)->ptr);\n    if (tmp_dir == NULL)\n\ttmp_dir = rc_dir;\n#endif\n    create_option_search_table();\n    goto open_rc;\n}", "target": 0}
{"code": "struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)\n{\n\tif (atomic_inc_return(&prog->aux->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&prog->aux->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\treturn prog;\n}", "target": 0}
{"code": "static bool pp_suppress_error(errflags severity)\n{\n    if (istk && istk->conds &&\n\t((severity & ERR_PP_PRECOND) ?\n\t istk->conds->state == COND_NEVER :\n\t !emitting(istk->conds->state)))\n        return true;\n    return false;\n}", "target": 0}
{"code": "inline PointerReader ListReader::getPointerElement(ElementCount index) const {\n  return PointerReader(segment, capTable, reinterpret_cast<const WirePointer*>(\n      ptr + upgradeBound<uint64_t>(index) * step / BITS_PER_BYTE), nestingLimit);\n}", "target": 1}
{"code": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\treturn datagrams;\n}", "target": 1}
{"code": "static inline void init_keys(at91_aes_key_size_t *key_size,\n\t\t\t     unsigned int *cipher_key,\n\t\t\t     unsigned int *cmac_key,\n\t\t\t     unsigned int *iv)\n{\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\t*key_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\t*key_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\t*key_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\tiv[0]\t\t= CONFIG_AES_IV_WORD0;\n\tiv[1]\t\t= CONFIG_AES_IV_WORD1;\n\tiv[2]\t\t= CONFIG_AES_IV_WORD2;\n\tiv[3]\t\t= CONFIG_AES_IV_WORD3;\n\tcipher_key[0]\t= CONFIG_AES_CIPHER_KEY_WORD0;\n\tcmac_key[0]\t= CONFIG_AES_CMAC_KEY_WORD0;\n\tcipher_key[1]\t= CONFIG_AES_CIPHER_KEY_WORD1;\n\tcmac_key[1]\t= CONFIG_AES_CMAC_KEY_WORD1;\n\tcipher_key[2]\t= CONFIG_AES_CIPHER_KEY_WORD2;\n\tcmac_key[2]\t= CONFIG_AES_CMAC_KEY_WORD2;\n\tcipher_key[3]\t= CONFIG_AES_CIPHER_KEY_WORD3;\n\tcmac_key[3]\t= CONFIG_AES_CMAC_KEY_WORD3;\n#if defined(CONFIG_AES_KEY_SIZE_192) || defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[4]\t= CONFIG_AES_CIPHER_KEY_WORD4;\n\tcmac_key[4]\t= CONFIG_AES_CMAC_KEY_WORD4;\n\tcipher_key[5]\t= CONFIG_AES_CIPHER_KEY_WORD5;\n\tcmac_key[5]\t= CONFIG_AES_CMAC_KEY_WORD5;\n#endif\n#if defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[6]\t= CONFIG_AES_CIPHER_KEY_WORD6;\n\tcmac_key[6]\t= CONFIG_AES_CMAC_KEY_WORD6;\n\tcipher_key[7]\t= CONFIG_AES_CIPHER_KEY_WORD7;\n\tcmac_key[7]\t= CONFIG_AES_CMAC_KEY_WORD7;\n#endif\n}", "target": 1}
{"code": "static int __d_unalias(struct inode *inode,\n\t\tstruct dentry *dentry, struct dentry *alias)\n{\n\tstruct mutex *m1 = NULL, *m2 = NULL;\n\tint ret = -ESTALE;\n\tif (alias->d_parent == dentry->d_parent)\n\t\tgoto out_unalias;\n\tif (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))\n\t\tgoto out_err;\n\tm1 = &dentry->d_sb->s_vfs_rename_mutex;\n\tif (!mutex_trylock(&alias->d_parent->d_inode->i_mutex))\n\t\tgoto out_err;\n\tm2 = &alias->d_parent->d_inode->i_mutex;\nout_unalias:\n\t__d_move(alias, dentry, false);\n\tret = 0;\nout_err:\n\tspin_unlock(&inode->i_lock);\n\tif (m2)\n\t\tmutex_unlock(m2);\n\tif (m1)\n\t\tmutex_unlock(m1);\n\treturn ret;\n}", "target": 0}
{"code": "unknown_layer_handler(TSS2_RC rc)\n{\n    static __thread char buf[32];\n    clearbuf(buf);\n    catbuf(buf, \"0x%X\", tpm2_error_get(rc));\n    return buf;\n}", "target": 1}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 0}
{"code": "static const char *cmd_xml_external_entity(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->xml_external_entity = 1;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->xml_external_entity = 0;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecXmlExternalEntity: %s\", p1);\n    return NULL;\n}", "target": 0}
{"code": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n    return result;\n}", "target": 1}
{"code": "LogLuvClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_samplesperpixel =\n\t    (td->td_photometric == PHOTOMETRIC_LOGL) ? 1 : 3;\n\ttd->td_bitspersample = 16;\n\ttd->td_sampleformat = SAMPLEFORMAT_INT;\n}", "target": 1}
{"code": "static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)\n{\n    char * const s = b->ptr;\n    const int blen = (int)buffer_string_length(b);\n    const int used = qs < 0 ? blen : qs;\n    int j = i;\n    for (; i < used; ++i, ++j) {\n        s[j] = s[i];\n        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {\n            s[j] = '/';\n            i+=2;\n        }\n    }\n    if (qs >= 0) {\n        memmove(s+j, s+qs, blen - qs);\n        j += blen - qs;\n    }\n    buffer_string_set_length(b, j);\n    return qs;\n}", "target": 1}
{"code": "static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\tif (!sel)\n\t\treturn 0;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\treturn limit;\n}", "target": 1}
{"code": "TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  \n    case kTfLiteFloat32:\n      return AverageEvalFloat<kernel_type>(context, node, params, data, input,\n                                           output);\n    case kTfLiteUInt8:\n      return AverageEvalQuantizedUint8<kernel_type>(context, node, params, data,\n                                                    input, output);\n    case kTfLiteInt8:\n      return AverageEvalQuantizedInt8<kernel_type>(context, node, params, data,\n                                                   input, output);\n    case kTfLiteInt16:\n      return AverageEvalQuantizedInt16<kernel_type>(context, node, params, data,\n                                                    input, output);\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    const std::vector<int64> out_sizes = {batch, out_rows, out_cols, depth};\n    TensorShape out_shape(out_sizes);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    if (out_shape.num_elements() == 0) {\n      return;\n    }\n    functor::Dilation<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), stride_rows, stride_cols, rate_rows, rate_cols,\n        pad_top, pad_left, output->tensor<T, 4>());\n  }", "target": 0}
{"code": "static struct mount *alloc_vfsmnt(const char *name)\n{\n\tstruct mount *mnt = kmem_cache_zalloc(mnt_cache, GFP_KERNEL);\n\tif (mnt) {\n\t\tint err;\n\t\terr = mnt_alloc_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free_cache;\n\t\tif (name) {\n\t\t\tmnt->mnt_devname = kstrdup(name, GFP_KERNEL);\n\t\t\tif (!mnt->mnt_devname)\n\t\t\t\tgoto out_free_id;\n\t\t}\n#ifdef CONFIG_SMP\n\t\tmnt->mnt_pcp = alloc_percpu(struct mnt_pcp);\n\t\tif (!mnt->mnt_pcp)\n\t\t\tgoto out_free_devname;\n\t\tthis_cpu_add(mnt->mnt_pcp->mnt_count, 1);\n#else\n\t\tmnt->mnt_count = 1;\n\t\tmnt->mnt_writers = 0;\n#endif\n\t\tINIT_HLIST_NODE(&mnt->mnt_hash);\n\t\tINIT_LIST_HEAD(&mnt->mnt_child);\n\t\tINIT_LIST_HEAD(&mnt->mnt_mounts);\n\t\tINIT_LIST_HEAD(&mnt->mnt_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_expire);\n\t\tINIT_LIST_HEAD(&mnt->mnt_share);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave_list);\n\t\tINIT_LIST_HEAD(&mnt->mnt_slave);\n#ifdef CONFIG_FSNOTIFY\n\t\tINIT_HLIST_HEAD(&mnt->mnt_fsnotify_marks);\n#endif\n\t}\n\treturn mnt;\n#ifdef CONFIG_SMP\nout_free_devname:\n\tkfree(mnt->mnt_devname);\n#endif\nout_free_id:\n\tmnt_free_id(mnt);\nout_free_cache:\n\tkmem_cache_free(mnt_cache, mnt);\n\treturn NULL;\n}", "target": 0}
{"code": "PHP_MINFO_FUNCTION(exif)\n{\n\tphp_info_print_table_start();\n\tphp_info_print_table_row(2, \"EXIF Support\", \"enabled\");\n\tphp_info_print_table_row(2, \"Supported EXIF Version\", \"0220\");\n\tphp_info_print_table_row(2, \"Supported filetypes\", \"JPEG, TIFF\");\n\tif (zend_hash_str_exists(&module_registry, \"mbstring\", sizeof(\"mbstring\")-1)) {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"enabled\");\n\t} else {\n\t\tphp_info_print_table_row(2, \"Multibyte decoding support using mbstring\", \"disabled\");\n\t}\n\tphp_info_print_table_row(2, \"Extended EXIF tag formats\", \"Canon, Casio, Fujifilm, Nikon, Olympus, Samsung, Panasonic, DJI, Sony, Pentax, Minolta, Sigma, Foveon, Kyocera, Ricoh, AGFA, Epson\");\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();\n}", "target": 0}
{"code": "static void process_tree(struct rev_info *revs,\n\t\t\t struct tree *tree,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *base,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &tree->object;\n\tstruct tree_desc desc;\n\tstruct name_entry entry;\n\tenum interesting match = revs->diffopt.pathspec.nr == 0 ?\n\t\tall_entries_interesting: entry_not_interesting;\n\tint baselen = base->len;\n\tif (!revs->tree_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad tree object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tif (parse_tree_gently(tree, revs->ignore_missing_links) < 0) {\n\t\tif (revs->ignore_missing_links)\n\t\t\treturn;\n\t\tdie(\"bad tree object %s\", oid_to_hex(&obj->oid));\n\t}\n\tobj->flags |= SEEN;\n\tshow(obj, base, name, cb_data);\n\tstrbuf_addstr(base, name);\n\tif (base->len)\n\t\tstrbuf_addch(base, '/');\n\tinit_tree_desc(&desc, tree->buffer, tree->size);\n\twhile (tree_entry(&desc, &entry)) {\n\t\tif (match != all_entries_interesting) {\n\t\t\tmatch = tree_entry_interesting(&entry, base, 0,\n\t\t\t\t\t\t       &revs->diffopt.pathspec);\n\t\t\tif (match == all_entries_not_interesting)\n\t\t\t\tbreak;\n\t\t\tif (match == entry_not_interesting)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (S_ISDIR(entry.mode))\n\t\t\tprocess_tree(revs,\n\t\t\t\t     lookup_tree(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t\telse if (S_ISGITLINK(entry.mode))\n\t\t\tprocess_gitlink(revs, entry.sha1,\n\t\t\t\t\tshow, base, entry.path,\n\t\t\t\t\tcb_data);\n\t\telse\n\t\t\tprocess_blob(revs,\n\t\t\t\t     lookup_blob(entry.sha1),\n\t\t\t\t     show, base, entry.path,\n\t\t\t\t     cb_data);\n\t}\n\tstrbuf_setlen(base, baselen);\n\tfree_tree_buffer(tree);\n}", "target": 1}
{"code": "static TEE_Result do_alloc_keypair(struct ecc_keypair *s, uint32_t type,\n\t\t\t\t   size_t size_bits __unused)\n{\n\tif (type != TEE_TYPE_ECDSA_KEYPAIR &&\n\t    type != TEE_TYPE_ECDH_KEYPAIR)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "static int ext4_split_unwritten_extents(handle_t *handle,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tstruct ext4_map_blocks *map,\n\t\t\t\t\tstruct ext4_ext_path *path,\n\t\t\t\t\tint flags)\n{\n\text4_lblk_t eof_block;\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len;\n\tint split_flag = 0, depth;\n\text_debug(\"ext4_split_unwritten_extents: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)map->m_lblk, map->m_len);\n\teof_block = (inode->i_size + inode->i_sb->s_blocksize - 1) >>\n\t\tinode->i_sb->s_blocksize_bits;\n\tif (eof_block < map->m_lblk + map->m_len)\n\t\teof_block = map->m_lblk + map->m_len;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n\tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n\tif (flags & EXT4_GET_BLOCKS_CONVERT)\n\t\tsplit_flag |= EXT4_EXT_DATA_VALID2;\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}", "target": 0}
{"code": "  explicit QuantizeAndDequantizeOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_min\", &input_min_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_max\", &input_max_));\n    if (range_given_) {\n      OP_REQUIRES(\n          ctx, input_min_ <= input_max_,\n          errors::InvalidArgument(\"Invalid range: input_min \", input_min_,\n                                  \" > input_max \", input_max_));\n    }\n  }", "target": 1}
{"code": "AuthenticationFeature::AuthenticationFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"Authentication\"),\n      _userManager(nullptr),\n      _authCache(nullptr),\n      _authenticationUnixSockets(true),\n      _authenticationSystemOnly(true),\n      _localAuthentication(true),\n      _active(true),\n      _authenticationTimeout(0.0) {\n  setOptional(false);\n  startsAfter<application_features::BasicFeaturePhaseServer>();\n#ifdef USE_ENTERPRISE\n  startsAfter<LdapFeature>();\n#endif\n}", "target": 1}
{"code": "absl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n  return cached_ip_san_peer_certificate_;\n}", "target": 1}
{"code": "auth_iochannel_watch (GIOChannel   *source,\n                      GIOCondition  condition,\n                      IceConn       ice_conn)\n{\n        GsmIceConnectionWatch *data;\n        gboolean               keep_going;\n        data = ice_conn->context;\n        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n        case IceProcessMessagesSuccess:\n                keep_going = TRUE;\n                break;\n        case IceProcessMessagesIOError:\n                g_debug (\"GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\");\n                free_ice_connection_watch (data);\n                disconnect_ice_connection (ice_conn);\n                keep_going = FALSE;\n                break;\n        case IceProcessMessagesConnectionClosed:\n                g_debug (\"GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\");\n                free_ice_connection_watch (data);\n                keep_going = FALSE;\n                break;\n        default:\n                g_assert_not_reached ();\n        }\n        return keep_going;\n}", "target": 0}
{"code": "bool MemoryManager::validate_user_write(const Process& process, VirtualAddress vaddr) const\n{\n    auto* region = region_from_vaddr(process, vaddr);\n    return region && region->is_writable();\n}", "target": 1}
{"code": "static const char *ifsection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    const command_rec *thiscmd = cmd->cmd;\n    ap_conf_vector_t *new_if_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);\n    const char *condition;\n    const char *expr_err;\n    if (err != NULL) {\n        return err;\n    }\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n    cmd->path = \"*If\";\n    if (!old_path) {\n        cmd->override = OR_ALL|ACCESS_CONF;\n    }\n    conf = ap_set_config_vectors(cmd->server, new_if_conf, cmd->path,\n                                 &core_module, cmd->pool);\n    if (cmd->cmd->cmd_data == COND_IF)\n        conf->condition_ifelse = AP_CONDITION_IF;\n    else if (cmd->cmd->cmd_data == COND_ELSEIF)\n        conf->condition_ifelse = AP_CONDITION_ELSEIF;\n    else if (cmd->cmd->cmd_data == COND_ELSE)\n        conf->condition_ifelse = AP_CONDITION_ELSE;\n    else\n        ap_assert(0);\n    if (conf->condition_ifelse == AP_CONDITION_ELSE) {\n        if (arg[0])\n            return \"<Else> does not take an argument\";\n    }\n    else {\n        if (!arg[0])\n            return missing_container_arg(cmd);\n        condition = ap_getword_conf(cmd->pool, &arg);\n        conf->condition = ap_expr_parse_cmd(cmd, condition, 0, &expr_err, NULL);\n        if (expr_err)\n            return apr_psprintf(cmd->pool, \"Cannot parse condition clause: %s\",\n                                expr_err);\n    }\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = 0;\n    conf->r = NULL;\n    errmsg = ap_add_if_conf(cmd->pool, (core_dir_config *)mconfig, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not supported.\", NULL);\n    }\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n    return NULL;\n}", "target": 0}
{"code": "static bool nf_generic_should_process(u8 proto)\n{\n\tswitch (proto) {\n#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE\n\tcase IPPROTO_SCTP:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE\n\tcase IPPROTO_DCCP:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE\n\tcase IPPROTO_GRE:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE\n\tcase IPPROTO_UDPLITE:\n\t\treturn false;\n#endif\n\tdefault:\n\t\treturn true;\n\t}\n}", "target": 0}
{"code": "void CNB::SetupLSO(virtio_net_hdr_basic *VirtioHeader, PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    PopulateIPLength(reinterpret_cast<IPv4Header*>(IpHeader), static_cast<USHORT>(EthPayloadLength));\n    tTcpIpPacketParsingResult packetReview;\n    packetReview = ParaNdis_CheckSumVerifyFlat(reinterpret_cast<IPv4Header*>(IpHeader), EthPayloadLength,\n                                               pcrIpChecksum | pcrFixIPChecksum | pcrTcpChecksum | pcrFixPHChecksum,\n                                               FALSE,\n                                               __FUNCTION__);\n    if (packetReview.xxpCheckSum == ppresPCSOK || packetReview.fixedXxpCS)\n    {\n        auto IpHeaderOffset = m_Context->Offload.ipHeaderOffset;\n        auto VHeader = static_cast<virtio_net_hdr_basic*>(VirtioHeader);\n        auto PriorityHdrLen = (m_ParentNBL->TCI() != 0) ? ETH_PRIORITY_HEADER_SIZE : 0;\n        VHeader->flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n        VHeader->gso_type = packetReview.ipStatus == ppresIPV4 ? VIRTIO_NET_HDR_GSO_TCPV4 : VIRTIO_NET_HDR_GSO_TCPV6;\n        VHeader->hdr_len = (USHORT)(packetReview.XxpIpHeaderSize + IpHeaderOffset + PriorityHdrLen);\n        VHeader->gso_size = (USHORT)m_ParentNBL->MSS();\n        VHeader->csum_start = (USHORT)(m_ParentNBL->TCPHeaderOffset() + PriorityHdrLen);\n        VHeader->csum_offset = TCP_CHECKSUM_OFFSET;\n    }\n}", "target": 0}
{"code": "eui64_to_display(wmem_allocator_t *allocator, const guint64 addr_eui64)\n{\n    guint8 *addr = (guint8 *)wmem_alloc(NULL, 8);\n    hashmanuf_t *manuf_value;\n    gchar *ret;\n    *(guint64 *)(void *)(addr) = pntoh64(&(addr_eui64));\n    manuf_value = manuf_name_lookup(addr);\n    if (!gbl_resolv_flags.mac_name || (manuf_value->status == HASHETHER_STATUS_UNRESOLVED)) {\n        ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);\n    } else {\n        ret = wmem_strdup_printf(allocator, \"%s_%02x:%02x:%02x:%02x:%02x\", manuf_value->resolved_name, addr[3], addr[4], addr[5], addr[6], addr[7]);\n    }\n    wmem_free(NULL, addr);\n    return ret;\n} ", "target": 1}
{"code": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  \n                goto exit;\n            case 1:  \n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n    ret = PyObject_Hash(tmp);\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == 1) {\n        ret = -1;\n        goto exit;\n    }\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}", "target": 1}
{"code": "static void xen_irq_lateeoi_worker(struct work_struct *work)\n{\n\tstruct lateeoi_work *eoi;\n\tstruct irq_info *info;\n\tu64 now = get_jiffies_64();\n\tunsigned long flags;\n\teoi = container_of(to_delayed_work(work), struct lateeoi_work, delayed);\n\tread_lock_irqsave(&evtchn_rwlock, flags);\n\twhile (true) {\n\t\tspin_lock(&eoi->eoi_list_lock);\n\t\tinfo = list_first_entry_or_null(&eoi->eoi_list, struct irq_info,\n\t\t\t\t\t\teoi_list);\n\t\tif (info == NULL || now < info->eoi_time) {\n\t\t\tspin_unlock(&eoi->eoi_list_lock);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&info->eoi_list);\n\t\tspin_unlock(&eoi->eoi_list_lock);\n\t\tinfo->eoi_time = 0;\n\t\txen_irq_lateeoi_locked(info);\n\t}\n\tif (info)\n\t\tmod_delayed_work_on(info->eoi_cpu, system_wq,\n\t\t\t\t    &eoi->delayed, info->eoi_time - now);\n\tread_unlock_irqrestore(&evtchn_rwlock, flags);\n}", "target": 0}
{"code": "comics_check_decompress_support\t(gchar          *mime_type,\n\t\t\t\t ComicsDocument *comics_document,\n\t\t\t\t GError         **error)\n{\n\tif (g_content_type_is_a (mime_type, \"application/x-cbr\") ||\n\t    g_content_type_is_a (mime_type, \"application/x-rar\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_RAR))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/zip\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_ZIP))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_7Z))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-tar\")) {\n\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_TAR))\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Not a comic book MIME type: %s\"),\n\t\t\t     mime_type);\n\t\t\t     return FALSE;\n\t}\n\tg_set_error_literal (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t             _(\"libarchive lacks support for this comic books \"\n\t\t\t     \"compression, please contact your distributor\"));\n\treturn FALSE;\n}", "target": 0}
{"code": "  clientpairingsecret(std::shared_ptr<safe::queue_t<crypto::x509_t>> &add_cert, pair_session_t &sess, pt::ptree &tree, const args_t &args) {\n    auto &client = sess.client;\n    auto pairingsecret = util::from_hex_vec(get_arg(args, \"clientpairingsecret\"), true);\n    if (pairingsecret.size() <= 16) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\"root.<xmlattr>.status_message\", \"Clientpairingsecret too short\");\n      return;\n    }\n    std::string_view secret { pairingsecret.data(), 16 };\n    std::string_view sign { pairingsecret.data() + secret.size(), pairingsecret.size() - secret.size() };\n    auto x509 = crypto::x509(client.cert);\n    auto x509_sign = crypto::signature(x509);\n    std::string data;\n    data.reserve(sess.serverchallenge.size() + x509_sign.size() + secret.size());\n    data.insert(std::end(data), std::begin(sess.serverchallenge), std::end(sess.serverchallenge));\n    data.insert(std::end(data), std::begin(x509_sign), std::end(x509_sign));\n    data.insert(std::end(data), std::begin(secret), std::end(secret));\n    auto hash = crypto::hash(data);\n    if (!std::memcmp(hash.data(), sess.clienthash.data(), hash.size()) && crypto::verify256(crypto::x509(client.cert), secret, sign)) {\n      tree.put(\"root.paired\", 1);\n      add_cert->raise(crypto::x509(client.cert));\n      auto it = map_id_sess.find(client.uniqueID);\n      update_id_client(client.uniqueID, std::move(client.cert), op_e::ADD);\n      map_id_sess.erase(it);\n    }\n    else {\n      map_id_sess.erase(client.uniqueID);\n      tree.put(\"root.paired\", 0);\n    }\n    tree.put(\"root.<xmlattr>.status_code\", 200);\n  }", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictAvgPoolGrad(const OpContext& op_context,\n                                                NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  bool shape_found = false;\n  TensorShapeProto x_shape;\n  if (op_info.inputs_size() >= 1 && op_info.inputs(0).has_value()) {\n    const TensorProto& value = op_info.inputs(0).value();\n    shape_found = GetTensorShapeProtoFromTensorProto(value, &x_shape);\n  }\n  if (!shape_found && op_info.outputs_size() > 0) {\n    x_shape = op_info.outputs(0).shape();\n    shape_found = true;\n  }\n  if (!shape_found) {\n    x_shape.Clear();\n    for (int i = 0; i < 4; ++i) {\n      x_shape.add_dim()->set_size(1);\n    }\n    found_unknown_shapes = true;\n  }\n  ConvolutionDimensions dims =\n      OpDimensionsFromInputs(x_shape, op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    ops = dims.batch * dims.iz * (dims.ix * dims.iy + dims.ox * dims.oy);\n  } else {\n    ops = dims.batch * dims.iz *\n          (dims.ix * dims.iy + dims.ox * dims.oy * (dims.kx * dims.ky + 1));\n  }\n  auto s = PredictDefaultNodeCosts(ops, op_context, &found_unknown_shapes,\n                                   node_costs);\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  return s;\n}", "target": 1}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint64 iskew = (int64)imagew - (int64)tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb > iskew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 0}
{"code": "static int spl_heap_it_valid(zend_object_iterator *iter TSRMLS_DC) \n{\n\tspl_heap_it         *iterator = (spl_heap_it *)iter;\n\treturn (iterator->object->heap->count != 0 ? SUCCESS : FAILURE);\n}", "target": 0}
{"code": "std::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, extra_settings &ext)\n{\n    std::string real_rule, ret;\n    for(const RegexMatchConfig &x : emoji_array)\n    {\n        if(!x.Script.empty())\n        {\n            std::string result;\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto getEmoji = (std::function<std::string(const Proxy&)>) ctx.eval(\"getEmoji\");\n                    ret = getEmoji(node);\n                    if(!ret.empty())\n                        result = ret + \" \" + node.Remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            if(!result.empty())\n                return result;\n            continue;\n        }\n        if(x.Replace.empty())\n            continue;\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size() && regFind(node.Remark, real_rule))\n            return x.Replace + \" \" + node.Remark;\n    }\n    return node.Remark;\n}", "target": 1}
{"code": "    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,\n                                       const UBaseType_t uxItemSize,\n                                       const uint8_t ucQueueType )\n    {\n        Queue_t * pxNewQueue;\n        size_t xQueueSizeInBytes;\n        uint8_t * pucQueueStorage;\n        configASSERT( uxQueueLength > ( UBaseType_t ) 0 );\n        xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); \n        configASSERT( ( uxItemSize == 0 ) || ( uxQueueLength == ( xQueueSizeInBytes / uxItemSize ) ) );\n        configASSERT( ( sizeof( Queue_t ) + xQueueSizeInBytes ) >  xQueueSizeInBytes );\n        pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); \n        if( pxNewQueue != NULL )\n        {\n            pucQueueStorage = ( uint8_t * ) pxNewQueue;\n            pucQueueStorage += sizeof( Queue_t ); \n            #if ( configSUPPORT_STATIC_ALLOCATION == 1 )\n                {\n                    pxNewQueue->ucStaticallyAllocated = pdFALSE;\n                }\n            #endif \n            prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );\n        }\n        else\n        {\n            traceQUEUE_CREATE_FAILED( ucQueueType );\n            mtCOVERAGE_TEST_MARKER();\n        }\n        return pxNewQueue;\n    }", "target": 0}
{"code": "static void *command_init(struct pci_dev *dev, int offset)\n{\n\tstruct pci_cmd_info *cmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tint err;\n\tif (!cmd)\n\t\treturn ERR_PTR(-ENOMEM);\n\terr = pci_read_config_word(dev, PCI_COMMAND, &cmd->val);\n\tif (err) {\n\t\tkfree(cmd);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn cmd;\n}", "target": 0}
{"code": "  FramebufferManager::FramebufferInfo* GetFramebufferInfoForTarget(\n      GLenum target) {\n    FramebufferManager::FramebufferInfo* info = NULL;\n    switch (target) {\n      case GL_FRAMEBUFFER:\n      case GL_DRAW_FRAMEBUFFER:\n        info = bound_draw_framebuffer_;\n        break;\n      case GL_READ_FRAMEBUFFER:\n        info = bound_read_framebuffer_;\n        break;\n      default:\n        NOTREACHED();\n        break;\n    }\n    return info;\n  }", "target": 0}
{"code": "static void dp8393x_do_load_cam(dp8393xState *s)\n{\n    int width, size;\n    uint16_t index = 0;\n    width = (s->regs[SONIC_DCR] & SONIC_DCR_DW) ? 2 : 1;\n    size = sizeof(uint16_t) * 4 * width;\n    while (s->regs[SONIC_CDC] & 0x1f) {\n        address_space_read(&s->as, dp8393x_cdp(s),\n                           MEMTXATTRS_UNSPECIFIED, s->data, size);\n        s->cam[index][0] = dp8393x_get(s, width, 1) & 0xff;\n        s->cam[index][1] = dp8393x_get(s, width, 1) >> 8;\n        s->cam[index][2] = dp8393x_get(s, width, 2) & 0xff;\n        s->cam[index][3] = dp8393x_get(s, width, 2) >> 8;\n        s->cam[index][4] = dp8393x_get(s, width, 3) & 0xff;\n        s->cam[index][5] = dp8393x_get(s, width, 3) >> 8;\n        DPRINTF(\"load cam[%d] with %02x%02x%02x%02x%02x%02x\\n\", index,\n            s->cam[index][0], s->cam[index][1], s->cam[index][2],\n            s->cam[index][3], s->cam[index][4], s->cam[index][5]);\n        s->regs[SONIC_CDC]--;\n        s->regs[SONIC_CDP] += size;\n        index++;\n    }\n    address_space_read(&s->as, dp8393x_cdp(s),\n                       MEMTXATTRS_UNSPECIFIED, s->data, size);\n    s->regs[SONIC_CE] = dp8393x_get(s, width, 0);\n    DPRINTF(\"load cam done. cam enable mask 0x%04x\\n\", s->regs[SONIC_CE]);\n    s->regs[SONIC_CR] &= ~SONIC_CR_LCAM;\n    s->regs[SONIC_ISR] |= SONIC_ISR_LCD;\n    dp8393x_update_irq(s);\n}", "target": 0}
{"code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n       nullptr);\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n    if (!hasSimpleParams(functionNode)) {\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n    emitFunctionEpilogue(gen);\n  }\n  return outerFn;\n}", "target": 1}
{"code": "char *redisProtocolToLuaType_Aggregate(lua_State *lua, char *reply, int atype) {\n    char *p = strchr(reply+1,'\\r');\n    long long mbulklen;\n    int j = 0;\n    string2ll(reply+1,p-reply-1,&mbulklen);\n    if (server.lua_client->resp == 2 || atype == '*') {\n        p += 2;\n        if (mbulklen == -1) {\n            lua_pushboolean(lua,0);\n            return p;\n        }\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            lua_pushnumber(lua,j+1);\n            p = redisProtocolToLuaType(lua,p);\n            lua_settable(lua,-3);\n        }\n    } else if (server.lua_client->resp == 3) {\n        p += 2;\n        lua_newtable(lua);\n        lua_pushstring(lua,atype == '%' ? \"map\" : \"set\");\n        lua_newtable(lua);\n        for (j = 0; j < mbulklen; j++) {\n            p = redisProtocolToLuaType(lua,p);\n            if (atype == '%') {\n                p = redisProtocolToLuaType(lua,p);\n            } else {\n                if (!lua_checkstack(lua, 1)) {\n                    serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n                }\n                lua_pushboolean(lua,1);\n            }\n            lua_settable(lua,-3);\n        }\n        lua_settable(lua,-3);\n    }\n    return p;\n}", "target": 0}
{"code": "decrypt(gcry_mpi_t output, gcry_mpi_t a, gcry_mpi_t b, ELG_secret_key *skey )\n{\n  gcry_mpi_t t1, t2, r;\n  unsigned int nbits = mpi_get_nbits (skey->p);\n  mpi_normalize (a);\n  mpi_normalize (b);\n  t1 = mpi_snew (nbits);\n#ifdef USE_BLINDING\n  t2 = mpi_snew (nbits);\n  r  = mpi_new (nbits);\n  _gcry_mpi_randomize (r, nbits, GCRY_WEAK_RANDOM);\n  mpi_powm (t1, r, skey->x, skey->p);\n  mpi_mulm (t2, a, r, skey->p);\n  mpi_powm (t2, t2, skey->x, skey->p);\n  mpi_invm (t2, t2, skey->p);\n  mpi_mulm (t1, t1, t2, skey->p);\n  mpi_free (r);\n  mpi_free (t2);\n#else \n  mpi_powm (t1, a, skey->x, skey->p);\n  mpi_invm (t1, t1, skey->p);\n#endif \n  mpi_mulm (output, b, t1, skey->p);\n#if 0\n  if( DBG_CIPHER )\n    {\n      log_mpidump(\"elg decrypted x= \", skey->x);\n      log_mpidump(\"elg decrypted p= \", skey->p);\n      log_mpidump(\"elg decrypted a= \", a);\n      log_mpidump(\"elg decrypted b= \", b);\n      log_mpidump(\"elg decrypted M= \", output);\n    }\n#endif\n  mpi_free (t1);\n}", "target": 0}
{"code": "void DetectSignatureApplyActions(Packet *p,\n        const Signature *s, const uint8_t alert_flags)\n{\n    PACKET_UPDATE_ACTION(p, s->action);\n    if (s->action & ACTION_DROP) {\n        if (p->alerts.drop.action == 0) {\n            p->alerts.drop.num = s->num;\n            p->alerts.drop.action = s->action;\n            p->alerts.drop.s = (Signature *)s;\n        }\n    } else if (s->action & ACTION_PASS) {\n        if ((p->flow != NULL) &&\n                (alert_flags & (PACKET_ALERT_FLAG_STATE_MATCH|PACKET_ALERT_FLAG_STREAM_MATCH)))\n        {\n            FlowSetNoPacketInspectionFlag(p->flow);\n        }\n    }\n}", "target": 0}
{"code": "void nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\tlocal_cleanup(local);\n\tnfc_llcp_local_put(local);\n}", "target": 1}
{"code": "static int php_curl_option_str(php_curl *ch, zend_long option, const char *str, const int len, zend_bool make_copy)\n{\n\tCURLcode error = CURLE_OK;\n\tif (strlen(str) != len) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Curl option contains invalid characters (\\\\0)\");\n\t\treturn FAILURE;\n\t}\n#if LIBCURL_VERSION_NUM >= 0x071100\n\tif (make_copy) {\n#endif\n\t\tchar *copystr;\n\t\tcopystr = estrndup(str, len);\n\t\terror = curl_easy_setopt(ch->cp, option, copystr);\n\t\tzend_llist_add_element(&ch->to_free->str, &copystr);\n#if LIBCURL_VERSION_NUM >= 0x071100\n\t} else {\n\t\terror = curl_easy_setopt(ch->cp, option, str);\n\t}\n#endif\n\tSAVE_CURL_ERROR(ch, error)\n\treturn error == CURLE_OK ? SUCCESS : FAILURE;\n}", "target": 0}
{"code": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\ttss_invalidate_io_bitmap(tss);\n\t\treturn;\n\t}\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\trefresh_tss_limit();\n}", "target": 1}
{"code": "static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path) + 1);\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;\n\t\tch2++;\n\t\tif (!*(ch-1))\n\t\t\tbreak;\n\t\twhile (*(ch - 1) == '/' && *ch == '/')\n\t\t\tch++;\n\t}\n\twhile ((ch = strrchr(str, '/'))) {\n\t\tif (ch == str)\n\t\t\tbreak;\n\t\tif (!*(ch+1))\n\t\t\t*ch = 0;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn str;\n}", "target": 0}
{"code": "innodb_clean_engine(\n\tENGINE_HANDLE*\t\thandle,\t\t\n\tconst void*\t\tcookie __attribute__((unused)),\n\tvoid*\t\t\tconn)\t\t\n{\n\tinnodb_conn_data_t*\tconn_data = (innodb_conn_data_t*)conn;\n\tstruct innodb_engine*\tengine = innodb_handle(handle);\n\tvoid*\t\t\torignal_thd;\n\tLOCK_CURRENT_CONN_IF_NOT_LOCKED(false, conn_data);\n\tif (conn_data->thd) {\n\t\thandler_thd_attach(conn_data->thd, &orignal_thd);\n\t}\n\tinnodb_reset_conn(conn_data, true, true, engine->enable_binlog);\n\tinnodb_conn_clean_data(conn_data, true, false);\n\tconn_data->is_stale = true;\n\tUNLOCK_CURRENT_CONN_IF_NOT_LOCKED(false, conn_data);\n}", "target": 0}
{"code": "dup_dest_constraint_hop(const struct dest_constraint_hop *dch,\n    struct dest_constraint_hop *out)\n{\n\tu_int i;\n\tint r;\n\tout->user = dch->user == NULL ? NULL : xstrdup(dch->user);\n\tout->hostname = dch->hostname == NULL ? NULL : xstrdup(dch->hostname);\n\tout->is_ca = dch->is_ca;\n\tout->nkeys = dch->nkeys;\n\tout->keys = out->nkeys == 0 ? NULL :\n\t    xcalloc(out->nkeys, sizeof(*out->keys));\n\tout->key_is_ca = out->nkeys == 0 ? NULL :\n\t    xcalloc(out->nkeys, sizeof(*out->key_is_ca));\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tif (dch->keys[i] != NULL &&\n\t\t    (r = sshkey_from_private(dch->keys[i],\n\t\t    &(out->keys[i]))) != 0)\n\t\t\tfatal_fr(r, \"copy key\");\n\t\tout->key_is_ca[i] = dch->key_is_ca[i];\n\t}\n}", "target": 0}
{"code": "SSL_SESSION *SSL_SESSION_dup(const SSL_SESSION *src)\n{\n    return ssl_session_dup(src, 1);\n}", "target": 1}
{"code": "countAllSwitchActions (union SWF_ACTION *actions, union SWF_ACTION *pre)\n{\n\tint i,j=1;\n\tif (actions->SWF_ACTIONRECORD.ActionCode==SWFACTION_IF && pre->SWF_ACTIONRECORD.ActionCode==SWFACTION_STRICTEQUALS )\n\t{\n\t\tfor(i=0; i < ((struct SWF_ACTIONIF*)actions)->numActions; i++)\n\t\t{\n\t\t\tj+=countAllSwitchActions(&((struct SWF_ACTIONIF*)actions)->Actions[i],pre);\n\t\t\tpre=&((struct SWF_ACTIONIF*)actions)->Actions[i];\n\t\t}\n\t}                  \n\treturn j;\n}", "target": 0}
{"code": "check_SET_VLAN_PCP(struct ofpact_vlan_pcp *a, struct ofpact_check_params *cp)\n{\n    ovs_be16 *tci = &cp->match->flow.vlans[0].tci;\n    a->flow_has_vlan = (*tci & htons(VLAN_CFI)) != 0;\n    if (!a->flow_has_vlan && !a->push_vlan_if_needed) {\n        inconsistent_match(&cp->usable_protocols);\n    }\n    *tci |= htons(VLAN_CFI);\n    return 0;\n}", "target": 0}
{"code": "static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tscm->fp = UNIXCB(skb).fp;\n\tUNIXCB(skb).fp = NULL;\n\tfor (i = scm->fp->count-1; i >= 0; i--)\n\t\tunix_notinflight(scm->fp->fp[i]);\n}", "target": 1}
{"code": "setup_wait_limits(struct infra_cache* infra, struct config_file* cfg)\n{\n\taddr_tree_init(&infra->wait_limits_netblock);\n\taddr_tree_init(&infra->wait_limits_cookie_netblock);\n\tif(!infra_wait_limit_netblock_insert(infra, cfg))\n\t\treturn 0;\n\taddr_tree_init_parents(&infra->wait_limits_netblock);\n\taddr_tree_init_parents(&infra->wait_limits_cookie_netblock);\n\treturn 1;\n}", "target": 0}
{"code": "static int inet_sk_reselect_saddr(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\t__be32 old_saddr = inet->inet_saddr;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\t__be32 new_saddr;\n\tif (inet->opt && inet->opt->srr)\n\t\tdaddr = inet->opt->faddr;\n\trt = ip_route_connect(&fl4, daddr, 0, RT_CONN_FLAGS(sk),\n\t\t\t      sk->sk_bound_dev_if, sk->sk_protocol,\n\t\t\t      inet->inet_sport, inet->inet_dport, sk, false);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\tsk_setup_caps(sk, &rt->dst);\n\tnew_saddr = rt->rt_src;\n\tif (new_saddr == old_saddr)\n\t\treturn 0;\n\tif (sysctl_ip_dynaddr > 1) {\n\t\tprintk(KERN_INFO \"%s(): shifting inet->saddr from %pI4 to %pI4\\n\",\n\t\t       __func__, &old_saddr, &new_saddr);\n\t}\n\tinet->inet_saddr = inet->inet_rcv_saddr = new_saddr;\n\t__sk_prot_rehash(sk);\n\treturn 0;\n}", "target": 1}
{"code": "static HashTable *spl_array_get_gc(zval *object, zval ***gc_data, int *gc_data_count TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\t*gc_data = &intern->array;\n\t*gc_data_count = 1;\n\treturn zend_std_get_properties(object);\n}", "target": 0}
{"code": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\tif (!res)\n\t\tgoto out;\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n}", "target": 0}
{"code": "ossl_cipher_pkcs5_keyivgen(int argc, VALUE *argv, VALUE self)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_MD *digest;\n    VALUE vpass, vsalt, viter, vdigest;\n    unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH], *salt = NULL;\n    int iter;\n    rb_scan_args(argc, argv, \"13\", &vpass, &vsalt, &viter, &vdigest);\n    StringValue(vpass);\n    if(!NIL_P(vsalt)){\n\tStringValue(vsalt);\n\tif(RSTRING_LEN(vsalt) != PKCS5_SALT_LEN)\n\t    ossl_raise(eCipherError, \"salt must be an 8-octet string\");\n\tsalt = (unsigned char *)RSTRING_PTR(vsalt);\n    }\n    iter = NIL_P(viter) ? 2048 : NUM2INT(viter);\n    digest = NIL_P(vdigest) ? EVP_md5() : GetDigestPtr(vdigest);\n    GetCipher(self, ctx);\n    EVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), digest, salt,\n\t\t   (unsigned char *)RSTRING_PTR(vpass), RSTRING_LENINT(vpass), iter, key, iv);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, key, iv, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    OPENSSL_cleanse(key, sizeof key);\n    OPENSSL_cleanse(iv, sizeof iv);\n    rb_ivar_set(self, id_key_set, Qtrue);\n    return Qnil;\n}", "target": 0}
{"code": "MagickExport void CatchException(ExceptionInfo *exception)\n{\n  register const ExceptionInfo\n    *p;\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (exception->exceptions  == (void *) NULL)\n    return;\n  LockSemaphoreInfo(exception->semaphore);\n  ResetLinkedListIterator((LinkedListInfo *) exception->exceptions);\n  p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n    exception->exceptions);\n  while (p != (const ExceptionInfo *) NULL)\n  {\n    if ((p->severity >= WarningException) && (p->severity < ErrorException))\n      MagickWarning(p->severity,p->reason,p->description);\n    if ((p->severity >= ErrorException) && (p->severity < FatalErrorException))\n      MagickError(p->severity,p->reason,p->description);\n    if (p->severity >= FatalErrorException)\n      MagickFatalError(p->severity,p->reason,p->description);\n    p=(const ExceptionInfo *) GetNextValueInLinkedList((LinkedListInfo *)\n      exception->exceptions);\n  }\n  UnlockSemaphoreInfo(exception->semaphore);\n  ClearMagickException(exception);\n}", "target": 1}
{"code": "int jas_stream_pad(jas_stream_t *stream, int n, int c)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_pad\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_putc(stream, c) == EOF)\n\t\t\treturn n - m;\n\t}\n\treturn n;\n}", "target": 0}
{"code": "snmp_ber_decode_timeticks(snmp_packet_t *snmp_packet, uint32_t *timeticks)\n{\n  return snmp_ber_decode_unsigned_integer(snmp_packet, BER_DATA_TYPE_TIMETICKS, timeticks);\n}", "target": 0}
{"code": "flatpak_context_set_persistent (FlatpakContext *context,\n                                const char     *path)\n{\n  g_hash_table_insert (context->persistent, g_strdup (path), GINT_TO_POINTER (1));\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* params;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kParams, &params));\n  const TfLiteTensor* indices;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kIndices, &indices));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE(context, NumElements(params) > 0);\n  switch (indices->type) {\n    case kTfLiteInt32:\n      return EvalGatherNd<int32_t>(context, params, indices, output);\n    case kTfLiteInt64:\n      return EvalGatherNd<int64_t>(context, params, indices, output);\n    default:\n      context->ReportError(\n          context, \"Indices of type '%s' are not supported by gather_nd.\",\n          TfLiteTypeGetName(indices->type));\n      return kTfLiteError;\n  }\n}", "target": 0}
{"code": "client_data cql_server::connection::make_client_data() const {\n    client_data cd;\n    std::tie(cd.ip, cd.port, cd.ct) = make_client_key(_client_state);\n    cd.shard_id = this_shard_id();\n    cd.protocol_version = _version;\n    cd.driver_name = _client_state.get_driver_name();\n    cd.driver_version = _client_state.get_driver_version();\n    if (const auto user_ptr = _client_state.user(); user_ptr) {\n        cd.username = user_ptr->name;\n    }\n    if (_ready) {\n        cd.connection_stage = client_connection_stage::ready;\n    } else if (_authenticating) {\n        cd.connection_stage = client_connection_stage::authenticating;\n    }\n    return cd;\n}", "target": 0}
{"code": "static QString mountPoint(const RemoteFsDevice::Details &details, bool create)\n{\n    if (details.isLocalFile()) {\n        return details.url.path();\n    }\n    return Utils::cacheDir(QLatin1String(\"mount/\")+details.name, create);\n}", "target": 0}
{"code": "static inline struct kmem_cache_node *get_node(struct kmem_cache *s, int node)\n{\n#ifdef CONFIG_NUMA\n\treturn s->node[node];\n#else\n\treturn &s->local_node;\n#endif\n}", "target": 0}
{"code": "  void DoRealForwardFFT(OpKernelContext* ctx, uint64* fft_shape,\n                        const Tensor& in, Tensor* out) {\n    const auto axes = Eigen::ArrayXi::LinSpaced(FFTRank, 1, FFTRank);\n    auto device = ctx->eigen_device<CPUDevice>();\n    auto input = Tensor(in).flat_inner_dims<RealT, FFTRank + 1>();\n    const auto input_dims = input.dimensions();\n    Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> input_slice_sizes;\n    input_slice_sizes[0] = input_dims[0];\n    TensorShape temp_shape{input_dims[0]};\n    for (int i = 1; i <= FFTRank; ++i) {\n      input_slice_sizes[i] = fft_shape[i - 1];\n      temp_shape.AddDim(fft_shape[i - 1]);\n    }\n    OP_REQUIRES(ctx, temp_shape.num_elements() > 0,\n                errors::InvalidArgument(\"Obtained a FFT shape of 0 elements: \",\n                                        temp_shape.DebugString()));\n    auto output = out->flat_inner_dims<ComplexT, FFTRank + 1>();\n    const Eigen::DSizes<Eigen::DenseIndex, FFTRank + 1> zero_start_indices;\n    Tensor temp;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(DataTypeToEnum<ComplexT>::v(),\n                                           temp_shape, &temp));\n    auto full_fft = temp.flat_inner_dims<ComplexT, FFTRank + 1>();\n    full_fft.device(device) =\n        input.slice(zero_start_indices, input_slice_sizes)\n            .template fft<Eigen::BothParts, Eigen::FFT_FORWARD>(axes);\n    output.device(device) =\n        full_fft.slice(zero_start_indices, output.dimensions());\n  }", "target": 0}
{"code": "static int em_ret_near_imm(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\trc = emulate_pop(ctxt, &ctxt->dst.val, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trsp_increment(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "grub_ext4_find_leaf (struct grub_ext2_data *data, char *buf,\n                     struct grub_ext4_extent_header *ext_block,\n                     grub_uint32_t fileblock)\n{\n  struct grub_ext4_extent_idx *index;\n  while (1)\n    {\n      int i;\n      grub_disk_addr_t block;\n      index = (struct grub_ext4_extent_idx *) (ext_block + 1);\n      if (grub_le_to_cpu16(ext_block->magic) != EXT4_EXT_MAGIC)\n        return 0;\n      if (ext_block->depth == 0)\n        return ext_block;\n      for (i = 0; i < grub_le_to_cpu16 (ext_block->entries); i++)\n        {\n          if (fileblock < grub_le_to_cpu32(index[i].block))\n            break;\n        }\n      if (--i < 0)\n        return 0;\n      block = grub_le_to_cpu16 (index[i].leaf_hi);\n      block = (block << 32) + grub_le_to_cpu32 (index[i].leaf);\n      if (grub_disk_read (data->disk,\n                          block << LOG2_EXT2_BLOCK_SIZE (data),\n                          0, EXT2_BLOCK_SIZE(data), buf))\n        return 0;\n      ext_block = (struct grub_ext4_extent_header *) buf;\n    }\n}", "target": 1}
{"code": "TEE_Result syscall_authenc_init(unsigned long state, const void *nonce,\n\t\t\tsize_t nonce_len, size_t tag_len,\n\t\t\tsize_t aad_len, size_t payload_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tstruct tee_cryp_obj_secret *key;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)nonce, nonce_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tkey = o->attr;\n\tres = crypto_authenc_init(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t  (uint8_t *)(key + 1), key->key_size,\n\t\t\t\t  nonce, nonce_len, tag_len, aad_len,\n\t\t\t\t  payload_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tcs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final;\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EINVAL;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\tdesc->len = sizeof(data->verdict);\n\treturn 0;\n}", "target": 0}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *hdr;\n\tu16 crc;\n\tint ret;\n\tskb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\thdr = skb_push(skb, NCI_SPI_HDR_LEN);\n\thdr[0] = NCI_SPI_DIRECT_WRITE;\n\thdr[1] = NCI_SPI_CRC_ENABLED;\n\thdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;\n\thdr[3] = 0;\n\tcrc = crc_ccitt(CRC_INIT, skb->data, skb->len);\n\tskb_put_u8(skb, crc >> 8);\n\tskb_put_u8(skb, crc & 0xFF);\n\tret = __nci_spi_send(nspi, skb, 0);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, Cookie> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "log2vis_unicode (PyObject * unicode, FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *visual = NULL;\t\n\tPyObject *result = NULL;\t\n\tint length = PyUnicode_GET_SIZE (unicode);\n\tlogical = PyUnicode_AsUTF8String (unicode);\n\tif (logical == NULL)\n\t\tgoto cleanup;\n\tvisual = log2vis_utf8 (logical, length, base_direction, clean, reordernsm);\n\tif (visual == NULL)\n\t\tgoto cleanup;\n\tresult = PyUnicode_DecodeUTF8 (PyString_AS_STRING (visual),\n\t\t\t\t       PyString_GET_SIZE (visual), \"strict\");\n      cleanup:\n\tPy_XDECREF (logical);\n\tPy_XDECREF (visual);\n\treturn result;\n}", "target": 1}
{"code": "static int __init pf_init(void)\n{\t\t\t\t\n\tstruct pf_unit *pf;\n\tint unit;\n\tif (disable)\n\t\treturn -EINVAL;\n\tpf_init_units();\n\tif (pf_detect())\n\t\treturn -ENODEV;\n\tpf_busy = 0;\n\tif (register_blkdev(major, name)) {\n\t\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++)\n\t\t\tput_disk(pf->disk);\n\t\treturn -EBUSY;\n\t}\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tstruct gendisk *disk = pf->disk;\n\t\tif (!pf->present)\n\t\t\tcontinue;\n\t\tdisk->private_data = pf;\n\t\tadd_disk(disk);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n    if (x >= 16 || c >= 256) {\n        return AVERROR_INVALIDDATA;\n    }\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n    *rval = c & s->cbits;\n    return 0;\n}", "target": 0}
{"code": "    CommentValue::CharsetId CommentValue::CharsetInfo::charsetIdByCode(\n        const std::string& code)\n    {\n        int i = 0;\n        for (;    charsetTable_[i].charsetId_ != lastCharsetId\n               && std::string(charsetTable_[i].code_, 8) != code; ++i) {}\n        return charsetTable_[i].charsetId_ == lastCharsetId ?\n               invalidCharsetId : charsetTable_[i].charsetId_;\n    }", "target": 0}
{"code": "int32_t CxImage::GetSize()\n{\n\treturn head.biSize + head.biSizeImage + GetPaletteSize();\n}", "target": 1}
{"code": "void CLASS kodak_65000_load_raw()\n{\n  short buf[256];\n  int row, col, len, pred[2], ret, i;\n  for (row=0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col=0; col < width; col+=256) {\n      pred[0] = pred[1] = 0;\n      len = MIN (256, width-col);\n      ret = kodak_65000_decode (buf, len);\n      for (i=0; i < len; i++)\n\tif ((RAW(row,col+i) =\tcurve[ret ? buf[i] :\n\t\t(pred[i & 1] += buf[i])]) >> 12) derror();\n    }\n  }\n}", "target": 1}
{"code": "static int validate_core_offset(const struct kvm_one_reg *reg)\n{\n\tu64 off = core_reg_offset_from_id(reg->id);\n\tint size;\n\tswitch (off) {\n\tcase KVM_REG_ARM_CORE_REG(regs.regs[0]) ...\n\t     KVM_REG_ARM_CORE_REG(regs.regs[30]):\n\tcase KVM_REG_ARM_CORE_REG(regs.sp):\n\tcase KVM_REG_ARM_CORE_REG(regs.pc):\n\tcase KVM_REG_ARM_CORE_REG(regs.pstate):\n\tcase KVM_REG_ARM_CORE_REG(sp_el1):\n\tcase KVM_REG_ARM_CORE_REG(elr_el1):\n\tcase KVM_REG_ARM_CORE_REG(spsr[0]) ...\n\t     KVM_REG_ARM_CORE_REG(spsr[KVM_NR_SPSR - 1]):\n\t\tsize = sizeof(__u64);\n\t\tbreak;\n\tcase KVM_REG_ARM_CORE_REG(fp_regs.vregs[0]) ...\n\t     KVM_REG_ARM_CORE_REG(fp_regs.vregs[31]):\n\t\tsize = sizeof(__uint128_t);\n\t\tbreak;\n\tcase KVM_REG_ARM_CORE_REG(fp_regs.fpsr):\n\tcase KVM_REG_ARM_CORE_REG(fp_regs.fpcr):\n\t\tsize = sizeof(__u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (KVM_REG_SIZE(reg->id) == size &&\n\t    IS_ALIGNED(off, size / sizeof(__u32)))\n\t\treturn 0;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)\n{\n\tunsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);\n\tmemslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);\n\tif (!memslot->dirty_bitmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "CURLcode Curl_close(struct Curl_easy *data)\n{\n  struct Curl_multi *m;\n  if(!data)\n    return CURLE_OK;\n  Curl_expire_clear(data); \n  m = data->multi;\n  if(m)\n    curl_multi_remove_handle(data->multi, data);\n  if(data->multi_easy)\n    curl_multi_cleanup(data->multi_easy);\n  Curl_llist_destroy(&data->state.timeoutlist, NULL);\n  data->magic = 0; \n  if(data->state.rangestringalloc)\n    free(data->state.range);\n  Curl_free_request_state(data);\n  Curl_ssl_close_all(data);\n  Curl_safefree(data->state.first_host);\n  Curl_safefree(data->state.scratch);\n  Curl_ssl_free_certinfo(data);\n  free(data->req.newurl);\n  data->req.newurl = NULL;\n  if(data->change.referer_alloc) {\n    Curl_safefree(data->change.referer);\n    data->change.referer_alloc = FALSE;\n  }\n  data->change.referer = NULL;\n  Curl_up_free(data);\n  Curl_safefree(data->state.buffer);\n  Curl_safefree(data->state.headerbuff);\n  Curl_safefree(data->state.ulbuf);\n  Curl_flush_cookies(data, 1);\n  Curl_digest_cleanup(data);\n  Curl_safefree(data->info.contenttype);\n  Curl_safefree(data->info.wouldredirect);\n  Curl_resolver_cleanup(data->state.resolver);\n  Curl_http2_cleanup_dependencies(data);\n  Curl_convert_close(data);\n  if(data->share) {\n    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);\n    data->share->dirty--;\n    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);\n  }\n  Curl_wildcard_dtor(&data->wildcard);\n  Curl_freeset(data);\n  free(data);\n  return CURLE_OK;\n}", "target": 1}
{"code": "bool generateV2Header(const Network::ProxyProtocolData& proxy_proto_data, Buffer::Instance& out,\n                      bool pass_all_tlvs, const absl::flat_hash_set<uint8_t>& pass_through_tlvs) {\n  uint64_t extension_length = 0;\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    extension_length += PROXY_PROTO_V2_TLV_TYPE_LENGTH_LEN + tlv.value.size();\n    if (extension_length > std::numeric_limits<uint16_t>::max()) {\n      ENVOY_LOG_MISC(\n          warn, \"Generating Proxy Protocol V2 header: TLVs exceed length limit {}, already got {}\",\n          std::numeric_limits<uint16_t>::max(), extension_length);\n      return false;\n    }\n  }\n  ASSERT(extension_length <= std::numeric_limits<uint16_t>::max());\n  if (proxy_proto_data.src_addr_ == nullptr || proxy_proto_data.src_addr_->ip() == nullptr) {\n    IS_ENVOY_BUG(\"Missing or incorrect source IP in proxy_proto_data_\");\n    return false;\n  }\n  if (proxy_proto_data.dst_addr_ == nullptr || proxy_proto_data.dst_addr_->ip() == nullptr) {\n    IS_ENVOY_BUG(\"Missing or incorrect dest IP in proxy_proto_data_\");\n    return false;\n  }\n  const auto& src = *proxy_proto_data.src_addr_->ip();\n  const auto& dst = *proxy_proto_data.dst_addr_->ip();\n  generateV2Header(src.addressAsString(), dst.addressAsString(), src.port(), dst.port(),\n                   src.version(), static_cast<uint16_t>(extension_length), out);\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    out.add(&tlv.type, 1);\n    uint16_t size = htons(static_cast<uint16_t>(tlv.value.size()));\n    out.add(&size, sizeof(uint16_t));\n    out.add(&tlv.value.front(), tlv.value.size());\n  }\n  return true;\n}", "target": 0}
{"code": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\tstrlcpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "void blk_mq_free_tag_set(struct blk_mq_tag_set *set)\n{\n\tint i;\n\tfor (i = 0; i < set->nr_hw_queues; i++) {\n\t\tif (set->tags[i]) {\n\t\t\tblk_mq_free_rq_map(set, set->tags[i], i);\n\t\t\tfree_cpumask_var(set->tags[i]->cpumask);\n\t\t}\n\t}\n\tkfree(set->tags);\n\tset->tags = NULL;\n}", "target": 0}
{"code": "static struct fsnotify_group *inotify_new_group(struct user_struct *user, unsigned int max_events)\n{\n\tstruct fsnotify_group *group;\n\tgroup = fsnotify_alloc_group(&inotify_fsnotify_ops);\n\tif (IS_ERR(group))\n\t\treturn group;\n\tgroup->max_events = max_events;\n\tspin_lock_init(&group->inotify_data.idr_lock);\n\tidr_init(&group->inotify_data.idr);\n\tgroup->inotify_data.last_wd = 0;\n\tgroup->inotify_data.user = user;\n\tgroup->inotify_data.fa = NULL;\n\treturn group;\n}", "target": 1}
{"code": "static void mark_curve(fixed sx, fixed sy, fixed c1x, fixed c1y, fixed c2x, fixed c2y, fixed ex, fixed ey, fixed base_y, fixed height, int *table, int *index, int depth)\n{\n    fixed ax = (sx + c1x)>>1;\n    fixed ay = (sy + c1y)>>1;\n    fixed bx = (c1x + c2x)>>1;\n    fixed by = (c1y + c2y)>>1;\n    fixed cx = (c2x + ex)>>1;\n    fixed cy = (c2y + ey)>>1;\n    fixed dx = (ax + bx)>>1;\n    fixed dy = (ay + by)>>1;\n    fixed fx = (bx + cx)>>1;\n    fixed fy = (by + cy)>>1;\n    fixed gx = (dx + fx)>>1;\n    fixed gy = (dy + fy)>>1;\n    assert(depth >= 0);\n    if (depth == 0)\n        mark_line(sx, sy, ex, ey, base_y, height, table, index);\n    else {\n        depth--;\n        mark_curve(sx, sy, ax, ay, dx, dy, gx, gy, base_y, height, table, index, depth);\n        mark_curve(gx, gy, fx, fy, cx, cy, ex, ey, base_y, height, table, index, depth);\n    }\n}", "target": 0}
{"code": "static GF_AV1Config* AV1_DuplicateConfig(GF_AV1Config const * const cfg) {\n\tu32 i = 0;\n\tGF_AV1Config *out = gf_malloc(sizeof(GF_AV1Config));\n\tout->marker = cfg->marker;\n\tout->version = cfg->version;\n\tout->seq_profile = cfg->seq_profile;\n\tout->seq_level_idx_0 = cfg->seq_level_idx_0;\n\tout->seq_tier_0 = cfg->seq_tier_0;\n\tout->high_bitdepth = cfg->high_bitdepth;\n\tout->twelve_bit = cfg->twelve_bit;\n\tout->monochrome = cfg->monochrome;\n\tout->chroma_subsampling_x = cfg->chroma_subsampling_x;\n\tout->chroma_subsampling_y = cfg->chroma_subsampling_y;\n\tout->chroma_sample_position = cfg->chroma_sample_position;\n\tout->initial_presentation_delay_present = cfg->initial_presentation_delay_present;\n\tout->initial_presentation_delay_minus_one = cfg->initial_presentation_delay_minus_one;\n\tout->obu_array = gf_list_new();\n\tfor (i = 0; i<gf_list_count(cfg->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *dst = gf_malloc(sizeof(GF_AV1_OBUArrayEntry)), *src = gf_list_get(cfg->obu_array, i);\n\t\tdst->obu_length = src->obu_length;\n\t\tdst->obu_type = src->obu_type;\n\t\tdst->obu = gf_malloc((size_t)dst->obu_length);\n\t\tmemcpy(dst->obu, src->obu, (size_t)src->obu_length);\n\t\tgf_list_add(out->obu_array, dst);\n\t}\n\treturn out;\n}", "target": 1}
{"code": "ff_layout_encode_layoutreturn(struct xdr_stream *xdr,\n\t\tconst void *voidargs,\n\t\tconst struct nfs4_xdr_opaque_data *ff_opaque)\n{\n\tconst struct nfs4_layoutreturn_args *args = voidargs;\n\tstruct nfs4_flexfile_layoutreturn_args *ff_args = ff_opaque->data;\n\tstruct xdr_buf tmp_buf = {\n\t\t.head = {\n\t\t\t[0] = {\n\t\t\t\t.iov_base = page_address(ff_args->pages[0]),\n\t\t\t},\n\t\t},\n\t\t.buflen = PAGE_SIZE,\n\t};\n\tstruct xdr_stream tmp_xdr;\n\t__be32 *start;\n\tdprintk(\"%s: Begin\\n\", __func__);\n\txdr_init_encode(&tmp_xdr, &tmp_buf, NULL, NULL);\n\tff_layout_encode_ioerr(&tmp_xdr, args, ff_args);\n\tff_layout_encode_iostats_array(&tmp_xdr, args, ff_args);\n\tstart = xdr_reserve_space(xdr, 4);\n\t*start = cpu_to_be32(tmp_buf.len);\n\txdr_write_pages(xdr, ff_args->pages, 0, tmp_buf.len);\n\tdprintk(\"%s: Return\\n\", __func__);\n}", "target": 0}
{"code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_source_debug_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_DEBUG_EXTENTSION_ATTR;\n\tif (attr->length == 0) {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Attempting to allocate 0 bytes for debug_extension.\\n\");\n\t\tattr->info.debug_extensions.debug_extension = NULL;\n\t\treturn attr;\n\t} else if ((attr->length + offset) > sz) {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Expected %d byte(s) got %\"\n\t\t\tPFMT64d \" bytes for debug_extension.\\n\", attr->length, (offset + sz));\n\t}\n\tattr->info.debug_extensions.debug_extension = (ut8 *) malloc (attr->length);\n\tif (attr->info.debug_extensions.debug_extension && (attr->length > (sz - offset))) {\n\t\tmemcpy (attr->info.debug_extensions.debug_extension, buffer + offset, sz - offset);\n\t} else if (attr->info.debug_extensions.debug_extension) {\n\t\tmemcpy (attr->info.debug_extensions.debug_extension, buffer + offset, attr->length);\n\t} else {\n\t\teprintf (\"r_bin_java_source_debug_attr_new: Unable to allocate the data for the debug_extension.\\n\");\n\t}\n\toffset += attr->length;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 0}
{"code": "get_image_extensions(void)\n{\n\tGHashTable *extensions;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tguint i;\n\tconst char *known_image_formats[] = {\n\t\t\"png\",\n\t\t\"jpg\",\n\t\t\"jpeg\",\n\t\t\"webp\"\n\t};\n\textensions = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t\t    g_free, NULL);\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (ext[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_SUPPORTED));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\tfor (i = 0; i < G_N_ELEMENTS (known_image_formats); i++) {\n\t\tif (!g_hash_table_lookup (extensions, known_image_formats[i])) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (known_image_formats[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_UNSUPPORTED));\n\t\t}\n\t}\n\treturn extensions;\n}", "target": 0}
{"code": "void aio_complete(struct kiocb *iocb, long res, long res2)\n{\n\tstruct kioctx\t*ctx = iocb->ki_ctx;\n\tstruct aio_ring\t*ring;\n\tstruct io_event\t*ev_page, *event;\n\tunsigned tail, pos, head;\n\tunsigned long\tflags;\n\tif (is_sync_kiocb(iocb)) {\n\t\tiocb->ki_user_data = res;\n\t\tsmp_wmb();\n\t\tiocb->ki_ctx = ERR_PTR(-EXDEV);\n\t\twake_up_process(iocb->ki_obj.tsk);\n\t\treturn;\n\t}\n\tif (iocb->ki_list.next) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\t\tlist_del(&iocb->ki_list);\n\t\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n\t}\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\ttail = ctx->tail;\n\tpos = tail + AIO_EVENTS_OFFSET;\n\tif (++tail >= ctx->nr_events)\n\t\ttail = 0;\n\tev_page = kmap_atomic(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tevent = ev_page + pos % AIO_EVENTS_PER_PAGE;\n\tevent->obj = (u64)(unsigned long)iocb->ki_obj.user;\n\tevent->data = iocb->ki_user_data;\n\tevent->res = res;\n\tevent->res2 = res2;\n\tkunmap_atomic(ev_page);\n\tflush_dcache_page(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tpr_debug(\"%p[%u]: %p: %p %Lx %lx %lx\\n\",\n\t\t ctx, tail, iocb, iocb->ki_obj.user, iocb->ki_user_data,\n\t\t res, res2);\n\tsmp_wmb();\t\n\tctx->tail = tail;\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\tring->tail = tail;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\tctx->completed_events++;\n\tif (ctx->completed_events > 1)\n\t\trefill_reqs_available(ctx, head, tail);\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\tpr_debug(\"added to ring %p at [%u]\\n\", iocb, tail);\n\tif (iocb->ki_eventfd != NULL)\n\t\teventfd_signal(iocb->ki_eventfd, 1);\n\tkiocb_free(iocb);\n\tsmp_mb();\n\tif (waitqueue_active(&ctx->wait))\n\t\twake_up(&ctx->wait);\n\tpercpu_ref_put(&ctx->reqs);\n}", "target": 0}
{"code": "static inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\tpmdval_t ret;\n\tu32 *tmp = (u32 *)pmdp;\n\tret = (pmdval_t) (*tmp);\n\tif (ret) {\n\t\tsmp_rmb();\n\t\tret |= ((pmdval_t)*(tmp + 1)) << 32;\n\t}\n\treturn (pmd_t) { ret };\n}", "target": 0}
{"code": "static int nfs_can_extend_write(struct file *file, struct page *page, struct inode *inode)\n{\n\tif (file->f_flags & O_DSYNC)\n\t\treturn 0;\n\tif (NFS_PROTO(inode)->have_delegation(inode, FMODE_WRITE))\n\t\treturn 1;\n\tif (nfs_write_pageuptodate(page, inode) && (inode->i_flock == NULL ||\n\t\t\t(inode->i_flock->fl_start == 0 &&\n\t\t\tinode->i_flock->fl_end == OFFSET_MAX &&\n\t\t\tinode->i_flock->fl_type != F_RDLCK)))\n\t\treturn 1;\n\treturn 0;\n}", "target": 1}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "int blkid_probe_invert_partitions_filter(blkid_probe pr)\n{\n\treturn __blkid_probe_invert_filter(pr, BLKID_CHAIN_PARTS);\n}", "target": 0}
{"code": "void PdfXRefStreamParserObject::ReadXRefTable()\n{\n    int64_t size = this->GetDictionary().FindKeyAs<int64_t>(PdfName::KeySize, 0);\n    auto& arrObj = this->GetDictionary().MustFindKey(\"W\");\n    const PdfArray* arr;\n    if (!arrObj.TryGetArray(arr) || arr->size() != 3)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n    int64_t wArray[W_ARRAY_SIZE] = { 0, 0, 0 };\n    int64_t num;\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (!(*arr)[i].TryGetNumber(num))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n        wArray[i] = num;\n    }\n    vector<int64_t> indices;\n    getIndices(indices, static_cast<int64_t>(size));\n    parseStream(wArray, indices);\n}", "target": 1}
{"code": "static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << NM_VECTOR) | (1u << DB_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR); \n\tif (vcpu->fpu_active)\n\t\teb &= ~(1u << NM_VECTOR);\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}", "target": 1}
{"code": "static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\tif(selector!=1) {\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\tif(selector==0) { \n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\tif(selector==0 || selector==1) {\n\t\tif(!d->iccprofile_file) {\n\t\t\tde_warn(c, \"Bad ICC profile segment\");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}", "target": 0}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithTooLongSni) {\n  upstream_tls_ = true;\n  initializeWithArgs(1024, 1024, \"x-host\");\n  std::string too_long_sni(300, 'a');\n  ASSERT_EQ(too_long_sni.size(), 300); \n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n                                                       {\":path\", \"/test/long/url\"},\n                                                       {\":scheme\", \"http\"},\n                                                       {\":authority\", \"localhost\"},\n                                                       {\"x-host\", too_long_sni}};\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  ASSERT_TRUE(response->waitForEndStream());\n  EXPECT_EQ(\"503\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& boxes = context->input(0);\n    const Tensor& scores = context->input(1);\n    const Tensor& max_output_size = context->input(2);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(max_output_size.shape()),\n        errors::InvalidArgument(\"max_output_size must be 0-D, got shape \",\n                                max_output_size.shape().DebugString()));\n    const Tensor& iou_threshold = context->input(3);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(iou_threshold.shape()),\n                errors::InvalidArgument(\"iou_threshold must be 0-D, got shape \",\n                                        iou_threshold.shape().DebugString()));\n    const T iou_threshold_val = iou_threshold.scalar<T>()();\n    OP_REQUIRES(context,\n                iou_threshold_val >= static_cast<T>(0.0) &&\n                    iou_threshold_val <= static_cast<T>(1.0),\n                errors::InvalidArgument(\"iou_threshold must be in [0, 1]\"));\n    const Tensor& score_threshold = context->input(4);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(score_threshold.shape()),\n        errors::InvalidArgument(\"score_threshold must be 0-D, got shape \",\n                                score_threshold.shape().DebugString()));\n    const T score_threshold_val = score_threshold.scalar<T>()();\n    int num_boxes = 0;\n    ParseAndCheckBoxSizes(context, boxes, &num_boxes);\n    CheckScoreSizes(context, num_boxes, scores);\n    if (!context->status().ok()) {\n      return;\n    }\n    auto similarity_fn = CreateIOUSimilarityFn<T>(boxes);\n    int num_valid_outputs;\n    bool return_scores_tensor_ = false;\n    const T dummy_soft_nms_sigma = static_cast<T>(0.0);\n    DoNonMaxSuppressionOp<T>(\n        context, scores, num_boxes, max_output_size, iou_threshold_val,\n        score_threshold_val, dummy_soft_nms_sigma, similarity_fn,\n        return_scores_tensor_, pad_to_max_output_size_, &num_valid_outputs);\n    if (!context->status().ok()) {\n      return;\n    }\n    Tensor* num_outputs_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                1, tensorflow::TensorShape{}, &num_outputs_t));\n    num_outputs_t->scalar<int32>().setConstant(num_valid_outputs);\n  }", "target": 0}
{"code": "get_certificate_type(X509 *cert, bool is_ta, enum cert_type *result)\n{\n\tif (is_ta) {\n\t\t*result = TA;\n\t\treturn 0;\n\t}\n\tif (X509_check_ca(cert) == 1) {\n\t\t*result = CA;\n\t\treturn 0;\n\t}\n\tif (has_bgpsec_router_eku(cert)) {\n\t\t*result = BGPSEC;\n\t\treturn 0;\n\t}\n\t*result = EE; \n\treturn pr_val_err(\"Certificate is not TA, CA nor BGPsec. Ignoring...\");\n}", "target": 0}
{"code": "ngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n    if (t < 0) {\n        t = 0;\n    }\n    days = t / 86400;\n    sec = t % 86400;\n    if (days > 2932896) {\n        days = 2932896;\n        sec = 86399;\n    }\n    wday = (4 + days) % 7;\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n    days = days - (31 + 28) + 719527;\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n    mon = (yday + 31) * 10 / 306;\n    mday = yday - (367 * mon / 12 - 30) + 1;\n    if (yday >= 306) {\n        year++;\n        mon -= 10;\n    } else {\n        mon += 2;\n    }\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}", "target": 0}
{"code": "static inline void xen_evtchn_handle_events(unsigned cpu)\n{\n\treturn evtchn_ops->handle_events(cpu);\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<_cimg_Ttfloat> get_correlate(const CImg<t>& kernel, const bool boundary_conditions=true,\n                                      const bool is_normalized=false) const {\n      return _correlate(kernel,boundary_conditions,is_normalized,false);", "target": 0}
{"code": "int write_output(void)\n{\n   int fd;\n   struct filter_op *fop;\n   struct filter_header fh;\n   size_t ninst, i;\n   u_char *data;\n   ninst = compile_tree(&fop);\n   if (fop == NULL)\n      return -E_NOTHANDLED;\n   if (ninst == 0)\n      return -E_INVALID;\n   fd = open(EF_GBL_OPTIONS->output_file, O_CREAT | O_RDWR | O_TRUNC | O_BINARY, 0644);\n   ON_ERROR(fd, -1, \"Can't create file %s\", EF_GBL_OPTIONS->output_file);\n   fprintf(stdout, \" Writing output to \\'%s\\' \", EF_GBL_OPTIONS->output_file);\n   fflush(stdout);\n   fh.magic = htons(EC_FILTER_MAGIC);\n   strncpy(fh.version, EC_VERSION, sizeof(fh.version));\n   fh.data = sizeof(fh);\n   data = create_data_segment(&fh, fop, ninst);\n   write(fd, &fh, sizeof(struct filter_header));\n   write(fd, data, fh.code - fh.data);\n   for (i = 0; i <= ninst; i++) {\n      print_progress_bar(&fop[i]);\n      write(fd, &fop[i], sizeof(struct filter_op));\n   }\n   close(fd);\n   fprintf(stdout, \" done.\\n\\n\");\n   fprintf(stdout, \" -> Script encoded into %d instructions.\\n\\n\", (int)(i - 1));\n   return E_SUCCESS;\n}", "target": 0}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0) {\n\t\tchar *name = path_name(path, last);\n\t\tbitmap_pos = ext_index_add_object(object, name);\n\t\tfree(name);\n\t}\n\tbitmap_set(base, bitmap_pos);\n}", "target": 1}
{"code": "static int newary(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tint id;\n\tint retval;\n\tstruct sem_array *sma;\n\tint size;\n\tkey_t key = params->key;\n\tint nsems = params->u.nsems;\n\tint semflg = params->flg;\n\tint i;\n\tif (!nsems)\n\t\treturn -EINVAL;\n\tif (ns->used_sems + nsems > ns->sc_semmns)\n\t\treturn -ENOSPC;\n\tsize = sizeof (*sma) + nsems * sizeof (struct sem);\n\tsma = ipc_rcu_alloc(size);\n\tif (!sma) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset (sma, 0, size);\n\tsma->sem_perm.mode = (semflg & S_IRWXUGO);\n\tsma->sem_perm.key = key;\n\tsma->sem_perm.security = NULL;\n\tretval = security_sem_alloc(sma);\n\tif (retval) {\n\t\tipc_rcu_putref(sma);\n\t\treturn retval;\n\t}\n\tid = ipc_addid(&sem_ids(ns), &sma->sem_perm, ns->sc_semmni);\n\tif (id < 0) {\n\t\tsecurity_sem_free(sma);\n\t\tipc_rcu_putref(sma);\n\t\treturn id;\n\t}\n\tns->used_sems += nsems;\n\tsma->sem_base = (struct sem *) &sma[1];\n\tfor (i = 0; i < nsems; i++)\n\t\tINIT_LIST_HEAD(&sma->sem_base[i].sem_pending);\n\tsma->complex_count = 0;\n\tINIT_LIST_HEAD(&sma->sem_pending);\n\tINIT_LIST_HEAD(&sma->list_id);\n\tsma->sem_nsems = nsems;\n\tsma->sem_ctime = get_seconds();\n\tsem_unlock(sma);\n\treturn sma->sem_perm.id;\n}", "target": 1}
{"code": "static int vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tfor (;;) {\n\t\tvcpu->arch.at_instruction_boundary = false;\n\t\tif (kvm_vcpu_running(vcpu)) {\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\t} else {\n\t\t\tr = vcpu_block(vcpu);\n\t\t}\n\t\tif (r <= 0)\n\t\t\tbreak;\n\t\tkvm_clear_request(KVM_REQ_UNBLOCK, vcpu);\n\t\tif (kvm_xen_has_pending_events(vcpu))\n\t\t\tkvm_xen_inject_pending_events(vcpu);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\t\tif (dm_request_for_irq_injection(vcpu) &&\n\t\t\tkvm_vcpu_ready_for_interrupt_injection(vcpu)) {\n\t\t\tr = 0;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t\tbreak;\n\t\t}\n\t\tif (__xfer_to_guest_mode_work_pending()) {\n\t\t\tkvm_vcpu_srcu_read_unlock(vcpu);\n\t\t\tr = xfer_to_guest_mode_handle_work(vcpu);\n\t\t\tkvm_vcpu_srcu_read_lock(vcpu);\n\t\t\tif (r)\n\t\t\t\treturn r;\n\t\t}\n\t}\n\treturn r;\n}", "target": 0}
{"code": "static inline int ip_ufo_append_data(struct sock *sk,\n\t\t\tstruct sk_buff_head *queue,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\t       int odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int maxfraglen, unsigned int flags)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif ((skb = skb_peek_tail(queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\t__skb_queue_tail(queue, skb);\n\t}\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}", "target": 1}
{"code": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "void WasmBinaryBuilder::read() {\n  if (DWARF) {\n    if (!hasDWARFSections()) {\n      DWARF = false;\n    }\n  }\n  readHeader();\n  readSourceMapHeader();\n  while (more()) {\n    uint8_t sectionCode = getInt8();\n    uint32_t payloadLen = getU32LEB();\n    if (uint64_t(pos) + uint64_t(payloadLen) > input.size()) {\n      throwError(\"Section extends beyond end of input\");\n    }\n    auto oldPos = pos;\n    if (sectionCode != BinaryConsts::Section::User &&\n        sectionCode != BinaryConsts::Section::Code) {\n      if (!seenSections.insert(BinaryConsts::Section(sectionCode)).second) {\n        throwError(\"section seen more than once: \" +\n                   std::to_string(sectionCode));\n      }\n    }\n    switch (sectionCode) {\n      case BinaryConsts::Section::Start:\n        readStart();\n        break;\n      case BinaryConsts::Section::Memory:\n        readMemory();\n        break;\n      case BinaryConsts::Section::Type:\n        readTypes();\n        break;\n      case BinaryConsts::Section::Import:\n        readImports();\n        break;\n      case BinaryConsts::Section::Function:\n        readFunctionSignatures();\n        break;\n      case BinaryConsts::Section::Code:\n        if (DWARF) {\n          codeSectionLocation = pos;\n        }\n        readFunctions();\n        break;\n      case BinaryConsts::Section::Export:\n        readExports();\n        break;\n      case BinaryConsts::Section::Element:\n        readElementSegments();\n        break;\n      case BinaryConsts::Section::Global:\n        readGlobals();\n        break;\n      case BinaryConsts::Section::Data:\n        readDataSegments();\n        break;\n      case BinaryConsts::Section::DataCount:\n        readDataCount();\n        break;\n      case BinaryConsts::Section::Table:\n        readTableDeclarations();\n        break;\n      case BinaryConsts::Section::Tag:\n        readTags();\n        break;\n      default: {\n        readUserSection(payloadLen);\n        if (pos > oldPos + payloadLen) {\n          throwError(\"bad user section size, started at \" +\n                     std::to_string(oldPos) + \" plus payload \" +\n                     std::to_string(payloadLen) +\n                     \" not being equal to new position \" + std::to_string(pos));\n        }\n        pos = oldPos + payloadLen;\n      }\n    }\n    if (pos != oldPos + payloadLen) {\n      throwError(\"bad section size, started at \" + std::to_string(oldPos) +\n                 \" plus payload \" + std::to_string(payloadLen) +\n                 \" not being equal to new position \" + std::to_string(pos));\n    }\n  }\n  validateBinary();\n  processNames();\n}", "target": 0}
{"code": "int bson_check_string( bson *b, const char *string,\n                       const int length ) {\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );\n}", "target": 1}
{"code": "bool ParamTraits<base::Time>::Read(const Message* m, PickleIterator* iter,\n                                   param_type* r) {\n  int64 value;\n  if (!ParamTraits<int64>::Read(m, iter, &value))\n    return false;\n  *r = base::Time::FromInternalValue(value);\n  return true;\n}", "target": 0}
{"code": "void OpenURL(const char *url)\n{\n    if (strchr(url, '\\'') != NULL)\n    {\n        TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL is not valid\");\n    }\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));\n    #if defined(_WIN32)\n        sprintf(cmd, \"explorer \\\"%s\\\"\", url);\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        sprintf(cmd, \"xdg-open '%s'\", url); \n    #endif\n    #if defined(__APPLE__)\n        sprintf(cmd, \"open '%s'\", url);\n    #endif\n        int result = system(cmd);\n        if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");\n        RL_FREE(cmd);\n#endif\n#if defined(PLATFORM_WEB)\n        emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));\n#endif\n#if defined(PLATFORM_ANDROID)\n        JNIEnv *env = NULL;\n        JavaVM *vm = CORE.Android.app->activity->vm;\n        (*vm)->AttachCurrentThread(vm, &env, NULL);\n        jstring urlString = (*env)->NewStringUTF(env, url);\n        jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");\n        jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");\n        jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);\n        jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");\n        jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");\n        jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);\n        jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");\n        jobject intent = (*env)->AllocObject(env, intentClass);\n        (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);\n        jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");\n        jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");\n        (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);\n        (*vm)->DetachCurrentThread(vm);\n#endif\n    }\n}", "target": 1}
{"code": "unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {\n    if (first == NULL || *first == NULL || second == NULL || *second == NULL)\n        return NULL;\n    if (*first == *second)\n        return NULL;\n    size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));\n    size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));\n    size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));\n    size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));\n    int append;\n    unsigned char *source, *target;\n    size_t target_bytes, source_bytes;\n    if (first_len >= second_len) {\n        target = *first;\n        target_bytes = first_bytes;\n        source = *second;\n        source_bytes = second_bytes;\n        append = 1;\n    } else {\n        target = *second;\n        target_bytes = second_bytes;\n        source = *first;\n        source_bytes = first_bytes;\n        append = 0;\n    }\n    size_t zlbytes = first_bytes + second_bytes -\n                     ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;\n    size_t zllength = first_len + second_len;\n    zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;\n    assert(zlbytes < UINT32_MAX);\n    size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));\n    size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));\n    target = zrealloc(target, zlbytes);\n    if (append) {\n        memcpy(target + target_bytes - ZIPLIST_END_SIZE,\n               source + ZIPLIST_HEADER_SIZE,\n               source_bytes - ZIPLIST_HEADER_SIZE);\n    } else {\n        memmove(target + source_bytes - ZIPLIST_END_SIZE,\n                target + ZIPLIST_HEADER_SIZE,\n                target_bytes - ZIPLIST_HEADER_SIZE);\n        memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);\n    }\n    ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);\n    ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);\n    ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(\n                                   (first_bytes - ZIPLIST_END_SIZE) +\n                                   (second_offset - ZIPLIST_HEADER_SIZE));\n    target = __ziplistCascadeUpdate(target, target+first_offset);\n    if (append) {\n        zfree(*second);\n        *second = NULL;\n        *first = target;\n    } else {\n        zfree(*first);\n        *first = NULL;\n        *second = target;\n    }\n    return target;\n}", "target": 0}
{"code": "static void nvme_select_iocs_ns(NvmeCtrl *n, NvmeNamespace *ns)\n{\n    uint32_t cc = ldl_le_p(&n->bar.cc);\n    ns->iocs = nvme_cse_iocs_none;\n    switch (ns->csi) {\n    case NVME_CSI_NVM:\n        if (NVME_CC_CSS(cc) != NVME_CC_CSS_ADMIN_ONLY) {\n            ns->iocs = nvme_cse_iocs_nvm;\n        }\n        break;\n    case NVME_CSI_ZONED:\n        if (NVME_CC_CSS(cc) == NVME_CC_CSS_CSI) {\n            ns->iocs = nvme_cse_iocs_zoned;\n        } else if (NVME_CC_CSS(cc) == NVME_CC_CSS_NVM) {\n            ns->iocs = nvme_cse_iocs_nvm;\n        }\n        break;\n    }\n}", "target": 0}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tr14\\n\" \n\t\t\"=BP\tsrp\\n\" \n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr0\\n\"\n\t\t\"=A1\tr1\\n\"\n\t\t\"=A2\tr2\\n\"\n\t\t\"=A3\tr3\\n\"\n\t\t\"gpr\tsp\t.32\t56\t0\\n\" \n\t\t\"gpr\tacr\t.32\t60\t0\\n\" \n\t\t\"gpr\tpc\t.32\t64\t0\\n\" \n\t\t\"gpr\tsrp\t.32\t68\t0\\n\" \n\t\t\"gpr\tr0\t.32\t0\t0\\n\"\n\t\t\"gpr\tr1\t.32\t4\t0\\n\"\n\t\t\"gpr\tr2\t.32\t8\t0\\n\"\n\t\t\"gpr\tr3\t.32\t12\t0\\n\"\n\t\t\"gpr\tr4\t.32\t16\t0\\n\"\n\t\t\"gpr\tr5\t.32\t20\t0\\n\"\n\t\t\"gpr\tr6\t.32\t24\t0\\n\"\n\t\t\"gpr\tr7\t.32\t28\t0\\n\"\n\t\t\"gpr\tr8\t.32\t32\t0\\n\"\n\t\t\"gpr\tr9\t.32\t36\t0\\n\"\n\t\t\"gpr\tr10\t.32\t40\t0\\n\"\n\t\t\"gpr\tr11\t.32\t44\t0\\n\"\n\t\t\"gpr\tr12\t.32\t48\t0\\n\"\n\t\t\"gpr\tr13\t.32\t52\t0\\n\"\n\t\t\"gpr\tr14\t.32\t56\t0\\n\"\n\t\t\"gpr\tr15\t.32\t60\t0\\n\"\n\t\t;\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "static TEE_Result do_allocate_keypair(struct dsa_keypair *key, size_t l_bits,\n\t\t\t\t      size_t n_bits)\n{\n\tDSA_TRACE(\"DSA allocate Keypair of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(n_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n\t\t   struct sockaddr_storage *kern_address, int mode)\n{\n\tint tot_len;\n\tif (kern_msg->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tint err = move_addr_to_kernel(kern_msg->msg_name,\n\t\t\t\t\t\t      kern_msg->msg_namelen,\n\t\t\t\t\t\t      kern_address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tkern_msg->msg_name = kern_address;\n\t} else\n\t\tkern_msg->msg_name = NULL;\n\ttot_len = iov_from_user_compat_to_kern(kern_iov,\n\t\t\t\t\t  (struct compat_iovec __user *)kern_msg->msg_iov,\n\t\t\t\t\t  kern_msg->msg_iovlen);\n\tif (tot_len >= 0)\n\t\tkern_msg->msg_iov = kern_iov;\n\treturn tot_len;\n}", "target": 1}
{"code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n    update_canvas_size(avctx, avctx->width, avctx->height);\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}", "target": 1}
{"code": "static void lateeoi_list_del(struct irq_info *info)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, info->eoi_cpu);\n\tunsigned long flags;\n\tspin_lock_irqsave(&eoi->eoi_list_lock, flags);\n\tlist_del_init(&info->eoi_list);\n\tspin_unlock_irqrestore(&eoi->eoi_list_lock, flags);\n}", "target": 0}
{"code": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}", "target": 1}
{"code": "static inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn tfm->generate(tfm, src, slen, dst, dlen);\n}", "target": 1}
{"code": "unsigned int add_ch(unsigned char ch, unsigned char* buf, unsigned int idx) {\n    if (idx >= MAX_ALN) {\n        verbprintf(3, \"FLEX: idx %u >= MAX_ALN %u\\n\", idx, MAX_ALN);\n        return 0;\n    }\n    if (ch == 0x09 && idx < (MAX_ALN - 2)) {  \n        buf[idx] = '\\\\';\n        buf[idx + 1] = 't';\n        return 2;\n    }\n    if (ch == 0x0a && idx < (MAX_ALN - 2)) {  \n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'n';\n        return 2;\n    }\n    if (ch == 0x0d && idx < (MAX_ALN - 2)) {  \n        buf[idx] = '\\\\';\n        buf[idx + 1] = 'r';\n        return 2;\n    }\n    if (ch == '%') {\n        if (idx < (MAX_ALN - 2)) {\n            buf[idx] = '%';\n            buf[idx + 1] = '%';\n            return 2;\n        }\n        return 0;\n    }\n    if (ch >= 32 && ch <= 126) {\n        buf[idx] = ch;\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"code": "std::wstring MB2WC(const std::string& input, unsigned int code_page) {\n  if (input.empty()) {\n    return L\"\";\n  }\n  int length = ::MultiByteToWideChar(code_page, 0, &input[0],\n                                     static_cast<int>(input.size()),\n                                     NULL, 0);\n  std::wstring output(length, '\\0');\n  ::MultiByteToWideChar(code_page, 0, &input[0], static_cast<int>(input.size()),\n                        &output[0], static_cast<int>(output.size()));\n  return output;\n}", "target": 1}
{"code": "  friend H AbslHashValue(H h, const TensorKey& k) {\n    const uint8* d = static_cast<uint8*>(k.data());\n    size_t s = k.AllocatedBytes();\n    std::vector<uint8> vec;\n    vec.reserve(s);\n    for (int i = 0; i < s; i++) {\n      vec.push_back(d[i]);\n    }\n    return H::combine(std::move(h), s);\n  }", "target": 1}
{"code": "jas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tchar *new_buf;\n\tsize_t new_bufsize;\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\tif (bufsize < 0) {\n\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n\t}\n\tif (buf && bufsize <= 0) {\n\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n\t\tjas_deprecated(\"A user-provided buffer for \"\n\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n\t}\n\tif (bufsize <= 0) {\n\t\tnew_bufsize = 0;\n\t\tnew_buf = 0;\n\t} else {\n\t\tnew_bufsize = bufsize;\n\t\tnew_buf = buf;\n\t}\n\treturn jas_stream_memopen2(new_buf, new_bufsize);\n}", "target": 0}
{"code": "atol8(const char *p, size_t char_cnt)\n{\n\tint64_t l;\n\tint digit;\n\tl = 0;\n\twhile (char_cnt-- > 0) {\n\t\tif (*p >= '0' && *p <= '7')\n\t\t\tdigit = *p - '0';\n\t\telse\n\t\t\tbreak;\n\t\tp++;\n\t\tl <<= 3;\n\t\tl |= digit;\n\t}\n\treturn (l);\n}", "target": 1}
{"code": "bool ArcMemory::Read(void *Data,size_t Size,size_t &Result)\n{\n  if (!Loaded)\n    return false;\n  Result=(size_t)Min(Size,ArcData.Size()-SeekPos);\n  memcpy(Data,&ArcData[(size_t)SeekPos],Result);\n  SeekPos+=Result;\n  return true;\n}", "target": 0}
{"code": "int test_gtpu_send_indirect_data_forwarding(\n        ogs_socknode_t *node, test_bearer_t *bearer, ogs_pkbuf_t *pkbuf)\n{\n    test_sess_t *sess = NULL;\n    ogs_gtp2_header_t gtp_hdesc;\n    ogs_gtp2_extension_header_t ext_hdesc;\n    ogs_assert(bearer);\n    sess = bearer->sess;\n    ogs_assert(sess);\n    ogs_assert(pkbuf);\n    memset(&gtp_hdesc, 0, sizeof(gtp_hdesc));\n    memset(&ext_hdesc, 0, sizeof(ext_hdesc));\n    gtp_hdesc.type = OGS_GTPU_MSGTYPE_GPDU;\n    if (bearer->qfi) {\n        gtp_hdesc.teid = sess->handover.upf_dl_teid;\n        ext_hdesc.qos_flow_identifier = bearer->qfi;\n    } else if (bearer->ebi) {\n        ogs_fatal(\"Not implmented EPC Indirect Tunnel\");\n        ogs_assert_if_reached();\n    } else {\n        ogs_fatal(\"No QFI[%d] and EBI[%d]\", bearer->qfi, bearer->ebi);\n        ogs_assert_if_reached();\n    }\n    return test_gtpu_send(node, bearer, &gtp_hdesc, &ext_hdesc, pkbuf);\n}", "target": 1}
{"code": "void mt_init(mtrand *mt, uint32_t seed) {\n  int i;\n  mt->mt_buffer_[0] = seed;\n  mt->mt_index_ = MT_LEN;\n  for (i = 1; i < MT_LEN; i++) {\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^ \n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}", "target": 1}
{"code": "av_cold void ff_mpv_idct_init(MpegEncContext *s)\n{\n    if (s->codec_id == AV_CODEC_ID_MPEG4)\n        s->idsp.mpeg4_studio_profile = s->studio_profile;\n    ff_idctdsp_init(&s->idsp, s->avctx);\n    if (s->alternate_scan) {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_alternate_vertical_scan);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_alternate_vertical_scan);\n    } else {\n        ff_init_scantable(s->idsp.idct_permutation, &s->inter_scantable, ff_zigzag_direct);\n        ff_init_scantable(s->idsp.idct_permutation, &s->intra_scantable, ff_zigzag_direct);\n    }\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_h_scantable, ff_alternate_horizontal_scan);\n    ff_init_scantable(s->idsp.idct_permutation, &s->intra_v_scantable, ff_alternate_vertical_scan);\n}", "target": 0}
{"code": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tcp = (uint8 *) cp0;\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[bps * count + byte] = tmp[byte * wc + count];\n\t\t\t#else\n\t\t\tcp[bps * count + byte] =\n\t\t\t\ttmp[(bps - byte - 1) * wc + count];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n    return 1;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n    std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =\n        GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,\n                                               shapes_list_in, dense_list_in);\n    const tstring k_feature_separator = \"_X_\";\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Crosser crosser(\n        columns, num_buckets_, hash_key_, k_feature_separator);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Updater updater(\n        output_start_indices, indices_out, values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<InternalType> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }", "target": 1}
{"code": "static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tstruct desc_ptr dt;\n\tvmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);  \n\tvmcs_writel(HOST_CR4, read_cr4());  \n\tvmcs_writel(HOST_CR3, read_cr3());  \n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  \n#ifdef CONFIG_X86_64\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  \n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  \n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  \n\tnative_store_idt(&dt);\n\tvmcs_writel(HOST_IDTR_BASE, dt.address);   \n\tvmx->host_idt_base = dt.address;\n\tvmcs_writel(HOST_RIP, vmx_return); \n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   \n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n}", "target": 1}
{"code": "static int ghash_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *dst = dctx->buffer;\n\tif (!ctx->gf128)\n\t\treturn -ENOKEY;\n\tif (dctx->bytes) {\n\t\tint n = min(srclen, dctx->bytes);\n\t\tu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\t\tif (!dctx->bytes)\n\t\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t}\n\twhile (srclen >= GHASH_BLOCK_SIZE) {\n\t\tcrypto_xor(dst, src, GHASH_BLOCK_SIZE);\n\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t\tsrc += GHASH_BLOCK_SIZE;\n\t\tsrclen -= GHASH_BLOCK_SIZE;\n\t}\n\tif (srclen) {\n\t\tdctx->bytes = GHASH_BLOCK_SIZE - srclen;\n\t\twhile (srclen--)\n\t\t\t*dst++ ^= *src++;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "target": 0}
{"code": "static void pcd_init_units(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tpcd_drive_count = 0;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tstruct gendisk *disk = alloc_disk(1);\n\t\tif (!disk)\n\t\t\tcontinue;\n\t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n\t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disk->queue)) {\n\t\t\tput_disk(disk);\n\t\t\tdisk->queue = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_LIST_HEAD(&cd->rq_list);\n\t\tdisk->queue->queuedata = cd;\n\t\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\t\tcd->disk = disk;\n\t\tcd->pi = &cd->pia;\n\t\tcd->present = 0;\n\t\tcd->last_sense = 0;\n\t\tcd->changed = 1;\n\t\tcd->drive = (*drives[unit])[D_SLV];\n\t\tif ((*drives[unit])[D_PRT])\n\t\t\tpcd_drive_count++;\n\t\tcd->name = &cd->info.name[0];\n\t\tsnprintf(cd->name, sizeof(cd->info.name), \"%s%d\", name, unit);\n\t\tcd->info.ops = &pcd_dops;\n\t\tcd->info.handle = cd;\n\t\tcd->info.speed = 0;\n\t\tcd->info.capacity = 1;\n\t\tcd->info.mask = 0;\n\t\tdisk->major = major;\n\t\tdisk->first_minor = unit;\n\t\tstrcpy(disk->disk_name, cd->name);\t\n\t\tdisk->fops = &pcd_bdops;\n\t\tdisk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\n\t}\n}", "target": 0}
{"code": "authDigestNonceLinks(digest_nonce_h * nonce)\n{\n    if (!nonce)\n        return -1;\n    return nonce->references;\n}", "target": 1}
{"code": "yy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)\n{\n  int res = 0;\n  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;\n  if (0 <= yylocp->first_line)\n    {\n      res += YYFPRINTF (yyo, \"%d\", yylocp->first_line);\n      if (0 <= yylocp->first_column)\n        res += YYFPRINTF (yyo, \".%d\", yylocp->first_column);\n    }\n  if (0 <= yylocp->last_line)\n    {\n      if (yylocp->first_line < yylocp->last_line)\n        {\n          res += YYFPRINTF (yyo, \"-%d\", yylocp->last_line);\n          if (0 <= end_col)\n            res += YYFPRINTF (yyo, \".%d\", end_col);\n        }\n      else if (0 <= end_col && yylocp->first_column < end_col)\n        res += YYFPRINTF (yyo, \"-%d\", end_col);\n    }\n  return res;\n }", "target": 1}
{"code": "check_mul_overflow(size_t a, size_t b, size_t* res)\n{\n    size_t tmp = a * b;\n    if (a != 0 && tmp / a != b) return 1;\n    *res = tmp;\n    return 0;\n}", "target": 0}
{"code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}", "target": 1}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "void Node::RunForwardTypeInference() {\n  VLOG(4) << \"Forward type inference: \" << props_->node_def.DebugString();\n  if (props_->fwd_type_fn == nullptr) {\n    return;\n  }\n  std::vector<Node*> input_nodes(props_->input_types.size(), nullptr);\n  std::vector<int> input_idx(props_->input_types.size(), 0);\n  for (const auto& edge : in_edges_) {\n    if (edge->IsControlEdge()) {\n      continue;\n    }\n    DCHECK(edge->dst_input() < input_nodes.size()) << DebugString();\n    int i = edge->dst_input();\n    input_nodes.at(i) = edge->src();\n    input_idx.at(i) = edge->src_output();\n  }\n  for (const auto* node : input_nodes) {\n    if (node == nullptr) {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  static FullTypeDef* no_type = new FullTypeDef();\n  std::vector<std::reference_wrapper<const FullTypeDef>> input_types;\n  for (int i = 0; i < input_nodes.size(); i++) {\n    const auto* node = input_nodes[i];\n    if (node->def().has_experimental_type()) {\n      const auto& node_t = node->def().experimental_type();\n      if (node_t.type_id() != TFT_UNSET) {\n        int ix = input_idx[i];\n        DCHECK(ix < node_t.args_size())\n            << \"input \" << i << \" should have an output \" << ix\n            << \" but instead only has \" << node_t.args_size()\n            << \" outputs: \" << node_t.DebugString();\n        input_types.emplace_back(node_t.args(ix));\n      } else {\n        input_types.emplace_back(*no_type);\n      }\n    } else {\n      ClearTypeInfo();\n      return;\n    }\n  }\n  const auto infer_type = props_->fwd_type_fn(input_types);\n  const FullTypeDef infer_typedef = infer_type.ValueOrDie();\n  if (infer_typedef.type_id() != TFT_UNSET) {\n    MaybeCopyOnWrite();\n    *(props_->node_def.mutable_experimental_type()) = infer_typedef;\n  }\n}", "target": 1}
{"code": "static unsigned long page_table_shareable(struct vm_area_struct *svma,\n\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\tunsigned long addr, pgoff_t idx)\n{\n\tunsigned long saddr = ((idx - svma->vm_pgoff) << PAGE_SHIFT) +\n\t\t\t\tsvma->vm_start;\n\tunsigned long sbase = saddr & PUD_MASK;\n\tunsigned long s_end = sbase + PUD_SIZE;\n\tunsigned long vm_flags = vma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tunsigned long svm_flags = svma->vm_flags & VM_LOCKED_CLEAR_MASK;\n\tif (pmd_index(addr) != pmd_index(saddr) ||\n\t    vm_flags != svm_flags ||\n\t    !range_in_vma(svma, sbase, s_end))\n\t\treturn 0;\n\treturn saddr;\n}", "target": 0}
{"code": "bool PixelFormat::is888(void) const\n{\n  if (!trueColour)\n    return false;\n  if (bpp != 32)\n    return false;\n  if (depth != 24)\n    return false;\n  if (redMax != 255)\n    return false;\n  if (greenMax != 255)\n    return false;\n  if (blueMax != 255)\n    return false;\n  if ((redShift & 0x7) != 0)\n    return false;\n  if ((greenShift & 0x7) != 0)\n    return false;\n  if ((blueShift & 0x7) != 0)\n    return false;\n  return true;\n}", "target": 0}
{"code": "snmp_ber_encode_null(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  (*out_len)++;\n  *out-- = 0x00;\n  out = snmp_ber_encode_type(out, out_len, type);\n  return out;\n}", "target": 1}
{"code": "int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],\n\t\t     unsigned char multicast_spec, u8 protocol_version)\n{\n\tstruct hsr_priv *hsr;\n\tstruct hsr_port *port;\n\tint res;\n\thsr = netdev_priv(hsr_dev);\n\tINIT_LIST_HEAD(&hsr->ports);\n\tINIT_LIST_HEAD(&hsr->node_db);\n\tINIT_LIST_HEAD(&hsr->self_node_db);\n\tether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);\n\tres = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,\n\t\t\t\t   slave[1]->dev_addr);\n\tif (res < 0)\n\t\treturn res;\n\tspin_lock_init(&hsr->seqnr_lock);\n\thsr->sequence_nr = HSR_SEQNR_START;\n\thsr->sup_sequence_nr = HSR_SUP_SEQNR_START;\n\ttimer_setup(&hsr->announce_timer, hsr_announce, 0);\n\ttimer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);\n\tether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);\n\thsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;\n\thsr->protVersion = protocol_version;\n\tnetif_carrier_off(hsr_dev);\n\tres = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);\n\tif (res)\n\t\treturn res;\n\tres = register_netdevice(hsr_dev);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);\n\tif (res)\n\t\tgoto fail;\n\tres = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);\n\tif (res)\n\t\tgoto fail;\n\tmod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));\n\treturn 0;\nfail:\n\thsr_for_each_port(hsr, port)\n\t\thsr_del_port(port);\n\treturn res;\n}", "target": 1}
{"code": "static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tmemcpy(state->stateid.data, deleg_stateid->data, sizeof(state->stateid.data));\n\t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n\tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, open_flags);\n\tspin_unlock(&state->owner->so_lock);\n}", "target": 1}
{"code": "void InferenceContext::PreInputInit(\n    const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,\n    const std::vector<ShapeHandle>& input_tensors_as_shapes) {\n  const auto ret = full_type::SpecializeType(attrs_, op_def);\n  DCHECK(ret.status().ok()) << \"while instantiating types: \" << ret.status();\n  ret_types_ = ret.ValueOrDie();\n  input_tensors_ = input_tensors;\n  input_tensors_as_shapes_ = input_tensors_as_shapes;\n  construction_status_ =\n      NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);\n  if (!construction_status_.ok()) return;\n  int num_outputs = 0;\n  for (const auto& e : output_name_map_) {\n    num_outputs = std::max(num_outputs, e.second.second);\n  }\n  outputs_.assign(num_outputs, nullptr);\n  output_handle_shapes_and_types_.resize(num_outputs);\n}", "target": 1}
{"code": "int compat_ipv6_setsockopt(struct sock *sk, int level, int optname,\n\t\t\t   char __user *optval, unsigned int optlen)\n{\n\tint err;\n\tif (level == SOL_IP && sk->sk_type != SOCK_RAW) {\n\t\tif (udp_prot.compat_setsockopt != NULL)\n\t\t\treturn udp_prot.compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t\t  optval, optlen);\n\t\treturn udp_prot.setsockopt(sk, level, optname, optval, optlen);\n\t}\n\tif (level != SOL_IPV6)\n\t\treturn -ENOPROTOOPT;\n\tif (optname >= MCAST_JOIN_GROUP && optname <= MCAST_MSFILTER)\n\t\treturn compat_mc_setsockopt(sk, level, optname, optval, optlen,\n\t\t\tipv6_setsockopt);\n\terr = do_ipv6_setsockopt(sk, level, optname, optval, optlen);\n#ifdef CONFIG_NETFILTER\n\tif (err == -ENOPROTOOPT && optname != IPV6_IPSEC_POLICY &&\n\t    optname != IPV6_XFRM_POLICY)\n\t\terr = compat_nf_setsockopt(sk, PF_INET6, optname, optval,\n\t\t\t\t\t   optlen);\n#endif\n\treturn err;\n}", "target": 0}
{"code": "smb_flush_file(struct smb_request *sr, struct smb_ofile *ofile)\n{\n\tsr->user_cr = smb_ofile_getcred(ofile);\n\tif ((ofile->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t(void) smb_fsop_commit(sr, sr->user_cr, ofile->f_node);\n}", "target": 1}
{"code": "log_close_all(void)\n{\nif (mainlogfd >= 0)\n  { (void)close(mainlogfd); mainlogfd = -1; }\nif (rejectlogfd >= 0)\n  { (void)close(rejectlogfd); rejectlogfd = -1; }\ncloselog();\nsyslog_open = FALSE;\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_some_authn_required(request_rec *r)\n{\n    int access_status;\n    switch (ap_satisfies(r)) {\n    case SATISFY_ALL:\n    case SATISFY_NOSPEC:\n        if ((access_status = ap_run_access_checker(r)) != OK) {\n            break;\n        }\n        access_status = ap_run_access_checker_ex(r);\n        if (access_status == DECLINED) {\n            return TRUE;\n        }\n        break;\n    case SATISFY_ANY:\n        if ((access_status = ap_run_access_checker(r)) == OK) {\n            break;\n        }\n        access_status = ap_run_access_checker_ex(r);\n        if (access_status == DECLINED) {\n            return TRUE;\n        }\n        break;\n    }\n    return FALSE;\n}", "target": 0}
{"code": "struct mnt_namespace *copy_mnt_ns(unsigned long flags, struct mnt_namespace *ns,\n\t\tstruct user_namespace *user_ns, struct fs_struct *new_fs)\n{\n\tstruct mnt_namespace *new_ns;\n\tstruct vfsmount *rootmnt = NULL, *pwdmnt = NULL;\n\tstruct mount *p, *q;\n\tstruct mount *old;\n\tstruct mount *new;\n\tint copy_flags;\n\tBUG_ON(!ns);\n\tif (likely(!(flags & CLONE_NEWNS))) {\n\t\tget_mnt_ns(ns);\n\t\treturn ns;\n\t}\n\told = ns->root;\n\tnew_ns = alloc_mnt_ns(user_ns);\n\tif (IS_ERR(new_ns))\n\t\treturn new_ns;\n\tnamespace_lock();\n\tcopy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE;\n\tif (user_ns != ns->user_ns)\n\t\tcopy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED;\n\tnew = copy_tree(old, old->mnt.mnt_root, copy_flags);\n\tif (IS_ERR(new)) {\n\t\tnamespace_unlock();\n\t\tfree_mnt_ns(new_ns);\n\t\treturn ERR_CAST(new);\n\t}\n\tnew_ns->root = new;\n\tlist_add_tail(&new_ns->list, &new->mnt_list);\n\tp = old;\n\tq = new;\n\twhile (p) {\n\t\tq->mnt_ns = new_ns;\n\t\tnew_ns->mounts++;\n\t\tif (new_fs) {\n\t\t\tif (&p->mnt == new_fs->root.mnt) {\n\t\t\t\tnew_fs->root.mnt = mntget(&q->mnt);\n\t\t\t\trootmnt = &p->mnt;\n\t\t\t}\n\t\t\tif (&p->mnt == new_fs->pwd.mnt) {\n\t\t\t\tnew_fs->pwd.mnt = mntget(&q->mnt);\n\t\t\t\tpwdmnt = &p->mnt;\n\t\t\t}\n\t\t}\n\t\tp = next_mnt(p, old);\n\t\tq = next_mnt(q, new);\n\t\tif (!q)\n\t\t\tbreak;\n\t\twhile (p->mnt.mnt_root != q->mnt.mnt_root)\n\t\t\tp = next_mnt(p, old);\n\t}\n\tnamespace_unlock();\n\tif (rootmnt)\n\t\tmntput(rootmnt);\n\tif (pwdmnt)\n\t\tmntput(pwdmnt);\n\treturn new_ns;\n}", "target": 0}
{"code": "wait_limit_netblock_findcreate(struct infra_cache* infra, char* str,\n\tint cookie)\n{\n\trbtree_type* tree;\n\tstruct sockaddr_storage addr;\n\tint net;\n\tsocklen_t addrlen;\n\tstruct wait_limit_netblock_info* d;\n\tif(!netblockstrtoaddr(str, 0, &addr, &addrlen, &net)) {\n\t\tlog_err(\"cannot parse wait limit netblock '%s'\", str);\n\t\treturn 0;\n\t}\n\tif(cookie)\n\t\ttree = &infra->wait_limits_cookie_netblock;\n\telse\n\t\ttree = &infra->wait_limits_netblock;\n\td = (struct wait_limit_netblock_info*)addr_tree_find(tree, &addr,\n\t\taddrlen, net);\n\tif(d)\n\t\treturn d;\n\td = (struct wait_limit_netblock_info*)calloc(1, sizeof(*d));\n\tif(!d)\n\t\treturn NULL;\n\td->limit = -1;\n\tif(!addr_tree_insert(tree, &d->node, &addr, addrlen, net)) {\n\t\tlog_err(\"duplicate element in domainlimit tree\");\n\t\tfree(d);\n\t\treturn NULL;\n\t}\n\treturn d;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "pf_update_state_timeout(struct pf_state *st, int to)\n{\n\tmtx_enter(&st->mtx);\n\tif (st->timeout != PFTM_UNLINKED)\n\t\tst->timeout = to;\n\tmtx_leave(&st->mtx);\n}", "target": 0}
{"code": "bool Archive::Open(const wchar *Name,uint Mode)\n{\n#ifdef USE_QOPEN\n  QOpen.Unload();\n#endif\n#ifdef USE_ARCMEM\n  if (Cmd->ArcInMem)\n  {\n    wcsncpyz(FileName,Name,ASIZE(FileName));\n    ArcMem.Load(Cmd->ArcMemData,Cmd->ArcMemSize);\n    Cmd->SetArcInMem(NULL,0); \n    return true;\n  }\n#endif\n  return File::Open(Name,Mode);\n}", "target": 0}
{"code": "int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,\n\t       void *buf, int buf_len, int in_len, int *pout_len)\n{\n\tswitch (key->type) {\n\tcase CEPH_CRYPTO_NONE:\n\t\t*pout_len = in_len;\n\t\treturn 0;\n\tcase CEPH_CRYPTO_AES:\n\t\treturn ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,\n\t\t\t\t      pout_len);\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n}", "target": 0}
{"code": "static inline int quic_token_validate(struct quic_rx_packet *pkt,\n                                      struct quic_dgram *dgram,\n                                      struct listener *l, struct quic_conn *qc,\n                                      struct quic_cid *odcid)\n{\n\tint ret = 0;\n\tTRACE_ENTER(QUIC_EV_CONN_LPKT, qc);\n\tswitch (*pkt->token) {\n\tcase QUIC_TOKEN_FMT_RETRY:\n\t\tret = quic_retry_token_check(pkt, dgram, l, qc, odcid);\n\t\tbreak;\n\tcase QUIC_TOKEN_FMT_NEW:\n\t\tret = quic_token_check(pkt, dgram, qc);\n\t\tif (!ret) {\n\t\t\tdgram->flags |= QUIC_DGRAM_FL_SEND_RETRY;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tTRACE_PROTO(\"Packet dropped\", QUIC_EV_CONN_LPKT, qc, NULL, NULL, pkt->version);\n\t\tbreak;\n\t}\n\tif (!ret)\n\t\tgoto err;\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_LPKT, qc);\n\treturn ret;\n err:\n\tTRACE_DEVEL(\"leaving in error\", QUIC_EV_CONN_LPKT, qc);\n\tgoto leave;\n}", "target": 0}
{"code": "DltReturnValue dlt_file_message(DltFile *file, int index, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n    if (index >= file->counter) {\n        dlt_vlog(LOG_WARNING, \"Message %d out of range!\\r\\n\", index);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n    if (fseek(file->handle, file->index[index], SEEK_SET) != 0) {\n        dlt_vlog(LOG_WARNING, \"Seek to message %d to position %ld failed!\\r\\n\",\n                 index, file->index[index]);\n        return DLT_RETURN_ERROR;\n    }\n    if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    file->position = index;\n    return DLT_RETURN_OK;\n}", "target": 1}
{"code": "static int cms_copy_content(BIO *out, BIO *in, unsigned int flags)\n\t{\n\tunsigned char buf[4096];\n\tint r = 0, i;\n\tBIO *tmpout = NULL;\n\tif (out == NULL)\n\t\ttmpout = BIO_new(BIO_s_null());\n\telse if (flags & CMS_TEXT)\n\t\t{\n\t\ttmpout = BIO_new(BIO_s_mem());\n\t\tBIO_set_mem_eof_return(tmpout, 0);\n\t\t}\n\telse\n\t\ttmpout = out;\n\tif(!tmpout)\n\t\t{\n\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,ERR_R_MALLOC_FAILURE);\n\t\tgoto err;\n\t\t}\n\tfor (;;)\n\t{\n\t\ti=BIO_read(in,buf,sizeof(buf));\n\t\tif (i <= 0)\n\t\t\t{\n\t\t\tif (BIO_method_type(in) == BIO_TYPE_CIPHER)\n\t\t\t\t{\n\t\t\t\tif (!BIO_get_cipher_status(in))\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\tif (i < 0)\n\t\t\t\tgoto err;\n\t\t\tbreak;\n\t\t\t}\n\t\tif (tmpout && (BIO_write(tmpout, buf, i) != i))\n\t\t\tgoto err;\n\t}\n\tif(flags & CMS_TEXT)\n\t\t{\n\t\tif(!SMIME_text(tmpout, out))\n\t\t\t{\n\t\t\tCMSerr(CMS_F_CMS_COPY_CONTENT,CMS_R_SMIME_TEXT_ERROR);\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\tr = 1;\n\terr:\n\tif (tmpout && (tmpout != out))\n\t\tBIO_free(tmpout);\n\treturn r;\n\t}", "target": 1}
{"code": "SSecurityTLS::SSecurityTLS(bool _anon) : session(0), dh_params(0),\n\t\t\t\t\t\t anon_cred(0), cert_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  certfile = X509_CertFile.getData();\n  keyfile = X509_KeyFile.getData();\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}", "target": 0}
{"code": "skip_varname(const char *s, bool aok)\n{\n\tsize_t alen;\n\tif (s && ksh_isalphx(*s)) {\n\t\twhile (*++s && ksh_isalnux(*s))\n\t\t\t;\n\t\tif (aok && *s == '[' && (alen = array_ref_len(s)))\n\t\t\ts += alen;\n\t}\n\treturn (s);\n}", "target": 0}
{"code": "        AuthenticationStatus get_auth_status() const\n        {\n            std::lock_guard<std::mutex> g(mtx_);\n            if (auth_.get() != nullptr)\n            {\n                return auth_->auth_status_;\n            }\n            else\n            {\n                return AUTHENTICATION_NOT_AVAILABLE;\n            }\n        }", "target": 0}
{"code": "static inline int restore_fpu_checking(struct task_struct *tsk)\n{\n\talternative_input(\n\t\tASM_NOP8 ASM_NOP2,\n\t\t\"emms\\n\\t\"\t\t\n\t\t\"fildl %P[addr]\",\t\n\t\tX86_FEATURE_FXSAVE_LEAK,\n\t\t[addr] \"m\" (tsk->thread.fpu.has_fpu));\n\treturn fpu_restore_checking(&tsk->thread.fpu);\n}", "target": 1}
{"code": "snmp_api_set_string(snmp_varbind_t *varbind, uint32_t *oid, char *string)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OCTET_STRING;\n  varbind->value.string.string = string;\n  varbind->value.string.length = strlen(string);\n}", "target": 1}
{"code": "static int io_files_update_with_index_alloc(struct io_kiocb *req,\n\t\t\t\t\t    unsigned int issue_flags)\n{\n\t__s32 __user *fds = u64_to_user_ptr(req->rsrc_update.arg);\n\tunsigned int done;\n\tstruct file *file;\n\tint ret, fd;\n\tif (!req->ctx->file_data)\n\t\treturn -ENXIO;\n\tfor (done = 0; done < req->rsrc_update.nr_args; done++) {\n\t\tif (copy_from_user(&fd, &fds[done], sizeof(fd))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tfile = fget(fd);\n\t\tif (!file) {\n\t\t\tret = -EBADF;\n\t\t\tbreak;\n\t\t}\n\t\tret = io_fixed_fd_install(req, issue_flags, file,\n\t\t\t\t\t  IORING_FILE_INDEX_ALLOC);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tif (copy_to_user(&fds[done], &ret, sizeof(ret))) {\n\t\t\t__io_close_fixed(req, issue_flags, ret);\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (done)\n\t\treturn done;\n\treturn ret;", "target": 0}
{"code": "    int32_t audio_io_osx::shutdown_audio_unit() {\n        OSStatus result = -1;\n        if (NULL != au_rec_) {\n            result = AudioOutputUnitStop(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_rec_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_rec_ = NULL;\n        }\n        if (NULL != au_play_) {\n            result = AudioOutputUnitStop(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error stopping Audio Unit (result=%d) \\n\", result);\n            }\n            result = AudioComponentInstanceDispose(au_play_);\n            if (0 != result) {\n                error(\"audio_io_osx: Error disposing Audio Unit (result=%d) \\n\", result);\n            }\n            au_play_ = NULL;\n        }\n        return 0;\n    }", "target": 0}
{"code": "static int tg_cfs_schedulable_down(struct task_group *tg, void *data)\n{\n\tstruct cfs_schedulable_data *d = data;\n\tstruct cfs_bandwidth *cfs_b = &tg->cfs_bandwidth;\n\ts64 quota = 0, parent_quota = -1;\n\tif (!tg->parent) {\n\t\tquota = RUNTIME_INF;\n\t} else {\n\t\tstruct cfs_bandwidth *parent_b = &tg->parent->cfs_bandwidth;\n\t\tquota = normalize_cfs_quota(tg, d);\n\t\tparent_quota = parent_b->hierarchical_quota;\n\t\tif (quota == RUNTIME_INF)\n\t\t\tquota = parent_quota;\n\t\telse if (parent_quota != RUNTIME_INF && quota > parent_quota)\n\t\t\treturn -EINVAL;\n\t}\n\tcfs_b->hierarchical_quota = quota;\n\treturn 0;\n}", "target": 0}
{"code": "jas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\tassert((buf && bufsize > 0) || (!buf));\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\tstream->ops_ = &jas_stream_memops;\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\tif (bufsize > 0 && buf) {\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\treturn stream;\n}", "target": 0}
{"code": "static Status ValidateStrides(const T& strides) {\n  for (size_t i = 0; i < strides.size(); ++i) {\n    if (strides[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field for dimension \", i,\n          \" must be positive but is \", strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "int unshare_userns(unsigned long unshare_flags, struct cred **new_cred)\n{\n\tstruct cred *cred;\n\tif (!(unshare_flags & CLONE_NEWUSER))\n\t\treturn 0;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\t*new_cred = cred;\n\treturn create_user_ns(cred);\n}", "target": 1}
{"code": "int X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)\n{\n    EVP_PKEY *ktmp = NULL, *ktmp2;\n    int i, j;\n    if ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey))\n        return 1;\n    for (i = 0; i < sk_X509_num(chain); i++) {\n        ktmp = X509_get_pubkey(sk_X509_value(chain, i));\n        if (ktmp == NULL) {\n            X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,\n                    X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);\n            return 0;\n        }\n        if (!EVP_PKEY_missing_parameters(ktmp))\n            break;\n        EVP_PKEY_free(ktmp);\n        ktmp = NULL;\n    }\n    if (ktmp == NULL) {\n        X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,\n                X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);\n        return 0;\n    }\n    for (j = i - 1; j >= 0; j--) {\n        ktmp2 = X509_get_pubkey(sk_X509_value(chain, j));\n        EVP_PKEY_copy_parameters(ktmp2, ktmp);\n        EVP_PKEY_free(ktmp2);\n    }\n    if (pkey != NULL)\n        EVP_PKEY_copy_parameters(pkey, ktmp);\n    EVP_PKEY_free(ktmp);\n    return 1;\n}", "target": 0}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; \n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\tupdate_db_bp_intercept(vcpu);\n}", "target": 1}
{"code": "void PDPClient::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "static inline bool unconditional(const struct arpt_arp *arp)\n{\n\tstatic const struct arpt_arp uncond;\n\treturn memcmp(arp, &uncond, sizeof(uncond)) == 0;\n}", "target": 1}
{"code": "static void packet_flush_mclist(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_mclist *ml;\n\tif (!po->mclist)\n\t\treturn;\n\trtnl_lock();\n\twhile ((ml = po->mclist) != NULL) {\n\t\tstruct net_device *dev;\n\t\tpo->mclist = ml->next;\n\t\tdev = __dev_get_by_index(sock_net(sk), ml->ifindex);\n\t\tif (dev != NULL)\n\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\tkfree(ml);\n\t}\n\trtnl_unlock();\n}", "target": 0}
{"code": "psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)\n{\tsf_count_t total = 0 ;\n\tssize_t\tcount ;\n\tif (bytes == 0 || items == 0)\n\t\treturn 0 ;\n\tif (psf->virtual_io)\n\t\treturn psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;\n\titems *= bytes ;\n\tif (items <= 0)\n\t\treturn 0 ;\n\twhile (items > 0)\n\t{\t\n\t\tcount = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;\n\t\tcount = write (psf->file.filedes, ((const char*) ptr) + total, count) ;\n\t\tif (count == -1)\n\t\t{\tif (errno == EINTR)\n\t\t\t\tcontinue ;\n\t\t\tpsf_log_syserr (psf, errno) ;\n\t\t\tbreak ;\n\t\t\t} ;\n\t\tif (count == 0)\n\t\t\tbreak ;\n\t\ttotal += count ;\n\t\titems -= count ;\n\t\t} ;\n\tif (psf->is_pipe)\n\t\tpsf->pipeoffset += total ;\n\treturn total / bytes ;\n} ", "target": 0}
{"code": "bool ContentSettingsObserver::AllowScript(bool enabled_per_settings) {\n  if (!enabled_per_settings)\n    return false;\n  if (IsScriptDisabledForPreview(render_frame()))\n    return false;\n  if (is_interstitial_page_)\n    return true;\n  blink::WebLocalFrame* frame = render_frame()->GetWebFrame();\n  const auto it = cached_script_permissions_.find(frame);\n  if (it != cached_script_permissions_.end())\n    return it->second;\n  bool allow = true;\n  if (content_setting_rules_) {\n    ContentSetting setting = GetContentSettingFromRules(\n        content_setting_rules_->script_rules, frame,\n        url::Origin(frame->GetDocument().GetSecurityOrigin()).GetURL());\n    allow = setting != CONTENT_SETTING_BLOCK;\n  }\n  allow = allow || IsWhitelistedForContentSettings();\n  cached_script_permissions_[frame] = allow;\n  return allow;\n}", "target": 1}
{"code": "  void createDebugInfo() override {\n    llvm_unreachable(\"Accessing debug info from a lazy module\");\n  }", "target": 1}
{"code": "int gnutls_x509_ext_export_aia(gnutls_x509_aia_t aia,\n\t\t\t\t\t      gnutls_datum_t * ext)\n{\n\tint ret, result;\n\tASN1_TYPE c2 = ASN1_TYPE_EMPTY;\n\tunsigned int i;\n\tret = asn1_create_element(_gnutls_get_pkix(),\n\t\t\t\t  \"PKIX1.AuthorityInfoAccessSyntax\", &c2);\n\tif (ret != ASN1_SUCCESS) {\n\t\tgnutls_assert();\n\t\treturn _gnutls_asn2err(ret);\n\t}\n\tfor (i=0;i<aia->size;i++) {\n\t\tresult = asn1_write_value(c2, \"\", \"NEW\", 1);\n\t\tif (result != ASN1_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tret = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tresult = asn1_write_value(c2, \"?LAST.accessMethod\", aia->aia[i].oid.data, 1);\n\t\tif (result != ASN1_SUCCESS) {\n\t\t\tgnutls_assert();\n\t\t\tret = _gnutls_asn2err(result);\n\t\t\tgoto cleanup;\n\t\t}\n\t\tret =\n\t\t    _gnutls_write_general_name(c2,\n\t\t\t\t\t\t   \"?LAST.accessLocation\",\n\t\t\t\t\t\t   aia->aia[i].san_type,\n\t\t\t\t\t\t   aia->aia[i].san.data,\n\t\t\t\t\t\t   aia->aia[i].san.size);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tret = _gnutls_x509_der_encode(c2, \"\", ext, 0);\n\tif (ret < 0) {\n\t\tgnutls_assert();\n\t\tgoto cleanup;\n\t}\n cleanup:\n\tasn1_delete_structure(&c2);\n\treturn ret;\n}", "target": 0}
{"code": "int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)\n{\n\tstruct mosquitto_client_msg *tail;\n\tif(!context) return MOSQ_ERR_INVAL;\n\t*stored = NULL;\n\tDL_FOREACH(context->msgs_in.inflight, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\tDL_FOREACH(context->msgs_in.queued, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "int ContentLine_Analyzer::DoDeliverOnce(int len, const u_char* data)\n\t{\n\tconst u_char* data_start = data;\n\tif ( len <= 0 )\n\t\treturn 0;\n\tfor ( ; len > 0; --len, ++data )\n\t\t{\n\t\tif ( offset >= buf_len )\n\t\t\tInitBuffer(buf_len * 2);\n\t\tint c = data[0];\n#define EMIT_LINE \\\n\t{ \\\n\tbuf[offset] = '\\0'; \\\n\tint seq_len = data + 1 - data_start; \\\n\tseq_delivered_in_lines = seq + seq_len; \\\n\tlast_char = c; \\\n\tForwardStream(offset, buf, IsOrig()); \\\n\toffset = 0; \\\n\treturn seq_len; \\\n\t}\n\t\tswitch ( c ) {\n\t\tcase '\\r':\n\t\t\tif ( len > 1 && data[1] == '\\n' )\n\t\t\t\t{\n\t\t\t\t--len; ++data;\n\t\t\t\tlast_char = c;\n\t\t\t\tc = data[0];\n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & CR_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tcase '\\n':\n\t\t\tif ( last_char == '\\r' )\n\t\t\t\t{\n\t\t\t\tif ( offset == 0 )\n\t\t\t\t\t{\n\t\t\t\t\tlast_char = c;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t--offset; \n\t\t\t\tEMIT_LINE\n\t\t\t\t}\n\t\t\telse if ( CR_LF_as_EOL & LF_as_EOL )\n\t\t\t\tEMIT_LINE\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_LF) )\n\t\t\t\t\tConn()->Weird(\"line_terminated_with_single_LF\");\n\t\t\t\tbuf[offset++] = c;\n\t\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\0':\n\t\t\tif ( flag_NULs )\n\t\t\t\tCheckNUL();\n\t\t\telse\n\t\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbuf[offset++] = c;\n\t\t\tbreak;\n\t\t}\n\t\tif ( last_char == '\\r' )\n\t\t\tif ( ! suppress_weirds && Conn()->FlagEvent(SINGULAR_CR) )\n\t\t\t\tConn()->Weird(\"line_terminated_with_single_CR\");\n\t\tlast_char = c;\n\t\t}\n\treturn data - data_start;\n\t}", "target": 0}
{"code": "static Jsi_RC NumberToExponentialCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMEFMT, prec, num);\n#ifdef __WIN32\n    char *e = strrchr(buf, 'e');\n    if (e && (e[1]=='+' || e[1]=='-')) {\n        e++;\n        int eNum = atoi(e);\n        if (e[0]=='-')\n            eNum = -eNum;\n        e++;\n        snprintf(e, (e-buf), \"%02d\", eNum);\n    }\n#endif\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "\tSilenceMessage(const std::string& mask, const std::string& flags)\n\t\t: ClientProtocol::Message(\"SILENCE\")\n\t{\n\t\tPushParam(mask);\n\t\tPushParam(flags);\n\t}", "target": 0}
{"code": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}", "target": 1}
{"code": "crm_recv_remote_raw(void *session, gboolean encrypted, size_t max_recv, size_t *recv_len, int *disconnected)\n{\n    char *reply = NULL;\n    if (recv_len) {\n        *recv_len = 0;\n    }\n    if (disconnected) {\n        *disconnected = 0;\n    }\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = crm_recv_tls(session, max_recv, recv_len, disconnected);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = crm_recv_plaintext(GPOINTER_TO_INT(session), max_recv, recv_len, disconnected);\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n    }\n    return reply;\n}", "target": 0}
{"code": "static inline bool sctp_chunk_pending(const struct sctp_chunk *chunk)\n{\n\treturn !list_empty(&chunk->list);\n}", "target": 0}
{"code": "content::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n  if (Emit(\"will-navigate\", params.url))\n    return nullptr;\n  if (IsDestroyed())\n    return nullptr;\n  return CommonWebContentsDelegate::OpenURLFromTab(source, params);\n}", "target": 1}
{"code": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *ndev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n\tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n}", "target": 1}
{"code": "get_authname(int type)\n{\n\tstatic char buf[1024];\n\tswitch (type) {\n\tcase SSH_CMSG_AUTH_PASSWORD:\n\t\treturn \"password\";\n\tcase SSH_CMSG_AUTH_RSA:\n\t\treturn \"rsa\";\n\tcase SSH_CMSG_AUTH_RHOSTS_RSA:\n\t\treturn \"rhosts-rsa\";\n\tcase SSH_CMSG_AUTH_RHOSTS:\n\t\treturn \"rhosts\";\n\tcase SSH_CMSG_AUTH_TIS:\n\tcase SSH_CMSG_AUTH_TIS_RESPONSE:\n\t\treturn \"challenge-response\";\n#if defined(KRB4) || defined(KRB5)\n\tcase SSH_CMSG_AUTH_KERBEROS:\n\t\treturn \"kerberos\";\n#endif\n\t}\n\tsnprintf(buf, sizeof buf, \"bad-auth-msg-%d\", type);\n\treturn buf;\n}", "target": 0}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "void LibRaw::blend_highlights()\n{\n  int clip = INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] = {\n      {{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},\n      {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  static const float itrans[2][4][4] = {\n      {{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},\n      {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  float cam[2][4], lab[2][4], sum[2], chratio;\n  if ((unsigned)(colors - 3) > 1)\n    return;\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);\n  FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      FORCC if (image[row * width + col][c] > clip) break;\n      if (c == colors)\n        continue;\n      FORCC\n      {\n        cam[0][c] = image[row * width + col][c];\n        cam[1][c] = MIN(cam[0][c], clip);\n      }\n      for (i = 0; i < 2; i++)\n      {\n        FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] +=\n            trans[colors - 3][c][j] * cam[i][j];\n        for (sum[i] = 0, c = 1; c < colors; c++)\n          sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1] / sum[0]);\n      for (c = 1; c < colors; c++)\n        lab[0][c] *= chratio;\n      FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] +=\n          itrans[colors - 3][c][j] * lab[0][j];\n      FORCC image[row * width + col][c] = cam[0][c] / colors;\n    }\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);\n}", "target": 0}
{"code": "int __fastcall BatchSettings(TConsole * Console, TProgramParams * Params)\n{\n  int Result = RESULT_SUCCESS;\n  try\n  {\n    std::unique_ptr<TStrings> Arguments(new TStringList());\n    if (!DebugAlwaysTrue(Params->FindSwitch(L\"batchsettings\", Arguments.get())))\n    {\n      Abort();\n    }\n    else\n    {\n      if (Arguments->Count < 1)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_MASK));\n      }\n      else if (Arguments->Count < 2)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_SETTINGS));\n      }\n      else\n      {\n        TFileMasks Mask(Arguments->Strings[0]);\n        Arguments->Delete(0);\n        std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Arguments.get(), false));\n        int Matches = 0;\n        int Changes = 0;\n        for (int Index = 0; Index < StoredSessions->Count; Index++)\n        {\n          TSessionData * Data = StoredSessions->Sessions[Index];\n          if (!Data->IsWorkspace &&\n              Mask.Matches(Data->Name, false, false))\n          {\n            Matches++;\n            std::unique_ptr<TSessionData> OriginalData(new TSessionData(L\"\"));\n            OriginalData->CopyDataNoRecrypt(Data);\n            Data->ApplyRawSettings(OptionsStorage.get());\n            bool Changed = !OriginalData->IsSame(Data, false);\n            if (Changed)\n            {\n              Changes++;\n            }\n            UnicodeString StateStr = LoadStr(Changed ? BATCH_SET_CHANGED : BATCH_SET_NOT_CHANGED);\n            Console->PrintLine(FORMAT(L\"%s - %s\", (Data->Name, StateStr)));\n          }\n        }\n        StoredSessions->Save(false, true); \n        Console->PrintLine(FMTLOAD(BATCH_SET_SUMMARY, (Matches, Changes)));\n      }\n    }\n  }\n  catch (Exception & E)\n  {\n    Result = HandleException(Console, E);\n  }\n  Console->WaitBeforeExit();\n  return Result;\n}", "target": 1}
{"code": "void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\tfree(name);\n}", "target": 1}
{"code": "int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n  struct {\n    __u8 v;\n    __le64 magic;\n    __le32 len;\n    __le32 header_crc;\n    __le32 front_crc;\n    __le32 middle_crc;\n    __le32 data_crc;\n  } __attribute__ ((packed)) sigblock = {\n    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n  };\n  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n  try {\n    const CryptoKey::in_slice_t in {\n      sizeof(sigblock),\n      reinterpret_cast<const unsigned char*>(&sigblock)\n    };\n    const CryptoKey::out_slice_t out {\n      sizeof(exp_buf),\n      reinterpret_cast<unsigned char*>(&exp_buf)\n    };\n    key.encrypt(cct, in, out);\n  } catch (std::exception& e) {\n    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n    return -1;\n  }\n  *psig = *reinterpret_cast<__le64*>(exp_buf);\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}", "target": 1}
{"code": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ net_secret[14];\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "static void destroy_surface(struct swaylock_surface *surface) {\n\twl_list_remove(&surface->link);\n\tif (surface->layer_surface != NULL) {\n\t\tzwlr_layer_surface_v1_destroy(surface->layer_surface);\n\t}\n\tif (surface->ext_session_lock_surface_v1 != NULL) {\n\t\text_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);\n\t}\n\tif (surface->surface != NULL) {\n\t\twl_surface_destroy(surface->surface);\n\t}\n\tdestroy_buffer(&surface->buffers[0]);\n\tdestroy_buffer(&surface->buffers[1]);\n\tdestroy_buffer(&surface->indicator_buffers[0]);\n\tdestroy_buffer(&surface->indicator_buffers[1]);\n\twl_output_destroy(surface->output);\n\tfree(surface);\n}", "target": 0}
{"code": "crm_recv_plaintext(int sock, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (sock <= 0) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        errno = 0;\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = read(sock, buf + len, chunk_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc > 0) {\n            continue;\n        } else if (rc == 0) {\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            crm_trace(\"EOF encoutered during read\");\n            goto done;\n        }\n        if (errno == EINTR) {\n            crm_trace(\"EINTER encoutered, retry socket read.\");\n        } else if (errno == EAGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (errno <= 0) {\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            crm_debug(\"Error receiving message: %d\", (int)rc);\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "static int smacker_decode_tree(BitstreamContext *bc, HuffContext *hc,\n                               uint32_t prefix, int length)\n{\n    if (length > SMKTREE_DECODE_MAX_RECURSION) {\n        av_log(NULL, AV_LOG_ERROR, \"Maximum tree recursion level exceeded.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!bitstream_read_bit(bc)) { \n        if(hc->current >= 256){\n            av_log(NULL, AV_LOG_ERROR, \"Tree size exceeded!\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if(length){\n            hc->bits[hc->current] = prefix;\n            hc->lengths[hc->current] = length;\n        } else {\n            hc->bits[hc->current] = 0;\n            hc->lengths[hc->current] = 0;\n        }\n        hc->values[hc->current] = bitstream_read(bc, 8);\n        hc->current++;\n        if(hc->maxlength < length)\n            hc->maxlength = length;\n        return 0;\n    } else { \n        int r;\n        length++;\n        r = smacker_decode_tree(bc, hc, prefix, length);\n        if(r)\n            return r;\n        return smacker_decode_tree(bc, hc, prefix | (1 << (length - 1)), length);\n    }\n}", "target": 0}
{"code": "void ext4_journal_abort_handle(const char *caller, unsigned int line,\n\t\t\t       const char *err_fn, struct buffer_head *bh,\n\t\t\t       handle_t *handle, int err)\n{\n\tchar nbuf[16];\n\tconst char *errstr = ext4_decode_error(NULL, err, nbuf);\n\tBUG_ON(!ext4_handle_valid(handle));\n\tif (bh)\n\t\tBUFFER_TRACE(bh, \"abort\");\n\tif (!handle->h_err)\n\t\thandle->h_err = err;\n\tif (is_handle_aborted(handle))\n\t\treturn;\n\tprintk(KERN_ERR \"EXT4-fs: %s:%d: aborting transaction: %s in %s\\n\",\n\t       caller, line, errstr, err_fn);\n\tjbd2_journal_abort_handle(handle);\n}", "target": 0}
{"code": "long video_ioctl2(struct file *file,\n\t       unsigned int cmd, unsigned long arg)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\tif (has_array_args) {\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\terr = __video_do_ioctl(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\nout_array_args:\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\nout:\n\tkfree(mbuf);\n\treturn err;\n}", "target": 1}
{"code": "TEST_F(ExtractorTest, TestDefaultHeaderLocation) {\n  auto headers = TestRequestHeaderMapImpl{{\"Authorization\", \"Bearer jwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 1);\n  EXPECT_EQ(tokens[0]->token(), \"jwt_token\");\n  EXPECT_TRUE(tokens[0]->isIssuerSpecified(\"issuer1\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer2\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer3\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer4\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer5\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"unknown_issuer\"));\n  tokens[0]->removeJwt(headers);\n  EXPECT_FALSE(headers.has(Http::CustomHeaders::get().Authorization));\n}", "target": 0}
{"code": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int uas_find_uas_alt_setting(struct usb_interface *intf)\n{\n\tint i;\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt->desc.bAlternateSetting;\n\t}\n\treturn -ENODEV;\n}", "target": 1}
{"code": "std::string WC2MB(const std::wstring& input, unsigned int code_page) {\n  if (input.empty()) {\n    return \"\";\n  }\n  DWORD flags = 0;\n  if (code_page != 65001 && code_page != 54936) {\n    flags = WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR;\n  }\n  int length = ::WideCharToMultiByte(code_page, flags, &input[0],\n                                     static_cast<int>(input.size()), NULL, 0,\n                                     NULL, NULL);\n  std::string output(length, '\\0');\n  ::WideCharToMultiByte(code_page, flags, &input[0],\n                        static_cast<int>(input.size()), &output[0],\n                        static_cast<int>(output.size()), NULL, NULL);\n  return output;\n}", "target": 1}
{"code": "static bool cma_match_net_dev(const struct rdma_cm_id *id,\n\t\t\t      const struct net_device *net_dev,\n\t\t\t      const struct cma_req_info *req)\n{\n\tconst struct rdma_addr *addr = &id->route.addr;\n\tif (!net_dev)\n\t\treturn (!id->port_num || id->port_num == req->port) &&\n\t\t       (addr->src_addr.ss_family == AF_IB);\n\tif (!cma_is_req_ipv6_ll(req))\n\t\treturn true;\n\tif (net_eq(dev_net(net_dev), addr->dev_addr.net) &&\n\t    (!!addr->dev_addr.bound_dev_if ==\n\t     (addr->dev_addr.bound_dev_if == net_dev->ifindex)))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "target": 0}
{"code": "static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tint ret;\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int snd_hrtimer_start(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\tatomic_set(&stime->running, 0);\n\thrtimer_cancel(&stime->hrt);\n\thrtimer_start(&stime->hrt, ns_to_ktime(t->sticks * resolution),\n\t\t      HRTIMER_MODE_REL);\n\tatomic_set(&stime->running, 1);\n\treturn 0;\n}", "target": 1}
{"code": "int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n{\n\tu8 *buf = NULL;\n\tint err;\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tget_random_bytes(buf, slen);\n\t\tseed = buf;\n\t}\n\terr = tfm->seed(tfm, seed, slen);\n\tkfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "sysContact_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG, https:\n}", "target": 1}
{"code": "  TfLiteRegistration CancelOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      cancellation_data_.is_cancelled = true;\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "  QInt8() {}", "target": 1}
{"code": "ev_archive_finalize (GObject *object)\n{\n\tEvArchive *archive = EV_ARCHIVE (object);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_clear_pointer (&archive->libar, archive_free);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tG_OBJECT_CLASS (ev_archive_parent_class)->finalize (object);\n}", "target": 0}
{"code": "static void __net_exit pfkey_net_exit(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tpfkey_exit_proc(net);\n\tWARN_ON(!hlist_empty(&net_pfkey->table));\n}", "target": 0}
{"code": "Http::FilterDataStatus Context::onResponseBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onResponseBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onResponseBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                                static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}", "target": 1}
{"code": "static void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    fio_stop();\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}", "target": 1}
{"code": "rb_reg_error_desc(VALUE str, int options, const char *err)\n{\n    return rb_enc_reg_error_desc(RSTRING_PTR(str), RSTRING_LEN(str),\n\t\t\t\t rb_enc_get(str), options, err);\n}", "target": 0}
{"code": "void *malloc(size_t size)\n{\n\tstruct free_arena_header *fp;\n\tstruct free_arena_header *pah;\n\tsize_t fsize;\n\tif (size == 0)\n\t\treturn NULL;\n\tif (size > PTRDIFF_MAX) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tsize = (size + 2 * sizeof(struct arena_header) - 1) & ARENA_SIZE_MASK;\n\tfor (fp = __malloc_head.next_free; fp->a.type != ARENA_TYPE_HEAD;\n\t     fp = fp->next_free) {\n\t\tif (fp->a.size >= size) {\n\t\t\treturn __malloc_from_block(fp, size);\n\t\t}\n\t}\n\tfsize = (size + MALLOC_CHUNK_MASK) & ~MALLOC_CHUNK_MASK;\n#if _KLIBC_MALLOC_USES_SBRK\n\tfp = (struct free_arena_header *)sbrk(fsize);\n#else\n\tfp = (struct free_arena_header *)\n\t    mmap(NULL, fsize, PROT_READ | PROT_WRITE,\n\t\t MAP_PRIVATE | MAP_ANONYMOUS, 0, 0);\n#endif\n\tif (fp == (struct free_arena_header *)MAP_FAILED) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\t\n\t}\n\tfp->a.type = ARENA_TYPE_FREE;\n\tfp->a.size = fsize;\n\tfor (pah = __malloc_head.a.prev; pah->a.type != ARENA_TYPE_HEAD;\n\t     pah = pah->a.prev) {\n\t\tif (pah < fp)\n\t\t\tbreak;\n\t}\n\tfp->a.next = pah->a.next;\n\tfp->a.prev = pah;\n\tpah->a.next = fp;\n\tfp->a.next->a.prev = fp;\n\tfp = __free_block(fp);\n\treturn __malloc_from_block(fp, size);\n}", "target": 0}
{"code": "isdn_net_force_dial(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tif (!p)\n\t\treturn -ENODEV;\n\treturn (isdn_net_force_dial_lp(p->local));\n}", "target": 0}
{"code": "static void calc_load_migrate(struct rq *rq)\n{\n\tlong delta = calc_load_fold_active(rq);\n\tif (delta)\n\t\tatomic_long_add(delta, &calc_load_tasks);\n}", "target": 0}
{"code": "static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)\n{\n\tint start = 0;\n\tu32 prev_legacy, cur_legacy;\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tprev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tcur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;\n\tif (!prev_legacy && cur_legacy)\n\t\tstart = 1;\n\tmemcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,\n\t       sizeof(kvm->arch.vpit->pit_state.channels));\n\tkvm->arch.vpit->pit_state.flags = ps->flags;\n\tkvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}", "target": 1}
{"code": "teardown_digests(cms_context *ctx)\n{\n\tstruct digest *digests = ctx->digests;\n\tif (!digests)\n\t\treturn;\n\tfor (int i = 0; i < n_digest_params; i++) {\n\t\tif (digests[i].pk11ctx) {\n\t\t\tPK11_Finalize(digests[i].pk11ctx);\n\t\t\tPK11_DestroyContext(digests[i].pk11ctx, PR_TRUE);\n\t\t}\n\t\tif (digests[i].pe_digest) {\n\t\t\tdigests[i].pe_digest = NULL;\n\t\t}\n\t}\n\tPORT_Free(digests);\n\tctx->digests = NULL;\n}", "target": 0}
{"code": "void ZydisFormatterBufferInit(ZydisFormatterBuffer* buffer, char* user_buffer,\n    ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n    buffer->is_token_list              = ZYAN_FALSE;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *user_buffer = '\\0';\n}", "target": 1}
{"code": "ssize_t uv__idna_toascii(const char* s, const char* se, char* d, char* de) {\n  const char* si;\n  const char* st;\n  unsigned c;\n  char* ds;\n  int rc;\n  if (s == se)\n    return UV_EINVAL;\n  ds = d;\n  si = s;\n  while (si < se) {\n    st = si;\n    c = uv__utf8_decode1(&si, se);\n    if (c == UINT_MAX)\n      return UV_EINVAL;\n    if (c != '.')\n      if (c != 0x3002)  \n        if (c != 0xFF0E)  \n          if (c != 0xFF61)  \n            continue;\n    rc = uv__idna_toascii_label(s, st, &d, de);\n    if (rc < 0)\n      return rc;\n    if (d < de)\n      *d++ = '.';\n    s = si;\n  }\n  if (s < se) {\n    rc = uv__idna_toascii_label(s, se, &d, de);\n    if (rc < 0)\n      return rc;\n  }\n  if (d >= de)\n    return UV_EINVAL;\n  *d++ = '\\0';\n  return d - ds;  \n}", "target": 0}
{"code": "static void bprm_fill_uid(struct linux_binprm *bprm)\n{\n\tstruct inode *inode;\n\tunsigned int mode;\n\tkuid_t uid;\n\tkgid_t gid;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID)\n\t\treturn;\n\tif (task_no_new_privs(current))\n\t\treturn;\n\tinode = file_inode(bprm->file);\n\tmode = READ_ONCE(inode->i_mode);\n\tif (!(mode & (S_ISUID|S_ISGID)))\n\t\treturn;\n\tmutex_lock(&inode->i_mutex);\n\tmode = inode->i_mode;\n\tuid = inode->i_uid;\n\tgid = inode->i_gid;\n\tmutex_unlock(&inode->i_mutex);\n\tif (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n\t\t !kgid_has_mapping(bprm->cred->user_ns, gid))\n\t\treturn;\n\tif (mode & S_ISUID) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->euid = uid;\n\t}\n\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\tbprm->cred->egid = gid;\n\t}\n}", "target": 0}
{"code": "static void _pam_log_int(const pam_handle_t *pamh,\n\t\t\t int err,\n\t\t\t const char *format,\n\t\t\t va_list args)\n{\n\tpam_vsyslog(pamh, err, format, args);\n}", "target": 0}
{"code": "static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)\n{\n\tu32 elem_size = sizeof(struct stack_map_bucket) + smap->map.value_size;\n\tint err;\n\tsmap->elems = bpf_map_area_alloc(elem_size * smap->map.max_entries,\n\t\t\t\t\t smap->map.numa_node);\n\tif (!smap->elems)\n\t\treturn -ENOMEM;\n\terr = pcpu_freelist_init(&smap->freelist);\n\tif (err)\n\t\tgoto free_elems;\n\tpcpu_freelist_populate(&smap->freelist, smap->elems, elem_size,\n\t\t\t       smap->map.max_entries);\n\treturn 0;\nfree_elems:\n\tbpf_map_area_free(smap->elems);\n\treturn err;\n}", "target": 1}
{"code": "TEST_F(GroupVerifierTest, TestRequiresAnyWithAllowMissingButOk) {\n  TestUtility::loadFromYaml(RequiresAnyConfig, proto_config_);\n  proto_config_.mutable_rules(0)\n      ->mutable_requires()\n      ->mutable_requires_any()\n      ->add_requirements()\n      ->mutable_allow_missing();\n  createAsyncMockAuthsAndVerifier(std::vector<std::string>{\"example_provider\", \"other_provider\"});\n  EXPECT_CALL(mock_cb_, onComplete(Status::Ok));\n  auto headers = Http::TestRequestHeaderMapImpl{};\n  context_ = Verifier::createContext(headers, parent_span_, &mock_cb_);\n  verifier_->verify(context_);\n  callbacks_[\"example_provider\"](Status::JwtMissed);\n  callbacks_[\"other_provider\"](Status::JwtUnknownIssuer);\n}", "target": 1}
{"code": "resolve_op_end (FlatpakTransaction *self,\n                FlatpakTransactionOperation *op,\n                const char *checksum,\n                GFile *sideload_path,\n                GBytes *metadata_bytes)\n{\n  g_autoptr(GBytes) old_metadata_bytes = NULL;\n  old_metadata_bytes = load_deployed_metadata (self, op->ref, NULL, NULL);\n  mark_op_resolved (op, checksum, sideload_path, metadata_bytes, old_metadata_bytes);\n  emit_eol_and_maybe_skip (self, op);\n }", "target": 1}
{"code": "static void __sco_chan_add(struct sco_conn *conn, struct sock *sk,\n\t\t\t   struct sock *parent)\n{\n\tBT_DBG(\"conn %p\", conn);\n\tsco_pi(sk)->conn = conn;\n\tconn->sk = sk;\n\tINIT_DELAYED_WORK(&conn->timeout_work, sco_sock_timeout);\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk, true);\n}", "target": 0}
{"code": "check_supported(item *new)\n{\nint c = -1;\nint bot = 0;\nint top = supported_elements_count;\nint mid;\ntree_node *tn;\nparamstr *param;\nwhile (top > bot)\n  {\n  mid = (top + bot)/2;\n  c = Ustrcmp(new->name, supported_elements[mid].name);\n  if (c == 0) break;\n  if (c < 0) top = mid; else bot = mid + 1;\n  }\nif (c != 0)\n  {\n  tn = tree_search(unknown_element_tree, new->name);\n  if (tn == NULL)\n    {\n    tn = misc_malloc(sizeof(tree_node) + Ustrlen(new->name));\n    Ustrcpy(tn->name, new->name);\n    (void)tree_insertnode(&unknown_element_tree, tn);\n    }\n  return;\n  }\nfor (param = new->p.param; param != NULL; param = param->next)\n  {\n  uschar buffer[256];\n  uschar **aptr;\n  if (param->name[0] == '#') continue;\n  if (Ustrcmp(param->name, \"revisionflag\") == 0)\n    {\n    if (Ustrcmp(param->value, \"changed\") == 0) continue;\n    (void)sprintf(CS buffer, \"+%s=%s:%s\", param->name, param->value,\n      new->name);\n    }\n  else\n    {\n    aptr = supported_elements[mid].attrs;\n    if (aptr != NULL)\n      {\n      if (Ustrcmp(*aptr, \"*\") == 0) continue;\n      for (; *aptr != NULL; aptr++)\n        if (Ustrcmp(*aptr, param->name) == 0) break;\n      if (*aptr != NULL) continue;\n      }\n    (void)sprintf(CS buffer, \"+%s:%s\", param->name, new->name);\n    }\n  tn = tree_search(unknown_element_tree, buffer);\n  if (tn == NULL)\n    {\n    tn = misc_malloc(sizeof(tree_node) + Ustrlen(buffer));\n    Ustrcpy(tn->name, buffer);\n    (void)tree_insertnode(&unknown_element_tree, tn);\n    }\n  }\n}", "target": 1}
{"code": "struct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\n\t\t\t\t      struct inode *inode, const char *path,\n\t\t\t\t      u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tstruct cifsFileInfo *open_file = NULL;\n\tif (inode)\n\t\topen_file = find_readable_file(CIFS_I(inode), true);\n\tif (!open_file)\n\t\treturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\n\tpntsd = get_cifs_acl_by_fid(cifs_sb, &open_file->fid, pacllen);\n\tcifsFileInfo_put(open_file);\n\treturn pntsd;\n}", "target": 0}
{"code": "static int smm_place_entry_code(uintptr_t smbase, unsigned int num_cpus,\n\t\t\t\tunsigned int stack_top, const struct smm_loader_params *params)\n{\n\tunsigned int i;\n\tunsigned int size;\n\tif (smm_create_map(smbase, num_cpus, params)) {\n\t\tif (cpus[num_cpus].active) {\n\t\t\tif (cpus[num_cpus - 1].smbase +\n\t\t\t\tparams->smm_main_entry_offset < stack_top) {\n\t\t\t\tprintk(BIOS_ERR, \"%s: stack encroachment\\n\", __func__);\n\t\t\t\tprintk(BIOS_ERR, \"%s: smbase %zx, stack_top %x\\n\",\n\t\t\t\t\t__func__, cpus[num_cpus].smbase, stack_top);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tprintk(BIOS_ERR, \"%s: unable to place smm entry code\\n\", __func__);\n\t\treturn 0;\n\t}\n\tprintk(BIOS_INFO, \"%s: smbase %zx, stack_top %x\\n\",\n\t\t__func__, cpus[num_cpus-1].smbase, stack_top);\n\tsize = cpus[0].code_end - cpus[0].code_start;\n\tfor (i = 1; i < num_cpus; i++) {\n\t\tmemcpy((int *)cpus[i].code_start, (int *)cpus[0].code_start, size);\n\t\tprintk(BIOS_DEBUG,\n\t\t\t\"SMM Module: placing smm entry code at %zx,  cpu # 0x%x\\n\",\n\t\t\tcpus[i].code_start, i);\n\t\tprintk(BIOS_DEBUG, \"%s: copying from %zx to %zx 0x%x bytes\\n\",\n\t\t\t__func__, cpus[0].code_start, cpus[i].code_start, size);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int __init personal_server_map_irq(const struct pci_dev *dev, u8 slot,\n\tu8 pin)\n{\n\tunsigned char line;\n\tpci_read_config_byte(dev, PCI_INTERRUPT_LINE, &line);\n\tif (line > 0x40 && line <= 0x5f) {\n\t\treturn irqmap_personal_server[(line & 0x1f) - 8];\n\t} else if (line == 0) {\n\t\treturn 0;\n\t} else\n\t\treturn irqmap_personal_server[(line - 1) & 3];\n}", "target": 1}
{"code": "ActivationPtr createActivation(Protobuf::Arena& arena, const StreamInfo::StreamInfo& info,\n                               const Http::RequestHeaderMap* request_headers,\n                               const Http::ResponseHeaderMap* response_headers,\n                               const Http::ResponseTrailerMap* response_trailers) {\n  auto activation = std::make_unique<Activation>();\n  activation->InsertValueProducer(Request,\n                                  std::make_unique<RequestWrapper>(arena, request_headers, info));\n  activation->InsertValueProducer(Response, std::make_unique<ResponseWrapper>(\n                                                arena, response_headers, response_trailers, info));\n  activation->InsertValueProducer(Connection, std::make_unique<ConnectionWrapper>(info));\n  activation->InsertValueProducer(Upstream, std::make_unique<UpstreamWrapper>(info));\n  activation->InsertValueProducer(Source, std::make_unique<PeerWrapper>(info, false));\n  activation->InsertValueProducer(Destination, std::make_unique<PeerWrapper>(info, true));\n  activation->InsertValueProducer(Metadata,\n                                  std::make_unique<MetadataProducer>(info.dynamicMetadata()));\n  activation->InsertValueProducer(FilterState,\n                                  std::make_unique<FilterStateWrapper>(info.filterState()));\n  return activation;\n}", "target": 0}
{"code": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\treturn prog;\n}", "target": 1}
{"code": "static inline void blk_mq_tag_set_rq(struct blk_mq_hw_ctx *hctx,\n\t\tunsigned int tag, struct request *rq)\n{\n\thctx->tags->rqs[tag] = rq;\n}", "target": 0}
{"code": "static bool too_many_pipe_buffers_soft(struct user_struct *user)\n{\n\treturn pipe_user_pages_soft &&\n\t       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_soft;\n}", "target": 0}
{"code": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n\tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n\t\treturn -EINVAL;\n\tbsg_set_block(bd, file);\n\tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\t*ppos = bytes_written;\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}", "target": 0}
{"code": "GF_Err diST_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i;\n\tchar str[1024];\n\tGF_DIMSScriptTypesBox *p = (GF_DIMSScriptTypesBox *)s;\n\ti=0;\n\tstr[0]=0;\n\twhile (1) {\n\t\tstr[i] = gf_bs_read_u8(bs);\n\t\tif (!str[i]) break;\n\t\ti++;\n\t}\n\tISOM_DECREASE_SIZE(p, i);\n\tp->content_script_types = gf_strdup(str);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}", "target": 1}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tassert(bidx <= PCI_BARMAX);\n\tassert(pdi->bar[bidx].type == PCIBAR_MEM32 ||\n\t       pdi->bar[bidx].type == PCIBAR_MEM64);\n\tassert(addr >= pdi->bar[bidx].addr &&\n\t       addr + size <= pdi->bar[bidx].addr + pdi->bar[bidx].size);\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; \n\tline[strlen(line)-1] = 0; \n\treturn line;\n}", "target": 0}
{"code": "RawTile OpenJPEGImage::getRegion( int ha, int va, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h ){\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, ha, va, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w * h * channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w * h * channels];\n  else throw file_error( \"OpenJPEG :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"OpenJPEG :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "static int nft_inner_init(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nlattr * const tb[])\n{\n\tstruct nft_inner *priv = nft_expr_priv(expr);\n\tu32 flags, hdrsize, type, num;\n\tstruct nft_expr_info expr_info;\n\tint err;\n\tif (!tb[NFTA_INNER_FLAGS] ||\n\t    !tb[NFTA_INNER_NUM] ||\n\t    !tb[NFTA_INNER_HDRSIZE] ||\n\t    !tb[NFTA_INNER_TYPE] ||\n\t    !tb[NFTA_INNER_EXPR])\n\t\treturn -EINVAL;\n\tflags = ntohl(nla_get_be32(tb[NFTA_INNER_FLAGS]));\n\tif (flags & ~NFT_INNER_MASK)\n\t\treturn -EOPNOTSUPP;\n\tnum = ntohl(nla_get_be32(tb[NFTA_INNER_NUM]));\n\tif (num != 0)\n\t\treturn -EOPNOTSUPP;\n\thdrsize = ntohl(nla_get_be32(tb[NFTA_INNER_HDRSIZE]));\n\ttype = ntohl(nla_get_be32(tb[NFTA_INNER_TYPE]));\n\tif (type > U8_MAX)\n\t\treturn -EINVAL;\n\tif (flags & NFT_INNER_HDRSIZE) {\n\t\tif (hdrsize == 0 || hdrsize > 64)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\tpriv->flags = flags;\n\tpriv->hdrsize = hdrsize;\n\tpriv->type = type;\n\terr = nft_expr_inner_parse(ctx, tb[NFTA_INNER_EXPR], &expr_info);\n\tif (err < 0)\n\t\treturn err;\n\tpriv->expr.ops = expr_info.ops;\n\tif (!strcmp(expr_info.ops->type->name, \"payload\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_PAYLOAD;\n\telse if (!strcmp(expr_info.ops->type->name, \"meta\"))\n\t\tpriv->expr_type = NFT_INNER_EXPR_META;\n\telse\n\t\treturn -EINVAL;\n\terr = expr_info.ops->init(ctx, (struct nft_expr *)&priv->expr,\n\t\t\t\t  (const struct nlattr * const*)expr_info.tb);\n\tif (err < 0)\n\t\treturn err;\n\treturn 0;\n}", "target": 0}
{"code": "test_compare_files (const char* tgt, const char *rec)\n{\n  FILE *orig, *recons;\n  static uint8_t obuf[TESTBUFSIZE], rbuf[TESTBUFSIZE];\n  xoff_t offset = 0;\n  size_t i;\n  size_t oc, rc;\n  xoff_t diffs = 0;\n  if ((orig = fopen (tgt, \"r\")) == NULL)\n    {\n      XPR(NT \"open %s failed\\n\", tgt);\n      return get_errno ();\n    }\n  if ((recons = fopen (rec, \"r\")) == NULL)\n    {\n      XPR(NT \"open %s failed\\n\", rec);\n      return get_errno ();\n    }\n  for (;;)\n    {\n      oc = fread (obuf, 1, TESTBUFSIZE, orig);\n      rc = fread (rbuf, 1, TESTBUFSIZE, recons);\n      if (oc != rc)\n\t{\n\t  return XD3_INTERNAL;\n\t}\n      if (oc == 0)\n\t{\n\t  break;\n\t}\n      for (i = 0; i < oc; i += 1)\n\t{\n\t  if (obuf[i] != rbuf[i])\n \t    {\n\t      XPR(NT \"byte %u (read %u @ %\"Q\"u) %d != %d\\n\", \n\t\t  (int)i, (int)oc, offset, obuf[i], rbuf[i]);\n\t      diffs++;\n\t      return XD3_INTERNAL;\n\t    }\n\t}\n      offset += oc;\n    }\n    fclose (orig);\n    fclose (recons);\n    if (diffs != 0) \n      {\n\treturn XD3_INTERNAL;\n      }\n    return 0;\n}", "target": 1}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  CHECK(input != nullptr) << \"node = \" << node.name()\n                          << \" input = \" << node.input(0);\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static int __ext4_expand_extra_isize(struct inode *inode,\n\t\t\t\t     unsigned int new_extra_isize,\n\t\t\t\t     struct ext4_iloc *iloc,\n\t\t\t\t     handle_t *handle, int *no_expand)\n{\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\tunsigned int inode_size = EXT4_INODE_SIZE(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tint error;\n\tif ((EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize > inode_size) ||\n\t    (ei->i_extra_isize & 3)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extra_isize %u (inode size %u)\",\n\t\t\t\t ei->i_extra_isize,\n\t\t\t\t EXT4_INODE_SIZE(inode->i_sb));\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif ((new_extra_isize < ei->i_extra_isize) ||\n\t    (new_extra_isize < 4) ||\n\t    (new_extra_isize > inode_size - EXT4_GOOD_OLD_INODE_SIZE))\n\t\treturn -EINVAL;\t\n\traw_inode = ext4_raw_inode(iloc);\n\theader = IHDR(inode, raw_inode);\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||\n\t    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\tmemset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE +\n\t\t       EXT4_I(inode)->i_extra_isize, 0,\n\t\t       new_extra_isize - EXT4_I(inode)->i_extra_isize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\treturn 0;\n\t}\n\terror = ext4_expand_extra_isize_ea(inode, new_extra_isize,\n\t\t\t\t\t   raw_inode, handle);\n\tif (error) {\n\t\t*no_expand = 1;\n\t}\n\treturn error;\n}", "target": 0}
{"code": "int ext4_resize_begin(struct super_block *sb)\n{\n\tint ret = 0;\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\text4_warning(sb, \"There are errors in the filesystem, \"\n\t\t\t     \"so online resizing is not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\tif (test_and_set_bit_lock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags))\n\t\tret = -EBUSY;\n\treturn ret;\n}", "target": 0}
{"code": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "bool Url::Decode(string_view encoded, std::string* raw) {\n  for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {\n    if (*iter == '%') {\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int h_decimal = 0;\n      if (!HexToDecimal(*iter, &h_decimal)) {\n        return false;\n      }\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int l_decimal = 0;\n      if (!HexToDecimal(*iter, &l_decimal)) {\n        return false;\n      }\n      raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));\n    } else if (*iter > 127 || *iter < 0) {\n      return false;\n    } else {\n      raw->push_back(*iter);\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0f)\n    return(0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return(value);\n#endif\n}", "target": 1}
{"code": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}", "target": 1}
{"code": "TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));\n  for (std::vector<FrameInfo>::const_iterator info = frame_info_list_.begin();\n       info != frame_info_list_.end(); ++info) {\n    const unsigned int frame = static_cast<unsigned>(info->pts);\n    unsigned int expected_w;\n    unsigned int expected_h;\n    ScaleForFrameNumber(frame, kInitialWidth, kInitialHeight, &expected_w,\n                        &expected_h, video.flag_codec_,\n                        video.smaller_width_larger_size_);\n    EXPECT_EQ(expected_w, info->w)\n        << \"Frame \" << frame << \" had unexpected width\";\n    EXPECT_EQ(expected_h, info->h)\n        << \"Frame \" << frame << \" had unexpected height\";\n    EXPECT_EQ(static_cast<unsigned int>(0), GetMismatchFrames());\n  }\n}", "target": 1}
{"code": "TypedValue HHVM_FUNCTION(array_reverse,\n                         ArrayArg input,\n                         bool preserve_keys ) {\n  ArrNR arrNR(input.get());\n  const Array& arr = arrNR.asArray();\n  return tvReturn(ArrayUtil::Reverse(arr, preserve_keys));\n}", "target": 0}
{"code": "inline typename V::VectorType FBUnserializer<V>::unserializeList() {\n  p_ += CODE_SIZE;\n  unserializeInt64();\n  typename V::VectorType ret = V::createVector();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "static void do_free_publickey(struct ecc_public_key *key)\n{\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n}", "target": 1}
{"code": "static void ToPropertyDescriptor(js_State *J, js_Object *obj, const char *name, js_Object *desc)\n{\n\tint haswritable = 0;\n\tint hasvalue = 0;\n\tint enumerable = 0;\n\tint configurable = 0;\n\tint writable = 0;\n\tint atts = 0;\n\tjs_pushobject(J, obj);\n\tjs_pushobject(J, desc);\n\tif (js_hasproperty(J, -1, \"writable\")) {\n\t\thaswritable = 1;\n\t\twritable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"enumerable\")) {\n\t\tenumerable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"configurable\")) {\n\t\tconfigurable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"value\")) {\n\t\thasvalue = 1;\n\t\tjs_setproperty(J, -3, name);\n\t}\n\tif (!writable) atts |= JS_READONLY;\n\tif (!enumerable) atts |= JS_DONTENUM;\n\tif (!configurable) atts |= JS_DONTCONF;\n\tif (js_hasproperty(J, -1, \"get\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\tif (js_hasproperty(J, -2, \"set\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\tjs_defaccessor(J, -4, name, atts);\n\tjs_pop(J, 2);\n}", "target": 1}
{"code": "exit_ext2_xattr(void)\n{\n}", "target": 1}
{"code": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       n * sizeof(struct pipe_buffer));\n\t\t} else {\n\t\t\tunsigned int tsize = pipe->ring_size - t;\n\t\t\tif (h > 0)\n\t\t\t\tmemcpy(bufs + tsize, pipe->bufs,\n\t\t\t\t       h * sizeof(struct pipe_buffer));\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\t\t\t       tsize * sizeof(struct pipe_buffer));\n\t\t}\n\t}\n\thead = n;\n\ttail = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}", "target": 1}
{"code": "AirPDcapGetSa(\n    PAIRPDCAP_CONTEXT ctx,\n    AIRPDCAP_SEC_ASSOCIATION_ID *id)\n{\n    INT sa_index;\n    if (ctx->sa_index!=-1) {\n        for (sa_index=ctx->sa_index; sa_index>=0; sa_index--) {\n            if (ctx->sa[sa_index].used) {\n                if (memcmp(id, &(ctx->sa[sa_index].saId), sizeof(AIRPDCAP_SEC_ASSOCIATION_ID))==0) {\n                    ctx->index=sa_index;\n                    return sa_index;\n                }\n            }\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "static void *__ns_get_path(struct path *path, struct ns_common *ns)\n{\n\tstruct vfsmount *mnt = nsfs_mnt;\n\tstruct qstr qname = { .name = \"\", };\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tunsigned long d;\n\trcu_read_lock();\n\td = atomic_long_read(&ns->stashed);\n\tif (!d)\n\t\tgoto slow;\n\tdentry = (struct dentry *)d;\n\tif (!lockref_get_not_dead(&dentry->d_lockref))\n\t\tgoto slow;\n\trcu_read_unlock();\n\tns->ops->put(ns);\ngot_it:\n\tpath->mnt = mntget(mnt);\n\tpath->dentry = dentry;\n\treturn NULL;\nslow:\n\trcu_read_unlock();\n\tinode = new_inode_pseudo(mnt->mnt_sb);\n\tif (!inode) {\n\t\tns->ops->put(ns);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinode->i_ino = ns->inum;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tinode->i_flags |= S_IMMUTABLE;\n\tinode->i_mode = S_IFREG | S_IRUGO;\n\tinode->i_fop = &ns_file_operations;\n\tinode->i_private = ns;\n\tdentry = d_alloc_pseudo(mnt->mnt_sb, &qname);\n\tif (!dentry) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\td_instantiate(dentry, inode);\n\tdentry->d_flags |= DCACHE_RCUACCESS;\n\tdentry->d_fsdata = (void *)ns->ops;\n\td = atomic_long_cmpxchg(&ns->stashed, 0, (unsigned long)dentry);\n\tif (d) {\n\t\td_delete(dentry);\t\n\t\tdput(dentry);\n\t\tcpu_relax();\n\t\treturn ERR_PTR(-EAGAIN);\n\t}\n\tgoto got_it;\n}", "target": 0}
{"code": "static void handle_irq_for_port(evtchn_port_t port)\n{\n\tint irq;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq != -1)\n\t\tgeneric_handle_irq(irq);\n}", "target": 1}
{"code": "LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n    if (type != EXPR_TYPE_INT)\n        return false;\n    str = xkb_atom_text(ctx, field);\n    if (!str)\n        return false;\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n    *val_rtrn = (1u << ndx);\n    return true;\n}", "target": 0}
{"code": "    bool cmpPreviewProperties(\n        const PreviewProperties& lhs,\n        const PreviewProperties& rhs\n    )\n    {\n        uint32_t l = lhs.width_ * lhs.height_;\n        uint32_t r = rhs.width_ * rhs.height_;\n        return l < r;\n    }", "target": 0}
{"code": "int sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, (xmlHashDeallocator) xmlFreeID);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "static void ext4_journal_commit_callback(journal_t *journal, transaction_t *txn)\n{\n\tstruct super_block\t\t*sb = journal->j_private;\n\tstruct ext4_sb_info\t\t*sbi = EXT4_SB(sb);\n\tint\t\t\t\terror = is_journal_aborted(journal);\n\tstruct ext4_journal_cb_entry\t*jce, *tmp;\n\tspin_lock(&sbi->s_md_lock);\n\tlist_for_each_entry_safe(jce, tmp, &txn->t_private_list, jce_list) {\n\t\tlist_del_init(&jce->jce_list);\n\t\tspin_unlock(&sbi->s_md_lock);\n\t\tjce->jce_func(sb, jce, error);\n\t\tspin_lock(&sbi->s_md_lock);\n\t}\n\tspin_unlock(&sbi->s_md_lock);\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const auto params =\n      static_cast<const TfLiteFullyConnectedParams*>(node->builtin_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  const TfLiteTensor* filter = GetInput(context, node, kWeightsTensor);\n  TF_LITE_ENSURE(context, filter != nullptr);\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE_MSG(context, input->type == filter->type,\n                     \"Hybrid models are not supported on TFLite Micro.\");\n  return CalculateOpData(context, params->activation, input->type, input,\n                         filter, bias, output, data);\n}", "target": 0}
{"code": "cib_notify_client(gpointer key, gpointer value, gpointer user_data)\n{\n    const char *type = NULL;\n    gboolean do_send = FALSE;\n    cib_client_t *client = value;\n    xmlNode *update_msg = user_data;\n    CRM_CHECK(client != NULL, return TRUE);\n    CRM_CHECK(update_msg != NULL, return TRUE);\n    if (client->ipc == NULL) {\n        crm_warn(\"Skipping client with NULL channel\");\n        return FALSE;\n    }\n    type = crm_element_value(update_msg, F_SUBTYPE);\n    CRM_LOG_ASSERT(type != NULL);\n    if (client->diffs && safe_str_eq(type, T_CIB_DIFF_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->replace && safe_str_eq(type, T_CIB_REPLACE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->confirmations && safe_str_eq(type, T_CIB_UPDATE_CONFIRM)) {\n        do_send = TRUE;\n    } else if (client->pre_notify && safe_str_eq(type, T_CIB_PRE_NOTIFY)) {\n        do_send = TRUE;\n    } else if (client->post_notify && safe_str_eq(type, T_CIB_POST_NOTIFY)) {\n        do_send = TRUE;\n    }\n    if (do_send) {\n        if (client->ipc) {\n            if(crm_ipcs_send(client->ipc, 0, update_msg, TRUE) == FALSE) {\n                crm_warn(\"Notification of client %s/%s failed\", client->name, client->id);\n            }\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client->session) {\n            crm_debug(\"Sent %s notification to client %s/%s\", type, client->name, client->id);\n            crm_send_remote_msg(client->session, update_msg, client->encrypted);\n#endif\n        } else {\n            crm_err(\"Unknown transport for %s\", client->name);\n        }\n    }\n    return FALSE;\n}", "target": 1}
{"code": "dump_dest_constraints(const char *context,\n    const struct dest_constraint *dcs, size_t ndcs)\n{\n#ifdef DEBUG_CONSTRAINTS\n\tsize_t i;\n\tdebug_f(\"%s: %zu constraints\", context, ndcs);\n\tfor (i = 0; i < ndcs; i++) {\n\t\tdebug_f(\"constraint %zu / %zu: from: \", i, ndcs);\n\t\tdump_dest_constraint_hop(&dcs[i].from);\n\t\tdebug_f(\"constraint %zu / %zu: to: \", i, ndcs);\n\t\tdump_dest_constraint_hop(&dcs[i].to);\n\t}\n\tdebug_f(\"done for %s\", context);\n#endif \n}", "target": 0}
{"code": "coolkey_find_matching_cert(sc_card_t *card, sc_cardctl_coolkey_object_t *in_obj, sc_cardctl_coolkey_object_t **cert_obj) {\n\tsc_cardctl_coolkey_find_object_t fobj;\n\tsc_cardctl_coolkey_attribute_t template[2];\n\tu8 obj_class[4];\n\tint r;\n\ttemplate[0].attribute_type = CKA_CLASS;\n\ttemplate[0].attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\ttemplate[0].attribute_length = sizeof(obj_class);\n\ttemplate[0].attribute_value = obj_class;\n\tulong2bebytes(obj_class, CKO_CERTIFICATE);\n\ttemplate[1].attribute_type = CKA_ID;\n\ttemplate[1].object = in_obj;\n\tr = sc_card_ctl(card, SC_CARDCTL_COOLKEY_GET_ATTRIBUTE, &template[1]);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\ttemplate[0].object = NULL; \n\ttemplate[1].object = NULL; \n\tfobj.type = SC_CARDCTL_COOLKEY_FIND_BY_TEMPLATE;\n\tfobj.obj = NULL;\n\tfobj.coolkey_template = &template[0];\n\tfobj.template_count=2;\n\tr = sc_card_ctl(card, SC_CARDCTL_COOLKEY_FIND_OBJECT, &fobj);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\t*cert_obj = fobj.obj;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "sanitize_speculative_path(struct bpf_verifier_env *env,\n\t\t\t  const struct bpf_insn *insn,\n\t\t\t  u32 next_idx, u32 curr_idx)\n{\n\tstruct bpf_verifier_state *branch;\n\tstruct bpf_reg_state *regs;\n\tbranch = push_stack(env, next_idx, curr_idx, true);\n\tif (branch && insn) {\n\t\tregs = branch->frame[branch->curframe]->regs;\n\t\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tmark_reg_unknown(env, regs, insn->src_reg);\n\t\t}\n\t}\n\treturn branch;\n}", "target": 0}
{"code": "void ogs_pfcp_context_init(void)\n{\n    int i;\n    ogs_assert(context_initialized == 0);\n    memset(&self, 0, sizeof(ogs_pfcp_context_t));\n    self.local_recovery = ogs_time_ntp32_now();\n    ogs_log_install_domain(&__ogs_pfcp_domain, \"pfcp\", ogs_core()->log.level);\n    ogs_pool_init(&ogs_pfcp_node_pool, ogs_app()->pool.nf);\n    ogs_pool_init(&ogs_pfcp_sess_pool, ogs_app()->pool.sess);\n    ogs_pool_init(&ogs_pfcp_far_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_FAR);\n    ogs_pool_init(&ogs_pfcp_urr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_URR);\n    ogs_pool_init(&ogs_pfcp_qer_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_QER);\n    ogs_pool_init(&ogs_pfcp_bar_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_BAR);\n    ogs_pool_init(&ogs_pfcp_pdr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_PDR);\n    ogs_pool_init(&ogs_pfcp_pdr_teid_pool, ogs_pfcp_pdr_pool.size);\n    ogs_pool_random_id_generate(&ogs_pfcp_pdr_teid_pool);\n    pdr_random_to_index = ogs_calloc(\n            sizeof(ogs_pool_id_t), ogs_pfcp_pdr_pool.size);\n    ogs_assert(pdr_random_to_index);\n    for (i = 0; i < ogs_pfcp_pdr_pool.size; i++)\n        pdr_random_to_index[ogs_pfcp_pdr_teid_pool.array[i]] = i;\n    ogs_pool_init(&ogs_pfcp_rule_pool,\n            ogs_app()->pool.sess *\n            OGS_MAX_NUM_OF_PDR * OGS_MAX_NUM_OF_FLOW_IN_PDR);\n    ogs_pool_init(&ogs_pfcp_dev_pool, OGS_MAX_NUM_OF_DEV);\n    ogs_pool_init(&ogs_pfcp_subnet_pool, OGS_MAX_NUM_OF_SUBNET);\n    self.object_teid_hash = ogs_hash_make();\n    ogs_assert(self.object_teid_hash);\n    self.far_f_teid_hash = ogs_hash_make();\n    ogs_assert(self.far_f_teid_hash);\n    self.far_teid_hash = ogs_hash_make();\n    ogs_assert(self.far_teid_hash);\n    context_initialized = 1;\n}", "target": 1}
{"code": "bool IsHostMemoryArg(const EagerOperation& op, const NodeDef* node_def,\n                     const Device* op_device, const KernelDef* kernel_def,\n                     const int port_id) {\n  if (op.is_function()) return false;\n  if (node_def == nullptr) return false;\n  if (kernel_def == nullptr || op_device == nullptr) return false;\n  const auto& host_memory_args = kernel_def->host_memory_arg();\n  const OpDef& op_def = OpRegistry::Global()->LookUp(op.Name())->op_def;\n  const int arg_id = OpPortIdToArgId(*node_def, op_def.input_arg(), port_id);\n  if (arg_id < 0) {\n    return false;\n  }\n  return std::find(host_memory_args.begin(), host_memory_args.end(),\n                   op_def.input_arg(arg_id).name()) != host_memory_args.end();\n}", "target": 0}
{"code": "void ast_dns_resolver_completed(struct ast_dns_query *query)\n{\n\tsort_result(ast_dns_query_get_rr_type(query), query->result);\n\tquery->callback(query);\n}", "target": 1}
{"code": "void IGDstartelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tmemcpy( datas->cureltname, name, l);\n\tdatas->cureltname[l] = '\\0';\n\tdatas->level++;\n\tif( (l==7) && !memcmp(name, \"service\", l) ) {\n\t\tdatas->tmp.controlurl[0] = '\\0';\n\t\tdatas->tmp.eventsuburl[0] = '\\0';\n\t\tdatas->tmp.scpdurl[0] = '\\0';\n\t\tdatas->tmp.servicetype[0] = '\\0';\n\t}\n}", "target": 1}
{"code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp->input, 28);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,\n\t\tstruct snd_compr_params *params)\n{\n\tunsigned int buffer_size;\n\tvoid *buffer;\n\tif (params->buffer.fragment_size == 0 ||\n\t    params->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tbuffer_size = params->buffer.fragment_size * params->buffer.fragments;\n\tif (stream->ops->copy) {\n\t\tbuffer = NULL;\n\t} else {\n\t\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\t}\n\tstream->runtime->fragment_size = params->buffer.fragment_size;\n\tstream->runtime->fragments = params->buffer.fragments;\n\tstream->runtime->buffer = buffer;\n\tstream->runtime->buffer_size = buffer_size;\n\treturn 0;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &getHeaders() const\n    {\n        return headers();\n    }", "target": 1}
{"code": "int ecall_answer(struct ecall *ecall, enum icall_call_type call_type,\n\t\t bool audio_cbr)\n{\n\tint err = 0;\n\tif (!ecall)\n\t\treturn EINVAL;\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\tinfo(\"ecall(%p): answer on pending econn %p call_type=%d\\n\", ecall, ecall->econn, call_type);\n\tif (!ecall->econn) {\n\t\twarning(\"ecall: answer: econn does not exist!\\n\");\n\t\treturn ENOENT;\n\t}\n\tif (ECONN_PENDING_INCOMING != econn_current_state(ecall->econn)) {\n\t\tinfo(\"ecall(%p): answer: invalid state (%s)\\n\", ecall,\n\t\t     econn_state_name(econn_current_state(ecall->econn)));\n\t\treturn EPROTO;\n\t}\n\tif (!ecall->flow) {\n\t\twarning(\"ecall: answer: no mediaflow\\n\");\n\t\treturn EPROTO;\n\t}\n\tecall->call_type = call_type;\n\tIFLOW_CALL(ecall->flow, set_call_type, call_type);\n\tecall->audio_cbr = audio_cbr;\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n#if 0\n\tif (ecall->props_local) {\n\t\tconst char *vstate_string =\n\t\t\tcall_type == ICALL_CALL_TYPE_VIDEO ? \"true\" : \"false\";\n\t\tint err2 = econn_props_update(ecall->props_local, \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t}\n\t}\n#endif\n\terr = generate_or_gather_answer(ecall, ecall->econn);\n\tif (err) {\n\t\twarning(\"ecall: answer: failed to gather_or_answer\\n\");\n\t\tgoto out;\n\t}\n\tecall->answered = true;\n\tecall->audio_setup_time = -1;\n\tecall->call_estab_time = -1;\n\tecall->ts_answered = tmr_jiffies();\n out:\n\treturn err;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList params_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"params_nested_splits\",\n                                                &params_nested_splits_in));\n    const Tensor& params_dense_values_in =\n        context->input(params_nested_splits_in.size());\n    const Tensor& indices_in =\n        context->input(params_nested_splits_in.size() + 1);\n    DCHECK_GT(params_nested_splits_in.size(), 0);  \n    SPLITS_TYPE num_params = params_nested_splits_in[0].dim_size(0) - 1;\n    OP_REQUIRES_OK(context, ValidateIndices(indices_in, num_params));\n    OP_REQUIRES(context, params_dense_values_in.dims() > 0,\n                errors::InvalidArgument(\"params.rank must be nonzero\"));\n    SPLITS_TYPE num_params_dense_values = params_dense_values_in.dim_size(0);\n    std::vector<std::pair<SPLITS_TYPE, SPLITS_TYPE>> value_slices;\n    SPLITS_TYPE num_values = 0;\n    std::vector<std::vector<SPLITS_TYPE>> out_splits;\n    OP_REQUIRES_OK(context, MakeSplits(indices_in, params_nested_splits_in,\n                                       num_params_dense_values, &out_splits,\n                                       &value_slices, &num_values));\n    OP_REQUIRES_OK(context, WriteSplits(out_splits, context));\n    OP_REQUIRES_OK(context,\n                   WriteValues(params_dense_values_in, value_slices,\n                               out_splits.size(), num_values, context));\n  }", "target": 1}
{"code": "static void clamp_buffer(void*& buffer, size_t& size, void* limit_start, void* limit_end)\n{\n\tif (NULL == limit_start || NULL == limit_end)\n\t\treturn;\n\tuint8_t* _buffer = (uint8_t*)buffer;\n\tuint8_t* _limit_start = (uint8_t*)limit_start;\n\tuint8_t* _limit_end = (uint8_t*)limit_end;\n\tif (_buffer > _limit_end)\n\t{\n\t\tbuffer = limit_end;\n\t\tsize = 0;\n\t\treturn;\n\t}\n\tif (_buffer < _limit_start)\n\t\t_buffer = _limit_start;\n\tif ((_buffer + size) > _limit_end)\n\t\tsize = (_limit_end - _buffer);\n}", "target": 0}
{"code": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\tptr++;\t\t\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}", "target": 1}
{"code": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "  bool hasEncodingError() const {\n    return encodingError_;\n  }", "target": 0}
{"code": "static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n\tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n\tvoid *memory;\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\treturn __dma_alloc(dev, size, handle, gfp, prot, true,\n\t\t\t   __builtin_return_address(0));\n}", "target": 1}
{"code": "spaddr_print_ip(netdissect_options *ndo,\n\t        const struct arp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (PROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong len>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, SPA(ap))));\n}", "target": 0}
{"code": "static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,\n  uint_fast16_t *stepsizes)\n{\n\tint bandno;\n\tint numbands;\n\tuint_fast16_t expn;\n\tuint_fast16_t mant;\n\texpn = JPC_QCX_GETEXPN(refstepsize);\n\tmant = JPC_QCX_GETMANT(refstepsize);\n\tnumbands = 3 * numrlvls - 2;\n\tfor (bandno = 0; bandno < numbands; ++bandno) {\n\t\tstepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +\n\t\t  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));\n\t}\n}", "target": 0}
{"code": "void RestAuthHandler::shutdownExecute(bool isFinalized) noexcept {\n  try {\n    if (_isValid) {\n      events::LoggedIn(*_request, _username);\n    } else {\n      events::CredentialsBad(*_request, _username);\n    }\n  } catch (...) {\n  }\n  RestVocbaseBaseHandler::shutdownExecute(isFinalized);\n}", "target": 1}
{"code": "tsetcap(int cap, int flags)\n{\n    if (tccan(cap) && !isset(SINGLELINEZLE) &&\n        !(termflags & (TERM_NOUP|TERM_BAD|TERM_UNKNOWN))) {\n\tswitch (flags & TSC_OUTPUT_MASK) {\n\tcase TSC_RAW:\n\t    tputs(tcstr[cap], 1, putraw);\n\t    break;\n\tcase 0:\n\tdefault:\n\t    tputs(tcstr[cap], 1, putshout);\n\t    break;\n\tcase TSC_PROMPT:\n\t    if (!bv->dontcount) {\n\t\taddbufspc(1);\n\t\t*bv->bp++ = Inpar;\n\t    }\n\t    tputs(tcstr[cap], 1, putstr);\n\t    if (!bv->dontcount) {\n\t\tint glitch = 0;\n\t\tif (cap == TCSTANDOUTBEG || cap == TCSTANDOUTEND)\n\t\t    glitch = tgetnum(\"sg\");\n\t\telse if (cap == TCUNDERLINEBEG || cap == TCUNDERLINEEND)\n\t\t    glitch = tgetnum(\"ug\");\n\t\tif(glitch < 0)\n\t\t    glitch = 0;\n\t\taddbufspc(glitch + 1);\n\t\twhile(glitch--)\n\t\t    *bv->bp++ = Nularg;\n\t\t*bv->bp++ = Outpar;\n\t    }\n\t    break;\n\t}\n\tif (flags & TSC_DIRTY) {\n\t    flags &= ~TSC_DIRTY;\n\t    if (txtisset(TXTBOLDFACE) && cap != TCBOLDFACEBEG)\n\t\ttsetcap(TCBOLDFACEBEG, flags);\n\t    if (txtisset(TXTSTANDOUT))\n\t\ttsetcap(TCSTANDOUTBEG, flags);\n\t    if (txtisset(TXTUNDERLINE))\n\t\ttsetcap(TCUNDERLINEBEG, flags);\n\t    if (txtisset(TXTFGCOLOUR))\n\t\tset_colour_attribute(txtattrmask, COL_SEQ_FG, TSC_PROMPT);\n\t    if (txtisset(TXTBGCOLOUR))\n\t\tset_colour_attribute(txtattrmask, COL_SEQ_BG, TSC_PROMPT);\n\t}\n    }\n}", "target": 0}
{"code": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\tref->ref++;\n}", "target": 1}
{"code": "    size_t MemIo::write(const byte* data, size_t wcount)\n    {\n        p_->reserve(wcount);\n        assert(p_->isMalloced_);\n        if (data != nullptr) {\n            std::memcpy(&p_->data_[p_->idx_], data, wcount);\n        }\n        p_->idx_ += wcount;\n        return wcount;\n    }", "target": 0}
{"code": "HMAC_SHA256_Final(unsigned char digest[32], struct HMAC_SHA256_CTX * ctx)\n{\n  unsigned char ihash[32];\n  scrypt_SHA256_Final(ihash, &ctx->ictx);\n  scrypt_SHA256_Update(&ctx->octx, ihash, 32);\n  scrypt_SHA256_Final(digest, &ctx->octx);\n  memset(ihash, 0, 32);\n}", "target": 1}
{"code": "static void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}", "target": 0}
{"code": "int xml_init(modsec_rec *msr, char **error_msg) {\n    xmlParserInputBufferCreateFilenameFunc entity;\n    if (error_msg == NULL) return -1;\n    *error_msg = NULL;\n    msr->xml = apr_pcalloc(msr->mp, sizeof(xml_data));\n    if (msr->xml == NULL) return -1;\n    if(msr->txcfg->xml_external_entity == 0)    {\n        entity = xmlParserInputBufferCreateFilenameDefault(xml_unload_external_entity);\n    }\n    return 1;\n}", "target": 0}
{"code": "static int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1}
{"code": "int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\t*cmd++ = htons(S_CMD_PACKET);\n\t*cmd++ = *pid;\n\tplen = len - 2;\n    if (plen < 0)\n        return 0;\n\tlast_id = ntohs(*pid);\n\tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "void gf_isom_check_position(GF_Box *s, GF_Box *child, u32 *pos)\n{\n\tif (!s || !s->child_boxes || !child || !pos) return;\n\tif (s->internal_flags & GF_ISOM_ORDER_FREEZE)\n\t\treturn;\n\ts32 cur_pos = gf_list_find(s->child_boxes, child);\n\tif (cur_pos < 0) return;\n\tif (cur_pos != (s32) *pos) {\n\t\tgf_list_del_item(s->child_boxes, child);\n\t\tgf_list_insert(s->child_boxes, child, *pos);\n\t}\n\t(*pos)++;", "target": 1}
{"code": "static int nr_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tlock_sock(sk);\n\tif (sock->state != SS_UNCONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tmemset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "end_write(JOIN *join, JOIN_TAB *join_tab __attribute__((unused)),\n\t  bool end_of_records)\n{\n  TABLE *const table= join_tab->table;\n  DBUG_ENTER(\"end_write\");\n  if (!end_of_records)\n  {\n    copy_fields(join_tab->tmp_table_param);\n    if (copy_funcs(join_tab->tmp_table_param->items_to_copy, join->thd))\n      DBUG_RETURN(NESTED_LOOP_ERROR);           \n    if (likely(!join_tab->having || join_tab->having->val_int()))\n    {\n      int error;\n      join->found_records++;\n      if ((error= table->file->ha_write_tmp_row(table->record[0])))\n      {\n        if (likely(!table->file->is_fatal_error(error, HA_CHECK_DUP)))\n\t  goto end;                             \n        bool is_duplicate;\n\tif (create_internal_tmp_table_from_heap(join->thd, table, \n                                                join_tab->tmp_table_param->start_recinfo,\n                                                &join_tab->tmp_table_param->recinfo,\n                                                error, 1, &is_duplicate))\n\t  DBUG_RETURN(NESTED_LOOP_ERROR);        \n        if (is_duplicate)\n          goto end;\n\ttable->s->uniques=0;\t\t\t\n      }\n      if (++join_tab->send_records >=\n            join_tab->tmp_table_param->end_write_records &&\n\t  join->do_send_rows)\n      {\n\tif (!(join->select_options & OPTION_FOUND_ROWS))\n\t  DBUG_RETURN(NESTED_LOOP_QUERY_LIMIT);\n\tjoin->do_send_rows=0;\n\tjoin->unit->select_limit_cnt = HA_POS_ERROR;\n      }\n    }\n  }\nend:\n  if (unlikely(join->thd->check_killed()))\n  {\n    DBUG_RETURN(NESTED_LOOP_KILLED);             \n  }\n  DBUG_RETURN(NESTED_LOOP_OK);\n}", "target": 0}
{"code": "parse_notification(struct rpki_uri *uri, struct update_notification **file)\n{\n\tstruct rdr_notification_ctx ctx;\n\tstruct update_notification *tmp;\n\tchar *dup;\n\tint error;\n\tdup = strdup(uri_get_global(uri));\n\tif (dup == NULL)\n\t\treturn pr_enomem();\n\terror = update_notification_create(&tmp);\n\tif (error)\n\t\treturn error;\n\ttmp->uri = dup;\n\tctx.notification = tmp;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_notification,\n\t    &ctx);\n\tif (error) {\n\t\tupdate_notification_destroy(tmp);\n\t\treturn error;\n\t}\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,\n\t\t\t\tconst struct nla_policy *policy,\n\t\t\t\tunsigned int validate,\n\t\t\t\tstruct netlink_ext_ack *extack,\n\t\t\t\tstruct nlattr **tb)\n{\n\tconst struct nlattr *nla;\n\tint rem;\n\tif (tb)\n\t\tmemset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));\n\tnla_for_each_attr(nla, head, len, rem) {\n\t\tu16 type = nla_type(nla);\n\t\tif (type == 0 || type > maxtype) {\n\t\t\tif (validate & NL_VALIDATE_MAXTYPE) {\n\t\t\t\tNL_SET_ERR_MSG_ATTR(extack, nla,\n\t\t\t\t\t\t    \"Unknown attribute type\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (policy) {\n\t\t\tint err = validate_nla(nla, maxtype, policy,\n\t\t\t\t\t       validate, extack);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (tb)\n\t\t\ttb[type] = (struct nlattr *)nla;\n\t}\n\tif (unlikely(rem > 0)) {\n\t\tpr_warn_ratelimited(\"netlink: %d bytes leftover after parsing attributes in process `%s'.\\n\",\n\t\t\t\t    rem, current->comm);\n\t\tNL_SET_ERR_MSG(extack, \"bytes leftover after parsing attributes\");\n\t\tif (validate & NL_VALIDATE_TRAILING)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "CompositeDeepScanLine::setFrameBuffer(const FrameBuffer& fr)\n{\n    _Data->_channels.resize(3);\n    _Data->_channels[0]=\"Z\";\n    _Data->_channels[1]=_Data->_zback ? \"ZBack\" : \"Z\";\n    _Data->_channels[2]=\"A\";\n    _Data->_bufferMap.resize(0);\n    for(FrameBuffer::ConstIterator q=fr.begin();q!=fr.end();q++)\n    {\n        if(q.slice().xSampling!=1 || q.slice().ySampling!=1)\n        {\n             THROW (IEX_NAMESPACE::ArgExc, \"X and/or y subsampling factors \"\n\t\t\t\t\"of \\\"\" << q.name() << \"\\\" channel in framebuffer \"\n\t\t\t\t\"are not 1\");\n        }\n        string name(q.name());\n        if(name==\"ZBack\")\n        {\n            _Data->_bufferMap.push_back(1);\n        }else if(name==\"Z\")\n        {\n            _Data->_bufferMap.push_back(0);\n        }else if(name==\"A\")\n        {\n            _Data->_bufferMap.push_back(2);\n        }else{\n            _Data->_bufferMap.push_back(static_cast<int>(_Data->_channels.size()));\n            _Data->_channels.push_back(name);\n        }\n    }\n  _Data->_outputFrameBuffer=fr;\n}", "target": 0}
{"code": "static static void adpt_delay(int millisec)\n{\n\tint i;\n\tfor (i = 0; i < millisec; i++) {\n\t\tudelay(1000);\t\n\t}\n}", "target": 1}
{"code": "struct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tget_user_ns(new->ns);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}", "target": 0}
{"code": "static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsec.level = rfcomm_pi(sk)->sec_level;\n\t\tsec.key_size = 0;\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "int nfc_dev_up(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->rfkill && rfkill_blocked(dev->rfkill)) {\n\t\trc = -ERFKILL;\n\t\tgoto error;\n\t}\n\tif (dev->fw_download_in_progress) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_up)\n\t\trc = dev->ops->dev_up(dev);\n\tif (!rc)\n\t\tdev->dev_up = true;\n\tif (dev->ops->discover_se && dev->ops->discover_se(dev))\n\t\tpr_err(\"SE discovery failed\\n\");\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "hostlist_matches_int(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = host_matches(parse_tree, pw, lhost, shost, m);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "void BinaryProtocolReader::readStringBody(StrType& str, int32_t size) {\n  checkStringSize(size);\n  if (size == 0) {\n    str.clear();\n    return;\n  }\n  if (static_cast<int32_t>(in_.length()) < size) {\n    if (!in_.canAdvance(size)) {\n      protocol::TProtocolException::throwTruncatedData();\n    }\n    str.reserve(size); \n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}", "target": 0}
{"code": "GF_EXPORT\nvoid gf_isom_reset_sample_count(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif", "target": 0}
{"code": "smix(uint8_t * B, size_t r, uint64_t N, void * V, void * XY)\n{\n  __m128i * X = (__m128i *) XY;\n  __m128i * Y = (__m128i *) ((uintptr_t)(XY) + 128 * r);\n  __m128i * Z = (__m128i *) ((uintptr_t)(XY) + 256 * r);\n  uint32_t * X32 = (uint32_t *)X;\n  uint64_t i, j;\n  size_t k;\n  for (k = 0; k < 2 * r; k++) {\n    for (i = 0; i < 16; i++) {\n      X32[k * 16 + i] = folly::Endian::little32(\n                          *((uint32_t *) &B[(k * 16 + (i * 5 % 16)) * 4]));\n    }\n  }\n  for (i = 0; i < N; i += 2) {\n    blkcpy((void *)((uintptr_t)(V) + i * 128 * r), X, 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    blkcpy((void *)((uintptr_t)(V) + (i + 1) * 128 * r),\n        Y, 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (i = 0; i < N; i += 2) {\n    j = integerify(X, r) & (N - 1);\n    blkxor(X, (void *)((uintptr_t)(V) + j * 128 * r), 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    j = integerify(Y, r) & (N - 1);\n    blkxor(Y, (void *)((uintptr_t)(V) + j * 128 * r), 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (k = 0; k < 2 * r; k++) {\n    for (i = 0; i < 16; i++) {\n      *((uint32_t *) &B[(k * 16 + (i * 5 % 16)) * 4]) =\n          folly::Endian::little32(X32[k * 16 + i]);\n    }\n  }\n}", "target": 1}
{"code": "GF_Err gf_isom_get_media_time(GF_ISOFile *the_file, u32 trackNumber, u32 movieTime, u64 *MediaTime)\n{\n\tGF_TrackBox *trak;\n\tu8 useEdit;\n\ts64 SegmentStartTime, mediaOffset;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !MediaTime) return GF_BAD_PARAM;\n\tSegmentStartTime = 0;\n\treturn GetMediaTime(trak, GF_FALSE, movieTime, MediaTime, &SegmentStartTime, &mediaOffset, &useEdit, NULL);\n}", "target": 0}
{"code": "size_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPHeaders& trailers) {\n  VLOG(4) << \"generating TRAILERS for stream=\" << stream;\n  std::vector<compress::Header> allHeaders;\n  CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n  HTTPHeaderSize size;\n  auto out = encodeHeaders(trailers, allHeaders, &size);\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto remainingFrameSize = maxFrameSize;\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n    bool endHeaders = queue.chainLength() == 0;\n    generateHeaderCallbackWrapper(stream,\n                                  http2::FrameType::HEADERS,\n                                  http2::writeHeaders(writeBuf,\n                                                      std::move(chunk),\n                                                      stream,\n                                                      pri,\n                                                      http2::kNoPadding,\n                                                      true ,\n                                                      endHeaders));\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n  return size.compressed;\n}", "target": 0}
{"code": "static int snd_timer_s_stop(struct snd_timer * timer)\n{\n\tstruct snd_timer_system_private *priv;\n\tunsigned long jiff;\n\tpriv = (struct snd_timer_system_private *) timer->private_data;\n\tdel_timer(&priv->tlist);\n\tjiff = jiffies;\n\tif (time_before(jiff, priv->last_expires))\n\t\ttimer->sticks = priv->last_expires - jiff;\n\telse\n\t\ttimer->sticks = 1;\n\tpriv->correction = 0;\n\treturn 0;\n}", "target": 0}
{"code": "static int smb2_resp_buf_len(struct ksmbd_work *work, unsigned short hdr2_len)\n{\n\tint free_len;\n\tfree_len = (int)(work->response_sz -\n\t\t(get_rfc1002_len(work->response_buf) + 4)) - hdr2_len;\n\treturn free_len;\n}", "target": 0}
{"code": "bool ResourceHandle::ParseFromString(const string& s) {\n  ResourceHandleProto proto;\n  const bool status = proto.ParseFromString(s);\n  if (status) FromProto(proto);\n  return status;\n}", "target": 1}
{"code": "std::unique_ptr<cql_server::response> cql_server::connection::make_supported(int16_t stream, const tracing::trace_state_ptr& tr_state) const\n{\n    std::multimap<sstring, sstring> opts;\n    opts.insert({\"CQL_VERSION\", cql3::query_processor::CQL_VERSION});\n    opts.insert({\"COMPRESSION\", \"lz4\"});\n    opts.insert({\"COMPRESSION\", \"snappy\"});\n    if (_server._config.allow_shard_aware_drivers) {\n        opts.insert({\"SCYLLA_SHARD\", format(\"{:d}\", this_shard_id())});\n        opts.insert({\"SCYLLA_NR_SHARDS\", format(\"{:d}\", smp::count)});\n        opts.insert({\"SCYLLA_SHARDING_ALGORITHM\", dht::cpu_sharding_algorithm_name()});\n        if (_server._config.shard_aware_transport_port) {\n            opts.insert({\"SCYLLA_SHARD_AWARE_PORT\", format(\"{:d}\", *_server._config.shard_aware_transport_port)});\n        }\n        if (_server._config.shard_aware_transport_port_ssl) {\n            opts.insert({\"SCYLLA_SHARD_AWARE_PORT_SSL\", format(\"{:d}\", *_server._config.shard_aware_transport_port_ssl)});\n        }\n        opts.insert({\"SCYLLA_SHARDING_IGNORE_MSB\", format(\"{:d}\", _server._config.sharding_ignore_msb)});\n        opts.insert({\"SCYLLA_PARTITIONER\", _server._config.partitioner_name});\n    }\n    for (cql_protocol_extension ext : supported_cql_protocol_extensions()) {\n        const sstring ext_key_name = protocol_extension_name(ext);\n        std::vector<sstring> params = additional_options_for_proto_ext(ext);\n        if (params.empty()) {\n            opts.emplace(ext_key_name, \"\");\n        } else {\n            for (sstring val : params) {\n                opts.emplace(ext_key_name, std::move(val));\n            }\n        }\n    }\n    auto response = std::make_unique<cql_server::response>(stream, cql_binary_opcode::SUPPORTED, tr_state);\n    response->write_string_multimap(std::move(opts));\n    return response;\n}", "target": 0}
{"code": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\tif (!ss_initialized) {\n\t\tint i;\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\tif (force) {\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}", "target": 0}
{"code": "int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n\t\t     int flen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\tif (udf_build_ustr_exact(unifilename, sname, flen))\n\t\tgoto out2;\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}", "target": 1}
{"code": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}", "target": 1}
{"code": "static Eina_Bool _ewk_view_smart_key_up(Ewk_View_Smart_Data* smartData, const Evas_Event_Key_Up* upEvent)\n{\n    Evas_Object* frame = ewk_view_frame_focused_get(smartData->self);\n    if (!frame)\n        frame = smartData->main_frame;\n    return ewk_frame_feed_key_up(frame, upEvent);\n}", "target": 0}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_READONLY) &&\n\t    !(mnt_flags & MNT_READONLY)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NODEV) &&\n\t    !(mnt_flags & MNT_NODEV)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOSUID) &&\n\t    !(mnt_flags & MNT_NOSUID)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_NOEXEC) &&\n\t    !(mnt_flags & MNT_NOEXEC)) {\n\t\treturn -EPERM;\n\t}\n\tif ((mnt->mnt.mnt_flags & MNT_LOCK_ATIME) &&\n\t    ((mnt->mnt.mnt_flags & MNT_ATIME_MASK) != (mnt_flags & MNT_ATIME_MASK))) {\n\t\treturn -EPERM;\n\t}\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 0}
{"code": "Item_func_ne::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                             uint *and_level, table_map usable_tables,\n                             SARGABLE_PARAM **sargables)\n{\n  if (!(used_tables() & OUTER_REF_TABLE_BIT))\n  {\n    if (is_local_field(args[0]) && !is_local_field(args[1]))\n      add_key_equal_fields(join, key_fields, *and_level, this,\n                           (Item_field*) (args[0]->real_item()), false,\n                           &args[1], 1, usable_tables, sargables);\n    if (is_local_field(args[1]) && !is_local_field(args[0]))\n      add_key_equal_fields(join, key_fields, *and_level, this,\n                           (Item_field*) (args[1]->real_item()), false,\n                           &args[0], 1, usable_tables, sargables);\n  }\n}", "target": 0}
{"code": "static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n\t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n\t\tmemcpy(command_info->result_buffer, &data[1],\n\t\t\t\t\t\turb->actual_length - 1);\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}", "target": 1}
{"code": "static void listdir(unsigned int depth, int f, void * const tls_fd,\n                    const char *name)\n{\n    PureFileInfo *dir;\n    char *names;\n    PureFileInfo *s;\n    PureFileInfo *r;\n    int d;\n    if (depth >= max_ls_depth || matches >= max_ls_files) {\n        return;\n    }\n    if ((dir = sreaddir(&names)) == NULL) {\n        addreply(226, MSG_CANT_READ_FILE, name);\n        return;\n    }\n    s = dir;\n    while (s->name_offset != (size_t) -1) {\n        d = 0;\n        if (FI_NAME(s)[0] != '.') {\n            d = listfile(s, NULL);\n        } else if (opt_a) {\n            if (FI_NAME(s)[1] == 0 ||\n                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {\n                listfile(s, NULL);\n            } else {\n                d = listfile(s, NULL);\n            }\n        }\n        if (!d) {\n            s->name_offset = (size_t) -1;\n        }\n        s++;\n    }\n    outputfiles(f, tls_fd);\n    r = dir;\n    while (opt_R && r != s) {\n        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {\n            char *alloca_subdir;\n            const size_t sizeof_subdir = PATH_MAX + 1U;\n            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {\n                goto toomany;\n            }\n            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",\n                                 name, FI_NAME(r)), sizeof_subdir)) {\n                goto nolist;\n            }\n            wrstr(f, tls_fd, \"\\r\\n\\r\\n\");\n            wrstr(f, tls_fd, alloca_subdir);\n            wrstr(f, tls_fd, \":\\r\\n\\r\\n\");\n            listdir(depth + 1U, f, tls_fd, alloca_subdir);\n            nolist:\n            ALLOCA_FREE(alloca_subdir);\n            if (matches >= max_ls_files) {\n                goto toomany;\n            }\n            if (chdir(\"..\")) {    \n                if (chdir(wd) || chdir(name)) {    \n                    die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                }\n            }\n        }\n        r++;\n    }\n    toomany:\n    free(names);\n    free(dir);\n    names = NULL;\n}", "target": 1}
{"code": "  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size =\n        prefix_size + internal::to_unsigned(spec.precision());\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    CharPtr result = prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size);\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    return result;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::uninitialized_fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::uninitialized_fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}", "target": 1}
{"code": "void HierarchicalBitmapRequester::PrepareForDecoding(void)\n{\n#if ACCUSOFT_CODE\n  UBYTE i;\n  BuildCommon();\n  if (m_ppDecodingMCU == NULL) {\n    m_ppDecodingMCU = (struct Line **)m_pEnviron->AllocMem(sizeof(struct Line *) * m_ucCount*8);\n    memset(m_ppDecodingMCU,0,sizeof(struct Line *) * m_ucCount * 8);\n  }\n  if (m_ppUpsampler == NULL) {\n    m_ppUpsampler = (class UpsamplerBase **)m_pEnviron->AllocMem(sizeof(class UpsamplerBase *) * m_ucCount);\n    memset(m_ppUpsampler,0,sizeof(class Upsampler *) * m_ucCount);\n    for(i = 0;i < m_ucCount;i++) {\n      class Component *comp = m_pFrame->ComponentOf(i);\n      UBYTE sx = comp->SubXOf();\n      UBYTE sy = comp->SubYOf();\n      if (m_pLargestScale) {\n        class Frame *frame = m_pLargestScale->FrameOf();\n        while(frame) {\n          if (frame->ComponentOf(i)->SubXOf() != sx || frame->ComponentOf(i)->SubYOf() != sy)\n            JPG_THROW(MALFORMED_STREAM,\"HierarchicalBitmapRequester::PrepareForDecoding\",\n                      \"component subsampling is inconsistent across hierarchical levels\");\n          frame = frame->NextOf();\n        }\n      }\n      if (sx > 1 || sy > 1) {\n        m_ppUpsampler[i] = UpsamplerBase::CreateUpsampler(m_pEnviron,sx,sy,\n                                                          m_ulPixelWidth,m_ulPixelHeight,\n                                                          m_pFrame->TablesOf()->isChromaCentered());\n        m_bSubsampling   = true;\n      }\n    }\n  }\n  if (m_pLargestScale)\n    m_pLargestScale->PrepareForDecoding();\n#endif\n}", "target": 0}
{"code": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "int mnt_optstr_get_uid(const char *optstr, const char *name, uid_t *uid)\n{\n\tchar *value = NULL;\n\tsize_t valsz = 0;\n\tchar buf[sizeof(stringify_value(UINT64_MAX))];\n\tint rc;\n\tuint64_t num;\n\tassert(optstr);\n\tassert(name);\n\tassert(uid);\n\trc = mnt_optstr_get_option(optstr, name, &value, &valsz);\n\tif (rc != 0)\n\t\tgoto fail;\n\tif (valsz > sizeof(buf) - 1) {\n\t\trc = -ERANGE;\n\t\tgoto fail;\n\t}\n\tmem2strcpy(buf, value, valsz, sizeof(buf));\n\trc = ul_strtou64(buf, &num, 10);\n\tif (rc != 0)\n\t\tgoto fail;\n\tif (num > ULONG_MAX || (uid_t) num != num) {\n\t\trc = -ERANGE;\n\t\tgoto fail;\n\t}\n\t*uid = (uid_t) num;\n\treturn 0;\nfail:\n\tDBG(UTILS, ul_debug(\"failed to convert '%s'= to number [rc=%d]\", name, rc));\n\treturn rc;\n}", "target": 0}
{"code": "static void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n\tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; \n}", "target": 0}
{"code": "void kvm_release_pfn_clean(kvm_pfn_t pfn)\n{\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn))\n\t\tput_page(pfn_to_page(pfn));\n}", "target": 0}
{"code": "static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n\t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n\t\trdesc[11] = rdesc[16] = 0xff;\n\t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg;\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 1}
{"code": "spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}", "target": 1}
{"code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  const int input_channels = input->dims->data[3];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = output_channels;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 0}
{"code": "static int lsm_set_label_at(int lsm_labelfd, int on_exec, char *lsm_label)\n{\n\tint fret = -1;\n\tconst char* name;\n\tchar *command = NULL;\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (strcmp(name, \"AppArmor\") == 0) {\n\t\tint size;\n\t\tcommand = malloc(strlen(lsm_label) + strlen(\"changeprofile \") + 1);\n\t\tif (!command) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tsize = sprintf(command, \"changeprofile %s\", lsm_label);\n\t\tif (size < 0) {\n\t\t\tSYSERROR(\"Failed to write apparmor profile\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (write(lsm_labelfd, command, size + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label: %s.\", command);\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", command);\n\t} else if (strcmp(name, \"SELinux\") == 0) {\n\t\tif (write(lsm_labelfd, lsm_label, strlen(lsm_label) + 1) < 0) {\n\t\t\tSYSERROR(\"Unable to set LSM label\");\n\t\t\tgoto out;\n\t\t}\n\t\tINFO(\"Set LSM label to: %s.\", lsm_label);\n\t} else {\n\t\tERROR(\"Unable to restore label for unknown LSM: %s\", name);\n\t\tgoto out;\n\t}\n\tfret = 0;\nout:\n\tfree(command);\n\tif (lsm_labelfd != -1)\n\t\tclose(lsm_labelfd);\n\treturn fret;\n}", "target": 0}
{"code": "DLLIMPORT int cfg_parse(cfg_t *cfg, const char *filename)\n{\n\tint ret;\n\tchar *fn;\n\tFILE *fp;\n\tif (!cfg || !filename) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FILE_ERROR;\n\t}\n\tif (cfg->path)\n\t\tfn = cfg_searchpath(cfg->path, filename);\n\telse\n\t\tfn = cfg_tilde_expand(filename);\n\tif (!fn)\n\t\treturn CFG_FILE_ERROR;\n\tfree(cfg->filename);\n\tcfg->filename = fn;\n\tfp = fopen(cfg->filename, \"r\");\n\tif (!fp)\n\t\treturn CFG_FILE_ERROR;\n\tret = cfg_parse_fp(cfg, fp);\n\tfclose(fp);\n\treturn ret;\n}", "target": 0}
{"code": "static inline bool _arq_scheduled(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    evtimer_event_t *ptr = _arq_timer.events;\n    evtimer_event_t *event = &fbuf->sfr.arq_timeout_event.event;\n    while (ptr) {\n        if (ptr == event) {\n            return true;\n        }\n        ptr = ptr->next;\n    }\n    return false;\n}", "target": 0}
{"code": "void cipso_v4_sock_delattr(struct sock *sk)\n{\n\tint hdr_delta;\n\tstruct ip_options *opt;\n\tstruct inet_sock *sk_inet;\n\tsk_inet = inet_sk(sk);\n\topt = sk_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\thdr_delta = cipso_v4_delopt(&sk_inet->opt);\n\tif (sk_inet->is_icsk && hdr_delta > 0) {\n\t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n\t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}", "target": 1}
{"code": "  void AddBatchOffsets(Tensor* indices, const Tensor& params) {\n    int64_t batch_size = 1;  \n    for (int idx = 0; idx < batch_dims_; ++idx) {\n      batch_size *= params.dim_size(idx);\n    }\n    auto indices_flat = indices->flat<Index>();\n    int64_t const index_inner_size = indices->NumElements() / batch_size;\n    int64_t const batch_offset = params.dim_size(batch_dims_);\n    for (int64_t batch_idx = 0, dest_idx = 0; batch_idx < batch_size;\n         ++batch_idx) {\n      for (int64_t idx = 0; idx < index_inner_size; ++idx) {\n        indices_flat(dest_idx++) += batch_offset * batch_idx;\n      }\n    }\n  }", "target": 1}
{"code": "crm_send_tls(gnutls_session * session, const char *buf, size_t len)\n{\n    const char *unsent = buf;\n    int rc = 0;\n    int total_send;\n    if (buf == NULL) {\n        return -1;\n    }\n    total_send = len;\n    crm_trace(\"Message size: %d\", len);\n    while (TRUE) {\n        rc = gnutls_record_send(*session, unsent, len);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_debug(\"Retry\");\n        } else if (rc < 0) {\n            crm_err(\"Connection terminated rc = %d\", rc);\n            break;\n        } else if (rc < len) {\n            crm_debug(\"Only sent %d of %d bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n        } else {\n            crm_debug(\"Sent %d bytes\", rc);\n            break;\n        }\n    }\n    return rc < 0 ? rc : total_send;\n}", "target": 0}
{"code": "void RtmpProtocol::handle_C1_simple(const char *data){\n    char handshake_head = HANDSHAKE_PLAINTEXT;\n    onSendRawData(obtainBuffer(&handshake_head, 1));\n    RtmpHandshake s1(0);\n    onSendRawData(obtainBuffer((char *) &s1, C1_HANDSHARK_SIZE));\n    onSendRawData(obtainBuffer(data + 1, C1_HANDSHARK_SIZE));\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_C2(data, len);\n    };\n}", "target": 0}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\t*sockp = sock;\n\treturn err;\n}", "target": 0}
{"code": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\terr = notify_change(upperdentry, attr, NULL);\n\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t} else {\n\t\terr = ovl_copy_up_last(dentry, attr, false);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}", "target": 1}
{"code": "PHP_FUNCTION(number_format)\n{\n\tdouble num;\n\tlong dec = 0;\n\tchar *thousand_sep = NULL, *dec_point = NULL;\n\tchar thousand_sep_chr = ',', dec_point_chr = '.';\n\tint thousand_sep_len = 0, dec_point_len = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d|ls!s!\", &num, &dec, &dec_point, &dec_point_len, &thousand_sep, &thousand_sep_len) == FAILURE) {\n\t\treturn;\n\t}\n\tswitch(ZEND_NUM_ARGS()) {\n\tcase 1:\n\t\tRETURN_STRING(_php_math_number_format(num, 0, dec_point_chr, thousand_sep_chr), 0);\n\t\tbreak;\n\tcase 2:\n\t\tRETURN_STRING(_php_math_number_format(num, dec, dec_point_chr, thousand_sep_chr), 0);\n\t\tbreak;\n\tcase 4:\n\t\tif (dec_point == NULL) {\n\t\t\tdec_point = &dec_point_chr;\n\t\t\tdec_point_len = 1;\n\t\t}\n\t\tif (thousand_sep == NULL) {\n\t\t\tthousand_sep = &thousand_sep_chr;\n\t\t\tthousand_sep_len = 1;\n\t\t}\n\t\tZ_TYPE_P(return_value) = IS_STRING;\n\t\tZ_STRVAL_P(return_value) = _php_math_number_format_ex_len(num, dec,\n\t\t\t\tdec_point, dec_point_len, thousand_sep, thousand_sep_len,\n\t\t\t\t&Z_STRLEN_P(return_value));\n\t\tbreak;\n\tdefault:\n\t\tWRONG_PARAM_COUNT;\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "int infra_wait_limit_allowed(struct infra_cache* infra, struct comm_reply* rep,\n\tint cookie_valid, struct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn 1;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 0);\n\tif(entry) {\n\t\trbtree_type* tree;\n\t\tstruct wait_limit_netblock_info* w;\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\tint mesh_wait = d->mesh_wait;\n\t\tlock_rw_unlock(&entry->lock);\n\t\tif(cookie_valid)\n\t\t\ttree = &infra->wait_limits_cookie_netblock;\n\t\telse\ttree = &infra->wait_limits_netblock;\n\t\tw = (struct wait_limit_netblock_info*)addr_tree_lookup(tree,\n\t\t\t&rep->client_addr, rep->client_addrlen);\n\t\tif(w) {\n\t\t\tif(w->limit != -1 && mesh_wait > w->limit)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif(mesh_wait > (cookie_valid?cfg->wait_limit_cookie:\n\t\t\t\tcfg->wait_limit))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "finish_stop(int stop_count)\n{\n\tif (tracehook_notify_jctl(stop_count == 0, CLD_STOPPED)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, CLD_STOPPED);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tdo {\n\t\tschedule();\n\t} while (try_to_freeze());\n\tcurrent->exit_code = 0;\n}", "target": 0}
{"code": "void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)\n{\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ti, *ts;\n\tif (timer->card && timer->card->shutdown)\n\t\treturn;\n\tif (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n\t\treturn;\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n\t\t       event > SNDRV_TIMER_EVENT_MRESUME))\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (event == SNDRV_TIMER_EVENT_MSTART ||\n\t    event == SNDRV_TIMER_EVENT_MCONTINUE ||\n\t    event == SNDRV_TIMER_EVENT_MRESUME) {\n\t\tif (timer->hw.c_resolution)\n\t\t\tresolution = timer->hw.c_resolution(timer);\n\t\telse\n\t\t\tresolution = timer->hw.resolution;\n\t}\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->ccallback)\n\t\t\tti->ccallback(ti, event, tstamp, resolution);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\t\tif (ts->ccallback)\n\t\t\t\tts->ccallback(ts, event, tstamp, resolution);\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}", "target": 0}
{"code": "resolve_iffeature(struct lys_iffeature *expr)\n{\n    int index_e = 0, index_f = 0;\n    if (expr->expr) {\n        return resolve_iffeature_recursive(expr, &index_e, &index_f);\n    }\n    return 0;\n}", "target": 1}
{"code": "void SecurityManager::cancel_init()\n{\n    SecurityException exception;\n    if (local_participant_crypto_handle_)\n    {\n        crypto_plugin_->cryptokeyfactory()->unregister_participant(local_participant_crypto_handle_, exception);\n    }\n    if (crypto_plugin_ != nullptr)\n    {\n        delete crypto_plugin_;\n        crypto_plugin_ = nullptr;\n    }\n    if (access_plugin_ != nullptr)\n    {\n        delete access_plugin_;\n        access_plugin_ = nullptr;\n    }\n    delete authentication_plugin_;\n    authentication_plugin_ = nullptr;\n    disable_security_manager();\n}", "target": 1}
{"code": "static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tvgacon_scrollback_update(c, t, lines);\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}", "target": 1}
{"code": "static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv *hv_vcpu = to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\tif (unlikely(!host && hv_vcpu->enforce_cpuid && new_config.direct_mode &&\n\t\t     !(hv_vcpu->cpuid_cache.features_edx &\n\t\t       HV_STIMER_DIRECT_MODE_AVAILABLE)))\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_config(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\t\t\tlen = skb->len - offset;\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n\t\tsk_eat_skb(sk, skb, 0);\n\t\tif (!desc->count)\n\t\t\tbreak;\n\t\ttp->copied_seq = seq;\n\t}\n\ttp->copied_seq = seq;\n\ttcp_rcv_space_adjust(sk);\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}", "target": 0}
{"code": "static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\tatomic_long_inc(&unix_nr_socks);\n\tif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\n\t\tgoto out;\n\tsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\tsock_init_data(sock, sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= net->unx.sysctl_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_long_set(&u->inflight, 0);\n\tINIT_LIST_HEAD(&u->link);\n\tmutex_init(&u->readlock); \n\tinit_waitqueue_head(&u->peer_wait);\n\tinit_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);\n\tunix_insert_socket(unix_sockets_unbound(sk), sk);\nout:\n\tif (sk == NULL)\n\t\tatomic_long_dec(&unix_nr_socks);\n\telse {\n\t\tlocal_bh_disable();\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tlocal_bh_enable();\n\t}\n\treturn sk;\n}", "target": 0}
{"code": "static int DefragBsdPeose173Ipv6Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "static int skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\tif (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {\n\t\tcrypto_skcipher_set_flags(tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\n\t\treturn -EINVAL;\n\t}\n\tif ((unsigned long)key & alignmask)\n\t\treturn skcipher_setkey_unaligned(tfm, key, keylen);\n\treturn cipher->setkey(tfm, key, keylen);\n}", "target": 0}
{"code": "bool SSecurityTLS::processMsg(SConnection *sc)\n{\n  rdr::InStream* is = sc->getInStream();\n  rdr::OutStream* os = sc->getOutStream();\n  vlog.debug(\"Process security message (session %p)\", session);\n  if (!session) {\n    initGlobal();\n    if (gnutls_init(&session, GNUTLS_SERVER) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n    try {\n      setParams(session);\n    }\n    catch(...) {\n      os->writeU8(0);\n      throw;\n    }\n    os->writeU8(1);\n    os->flush();\n  }\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n    if (!gnutls_error_is_fatal(err)) {\n      vlog.debug(\"Deferring completion of TLS handshake: %s\", gnutls_strerror(err));\n      return false;\n    }\n    vlog.error(\"TLS Handshake failed: %s\", gnutls_strerror (err));\n    shutdown();\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n  vlog.debug(\"Handshake completed\");\n  sc->setStreams(fis = tlsis, fos = tlsos);\n  return true;\n}", "target": 1}
{"code": "test_js (void) {\n    GString *result = g_string_new(\"\");\n    parse_cmd_line(\"js ('x' + 345).toUpperCase()\", result);\n    g_assert_cmpstr(\"X345\", ==, result->str);\n    uzbl.net.useragent = \"Test useragent\";\n    parse_cmd_line(\"js Uzbl.run('print @useragent').toUpperCase();\", result);\n    g_assert_cmpstr(\"TEST USERAGENT\", ==, result->str);\n    g_string_free(result, TRUE);\n}", "target": 1}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "snmp_process_data(void)\n{\n  static unsigned char packet[SNMP_MAX_PACKET_SIZE];\n  unsigned char *packet_end;\n  static uint32_t packet_len;\n  packet_end = packet + sizeof(packet) - 1;\n  packet_len = 0;\n  LOG_DBG(\"receiving UDP datagram from [\");\n  LOG_DBG_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_DBG_(\"]:%u\", uip_ntohs(UIP_UDP_BUF->srcport));\n  LOG_DBG_(\" Length: %u\\n\", uip_datalen());\n  if((packet_end = snmp_engine(uip_appdata, uip_datalen(), packet_end, &packet_len)) == NULL) {\n    LOG_DBG(\"Error while handling the request\\n\");\n  } else {\n    LOG_DBG(\"Sending response\\n\");\n    uip_udp_packet_sendto(snmp_udp_conn, packet_end, packet_len, &UIP_IP_BUF->srcipaddr, UIP_UDP_BUF->srcport);\n  }\n}", "target": 1}
{"code": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "ext2_xattr_put_super(struct super_block *sb)\n{\n}", "target": 1}
{"code": "bool f_libxml_disable_entity_loader(bool disable ) {\n  xmlParserInputBufferCreateFilenameFunc old;\n  if (disable) {\n    old = xmlParserInputBufferCreateFilenameDefault(hphp_libxml_input_buffer_noload);\n  } else {\n    old = xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }\n  return (old == hphp_libxml_input_buffer_noload);\n}", "target": 1}
{"code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n    OP_REQUIRES(context, batch_dim_ >= 0,\n                errors::InvalidArgument(\"Invalid batch_dim \", batch_dim_));\n    OP_REQUIRES(context, seq_dim_ >= 0,\n                errors::InvalidArgument(\"Invalid seq_dim \", seq_dim_));\n  }", "target": 0}
{"code": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n\t{\n\t  return U2FH_MEMORY_ERROR;\n\t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "target": 1}
{"code": "NCR_CheckAccessRestriction(IPAddr *ip_addr)\n{\n  return ADF_IsAllowed(access_auth_table, ip_addr);\n}", "target": 0}
{"code": "gss_process_context_token (minor_status,\n                           context_handle,\n                           token_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    if (token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n    if (GSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_process_context_token) {\n\t    status = mech->gss_process_context_token(\n\t\t\t\t\t\t    minor_status,\n\t\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t\t    token_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\tif (!handle)\n\t\treturn NULL;\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\treturn pointer;\n}", "target": 1}
{"code": "__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\tload_sp0(tss, next);\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\tload_TLS(next, cpu);\n\tarch_end_context_switch(next_p);\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\tswitch_fpu_finish(next_p, fpu);\n\tprev->usersp = this_cpu_read(old_rsp);\n\tthis_cpu_write(old_rsp, next->usersp);\n\tthis_cpu_write(current_task, next_p);\n\ttask_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);\n\tthis_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);\n\tthis_cpu_write(kernel_stack,\n\t\t  (unsigned long)task_stack_page(next_p) +\n\t\t  THREAD_SIZE - KERNEL_STACK_OFFSET);\n\tif (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||\n\t\t     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))\n\t\t__switch_to_xtra(prev_p, next_p, tss);\n\treturn prev_p;\n}", "target": 1}
{"code": "router_get_hashes_impl(const char *s, size_t s_len, digests_t *digests,\n                       const char *start_str,\n                       const char *end_str, char end_c)\n{\n  const char *start=NULL, *end=NULL;\n  if (router_get_hash_impl_helper(s,s_len,start_str,end_str,end_c,\n                                  &start,&end)<0)\n    return -1;\n  if (crypto_digest_all(digests, start, end-start)) {\n    log_warn(LD_BUG,\"couldn't compute digests\");\n    return -1;\n  }\n  return 0;\n}", "target": 0}
{"code": "archive_reopen_if_needed (ComicsDocument  *comics_document,\n\t\t\t  const char      *page_wanted,\n\t\t\t  GError         **error)\n{\n\tconst char *current_page;\n\tguint current_page_idx, page_wanted_idx;\n\tif (ev_archive_at_entry (comics_document->archive)) {\n\t\tcurrent_page = ev_archive_get_entry_pathname (comics_document->archive);\n\t\tif (current_page) {\n\t\t\tcurrent_page_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, current_page));\n\t\t\tpage_wanted_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, page_wanted));\n\t\t\tif (current_page_idx != 0 &&\n\t\t\t    page_wanted_idx != 0 &&\n\t\t\t    page_wanted_idx > current_page_idx)\n\t\t\t\treturn TRUE;\n\t\t}\n\t\tev_archive_reset (comics_document->archive);\n\t}\nreturn ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error);\n}", "target": 0}
{"code": "static inline struct blk_align_bitmap *get_bm(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t\t      struct blk_mq_ctx *ctx)\n{\n\treturn &hctx->ctx_map.map[ctx->index_hw / hctx->ctx_map.bits_per_word];\n}", "target": 0}
{"code": "  const hbc::DebugOffsets *getDebugOffsets(uint32_t) const override {\n    llvm_unreachable(\"Accessing debug offsets from a lazy module\");\n  }", "target": 1}
{"code": "fs::path TranslatePath(const std::string& utf8_url_path) {\n#if (defined(_WIN32) || defined(_WIN64))\n  std::wstring url_path = Utf8To16(utf8_url_path);\n  std::vector<std::wstring> words;\n  boost::split(words, url_path, boost::is_any_of(L\"/\"),\n               boost::token_compress_on);\n#else\n  std::vector<std::string> words;\n  boost::split(words, utf8_url_path, boost::is_any_of(\"/\"),\n               boost::token_compress_on);\n#endif  \n  fs::path path;\n  for (auto& word : words) {\n#if (defined(_WIN32) || defined(_WIN64))\n    if (word == L\".\" || word == L\"..\") {\n#else\n    if (word == \".\" || word == \"..\") {\n#endif\n      continue;\n    }\n    fs::path p{ word };\n    if (!p.parent_path().empty()) {\n      continue;\n    }\n    path /= p;\n  }\n  return path;\n}\n}  ", "target": 0}
{"code": "unsigned long OPENSSL_LH_get_down_load(const OPENSSL_LHASH *lh)\n{\n    return lh->down_load;\n}", "target": 0}
{"code": "hash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\treturn hash;\n}", "target": 1}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tif(charsetMatch == NULL) {\n\t\tinfo.GetReturnValue().Set(Nan::Null());\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "pci_msix_table_init(struct pci_vdev *dev, int table_entries)\n{\n\tint i, table_size;\n\tassert(table_entries > 0);\n\tassert(table_entries <= MAX_MSIX_TABLE_ENTRIES);\n\ttable_size = table_entries * MSIX_TABLE_ENTRY_SIZE;\n\tdev->msix.table = calloc(1, table_size);\n\tassert(dev->msix.table != NULL);\n\tfor (i = 0; i < table_entries; i++)\n\t\tdev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK;\n}", "target": 1}
{"code": "static int db_dict_iter_lookup_key_values(struct db_dict_value_iter *iter)\n{\n\tstruct db_dict_iter_key *key;\n\tstring_t *path;\n\tconst char *error;\n\tint ret;\n\tarray_sort(&iter->keys, db_dict_iter_key_cmp);\n\tpath = t_str_new(128);\n\tstr_append(path, DICT_PATH_SHARED);\n\tarray_foreach_modifiable(&iter->keys, key) {\n\t\tif (!key->used)\n\t\t\tcontinue;\n\t\tstr_truncate(path, strlen(DICT_PATH_SHARED));\n\t\tret = var_expand(path, key->key->key, iter->var_expand_table, &error);\n\t\tif (ret <= 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to expand key %s: %s\", key->key->key, error);\n\t\t\treturn -1;\n\t\t}\n\t\tret = dict_lookup(iter->conn->dict, iter->pool,\n\t\t\t\t  str_c(path), &key->value, &error);\n\t\tif (ret > 0) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\t       \"Lookup: %s = %s\", str_c(path),\n\t\t\t\t\t       key->value);\n\t\t} else if (ret < 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to lookup key %s: %s\", str_c(path), error);\n\t\t\treturn -1;\n\t\t} else if (key->key->default_value != NULL) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Lookup: %s not found, using default value %s\",\n\t\t\t\tstr_c(path), key->key->default_value);\n\t\t\tkey->value = key->key->default_value;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "int HttpFileImpl::save(const std::string &path) const\n{\n    assert(!path.empty());\n    if (fileName_.empty())\n        return -1;\n    filesystem::path fsPath(utils::toNativePath(path));\n    if (!fsPath.is_absolute() &&\n        (!fsPath.has_parent_path() ||\n         (fsPath.begin()->string() != \".\" && fsPath.begin()->string() != \"..\")))\n    {\n        filesystem::path fsUploadPath(utils::toNativePath(\n            HttpAppFrameworkImpl::instance().getUploadPath()));\n        fsPath = fsUploadPath / fsPath;\n    }\n    filesystem::path fsFileName(utils::toNativePath(fileName_));\n    if (!filesystem::exists(fsPath))\n    {\n        LOG_TRACE << \"create path:\" << fsPath;\n        drogon::error_code err;\n        filesystem::create_directories(fsPath, err);\n        if (err)\n        {\n            LOG_SYSERR;\n            return -1;\n        }\n    }\n    return saveTo(fsPath / fsFileName);\n}", "target": 1}
{"code": "*/\nMYSQL_PLUGIN_EXPORT\nchar *mysql_authentication_dialog_ask(MYSQL *mysql, int type,\n                                      const char *prompt,\n                                      char *buf, int buf_len)\n{\n  char *s=buf;\n  fputs(prompt, stdout);\n  fputs(\" \", stdout);\n  if (!fgets(buf, buf_len-1, stdin))\n    buf[0]= 0;\n  else if (buf[0] && (s= strend(buf))[-1] == '\\n')\n    s[-1]= 0;\n  for (s= buf; *s; s++)\n    fputc(type == 2 ? '*' : *s, stdout);\n  fputc('\\n', stdout);", "target": 0}
{"code": "alt_merge_opt_map_info(OnigEncoding enc, OptMapInfo* to, OptMapInfo* add)\n{\n  int i, val;\n  if (to->value == 0) return ;\n  if (add->value == 0 || to->mmd.max < add->mmd.min) {\n    clear_opt_map_info(to);\n    return ;\n  }\n  alt_merge_mml(&to->mmd, &add->mmd);\n  val = 0;\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) {\n    if (add->map[i])\n      to->map[i] = 1;\n    if (to->map[i])\n      val += map_position_value(enc, i);\n  }\n  to->value = val;\n  alt_merge_opt_anc_info(&to->anc, &add->anc);\n}", "target": 0}
{"code": "static void draw_block_rectangle(uint8_t *buf, int sx, int sy, int w, int h, ptrdiff_t stride, int color)\n{\n    for (int x = sx; x < sx + w; x++)\n        buf[x] = color;\n    for (int y = sy; y < sy + h; y++) {\n        buf[sx] = color;\n        buf[sx + w - 1] = color;\n        buf += stride;\n    }\n    for (int x = sx; x < sx + w; x++)\n        buf[x] = color;\n}", "target": 1}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}", "target": 1}
{"code": "gss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n        return(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "static void kvm_vcpu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_dirty_ring_free(&vcpu->dirty_ring);\n\tkvm_arch_vcpu_destroy(vcpu);\n\tput_pid(rcu_dereference_protected(vcpu->pid, 1));\n\tfree_page((unsigned long)vcpu->run);\n\tkmem_cache_free(kvm_vcpu_cache, vcpu);\n}", "target": 1}
{"code": "int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang)\n{\n    jsi_Lexer *l = ps->lexer;\n    jsi_PstateClear(ps);\n    l->ltype = LT_FILE;\n    l->d.fp = fp;\n    Jsi_Rewind(ps->interp, fp);\n    if (skipbang) {\n        char buf[1000];\n        if (Jsi_Gets(ps->interp, fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) {\n            Jsi_Rewind(ps->interp, fp);\n        }\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "cdf_unpack_summary_info(const cdf_stream_t *sst, const cdf_header_t *h,\n    cdf_summary_info_header_t *ssi, cdf_property_info_t **info, size_t *count)\n{\n\tsize_t i, maxcount;\n\tconst cdf_summary_info_header_t *si =\n\t    CAST(const cdf_summary_info_header_t *, sst->sst_tab);\n\tconst cdf_section_declaration_t *sd =\n\t    CAST(const cdf_section_declaration_t *, (const void *)\n\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET));\n\tif (cdf_check_stream_offset(sst, h, si, sizeof(*si), __LINE__) == -1 ||\n\t    cdf_check_stream_offset(sst, h, sd, sizeof(*sd), __LINE__) == -1)\n\t\treturn -1;\n\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n\tssi->si_os = CDF_TOLE2(si->si_os);\n\tssi->si_class = si->si_class;\n\tcdf_swap_class(&ssi->si_class);\n\tssi->si_count = CDF_TOLE2(si->si_count);\n\t*count = 0;\n\tmaxcount = 0;\n\t*info = NULL;\n\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n\t\tif (i >= CDF_LOOP_LIMIT) {\n\t\t\tDPRINTF((\"Unpack summary info loop limit\"));\n\t\t\terrno = EFTYPE;\n\t\t\treturn -1;\n\t\t}\n\t\tif (cdf_read_property_info(sst, h, CDF_TOLE4(sd->sd_offset),\n\t\t    info, count, &maxcount) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}", "target": 0}
{"code": "static bool check_underflow(const struct ipt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->ip))\n\t\treturn false;\n\tt = ipt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\tlock_sock(sk);\n\twhile (iov_iter_count(&msg->msg_iter)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\t\tused = ctx->used;\n\t\tif (!used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\tused = min_t(unsigned long, used, iov_iter_count(&msg->msg_iter));\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t     ctx->iv);\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\terr = 0;\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\treturn copied ?: err;\n}", "target": 1}
{"code": "static void reset_active(struct i915_request *rq,\n\t\t\t struct intel_engine_cs *engine)\n{\n\tstruct intel_context * const ce = rq->hw_context;\n\tu32 head;\n\tGEM_TRACE(\"%s(%s): { rq=%llx:%lld }\\n\",\n\t\t  __func__, engine->name, rq->fence.context, rq->fence.seqno);\n\tif (i915_request_completed(rq))\n\t\thead = rq->tail;\n\telse\n\t\thead = active_request(ce->timeline, rq)->head;\n\tce->ring->head = intel_ring_wrap(ce->ring, head);\n\tintel_ring_update_space(ce->ring);\n\trestore_default_state(ce, engine);\n\t__execlists_update_reg_state(ce, engine);\n\tce->lrc_desc |= CTX_DESC_FORCE_RESTORE;\n}", "target": 0}
{"code": "Status UncompressElement(const CompressedElement& compressed,\n                         std::vector<Tensor>* out) {\n  int num_components = compressed.component_metadata_size();\n  out->clear();\n  out->reserve(num_components);\n  std::vector<struct iovec> iov(num_components);\n  std::vector<tstring> tensor_proto_strs;\n  tensor_proto_strs.reserve(num_components);\n  int64 total_size = 0;\n  for (int i = 0; i < num_components; ++i) {\n    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      iov[i].iov_base = buffer->data();\n      iov[i].iov_len = buffer->size();\n    } else {\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();\n      tstring& tensor_proto_str = tensor_proto_strs.back();\n      tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes());\n      iov[i].iov_base = tensor_proto_str.mdata();\n      iov[i].iov_len = tensor_proto_str.size();\n    }\n    total_size += iov[i].iov_len;\n  }\n  const std::string& compressed_data = compressed.data();\n  size_t uncompressed_size;\n  if (!port::Snappy_GetUncompressedLength(\n          compressed_data.data(), compressed_data.size(), &uncompressed_size)) {\n    return errors::Internal(\n        \"Could not get snappy uncompressed length. Compressed data size: \",\n        compressed_data.size());\n  }\n  if (uncompressed_size != static_cast<size_t>(total_size)) {\n    return errors::Internal(\n        \"Uncompressed size mismatch. Snappy expects \", uncompressed_size,\n        \" whereas the tensor metadata suggests \", total_size);\n  }\n  if (!port::Snappy_UncompressToIOVec(compressed_data.data(),\n                                      compressed_data.size(), iov.data(),\n                                      num_components)) {\n    return errors::Internal(\"Failed to perform snappy decompression.\");\n  }\n  int tensor_proto_strs_index = 0;\n  for (int i = 0; i < num_components; ++i) {\n    if (DataTypeCanUseMemcpy(compressed.component_metadata(i).dtype())) {\n      continue;\n    }\n    TensorProto tp;\n    if (!tp.ParseFromString(tensor_proto_strs[tensor_proto_strs_index++])) {\n      return errors::Internal(\"Could not parse TensorProto\");\n    }\n    if (!out->at(i).FromProto(tp)) {\n      return errors::Internal(\"Could not parse Tensor\");\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "void Server::CheckDocRoot() {\n  try {\n    if (!fs::exists(doc_root_) || !fs::is_directory(doc_root_)) {\n      LOG_ERRO(\"Doc root is not an existing directory!\");\n      return;\n    }\n    if (doc_root_.is_relative()) {\n      doc_root_ = fs::absolute(doc_root_);\n    }\n    doc_root_ = fs::canonical(doc_root_);\n  } catch (fs::filesystem_error& e) {\n    LOG_ERRO(\"Doc root error: %s\", e.what());\n    doc_root_.clear();\n  }\n  LOG_INFO(\"Doc root: %s\", doc_root_.u8string().c_str());\n}", "target": 0}
{"code": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->ipv6))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "long kernel_wait4(pid_t upid, int __user *stat_addr, int options,\n\t\t  struct rusage *ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = NULL;\n\tenum pid_type type;\n\tlong ret;\n\tif (options & ~(WNOHANG|WUNTRACED|WCONTINUED|\n\t\t\t__WNOTHREAD|__WCLONE|__WALL))\n\t\treturn -EINVAL;\n\tif (upid == INT_MIN)\n\t\treturn -ESRCH;\n\tif (upid == -1)\n\t\ttype = PIDTYPE_MAX;\n\telse if (upid < 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = PIDTYPE_PGID;\n\t\tpid = get_task_pid(current, PIDTYPE_PGID);\n\t} else  {\n\t\ttype = PIDTYPE_PID;\n\t\tpid = find_get_pid(upid);\n\t}\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options | WEXITED;\n\two.wo_info\t= NULL;\n\two.wo_stat\t= 0;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\tput_pid(pid);\n\tif (ret > 0 && stat_addr && put_user(wo.wo_stat, stat_addr))\n\t\tret = -EFAULT;\n\treturn ret;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& in_grads = context->input(0);\n    const Tensor& in_image = context->input(1);\n    const Tensor& out_image = context->input(2);\n    OP_REQUIRES(context, in_grads.dims() == 4 && in_image.dims() == 4,\n                errors::InvalidArgument(\"inputs must be 4-dimensional\"));\n    const int64_t batch = in_grads.dim_size(0);\n    const int64_t rows = in_grads.dim_size(1);\n    const int64_t cols = in_grads.dim_size(2);\n    const int64_t depth = in_grads.dim_size(3);\n    OP_REQUIRES(\n        context,\n        in_image.dim_size(0) == batch && in_image.dim_size(1) == rows &&\n            in_image.dim_size(2) == cols && in_image.dim_size(3) == depth &&\n            out_image.dim_size(0) == batch && out_image.dim_size(1) == rows &&\n            out_image.dim_size(2) == cols && out_image.dim_size(3) == depth,\n        errors::InvalidArgument(\n            \"input_grads, input_image, and out_image should have the same \"\n            \"shape\"));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({batch, rows, cols, depth}), &output));\n    LaunchLRNGrad<Device, T> launcher(depth_radius_, bias_, alpha_, beta_);\n    launcher.launch(context, this, in_grads, in_image, out_image, output);\n  }", "target": 1}
{"code": "static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\tnetlink_table_grab();\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n\trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n\tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n\tnl_table[NETLINK_USERSOCK].registered = 1;\n\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;\n\tnetlink_table_ungrab();\n}", "target": 0}
{"code": "INST_HANDLER (cpse) {\t\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "_dbus_lookup_session_address_launchd (DBusString *address, DBusError  *error)\n{\n  dbus_bool_t valid_socket;\n  DBusString socket_path;\n  if (_dbus_check_setuid ())\n    {\n      dbus_set_error_const (error, DBUS_ERROR_NOT_SUPPORTED,\n                            \"Unable to find launchd socket when setuid\");\n      return FALSE;\n    }\n  if (!_dbus_string_init (&socket_path))\n    {\n      _DBUS_SET_OOM (error);\n      return FALSE;\n    }\n  valid_socket = _dbus_lookup_launchd_socket (&socket_path, \"DBUS_LAUNCHD_SESSION_BUS_SOCKET\", error);\n  if (dbus_error_is_set(error))\n    {\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  if (!valid_socket)\n    {\n      dbus_set_error(error, \"no socket path\",\n                \"launchd did not provide a socket path, \"\n                \"verify that org.freedesktop.dbus-session.plist is loaded!\");\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  if (!_dbus_string_append (address, \"unix:path=\"))\n    {\n      _DBUS_SET_OOM (error);\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  if (!_dbus_string_copy (&socket_path, 0, address,\n                          _dbus_string_get_length (address)))\n    {\n      _DBUS_SET_OOM (error);\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  _dbus_string_free(&socket_path);\n  return TRUE;\n}", "target": 0}
{"code": "static void dp8393x_instance_init(Object *obj)\n{\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n    dp8393xState *s = DP8393X(obj);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_mmio(sbd, &s->prom);\n    sysbus_init_irq(sbd, &s->irq);\n}", "target": 0}
{"code": "    inline bool match(const EndpointSecurityAttributesMask remoteMask,\n        const PluginEndpointSecurityAttributesMask remotePluginMask) const\n    {\n        return security_mask_matches(mask(), remoteMask) &&\n            security_mask_matches(plugin_endpoint_attributes, remotePluginMask);\n    }", "target": 1}
{"code": "        bool erase() const { return erase_; }", "target": 0}
{"code": "void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,\n\t\t\t       u32 pm1a_ctrl, u32 pm1b_ctrl))\n{\n\t__acpi_os_prepare_sleep = func;\n}", "target": 0}
{"code": "void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "static void create_layer_surface(struct swaylock_surface *surface) {\n\tstruct swaylock_state *state = surface->state;\n\tsurface->image = select_image(state, surface);\n\tsurface->surface = wl_compositor_create_surface(state->compositor);\n\tassert(surface->surface);\n\tsurface->child = wl_compositor_create_surface(state->compositor);\n\tassert(surface->child);\n\tsurface->subsurface = wl_subcompositor_get_subsurface(state->subcompositor, surface->child, surface->surface);\n\tassert(surface->subsurface);\n\twl_subsurface_set_sync(surface->subsurface);\n\tsurface->layer_surface = zwlr_layer_shell_v1_get_layer_surface(\n\t\t\tstate->layer_shell, surface->surface, surface->output,\n\t\t\tZWLR_LAYER_SHELL_V1_LAYER_OVERLAY, \"lockscreen\");\n\tassert(surface->layer_surface);\n\tzwlr_layer_surface_v1_set_size(surface->layer_surface, 0, 0);\n\tzwlr_layer_surface_v1_set_anchor(surface->layer_surface,\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_TOP |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_RIGHT |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_BOTTOM |\n\t\t\tZWLR_LAYER_SURFACE_V1_ANCHOR_LEFT);\n\tzwlr_layer_surface_v1_set_exclusive_zone(surface->layer_surface, -1);\n\tzwlr_layer_surface_v1_set_keyboard_interactivity(\n\t\t\tsurface->layer_surface, true);\n\tzwlr_layer_surface_v1_add_listener(surface->layer_surface,\n\t\t\t&layer_surface_listener, surface);\n\tif (surface_is_opaque(surface) &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_CENTER &&\n\t\t\tsurface->state->args.mode != BACKGROUND_MODE_FIT) {\n\t\tstruct wl_region *region =\n\t\t\twl_compositor_create_region(surface->state->compositor);\n\t\twl_region_add(region, 0, 0, INT32_MAX, INT32_MAX);\n\t\twl_surface_set_opaque_region(surface->surface, region);\n\t\twl_region_destroy(region);\n\t}\n\twl_surface_commit(surface->surface);\n}", "target": 1}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "vm_fault_t gru_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct gru_thread_state *gts;\n\tunsigned long paddr, vaddr;\n\tunsigned long expires;\n\tvaddr = vmf->address;\n\tgru_dbg(grudev, \"vma %p, vaddr 0x%lx (0x%lx)\\n\",\n\t\tvma, vaddr, GSEG_BASE(vaddr));\n\tSTAT(nopfn);\n\tgts = gru_find_thread_state(vma, TSID(vaddr, vma));\n\tif (!gts)\n\t\treturn VM_FAULT_SIGBUS;\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\tgru_check_context_placement(gts);\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();\n\t\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(GRU_ASSIGN_DELAY);  \n\t\t\texpires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;\n\t\t\tif (time_before(expires, jiffies))\n\t\t\t\tgru_steal_context(gts);\n\t\t\tgoto again;\n\t\t}\n\t\tgru_load_context(gts);\n\t\tpaddr = gseg_physical_address(gts->ts_gru, gts->ts_ctxnum);\n\t\tremap_pfn_range(vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1),\n\t\t\t\tpaddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,\n\t\t\t\tvma->vm_page_prot);\n\t}\n\tpreempt_enable();\n\tmutex_unlock(&gts->ts_ctxlock);\n\treturn VM_FAULT_NOPAGE;\n}", "target": 1}
{"code": "*/\nPHP_FUNCTION(date_timestamp_get)\n{\n\tzval         *object;\n\tphp_date_obj *dateobj;\n\tlong          timestamp;\n\tint           error;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O\", &object, date_ce_interface) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tdateobj = (php_date_obj *) zend_object_store_get_object(object TSRMLS_CC);\n\tDATE_CHECK_INITIALIZED(dateobj->time, DateTime);\n\ttimelib_update_ts(dateobj->time, NULL);\n\ttimestamp = timelib_date_to_int(dateobj->time, &error);\n\tif (error) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETVAL_LONG(timestamp);\n\t}", "target": 0}
{"code": "Status ImmutableExecutorState::BuildControlFlowInfo(const Graph* g,\n                                                    ControlFlowInfo* cf_info) {\n  const int num_nodes = g->num_node_ids();\n  cf_info->frame_names.resize(num_nodes);\n  std::vector<Node*> parent_nodes;\n  parent_nodes.resize(num_nodes);\n  std::vector<bool> visited;\n  visited.resize(num_nodes);\n  string frame_name;\n  std::deque<Node*> ready;\n  for (Node* n : g->nodes()) {\n    if (n->in_edges().empty()) {\n      visited[n->id()] = true;\n      cf_info->unique_frame_names.insert(frame_name);\n      ready.push_back(n);\n    }\n  }\n  while (!ready.empty()) {\n    Node* curr_node = ready.front();\n    int curr_id = curr_node->id();\n    ready.pop_front();\n    Node* parent = nullptr;\n    if (IsEnter(curr_node)) {\n      TF_RETURN_IF_ERROR(\n          GetNodeAttr(curr_node->attrs(), \"frame_name\", &frame_name));\n      parent = curr_node;\n    } else if (IsExit(curr_node)) {\n      parent = parent_nodes[curr_id];\n      if (!parent) {\n        return errors::InvalidArgument(\n            \"Invalid Exit op: Cannot find a corresponding Enter op.\");\n      }\n      frame_name = cf_info->frame_names[parent->id()];\n      parent = parent_nodes[parent->id()];\n    } else {\n      parent = parent_nodes[curr_id];\n      frame_name = cf_info->frame_names[curr_id];\n    }\n    for (const Edge* out_edge : curr_node->out_edges()) {\n      Node* out = out_edge->dst();\n      if (IsSink(out)) continue;\n      const int out_id = out->id();\n      bool is_visited = visited[out_id];\n      if (!is_visited) {\n        ready.push_back(out);\n        visited[out_id] = true;\n        cf_info->frame_names[out_id] = frame_name;\n        parent_nodes[out_id] = parent;\n        cf_info->unique_frame_names.insert(frame_name);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "void SecurityManager::resend_handshake_message_token(\n        const GUID_t& remote_participant_key) const\n{\n    auto sentry = is_security_manager_initialized();\n    if (!sentry)\n    {\n        return;\n    }\n    shared_lock<shared_mutex> _(mutex_);\n    auto dp_it = discovered_participants_.find(remote_participant_key);\n    if (dp_it != discovered_participants_.end())\n    {\n        SecurityManager::DiscoveredParticipantInfo::AuthUniquePtr remote_participant_info = dp_it->second->get_auth();\n        if (remote_participant_info)\n        {\n            if (remote_participant_info->change_sequence_number_ != SequenceNumber_t::unknown())\n            {\n                CacheChange_t* p_change = participant_stateless_message_writer_history_->remove_change_and_reuse(\n                    remote_participant_info->change_sequence_number_);\n                remote_participant_info->change_sequence_number_ = SequenceNumber_t::unknown();\n                if (p_change != nullptr)\n                {\n                    EPROSIMA_LOG_INFO(SECURITY, \"Authentication handshake resent to participant \" <<\n                            remote_participant_key);\n                    if (participant_stateless_message_writer_history_->add_change(p_change))\n                    {\n                        remote_participant_info->change_sequence_number_ = p_change->sequenceNumber;\n                    }\n                }\n            }\n            dp_it->second->set_auth(remote_participant_info);\n        }\n    }\n}", "target": 1}
{"code": "GF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->layout.stream_structure);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tgf_bs_write_u8(bs, ptr->layout.definedLayout);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\tgf_bs_write_u8(bs, ptr->layout.layouts[i].position);\n\t\t\t\tif (ptr->layout.layouts[i].position==126) {\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16);\n\t\t\t\t\tgf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u64(bs, ptr->layout.omittedChannelsMap);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tgf_bs_write_u8(bs, ptr->layout.object_count);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "hash_new_from_values(mrb_state *mrb, mrb_int argc, mrb_value *regs)\n{\n  mrb_value hash = mrb_hash_new_capa(mrb, argc);\n  while (argc--) {\n    mrb_hash_set(mrb, hash, regs[0], regs[1]);\n    regs += 2;\n  }\n  return hash;\n}", "target": 1}
{"code": "int xt_compat_check_entry_offsets(const void *base,\n\t\t\t\t  unsigned int target_offset,\n\t\t\t\t  unsigned int next_offset)\n{\n\tconst struct compat_xt_entry_target *t;\n\tconst char *e = base;\n\tif (target_offset + sizeof(*t) > next_offset)\n\t\treturn -EINVAL;\n\tt = (void *)(e + target_offset);\n\tif (t->u.target_size < sizeof(*t))\n\t\treturn -EINVAL;\n\tif (target_offset + t->u.target_size > next_offset)\n\t\treturn -EINVAL;\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 &&\n\t    target_offset + sizeof(struct compat_xt_standard_target) != next_offset)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "void Bezier(double x1,double y1,double x2,double y2,double x3,double y3) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f %12.3f %12.3f %12.3f %12.3f c\",x1,y1,x2,y2,x3,y3);\n}", "target": 1}
{"code": "dhcpv4_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint8_t type, optlen;\n    i = 0;\n    while (i < length) {\n        if (i + 2 > length)\n            return -1;\n        tlv = cp + i;\n        type = (uint8_t)tlv[0];\n        optlen = (uint8_t)tlv[1];\n        value = tlv + 2;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n        ND_PRINT((ndo, \"%s\", tok2str(dh4opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 2 ));\n        if (i + 2 + optlen > length)\n            return -1;\n        switch (type) {\n        case DH4OPT_DNS_SERVERS:\n        case DH4OPT_NTP_SERVERS: {\n            if (optlen < 4 || optlen % 4 != 0) {\n                return -1;\n            }\n            for (t = 0; t < optlen; t += 4)\n                ND_PRINT((ndo, \" %s\", ipaddr_string(ndo, value + t)));\n        }\n            break;\n        case DH4OPT_DOMAIN_SEARCH: {\n            const u_char *tp = value;\n            while (tp < value + optlen) {\n                ND_PRINT((ndo, \" \"));\n                if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                    return -1;\n            }\n        }\n            break;\n        }\n        i += 2 + optlen;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void remove_full(struct kmem_cache *s, struct kmem_cache_node *n, struct page *page)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->slab_list);\n}", "target": 0}
{"code": "static int ext4_end_io_nolock(ext4_io_end_t *io)\n{\n\tstruct inode *inode = io->inode;\n\tloff_t offset = io->offset;\n\tssize_t size = io->size;\n\tint ret = 0;\n\text4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"\n\t\t   \"list->prev 0x%p\\n\",\n\t           io, inode->i_ino, io->list.next, io->list.prev);\n\tif (list_empty(&io->list))\n\t\treturn ret;\n\tif (io->flag != EXT4_IO_UNWRITTEN)\n\t\treturn ret;\n\tif (offset + size <= i_size_read(inode))\n\t\tret = ext4_convert_unwritten_extents(inode, offset, size);\n\tif (ret < 0) {\n\t\tprintk(KERN_EMERG \"%s: failed to convert unwritten\"\n\t\t\t\"extents to written extents, error is %d\"\n\t\t\t\" io is still on inode %lu aio dio list\\n\",\n                       __func__, ret, inode->i_ino);\n\t\treturn ret;\n\t}\n\tio->flag = 0;\n\treturn ret;\n}", "target": 1}
{"code": "static void RemoveICCProfileFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if (id == 0x0000040f)\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "ssh_packet_set_postauth(struct ssh *ssh)\n{\n\tstruct sshcomp *comp;\n\tint r, mode;\n\tdebug(\"%s: called\", __func__);\n\tssh->state->after_authentication = 1;\n\tssh->state->rekeying = 0;\n\tfor (mode = 0; mode < MODE_MAX; mode++) {\n\t\tif (ssh->state->newkeys[mode] == NULL)\n\t\t\tcontinue;\n\t\tcomp = &ssh->state->newkeys[mode]->comp;\n\t\tif (comp && comp->enabled &&\n\t\t    (r = ssh_packet_init_compression(ssh)) != 0)\n\t\t\treturn r;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "void __init kvmclock_init(void)\n{\n\tif (!kvm_para_available())\n\t\treturn;\n\tif (kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE2)) {\n\t\tmsr_kvm_system_time = MSR_KVM_SYSTEM_TIME_NEW;\n\t\tmsr_kvm_wall_clock = MSR_KVM_WALL_CLOCK_NEW;\n\t} else if (!(kvmclock && kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE)))\n\t\treturn;\n\tprintk(KERN_INFO \"kvm-clock: Using msrs %x and %x\",\n\t\tmsr_kvm_system_time, msr_kvm_wall_clock);\n\tif (kvm_register_clock(\"boot clock\"))\n\t\treturn;\n\tpv_time_ops.sched_clock = kvm_clock_read;\n\tx86_platform.calibrate_tsc = kvm_get_tsc_khz;\n\tx86_platform.get_wallclock = kvm_get_wallclock;\n\tx86_platform.set_wallclock = kvm_set_wallclock;\n#ifdef CONFIG_X86_LOCAL_APIC\n\tx86_cpuinit.setup_percpu_clockev =\n\t\tkvm_setup_secondary_clock;\n#endif\n\tmachine_ops.shutdown  = kvm_shutdown;\n#ifdef CONFIG_KEXEC\n\tmachine_ops.crash_shutdown  = kvm_crash_shutdown;\n#endif\n\tkvm_get_preset_lpj();\n\tclocksource_register_hz(&kvm_clock, NSEC_PER_SEC);\n\tpv_info.paravirt_enabled = 1;\n\tpv_info.name = \"KVM\";\n\tif (kvm_para_has_feature(KVM_FEATURE_CLOCKSOURCE_STABLE_BIT))\n\t\tpvclock_set_flags(PVCLOCK_TSC_STABLE_BIT);\n}", "target": 0}
{"code": "static ssize_t mem_write(struct file * file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint copied;\n\tchar *page;\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tunsigned long dst = *ppos;\n\tcopied = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (!MAY_PTRACE(task) || !ptrace_may_attach(task))\n\t\tgoto out;\n\tcopied = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\tcopied = 0;\n\twhile (count > 0) {\n\t\tint this_len, retval;\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tif (copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tretval = access_process_vm(task, dst, page, this_len, 1);\n\t\tif (!retval) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += retval;\n\t\tbuf += retval;\n\t\tdst += retval;\n\t\tcount -= retval;\t\t\t\n\t}\n\t*ppos = dst;\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn copied;\n}", "target": 0}
{"code": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}", "target": 1}
{"code": "pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len;\n\tuint16_t idx;\n\tsc = vsc;\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\twhile (vq_has_descs(vq)) {\n\t\tvq_getchain(vq, &idx, &iov, 1, NULL);\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\t\tassert(len > 0);\n\t\tvq_relchain(vq, idx, (uint32_t)len);\n\t}\n\tvq_endchains(vq, 1);\t\n}", "target": 1}
{"code": "sshpam_cleanup(void *arg)\n{\n\t(void)arg;\n\tdebug(\"PAM: cleanup\");\n\tpam_set_item(sshpam_handle, PAM_CONV, (const void *)&null_conv);\n\tif (sshpam_cred_established) {\n\t\tpam_setcred(sshpam_handle, PAM_DELETE_CRED);\n\t\tsshpam_cred_established = 0;\n\t}\n\tif (sshpam_session_open) {\n\t\tpam_close_session(sshpam_handle, PAM_SILENT);\n\t\tsshpam_session_open = 0;\n\t}\n\tsshpam_authenticated = sshpam_new_authtok_reqd = 0;\n\tpam_end(sshpam_handle, sshpam_err);\n\tsshpam_handle = NULL;\n}", "target": 0}
{"code": "void PDPServer::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "exit_ext2_xattr(void)\n{\n\tmb_cache_destroy(ext2_xattr_cache);\n}", "target": 1}
{"code": "alloc_limit_assert (char *fn_name, size_t size)\n{\n    if (alloc_limit && size > alloc_limit)\n    {\n\talloc_limit_failure (fn_name, size);\n\texit (-1);\n    }\n}", "target": 1}
{"code": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n{\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static int fill_thread_core_info(struct elf_thread_core_info *t,\n\t\t\t\t const struct user_regset_view *view,\n\t\t\t\t long signr, size_t *total)\n{\n\tunsigned int i;\n\tfill_prstatus(&t->prstatus, t->task, signr);\n\t(void) view->regsets[0].get(t->task, &view->regsets[0],\n\t\t\t\t    0, sizeof(t->prstatus.pr_reg),\n\t\t\t\t    &t->prstatus.pr_reg, NULL);\n\tfill_note(&t->notes[0], \"CORE\", NT_PRSTATUS,\n\t\t  sizeof(t->prstatus), &t->prstatus);\n\t*total += notesize(&t->notes[0]);\n\tdo_thread_regset_writeback(t->task, &view->regsets[0]);\n\tfor (i = 1; i < view->n; ++i) {\n\t\tconst struct user_regset *regset = &view->regsets[i];\n\t\tdo_thread_regset_writeback(t->task, regset);\n\t\tif (regset->core_note_type &&\n\t\t    (!regset->active || regset->active(t->task, regset))) {\n\t\t\tint ret;\n\t\t\tsize_t size = regset->n * regset->size;\n\t\t\tvoid *data = kmalloc(size, GFP_KERNEL);\n\t\t\tif (unlikely(!data))\n\t\t\t\treturn 0;\n\t\t\tret = regset->get(t->task, regset,\n\t\t\t\t\t  0, size, data, NULL);\n\t\t\tif (unlikely(ret))\n\t\t\t\tkfree(data);\n\t\t\telse {\n\t\t\t\tif (regset->core_note_type != NT_PRFPREG)\n\t\t\t\t\tfill_note(&t->notes[i], \"LINUX\",\n\t\t\t\t\t\t  regset->core_note_type,\n\t\t\t\t\t\t  size, data);\n\t\t\t\telse {\n\t\t\t\t\tt->prstatus.pr_fpvalid = 1;\n\t\t\t\t\tfill_note(&t->notes[i], \"CORE\",\n\t\t\t\t\t\t  NT_PRFPREG, size, data);\n\t\t\t\t}\n\t\t\t\t*total += notesize(&t->notes[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void next_character(void)\n{\n    if (!recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    strlcpy(cipher, english_alphabet, ENGLISH_ALPHABET_BUF);\n    random_permute_char(cipher, strlen(cipher));\n    static char CONFIDENTIAL current_word[CURRENT_WORD_BUF];\n    get_current_word(current_word);\n    if (strlen(current_word) > 4) {\n        memzero(current_word, sizeof(current_word));\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError,\n                        \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n        layoutHome();\n        return;\n    }\n    CharacterRequest resp;\n    memset(&resp, 0, sizeof(CharacterRequest));\n    resp.word_pos = get_current_word_pos();\n    resp.character_pos = strlen(current_word);\n    msg_write(MessageType_MessageType_CharacterRequest, &resp);\n    bool auto_completed = false;\n    if (strlen(current_word) >= 3) {\n        auto_completed = attempt_auto_complete(current_word);\n    }\n#if DEBUG_LINK\n    if (auto_completed) {\n        strlcpy(auto_completed_word, current_word, CURRENT_WORD_BUF);\n    } else {\n        auto_completed_word[0] = '\\0';\n    }\n#endif\n    format_current_word(current_word, auto_completed);\n    layout_cipher(current_word, cipher);\n    memzero(current_word, sizeof(current_word));\n}", "target": 0}
{"code": "nd_format_time(char *buf, size_t bufsize, const char *format,\n         const struct tm *timeptr)\n{\n\tif (timeptr != NULL) {\n\t\tif (strftime(buf, bufsize, format, timeptr) != 0)\n\t\t\treturn (buf);\n\t\telse\n\t\t\treturn (\"[nd_format_time() buffer is too small]\");\n\t} else\n\t\treturn (\"[localtime() or gmtime() couldn't convert the date and time]\");\n}", "target": 0}
{"code": "static UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\trdpPrintJob* printjob = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse\n\t{\n\t\terror = printjob->Write(printjob, Stream_Pointer(irp->input), Length);\n\t}\n\tif (error)\n\t{\n\t\tWLog_ERR(TAG, \"printjob->Write failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "static ssize_t attr_show_buffers(struct device *cd,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\treturn sprintf(buf, \"%d\\n\", dev->used_buffers);\n}", "target": 0}
{"code": "intrusive_ptr<DocumentSource> DocumentSourceGroup::optimize() {\n    for (size_t i = 0; i < _idExpressions.size(); i++) {\n        _idExpressions[i] = _idExpressions[i]->optimize();\n    }\n    for (auto&& accumulatedField : _accumulatedFields) {\n        accumulatedField.expr.initializer = accumulatedField.expr.initializer->optimize();\n        accumulatedField.expr.argument = accumulatedField.expr.argument->optimize();\n    }\n    return this;\n}", "target": 0}
{"code": "static bool nfs_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\tstruct svc_procedure *proc)\n{\n\tif (rqstp->rq_prog != NFS_PROGRAM)\n\t\treturn false;\n\tif (rqstp->rq_vers >= 4)\n\t\treturn false;\n\tif (proc->pc_xdrressize > 0 &&\n\t    proc->pc_xdrressize < XDR_QUADLEN(PAGE_SIZE))\n\t\treturn false;\n\treturn rqstp->rq_arg.len > PAGE_SIZE;\n}", "target": 0}
{"code": "\tvoid testQueryCompositionMathWrite_GoogleAutofuzz113244572() {\n\t\tUriQueryListA second = { .key = \"\\x11\", .value = NULL, .next = NULL };\n\t\tUriQueryListA first = { .key = \"\\x01\", .value = \"\\x02\", .next = &second };\n\t\tconst UriBool spaceToPlus = URI_TRUE;\n\t\tconst UriBool normalizeBreaks = URI_FALSE;  \n\t\tconst int charsRequired = (3 + 1 + 3) + 1 + (3);\n\t\t{\n\t\t\tconst char * const expected = \"%01=%02\" \"&\" \"%11\";\n\t\t\tchar dest[charsRequired + 1];\n\t\t\tint charsWritten;\n\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_SUCCESS);\n\t\t\tTEST_ASSERT(! strcmp(dest, expected));\n\t\t\tTEST_ASSERT(charsWritten == strlen(expected) + 1);\n\t\t}\n\t\t{\n\t\t\tchar dest[charsRequired + 1 - 1];\n\t\t\tint charsWritten;\n\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_ERROR_OUTPUT_TOO_LARGE);\n\t\t}\n\t}", "target": 0}
{"code": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n}", "target": 1}
{"code": "static INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvLen;\n\tData_Read_UINT16(&pAvPair->AvLen, AvLen);\n\treturn AvLen;\n}", "target": 1}
{"code": "void ZlibInStream::removeUnderlying()\n{\n  ptr = end = start;\n  if (!underlying) return;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  underlying = 0;\n}", "target": 1}
{"code": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                     Ssl::HandshakerFactoryCb handshaker_factory_cb)\n    : transport_socket_options_(transport_socket_options),\n      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),\n      info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n          ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n}", "target": 1}
{"code": "struct request *blk_mq_tag_to_rq(struct blk_mq_tags *tags, unsigned int tag)\n{\n\tstruct request *rq = tags->rqs[tag];\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(rq->q, rq->mq_ctx);\n\tif (!is_flush_request(rq, fq, tag))\n\t\treturn rq;\n\treturn fq->flush_rq;\n}", "target": 1}
{"code": "njs_promise_perform_all_settled_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled, *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n    context = on_fulfilled->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    on_rejected = njs_promise_create_function(vm, 0);\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n    on_fulfilled->u.native = njs_promise_all_settled_element_functions;\n    on_rejected->u.native = njs_promise_all_settled_element_functions;\n    on_rejected->magic8 = 1; \n    on_fulfilled->args_count = 1;\n    on_rejected->args_count = 1;\n    on_rejected->context = context;\n    (*pargs->remaining)++;\n    njs_set_function(&arguments[0], on_fulfilled);\n    njs_set_function(&arguments[1], on_rejected);\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "mm_destroy(struct mm_master *mm)\n{\n\tmm_freelist(mm->mmalloc, &mm->rb_free);\n\tmm_freelist(mm->mmalloc, &mm->rb_allocated);\n\tif (munmap(mm->address, mm->size) == -1)\n\t\tfatal(\"munmap(%p, %zu): %s\", mm->address, mm->size,\n\t\t    strerror(errno));\n\tif (mm->mmalloc == NULL)\n\t\tfree(mm);\n\telse\n\t\tmm_free(mm->mmalloc, mm);\n}", "target": 1}
{"code": "snmp_mib_cmp_oid(snmp_oid_t *oid1, snmp_oid_t *oid2)\n{\n  uint8_t i;\n  i = 0;\n  while(i < oid1->length && i < oid2->length) {\n    if(oid1->data[i] != oid2->data[i]) {\n      if(oid1->data[i] < oid2->data[i]) {\n        return -1;\n      }\n      return 1;\n    }\n    i++;\n  }\n  if(i == oid1->length &&\n     i < oid2->length) {\n    return -1;\n  }\n  if(i < oid1->length &&\n     i == oid2->length) {\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "void rose_start_idletimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->idletimer);\n\tif (rose->idle > 0) {\n\t\trose->idletimer.function = rose_idletimer_expiry;\n\t\trose->idletimer.expires  = jiffies + rose->idle;\n\t\tadd_timer(&rose->idletimer);\n\t}\n}", "target": 1}
{"code": "int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *xsave;\n\tint ret;\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\tif ((pos != 0) || (count < fpu_user_xstate_size))\n\t\treturn -EFAULT;\n\txsave = &fpu->state.xsave;\n\tfpu__activate_fpstate_write(fpu);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES)) {\n\t\tif (kbuf)\n\t\t\tret = copy_kernel_to_xstate(xsave, kbuf);\n\t\telse\n\t\t\tret = copy_user_to_xstate(xsave, ubuf);\n\t} else {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n\t\tif (!ret && xsave->header.xcomp_bv)\n\t\t\tret = -EINVAL;\n\t}\n\tif (ret)\n\t\tfpstate_init(&fpu->state);\n\txsave->i387.mxcsr &= mxcsr_feature_mask;\n\txsave->header.xfeatures &= xfeatures_mask;\n\tmemset(&xsave->header.reserved, 0, 48);\n\treturn ret;\n}", "target": 0}
{"code": "        friend std::ostream& operator<<(std::ostream& os, const query_string& qs)\n        {\n            os << \"[ \";\n            for (size_t i = 0; i < qs.key_value_pairs_.size(); ++i)\n            {\n                if (i)\n                    os << \", \";\n                os << qs.key_value_pairs_[i];\n            }\n            os << \" ]\";\n            return os;\n        }", "target": 0}
{"code": "  QUInt8() {}", "target": 1}
{"code": "static BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tBYTE* rle = context->Planes;\n\tWINPR_ASSERT(rle);\n\tfor (size_t i = 0; i < 4; i++)\n\t{\n\t\tconst UINT32 originalSize = context->OrgByteCount[i];\n\t\tconst UINT32 planeSize = context->PlaneByteCount[i];\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i],\n\t\t\t                    context->priv->PlaneBuffersLength, originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\t\trle += planeSize;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "      BigInt multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const\n         {\n         return m_mod_order.multiply(m_mod_order.multiply(x, y), z);\n         }", "target": 0}
{"code": "Java_org_tensorflow_lite_InterpreterTest_getNativeHandleForDelegate(\n    JNIEnv* env, jclass clazz) {\n  static TfLiteRegistration registration = {\n      .init = nullptr,\n      .free = nullptr,\n      .prepare =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n            output->type = kTfLiteFloat32;\n            return context->ResizeTensor(context, output, output_dims);\n          },\n      .invoke =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            std::fill(output->data.f,\n                      output->data.f + tflite::NumElements(output), 7.0f);\n            return kTfLiteOk;\n          },\n      .profiling_string = nullptr,\n      .builtin_code = 0,\n      .custom_name = \"\",\n      .version = 1,\n  };\n  static TfLiteDelegate delegate = {\n      .data_ = nullptr,\n      .Prepare = [](TfLiteContext* context,\n                    TfLiteDelegate* delegate) -> TfLiteStatus {\n        TfLiteIntArray* execution_plan;\n        TF_LITE_ENSURE_STATUS(\n            context->GetExecutionPlan(context, &execution_plan));\n        context->ReplaceNodeSubsetsWithDelegateKernels(\n            context, registration, execution_plan, delegate);\n        for (size_t i = 0; i < context->tensors_size; ++i) {\n          context->tensors[i].delegate = delegate;\n          context->tensors[i].buffer_handle = static_cast<int>(i);\n        }\n        return kTfLiteOk;\n      },\n      .CopyFromBufferHandle = nullptr,\n      .CopyToBufferHandle = nullptr,\n      .FreeBufferHandle = nullptr,\n      .flags = kTfLiteDelegateFlagsAllowDynamicTensors,\n  };\n  return reinterpret_cast<jlong>(&delegate);\n}", "target": 1}
{"code": "\t__releases(proto_list_mutex)\n{\n\tmutex_unlock(&proto_list_mutex);\n}", "target": 0}
{"code": "  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n    currentBuffer.length = len;\n    wcb_->setSocket(socket_);\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n  }", "target": 1}
{"code": "void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}", "target": 0}
{"code": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\ttmp = xmalloc(len);\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}", "target": 1}
{"code": "  virtual void requestInit() {\n    m_use_error = false;\n    m_errors.reset();\n    xmlParserInputBufferCreateFilenameDefault(nullptr);\n  }", "target": 1}
{"code": "void SocketLineReader::dataReceived()\n{\n    while (m_socket->canReadLine()) {\n        const QByteArray line = m_socket->readLine();\n        if (line.length() > 1) { \n            m_packets.enqueue(line);\n        }\n    }\n    if (m_socket->bytesAvailable() > 0) {\n        QMetaObject::invokeMethod(this, \"dataReceived\", Qt::QueuedConnection);\n        return;\n    }\n    if (!m_packets.isEmpty()) {\n        Q_EMIT readyRead();\n    }\n}", "target": 1}
{"code": "static unsigned int stack_maxrandom_size(void)\n{\n\tunsigned int max = 0;\n\tif ((current->flags & PF_RANDOMIZE) &&\n\t\t!(current->personality & ADDR_NO_RANDOMIZE)) {\n\t\tmax = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;\n\t}\n\treturn max;\n}", "target": 1}
{"code": "getTable (const char *tableList)\n{\n  int tableListLen;\n  ChainEntry *currentEntry = NULL;\n  ChainEntry *lastEntry = NULL;\n  void *newTable;\n  if (tableList == NULL || *tableList == 0)\n    return NULL;\n  errorCount = fileCount = 0;\n  tableListLen = strlen (tableList);\n  if (lastTrans != NULL)\n    if (tableListLen == lastTrans->tableListLength && (memcmp\n\t\t\t\t\t\t       (&lastTrans->\n\t\t\t\t\t\t\ttableList\n\t\t\t\t\t\t\t[0],\n\t\t\t\t\t\t\ttableList,\n\t\t\t\t\t\t\ttableListLen)) == 0)\n      return (table = lastTrans->table);\n  currentEntry = tableChain;\n  while (currentEntry != NULL)\n    {\n      if (tableListLen == currentEntry->tableListLength && (memcmp\n\t\t\t\t\t\t\t    (&currentEntry->\n\t\t\t\t\t\t\t     tableList\n\t\t\t\t\t\t\t     [0],\n\t\t\t\t\t\t\t     tableList,\n\t\t\t\t\t\t\t     tableListLen))\n\t  == 0)\n\t{\n\t  lastTrans = currentEntry;\n\t  return (table = currentEntry->table);\n\t}\n      lastEntry = currentEntry;\n      currentEntry = currentEntry->next;\n    }\n  if ((newTable = compileTranslationTable (tableList)))\n    {\n      int entrySize = sizeof (ChainEntry) + tableListLen;\n      ChainEntry *newEntry = malloc (entrySize);\n      if (!newEntry)\n\toutOfMemory ();\n      if (tableChain == NULL)\n\ttableChain = newEntry;\n      else\n\tlastEntry->next = newEntry;\n      newEntry->next = NULL;\n      newEntry->table = newTable;\n      newEntry->tableListLength = tableListLen;\n      memcpy (&newEntry->tableList[0], tableList, tableListLen);\n      lastTrans = newEntry;\n      return newEntry->table;\n    }\n  return NULL;\n}", "target": 0}
{"code": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n{\n    VirtQueueElement elem;\n    VirtQueue *vq;\n    vq = vser->c_ivq;\n    if (!virtio_queue_ready(vq)) {\n        return 0;\n    }\n    if (!virtqueue_pop(vq, &elem)) {\n        return 0;\n    }\n    memcpy(elem.in_sg[0].iov_base, buf, len);\n    virtqueue_push(vq, &elem, len);\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n    return len;\n}", "target": 1}
{"code": "static std::string GetBaseFilename(const std::string &filepath) {\n  auto idx = filepath.find_last_of(\"/\\\\\");\n  if (idx != std::string::npos)\n    return filepath.substr(idx + 1);\n  return filepath;\n}", "target": 1}
{"code": "nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tstruct dentry *res;\n\tif (nd->flags & LOOKUP_CREATE) {\n\t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n\tparent = dentry->d_parent;\n\tnfs_block_sillyrename(parent);\n\tstate = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n\t\tpath.dentry = res;\n\tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n\tnfs_unblock_sillyrename(parent);\n\tnfs4_intent_set_file(nd, &path, state);\n\treturn res;\n}", "target": 1}
{"code": "void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy, DatabasePolicy databasePolicy)\n{\n    if (m_frame->document() && m_frame->document()->tokenizer())\n        m_frame->document()->tokenizer()->stopParsing();\n    if (unloadEventPolicy != UnloadEventPolicyNone) {\n        if (m_frame->document()) {\n            if (m_didCallImplicitClose && !m_wasUnloadEventEmitted) {\n                Node* currentFocusedNode = m_frame->document()->focusedNode();\n                if (currentFocusedNode)\n                    currentFocusedNode->aboutToUnload();\n                m_unloadEventBeingDispatched = true;\n                if (m_frame->domWindow()) {\n                    if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide)\n                        m_frame->domWindow()->dispatchEvent(PageTransitionEvent::create(EventNames().pagehideEvent, m_frame->document()->inPageCache()), m_frame->document());\n                    if (!m_frame->document()->inPageCache())\n                        m_frame->domWindow()->dispatchEvent(Event::create(eventNames().unloadEvent, false, false), m_frame->domWindow()->document());\n                }\n                m_unloadEventBeingDispatched = false;\n                if (m_frame->document())\n                    m_frame->document()->updateStyleIfNeeded();\n                m_wasUnloadEventEmitted = true;\n            }\n        }\n        if (m_frame->document() && !m_frame->document()->inPageCache()) {\n            bool keepEventListeners = m_isDisplayingInitialEmptyDocument && m_provisionalDocumentLoader\n                && m_frame->document()->securityOrigin()->isSecureTransitionTo(m_provisionalDocumentLoader->url());\n            if (!keepEventListeners)\n                m_frame->document()->removeAllEventListeners();\n        }\n    }\n    m_isComplete = true; \n    m_isLoadingMainResource = false;\n    m_didCallImplicitClose = true; \n    if (m_frame->document() && m_frame->document()->parsing()) {\n        finishedParsing();\n        m_frame->document()->setParsing(false);\n    }\n    m_workingURL = KURL();\n    if (Document* doc = m_frame->document()) {\n        if (DocLoader* docLoader = doc->docLoader())\n            cache()->loader()->cancelRequests(docLoader);\n#if ENABLE(DATABASE)\n        if (databasePolicy == DatabasePolicyStop)\n            doc->stopDatabases();\n#endif\n    }\n    for (Frame* child = m_frame->tree()->firstChild(); child; child = child->tree()->nextSibling())\n        child->loader()->stopLoading(unloadEventPolicy);\n    m_frame->redirectScheduler()->cancel();\n}", "target": 0}
{"code": "mm_xmalloc(struct mm_master *mm, size_t size)\n{\n\tvoid *address;\n\taddress = mm_malloc(mm, size);\n\tif (address == NULL)\n\t\tfatal(\"%s: mm_malloc(%zu)\", __func__, size);\n\tmemset(address, 0, size);\n\treturn (address);\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  auto* params = reinterpret_cast<TfLiteSubParams*>(node->builtin_data);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      CalculateOpData(context, params, input1, input2, output, data));\n  return kTfLiteOk;\n}", "target": 0}
{"code": "pdf_write_names(FILE *out)\t\t\n{\n  int\t\ti;\t\t\t\n  uchar\t\t*s;\t\t\t\n  link_t\t*link;\t\t\t\n  for (i = num_links, link = links; i > 0; i --, link ++)\n    for (s = link->name; *s != '\\0'; s ++)\n      *s = (uchar)tolower(*s);\n  names_object = pdf_start_object(out);\n  fprintf(out, \"/Dests %d 0 R\", (int)num_objects + 1);\n  pdf_end_object(out);\n  pdf_start_object(out);\n  fprintf(out, \"/Kids[%d 0 R]\", (int)num_objects + 1);\n  pdf_end_object(out);\n  pdf_start_object(out);\n  fputs(\"/Limits[\", out);\n  write_string(out, links[0].name, 0);\n  write_string(out, links[num_links - 1].name, 0);\n  fputs(\"]\", out);\n  fputs(\"/Names[\", out);\n  for (i = 1, link = links; i <= (int)num_links; i ++, link ++)\n  {\n    write_string(out, link->name, 0);\n    fprintf(out, \"%d 0 R\", (int)num_objects + i);\n  }\n  fputs(\"]\", out);\n  pdf_end_object(out);\n  for (i = num_links, link = links; i > 0; i --, link ++)\n  {\n    pdf_start_object(out);\n    float x, y;\n    check_pages(link->page);\n    x = 0.0f;\n    y = link->top + pages[link->page].bottom;\n    pspdf_transform_coords(pages + link->page, x, y);\n    fprintf(out, \"/D[%d 0 R/XYZ %.0f %.0f 0]\",\n            pages_object + 2 * pages[link->page].outpage + 1, x, y);\n    pdf_end_object(out);\n  }\n}", "target": 0}
{"code": "gss_get_mic (minor_status,\n\t     context_handle,\n\t     qop_req,\n\t     message_buffer,\n\t     msg_token)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_get_mic_args(minor_status, context_handle,\n\t\t\t      qop_req, message_buffer, msg_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_get_mic) {\n\t    status = mech->gss_get_mic(\n\t\t\t\t    minor_status,\n\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t    qop_req,\n\t\t\t\t    message_buffer,\n\t\t\t\t    msg_token);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    FileContainerFree(s->files_ts);\n    FileContainerFree(s->files_tc);\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static UINT urb_isoch_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                               UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                               int transferDir)\n{\n\tUINT32 EndpointAddress;\n\tUINT32 PipeHandle, TransferFlags, StartFrame, NumberOfPackets;\n\tUINT32 ErrorCount, OutputBufferSize;\n\tBYTE* packetDescriptorData;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\tif (!pdev || !callback || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(s, PipeHandle);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tStream_Read_UINT32(s, TransferFlags);   \n\tStream_Read_UINT32(s, StartFrame);      \n\tStream_Read_UINT32(s, NumberOfPackets); \n\tStream_Read_UINT32(s, ErrorCount);      \n\tif (Stream_GetRemainingLength(s) < NumberOfPackets * 12 + 4)\n\t\treturn ERROR_INVALID_DATA;\n\tpacketDescriptorData = Stream_Pointer(s);\n\tStream_Seek(s, NumberOfPackets * 12);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (!Stream_CheckAndLogRequiredLength(TAG, s, OutputBufferSize))\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\treturn pdev->isoch_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, StartFrame,\n\t    ErrorCount, noAck, packetDescriptorData, NumberOfPackets, OutputBufferSize,\n\t    (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_isoch_transfer_cb, 2000);\n}", "target": 0}
{"code": "R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}", "target": 1}
{"code": "yy_reduce_print (yytype_int16 *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)\n{\n  unsigned long int yylno = yyrline[yyrule];\n  int yynrhs = yyr2[yyrule];\n  int yyi;\n  YYFPRINTF (stderr, \"Reducing stack by rule %d (line %lu):\\n\",\n             yyrule - 1, yylno);\n  for (yyi = 0; yyi < yynrhs; yyi++)\n    {\n      YYFPRINTF (stderr, \"   $%d = \", yyi + 1);\n      yy_symbol_print (stderr,\n                       yystos[yyssp[yyi + 1 - yynrhs]],\n                       &(yyvsp[(yyi + 1) - (yynrhs)])\n                                              , yyscanner, lex_env);\n      YYFPRINTF (stderr, \"\\n\");\n    }\n}", "target": 0}
{"code": "static inline int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t       int cs_l)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tif ((cs_l && is_noncanonical_address(dst)) ||\n\t\t    (!cs_l && (dst & ~(u32)-1)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "start_pass_merged_upsample(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  upsample->spare_full = FALSE;\n  upsample->rows_to_go = cinfo->output_height;\n}", "target": 1}
{"code": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\nretry:\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\tfutex_wait_queue_me(hb, &q, to);\n\tret = 0;\n\tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out_put_key;\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n\t\tgoto retry;\n\t}\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out_put_key;\n\trestart = &current_thread_info()->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n\tret = -ERESTART_RESTARTBLOCK;\nout_put_key:\n\tput_futex_key(fshared, &q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void InsertNode(CPpmd8 *p, void *node, unsigned indx)\n{\n  ((CPpmd8_Node *)node)->Stamp = EMPTY_NODE;\n  ((CPpmd8_Node *)node)->Next = (CPpmd8_Node_Ref)p->FreeList[indx];\n  ((CPpmd8_Node *)node)->NU = I2U(indx);\n  p->FreeList[indx] = REF(node);\n  p->Stamps[indx]++;\n}", "target": 0}
{"code": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\tif (prevGlyph)\n\t\tprevGlyph->Free(glyphCache->context, prevGlyph);\n\tglyphCache->glyphCache[id].entries[index] = glyph;\n\treturn TRUE;\n}", "target": 1}
{"code": "void pickHyprPicker(sdbus::MethodCall& call) {\n    const std::string HYPRPICKER_CMD = \"hyprpicker --format=rgb --no-fancy\";\n    std::string       rgbColor       = execAndGet(HYPRPICKER_CMD.c_str());\n    if (rgbColor.size() > 12) {\n        Debug::log(ERR, \"hyprpicker returned strange output: \" + rgbColor);\n        sendEmptyDbusMethodReply(call, 1);\n        return;\n    }\n    std::array<uint8_t, 3> colors{0, 0, 0};\n    try {\n        for (uint8_t i = 0; i < 2; i++) {\n            uint64_t next = rgbColor.find(' ');\n            if (next == std::string::npos) {\n                Debug::log(ERR, \"hyprpicker returned strange output: \" + rgbColor);\n                sendEmptyDbusMethodReply(call, 1);\n                return;\n            }\n            colors[i] = std::stoi(rgbColor.substr(0, next));\n            rgbColor  = rgbColor.substr(next + 1, rgbColor.size() - next);\n        }\n        colors[2] = std::stoi(rgbColor);\n    } catch (...) {\n        Debug::log(ERR, \"Reading RGB values from hyprpicker failed. This is likely a string to integer error.\");\n        sendEmptyDbusMethodReply(call, 1);\n    }\n    auto [r, g, b] = colors;\n    std::unordered_map<std::string, sdbus::Variant> results;\n    results[\"color\"] = sdbus::Struct(std::tuple{r / 255.0, g / 255.0, b / 255.0});\n    auto reply = call.createReply();\n    reply << (uint32_t)0;\n    reply << results;\n    reply.send();\n}", "target": 1}
{"code": "int main(int argc, char **argv, char **envp)\n{\n#ifdef DYNLOAD\n    if (!uc_dyn_load(NULL, 0)) {\n        printf(\"Error dynamically loading shared library.\\n\");\n        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    return 0;\n}", "target": 1}
{"code": "DEFINE_TEST(test_write_disk_fixup)\n{\n\tstruct archive *ad;\n\tstruct archive_entry *ae;\n\tint r;\n\tif (!canSymlink()) {\n\t\tskipping(\"Symlinks not supported\");\n\t\treturn;\n\t}\n\tassert((ad = archive_write_disk_new()) != NULL);\n\tassertMakeFile(\"victim\", 0600, \"a\");\n        assert((ae = archive_entry_new()) != NULL);\n        archive_entry_copy_pathname(ae, \"dir\");\n        archive_entry_set_mode(ae, AE_IFDIR | 0606);\n\tassertEqualIntA(ad, 0, archive_write_header(ad, ae));\n\tassertEqualIntA(ad, 0, archive_write_finish_entry(ad));\n        archive_entry_free(ae);\n\tassert((ae = archive_entry_new()) != NULL);\n\tarchive_entry_copy_pathname(ae, \"dir\");\n\tarchive_entry_set_mode(ae, AE_IFLNK | 0777);\n\tarchive_entry_set_size(ae, 0);\n\tarchive_entry_copy_symlink(ae, \"victim\");\n\tassertEqualIntA(ad, 0, r = archive_write_header(ad, ae));\n\tif (r >= ARCHIVE_WARN)\n\t\tassertEqualIntA(ad, 0, archive_write_finish_entry(ad));\n\tarchive_entry_free(ae);\n\tassertEqualInt(ARCHIVE_OK, archive_write_free(ad));\n\tassertIsSymlink(\"dir\", \"victim\", 0);\n\tassertFileMode(\"victim\", 0600);\n}", "target": 0}
{"code": "vte_sequence_handler_dc (VteTerminal *terminal, GValueArray *params)\n{\n\tVteScreen *screen;\n\tVteRowData *rowdata;\n\tlong col;\n\tscreen = terminal->pvt->screen;\n\tif (_vte_ring_next(screen->row_data) > screen->cursor_current.row) {\n\t\tlong len;\n\t\trowdata = _vte_ring_index(screen->row_data,\n\t\t\t\t\t  VteRowData *,\n\t\t\t\t\t  screen->cursor_current.row);\n\t\tg_assert(rowdata != NULL);\n\t\tcol = screen->cursor_current.col;\n\t\tlen = rowdata->cells->len;\n\t\tif (col < len) {\n\t\t\tg_array_remove_index(rowdata->cells, col);\n\t\t\tif (screen->fill_defaults.attr.back != VTE_DEF_BG) {\n\t\t\t\tvte_g_array_fill (rowdata->cells,\n\t\t\t\t\t\t&screen->fill_defaults,\n\t\t\t\t\t\tterminal->column_count);\n\t\t\t\tlen = terminal->column_count;\n\t\t\t}\n\t\t\t_vte_invalidate_cells(terminal,\n\t\t\t\t\tcol, len - col,\n\t\t\t\t\tscreen->cursor_current.row, 1);\n\t\t}\n\t}\n\tterminal->pvt->text_deleted_flag = TRUE;\n}", "target": 0}
{"code": "static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif(im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif(!pim) {\n\t\t\treturn 1;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\tGIFEncode(\n\t    out, tim->sx, tim->sy, interlace, 0, tim->transparent, BitsPerPixel,\n\t    tim->red, tim->green, tim->blue, tim);\n\tif(pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  absl::optional<uint64_t> evaluate(const Network::Address::Instance*,\n                                    const RequestHeaderMap& headers,\n                                    const HashPolicy::AddCookieCallback add_cookie,\n                                    const StreamInfo::FilterStateSharedPtr) const override {\n    absl::optional<uint64_t> hash;\n    std::string value = Utility::parseCookieValue(headers, key_);\n    if (value.empty() && ttl_.has_value()) {\n      value = add_cookie(key_, path_, ttl_.value(), attributes_);\n      hash = HashUtil::xxHash64(value);\n    } else if (!value.empty()) {\n      hash = HashUtil::xxHash64(value);\n    }\n    return hash;\n  }", "target": 1}
{"code": "void svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "htp_status_t htp_connp_REQ_PROTOCOL(htp_connp_t *connp) {\n    if (connp->in_tx->is_protocol_0_9 == 0) {\n        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        int64_t pos = connp->in_current_read_offset;\n        if (connp->in_current_len > connp->in_current_read_offset + HTTP09_MAX_JUNK_LEN) {\n            htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n            connp->in_tx->is_protocol_0_9 = 0;\n            connp->in_state = htp_connp_REQ_HEADERS;\n            connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n            return HTP_OK;\n        }\n        while (pos < connp->in_current_len) {\n            if (!htp_is_space(connp->in_current_data[pos])) {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            }\n            pos++;\n        }\n        connp->in_state = htp_connp_REQ_FINALIZE;\n    }\n    return HTP_OK;\n}", "target": 0}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tkvm_get_kvm(kvm);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\tops->destroy(dev);\n\t\treturn ret;\n\t}\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 0}
{"code": "spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t\t  int iov_count)\n{\n    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n\t\t\t      iov_count);\n}", "target": 1}
{"code": "static int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\tline += 3; \n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\t*out = (git_pkt *)pkt;\n\treturn 0;\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}", "target": 1}
{"code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    mrb_stack_extend(mrb, len+2); \n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    if (vmexec) {\n      c->ci--;                    \n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}", "target": 1}
{"code": "SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\tstatus = table->DeleteSecurityContext(phContext);\n\treturn status;\n}", "target": 1}
{"code": "Curves16Data* CurvesAlloc(cmsContext ContextID, int nCurves, int nElements, cmsToneCurve** G)\n{\n    int i, j;\n    Curves16Data* c16;\n    c16 = _cmsMallocZero(ContextID, sizeof(Curves16Data));\n    if (c16 == NULL) return NULL;\n    c16 ->nCurves = nCurves;\n    c16 ->nElements = nElements;\n    c16 ->Curves = _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));\n    if (c16 ->Curves == NULL) return NULL;\n    for (i=0; i < nCurves; i++) {\n        c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));\n        if (c16->Curves[i] == NULL) {\n            for (j=0; j < i; j++) {\n                _cmsFree(ContextID, c16->Curves[j]);\n            }\n            _cmsFree(ContextID, c16->Curves);\n            _cmsFree(ContextID, c16);\n            return NULL;\n        }\n        if (nElements == 256) {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], FROM_8_TO_16(j));\n            }\n        }\n        else {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], (cmsUInt16Number) j);\n            }\n        }\n    }\n    return c16;\n}", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tchar *name = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\tRBinJavaAttrMetas *type_info = NULL;\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\tname = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\ttype_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((attr = type_info->allocs->new_obj (buffer, nsz, buf_offset))) {\n\t\t\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\t\t}\n\t} else {\n\t\teprintf (\"r_bin_java_read_next_attr_from_buffer: Cannot find type_info for %s\\n\", name);\n\t}\n\tfree (name);\n\treturn attr;\n}", "target": 1}
{"code": "PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        if (timestamp >= file_info.m_ModificationTime) {\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n    }\n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}", "target": 1}
{"code": "kvp_respond_to_host(char *key, char *value, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_msg_enumerate  *kvp_data;\n\tchar\t*key_name;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen, valuelen;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\tif (!kvp_transaction.active) {\n\t\tpr_warn(\"KVP: Transaction not active\\n\");\n\t\treturn;\n\t}\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\tkvp_transaction.active = false;\n\tif (channel->onchannel_callback == NULL)\n\t\treturn;\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\tkvp_data = &kvp_msg->kvp_data;\n\tkey_name = key;\n\tif (error) {\n\t\ticmsghdrp->status = HV_E_FAIL;\n\t\tgoto response_done;\n\t}\n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name),\n\t\t\t\t(wchar_t *)kvp_data->data.key);\n\tkvp_data->data.key_size = 2*(keylen + 1); \n\tvaluelen = utf8s_to_utf16s(value, strlen(value),\n\t\t\t\t(wchar_t *)kvp_data->data.value);\n\tkvp_data->data.value_size = 2*(valuelen + 1); \n\tkvp_data->data.value_type = REG_SZ; \n\ticmsghdrp->status = HV_S_OK;\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n}", "target": 1}
{"code": "static uint get_alen(char *arg, int default_len)\n{\n\tint\tj;\n\tint\talen;\n\talen = default_len;\n\tfor (j = 0; j < 8; j++) {\n\t\tif (arg[j] == '.') {\n\t\t\talen = arg[j+1] - '0';\n\t\t\tbreak;\n\t\t} else if (arg[j] == '\\0')\n\t\t\tbreak;\n\t}\n\treturn alen;\n}", "target": 1}
{"code": "p_string(FILE* f, ptrdiff_t len, UChar* s)\n{\n  fputs(\":\", f);\n  while (len-- > 0) { fputc(*s++, f); }\n}", "target": 0}
{"code": "static inline void txopt_put(struct ipv6_txoptions *opt)\n{\n\tif (opt && atomic_dec_and_test(&opt->refcnt))\n\t\tkfree_rcu(opt, rcu);\n}", "target": 0}
{"code": "nvkm_vmm_unmap_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *next;\n\tnvkm_memory_tags_put(vma->memory, vmm->mmu->subdev.device, &vma->tags);\n\tnvkm_memory_unref(&vma->memory);\n\tif (vma->part) {\n\t\tstruct nvkm_vma *prev = node(vma, prev);\n\t\tif (!prev->memory) {\n\t\t\tprev->size += vma->size;\n\t\t\trb_erase(&vma->tree, &vmm->root);\n\t\t\tlist_del(&vma->head);\n\t\t\tkfree(vma);\n\t\t\tvma = prev;\n\t\t}\n\t}\n\tnext = node(vma, next);\n\tif (next && next->part) {\n\t\tif (!next->memory) {\n\t\t\tvma->size += next->size;\n\t\t\trb_erase(&next->tree, &vmm->root);\n\t\t\tlist_del(&next->head);\n\t\t\tkfree(next);\n\t\t}\n\t}\n}", "target": 1}
{"code": "int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {\n    keyReference *keys;\n    UNUSED(cmd);\n    UNUSED(argv);\n    UNUSED(argc);\n    keys = getKeysPrepareResult(result, 1);\n    keys[0].pos = 1; \n    keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;\n    return 1;\n}", "target": 1}
{"code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 1}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}", "target": 1}
{"code": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}", "target": 1}
{"code": "int secure_check(void *data)\n{\n\tconst at91_secure_header_t *header;\n\tvoid *file;\n\tif (secure_decrypt(data, sizeof(*header), 0))\n\t\treturn -1;\n\theader = (const at91_secure_header_t *)data;\n\tif (header->magic != AT91_SECURE_MAGIC)\n\t\treturn -1;\n\tfile = (unsigned char *)data + sizeof(*header);\n\treturn secure_decrypt(file, header->file_size, 1);\n}", "target": 1}
{"code": "SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)\n{\n\tint ufd;\n\tstruct timerfd_ctx *ctx;\n\tBUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);\n\tif ((flags & ~TFD_CREATE_FLAGS) ||\n\t    (clockid != CLOCK_MONOTONIC &&\n\t     clockid != CLOCK_REALTIME &&\n\t     clockid != CLOCK_REALTIME_ALARM &&\n\t     clockid != CLOCK_BOOTTIME &&\n\t     clockid != CLOCK_BOOTTIME_ALARM))\n\t\treturn -EINVAL;\n\tif (!capable(CAP_WAKE_ALARM) &&\n\t    (clockid == CLOCK_REALTIME_ALARM ||\n\t     clockid == CLOCK_BOOTTIME_ALARM))\n\t\treturn -EPERM;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tinit_waitqueue_head(&ctx->wqh);\n\tspin_lock_init(&ctx->cancel_lock);\n\tctx->clockid = clockid;\n\tif (isalarm(ctx))\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\telse\n\t\thrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);\n\tctx->moffs = ktime_mono_to_real(0);\n\tufd = anon_inode_getfd(\"[timerfd]\", &timerfd_fops, ctx,\n\t\t\t       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));\n\tif (ufd < 0)\n\t\tkfree(ctx);\n\treturn ufd;\n}", "target": 0}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "int vcc_getsockopt(struct socket *sock, int level, int optname,\n\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct atm_vcc *vcc;\n\tint len;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (__SO_LEVEL_MATCH(optname, level) && len != __SO_SIZE(optname))\n\t\treturn -EINVAL;\n\tvcc = ATM_SD(sock);\n\tswitch (optname) {\n\tcase SO_ATMQOS:\n\t\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags))\n\t\t\treturn -EINVAL;\n\t\treturn copy_to_user(optval, &vcc->qos, sizeof(vcc->qos))\n\t\t\t? -EFAULT : 0;\n\tcase SO_SETCLP:\n\t\treturn put_user(vcc->atm_options & ATM_ATMOPT_CLP ? 1 : 0,\n\t\t\t\t(unsigned long __user *)optval) ? -EFAULT : 0;\n\tcase SO_ATMPVC:\n\t{\n\t\tstruct sockaddr_atmpvc pvc;\n\t\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\t\treturn -ENOTCONN;\n\t\tmemset(&pvc, 0, sizeof(pvc));\n\t\tpvc.sap_family = AF_ATMPVC;\n\t\tpvc.sap_addr.itf = vcc->dev->number;\n\t\tpvc.sap_addr.vpi = vcc->vpi;\n\t\tpvc.sap_addr.vci = vcc->vci;\n\t\treturn copy_to_user(optval, &pvc, sizeof(pvc)) ? -EFAULT : 0;\n\t}\n\tdefault:\n\t\tif (level == SOL_SOCKET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tif (!vcc->dev || !vcc->dev->ops->getsockopt)\n\t\treturn -EINVAL;\n\treturn vcc->dev->ops->getsockopt(vcc, level, optname, optval, len);\n}", "target": 0}
{"code": "int rpc_type_of_NPPVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPPVpluginNameString:\n  case NPPVpluginDescriptionString:\n  case NPPVformValue: \n  case NPPVpluginNativeAccessibleAtkPlugId:\n\ttype = RPC_TYPE_STRING;\n\tbreak;\n  case NPPVpluginWindowSize:\n  case NPPVpluginTimerInterval:\n\ttype = RPC_TYPE_INT32;\n\tbreak;\n  case NPPVpluginNeedsXEmbed:\n  case NPPVpluginWindowBool:\n  case NPPVpluginTransparentBool:\n  case NPPVjavascriptPushCallerBool:\n  case NPPVpluginKeepLibraryInMemory:\n  case NPPVpluginUrlRequestsDisplayedBool:\n  case NPPVpluginWantsAllNetworkStreams:\n  case NPPVpluginCancelSrcStream:\n  case NPPVSupportsAdvancedKeyHandling:\n\ttype = RPC_TYPE_BOOLEAN;\n\tbreak;\n  case NPPVpluginScriptableNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}", "target": 0}
{"code": "smb2_parse_lease_state(struct TCP_Server_Info *server,\n\t\t       struct smb2_create_rsp *rsp,\n\t\t       unsigned int *epoch, char *lease_key)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next;\n\tunsigned int remaining;\n\tchar *name;\n\tdata_offset = (char *)rsp + le32_to_cpu(rsp->CreateContextsOffset);\n\tremaining = le32_to_cpu(rsp->CreateContextsLength);\n\tcc = (struct create_context *)data_offset;\n\twhile (remaining >= sizeof(struct create_context)) {\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) == 4 &&\n\t\t    strncmp(name, \"RqLs\", 4) == 0)\n\t\t\treturn server->ops->parse_lease_buf(cc, epoch,\n\t\t\t\t\t\t\t    lease_key);\n\t\tnext = le32_to_cpu(cc->Next);\n\t\tif (!next)\n\t\t\tbreak;\n\t\tremaining -= next;\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "auth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "target": 0}
{"code": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\tcipso_v4_delopt(&req_inet->opt);\n}", "target": 1}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape(ssm.shape());\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice(tsp);\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 1}
{"code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "bool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbPlaintextData_longlong;\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n    *pcbPlaintextData = pcbPlaintextData_longlong;\n    return nDecryptResult == 0;\n}", "target": 1}
{"code": "PJ_DEF(pj_status_t) pj_file_setpos( pj_oshandle_t fd,\n                                    pj_off_t offset,\n                                    enum pj_file_seek_type whence)\n{\n    int mode;\n    if ((sizeof(pj_off_t) > sizeof(long)) &&\n        (offset > PJ_MAXLONG || offset < PJ_MINLONG)) \n    {\n        return PJ_ENOTSUP;\n    }\n    switch (whence) {\n    case PJ_SEEK_SET:\n        mode = SEEK_SET; break;\n    case PJ_SEEK_CUR:\n        mode = SEEK_CUR; break;\n    case PJ_SEEK_END:\n        mode = SEEK_END; break;\n    default:\n        pj_assert(!\"Invalid whence in file_setpos\");\n        return PJ_EINVAL;\n    }\n    if (fseek((FILE*)fd, (long)offset, mode) != 0)\n        return PJ_RETURN_OS_ERROR(errno);\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask) {\n\t\terr = compat_get_bitmap(bm, nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, bm, alloc_size);\n\t}\n\tif (err)\n\t\treturn -EFAULT;\n\treturn sys_set_mempolicy(mode, nm, nr_bits+1);\n}", "target": 1}
{"code": "dirvote_get_vote(const char *fp, int flags)\n{\n  int by_id = flags & DGV_BY_ID;\n  const int include_pending = flags & DGV_INCLUDE_PENDING;\n  const int include_previous = flags & DGV_INCLUDE_PREVIOUS;\n  if (!pending_vote_list && !previous_vote_list)\n    return NULL;\n  if (fp == NULL) {\n    authority_cert_t *c = get_my_v3_authority_cert();\n    if (c) {\n      fp = c->cache_info.identity_digest;\n      by_id = 1;\n    } else\n      return NULL;\n  }\n  if (by_id) {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  } else {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "GF_Err gf_isom_reset_tables(GF_ISOFile *movie, Bool reset_sample_count)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\t\tu32 dur;\n\t\tu64 dts;\n\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\t\ttrak->sample_count_at_seg_start += stbl->SampleSize->sampleCount;\n\t\tif (trak->sample_count_at_seg_start) {\n\t\t\tGF_Err e;\n\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\tif (e == GF_OK) {\n\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t}\n\t\t}\n\t\tgf_isom_recreate_tables(trak);\n#if 0\n\t\tj = stbl->nb_stbl_boxes;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t}\n#endif\n\t\tif (reset_sample_count) {\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t\t\ttrak->dts_at_seg_start = 0;\n\t\t\ttrak->first_traf_merged = GF_FALSE;\n#endif\n\t\t}\n\t}\n\tif (reset_sample_count) {\n\t\tmovie->NextMoofNumber = 0;\n\t}\n#endif\n\treturn GF_OK;\n}", "target": 0}
{"code": "spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\t*minor_status = 0;\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\treturn (ret);\n}", "target": 1}
{"code": "mark_trusted_task_thread_func (GTask        *task,\n                               gpointer      source_object,\n                               gpointer      task_data,\n                               GCancellable *cancellable)\n{\n    MarkTrustedJob *job = task_data;\n    CommonJob *common;\n    common = (CommonJob *) job;\n    nautilus_progress_info_start (job->common.progress);\n    mark_desktop_file_trusted (common,\n                               cancellable,\n                               job->file,\n                               job->interactive);\n}", "target": 1}
{"code": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) \n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\tumount2(path, MNT_DETACH); \n\t\tgoto domount;\n\t}\n\treturn 0;\ndomount:\n\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}", "target": 1}
{"code": "static int flakey_ioctl(struct dm_target *ti, unsigned int cmd, unsigned long arg)\n{\n\tstruct flakey_c *fc = ti->private;\n\treturn __blkdev_driver_ioctl(fc->dev->bdev, fc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "bool ArcMemory::Unload()\n{\n  if (!Loaded)\n    return false;\n  Loaded=false;\n  return true;\n}", "target": 0}
{"code": "static void init_security_types(struct nvnc* server)\n{\n#define ADD_SECURITY_TYPE(type) \\\n\tassert(server->n_security_types < MAX_SECURITY_TYPES); \\\n\tserver->security_types[server->n_security_types++] = (type);\n\tif (server->n_security_types > 0)\n\t\treturn;\n\tif (server->auth_flags & NVNC_AUTH_REQUIRE_AUTH) {\n\t\tassert(server->auth_fn);\n#ifdef ENABLE_TLS\n\t\tif (server->tls_creds) {\n\t\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_VENCRYPT);\n\t\t}\n#endif\n#ifdef HAVE_CRYPTO\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_RSA_AES256);\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_RSA_AES);\n\t\tif (!(server->auth_flags & NVNC_AUTH_REQUIRE_ENCRYPTION)) {\n\t\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_APPLE_DH);\n\t\t}\n#endif\n\t} else {\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_NONE);\n\t}\n\tif (server->n_security_types == 0) {\n\t\tnvnc_log(NVNC_LOG_PANIC, \"Failed to satisfy requested security constraints\");\n\t}\n#undef ADD_SECURITY_TYPE\n}", "target": 0}
{"code": "void set_module_sig_enforced(void)\n{\n\tsig_enforce = true;\n}", "target": 1}
{"code": "QPDF::resolve(int objid, int generation)\n{\n    QPDFObjGen og(objid, generation);\n    if (this->resolving.count(og))\n    {\n\tQTC::TC(\"qpdf\", \"QPDF recursion loop in resolve\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->file->getName(),\n\t\t     \"\", this->file->getLastOffset(),\n\t\t     \"loop detected resolving object \" +\n\t\t     QUtil::int_to_string(objid) + \" \" +\n\t\t     QUtil::int_to_string(generation)));\n        return new QPDF_Null;\n    }\n    ResolveRecorder rr(this, og);\n    if (! this->obj_cache.count(og))\n    {\n\tif (! this->xref_table.count(og))\n\t{\n\t    return new QPDF_Null;\n\t}\n\tQPDFXRefEntry const& entry = this->xref_table[og];\n\tswitch (entry.getType())\n\t{\n\t  case 1:\n\t    {\n\t\tqpdf_offset_t offset = entry.getOffset();\n\t\tint aobjid;\n\t\tint ageneration;\n\t\tQPDFObjectHandle oh =\n\t\t    readObjectAtOffset(true, offset, \"\", objid, generation,\n\t\t\t\t       aobjid, ageneration);\n\t    }\n\t    break;\n\t  case 2:\n\t    resolveObjectsInStream(entry.getObjStreamNumber());\n\t    break;\n\t  default:\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), \"\", 0,\n\t\t\t  \"object \" +\n\t\t\t  QUtil::int_to_string(objid) + \"/\" +\n\t\t\t  QUtil::int_to_string(generation) +\n\t\t\t  \" has unexpected xref entry type\");\n\t}\n    }\n    return this->obj_cache[og].object;\n}", "target": 0}
{"code": "static int valid_entry_name(const char *filename)\n{\n\treturn *filename != '\\0' &&\n\t\tstrchr(filename, '/') == NULL &&\n\t\t(*filename != '.' ||\n\t\t (strcmp(filename, \".\") != 0 &&\n\t\t  strcmp(filename, \"..\") != 0 &&\n\t\t  strcmp(filename, DOT_GIT) != 0));\n}", "target": 1}
{"code": "GF_AV1Config *gf_isom_av1_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex - 1);\n\tif (!entry || !entry->av1_config) return NULL;\n\treturn AV1_DuplicateConfig(entry->av1_config->config);\n}", "target": 1}
{"code": "void fio_signal_handler_reset(void) {\n  struct sigaction old;\n  if (!fio_old_sig_int.sa_handler)\n    return;\n  memset(&old, 0, sizeof(old));\n  sigaction(SIGINT, &fio_old_sig_int, &old);\n  sigaction(SIGTERM, &fio_old_sig_term, &old);\n  sigaction(SIGPIPE, &fio_old_sig_pipe, &old);\n  if (fio_old_sig_chld.sa_handler)\n    sigaction(SIGCHLD, &fio_old_sig_chld, &old);\n#if !FIO_DISABLE_HOT_RESTART\n  sigaction(SIGUSR1, &fio_old_sig_usr1, &old);\n  memset(&fio_old_sig_usr1, 0, sizeof(fio_old_sig_usr1));\n#endif\n  memset(&fio_old_sig_int, 0, sizeof(fio_old_sig_int));\n  memset(&fio_old_sig_term, 0, sizeof(fio_old_sig_term));\n  memset(&fio_old_sig_pipe, 0, sizeof(fio_old_sig_pipe));\n  memset(&fio_old_sig_chld, 0, sizeof(fio_old_sig_chld));\n}", "target": 1}
{"code": "int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\tm->msg_iov = iov;\n\terr = 0;\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "gopherStateFree(const CommCloseCbParams &params)\n{\n    GopherStateData *gopherState = (GopherStateData *)params.data;\n    delete gopherState;\n}", "target": 1}
{"code": "static int count_channels(uint8_t (*layout)[3], int tags)\n{\n    int i, sum = 0;\n    for (i = 0; i < tags; i++) {\n        int syn_ele = layout[i][0];\n        int pos     = layout[i][2];\n        sum += (1 + (syn_ele == TYPE_CPE)) *\n               (pos != AAC_CHANNEL_OFF && pos != AAC_CHANNEL_CC);\n    }\n    return sum;\n}", "target": 0}
{"code": "SecureSocket::initContext(bool server)\n{\n    SSL_library_init();\n    const SSL_METHOD* method;\n    OpenSSL_add_all_algorithms();\n    SSL_load_error_strings();\n    if (CLOG->getFilter() >= kINFO) {\n        showSecureLibInfo();\n    }\n    if (server) {\n        method = SSLv23_server_method();\n    }\n    else {\n        method = SSLv23_client_method();\n    }\n    SSL_METHOD* m = const_cast<SSL_METHOD*>(method);\n    m_ssl->m_context = SSL_CTX_new(m);\n    SSL_CTX_set_options(m_ssl->m_context, SSL_OP_NO_SSLv3);\n    if (m_ssl->m_context == NULL) {\n        showError(\"\");\n    }\n    if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n        SSL_CTX_set_verify(m_ssl->m_context, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,\n                           nullptr);\n        SSL_CTX_set_cert_verify_callback(m_ssl->m_context, cert_verify_ignore_callback, nullptr);\n    }\n}", "target": 0}
{"code": "gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,\n                    const unsigned int new_height)\n{\n    const unsigned int src_width = src->sx;\n    const unsigned int src_height = src->sy;\n\tgdImagePtr tmp_im = NULL;\n\tgdImagePtr dst = NULL;\n    if (src_width == new_width && src_height == new_height) {\n        return gdImageClone(src);\n    }\n\tif (!src->trueColor) {\n\t\tgdImagePaletteToTrueColor(src);\n\t}\n    if (src_width == new_width) {\n        tmp_im = src;\n    } else {\n        tmp_im = gdImageCreateTrueColor(new_width, src_height);\n        if (tmp_im == NULL) {\n            return NULL;\n        }\n        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);\n        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);\n    }\n    if (src_height == new_height) {\n        assert(tmp_im != src);\n        return tmp_im;\n    }\n\tdst = gdImageCreateTrueColor(new_width, new_height);\n\tif (dst != NULL) {\n        gdImageSetInterpolationMethod(dst, src->interpolation_id);\n        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);\n    }\n    if (src != tmp_im) {\n        gdFree(tmp_im);\n    }\n\treturn dst;\n}", "target": 1}
{"code": "static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n\t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n\t\t\t}\n\t\t}\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n\t\t}\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, \n\t\t\t     0, \n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\tkfree(status_buf);\n\treturn rc;\n}", "target": 1}
{"code": "void sas_deform_port(struct asd_sas_phy *phy, int gone)\n{\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_internal *si =\n\t\tto_sas_internal(sas_ha->core.shost->transportt);\n\tstruct domain_device *dev;\n\tunsigned long flags;\n\tif (!port)\n\t\treturn;\t\t  \n\tdev = port->port_dev;\n\tif (dev)\n\t\tdev->pathways--;\n\tif (port->num_phys == 1) {\n\t\tsas_unregister_domain_devices(port, gone);\n\t\tsas_destruct_devices(port);\n\t\tsas_port_delete(port->port);\n\t\tport->port = NULL;\n\t} else {\n\t\tsas_port_delete_phy(port->port, phy->phy);\n\t\tsas_device_set_phy(dev, port->port);\n\t}\n\tif (si->dft->lldd_port_deformed)\n\t\tsi->dft->lldd_port_deformed(phy);\n\tspin_lock_irqsave(&sas_ha->phy_port_lock, flags);\n\tspin_lock(&port->phy_list_lock);\n\tlist_del_init(&phy->port_phy_el);\n\tsas_phy_set_target(phy, NULL);\n\tphy->port = NULL;\n\tport->num_phys--;\n\tport->phy_mask &= ~(1U << phy->id);\n\tif (port->num_phys == 0) {\n\t\tINIT_LIST_HEAD(&port->phy_list);\n\t\tmemset(port->sas_addr, 0, SAS_ADDR_SIZE);\n\t\tmemset(port->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\t\tport->class = 0;\n\t\tport->iproto = 0;\n\t\tport->tproto = 0;\n\t\tport->oob_mode = 0;\n\t\tport->phy_mask = 0;\n\t}\n\tspin_unlock(&port->phy_list_lock);\n\tspin_unlock_irqrestore(&sas_ha->phy_port_lock, flags);\n\treturn;\n}", "target": 0}
{"code": "static bool torture_winbind_struct_netbios_name(struct torture_context *torture)\n{\n\tstruct winbindd_response rep;\n\tconst char *expected;\n\tZERO_STRUCT(rep);\n\ttorture_comment(torture, \"Running WINBINDD_NETBIOS_NAME (struct based)\\n\");\n\tDO_STRUCT_REQ_REP(WINBINDD_NETBIOS_NAME, NULL, &rep);\n\texpected = torture_setting_string(torture,\n\t\t\t\t\t  \"winbindd_netbios_name\",\n\t\t\t\t\t  lpcfg_netbios_name(torture->lp_ctx));\n\texpected = strupper_talloc(torture, expected);\n\ttorture_assert_str_equal(torture,\n\t\t\t\t rep.data.netbios_name, expected,\n\t\t\t\t \"winbindd's netbios name doesn't match\");\n\treturn true;\n}", "target": 0}
{"code": "psf_close (SF_PRIVATE *psf)\n{\tuint32_t k ;\n\tint\terror = 0 ;\n\tif (psf->codec_close)\n\t{\terror = psf->codec_close (psf) ;\n\t\tpsf->codec_close = NULL ;\n\t\t} ;\n\tif (psf->container_close)\n\t\terror = psf->container_close (psf) ;\n\terror = psf_fclose (psf) ;\n\tpsf_close_rsrc (psf) ;\n\tfree (psf->header.ptr) ;\n\tfree (psf->container_data) ;\n\tfree (psf->codec_data) ;\n\tfree (psf->interleave) ;\n\tfree (psf->dither) ;\n\tfree (psf->peak_info) ;\n\tfree (psf->broadcast_16k) ;\n\tfree (psf->loop_info) ;\n\tfree (psf->instrument) ;\n\tfree (psf->cues) ;\n\tfree (psf->channel_map) ;\n\tfree (psf->format_desc) ;\n\tfree (psf->strings.storage) ;\n\tif (psf->wchunks.chunks)\n\t\tfor (k = 0 ; k < psf->wchunks.used ; k++)\n\t\t\tfree (psf->wchunks.chunks [k].data) ;\n\tfree (psf->rchunks.chunks) ;\n\tfree (psf->wchunks.chunks) ;\n\tfree (psf->iterator) ;\n\tfree (psf->cart_16k) ;\n\tmemset (psf, 0, sizeof (SF_PRIVATE)) ;\n\tfree (psf) ;\n\treturn error ;\n} ", "target": 0}
{"code": "bool CephXAuthorizer::add_challenge(CephContext *cct, bufferlist& challenge)\n{\n  bl = base_bl;\n  CephXAuthorize msg;\n  msg.nonce = nonce;\n  auto p = challenge.begin();\n  if (!p.end()) {\n    std::string error;\n    CephXAuthorizeChallenge ch;\n    decode_decrypt_enc_bl(cct, ch, session_key, challenge, error);\n    if (!error.empty()) {\n      ldout(cct, 0) << \"failed to decrypt challenge (\" << challenge.length() << \" bytes): \"\n\t\t    << error << dendl;\n      return false;\n    }\n    msg.have_challenge = true;\n    msg.server_challenge_plus_one = ch.server_challenge + 1;\n  }\n  std::string error;\n  if (encode_encrypt(cct, msg, session_key, bl, error)) {\n    ldout(cct, 0) << __func__ << \" failed to encrypt authorizer: \" << error << dendl;\n    return false;\n  }\n  return true;\n}", "target": 0}
{"code": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_realloc called with %x,%zu\\n\", ptr, size));\n\tresult = realloc(ptr, size);\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\n\treturn result;\n}", "target": 1}
{"code": "void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\n  decoder_info->width = get_flc(16, stream);\n  decoder_info->height = get_flc(16, stream);\n  decoder_info->log2_sb_size = get_flc(3, stream);\n  decoder_info->log2_sb_size = clip(decoder_info->log2_sb_size, log2i(MIN_BLOCK_SIZE), log2i(MAX_SB_SIZE));\n  decoder_info->pb_split = get_flc(1, stream);\n  decoder_info->tb_split_enable = get_flc(1, stream);\n  decoder_info->max_num_ref = get_flc(2, stream) + 1;\n  decoder_info->interp_ref = get_flc(2, stream);\n  decoder_info->max_delta_qp = get_flc(1, stream);\n  decoder_info->deblocking = get_flc(1, stream);\n  decoder_info->clpf = get_flc(1, stream);\n  decoder_info->use_block_contexts = get_flc(1, stream);\n  decoder_info->bipred = get_flc(2, stream);\n  decoder_info->qmtx = get_flc(1, stream);\n  if (decoder_info->qmtx) {\n    decoder_info->qmtx_offset = get_flc(6, stream) - 32;\n  }\n  decoder_info->subsample = get_flc(2, stream);\n    decoder_info->subsample = \n    (decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n    ((decoder_info->subsample & 3) == 3) * 2 + 400;\n  decoder_info->num_reorder_pics = get_flc(4, stream);\n  if (decoder_info->subsample != 400) {\n    decoder_info->cfl_intra = get_flc(1, stream);\n    decoder_info->cfl_inter = get_flc(1, stream);\n  }\n  decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->bitdepth == 10)\n    decoder_info->bitdepth += 2 * get_flc(1, stream);\n  decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->input_bitdepth == 10)\n    decoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}", "target": 0}
{"code": "CmdExtract::CmdExtract(CommandData *Cmd)\n{\n  CmdExtract::Cmd=Cmd;\n  *ArcName=0;\n  *DestFileName=0;\n  ArcAnalyzed=false;\n  Analyze=new AnalyzeData;\n  memset(Analyze,0,sizeof(*Analyze));\n  TotalFileCount=0;\n  UpLinkExtracted=false;\n  Unp=new Unpack(&DataIO);\n#ifdef RAR_SMP\n  Unp->SetThreads(Cmd->Threads);\n#endif\n}", "target": 0}
{"code": "  ErrorSslSocket(absl::string_view error) : error_(error) {}", "target": 0}
{"code": "SPL_METHOD(SplFileInfo, __construct)\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint len;\n\tzend_error_handling error_handling;\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &len) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 0}
{"code": "batchInit(batch_t *pBatch, int maxElem) {\n\tDEFiRet;\n\tpBatch->iDoneUpTo = 0;\n\tpBatch->maxElem = maxElem;\n\tCHKmalloc(pBatch->pElem = calloc((size_t)maxElem, sizeof(batch_obj_t)));\nfinalize_it:\n\tRETiRet;\n}", "target": 0}
{"code": "mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n{\n\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n\t\tfatal(\"%s: mm_zalloc(%u, %u)\", __func__, ncount, size);\n\treturn mm_malloc(mm, size * ncount);\n}", "target": 1}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n#define TF_LITE_CHECK_DIV_NON_ZERO(data_type)                       \\\n  const auto* input2_data = GetTensorData<data_type>(input2);       \\\n  const size_t input2_elements = input2->bytes / sizeof(data_type); \\\n  for (size_t i = 0; i < input2_elements; i++) {                    \\\n    TF_LITE_ENSURE(context, input2_data[i] != 0);                   \\\n  }\n  if (output->type == kTfLiteFloat32) {\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteInt32) {\n    TF_LITE_CHECK_DIV_NON_ZERO(int32_t);\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_CHECK_DIV_NON_ZERO(uint8_t);\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n#undef TF_LITE_CHECK_DIV_NON_ZERO\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void CreateWindowForRequest(const FrameLoadRequest& request,\n                            LocalFrame& opener_frame,\n                            NavigationPolicy policy) {\n  DCHECK(request.GetResourceRequest().RequestorOrigin() ||\n         (opener_frame.GetDocument() &&\n          opener_frame.GetDocument()->Url().IsEmpty()));\n  if (opener_frame.GetDocument()->PageDismissalEventBeingDispatched() !=\n      Document::kNoDismissal)\n    return;\n  if (opener_frame.GetDocument() &&\n      opener_frame.GetDocument()->IsSandboxed(kSandboxPopups))\n    return;\n  if (policy == kNavigationPolicyCurrentTab)\n    policy = kNavigationPolicyNewForegroundTab;\n  WebWindowFeatures features;\n  features.noopener = request.GetShouldSetOpener() == kNeverSetOpener;\n  bool created;\n  Frame* new_frame =\n      CreateWindowHelper(opener_frame, opener_frame, opener_frame, request,\n                         features, policy, created);\n  if (!new_frame)\n    return;\n  if (request.GetShouldSendReferrer() == kMaybeSendReferrer) {\n    if (new_frame->IsLocalFrame())\n      ToLocalFrame(new_frame)->GetDocument()->SetReferrerPolicy(\n          opener_frame.GetDocument()->GetReferrerPolicy());\n  }\n  FrameLoadRequest new_request(0, request.GetResourceRequest());\n  new_request.SetForm(request.Form());\n  if (new_frame->IsLocalFrame())\n    ToLocalFrame(new_frame)->Loader().Load(new_request);\n}", "target": 0}
{"code": "GF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\ts->size += 8;\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int __socket_slurp (RSocket *s, ut8 *buf, int bufsz) {\n\tint i;\n\tint chsz = 1;\n\tif (r_socket_read_block (s, (ut8 *) buf, 1) != 1) {\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < bufsz; i += chsz) {\n\t\tbuf[i] =0;\n\t\tr_socket_block_time (s, 1, 0, 1000);\n\t\tint olen = r_socket_read_block (s, (ut8 *) buf + i , chsz);\n\t\tif (olen != chsz) {\n\t\t\tbuf[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}", "target": 1}
{"code": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}", "target": 1}
{"code": "static bool too_many_pipe_buffers_hard(struct user_struct *user)\n{\n\treturn pipe_user_pages_hard &&\n\t       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_hard;\n}", "target": 0}
{"code": "const FunctionDef* FunctionLibraryDefinition::GetAttrImpl(\n    const NodeDef& ndef) const {\n  if (ndef.op() != kGradientOp) {\n    return Find(ndef.op());\n  }\n  const NameAttrList* forward_func_attrs;\n  if (!TryGetNodeAttr(ndef, kFuncAttr, &forward_func_attrs)) {\n    return nullptr;\n  }\n  const string& func_name = forward_func_attrs->name();\n  {\n    tf_shared_lock l(mu_);\n    const string& grad_name = FindGradientHelper(func_name);\n    if (!grad_name.empty()) {\n      if (const auto helper = FindHelper(grad_name)) {\n        return &(helper->fdef);\n      } else {\n        return nullptr;\n      }\n    }\n    if (const auto helper = FindHelper(func_name)) {\n      return &(helper->fdef);\n    } else {\n      return nullptr;\n    }\n  }\n}", "target": 0}
{"code": "static void netprobe_handler(int err, const struct netprobe_result *result,\n\t\t\t     void *arg)\n{\n\tstruct probe_entry *np;\n\tsize_t ix = (size_t)arg;\n\tif (err) {\n\t\twarning(\"netprobe failed (%m)\\n\", err);\n\t\tgoto out;\n\t}\n\tnp = &netprobev[ix];\n\tre_printf(\"Network Probe results for %s TURN%s-server at %J\\n\",\n\t\t  net_proto2name(np->proto),\n\t\t  np->secure ? \"S\" : \"\", &np->turn_srv);\n\tre_printf(\"    Average RTT:   %.1f milliseconds\\n\",\n\t\t  result->rtt_avg / 1000.0);\n\tre_printf(\"    transmitted:   %u packets\\n\", result->n_pkt_sent);\n\tre_printf(\"    received:      %u packets\\n\", result->n_pkt_recv);\n\tre_printf(\"\\n\");\n out:\n\tnetprobec_ok++;\n\tif (netprobec_ok >= netprobec) {\n\t\tinfo(\"netprobing done. shutting down..\\n\");\n\t\tengine_shutdown(engine);\n\t}\n}", "target": 0}
{"code": "static wStream* rdg_receive_packet(rdpRdg* rdg)\n{\n\twStream* s;\n\tconst size_t header = sizeof(RdgPacketHeader);\n\tsize_t packetLength;\n\tassert(header <= INT_MAX);\n\ts = Stream_New(NULL, 1024);\n\tif (!s)\n\t\treturn NULL;\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s), header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tStream_Seek(s, 4);\n\tStream_Read_UINT32(s, packetLength);\n\tif ((packetLength > INT_MAX) || !Stream_EnsureCapacity(s, packetLength))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tif (!rdg_read_all(rdg->tlsOut, Stream_Buffer(s) + header, (int)packetLength - (int)header))\n\t{\n\t\tStream_Free(s, TRUE);\n\t\treturn NULL;\n\t}\n\tStream_SetLength(s, packetLength);\n\treturn s;\n}", "target": 1}
{"code": "i915_gem_execbuffer2(struct drm_device *dev, void *data,\n\t\t     struct drm_file *file)\n{\n\tstruct drm_i915_gem_execbuffer2 *args = data;\n\tstruct drm_i915_gem_exec_object2 *exec2_list = NULL;\n\tint ret;\n\tif (args->buffer_count < 1) {\n\t\tDRM_DEBUG(\"execbuf2 with %d buffers\\n\", args->buffer_count);\n\t\treturn -EINVAL;\n\t}\n\texec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,\n\t\t\t     GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);\n\tif (exec2_list == NULL)\n\t\texec2_list = drm_malloc_ab(sizeof(*exec2_list),\n\t\t\t\t\t   args->buffer_count);\n\tif (exec2_list == NULL) {\n\t\tDRM_DEBUG(\"Failed to allocate exec list for %d buffers\\n\",\n\t\t\t  args->buffer_count);\n\t\treturn -ENOMEM;\n\t}\n\tret = copy_from_user(exec2_list,\n\t\t\t     (struct drm_i915_relocation_entry __user *)\n\t\t\t     (uintptr_t) args->buffers_ptr,\n\t\t\t     sizeof(*exec2_list) * args->buffer_count);\n\tif (ret != 0) {\n\t\tDRM_DEBUG(\"copy %d exec entries failed %d\\n\",\n\t\t\t  args->buffer_count, ret);\n\t\tdrm_free_large(exec2_list);\n\t\treturn -EFAULT;\n\t}\n\tret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);\n\tif (!ret) {\n\t\tret = copy_to_user((struct drm_i915_relocation_entry __user *)\n\t\t\t\t   (uintptr_t) args->buffers_ptr,\n\t\t\t\t   exec2_list,\n\t\t\t\t   sizeof(*exec2_list) * args->buffer_count);\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tDRM_DEBUG(\"failed to copy %d exec entries \"\n\t\t\t\t  \"back to user (%d)\\n\",\n\t\t\t\t  args->buffer_count, ret);\n\t\t}\n\t}\n\tdrm_free_large(exec2_list);\n\treturn ret;\n}", "target": 1}
{"code": "static u32 __ipv6_select_ident(struct net *net, u32 hashrnd,\n\t\t\t       const struct in6_addr *dst,\n\t\t\t       const struct in6_addr *src)\n{\n\tu32 hash, id;\n\thash = __ipv6_addr_jhash(dst, hashrnd);\n\thash = __ipv6_addr_jhash(src, hash);\n\thash ^= net_hash_mix(net);\n\tid = ip_idents_reserve(hash, 1);\n\tif (unlikely(!id))\n\t\tid = 1 << 31;\n\treturn id;\n}", "target": 1}
{"code": "nft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64(dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "format_SET_IP_ECN(const struct ofpact_ecn *a,\n                  const struct ofpact_format_params *fp)\n{\n    ds_put_format(fp->s, \"%smod_nw_ecn:%s%d\",\n                  colors.param, colors.end, a->ecn);\n}", "target": 0}
{"code": "Bool gf_isom_is_self_contained(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\treturn Media_IsSelfContained(trak->Media, sampleDescriptionIndex);\n}", "target": 0}
{"code": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t\tseqf->private = NULL;\n\t}\n}", "target": 0}
{"code": "static int pdf_findobj(struct pdf_struct *pdf)\n{\n    const char *start, *q, *q2, *q3, *eof;\n    struct pdf_obj *obj;\n    off_t bytesleft;\n    unsigned genid, objid;\n    pdf->nobjs++;\n    pdf->objs = cli_realloc2(pdf->objs, sizeof(*pdf->objs)*pdf->nobjs);\n    if (!pdf->objs) {\n\tcli_warnmsg(\"cli_pdf: out of memory parsing objects (%u)\\n\", pdf->nobjs);\n\treturn -1;\n    }\n    obj = &pdf->objs[pdf->nobjs-1];\n    memset(obj, 0, sizeof(*obj));\n    start = pdf->map+pdf->offset;\n    bytesleft = pdf->size - pdf->offset;\n    q2 = cli_memstr(start, bytesleft, \" obj\", 4);\n    if (!q2)\n\treturn 0;\n    bytesleft -= q2 - start;\n    q = findNextNonWSBack(q2-1, start);\n    while (q > start && isdigit(*q)) { q--; }\n    genid = atoi(q);\n    q = findNextNonWSBack(q-1,start);\n    while (q > start && isdigit(*q)) { q--; }\n    objid = atoi(q);\n    obj->id = (objid << 8) | (genid&0xff);\n    obj->start = q2+4 - pdf->map;\n    obj->flags = 0;\n    bytesleft -= 4;\n    eof = pdf->map + pdf->size;\n    q = pdf->map + obj->start;\n    while (q < eof && bytesleft > 0) {\n\toff_t p_stream, p_endstream;\n\tq2 = pdf_nextobject(q, bytesleft);\n\tif (!q2)\n\t    return 0;\n\tbytesleft -= q2 - q;\n\tif (find_stream_bounds(q-1, q2-q, bytesleft + (q2-q), &p_stream, &p_endstream)) {\n\t    obj->flags |= 1 << OBJ_STREAM;\n\t    q2 = q-1 + p_endstream + 6;\n\t    bytesleft -= q2 - q + 1;\n\t} else if ((q3 = cli_memstr(q-1, q2-q+1, \"endobj\", 6))) {\n\t    q2 = q3 + 6;\n\t    pdf->offset = q2 - pdf->map;\n\t    return 1; \n\t} else {\n\t    q2++;\n\t}\n\tq = q2;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void HttpMultiBufHeaderThreadDataFree(void *data)\n{\n    HttpMultiBufHeaderThreadData *td = data;\n    for (size_t i = 0; i < td->cap; i++) {\n        SCFree(td->items[i].buffer);\n    }\n    SCFree(td->items);\n    SCFree(td);\n}", "target": 0}
{"code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}", "target": 1}
{"code": "int BN_bn2bin(const BIGNUM *a, unsigned char *to)\n{\n    return bn2binpad(a, to, -1);\n}", "target": 0}
{"code": "static void fio_cluster_client_handler(struct cluster_pr_s *pr) {\n  switch ((fio_cluster_message_type_e)pr->type) {\n  case FIO_CLUSTER_MSG_FORWARD: \n  case FIO_CLUSTER_MSG_JSON:\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n  case FIO_CLUSTER_MSG_SHUTDOWN:\n    fio_stop();\n    kill(getpid(), SIGINT);\n  case FIO_CLUSTER_MSG_ERROR:         \n  case FIO_CLUSTER_MSG_PING:          \n  case FIO_CLUSTER_MSG_ROOT:          \n  case FIO_CLUSTER_MSG_ROOT_JSON:     \n  case FIO_CLUSTER_MSG_PUBSUB_SUB:    \n  case FIO_CLUSTER_MSG_PUBSUB_UNSUB:  \n  case FIO_CLUSTER_MSG_PATTERN_SUB:   \n  case FIO_CLUSTER_MSG_PATTERN_UNSUB: \n  default:\n    break;\n  }\n}", "target": 0}
{"code": "clientHierarchical(ClientHttpRequest * http)\n{\n    HttpRequest *request = http->request;\n    HttpRequestMethod method = request->method;\n    if (!request->flags.hostVerified && (request->flags.intercepted || request->flags.interceptTproxy))\n        return 0;\n    if (request->flags.ims && !neighbors_do_private_keys)\n        return 0;\n    if (request->flags.auth)\n        return 0;\n    if (method == Http::METHOD_TRACE)\n        return 1;\n    if (method != Http::METHOD_GET)\n        return 0;\n    if (request->flags.loopDetected)\n        return 0;\n    if (request->url.getScheme() == AnyP::PROTO_HTTP)\n        return method.respMaybeCacheable();\n    if (request->url.getScheme() == AnyP::PROTO_GOPHER)\n        return gopherCachable(request);\n    if (request->url.getScheme() == AnyP::PROTO_CACHE_OBJECT)\n        return 0;\n    return 1;\n}", "target": 1}
{"code": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}", "target": 1}
{"code": "  void operator()(OpKernelContext* ctx, bool use_cudnn, bool cudnn_use_autotune,\n                  const Tensor& input, const Tensor& filter, int row_dilation,\n                  int col_dilation, int row_stride, int col_stride,\n                  const Padding& padding,\n                  const std::vector<int64>& explicit_paddings, Tensor* output,\n                  TensorFormat data_format) {\n    if (data_format != FORMAT_NHWC) {\n      ctx->SetStatus(errors::Unimplemented(\n          \"The Conv2D op currently only supports the NHWC tensor format on the \"\n          \"CPU. The op was given the format: \",\n          ToString(data_format)));\n      return;\n    }\n    for (int64 explicit_padding : explicit_paddings) {\n      if (!FastBoundsCheck(explicit_padding, std::numeric_limits<int>::max())) {\n        ctx->SetStatus(errors::InvalidArgument(\"filter too large\"));\n        return;\n      }\n    }\n    const int64 in_depth = input.dim_size(3);\n    const int64 out_depth = output->dim_size(3);\n    const int64 patch_depth = filter.dim_size(2);\n    if (patch_depth <= 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"filter depth must be stricly positive, got \", patch_depth));\n      return;\n    }\n    if (in_depth % patch_depth != 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"input depth must be evenly divisible by filter depth: \", in_depth,\n          \" vs \", patch_depth));\n      return;\n    }\n    const int64 num_groups = in_depth / patch_depth;\n    if (num_groups <= 0) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"number of groups must be stricly positive, got \", num_groups));\n      return;\n    }\n    if (out_depth % num_groups != 0 || out_depth < num_groups) {\n      ctx->SetStatus(errors::InvalidArgument(\n          \"output depth must be evenly divisible by number of groups: \",\n          out_depth, \" vs \", num_groups));\n      return;\n    }\n    if (in_depth != patch_depth) {\n      LaunchGrouped<T>()(ctx, input, filter, row_stride, col_stride,\n                         row_dilation, col_dilation, padding, explicit_paddings,\n                         output, data_format);\n    } else {\n      LaunchGeneric<CPUDevice, T>()(ctx, input, filter, row_stride, col_stride,\n                                    row_dilation, col_dilation, padding,\n                                    explicit_paddings, output, data_format);\n    }\n  }", "target": 0}
{"code": "int nfc_llcp_send_symm(struct nfc_dev *dev)\n{\n\tstruct sk_buff *skb;\n\tstruct nfc_llcp_local *local;\n\tu16 size = 0;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tsize += LLCP_HEADER_SIZE;\n\tsize += dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\tskb = llcp_add_header(skb, 0, 0, LLCP_PDU_SYMM);\n\t__net_timestamp(skb);\n\tnfc_llcp_send_to_raw_sock(local, skb, NFC_DIRECTION_TX);\n\treturn nfc_data_exchange(dev, local->target_idx, skb,\n\t\t\t\t nfc_llcp_recv, local);\n}", "target": 1}
{"code": "ssize_t enc_untrusted_recvmsg(int sockfd, struct msghdr *msg, int flags) {\n  size_t total_buffer_size = CalculateTotalMessageSize(msg);\n  MessageWriter input;\n  input.Push(sockfd);\n  input.Push<uint64_t>(msg->msg_namelen);\n  input.Push<uint64_t>(total_buffer_size);\n  input.Push<uint64_t>(msg->msg_controllen);\n  input.Push(msg->msg_flags);\n  input.Push(flags);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kRecvMsgHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_recvmsg\", 2,\n                           false);\n  ssize_t result = output.next<ssize_t>();\n  int klinux_errno = output.next<int>();\n  if (result == -1) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return result;\n  }\n  if (result > total_buffer_size) {\n    ::asylo::primitives::TrustedPrimitives::BestEffortAbort(\n        \"enc_untrusted_recvmsg: result exceeds requested\");\n  }\n  auto msg_name_extent = output.next();\n  if (msg_name_extent.size() <= msg->msg_namelen) {\n    msg->msg_namelen = msg_name_extent.size();\n  }\n  memcpy(msg->msg_name, msg_name_extent.As<char>(), msg->msg_namelen);\n  auto msg_iov_extent = output.next();\n  size_t total_bytes = msg_iov_extent.size();\n  size_t bytes_copied = 0;\n  for (int i = 0; i < msg->msg_iovlen && bytes_copied < total_bytes; ++i) {\n    size_t bytes_to_copy =\n        std::min(msg->msg_iov[i].iov_len, total_bytes - bytes_copied);\n    memcpy(msg->msg_iov[i].iov_base, msg_iov_extent.As<char>() + bytes_copied,\n           bytes_to_copy);\n    bytes_copied += bytes_to_copy;\n  }\n  auto msg_control_extent = output.next();\n  if (msg_control_extent.size() <= msg->msg_controllen) {\n    msg->msg_controllen = msg_control_extent.size();\n  }\n  memcpy(msg->msg_control, msg_control_extent.As<char>(), msg->msg_controllen);\n  return result;\n}", "target": 0}
{"code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        sq_reservestack(_thread(o), nparams + 3);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "target": 0}
{"code": "Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}", "target": 1}
{"code": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}", "target": 0}
{"code": "absl::Status Ipv4Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv4 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "  const std::string& get_tenant() const {\n    ceph_assert(t != Wildcard);\n    return u.tenant;\n  }", "target": 1}
{"code": "static MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n{\n  FILE\n    *input,\n    *output;\n  int\n    c;\n  register ssize_t\n    i;\n  if (ExpandFilenames(&argc,&argv) == MagickFalse)\n    ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n  output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n    input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n        ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n        continue;\n      }\n    for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n    (void) fclose(input);\n    (void) remove_utf8(argv[i]);\n  }\n  (void) fclose(output);\n  return(MagickTrue);\n}", "target": 1}
{"code": "int virtio_gpu_object_create(struct virtio_gpu_device *vgdev,\n\t\t\t     unsigned long size, bool kernel, bool pinned,\n\t\t\t     struct virtio_gpu_object **bo_ptr)\n{\n\tstruct virtio_gpu_object *bo;\n\tenum ttm_bo_type type;\n\tsize_t acc_size;\n\tint ret;\n\tif (kernel)\n\t\ttype = ttm_bo_type_kernel;\n\telse\n\t\ttype = ttm_bo_type_device;\n\t*bo_ptr = NULL;\n\tacc_size = ttm_bo_dma_acc_size(&vgdev->mman.bdev, size,\n\t\t\t\t       sizeof(struct virtio_gpu_object));\n\tbo = kzalloc(sizeof(struct virtio_gpu_object), GFP_KERNEL);\n\tif (bo == NULL)\n\t\treturn -ENOMEM;\n\tsize = roundup(size, PAGE_SIZE);\n\tret = drm_gem_object_init(vgdev->ddev, &bo->gem_base, size);\n\tif (ret != 0)\n\t\treturn ret;\n\tbo->dumb = false;\n\tvirtio_gpu_init_ttm_placement(bo, pinned);\n\tret = ttm_bo_init(&vgdev->mman.bdev, &bo->tbo, size, type,\n\t\t\t  &bo->placement, 0, !kernel, NULL, acc_size,\n\t\t\t  NULL, NULL, &virtio_gpu_ttm_bo_destroy);\n\tif (ret != 0)\n\t\treturn ret;\n\t*bo_ptr = bo;\n\treturn 0;\n}", "target": 1}
{"code": "alloc_compspace(isc_httpd_t *httpd, unsigned int size) {\n\tchar *newspace = NULL;\n\tisc_region_t r;\n\tisc_buffer_region(&httpd->compbuffer, &r);\n\tif (size < r.length) {\n\t\treturn;\n\t}\n\tnewspace = isc_mem_get(httpd->mgr->mctx, size);\n\tisc_buffer_reinit(&httpd->compbuffer, newspace, size);\n\tif (r.base != NULL) {\n\t\tisc_mem_put(httpd->mgr->mctx, r.base, r.length);\n\t}\n}", "target": 0}
{"code": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldl_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "void SetGray(double grayscale,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f G\",grayscale);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f g\",grayscale);\n    }\n}", "target": 1}
{"code": "static inline void get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tVM_BUG_ON_PAGE(page_ref_count(page) <= 0, page);\n\tpage_ref_inc(page);\n}", "target": 1}
{"code": "void ConnectionImpl::onHeaderValue(const char* data, size_t length) {\n  if (header_parsing_state_ == HeaderParsingState::Done) {\n    return;\n  }\n  const absl::string_view header_value = absl::string_view(data, length);\n  if (strict_header_validation_) {\n    if (!Http::HeaderUtility::headerIsValid(header_value)) {\n      ENVOY_CONN_LOG(debug, \"invalid header value: {}\", connection_, header_value);\n      error_code_ = Http::Code::BadRequest;\n      sendProtocolError();\n      throw CodecProtocolException(\"http/1.1 protocol error: header value contains invalid chars\");\n    }\n  } else if (header_value.find('\\0') != absl::string_view::npos) {\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n  const uint32_t total =\n      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}", "target": 1}
{"code": "Pl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    getNext()->write(outbuf, this->pos - 1);\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n}", "target": 1}
{"code": "struct sock *inet_csk_clone_lock(const struct sock *sk,\n\t\t\t\t const struct request_sock *req,\n\t\t\t\t const gfp_t priority)\n{\n\tstruct sock *newsk = sk_clone_lock(sk, priority);\n\tif (newsk) {\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\t\tnewsk->sk_state = TCP_SYN_RECV;\n\t\tnewicsk->icsk_bind_hash = NULL;\n\t\tinet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;\n\t\tinet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;\n\t\tinet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);\n\t\tnewsk->sk_write_space = sk_stream_write_space;\n\t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n\t\tinet_sk(newsk)->mc_list = NULL;\n\t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n\t\tatomic64_set(&newsk->sk_cookie,\n\t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));\n\t\tnewicsk->icsk_retransmits = 0;\n\t\tnewicsk->icsk_backoff\t  = 0;\n\t\tnewicsk->icsk_probes_out  = 0;\n\t\tmemset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));\n\t\tsecurity_inet_csk_clone(newsk, req);\n\t}\n\treturn newsk;\n}", "target": 0}
{"code": "static void cleanup_timers(struct list_head *head,\n\t\t\t   cputime_t utime, cputime_t stime,\n\t\t\t   unsigned long long sum_exec_runtime)\n{\n\tstruct cpu_timer_list *timer, *next;\n\tcputime_t ptime = cputime_add(utime, stime);\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (cputime_lt(timer->expires.cpu, ptime)) {\n\t\t\ttimer->expires.cpu = cputime_zero;\n\t\t} else {\n\t\t\ttimer->expires.cpu = cputime_sub(timer->expires.cpu,\n\t\t\t\t\t\t\t ptime);\n\t\t}\n\t}\n\t++head;\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (cputime_lt(timer->expires.cpu, utime)) {\n\t\t\ttimer->expires.cpu = cputime_zero;\n\t\t} else {\n\t\t\ttimer->expires.cpu = cputime_sub(timer->expires.cpu,\n\t\t\t\t\t\t\t utime);\n\t\t}\n\t}\n\t++head;\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (timer->expires.sched < sum_exec_runtime) {\n\t\t\ttimer->expires.sched = 0;\n\t\t} else {\n\t\t\ttimer->expires.sched -= sum_exec_runtime;\n\t\t}\n\t}\n}", "target": 0}
{"code": "v8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    event = CreateEvent(isolate);\n  }\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}", "target": 1}
{"code": "pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)\n{\n\tInitializeCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "static void reds_update_agent_properties(RedsState *reds)\n{\n    if (!reds->agent_dev || reds->config == NULL) {\n        return;\n    }\n    reds->agent_dev->priv->write_filter.copy_paste_enabled = reds->config->agent_copypaste;\n    reds->agent_dev->priv->read_filter.copy_paste_enabled = reds->config->agent_copypaste;\n    reds->agent_dev->priv->write_filter.file_xfer_enabled = reds->config->agent_file_xfer;\n    reds->agent_dev->priv->read_filter.file_xfer_enabled = reds->config->agent_file_xfer;\n}", "target": 0}
{"code": "static unsigned long mb2_cache_count(struct shrinker *shrink,\n\t\t\t\t     struct shrink_control *sc)\n{\n\tstruct mb2_cache *cache = container_of(shrink, struct mb2_cache,\n\t\t\t\t\t       c_shrink);\n\treturn cache->c_entry_count;\n}", "target": 0}
{"code": "cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)\n{\n    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));\n    if (v == NULL) return NULL;\n    v ->List      = NULL;\n    v ->nColors   = 0;\n    v ->ContextID  = ContextID;\n    while (v -> Allocated < n)\n        GrowNamedColorList(v);\n    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));\n    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));\n    v->Prefix[32] = v->Suffix[32] = 0;\n    v -> ColorantCount = ColorantCount;\n    return v;\n}", "target": 1}
{"code": "read_mysql_variables_from_result(MYSQL_RES *mysql_result, mysql_variable *vars,\n\tbool vertical_result)\n{\n\tMYSQL_ROW row;\n\tmysql_variable *var;\n\tut_ad(!vertical_result || mysql_num_fields(mysql_result) == 2);\n\tint rows_read = 0;\n\tif (vertical_result) {\n\t\twhile ((row = mysql_fetch_row(mysql_result))) {\n\t\t\t++rows_read;\n\t\t\tchar *name = row[0];\n\t\t\tchar *value = row[1];\n\t\t\tfor (var = vars; var->name; var++) {\n\t\t\t\tif (strcmp(var->name, name) == 0\n\t\t\t\t    && value != NULL) {\n\t\t\t\t\t*(var->value) = strdup(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tMYSQL_FIELD *field;\n\t\tif ((row = mysql_fetch_row(mysql_result)) != NULL) {\n\t\t\tmysql_field_seek(mysql_result, 0);\n\t\t\t++rows_read;\n\t\t\tint i = 0;\n\t\t\twhile ((field = mysql_fetch_field(mysql_result))\n\t\t\t\t!= NULL) {\n\t\t\t\tchar *name = field->name;\n\t\t\t\tchar *value = row[i];\n\t\t\t\tfor (var = vars; var->name; var++) {\n\t\t\t\t\tif (strcmp(var->name, name) == 0\n\t\t\t\t\t    && value != NULL) {\n\t\t\t\t\t\t*(var->value) = strdup(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++i;\n\t\t\t}\n\t\t}\n\t}\n\treturn rows_read;\n}", "target": 0}
{"code": "static GF_Err gf_isom_set_root_iod(GF_ISOFile *movie)\n{\n\tGF_IsomInitialObjectDescriptor *iod;\n\tGF_IsomObjectDescriptor *od;\n\tGF_Err e;\n\te = gf_isom_insert_moov(movie);\n\tif (e) return e;\n\tif (!movie->moov->iods) {\n\t\tAddMovieIOD(movie->moov, 1);\n\t\treturn GF_OK;\n\t}\n\tif (movie->moov->iods->descriptor->tag == GF_ODF_ISOM_IOD_TAG) return GF_OK;\n\tod = (GF_IsomObjectDescriptor *) movie->moov->iods->descriptor;\n\tiod = (GF_IsomInitialObjectDescriptor*)gf_malloc(sizeof(GF_IsomInitialObjectDescriptor));\n\tif (!iod) return GF_OUT_OF_MEM;\n\tmemset(iod, 0, sizeof(GF_IsomInitialObjectDescriptor));\n\tiod->ES_ID_IncDescriptors = od->ES_ID_IncDescriptors;\n\tod->ES_ID_IncDescriptors = NULL;\n\tiod->ES_ID_RefDescriptors = NULL;\n\tiod->extensionDescriptors = od->extensionDescriptors;\n\tod->extensionDescriptors = NULL;\n\tiod->IPMP_Descriptors = od->IPMP_Descriptors;\n\tod->IPMP_Descriptors = NULL;\n\tiod->objectDescriptorID = od->objectDescriptorID;\n\tiod->OCIDescriptors = od->OCIDescriptors;\n\tod->OCIDescriptors = NULL;\n\tiod->tag = GF_ODF_ISOM_IOD_TAG;\n\tiod->URLString = od->URLString;\n\tod->URLString = NULL;\n\tgf_odf_desc_del((GF_Descriptor *) od);\n\tmovie->moov->iods->descriptor = (GF_Descriptor *)iod;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static bool io_wq_for_each_worker(struct io_wqe *wqe,\n\t\t\t\t  bool (*func)(struct io_worker *, void *),\n\t\t\t\t  void *data)\n{\n\tstruct io_worker *worker;\n\tbool ret = false;\n\tlist_for_each_entry_rcu(worker, &wqe->all_list, all_list) {\n\t\tif (io_worker_get(worker)) {\n\t\t\tif (worker->task)\n\t\t\t\tret = func(worker, data);\n\t\t\tio_worker_release(worker);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "FILE *fopen_safe(const char *path, const char *mode)\n{\n\tint fd;\n\tFILE *file;\n\tint flags = O_NOFOLLOW | O_CREAT;\n\tif (mode[0] == 'r')\n\t\treturn fopen(path, mode);\n\tif (mode[0] != 'a' && mode[0] != 'w')\n\t\treturn NULL;\n\tif (mode[1] &&\n\t    (mode[1] != '+' || mode[2]))\n\t\treturn NULL;\n\tif (mode[0] == 'w')\n\t\tflags |= O_TRUNC;\n\telse\n\t\tflags |= O_APPEND;\n\tif (mode[1])\n\t\tflags |= O_RDWR;\n\telse\n\t\tflags |= O_WRONLY;\n\tfd = open(path, flags, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\tif (fd == -1)\n\t\treturn NULL;\n\tfile = fdopen (fd, \"w\");\n\tif (!file) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 0}
{"code": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}", "target": 1}
{"code": "createFile(const string &filename, const StaticString &contents, mode_t permissions, uid_t owner,\n\tgid_t group, bool overwrite)\n{\n\tFileDescriptor fd;\n\tint ret, e, options;\n\toptions = O_WRONLY | O_CREAT | O_TRUNC;\n\tif (!overwrite) {\n\t\toptions |= O_EXCL;\n\t}\n\tdo {\n\t\tfd = open(filename.c_str(), options, permissions);\n\t} while (fd == -1 && errno == EINTR);\n\tif (fd != -1) {\n\t\tFileGuard guard(filename);\n\t\tdo {\n\t\t\tret = fchmod(fd, permissions);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\te = errno;\n\t\t\tthrow FileSystemException(\"Cannot set permissions on \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = fchown(fd, owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\te = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot set ownership for \" + filename,\n\t\t\t\t\te, filename);\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\twriteExact(fd, contents);\n\t\t\tfd.close();\n\t\t} catch (const SystemException &e) {\n\t\t\tthrow FileSystemException(\"Cannot write to file \" + filename,\n\t\t\t\te.code(), filename);\n\t\t}\n\t\tguard.commit();\n\t} else {\n\t\te = errno;\n\t\tif (overwrite || e != EEXIST) {\n\t\t\tthrow FileSystemException(\"Cannot create file \" + filename,\n\t\t\t\te, filename);\n\t\t}\n\t}\n}", "target": 0}
{"code": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->process_keyring)\n\t\treturn -EEXIST;\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->process_keyring = keyring;\n\treturn 0;\n}", "target": 1}
{"code": "static int openssl_static_locks_install(void)\n{\n    int result;\n    if (openssl_locks != NULL)\n    {\n        LogInfo(\"Locks already initialized\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        openssl_locks = malloc(CRYPTO_num_locks() * sizeof(LOCK_HANDLE));\n        if (openssl_locks == NULL)\n        {\n            LogError(\"Failed to allocate locks\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            int i;\n            for (i = 0; i < CRYPTO_num_locks(); i++)\n            {\n                openssl_locks[i] = Lock_Init();\n                if (openssl_locks[i] == NULL)\n                {\n                    LogError(\"Failed to allocate lock %d\", i);\n                    break;\n                }\n            }\n            if (i != CRYPTO_num_locks())\n            {\n                int j;\n                for (j = 0; j < i; j++)\n                {\n                    Lock_Deinit(openssl_locks[j]);\n                }\n                result = MU_FAILURE;\n            }\n            else\n            {\n                CRYPTO_set_locking_callback(openssl_static_locks_lock_unlock_cb);\n                result = 0;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "PHP_FUNCTION(imagetruecolortopalette)\n{\n\tzval *IM;\n\tzend_bool dither;\n\tzend_long ncolors;\n\tgdImagePtr im;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rbl\", &IM, &dither, &ncolors) == FAILURE)  {\n\t\treturn;\n\t}\n\tif ((im = (gdImagePtr)zend_fetch_resource(Z_RES_P(IM), \"Image\", le_gd)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (ncolors <= 0) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Number of colors has to be greater than zero\");\n\t\tRETURN_FALSE;\n\t}\n\tgdImageTrueColorToPalette(im, dither, ncolors);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}", "target": 1}
{"code": "void nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "exif_data_load_data_thumbnail (ExifData *data, const unsigned char *d,\n\t\t\t       unsigned int ds, ExifLong o, ExifLong s)\n{\n\tif ((o + s < o) || (o + s < s) || (o + s > ds) || (o > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t  \"Bogus thumbnail offset (%u) or size (%u).\",\n\t\t\t  o, s);\n\t\treturn;\n\t}\n\tif (data->data) \n\t\texif_mem_free (data->priv->mem, data->data);\n\tif (!(data->data = exif_data_alloc (data, s))) {\n\t\tEXIF_LOG_NO_MEMORY (data->priv->log, \"ExifData\", s);\n\t\tdata->size = 0;\n\t\treturn;\n\t}\n\tdata->size = s;\n\tmemcpy (data->data, d + o, s);\n}", "target": 1}
{"code": "pci_lintr_deassert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == ASSERTED) {\n\t\tdev->lintr.state = IDLE;\n\t\tpci_irq_deassert(dev);\n\t} else if (dev->lintr.state == PENDING)\n\t\tdev->lintr.state = IDLE;\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "int crxFreeImageData(CrxImage *img)\n{\n  CrxTile *tile = img->tiles;\n  int nTiles = img->tileRows * img->tileCols;\n  if (img->tiles)\n  {\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\n      if (tile[curTile].comps)\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\n    free(img->tiles);\n    img->tiles = 0;\n  }\n  if (img->planeBuf)\n  {\n    free(img->planeBuf);\n    img->planeBuf = 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "MONGO_EXPORT void *bson_malloc( int size ) {\n    void *p;\n    p = bson_malloc_func( size );\n    bson_fatal_msg( !!p, \"malloc() failed\" );\n    return p;\n}", "target": 1}
{"code": "\tCmdResult Handle (const std::vector<std::string>& parameters, User *user)\n\t{\n\t\tif (user->registered != REG_ALL)\n\t\t{\n\t\t\tif (!cap.ext.get(user))\n\t\t\t\treturn CMD_FAILURE;\n\t\t\tif (parameters[0].find(' ') != std::string::npos || parameters[0][0] == ':')\n\t\t\t\treturn CMD_FAILURE;\n\t\t\tSaslAuthenticator *sasl = authExt.get(user);\n\t\t\tif (!sasl)\n\t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0]));\n\t\t\telse if (sasl->SendClientMessage(parameters) == false)\t\n\t\t\t{\n\t\t\t\tsasl->AnnounceState();\n\t\t\t\tauthExt.unset(user);\n\t\t\t}\n\t\t}\n\t\treturn CMD_FAILURE;\n\t}", "target": 0}
{"code": "void HttpIntegrationTest::testLargeRequestTrailers(uint32_t size, uint32_t max_size) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });\n  max_request_headers_kb_ = max_size;\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  request_trailers.addCopy(\"big\", std::string(size * 1024, 'a'));\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendData(*request_encoder_, 10, false);\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  if (size >= max_size && downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n    response->waitForReset();\n    codec_client_->close();\n    EXPECT_FALSE(response->complete());\n  } else {\n    waitForNextUpstreamRequest();\n    upstream_request_->encodeHeaders(default_response_headers_, true);\n    response->waitForEndStream();\n    EXPECT_TRUE(response->complete());\n  }\n}", "target": 0}
{"code": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tint error = -EACCES;\n\tpath_put(&nd->path);\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &nd->path);\n\tnd->last_type = LAST_BIND;\nout:\n\treturn ERR_PTR(error);\n}", "target": 1}
{"code": "TfLiteStatus EvalSimple(TfLiteContext* context, TfLiteNode* node,\n                        const TfLiteTensor* lookup, const TfLiteTensor* value,\n                        TfLiteTensor* output) {\n  const int row_size = SizeOfDimension(value, 0);\n  if (row_size == 0) {\n    return kTfLiteOk;\n  }\n  const int row_bytes = value->bytes / row_size;\n  char* output_raw = GetTensorData<char>(output);\n  const char* value_raw = GetTensorData<char>(value);\n  const int32_t* lookup_data = GetTensorData<int32_t>(lookup);\n  for (int i = 0; i < SizeOfDimension(lookup, 0); i++) {\n    int idx = lookup_data[i];\n    if (idx >= row_size || idx < 0) {\n      context->ReportError(context,\n                           \"Embedding Lookup: index out of bounds. \"\n                           \"Got %d, and bounds are [0, %d]\",\n                           idx, row_size - 1);\n      return kTfLiteError;\n    } else {\n      std::memcpy(output_raw + i * row_bytes, value_raw + idx * row_bytes,\n                  row_bytes);\n    }\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\treturn ip_local_out(skb);\n}", "target": 1}
{"code": "l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) final {\n    const Tensor& superdiag = context->input(0);\n    const Tensor& maindiag = context->input(1);\n    const Tensor& subdiag = context->input(2);\n    const Tensor& rhs = context->input(3);\n    const int ndims = rhs.dims();\n    OP_REQUIRES(\n        context, ndims >= 2,\n        errors::InvalidArgument(\"Input must have rank >= 2, but got \", ndims));\n    OP_REQUIRES_OK(context, ValidateInputTensor(superdiag, \"superdiag\", rhs));\n    OP_REQUIRES_OK(context, ValidateInputTensor(maindiag, \"maindiag\", rhs));\n    OP_REQUIRES_OK(context, ValidateInputTensor(subdiag, \"subdiag\", rhs));\n    int64 batch_size = 1;\n    for (int i = 0; i < ndims - 2; i++) {\n      batch_size *= rhs.dim_size(i);\n    }\n    const int m = rhs.dim_size(ndims - 2);\n    const int n = rhs.dim_size(ndims - 1);\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, rhs.shape(), &output));\n    const Eigen::GpuDevice& device = context->eigen_device<Eigen::GpuDevice>();\n    GpuLaunchConfig cfg = GetGpuLaunchConfig(1, device);\n    TF_CHECK_OK(GpuLaunchKernel(\n        TridiagonalMatMulKernel<Scalar>, cfg.block_count, cfg.thread_per_block,\n        0, device.stream(), batch_size, m, n, superdiag.flat<Scalar>().data(),\n        maindiag.flat<Scalar>().data(), subdiag.flat<Scalar>().data(),\n        rhs.flat<Scalar>().data(), output->flat<Scalar>().data()));\n  }", "target": 0}
{"code": "_PUBLIC_ char **file_lines_load(const char *fname, int *numlines, size_t maxsize, TALLOC_CTX *mem_ctx)\n{\n\tchar *p;\n\tsize_t size;\n\tp = file_load(fname, &size, maxsize, mem_ctx);\n\tif (!p) return NULL;\n\treturn file_lines_parse(p, size, numlines, mem_ctx);\n}", "target": 0}
{"code": "void posixtimer_rearm(struct siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\tif (timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1;\n\t\t++timr->it_requeue_pending;\n\t\tinfo->si_overrun += timr->it_overrun_last;\n\t}\n\tunlock_timer(timr, flags);\n}", "target": 1}
{"code": "static int clgi_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 3;\n\tskip_emulated_instruction(&svm->vcpu);\n\tdisable_gif(svm);\n\tsvm_clear_vintr(svm);\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\treturn 1;\n}", "target": 0}
{"code": "static uint64_t HTPStateGetTxCnt(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        const int64_t size = (int64_t)htp_list_size(http_state->conn->transactions);\n        if (size < 0)\n            return 0ULL;\n        SCLogDebug(\"size %\"PRIu64, size);\n        return (uint64_t)size;\n    } else {\n        return 0ULL;\n    }\n}", "target": 1}
{"code": "scrypt_SHA256_Final(unsigned char digest[32], struct SHA256_CTX * ctx)\n{\n  SHA256_Pad(ctx);\n  be32enc_vect(digest, ctx->state, 32);\n  memset((void *)ctx, 0, sizeof(*ctx));\n}", "target": 1}
{"code": "write_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);\n\t\tstrs = backtrace_symbols(buffer, nptrs);\n\t\tif (strs == NULL) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get stack backtrace\");\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 1; i < nptrs - 2; i++)\n\t\t\tlog_message(LOG_INFO, \"  %s\", strs[i]);\n\t\tfree(strs);\n\t}\n}", "target": 1}
{"code": "njs_function_prototype_apply(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    int64_t         i, length;\n    njs_int_t       ret;\n    njs_frame_t     *frame;\n    njs_value_t     *this, *arr_like;\n    njs_array_t     *arr;\n    njs_function_t  *func;\n    if (!njs_is_function(njs_argument(args, 0))) {\n        njs_type_error(vm, \"\\\"this\\\" argument is not a function\");\n        return NJS_ERROR;\n    }\n    func = njs_function(njs_argument(args, 0));\n    this = njs_arg(args, nargs, 1);\n    arr_like = njs_arg(args, nargs, 2);\n    if (njs_is_null_or_undefined(arr_like)) {\n        length = 0;\n        goto activate;\n    } else if (njs_is_array(arr_like)) {\n        arr = arr_like->data.u.array;\n        args = arr->start;\n        length = arr->length;\n        goto activate;\n    } else if (njs_slow_path(!njs_is_object(arr_like))) {\n        njs_type_error(vm, \"second argument is not an array-like object\");\n        return NJS_ERROR;\n    }\n    ret = njs_object_length(vm, arr_like, &length);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    arr = njs_array_alloc(vm, 1, length, NJS_ARRAY_SPARE);\n    if (njs_slow_path(arr == NULL)) {\n        return NJS_ERROR;\n    }\n    args = arr->start;\n    for (i = 0; i < length; i++) {\n        ret = njs_value_property_i64(vm, arr_like, i, &args[i]);\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return ret;\n        }\n    }\nactivate:\n    vm->top_frame->skip = 1;\n    frame = (njs_frame_t *) vm->top_frame;\n    ret = njs_function_frame(vm, func, this, args, length, 0);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    ret = njs_function_frame_invoke(vm, frame->native.retval);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    return NJS_DECLINED;\n}", "target": 1}
{"code": "mm_skey_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tBuffer m;\n\tint len;\n\tu_int success;\n\tchar *p, *challenge;\n\tdebug3(\"%s: entering\", __func__);\n\tbuffer_init(&m);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SKEYQUERY,\n\t    &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: no challenge\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (-1);\n\t}\n\tchallenge  = buffer_get_string(&m, NULL);\n\tbuffer_free(&m);\n\tdebug3(\"%s: received challenge: %s\", __func__, challenge);\n\tmm_chall_setup(name, infotxt, numprompts, prompts, echo_on);\n\tlen = strlen(challenge) + strlen(SKEY_PROMPT) + 1;\n\tp = xmalloc(len);\n\tstrlcpy(p, challenge, len);\n\tstrlcat(p, SKEY_PROMPT, len);\n\t(*prompts)[0] = p;\n\txfree(challenge);\n\treturn (0);\n}", "target": 0}
{"code": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n        assert(p);\n        assert(key);\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n        r = dns_packet_extract(p);\n        if (r < 0)\n                return r;\n        if (!p->question)\n                return 0;\n        if (p->question->n_keys != 1)\n                return 0;\n        return dns_resource_key_equal(p->question->keys[0], key);\n}", "target": 0}
{"code": "void TestGatherNd(int* param_dims, const ParamType* param_data, int* index_dims,\n                  const IndexType* index_data, int* output_dims,\n                  ParamType* output_data,\n                  const ParamType* expected_output_data) {\n  TfLiteIntArray* pdims = IntArrayFromInts(param_dims);\n  TfLiteIntArray* idims = IntArrayFromInts(index_dims);\n  TfLiteIntArray* odims = IntArrayFromInts(output_dims);\n  constexpr int inputs_size = 2;\n  constexpr int outputs_size = 1;\n  constexpr int tensors_size = inputs_size + outputs_size;\n  TfLiteTensor tensors[tensors_size] = {\n      CreateTensor(param_data, pdims),\n      CreateTensor(index_data, idims),\n      CreateTensor(output_data, odims),\n  };\n  int inputs_array_data[] = {2, 0, 1};\n  TfLiteIntArray* inputs_array = IntArrayFromInts(inputs_array_data);\n  int outputs_array_data[] = {1, 2};\n  TfLiteIntArray* outputs_array = IntArrayFromInts(outputs_array_data);\n  const TfLiteRegistration registration = Register_GATHER_ND();\n  micro::KernelRunner runner(registration, tensors, tensors_size, inputs_array,\n                             outputs_array, nullptr);\n  TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.InitAndPrepare());\n  TF_LITE_MICRO_EXPECT_EQ(kTfLiteOk, runner.Invoke());\n  TfLiteTensor* actual_output_tensor = &tensors[2];\n  TfLiteIntArray* actual_output_dims = actual_output_tensor->dims;\n  const int output_size = ElementCount(*actual_output_dims);\n  for (int i = 0; i < output_size; ++i) {\n    TF_LITE_MICRO_EXPECT_EQ(expected_output_data[i], output_data[i]);\n  }\n}", "target": 1}
{"code": "  Status DoCompute(OpKernelContext* ctx) {\n    tensorflow::ResourceTagger tag(kTFDataResourceTag,\n                                   ctx->op_kernel().type_string());\n    tstring filename;\n    TF_RETURN_IF_ERROR(\n        ParseScalarArgument<tstring>(ctx, \"filename\", &filename));\n    tstring compression_type;\n    TF_RETURN_IF_ERROR(ParseScalarArgument<tstring>(ctx, \"compression_type\",\n                                                    &compression_type));\n    std::unique_ptr<WritableFile> file;\n    TF_RETURN_IF_ERROR(ctx->env()->NewWritableFile(filename, &file));\n    auto writer = absl::make_unique<io::RecordWriter>(\n        file.get(),\n        io::RecordWriterOptions::CreateRecordWriterOptions(compression_type));\n    DatasetBase* dataset;\n    TF_RETURN_IF_ERROR(GetDatasetFromVariantTensor(ctx->input(0), &dataset));\n    IteratorContext::Params params(ctx);\n    FunctionHandleCache function_handle_cache(params.flr);\n    params.function_handle_cache = &function_handle_cache;\n    ResourceMgr resource_mgr;\n    params.resource_mgr = &resource_mgr;\n    CancellationManager cancellation_manager(ctx->cancellation_manager());\n    params.cancellation_manager = &cancellation_manager;\n    IteratorContext iter_ctx(std::move(params));\n    DatasetBase* finalized_dataset;\n    TF_RETURN_IF_ERROR(FinalizeDataset(ctx, dataset, &finalized_dataset));\n    std::unique_ptr<IteratorBase> iterator;\n    TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(\n        &iter_ctx, nullptr, \"ToTFRecordOpIterator\", &iterator));\n    std::vector<Tensor> components;\n    components.reserve(finalized_dataset->output_dtypes().size());\n    bool end_of_sequence;\n    do {\n      TF_RETURN_IF_ERROR(\n          iterator->GetNext(&iter_ctx, &components, &end_of_sequence));\n      if (!end_of_sequence) {\n        TF_RETURN_IF_ERROR(\n            writer->WriteRecord(components[0].scalar<tstring>()()));\n      }\n      components.clear();\n    } while (!end_of_sequence);\n    return Status::OK();\n  }", "target": 1}
{"code": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}", "target": 1}
{"code": "    }\n    template<typename t>\n    const T& max_min(t& min_val) const {\n      if (is_empty())\n        throw CImgInstanceException(_cimglist_instance\n                                    \"max_min(): Empty instance.\",\n                                    cimglist_instance);\n      const T *ptr_max = _data->_data;\n      T min_value = *ptr_max, max_value = min_value;\n      cimglist_for(*this,l) {\n        const CImg<T>& img = _data[l];\n        cimg_for(img,ptrs,T) {\n          const T val = *ptrs;\n          if (val>max_value) { max_value = val; ptr_max = ptrs; }\n          if (val<min_value) min_value = val;\n        }", "target": 0}
{"code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\topenflags &= ~(O_CREAT|O_EXCL);\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}", "target": 1}
{"code": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->set (*other);\n}", "target": 1}
{"code": "xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n    xmlAttrPtr attr) {\n    xmlRefPtr ret;\n    xmlRefTablePtr table;\n    xmlListPtr ref_list;\n    if (doc == NULL) {\n        return(NULL);\n    }\n    if (value == NULL) {\n        return(NULL);\n    }\n    if (attr == NULL) {\n        return(NULL);\n    }\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL) {\n        doc->refs = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddRef: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n        return(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->name = NULL;\n\tret->attr = attr;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (NULL == (ref_list = xmlHashLookup(table, value))) {\n        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list creation failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n        if (xmlHashAddEntry(table, value, ref_list) < 0) {\n            xmlListDelete(ref_list);\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n    }\n    if (xmlListAppend(ref_list, ret) != 0) {\n\txmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n        goto failed;\n    }\n    return(ret);\nfailed:\n    if (ret != NULL) {\n        if (ret->value != NULL)\n\t    xmlFree((char *)ret->value);\n        if (ret->name != NULL)\n\t    xmlFree((char *)ret->name);\n        xmlFree(ret);\n    }\n    return(NULL);\n}", "target": 1}
{"code": "static inline bool cpu_has_vmx_ple(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING;\n}", "target": 0}
{"code": "int kvm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_FS_BASE:\n\tcase MSR_GS_BASE:\n\tcase MSR_KERNEL_GS_BASE:\n\tcase MSR_CSTAR:\n\tcase MSR_LSTAR:\n\t\tif (is_noncanonical_address(msr->data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr->data = get_canonical(msr->data);\n\t}\n\treturn kvm_x86_ops->set_msr(vcpu, msr);\n}", "target": 0}
{"code": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    CString sModPath, sTmp;\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}", "target": 0}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\tunmask_evtchn(evtchn);\n}", "target": 1}
{"code": "static int open_if_safe(int dirfd, const char *nextpath)\n{\n\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n\tif (newfd >= 0) \n\t\treturn newfd;\n\tif (errno == ELOOP)\n\t\treturn newfd;\n\tif (errno == EPERM || errno == EACCES) {\n\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n\t\tif (newfd >= 0) {\n\t\t\tint ret = check_symlink(newfd);\n\t\t\tif (ret < 0) {\n\t\t\t\tclose(newfd);\n\t\t\t\tnewfd = ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn newfd;\n}", "target": 0}
{"code": "static void sctp_close(struct sock *sk, long timeout)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct sctp_endpoint *ep;\n\tstruct sctp_association *asoc;\n\tstruct list_head *pos, *temp;\n\tunsigned int data_was_unread;\n\tpr_debug(\"%s: sk:%p, timeout:%ld\\n\", __func__, sk, timeout);\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tsk->sk_state = SCTP_SS_CLOSING;\n\tep = sctp_sk(sk)->ep;\n\tdata_was_unread = sctp_queue_purge_ulpevents(&sk->sk_receive_queue);\n\tdata_was_unread += sctp_queue_purge_ulpevents(&sctp_sk(sk)->pd_lobby);\n\tlist_for_each_safe(pos, temp, &ep->asocs) {\n\t\tasoc = list_entry(pos, struct sctp_association, asocs);\n\t\tif (sctp_style(sk, TCP)) {\n\t\t\tif (sctp_state(asoc, CLOSED)) {\n\t\t\t\tsctp_unhash_established(asoc);\n\t\t\t\tsctp_association_free(asoc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (data_was_unread || !skb_queue_empty(&asoc->ulpq.lobby) ||\n\t\t    !skb_queue_empty(&asoc->ulpq.reasm) ||\n\t\t    (sock_flag(sk, SOCK_LINGER) && !sk->sk_lingertime)) {\n\t\t\tstruct sctp_chunk *chunk;\n\t\t\tchunk = sctp_make_abort_user(asoc, NULL, 0);\n\t\t\tif (chunk)\n\t\t\t\tsctp_primitive_ABORT(net, asoc, chunk);\n\t\t} else\n\t\t\tsctp_primitive_SHUTDOWN(net, asoc, NULL);\n\t}\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\trelease_sock(sk);\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\tsock_put(sk);\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}", "target": 1}
{"code": " bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n  if (render_view_host_->IsSwappedOut()) {\n    if (!SwappedOutMessages::CanHandleWhileSwappedOut(msg)) {\n      if (msg.is_sync()) {\n        IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg);\n        reply->set_reply_error();\n        Send(reply);\n      }\n      return true;\n    }\n  }\n   if (delegate_->OnMessageReceived(this, msg))\n     return true;\n  if (cross_process_frame_connector_ &&\n      cross_process_frame_connector_->OnMessageReceived(msg))\n    return true;\n  bool handled = true;\n  bool msg_is_ok = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(RenderFrameHostImpl, msg, msg_is_ok)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoadForFrame,\n                        OnDidStartProvisionalLoadForFrame)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n                        OnDidFailProvisionalLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidRedirectProvisionalLoad,\n                        OnDidRedirectProvisionalLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER_GENERIC(FrameHostMsg_DidCommitProvisionalLoad,\n                                OnNavigate(msg))\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse,\n                        OnJavaScriptExecuteResponse)\n  IPC_END_MESSAGE_MAP_EX()\n  if (!msg_is_ok) {\n    RecordAction(base::UserMetricsAction(\"BadMessageTerminate_RFH\"));\n    GetProcess()->ReceivedBadMessage();\n  }\n  return handled;\n}", "target": 0}
{"code": "static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)\n{\n\tbdaddr_t bdaddr;\n\tint err;\n\tif (copy_from_user(&bdaddr, arg, sizeof(bdaddr)))\n\t\treturn -EFAULT;\n\thci_dev_lock(hdev);\n\terr = hci_blacklist_add(hdev, &bdaddr, 0);\n\thci_dev_unlock(hdev);\n\treturn err;\n}", "target": 0}
{"code": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (const struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (const struct pgstate *)io;\n\t}\n\treturn ((const u_char *)ps <= ep? 0 : -1);\n}", "target": 1}
{"code": "coolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)\n{\n\tsc_cardctl_coolkey_object_t new_object;\n\tint r;\n\tmemset(&new_object, 0, sizeof(new_object));\n\tnew_object.path = coolkey_template_path;\n\tnew_object.path.len = 4;\n\tulong2bebytes(new_object.path.value, object_id);\n\tnew_object.id = object_id;\n\tnew_object.length = object_length;\n\tif (coolkey_find_object_by_id(&priv->objects_list, object_id) != NULL) {\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tif (object_data) {\n\t\tnew_object.data = malloc(object_length + add_v1_record);\n\t\tif (new_object.data == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tif (add_v1_record) {\n\t\t\tnew_object.data[0] = COOLKEY_V1_OBJECT;\n\t\t\tnew_object.length++;\n\t\t}\n\t\tmemcpy(&new_object.data[add_v1_record], object_data, object_length);\n\t}\n\tr = coolkey_add_object_to_list(&priv->objects_list, &new_object);\n\tif (r != SC_SUCCESS) {\n\t\tfree(new_object.data);\n\t\tnew_object.data = NULL;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n{\n    const xmlChar * numstr;\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            *value = atol((const char *)numstr);\n            if (*value < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}", "target": 1}
{"code": "sanitize (GPtrArray *array)\n{\n        int i;\n        GPtrArray *new;\n        g_debug (\"before sanitizing\");\n        for (i = 0; i < array->len; ++i) {\n                if (array->pdata[i]) {\n                        print_configuration (array->pdata[i], \"before\");\n                }\n        }\n        for (i = 1; i < array->len; ++i) {\n                int j;\n                for (j = 0; j < i; ++j) {\n                        GnomeRRConfig *this = array->pdata[j];\n                        GnomeRRConfig *other = array->pdata[i];\n                        if (this && other && gnome_rr_config_equal (this, other)) {\n                                g_debug (\"removing duplicate configuration\");\n                                gnome_rr_config_free (this);\n                                array->pdata[j] = NULL;\n                                break;\n                        }\n                }\n        }\n        for (i = 0; i < array->len; ++i) {\n                GnomeRRConfig *config = array->pdata[i];\n                if (config) {\n                        gboolean all_off = TRUE;\n                        int j;\n                        for (j = 0; config->outputs[j] != NULL; ++j) {\n                                if (config->outputs[j]->on)\n                                        all_off = FALSE;\n                        }\n                        if (all_off) {\n                                gnome_rr_config_free (array->pdata[i]);\n                                array->pdata[i] = NULL;\n                        }\n                }\n        }\n        new = g_ptr_array_new ();\n        for (i = 0; i < array->len; ++i) {\n                if (array->pdata[i]) {\n                        g_ptr_array_add (new, array->pdata[i]);\n                        print_configuration (array->pdata[i], \"Final\");\n                }\n        }\n        if (new->len > 0) {\n                g_ptr_array_add (new, NULL);\n        } else {\n                g_ptr_array_free (new, TRUE);\n                new = NULL;\n        }\n        g_ptr_array_free (array, TRUE);\n        return new;\n}", "target": 0}
{"code": "WM_SYMBOL midi *WildMidi_OpenBuffer(uint8_t *midibuffer, uint32_t size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midibuffer == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL midi data buffer)\", 0);\n        return (NULL);\n    }\n    if (size > WM_MAXFILESIZE) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_LONGFIL, NULL, 0);\n        return (NULL);\n    }\n    if (size < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(midibuffer,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(midibuffer, size);\n    } else if (memcmp(midibuffer, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(midibuffer, size);\n    } else if (memcmp(midibuffer, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(midibuffer, size);\n    } else if (memcmp(midibuffer, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(midibuffer, size);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(midibuffer, size);\n    }\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\tif (!a->size) return GF_OK;\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);\n\t}\n\tpos = gf_bs_get_position(bs) - pos;\n\tif (pos != a->size) {\n\t\tif (a->type != GF_ISOM_BOX_TYPE_MDAT) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[iso file] Box %s wrote \"LLU\" bytes but size is \"LLU\"\\n\", gf_4cc_to_str(a->type), pos, a->size ));\n\t\t}\n\t}\n\treturn e;", "target": 1}
{"code": "void ecdsa_verify_prepare_legacy(ecdsa_verify_context_t *ctx, const ecc_int256_t *hash, const ecdsa_signature_t *signature) {\n  ecc_int256_t w, u1, tmp;\n  if (ecc_25519_gf_is_zero(&signature->s) || ecc_25519_gf_is_zero(&signature->r)) {\n    memset(&ctx->r, 0, sizeof(ctx->r));\n    return;\n  }\n  ctx->r = signature->r;\n  ecc_25519_gf_recip(&w, &signature->s);\n  ecc_25519_gf_reduce(&tmp, hash);\n  ecc_25519_gf_mult(&u1, &tmp, &w);\n  ecc_25519_gf_mult(&ctx->u2, &ctx->r, &w);\n  ecc_25519_scalarmult_base(&ctx->s1, &u1);\n}", "target": 0}
{"code": "struct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = proto;\n\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tfl6->saddr = ireq->ir_v6_loc_addr;\n\tfl6->flowi6_oif = ireq->ir_iif;\n\tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\treturn dst;\n}", "target": 1}
{"code": "PHP_FUNCTION(mb_ereg_search_setpos)\n{\n\tlong position;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &position) == FAILURE) {\n\t\treturn;\n\t}\n\tif (position < 0 || (MBREX(search_str) != NULL && Z_TYPE_P(MBREX(search_str)) == IS_STRING && position >= Z_STRLEN_P(MBREX(search_str)))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Position is out of range\");\n\t\tMBREX(search_pos) = 0;\n\t\tRETURN_FALSE;\n\t}\n\tMBREX(search_pos) = position;\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tu64 connection_id)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tu64 association_id = nvmet_fc_getassociationid(connection_id);\n\tu16 qid = nvmet_fc_getqueueid(connection_id);\n\tunsigned long flags;\n\tif (qid > NVMET_NR_QUEUES)\n\t\treturn NULL;\n\tspin_lock_irqsave(&tgtport->lock, flags);\n\tlist_for_each_entry(assoc, &tgtport->assoc_list, a_list) {\n\t\tif (association_id == assoc->association_id) {\n\t\t\tqueue = assoc->queues[qid];\n\t\t\tif (queue &&\n\t\t\t    (!atomic_read(&queue->connected) ||\n\t\t\t     !nvmet_fc_tgt_q_get(queue)))\n\t\t\t\tqueue = NULL;\n\t\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t\t\treturn queue;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\treturn NULL;\n}", "target": 0}
{"code": "spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "static void __account_cfs_rq_runtime(struct cfs_rq *cfs_rq, u64 delta_exec)\n{\n\tcfs_rq->runtime_remaining -= delta_exec;\n\texpire_cfs_rq_runtime(cfs_rq);\n\tif (likely(cfs_rq->runtime_remaining > 0))\n\t\treturn;\n\tif (!assign_cfs_rq_runtime(cfs_rq) && likely(cfs_rq->curr))\n\t\tresched_curr(rq_of(cfs_rq));\n}", "target": 1}
{"code": "std::string Utf16ToUtf8(const std::wstring& utf16_string) {\n  return WC2MB(utf16_string, CP_UTF8);\n}", "target": 1}
{"code": "static char *tls_text_name(X509_NAME *name, int nid)\n{\n\tint     pos;\n\tX509_NAME_ENTRY *entry;\n\tASN1_STRING *entry_str;\n\tint     utf8_length;\n\tunsigned char *utf8_value;\n\tchar *result;\n\tif (name == 0 || (pos = X509_NAME_get_index_by_NID(name, nid, -1)) < 0) {\n\t\treturn NULL;\n    }\n    entry = X509_NAME_get_entry(name, pos);\n    g_return_val_if_fail(entry != NULL, NULL);\n    entry_str = X509_NAME_ENTRY_get_data(entry);\n    g_return_val_if_fail(entry_str != NULL, NULL);\n    if ((utf8_length = ASN1_STRING_to_UTF8(&utf8_value, entry_str)) < 0) {\n    \tg_warning(\"Error decoding ASN.1 type=%d\", ASN1_STRING_type(entry_str));\n    \treturn NULL;\n    }\n    if (has_internal_nul((char *)utf8_value, utf8_length)) {\n    \tg_warning(\"NUL character in hostname in certificate\");\n    \tOPENSSL_free(utf8_value);\n    \treturn NULL;\n    }\n    result = g_strdup((char *) utf8_value);\n\tOPENSSL_free(utf8_value);\n\treturn result;\n}", "target": 0}
{"code": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tax25->sk    = sk;\n\treturn 0;\n}", "target": 0}
{"code": "static BOOL rdp_write_logon_info_v1(wStream* s, logon_info* info)\n{\n\tconst size_t charLen = 52 / sizeof(WCHAR);\n\tconst size_t userCharLen = 512 / sizeof(WCHAR);\n\tsize_t sz = 4 + 52 + 4 + 512 + 4;\n\tsize_t len = 0;\n\tif (!Stream_EnsureRemainingCapacity(s, sz))\n\t\treturn FALSE;\n\tWINPR_ASSERT(info);\n\tif (!info->domain || !info->username)\n\t\treturn FALSE;\n\tlen = strnlen(info->domain, charLen + 1);\n\tif (len > charLen)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, len * sizeof(WCHAR));\n\tif (Stream_Write_UTF16_String_From_UTF8(s, charLen, info->domain, len, TRUE) < 0)\n\t\treturn FALSE;\n\tlen = strnlen(info->username, userCharLen + 1);\n\tif (len > userCharLen)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, len * sizeof(WCHAR));\n\tif (Stream_Write_UTF16_String_From_UTF8(s, userCharLen, info->username, len, TRUE) < 0)\n\t\treturn FALSE;\n\tStream_Write_UINT32(s, info->sessionId);\n\treturn TRUE;\n}", "target": 0}
{"code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif \n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}", "target": 1}
{"code": "imapx_unset_folder_flagged_flag (CamelFolderSummary *summary,\n\t\t\t\t GPtrArray *changed_uids,\n\t\t\t\t gboolean except_deleted_messages)\n{\n\tCamelMessageInfo *info;\n\tgboolean changed = FALSE;\n\tgint ii;\n\tg_return_if_fail (CAMEL_IS_FOLDER_SUMMARY (summary));\n\tg_return_if_fail (changed_uids != NULL);\n\tfor (ii = 0; ii < changed_uids->len; ii++) {\n\t\tinfo = camel_folder_summary_get (summary, changed_uids->pdata[ii]);\n\t\tif (info) {\n\t\t\tCamelMessageInfoBase *mi = (CamelMessageInfoBase *) info;\n\t\t\tif ((mi->flags & CAMEL_MESSAGE_FOLDER_FLAGGED) != 0 &&\n\t\t\t   (!except_deleted_messages || (mi->flags & CAMEL_MESSAGE_DELETED) == 0)) {\n\t\t\t\tmi->flags &= ~CAMEL_MESSAGE_FOLDER_FLAGGED;\n\t\t\t\tmi->dirty = TRUE;\n\t\t\t\tchanged = TRUE;\n\t\t\t}\n\t\t\tcamel_message_info_unref (info);\n\t\t}\n\t}\n\tif (changed) {\n\t\tcamel_folder_summary_touch (summary);\n\t\tcamel_folder_summary_save_to_db (summary, NULL);\n\t}\n}", "target": 0}
{"code": "static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n\t\t\tdev_put(llc->dev);\n\t\t\tllc->dev = NULL;\n\t\t}\n\t} else\n\t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; \n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\tif (rc) {\n\t\tdev_put_track(llc->dev, &llc->dev_tracker);\n\t\tllc->dev = NULL;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "Status ValidatePaddingValues(absl::Span<const int64_t> input_dimensions,\n                             absl::Span<const int64_t> window_dimensions,\n                             absl::Span<const int64_t> window_strides) {\n  bool ok = input_dimensions.size() == window_dimensions.size() &&\n            input_dimensions.size() == window_strides.size();\n  if (!ok) {\n    return InvalidArgument(\n        \"Want input dimensions size %u = window dimensions size %u = window \"\n        \"strides size %u\",\n        input_dimensions.size(), window_dimensions.size(),\n        window_strides.size());\n  }\n  for (size_t i = 0; i < input_dimensions.size(); ++i) {\n    if (window_dimensions[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive size %d\", i,\n                             window_dimensions[i]);\n    }\n    if (window_strides[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive stride %d\",\n                             i, window_strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}", "target": 1}
{"code": "Eina_Bool ewk_view_forward_possible(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_forward_possible(smartData->main_frame);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "static bool rb_is_reader_page(struct buffer_page *page)\n{\n\tstruct list_head *list = page->list.prev;\n\treturn rb_list_head(list->next) != &page->list;\n}", "target": 0}
{"code": "static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)\n{\n\tint *fdp = (int*)CMSG_DATA(cmsg);\n\tstruct scm_fp_list *fpl = *fplp;\n\tstruct file **fpp;\n\tint i, num;\n\tnum = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(struct cmsghdr)))/sizeof(int);\n\tif (num <= 0)\n\t\treturn 0;\n\tif (num > SCM_MAX_FD)\n\t\treturn -EINVAL;\n\tif (!fpl)\n\t{\n\t\tfpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL);\n\t\tif (!fpl)\n\t\t\treturn -ENOMEM;\n\t\t*fplp = fpl;\n\t\tfpl->count = 0;\n\t\tfpl->max = SCM_MAX_FD;\n\t\tfpl->user = NULL;\n\t}\n\tfpp = &fpl->fp[fpl->count];\n\tif (fpl->count + num > fpl->max)\n\t\treturn -EINVAL;\n\tfor (i=0; i< num; i++)\n\t{\n\t\tint fd = fdp[i];\n\t\tstruct file *file;\n\t\tif (fd < 0 || !(file = fget_raw(fd)))\n\t\t\treturn -EBADF;\n\t\t*fpp++ = file;\n\t\tfpl->count++;\n\t}\n\tif (!fpl->user)\n\t\tfpl->user = get_uid(current_user());\n\treturn num;\n}", "target": 0}
{"code": "static RList *symbols(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tbool found = false;\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t}\n\t\t}\n\t}\n\tht_uu_free (hash);\n\treturn res;\n}", "target": 0}
{"code": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\tif (!acl)\n\t\tgoto set_acl;\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}", "target": 1}
{"code": "void Filter::onDownstreamEvent(Network::ConnectionEvent event) {\n  if (event == Network::ConnectionEvent::LocalClose ||\n      event == Network::ConnectionEvent::RemoteClose) {\n    downstream_closed_ = true;\n  }\n  ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),\n                 static_cast<int>(event), upstream_ == nullptr);\n  if (upstream_) {\n    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));\n    if (conn_data != nullptr &&\n        conn_data->connection().state() != Network::Connection::State::Closed) {\n      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),\n                                  std::move(upstream_callbacks_), std::move(idle_timer_),\n                                  read_callbacks_->upstreamHost());\n    }\n    if (event != Network::ConnectionEvent::Connected) {\n      upstream_.reset();\n      disableIdleTimer();\n    }\n  }\n  if (generic_conn_pool_) {\n    if (event == Network::ConnectionEvent::LocalClose ||\n        event == Network::ConnectionEvent::RemoteClose) {\n      generic_conn_pool_.reset();\n    }\n  }\n}", "target": 0}
{"code": "TfLiteStatus ReshapeOutput(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  int num_input_elements = NumElements(input);\n  TfLiteIntArray* output_shape = output->dims;\n  if (NumInputs(node) == 1 &&  \n      output_shape->size == 1 && output_shape->data[0] == 0) {\n    output_shape->size = 0;\n  }\n  int num_output_elements = 1;\n  int stretch_dim = -1;\n  for (int i = 0; i < output_shape->size; ++i) {\n    int value = output_shape->data[i];\n    if (value == -1) {\n      TF_LITE_ENSURE_EQ(context, stretch_dim, -1);\n      stretch_dim = i;\n    } else {\n      num_output_elements *= value;\n    }\n  }\n  if (stretch_dim != -1) {\n    output_shape->data[stretch_dim] = num_input_elements / num_output_elements;\n    num_output_elements *= output_shape->data[stretch_dim];\n  }\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE_EQ(context, num_input_elements, num_output_elements);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "int main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL);\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}", "target": 1}
{"code": "static inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;\n}", "target": 0}
{"code": "bool ConstantFolding::SimplifyReshape(const GraphProperties& properties,\n                                      bool use_shape_info, NodeDef* node) {\n  if (!use_shape_info || node->attr().count(\"T\") == 0 ||\n      !IsSimplifiableReshape(*node, properties)) {\n    return false;\n  }\n  DataType output_type = node->attr().at(\"T\").type();\n  node->set_op(\"Identity\");\n  EraseRegularNodeAttributes(node);\n  (*node->mutable_attr())[\"T\"].set_type(output_type);\n  *node->mutable_input(1) = AsControlDependency(node->input(1));\n  return true;\n}", "target": 1}
{"code": "ZEND_API int zend_ts_hash_num_elements(TsHashTable *ht)\n{\n\tint retval;\n\tbegin_read(ht);\n\tretval = zend_hash_num_elements(TS_HASH(ht));\n\tend_read(ht);\n\treturn retval;\n}", "target": 0}
{"code": "decode_definite_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL;\n    char *buf;\n    buf = PyMem_Malloc(length);\n    if (!buf)\n        return PyErr_NoMemory();\n    if (fp_read(self, buf, length) == 0)\n        ret = PyUnicode_DecodeUTF8(\n                buf, length, PyBytes_AS_STRING(self->str_errors));\n    PyMem_Free(buf);\n    if (!ret)\n        return NULL;\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 1}
{"code": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}", "target": 1}
{"code": "static void *my_malloc(size_t size)\n{\n    malloc_called += 1;\n    return malloc(size);\n}", "target": 1}
{"code": "static int hns_gmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_gmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "static int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\toidc_debug(r, \"enter\");\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}", "target": 1}
{"code": "BufferedRandomDevice::BufferedRandomDevice(size_t bufferSize)\n  : bufferSize_(bufferSize),\n    buffer_(new unsigned char[bufferSize]),\n    ptr_(buffer_.get() + bufferSize) {  \n  call_once(flag, [this]() {\n    detail::AtFork::registerHandler(\n        this,\n         []() { return true; },\n         []() {},\n        []() {\n          using Single = SingletonThreadLocal<BufferedRandomDevice, RandomTag>;\n          auto& t = Single::get();\n          t.ptr_ = t.buffer_.get() + t.bufferSize_;\n        });\n  });\n}", "target": 0}
{"code": "rb_iter_peek(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct trace_buffer *buffer;\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint nr_loops = 0;\n\tif (ts)\n\t\t*ts = 0;\n\tcpu_buffer = iter->cpu_buffer;\n\tbuffer = cpu_buffer->buffer;\n\tif (unlikely(iter->cache_read != cpu_buffer->read ||\n\t\t     iter->cache_reader_page != cpu_buffer->reader_page))\n\t\trb_iter_reset(iter);\n again:\n\tif (ring_buffer_iter_empty(iter))\n\t\treturn NULL;\n\tif (++nr_loops > 3)\n\t\treturn NULL;\n\tif (rb_per_cpu_empty(cpu_buffer))\n\t\treturn NULL;\n\tif (iter->head >= rb_page_size(iter->head_page)) {\n\t\trb_inc_iter(iter);\n\t\tgoto again;\n\t}\n\tevent = rb_iter_head_event(iter);\n\tif (!event)\n\t\tgoto again;\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\tif (rb_null_event(event)) {\n\t\t\trb_inc_iter(iter);\n\t\t\tgoto again;\n\t\t}\n\t\trb_advance_iter(iter);\n\t\treturn event;\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\trb_advance_iter(iter);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\tif (ts) {\n\t\t\t*ts = rb_event_time_stamp(event);\n\t\t\tring_buffer_normalize_time_stamp(cpu_buffer->buffer,\n\t\t\t\t\t\t\t cpu_buffer->cpu, ts);\n\t\t}\n\t\trb_advance_iter(iter);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_DATA:\n\t\tif (ts && !(*ts)) {\n\t\t\t*ts = iter->read_stamp + event->time_delta;\n\t\t\tring_buffer_normalize_time_stamp(buffer,\n\t\t\t\t\t\t\t cpu_buffer->cpu, ts);\n\t\t}\n\t\treturn event;\n\tdefault:\n\t\tRB_WARN_ON(cpu_buffer, 1);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "  template<typename T> const T GetWirelessNetworkByPath(\n      const std::vector<T>& networks, const std::string& path) const {\n    typedef typename std::vector<T>::const_iterator iter_t;\n    iter_t iter = std::find_if(networks.begin(), networks.end(),\n                               WirelessNetwork::ServicePathEq(path));\n    return (iter != networks.end()) ? *iter : NULL;\n  }", "target": 0}
{"code": "int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n\t\tif (encoded[1] & 0x80)\n\t\t\tm_adpcmState[c].previousValue -= 0x10000;\n\t\tm_adpcmState[c].index = encoded[2];\n\t\t*decoded++ = m_adpcmState[c].previousValue;\n\t\tencoded += 4;\n\t}\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tint16_t *output = decoded + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n\t\t\t\toutput += channelCount;\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n\t\t\t\toutput += channelCount;\n\t\t\t\tencoded++;\n\t\t\t}\n\t\t}\n\t\tdecoded += channelCount * 8;\n\t}\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}", "target": 1}
{"code": "static void set_last_stream_little_endian(AVFormatContext *fc)\n{\n    AVStream *st;\n    if (fc->nb_streams < 1)\n        return;\n    st = fc->streams[fc->nb_streams-1];\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_PCM_S16BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S16LE;\n        break;\n    case AV_CODEC_ID_PCM_S24BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;\n        break;\n    case AV_CODEC_ID_PCM_S32BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n        break;\n    case AV_CODEC_ID_PCM_F32BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_F32LE;\n        break;\n    case AV_CODEC_ID_PCM_F64BE:\n        st->codecpar->codec_id = AV_CODEC_ID_PCM_F64LE;\n        break;\n    default:\n        break;\n    }\n}", "target": 0}
{"code": "h2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}", "target": 1}
{"code": "bbuf_clone(BBuf** rto, BBuf* from)\n{\n  int r;\n  BBuf *to;\n  *rto = to = (BBuf* )xmalloc(sizeof(BBuf));\n  CHECK_NULL_RETURN_MEMERR(to);\n  r = BB_INIT(to, from->alloc);\n  if (r != 0) {\n    xfree(to->p);\n    *rto = 0;\n    return r;\n  }\n  to->used = from->used;\n  xmemcpy(to->p, from->p, from->used);\n  return 0;\n}", "target": 0}
{"code": "void ssl_update_cache(SSL *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(s, s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "uint32_t sftp_parse_handle(struct sftpjob *job, struct handleid *id) {\n  uint32_t len, rc;\n  if((rc = sftp_parse_uint32(job, &len)) != SSH_FX_OK || len != 8 ||\n     (rc = sftp_parse_uint32(job, &id->id)) != SSH_FX_OK ||\n     (rc = sftp_parse_uint32(job, &id->tag) != SSH_FX_OK))\n    return rc;\n  return SSH_FX_OK;\n}", "target": 1}
{"code": "bool Curl_conncache_foreach(struct Curl_easy *data,\n                            struct conncache *connc,\n                            void *param,\n                            int (*func)(struct Curl_easy *data,\n                                        struct connectdata *conn, void *param))\n{\n  struct Curl_hash_iterator iter;\n  struct Curl_llist_element *curr;\n  struct Curl_hash_element *he;\n  if(!connc)\n    return FALSE;\n  CONNCACHE_LOCK(data);\n  Curl_hash_start_iterate(&connc->hash, &iter);\n  he = Curl_hash_next_element(&iter);\n  while(he) {\n    struct connectbundle *bundle;\n    bundle = he->ptr;\n    he = Curl_hash_next_element(&iter);\n    curr = bundle->conn_list.head;\n    while(curr) {\n      struct connectdata *conn = curr->ptr;\n      curr = curr->next;\n      if(1 == func(data, conn, param)) {\n        CONNCACHE_UNLOCK(data);\n        return TRUE;\n      }\n    }\n  }\n  CONNCACHE_UNLOCK(data);\n  return FALSE;\n}", "target": 0}
{"code": "uint16_t mesg_id (void) {\n\tstatic uint16_t id = 0;\n\tif (!id) {\n\t\tsrandom (time (NULL));\n\t\tid = random ();\n\t}\n\tid++;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", id);\n\treturn id;\n}", "target": 1}
{"code": "static void cancel_att_send_op(struct att_send_op *op)\n{\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}", "target": 1}
{"code": "TfLiteStatus EvalHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  const int resource_id = input_resource_id_tensor->data.i32[0];\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      lookup->CheckKeyAndValueTypes(context, key_tensor, value_tensor));\n  auto result = lookup->Import(context, key_tensor, value_tensor);\n  return result;\n}", "target": 1}
{"code": "static char *__filterQuotedShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase ' ':\n\t\tcase '=':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}", "target": 0}
{"code": "INST_HANDLER (sbrx) {\t\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\n\t\t\t: \"!,!,\");\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "SWFShape_addGradientFillStyle(SWFShape shape, SWFGradient gradient, byte flags)\n{\n\tSWFFillStyle fill = newSWFGradientFillStyle(gradient, flags);\n\tif(addFillStyle(shape, fill) < 0)\n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\treturn fill;\t\t\n}", "target": 0}
{"code": "acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)\n{\n\t*cache = kmem_cache_create(name, size, 0, 0, NULL);\n\tif (*cache == NULL)\n\t\treturn AE_ERROR;\n\telse\n\t\treturn AE_OK;\n}", "target": 0}
{"code": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n        }\n        buffer_pool_.push(buffers[i]);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n  if (is_pool_empty) {\n    Free(buffers);\n  }\n  return buffer;\n}", "target": 1}
{"code": "ResponsePtr Server::ServeStatic(RequestPtr request) {\n  assert(request->method() == methods::kGet);\n  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n  fs::path path = doc_root_ / request->url().path();\n  try {\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n    auto response = std::make_shared<Response>(Status::kOK);\n    std::string extension = path.extension().string();\n    response->SetContentType(media_types::FromExtension(extension), \"\");\n    response->SetBody(body, true);\n    return response;\n  } catch (const Error& error) {\n    LOG_ERRO(\"File error: %s\", error.message().c_str());\n    return {};\n  }\n}", "target": 1}
{"code": "    OFCondition operator()(ImagePixel& pixel)\n    {\n        (void)pixel;\n        Uint16 rows = 0;\n        Uint16 cols = 0;\n        m_CT.getRows(rows);\n        m_CT.getColumns(cols);\n        const size_t numFrames      = m_CT.m_Frames.size();\n        const size_t numBytesFrame  = m_CT.m_Frames[0]->length;\n        const size_t numPixelsFrame = rows * cols;\n        DcmPixelData* pixData = new DcmPixelData(DCM_PixelData);\n        OFCondition result;\n        if (pixData)\n        {\n            pixData->setVR(EVR_OW);\n            Uint16* ptr          = NULL;\n            size_t numBytesTotal = numBytesFrame * numFrames / 2;\n            if (numBytesTotal <= 4294967294UL)\n            {\n                result = pixData->createUint16Array(OFstatic_cast(Uint32, numBytesTotal), ptr);\n                if (ptr)\n                {\n                    for (size_t f = 0; f < numFrames; ++f)\n                    {\n                        memcpy(ptr, m_CT.m_Frames[f]->pixData, numBytesFrame);\n                        ptr += numPixelsFrame;\n                    }\n                    return m_Item.insert(pixData);\n                }\n            }\n            else\n            {\n                result = FG_EC_PixelDataTooLarge;\n                delete pixData;\n            }\n        }\n        return result;\n    }", "target": 1}
{"code": "string_copylc(uschar *s)\n{\nuschar *ss = store_get(Ustrlen(s) + 1);\nuschar *p = ss;\nwhile (*s != 0) *p++ = tolower(*s++);\n*p = 0;\nreturn ss;\n}", "target": 0}
{"code": "static int proc_open(const char *path, struct fuse_file_info *fi)\n{\n\tint type = -1;\n\tstruct file_info *info;\n\tif (strcmp(path, \"/proc/meminfo\") == 0)\n\t\ttype = LXC_TYPE_PROC_MEMINFO;\n\telse if (strcmp(path, \"/proc/cpuinfo\") == 0)\n\t\ttype = LXC_TYPE_PROC_CPUINFO;\n\telse if (strcmp(path, \"/proc/uptime\") == 0)\n\t\ttype = LXC_TYPE_PROC_UPTIME;\n\telse if (strcmp(path, \"/proc/stat\") == 0)\n\t\ttype = LXC_TYPE_PROC_STAT;\n\telse if (strcmp(path, \"/proc/diskstats\") == 0)\n\t\ttype = LXC_TYPE_PROC_DISKSTATS;\n\tif (type == -1)\n\t\treturn -ENOENT;\n\tinfo = malloc(sizeof(*info));\n\tif (!info)\n\t\treturn -ENOMEM;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->type = type;\n\tinfo->buflen = get_procfile_size(path) + BUF_RESERVE_SIZE;\n\tdo {\n\t\tinfo->buf = malloc(info->buflen);\n\t} while (!info->buf);\n\tmemset(info->buf, 0, info->buflen);\n\tinfo->size = info->buflen;\n\tfi->fh = (unsigned long)info;\n\treturn 0;\n}", "target": 0}
{"code": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\tunsigned char header[18];\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\ttga->ident = NULL;\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "int DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert,\n    const Network::TransportSocketOptions* transport_socket_options) {\n  if (verify_trusted_ca_) {\n    int ret = X509_verify_cert(store_ctx);\n    if (ssl_extended_info) {\n      ssl_extended_info->setCertificateValidationStatus(\n          ret == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n    if (ret <= 0) {\n      stats_.fail_verify_error_.inc();\n      ENVOY_LOG(debug, \"{}\", Utility::getX509VerificationErrorInfo(store_ctx));\n      return allow_untrusted_certificate_ ? 1 : ret;\n    }\n  }\n  Envoy::Ssl::ClientValidationStatus validated =\n      verifyCertificate(&leaf_cert,\n                        transport_socket_options != nullptr\n                            ? transport_socket_options->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        subject_alt_name_matchers_);\n  if (ssl_extended_info) {\n    if (ssl_extended_info->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    } else if (validated != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    }\n  }\n  int validation_status = verify_trusted_ca_\n                              ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                              : validated == Envoy::Ssl::ClientValidationStatus::Validated;\n  return allow_untrusted_certificate_ ? 1 : validation_status;\n}", "target": 1}
{"code": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn)\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n  data->conn = NULL;\n}", "target": 1}
{"code": "static int decode_level3_header(LHAFileHeader **header, LHAInputStream *stream)\n{\n\tunsigned int header_len;\n\tif (lha_decode_uint16(&RAW_DATA(header, 0)) != 4) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     LEVEL_3_HEADER_LEN - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\tmemcpy((*header)->compress_method, &RAW_DATA(header, 2), 5);\n\t(*header)->compress_method[5] = '\\0';\n\t(*header)->compressed_length = lha_decode_uint32(&RAW_DATA(header, 7));\n\t(*header)->length = lha_decode_uint32(&RAW_DATA(header, 11));\n\t(*header)->timestamp = lha_decode_uint32(&RAW_DATA(header, 15));\n\t(*header)->crc = lha_decode_uint16(&RAW_DATA(header, 21));\n\t(*header)->os_type = RAW_DATA(header, 23);\n\tif (!decode_extended_headers(header, 28)) {\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "void add_interrupt_randomness(int irq, int irq_flags)\n{\n\tstruct entropy_store\t*r;\n\tstruct fast_pool\t*fast_pool = this_cpu_ptr(&irq_randomness);\n\tstruct pt_regs\t\t*regs = get_irq_regs();\n\tunsigned long\t\tnow = jiffies;\n\tcycles_t\t\tcycles = random_get_entropy();\n\t__u32\t\t\tc_high, j_high;\n\t__u64\t\t\tip;\n\tunsigned long\t\tseed;\n\tint\t\t\tcredit = 0;\n\tif (cycles == 0)\n\t\tcycles = get_reg(fast_pool, regs);\n\tc_high = (sizeof(cycles) > 4) ? cycles >> 32 : 0;\n\tj_high = (sizeof(now) > 4) ? now >> 32 : 0;\n\tfast_pool->pool[0] ^= cycles ^ j_high ^ irq;\n\tfast_pool->pool[1] ^= now ^ c_high;\n\tip = regs ? instruction_pointer(regs) : _RET_IP_;\n\tfast_pool->pool[2] ^= ip;\n\tfast_pool->pool[3] ^= (sizeof(ip) > 4) ? ip >> 32 :\n\t\tget_reg(fast_pool, regs);\n\tfast_mix(fast_pool);\n\tadd_interrupt_bench(cycles);\n\tthis_cpu_add(net_rand_state.s1, fast_pool->pool[cycles & 3]);\n\tif (unlikely(crng_init == 0)) {\n\t\tif ((fast_pool->count >= 64) &&\n\t\t    crng_fast_load((char *) fast_pool->pool,\n\t\t\t\t   sizeof(fast_pool->pool))) {\n\t\t\tfast_pool->count = 0;\n\t\t\tfast_pool->last = now;\n\t\t}\n\t\treturn;\n\t}\n\tif ((fast_pool->count < 64) &&\n\t    !time_after(now, fast_pool->last + HZ))\n\t\treturn;\n\tr = &input_pool;\n\tif (!spin_trylock(&r->lock))\n\t\treturn;\n\tfast_pool->last = now;\n\t__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool));\n\tif (arch_get_random_seed_long(&seed)) {\n\t\t__mix_pool_bytes(r, &seed, sizeof(seed));\n\t\tcredit = 1;\n\t}\n\tspin_unlock(&r->lock);\n\tfast_pool->count = 0;\n\tcredit_entropy_bits(r, credit + 1);\n}", "target": 0}
{"code": "static unsigned int btrfs_mask_fsflags_for_type(struct inode *inode,\n\t\tunsigned int flags)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn flags;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn flags & ~FS_DIRSYNC_FL;\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_ptr = data.template flat<T>().data();\n    reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,\n                       data.NumElements(), data_ptr, output_flat);\n  }", "target": 1}
{"code": "GF_Err svhd_box_size(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string)\n\t\ts->size += (u32) strlen(ptr->string);\n\ts->size += 1;\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\t*skip_dentries = i;\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\tadd_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "static void *etm_setup_aux(int event_cpu, void **pages,\n\t\t\t   int nr_pages, bool overwrite)\n{\n\tint cpu;\n\tcpumask_t *mask;\n\tstruct coresight_device *sink;\n\tstruct etm_event_data *event_data = NULL;\n\tevent_data = alloc_event_data(event_cpu);\n\tif (!event_data)\n\t\treturn NULL;\n\tsink = coresight_get_enabled_sink(true);\n\tif (!sink)\n\t\tgoto err;\n\tINIT_WORK(&event_data->work, free_event_data);\n\tmask = &event_data->mask;\n\tfor_each_cpu(cpu, mask) {\n\t\tstruct coresight_device *csdev;\n\t\tcsdev = per_cpu(csdev_src, cpu);\n\t\tif (!csdev)\n\t\t\tgoto err;\n\t\tevent_data->path[cpu] = coresight_build_path(csdev, sink);\n\t\tif (IS_ERR(event_data->path[cpu]))\n\t\t\tgoto err;\n\t}\n\tif (!sink_ops(sink)->alloc_buffer)\n\t\tgoto err;\n\tcpu = cpumask_first(mask);\n\tevent_data->snk_config =\n\t\t\tsink_ops(sink)->alloc_buffer(sink, cpu, pages,\n\t\t\t\t\t\t     nr_pages, overwrite);\n\tif (!event_data->snk_config)\n\t\tgoto err;\nout:\n\treturn event_data;\nerr:\n\tetm_free_aux(event_data);\n\tevent_data = NULL;\n\tgoto out;\n}", "target": 0}
{"code": "matching_line_len(char_u *lbuf)\n{\n    char_u\t*p = lbuf + 1;\n    p += STRLEN(p) + 1;\n#ifdef FEAT_EMACS_TAGS\n    p += STRLEN(p) + 1;\n#endif\n    return (p - lbuf) + STRLEN(p);\n}", "target": 0}
{"code": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "gss_wrap_iov_length (minor_status,\n                     context_handle,\n                     conf_req_flag,\n                     qop_req,\n                     conf_state,\n                     iov,\n                     iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov_length) {\n\t    status = mech->gss_wrap_iov_length(\n\t\t\t\t\t      minor_status,\n\t\t\t\t\t      ctx->internal_ctx_id,\n\t\t\t\t\t      conf_req_flag,\n\t\t\t\t\t      qop_req,\n\t\t\t\t\t      conf_state,\n\t\t\t\t\t      iov,\n\t\t\t\t\t      iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}", "target": 1}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    OP_REQUIRES_OK_ASYNC(c,\n                         FillCollectiveParams(col_params, REDUCTION_COLLECTIVE,\n                                               c->input(1),\n                                               c->input(2),\n                                               c->input(3)),\n                         done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV2 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "Status GetDeviceForInput(const EagerOperation& op, const EagerContext& ctx,\n                         TensorHandle* tensor_handle, Device** result) {\n  Device* cpu_device = ctx.HostCPU();\n  string device_name;\n  if (tensor_handle->Type() != TensorHandle::LOCAL) {\n    Device* device = tensor_handle->device();\n    device_name = device != nullptr ? device->name() : cpu_device->name();\n    *result = (device == nullptr ? cpu_device : device);\n  } else if (tensor_handle->dtype == DT_RESOURCE) {\n    const Tensor* tensor;\n    TF_RETURN_IF_ERROR(tensor_handle->Tensor(&tensor));\n    if (tensor->NumElements() == 0) {\n      return errors::InvalidArgument(\"Empty resource handle\");\n    }\n    const ResourceHandle& handle = tensor->flat<ResourceHandle>()(0);\n    device_name = handle.device();\n    Device* input_device;\n    TF_RETURN_IF_ERROR(\n        ctx.FindDeviceFromName(device_name.c_str(), &input_device));\n    *result = input_device;\n  } else {\n    Device* device = tensor_handle->device();\n    const bool is_tpu = device != nullptr && device->device_type() == \"TPU\";\n    const bool use_host_memory =\n        is_tpu ? MTypeFromDTypeIntsOnDevice(tensor_handle->dtype)\n               : MTypeFromDType(tensor_handle->dtype);\n    if (use_host_memory) {\n      *result = cpu_device;\n    } else {\n      if (!op.is_function() && device != nullptr && device != cpu_device) {\n        device = absl::get<Device*>(op.Device());\n      }\n      *result = (device == nullptr ? cpu_device : device);\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static struct rq *__migrate_task(struct rq *rq, struct task_struct *p, int dest_cpu)\n{\n\tif (unlikely(!cpu_active(dest_cpu)))\n\t\treturn rq;\n\tif (!cpumask_test_cpu(dest_cpu, tsk_cpus_allowed(p)))\n\t\treturn rq;\n\trq = move_queued_task(rq, p, dest_cpu);\n\treturn rq;\n}", "target": 0}
{"code": "gopher_request_parse(const HttpRequest * req, char *type_id, char *request)\n{\n    ::Parser::Tokenizer tok(req->url.path());\n    if (request)\n        *request = 0;\n    tok.skip('/'); \n    if (tok.atEnd()) {\n        *type_id = GOPHER_DIRECTORY;\n        return;\n    }\n    static const CharacterSet anyByte(\"UTF-8\",0x00, 0xFF);\n    SBuf typeId;\n    (void)tok.prefix(typeId, anyByte, 1); \n    *type_id = typeId[0];\n    if (request) {\n        SBufToCstring(request, tok.remaining().substr(0, MAX_URL-1));\n        rfc1738_unescape(request);\n    }\n}", "target": 1}
{"code": "DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)\n{\n    int i;\n    storeAppendPrintf(sentry, \"HTTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.http_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.http_read_hist[i],\n                          Math::doublePercent(stats.http_read_hist[i], stats.http_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"FTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.ftp_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.ftp_read_hist[i],\n                          Math::doublePercent(stats.ftp_read_hist[i], stats.ftp_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"Gopher I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.gopher_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.gopher_read_hist[i],\n                          Math::doublePercent(stats.gopher_read_hist[i], stats.gopher_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n}", "target": 1}
{"code": "NOEXPORT void cb_new_auth(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n        int idx, long argl, void *argp) {\n    (void)parent; \n    (void)ptr; \n    (void)argl; \n    s_log(LOG_DEBUG, \"Initializing application specific data for %s\",\n        (char *)argp);\n    if(!CRYPTO_set_ex_data(ad, idx, (void *)(-1)))\n        sslerror(\"CRYPTO_set_ex_data\");\n}", "target": 0}
{"code": "static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = l2t_send(tdev, skb, l2e);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    ParaNdis_CheckSumVerifyFlat(IpHeader,\n                                EthPayloadLength,\n                                pcrIpChecksum | pcrFixIPChecksum,\n                                __FUNCTION__);\n}", "target": 1}
{"code": "TEE_Result syscall_hash_init(unsigned long state,\n\t\t\t     const void *iv __maybe_unused,\n\t\t\t     size_t iv_len __maybe_unused)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_init(cs->ctx, cs->algo);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\t{\n\t\t\tstruct tee_obj *o;\n\t\t\tstruct tee_cryp_obj_secret *key;\n\t\t\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  cs->key1, &o);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tif ((o->info.handleFlags &\n\t\t\t     TEE_HANDLE_FLAG_INITIALIZED) == 0)\n\t\t\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t\t\tkey = (struct tee_cryp_obj_secret *)o->attr;\n\t\t\tres = crypto_mac_init(cs->ctx, cs->algo,\n\t\t\t\t\t      (void *)(key + 1), key->key_size);\n\t\t\tif (res != TEE_SUCCESS)\n\t\t\t\treturn res;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\tcs->state = CRYP_STATE_INITIALIZED;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_result_seek)\n{\n\tzval *result;\n\tzend_long row;\n\tpgsql_result_handle *pg_result;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rl\", &result, &row) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, result, -1, \"PostgreSQL result\", le_result);\n\tif (row < 0 || row >= PQntuples(pg_result->result)) {\n\t\tRETURN_FALSE;\n\t}\n\tpg_result->row = (int)row;\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)\n{\n\tint kcmp;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi, *epir = NULL;\n\tstruct epoll_filefd ffd;\n\tep_set_ffd(&ffd, file, fd);\n\tfor (rbp = ep->rbr.rb_node; rbp; ) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&ffd, &epi->ffd);\n\t\tif (kcmp > 0)\n\t\t\trbp = rbp->rb_right;\n\t\telse if (kcmp < 0)\n\t\t\trbp = rbp->rb_left;\n\t\telse {\n\t\t\tepir = epi;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn epir;\n}", "target": 0}
{"code": "void nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t      struct nft_set_binding *binding,\n\t\t\t      enum nft_trans_phase phase)\n{\n\tswitch (phase) {\n\tcase NFT_TRANS_PREPARE:\n\t\tif (nft_set_is_anonymous(set))\n\t\t\tnft_deactivate_next(ctx->net, set);\n\t\tset->use--;\n\t\treturn;\n\tcase NFT_TRANS_ABORT:\n\tcase NFT_TRANS_RELEASE:\n\t\tset->use--;\n\t\tfallthrough;\n\tdefault:\n\t\tnf_tables_unbind_set(ctx, set, binding,\n\t\t\t\t     phase == NFT_TRANS_COMMIT);\n\t}\n}", "target": 0}
{"code": "fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n    if((cc%(bps*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpDiff\",\n                     \"%s\", \"(cc%(bps*stride))!=0\");\n        return 0;\n    }\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[byte * wc + count] = tmp[bps * count + byte];\n\t\t\t#else\n\t\t\tcp[(bps - byte - 1) * wc + count] =\n\t\t\t\ttmp[bps * count + byte];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n\tcp = (uint8 *) cp0;\n\tcp += cc - stride - 1;\n\tfor (count = cc; count > stride; count -= stride)\n\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n    return 1;\n}", "target": 0}
{"code": "void iov_iter_pipe(struct iov_iter *i, int direction,\n\t\t\tstruct pipe_inode_info *pipe,\n\t\t\tsize_t count)\n{\n\tBUG_ON(direction != ITER_PIPE);\n\tWARN_ON(pipe->nrbufs == pipe->buffers);\n\ti->type = direction;\n\ti->pipe = pipe;\n\ti->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\ti->iov_offset = 0;\n\ti->count = count;\n}", "target": 0}
{"code": "merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JSAMPROW work_ptrs[2];\n  JDIMENSION num_rows;          \n  if (upsample->spare_full) {\n    JDIMENSION size = upsample->out_row_width;\n    if (cinfo->out_color_space == JCS_RGB565)\n      size = cinfo->output_width * 2;\n    jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,\n                      size);\n    num_rows = 1;\n    upsample->spare_full = FALSE;\n  } else {\n    num_rows = 2;\n    if (num_rows > upsample->rows_to_go)\n      num_rows = upsample->rows_to_go;\n    out_rows_avail -= *out_row_ctr;\n    if (num_rows > out_rows_avail)\n      num_rows = out_rows_avail;\n    work_ptrs[0] = output_buf[*out_row_ctr];\n    if (num_rows > 1) {\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\n    } else {\n      work_ptrs[1] = upsample->spare_row;\n      upsample->spare_full = TRUE;\n    }\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\n  }\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  if (!upsample->spare_full)\n    (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "SPL_METHOD(SplDoublyLinkedList, offsetSet)\n{\n\tzval                  *zindex, *value;\n\tspl_dllist_object     *intern;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"zz\", &zindex, &value) == FAILURE) {\n\t\treturn;\n\t}\n\tintern = Z_SPLDLLIST_P(getThis());\n\tif (Z_TYPE_P(zindex) == IS_NULL) {\n\t\tspl_ptr_llist_push(intern->llist, value);\n\t} else {\n\t\tzend_long                   index;\n\t\tspl_ptr_llist_element *element;\n\t\tindex = spl_offset_convert_to_long(zindex);\n\t\tif (index < 0 || index >= intern->llist->count) {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid or out of range\", 0);\n\t\t\treturn;\n\t\t}\n\t\telement = spl_ptr_llist_offset(intern->llist, index, intern->flags & SPL_DLLIST_IT_LIFO);\n\t\tif (element != NULL) {\n\t\t\tif (intern->llist->dtor) {\n\t\t\t\tintern->llist->dtor(element);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&element->data);\n\t\t\tZVAL_COPY_VALUE(&element->data, value);\n\t\t\tif (intern->llist->ctor) {\n\t\t\t\tintern->llist->ctor(element);\n\t\t\t}\n\t\t} else {\n\t\t\tzval_ptr_dtor(value);\n\t\t\tzend_throw_exception(spl_ce_OutOfRangeException, \"Offset invalid\", 0);\n\t\t\treturn;\n\t\t}\n\t}\n} ", "target": 1}
{"code": "static void encode_open(struct xdr_stream *xdr, const struct nfs_openargs *arg, struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_OPEN, decode_open_maxsz, hdr);\n\tencode_openhdr(xdr, arg);\n\tencode_opentype(xdr, arg);\n\tswitch (arg->claim) {\n\tcase NFS4_OPEN_CLAIM_NULL:\n\t\tencode_claim_null(xdr, arg->name);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_PREVIOUS:\n\t\tencode_claim_previous(xdr, arg->u.delegation_type);\n\t\tbreak;\n\tcase NFS4_OPEN_CLAIM_DELEGATE_CUR:\n\t\tencode_claim_delegate_cur(xdr, arg->name, &arg->u.delegation);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}", "target": 0}
{"code": "static int fit_image_verify_sig(const void *fit, int image_noffset,\n\t\t\t\tconst char *data, size_t size,\n\t\t\t\tconst void *sig_blob, int sig_offset)\n{\n\tint noffset;\n\tchar *err_msg = \"\";\n\tint verified = 0;\n\tint ret;\n\tfdt_for_each_subnode(noffset, fit, image_noffset) {\n\t\tconst char *name = fit_get_name(fit, noffset, NULL);\n\t\tif (strchr(name, '@')) {\n\t\t\terr_msg = \"Node name contains @\";\n\t\t\tgoto error;\n\t\t}\n\t\tif (!strncmp(name, FIT_SIG_NODENAME,\n\t\t\t     strlen(FIT_SIG_NODENAME))) {\n\t\t\tret = fit_image_check_sig(fit, noffset, data,\n\t\t\t\t\t\t  size, -1, &err_msg);\n\t\t\tif (ret) {\n\t\t\t\tputs(\"- \");\n\t\t\t} else {\n\t\t\t\tputs(\"+ \");\n\t\t\t\tverified = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {\n\t\terr_msg = \"Corrupted or truncated tree\";\n\t\tgoto error;\n\t}\n\treturn verified ? 0 : -EPERM;\nerror:\n\tprintf(\" error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn -1;\n}", "target": 0}
{"code": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}", "target": 1}
{"code": "\t\tauto GetKey(Local<Context> context) -> Local<Name> {\n\t\t\tauto key_inner = key->CopyInto();\n\t\t\treturn (key_inner->IsString() || key_inner->IsSymbol()) ?\n\t\t\t\tkey_inner.As<Name>() : Unmaybe(key_inner->ToString(context)).As<Name>();\n\t\t}", "target": 0}
{"code": "static int skip_boxes(JXLParseContext *ctx, const uint8_t *buf, int buf_size)\n{\n    GetByteContext gb;\n    if (ctx->skip > buf_size)\n        return AVERROR_BUFFER_TOO_SMALL;\n    buf += ctx->skip;\n    buf_size -= ctx->skip;\n    bytestream2_init(&gb, buf, buf_size);\n    while (1) {\n        uint64_t size;\n        int head_size = 4;\n        if (bytestream2_peek_le16(&gb) == FF_JPEGXL_CODESTREAM_SIGNATURE_LE)\n            break;\n        if (bytestream2_peek_le64(&gb) == FF_JPEGXL_CONTAINER_SIGNATURE_LE)\n            break;\n        if (bytestream2_get_bytes_left(&gb) < 8)\n            return AVERROR_BUFFER_TOO_SMALL;\n        size = bytestream2_get_be32(&gb);\n        if (size == 1) {\n            if (bytestream2_get_bytes_left(&gb) < 12)\n                return AVERROR_BUFFER_TOO_SMALL;\n            size = bytestream2_get_be64(&gb);\n            head_size = 12;\n        }\n        if (!size)\n            return AVERROR_INVALIDDATA;\n        if (size <= head_size + 4)\n            return AVERROR_INVALIDDATA;\n        ctx->skip += size;\n        bytestream2_skip(&gb, size - head_size);\n        if (bytestream2_get_bytes_left(&gb) <= 0)\n            return AVERROR_BUFFER_TOO_SMALL;\n    }\n    return 0;\n}", "target": 1}
{"code": "do_local_notify(xmlNode * notify_src, const char *client_id,\n                gboolean sync_reply, gboolean from_peer)\n{\n    cib_client_t *client_obj = NULL;\n    int local_rc = pcmk_ok;\n    if (client_id != NULL) {\n        client_obj = g_hash_table_lookup(client_list, client_id);\n    } else {\n        crm_trace(\"No client to sent the response to. F_CIB_CLIENTID not set.\");\n    }\n    if (client_obj == NULL) {\n        local_rc = -ECONNRESET;\n    } else {\n        int rid = 0;\n        if(sync_reply) {\n            CRM_LOG_ASSERT(client_obj->request_id);\n            rid = client_obj->request_id;\n            client_obj->request_id = 0;\n            crm_trace(\"Sending response %d to %s %s\",\n                      rid, client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        } else {\n            crm_trace(\"Sending an event to %s %s\",\n                      client_obj->name, from_peer?\"(originator of delegated request)\":\"\");\n        }\n        if (client_obj->ipc && crm_ipcs_send(client_obj->ipc, rid, notify_src, !sync_reply) < 0) {\n            local_rc = -ENOMSG;\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        } else if (client_obj->session) {\n            crm_send_remote_msg(client_obj->session, notify_src, client_obj->encrypted);\n#endif\n        } else if(client_obj->ipc == NULL) {\n            crm_err(\"Unknown transport for %s\", client_obj->name);\n        }\n    }\n    if (local_rc != pcmk_ok && client_obj != NULL) {\n        crm_warn(\"%sSync reply to %s failed: %s\",\n                 sync_reply ? \"\" : \"A-\",\n                 client_obj ? client_obj->name : \"<unknown>\", pcmk_strerror(local_rc));\n    }\n}", "target": 1}
{"code": "int VP8LHuffmanTablesAllocate(int size, HuffmanTables* huffman_tables) {\n  HuffmanTablesSegment* const root = &huffman_tables->root;\n  huffman_tables->curr_segment = root;\n  root->start = (HuffmanCode*)WebPSafeMalloc(size, sizeof(*root->start));\n  if (root->start == NULL) return 0;\n  root->curr_table = root->start;\n  root->next = NULL;\n  root->size = size;\n  return 1;\n}", "target": 0}
{"code": "static int unpack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_unpack *pkt;\n\tGIT_UNUSED(len);\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->type = GIT_PKT_UNPACK;\n\tif (!git__prefixcmp(line, \"unpack ok\"))\n\t\tpkt->unpack_ok = 1;\n\telse\n\t\tpkt->unpack_ok = 0;\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}", "target": 0}
{"code": "rb_reg_prepare_enc(VALUE re, VALUE str, int warn)\n{\n    rb_encoding *enc = 0;\n    int cr = str_coderange(str);\n    if (cr == ENC_CODERANGE_BROKEN) {\n        rb_raise(rb_eArgError,\n            \"invalid byte sequence in %s\",\n            rb_enc_name(rb_enc_get(str)));\n    }\n    rb_reg_check(re);\n    enc = rb_enc_get(str);\n    if (RREGEXP_PTR(re)->enc == enc) {\n    }\n    else if (cr == ENC_CODERANGE_7BIT &&\n\t    RREGEXP_PTR(re)->enc == rb_usascii_encoding()) {\n\tenc = RREGEXP_PTR(re)->enc;\n    }\n    else if (!rb_enc_asciicompat(enc)) {\n\treg_enc_error(re, str);\n    }\n    else if (rb_reg_fixed_encoding_p(re)) {\n        if ((!rb_enc_asciicompat(RREGEXP_PTR(re)->enc) ||\n\t     cr != ENC_CODERANGE_7BIT)) {\n\t    reg_enc_error(re, str);\n\t}\n\tenc = RREGEXP_PTR(re)->enc;\n    }\n    else if (warn && (RBASIC(re)->flags & REG_ENCODING_NONE) &&\n\tenc != rb_ascii8bit_encoding() &&\n\tcr != ENC_CODERANGE_7BIT) {\n\trb_warn(\"regexp match /.../n against to %s string\",\n\t\trb_enc_name(enc));\n    }\n    return enc;\n}", "target": 0}
{"code": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tpipe_buf_get(ipipe, ibuf);\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\treturn ret;\n}", "target": 1}
{"code": "void my_output_message( j_common_ptr ) {} ", "target": 1}
{"code": "static void ip_expire(unsigned long arg)\n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\tspin_lock(&qp->q.lock);\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\tipq_kill(qp);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n\t\t}\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}", "target": 1}
{"code": "TfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void addFrames(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n    FGFrameContent *fg = new FGFrameContent();\n    fg->setStackID(\"1\");\n    OFCHECK(fg);\n    if (fg)\n    {\n        EctEnhancedCT::FramesType frames = ct->getFrames();\n        for (Uint16 frameNo = 1; frameNo <= NUM_FRAMES; frameNo++)\n        {\n            OFCHECK(fg->setFrameAcquisitionNumber(frameNo).good());\n            OFCHECK(fg->setFrameReferenceDateTime(\"20190816092557\").good());\n            OFCHECK(fg->setFrameAcquisitionDateTime(\"20190816092557\").good());\n            OFCHECK(fg->setFrameAcquisitionDuration(0.001).good());\n            OFCHECK(fg->setInStackPositionNumber(frameNo).good());\n            OFCHECK(fg->setDimensionIndexValues(1, 0).good());\n            OFCHECK(fg->setDimensionIndexValues(frameNo, 1).good());\n            OFVector<FGBase *> groups;\n            groups.push_back(fg);\n            Uint16 *data = new Uint16[NUM_PIXELS_PER_FRAME];\n            for (size_t i = 0; i < NUM_PIXELS_PER_FRAME; ++i)\n            {\n                data[i] = 0x4141;\n            }\n            OFCHECK(\n                OFget<EctEnhancedCT::Frames<Uint16>>(&frames)->addFrame(data, NUM_PIXELS_PER_FRAME, groups).good());\n            delete[] data;\n        }\n    }\n    delete fg;\n}", "target": 0}
{"code": "execlists_unwind_incomplete_requests(struct intel_engine_execlists *execlists)\n{\n\tstruct intel_engine_cs *engine =\n\t\tcontainer_of(execlists, typeof(*engine), execlists);\n\treturn __unwind_incomplete_requests(engine);\n}", "target": 0}
{"code": "rpl_daoack_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length)\n{\n        const struct nd_rpl_daoack *daoack = (const struct nd_rpl_daoack *)bp;\n        const char *dagid_str = \"<elided>\";\n        ND_TCHECK2(*daoack, ND_RPL_DAOACK_MIN_LEN);\n        if (length < ND_RPL_DAOACK_MIN_LEN)\n        \tgoto tooshort;\n        bp += ND_RPL_DAOACK_MIN_LEN;\n        length -= ND_RPL_DAOACK_MIN_LEN;\n        if(RPL_DAOACK_D(daoack->rpl_flags)) {\n                ND_TCHECK2(daoack->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, daoack->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,status:%u]\",\n                  dagid_str,\n                  daoack->rpl_daoseq,\n                  daoack->rpl_instanceid,\n                  daoack->rpl_status));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|dao-truncated]\"));\n\treturn;\ntooshort:\n\tND_PRINT((ndo,\" [|dao-length too short]\"));\n\treturn;\n}", "target": 1}
{"code": "static bool _valid_hex(char *s, const char *file, const char *func, const int line)\n{\n\tbool ret = false;\n\tint i, len;\n\tif (unlikely(!s)) {\n\t\tapplog(LOG_ERR, \"Null string passed to valid_hex from\"IN_FMT_FFL, file, func, line);\n\t\treturn ret;\n\t}\n\tlen = strlen(s);\n\tif (unlikely(!len)) {\n\t\tapplog(LOG_ERR, \"Zero length string passed to valid_hex from\"IN_FMT_FFL, file, func, line);\n\t\treturn ret;\n\t}\n\tfor (i = 0; i < len; i++) {\n\t\tunsigned char idx = s[i];\n\t\tif (unlikely(hex2bin_tbl[idx] < 0)) {\n\t\t\tapplog(LOG_ERR, \"Invalid char %x passed to valid_hex from\"IN_FMT_FFL, idx, file, func, line);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tret = true;\n\treturn ret;\n}", "target": 0}
{"code": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n  free(copy);\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n  return result;\n}", "target": 1}
{"code": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    return MK_PLUGIN_RET_NOT_ME;\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageGifCtx(im, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc_ctrl_data *cdata,\n\t\t\t\t       struct sof_ipc_ctrl_data_params *sparams,\n\t\t\t\t       bool send)\n{\n\tstruct sof_ipc_ctrl_data *partdata;\n\tsize_t send_bytes;\n\tsize_t offset = 0;\n\tsize_t msg_bytes;\n\tsize_t pl_size;\n\tint err;\n\tint i;\n\tpartdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!partdata)\n\t\treturn -ENOMEM;\n\tif (send)\n\t\terr = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,\n\t\t\t\t\t       sparams);\n\telse\n\t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n\t\t\t\t\t       sparams);\n\tif (err < 0)\n\t\treturn err;\n\tmsg_bytes = sparams->msg_bytes;\n\tpl_size = sparams->pl_size;\n\tmemcpy(partdata, cdata, sparams->hdr_bytes);\n\tmutex_lock(&sdev->ipc->tx_mutex);\n\tfor (i = 0; i < sparams->num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, pl_size);\n\t\tpartdata->num_elems = send_bytes;\n\t\tpartdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;\n\t\tpartdata->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tpartdata->elems_remaining = msg_bytes;\n\t\tif (send)\n\t\t\tmemcpy(sparams->dst, sparams->src + offset, send_bytes);\n\t\terr = sof_ipc_tx_message_unlocked(sdev->ipc,\n\t\t\t\t\t\t  partdata->rhdr.hdr.cmd,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (!send)\n\t\t\tmemcpy(sparams->dst + offset, sparams->src, send_bytes);\n\t\toffset += pl_size;\n\t}\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\tkfree(partdata);\n\treturn err;\n}", "target": 1}
{"code": "static void evtchn_fifo_handle_events(unsigned cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, false);\n}", "target": 1}
{"code": "static struct sctp_auth_bytes *sctp_auth_make_key_vector(\n\t\t\tsctp_random_param_t *random,\n\t\t\tsctp_chunks_param_t *chunks,\n\t\t\tsctp_hmac_algo_param_t *hmacs,\n\t\t\tgfp_t gfp)\n{\n\tstruct sctp_auth_bytes *new;\n\t__u32\tlen;\n\t__u32\toffset = 0;\n\tlen = ntohs(random->param_hdr.length) + ntohs(hmacs->param_hdr.length);\n        if (chunks)\n\t\tlen += ntohs(chunks->param_hdr.length);\n\tnew = kmalloc(sizeof(struct sctp_auth_bytes) + len, gfp);\n\tif (!new)\n\t\treturn NULL;\n\tnew->len = len;\n\tmemcpy(new->data, random, ntohs(random->param_hdr.length));\n\toffset += ntohs(random->param_hdr.length);\n\tif (chunks) {\n\t\tmemcpy(new->data + offset, chunks,\n\t\t\tntohs(chunks->param_hdr.length));\n\t\toffset += ntohs(chunks->param_hdr.length);\n\t}\n\tmemcpy(new->data + offset, hmacs, ntohs(hmacs->param_hdr.length));\n\treturn new;\n}", "target": 0}
{"code": "static u8 BS_ReadByte(GF_BitStream *bs)\n{\n\tBool is_eos;\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tu8 res;\n\t\tif (bs->position >= bs->size) {\n\t\t\tif (bs->EndOfStream) bs->EndOfStream(bs->par);\n\t\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t\t\treturn 0;\n\t\t}\n\t\tres = bs->original[bs->position++];\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size) && (bs->original[bs->position]<0x04)) {\n\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\tres = bs->original[bs->position++];\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\n\tif (bs->cache_write)\n\t\tbs_flush_write_cache(bs);\n\tis_eos = gf_feof(bs->stream);\n\tif (!is_eos || bs->cache_read) {\n\t\tu8 res;\n\t\tBool loc_eos=GF_FALSE;\n\t\tassert(bs->position<=bs->size);\n\t\tbs->position++;\n\t\tres = gf_bs_load_byte(bs, &loc_eos);\n\t\tif (loc_eos) goto bs_eof;\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\tif ((bs->nb_zeros==2) && (res==0x03) && (bs->position<bs->size)) {\n\t\t\t\tu8 next = gf_bs_load_byte(bs, &loc_eos);\n\t\t\t\tif (next < 0x04) {\n\t\t\t\t\tbs->nb_zeros = 0;\n\t\t\t\t\tres = next;\n\t\t\t\t\tbs->position++;\n\t\t\t\t} else {\n\t\t\t\t\tgf_bs_seek(bs, bs->position);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!res) bs->nb_zeros++;\n\t\t\telse bs->nb_zeros = 0;\n\t\t}\n\t\treturn res;\n\t}\nbs_eof:\n\tif (bs->EndOfStream) {\n\t\tbs->EndOfStream(bs->par);\n\t\tif (!bs->overflow_state) bs->overflow_state = 1;\n\t} else {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[BS] Attempt to overread bitstream\\n\"));\n\t}\n\tassert(bs->position <= 1+bs->size);\n\treturn 0;\n}", "target": 1}
{"code": "static int rb_head_page_set_head(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t struct buffer_page *head,\n\t\t\t\t struct buffer_page *prev,\n\t\t\t\t int old_flag)\n{\n\treturn rb_head_page_set(cpu_buffer, head, prev,\n\t\t\t\told_flag, RB_PAGE_HEAD);\n}", "target": 0}
{"code": "bounded_iostream::bounded_iostream(Sirikata::DecoderWriter *w,\n                                   const std::function<void(Sirikata::DecoderWriter*, size_t)> &size_callback,\n                                   const Sirikata::JpegAllocator<uint8_t> &alloc) \n    : parent(w), err(Sirikata::JpegError::nil()) {\n    this->size_callback = size_callback;\n    buffer_position = 0;\n    byte_position = 0;\n    byte_bound = 0x7FFFFFFF;\n    num_bytes_attempted_to_write = 0;\n    set_bound(0);\n}", "target": 0}
{"code": "void CLASS panasonic_load_raw()\n{\n  int row, col, i, j, sh = 0, pred[2], nonz[2];\n  pana_bits(0);\n  for (row = 0; row < height; row++)\n  {\n#ifdef LIBRAW_LIBRARY_BUILD\n    checkCancel();\n#endif\n    for (col = 0; col < raw_width; col++)\n    {\n      if ((i = col % 14) == 0)\n        pred[0] = pred[1] = nonz[0] = nonz[1] = 0;\n      if (i % 3 == 2)\n        sh = 4 >> (3 - pana_bits(2));\n      if (nonz[i & 1])\n      {\n        if ((j = pana_bits(8)))\n        {\n          if ((pred[i & 1] -= 0x80 << sh) < 0 || sh == 4)\n            pred[i & 1] &= ~((~0u) << sh);\n          pred[i & 1] += j << sh;\n        }\n      }\n      else if ((nonz[i & 1] = pana_bits(8)) || i > 11)\n        pred[i & 1] = nonz[i & 1] << 4 | pana_bits(4);\n      if ((RAW(row, col) = pred[col & 1]) > 4098 && col < width)\n        derror();\n    }\n  }\n}", "target": 1}
{"code": "static struct ast_sip_endpoint *ip_identify(pjsip_rx_data *rdata)\n{\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tast_sockaddr_parse(&addr_with_tp.addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);\n\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->pkt_info.src_port);\n\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n}", "target": 1}
{"code": "comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n\tiface->get_thumbnail = comics_document_thumbnails_get_thumbnail;\n\tiface->get_dimensions = comics_document_thumbnails_get_dimensions;\n}", "target": 1}
{"code": "void mark_files_ro(struct super_block *sb)\n{\n\tstruct file *f;\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, f) {\n\t\tif (!file_count(f))\n\t\t\tcontinue;\n\t\tif (!(f->f_mode & FMODE_WRITE))\n\t\t\tcontinue;\n\t\tspin_lock(&f->f_lock);\n\t\tf->f_mode &= ~FMODE_WRITE;\n\t\tspin_unlock(&f->f_lock);\n\t\tif (file_check_writeable(f) != 0)\n\t\t\tcontinue;\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t\tfile_release_write(f);\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n}", "target": 1}
{"code": "acpi_os_write_pci_configuration(struct acpi_pci_id * pci_id, u32 reg,\n\t\t\t\tu64 value, u32 width)\n{\n\tint result, size;\n\tswitch (width) {\n\tcase 8:\n\t\tsize = 1;\n\t\tbreak;\n\tcase 16:\n\t\tsize = 2;\n\t\tbreak;\n\tcase 32:\n\t\tsize = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn AE_ERROR;\n\t}\n\tresult = raw_pci_write(pci_id->segment, pci_id->bus,\n\t\t\t\tPCI_DEVFN(pci_id->device, pci_id->function),\n\t\t\t\treg, size, value);\n\treturn (result ? AE_ERROR : AE_OK);\n}", "target": 0}
{"code": "queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "static void parse_version(pj_scanner *scanner, \n                          volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINVER;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    if (*(scanner->curptr+2) != '0') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "static int tcp_parse_options(struct pico_frame *f)\n{\n    struct pico_socket_tcp *t = (struct pico_socket_tcp *)f->sock;\n    uint8_t *opt = f->transport_hdr + PICO_SIZE_TCPHDR;\n    uint32_t i = 0;\n    f->timestamp = 0;\n    if (f->buffer + f->buffer_len > f->transport_hdr + f->transport_len)\n        return -1;\n    while (i < (f->transport_len - PICO_SIZE_TCPHDR)) {\n        uint8_t type =  opt[i++];\n        uint8_t len;\n        if(i < (f->transport_len - PICO_SIZE_TCPHDR) && (type > 1))\n            len =  opt[i++];\n        else\n            len = 1;\n        if (f->payload && ((opt + i) > f->payload))\n            break;\n        if (len == 0) {\n            return -1;\n        }\n        tcp_dbg_options(\"Received option '%d', len = %d \\n\", type, len);\n        switch (type) {\n        case PICO_TCP_OPTION_NOOP:\n        case PICO_TCP_OPTION_END:\n            break;\n        case PICO_TCP_OPTION_WS:\n            tcp_parse_option_ws(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK_OK:\n            tcp_parse_option_sack_ok(t, f, len, &i);\n            break;\n        case PICO_TCP_OPTION_MSS:\n            tcp_parse_option_mss(t, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_TIMESTAMP:\n            tcp_parse_option_timestamp(t, f, len, opt, &i);\n            break;\n        case PICO_TCP_OPTION_SACK:\n            tcp_rcv_sack(t, opt + i, len - 2);\n            i = i + len - 2;\n            break;\n        default:\n            tcp_dbg_options(\"TCP: received unsupported option %u\\n\", type);\n            i = i + len - 2;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "gplotCreate(const char  *rootname,\n            l_int32      outformat,\n            const char  *title,\n            const char  *xlabel,\n            const char  *ylabel)\n{\nchar    *newroot;\nchar     buf[L_BUF_SIZE];\nl_int32  badchar;\nGPLOT   *gplot;\n    PROCNAME(\"gplotCreate\");\n    if (!rootname)\n        return (GPLOT *)ERROR_PTR(\"rootname not defined\", procName, NULL);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return (GPLOT *)ERROR_PTR(\"outformat invalid\", procName, NULL);\n    stringCheckForChars(rootname, \"`;&|><\\\"?*\", &badchar);\n    if (badchar)  \n        return (GPLOT *)ERROR_PTR(\"invalid rootname\", procName, NULL);\n    if ((gplot = (GPLOT *)LEPT_CALLOC(1, sizeof(GPLOT))) == NULL)\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    gplot->cmddata = sarrayCreate(0);\n    gplot->datanames = sarrayCreate(0);\n    gplot->plotdata = sarrayCreate(0);\n    gplot->plottitles = sarrayCreate(0);\n    gplot->plotstyles = numaCreate(0);\n    newroot = genPathname(rootname, NULL);\n    gplot->rootname = newroot;\n    gplot->outformat = outformat;\n    snprintf(buf, L_BUF_SIZE, \"%s.cmd\", rootname);\n    gplot->cmdname = stringNew(buf);\n    if (outformat == GPLOT_PNG)\n        snprintf(buf, L_BUF_SIZE, \"%s.png\", newroot);\n    else if (outformat == GPLOT_PS)\n        snprintf(buf, L_BUF_SIZE, \"%s.ps\", newroot);\n    else if (outformat == GPLOT_EPS)\n        snprintf(buf, L_BUF_SIZE, \"%s.eps\", newroot);\n    else if (outformat == GPLOT_LATEX)\n        snprintf(buf, L_BUF_SIZE, \"%s.tex\", newroot);\n    gplot->outname = stringNew(buf);\n    if (title) gplot->title = stringNew(title);\n    if (xlabel) gplot->xlabel = stringNew(xlabel);\n    if (ylabel) gplot->ylabel = stringNew(ylabel);\n    return gplot;\n}", "target": 1}
{"code": "static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct net *net = sock_net(cb->skb->sk);\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}", "target": 1}
{"code": "static inline void exit_io_context(void)\n{\n}", "target": 1}
{"code": "static int openssl_push_check_result(lua_State *L, int ret, const char* name)\n{\n  switch (ret)\n  {\n  case 1:\n    lua_pushboolean(L, 1);\n    if (name)\n    {\n      lua_pushstring(L, name);\n      ret = 2;\n    }\n    break;\n  case 0:\n    lua_pushboolean(L, 0);\n    ret = 1;\n    break;\n  case -1:\n    lua_pushnil(L);\n    lua_pushliteral(L, \"internal\");\n    ret = 2;\n  case -2:\n    lua_pushnil(L);\n    lua_pushliteral(L, \"malformed\");\n    ret = 2;\n  default:\n    lua_pushnil(L);\n    lua_pushinteger(L, ret);\n    ret = 2;\n  }\n  return ret;\n}", "target": 0}
{"code": "void BezierCircle(double r,char *action)\n{\n    char *outpos = outputbuffer;\n    outpos +=\n    sprintf(outpos,\" %12.3f 0 m %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",-r,-r,r*BzK,-r*BzK,r,r);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c\\n\",r*BzK,r,r,r*BzK,r);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",r,-r*BzK,r*BzK,-r,-r);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c %s\\n\",-r*BzK,-r,-r,-r*BzK,-r,action);\n    sendClean(outputbuffer);\n}", "target": 0}
{"code": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int scsi_verify_blk_ioctl(struct block_device *bd, unsigned int cmd)\n{\n\tif (bd && bd == bd->bd_contains)\n\t\treturn 0;\n\tswitch (cmd) {\n\tcase SCSI_IOCTL_GET_IDLUN:\n\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\tcase SCSI_IOCTL_GET_PCI:\n\tcase SCSI_IOCTL_PROBE_HOST:\n\tcase SG_GET_VERSION_NUM:\n\tcase SG_SET_TIMEOUT:\n\tcase SG_GET_TIMEOUT:\n\tcase SG_GET_RESERVED_SIZE:\n\tcase SG_SET_RESERVED_SIZE:\n\tcase SG_EMULATED_HOST:\n\t\treturn 0;\n\tcase CDROM_GET_CAPABILITY:\n\t\treturn -ENOIOCTLCMD;\n\tdefault:\n\t\tbreak;\n\t}\n\tprintk_ratelimited(KERN_WARNING\n\t\t\t   \"%s: sending ioctl %x to a partition!\\n\", current->comm, cmd);\n\treturn capable(CAP_SYS_RAWIO) ? 0 : -ENOIOCTLCMD;\n}", "target": 0}
{"code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n\tif (tcp_sk(sk)->highest_sack == skb_unlinked)\n\t\ttcp_sk(sk)->highest_sack = NULL;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n    const Tensor* sep_t;\n    OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));\n    const tstring separator = sep_t->scalar<tstring>()();\n    std::vector<std::unique_ptr<ColumnInterface<tstring>>> columns =\n        GenerateColumnsFromInput<tstring>(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64 batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    StringCrosser<tstring> crosser(columns, 0, 0, separator);\n    OutputUpdater<tstring> updater(output_start_indices, indices_out,\n                                   values_out);\n    auto do_work = [&columns, crosser, updater](int64 begin, int64 end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<tstring> product_iterator(columns, b);\n        int64 cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    const T min_as_quantized = FloatToQuantized<T>(0.0f, min_input, max_input);\n    if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n      auto input_ui8_array = input.flat<quint8>();\n      meta::Clamp(context, input_ui8_array.data(), input_ui8_array.size(),\n                  min_as_quantized, 255, output->flat<quint8>().data());\n    } else {\n      output->flat<T>().device(context->eigen_cpu_device()) =\n          input.flat<T>().cwiseMax(min_as_quantized).template cast<T>();\n    }\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "static void stellaris_enet_class_init(ObjectClass *klass, void *data)\n{\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n    k->init = stellaris_enet_init;\n    dc->unrealize = stellaris_enet_unrealize;\n    dc->props = stellaris_enet_properties;\n    dc->vmsd = &vmstate_stellaris_enet;\n}", "target": 0}
{"code": "static mp_obj_t array_extend(mp_obj_t self_in, mp_obj_t arg_in) {\n    assert((MICROPY_PY_BUILTINS_BYTEARRAY && mp_obj_is_type(self_in, &mp_type_bytearray))\n        || (MICROPY_PY_ARRAY && mp_obj_is_type(self_in, &mp_type_array)));\n    mp_obj_array_t *self = MP_OBJ_TO_PTR(self_in);\n    mp_buffer_info_t arg_bufinfo;\n    mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n    size_t sz = mp_binary_get_size('@', self->typecode, NULL);\n    size_t len = arg_bufinfo.len / sz;\n    if (self->free < len) {\n        self->items = m_renew(byte, self->items, (self->len + self->free) * sz, (self->len + len) * sz);\n        self->free = 0;\n        if (self_in == arg_in) {\n            mp_get_buffer_raise(arg_in, &arg_bufinfo, MP_BUFFER_READ);\n        }\n    } else {\n        self->free -= len;\n    }\n    mp_seq_copy((byte *)self->items + self->len * sz, arg_bufinfo.buf, len * sz, byte);\n    self->len += len;\n    return mp_const_none;\n}", "target": 0}
{"code": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}", "target": 1}
{"code": "alloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr, \n             \"%s: Maximum allocation size exceeded \"\n             \"(maxsize = %lu; size = %lu).\\n\",\n             fn_name,\n             (unsigned long)alloc_limit, \n             (unsigned long)size);\n}", "target": 1}
{"code": "static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n\tbool phdr_found = false;\n\tint i;\n#if R_BIN_ELF64\n\tconst bool is_elf64 = true;\n#else\n\tconst bool is_elf64 = false;\n#endif\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tfor (i = 0; i < phnum; i++) {\n\t\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\t\tint j = 0;\n\t\tconst size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n\t\tint len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (phdr)\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j);\n\t\tif (bin->phdr[i].p_type == PT_PHDR) {\n\t\t\tphdr_found = true;\n\t\t}\n\t\tif (is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_offset = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_vaddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_paddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_filesz = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_memsz = R_BIN_ELF_READWORD (phdr, j);\n\t\tif (!is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_align = R_BIN_ELF_READWORD (phdr, j);\n\t}\n\tif (linux_kernel_hack && phdr_found) {\n\t\tut64 load_addr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tbin->ehdr.e_phoff = Elf_(r_bin_elf_v2p) (bin, load_addr + bin->ehdr.e_phoff);\n\t\treturn read_phdr (bin, false);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "int TfLiteIntArrayGetSizeInBytes(int size) {\n  static TfLiteIntArray dummy;\n  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n#if defined(_MSC_VER)\n  computed_size -= sizeof(dummy.data[0]);\n#endif\n  return computed_size;\n}", "target": 1}
{"code": "static int xennet_xdp_xmit(struct net_device *dev, int n,\n\t\t\t   struct xdp_frame **frames, u32 flags)\n{\n\tunsigned int num_queues = dev->real_num_tx_queues;\n\tstruct netfront_info *np = netdev_priv(dev);\n\tstruct netfront_queue *queue = NULL;\n\tunsigned long irq_flags;\n\tint nxmit = 0;\n\tint i;\n\tif (unlikely(np->broken))\n\t\treturn -ENODEV;\n\tif (unlikely(flags & ~XDP_XMIT_FLAGS_MASK))\n\t\treturn -EINVAL;\n\tqueue = &np->queues[smp_processor_id() % num_queues];\n\tspin_lock_irqsave(&queue->tx_lock, irq_flags);\n\tfor (i = 0; i < n; i++) {\n\t\tstruct xdp_frame *xdpf = frames[i];\n\t\tif (!xdpf)\n\t\t\tcontinue;\n\t\tif (xennet_xdp_xmit_one(dev, queue, xdpf))\n\t\t\tbreak;\n\t\tnxmit++;\n\t}\n\tspin_unlock_irqrestore(&queue->tx_lock, irq_flags);\n\treturn nxmit;\n}", "target": 0}
{"code": "static RList* sections(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinSection* sect = NULL;\n\tpsxexe_header psxheader = {0};\n\tut64 sz = 0;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tif (!(sect = R_NEW0 (RBinSection))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"Truncated Header\\n\");\n\t\tfree (sect);\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tsz = r_buf_size (bf->buf);\n\tsect->name = strdup (\"TEXT\");\n\tsect->paddr = PSXEXE_TEXTSECTION_OFFSET;\n\tsect->size = sz - PSXEXE_TEXTSECTION_OFFSET;\n\tsect->vaddr = psxheader.t_addr;\n\tsect->vsize = psxheader.t_size;\n\tsect->perm = R_PERM_RX;\n\tsect->add = true;\n\tsect->has_strings = true;\n\tr_list_append (ret, sect);\n\treturn ret;\n}", "target": 1}
{"code": " */\nstatic inline zval *add_next_index_object(zval *arg, zval *tmp)\n{\n\tHashTable *symtable;\n\tif (Z_TYPE_P(arg) == IS_OBJECT) {\n\t\tsymtable = Z_OBJPROP_P(arg);\n\t} else {\n\t\tsymtable = Z_ARRVAL_P(arg);\n\t}\n\treturn zend_hash_next_index_insert(symtable, tmp);", "target": 0}
{"code": "static void do_free_upto(BIO *f, BIO *upto)\n\t{\n\tif (upto)\n\t\t{\n\t\tBIO *tbio;\n\t\tdo \n\t\t\t{\n\t\t\ttbio = BIO_pop(f);\n\t\t\tBIO_free(f);\n\t\t\tf = tbio;\n\t\t\t}\n\t\twhile (f != upto);\n\t\t}\n\telse\n\t\tBIO_free_all(f);\n\t}", "target": 1}
{"code": "const char *enter_repo(const char *path, int strict)\n{\n\tstatic struct strbuf validated_path = STRBUF_INIT;\n\tstatic struct strbuf used_path = STRBUF_INIT;\n\tif (!path)\n\t\treturn NULL;\n\tif (!strict) {\n\t\tstatic const char *suffix[] = {\n\t\t\t\"/.git\", \"\", \".git/.git\", \".git\", NULL,\n\t\t};\n\t\tconst char *gitfile;\n\t\tint len = strlen(path);\n\t\tint i;\n\t\twhile ((1 < len) && (path[len-1] == '/'))\n\t\t\tlen--;\n\t\tif (PATH_MAX <= len)\n\t\t\treturn NULL;\n\t\tstrbuf_reset(&used_path);\n\t\tstrbuf_reset(&validated_path);\n\t\tstrbuf_add(&used_path, path, len);\n\t\tstrbuf_add(&validated_path, path, len);\n\t\tif (used_path.buf[0] == '~') {\n\t\t\tchar *newpath = interpolate_path(used_path.buf, 0);\n\t\t\tif (!newpath)\n\t\t\t\treturn NULL;\n\t\t\tstrbuf_attach(&used_path, newpath, strlen(newpath),\n\t\t\t\t      strlen(newpath));\n\t\t}\n\t\tfor (i = 0; suffix[i]; i++) {\n\t\t\tstruct stat st;\n\t\t\tsize_t baselen = used_path.len;\n\t\t\tstrbuf_addstr(&used_path, suffix[i]);\n\t\t\tif (!stat(used_path.buf, &st) &&\n\t\t\t    (S_ISREG(st.st_mode) ||\n\t\t\t    (S_ISDIR(st.st_mode) && is_git_directory(used_path.buf)))) {\n\t\t\t\tstrbuf_addstr(&validated_path, suffix[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrbuf_setlen(&used_path, baselen);\n\t\t}\n\t\tif (!suffix[i])\n\t\t\treturn NULL;\n\t\tgitfile = read_gitfile(used_path.buf);\n\t\tdie_upon_dubious_ownership(gitfile, NULL, used_path.buf);\n\t\tif (gitfile) {\n\t\t\tstrbuf_reset(&used_path);\n\t\t\tstrbuf_addstr(&used_path, gitfile);\n\t\t}\n\t\tif (chdir(used_path.buf))\n\t\t\treturn NULL;\n\t\tpath = validated_path.buf;\n\t}\n\telse {\n\t\tconst char *gitfile = read_gitfile(path);\n\t\tdie_upon_dubious_ownership(gitfile, NULL, path);\n\t\tif (gitfile)\n\t\t\tpath = gitfile;\n\t\tif (chdir(path))\n\t\t\treturn NULL;\n\t}\n\tif (is_git_directory(\".\")) {\n\t\tset_git_dir(\".\", 0);\n\t\tcheck_repository_format(NULL);\n\t\treturn path;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static Jsi_RC SysRunMainCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (jsi_isMain(interp))\n        return SysRunModuleCmd(interp, args, _this, ret, funcPtr);\n    return JSI_OK;\n}", "target": 0}
{"code": "x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}", "target": 1}
{"code": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}", "target": 1}
{"code": "int fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tif (!ci ||\n\t\t(ci->ci_keyring_key &&\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n\t\treturn fscrypt_get_crypt_info(inode);\n\treturn 0;\n}", "target": 1}
{"code": "static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\t    struct msghdr *msg, size_t len, int noblock,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_timestamp(msg, sk, skb);\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n\t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n\t\tlsa->l2tp_flowinfo = 0;\n\t\tlsa->l2tp_scope_id = 0;\n\t\tlsa->l2tp_conn_id = 0;\n\t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;\n\t}\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}", "target": 0}
{"code": "void CheckServiceControl(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span(\n      CreateSpan(context->cloud_trace(), \"CheckServiceControl\"));\n  if (!context->method()) {\n    if (context->GetRequestHTTPMethodWithOverride() == \"OPTIONS\") {\n      TRACE(trace_span) << \"OPTIONS request is rejected\";\n      continuation(Status(Code::PERMISSION_DENIED,\n                          \"The service does not allow CORS traffic.\",\n                          Status::SERVICE_CONTROL));\n    } else {\n      TRACE(trace_span) << \"Method is not configured in the service config\";\n      continuation(Status(Code::NOT_FOUND, \"Method does not exist.\",\n                          Status::SERVICE_CONTROL));\n    }\n    return;\n  } else if (!context->service_context()->service_control() ||\n             context->method()->skip_service_control()) {\n    TRACE(trace_span) << \"Service control check is not needed\";\n    continuation(Status::OK);\n    return;\n  }\n  if (context->api_key().empty()) {\n    if (context->method()->allow_unregistered_calls()) {\n      TRACE(trace_span) << \"Service control check is not needed\";\n      continuation(Status::OK);\n      return;\n    }\n    TRACE(trace_span) << \"Failed at checking caller identity.\";\n    continuation(\n        Status(Code::UNAUTHENTICATED,\n               \"Method doesn't allow unregistered callers (callers without \"\n               \"established identity). Please use API Key or other form of \"\n               \"API consumer identity to call this API.\",\n               Status::SERVICE_CONTROL));\n    return;\n  }\n  service_control::CheckRequestInfo info;\n  context->FillCheckRequestInfo(&info);\n  context->service_context()->service_control()->Check(\n      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        context->set_check_response_info(info);\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(kConsumerProjecId,\n                                                 info.consumer_project_id);\n        }\n        continuation(status);\n      });\n}", "target": 1}
{"code": "void jslGetTokenString(char *str, size_t len) {\n  if (lex->tk == LEX_ID) {\n    strncpy(str, \"ID:\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n  } else if (lex->tk == LEX_STR) {\n    strncpy(str, \"String:'\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n    strncat(str, \"'\", len);\n  } else\n    jslTokenAsString(lex->tk, str, len);\n}", "target": 1}
{"code": "static int snd_hrtimer_stop(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\tatomic_set(&stime->running, 0);\n\thrtimer_try_to_cancel(&stime->hrt);\n\treturn 0;\n}", "target": 0}
{"code": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}", "target": 1}
{"code": "inline FIO_FUNC ssize_t fio_sendfile(intptr_t uuid, intptr_t source_fd,\n                                     off_t offset, size_t length) {\n  return fio_write2(uuid, .data.fd = source_fd, .length = length, .is_fd = 1,\n                    .offset = offset);\n}", "target": 1}
{"code": "static int pfkey_add(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\tx = pfkey_msg2xfrm_state(net, hdr, ext_hdrs);\n\tif (IS_ERR(x))\n\t\treturn PTR_ERR(x);\n\txfrm_state_hold(x);\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\txfrm_audit_state_add(x, err ? 0 : 1, true);\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\tc.event = XFRM_MSG_NEWSA;\n\telse\n\t\tc.event = XFRM_MSG_UPDSA;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}", "target": 0}
{"code": "atmarp_tpaddr_print(netdissect_options *ndo,\n\t\t    const struct atmarp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (ATMTPROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong tplen>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, ATMTPA(ap))));\n}", "target": 0}
{"code": "vq_endchains(struct virtio_vq_info *vq, int used_all_avail)\n{\n\tstruct virtio_base *base;\n\tuint16_t event_idx, new_idx, old_idx;\n\tint intr;\n\tif (!vq || !vq->used)\n\t\treturn;\n\tatomic_thread_fence();\n\tbase = vq->base;\n\told_idx = vq->save_used;\n\tvq->save_used = new_idx = vq->used->idx;\n\tif (used_all_avail &&\n\t    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))\n\t\tintr = 1;\n\telse if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\t\tevent_idx = VQ_USED_EVENT_IDX(vq);\n\t\tintr = (uint16_t)(new_idx - event_idx - 1) <\n\t\t\t(uint16_t)(new_idx - old_idx);\n\t} else {\n\t\tintr = new_idx != old_idx &&\n\t\t    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);\n\t}\n\tif (intr)\n\t\tvq_interrupt(base, vq);\n}", "target": 0}
{"code": "irc_server_reconnect_schedule (struct t_irc_server *server)\n{\n    int minutes, seconds;\n    if (IRC_SERVER_OPTION_BOOLEAN(server, IRC_SERVER_OPTION_AUTORECONNECT))\n    {\n        if (server->reconnect_delay == 0)\n            server->reconnect_delay = IRC_SERVER_OPTION_INTEGER(server, IRC_SERVER_OPTION_AUTORECONNECT_DELAY);\n        else\n            server->reconnect_delay = server->reconnect_delay * weechat_config_integer (irc_config_network_autoreconnect_delay_growing);\n        if ((weechat_config_integer (irc_config_network_autoreconnect_delay_max) > 0)\n            && (server->reconnect_delay > weechat_config_integer (irc_config_network_autoreconnect_delay_max)))\n            server->reconnect_delay = weechat_config_integer (irc_config_network_autoreconnect_delay_max);\n        server->reconnect_start = time (NULL);\n        minutes = server->reconnect_delay / 60;\n        seconds = server->reconnect_delay % 60;\n        if ((minutes > 0) && (seconds > 0))\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s, %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes),\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n        else if (minutes > 0)\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                minutes,\n                NG_(\"minute\", \"minutes\", minutes));\n        }\n        else\n        {\n            weechat_printf (\n                server->buffer,\n                _(\"%s%s: reconnecting to server in %d %s\"),\n                weechat_prefix (\"network\"),\n                IRC_PLUGIN_NAME,\n                seconds,\n                NG_(\"second\", \"seconds\", seconds));\n        }\n    }\n    else\n    {\n        server->reconnect_delay = 0;\n        server->reconnect_start = 0;\n    }\n}", "target": 0}
{"code": "pci_lintr_request(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint bestpin, bestcount, pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tbestpin = 0;\n\tbestcount = si->si_intpins[0].ii_count;\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tif (si->si_intpins[pin].ii_count < bestcount) {\n\t\t\tbestpin = pin;\n\t\t\tbestcount = si->si_intpins[pin].ii_count;\n\t\t}\n\t}\n\tsi->si_intpins[bestpin].ii_count++;\n\tdev->lintr.pin = bestpin + 1;\n\tpci_set_cfgdata8(dev, PCIR_INTPIN, bestpin + 1);\n}", "target": 1}
{"code": "int VP8LBuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n                          const int code_lengths[], int code_lengths_size) {\n  int total_size;\n  assert(code_lengths_size <= MAX_CODE_LENGTHS_SIZE);\n  if (root_table == NULL) {\n    total_size = BuildHuffmanTable(NULL, root_bits,\n                                   code_lengths, code_lengths_size, NULL);\n  } else if (code_lengths_size <= SORTED_SIZE_CUTOFF) {\n    uint16_t sorted[SORTED_SIZE_CUTOFF];\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n  } else {   \n    uint16_t* const sorted =\n        (uint16_t*)WebPSafeMalloc(code_lengths_size, sizeof(*sorted));\n    if (sorted == NULL) return 0;\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n    WebPSafeFree(sorted);\n  }\n  return total_size;\n}", "target": 1}
{"code": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\t*ie_ptr = ie;\n\treturn 0;\n}", "target": 0}
{"code": "htc_request_check_host_hdr(struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static int call_function(cfg_t *cfg, cfg_opt_t *opt, cfg_opt_t *funcopt)\n{\n\tint ret;\n\tconst char **argv;\n\tunsigned int i;\n\tif (!cfg || !opt ||!funcopt) {\n\t\terrno = EINVAL;\n\t\treturn CFG_FAIL;\n\t}\n\targv = calloc(funcopt->nvalues, sizeof(char *));\n\tif (!argv)\n\t\treturn CFG_FAIL;\n\tfor (i = 0; i < funcopt->nvalues; i++)\n\t\targv[i] = funcopt->values[i]->string;\n\tret = (*opt->func) (cfg, opt, funcopt->nvalues, argv);\n\tcfg_free_value(funcopt);\n\tfree(argv);\n\treturn ret;\n}", "target": 0}
{"code": "snmp_oid_cmp_oid(uint32_t *oid1, uint32_t *oid2)\n{\n  uint8_t i;\n  i = 0;\n  while(oid1[i] != ((uint32_t)-1) &&\n        oid2[i] != ((uint32_t)-1)) {\n    if(oid1[i] != oid2[i]) {\n      if(oid1[i] < oid2[i]) {\n        return -1;\n      }\n      return 1;\n    }\n    i++;\n  }\n  if(oid1[i] == ((uint32_t)-1) &&\n     oid2[i] != ((uint32_t)-1)) {\n    return -1;\n  }\n  if(oid1[i] != ((uint32_t)-1) &&\n     oid2[i] == ((uint32_t)-1)) {\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "            AuthenticationInfo(\n                    AuthenticationStatus auth_status)\n                : identity_handle_(nullptr)\n                , handshake_handle_(nullptr)\n                , auth_status_(auth_status)\n                , expected_sequence_number_(0)\n                , change_sequence_number_(SequenceNumber_t::unknown())\n                , handshake_requests_sent_(0)\n            {\n            }", "target": 0}
{"code": "int cma_get_default_gid_type(struct cma_device *cma_dev,\n\t\t\t     u32 port)\n{\n\tif (!rdma_is_port_valid(cma_dev->device, port))\n\t\treturn -EINVAL;\n\treturn cma_dev->default_gid_type[port - rdma_start_port(cma_dev->device)];\n}", "target": 0}
{"code": "static struct btf *find_kfunc_desc_btf(struct bpf_verifier_env *env,\n\t\t\t\t       u32 func_id, s16 offset,\n\t\t\t\t       struct module **btf_modp)\n{\n\tif (offset) {\n\t\tif (offset < 0) {\n\t\t\tverbose(env, \"negative offset disallowed for kernel module function call\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\treturn __find_kfunc_desc_btf(env, offset, btf_modp);\n\t}\n\treturn btf_vmlinux ?: ERR_PTR(-ENOENT);\n}", "target": 0}
{"code": "R_API int r_io_bank_write_to_submap_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_W)) {\n\t\treturn -1;\n\t}\n\tconst int write_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_write_at (io, map->fd, paddr, buf, write_len);\n}", "target": 0}
{"code": "vg_send_msg(VuGpu *vg, const VhostUserGpuMsg *msg, int fd)\n{\n    if (vg_sock_fd_write(vg->sock_fd, msg,\n                         VHOST_USER_GPU_HDR_SIZE + msg->size, fd) < 0) {\n        vg_sock_fd_close(vg);\n    }\n}", "target": 0}
{"code": "extract_auth_val(char **q)\n{\n    unsigned char *qq = *(unsigned char **)q;\n    int quoted = 0;\n    Str val = Strnew();\n    SKIP_BLANKS(qq);\n    if (*qq == '\"') {\n\tquoted = TRUE;\n\tStrcat_char(val, *qq++);\n    }\n    while (*qq != '\\0') {\n\tif (quoted && *qq == '\"') {\n\t    Strcat_char(val, *qq++);\n\t    break;\n\t}\n\tif (!quoted) {\n\t    switch (*qq) {\n\t    case '[':\n\t    case ']':\n\t    case '(':\n\t    case ')':\n\t    case '<':\n\t    case '>':\n\t    case '@':\n\t    case ';':\n\t    case ':':\n\t    case '\\\\':\n\t    case '\"':\n\t    case '/':\n\t    case '?':\n\t    case '=':\n\t    case ' ':\n\t    case '\\t':\n\t\tqq++;\n\t    case ',':\n\t\tgoto end_token;\n\t    default:\n\t\tif (*qq <= 037 || *qq == 0177) {\n\t\t    qq++;\n\t\t    goto end_token;\n\t\t}\n\t    }\n\t}\n\telse if (quoted && *qq == '\\\\')\n\t    Strcat_char(val, *qq++);\n\tStrcat_char(val, *qq++);\n    }\n  end_token:\n    *q = (char *)qq;\n    return val;\n}", "target": 0}
{"code": "SYSCALL_DEFINE1(timer_getoverrun, timer_t, timer_id)\n{\n\tstruct k_itimer *timr;\n\tint overrun;\n\tunsigned long flags;\n\ttimr = lock_timer(timer_id, &flags);\n\tif (!timr)\n\t\treturn -EINVAL;\n\toverrun = timr->it_overrun_last;\n\tunlock_timer(timr, flags);\n\treturn overrun;\n}", "target": 1}
{"code": "snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len, uint8_t *length)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n  *length = *buff++;\n  (*buff_len)--;\n  return buff;\n}", "target": 1}
{"code": "void iwjson_ftoa(long double val, char buf[static IWNUMBUF_SIZE], size_t *out_len) {\n  int len = snprintf(buf, 64, \"%.8Lf\", val);\n  if (len <= 0) {\n    buf[0] = '\\0';\n    *out_len = 0;\n    return;\n  }\n  while (len > 0 && buf[len - 1] == '0') { \n    buf[len - 1] = '\\0';\n    len--;\n  }\n  if ((len > 0) && (buf[len - 1] == '.')) {\n    buf[len - 1] = '\\0';\n    len--;\n  }\n  *out_len = (size_t) len;\n}", "target": 1}
{"code": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining;\n\ts64 ns;\n\tu32 tmcct;\n\tASSERT(apic != NULL);\n\tif (kvm_apic_get_reg(apic, APIC_TMICT) == 0)\n\t\treturn 0;\n\tremaining = hrtimer_get_remaining(&apic->lapic_timer.timer);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = ktime_set(0, 0);\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\treturn tmcct;\n}", "target": 1}
{"code": "expand_command(struct eventlog *evlog, char **newbuf)\n{\n    size_t len, bufsize = strlen(evlog->command) + 1;\n    char *cp, *buf;\n    int ac;\n    debug_decl(expand_command, SUDO_DEBUG_UTIL);\n    if (evlog->argv == NULL || evlog->argv[0] == NULL || evlog->argv[1] == NULL) {\n\t*newbuf = NULL;\n\tdebug_return_str(evlog->command);\n    }\n    for (ac = 1; evlog->argv[ac] != NULL; ac++)\n\tbufsize += strlen(evlog->argv[ac]) + 1;\n    if ((buf = malloc(bufsize)) == NULL)\n\tsudo_fatalx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\n    cp = buf;\n    len = strlcpy(cp, evlog->command, bufsize);\n    if (len >= bufsize)\n\tsudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n    cp += len;\n    bufsize -= len;\n    for (ac = 1; evlog->argv[ac] != NULL; ac++) {\n\tif (bufsize < 2)\n\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\t*cp++ = ' ';\n\tbufsize--;\n\tlen = strlcpy(cp, evlog->argv[ac], bufsize);\n\tif (len >= bufsize)\n\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\tcp += len;\n\tbufsize -= len;\n    }\n    *newbuf = buf;\n    debug_return_str(buf);\n}", "target": 0}
{"code": "int main(int argc, char *argv[])\n{\n\tchar *procspath;\n\tsize_t len;\n\tif (geteuid() != 0) {\n\t\tfprintf(stderr, \"Run me as root\\n\");\n\t\texit(1);\n\t}\n\tif (argc != 2)  {\n\t\tfprintf(stderr, \"Usage: %s [lxcfs_test_cgroup_path]\\n\", argv[0]);\n\t\texit(1);\n\t}\n\tlen = strlen(argv[1]) + strlen(\"/cgroup.procs\") + 1;\n\tprocspath = alloca(len);\n\tsnprintf(procspath, len, \"%s/cgroup.procs\", argv[1]);\n\ttest_open(argv[1]);\n\ttest_open(procspath);\n\ttest_stat(argv[1]);\n\ttest_stat(procspath);\n\ttest_access(argv[1]);\n\ttest_access(procspath);\n\ttest_bind(argv[1]);\n\ttest_bind(procspath);\n\ttest_bindmount(argv[1]);\n\ttest_bindmount(procspath);\n\ttest_truncate(argv[1]);\n\ttest_truncate(procspath);\n\ttest_chdir(argv[1]);\n\ttest_chdir(procspath);\n\ttest_rename(argv[1]);\n\ttest_rename(procspath);\n\ttest_mkdir(argv[1]);\n\ttest_mkdir(procspath);\n\ttest_rmdir(argv[1]);\n\ttest_rmdir(procspath);\n\ttest_creat(argv[1]);\n\ttest_creat(procspath);\n\ttest_link(argv[1]);\n\ttest_link(procspath);\n\ttest_unlink(argv[1]);\n\ttest_unlink(procspath);\n\ttest_symlink(argv[1]);\n\ttest_symlink(procspath);\n\ttest_readlink(argv[1]);\n\ttest_readlink(procspath);\n\ttest_chmod(argv[1]);\n\ttest_chmod(procspath);\n\ttest_chown(argv[1]);\n\ttest_chown(procspath);\n\ttest_lchown(argv[1]);\n\ttest_lchown(procspath);\n\ttest_mknod(argv[1]);\n\ttest_mknod(procspath);\n\ttest_chroot(argv[1]);\n\ttest_chroot(procspath);\n\ttest_xattrs(argv[1]);\n\ttest_xattrs(procspath);\n\ttest_utimes(argv[1]);\n\ttest_utimes(procspath);\n\ttest_openat(argv[1]);\n\tprintf(\"All tests passed\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "static struct inode *ext4_alloc_inode(struct super_block *sb)\n{\n\tstruct ext4_inode_info *ei;\n\tei = kmem_cache_alloc(ext4_inode_cachep, GFP_NOFS);\n\tif (!ei)\n\t\treturn NULL;\n\tei->vfs_inode.i_version = 1;\n\tei->vfs_inode.i_data.writeback_index = 0;\n\tmemset(&ei->i_cached_extent, 0, sizeof(struct ext4_ext_cache));\n\tINIT_LIST_HEAD(&ei->i_prealloc_list);\n\tspin_lock_init(&ei->i_prealloc_lock);\n\tjbd2_journal_init_jbd_inode(&ei->jinode, &ei->vfs_inode);\n\tei->i_reserved_data_blocks = 0;\n\tei->i_reserved_meta_blocks = 0;\n\tei->i_allocated_meta_blocks = 0;\n\tei->i_da_metadata_calc_len = 0;\n\tei->i_delalloc_reserved_flag = 0;\n\tspin_lock_init(&(ei->i_block_reservation_lock));\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n#endif\n\tINIT_LIST_HEAD(&ei->i_completed_io_list);\n\tspin_lock_init(&ei->i_completed_io_lock);\n\tei->cur_aio_dio = NULL;\n\tei->i_sync_tid = 0;\n\tei->i_datasync_tid = 0;\n\treturn &ei->vfs_inode;\n}", "target": 0}
{"code": "int BUFFER_append(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)\n{\n    int result;\n    if ( (handle1 == NULL) || (handle2 == NULL) || (handle1 == handle2) )\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        BUFFER* b1 = (BUFFER*)handle1;\n        BUFFER* b2 = (BUFFER*)handle2;\n        if (b1->buffer == NULL)\n        {\n            result = MU_FAILURE;\n        }\n        else if (b2->buffer == NULL)\n        {\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (b2->size ==0)\n            {\n                result = 0;\n            }\n            else\n            {\n                unsigned char* temp = (unsigned char*)realloc(b1->buffer, b1->size + b2->size);\n                if (temp == NULL)\n                {\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    b1->buffer = temp;\n                    (void)memcpy(&b1->buffer[b1->size], b2->buffer, b2->size);\n                    b1->size += b2->size;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "int jas_stream_gobble(jas_stream_t *stream, int n)\n{\n\tint m;\n\tif (n < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_gobble\");\n\t}\n\tm = n;\n\tfor (m = n; m > 0; --m) {\n\t\tif (jas_stream_getc(stream) == EOF) {\n\t\t\treturn n - m;\n\t\t}\n\t}\n\treturn n;\n}", "target": 0}
{"code": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n        assert(f);\n        assert(ret);\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n        path_simplify(p);\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n                delete_trailing_chars(p, \"/\");\n                p = skip_leading_chars(p, \"/\");\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 1}
{"code": "relax_ng_parse(const char *path, xml_read_cb cb, void *arg)\n{\n\txmlTextReaderPtr reader;\n\txmlRelaxNGValidCtxtPtr rngvalidctx;\n\tint read;\n\tint error;\n\treader = xmlNewTextReaderFilename(path);\n\tif (reader == NULL)\n\t\treturn pr_val_err(\"Couldn't get XML '%s' file.\", path);\n\terror = xmlTextReaderRelaxNGSetSchema(reader, schema);\n\tif (error) {\n\t\terror = pr_val_err(\"Couldn't set Relax NG schema.\");\n\t\tgoto free_reader;\n\t}\n\trngvalidctx = xmlRelaxNGNewValidCtxt(schema);\n\tif (rngvalidctx == NULL) {\n\t\terror = pr_val_err(\"xmlRelaxNGNewValidCtxt() returned NULL\");\n\t\tgoto free_reader;\n\t}\n\txmlRelaxNGSetValidErrors(rngvalidctx, relax_ng_log_err,\n\t    relax_ng_log_warn, NULL);\n\terror = xmlTextReaderRelaxNGValidateCtxt(reader, rngvalidctx, 1);\n\tif (error) {\n\t\terror = pr_val_err(\"Invalid XML document\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlTextReaderSetStructuredErrorHandler(reader, relax_ng_log_str_err,\n\t    NULL);\n\twhile ((read = xmlTextReaderRead(reader)) == 1) {\n\t\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\t\tgoto free_valid_ctx;\n\t\t}\n\t\terror = cb(reader, arg);\n\t\tif (error)\n\t\t\tgoto free_valid_ctx;\n\t}\n\tif (read < 0) {\n\t\terror = pr_val_err(\"Error parsing XML document.\");\n\t\tgoto free_valid_ctx;\n\t}\n\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\n\txmlFreeTextReader(reader);\n\treturn 0;\nfree_valid_ctx:\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\nfree_reader:\n\txmlFreeTextReader(reader);\n\treturn error;\n}", "target": 1}
{"code": "void LinearAlgebraOp<InputScalar, OutputScalar>::PrepareOutputs(\n    OpKernelContext* context, const TensorShapes& input_matrix_shapes,\n    const TensorShape& batch_shape, TensorOutputs* outputs,\n    TensorShapes* output_matrix_shapes) {\n  *output_matrix_shapes = GetOutputMatrixShapes(input_matrix_shapes);\n  const int num_outputs = output_matrix_shapes->size();\n  OP_REQUIRES(\n      context, num_outputs <= context->num_outputs(),\n      errors::Internal(\n          \"Derived class expected more outputs (%d) that the op has (%d).\",\n          num_outputs, context->num_outputs()));\n  std::set<int> unused_inputs;\n  for (int input_idx = 0; input_idx < context->num_inputs(); ++input_idx) {\n    unused_inputs.insert(input_idx);\n  }\n  for (int output_idx = 0; output_idx < context->num_outputs(); ++output_idx) {\n    TensorShape output_tensor_shape({});\n    if (output_idx < num_outputs) {\n      const TensorShape& output_matrix_shape =\n          output_matrix_shapes->at(output_idx);\n      OP_REQUIRES(context, output_matrix_shape.dims() <= 2,\n                  errors::InvalidArgument(\n                      \"Rank of matrix output no. %d must be 0, 1 or 2, got %d.\",\n                      output_idx, output_matrix_shape.dims()));\n      output_tensor_shape = batch_shape;\n      output_tensor_shape.AppendShape(output_matrix_shape);\n    }\n    Tensor* out = nullptr;\n    bool reused_input = false;\n    if (EnableInputForwarding()) {\n      for (int input_idx : unused_inputs) {\n        if (context->forward_input_to_output_with_shape(\n                input_idx, output_idx, output_tensor_shape, &out)) {\n          reused_input = true;\n          unused_inputs.erase(input_idx);\n          break;\n        }\n      }\n    }\n    if (!reused_input) {\n      OP_REQUIRES_OK(context, context->allocate_output(\n                                  output_idx, output_tensor_shape, &out));\n    }\n    OP_REQUIRES(\n        context, out->dtype() == DataTypeToEnum<OutputScalar>::v(),\n        errors::InvalidArgument(\"Invalid output dtype \", out->dtype(), \" vs \",\n                                DataTypeToEnum<OutputScalar>::v()));\n    outputs->emplace_back(out);\n  }\n}", "target": 0}
{"code": "ff_layout_get_ds_info(struct inode *inode)\n{\n\tstruct pnfs_layout_hdr *layout = NFS_I(inode)->layout;\n\tif (layout == NULL)\n\t\treturn NULL;\n\treturn &FF_LAYOUT_FROM_HDR(layout)->commit_info;\n}", "target": 0}
{"code": "cib_remote_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    const char *type = NULL;\n    crm_info(\"Message on callback channel\");\n    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);\n    type = crm_element_value(msg, F_TYPE);\n    crm_trace(\"Activating %s callbacks...\", type);\n    if (safe_str_eq(type, T_CIB)) {\n        cib_native_callback(cib, msg, 0, 0);\n    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n        g_list_foreach(cib->notify_list, cib_native_notify, msg);\n    } else {\n        crm_err(\"Unknown message type: %s\", type);\n    }\n    if (msg != NULL) {\n        free_xml(msg);\n        return 0;\n    }\n    return -1;\n}", "target": 1}
{"code": "static struct btrfs_device *btrfs_find_device_by_path(\n\t\tstruct btrfs_fs_info *fs_info, const char *device_path)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\tstruct btrfs_device *device;\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\tif (btrfs_fs_incompat(fs_info, METADATA_UUID))\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->metadata_uuid);\n\telse\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid);\n\tbrelse(bh);\n\tif (!device)\n\t\tdevice = ERR_PTR(-ENOENT);\n\tblkdev_put(bdev, FMODE_READ);\n\treturn device;\n}", "target": 1}
{"code": "static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int clnpass_cnt = 0;\n    int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n    av_assert0(width  <= JPEG2000_MAX_CBLKW);\n    av_assert0(height <= JPEG2000_MAX_CBLKH);\n    for (y = 0; y < height; y++)\n        memset(t1->data[y], 0, width * sizeof(**t1->data));\n    if (!cblk->length)\n        return 0;\n    for (y = 0; y < height + 2; y++)\n        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data);\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           bpass_csty_symbol && (clnpass_cnt >= 4),\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1);\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        case 2:\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            clnpass_cnt = clnpass_cnt + 1;\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        }\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 1}
{"code": "TEST_F(TestSPIFFEValidator, TestGetTrustBundleStore) {\n  initialize();\n  auto cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/extensions_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/non_spiffe_san_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  cert = readCertFromFile(TestEnvironment::substitute(\n      \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/spiffe_san_cert.pem\"));\n  EXPECT_FALSE(validator().getTrustBundleStore(cert.get()));\n  validator().trustBundleStores().emplace(\"example.com\", X509StorePtr(X509_STORE_new()));\n  EXPECT_TRUE(validator().getTrustBundleStore(cert.get()));\n}", "target": 1}
{"code": "int kvm_get_dirty_log(struct kvm *kvm,\n\t\t\tstruct kvm_dirty_log *log, int *is_dirty)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint r, i, as_id, id;\n\tunsigned long n;\n\tunsigned long any = 0;\n\tr = -EINVAL;\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\tslots = __kvm_memslots(kvm, as_id);\n\tmemslot = id_to_memslot(slots, id);\n\tr = -ENOENT;\n\tif (!memslot->dirty_bitmap)\n\t\tgoto out;\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\tfor (i = 0; !any && i < n/sizeof(long); ++i)\n\t\tany = memslot->dirty_bitmap[i];\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, memslot->dirty_bitmap, n))\n\t\tgoto out;\n\tif (any)\n\t\t*is_dirty = 1;\n\tr = 0;\nout:\n\treturn r;\n}", "target": 0}
{"code": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t}\n\telse if (rc == -ENODATA)\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\treturn rc;\n}", "target": 1}
{"code": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}", "target": 1}
{"code": "static void php_array_merge_recursive(PointerSet &seen, bool check,\n                                      Array &arr1, const Array& arr2) {\n  if (check && !seen.insert((void*)arr1.get()).second) {\n    raise_warning(\"array_merge_recursive(): recursion detected\");\n    return;\n  }\n  for (ArrayIter iter(arr2); iter; ++iter) {\n    Variant key(iter.first());\n    const Variant& value(iter.secondRef());\n    if (key.isNumeric()) {\n      arr1.appendWithRef(value);\n    } else if (arr1.exists(key, true)) {\n      Variant &v = arr1.lvalAt(key, AccessFlags::Key);\n      auto subarr1 = v.toArray().copy();\n      php_array_merge_recursive(seen,\n                                couldRecur(v, subarr1.get()),\n                                subarr1,\n                                value.toArray());\n      v.unset(); \n      v = subarr1;\n    } else {\n      arr1.setWithRef(key, value, true);\n    }\n  }\n  if (check) {\n    seen.erase((void*)arr1.get());\n  }\n}", "target": 0}
{"code": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\treturn -EIO;\n\t}\n\treturn brightness;\n}", "target": 1}
{"code": "bool DNP3_Base::ProcessData(int len, const u_char* data, bool orig)\n\t{\n\tEndpoint* endp = orig ? &orig_state : &resp_state;\n\twhile ( len )\n\t\t{\n\t\tif ( endp->in_hdr )\n\t\t\t{\n\t\t\tif ( ! AddToBuffer(endp, PSEUDO_APP_LAYER_INDEX, &data, &len) )\n\t\t\t\treturn true;\n\t\t\tif( endp->buffer[0] != 0x05 || endp->buffer[1] != 0x64 )\n\t\t\t\t{\n\t\t\t\tanalyzer->Weird(\"dnp3_header_lacks_magic\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\tif ( ! CheckCRC(PSEUDO_LINK_LAYER_LEN, endp->buffer, endp->buffer + PSEUDO_LINK_LAYER_LEN, \"header\") )\n\t\t\t\t{\n\t\t\t\tanalyzer->ProtocolViolation(\"broken_checksum\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\tanalyzer->ProtocolConfirmation();\n\t\t\tif ( (endp->buffer[PSEUDO_LENGTH_INDEX] + 3) == (char)PSEUDO_LINK_LAYER_LEN  )\n\t\t\t\t{\n\t\t\t\tClearEndpointState(orig);\n\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\tu_char ctrl = endp->buffer[PSEUDO_CONTROL_FIELD_INDEX];\n\t\t\tif ( orig != (bool)(ctrl & 0x80) )\n\t\t\t\tanalyzer->Weird(\"dnp3_unexpected_flow_direction\");\n\t\t\tendp->pkt_length = endp->buffer[PSEUDO_LENGTH_INDEX];\n\t\t\tendp->tpflags = endp->buffer[PSEUDO_TRANSPORT_INDEX];\n\t\t\tendp->in_hdr = false; \n\t\t\tif ( ++endp->pkt_cnt == 1 )\n\t\t\t\tinterp->NewData(orig, endp->buffer, endp->buffer + PSEUDO_LINK_LAYER_LEN);\n\t\t\t}\n\t\tif ( ! endp->in_hdr )\n\t\t\t{\n\t\t\tassert(endp->pkt_length);\n\t\t\tint n = PSEUDO_APP_LAYER_INDEX + (endp->pkt_length - 5) + ((endp->pkt_length - 5) / 16) * 2\n\t\t\t\t\t+ 2 * ( ((endp->pkt_length - 5) % 16 == 0) ? 0 : 1) - 1 ;\n\t\t\tif ( ! AddToBuffer(endp, n, &data, &len) )\n\t\t\t\treturn true;\n\t\t\tif ( ! ParseAppLayer(endp) )\n\t\t\t\treturn false;\n\t\t\tendp->buffer_len = 0;\n\t\t\tendp->in_hdr = true;\n\t\t\t}\n\t\t}\n\treturn true;\n\t}", "target": 1}
{"code": "htp_param_t *htp_tx_req_get_param_ex(htp_tx_t *tx, enum htp_data_source_t source, const char *name, size_t name_len) {\n    if ((tx == NULL) || (name == NULL)) return NULL;\n    htp_param_t *p = NULL;\n    for (size_t i = 0, n = htp_table_size(tx->request_params); i < n; i++) {\n        p = htp_table_get_index(tx->request_params, i, NULL);\n        if (p->source != source) continue;\n        if (bstr_cmp_mem_nocase(p->name, name, name_len) == 0) return p;\n    }\n    return NULL;\n}", "target": 0}
{"code": "deltas_head_values_set(struct deltas_head *deltas)\n{\n\treturn deltas->len == deltas->capacity;\n}", "target": 1}
{"code": "pxa3xx_gcu_write(struct file *file, const char *buff,\n\t\t size_t count, loff_t *offp)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct pxa3xx_gcu_batch\t*buffer;\n\tstruct pxa3xx_gcu_priv *priv = to_pxa3xx_gcu_priv(file);\n\tint words = count / 4;\n\tpriv->shared->num_writes++;\n\tpriv->shared->num_words += words;\n\tif (words >= PXA3XX_GCU_BATCH_WORDS)\n\t\treturn -E2BIG;\n\tif (!priv->free) {\n\t\tret = pxa3xx_gcu_wait_free(priv);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer = priv->free;\n\tpriv->free = buffer->next;\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\tret = copy_from_user(buffer->ptr, buff, words * 4);\n\tif (ret) {\n\t\tspin_lock_irqsave(&priv->spinlock, flags);\n\t\tbuffer->next = priv->free;\n\t\tpriv->free = buffer;\n\t\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\t\treturn -EFAULT;\n\t}\n\tbuffer->length = words;\n\tbuffer->ptr[words] = 0x01000000;\n\tspin_lock_irqsave(&priv->spinlock, flags);\n\tbuffer->next = NULL;\n\tif (priv->ready) {\n\t\tBUG_ON(priv->ready_last == NULL);\n\t\tpriv->ready_last->next = buffer;\n\t} else\n\t\tpriv->ready = buffer;\n\tpriv->ready_last = buffer;\n\tif (!priv->shared->hw_running)\n\t\trun_ready(priv);\n\tspin_unlock_irqrestore(&priv->spinlock, flags);\n\treturn words * 4;\n}", "target": 1}
{"code": "static int whiteheat_probe(struct usb_serial *serial,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tsize_t num_bulk_in = 0;\n\tsize_t num_bulk_out = 0;\n\tsize_t min_num_bulk;\n\tunsigned int i;\n\tiface_desc = serial->interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; i++) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endpoint))\n\t\t\t++num_bulk_in;\n\t\tif (usb_endpoint_is_bulk_out(endpoint))\n\t\t\t++num_bulk_out;\n\t}\n\tmin_num_bulk = COMMAND_PORT + 1;\n\tif (num_bulk_in < min_num_bulk || num_bulk_out < min_num_bulk)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 0}
{"code": "static void skcipher_release(void *private)\n{\n\tcrypto_free_skcipher(private);\n}", "target": 1}
{"code": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\tmutex_lock(&ctx->ring_lock);\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\tif (head == tail)\n\t\tgoto out;\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\treturn ret;\n}", "target": 0}
{"code": "njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n    if (njs_slow_path(!array->object.fast_array)) {\n        return NJS_OK;\n    }\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n    length = array->length;\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n            prop->value = array->start[i];\n        }\n    }\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n    return NJS_OK;\n}", "target": 0}
{"code": "void test_base64_lengths(void)\n{\n  const char *in = \"FuseMuse\";\n  char out1[32];\n  char out2[32];\n  size_t enclen;\n  int declen;\n  enclen = mutt_b64_encode(out1, in, 0, 32);\n  if (!TEST_CHECK(enclen == 0))\n  {\n    TEST_MSG(\"Expected: %zu\", 0);\n    TEST_MSG(\"Actual  : %zu\", enclen);\n  }\n  out1[0] = '\\0';\n  declen = mutt_b64_decode(out2, out1);\n  if (!TEST_CHECK(declen == -1))\n  {\n    TEST_MSG(\"Expected: %zu\", -1);\n    TEST_MSG(\"Actual  : %zu\", declen);\n  }\n  for (size_t i = 1; i <= 8; ++i)\n  {\n    enclen = mutt_b64_encode(out1, in, i, 32);\n    size_t exp = ((i + 2) / 3) << 2;\n    if (!TEST_CHECK(enclen == exp))\n    {\n      TEST_MSG(\"Expected: %zu\", exp);\n      TEST_MSG(\"Actual  : %zu\", enclen);\n    }\n    declen = mutt_b64_decode(out2, out1);\n    if (!TEST_CHECK(declen == i))\n    {\n      TEST_MSG(\"Expected: %zu\", i);\n      TEST_MSG(\"Actual  : %zu\", declen);\n    }\n    out2[declen] = '\\0';\n    if (!TEST_CHECK(strncmp(out2, in, i) == 0))\n    {\n      TEST_MSG(\"Expected: %s\", in);\n      TEST_MSG(\"Actual  : %s\", out2);\n    }\n  }\n}", "target": 1}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "static void sr_mdio_write(struct net_device *netdev, int phy_id, int loc,\n\t\t\t  int val)\n{\n\tstruct usbnet *dev = netdev_priv(netdev);\n\t__le16 res = cpu_to_le16(val);\n\tif (phy_id) {\n\t\tnetdev_dbg(netdev, \"Only internal phy supported\\n\");\n\t\treturn;\n\t}\n\tnetdev_dbg(netdev, \"sr_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\\n\",\n\t\t   phy_id, loc, val);\n\tsr_share_write_word(dev, 1, loc, res);\n}", "target": 0}
{"code": "SWFInput_stream_read(SWFInput input, unsigned char* buffer, int count)\n{\n\tstruct SWFInputStreamData *data = (struct SWFInputStreamData *) input->data;\n\tint need = input->offset + count - input->length;\n\tif ( need > 0 )\n\t{\n\t\tint num;\n\t\tdata->buffer =\n\t\t\t(unsigned char*) realloc(data->buffer,\n\t\t\t\t\t\t\tsizeof(unsigned char) * INPUTSTREAM_INCREMENT *\n\t\t\t\t\t\t\t(((input->offset + count) / INPUTSTREAM_INCREMENT) + 1));\n\t\tnum = fread(data->buffer + input->length,\n\t\t\t\t\t\t\t\tsizeof(unsigned char), need, data->file);\n\t\tinput->length += num;\n\t}\n\tif ( count > input->length - input->offset )\n\t\tcount = input->length - input->offset;\n\tmemcpy(buffer, data->buffer + input->offset, count);\n\treturn count;\n}", "target": 0}
{"code": "static char *handle_new_problem(GVariant *problem_info, uid_t caller_uid, char **error)\n{\n    problem_data_t *pd = problem_data_new();\n    GVariantIter *iter;\n    g_variant_get(problem_info, \"a{ss}\", &iter);\n    gchar *key, *value;\n    while (g_variant_iter_loop(iter, \"{ss}\", &key, &value))\n    {\n        problem_data_add_text_editable(pd, key, value);\n    }\n    if (caller_uid != 0 || problem_data_get_content_or_NULL(pd, FILENAME_UID) == NULL)\n    {   \n        log_info(\"Adding UID %d to problem data\", caller_uid);\n        char buf[sizeof(uid_t) * 3 + 2];\n        snprintf(buf, sizeof(buf), \"%d\", caller_uid);\n        problem_data_add_text_noteditable(pd, FILENAME_UID, buf);\n    }\n    problem_data_add_basics(pd);\n    char *problem_id = problem_data_save(pd);\n    if (problem_id)\n        notify_new_path(problem_id);\n    else if (error)\n        *error = xasprintf(\"Cannot create a new problem\");\n    problem_data_free(pd);\n    return problem_id;\n}", "target": 1}
{"code": "int netdev_printk(const char *level, const struct net_device *dev,\n\t\t  const char *format, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint r;\n\tva_start(args, format);\n\tvaf.fmt = format;\n\tvaf.va = &args;\n\tr = __netdev_printk(level, dev, &vaf);\n\tva_end(args);\n\treturn r;\n}", "target": 0}
{"code": "static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {\n    if (bind(s,sa,len) == -1) {\n        anetSetError(err, \"bind: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    if (listen(s, backlog) == -1) {\n        anetSetError(err, \"listen: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}", "target": 1}
{"code": "    template<typename tp, typename tf, typename tc, typename to>\n    CImg<T>& draw_object3d(LibBoard::Board& board,\n                           const float x0, const float y0, const float z0,\n                           const CImg<tp>& vertices, const CImgList<tf>& primitives,\n                           const CImgList<tc>& colors, const CImgList<to>& opacities,\n                           const unsigned int render_type=4,\n                           const bool is_double_sided=false, const float focale=700,\n                           const float lightx=0, const float lighty=0, const float lightz=-5e8,\n                           const float specular_lightness=0.2f, const float specular_shininess=0.1f) {\n      return draw_object3d(board,x0,y0,z0,vertices,primitives,colors,opacities,render_type,\n                           is_double_sided,focale,lightx,lighty,lightz,\n                           specular_lightness,specular_shininess,CImg<floatT>::empty());", "target": 0}
{"code": "name_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n    if (s >= maxbuf)\n\treturn(-1);\t\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n\t    return(-1);\t\n\tND_TCHECK2(*s, 1);\n\ts += (*s) + 1;\n\tND_TCHECK2(*s, 1);\n    }\n    return(PTR_DIFF(s, s0) + 1);\ntrunc:\n    return(-1);\t\n}", "target": 0}
{"code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n      __err:\n\treturn err;\n}", "target": 0}
{"code": "xmlNodePtr SimpleXMLElement_exportNode(const Object& sxe) {\n  assert(sxe->instanceof(SimpleXMLElement_classof()));\n  auto data = Native::data<SimpleXMLElement>(sxe.get());\n  return php_sxe_get_first_node(data, data->nodep());\n}", "target": 1}
{"code": "_pdfioFileConsume(pdfio_file_t *pdf,\t\n                  size_t       bytes)\t\n{\n  PDFIO_DEBUG(\"_pdfioFileConsume(pdf=%p, bytes=%u)\\n\", pdf, (unsigned)bytes);\n  if ((size_t)(pdf->bufend - pdf->bufptr) > bytes)\n    pdf->bufptr += bytes;\n  else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)\n    return (false);\n  PDFIO_DEBUG(\"_pdfioFileConsume: pos=%ld\\n\", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));\n  return (true);\n}", "target": 0}
{"code": "SkBitmap Clipboard::ReadImage(Buffer buffer) const {\n  ScopedGObject<GdkPixbuf>::Type pixbuf(\n      gtk_clipboard_wait_for_image(clipboard_));\n  if (!pixbuf.get())\n    return SkBitmap();\n  gfx::CanvasSkia canvas(gdk_pixbuf_get_width(pixbuf.get()),\n                         gdk_pixbuf_get_height(pixbuf.get()),\n                         false);\n  {\n    skia::ScopedPlatformPaint scoped_platform_paint(canvas.sk_canvas());\n    cairo_t* context = scoped_platform_paint.GetPlatformSurface();\n    gdk_cairo_set_source_pixbuf(context, pixbuf.get(), 0.0, 0.0);\n    cairo_paint(context);\n  }\n  return canvas.ExtractBitmap();\n}", "target": 0}
{"code": "int ossl_dsa_check_pairwise(const DSA *dsa)\n{\n    int ret = 0;\n    BN_CTX *ctx = NULL;\n    BIGNUM *pub_key = NULL;\n    if (dsa->params.p == NULL\n        || dsa->params.g == NULL\n        || dsa->priv_key == NULL\n        || dsa->pub_key == NULL)\n        return 0;\n    ctx = BN_CTX_new_ex(dsa->libctx);\n    if (ctx == NULL)\n        goto err;\n    pub_key = BN_new();\n    if (pub_key == NULL)\n        goto err;\n    if (!ossl_dsa_generate_public_key(ctx, dsa, dsa->priv_key, pub_key))\n        goto err;\n    ret = BN_cmp(pub_key, dsa->pub_key) == 0;\nerr:\n    BN_free(pub_key);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 1}
{"code": "static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t\tunsigned int slen)\n{\n\tu8 *buf = NULL;\n\tu8 *src = (u8 *)seed;\n\tint err;\n\tif (slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(buf, seed, slen);\n\t\tsrc = buf;\n\t}\n\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n\tkzfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "PHPAPI int php_lint_script(zend_file_handle *file)\n{\n\tzend_op_array *op_array;\n\tint retval = FAILURE;\n\tzend_try {\n\t\top_array = zend_compile_file(file, ZEND_INCLUDE);\n\t\tzend_destroy_file_handle(file);\n\t\tif (op_array) {\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t\tretval = SUCCESS;\n\t\t}\n\t} zend_end_try();\n\tif (EG(exception)) {\n\t\tzend_exception_error(EG(exception), E_ERROR);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "void usbredirparser_send_control_packet(struct usbredirparser *parser,\n    uint64_t id,\n    struct usb_redir_control_packet_header *control_header,\n    uint8_t *data, int data_len)\n{\n    usbredirparser_queue(parser, usb_redir_control_packet, id, control_header,\n                         data, data_len);\n}", "target": 0}
{"code": "psf_allocate (void)\n{\tSF_PRIVATE * psf ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t\treturn\tNULL ;\n\tif ((psf->header.ptr = calloc (1, INITAL_HEADER_SIZE)) == NULL)\n\t{\tfree (psf) ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf->header.len = INITAL_HEADER_SIZE ;\n\treturn psf ;\n} ", "target": 0}
{"code": "NOEXPORT unsigned __stdcall daemon_thread(void *arg) {\n    (void)arg; \n    tls_alloc(NULL, NULL, \"main\"); \n    main_init();\n    SetEvent(main_initialized); \n    while(main_configure(cmdline.config_file, NULL)) {\n        if(cmdline.config_file && *cmdline.config_file=='-')\n            cmdline.config_file=NULL; \n        unbind_ports(); \n        log_flush(LOG_MODE_ERROR); \n        PostMessage(hwnd, WM_INVALID_CONFIG, 0, 0); \n        WaitForSingleObject(config_ready, INFINITE);\n    }\n    PostMessage(hwnd, WM_VALID_CONFIG, 0, 0);\n    daemon_loop();\n    main_cleanup();\n    _endthreadex(0); \n    return 0;\n}", "target": 1}
{"code": "static long media_device_enum_entities(struct media_device *mdev,\n\t\t\t\t       struct media_entity_desc __user *uent)\n{\n\tstruct media_entity *ent;\n\tstruct media_entity_desc u_ent;\n\tmemset(&u_ent, 0, sizeof(u_ent));\n\tif (copy_from_user(&u_ent.id, &uent->id, sizeof(u_ent.id)))\n\t\treturn -EFAULT;\n\tent = find_entity(mdev, u_ent.id);\n\tif (ent == NULL)\n\t\treturn -EINVAL;\n\tu_ent.id = ent->id;\n\tif (ent->name) {\n\t\tstrncpy(u_ent.name, ent->name, sizeof(u_ent.name));\n\t\tu_ent.name[sizeof(u_ent.name) - 1] = '\\0';\n\t} else {\n\t\tmemset(u_ent.name, 0, sizeof(u_ent.name));\n\t}\n\tu_ent.type = ent->type;\n\tu_ent.revision = ent->revision;\n\tu_ent.flags = ent->flags;\n\tu_ent.group_id = ent->group_id;\n\tu_ent.pads = ent->num_pads;\n\tu_ent.links = ent->num_links - ent->num_backlinks;\n\tmemcpy(&u_ent.raw, &ent->info, sizeof(ent->info));\n\tif (copy_to_user(uent, &u_ent, sizeof(u_ent)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "static int wcd9335_codec_find_amic_input(struct snd_soc_component *comp,\n\t\t\t\t\t int adc_mux_n)\n{\n\tint mux_sel, reg, mreg;\n\tif (adc_mux_n < 0 || adc_mux_n > WCD9335_MAX_VALID_ADC_MUX ||\n\t    adc_mux_n == WCD9335_INVALID_ADC_MUX)\n\t\treturn 0;\n\tif (adc_mux_n < 4) {\n\t\treg = WCD9335_CDC_TX_INP_MUX_ADC_MUX0_CFG1 + 2 * adc_mux_n;\n\t\tmreg = WCD9335_CDC_TX_INP_MUX_ADC_MUX0_CFG0 + 2 * adc_mux_n;\n\t\tmux_sel = snd_soc_component_read32(comp, reg) & 0x3;\n\t} else {\n\t\treg = WCD9335_CDC_TX_INP_MUX_ADC_MUX4_CFG0 + adc_mux_n - 4;\n\t\tmreg = reg;\n\t\tmux_sel = snd_soc_component_read32(comp, reg) >> 6;\n\t}\n\tif (mux_sel != WCD9335_CDC_TX_INP_MUX_SEL_AMIC)\n\t\treturn 0;\n\treturn snd_soc_component_read32(comp, mreg) & 0x07;\n}", "target": 0}
{"code": "gimp_write_and_read_file (Gimp     *gimp,\n                          gboolean  with_unusual_stuff,\n                          gboolean  compat_paths,\n                          gboolean  use_gimp_2_8_features)\n{\n  GimpImage           *image;\n  GimpImage           *loaded_image;\n  GimpPlugInProcedure *proc;\n  gchar               *filename;\n  GFile               *file;\n  image = gimp_create_mainimage (gimp,\n                                 with_unusual_stuff,\n                                 compat_paths,\n                                 use_gimp_2_8_features);\n  gimp_assert_mainimage (image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  filename = g_build_filename (g_get_tmp_dir (), \"gimp-test.xcf\", NULL);\n  file = g_file_new_for_path (filename);\n  g_free (filename);\n  proc = gimp_plug_in_manager_file_procedure_find (image->gimp->plug_in_manager,\n                                                   GIMP_FILE_PROCEDURE_GROUP_SAVE,\n                                                   file,\n                                                   NULL );\n  file_save (gimp,\n             image,\n             NULL ,\n             file,\n             proc,\n             GIMP_RUN_NONINTERACTIVE,\n             FALSE ,\n             FALSE ,\n             FALSE ,\n             NULL );\n  loaded_image = gimp_test_load_image (image->gimp, file);\n  gimp_assert_mainimage (loaded_image,\n                         with_unusual_stuff,\n                         compat_paths,\n                         use_gimp_2_8_features);\n  g_file_delete (file, NULL, NULL);\n  g_object_unref (file);\n}", "target": 1}
{"code": "struct tcp_conn_t *tcp_conn_select(struct tcp_sock_t *sock,\n\t\t\t\t   struct tcp_sock_t *sock6)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tfd_set rfds;\n\tstruct timeval tv;\n\tint retval = 0;\n\tint nfds = 0;\n\twhile (retval == 0) {\n\t\tFD_ZERO(&rfds);\n\t\tif (sock) {\n\t\t\tFD_SET(sock->sd, &rfds);\n\t\t\tnfds = sock->sd;\n\t\t}\n\t\tif (sock6) {\n\t\t\tFD_SET(sock6->sd, &rfds);\n\t\t\tif (sock6->sd > nfds)\n\t\t\t\tnfds = sock6->sd;\n\t\t}\n\t\tif (nfds == 0) {\n\t\t\tERR(\"No valid TCP socket supplied.\");\n\t\t\tgoto error;\n\t\t}\n\t\tnfds += 1;\n\t\ttv.tv_sec = 5;\n\t\ttv.tv_usec = 0;\n\t\tretval = select(nfds, &rfds, NULL, NULL, &tv);\n\t\tif (retval == -1) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (sock && FD_ISSET(sock->sd, &rfds)) {\n\t\tconn->sd = accept(sock->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv4\");\n\t} else if (sock6 && FD_ISSET(sock6->sd, &rfds)) {\n\t\tconn->sd = accept(sock6->sd, NULL, NULL);\n\t\tNOTE (\"Using IPv6\");\n\t} else {\n\t\tERR(\"select failed\");\n\t\tgoto error;\n\t}\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 0}
{"code": "static inline bool rt6_qualify_for_ecmp(struct rt6_info *rt)\n{\n\treturn (rt->rt6i_flags & (RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC)) ==\n\t       RTF_GATEWAY;\n}", "target": 0}
{"code": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, int length)\n{\n\tu_int caplen = ndo->ndo_snapend - p;\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i;\n\tint proto;\n\tconst void *se;\n\tif (caplen == 0)\n\t\treturn;\n        if (length <= 0)\n                return;\n\tb = (u_char *)malloc(caplen);\n\tif (b == NULL)\n\t\treturn;\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = *s++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = *s++ ^ 0x20;\n\t\t}\n\t\t*t++ = c;\n\t}\n\tse = ndo->ndo_snapend;\n\tndo->ndo_snapend = t;\n\tlength = t - b;\n        if (length < 1)\n                goto trunc;\n        proto = *b; \n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        case PPP_IPV6:\n\t\tip6_print(ndo, b + 1, length - 1);\n\t\tgoto cleanup;\n        default: \n\t\tbreak;\n        }\n        if (length < 2)\n                goto trunc;\n        proto = EXTRACT_16BITS(b); \n        switch (proto) {\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n            if (length < 4)\n                goto trunc;\n            proto = EXTRACT_16BITS(b+2); \n            handle_ppp(ndo, proto, b + 4, length - 4);\n            break;\n        default: \n            handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\ncleanup:\n\tndo->ndo_snapend = se;\n\tfree(b);\n        return;\ntrunc:\n\tndo->ndo_snapend = se;\n\tfree(b);\n\tND_PRINT((ndo, \"[|ppp]\"));\n}", "target": 0}
{"code": "static inline int copy_pmd_range(struct mm_struct *dst_mm, struct mm_struct *src_mm,\n\t\tpud_t *dst_pud, pud_t *src_pud, struct vm_area_struct *vma,\n\t\tunsigned long addr, unsigned long end)\n{\n\tpmd_t *src_pmd, *dst_pmd;\n\tunsigned long next;\n\tdst_pmd = pmd_alloc(dst_mm, dst_pud, addr);\n\tif (!dst_pmd)\n\t\treturn -ENOMEM;\n\tsrc_pmd = pmd_offset(src_pud, addr);\n\tdo {\n\t\tnext = pmd_addr_end(addr, end);\n\t\tif (pmd_none_or_clear_bad(src_pmd))\n\t\t\tcontinue;\n\t\tif (copy_pte_range(dst_mm, src_mm, dst_pmd, src_pmd,\n\t\t\t\t\t\tvma, addr, next))\n\t\t\treturn -ENOMEM;\n\t} while (dst_pmd++, src_pmd++, addr = next, addr != end);\n\treturn 0;\n}", "target": 0}
{"code": "m_proleptic_julian_p(union DateData *x)\n{\n    double sg;\n    sg = m_sg(x);\n    if (isinf(sg) && sg > 0)\n\treturn 1;\n    return 0;\n}", "target": 0}
{"code": "struct vfsmount *clone_private_mount(const struct path *path)\n{\n\tstruct mount *old_mnt = real_mount(path->mnt);\n\tstruct mount *new_mnt;\n\tif (IS_MNT_UNBINDABLE(old_mnt))\n\t\treturn ERR_PTR(-EINVAL);\n\tnew_mnt = clone_mnt(old_mnt, path->dentry, CL_PRIVATE);\n\tif (IS_ERR(new_mnt))\n\t\treturn ERR_CAST(new_mnt);\n\tnew_mnt->mnt_ns = MNT_NS_INTERNAL;\n\treturn &new_mnt->mnt;\n}", "target": 1}
{"code": "TEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}", "target": 1}
{"code": "        int    ReadDoubleArray(unsigned char *sString, int nLen, double (&pArray)[nMax])\n        {\n            int nStart = 0;\n            while( sString[nStart] != '[' )\n            {\n                nStart++;\n                if ( nStart >= nLen )\n                    return 0;\n            }\n            int nEnd = ++nStart;\n            while ( sString[nEnd] != ']' )\n            {\n                nEnd++;\n                if ( nEnd >= nLen )\n                    return 0;\n            }\n            sString = sString + nStart;\n            nLen    = nEnd - nStart;\n            int nCount = 0;\n            const int c_nNumLimit = 32;\n            unsigned char sBuffer[c_nNumLimit];\n            int nBufPos = 0;\n            bool bNewItem = true;\n            for ( int nIndex = 0; nIndex < nLen; ++nIndex )\n            {\n                unsigned char unChar = sString[nIndex];\n                if ( ' ' == unChar )\n                {\n                    if ( !bNewItem )\n                        bNewItem = true;\n                    continue;\n                }\n                if ( bNewItem )\n                {\n                    if ( nCount >= nMax )\n                        break;\n                    if ( nCount > 0 )\n                        pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n                    memset( sBuffer, 0x00, c_nNumLimit );\n                    nBufPos = 0;\n                    bNewItem = false;\n                    nCount++;\n                }\n                sBuffer[nBufPos++] = unChar;\n                if (nBufPos >= c_nNumLimit)\n                    break;\n            }\n            if ( 0 != sBuffer[0] && nCount > 0 )\n                pArray[nCount - 1] = Utils::GetDouble( (const char *)sBuffer );\n            return nCount;\n        }", "target": 0}
{"code": "std::wstring CreateUniqueTempDirectory()\n{\n    wchar_t tmpdir[MAX_PATH+1];\n    if ( GetTempPath(MAX_PATH+1, tmpdir) == 0 )\n        throw Win32Exception(\"Cannot create temporary directory\");\n    for ( ;; )\n    {\n        std::wstring dir(tmpdir);\n        dir += L\"Update-\";\n        UUID uuid;\n        UuidCreate(&uuid);\n        RPC_WSTR uuidStr;\n        RPC_STATUS status = UuidToString(&uuid, &uuidStr);\n        dir += reinterpret_cast<wchar_t*>(uuidStr);\n        RpcStringFree(&uuidStr);\n        if ( CreateDirectory(dir.c_str(), NULL) )\n            return dir;\n        else if ( GetLastError() != ERROR_ALREADY_EXISTS )\n            throw Win32Exception(\"Cannot create temporary directory\");\n    }\n}", "target": 1}
{"code": "void set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tpmd_t pmdval;\n\tswp_entry_t entry;\n\tpmd_t pmdswp;\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\tmmu_notifier_invalidate_range_start(mm, address,\n\t\t\taddress + HPAGE_PMD_SIZE);\n\tflush_cache_range(vma, address, address + HPAGE_PMD_SIZE);\n\tpmdval = *pvmw->pmd;\n\tpmdp_invalidate(vma, address, pvmw->pmd);\n\tif (pmd_dirty(pmdval))\n\t\tset_page_dirty(page);\n\tentry = make_migration_entry(page, pmd_write(pmdval));\n\tpmdswp = swp_entry_to_pmd(entry);\n\tif (pmd_soft_dirty(pmdval))\n\t\tpmdswp = pmd_swp_mksoft_dirty(pmdswp);\n\tset_pmd_at(mm, address, pvmw->pmd, pmdswp);\n\tpage_remove_rmap(page, true);\n\tput_page(page);\n\tmmu_notifier_invalidate_range_end(mm, address,\n\t\t\taddress + HPAGE_PMD_SIZE);\n}", "target": 0}
{"code": "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String&  ,\n                         int  , int  ) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n  int server_count = memcached_server_count(&data->m_memcache);\n  Array return_val;\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n    stat = stats + server_id;\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n  free(stats);\n  return return_val;\n}", "target": 1}
{"code": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}", "target": 1}
{"code": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\treturn 0;\n}", "target": 1}
{"code": "void file_sb_list_del(struct file *file)\n{\n\tif (!list_empty(&file->f_u.fu_list)) {\n\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n\t\tlist_del_init(&file->f_u.fu_list);\n\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n\t}\n}", "target": 1}
{"code": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}", "target": 1}
{"code": "void HTTPSession::onCertificateRequest(uint16_t requestId,\n                                       std::unique_ptr<IOBuf> authRequest) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE_REQUEST on\" << *this << \", requestId=\" << requestId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  std::pair<uint16_t, std::unique_ptr<folly::IOBuf>> authenticator;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      authenticator =\n          secondAuthManager_->getAuthenticator(*fizzBase,\n                                               TransportDirection::UPSTREAM,\n                                               requestId,\n                                               std::move(authRequest));\n    } else {\n      authenticator =\n          secondAuthManager_->getAuthenticator(*fizzBase,\n                                               TransportDirection::DOWNSTREAM,\n                                               requestId,\n                                               std::move(authRequest));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (codec_->generateCertificate(writeBuf_,\n                                  authenticator.first,\n                                  std::move(authenticator.second)) > 0) {\n    scheduleWrite();\n  }\n}", "target": 0}
{"code": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count;\n    nut->avf = s;\n    pos = 0;\n    do {\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while (decode_main_header(nut) < 0);\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n        decode_info_header(nut);\n    }\n    ffformatcontext(s)->data_offset = pos - 8;\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n    return 0;\n}", "target": 1}
{"code": "static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tgoto error;\n\t}\n\treturn cmpt;\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bool tipc_node_cleanup(struct tipc_node *peer)\n{\n\tstruct tipc_node *temp_node;\n\tstruct tipc_net *tn = tipc_net(peer->net);\n\tbool deleted = false;\n\tif (!spin_trylock_bh(&tn->node_list_lock))\n\t\treturn false;\n\ttipc_node_write_lock(peer);\n\tif (!node_is_up(peer) && time_after(jiffies, peer->delete_at)) {\n\t\ttipc_node_clear_links(peer);\n\t\ttipc_node_delete_from_list(peer);\n\t\tdeleted = true;\n\t}\n\ttipc_node_write_unlock(peer);\n\tif (!deleted) {\n\t\tspin_unlock_bh(&tn->node_list_lock);\n\t\treturn deleted;\n\t}\n\ttn->capabilities = TIPC_NODE_CAPABILITIES;\n\tlist_for_each_entry_rcu(temp_node, &tn->node_list, list) {\n\t\ttn->capabilities &= temp_node->capabilities;\n\t}\n\ttipc_bcast_toggle_rcast(peer->net,\n\t\t\t\t(tn->capabilities & TIPC_BCAST_RCAST));\n\tspin_unlock_bh(&tn->node_list_lock);\n\treturn deleted;\n}", "target": 0}
{"code": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}", "target": 1}
{"code": "crm_send_remote_msg(void *session, xmlNode * msg, gboolean encrypted)\n{\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        cib_send_tls(session, msg);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        cib_send_plaintext(GPOINTER_TO_INT(session), msg);\n    }\n}", "target": 1}
{"code": "real_need_secrets (NMVpnServicePlugin *plugin,\n                   NMConnection *connection,\n                   const char **out_setting_name,\n                   GError **error)\n{\n\tNMSettingVpn *s_vpn;\n\tNMSettingSecretFlags pw_flags;\n\tconst char *pw = NULL;\n\tg_return_val_if_fail (NM_IS_VPN_SERVICE_PLUGIN (plugin), FALSE);\n\tg_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);\n\ts_vpn = nm_connection_get_setting_vpn (connection);\n\tif (!s_vpn) {\n\t\tg_set_error (error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION,\n\t\t             \"%s\",\n\t\t             _(\"Could not process the request because the VPN connection settings were invalid.\"));\n\t\treturn FALSE;\n\t}\n\tpw = nm_setting_vpn_get_secret (s_vpn, NM_VPNC_KEY_SECRET);\n\tpw_flags = get_pw_flags (s_vpn, NM_VPNC_KEY_SECRET, NM_VPNC_KEY_SECRET_TYPE);\n\tif (!pw && !(pw_flags & NM_SETTING_SECRET_FLAG_NOT_REQUIRED)) {\n\t\t*out_setting_name = NM_SETTING_VPN_SETTING_NAME;\n\t\treturn TRUE;\n\t}\n\tpw = nm_setting_vpn_get_secret (s_vpn, NM_VPNC_KEY_XAUTH_PASSWORD);\n\tpw_flags = get_pw_flags (s_vpn, NM_VPNC_KEY_XAUTH_PASSWORD, NM_VPNC_KEY_XAUTH_PASSWORD_TYPE);\n\tif (!pw && !(pw_flags & NM_SETTING_SECRET_FLAG_NOT_REQUIRED)) {\n\t\t*out_setting_name = NM_SETTING_VPN_SETTING_NAME;\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    if (row_partition_types_.empty()) {\n      return errors::InvalidArgument(\"No row_partition_types given.\");\n    }\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            \"Cannot handle VALUE_ROWIDS in first dimension.\");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Cannot handle type \",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }", "target": 0}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      const void *input_pointer = sgx_params->input;\n      uint64_t input_size = sgx_params->input_size;\n      if (!TrustedPrimitives::IsOutsideEnclave(input_pointer, input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(input_pointer));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  const void *output_pointer = sgx_params->output;\n  uint64_t output_size = sgx_params->output_size;\n  if (!TrustedPrimitives::IsOutsideEnclave(output_pointer, output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    output->Deserialize(output_pointer, output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 0}
{"code": "void RtmpProtocol::reset() {\n    _chunk_size_in = DEFAULT_CHUNK_LEN;\n    _chunk_size_out = DEFAULT_CHUNK_LEN;\n    _bytes_sent = 0;\n    _bytes_sent_last = 0;\n    _windows_size = 0;\n    _bandwidth = 2500000;\n    _band_limit_type = 2;\n    _map_chunk_data.clear();\n    _now_stream_index = 0;\n    _now_chunk_id = 0;\n    _send_req_id = 0;\n    HttpRequestSplitter::reset();\n    _stream_index = STREAM_CONTROL;\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_C0C1(data, len);\n    };\n}", "target": 0}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += stripsize;\n        }\n        return 1;\n} ", "target": 0}
{"code": "static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\tunsigned int i;\n\tif (!(quirks & CP_RDESC_SWAPPED_MIN_MAX))\n\t\treturn rdesc;\n\tif (*rsize < 4)\n\t\treturn rdesc;\n\tfor (i = 0; i < *rsize - 4; i++)\n\t\tif (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) {\n\t\t\trdesc[i] = 0x19;\n\t\t\trdesc[i + 2] = 0x29;\n\t\t\tswap(rdesc[i + 3], rdesc[i + 1]);\n\t\t}\n\treturn rdesc;\n}", "target": 0}
{"code": "void auth_client_request_abort(struct auth_client_request **_request)\n{\n\tstruct auth_client_request *request = *_request;\n\t*_request = NULL;\n\tauth_client_send_cancel(request->conn->client, request->id);\n\tcall_callback(request, AUTH_REQUEST_STATUS_ABORT, NULL, NULL);\n\tpool_unref(&request->pool);\n}", "target": 0}
{"code": "next_line(struct archive_read *a,\n    const char **b, ssize_t *avail, ssize_t *ravail, ssize_t *nl)\n{\n\tssize_t len;\n\tint quit;\n\tquit = 0;\n\tif (*avail == 0) {\n\t\t*nl = 0;\n\t\tlen = 0;\n\t} else\n\t\tlen = get_line_size(*b, *avail, nl);\n\twhile (*nl == 0 && len == *avail && !quit) {\n\t\tssize_t diff = *ravail - *avail;\n\t\tsize_t nbytes_req = (*ravail+1023) & ~1023U;\n\t\tssize_t tested;\n\t\tif (nbytes_req < (size_t)*ravail + 160)\n\t\t\tnbytes_req <<= 1;\n\t\t*b = __archive_read_ahead(a, nbytes_req, avail);\n\t\tif (*b == NULL) {\n\t\t\tif (*ravail >= *avail)\n\t\t\t\treturn (0);\n\t\t\t*b = __archive_read_ahead(a, *avail, avail);\n\t\t\tquit = 1;\n\t\t}\n\t\t*ravail = *avail;\n\t\t*b += diff;\n\t\t*avail -= diff;\n\t\ttested = len;\n\t\tlen = get_line_size(*b, *avail, nl);\n\t\tif (len >= 0)\n\t\t\tlen += tested;\n\t}\n\treturn (len);\n}", "target": 1}
{"code": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}", "target": 0}
{"code": "get_indent_lnum(linenr_T lnum)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get(lnum), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);\n#endif\n}", "target": 0}
{"code": "parse_memory(VALUE klass, VALUE data, VALUE encoding)\n{\n  htmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = htmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                    (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  if (RTEST(encoding)) {\n    xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler(StringValueCStr(encoding));\n    if (enc != NULL) {\n      xmlSwitchToEncoding(ctxt, enc);\n      if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n        rb_raise(rb_eRuntimeError, \"Unsupported encoding %s\",\n                 StringValueCStr(encoding));\n      }\n    }\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "void schedule_deferred_open_smb_message(uint16 mid)\n{\n\tstruct pending_message_list *pml;\n\tint i = 0;\n\tfor (pml = deferred_open_queue; pml; pml = pml->next) {\n\t\tuint16 msg_mid = SVAL(pml->buf.data,smb_mid);\n\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: [%d] msg_mid = %u\\n\", i++,\n\t\t\t(unsigned int)msg_mid ));\n\t\tif (mid == msg_mid) {\n\t\t\tstruct timed_event *te;\n\t\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: scheduling mid %u\\n\",\n\t\t\t\tmid ));\n\t\t\tte = event_add_timed(smbd_event_context(),\n\t\t\t\t\t     pml,\n\t\t\t\t\t     timeval_zero(),\n\t\t\t\t\t     smbd_deferred_open_timer,\n\t\t\t\t\t     pml);\n\t\t\tif (!te) {\n\t\t\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: \"\n\t\t\t\t\t  \"event_add_timed() failed, skipping mid %u\\n\",\n\t\t\t\t\t  mid ));\n\t\t\t}\n\t\t\tTALLOC_FREE(pml->te);\n\t\t\tpml->te = te;\n\t\t\tDLIST_PROMOTE(deferred_open_queue, pml);\n\t\t\treturn;\n\t\t}\n\t}\n\tDEBUG(10,(\"schedule_deferred_open_smb_message: failed to find message mid %u\\n\",\n\t\tmid ));\n}", "target": 0}
{"code": "static int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,\n\t\t\t  void *buf, int buf_len, int in_len, int *pout_len)\n{\n\tstruct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();\n\tSKCIPHER_REQUEST_ON_STACK(req, tfm);\n\tstruct sg_table sgt;\n\tstruct scatterlist prealloc_sg;\n\tchar iv[AES_BLOCK_SIZE];\n\tint pad_byte = AES_BLOCK_SIZE - (in_len & (AES_BLOCK_SIZE - 1));\n\tint crypt_len = encrypt ? in_len + pad_byte : in_len;\n\tint ret;\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\tWARN_ON(crypt_len > buf_len);\n\tif (encrypt)\n\t\tmemset(buf + in_len, pad_byte, pad_byte);\n\tret = setup_sgtable(&sgt, &prealloc_sg, buf, crypt_len);\n\tif (ret)\n\t\tgoto out_tfm;\n\tcrypto_skcipher_setkey((void *)tfm, key->key, key->len);\n\tmemcpy(iv, aes_iv, AES_BLOCK_SIZE);\n\tskcipher_request_set_tfm(req, tfm);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);\n\tif (encrypt)\n\t\tret = crypto_skcipher_encrypt(req);\n\telse\n\t\tret = crypto_skcipher_decrypt(req);\n\tskcipher_request_zero(req);\n\tif (ret) {\n\t\tpr_err(\"%s %scrypt failed: %d\\n\", __func__,\n\t\t       encrypt ? \"en\" : \"de\", ret);\n\t\tgoto out_sgt;\n\t}\n\tif (encrypt) {\n\t\t*pout_len = crypt_len;\n\t} else {\n\t\tpad_byte = *(char *)(buf + in_len - 1);\n\t\tif (pad_byte > 0 && pad_byte <= AES_BLOCK_SIZE &&\n\t\t    in_len >= pad_byte) {\n\t\t\t*pout_len = in_len - pad_byte;\n\t\t} else {\n\t\t\tpr_err(\"%s got bad padding %d on in_len %d\\n\",\n\t\t\t       __func__, pad_byte, in_len);\n\t\t\tret = -EPERM;\n\t\t\tgoto out_sgt;\n\t\t}\n\t}\nout_sgt:\n\tteardown_sgtable(&sgt);\nout_tfm:\n\tcrypto_free_skcipher(tfm);\n\treturn ret;\n}", "target": 0}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 0}
{"code": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}", "target": 1}
{"code": "gopherHTMLFooter(StoreEntry * e)\n{\n    storeAppendPrintf(e, \"<HR noshade size=\\\"1px\\\">\\n\");\n    storeAppendPrintf(e, \"<ADDRESS>\\n\");\n    storeAppendPrintf(e, \"Generated %s by %s (%s)\\n\",\n                      Time::FormatRfc1123(squid_curtime),\n                      getMyHostname(),\n                      visible_appname_string);\n    storeAppendPrintf(e, \"</ADDRESS></BODY></HTML>\\n\");\n}", "target": 1}
{"code": "void securityWarningCommand(client *c) {\n    static time_t logged_time;\n    time_t now = time(NULL);\n    if (labs(now-logged_time) > 60) {\n        serverLog(LL_WARNING,\"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.\");\n        logged_time = now;\n    }\n    freeClientAsync(c);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in_shape = context->input(0);\n    const Tensor& out_backprop = context->input(1);\n    OP_REQUIRES(\n        context,\n        tensor_in_shape.dims() == 1 && tensor_in_shape.NumElements() == 5,\n        errors::InvalidArgument(\"tensor_in must be 1-dimensional and 5 \"\n                                \"elements\"));\n    OP_REQUIRES(context, out_backprop.dims() == 5,\n                errors::InvalidArgument(\"out_backprop must be 5-dimensional\"));\n    TensorShape output_shape;\n    auto shape_vec = tensor_in_shape.vec<int32>();\n    for (int64_t i = 0; i < tensor_in_shape.NumElements(); ++i) {\n      output_shape.AddDim(shape_vec(i));\n    }\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    std::array<int64_t, 3> input_size{\n        {GetTensorDim(output_shape, data_format_, '2'),\n         GetTensorDim(output_shape, data_format_, '1'),\n         GetTensorDim(output_shape, data_format_, '0')}};\n    std::array<int64_t, 3> window{{GetTensorDim(ksize_, data_format_, '2'),\n                                   GetTensorDim(ksize_, data_format_, '1'),\n                                   GetTensorDim(ksize_, data_format_, '0')}};\n    std::array<int64_t, 3> stride{{GetTensorDim(stride_, data_format_, '2'),\n                                   GetTensorDim(stride_, data_format_, '1'),\n                                   GetTensorDim(stride_, data_format_, '0')}};\n    std::array<int64_t, 3> padding, out;\n    OP_REQUIRES_OK(context, Get3dOutputSize(input_size, window, stride,\n                                            padding_, &out, &padding));\n    LaunchAvgPooling3dGradOp<Device, T>::launch(\n        context, output_shape, out_backprop, window, stride, out, padding,\n        data_format_, output);\n  }", "target": 1}
{"code": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n    segment->nb_index_entries = avio_rb32(pb);\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))\n        return AVERROR(ENOMEM);\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        \n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 0}
{"code": "static void axfm(RCore *core) {\n\tRVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX);\n\tif (refs && !RVecAnalRef_empty (refs)) {\n\t\tRVecAnalRef_sort (refs, compare_ref);\n\t\tut64 last_addr = UT64_MAX;\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\tconst bool is_first = ref->addr != last_addr;\n\t\t\tconst char *name;\n\t\t\tif (is_first) {\n\t\t\t\tname = axtm_name (core, ref->addr);\n\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\": %s\\n\", ref->addr, name? name: \"?\");\n\t\t\t}\n\t\t\tname = axtm_name (core, ref->at);\n\t\t\tr_cons_printf (\"  0x%\"PFMT64x\": %s\\n\", ref->at, name? name: \"?\");\n\t\t\tlast_addr = ref->addr;\n\t\t}\n\t}\n\tRVecAnalRef_free (refs);\n}", "target": 1}
{"code": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_flags);\n\tadd_bool_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table, 0, &anope_flags_compat, true);\n\thook_add_event(\"nick_can_register\");\n\thook_add_nick_can_register(check_registration_keywords);\n\thook_add_event(\"user_can_register\");\n\thook_add_user_can_register(check_registration_keywords);\n}", "target": 0}
{"code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\tsalsa20_ivsetup(ctx, walk.iv);\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_sco))\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\n\tsk->sk_state = BT_BOUND;\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "size_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n{\n    Error *err = NULL;\n    ssize_t ret;\n    ret = qio_channel_write(\n        vs->ioc, (const char *)data, datalen, &err);\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, &err);\n}", "target": 0}
{"code": "StatusOr<unsigned> GraphDefImporter::ArgNumType(const NamedAttrList &attrs,\n                                                const OpDef::ArgDef &arg_def,\n                                                SmallVectorImpl<Type> &types) {\n  if (!arg_def.type_list_attr().empty()) {\n    if (auto v = attrs.get(arg_def.type_list_attr()).dyn_cast<ArrayAttr>()) {\n      for (Attribute attr : v) {\n        if (auto dtype = attr.dyn_cast<TypeAttr>()) {\n          types.push_back(UnrankedTensorType::get(dtype.getValue()));\n        } else {\n          return InvalidArgument(\"Expected '\", arg_def.type_list_attr(),\n                                 \"' to be a list of types\");\n        }\n      }\n      return v.size();\n    }\n    return NotFound(\"Type attr not found: \", arg_def.type_list_attr());\n  }\n  unsigned num = 1;\n  if (!arg_def.number_attr().empty()) {\n    if (auto v = attrs.get(arg_def.number_attr()).dyn_cast<IntegerAttr>()) {\n      num = v.getValue().getZExtValue();\n    } else {\n      return NotFound(\"Type attr not found: \", arg_def.number_attr());\n    }\n  }\n  Type dtype;\n  if (arg_def.type() != DataType::DT_INVALID) {\n    TF_RETURN_IF_ERROR(ConvertDataType(arg_def.type(), b_, &dtype));\n  } else if (arg_def.type_attr().empty()) {\n    return InvalidArgument(\"Arg '\", arg_def.name(),\n                           \"' has invalid type and no type attribute\");\n  } else {\n    if (auto v = attrs.get(arg_def.type_attr()).dyn_cast<TypeAttr>()) {\n      dtype = v.getValue();\n    } else {\n      return NotFound(\"Type attr not found: \", arg_def.type_attr());\n    }\n  }\n  types.append(num, UnrankedTensorType::get(dtype));\n  return num;\n}", "target": 1}
{"code": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}", "target": 1}
{"code": "rdr_notification_ctx_cleanup(struct rdr_notification_ctx *ctx)\n{\n\tif (ctx->deltas.array != NULL)\n\t\tdeltas_parsed_cleanup(&ctx->deltas, __delta_head_destroy);\n}", "target": 1}
{"code": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}", "target": 1}
{"code": "void Context::onDelete() {\n  if (wasm_->onDelete_) {\n    wasm_->onDelete_(this, id_);\n  }\n}", "target": 1}
{"code": "static int __init mbochs_dev_init(void)\n{\n\tint ret = 0;\n\tatomic_set(&mbochs_avail_mbytes, max_mbytes);\n\tret = alloc_chrdev_region(&mbochs_devt, 0, MINORMASK + 1, MBOCHS_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"Error: failed to register mbochs_dev, err: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tcdev_init(&mbochs_cdev, &vd_fops);\n\tcdev_add(&mbochs_cdev, mbochs_devt, MINORMASK + 1);\n\tpr_info(\"%s: major %d\\n\", __func__, MAJOR(mbochs_devt));\n\tret = mdev_register_driver(&mbochs_driver);\n\tif (ret)\n\t\tgoto err_cdev;\n\tmbochs_class = class_create(THIS_MODULE, MBOCHS_CLASS_NAME);\n\tif (IS_ERR(mbochs_class)) {\n\t\tpr_err(\"Error: failed to register mbochs_dev class\\n\");\n\t\tret = PTR_ERR(mbochs_class);\n\t\tgoto err_driver;\n\t}\n\tmbochs_dev.class = mbochs_class;\n\tmbochs_dev.release = mbochs_device_release;\n\tdev_set_name(&mbochs_dev, \"%s\", MBOCHS_NAME);\n\tret = device_register(&mbochs_dev);\n\tif (ret)\n\t\tgoto err_class;\n\tret = mdev_register_device(&mbochs_dev, &mdev_fops);\n\tif (ret)\n\t\tgoto err_device;\n\treturn 0;\nerr_device:\n\tdevice_unregister(&mbochs_dev);\nerr_class:\n\tclass_destroy(mbochs_class);\nerr_driver:\n\tmdev_unregister_driver(&mbochs_driver);\nerr_cdev:\n\tcdev_del(&mbochs_cdev);\n\tunregister_chrdev_region(mbochs_devt, MINORMASK + 1);\n\treturn ret;\n}", "target": 0}
{"code": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n\t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n\t\t\tregno, tn_buf);\n\t\treturn -EACCES;\n\t}\n\toff = regs[regno].off + regs[regno].var_off.value;\n\tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n    Tensor group_assignment = c->input(2);\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment, REDUCTION_COLLECTIVE,\n                             resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV3 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "static bool has_locked_children(struct mount *mnt, struct dentry *dentry)\n{\n\tstruct mount *child;\n\tlist_for_each_entry(child, &mnt->mnt_mounts, mnt_child) {\n\t\tif (!is_subdir(child->mnt_mountpoint, dentry))\n\t\t\tcontinue;\n\t\tif (child->mnt.mnt_flags & MNT_LOCKED)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "    Exifdatum& Exifdatum::operator=(const URational& value)\n    {\n        return Exiv2::setValue(*this, value);\n    }", "target": 0}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4009 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "static void php_ifd_set32u(char *data, size_t value, int motorola_intel)\n{\n\tif (motorola_intel) {\n\t\tdata[0] = (value & 0xFF000000) >> 24;\n\t\tdata[1] = (value & 0x00FF0000) >> 16;\n\t\tdata[2] = (value & 0x0000FF00) >>  8;\n\t\tdata[3] = (value & 0x000000FF);\n\t} else {\n\t\tdata[3] = (value & 0xFF000000) >> 24;\n\t\tdata[2] = (value & 0x00FF0000) >> 16;\n\t\tdata[1] = (value & 0x0000FF00) >>  8;\n\t\tdata[0] = (value & 0x000000FF);\n\t}\n}", "target": 0}
{"code": "static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s32 off_min = S16_MIN, off_max = S16_MAX;\n\ts32 off = insn->off;\n\tif (curr < pos && curr + off + 1 > pos)\n\t\toff += delta;\n\telse if (curr > pos + delta && curr + off + 1 <= pos + delta)\n\t\toff -= delta;\n\tif (off < off_min || off > off_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->off = off;\n\treturn 0;\n}", "target": 0}
{"code": "hybiDecodeCleanup(ws_ctx_t *wsctx)\n{\n  wsctx->header.payloadLen = 0;\n  wsctx->header.mask.u = 0;\n  wsctx->nReadRaw = 0;\n  wsctx->nToRead= 0;\n  wsctx->carrylen = 0;\n  wsctx->readPos = (unsigned char *)wsctx->codeBufDecode;\n  wsctx->readlen = 0;\n  wsctx->hybiDecodeState = WS_HYBI_STATE_HEADER_PENDING;\n  wsctx->writePos = NULL;\n  rfbLog(\"cleaned up wsctx\\n\");\n}", "target": 0}
{"code": "static void edge_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\tint bv = 0;\t\n\tif (break_state == -1)\n\t\tbv = 1;\t\n\tstatus = ti_do_config(edge_port, UMPC_SET_CLR_BREAK, bv);\n\tif (status)\n\t\tdev_dbg(&port->dev, \"%s - error %d sending break set/clear command.\\n\",\n\t\t\t__func__, status);\n}", "target": 0}
{"code": "    ThreadId thread_id() const { return thread_id_; }", "target": 0}
{"code": "uint64_t ssh_scp_request_get_size64(ssh_scp scp)\n{\n    if (scp == NULL) {\n        return 0;\n    }\n    return scp->filelen;\n}", "target": 0}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\ndone:\n\treturn err;\n}", "target": 1}
{"code": "static int dwc3_qcom_acpi_register_core(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom\t*qcom = platform_get_drvdata(pdev);\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct resource\t\t*res, *child_res = NULL;\n\tstruct platform_device\t*pdev_irq = qcom->urs_usb ? qcom->urs_usb :\n\t\t\t\t\t\t\t    pdev;\n\tint\t\t\tirq;\n\tint\t\t\tret;\n\tqcom->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!qcom->dwc3)\n\t\treturn -ENOMEM;\n\tqcom->dwc3->dev.parent = dev;\n\tqcom->dwc3->dev.type = dev->type;\n\tqcom->dwc3->dev.dma_mask = dev->dma_mask;\n\tqcom->dwc3->dev.dma_parms = dev->dma_parms;\n\tqcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;\n\tchild_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);\n\tif (!child_res)\n\t\treturn -ENOMEM;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to get memory resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tchild_res[0].flags = res->flags;\n\tchild_res[0].start = res->start;\n\tchild_res[0].end = child_res[0].start +\n\t\tqcom->acpi_pdata->dwc3_core_base_size;\n\tirq = platform_get_irq(pdev_irq, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out;\n\t}\n\tchild_res[1].flags = IORESOURCE_IRQ;\n\tchild_res[1].start = child_res[1].end = irq;\n\tret = platform_device_add_resources(qcom->dwc3, child_res, 2);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add resources\\n\");\n\t\tgoto out;\n\t}\n\tret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add properties\\n\");\n\t\tgoto out;\n\t}\n\tret = platform_device_add(qcom->dwc3);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add device\\n\");\n\t\tdevice_remove_software_node(&qcom->dwc3->dev);\n\t}\nout:\n\tkfree(child_res);\n\treturn ret;\n}", "target": 1}
{"code": "xsltFreeKeyDef(xsltKeyDefPtr keyd) {\n    if (keyd == NULL)\n\treturn;\n    if (keyd->comp != NULL)\n\txmlXPathFreeCompExpr(keyd->comp);\n    if (keyd->usecomp != NULL)\n\txmlXPathFreeCompExpr(keyd->usecomp);\n    if (keyd->name != NULL)\n\txmlFree(keyd->name);\n    if (keyd->nameURI != NULL)\n\txmlFree(keyd->nameURI);\n    if (keyd->match != NULL)\n\txmlFree(keyd->match);\n    if (keyd->use != NULL)\n\txmlFree(keyd->use);\n    if (keyd->nsList != NULL)\n        xmlFree(keyd->nsList);\n    memset(keyd, -1, sizeof(xsltKeyDef));\n    xmlFree(keyd);\n}", "target": 0}
{"code": "static int open_without_symlink(const char *target, const char *prefix_skip)\n{\n\tint curlen = 0, dirfd, fulllen, i;\n\tchar *dup = NULL;\n\tfulllen = strlen(target);\n\tif (prefix_skip) {\n\t\tcurlen = strlen(prefix_skip);\n\t\tif (!is_subdir(target, prefix_skip, curlen)) {\n\t\t\tERROR(\"WHOA there - target '%s' didn't start with prefix '%s'\",\n\t\t\t\ttarget, prefix_skip);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (curlen)\n\t\t\tcurlen--;\n\t} else {\n\t\tprefix_skip = \"/\";\n\t\tcurlen = 0;\n\t}\n\tif ((dup = strdup(target)) == NULL) {\n\t\tSYSERROR(\"Out of memory checking for symbolic link\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < fulllen; i++) {\n\t\tif (dup[i] == '/')\n\t\t\tdup[i] = '\\0';\n\t}\n\tdirfd = open(prefix_skip, O_RDONLY);\n\tif (dirfd < 0)\n\t\tgoto out;\n\twhile (1) {\n\t\tint newfd, saved_errno;\n\t\tchar *nextpath;\n\t\tif ((nextpath = get_nextpath(dup, &curlen, fulllen)) == NULL)\n\t\t\tgoto out;\n\t\tnewfd = open_if_safe(dirfd, nextpath);\n\t\tsaved_errno = errno;\n\t\tclose(dirfd);\n\t\tdirfd = newfd;\n\t\tif (newfd < 0) {\n\t\t\terrno = saved_errno;\n\t\t\tif (errno == ELOOP)\n\t\t\t\tSYSERROR(\"%s in %s was a symbolic link!\", nextpath, target);\n\t\t\telse\n\t\t\t\tSYSERROR(\"Error examining %s in %s\", nextpath, target);\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\tfree(dup);\n\treturn dirfd;\n}", "target": 0}
{"code": "static void get_request(GDHCPClient *dhcp_client, struct dhcp_packet *packet,\n\t\tuint16_t packet_len)\n{\n\tGDHCPOptionType type;\n\tGList *list, *value_list;\n\tchar *option_value;\n\tuint8_t *option;\n\tuint8_t code;\n\tfor (list = dhcp_client->request_list; list; list = list->next) {\n\t\tcode = (uint8_t) GPOINTER_TO_INT(list->data);\n\t\toption = dhcp_get_option(packet, packet_len, code);\n\t\tif (!option) {\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\t\tcontinue;\n\t\t}\n\t\ttype =  dhcp_get_code_type(code);\n\t\toption_value = malloc_option_value_string(option, type);\n\t\tif (!option_value)\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\tvalue_list = get_option_value_list(option_value, type);\n\t\tg_free(option_value);\n\t\tif (!value_list)\n\t\t\tg_hash_table_remove(dhcp_client->code_value_hash,\n\t\t\t\t\t\tGINT_TO_POINTER((int) code));\n\t\telse\n\t\t\tg_hash_table_insert(dhcp_client->code_value_hash,\n\t\t\t\tGINT_TO_POINTER((int) code), value_list);\n\t}\n}", "target": 0}
{"code": "bool RenderWidgetHostImpl::GetResizeParams(ResizeParams* resize_params) {\n  *resize_params = ResizeParams();\n  GetWebScreenInfo(&resize_params->screen_info);\n  if (delegate_) {\n    resize_params->resizer_rect = delegate_->GetRootWindowResizerRect(this);\n    resize_params->is_fullscreen_granted =\n        delegate_->IsFullscreenForCurrentTab(this);\n    resize_params->display_mode = delegate_->GetDisplayMode(this);\n  } else {\n    resize_params->is_fullscreen_granted = false;\n    resize_params->display_mode = blink::WebDisplayModeBrowser;\n  }\n  if (view_) {\n    resize_params->new_size = view_->GetRequestedRendererSize();\n    resize_params->physical_backing_size = view_->GetPhysicalBackingSize();\n    resize_params->top_controls_height = view_->GetTopControlsHeight();\n    resize_params->top_controls_shrink_blink_size =\n        view_->DoTopControlsShrinkBlinkSize();\n    resize_params->visible_viewport_size = view_->GetVisibleViewportSize();\n  }\n  const bool size_changed =\n      !old_resize_params_ ||\n      old_resize_params_->new_size != resize_params->new_size ||\n      (old_resize_params_->physical_backing_size.IsEmpty() &&\n       !resize_params->physical_backing_size.IsEmpty());\n  bool dirty = size_changed ||\n      old_resize_params_->screen_info != resize_params->screen_info ||\n      old_resize_params_->physical_backing_size !=\n          resize_params->physical_backing_size ||\n      old_resize_params_->is_fullscreen_granted !=\n          resize_params->is_fullscreen_granted ||\n      old_resize_params_->display_mode != resize_params->display_mode ||\n      old_resize_params_->top_controls_height !=\n          resize_params->top_controls_height ||\n      old_resize_params_->top_controls_shrink_blink_size !=\n          resize_params->top_controls_shrink_blink_size ||\n      old_resize_params_->visible_viewport_size !=\n          resize_params->visible_viewport_size;\n  resize_params->needs_resize_ack =\n      g_check_for_pending_resize_ack && !resize_params->new_size.IsEmpty() &&\n      !resize_params->physical_backing_size.IsEmpty() && size_changed;\n  return dirty;\n}", "target": 0}
{"code": "njs_typed_array_get_string_tag(njs_vm_t *vm, njs_value_t *args,\n    njs_uint_t nargs, njs_index_t unused)\n{\n    njs_value_t  *this;\n    static const njs_value_t  *tags[NJS_OBJ_TYPE_TYPED_ARRAY_SIZE] = {\n        &njs_typed_array_uint8_tag,\n        &njs_typed_array_uint8_clamped_tag,\n        &njs_typed_array_int8_tag,\n        &njs_typed_array_uint16_tag,\n        &njs_typed_array_int16_tag,\n        &njs_typed_array_uint32_tag,\n        &njs_typed_array_int32_tag,\n        &njs_typed_array_float32_tag,\n        &njs_typed_array_float64_tag,\n    };\n    this = njs_argument(args, 0);\n    if (!njs_is_typed_array(this)) {\n        njs_set_undefined(&vm->retval);\n        return NJS_OK;\n    }\n    vm->retval = *tags[njs_typed_array_index(njs_typed_array(this)->type)];\n    return NJS_OK;\n}", "target": 0}
{"code": "  QUInt16() {}", "target": 1}
{"code": "Status FractionalPoolShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 4, &input));\n  std::vector<float> pooling_ratio;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"pooling_ratio\", &pooling_ratio));\n  if (pooling_ratio.size() != 4) {\n    return errors::InvalidArgument(\n        \"pooling_ratio field must specify 4 dimensions\");\n  }\n  std::vector<DimensionHandle> output_dims;\n  for (int i = 0; i < 4; ++i) {\n    DimensionHandle d = c->Dim(input, i);\n    if (c->ValueKnown(d)) {\n      auto val =\n          static_cast<int64_t>(std::floor(c->Value(d) / pooling_ratio[i]));\n      if (val < 0) {\n        return errors::InvalidArgument(\"Size computed for dim \", i,\n                                       \" is negative: \", val);\n      }\n      output_dims.push_back(c->MakeDim(val));\n    } else {\n      output_dims.push_back(c->UnknownDim());\n    }\n  }\n  for (std::size_t i = 0; i < pooling_ratio.size(); ++i) {\n    if (pooling_ratio[i] < 1) {\n      return errors::InvalidArgument(\n          \"pooling_ratio cannot be smaller than 1, got: \", pooling_ratio[i]);\n    }\n  }\n  c->set_output(0, c->MakeShape(output_dims));\n  c->set_output(1, c->Vector(output_dims[1]));\n  c->set_output(2, c->Vector(output_dims[2]));\n  return OkStatus();\n}", "target": 0}
{"code": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n    if (!strncmp(p, \"bytes \", 6)) {\n        p     += 6;\n        s->off = strtoll(p, NULL, 10);\n        if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoll(slash + 1, NULL, 10);\n    }\n    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n        h->is_streamed = 0; \n}", "target": 1}
{"code": "    const char* Image::typeName(uint16_t tag) const\n    {\n        const char* result = nullptr;\n        switch (tag ) {\n            case Exiv2::unsignedByte     : result = \"BYTE\"      ; break;\n            case Exiv2::asciiString      : result = \"ASCII\"     ; break;\n            case Exiv2::unsignedShort    : result = \"SHORT\"     ; break;\n            case Exiv2::unsignedLong     : result = \"LONG\"      ; break;\n            case Exiv2::unsignedRational : result = \"RATIONAL\"  ; break;\n            case Exiv2::signedByte       : result = \"SBYTE\"     ; break;\n            case Exiv2::undefined        : result = \"UNDEFINED\" ; break;\n            case Exiv2::signedShort      : result = \"SSHORT\"    ; break;\n            case Exiv2::signedLong       : result = \"SLONG\"     ; break;\n            case Exiv2::signedRational   : result = \"SRATIONAL\" ; break;\n            case Exiv2::tiffFloat        : result = \"FLOAT\"     ; break;\n            case Exiv2::tiffDouble       : result = \"DOUBLE\"    ; break;\n            case Exiv2::tiffIfd          : result = \"IFD\"       ; break;\n            default                      : result = \"unknown\"   ; break;\n        }\n        return result;\n    }", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                BOOLEAN verifyLength,\n                                                LPCSTR caller)\n{\n    IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength, verifyLength);\n    if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)\n        return res;\n    if (res.ipStatus == ppresIPV4)\n    {\n        if (flags & pcrIpChecksum)\n            res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) \n            {\n                if(flags & pcrTcpV4Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));\n                }\n            }\n            else \n            {\n                if (flags & pcrUdpV4Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));\n                }\n            }\n        }\n    }\n    else if (res.ipStatus == ppresIPV6)\n    {\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) \n            {\n                if(flags & pcrTcpV6Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));\n                }\n            }\n            else \n            {\n                if (flags & pcrUdpV6Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));\n                }\n            }\n        }\n    }\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 0}
{"code": "static int unload_module(void)\n{\n\tast_cli_unregister_multiple(cli_identify, ARRAY_LEN(cli_identify));\n\tast_sip_unregister_cli_formatter(cli_formatter);\n\tast_sip_unregister_endpoint_formatter(&endpoint_identify_formatter);\n\tast_sip_unregister_endpoint_identifier(&header_identifier);\n\tast_sip_unregister_endpoint_identifier(&request_identifier);\n\tast_sip_unregister_endpoint_identifier(&ip_identifier);\n\tast_sip_unregister_endpoint_identifier(&transport_identifier);\n\treturn 0;\n}", "target": 1}
{"code": "static bool ldm_frag_add (const u8 *data, int size, struct list_head *frags)\n{\n\tstruct frag *f;\n\tstruct list_head *item;\n\tint rec, num, group;\n\tBUG_ON (!data || !frags);\n\tif (size < 2 * VBLK_SIZE_HEAD) {\n\t\tldm_error(\"Value of size is to small.\");\n\t\treturn false;\n\t}\n\tgroup = get_unaligned_be32(data + 0x08);\n\trec   = get_unaligned_be16(data + 0x0C);\n\tnum   = get_unaligned_be16(data + 0x0E);\n\tif ((num < 1) || (num > 4)) {\n\t\tldm_error (\"A VBLK claims to have %d parts.\", num);\n\t\treturn false;\n\t}\n\tif (rec >= num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, num);\n\t\treturn false;\n\t}\n\tlist_for_each (item, frags) {\n\t\tf = list_entry (item, struct frag, list);\n\t\tif (f->group == group)\n\t\t\tgoto found;\n\t}\n\tf = kmalloc (sizeof (*f) + size*num, GFP_KERNEL);\n\tif (!f) {\n\t\tldm_crit (\"Out of memory.\");\n\t\treturn false;\n\t}\n\tf->group = group;\n\tf->num   = num;\n\tf->rec   = rec;\n\tf->map   = 0xFF << num;\n\tlist_add_tail (&f->list, frags);\nfound:\n\tif (rec >= f->num) {\n\t\tldm_error(\"REC value (%d) exceeds NUM value (%d)\", rec, f->num);\n\t\treturn false;\n\t}\n\tif (f->map & (1 << rec)) {\n\t\tldm_error (\"Duplicate VBLK, part %d.\", rec);\n\t\tf->map &= 0x7F;\t\t\t\n\t\treturn false;\n\t}\n\tf->map |= (1 << rec);\n\tdata += VBLK_SIZE_HEAD;\n\tsize -= VBLK_SIZE_HEAD;\n\tmemcpy (f->data+rec*(size-VBLK_SIZE_HEAD)+VBLK_SIZE_HEAD, data, size);\n\treturn true;\n}", "target": 0}
{"code": "static uint16_t nvme_cmd_effects(NvmeCtrl *n, uint8_t csi, uint32_t buf_len,\n                                 uint64_t off, NvmeRequest *req)\n{\n    NvmeEffectsLog log = {};\n    const uint32_t *src_iocs = NULL;\n    uint32_t trans_len;\n    if (off >= sizeof(log)) {\n        trace_pci_nvme_err_invalid_log_page_offset(off, sizeof(log));\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n    switch (NVME_CC_CSS(ldl_le_p(&n->bar.cc))) {\n    case NVME_CC_CSS_NVM:\n        src_iocs = nvme_cse_iocs_nvm;\n    case NVME_CC_CSS_ADMIN_ONLY:\n        break;\n    case NVME_CC_CSS_CSI:\n        switch (csi) {\n        case NVME_CSI_NVM:\n            src_iocs = nvme_cse_iocs_nvm;\n            break;\n        case NVME_CSI_ZONED:\n            src_iocs = nvme_cse_iocs_zoned;\n            break;\n        }\n    }\n    memcpy(log.acs, nvme_cse_acs, sizeof(nvme_cse_acs));\n    if (src_iocs) {\n        memcpy(log.iocs, src_iocs, sizeof(log.iocs));\n    }\n    trans_len = MIN(sizeof(log) - off, buf_len);\n    return nvme_c2h(n, ((uint8_t *)&log) + off, trans_len, req);\n}", "target": 0}
{"code": "static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static int scanbraces(const char* in) {\n    if (strncmp(in, \"{\\\\an\", 4) != 0) {\n        return 0;\n    }\n    if (!isdigit(in[4])) {\n        return 0;\n    }\n    if (in[5] != '}') {\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "static int __netdev_printk(const char *level, const struct net_device *dev,\n\t\t\t   struct va_format *vaf)\n{\n\tint r;\n\tif (dev && dev->dev.parent)\n\t\tr = dev_printk(level, dev->dev.parent, \"%s: %pV\",\n\t\t\t       netdev_name(dev), vaf);\n\telse if (dev)\n\t\tr = printk(\"%s%s: %pV\", level, netdev_name(dev), vaf);\n\telse\n\t\tr = printk(\"%s(NULL net_device): %pV\", level, vaf);\n\treturn r;\n}", "target": 0}
{"code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n    return sRet + \"/\";\n}", "target": 1}
{"code": "static int snd_compress_check_input(struct snd_compr_params *params)\n{\n\tif (params->buffer.fragment_size == 0 ||\n\t\t\tparams->buffer.fragments > SIZE_MAX / params->buffer.fragment_size)\n\t\treturn -EINVAL;\n\tif (params->codec.id == 0 || params->codec.id > SND_AUDIOCODEC_MAX)\n\t\treturn -EINVAL;\n\tif (params->codec.ch_in == 0 || params->codec.ch_out == 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 1}
{"code": "static inline int xrstor_state(struct xsave_struct *fx, u64 mask)\n{\n\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\t\"1: \" XRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}", "target": 1}
{"code": "juniper_atm1_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM1;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[0] == 0x80) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        ND_TCHECK2(p[0], 3);\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            return l2info.header_len;\n        }\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_atm1]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "static UINT ExtractRunLengthRegularFgBg(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\trunLength = (*pbOrderHdr) & g_MaskRegularRunLength;\n\tif (runLength == 0)\n\t{\n\t\tif (!buffer_within_range(pbOrderHdr, 1, pbEnd))\n\t\t{\n\t\t\t*advance = 0;\n\t\t\treturn 0;\n\t\t}\n\t\trunLength = *(pbOrderHdr + 1) + 1;\n\t\t(*advance)++;\n\t}\n\telse\n\t\trunLength = runLength * 8;\n\treturn runLength;\n}", "target": 1}
{"code": "static s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)\n{\n\tu32 m = EMPTY_QUEUE;\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 30*HZ;\n\tdo {\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif (m != EMPTY_QUEUE) {\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_WARNING\"dpti%d: Timeout waiting for message frame!\\n\", pHba->unit);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while(m == EMPTY_QUEUE);\n\tmsg = pHba->msg_addr_virt + m;\n\tmemcpy_toio(msg, data, len);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "static void vhost_zerocopy_done_signal(struct kref *kref)\n{\n\tstruct vhost_ubuf_ref *ubufs = container_of(kref, struct vhost_ubuf_ref,\n\t\t\t\t\t\t    kref);\n\twake_up(&ubufs->wait);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n    if (!batched_input_) {\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n    OP_REQUIRES(context, ragged_nested_splits_len > 0,\n                errors::InvalidArgument(\n                    \"rt_nested_splits must be a list of one or more, but \"\n                    \"received rt_nested_splits of length 0.\"));\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    auto batched_splits_top_vec =\n        batched_ragged_input.splits(0).vec<SPLIT_TYPE>();\n    int num_components = batched_splits_top_vec.size() - 1;\n    OP_REQUIRES(context, num_components >= 0,\n                errors::Internal(\"Invalid split argument.\"));\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n    Tensor* encoded_vector;\n    int output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (int i = 0; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }", "target": 0}
{"code": "static BOOL update_gdi_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cacheBitmapV2)\n{\n\trdpBitmap* bitmap;\n\trdpBitmap* prevBitmap;\n\trdpCache* cache = context->cache;\n\trdpSettings* settings = context->settings;\n\tbitmap = Bitmap_Alloc(context);\n\tif (!bitmap)\n\t\treturn FALSE;\n\tif (!cacheBitmapV2->bitmapBpp)\n\t\tcacheBitmapV2->bitmapBpp = settings->ColorDepth;\n\tif ((settings->ColorDepth == 15) && (cacheBitmapV2->bitmapBpp == 16))\n\t\tcacheBitmapV2->bitmapBpp = settings->ColorDepth;\n\tBitmap_SetDimensions(bitmap, cacheBitmapV2->bitmapWidth, cacheBitmapV2->bitmapHeight);\n\tif (!bitmap->Decompress(context, bitmap, cacheBitmapV2->bitmapDataStream,\n\t                        cacheBitmapV2->bitmapWidth, cacheBitmapV2->bitmapHeight,\n\t                        cacheBitmapV2->bitmapBpp, cacheBitmapV2->bitmapLength,\n\t                        cacheBitmapV2->compressed, RDP_CODEC_ID_NONE))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\tprevBitmap = bitmap_cache_get(cache->bitmap, cacheBitmapV2->cacheId, cacheBitmapV2->cacheIndex);\n\tif (!bitmap->New(context, bitmap))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\tBitmap_Free(context, prevBitmap);\n\treturn bitmap_cache_put(cache->bitmap, cacheBitmapV2->cacheId, cacheBitmapV2->cacheIndex,\n\t                        bitmap);\n}", "target": 0}
{"code": "static TEE_Result do_alloc_publickey(struct ecc_public_key *s, uint32_t type,\n\t\t\t\t     size_t size_bits __unused)\n{\n\tif (type != TEE_TYPE_ECDSA_PUBLIC_KEY &&\n\t    type != TEE_TYPE_ECDH_PUBLIC_KEY)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "static void l2tp_eth_dev_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n}", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n        aligned_height     = FFALIGN(c->height,    16);\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 1}
{"code": "cib_send_plaintext(int sock, xmlNode * msg)\n{\n    char *xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        int rc = 0;\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        len++;                  \n        crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n        rc = write(sock, unsent, len);\n        if (rc < 0) {\n            switch (errno) {\n                case EINTR:\n                case EAGAIN:\n                    crm_trace(\"Retry\");\n                    goto retry;\n                default:\n                    crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, len);\n                    break;\n            }\n        } else if (rc < len) {\n            crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n            goto retry;\n        } else {\n            crm_trace(\"Sent %d bytes: %.100s\", rc, xml_text);\n        }\n    }\n    free(xml_text);\n    return NULL;\n}", "target": 1}
{"code": "static inline void fsnotify_oldname_free(const unsigned char *old_name)\n{\n\tkfree(old_name);\n}", "target": 1}
{"code": "static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static uint8_t search_next_ip(void)\n{       \n\tuint8_t range_count, offset_count;\n\tuint8_t start, end;\n\tuint8_t max_count;\n\tif(dhcps_addr_pool_set){\n#if LWIP_VERSION_MAJOR >= 2\n\t\tstart = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_start));\n\t\tend = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_end));\n#else\n\t\tstart = (uint8_t)ip4_addr4(&dhcps_addr_pool_start);\n\t\tend = (uint8_t)ip4_addr4(&dhcps_addr_pool_end);\n#endif\n\t}else{\n\t\tstart = 0;\n\t\tend = 255;\n\t}\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tfor (range_count = 0; range_count < (max_count = 8); range_count++) {\n\t\tfor (offset_count = 0;offset_count < 32; offset_count++) {\n\t\t\tif ((((ip_table.ip_range[range_count] >> offset_count) & 0x01) == 0) \n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) >= start)\n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) <= end)) {\n\t\t\t\txSemaphoreGive(dhcps_ip_table_semaphore); \n\t\t\t\treturn ((range_count * 32) + (offset_count + 1));\n\t\t\t}\n\t\t}\n\t}\n\txSemaphoreGive(dhcps_ip_table_semaphore); \n\treturn 0;\n}", "target": 0}
{"code": "bit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "gopherStart(FwdState * fwd)\n{\n    GopherStateData *gopherState = new GopherStateData(fwd);\n    debugs(10, 3, gopherState->entry->url());\n    ++ statCounter.server.all.requests;\n    ++ statCounter.server.other.requests;\n    gopher_request_parse(fwd->request,\n                         &gopherState->type_id, gopherState->request);\n    comm_add_close_handler(fwd->serverConnection()->fd, gopherStateFree, gopherState);\n    if (((gopherState->type_id == GOPHER_INDEX) || (gopherState->type_id == GOPHER_CSO))\n            && (strchr(gopherState->request, '?') == nullptr)) {\n        gopherMimeCreate(gopherState);\n        if (gopherState->type_id == GOPHER_INDEX) {\n            gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n        } else {\n            if (gopherState->type_id == GOPHER_CSO) {\n                gopherState->conversion = GopherStateData::HTML_CSO_PAGE;\n            } else {\n                gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n            }\n        }\n        gopherToHTML(gopherState, (char *) nullptr, 0);\n        fwd->markStoredReplyAsWhole(\"gopher instant internal request satisfaction\");\n        fwd->complete();\n        return;\n    }\n    gopherState->serverConn = fwd->serverConnection();\n    gopherSendRequest(fwd->serverConnection()->fd, gopherState);\n    AsyncCall::Pointer timeoutCall = commCbCall(5, 4, \"gopherTimeout\",\n                                     CommTimeoutCbPtrFun(gopherTimeout, gopherState));\n    commSetConnTimeout(fwd->serverConnection(), Config.Timeout.read, timeoutCall);\n}", "target": 1}
{"code": "static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\tfor (n = 0; n < count; n++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "NAN_METHOD(DetectCharacterEncoding) {\n\tNan::HandleScope scope;\n\tv8::Local<v8::Object> inputBuffer = info[0]->ToObject();\n\tUCharsetDetector *charsetDetector;\n\tconst UCharsetMatch *charsetMatch;\n\tUErrorCode errorCode = U_ZERO_ERROR;\n\tcharsetDetector = ucsdet_open(&errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to open ICU charset detector.\");\n\t\treturn;\n\t}\n\tucsdet_setText(\n\t\tcharsetDetector,\n\t\tnode::Buffer::Data(inputBuffer),\n\t\tnode::Buffer::Length(inputBuffer),\n\t\t&errorCode\n\t);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to set ICU charset detectors text.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tcharsetMatch = ucsdet_detect(charsetDetector, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to detect charset.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tconst char *charsetName = ucsdet_getName(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get name from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tint32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);\n\tif(U_FAILURE(errorCode)) {\n\t\tNan::ThrowError(\"Failed to get confidence from charset match.\");\n\t\tucsdet_close(charsetDetector);\n\t\treturn;\n\t}\n\tv8::Local<v8::Object> obj = Nan::New<v8::Object>();\n\tobj->Set(Nan::New<v8::String>(\"encoding\").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());\n\tobj->Set(Nan::New<v8::String>(\"confidence\").ToLocalChecked(), Nan::New<v8::Number>(confidence));\n\tinfo.GetReturnValue().Set(obj);\n\tucsdet_close(charsetDetector);\n}", "target": 0}
{"code": "agoo_ws_create_req(agooCon c, long mlen) {\n    uint8_t\top = 0x0F & *c->buf;\n    if (NULL == (c->req = agoo_req_create(mlen))) {\n\tagoo_log_cat(&agoo_error_cat, \"Out of memory attempting to allocate request.\");\n\treturn true;\n    }\n    if (NULL == c->up || agoo_server.ctx_nil_value == c->up->ctx) {\n\treturn true;\n    }\n    memset(c->req, 0, sizeof(struct _agooReq));\n    if ((long)c->bcnt <= mlen) {\n\tmemcpy(c->req->msg, c->buf, c->bcnt);\n\tif ((long)c->bcnt < mlen) {\n\t    memset(c->req->msg + c->bcnt, 0, mlen - c->bcnt);\n\t}\n    } else {\n\tmemcpy(c->req->msg, c->buf, mlen);\n    }\n    c->req->msg[mlen] = '\\0';\n    c->req->mlen = mlen;\n    c->req->method = (AGOO_WS_OP_BIN == op) ? AGOO_ON_BIN : AGOO_ON_MSG;\n    c->req->upgrade = AGOO_UP_NONE;\n    c->req->up = c->up;\n    memcpy(c->req->remote, c->remote, sizeof(c->remote));\n    c->req->res = NULL;\n    if (c->up->on_msg) {\n\tc->req->hook = agoo_hook_create(AGOO_NONE, NULL, c->up->ctx, PUSH_HOOK, &agoo_server.eval_queue);\n    }\n    return false;\n}", "target": 0}
{"code": "dtls1_process_buffered_records(SSL *s)\n    {\n    pitem *item;\n    item = pqueue_peek(s->d1->unprocessed_rcds.q);\n    if (item)\n        {\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  \n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n    return(1);\n    }", "target": 1}
{"code": "aspath_loop_check (struct aspath *aspath, as_t asno)\n{\n  struct assegment *seg;\n  int count = 0;\n  if ( (aspath == NULL) || (aspath->segments == NULL) )\n    return 0;\n  seg = aspath->segments;\n  while (seg)\n    {\n      int i;\n      for (i = 0; i < seg->length; i++)\n\tif (seg->as[i] == asno)\n\t  count++;\n      seg = seg->next;\n    }\n  return count;\n}", "target": 0}
{"code": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\t\twhile (bytes) {\n\t\t\tint copy = min(bytes, iov->iov_len - base);\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}", "target": 1}
{"code": "static ssize_t intel_iommu_show_ndoms(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct intel_iommu *iommu = dev_to_intel_iommu(dev);\n\treturn sprintf(buf, \"%ld\\n\", cap_ndoms(iommu->cap));\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    Tensor encoded_t = context->input(0);\n    OP_REQUIRES(\n        context, encoded_t.flat<Variant>().size() > 0,\n        errors::InvalidArgument(\"Input `encoded` must not be an empty variant \"\n                                \"tensor, but got \",\n                                encoded_t.DebugString()));\n    auto* encoded = encoded_t.flat<Variant>()(0).get<CompositeTensorVariant>();\n    OP_REQUIRES(context, encoded != nullptr,\n                errors::InvalidArgument(\"The input `encoded` is not a valid \"\n                                        \"CompositeTensorVariant tensor, got \",\n                                        encoded_t.DebugString()));\n    auto expected_class = metadata_.type_spec_proto().type_spec_class();\n    auto actual_class = encoded->metadata().type_spec_proto().type_spec_class();\n    OP_REQUIRES(\n        context, expected_class == actual_class,\n        errors::InvalidArgument(\n            \"Expected a \", TypeSpecProto::TypeSpecClass_Name(expected_class),\n            \" (based on `type_spec`), but `encoded` contains a \",\n            TypeSpecProto::TypeSpecClass_Name(actual_class)));\n    OpOutputList components;\n    OP_REQUIRES_OK(context, context->output_list(\"components\", &components));\n    int num_components = encoded->flat_components().size();\n    OP_REQUIRES(context, component_dtypes_.size() == num_components,\n                errors::InvalidArgument(\"Encoded value has \", num_components,\n                                        \" tensor components; expected \",\n                                        component_dtypes_.size(),\n                                        \" components based on type_spec\"));\n    for (int i = 0; i < component_dtypes_.size(); i++) {\n      const Tensor& component = encoded->flat_components()[i];\n      OP_REQUIRES(context, component_dtypes_[i] == component.dtype(),\n                  errors::InvalidArgument(\"Tensor component \", i, \" had dtype \",\n                                          DataType_Name(component.dtype()),\n                                          \"; expected dtype \",\n                                          DataType_Name(component_dtypes_[i])));\n      components.set(i, component);\n    }\n  }", "target": 0}
{"code": "iasecc_chv_verify(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd, unsigned char *scbs,\n\t\t  int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char scb = scbs[IASECC_ACLS_CHV_VERIFY];\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Verify CHV PIN(ref:%i,len:%i,scb:%X)\", pin_cmd->pin_reference, pin_cmd->pin1.len,\n\t       scb);\n\tif (scb & IASECC_SCB_METHOD_SM) {\n\t\trv = iasecc_sm_pin_verify(card, scb & IASECC_SCB_METHOD_MASK_REF, pin_cmd, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\trv = iso_ops->pin_cmd(card, pin_cmd, tries_left);\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "static int http1_on_response(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_response_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.status_str && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}", "target": 1}
{"code": "static int snd_ctl_elem_lock(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner != NULL)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tvd->owner = file;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}", "target": 0}
{"code": "bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)\n{\n\tuid_t v_uid, tmpuid;\n\tgid_t v_gid;\n\tif (r == v)\n\t\treturn true;\n\tif (r_uid == 0)\n\t\treturn true;\n\tget_pid_creds(v, &v_uid, &v_gid);\n\tif (r_uid == v_uid)\n\t\treturn true;\n\tif (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0\n\t\t\t&& hostuid_to_ns(v_uid, r, &tmpuid))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "is_word_char(unsigned char *ch)\n{\n    Lineprop ctype = get_mctype(ch);\n#ifdef USE_M17N\n    if (ctype & (PC_CTRL | PC_KANJI | PC_UNKNOWN))\n\treturn 0;\n    if (ctype & (PC_WCHAR1 | PC_WCHAR2))\n\treturn 1;\n#else\n    if (ctype == PC_CTRL)\n\treturn 0;\n#endif\n    if (IS_ALNUM(*ch))\n\treturn 1;\n    switch (*ch) {\n    case ',':\n    case '.':\n    case ':':\n    case '\\\"':\t\t\t\n    case '\\'':\n    case '$':\n    case '%':\n    case '*':\n    case '+':\n    case '-':\n    case '@':\n    case '~':\n    case '_':\n\treturn 1;\n    }\n#ifdef USE_M17N\n    if (*ch == NBSP_CODE)\n\treturn 1;\n#else\n    if (*ch == TIMES_CODE || *ch == DIVIDE_CODE || *ch == ANSP_CODE)\n\treturn 0;\n    if (*ch >= AGRAVE_CODE || *ch == NBSP_CODE)\n\treturn 1;\n#endif\n    return 0;\n}", "target": 0}
{"code": "static int nfs4_map_errors(int err)\n{\n\tif (err >= -1000)\n\t\treturn err;\n\tswitch (err) {\n\tcase -NFS4ERR_RESOURCE:\n\t\treturn -EREMOTEIO;\n\tcase -NFS4ERR_WRONGSEC:\n\t\treturn -EPERM;\n\tcase -NFS4ERR_BADOWNER:\n\tcase -NFS4ERR_BADNAME:\n\t\treturn -EINVAL;\n\tcase -NFS4ERR_SHARE_DENIED:\n\t\treturn -EACCES;\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\treturn -EPROTONOSUPPORT;\n\tdefault:\n\t\tdprintk(\"%s could not handle NFSv4 error %d\\n\",\n\t\t\t\t__func__, -err);\n\t\tbreak;\n\t}\n\treturn -EIO;\n}", "target": 0}
{"code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static int init_nss_hash(struct crypto_instance *instance)\n{\n\tPK11SlotInfo*\thash_slot = NULL;\n\tSECItem\t\thash_param;\n\tif (!hash_to_nss[instance->crypto_hash_type]) {\n\t\treturn 0;\n\t}\n\thash_param.type = siBuffer;\n\thash_param.data = 0;\n\thash_param.len = 0;\n\thash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);\n\tif (hash_slot == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Unable to find security slot (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tinstance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,\n\t\t\t\t\t\t       hash_to_nss[instance->crypto_hash_type],\n\t\t\t\t\t\t       PK11_OriginUnwrap, CKA_SIGN,\n\t\t\t\t\t\t       &hash_param, NULL);\n\tif (instance->nss_sym_key_sign == NULL) {\n\t\tlog_printf(instance->log_level_security, \"Failure to import key into NSS (err %d)\",\n\t\t\t   PR_GetError());\n\t\treturn -1;\n\t}\n\tPK11_FreeSlot(hash_slot);\n\treturn 0;\n}", "target": 1}
{"code": "bool_t xdr_krb5_tl_data(XDR *xdrs, krb5_tl_data **tl_data_head)\n{\n     krb5_tl_data *tl, *tl2;\n     bool_t more;\n     unsigned int len;\n     switch (xdrs->x_op) {\n     case XDR_FREE:\n\t  tl = tl2 = *tl_data_head;\n\t  while (tl) {\n\t       tl2 = tl->tl_data_next;\n\t       free(tl->tl_data_contents);\n\t       free(tl);\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = NULL;\n\t  break;\n     case XDR_ENCODE:\n\t  tl = *tl_data_head;\n\t  while (1) {\n\t       more = (tl != NULL);\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (tl == NULL)\n\t\t    break;\n\t       if (!xdr_krb5_int16(xdrs, &tl->tl_data_type))\n\t\t    return FALSE;\n\t       len = tl->tl_data_length;\n\t       if (!xdr_bytes(xdrs, (char **) &tl->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl = tl->tl_data_next;\n\t  }\n\t  break;\n     case XDR_DECODE:\n\t  tl = NULL;\n\t  while (1) {\n\t       if (!xdr_bool(xdrs, &more))\n\t\t    return FALSE;\n\t       if (more == FALSE)\n\t\t    break;\n\t       tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t       if (tl2 == NULL)\n\t\t    return FALSE;\n\t       memset(tl2, 0, sizeof(krb5_tl_data));\n\t       if (!xdr_krb5_int16(xdrs, &tl2->tl_data_type))\n\t\t    return FALSE;\n\t       if (!xdr_bytes(xdrs, (char **)&tl2->tl_data_contents, &len, ~0))\n\t\t    return FALSE;\n\t       tl2->tl_data_length = len;\n\t       tl2->tl_data_next = tl;\n\t       tl = tl2;\n\t  }\n\t  *tl_data_head = tl;\n\t  break;\n     }\n     return TRUE;\n}", "target": 0}
{"code": "REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,\n                                           const int fill, const size_t sz) {\n    if (unlikely(!node))\n        return 0;\n    int ziplist_overhead;\n    if (sz < 254)\n        ziplist_overhead = 1;\n    else\n        ziplist_overhead = 5;\n    if (sz < 64)\n        ziplist_overhead += 1;\n    else if (likely(sz < 16384))\n        ziplist_overhead += 2;\n    else\n        ziplist_overhead += 5;\n    unsigned int new_sz = node->sz + sz + ziplist_overhead;\n    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))\n        return 1;\n    else if (!sizeMeetsSafetyLimit(new_sz))\n        return 0;\n    else if ((int)node->count < fill)\n        return 1;\n    else\n        return 0;\n}", "target": 0}
{"code": "static void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    ses->time.stop = pj_strtoul(&str);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "static int kvm_vm_ioctl_set_pit(struct kvm *kvm, struct kvm_pit_state *ps)\n{\n\tmutex_lock(&kvm->arch.vpit->pit_state.lock);\n\tmemcpy(&kvm->arch.vpit->pit_state, ps, sizeof(struct kvm_pit_state));\n\tkvm_pit_load_count(kvm, 0, ps->channels[0].count, 0);\n\tmutex_unlock(&kvm->arch.vpit->pit_state.lock);\n\treturn 0;\n}", "target": 1}
{"code": "UpdatePinhole(struct upnphttp * h, const char * action, const char * ns)\n{\n#if 0\n\tstatic const char resp[] =\n\t\t\"<u:UpdatePinholeResponse \"\n\t\t\"xmlns:u=\\\"urn:schemas-upnp-org:service:WANIPv6FirewallControl:1\\\">\"\n\t\t\"</u:UpdatePinholeResponse>\";\n#endif\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * uid_str, * leaseTime;\n\tchar iaddr[INET6_ADDRSTRLEN];\n\tunsigned short iport;\n\tint ltime;\n\tint uid;\n\tint n;\n\tif(CheckStatus(h)==0)\n\t\treturn;\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tuid_str = GetValueFromNameValueList(&data, \"UniqueID\");\n\tleaseTime = GetValueFromNameValueList(&data, \"NewLeaseTime\");\n\tuid = uid_str ? atoi(uid_str) : -1;\n\tltime = leaseTime ? atoi(leaseTime) : -1;\n\tClearNameValueList(&data);\n\tif(uid < 0 || uid > 65535 || ltime <= 0 || ltime > 86400)\n\t{\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\tn = upnp_get_pinhole_info(uid, NULL, 0, NULL,\n\t                          iaddr, sizeof(iaddr), &iport,\n\t                          NULL, \n\t                          NULL, 0, \n\t                          NULL, NULL);\n\tif (n >= 0)\n\t{\n\t\tif(PinholeVerification(h, iaddr, iport) <= 0)\n\t\t\treturn;\n\t}\n\telse if(n == -2)\n\t{\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tSoapError(h, 501, \"ActionFailed\");\n\t\treturn;\n\t}\n\tsyslog(LOG_INFO, \"%s: (inbound) updating lease duration to %d for pinhole with ID: %d\",\n\t       action, ltime, uid);\n\tn = upnp_update_inboundpinhole(uid, ltime);\n\tif(n == -1)\n\t\tSoapError(h, 704, \"NoSuchEntry\");\n\telse if(n < 0)\n\t\tSoapError(h, 501, \"ActionFailed\");\n\telse {\n\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t                   action, ns, action);\n\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t}\n}", "target": 0}
{"code": "bool VerifySparsity(const RuntimeShape& weights_shape,\n                    const RuntimeShape& input_shape,\n                    const RuntimeShape& output_shape,\n                    const TfLiteSparsity* sparsity) {\n  const int weights_dims_count = weights_shape.DimensionsCount();\n  const int output_dims_count = output_shape.DimensionsCount();\n  const int w0_size = sparsity->dim_metadata[0].dense_size;\n  const int accum_depth = weights_shape.Dims(weights_dims_count - 1);\n  const int output_elements = output_shape.FlatSize();\n  const int input_elements = input_shape.FlatSize();\n  const int batches = FlatSizeSkipDim(output_shape, output_dims_count - 1);\n  const int output_depth = MatchingDim(weights_shape, weights_dims_count - 2,\n                                       output_shape, output_dims_count - 1);\n  const int max_batch_index = batches - 1;\n  const int max_output = max_batch_index * output_depth + w0_size;\n  const int max_batch_depth = accum_depth * max_batch_index;\n  if (output_elements < max_output) return false;\n  for (int i = 0; i < sparsity->dim_metadata[1].array_indices->size; ++i) {\n    if (input_elements <=\n        max_batch_depth + sparsity->dim_metadata[1].array_indices->data[i])\n      return false;\n  }\n  return true;\n}", "target": 0}
{"code": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n  if (decNumberIsInfinite(pdec)) {\n    return NULL;\n  }\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n    plit->literal_data = jv_mem_alloc(len);\n    decNumberToString(pdec, plit->literal_data);\n  }\n  return plit->literal_data;\n}", "target": 1}
{"code": "int main_configure(char *arg1, char *arg2) {\n    int cmdline_status;\n    cmdline_status=options_cmdline(arg1, arg2);\n    if(cmdline_status) \n        return cmdline_status;\n    options_apply();\n    str_canary_init(); \n    log_open(SINK_SYSLOG);\n    if(bind_ports())\n        return 1;\n#ifdef HAVE_CHROOT\n    if(change_root())\n        return 1;\n#endif \n    if(drop_privileges(1))\n        return 1;\n    if(log_open(SINK_OUTFILE))\n        return 1;\n#ifndef USE_FORK\n    num_clients=0; \n#endif\n    log_flush(LOG_MODE_CONFIGURED);\n    return 0;\n}", "target": 1}
{"code": "static void unbound_resolver_callback(void *data, int err, struct ub_result *ub_result)\n{\n\tstruct ast_dns_query *query = data;\n\tif (!ub_result) {\n\t\tast_debug(3, \"Badly formatted DNS query '%s'\\n\", ast_dns_query_get_name(query));\n\t\tast_dns_resolver_set_result(query, 0, 0, ns_r_formerr, ast_dns_query_get_name(query), \"\", 0);\n\t\tast_dns_resolver_completed(query);\n\t\tao2_ref(query, -1);\n\t\treturn;\n\t}\n\tif (!ast_dns_resolver_set_result(query, ub_result->secure, ub_result->bogus, ub_result->rcode,\n\t\tS_OR(ub_result->canonname, ast_dns_query_get_name(query)), ub_result->answer_packet, ub_result->answer_len)) {\n\t\tint i;\n\t\tchar *result_data;\n\t\tfor (i = 0; (result_data = ub_result->data[i]); i++) {\n\t\t\tif (ast_dns_resolver_add_record(query, ub_result->qtype, ub_result->qclass, ub_result->ttl,\n\t\t\t\tresult_data, ub_result->len[i])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tast_dns_resolver_completed(query);\n\tao2_ref(query, -1);\n\tub_resolve_free(ub_result);\n}", "target": 0}
{"code": "MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    size_t needle_length = strlen(needle);\n    if (needle_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", needle_length);\n        return MOBI_PARAM_ERR;\n    }\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    unsigned char tag_open;\n    unsigned char tag_close;\n    if (type == T_CSS) {\n        tag_open = '{';\n        tag_close = '}';\n    } else {\n        tag_open = '<';\n        tag_close = '>';\n    }\n    unsigned char last_border = tag_close;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {\n            if (last_border != tag_open) {\n                data += needle_length;\n                continue;\n            }\n            while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {\n                data--;\n            }\n            result->is_url = (*data == '(');\n            result->start = ++data;\n            int i = 0;\n            while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {\n                result->value[i++] = (char) *data++;\n            }\n            if (*(data - 1) == '/' && *data == '>') {\n                --data; --i;\n            }\n            result->end = data;\n            result->value[i] = '\\0';\n            return MOBI_SUCCESS;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "\t\tstatic auto HasProxy(Local<Object> object) -> bool {\n\t\t\tif (object->IsProxy()) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tauto proto = object->GetPrototype();\n\t\t\t\tif (proto->IsNullOrUndefined()) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn HasProxy(proto.As<Object>());\n\t\t\t\t}\n\t\t\t}\n\t\t}", "target": 0}
{"code": "juniper_monitor_print(netdissect_options *ndo,\n                      const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_monitor_header {\n            uint8_t pkt_type;\n            uint8_t padding;\n            uint8_t iif[2];\n            uint8_t service_id[4];\n        };\n        const struct juniper_monitor_header *mh;\n        l2info.pictype = DLT_JUNIPER_MONITOR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        mh = (const struct juniper_monitor_header *)p;\n        ND_TCHECK(*mh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u, iif %u, pkt-type %u: \",\n                   EXTRACT_32BITS(&mh->service_id),\n                   EXTRACT_16BITS(&mh->iif),\n                   mh->pkt_type));\n        ip_heuristic_guess (ndo, p, l2info.length);\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "Status ShapeRefiner::InferShapesForFunctionSubNode(\n    const Node* node, InferenceContext* outer_context) {\n  TF_RETURN_IF_ERROR(AddNodeInternal(node, outer_context));\n  InferenceContext* node_context = CHECK_NOTNULL(GetContext(node));\n  if (StringPiece(node->type_string()) == kArgOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_inputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid input index: \", index,\n          \" not in [0, \", outer_context->num_inputs(), \").\");\n    }\n    if (outer_context->input(index).SameHandle(ShapeHandle())) {\n      VLOG(1) << \"Function instantiation has undefined input shape at \"\n              << \"index: \" << index << \" in the outer inference context.\";\n      node_context->set_output(0, node_context->UnknownShape());\n    } else {\n      node_context->set_output(0, outer_context->input(index));\n    }\n    auto* resource = outer_context->input_handle_shapes_and_types(index);\n    if (resource) {\n      node_context->set_output_handle_shapes_and_types(0, *resource);\n    }\n  } else if (StringPiece(node->type_string()) == kRetvalOp) {\n    int index;\n    TF_RETURN_IF_ERROR(GetNodeAttr(AttrSlice(node->def()), \"index\", &index));\n    if (index < 0 || outer_context->num_outputs() <= index) {\n      return errors::Internal(\n          \"Function instantiation included invalid output index: \", index,\n          \" not in [0, \", outer_context->num_outputs(), \").\");\n    }\n    ShapeHandle handle;\n    TensorShapeProto proto;\n    node_context->ShapeHandleToProto(node_context->input(0), &proto);\n    TF_RETURN_IF_ERROR(outer_context->MakeShapeFromShapeProto(proto, &handle));\n    outer_context->set_output(index, handle);\n    auto* resource = node_context->input_handle_shapes_and_types(0);\n    if (resource) {\n      outer_context->set_output_handle_shapes_and_types(index, *resource);\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}", "target": 1}
{"code": "QString KNSResource::longDescription()\n{\n    QString ret = m_entry.summary();\n    if (m_entry.shortSummary().isEmpty()) {\n        const int newLine = ret.indexOf(QLatin1Char('\\n'));\n        if (newLine<0)\n            ret.clear();\n        else\n            ret = ret.mid(newLine+1).trimmed();\n    }\n    ret.remove(QLatin1Char('\\r'));\n    ret.replace(QStringLiteral(\"[li]\"), QStringLiteral(\"\\n* \"));\n    ret.remove(QRegularExpression(QStringLiteral(\"\\\\[\\\\/?[a-z]*\\\\]\")));\n    static const QRegularExpression urlRegExp(QStringLiteral(\"(^|\\\\s)([-a-zA-Z0-9@:%_\\\\+.~#?&\n    ret.replace(urlRegExp, QStringLiteral(\"<a href=\\\"\\\\2\\\">\\\\2</a>\"));\n    return ret;\n}", "target": 1}
{"code": "void PluginInfoMessageFilter::OnGetPluginInfo(\n    int render_view_id,\n    const GURL& url,\n    const GURL& top_origin_url,\n    const std::string& mime_type,\n    IPC::Message* reply_msg) {\n  GetPluginInfo_Params params = {\n    render_view_id,\n    url,\n    top_origin_url,\n    mime_type\n  };\n  PluginService::GetInstance()->GetPlugins(\n      base::Bind(&PluginInfoMessageFilter::PluginsLoaded,\n                 weak_ptr_factory_.GetWeakPtr(),\n                 params, reply_msg));\n}", "target": 0}
{"code": "static inline const void *choose_neigh_daddr(struct rt6_info *rt,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     const void *daddr)\n{\n\tstruct in6_addr *p = &rt->rt6i_gateway;\n\tif (!ipv6_addr_any(p))\n\t\treturn (const void *) p;\n\telse if (skb)\n\t\treturn &ipv6_hdr(skb)->daddr;\n\treturn daddr;\n}", "target": 0}
{"code": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\treturn do_dentry_open(file, inode, NULL, cred);\n}", "target": 1}
{"code": "GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n{\n    size_t size, len;\n    BOOL ret = FALSE;\n    WCHAR *data = NULL;\n    DWORD bytes, read;\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n        ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n    }\n    size = bytes / sizeof(*data);\n    if (size == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    data = malloc(bytes);\n    if (data == NULL)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n        ReturnLastError(pipe, L\"malloc\");\n        goto out;\n    }\n    read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n    if (bytes != read)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n        ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n    }\n    if (data[size - 1] != 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->std_input = sud->options + len;\n    data = NULL; \n    ret = TRUE;\nout:\n    free(data);\n    return ret;\n}", "target": 1}
{"code": "static intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}", "target": 1}
{"code": "static __always_inline int slab_trylock(struct page *page)\n{\n\tint rc = 1;\n\trc = bit_spin_trylock(PG_locked, &page->flags);\n\treturn rc;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input->type);\n  TF_LITE_ENSURE_EQ(context, output->bytes, input->bytes);\n  TF_LITE_ENSURE_EQ(context, output->dims->size, input->dims->size);\n  for (int i = 0; i < output->dims->size; ++i) {\n    TF_LITE_ENSURE_EQ(context, output->dims->data[i], input->dims->data[i]);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "ext4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictFusedBatchNormGrad(\n    const OpContext& op_context, NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(1).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  const auto rsqrt_cost = Eigen::internal::functor_traits<\n      Eigen::internal::scalar_rsqrt_op<float>>::Cost;\n  ops = dims.iz * (dims.batch * dims.ix * dims.iy * 11 + 5 + rsqrt_cost);\n  node_costs->num_compute_ops = ops;\n  const int64_t size_nhwc =\n      CalculateTensorSize(op_info.inputs(1), &found_unknown_shapes);\n  const int64_t size_c =\n      CalculateTensorSize(op_info.inputs(2), &found_unknown_shapes);\n  node_costs->num_input_bytes_accessed = {size_nhwc, size_nhwc, size_c, size_c};\n  node_costs->num_output_bytes_accessed = {size_nhwc, size_c, size_c};\n  node_costs->internal_read_bytes = size_nhwc;\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "xfs_attr3_leaf_clearflag(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n#ifdef DEBUG\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\txfs_attr_leaf_name_local_t *name_loc;\n\tint namelen;\n\tchar *name;\n#endif \n\ttrace_xfs_attr_leaf_clearflag(args);\n\terror = xfs_attr3_leaf_read(args->trans, args->dp, args->blkno, -1, &bp);\n\tif (error)\n\t\treturn(error);\n\tleaf = bp->b_addr;\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tASSERT(entry->flags & XFS_ATTR_INCOMPLETE);\n#ifdef DEBUG\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(args->index < ichdr.count);\n\tASSERT(args->index >= 0);\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tnamelen = name_loc->namelen;\n\t\tname = (char *)name_loc->nameval;\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tnamelen = name_rmt->namelen;\n\t\tname = (char *)name_rmt->name;\n\t}\n\tASSERT(be32_to_cpu(entry->hashval) == args->hashval);\n\tASSERT(namelen == args->namelen);\n\tASSERT(memcmp(name, args->name, namelen) == 0);\n#endif \n\tentry->flags &= ~XFS_ATTR_INCOMPLETE;\n\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, entry, sizeof(*entry)));\n\tif (args->rmtblkno) {\n\t\tASSERT((entry->flags & XFS_ATTR_LOCAL) == 0);\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tname_rmt->valueblk = cpu_to_be32(args->rmtblkno);\n\t\tname_rmt->valuelen = cpu_to_be32(args->valuelen);\n\t\txfs_trans_log_buf(args->trans, bp,\n\t\t\t XFS_DA_LOGRANGE(leaf, name_rmt, sizeof(*name_rmt)));\n\t}\n\treturn xfs_trans_roll(&args->trans, args->dp);\n}", "target": 0}
{"code": "void MainWindow::on_actionUpgrade_triggered()\n{\n    if (Settings.askUpgradeAutmatic()) {\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"Do you want to automatically check for updates in the future?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"http:\n}", "target": 1}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_INFLIGHT_FD:\n\t\tvring_idx = ctx->msg.payload.inflight.num_queues - 1;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 0}
{"code": "bool dir_is_in_dump_location(const char *dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0)\n    {\n        log_debug(\"Bad parent directory: '%s' not in '%s'\", g_settings_dump_location, dir_name);\n        return false;\n    }\n    const char *base_name = dir_name + len;\n    while (*base_name && *base_name == '/')\n        ++base_name;\n    if (*(base_name - 1) != '/' || !str_is_correct_filename(base_name))\n    {\n        log_debug(\"Invalid dump directory name: '%s'\", base_name);\n        return false;\n    }\n    struct stat sb;\n    if (lstat(dir_name, &sb) < 0)\n    {\n        VERB2 perror_msg(\"stat('%s')\", dir_name);\n        return errno== ENOENT;\n    }\n    return S_ISDIR(sb.st_mode);\n}", "target": 0}
{"code": "void SetBackgroundColor(int par)\n{\n    if ( par == STROKING ) { outpos += sprintf(outpos,\" 0 0 0 0 K\"); }\n    else                   { outpos += sprintf(outpos,\" 0 0 0 0 k\"); }\n}", "target": 1}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "HMAC_SHA256_Update(struct HMAC_SHA256_CTX * ctx, const void *in, size_t len)\n{\n  scrypt_SHA256_Update(&ctx->ictx, in, len);\n}", "target": 1}
{"code": "MagickExport MagickBooleanType FileToImage(Image *image,const char *filename,\n  ExceptionInfo *exception)\n{\n  int\n    file;\n  MagickBooleanType\n    status;\n  size_t\n    length,\n    quantum;\n  ssize_t\n    count;\n  struct stat\n    file_stats;\n  unsigned char\n    *blob;\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  status=IsRightsAuthorized(PathPolicyDomain,WritePolicyRights,filename);\n  if (status == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  file=fileno(stdin);\n  if (LocaleCompare(filename,\"-\") != 0)\n    file=open_utf8(filename,O_RDONLY | O_BINARY,0);\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  blob=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*blob));\n  if (blob == (unsigned char *) NULL)\n    {\n      file=close(file);\n      ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n        filename);\n      return(MagickFalse);\n    }\n  for ( ; ; )\n  {\n    count=read(file,blob,quantum);\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n    length=(size_t) count;\n    count=WriteBlobStream(image,length,blob);\n    if (count != (ssize_t) length)\n      {\n        ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n        break;\n      }\n  }\n  file=close(file);\n  if (file == -1)\n    ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  return(MagickTrue);\n}", "target": 0}
{"code": "static long kvm_dev_ioctl(struct file *filp,\n\t\t\t  unsigned int ioctl, unsigned long arg)\n{\n\tlong r = -EINVAL;\n\tswitch (ioctl) {\n\tcase KVM_GET_API_VERSION:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = KVM_API_VERSION;\n\t\tbreak;\n\tcase KVM_CREATE_VM:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = kvm_dev_ioctl_create_vm();\n\t\tbreak;\n\tcase KVM_CHECK_EXTENSION:\n\t\tr = kvm_dev_ioctl_check_extension_generic(arg);\n\t\tbreak;\n\tcase KVM_GET_VCPU_MMAP_SIZE:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = PAGE_SIZE;     \n#ifdef CONFIG_X86\n\t\tr += PAGE_SIZE;    \n#endif\n#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET\n\t\tr += PAGE_SIZE;    \n#endif\n\t\tbreak;\n\tcase KVM_TRACE_ENABLE:\n\tcase KVM_TRACE_PAUSE:\n\tcase KVM_TRACE_DISABLE:\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_arch_dev_ioctl(filp, ioctl, arg);\n\t}\nout:\n\treturn r;\n}", "target": 0}
{"code": "static void iriap_getvaluebyclass_indication(struct iriap_cb *self,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ias_object *obj;\n\tstruct ias_attrib *attrib;\n\tint name_len;\n\tint attr_len;\n\tchar name[IAS_MAX_CLASSNAME + 1];\t\n\tchar attr[IAS_MAX_ATTRIBNAME + 1];\t\n\t__u8 *fp;\n\tint n;\n\tIRDA_DEBUG(4, \"%s()\\n\", __func__);\n\tIRDA_ASSERT(self != NULL, return;);\n\tIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\n\tIRDA_ASSERT(skb != NULL, return;);\n\tfp = skb->data;\n\tn = 1;\n\tname_len = fp[n++];\n\tIRDA_ASSERT(name_len < IAS_MAX_CLASSNAME + 1, return;);\n\tmemcpy(name, fp+n, name_len); n+=name_len;\n\tname[name_len] = '\\0';\n\tattr_len = fp[n++];\n\tIRDA_ASSERT(attr_len < IAS_MAX_ATTRIBNAME + 1, return;);\n\tmemcpy(attr, fp+n, attr_len); n+=attr_len;\n\tattr[attr_len] = '\\0';\n\tIRDA_DEBUG(4, \"LM-IAS: Looking up %s: %s\\n\", name, attr);\n\tobj = irias_find_object(name);\n\tif (obj == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Object %s not found\\n\", name);\n\t\tiriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tIRDA_DEBUG(4, \"LM-IAS: found %s, id=%d\\n\", obj->name, obj->id);\n\tattrib = irias_find_attrib(obj, attr);\n\tif (attrib == NULL) {\n\t\tIRDA_DEBUG(2, \"LM-IAS: Attribute %s not found\\n\", attr);\n\t\tiriap_getvaluebyclass_response(self, obj->id,\n\t\t\t\t\t       IAS_ATTRIB_UNKNOWN,\n\t\t\t\t\t       &irias_missing);\n\t\treturn;\n\t}\n\tiriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\n\t\t\t\t       attrib->value);\n}", "target": 0}
{"code": "bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)\n{\n    barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;\n    try {\n        auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);\n        fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,\n                                                             barrier::FingerprintType::SHA1);\n        fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,\n                                                               barrier::FingerprintType::SHA256);\n    } catch (const std::exception& e) {\n        LOG((CLOG_ERR \"%s\", e.what()));\n        return false;\n    }\n    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\",\n         barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n         barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n    LOG((CLOG_NOTE \"fingerprint_db_path: %s\", fingerprint_db_path.u8string().c_str()));\n    barrier::FingerprintDatabase db;\n    db.read(fingerprint_db_path);\n    if (!db.fingerprints().empty()) {\n        LOG((CLOG_NOTE \"Read %d fingerprints from: %s\", db.fingerprints().size(),\n             fingerprint_db_path.u8string().c_str()));\n    } else {\n        LOG((CLOG_NOTE \"Could not read fingerprints from: %s\",\n             fingerprint_db_path.u8string().c_str()));\n    }\n    if (db.is_trusted(fingerprint_sha256)) {\n        LOG((CLOG_NOTE \"Fingerprint matches trusted fingerprint\"));\n        return true;\n    } else {\n        LOG((CLOG_NOTE \"Fingerprint does not match trusted fingerprint\"));\n        return false;\n    }\n}", "target": 1}
{"code": "inline TfLiteStatus GetMutableInputSafe(const TfLiteContext* context,\n                                        const TfLiteNode* node, int index,\n                                        const TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->inputs->size,\n                                          node->inputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EAGAIN;\n\ttrace_f2fs_readpage(page, DATA);\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);\n\treturn ret;\n}", "target": 1}
{"code": "static unsigned long get_ctl_id_hash(const struct snd_ctl_elem_id *id)\n{\n\tint i;\n\tunsigned long h;\n\th = id->iface;\n\th = MULTIPLIER * h + id->device;\n\th = MULTIPLIER * h + id->subdevice;\n\tfor (i = 0; i < SNDRV_CTL_ELEM_ID_NAME_MAXLEN && id->name[i]; i++)\n\t\th = MULTIPLIER * h + id->name[i];\n\th = MULTIPLIER * h + id->index;\n\th &= LONG_MAX;\n\treturn h;\n}", "target": 0}
{"code": "static ssize_t ucma_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct ucma_file *file = filp->private_data;\n\tstruct rdma_ucm_cmd_hdr hdr;\n\tssize_t ret;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tif (!ucma_cmd_table[hdr.cmd])\n\t\treturn -ENOSYS;\n\tret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\n\tif (!ret)\n\t\tret = len;\n\treturn ret;\n}", "target": 0}
{"code": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_stimer_to_vcpu(stimer);\n\tstruct kvm_vcpu_hv_synic *synic = to_hv_synic(vcpu);\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_stimer_set_count(hv_stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\treturn 0;\n}", "target": 1}
{"code": "static bool find_andx_cmd_ofs(uint8_t *buf, size_t *pofs)\n{\n\tuint8_t cmd;\n\tsize_t ofs;\n\tcmd = CVAL(buf, smb_com);\n\tSMB_ASSERT(is_andx_req(cmd));\n\tofs = smb_vwv0;\n\twhile (CVAL(buf, ofs) != 0xff) {\n\t\tif (!is_andx_req(CVAL(buf, ofs))) {\n\t\t\treturn false;\n\t\t}\n\t\tofs = SVAL(buf, ofs+2) + 4 + 1;\n\t\tSMB_ASSERT(ofs+4 < talloc_get_size(buf));\n\t}\n\t*pofs = ofs;\n\treturn true;\n}", "target": 0}
{"code": "TfLiteStatus GatherNd(const TfLiteTensor* params, const TfLiteTensor* indices,\n                      TfLiteTensor* output) {\n  reference_ops::GatherNd(\n      GetTensorShape(params), GetTensorData<ParamsT>(params),\n      GetTensorShape(indices), GetTensorData<IndicesT>(indices),\n      GetTensorShape(output), GetTensorData<ParamsT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "void VariableUnserializer::unserializeProp(ObjectData* obj,\n                                           const String& key,\n                                           Class* ctx,\n                                           const String& realKey,\n                                           int nProp) {\n  auto const cls = obj->getVMClass();\n  auto const lookup = cls->getDeclPropSlot(ctx, key.get());\n  auto const slot = lookup.slot;\n  tv_lval t;\n  if (slot == kInvalidSlot || !lookup.accessible) {\n    obj->reserveDynProps(nProp);\n    t = obj->makeDynProp(realKey.get());\n  } else {\n    t = obj->getPropLval(ctx, key.get());\n  }\n  unserializePropertyValue(t, nProp);\n  if (!RuntimeOption::RepoAuthoritative) return;\n  if (!Repo::get().global().HardPrivatePropInference) return;\n  if (UNLIKELY(slot == kInvalidSlot)) return;\n  auto const repoTy = cls->declPropRepoAuthType(slot);\n  if (LIKELY(tvMatchesRepoAuthType(*t, repoTy))) return;\n  if (t.type() == KindOfUninit &&\n      (cls->declProperties()[slot].attrs & AttrLateInit)) {\n    return;\n  }\n  throwUnexpectedType(key, obj, *t);\n}", "target": 0}
{"code": "void grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device)\n\t\t\tfree (gf->file->device->disk);\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}", "target": 1}
{"code": "bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "static void test_show_object(struct object *object,\n\t\t\t     struct strbuf *path,\n\t\t\t     const char *last, void *data)\n{\n\tstruct bitmap_test_data *tdata = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0)\n\t\tdie(\"Object not in bitmap: %s\\n\", oid_to_hex(&object->oid));\n\tbitmap_set(tdata->base, bitmap_pos);\n\tdisplay_progress(tdata->prg, ++tdata->seen);\n}", "target": 1}
{"code": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:\n\tcase SPECTRE_V2_USER_SECCOMP:\n\t\tif (static_key_enabled(&switch_to_cond_stibp))\n\t\t\treturn \", STIBP: conditional\";\n\t}\n\treturn \"\";\n}", "target": 1}
{"code": "static void read_buf(FILE *fin, char *buf) {\n  if (!fgets(buf, BUFFER_SIZE, fin)) {\n    buf[0] = '\\0';\n    return;\n  }\n  buf[strlen(buf) - 1] = '\\0';\n}", "target": 1}
{"code": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    OP_REQUIRES(context, grad_in.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected grad shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", grad_in.shape()));\n    OP_REQUIRES(context, argmax.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected argmax shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", argmax.shape()));\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    if (out_shape.num_elements() == 0) return;  \n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "GF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static char *mongo_data_append( char *start , const void *data , int len ) {\n    memcpy( start , data , len );\n    return start + len;\n}", "target": 1}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tgpointer         data)\n{\n\tdouble *scale = data;\n\tint w = (width  * (*scale) + 0.5);\n\tint h = (height * (*scale) + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 1}
{"code": "static void coroutine_fn virtfs_reset(V9fsPDU *pdu)\n{\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp = NULL;\n    while (s->fid_list) {\n        fidp = s->fid_list;\n        s->fid_list = fidp->next;\n        if (fidp->ref) {\n            fidp->clunked = 1;\n        } else {\n            free_fid(pdu, fidp);\n        }\n    }\n    if (fidp) {\n        error_report(\"9pfs:%s: One or more uncluncked fids \"\n                     \"found during reset\", __func__);\n    }\n}", "target": 0}
{"code": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}", "target": 1}
{"code": "int unlinkat_harder(int dfd, const char *filename, int unlink_flags, RemoveFlags remove_flags) {\n        mode_t old_mode;\n        int r;\n        if (unlinkat(dfd, filename, unlink_flags) >= 0)\n                return 0;\n        if (errno != EACCES || !FLAGS_SET(remove_flags, REMOVE_CHMOD))\n                return -errno;\n        r = patch_dirfd_mode(dfd, &old_mode);\n        if (r < 0)\n                return r;\n        if (unlinkat(dfd, filename, unlink_flags) < 0) {\n                r = -errno;\n                (void) fchmod(dfd, old_mode);\n                return r;\n        }\n        if (FLAGS_SET(remove_flags, REMOVE_CHMOD_RESTORE) && fchmod(dfd, old_mode) < 0)\n                return -errno;\n        return 0;\n}", "target": 1}
{"code": "QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n    if (!cipher.ok())\n        return cipherText;\n    if (direction)\n        temp2 = byteToB64(temp2);\n    return temp2;\n}", "target": 1}
{"code": "static int vidioc_querycap(struct file *file, void *priv,\n\t\t\t   struct v4l2_capability *cap)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_getdevice(file);\n\tint labellen = (sizeof(cap->card) < sizeof(dev->card_label)) ?\n\t\t\t       sizeof(cap->card) :\n\t\t\t\t     sizeof(dev->card_label);\n\tint device_nr =\n\t\t((struct v4l2loopback_private *)video_get_drvdata(dev->vdev))\n\t\t\t->device_nr;\n\t__u32 capabilities = V4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\n\tstrlcpy(cap->driver, \"v4l2 loopback\", sizeof(cap->driver));\n\tsnprintf(cap->card, labellen, dev->card_label);\n\tsnprintf(cap->bus_info, sizeof(cap->bus_info),\n\t\t \"platform:v4l2loopback-%03d\", device_nr);\n#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 1, 0)\n\tcap->version = V4L2LOOPBACK_VERSION_CODE;\n#endif\n#ifdef V4L2_CAP_VIDEO_M2M\n\tcapabilities |= V4L2_CAP_VIDEO_M2M;\n#endif \n\tif (dev->announce_all_caps) {\n\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_VIDEO_OUTPUT;\n\t} else {\n\t\tif (dev->ready_for_capture) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_CAPTURE;\n\t\t}\n\t\tif (dev->ready_for_output) {\n\t\t\tcapabilities |= V4L2_CAP_VIDEO_OUTPUT;\n\t\t}\n\t}\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)\n\tdev->vdev->device_caps =\n#endif \n\t\tcap->device_caps = cap->capabilities = capabilities;\n#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)\n\tcap->capabilities |= V4L2_CAP_DEVICE_CAPS;\n#endif\n\tmemset(cap->reserved, 0, sizeof(cap->reserved));\n\treturn 0;\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, Cookie> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "void kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,\n\t\t\t\t\t   unsigned long address)\n{\n\tif (address == gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT))\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);\n}", "target": 0}
{"code": "static int rm_rf_inner_child(\n                int fd,\n                const char *fname,\n                int is_dir,\n                RemoveFlags flags,\n                const struct stat *root_dev,\n                bool allow_recursion) {\n        struct stat st;\n        int r, q = 0;\n        assert(fd >= 0);\n        assert(fname);\n        if (is_dir < 0 ||\n            root_dev ||\n            (is_dir > 0 && (root_dev || (flags & REMOVE_SUBVOLUME)))) {\n                r = fstatat_harder(fd, fname, &st, AT_SYMLINK_NOFOLLOW, flags);\n                if (r < 0)\n                        return r;\n                is_dir = S_ISDIR(st.st_mode);\n        }\n        if (is_dir) {\n                if (root_dev && st.st_dev != root_dev->st_dev)\n                        return 0;\n                r = fd_is_mount_point(fd, fname, 0);\n                if (r < 0)\n                        return r;\n                if (r > 0)\n                        return 0;\n                if ((flags & REMOVE_SUBVOLUME) && btrfs_might_be_subvol(&st)) {\n                        r = btrfs_subvol_remove_fd(fd, fname, BTRFS_REMOVE_RECURSIVE|BTRFS_REMOVE_QUOTA);\n                        if (r < 0) {\n                                if (!IN_SET(r, -ENOTTY, -EINVAL))\n                                        return r;\n                        } else\n                                return 1;\n                }\n                if (!allow_recursion)\n                        return -EISDIR;\n                int subdir_fd = openat(fd, fname, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC|O_NOFOLLOW|O_NOATIME);\n                if (subdir_fd < 0)\n                        return -errno;\n                q = rm_rf_children(subdir_fd, flags | REMOVE_PHYSICAL, root_dev);\n        } else if (flags & REMOVE_ONLY_DIRECTORIES)\n                return 0;\n        r = unlinkat_harder(fd, fname, is_dir ? AT_REMOVEDIR : 0, flags);\n        if (r < 0)\n                return r;\n        if (q < 0)\n                return q;\n        return 1;\n}", "target": 0}
{"code": "const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}", "target": 1}
{"code": "arista_print_date_hms_time(netdissect_options *ndo, uint32_t seconds,\n\t\tuint32_t nanoseconds)\n{\n\ttime_t ts;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tts = seconds + (nanoseconds / 1000000000);\n\tnanoseconds %= 1000000000;\n\tif (NULL == (tm = gmtime(&ts)))\n\t\tND_PRINT(\"gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\"strftime() error\");\n\telse\n\t\tND_PRINT(\"%s.%09u\", buf, nanoseconds);\n}", "target": 1}
{"code": "void preproc_mount_mnt_dir(void) {\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n#ifdef HAVE_SECCOMP\n\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); \n\t\telse {\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); \n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); \n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); \n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); \n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}", "target": 0}
{"code": "static inline void tcp_parse_option_mss(struct pico_socket_tcp *t, uint8_t len, uint8_t *opt, uint32_t *idx)\n{\n    uint16_t mss;\n    if (tcpopt_len_check(idx, len, PICO_TCPOPTLEN_MSS) < 0)\n        return;\n    if ((*idx + PICO_TCPOPTLEN_MSS) > len)\n        return;\n    t->mss_ok = 1;\n    mss = short_from(opt + *idx);\n    *idx += (uint32_t)sizeof(uint16_t);\n    if (t->mss > short_be(mss))\n        t->mss = short_be(mss);\n}", "target": 0}
{"code": "print_al(const gs_memory_t *mem, const char *label, const active_line * alp)\n{\n    if (gs_debug_c('F'))\n        print_active_line(mem, label, alp);\n}", "target": 0}
{"code": "containsNonAlphaNumDash(const LString &s) {\n\tconst LString::Part *part = s.start;\n\twhile (part != NULL) {\n\t\tfor (unsigned int i = 0; i < part->size; i++) {\n\t\t\tconst char start = part->data[i];\n\t\t\tif (start != '-' && !isAlphaNum(start)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tpart = part->next;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "\t\tauto GetTargetAndAlsoCheckForProxy() -> Local<Object> {\n\t\t\tauto object = Local<Object>::Cast(Deref(target));\n\t\t\tif (HasProxy(object)) {\n\t\t\t\tthrow RuntimeTypeError(\"Object is or has proxy\");\n\t\t\t}\n\t\t\treturn object;\n\t\t}", "target": 0}
{"code": "static void ndpi_reset_packet_line_info(struct ndpi_packet_struct *packet) {\n  packet->parsed_lines = 0, packet->empty_line_position_set = 0, packet->host_line.ptr = NULL,\n    packet->host_line.len = 0, packet->referer_line.ptr = NULL, packet->referer_line.len = 0,\n    packet->content_line.ptr = NULL, packet->content_line.len = 0, packet->accept_line.ptr = NULL,\n    packet->accept_line.len = 0, packet->user_agent_line.ptr = NULL, packet->user_agent_line.len = 0,\n    packet->http_url_name.ptr = NULL, packet->http_url_name.len = 0, packet->http_encoding.ptr = NULL,\n    packet->http_encoding.len = 0, packet->http_transfer_encoding.ptr = NULL, packet->http_transfer_encoding.len = 0,\n    packet->http_contentlen.ptr = NULL, packet->http_contentlen.len = 0, packet->http_cookie.ptr = NULL,\n    packet->http_cookie.len = 0, packet->http_origin.len = 0, packet->http_origin.ptr = NULL,\n    packet->http_x_session_type.ptr = NULL, packet->http_x_session_type.len = 0, packet->server_line.ptr = NULL,\n    packet->server_line.len = 0, packet->http_method.ptr = NULL, packet->http_method.len = 0,\n    packet->http_response.ptr = NULL, packet->http_response.len = 0, packet->http_num_headers = 0;\n}", "target": 1}
{"code": "prepare_singleton_class(mrb_state *mrb, struct RBasic *o)\n{\n  struct RClass *sc, *c;\n  mrb_assert(o->c);\n  if (o->c->tt == MRB_TT_SCLASS) return;\n  sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class);\n  sc->flags |= MRB_FL_CLASS_IS_INHERITED;\n  sc->mt = mt_new(mrb);\n  sc->iv = 0;\n  if (o->tt == MRB_TT_CLASS) {\n    c = (struct RClass*)o;\n    if (!c->super) {\n      sc->super = mrb->class_class;\n    }\n    else {\n      sc->super = c->super->c;\n    }\n  }\n  else if (o->tt == MRB_TT_SCLASS) {\n    c = (struct RClass*)o;\n    while (c->super->tt == MRB_TT_ICLASS)\n      c = c->super;\n    make_metaclass(mrb, c->super);\n    sc->super = c->super->c;\n  }\n  else {\n    sc->super = o->c;\n    prepare_singleton_class(mrb, (struct RBasic*)sc);\n  }\n  o->c = sc;\n  mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc);\n  mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o);\n  mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o));\n  sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN;\n}", "target": 0}
{"code": "GF_Err load_svg_run(GF_SceneLoader *load)\n{\n\tu32 in_time;\n\tGF_Err e;\n\tGF_SVG_Parser *parser = (GF_SVG_Parser *)load->loader_priv;\n\tif (!parser) {\n\t\te = gf_sm_load_initialize_svg(load, NULL, GF_FALSE);\n\t\tif (e) return e;\n\t\tparser = (GF_SVG_Parser *)load->loader_priv;\n\t}\n\tin_time = gf_sys_clock();\n\te = gf_xml_sax_parse_file(parser->sax_parser, (const char *)load->fileName, svg_progress);\n\tif (parser->last_error<0) e = parser->last_error;\n\tif (e<0) return svg_report(parser, e, \"Unable to parse file %s: %s\", load->fileName, gf_xml_sax_get_error(parser->sax_parser) );\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[Parser] Scene parsed and Scene Graph built in %d ms\\n\", gf_sys_clock() - in_time));\n\tsvg_flush_animations(parser);\n\tgf_sm_svg_flush_state(parser);\n\treturn e;\n}", "target": 1}
{"code": "static void m_stop(struct seq_file *m, void *v)\n{\n\tstruct proc_maps_private *priv = m->private;\n\tstruct vm_area_struct *vma = v;\n\tvma_stop(priv, vma);\n\tif (priv->task)\n\t\tput_task_struct(priv->task);\n}", "target": 1}
{"code": "void nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 0);\n}", "target": 1}
{"code": "static UINT serial_process_irp_write(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tDWORD nbWritten = 0;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length); \n\tStream_Read_UINT64(irp->input, Offset); \n\tStream_Seek(irp->input, 20);            \n\tWLog_Print(serial->log, WLOG_DEBUG, \"writing %\" PRIu32 \" bytes to %s\", Length,\n\t           serial->device.name);\n\tif (CommWriteFile(serial->hComm, Stream_Pointer(irp->input), Length, &nbWritten, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"write failure to %s, nbWritten=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbWritten, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes written to %s\", nbWritten,\n\t           serial->device.name);\n\tStream_Write_UINT32(irp->output, nbWritten); \n\tStream_Write_UINT8(irp->output, 0);          \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "void SSecurityTLS::shutdown()\n{\n  if (session) {\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS) {\n      vlog.error(\"TLS session wasn't terminated gracefully\");\n    }\n  }\n  if (dh_params) {\n    gnutls_dh_params_deinit(dh_params);\n    dh_params = 0;\n  }\n  if (anon_cred) {\n    gnutls_anon_free_server_credentials(anon_cred);\n    anon_cred = 0;\n  }\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n    gnutls_global_deinit();\n  }\n}", "target": 1}
{"code": "static uint8_t nvme_sq_empty(NvmeSQueue *sq)\n{\n    return sq->head == sq->tail;\n}", "target": 0}
{"code": "bool SignedData::verify_signature() const {\n  STACK_OF(X509) *certs = nullptr;\n  switch (OBJ_obj2nid(p7_->type)) {\n    case NID_pkcs7_signed: {\n      certs = p7_->d.sign->cert;\n      break;\n    }\n    case NID_pkcs7_signedAndEnveloped: {\n      certs = p7_->d.signed_and_enveloped->cert;\n      break;\n    }\n  }\n  if (certs == nullptr) {\n    return false;\n  }\n  auto *signers_stack_ptr = PKCS7_get0_signers(p7_, nullptr, 0);\n  if (signers_stack_ptr == nullptr) {\n    return false;\n  }\n  auto signers_stack = impl::STACK_OF_X509_ptr(signers_stack_ptr, impl::SK_X509_free);\n  for (auto i = 0; i < sk_X509_num(signers_stack.get()); ++i) {\n    auto *signer = sk_X509_value(signers_stack.get(), i);\n    auto xku_flags = X509_get_extended_key_usage(signer);\n    if (!(xku_flags & XKU_CODE_SIGN)) {\n      return false;\n    }\n  }\n  std::uint8_t *indirect_data_buf = nullptr;\n  auto buf_size = impl::i2d_Authenticode_SpcIndirectDataContent(indirect_data_, &indirect_data_buf);\n  if (buf_size < 0 || indirect_data_buf == nullptr) {\n    return false;\n  }\n  auto indirect_data_ptr =\n      impl::OpenSSL_ptr(reinterpret_cast<char *>(indirect_data_buf), impl::OpenSSL_free);\n  const auto *signed_data_seq = reinterpret_cast<std::uint8_t *>(indirect_data_ptr.get());\n  long length = 0;\n  int tag = 0, tag_class = 0;\n  ASN1_get_object(&signed_data_seq, &length, &tag, &tag_class, buf_size);\n  if (tag != V_ASN1_SEQUENCE) {\n    return false;\n  }\n  auto *signed_data_ptr = BIO_new_mem_buf(signed_data_seq, length);\n  if (signed_data_ptr == nullptr) {\n    return false;\n  }\n  impl::BIO_ptr signed_data(signed_data_ptr, BIO_free);\n  auto status = PKCS7_verify(p7_, certs, nullptr, signed_data.get(), nullptr, PKCS7_NOVERIFY);\n  return status == 1;\n}", "target": 0}
{"code": "static int fsmDoMkDir(rpmPlugins plugins, int dirfd, const char *dn,\n\t\t\tint owned, mode_t mode)\n{\n    int rc;\n    rpmFsmOp op = (FA_CREATE);\n    if (!owned)\n\top |= FAF_UNOWNED;\n    rc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n    if (!rc)\n\trc = fsmMkdir(dirfd, dn, mode);\n    if (!rc) {\n\trc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn, mode, op);\n    }\n    rpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n    if (!rc) {\n\trpmlog(RPMLOG_DEBUG,\n\t\t\"%s directory created with perms %04o\\n\",\n\t\tdn, (unsigned)(mode & 07777));\n    }\n    return rc;\n}", "target": 0}
{"code": "fetch_var_cell_from_buf(buf_t *buf, var_cell_t **out, int linkproto)\n{\n  char hdr[VAR_CELL_MAX_HEADER_SIZE];\n  var_cell_t *result;\n  uint8_t command;\n  uint16_t length;\n  const int wide_circ_ids = linkproto >= MIN_LINK_PROTO_FOR_WIDE_CIRC_IDS;\n  const int circ_id_len = get_circ_id_size(wide_circ_ids);\n  const unsigned header_len = get_var_cell_header_size(wide_circ_ids);\n  check();\n  *out = NULL;\n  if (buf->datalen < header_len)\n    return 0;\n  peek_from_buf(hdr, header_len, buf);\n  command = get_uint8(hdr + circ_id_len);\n  if (!(cell_command_is_var_length(command, linkproto)))\n    return 0;\n  length = ntohs(get_uint16(hdr + circ_id_len + 1));\n  if (buf->datalen < (size_t)(header_len+length))\n    return 1;\n  result = var_cell_new(length);\n  result->command = command;\n  if (wide_circ_ids)\n    result->circ_id = ntohl(get_uint32(hdr));\n  else\n    result->circ_id = ntohs(get_uint16(hdr));\n  buf_remove_from_front(buf, header_len);\n  peek_from_buf((char*) result->payload, length, buf);\n  buf_remove_from_front(buf, length);\n  check();\n  *out = result;\n  return 1;\n}", "target": 0}
{"code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n        methnum = ap_method_number_of(method);\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            if (cmd->pool == cmd->temp_pool) {\n                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n                                   \"for %s from .htaccess configuration\",\n                                    method, cmd->cmd->name);\n            }\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n    limited = tog ? ~limited : limited;\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n    cmd->limited &= limited;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n    cmd->limited = old_limited;\n    return errmsg;\n}", "target": 0}
{"code": "snmp_ber_decode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint8_t *buf_end, type;\n  uint8_t len, j;\n  div_t first;\n  if(!snmp_ber_decode_type(snmp_packet, &type)) {\n    return 0;\n  }\n  if(type != BER_DATA_TYPE_OBJECT_IDENTIFIER) {\n    return 0;\n  }\n  if(!snmp_ber_decode_length(snmp_packet, &len)) {\n    return 0;\n  }\n  buf_end = snmp_packet->in + len;\n  if(snmp_packet->used == 0) {\n    return 0;\n  }\n  snmp_packet->used--;\n  first = div(*snmp_packet->in++, 40);\n  oid->length = 0;\n  oid->data[oid->length++] = (uint32_t)first.quot;\n  oid->data[oid->length++] = (uint32_t)first.rem;\n  while(snmp_packet->in != buf_end) {\n    if(oid->length >= SNMP_MSG_OID_MAX_LEN) {\n      return 0;\n    }\n    if(snmp_packet->used == 0) {\n      return 0;\n    }\n    oid->data[oid->length] = (uint32_t)(*snmp_packet->in & 0x7F);\n    for(j = 0; j < 4; j++) {\n      snmp_packet->used--;\n      if((*snmp_packet->in++ & 0x80) == 0) {\n        break;\n      }\n      if(snmp_packet->used == 0) {\n        return 0;\n      }\n      oid->data[oid->length] <<= 7;\n      oid->data[oid->length] |= (*snmp_packet->in & 0x7F);\n    }\n    oid->length++;\n  }\n  return 1;\n}", "target": 0}
{"code": "int touch(const char *path) {\n        return touch_file(path, false, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n}", "target": 1}
{"code": "static int sd_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tint max_packet_size;\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmax_packet_size = 450;\n\t\tbreak;\n\tcase 176:\n\t\tmax_packet_size = 600;\n\t\tbreak;\n\tdefault:\n\t\tmax_packet_size = 1022;\n\t\tbreak;\n\t}\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\treturn 0;\n}", "target": 1}
{"code": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    reclaim_ramblock(uc, block);\n}", "target": 1}
{"code": "entityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: \n      default:\n        break;\n      }\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n      *nextPtr = next;\n      s = next;\n    }\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::SetNeedsFlush() {\n  if (view_)\n    view_->OnSetNeedsFlushInput();\n}", "target": 0}
{"code": "static int handle_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tstruct msr_data msr;\n\tu32 ecx = vcpu->arch.regs[VCPU_REGS_RCX];\n\tu64 data = (vcpu->arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(vcpu->arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tif (vmx_set_msr(vcpu, &msr) != 0) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\ttrace_kvm_msr_write(ecx, data);\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 1}
{"code": "static inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}", "target": 1}
{"code": "static void sas_discover_domain(struct work_struct *work)\n{\n\tstruct domain_device *dev;\n\tint error = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_DISCOVER_DOMAIN, &port->disc.pending);\n\tif (port->port_dev)\n\t\treturn;\n\terror = sas_get_port_device(port);\n\tif (error)\n\t\treturn;\n\tdev = port->port_dev;\n\tSAS_DPRINTK(\"DOING DISCOVERY on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\tswitch (dev->dev_type) {\n\tcase SAS_END_DEVICE:\n\t\terror = sas_discover_end_dev(dev);\n\t\tbreak;\n\tcase SAS_EDGE_EXPANDER_DEVICE:\n\tcase SAS_FANOUT_EXPANDER_DEVICE:\n\t\terror = sas_discover_root_expander(dev);\n\t\tbreak;\n\tcase SAS_SATA_DEV:\n\tcase SAS_SATA_PM:\n#ifdef CONFIG_SCSI_SAS_ATA\n\t\terror = sas_discover_sata(dev);\n\t\tbreak;\n#else\n\t\tSAS_DPRINTK(\"ATA device seen but CONFIG_SCSI_SAS_ATA=N so cannot attach\\n\");\n#endif\n\tdefault:\n\t\terror = -ENXIO;\n\t\tSAS_DPRINTK(\"unhandled device %d\\n\", dev->dev_type);\n\t\tbreak;\n\t}\n\tif (error) {\n\t\tsas_rphy_free(dev->rphy);\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_del_init(&dev->dev_list_node);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t\tsas_put_device(dev);\n\t\tport->port_dev = NULL;\n\t}\n\tsas_probe_devices(port);\n\tSAS_DPRINTK(\"DONE DISCOVERY on port %d, pid:%d, result:%d\\n\", port->id,\n\t\t    task_pid_nr(current), error);\n}", "target": 0}
{"code": "static long hugetlbfs_punch_hole(struct inode *inode, loff_t offset, loff_t len)\n{\n\tstruct hstate *h = hstate_inode(inode);\n\tloff_t hpage_size = huge_page_size(h);\n\tloff_t hole_start, hole_end;\n\thole_start = round_up(offset, hpage_size);\n\thole_end = round_down(offset + len, hpage_size);\n\tif (hole_end > hole_start) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\ti_mmap_lock_write(mapping);\n\t\tif (!RB_EMPTY_ROOT(&mapping->i_mmap))\n\t\t\thugetlb_vmdelete_list(&mapping->i_mmap,\n\t\t\t\t\t\thole_start >> PAGE_SHIFT,\n\t\t\t\t\t\thole_end  >> PAGE_SHIFT);\n\t\ti_mmap_unlock_write(mapping);\n\t\tremove_inode_hugepages(inode, hole_start, hole_end);\n\t\tmutex_unlock(&inode->i_mutex);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "WebProcessProxy::WebProcessProxy(PassRefPtr<WebContext> context)\n    : ChildProcessProxy(this)\n    , m_responsivenessTimer(this)\n    , m_context(context)\n    , m_mayHaveUniversalFileReadSandboxExtension(false)\n#if ENABLE(CUSTOM_PROTOCOLS)\n    , m_customProtocolManagerProxy(this)\n#endif\n#if PLATFORM(MAC)\n    , m_processSuppressionEnabled(false)\n#endif\n{\n    connect();\n}", "target": 0}
{"code": "ikev1_sub_print(netdissect_options *ndo,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "static int truncate_inline_extent(struct inode *inode,\n\t\t\t\t  struct btrfs_path *path,\n\t\t\t\t  struct btrfs_key *found_key,\n\t\t\t\t  const u64 item_end,\n\t\t\t\t  const u64 new_size)\n{\n\tstruct extent_buffer *leaf = path->nodes[0];\n\tint slot = path->slots[0];\n\tstruct btrfs_file_extent_item *fi;\n\tu32 size = (u32)(new_size - found_key->offset);\n\tstruct btrfs_root *root = BTRFS_I(inode)->root;\n\tfi = btrfs_item_ptr(leaf, slot, struct btrfs_file_extent_item);\n\tif (btrfs_file_extent_compression(leaf, fi) != BTRFS_COMPRESS_NONE) {\n\t\tloff_t offset = new_size;\n\t\tloff_t page_end = ALIGN(offset, PAGE_CACHE_SIZE);\n\t\tbtrfs_release_path(path);\n\t\treturn btrfs_truncate_page(inode, offset, page_end - offset, 0);\n\t}\n\tbtrfs_set_file_extent_ram_bytes(leaf, fi, size);\n\tsize = btrfs_file_extent_calc_inline_size(size);\n\tbtrfs_truncate_item(root, path, size, 1);\n\tif (test_bit(BTRFS_ROOT_REF_COWS, &root->state))\n\t\tinode_sub_bytes(inode, item_end + 1 - new_size);\n\treturn 0;\n}", "target": 0}
{"code": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}", "target": 1}
{"code": "FramebufferModel::~FramebufferModel()\n{\n    delete[] m_pixelBuffer;\n}", "target": 1}
{"code": "static long __media_device_enum_links(struct media_device *mdev,\n\t\t\t\t      struct media_links_enum *links)\n{\n\tstruct media_entity *entity;\n\tentity = find_entity(mdev, links->entity);\n\tif (entity == NULL)\n\t\treturn -EINVAL;\n\tif (links->pads) {\n\t\tunsigned int p;\n\t\tfor (p = 0; p < entity->num_pads; p++) {\n\t\t\tstruct media_pad_desc pad;\n\t\t\tmemset(&pad, 0, sizeof(pad));\n\t\t\tmedia_device_kpad_to_upad(&entity->pads[p], &pad);\n\t\t\tif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (links->links) {\n\t\tstruct media_link_desc __user *ulink;\n\t\tunsigned int l;\n\t\tfor (l = 0, ulink = links->links; l < entity->num_links; l++) {\n\t\t\tstruct media_link_desc link;\n\t\t\tif (entity->links[l].source->entity != entity)\n\t\t\t\tcontinue;\n\t\t\tmemset(&link, 0, sizeof(link));\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].source,\n\t\t\t\t\t\t  &link.source);\n\t\t\tmedia_device_kpad_to_upad(entity->links[l].sink,\n\t\t\t\t\t\t  &link.sink);\n\t\t\tlink.flags = entity->links[l].flags;\n\t\t\tif (copy_to_user(ulink, &link, sizeof(*ulink)))\n\t\t\t\treturn -EFAULT;\n\t\t\tulink++;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void xennet_make_txreqs(\n\tstruct xennet_gnttab_make_txreq *info,\n\tstruct page *page,\n\tunsigned int offset, unsigned int len)\n{\n\tpage += offset >> PAGE_SHIFT;\n\toffset &= ~PAGE_MASK;\n\twhile (len) {\n\t\tinfo->page = page;\n\t\tinfo->size = 0;\n\t\tgnttab_foreach_grant_in_range(page, offset, len,\n\t\t\t\t\t      xennet_make_one_txreq,\n\t\t\t\t\t      info);\n\t\tpage++;\n\t\toffset = 0;\n\t\tlen -= info->size;\n\t}\n}", "target": 0}
{"code": "receive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}", "target": 1}
{"code": "static int muscle_restore_security_env(sc_card_t *card, int se_num)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmemset(&priv->env, 0, sizeof(priv->env));\n\treturn 0;\n}", "target": 0}
{"code": "PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)\n{\n\tstatic const char module[] = \"PredictorEncodeTile\";\n\tTIFFPredictorState *sp = PredictorState(tif);\n        uint8 *working_copy;\n\ttmsize_t cc = cc0, rowsize;\n\tunsigned char* bp;\n        int result_code;\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encodetile != NULL);\n        working_copy = (uint8*) _TIFFmalloc(cc0);\n        if( working_copy == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, module, \n                         \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\",\n                         cc0 );\n            return 0;\n        }\n        memcpy( working_copy, bp0, cc0 );\n        bp = working_copy;\n\trowsize = sp->rowsize;\n\tassert(rowsize > 0);\n\tif((cc0%rowsize)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"PredictorEncodeTile\",\n                     \"%s\", \"(cc0%rowsize)!=0\");\n        _TIFFfree( working_copy );\n        return 0;\n    }\n\twhile (cc > 0) {\n\t\t(*sp->encodepfunc)(tif, bp, rowsize);\n\t\tcc -= rowsize;\n\t\tbp += rowsize;\n\t}\n\tresult_code = (*sp->encodetile)(tif, working_copy, cc0, s);\n        _TIFFfree( working_copy );\n        return result_code;\n}", "target": 0}
{"code": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    *base64,\n    message[MagickPathExtent];\n  const MagickInfo\n    *magick_info;\n  Image\n    *write_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  size_t\n    blob_length,\n    encode_length;\n  unsigned char\n    *blob;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(write_info->magick,exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickMimeType(magick_info) == (const char *) NULL))\n    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n  (void) CopyMagickString(image->filename,write_info->filename,\n    MagickPathExtent);\n  blob_length=2048;\n  write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MagickPathExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}", "target": 1}
{"code": "void read(Protocol_* iprot, const StructInfo& structInfo, void* object) {\n  DCHECK(object);\n  ProtocolReaderStructReadState<Protocol_> readState;\n  readState.readStructBegin(iprot);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    readState.fieldId = 0;\n    readState.readFieldBegin(iprot);\n    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);\n    if (fieldInfo) {\n      void* unionVal = getMember(*fieldInfo, object);\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](\n          unionVal);\n      read(iprot, *fieldInfo->typeInfo, readState, unionVal);\n      const_cast<FieldID&>(activeUnionMemberId(\n          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);\n    if (UNLIKELY(!readState.atStop())) {\n      TProtocolException::throwUnionMissingStop();\n    }\n    readState.readStructEnd(iprot);\n    return;\n  }\n  FieldID prevFieldId = 0;\n  std::int16_t index = 0;\n  for (;; ++index) {\n    auto* fieldInfo = index < structInfo.numFields\n        ? &structInfo.fieldInfos[index]\n        : &kStopMarker;\n    if (UNLIKELY(!readState.advanceToNextField(\n            iprot, prevFieldId, fieldInfo->id, fieldInfo->typeInfo->type))) {\n      for (;;) {\n        readState.afterAdvanceFailure(iprot);\n        if (readState.atStop()) {\n          readState.readStructEnd(iprot);\n          return;\n        }\n        fieldInfo = findFieldInfo(iprot, readState, structInfo);\n        if (fieldInfo) {\n          index = fieldInfo - structInfo.fieldInfos;\n          break;\n        }\n        skip(iprot, readState);\n      }\n    } else if (UNLIKELY(index >= structInfo.numFields)) {\n      readState.readStructEnd(iprot);\n      return;\n    }\n    prevFieldId = fieldInfo->id;\n    read(iprot, *fieldInfo->typeInfo, readState, getMember(*fieldInfo, object));\n    if (fieldInfo->issetOffset > 0) {\n      const_cast<bool&>(fieldIsSet(object, fieldInfo->issetOffset)) = true;\n    }\n  }\n}", "target": 1}
{"code": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\t\tcatcount++;\n\t}\n\tif (!ast_strlen_zero(category) && catcount == 0) { \n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "void PDPServer::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    static_cast<void>(pdata);\n#if HAVE_SECURITY\n    match_reliable_pdp_endpoints(pdata);\n#endif \n}", "target": 1}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n    Tensor group_assignment = c->input(2);\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment,\n                             ALL_TO_ALL_COLLECTIVE, resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    VLOG(1) << \"CollectiveAllToAll group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "gs_heap_resize_object(gs_memory_t * mem, void *obj, uint new_num_elements,\n                      client_name_t cname)\n{\n    gs_malloc_memory_t *mmem = (gs_malloc_memory_t *) mem;\n    gs_malloc_block_t *ptr = (gs_malloc_block_t *) obj - 1;\n    gs_memory_type_ptr_t pstype = ptr->type;\n    uint old_size = gs_object_size(mem, obj) + sizeof(gs_malloc_block_t);\n    uint new_size =\n        gs_struct_type_size(pstype) * new_num_elements +\n        sizeof(gs_malloc_block_t);\n    gs_malloc_block_t *new_ptr;\n    if (new_size == old_size)\n        return obj;\n    if (mmem->monitor)\n        gx_monitor_enter(mmem->monitor);\t\n    new_ptr = (gs_malloc_block_t *) gs_realloc(ptr, old_size, new_size);\n    if (new_ptr == 0)\n        return 0;\n    if (new_ptr->prev)\n        new_ptr->prev->next = new_ptr;\n    else\n        mmem->allocated = new_ptr;\n    if (new_ptr->next)\n        new_ptr->next->prev = new_ptr;\n    new_ptr->size = new_size - sizeof(gs_malloc_block_t);\n    mmem->used -= old_size;\n    mmem->used += new_size;\n    if (mmem->monitor)\n        gx_monitor_leave(mmem->monitor);\t\n    if (new_size > old_size)\n        gs_alloc_fill((byte *) new_ptr + old_size,\n                      gs_alloc_fill_alloc, new_size - old_size);\n    return new_ptr + 1;\n}", "target": 0}
{"code": "static unsigned long mmap_legacy_base(unsigned long rnd)\n{\n\tif (mmap_is_ia32())\n\t\treturn TASK_UNMAPPED_BASE;\n\telse\n\t\treturn TASK_UNMAPPED_BASE + rnd;\n}", "target": 1}
{"code": "void pin_remove(struct fs_pin *pin)\n{\n\tspin_lock(&pin_lock);\n\thlist_del(&pin->m_list);\n\thlist_del(&pin->s_list);\n\tspin_unlock(&pin_lock);\n\tspin_lock_irq(&pin->wait.lock);\n\tpin->done = 1;\n\twake_up_locked(&pin->wait);\n\tspin_unlock_irq(&pin->wait.lock);\n}", "target": 1}
{"code": "static void ptirq_free_irte(const struct ptirq_remapping_info *entry)\n{\n\tstruct intr_source intr_src;\n\tif (entry->irte_idx < CONFIG_MAX_IR_ENTRIES) {\n\t\tif (entry->intr_type == PTDEV_INTR_MSI) {\n\t\t\tintr_src.is_msi = true;\n\t\t\tintr_src.src.msi.value = entry->phys_sid.msi_id.bdf;\n\t\t} else {\n\t\t\tintr_src.is_msi = false;\n\t\t\tintr_src.src.ioapic_id = ioapic_irq_to_ioapic_id(entry->allocated_pirq);\n\t\t}\n\t\tdmar_free_irte(&intr_src, entry->irte_idx);\n\t}\n}", "target": 1}
{"code": "void jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}", "target": 1}
{"code": "gplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUF_SIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n    PROCNAME(\"gplotAddPlot\");\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if ((n = numaGetCount(nay)) == 0)\n        return ERROR_INT(\"no points to plot\", procName, 1);\n    if (nax && (n != numaGetCount(nax)))\n        return ERROR_INT(\"nax and nay sizes differ\", procName, 1);\n    if (n == 1 && plotstyle == GPLOT_LINES) {\n        L_INFO(\"only 1 pt; changing style to points\\n\", procName);\n        plotstyle = GPLOT_POINTS;\n    }\n    numaGetParameters(nay, &startx, &delx);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n    gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n    return 0;\n}", "target": 1}
{"code": "parseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "PHP_FUNCTION( msgfmt_format_message )\n{\n\tzval       *args;\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tint         pattern_len = 0;\n\tconst char *slocale = NULL;\n\tint         slocale_len = 0;\n\tMessageFormatter_object mf = {0};\n\tMessageFormatter_object *mfo = &mf;\n\tif( zend_parse_method_parameters( ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"ssa\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &args ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_format_message: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tINTL_CHECK_LOCALE_LEN(slocale_len);\n\tmsgformat_data_init(&mfo->mf_data TSRMLS_CC);\n\tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_format_message: error converting pattern to UTF-16\", 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default(TSRMLS_C);\n\t}\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_format_message: error converting pattern to quote-friendly format\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\tmsgfmt_do_format(mfo, args, return_value TSRMLS_CC);\n\tmsgformat_data_free(&mfo->mf_data TSRMLS_CC);\n}", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 1}
{"code": "Eina_Bool ewk_view_disable_render(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api->disable_render, false);\n    return smartData->api->disable_render(smartData);\n}", "target": 0}
{"code": "static bool ptrace_freeze_traced(struct task_struct *task)\n{\n\tbool ret = false;\n\tif (task->jobctl & JOBCTL_LISTENING)\n\t\treturn ret;\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task_is_traced(task) && !__fatal_signal_pending(task)) {\n\t\ttask->state = __TASK_TRACED;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n\treturn ret;\n}", "target": 0}
{"code": "void poly_frommsg(poly *r, const uint8_t msg[KYBER_INDCPA_MSGBYTES])\n{\n  unsigned int i,j;\n  int16_t mask;\n#if (KYBER_INDCPA_MSGBYTES != KYBER_N/8)\n#error \"KYBER_INDCPA_MSGBYTES must be equal to KYBER_N/8 bytes!\"\n#endif\n  for(i=0;i<KYBER_N/8;i++) {\n    for(j=0;j<8;j++) {\n      mask = -(int16_t)((msg[i] >> j)&1);\n      r->coeffs[8*i+j] = mask & ((KYBER_Q+1)/2);\n    }\n  }\n}", "target": 1}
{"code": "static int remarkupvals (global_State *g) {\n  lua_State *thread;\n  lua_State **p = &g->twups;\n  int work = 0;\n  while ((thread = *p) != NULL) {\n    work++;\n    lua_assert(!isblack(thread));  \n    if (isgray(thread) && thread->openupval != NULL)\n      p = &thread->twups;  \n    else {  \n      UpVal *uv;\n      lua_assert(!isold(thread) || thread->openupval == NULL);\n      *p = thread->twups;  \n      thread->twups = thread;  \n      for (uv = thread->openupval; uv != NULL; uv = uv->u.open.next) {\n        lua_assert(getage(uv) <= getage(thread));\n        work++;\n        if (!iswhite(uv))  \n          markvalue(g, uv->v);  \n      }\n    }\n  }\n  return work;\n}", "target": 0}
{"code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint error = sock_error(sk);\n\tif (error)\n\t\tgoto no_packet;\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tdo {\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n\t\tskb_queue_walk(queue, skb) {\n\t\t\t*peeked = skb->peeked;\n\t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n\t\t\t\t\t*off -= skb->len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (!wait_for_packet(sk, err, &timeo));\n\treturn NULL;\nno_packet:\n\t*err = error;\n\treturn NULL;\n}", "target": 1}
{"code": "std::string get_wml_location(const std::string &filename, const std::string &current_dir)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\" << std::endl;\n\tassert(game_config::path.empty() == false);\n\tstd::string result;\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\" << std::endl;\n\t\treturn result;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tif (looks_like_pbl(filename)) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn result;\n\t}\n\tbool already_found = false;\n\tif (filename[0] == '~')\n\t{\n\t\tresult = get_user_data_dir() + \"/data/\" + filename.substr(1);\n\t\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\t\talready_found = file_exists(result) || is_directory(result);\n\t}\n\telse if (filename.size() >= 2 && filename[0] == '.' && filename[1] == '/')\n\t{\n\t\tif (!current_dir.empty())\n\t\t{\n\t\t\tresult = current_dir;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult = game_config::path;\n\t\t}\n\t\tresult += filename.substr(2);\n\t}\n\telse if (!game_config::path.empty())\n\t\tresult = game_config::path + \"/data/\" + filename;\n\tDBG_FS << \"  trying '\" << result << \"'\" << std::endl;\n\tif (result.empty() ||\n\t    (!already_found && !file_exists(result) && !is_directory(result)))\n\t{\n\t\tDBG_FS << \"  not found\" << std::endl;\n\t\tresult.clear();\n\t}\n\telse\n\t\tDBG_FS << \"  found: '\" << result << \"'\" << std::endl;\n\treturn result;\n}", "target": 0}
{"code": "void PrintWebViewHelper::Print(WebKit::WebFrame* frame,\n                               const WebKit::WebNode& node) {\n  if (print_web_view_)\n    return;\n  scoped_ptr<PrepareFrameAndViewForPrint> prepare;\n  if (!InitPrintSettingsAndPrepareFrame(frame, node, &prepare)) {\n    DidFinishPrinting(FAIL_PRINT);\n    return;  \n  }\n  int expected_page_count = 0;\n  bool use_browser_overlays = true;\n  expected_page_count = prepare->GetExpectedPageCount();\n  if (expected_page_count)\n    use_browser_overlays = prepare->ShouldUseBrowserOverlays();\n  prepare.reset();\n  if (!expected_page_count) {\n    DidFinishPrinting(OK);  \n    return;\n  }\n  if (!GetPrintSettingsFromUser(frame, node, expected_page_count,\n                                use_browser_overlays)) {\n    DidFinishPrinting(OK);  \n    return;\n  }\n  if (!RenderPagesForPrint(frame, node, NULL)) {\n    LOG(ERROR) << \"RenderPagesForPrint failed\";\n    DidFinishPrinting(FAIL_PRINT);\n  }\n  ResetScriptedPrintCount();\n}", "target": 0}
{"code": "static unsigned int __blk_mq_get_reserved_tag(struct blk_mq_alloc_data *data)\n{\n\tint tag, zero = 0;\n\tif (unlikely(!data->hctx->tags->nr_reserved_tags)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn BLK_MQ_TAG_FAIL;\n\t}\n\ttag = bt_get(data, &data->hctx->tags->breserved_tags, NULL, &zero,\n\t\tdata->hctx->tags);\n\tif (tag < 0)\n\t\treturn BLK_MQ_TAG_FAIL;\n\treturn tag;\n}", "target": 0}
{"code": "struct clock_source *dce100_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\tif (!err)\n\t\td_drop(dentry);\n\tinode_unlock(dir);\n\treturn err;\n}", "target": 1}
{"code": "static inline unsigned long do_div_llr(const long long dividend,\n\t\t\t\t       const long divisor, long *remainder)\n{\n\tu64 result = dividend;\n\t*(remainder) = do_div(result, divisor);\n\treturn (unsigned long) result;\n}", "target": 1}
{"code": "Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onDownstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                         static_cast<uint32_t>(end_of_stream));\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n\tint ret;\n\tstruct lxc_lock *lock;\n\tlock = lxc_newlock(NULL, NULL);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get unnamed lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tret = lxclock(lock, 0);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to take unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tret = lxcunlock(lock);\n\tif (ret) {\n\t\tfprintf(stderr, \"%d: failed to put unnamed lock (%d)\\n\", __LINE__, ret);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\tlock = lxc_newlock(\"/var/lib/lxc\", mycontainername);\n\tif (!lock) {\n\t\tfprintf(stderr, \"%d: failed to get lock\\n\", __LINE__);\n\t\texit(1);\n\t}\n\tstruct stat sb;\n\tchar *pathname = RUNTIME_PATH \"/lock/lxc/var/lib/lxc/\";\n\tret = stat(pathname, &sb);\n\tif (ret != 0) {\n\t\tfprintf(stderr, \"%d: filename %s not created\\n\", __LINE__,\n\t\t\tpathname);\n\t\texit(1);\n\t}\n\tlxc_putlock(lock);\n\ttest_two_locks();\n\tfprintf(stderr, \"all tests passed\\n\");\n\texit(ret);\n}", "target": 1}
{"code": "void cql_server::response::write_bytes(bytes b)\n{\n    write_int(cast_if_fits<int32_t>(b.size()));\n    _body.write(b);\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    GradFunContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int p, direct;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    for (p = 0; p < 4 && in->data[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n        if (FFMIN(w, h) > 2 * r)\n            filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r);\n        else if (out->data[p] != in->data[p])\n            av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h);\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "const char *enc_untrusted_inet_ntop(int af, const void *src, char *dst,\n                                    socklen_t size) {\n  if (!src || !dst) {\n    errno = EFAULT;\n    return nullptr;\n  }\n  size_t src_size = 0;\n  if (af == AF_INET) {\n    src_size = sizeof(struct in_addr);\n  } else if (af == AF_INET6) {\n    src_size = sizeof(struct in6_addr);\n  } else {\n    errno = EAFNOSUPPORT;\n    return nullptr;\n  }\n  MessageWriter input;\n  input.Push<int>(TokLinuxAfFamily(af));\n  input.PushByReference(Extent{reinterpret_cast<const char *>(src), src_size});\n  input.Push(size);\n  MessageReader output;\n  const auto status = NonSystemCallDispatcher(\n      ::asylo::host_call::kInetNtopHandler, &input, &output);\n  CheckStatusAndParamCount(status, output, \"enc_untrusted_inet_ntop\", 2);\n  auto result = output.next();\n  int klinux_errno = output.next<int>();\n  if (result.empty()) {\n    errno = FromkLinuxErrorNumber(klinux_errno);\n    return nullptr;\n  }\n  memcpy(dst, result.data(),\n         std::min(static_cast<size_t>(size),\n                  static_cast<size_t>(INET6_ADDRSTRLEN)));\n  return dst;\n}", "target": 1}
{"code": "int regset_tls_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tstruct user_desc infobuf[GDT_ENTRY_TLS_ENTRIES];\n\tconst struct user_desc *info;\n\tint i;\n\tif (pos >= GDT_ENTRY_TLS_ENTRIES * sizeof(struct user_desc) ||\n\t    (pos % sizeof(struct user_desc)) != 0 ||\n\t    (count % sizeof(struct user_desc)) != 0)\n\t\treturn -EINVAL;\n\tif (kbuf)\n\t\tinfo = kbuf;\n\telse if (__copy_from_user(infobuf, ubuf, count))\n\t\treturn -EFAULT;\n\telse\n\t\tinfo = infobuf;\n\tfor (i = 0; i < count / sizeof(struct user_desc); i++)\n\t\tif (!tls_desc_okay(info + i))\n\t\t\treturn -EINVAL;\n\tset_tls_desc(target,\n\t\t     GDT_ENTRY_TLS_MIN + (pos / sizeof(struct user_desc)),\n\t\t     info, count / sizeof(struct user_desc));\n\treturn 0;\n}", "target": 0}
{"code": "static int tight_compress_data(VncState *vs, int stream_id, size_t bytes,\n                               int level, int strategy)\n{\n    z_streamp zstream = &vs->tight->stream[stream_id];\n    int previous_out;\n    if (bytes < VNC_TIGHT_MIN_TO_COMPRESS) {\n        vnc_write(vs, vs->tight->tight.buffer, vs->tight->tight.offset);\n        return bytes;\n    }\n    if (tight_init_stream(vs, stream_id, level, strategy)) {\n        return -1;\n    }\n    buffer_reserve(&vs->tight->zlib, bytes + 64);\n    zstream->next_in = vs->tight->tight.buffer;\n    zstream->avail_in = vs->tight->tight.offset;\n    zstream->next_out = vs->tight->zlib.buffer + vs->tight->zlib.offset;\n    zstream->avail_out = vs->tight->zlib.capacity - vs->tight->zlib.offset;\n    previous_out = zstream->avail_out;\n    zstream->data_type = Z_BINARY;\n    if (deflate(zstream, Z_SYNC_FLUSH) != Z_OK) {\n        fprintf(stderr, \"VNC: error during tight compression\\n\");\n        return -1;\n    }\n    vs->tight->zlib.offset = vs->tight->zlib.capacity - zstream->avail_out;\n    bytes = previous_out - zstream->avail_out;\n    tight_send_compact_size(vs, bytes);\n    vnc_write(vs, vs->tight->zlib.buffer, bytes);\n    buffer_reset(&vs->tight->zlib);\n    return bytes;\n}", "target": 0}
{"code": "hybiRemaining(ws_ctx_t *wsctx)\n{\n  return wsctx->nToRead - wsctx->nReadRaw;\n}", "target": 0}
{"code": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n#ifdef CONFIG_SND_CTL_DEBUG\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static int pgpVerifySelf(pgpDigParams key, pgpDigParams selfsig,\n\t\t\tconst struct pgpPkt *all, int i)\n{\n    int rc = -1;\n    DIGEST_CTX hash = NULL;\n    switch (selfsig->sigtype) {\n    case PGPSIGTYPE_SUBKEY_BINDING:\n\thash = rpmDigestInit(selfsig->hash_algo, 0);\n\tif (hash) {\n\t    rc = hashKey(hash, &all[0], PGPTAG_PUBLIC_KEY);\n\t    if (!rc)\n\t\trc = hashKey(hash, &all[i-1], PGPTAG_PUBLIC_SUBKEY);\n\t}\n\tbreak;\n    default:\n\trc = 0;\n\tbreak;\n    }\n    if (hash && rc == 0)\n\trc = pgpVerifySignature(key, selfsig, hash);\n    rpmDigestFinal(hash, NULL, NULL, 0);\n    return rc;\n}", "target": 0}
{"code": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}", "target": 1}
{"code": "static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,\n\t\t\t\tstruct bpf_reg_state *src_reg)\n{\n\tbool src_known = tnum_subreg_is_const(src_reg->var_off);\n\tbool dst_known = tnum_subreg_is_const(dst_reg->var_off);\n\tstruct tnum var32_off = tnum_subreg(dst_reg->var_off);\n\ts32 smin_val = src_reg->smin_value;\n\tu32 umin_val = src_reg->umin_value;\n\tif (src_known && dst_known)\n\t\treturn;\n\tdst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);\n\tdst_reg->u32_max_value = var32_off.value | var32_off.mask;\n\tif (dst_reg->s32_min_value < 0 || smin_val < 0) {\n\t\tdst_reg->s32_min_value = S32_MIN;\n\t\tdst_reg->s32_max_value = S32_MAX;\n\t} else {\n\t\tdst_reg->s32_min_value = dst_reg->umin_value;\n\t\tdst_reg->s32_max_value = dst_reg->umax_value;\n\t}\n}", "target": 1}
{"code": "static s32 adpt_rescan(adpt_hba* pHba)\n{\n\ts32 rcode;\n\tulong flags = 0;\n\tif(pHba->host)\n\t\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tif ((rcode=adpt_i2o_lct_get(pHba)) < 0)\n\t\tgoto out;\n\tif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0)\n\t\tgoto out;\n\trcode = 0;\nout:\tif(pHba->host)\n\t\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\treturn rcode;\n}", "target": 1}
{"code": "_client_protocol_timeout (GsmXSMPClient *client)\n{\n        g_debug (\"GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d\",\n                 client->priv->description,\n                 IceConnectionStatus (client->priv->ice_connection));\n        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);\n        gsm_client_disconnected (GSM_CLIENT (client));\n        return FALSE;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"dim must be a scalar\"));\n    int32_t dim = context->input(0).scalar<int32_t>()();\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"num_results must be a scalar\"));\n    int32_t num_results = context->input(1).scalar<int32_t>()();\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(context->input(0).shape()),\n                errors::InvalidArgument(\"skip must be a scalar\"));\n    int32_t skip = context->input(2).scalar<int32_t>()();\n    OP_REQUIRES(context, dim >= 1,\n                errors::InvalidArgument(\"dim must be at least one\"));\n    OP_REQUIRES(context, dim <= sobol_data::kMaxSobolDim,\n                errors::InvalidArgument(\"dim must be at most \",\n                                        sobol_data::kMaxSobolDim));\n    OP_REQUIRES(context, num_results >= 1,\n                errors::InvalidArgument(\"num_results must be at least one\"));\n    OP_REQUIRES(context, skip >= 0,\n                errors::InvalidArgument(\"skip must be non-negative\"));\n    OP_REQUIRES(context,\n                num_results < std::numeric_limits<int32_t>::max() - skip,\n                errors::InvalidArgument(\"num_results+skip must be less than \",\n                                        std::numeric_limits<int32_t>::max()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(\n                       0, TensorShape({num_results, dim}), &output));\n    auto output_flat = output->flat<T>();\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    int num_threads = worker_threads.num_threads;\n    int block_size = std::max(\n        kMinBlockSize, static_cast<int>(std::ceil(\n                           static_cast<float>(num_results) / num_threads)));\n    worker_threads.workers->TransformRangeConcurrently(\n        block_size, num_results ,\n        [&dim, &skip, &output_flat](const int start, const int end) {\n          CalculateSobolSample<T>(dim, end - start , skip,\n                                  start, output_flat);\n        });\n  }", "target": 0}
{"code": "static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct multipath *m = (struct multipath *) ti->private;\n\tstruct block_device *bdev = NULL;\n\tfmode_t mode = 0;\n\tunsigned long flags;\n\tint r = 0;\n\tspin_lock_irqsave(&m->lock, flags);\n\tif (!m->current_pgpath)\n\t\t__choose_pgpath(m, 0);\n\tif (m->current_pgpath) {\n\t\tbdev = m->current_pgpath->path.dev->bdev;\n\t\tmode = m->current_pgpath->path.dev->mode;\n\t}\n\tif (m->queue_io)\n\t\tr = -EAGAIN;\n\telse if (!bdev)\n\t\tr = -EIO;\n\tspin_unlock_irqrestore(&m->lock, flags);\n\tif (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)\n\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n\treturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\n}", "target": 0}
{"code": "xfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen = args->valuelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\ttrace_xfs_attr_rmtval_get(args);\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}", "target": 1}
{"code": "devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,\n    int *eofp, caller_context_t *ct_unused, int flags_unused)\n{\n\tstruct sdev_node *sdvp = VTOSDEV(dvp);\n\tchar *ptr;\n\tsdcmn_err13((\"zv readdir of '%s' %s'\", sdvp->sdev_path,\n\t    sdvp->sdev_name));\n\tif (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {\n\t\tstruct vnode *vp;\n\t\trw_exit(&sdvp->sdev_contents);\n\t\t(void) devname_lookup_func(sdvp, \"dsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\t(void) devname_lookup_func(sdvp, \"rdsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tif (uiop->uio_offset == 0)\n\t\tdevzvol_prunedir(sdvp);\n\tptr = sdvp->sdev_path + strlen(ZVOL_DIR);\n\tif ((strcmp(ptr, \"/dsk\") == 0) || (strcmp(ptr, \"/rdsk\") == 0)) {\n\t\trw_exit(&sdvp->sdev_contents);\n\t\tdevzvol_create_pool_dirs(dvp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tptr = strchr(ptr + 1, '/') + 1;\n\trw_exit(&sdvp->sdev_contents);\n\tsdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);\n\trw_enter(&sdvp->sdev_contents, RW_READER);\n\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n}", "target": 1}
{"code": "static void key_gc_timer_func(unsigned long data)\n{\n\tkenter(\"\");\n\tkey_gc_next_run = LONG_MAX;\n\tkey_schedule_gc_links();\n}", "target": 0}
{"code": "static int fsmVerify(int dirfd, const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n    rc = fsmStat(dirfd, path, 1, &dsb);\n    if (rc)\n\treturn rc;\n    if (S_ISREG(mode)) {\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(dirfd, path, dirfd, rmpath);\n\tif (!rc)\n\t    (void) fsmUnlink(dirfd, rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(dirfd, path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == dsb.st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    rc = fsmUnlink(dirfd, path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t\n}", "target": 0}
{"code": "R_API char *r_cons_hud_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_ansi_strip (o);\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}", "target": 0}
{"code": "\t\tAccessorRunner(ReferenceHandle& target, Local<Value> key_handle) :\n\t\tcontext{target.context},\n\t\ttarget{target.reference},\n\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)} {\n\t\t\ttarget.CheckDisposed();\n\t\t\tif (!key || (!key_handle->IsName() && !key_handle->IsUint32())) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t} else if (target.type_of != decltype(target.type_of)::Object) {\n\t\t\t\tthrow RuntimeTypeError(\"Reference is not an object\");\n\t\t\t}\n\t\t}", "target": 0}
{"code": "static int cg_rmdir(const char *path)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n\t\t\tcontroller, cgdir, path);\n\tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, NOBH))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "static void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\tcrypto_bignum_free(*bn);\n\t*bn = NULL;\n}", "target": 1}
{"code": "PackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "    void appendCDATABlockCallback(const xmlChar* s, int len)\n    {\n        PendingCDATABlockCallback* callback = new PendingCDATABlockCallback;\n        callback->s = xmlStrndup(s, len);\n        callback->len = len;\n        m_callbacks.append(callback);        \n    }", "target": 0}
{"code": "static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    size_t alloc_size;\n    bool status;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    alloc_size = size + 1;\n    if (alloc_size < size)\n        PB_RETURN_ERROR(stream, \"size too large\");\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, alloc_size, 1))\n            return false;\n        dest = *(void**)dest;\n#endif\n    }\n    else\n    {\n        if (alloc_size > field->data_size)\n            PB_RETURN_ERROR(stream, \"string overflow\");\n    }\n    status = pb_read(stream, (uint8_t*)dest, size);\n    *((uint8_t*)dest + size) = 0;\n    return status;\n}", "target": 0}
{"code": "static void rb_wake_up_waiters(struct irq_work *work)\n{\n\tstruct rb_irq_work *rbwork = container_of(work, struct rb_irq_work, work);\n\twake_up_all(&rbwork->waiters);\n\tif (rbwork->wakeup_full) {\n\t\trbwork->wakeup_full = false;\n\t\twake_up_all(&rbwork->full_waiters);\n\t}\n}", "target": 0}
{"code": "static int em_syscall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_ud(ctxt);\n\tif (!(em_syscall_is_enabled(ctxt)))\n\t\treturn emulate_ud(ctxt);\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif (!(efer & EFER_SCE))\n\t\treturn emulate_ud(ctxt);\n\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\tmsr_data >>= 32;\n\tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->regs[VCPU_REGS_RCX] = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\tctxt->regs[VCPU_REGS_R11] = ctxt->eflags & ~EFLG_RF;\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~(msr_data | EFLG_RF);\n#endif\n\t} else {\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\t\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\t\tkfree(ucounts);\n\t}\n}", "target": 1}
{"code": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}", "target": 1}
{"code": "GF_Err schm_box_size(GF_Box *s)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += 8;\n\tif (ptr->flags & 0x000001) ptr->size += 1 + (ptr->URI ? strlen(ptr->URI) : 0);\n\treturn GF_OK;\n}", "target": 0}
{"code": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      if (*vs > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n  default:\n    break;\n  }\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}", "target": 0}
{"code": "void __drm_atomic_state_free(struct kref *ref)\n{\n\tstruct drm_atomic_state *state = container_of(ref, typeof(*state), ref);\n\tstruct drm_mode_config *config = &state->dev->mode_config;\n\tdrm_atomic_state_clear(state);\n\tdrm_dbg_atomic(state->dev, \"Freeing atomic state %p\\n\", state);\n\tif (config->funcs->atomic_state_free) {\n\t\tconfig->funcs->atomic_state_free(state);\n\t} else {\n\t\tdrm_atomic_state_default_release(state);\n\t\tkfree(state);\n\t}\n}", "target": 1}
{"code": "static void rds_tcp_kill_sock(struct net *net)\n{\n\tstruct rds_tcp_connection *tc, *_tc;\n\tLIST_HEAD(tmp_list);\n\tstruct rds_tcp_net *rtn = net_generic(net, rds_tcp_netid);\n\tstruct socket *lsock = rtn->rds_tcp_listen_sock;\n\trtn->rds_tcp_listen_sock = NULL;\n\trds_tcp_listen_stop(lsock, &rtn->rds_tcp_accept_w);\n\tspin_lock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &rds_tcp_conn_list, t_tcp_node) {\n\t\tstruct net *c_net = read_pnet(&tc->t_cpath->cp_conn->c_net);\n\t\tif (net != c_net || !tc->t_sock)\n\t\t\tcontinue;\n\t\tif (!list_has_conn(&tmp_list, tc->t_cpath->cp_conn)) {\n\t\t\tlist_move_tail(&tc->t_tcp_node, &tmp_list);\n\t\t} else {\n\t\t\tlist_del(&tc->t_tcp_node);\n\t\t\ttc->t_tcp_node_detached = true;\n\t\t}\n\t}\n\tspin_unlock_irq(&rds_tcp_conn_lock);\n\tlist_for_each_entry_safe(tc, _tc, &tmp_list, t_tcp_node)\n\t\trds_conn_destroy(tc->t_cpath->cp_conn);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() == 2,\n        errors::InvalidArgument(absl::StrCat(\n            \"Shape must be rank 2 but is rank \", sorted_inputs_t.shape().dims(),\n            \" for \"\n            \"`sorted_inputs` argument\")));\n    OP_REQUIRES(ctx, values_t.shape().dims() == 2,\n                errors::InvalidArgument(absl::StrCat(\n                    \"Shape must be rank 2 but is rank \",\n                    values_t.shape().dims(), \" for `values` argument\")));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}\n\t}\n\tif (!node) {\n\t\t*ch = 0;\n\t\treturn;\n\t}\n\t*ch = node->symbol;\n\t*offset = bloc;\n}", "target": 1}
{"code": "static int hexagon_v6_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tHexInsn hi = {0};;\n\tut32 data = 0;\n\tdata = r_read_le32 (buf);\n\tint size = hexagon_disasm_instruction (data, &hi, (ut32) addr);\n\top->size = size;\n\tif (size <= 0) {\n\t\treturn size;\n\t}\n\top->addr = addr;\n\treturn hexagon_anal_instruction (&hi, op);\n}", "target": 1}
{"code": "dirserv_add_multiple_descriptors(const char *desc, uint8_t purpose,\n                                 const char *source,\n                                 const char **msg)\n{\n  was_router_added_t r, r_tmp;\n  const char *msg_out;\n  smartlist_t *list;\n  const char *s;\n  int n_parsed = 0;\n  time_t now = time(NULL);\n  char annotation_buf[ROUTER_ANNOTATION_BUF_LEN];\n  char time_buf[ISO_TIME_LEN+1];\n  int general = purpose == ROUTER_PURPOSE_GENERAL;\n  tor_assert(msg);\n  r=ROUTER_ADDED_SUCCESSFULLY; \n  format_iso_time(time_buf, now);\n  if (tor_snprintf(annotation_buf, sizeof(annotation_buf),\n                   \"@uploaded-at %s\\n\"\n                   \"@source %s\\n\"\n                   \"%s%s%s\", time_buf, escaped(source),\n                   !general ? \"@purpose \" : \"\",\n                   !general ? router_purpose_to_string(purpose) : \"\",\n                   !general ? \"\\n\" : \"\")<0) {\n    *msg = \"Couldn't format annotations\";\n    return -1;\n  }\n  s = desc;\n  list = smartlist_create();\n  if (!router_parse_list_from_string(&s, NULL, list, SAVED_NOWHERE, 0, 0,\n                                     annotation_buf)) {\n    SMARTLIST_FOREACH(list, routerinfo_t *, ri, {\n        msg_out = NULL;\n        tor_assert(ri->purpose == purpose);\n        r_tmp = dirserv_add_descriptor(ri, &msg_out, source);\n        if (WRA_MORE_SEVERE(r_tmp, r)) {\n          r = r_tmp;\n          *msg = msg_out;\n        }\n      });\n  }\n  n_parsed += smartlist_len(list);\n  smartlist_clear(list);\n  s = desc;\n  if (!router_parse_list_from_string(&s, NULL, list, SAVED_NOWHERE, 1, 0,\n                                     NULL)) {\n    SMARTLIST_FOREACH(list, extrainfo_t *, ei, {\n        msg_out = NULL;\n        r_tmp = dirserv_add_extrainfo(ei, &msg_out);\n        if (WRA_MORE_SEVERE(r_tmp, r)) {\n          r = r_tmp;\n          *msg = msg_out;\n        }\n      });\n  }\n  n_parsed += smartlist_len(list);\n  smartlist_free(list);\n  if (! *msg) {\n    if (!n_parsed) {\n      *msg = \"No descriptors found in your POST.\";\n      if (WRA_WAS_ADDED(r))\n        r = ROUTER_WAS_NOT_NEW;\n    } else {\n      *msg = \"(no message)\";\n    }\n  }\n  return r;\n}", "target": 0}
{"code": "static __always_inline int __do_follow_link(struct path *path, struct nameidata *nd)\n{\n\tint error;\n\tvoid *cookie;\n\tstruct dentry *dentry = path->dentry;\n\ttouch_atime(path->mnt, dentry);\n\tnd_set_link(nd, NULL);\n\tif (path->mnt != nd->path.mnt) {\n\t\tpath_to_nameidata(path, nd);\n\t\tdget(dentry);\n\t}\n\tmntget(path->mnt);\n\tnd->last_type = LAST_BIND;\n\tcookie = dentry->d_inode->i_op->follow_link(dentry, nd);\n\terror = PTR_ERR(cookie);\n\tif (!IS_ERR(cookie)) {\n\t\tchar *s = nd_get_link(nd);\n\t\terror = 0;\n\t\tif (s)\n\t\t\terror = __vfs_follow_link(nd, s);\n\t\telse if (nd->last_type == LAST_BIND) {\n\t\t\terror = force_reval_path(&nd->path, nd);\n\t\t\tif (error)\n\t\t\t\tpath_put(&nd->path);\n\t\t}\n\t\tif (dentry->d_inode->i_op->put_link)\n\t\t\tdentry->d_inode->i_op->put_link(dentry, nd, cookie);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "static int decode_user_data(Mpeg4DecContext *ctx, GetBitContext *gb)\n{\n    MpegEncContext *s = &ctx->m;\n    char buf[256];\n    int i;\n    int e;\n    int ver = 0, build = 0, ver2 = 0, ver3 = 0;\n    char last;\n    for (i = 0; i < 255 && get_bits_count(gb) < gb->size_in_bits; i++) {\n        if (show_bits(gb, 23) == 0)\n            break;\n        buf[i] = get_bits(gb, 8);\n    }\n    buf[i] = 0;\n    e = sscanf(buf, \"DivX%dBuild%d%c\", &ver, &build, &last);\n    if (e < 2)\n        e = sscanf(buf, \"DivX%db%d%c\", &ver, &build, &last);\n    if (e >= 2) {\n        ctx->divx_version = ver;\n        ctx->divx_build   = build;\n        s->divx_packed  = e == 3 && last == 'p';\n        if (s->divx_packed && !ctx->showed_packed_warning) {\n            av_log(s->avctx, AV_LOG_INFO, \"Video uses a non-standard and \"\n                   \"wasteful way to store B-frames ('packed B-frames'). \"\n                   \"Consider using a tool like VirtualDub or avidemux to fix it.\\n\");\n            ctx->showed_packed_warning = 1;\n        }\n    }\n    e = sscanf(buf, \"FFmpe%*[^b]b%d\", &build) + 3;\n    if (e != 4)\n        e = sscanf(buf, \"FFmpeg v%d.%d.%d / libavcodec build: %d\", &ver, &ver2, &ver3, &build);\n    if (e != 4) {\n        e = sscanf(buf, \"Lavc%d.%d.%d\", &ver, &ver2, &ver3) + 1;\n        if (e > 1)\n            build = (ver << 16) + (ver2 << 8) + ver3;\n    }\n    if (e != 4) {\n        if (strcmp(buf, \"ffmpeg\") == 0)\n            ctx->lavc_build = 4600;\n    }\n    if (e == 4)\n        ctx->lavc_build = build;\n    e = sscanf(buf, \"XviD%d\", &build);\n    if (e == 1)\n        ctx->xvid_build = build;\n    return 0;\n}", "target": 0}
{"code": "static char* umocktypes_stringify_FLOW_HANDLE(const FLOW_HANDLE* value)\n{\n    char temp_buffer[32];\n    char* result;\n    size_t length = sprintf(temp_buffer, \"%p\", (void*)*value);\n    if (length < 0)\n    {\n        result = NULL;\n    }\n    else\n    {\n        result = (char*)malloc(length + 1);\n        if (result != NULL)\n        {\n            (void)memcpy(result, temp_buffer, length + 1);\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stw_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "static int __tipc_nl_compat_dumpit(struct tipc_nl_compat_cmd_dump *cmd,\n\t\t\t\t   struct tipc_nl_compat_msg *msg,\n\t\t\t\t   struct sk_buff *arg)\n{\n\tint len = 0;\n\tint err;\n\tstruct sk_buff *buf;\n\tstruct nlmsghdr *nlmsg;\n\tstruct netlink_callback cb;\n\tmemset(&cb, 0, sizeof(cb));\n\tcb.nlh = (struct nlmsghdr *)arg->data;\n\tcb.skb = arg;\n\tbuf = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf->sk = msg->dst_sk;\n\tdo {\n\t\tint rem;\n\t\tlen = (*cmd->dumpit)(buf, &cb);\n\t\tnlmsg_for_each_msg(nlmsg, nlmsg_hdr(buf), len, rem) {\n\t\t\tstruct nlattr **attrs;\n\t\t\terr = tipc_nlmsg_parse(nlmsg, &attrs);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\terr = (*cmd->format)(msg, attrs);\n\t\t\tif (err)\n\t\t\t\tgoto err_out;\n\t\t\tif (tipc_skb_tailroom(msg->rep) <= 1) {\n\t\t\t\terr = -EMSGSIZE;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tskb_reset_tail_pointer(buf);\n\t\tbuf->len = 0;\n\t} while (len);\n\terr = 0;\nerr_out:\n\tkfree_skb(buf);\n\tif (err == -EMSGSIZE) {\n\t\tif ((TIPC_SKB_MAX - msg->rep->len) <= 1) {\n\t\t\tchar *tail = skb_tail_pointer(msg->rep);\n\t\t\tif (*tail != '\\0')\n\t\t\t\tsprintf(tail - sizeof(REPLY_TRUNCATED) - 1,\n\t\t\t\t\tREPLY_TRUNCATED);\n\t\t}\n\t\treturn 0;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "tlb_update_vma_flags(struct mmu_gather *tlb, struct vm_area_struct *vma) { }", "target": 1}
{"code": "dhcpv6_print(netdissect_options *ndo,\n             const u_char *cp, u_int length, int indent)\n{\n    u_int i, t;\n    const u_char *tlv, *value;\n    uint16_t type, optlen;\n    i = 0;\n    while (i < length) {\n        if (i + 4 > length)\n            return -1;\n        tlv = cp + i;\n        type = EXTRACT_16BITS(tlv);\n        optlen = EXTRACT_16BITS(tlv + 2);\n        value = tlv + 4;\n        ND_PRINT((ndo, \"\\n\"));\n        for (t = indent; t > 0; t--)\n            ND_PRINT((ndo, \"\\t\"));\n        ND_PRINT((ndo, \"%s\", tok2str(dh6opt_str, \"Unknown\", type)));\n        ND_PRINT((ndo,\" (%u)\", optlen + 4 ));\n        if (i + 4 + optlen > length)\n            return -1;\n        switch (type) {\n            case DH6OPT_DNS_SERVERS:\n            case DH6OPT_SNTP_SERVERS: {\n                if (optlen % 16 != 0) {\n                    ND_PRINT((ndo, \" %s\", istr));\n                    return -1;\n                }\n                for (t = 0; t < optlen; t += 16)\n                    ND_PRINT((ndo, \" %s\", ip6addr_string(ndo, value + t)));\n            }\n                break;\n            case DH6OPT_DOMAIN_LIST: {\n                const u_char *tp = value;\n                while (tp < value + optlen) {\n                    ND_PRINT((ndo, \" \"));\n                    if ((tp = ns_nprint(ndo, tp, value + optlen)) == NULL)\n                        return -1;\n                }\n            }\n                break;\n        }\n        i += 4 + optlen;\n    }\n    return 0;\n}", "target": 0}
{"code": "smtp_get_interface(uschar *istring, int host_af, address_item *addr,\n  uschar **interface, uschar *msg)\n{\nconst uschar * expint;\nuschar *iface;\nint sep = 0;\nif (!istring) return TRUE;\nif (!(expint = expand_string(istring)))\n  {\n  if (f.expand_string_forcedfail) return TRUE;\n  addr->transport_return = PANIC;\n  addr->message = string_sprintf(\"failed to expand \\\"interface\\\" \"\n      \"option for %s: %s\", msg, expand_string_message);\n  return FALSE;\n  }\nwhile (isspace(*expint)) expint++;\nif (*expint == 0) return TRUE;\nwhile ((iface = string_nextinlist(&expint, &sep, big_buffer,\n          big_buffer_size)))\n  {\n  if (string_is_ip_address(iface, NULL) == 0)\n    {\n    addr->transport_return = PANIC;\n    addr->message = string_sprintf(\"\\\"%s\\\" is not a valid IP \"\n      \"address for the \\\"interface\\\" option for %s\",\n      iface, msg);\n    return FALSE;\n    }\n  if (((Ustrchr(iface, ':') == NULL)? AF_INET:AF_INET6) == host_af)\n    break;\n  }\nif (iface) *interface = string_copy(iface);\nreturn TRUE;\n}", "target": 0}
{"code": "  explicit DataFormatDimMapOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n                errors::InvalidArgument(strings::StrCat(\n                    \"Source format must of length 4 or 5, received \"\n                    \"src_format = \",\n                    src_format)));\n    OP_REQUIRES(\n        context, dst_format.size() == 4 || dst_format.size() == 5,\n        errors::InvalidArgument(strings::StrCat(\n            \"Destination format must of length 4 or 5, received dst_format = \",\n            dst_format)));\n    dst_idx_ = Tensor(DT_INT32, {static_cast<int64>(src_format.size())});\n    for (int i = 0; i < src_format.size(); ++i) {\n      for (int j = 0; j < dst_format.size(); ++j) {\n        if (dst_format[j] == src_format[i]) {\n          dst_idx_.vec<int>()(i) = j;\n          break;\n        }\n      }\n    }\n  }", "target": 1}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (val && len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (val && (len > 0 || update)) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  return len;\n}", "target": 0}
{"code": "static int mct_u232_port_probe(struct usb_serial_port *port)\n{\n\tstruct mct_u232_private *priv;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->read_urb = port->serial->port[1]->interrupt_in_urb;\n\tpriv->read_urb->context = port;\n\tspin_lock_init(&priv->lock);\n\tusb_set_serial_port_data(port, priv);\n\treturn 0;\n}", "target": 1}
{"code": "void linsertCommand(client *c) {\n    int where;\n    robj *subject;\n    listTypeIterator *iter;\n    listTypeEntry entry;\n    int inserted = 0;\n    if (strcasecmp(c->argv[2]->ptr,\"after\") == 0) {\n        where = LIST_TAIL;\n    } else if (strcasecmp(c->argv[2]->ptr,\"before\") == 0) {\n        where = LIST_HEAD;\n    } else {\n        addReply(c,shared.syntaxerr);\n        return;\n    }\n    if (sdslen(c->argv[4]->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero)) == NULL ||\n        checkType(c,subject,OBJ_LIST)) return;\n    iter = listTypeInitIterator(subject,0,LIST_TAIL);\n    while (listTypeNext(iter,&entry)) {\n        if (listTypeEqual(&entry,c->argv[3])) {\n            listTypeInsert(&entry,c->argv[4],where);\n            inserted = 1;\n            break;\n        }\n    }\n    listTypeReleaseIterator(iter);\n    if (inserted) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,\"linsert\",\n                            c->argv[1],c->db->id);\n        server.dirty++;\n    } else {\n        addReplyLongLong(c,-1);\n        return;\n    }\n    addReplyLongLong(c,listTypeLength(subject));\n}", "target": 0}
{"code": "MagickExport size_t GetQuantumExtent(const Image *image,\n  const QuantumInfo *quantum_info,const QuantumType quantum_type)\n{\n  size_t\n    extent,\n    packet_size;\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  packet_size=1;\n  switch (quantum_type)\n  {\n    case GrayAlphaQuantum: packet_size=2; break;\n    case IndexAlphaQuantum: packet_size=2; break;\n    case RGBQuantum: packet_size=3; break;\n    case BGRQuantum: packet_size=3; break;\n    case RGBAQuantum: packet_size=4; break;\n    case RGBOQuantum: packet_size=4; break;\n    case BGRAQuantum: packet_size=4; break;\n    case CMYKQuantum: packet_size=4; break;\n    case CMYKAQuantum: packet_size=5; break;\n    case CbYCrAQuantum: packet_size=4; break;\n    case CbYCrQuantum: packet_size=3; break;\n    case CbYCrYQuantum: packet_size=4; break;\n    default: break;\n  }\n  extent=MagickMax(image->columns,image->rows);\n  if (quantum_info->pack == MagickFalse)\n    return((size_t) (packet_size*extent*((quantum_info->depth+7)/8)));\n  return((size_t) ((packet_size*extent*quantum_info->depth+7)/8));\n}", "target": 0}
{"code": "parserule(struct scanner *s, struct environment *env)\n{\n\tstruct rule *r;\n\tchar *var;\n\tstruct evalstring *val;\n\tbool hascommand = false, hasrspfile = false, hasrspcontent = false;\n\tr = mkrule(scanname(s));\n\tscannewline(s);\n\twhile (scanindent(s)) {\n\t\tvar = scanname(s);\n\t\tparselet(s, &val);\n\t\truleaddvar(r, var, val);\n\t\tif (!val)\n\t\t\tcontinue;\n\t\tif (strcmp(var, \"command\") == 0)\n\t\t\thascommand = true;\n\t\telse if (strcmp(var, \"rspfile\") == 0)\n\t\t\thasrspfile = true;\n\t\telse if (strcmp(var, \"rspfile_content\") == 0)\n\t\t\thasrspcontent = true;\n\t}\n\tif (!hascommand)\n\t\tfatal(\"rule '%s' has no command\", r->name);\n\tif (hasrspfile != hasrspcontent)\n\t\tfatal(\"rule '%s' has rspfile and no rspfile_content or vice versa\", r->name);\n\tenvaddrule(env, r);\n}", "target": 0}
{"code": "static bool ParseSparseAccessor(Accessor *accessor, std::string *err,\n                                const json &o) {\n  accessor->sparse.isSparse = true;\n  int count = 0;\n  if (!ParseIntegerProperty(&count, err, o, \"count\", true, \"SparseAccessor\")) {\n    return false;\n  }\n  json_const_iterator indices_iterator;\n  json_const_iterator values_iterator;\n  if (!FindMember(o, \"indices\", indices_iterator)) {\n    (*err) = \"the sparse object of this accessor doesn't have indices\";\n    return false;\n  }\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;\n  accessor->sparse.values.byteOffset = values_byte_offset;\n  return true;\n}", "target": 1}
{"code": "int sldns_str2wire_nsap_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tconst char* s = str;\n\tsize_t slen;\n\tsize_t dlen = 0; \n\tif (s[0] != '0' || s[1] != 'x')\n\t\treturn LDNS_WIREPARSE_ERR_INVALID_STR;\n\ts += 2;\n\tslen = strlen(s);\n\tif(slen > LDNS_MAX_RDFLEN*2)\n\t\treturn LDNS_WIREPARSE_ERR_LABEL_OVERFLOW;\n\twhile(*s) {\n\t\tif(isspace((unsigned char)*s) || *s == '.') {\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!isxdigit((unsigned char)*s))\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_SYNTAX_HEX, s-str);\n\t\tif(*len < dlen/2 + 1)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\ts-str);\n\t\tif((dlen&1)==0)\n\t\t\trd[dlen/2] = (uint8_t)sldns_hexdigit_to_int(*s++) * 16;\n\t\telse\trd[dlen/2] += sldns_hexdigit_to_int(*s++);\n\t\tdlen++;\n\t}\n\tif((dlen&1)!=0)\n\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_SYNTAX_HEX, s-str);\n\t*len = dlen/2;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "file_add_mapi_attrs (File* file, MAPI_Attr** attrs)\n{\n    int i;\n    for (i = 0; attrs[i]; i++)\n    {\n\tMAPI_Attr* a = attrs[i];\n\tif (a->num_values)\n\t{\n\t    switch (a->name)\n\t    {\n\t    case MAPI_ATTACH_LONG_FILENAME:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->name) XFREE(file->name);\n\t\tfile->name = strdup( (char*)a->values[0].data.buf );\n\t\tbreak;\n\t    case MAPI_ATTACH_DATA_OBJ:\n\t\tassert((a->type == szMAPI_BINARY) || (a->type == szMAPI_OBJECT));\n\t\tfile->len = a->values[0].len;\n\t\tif (file->data) XFREE (file->data);\n\t\tfile->data = CHECKED_XMALLOC (unsigned char, file->len);\n\t\tmemmove (file->data, a->values[0].data.buf, file->len);\n\t\tbreak;\n             case MAPI_ATTACH_MIME_TAG:\n\t\tassert(a->type == szMAPI_STRING);\n\t\tif (file->mime_type) XFREE (file->mime_type);\n\t\tfile->mime_type = CHECKED_XMALLOC (char, a->values[0].len);\n\t\tmemmove (file->mime_type, a->values[0].data.buf, a->values[0].len);\n\t\tbreak;\n                case MAPI_ATTACH_CONTENT_ID:\n                    assert(a->type == szMAPI_STRING);\n                    if (file->content_id) XFREE(file->content_id);\n                    file->content_id = CHECKED_XMALLOC (char, a->values[0].len);\n                    memmove (file->content_id, a->values[0].data.buf, a->values[0].len);\n                    break;\n\t    default:\n\t\tbreak;\n\t    }\n\t}\n    }\n}", "target": 0}
{"code": "struct mb2_cache_entry *mb2_cache_entry_find_first(struct mb2_cache *cache,\n\t\t\t\t\t\t   u32 key)\n{\n\treturn __entry_find(cache, NULL, key);\n}", "target": 0}
{"code": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = false;\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n}", "target": 1}
{"code": "static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "void EventPluginsManager::loadPlugin(const QString &pluginId)\n{\n    QPluginLoader loader(\"plasmacalendarplugins/\" + pluginId);\n    if (!loader.load()) {\n        qWarning() << \"Could not create Plasma Calendar Plugin: \" << pluginId;\n        qWarning() << loader.errorString();\n        return;\n    }\n    QObject *obj = loader.instance();\n    if (obj) {\n        CalendarEvents::CalendarEventsPlugin *eventsPlugin = qobject_cast<CalendarEvents::CalendarEventsPlugin *>(obj);\n        if (eventsPlugin) {\n            qDebug() << \"Loading Calendar plugin\" << eventsPlugin;\n            eventsPlugin->setProperty(\"pluginId\", pluginId);\n            d->plugins << eventsPlugin;\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::dataReady, this, &EventPluginsManager::dataReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventModified, this, &EventPluginsManager::eventModified);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventRemoved, this, &EventPluginsManager::eventRemoved);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::alternateCalendarDateReady, this, &EventPluginsManager::alternateCalendarDateReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::subLabelReady, this, &EventPluginsManager::subLabelReady);\n        } else {\n            loader.unload();\n        }\n    } else {\n        loader.unload();\n    }\n}", "target": 1}
{"code": "dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 size;\n\tint end_offset;\n\tif (di->conformant_run)\n\t\treturn offset;\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_keybuffer_size, &size);\n\tend_offset = offset + (size*2);\n\tif (end_offset < offset) {\n\t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n\t}\n\twhile (offset < end_offset)\n\t\toffset = dissect_spoolss_uint16uni(\n\t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n\treturn offset;\n}", "target": 1}
{"code": " static int asymmetric_key_match_preparse(struct key_match_data *match_data)\n {\n \tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = asymmetric_key_cmp;\n \treturn 0;\n }", "target": 0}
{"code": "static int ptrace_setoptions(struct task_struct *child, unsigned long data)\n{\n\tunsigned flags;\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\tflags = child->ptrace;\n\tflags &= ~(PTRACE_O_MASK << PT_OPT_FLAG_SHIFT);\n\tflags |= (data << PT_OPT_FLAG_SHIFT);\n\tchild->ptrace = flags;\n\treturn 0;\n}", "target": 1}
{"code": "crm_send_remote_msg_raw(void *session, const char *buf, size_t len, gboolean encrypted)\n{\n    int rc = -1;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        rc = crm_send_tls(session, buf, len);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        rc = crm_send_plaintext(GPOINTER_TO_INT(session), buf, len);\n    }\n    return rc;\n}", "target": 0}
{"code": "static void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "int wc_SignatureGenerate(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* data, word32 data_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    return wc_SignatureGenerate_ex(hash_type, sig_type, data, data_len, sig,\n        sig_len, key, key_len, rng, 1);\n}", "target": 0}
{"code": "static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tmsg->msg_namelen = 0;\n\tif (u->addr) {\n\t\tmsg->msg_namelen = u->addr->len;\n\t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n\t}\n}", "target": 1}
{"code": "HttpRequest::maybeCacheable()\n{\n    if (!flags.hostVerified && (flags.intercepted || flags.interceptTproxy))\n        return false;\n    switch (url.getScheme()) {\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_HTTPS:\n        if (!method.respMaybeCacheable())\n            return false;\n        if (!flags.ignoreCc && cache_control && cache_control->hasNoStore())\n            return false;\n        break;\n    case AnyP::PROTO_GOPHER:\n        if (!gopherCachable(this))\n            return false;\n        break;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return false;\n    default:\n        break;\n    }\n    return true;\n}", "target": 1}
{"code": "static inline void GetStandardDeviationPixelList(PixelList *pixel_list,\n  Quantum *pixel)\n{\n  double\n    sum,\n    sum_squared;\n  register SkipList\n    *p;\n  size_t\n    color;\n  ssize_t\n    count;\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  sum_squared=0.0;\n  do\n  {\n    register ssize_t\n      i;\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    for (i=0; i < (ssize_t) p->nodes[color].count; i++)\n      sum_squared+=((double) color)*((double) color);\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  sum_squared/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sqrt(sum_squared-(sum*sum)));\n}", "target": 0}
{"code": "void PrivateThreadPoolDatasetOp::MakeDataset(OpKernelContext* ctx,\n                                             DatasetBase* input,\n                                             DatasetBase** output) {\n  int64_t num_threads = 0;\n  OP_REQUIRES_OK(\n      ctx, ParseScalarArgument<int64_t>(ctx, \"num_threads\", &num_threads));\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx, input, num_threads);\n}", "target": 1}
{"code": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}", "target": 1}
{"code": "static int check_client_redirect_uri_valid(struct _oidc_config * config,\n                                           const char * client_id,\n                                           const char * redirect_uri,\n                                           const char * ip_source) {\n  json_t * j_client = config->glewlwyd_config->glewlwyd_plugin_callback_get_client(config->glewlwyd_config, client_id);\n  int uri_found = 0, ret;\n  if (check_result_value(j_client, G_OK) && json_object_get(json_object_get(j_client, \"client\"), \"enabled\") == json_true()) {\n    if (!o_strnullempty(redirect_uri)) {\n      if (json_array_has_string(json_object_get(json_object_get(j_client, \"client\"), \"redirect_uri\"), redirect_uri)) {\n        uri_found = 1;\n      } else {\n        uri_found = 0;\n      }\n    } else {\n      uri_found = 1;\n    }\n    if (!uri_found) {\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_redirect_uri_valid - oidc - Error, redirect_uri '%s' is invalid for the client '%s', origin: %s\", redirect_uri, client_id, ip_source);\n      ret = G_ERROR_UNAUTHORIZED;\n    } else {\n      ret = G_OK;\n    }\n  } else {\n    ret = G_ERROR_UNAUTHORIZED;\n  }\n  json_decref(j_client);\n  return ret;\n}", "target": 1}
{"code": "deltas_head_cleanup(struct deltas_head *list)\n{\n\tsize_t i;\n\tfor (i = 0; i < list->capacity; i++)\n\t\tdelta_head_destroy(list->array[i]);\n\tif (list->array)\n\t\tfree(list->array);\n}", "target": 1}
{"code": "void Curl_ssl_associate_conn(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  if(Curl_ssl->associate_connection) {\n    Curl_ssl->associate_connection(data, conn, FIRSTSOCKET);\n    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n      Curl_ssl->associate_connection(data, conn, SECONDARYSOCKET);\n  }\n}", "target": 0}
{"code": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\twait_for_completion(&fcomp.comp);\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1}
{"code": "static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "int btrfs_scrub_progress(struct btrfs_fs_info *fs_info, u64 devid,\n\t\t\t struct btrfs_scrub_progress *progress)\n{\n\tstruct btrfs_device *dev;\n\tstruct scrub_ctx *sctx = NULL;\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (dev)\n\t\tsctx = dev->scrub_ctx;\n\tif (sctx)\n\t\tmemcpy(progress, &sctx->stat, sizeof(*progress));\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\treturn dev ? (sctx ? 0 : -ENOTCONN) : -ENODEV;\n}", "target": 1}
{"code": "x_order(const active_line *lp1, const active_line *lp2)\n{\n    bool s1;\n    INCR(order);\n    if (!lp1 || !lp2 || lp1->x_current < lp2->x_current)\n        return -1;\n    else if (lp1->x_current > lp2->x_current)\n        return 1;\n    if ((s1 = lp1->start.x < lp1->end.x) != (lp2->start.x < lp2->end.x))\n        return (s1 ? 1 : -1);\n    INCR(slow_order);\n    {\n        fixed dx1 = lp1->end.x - lp1->start.x,\n            dy1 = lp1->end.y - lp1->start.y;\n        fixed dx2 = lp2->end.x - lp2->start.x,\n            dy2 = lp2->end.y - lp2->start.y;\n        double diff = (double)dx1 * dy2 - (double)dx2 * dy1;\n        return (diff < 0 ? -1 : diff > 0 ? 1 : 0);\n    }\n}", "target": 0}
{"code": "void recovery_cipher_init(bool passphrase_protection, bool pin_protection,\n                          const char *language, const char *label, bool _enforce_wordlist,\n                          uint32_t _auto_lock_delay_ms, uint32_t _u2f_counter, bool _dry_run)\n{\n    enforce_wordlist = _enforce_wordlist;\n    dry_run = _dry_run;\n    if (!dry_run) {\n        if (pin_protection) {\n            if (!change_pin()) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_ActionCancelled, \"PINs do not match\");\n                layoutHome();\n                return;\n            }\n        } else {\n            storage_setPin(\"\");\n        }\n        storage_setPassphraseProtected(passphrase_protection);\n        storage_setLanguage(language);\n        storage_setLabel(label);\n        storage_setAutoLockDelayMs(_auto_lock_delay_ms);\n        storage_setU2FCounter(_u2f_counter);\n    } else if (!pin_protect(\"Enter Your PIN\")) {\n        layoutHome();\n        return;\n    }\n    if (!confirm(ButtonRequestType_ButtonRequest_Other,\n                 dry_run ? \"Recovery Dry Run\" : \"Recovery\",\n                 \"When entering your recovery seed, use the substitution cipher \"\n                 \"and check that each word shows up correctly on the screen.\")) {\n        fsm_sendFailure(FailureType_Failure_ActionCancelled, \"Recovery cancelled\");\n        if (!dry_run)\n            storage_reset();\n        layoutHome();\n        return;\n    }\n    memset(mnemonic, 0, sizeof(mnemonic) / sizeof(char));\n    awaiting_character = true;\n    recovery_started = true;\n    next_character();\n}", "target": 0}
{"code": "static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {\n        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;\n        AsyncPolkitQuery *q = userdata;\n        int r;\n        assert(reply);\n        assert(q);\n        assert(q->slot);\n        q->slot = sd_bus_slot_unref(q->slot);\n        assert(!q->reply);\n        q->reply = sd_bus_message_ref(reply);\n        assert(!q->defer_event_source);\n        r = sd_event_add_defer(sd_bus_get_event(sd_bus_message_get_bus(reply)), &q->defer_event_source, async_polkit_defer, q);\n        if (r < 0)\n                goto fail;\n        r = sd_event_source_set_priority(q->defer_event_source, SD_EVENT_PRIORITY_IDLE);\n        if (r < 0)\n                goto fail;\n        r = sd_event_source_set_enabled(q->defer_event_source, SD_EVENT_ONESHOT);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0)\n                goto fail;\n        r = sd_bus_enqueue_for_read(sd_bus_message_get_bus(q->request), q->request);\n        if (r < 0)\n                goto fail;\n        return 1;\nfail:\n        log_debug_errno(r, \"Processing asynchronous PolicyKit reply failed, ignoring: %m\");\n        (void) sd_bus_reply_method_errno(q->request, r, NULL);\n        async_polkit_query_free(q);\n        return r;\n}", "target": 0}
{"code": "Status OpLevelCostEstimator::PredictFusedBatchNorm(\n    const OpContext& op_context, NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  const bool is_training = IsTraining(op_info);\n  int64_t ops = 0;\n  const auto rsqrt_cost = Eigen::internal::functor_traits<\n      Eigen::internal::scalar_rsqrt_op<float>>::Cost;\n  if (is_training) {\n    ops = dims.iz * (dims.batch * dims.ix * dims.iy * 4 + 6 + rsqrt_cost);\n  } else {\n    ops = dims.batch * dims.ix * dims.iy * dims.iz * 2;\n  }\n  node_costs->num_compute_ops = ops;\n  const int64_t size_nhwc =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  const int64_t size_c =\n      CalculateTensorSize(op_info.inputs(1), &found_unknown_shapes);\n  if (is_training) {\n    node_costs->num_input_bytes_accessed = {size_nhwc, size_c, size_c};\n    node_costs->num_output_bytes_accessed = {size_nhwc, size_c, size_c, size_c,\n                                             size_c};\n    node_costs->internal_read_bytes = size_nhwc;\n  } else {\n    node_costs->num_input_bytes_accessed = {size_nhwc, size_c, size_c, size_c,\n                                            size_c};\n    node_costs->num_output_bytes_accessed = {size_nhwc};\n  }\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); \n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); \n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,\n\t                                     irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\treturn irp->Complete(irp);\n}", "target": 0}
{"code": "void Triangle(double x1,double y1,double x2,double y2,double x3,double y3) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f m %12.3f %12.3f l %12.3f %12.3f l h\",x1,y1,x2,y2,x3,y3);\n}", "target": 1}
{"code": "static uint8_t avrcp_handle_abort_continuing(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tuint16_t len = ntohs(pdu->params_len);\n\tstruct pending_pdu *pending;\n\tif (len != 1 || session->pending_pdu == NULL)\n\t\tgoto err;\n\tpending = session->pending_pdu;\n\tif (pending->pdu_id != pdu->params[0])\n\t\tgoto err;\n\tsession_abort_pending_pdu(session);\n\tpdu->params_len = 0;\n\treturn AVC_CTYPE_ACCEPTED;\nerr:\n\tpdu->params_len = htons(1);\n\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\treturn AVC_CTYPE_REJECTED;\n}", "target": 0}
{"code": "void init_xml_schema()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"Schema\", rb_cObject);\n  cNokogiriXmlSchema = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n  rb_define_private_method(klass, \"validate_file\",     validate_file, 1);\n}", "target": 1}
{"code": "_PUBLIC_ char *fgets_slash(char *s2,int maxlen,XFILE *f)\n{\n  char *s=s2;\n  int len = 0;\n  int c;\n  bool start_of_line = true;\n  if (x_feof(f))\n    return(NULL);\n  if (maxlen <2) return(NULL);\n  if (!s2)\n    {\n      maxlen = MIN(maxlen,8);\n      s = (char *)malloc(maxlen);\n    }\n  if (!s) return(NULL);\n  *s = 0;\n  while (len < maxlen-1)\n    {\n      c = x_getc(f);\n      switch (c)\n\t{\n\tcase '\\r':\n\t  break;\n\tcase '\\n':\n\t  while (len > 0 && s[len-1] == ' ')\n\t    {\n\t      s[--len] = 0;\n\t    }\n\t  if (len > 0 && s[len-1] == '\\\\')\n\t    {\n\t      s[--len] = 0;\n\t      start_of_line = true;\n\t      break;\n\t    }\n\t  return(s);\n\tcase EOF:\n\t  if (len <= 0 && !s2) \n\t    SAFE_FREE(s);\n\t  return(len>0?s:NULL);\n\tcase ' ':\n\t  if (start_of_line)\n\t    break;\n\tdefault:\n\t  start_of_line = false;\n\t  s[len++] = c;\n\t  s[len] = 0;\n\t}\n      if (!s2 && len > maxlen-3)\n\t{\n\t  char *t;\n\t  maxlen *= 2;\n\t  t = realloc_p(s, char, maxlen);\n\t  if (!t) {\n\t    DEBUG(0,(\"fgets_slash: failed to expand buffer!\\n\"));\n\t    SAFE_FREE(s);\n\t    return(NULL);\n\t  } else s = t;\n\t}\n    }\n  return(s);\n}", "target": 0}
{"code": "static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n    int ret = 0;\n\tif (im == NULL) {\n\t\treturn 1;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Palette image not supported by webp\");\n\t\treturn 1;\n\t}\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn 1;\n\t}\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn 1;\n\t}\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn 1;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n        ret = 1;\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n    return ret;\n}", "target": 0}
{"code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\tline += PKT_LEN_SIZE;\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}", "target": 0}
{"code": "void InitCodec(const vpx_codec_iface_t &iface, int width, int height,\n               vpx_codec_ctx_t *enc, vpx_codec_enc_cfg_t *cfg) {\n  ASSERT_EQ(vpx_codec_enc_config_default(&iface, cfg, 0), VPX_CODEC_OK);\n  cfg->g_w = width;\n  cfg->g_h = height;\n  cfg->g_lag_in_frames = 0;\n  cfg->g_pass = VPX_RC_ONE_PASS;\n  ASSERT_EQ(vpx_codec_enc_init(enc, &iface, cfg, 0), VPX_CODEC_OK);\n  ASSERT_EQ(vpx_codec_control_(enc, VP8E_SET_CPUUSED, 2), VPX_CODEC_OK);\n}", "target": 1}
{"code": "void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tpreempt_disable();\n\tif (current->active_mm == mm) {\n\t\tif (current->mm)\n\t\t\t__flush_tlb_one(start);\n\t\telse\n\t\t\tleave_mm(smp_processor_id());\n\t}\n\tif (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)\n\t\tflush_tlb_others(mm_cpumask(mm), mm, start, 0UL);\n\tpreempt_enable();\n}", "target": 1}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}", "target": 1}
{"code": "static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, Stream_Pointer(irp->input), Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "static inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\tfollow_dotdot(nd);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,\n\t\t\t\t       u64 devid, u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\twhile (fs_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) {\n\t\t\tdevice = find_device(fs_devices, devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tfs_devices = fs_devices->seed;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void AverageEvalQuantizedInt8(TfLiteContext* context, TfLiteNode* node,\n                              TfLitePoolParams* params, OpData* data,\n                              const TfLiteTensor* input, TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                        \\\n  tflite::PoolParams op_params;                                           \\\n  op_params.stride_height = params->stride_height;                        \\\n  op_params.stride_width = params->stride_width;                          \\\n  op_params.filter_height = params->filter_height;                        \\\n  op_params.filter_width = params->filter_width;                          \\\n  op_params.padding_values.height = data->padding.height;                 \\\n  op_params.padding_values.width = data->padding.width;                   \\\n  op_params.quantized_activation_min = activation_min;                    \\\n  op_params.quantized_activation_max = activation_max;                    \\\n  type::AveragePool(op_params, GetTensorShape(input),                     \\\n                    GetTensorData<int8_t>(input), GetTensorShape(output), \\\n                    GetTensorData<int8_t>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_integer_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_integer_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    result = (CONSTBUFFER_HANDLE)calloc(1, (sizeof(CONSTBUFFER_HANDLE_DATA) + size));\n    if (result == NULL)\n    {\n        LogError(\"unable to malloc\");\n    }\n    else\n    {\n        INIT_REF_VAR(result->count);\n        result->alias.size = size;\n        if (size == 0)\n        {\n            result->alias.buffer = NULL;\n        }\n        else\n        {\n            unsigned char* temp = (unsigned char*)(result + 1);\n            (void)memcpy(temp, source, size);\n            result->alias.buffer = temp;\n        }\n        result->buffer_type = CONSTBUFFER_TYPE_COPIED;\n    }\n    return result;\n}", "target": 1}
{"code": "int bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}", "target": 1}
{"code": "int check_directory(struct dir *dir)\n{\n\tint i;\n\tstruct dir_ent *ent;\n\tif(dir->dir_count < 2)\n\t\treturn TRUE;\n\tfor(ent = dir->dirs, i = 0; i < dir->dir_count - 1; ent = ent->next, i++)\n\t\tif(strcmp(ent->name, ent->next->name) >= 0)\n\t\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "void CmdExtract::ExtractArchiveInit(Archive &Arc)\n{\n  DataIO.AdjustTotalArcSize(&Arc);\n  FileCount=0;\n  MatchedArgs=0;\n#ifndef SFX_MODULE\n  FirstFile=true;\n#endif\n  GlobalPassword=Cmd->Password.IsSet() || uiIsGlobalPasswordSet();\n  DataIO.UnpVolume=false;\n  PrevProcessed=false;\n  AllMatchesExact=true;\n  AnySolidDataUnpackedWell=false;\n  ArcAnalyzed=false;\n  StartTime.SetCurrentTime();\n  LastCheckedSymlink.clear();\n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui16le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8);\n}", "target": 1}
{"code": "static void dump_completed_IO(struct inode * inode)\n{\n#ifdef\tEXT4_DEBUG\n\tstruct list_head *cur, *before, *after;\n\text4_io_end_t *io, *io0, *io1;\n\tunsigned long flags;\n\tif (list_empty(&EXT4_I(inode)->i_completed_io_list)){\n\t\text4_debug(\"inode %lu completed_io list is empty\\n\", inode->i_ino);\n\t\treturn;\n\t}\n\text4_debug(\"Dump inode %lu completed_io list \\n\", inode->i_ino);\n\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n\tlist_for_each_entry(io, &EXT4_I(inode)->i_completed_io_list, list){\n\t\tcur = &io->list;\n\t\tbefore = cur->prev;\n\t\tio0 = container_of(before, ext4_io_end_t, list);\n\t\tafter = cur->next;\n\t\tio1 = container_of(after, ext4_io_end_t, list);\n\t\text4_debug(\"io 0x%p from inode %lu,prev 0x%p,next 0x%p\\n\",\n\t\t\t    io, inode->i_ino, io0, io1);\n\t}\n\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n#endif\n}", "target": 0}
{"code": "static BOOL recurse_check_bit(compiler_common *common, sljit_sw bit_index)\n{\nuint8_t *byte;\nuint8_t mask;\nSLJIT_ASSERT((bit_index & (sizeof(sljit_sw) - 1)) == 0);\nbit_index >>= SLJIT_WORD_SHIFT;\nmask = 1 << (bit_index & 0x7);\nbyte = common->recurse_bitset + (bit_index >> 3);\nif (*byte & mask)\n  return FALSE;\n*byte |= mask;\nreturn TRUE;\n}", "target": 0}
{"code": "Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,\n                                  int input_index) {\n  if (output_index >= src->num_outputs()) {\n    return errors::InvalidArgument(\n        \"Output \", output_index, \" of node \", src->name(),\n        \" does not exist. Node only has \", src->num_outputs(), \" outputs.\");\n  }\n  if (input_index >= dst->num_inputs()) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(),\n        \" does not exist. Node only has \", dst->num_inputs(), \" inputs.\");\n  }\n  DataType src_out = src->output_type(output_index);\n  DataType dst_in = dst->input_type(input_index);\n  if (!TypesCompatible(dst_in, src_out)) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(), \" was passed \",\n        DataTypeString(src_out), \" from \", src->name(), \":\", output_index,\n        \" incompatible with expected \", DataTypeString(dst_in), \".\");\n  }\n  g_->AddEdge(src, output_index, dst, input_index);\n  return Status::OK();\n}", "target": 0}
{"code": "static u32 gasp_specifier_id(__be32 *p)\n{\n\treturn (be32_to_cpu(p[0]) & 0xffff) << 8 |\n\t       (be32_to_cpu(p[1]) & 0xff000000) >> 24;\n}", "target": 0}
{"code": "mrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb->nil_class;\n    return mrb->false_class;\n  case MRB_TT_TRUE:\n    return mrb->true_class;\n  case MRB_TT_CPTR:\n  case MRB_TT_SYMBOL:\n  case MRB_TT_INTEGER:\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    return NULL;\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  if (obj->c == NULL) return NULL;\n  prepare_singleton_class(mrb, obj);\n  return obj->c;\n}", "target": 0}
{"code": "static inline ut64 dwarf_read_offset(bool is_64bit, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (is_64bit) {\n\t\tresult = READ64 (*buf);\n\t} else {\n\t\tresult = READ32 (*buf);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "check_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    iterate_rc4(O_data, key_bytes, key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;\n}", "target": 1}
{"code": "static struct full_stripe_lock *search_full_stripe_lock(\n\t\tstruct btrfs_full_stripe_locks_tree *locks_root,\n\t\tu64 fstripe_logical)\n{\n\tstruct rb_node *node;\n\tstruct full_stripe_lock *entry;\n\tlockdep_assert_held(&locks_root->lock);\n\tnode = locks_root->root.rb_node;\n\twhile (node) {\n\t\tentry = rb_entry(node, struct full_stripe_lock, node);\n\t\tif (fstripe_logical < entry->logical)\n\t\t\tnode = node->rb_left;\n\t\telse if (fstripe_logical > entry->logical)\n\t\t\tnode = node->rb_right;\n\t\telse\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void AverageEvalQuantizedInt16(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  CalculateActivationRangeQuantized(context, params->activation, output,\n                                    &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<int16_t>(input), GetTensorShape(output), \\\n                    GetTensorData<int16_t>(output))\n  TF_LITE_AVERAGE_POOL(reference_integer_ops);\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "xfs_lock_inodes(\n\tstruct xfs_inode\t**ips,\n\tint\t\t\tinodes,\n\tuint\t\t\tlock_mode)\n{\n\tint\t\t\tattempts = 0, i, j, try_lock;\n\tstruct xfs_log_item\t*lp;\n\tASSERT(ips && inodes >= 2 && inodes <= 5);\n\tASSERT(lock_mode & (XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL |\n\t\t\t    XFS_ILOCK_EXCL));\n\tASSERT(!(lock_mode & (XFS_IOLOCK_SHARED | XFS_MMAPLOCK_SHARED |\n\t\t\t      XFS_ILOCK_SHARED)));\n\tASSERT(!(lock_mode & XFS_MMAPLOCK_EXCL) ||\n\t\tinodes <= XFS_MMAPLOCK_MAX_SUBCLASS + 1);\n\tASSERT(!(lock_mode & XFS_ILOCK_EXCL) ||\n\t\tinodes <= XFS_ILOCK_MAX_SUBCLASS + 1);\n\tif (lock_mode & XFS_IOLOCK_EXCL) {\n\t\tASSERT(!(lock_mode & (XFS_MMAPLOCK_EXCL | XFS_ILOCK_EXCL)));\n\t} else if (lock_mode & XFS_MMAPLOCK_EXCL)\n\t\tASSERT(!(lock_mode & XFS_ILOCK_EXCL));\n\ttry_lock = 0;\n\ti = 0;\nagain:\n\tfor (; i < inodes; i++) {\n\t\tASSERT(ips[i]);\n\t\tif (i && (ips[i] == ips[i - 1]))\t\n\t\t\tcontinue;\n\t\tif (!try_lock) {\n\t\t\tfor (j = (i - 1); j >= 0 && !try_lock; j--) {\n\t\t\t\tlp = &ips[j]->i_itemp->ili_item;\n\t\t\t\tif (lp && test_bit(XFS_LI_IN_AIL, &lp->li_flags))\n\t\t\t\t\ttry_lock++;\n\t\t\t}\n\t\t}\n\t\tif (!try_lock) {\n\t\t\txfs_ilock(ips[i], xfs_lock_inumorder(lock_mode, i));\n\t\t\tcontinue;\n\t\t}\n\t\tASSERT(i != 0);\n\t\tif (xfs_ilock_nowait(ips[i], xfs_lock_inumorder(lock_mode, i)))\n\t\t\tcontinue;\n\t\tattempts++;\n\t\tfor (j = i - 1; j >= 0; j--) {\n\t\t\tif (j != (i - 1) && ips[j] == ips[j + 1])\n\t\t\t\tcontinue;\n\t\t\txfs_iunlock(ips[j], lock_mode);\n\t\t}\n\t\tif ((attempts % 5) == 0) {\n\t\t\tdelay(1); \n\t\t}\n\t\ti = 0;\n\t\ttry_lock = 0;\n\t\tgoto again;\n\t}\n}", "target": 0}
{"code": "static int fill_autodev(const struct lxc_rootfs *rootfs)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\tINFO(\"Creating initial consoles under container /dev\");\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\tif (!dir_exists(path))  \n\t\treturn 0;\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->err_code = buf[6] * 100 + buf[7];\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    if (value.slen < 0)\n        value.slen = 0;\n    pj_strdup(pool, &attr->reason, &value);\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\tpvclock_update_vm_gtod_copy(kvm);\n\treturn 0;\n}", "target": 0}
{"code": "int writeToFile(PlatformFileHandle handle, const char* data, int length)\n{\n    if (!isHandleValid(handle))\n        return -1;\n    DWORD bytesWritten;\n    bool success = WriteFile(handle, data, length, &bytesWritten, 0);\n    if (!success)\n        return -1;\n    return static_cast<int>(bytesWritten);\n}", "target": 0}
{"code": "void __init acpi_debugfs_init(void)\n{\n\tacpi_debugfs_dir = debugfs_create_dir(\"acpi\", NULL);\n\tacpi_custom_method_init();\n}", "target": 1}
{"code": "http_splitline(struct worker *w, int fd, struct http *hp,\n    const struct http_conn *htc, int h1, int h2, int h3)\n{\n\tchar *p, *q;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\tTcheck(htc->rxbuf);\n\tfor (p = htc->rxbuf.b ; vct_islws(*p); p++)\n\t\tcontinue;\n\tq = p;\n\tfor (; !vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\thp->hd[h1].b = q;\n\thp->hd[h1].e = p;\n\tfor (; vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\tq = p;\n\tfor (; !vct_islws(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\thp->hd[h2].b = q;\n\thp->hd[h2].e = p;\n\tif (!Tlen(hp->hd[h2]))\n\t\treturn (400);\n\tfor (; vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\tq = p;\n\tif (!vct_iscrlf(*p)) {\n\t\tfor (; !vct_iscrlf(*p); p++)\n\t\t\tif (!vct_issep(*p) && vct_isctl(*p))\n\t\t\t\treturn (400);\n\t}\n\thp->hd[h3].b = q;\n\thp->hd[h3].e = p;\n\tp += vct_skipcrlf(p);\n\t*hp->hd[h1].e = '\\0';\n\tWSLH(w, fd, hp, h1);\n\t*hp->hd[h2].e = '\\0';\n\tWSLH(w, fd, hp, h2);\n\tif (hp->hd[h3].e != NULL) {\n\t\t*hp->hd[h3].e = '\\0';\n\t\tWSLH(w, fd, hp, h3);\n\t}\n\treturn (http_dissect_hdrs(w, hp, fd, p, htc));\n}", "target": 1}
{"code": "static __be16 cma_port(const struct sockaddr *addr)\n{\n\tstruct sockaddr_ib *sib;\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\treturn ((struct sockaddr_in *) addr)->sin_port;\n\tcase AF_INET6:\n\t\treturn ((struct sockaddr_in6 *) addr)->sin6_port;\n\tcase AF_IB:\n\t\tsib = (struct sockaddr_ib *) addr;\n\t\treturn htons((u16) (be64_to_cpu(sib->sib_sid) &\n\t\t\t\t    be64_to_cpu(sib->sib_sid_mask)));\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "static TEE_Result do_allocate_publickey(struct rsa_public_key *key,\n\t\t\t\t\tsize_t size_bits)\n{\n\tRSA_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->e = crypto_bignum_allocate(MAX_BITS_EXP_E);\n\tif (!key->e)\n\t\tgoto err_alloc_publickey;\n\tkey->n = crypto_bignum_allocate(size_bits);\n\tif (!key->n)\n\t\tgoto err_alloc_publickey;\n\treturn TEE_SUCCESS;\nerr_alloc_publickey:\n\tRSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "option_persist_cb (const gchar *option_name,\n                   const gchar *value,\n                   gpointer     data,\n                   GError     **error)\n{\n  FlatpakContext *context = data;\n  flatpak_context_set_persistent (context, value);\n  return TRUE;\n}", "target": 1}
{"code": "static Status ValidateKernelSizes(const T& ksizes) {\n  for (size_t i = 0; i < ksizes.size(); ++i) {\n    if (ksizes[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window ksize field for dimension \", i,\n          \" must be positive but is \", ksizes[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "static int count_paired_channels(uint8_t (*layout_map)[3], int tags, int pos,\n                                 int *current)\n{\n    int num_pos_channels = 0;\n    int first_cpe        = 0;\n    int sce_parity       = 0;\n    int i;\n    for (i = *current; i < tags; i++) {\n        if (layout_map[i][2] != pos)\n            break;\n        if (layout_map[i][0] == TYPE_CPE) {\n            if (sce_parity) {\n                if (pos == AAC_CHANNEL_FRONT && !first_cpe) {\n                    sce_parity = 0;\n                } else {\n                    return -1;\n                }\n            }\n            num_pos_channels += 2;\n            first_cpe         = 1;\n        } else {\n            num_pos_channels++;\n            sce_parity ^= 1;\n        }\n    }\n    if (sce_parity &&\n        ((pos == AAC_CHANNEL_FRONT && first_cpe) || pos == AAC_CHANNEL_SIDE))\n        return -1;\n    *current = i;\n    return num_pos_channels;\n}", "target": 0}
{"code": " */\nstatic enum hrtimer_restart bfq_idle_slice_timer(struct hrtimer *timer)\n{\n\tstruct bfq_data *bfqd = container_of(timer, struct bfq_data,\n\t\t\t\t\t     idle_slice_timer);\n\tstruct bfq_queue *bfqq = bfqd->in_service_queue;\n\tif (bfqq)\n\t\tbfq_idle_slice_timer_body(bfqq);\n\treturn HRTIMER_NORESTART;", "target": 1}
{"code": "int create_flush_cmd_control(struct f2fs_sb_info *sbi)\n{\n\tdev_t dev = sbi->sb->s_bdev->bd_dev;\n\tstruct flush_cmd_control *fcc;\n\tint err = 0;\n\tif (SM_I(sbi)->fcc_info) {\n\t\tfcc = SM_I(sbi)->fcc_info;\n\t\tgoto init_thread;\n\t}\n\tfcc = kzalloc(sizeof(struct flush_cmd_control), GFP_KERNEL);\n\tif (!fcc)\n\t\treturn -ENOMEM;\n\tatomic_set(&fcc->issued_flush, 0);\n\tatomic_set(&fcc->issing_flush, 0);\n\tinit_waitqueue_head(&fcc->flush_wait_queue);\n\tinit_llist_head(&fcc->issue_list);\n\tSM_I(sbi)->fcc_info = fcc;\n\tif (!test_opt(sbi, FLUSH_MERGE))\n\t\treturn err;\ninit_thread:\n\tfcc->f2fs_issue_flush = kthread_run(issue_flush_thread, sbi,\n\t\t\t\t\"f2fs_flush-%u:%u\", MAJOR(dev), MINOR(dev));\n\tif (IS_ERR(fcc->f2fs_issue_flush)) {\n\t\terr = PTR_ERR(fcc->f2fs_issue_flush);\n\t\tkfree(fcc);\n\t\tSM_I(sbi)->fcc_info = NULL;\n\t\treturn err;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                BatchToSpaceNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int* crops = GetTensorData<int32>(op_context->crops);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->crops), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->crops->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->crops->dims->data[1], 2);\n  for (int i = 0; i < spatial_dims_num * 2; ++i) {\n    TF_LITE_ENSURE(context, crops[i] >= 0);\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    TF_LITE_ENSURE(context, block_shape[dim] != 0);\n    TF_LITE_ENSURE_EQ(context, output_batch_size % block_shape[dim], 0);\n    output_batch_size = output_batch_size / block_shape[dim];\n    output_size->data[dim + 1] = input_size->data[dim + 1] * block_shape[dim] -\n                                 crops[dim * 2] - crops[dim * 2 + 1];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 0}
{"code": "static bool ctx_single_port_submission(const struct intel_context *ce)\n{\n\treturn (IS_ENABLED(CONFIG_DRM_I915_GVT) &&\n\t\ti915_gem_context_force_single_submission(ce->gem_context));\n}", "target": 0}
{"code": "static int n_tty_ioctl(struct tty_struct *tty, struct file *file,\n\t\t       unsigned int cmd, unsigned long arg)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint retval;\n\tswitch (cmd) {\n\tcase TIOCOUTQ:\n\t\treturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\n\tcase TIOCINQ:\n\t\tdown_write(&tty->termios_rwsem);\n\t\tif (L_ICANON(tty))\n\t\t\tretval = inq_canon(ldata);\n\t\telse\n\t\t\tretval = read_cnt(ldata);\n\t\tup_write(&tty->termios_rwsem);\n\t\treturn put_user(retval, (unsigned int __user *) arg);\n\tdefault:\n\t\treturn n_tty_ioctl_helper(tty, file, cmd, arg);\n\t}\n}", "target": 1}
{"code": "static int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs;\n\tstruct inode *inode = page->mapping->host;\n\ttrace_ext4_writepage(inode, page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tif (page_has_buffers(page)) {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tret = block_prepare_write(page, 0, len,\n\t\t\t\t\t  noalloc_get_block_write);\n\t\tif (!ret) {\n\t\t\tpage_bufs = page_buffers(page);\n\t\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tunlock_page(page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tblock_commit_write(page, 0, len);\n\t}\n\tif (PageChecked(page) && ext4_should_journal_data(inode)) {\n\t\tClearPageChecked(page);\n\t\treturn __ext4_journalled_writepage(page, len);\n\t}\n\tif (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))\n\t\tret = nobh_writepage(page, noalloc_get_block_write, wbc);\n\telse\n\t\tret = block_write_full_page(page, noalloc_get_block_write,\n\t\t\t\t\t    wbc);\n\treturn ret;\n}", "target": 1}
{"code": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n    if (url == NULL) {\n        return HTTP_BAD_REQUEST;\n    }\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n        if (*i == '\\\\') {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Backslash character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n    if (strstr(url, \"\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"URL starts with '\n        return HTTP_BAD_REQUEST;\n    }\n    return OK;\n}", "target": 0}
{"code": "RAMBlock *qemu_ram_alloc_from_ptr(struct uc_struct *uc, ram_addr_t size, void *host,\n                                   MemoryRegion *mr)\n{\n    RAMBlock *new_block;\n    ram_addr_t max_size = size;\n    size = HOST_PAGE_ALIGN(uc, size);\n    max_size = HOST_PAGE_ALIGN(uc, max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    if (new_block == NULL)\n        return NULL;\n    new_block->mr = mr;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->page_size = uc->qemu_real_host_page_size;\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n    uc->invalid_addr = UC_ERR_OK;\n    ram_block_add(mr->uc, new_block);\n    if (uc->invalid_error != UC_ERR_OK) {\n        g_free(new_block);\n        return NULL;\n    }\n    return new_block;\n}", "target": 0}
{"code": "RecordConvertRangesToIntervals(SetInfoPtr psi,\n                               xRecordRange * pRanges,\n                               int nRanges,\n                               int byteoffset,\n                               SetInfoPtr pExtSetInfo, int *pnExtSetInfo)\n{\n    int i;\n    CARD8 *pCARD8;\n    int first, last;\n    int err;\n    for (i = 0; i < nRanges; i++, pRanges++) {\n        pCARD8 = ((CARD8 *) pRanges) + byteoffset;\n        first = pCARD8[0];\n        last = pCARD8[1];\n        if (first || last) {\n            if (!psi->intervals) {\n                err = RecordAllocIntervals(psi, 2 * (nRanges - i));\n                if (err != Success)\n                    return err;\n            }\n            psi->intervals[psi->nintervals].first = first;\n            psi->intervals[psi->nintervals].last = last;\n            psi->nintervals++;\n            assert(psi->nintervals <= psi->size);\n            if (pExtSetInfo) {\n                SetInfoPtr pesi = pExtSetInfo;\n                CARD16 *pCARD16 = (CARD16 *) (pCARD8 + 2);\n                int j;\n                for (j = 0; j < *pnExtSetInfo; j++, pesi++) {\n                    if ((first == pesi->first) && (last == pesi->last))\n                        break;\n                }\n                if (j == *pnExtSetInfo) {\n                    err = RecordAllocIntervals(pesi, 2 * (nRanges - i));\n                    if (err != Success)\n                        return err;\n                    pesi->first = first;\n                    pesi->last = last;\n                    (*pnExtSetInfo)++;\n                }\n                pesi->intervals[pesi->nintervals].first = pCARD16[0];\n                pesi->intervals[pesi->nintervals].last = pCARD16[1];\n                pesi->nintervals++;\n                assert(pesi->nintervals <= pesi->size);\n            }\n        }\n    }\n    return Success;\n}                               ", "target": 0}
{"code": "ikev2_auth_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_auth a;\n\tconst char *v2_auth[]={ \"invalid\", \"rsasig\",\n\t\t\t\t\"shared-secret\", \"dsssig\" };\n\tconst u_char *authdata = (const u_char*)ext + sizeof(a);\n\tunsigned int len;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&a, ext, sizeof(a));\n\tikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);\n\tlen = ntohs(a.h.len);\n\tND_PRINT((ndo,\" len=%d method=%s\", len-4,\n\t\t  STR_OR_ID(a.auth_method, v2_auth)));\n\tif (1 < ndo->ndo_vflag && 4 < len) {\n\t\tND_PRINT((ndo,\" authdata=(\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo,\") \"));\n\t} else if(ndo->ndo_vflag && 4 < len) {\n\t\tif(!ike_show_somedata(ndo, authdata, ep)) goto trunc;\n\t}\n\treturn (const u_char *)ext + len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "void rdma_lock_handler(struct rdma_cm_id *id)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(id, struct rdma_id_private, id);\n\tmutex_lock(&id_priv->handler_mutex);\n}", "target": 0}
{"code": "static void dtls1_clear_queues(SSL *s)\n\t{\n    pitem *item = NULL;\n    hm_fragment *frag = NULL;\n\tDTLS1_RECORD_DATA *rdata;\n    while( (item = pqueue_pop(s->d1->unprocessed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->processed_rcds.q)) != NULL)\n        {\n\t\trdata = (DTLS1_RECORD_DATA *) item->data;\n\t\tif (rdata->rbuf.buf)\n\t\t\t{\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\t\t}\n        OPENSSL_free(item->data);\n        pitem_free(item);\n        }\n    while( (item = pqueue_pop(s->d1->buffered_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n    while ( (item = pqueue_pop(s->d1->sent_messages)) != NULL)\n        {\n        frag = (hm_fragment *)item->data;\n        OPENSSL_free(frag->fragment);\n        OPENSSL_free(frag);\n        pitem_free(item);\n        }\n\twhile ( (item = pqueue_pop(s->d1->buffered_app_data.q)) != NULL)\n\t\t{\n\t\tfrag = (hm_fragment *)item->data;\n\t\tOPENSSL_free(frag->fragment);\n\t\tOPENSSL_free(frag);\n\t\tpitem_free(item);\n\t\t}\n\t}", "target": 1}
{"code": "static inline int ldsem_cmpxchg(long *old, long new, struct ld_semaphore *sem)\n{\n\tlong tmp = *old;\n\t*old = atomic_long_cmpxchg(&sem->count, *old, new);\n\treturn *old == tmp;\n}", "target": 1}
{"code": "void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext)\n{\n    std::string real_rule;\n    if(startsWith(rule, \"[]\") && add_direct)\n    {\n        filtered_nodelist.emplace_back(rule.substr(2));\n    }\n#ifndef NO_JS_RUNTIME\n    else if(startsWith(rule, \"script:\"))\n    {\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){\n            std::string script = fileGet(rule.substr(7), true);\n            try\n            {\n                ctx.eval(script);\n                auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(\"filter\");\n                std::string result_list = filter(nodelist);\n                filtered_nodelist = split(regTrim(result_list), \"\\n\");\n            }\n            catch (qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n#endif \n    else\n    {\n        for(Proxy &x : nodelist)\n        {\n            if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end())\n                filtered_nodelist.emplace_back(x.Remark);\n        }\n    }\n}", "target": 1}
{"code": "TfLiteStatus ExpandTensorDim(TfLiteContext* context, const TfLiteTensor& input,\n                             int axis, TfLiteTensor* output) {\n  const TfLiteIntArray& input_dims = *input.dims;\n  if (axis < 0) {\n    axis = input_dims.size + 1 + axis;\n  }\n  TF_LITE_ENSURE(context, axis <= input_dims.size);\n  TF_LITE_ENSURE(context, axis >= 0);\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(input_dims.size + 1);\n  for (int i = 0; i < output_dims->size; ++i) {\n    if (i < axis) {\n      output_dims->data[i] = input_dims.data[i];\n    } else if (i == axis) {\n      output_dims->data[i] = 1;\n    } else {\n      output_dims->data[i] = input_dims.data[i - 1];\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 0}
{"code": "void rose_del_loopback_node(const rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\tspin_lock_bh(&rose_node_list_lock);\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t    (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t    rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\tif (rose_node == NULL)\n\t\tgoto out;\n\trose_remove_node(rose_node);\n\trose_loopback_neigh->count--;\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n}", "target": 0}
{"code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}", "target": 1}
{"code": "delta_head_create(struct delta_head **result)\n{\n\tstruct delta_head *tmp;\n\ttmp = malloc(sizeof(struct delta_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdoc_data_init(&tmp->doc_data);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t cm_write(struct file *file, const char __user * user_buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstatic char *buf;\n\tstatic u32 max_size;\n\tstatic u32 uncopied_bytes;\n\tstruct acpi_table_header table;\n\tacpi_status status;\n\tif (!(*ppos)) {\n\t\tif (count <= sizeof(struct acpi_table_header))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&table, user_buf,\n\t\t\t\t   sizeof(struct acpi_table_header)))\n\t\t\treturn -EFAULT;\n\t\tuncopied_bytes = max_size = table.length;\n\t\tbuf = kzalloc(max_size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\tif ((*ppos > max_size) ||\n\t    (*ppos + count > max_size) ||\n\t    (*ppos + count < count) ||\n\t    (count > uncopied_bytes))\n\t\treturn -EINVAL;\n\tif (copy_from_user(buf + (*ppos), user_buf, count)) {\n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t\treturn -EFAULT;\n\t}\n\tuncopied_bytes -= count;\n\t*ppos += count;\n\tif (!uncopied_bytes) {\n\t\tstatus = acpi_install_method(buf);\n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -EINVAL;\n\t\tadd_taint(TAINT_OVERRIDDEN_ACPI_TABLE);\n\t}\n\treturn count;\n}", "target": 0}
{"code": "static void free_copy_partition_data(VP9_COMP *cpi) {\n  vpx_free(cpi->prev_partition);\n  cpi->prev_partition = NULL;\n  vpx_free(cpi->prev_segment_id);\n  cpi->prev_segment_id = NULL;\n  vpx_free(cpi->prev_variance_low);\n  cpi->prev_variance_low = NULL;\n  vpx_free(cpi->copied_frame_cnt);\n  cpi->copied_frame_cnt = NULL;\n}", "target": 0}
{"code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!IsSupportedType(input->type)) {\n    TF_LITE_KERNEL_LOG(context, \"Input data type %s (%d) is not supported.\",\n                       TfLiteTypeGetName(input->type), input->type);\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void unix_release_sock(struct sock *sk, int embrion)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct path path;\n\tstruct sock *skpair;\n\tstruct sk_buff *skb;\n\tint state;\n\tunix_remove_socket(sk);\n\tunix_state_lock(sk);\n\tsock_orphan(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\tpath\t     = u->path;\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tstate = sk->sk_state;\n\tsk->sk_state = TCP_CLOSE;\n\tunix_state_unlock(sk);\n\twake_up_interruptible_all(&u->peer_wait);\n\tskpair = unix_peer(sk);\n\tif (skpair != NULL) {\n\t\tif (sk->sk_type == SOCK_STREAM || sk->sk_type == SOCK_SEQPACKET) {\n\t\t\tunix_state_lock(skpair);\n\t\t\tskpair->sk_shutdown = SHUTDOWN_MASK;\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue) || embrion)\n\t\t\t\tskpair->sk_err = ECONNRESET;\n\t\t\tunix_state_unlock(skpair);\n\t\t\tskpair->sk_state_change(skpair);\n\t\t\tsk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);\n\t\t}\n\t\tunix_dgram_peer_wake_disconnect(sk, skpair);\n\t\tsock_put(skpair); \n\t\tunix_peer(sk) = NULL;\n\t}\n\twhile ((skb = skb_dequeue(&sk->sk_receive_queue)) != NULL) {\n\t\tif (state == TCP_LISTEN)\n\t\t\tunix_release_sock(skb->sk, 1);\n\t\tUNIXCB(skb).consumed = skb->len;\n\t\tkfree_skb(skb);\n\t}\n\tif (path.dentry)\n\t\tpath_put(&path);\n\tsock_put(sk);\n\tif (unix_tot_inflight)\n\t\tunix_gc();\t\t\n}", "target": 0}
{"code": "  void DidGetGlobalUsage(StorageType type, int64 usage,\n                         int64 unlimited_usage) {\n    DCHECK_EQ(type_, type);\n    DCHECK_GE(usage, unlimited_usage);\n    global_usage_ = usage;\n    global_unlimited_usage_ = unlimited_usage;\n    CheckCompleted();\n  }", "target": 0}
{"code": "void SslSPIFFECertValidatorIntegrationTest::addStringMatcher(\n    const envoy::type::matcher::v3::StringMatcher& matcher) {\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS);\n}", "target": 0}
{"code": "static void encode_reclaim_complete(struct xdr_stream *xdr,\n\t\t\t\t    struct nfs41_reclaim_complete_args *args,\n\t\t\t\t    struct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_RECLAIM_COMPLETE, decode_reclaim_complete_maxsz, hdr);\n\tencode_uint32(xdr, args->one_fs);\n}", "target": 0}
{"code": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}", "target": 1}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\treturn -EINVAL;\n\tif (!error)\n\t\terror = size;\n\treturn error;\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "ring_buffer_read_finish(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\trb_check_pages(cpu_buffer);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\tatomic_dec(&cpu_buffer->record_disabled);\n\tatomic_dec(&cpu_buffer->buffer->resize_disabled);\n\tkfree(iter);\n}", "target": 0}
{"code": "static inline void vma_adjust_trans_huge(struct vm_area_struct *vma,\n\t\t\t\t\t unsigned long start,\n\t\t\t\t\t unsigned long end,\n\t\t\t\t\t long adjust_next)\n{\n\tif (!vma->anon_vma || vma->vm_ops || vma->vm_file)\n\t\treturn;\n\t__vma_adjust_trans_huge(vma, start, end, adjust_next);\n}", "target": 1}
{"code": "static int ion_handle_put_nolock(struct ion_handle *handle)\n{\n\tint ret;\n\tret = kref_put(&handle->ref, ion_handle_destroy);\n\treturn ret;\n}", "target": 0}
{"code": "TEST_FUNCTION_INITIALIZE(test_init)\n{\n    if (TEST_MUTEX_ACQUIRE(g_testByTest))\n    {\n        ASSERT_FAIL(\"our mutex is ABANDONED. Failure in test framework\");\n    }\n    umock_c_reset_all_calls();\n}", "target": 0}
{"code": "static int treo_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *swap_port;\n\tif (!((le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== HANDSPRING_VENDOR_ID) ||\n\t\t(le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== KYOCERA_VENDOR_ID)) ||\n\t\t(serial->num_interrupt_in == 0))\n\t\treturn 0;\n\tif (serial->num_bulk_in < 2 || serial->num_interrupt_in < 2) {\n\t\tdev_err(&serial->interface->dev, \"missing endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n#define COPY_PORT(dest, src)\t\t\t\t\t\t\\\n\tdo { \\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {\t\\\n\t\t\tdest->read_urbs[i] = src->read_urbs[i];\t\t\\\n\t\t\tdest->read_urbs[i]->context = dest;\t\t\\\n\t\t\tdest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tdest->read_urb = src->read_urb;\t\t\t\t\\\n\t\tdest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\\\n\t\tdest->bulk_in_buffer = src->bulk_in_buffer;\t\t\\\n\t\tdest->bulk_in_size = src->bulk_in_size;\t\t\t\\\n\t\tdest->interrupt_in_urb = src->interrupt_in_urb;\t\t\\\n\t\tdest->interrupt_in_urb->context = dest;\t\t\t\\\n\t\tdest->interrupt_in_endpointAddress = \\\n\t\t\t\t\tsrc->interrupt_in_endpointAddress;\\\n\t\tdest->interrupt_in_buffer = src->interrupt_in_buffer;\t\\\n\t} while (0);\n\tswap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);\n\tif (!swap_port)\n\t\treturn -ENOMEM;\n\tCOPY_PORT(swap_port, serial->port[0]);\n\tCOPY_PORT(serial->port[0], serial->port[1]);\n\tCOPY_PORT(serial->port[1], swap_port);\n\tkfree(swap_port);\n\treturn 0;\n}", "target": 0}
{"code": "rb_event_data(struct ring_buffer_event *event)\n{\n\tif (event->type_len == RINGBUF_TYPE_TIME_EXTEND)\n\t\tevent = skip_time_extend(event);\n\tBUG_ON(event->type_len > RINGBUF_TYPE_DATA_TYPE_LEN_MAX);\n\tif (event->type_len)\n\t\treturn (void *)&event->array[0];\n\treturn (void *)&event->array[1];\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "comics_regex_quote (const gchar *unquoted_string)\n{\n\tconst gchar *p;\n\tGString *dest;\n\tdest = g_string_new (\"'\");\n\tp = unquoted_string;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\t\tcase ('*'):\n\t\t\tcase ('?'):\n\t\t\tcase ('['):\n\t\t\t\tg_string_append (dest, \"[\");\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tg_string_append (dest, \"]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\\\'):\n\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\''):\n\t\t\t\tg_string_append (dest, \"'\\\\''\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\tg_string_append_c (dest, '\\'');\n\treturn g_string_free (dest, FALSE);\n}", "target": 1}
{"code": "static inline pmd_t pmdp_get_and_clear(struct mm_struct *mm,\n\t\t\t\t       unsigned long address,\n\t\t\t\t       pmd_t *pmdp)\n{\n\tpmd_t pmd = *pmdp;\n\tpmd_clear(pmdp);\n\treturn pmd;\n}", "target": 0}
{"code": "get_page_size_area_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgpointer         data)\n{\n\tgboolean *got_size = data;\n\t*got_size = TRUE;\n}", "target": 1}
{"code": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tif (num_clips && clips_ptr) {\n\t\tif (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n\t\tif (!clips) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}", "target": 0}
{"code": "static int ntlm_decode_field(struct wire_field_hdr *hdr,\n                             struct ntlm_buffer *buffer,\n                             size_t payload_offs,\n                             struct ntlm_buffer *field)\n{\n    struct ntlm_buffer b = { NULL, 0 };\n    uint32_t offs;\n    uint16_t len;\n    len = le16toh(hdr->len);\n    if (len == 0) goto done;\n    offs = le32toh(hdr->offset);\n    if ((offs < payload_offs) ||\n        (offs > buffer->length) ||\n        (UINT32_MAX - offs < len) ||\n        (offs + len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    b.data = malloc(len);\n    if (!b.data) return ENOMEM;\n    b.length = len;\n    memcpy(b.data, &buffer->data[offs], b.length);\ndone:\n    *field = b;\n    return 0;\n}", "target": 0}
{"code": "static char *get_netscape_format(const struct Cookie *co)\n{\n  return aprintf(\n    \"%s\"     \n    \"%s%s\\t\" \n    \"%s\\t\"   \n    \"%s\\t\"   \n    \"%s\\t\"   \n    \"%\" FORMAT_OFF_T \"\\t\"   \n    \"%s\\t\"   \n    \"%s\",    \n    co->httponly?\"#HttpOnly_\":\"\",\n    (co->tailmatch && co->domain && co->domain[0] != '.')? \".\":\"\",\n    co->domain?co->domain:\"unknown\",\n    co->tailmatch?\"TRUE\":\"FALSE\",\n    co->path?co->path:\"/\",\n    co->secure?\"TRUE\":\"FALSE\",\n    co->expires,\n    co->name,\n    co->value?co->value:\"\");\n}", "target": 0}
{"code": "init_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "int crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n  if (!paramBuf)\n    return -1;\n  *param = (CrxBandParam *)paramBuf;\n  paramBuf += sizeof(CrxBandParam);\n  (*param)->paramData = (int32_t *)paramBuf;\n  (*param)->nonProgrData =\n      progrDataSize ? (*param)->paramData + paramLength : 0;\n  (*param)->subbandWidth = subbandWidth;\n  (*param)->subbandHeight = subbandHeight;\n  (*param)->roundedBits = 0;\n  (*param)->curLine = 0;\n  (*param)->roundedBitsMask = roundedBitsMask;\n  (*param)->supportsPartial = supportsPartial;\n  (*param)->bitStream.bitData = 0;\n  (*param)->bitStream.bitsLeft = 0;\n  (*param)->bitStream.mdatSize = subbandDataSize;\n  (*param)->bitStream.curPos = 0;\n  (*param)->bitStream.curBufSize = 0;\n  (*param)->bitStream.curBufOffset = subbandMdatOffset;\n  (*param)->bitStream.input = input;\n  crxFillBuffer(&(*param)->bitStream);\n  return 0;\n}", "target": 1}
{"code": "int read_super_2(squashfs_operations **s_ops, void *s)\n{\n\t squashfs_super_block_3 *sBlk_3 = s;\n\tif(sBlk_3->s_magic != SQUASHFS_MAGIC || sBlk_3->s_major != 2 ||\n\t\t\t\t\t\t\tsBlk_3->s_minor > 1)\n\t\treturn -1;\n\tsBlk.s.s_magic = sBlk_3->s_magic;\n\tsBlk.s.inodes = sBlk_3->inodes;\n\tsBlk.s.mkfs_time = sBlk_3->mkfs_time;\n\tsBlk.s.block_size = sBlk_3->block_size;\n\tsBlk.s.fragments = sBlk_3->fragments;\n\tsBlk.s.block_log = sBlk_3->block_log;\n\tsBlk.s.flags = sBlk_3->flags;\n\tsBlk.s.s_major = sBlk_3->s_major;\n\tsBlk.s.s_minor = sBlk_3->s_minor;\n\tsBlk.s.root_inode = sBlk_3->root_inode;\n\tsBlk.s.bytes_used = sBlk_3->bytes_used_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start;\n\tsBlk.s.directory_table_start = sBlk_3->directory_table_start_2;\n\tsBlk.s.fragment_table_start = sBlk_3->fragment_table_start_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start_2;\n\tsBlk.no_uids = sBlk_3->no_uids;\n\tsBlk.no_guids = sBlk_3->no_guids;\n\tsBlk.uid_start = sBlk_3->uid_start_2;\n\tsBlk.guid_start = sBlk_3->guid_start_2;\n\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n\t*s_ops = &ops;\n\tcomp = lookup_compressor(\"gzip\");\n\tif(sBlk_3->s_minor == 0)\n\t\tneeds_sorting = TRUE;\n\treturn TRUE;\n}", "target": 0}
{"code": "void SecurityManager::notify_participant_authorized(\n        const ParticipantProxyData& participant_data)\n{\n    participant_->pdp()->notifyAboveRemoteEndpoints(participant_data);\n    EPROSIMA_LOG_INFO(SECURITY, \"Participant \" << participant_data.m_guid << \" authenticated\");\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::AUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 1}
{"code": "blockmix_salsa8(__m128i * Bin, __m128i * Bout, __m128i * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[8 * r - 4], 64);\n  for (i = 0; i < r; i++) {\n    blkxor(X, &Bin[i * 8], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 4], X, 64);\n    blkxor(X, &Bin[i * 8 + 4], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[(r + i) * 4], X, 64);\n  }\n}", "target": 1}
{"code": "static void nft_lookup_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_lookup *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "TEST_F(EncryptedRecordTest, TestAllPaddingHandshake) {\n  addToQueue(\"17030100050123456789\");\n  EXPECT_CALL(*readAead_, _decrypt(_, _, 0))\n      .WillOnce(Invoke([](std::unique_ptr<IOBuf>& buf, const IOBuf*, uint64_t) {\n        expectSame(buf, \"0123456789\");\n        return getBuf(\"16000000\");\n      }));\n  EXPECT_NO_THROW(read_.read(queue_));\n}", "target": 1}
{"code": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n        assert(f);\n        assert(ret);\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n        path_simplify(p, false);\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n                delete_trailing_chars(p, \"/\");\n                p = skip_leading_chars(p, \"/\");\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 1}
{"code": "static HTTPAPI_RESULT ConstructHeadersString(HTTP_HEADERS_HANDLE httpHeadersHandle, wchar_t** httpHeaders)\n{\n    HTTPAPI_RESULT result;\n    size_t headersCount;\n    if (HTTPHeaders_GetHeaderCount(httpHeadersHandle, &headersCount) != HTTP_HEADERS_OK)\n    {\n        result = HTTPAPI_ERROR;\n        LogError(\"HTTPHeaders_GetHeaderCount failed (result = %\" PRI_MU_ENUM \").\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else\n    {\n        size_t i;\n        size_t toAlloc = 0;\n        for (i = 0; i < headersCount; i++)\n        {\n            char *temp;\n            if (HTTPHeaders_GetHeader(httpHeadersHandle, i, &temp) == HTTP_HEADERS_OK)\n            {\n                toAlloc += strlen(temp);\n                toAlloc += 2;\n                free(temp);\n            }\n            else\n            {\n                LogError(\"HTTPHeaders_GetHeader failed\");\n                break;\n            }\n        }\n        if (i < headersCount)\n        {\n            result = HTTPAPI_ERROR;\n        }\n        else\n        {\n            char *httpHeadersA;\n            size_t requiredCharactersForHeaders;\n            if ((httpHeadersA = ConcatHttpHeaders(httpHeadersHandle, toAlloc, headersCount)) == NULL)\n            {\n                result = HTTPAPI_ERROR;\n                LogError(\"Cannot concatenate headers\");\n            }\n            else if ((requiredCharactersForHeaders = MultiByteToWideChar(CP_ACP, 0, httpHeadersA, -1, NULL, 0)) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x (result = %\" PRI_MU_ENUM \")\", GetLastError(), MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n            }\n            else if ((*httpHeaders = (wchar_t*)malloc((requiredCharactersForHeaders + 1) * sizeof(wchar_t))) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"Cannot allocate memory (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n            }\n            else if (MultiByteToWideChar(CP_ACP, 0, httpHeadersA, -1, *httpHeaders, (int)requiredCharactersForHeaders) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x (result = %\" PRI_MU_ENUM \")\", GetLastError(), MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n                free(*httpHeaders);\n                *httpHeaders = NULL;\n            }\n            else\n            {\n                result = HTTPAPI_OK;\n            }\n            free(httpHeadersA);\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "    static std::string indent(int depth)\n    {\n        std::string result;\n        while ( depth -- ) result += \"  \";\n        return result;\n    }", "target": 0}
{"code": "int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {\n\tint ret;\n\tSPDBDownloaderOpt opt;\n\tSPDBDownloader pdb_downloader;\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\tif (!info || !info->debug_file_name) {\n\t\teprintf (\"Can't find debug filename\\n\");\n\t\treturn 1;\n\t}\n\tif (!is_valid_guid (info->guid)) {\n\t\teprintf (\"Invalid GUID for file\\n\");\n\t\treturn 1;\n\t}\n\tif (!options || !options->symbol_server || !options->user_agent) {\n\t\teprintf (\"Can't retrieve pdb configurations\\n\");\n\t\treturn 1;\n\t}\n\topt.dbg_file = (char*) r_file_basename (info->debug_file_name);\n\topt.guid = info->guid;\n\topt.symbol_server = options->symbol_server;\n\topt.user_agent = options->user_agent;\n\topt.symbol_store_path = options->symbol_store_path;\n\topt.extract = options->extract;\n\tinit_pdb_downloader (&opt, &pdb_downloader);\n\tret = pdb_downloader.download ? pdb_downloader.download (&pdb_downloader) : 0;\n\tif (isradjson && actions_done) {\n\t\tprintf (\"%s\\\"pdb\\\":{\\\"file\\\":\\\"%s\\\",\\\"download\\\":%s}\",\n\t\t        *actions_done ? \",\" : \"\", opt.dbg_file, ret ? \"true\" : \"false\");\n\t} else {\n\t\tprintf (\"PDB \\\"%s\\\" download %s\\n\",\n\t\t        opt.dbg_file, ret ? \"success\" : \"failed\");\n\t}\n\tif (actions_done) {\n\t\t(*actions_done)++;\n\t}\n\tdeinit_pdb_downloader (&pdb_downloader);\n\treturn 0;\n}", "target": 0}
{"code": "void infra_wait_limit_inc(struct infra_cache* infra, struct comm_reply* rep,\n\ttime_t timenow, struct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 1);\n\tif(entry) {\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\td->mesh_wait++;\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn;\n\t}\n\tinfra_ip_create_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, timenow, 1);\n}", "target": 0}
{"code": "parse_delta(struct rpki_uri *uri, struct delta_head *parents_data,\n    struct proc_upd_args *args)\n{\n\tstruct rdr_delta_ctx ctx;\n\tstruct delta *delta;\n\tstruct doc_data *expected_data;\n\tint error;\n\texpected_data = &parents_data->doc_data;\n\tfnstack_push_uri(uri);\n\terror = hash_validate_file(\"sha256\", uri, expected_data->hash,\n\t    expected_data->hash_len);\n\tif (error)\n\t\tgoto pop_fnstack;\n\terror = delta_create(&delta);\n\tif (error)\n\t\tgoto pop_fnstack;\n\tctx.delta = delta;\n\tctx.parent = args->parent;\n\tctx.visited_uris = args->visited_uris;\n\tctx.expected_serial = parents_data->serial;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_delta, &ctx);\n\tdelta_destroy(delta);\npop_fnstack:\n\tfnstack_pop();\n\treturn error;\n}", "target": 1}
{"code": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace(*s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}", "target": 1}
{"code": "usage (const char *prog)\n{\n\tg_print (\"- Lists file in a supported archive format\\n\");\n\tg_print (\"Usage: %s archive-type filename\\n\", prog);\n\tg_print (\"Where archive-type is one of rar, zip, 7z or tar\\n\");\n}", "target": 0}
{"code": "struct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "void CxImage::Ghost(const CxImage *from)\n{\n\tif (from){\n\t\tmemcpy(&head,&from->head,sizeof(BITMAPINFOHEADER));\n\t\tmemcpy(&info,&from->info,sizeof(CXIMAGEINFO));\n\t\tpDib = from->pDib;\n        pDibLimit = from->pDibLimit;\n\t\tpSelection = from->pSelection;\n\t\tpAlpha = from->pAlpha;\n\t\tppLayers = from->ppLayers;\n\t\tppFrames = from->ppFrames;\n\t\tinfo.pGhost=(CxImage *)from;\n\t}\n}", "target": 0}
{"code": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "snmp_api_replace_oid(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  while(oid[i] != ((uint32_t)-1)) {\n    varbind->oid[i] = oid[i];\n    i++;\n  }\n  varbind->oid[i] = ((uint32_t)-1);\n}", "target": 1}
{"code": "static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}", "target": 1}
{"code": "static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      u32 type, u32 mask)\n{\n\tstruct pcrypt_instance_ctx *ctx;\n\tstruct crypto_attr_type *algt;\n\tstruct aead_instance *inst;\n\tstruct aead_alg *alg;\n\tconst char *name;\n\tint err;\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\tname = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tctx = aead_instance_ctx(inst);\n\tcrypto_set_aead_spawn(&ctx->spawn, aead_crypto_instance(inst));\n\terr = crypto_grab_aead(&ctx->spawn, name, 0, 0);\n\tif (err)\n\t\tgoto out_free_inst;\n\talg = crypto_spawn_aead_alg(&ctx->spawn);\n\terr = pcrypt_init_instance(aead_crypto_instance(inst), &alg->base);\n\tif (err)\n\t\tgoto out_drop_aead;\n\tinst->alg.base.cra_flags = CRYPTO_ALG_ASYNC;\n\tinst->alg.ivsize = crypto_aead_alg_ivsize(alg);\n\tinst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\n\tinst->alg.base.cra_ctxsize = sizeof(struct pcrypt_aead_ctx);\n\tinst->alg.init = pcrypt_aead_init_tfm;\n\tinst->alg.exit = pcrypt_aead_exit_tfm;\n\tinst->alg.setkey = pcrypt_aead_setkey;\n\tinst->alg.setauthsize = pcrypt_aead_setauthsize;\n\tinst->alg.encrypt = pcrypt_aead_encrypt;\n\tinst->alg.decrypt = pcrypt_aead_decrypt;\n\tinst->free = pcrypt_free;\n\terr = aead_register_instance(tmpl, inst);\n\tif (err)\n\t\tgoto out_drop_aead;\nout:\n\treturn err;\nout_drop_aead:\n\tcrypto_drop_aead(&ctx->spawn);\nout_free_inst:\n\tkfree(inst);\n\tgoto out;\n}", "target": 0}
{"code": "static void mq_flush_data_end_io(struct request *rq, int error)\n{\n\tstruct request_queue *q = rq->q;\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *ctx = rq->mq_ctx;\n\tunsigned long flags;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, ctx);\n\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\tif (blk_flush_complete_seq(rq, fq, REQ_FSEQ_DATA, error))\n\t\tblk_mq_run_hw_queue(hctx, true);\n\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}", "target": 0}
{"code": "    void TiffEncoder::add(\n        TiffComponent* pRootDir,\n        TiffComponent* pSourceDir,\n        uint32_t       root\n    )\n    {\n        assert(pRootDir != 0);\n        writeMethod_ = wmIntrusive;\n        pSourceTree_ = pSourceDir;\n        del_ = false;\n        ExifData::const_iterator posBo = exifData_.end();\n        for (ExifData::const_iterator i = exifData_.begin();\n             i != exifData_.end(); ++i) {\n            IfdId group = groupId(i->groupName());\n            if (group == mnId) {\n                if (i->tag() == 0x0002) {\n                    posBo = i;\n                }\n                continue;\n            }\n            if (isImageTag(i->tag(), group)) continue;\n            TiffPath tiffPath;\n            TiffCreator::getPath(tiffPath, i->tag(), group, root);\n            TiffComponent* tc = pRootDir->addPath(i->tag(), tiffPath, pRootDir);\n            TiffEntryBase* object = dynamic_cast<TiffEntryBase*>(tc);\n#ifdef DEBUG\n            if (object == 0) {\n                std::cerr << \"Warning: addPath() didn't add an entry for \"\n                          << i->groupName()\n                          << \" tag 0x\" << std::setw(4) << std::setfill('0')\n                          << std::hex << i->tag() << \"\\n\";\n            }\n#endif\n            if (object != 0) {\n                encodeTiffComponent(object, &(*i));\n            }\n        }\n        if (posBo == exifData_.end()) return;\n        TiffFinder finder(0x927c, exifId);\n        pRootDir->accept(finder);\n        TiffMnEntry* te = dynamic_cast<TiffMnEntry*>(finder.result());\n        if (te) {\n            TiffIfdMakernote* tim = dynamic_cast<TiffIfdMakernote*>(te->mn_);\n            if (tim) {\n                ByteOrder bo = stringToByteOrder(posBo->toString());\n                if (bo != invalidByteOrder) tim->setByteOrder(bo);\n            }\n        }\n    } ", "target": 0}
{"code": "juniper_pppoe_atm_print(netdissect_options *ndo,\n                        const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n\tuint16_t extracted_ethertype;\n        l2info.pictype = DLT_JUNIPER_PPPOE_ATM;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        ND_TCHECK2(p[0], 2);\n        extracted_ethertype = EXTRACT_16BITS(p);\n        if (ethertype_print(ndo, extracted_ethertype,\n                              p+ETHERTYPE_LEN,\n                              l2info.length-ETHERTYPE_LEN,\n                              l2info.caplen-ETHERTYPE_LEN,\n                              NULL, NULL) == 0)\n            ND_PRINT((ndo, \"unknown ethertype 0x%04x\", extracted_ethertype));\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_pppoe_atm]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,\n\t\t\t   const struct qstr *name,\n\t\t\t   struct nfs4_fs_locations *fs_locations,\n\t\t\t   struct page *page)\n{\n\tstruct nfs4_exception exception = { };\n\tint err;\n\tdo {\n\t\terr = nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t_nfs4_proc_fs_locations(client, dir, name, fs_locations, page),\n\t\t\t\t&exception);\n\t} while (exception.retry);\n\treturn err;\n}", "target": 0}
{"code": "inline bool ClientImpl::write_request(Stream &strm, Request &req,\n                                      bool close_connection, Error &error) {\n  if (close_connection) {\n    if (!req.has_header(\"Connection\")) {\n      req.headers.emplace(\"Connection\", \"close\");\n    }\n  }\n  if (!req.has_header(\"Host\")) {\n    if (is_ssl()) {\n      if (port_ == 443) {\n        req.headers.emplace(\"Host\", host_);\n      } else {\n        req.headers.emplace(\"Host\", host_and_port_);\n      }\n    } else {\n      if (port_ == 80) {\n        req.headers.emplace(\"Host\", host_);\n      } else {\n        req.headers.emplace(\"Host\", host_and_port_);\n      }\n    }\n  }\n  if (!req.has_header(\"Accept\")) { req.headers.emplace(\"Accept\", \"*", "target": 1}
{"code": "static void sunkbd_set_leds_beeps(struct sunkbd *sunkbd)\n{\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 0}
{"code": "int nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\tline += PKT_LEN_SIZE;\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n\t\treturn GIT_ERROR;\n\t}\n\tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}", "target": 0}
{"code": "void Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n  ASSERT(!upstream_request.retried());\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n  upstream_request.outlierDetectionTimeoutRecorded(true);\n  if (!downstream_response_started_ && retry_state_) {\n    RetryStatus retry_status = retry_state_->shouldHedgeRetryPerTryTimeout(\n        [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_]() -> void {\n          doRetry( false, can_use_http3, TimeoutRetry::Yes);\n        });\n    if (retry_status == RetryStatus::Yes) {\n      runRetryOptionsPredicates(upstream_request);\n      pending_retries_++;\n      upstream_request.retried(true);\n    } else if (retry_status == RetryStatus::NoOverflow) {\n      callbacks_->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamOverflow);\n    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n      callbacks_->streamInfo().setResponseFlag(\n          StreamInfo::CoreResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}", "target": 0}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tmark_key_instantiated(key, -error);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 0}
{"code": "static void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_CSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\t\tif (index >= 0 && vmx->rdtscp_enabled)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif ((index >= 0) && (vmx->vcpu.arch.efer & EFER_SCE))\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tvmx->save_nmsrs = save_nmsrs;\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(&vmx->vcpu);\n}", "target": 0}
{"code": "\tvirtual void run(Chunk &inChunk, Chunk &outChunk)\n\t{\n\t\tint count = inChunk.f.channelCount * inChunk.frameCount;\n\t\tif (m_isSigned)\n\t\t\trun<int32_t>(reinterpret_cast<const uint8_t *>(inChunk.buffer),\n\t\t\t\treinterpret_cast<int32_t *>(outChunk.buffer),\n\t\t\t\tcount);\n\t\telse\n\t\t\trun<uint32_t>(reinterpret_cast<const uint8_t *>(inChunk.buffer),\n\t\t\t\treinterpret_cast<uint32_t *>(outChunk.buffer),\n\t\t\t\tcount);\n\t}", "target": 0}
{"code": "    size_t Xmpdatum::count() const\n    {\n        return p_->value_.get() == 0 ? 0 : p_->value_->count();\n    }", "target": 0}
{"code": "GopherStateData::~GopherStateData()\n{\n    if (entry)\n        entry->unlock(\"gopherState\");\n    if (buf)\n        memFree(buf, MEM_4K_BUF);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    OP_REQUIRES(ctx, ctx->input(1).NumElements() > 0,\n                errors::InvalidArgument(\"Input min must not be empty.\"));\n    OP_REQUIRES(ctx, ctx->input(2).NumElements() > 0,\n                errors::InvalidArgument(\"Input max must not be empty.\"));\n    const float input_min_float = ctx->input(1).flat<float>()(0);\n    const float input_max_float = ctx->input(2).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &output_min));\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_max));\n    qint32 used_min_quantized;\n    qint32 used_max_quantized;\n    CalculateUsedRange(input, &used_min_quantized, &used_max_quantized);\n    const float used_min_float = std::min(\n        0.0f,\n        QuantizedToFloat(used_min_quantized, input_min_float, input_max_float));\n    const float used_max_float =\n        QuantizedToFloat(used_max_quantized, input_min_float, input_max_float);\n    output_min->flat<float>().setConstant(used_min_float);\n    output_max->flat<float>().setConstant(used_max_float);\n  }", "target": 0}
{"code": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\tfor (i = 0; i < refs.count; ++i) {\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\t\tgit_reference_free(ref);\n\t}\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}", "target": 0}
{"code": "path_poly(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tPOLYGON    *poly;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tif (!path->closed)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"open path cannot be converted to polygon\")));\n\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * path->npts;\n\tpoly = (POLYGON *) palloc(size);\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = path->npts;\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpoly->p[i].x = path->p[i].x;\n\t\tpoly->p[i].y = path->p[i].y;\n\t}\n\tmake_bound_box(poly);\n\tPG_RETURN_POLYGON_P(poly);\n}", "target": 0}
{"code": "pci_lintr_assert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == IDLE) {\n\t\tif (pci_lintr_permitted(dev)) {\n\t\t\tdev->lintr.state = ASSERTED;\n\t\t\tpci_irq_assert(dev);\n\t\t} else\n\t\t\tdev->lintr.state = PENDING;\n\t}\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,\n                          const TfLiteTensor* axis, TfLiteTensor* output) {\n  int axis_value;\n  if (axis->type == kTfLiteInt64) {\n    axis_value = static_cast<int>(*GetTensorData<int64_t>(axis));\n  } else {\n    axis_value = *GetTensorData<int>(axis);\n  }\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);\n  int j = 0;\n  for (int i = 0; i < NumDimensions(input); ++i) {\n    if (i != axis_value) {\n      output_dims->data[j] = SizeOfDimension(input, i);\n      ++j;\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 0}
{"code": "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n{\n\tzend_hash_destroy(&pglobals->ht_rc);\n}", "target": 1}
{"code": "int nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx, u8 mode)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s target_idx=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->active_target->idx != target_idx) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->ops->check_presence)\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\tdev->ops->deactivate_target(dev, dev->active_target, mode);\n\tdev->active_target = NULL;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "test_read_integer_error (xd3_stream *stream, usize_t trunto, const char *msg)\n{\n  uint64_t eval = 1ULL << 34;\n  uint32_t rval;\n  xd3_output *buf = NULL;\n  const uint8_t *max;\n  const uint8_t *inp;\n  int ret;\n  buf = xd3_alloc_output (stream, buf);\n  if ((ret = xd3_emit_uint64_t (stream, & buf, eval)))\n    {\n      goto fail;\n    }\n again:\n  inp = buf->base;\n  max = buf->base + buf->next - trunto;\n  if ((ret = xd3_read_uint32_t (stream, & inp, max, & rval)) != \n      XD3_INVALID_INPUT ||\n      !MSG_IS (msg))\n    {\n      ret = XD3_INTERNAL;\n    }\n  else if (trunto && trunto < buf->next)\n    {\n      trunto += 1;\n      goto again;\n    }\n  else\n    {\n      ret = 0;\n    }\n fail:\n  xd3_free_output (stream, buf);\n  return ret;\n}", "target": 1}
{"code": "ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)\n{\n\tcheck_preempt_curr(rq, p, wake_flags);\n\tp->state = TASK_RUNNING;\n\ttrace_sched_wakeup(p);\n#ifdef CONFIG_SMP\n\tif (p->sched_class->task_woken) {\n\t\tlockdep_unpin_lock(&rq->lock);\n\t\tp->sched_class->task_woken(rq, p);\n\t\tlockdep_pin_lock(&rq->lock);\n\t}\n\tif (rq->idle_stamp) {\n\t\tu64 delta = rq_clock(rq) - rq->idle_stamp;\n\t\tu64 max = 2*rq->max_idle_balance_cost;\n\t\tupdate_avg(&rq->avg_idle, delta);\n\t\tif (rq->avg_idle > max)\n\t\t\trq->avg_idle = max;\n\t\trq->idle_stamp = 0;\n\t}\n#endif\n}", "target": 0}
{"code": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "        EDP* getEDP() { return &edp_; }", "target": 1}
{"code": "int nft_chain_validate_dependency(const struct nft_chain *chain,\n\t\t\t\t  enum nft_chain_type type)\n{\n\tconst struct nft_base_chain *basechain;\n\tif (chain->flags & NFT_BASE_CHAIN) {\n\t\tbasechain = nft_base_chain(chain);\n\t\tif (basechain->type->type != type)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int send_release(uint32_t server, uint32_t ciaddr)\n{\n\tstruct dhcp_packet packet;\n\tinit_packet(&packet, DHCPRELEASE);\n\tpacket.ciaddr = ciaddr;\n\tudhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);\n\tbb_info_msg(\"Sending release...\");\n\treturn bcast_or_ucast(&packet, ciaddr, server);\n}", "target": 0}
{"code": "cssp_encode_tspasswordcreds(char *username, char *password, char *domain)\n{\n\tSTREAM out, h1, h2;\n\tstruct stream tmp = { 0 };\n\tstruct stream message = { 0 };\n\tmemset(&tmp, 0, sizeof(tmp));\n\tmemset(&message, 0, sizeof(message));\n\ts_realloc(&tmp, 4 + strlen(domain) * sizeof(uint16));\n\ts_reset(&tmp);\n\trdp_out_unistr(&tmp, domain, strlen(domain) * sizeof(uint16));\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\ts_realloc(&tmp, 4 + strlen(username) * sizeof(uint16));\n\ts_reset(&tmp);\n\trdp_out_unistr(&tmp, username, strlen(username) * sizeof(uint16));\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\ts_realloc(&tmp, 4 + strlen(password) * sizeof(uint16));\n\ts_reset(&tmp);\n\trdp_out_unistr(&tmp, password, strlen(password) * sizeof(uint16));\n\ts_mark_end(&tmp);\n\th2 = ber_wrap_hdr_data(BER_TAG_OCTET_STRING, &tmp);\n\th1 = ber_wrap_hdr_data(BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 2, h2);\n\ts_realloc(&message, s_length(&message) + s_length(h1));\n\tout_uint8p(&message, h1->data, s_length(h1));\n\ts_mark_end(&message);\n\ts_free(h2);\n\ts_free(h1);\n\tout = ber_wrap_hdr_data(BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED, &message);\n\txfree(tmp.data);\n\txfree(message.data);\n\treturn out;\n}", "target": 0}
{"code": "static void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINORIGIN;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.user);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.id = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.version = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &ses->origin.addr);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "Item_cond_and::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                              uint *and_level, table_map usable_tables,\n                              SARGABLE_PARAM **sargables)\n{\n  List_iterator_fast<Item> li(*argument_list());\n  KEY_FIELD *org_key_fields= *key_fields;\n  Item *item;\n  while ((item=li++))\n    item->add_key_fields(join, key_fields, and_level, usable_tables,\n                         sargables);\n  for (; org_key_fields != *key_fields ; org_key_fields++)\n    org_key_fields->level= *and_level;\n}", "target": 0}
{"code": "pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n\t\t      int atomic)\n{\n\tunsigned long copy;\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\t\tif (atomic) {\n\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tfrom += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int selinux_sb_remount(struct super_block *sb, void *mnt_opts)\n{\n\tstruct selinux_mnt_opts *opts = mnt_opts;\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tu32 sid;\n\tint rc;\n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\treturn 0;\n\tif (!opts)\n\t\treturn 0;\n\tif (opts->fscontext) {\n\t\trc = parse_sid(sb, opts->fscontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->context) {\n\t\trc = parse_sid(sb, opts->context, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->rootcontext) {\n\t\tstruct inode_security_struct *root_isec;\n\t\troot_isec = backing_inode_security(sb->s_root);\n\t\trc = parse_sid(sb, opts->rootcontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->defcontext) {\n\t\trc = parse_sid(sb, opts->defcontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\treturn 0;\nout_bad_option:\n\tpr_warn(\"SELinux: unable to change security options \"\n\t       \"during remount (dev %s, type=%s)\\n\", sb->s_id,\n\t       sb->s_type->name);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static WCHAR* drive_file_combine_fullpath(const WCHAR* base_path, const WCHAR* path,\n                                          size_t PathLength)\n{\n\tWCHAR* fullpath;\n\tsize_t base_path_length;\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\tbase_path_length = _wcslen(base_path) * 2;\n\tfullpath = (WCHAR*)calloc(1, base_path_length + PathLength + sizeof(WCHAR));\n\tif (!fullpath)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn NULL;\n\t}\n\tCopyMemory(fullpath, base_path, base_path_length);\n\tif (path)\n\t\tCopyMemory((char*)fullpath + base_path_length, path, PathLength);\n\tdrive_file_fix_path(fullpath);\n\treturn fullpath;\n}", "target": 1}
{"code": "txid_snapshot_recv(PG_FUNCTION_ARGS)\n{\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tTxidSnapshot *snap;\n\ttxid\t\tlast = 0;\n\tint\t\t\tnxip;\n\tint\t\t\ti;\n\tint\t\t\tavail;\n\tint\t\t\texpect;\n\ttxid\t\txmin,\n\t\t\t\txmax;\n\tnxip = pq_getmsgint(buf, 4);\n\tavail = buf->len - buf->cursor;\n\texpect = 8 + 8 + nxip * 8;\n\tif (nxip < 0 || nxip > avail || expect > avail)\n\t\tgoto bad_format;\n\txmin = pq_getmsgint64(buf);\n\txmax = pq_getmsgint64(buf);\n\tif (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)\n\t\tgoto bad_format;\n\tsnap = palloc(TXID_SNAPSHOT_SIZE(nxip));\n\tsnap->xmin = xmin;\n\tsnap->xmax = xmax;\n\tsnap->nxip = nxip;\n\tSET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));\n\tfor (i = 0; i < nxip; i++)\n\t{\n\t\ttxid\t\tcur = pq_getmsgint64(buf);\n\t\tif (cur <= last || cur < xmin || cur >= xmax)\n\t\t\tgoto bad_format;\n\t\tsnap->xip[i] = cur;\n\t\tlast = cur;\n\t}\n\tPG_RETURN_POINTER(snap);\nbad_format:\n\telog(ERROR, \"invalid snapshot data\");\n\treturn (Datum) NULL;\n}", "target": 1}
{"code": "dump_dest_constraint_hop(const struct dest_constraint_hop *dch)\n{\n\tu_int i;\n\tchar *fp;\n\tdebug_f(\"user %s hostname %s is_ca %d nkeys %u\",\n\t    dch->user == NULL ? \"(null)\" : dch->user,\n\t    dch->hostname == NULL ? \"(null)\" : dch->hostname,\n\t    dch->is_ca, dch->nkeys);\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tfp = NULL;\n\t\tif (dch->keys[i] != NULL &&\n\t\t    (fp = sshkey_fingerprint(dch->keys[i],\n\t\t    SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug_f(\"key %u/%u: %s%s%s key_is_ca %d\", i, dch->nkeys,\n\t\t    dch->keys[i] == NULL ? \"\" : sshkey_ssh_name(dch->keys[i]),\n\t\t    dch->keys[i] == NULL ? \"\" : \" \",\n\t\t    dch->keys[i] == NULL ? \"none\" : fp,\n\t\t    dch->key_is_ca[i]);\n\t\tfree(fp);\n\t}\n}", "target": 0}
{"code": "static int _FVMenuClose(FontView *fv) {\n    int i;\n    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;\n    if ( !SFCloseAllInstrs(fv->b.sf) )\nreturn( false );\n    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {\n    } else if ( warn_script_unsaved && fv->script_unsaved && \n                AskScriptChanged()==2 ) {\n        return false;\n    } else if ( SFAnyChanged(sf) ) {\n\ti = AskChanged(fv->b.sf);\n\tif ( i==2 )\t\nreturn( false );\n\tif ( i==0 && !_FVMenuSave(fv))\t\t\nreturn(false);\n\telse\n\t    SFClearAutoSave(sf);\t\t\n    }\n    _FVCloseWindows(fv);\n    if ( sf->filename!=NULL )\n\tRecentFilesRemember(sf->filename);\n    else if ( sf->origname!=NULL )\n\tRecentFilesRemember(sf->origname);\n    GDrawDestroyWindow(fv->gw);\nreturn( true );\n}", "target": 0}
{"code": "int mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n    return MONGO_OK;\n}", "target": 1}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "static int decode_server_caps(struct xdr_stream *xdr, struct nfs4_server_caps_res *res)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_supported(xdr, bitmap, res->attr_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fh_expire_type(xdr, bitmap,\n\t\t\t\t\t\t &res->fh_expire_type)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_link_support(xdr, bitmap, &res->has_links)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_symlink_support(xdr, bitmap, &res->has_symlinks)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_aclsupport(xdr, bitmap, &res->acl_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}", "target": 0}
{"code": "DEFINE_TEST(test_read_too_many_filters)\n{\n\tconst char *name = \"test_read_too_many_filters.gz\";\n\tstruct archive *a;\n\tint r;\n\tassert((a = archive_read_new()) != NULL);\n\tr = archive_read_support_filter_gzip(a);\n\tif (r == ARCHIVE_WARN) {\n\t\tskipping(\"gzip reading not fully supported on this platform\");\n\t}\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));\n\textract_reference_file(name);\n\tassertEqualIntA(a, ARCHIVE_FATAL,\n\t    archive_read_open_filename(a, name, 200));\n\tassertEqualInt(ARCHIVE_OK, archive_read_close(a));\n\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n}", "target": 0}
{"code": "static void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle = 0;\n\tuint16_t offset;\n\tstruct gatt_db_attribute *attr;\n\tstruct prep_write_complete_data *pwcd;\n\tuint8_t ecode, status;\n\tif (length < 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\tif (queue_length(server->prep_queue) >= server->max_prep_queue_len) {\n\t\tecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL;\n\t\tgoto error;\n\t}\n\thandle = get_le16(pdu);\n\toffset = get_le16(pdu + 2);\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Prep Write Req - handle: 0x%04x\", handle);\n\tecode = check_length(length, offset);\n\tif (ecode)\n\t\tgoto error;\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\tpwcd = new0(struct prep_write_complete_data, 1);\n\tpwcd->chan = chan;\n\tpwcd->pdu = malloc(length);\n\tmemcpy(pwcd->pdu, pdu, length);\n\tpwcd->length = length;\n\tpwcd->server = server;\n\tstatus = gatt_db_attribute_write(attr, offset, NULL, 0,\n\t\t\t\t\t\tBT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\tprep_write_complete_cb, pwcd);\n\tif (status)\n\t\treturn;\n\tecode = BT_ATT_ERROR_UNLIKELY;\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}", "target": 0}
{"code": "x509_vfy_callback_indicate_success(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}", "target": 1}
{"code": "static bool download_and_write(SPDBDownloaderOpt *opt, const char *file) {\n\tchar *dir = r_str_newf (\"%s%s%s%s%s\",\n\t\topt->symbol_store_path, R_SYS_DIR,\n\t\topt->dbg_file, R_SYS_DIR,\n\t\topt->guid);\n\tif (!r_sys_mkdirp (dir)) {\n\t\tfree (dir);\n\t\treturn false;\n\t}\n\tchar *url = r_str_newf (\"%s/%s/%s/%s\", opt->symbol_server, opt->dbg_file, opt->guid, file);\n\tint len;\n\tchar *file_buf = r_socket_http_get (url, NULL, &len);\n\tfree (url);\n\tif (!len || R_STR_ISEMPTY (file_buf)) {\n\t\tfree (dir);\n\t\tfree (file_buf);\n\t\treturn false;\n\t}\n\tchar *path = r_str_newf (\"%s%s%s\", dir, R_SYS_DIR, opt->dbg_file);\n\tFILE *f = fopen (path, \"wb\");\n\tif (f) {\n\t\tfwrite (file_buf, sizeof (char), (size_t)len, f);\n\t\tfclose (f);\n\t}\n\tfree (dir);\n\tfree (path);\n\tfree (file_buf);\n\treturn true;\n}", "target": 0}
{"code": "void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n\t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}", "target": 1}
{"code": "DownloadResult downloadFile(string url, string expectedETag)\n{\n    DownloadResult res;\n    Curl curl;\n    if (curl.fetch(url, expectedETag)) {\n        res.cached = false;\n        res.data = curl.data;\n    } else\n        res.cached = true;\n    res.etag = curl.etag;\n    return res;\n}", "target": 1}
{"code": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n  imap_quote_string(dest, dlen, buf);\n  FREE(&buf);\n}", "target": 1}
{"code": "FIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {\n  const struct timespec tm = {.tv_nsec = (nano_sec % 1000000000),\n                              .tv_sec = (nano_sec / 1000000000)};\n  nanosleep(&tm, NULL);\n}", "target": 1}
{"code": "static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)\n{\n\tif (mm->context.asce_limit == (1UL << 31))\n\t\tpgtable_pmd_page_dtor(virt_to_page(pgd));\n\tcrst_table_free(mm, (unsigned long *) pgd);\n}", "target": 0}
{"code": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}", "target": 1}
{"code": "  explicit UnravelIndexOp(OpKernelConstruction* ctx) : OpKernel(ctx) {}", "target": 1}
{"code": "int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n\tint\t\t\ti, nbits;\n\tvalue = 0;\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n\t}\n\tif (msg->oob) {\n\t\tif(bits==8)\n\t\t{\n\t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t}\n\t\telse if(bits==16)\n\t\t{\n\t\t\tshort temp;\n\t\t\tCopyLittleShort(&temp, &msg->data[msg->readcount]);\n\t\t\tvalue = temp;\n\t\t\tmsg->readcount += 2;\n\t\t\tmsg->bit += 16;\n\t\t}\n\t\telse if(bits==32)\n\t\t{\n\t\t\tCopyLittleLong(&value, &msg->data[msg->readcount]);\n\t\t\tmsg->readcount += 4;\n\t\t\tmsg->bit += 32;\n\t\t}\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n\t\tnbits = 0;\n\t\tif (bits&7) {\n\t\t\tnbits = bits&7;\n\t\t\tfor(i=0;i<nbits;i++) {\n\t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif (bits) {\n\t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);\n\t\t\t\tvalue |= (get<<(i+nbits));\n\t\t\t}\n\t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}\n\tif ( sgn && bits > 0 && bits < 32 ) {\n\t\tif ( value & ( 1 << ( bits - 1 ) ) ) {\n\t\t\tvalue |= -1 ^ ( ( 1 << bits ) - 1 );\n\t\t}\n\t}\n\treturn value;\n}", "target": 1}
{"code": "AsyncSocket::WriteResult AsyncSSLSocket::interpretSSLError(int rc, int error) {\n  if (error == SSL_ERROR_WANT_READ) {\n    LOG(ERROR) << \"AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n               << \", sslState=\" << sslState_ << \", events=\" << eventFlags_\n               << \"): \"\n               << \"unsupported SSL renegotiation during write\";\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(SSLError::INVALID_RENEGOTIATION));\n  } else {\n    if (zero_return(error, rc, errno)) {\n      return WriteResult(0);\n    }\n    auto errError = ERR_get_error();\n    VLOG(3) << \"ERROR: AsyncSSLSocket(fd=\" << fd_ << \", state=\" << int(state_)\n            << \", sslState=\" << sslState_ << \", events=\" << eventFlags_ << \"): \"\n            << \"SSL error: \" << error << \", errno: \" << errno\n            << \", func: \" << ERR_func_error_string(errError)\n            << \", reason: \" << ERR_reason_error_string(errError);\n    return WriteResult(\n        WRITE_ERROR,\n        std::make_unique<SSLException>(error, errError, rc, errno));\n  }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n    OP_REQUIRES(ctx, key_tensor->NumElements() == 1,\n                errors::InvalidArgument(\n                    \"key must be an int64 scalar, got tensor with shape: \",\n                    key_tensor->shape()));\n    Tensor key(*key_tensor);\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }", "target": 0}
{"code": "CompileKeymap(XkbFile *file, struct xkb_keymap *keymap, enum merge_mode merge)\n{\n    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n        files[file->file_type] = file;\n    }\n    ok = true;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        if (files[type] == NULL) {\n            log_err(ctx, \"Required section %s missing from keymap\\n\",\n                    xkb_file_type_to_string(type));\n            ok = false;\n        }\n    }\n    if (!ok)\n        return false;\n    for (type = FIRST_KEYMAP_FILE_TYPE;\n         type <= LAST_KEYMAP_FILE_TYPE;\n         type++) {\n        log_dbg(ctx, \"Compiling %s \\\"%s\\\"\\n\",\n                xkb_file_type_to_string(type), files[type]->name);\n        ok = compile_file_fns[type](files[type], keymap, merge);\n        if (!ok) {\n            log_err(ctx, \"Failed to compile %s\\n\",\n                    xkb_file_type_to_string(type));\n            return false;\n        }\n    }\n    return UpdateDerivedKeymapFields(keymap);\n}", "target": 1}
{"code": "static void xmt_remove_link_for_descriptor(GF_XMTParser* parser, GF_Descriptor* desc) {\n\tu32 i=0;\n\tXMT_ODLink *l, *to_del=NULL;\n\twhile ((l = (XMT_ODLink*)gf_list_enum(parser->od_links, &i)) ) {\n\t\tif (l->od && l->od == (GF_ObjectDescriptor*)desc) {\n\t\t\tl->od = NULL;\n\t\t\tto_del = l;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (to_del) {\n\t\ti=0;\n\t\tGF_Descriptor* subdesc;\n\t\twhile ((subdesc = gf_list_enum(((GF_ObjectDescriptor*)desc)->ESDescriptors, &i))) {\n\t\t\tif (subdesc) xmt_remove_link_for_descriptor(parser, subdesc);\n\t\t}\n\t\tgf_list_del_item(parser->od_links, to_del);\n\t\tif (to_del->desc_name) gf_free(to_del->desc_name);\n\t\tgf_list_del(to_del->mf_urls);\n\t\tgf_free(to_del);\n\t}\n\tXMT_ESDLink *esdl, *esdl_del=NULL;\n\ti=0;\n\twhile ((esdl = (XMT_ESDLink *)gf_list_enum(parser->esd_links, &i))) {\n\t\tif (esdl->esd && esdl->esd == (GF_ESD*)desc) {\n\t\t\tesdl->esd = NULL;\n\t\t\tesdl_del = esdl;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (esdl_del) {\n\t\tgf_list_del_item(parser->esd_links, esdl_del);\n\t\tif (esdl_del->desc_name) gf_free(esdl_del->desc_name);\n\t\tgf_free(esdl_del);\n\t}\n}", "target": 0}
{"code": "bgp_capability_receive (struct peer *peer, bgp_size_t size)\n{\n  u_char *pnt;\n  int ret;\n  pnt = stream_pnt (peer->ibuf);\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv CAPABILITY\", peer->host);\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP dynamic capability is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n  if (peer->status != Established)\n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Dynamic capability packet received under status %s\", peer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n  ret = bgp_capability_msg_parse (peer, pnt, size);\n}", "target": 1}
{"code": "static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)\n{\n\tint L1, L2, L3;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\tL2 = emitjump(J, F, OP_TRY);\n\t\t{\n\t\t\tcstm(J, F, finallystm); \n\t\t\temit(J, F, OP_THROW); \n\t\t}\n\t\tlabel(J, F, L2);\n\t\tif (F->strict) {\n\t\t\tcheckfutureword(J, F, catchvar);\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\temit(J, F, OP_ENDTRY);\n\t\tL3 = emitjump(J, F, OP_JUMP); \n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L3);\n\tcstm(J, F, finallystm);\n}", "target": 0}
{"code": "inline void ImageLoader::crossSiteOrCSPViolationOccurred(\n    AtomicString imageSourceURL) {\n  m_failedLoadURL = imageSourceURL;\n}", "target": 0}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "static void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmx_get_intr_info(vcpu);\n\tunsigned int vector = intr_info & INTR_INFO_VECTOR_MASK;\n\tgate_desc *desc = (gate_desc *)host_idt_base + vector;\n\tif (KVM_BUG(!is_external_intr(intr_info), vcpu->kvm,\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\thandle_interrupt_nmi_irqoff(vcpu, gate_offset(desc));\n\tvcpu->arch.at_instruction_boundary = true;\n}", "target": 0}
{"code": "flac_read_loop (SF_PRIVATE *psf, unsigned len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tpflac->pos = 0 ;\n\tpflac->len = len ;\n\tpflac->remain = len ;\n\tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)\n\t\tflac_buffer_copy (psf) ;\n\twhile (pflac->pos < pflac->len)\n\t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)\n\t\t\tbreak ;\n\t\tif (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t\tbreak ;\n\t\t} ;\n\tpflac->ptr = NULL ;\n\treturn pflac->pos ;\n} ", "target": 1}
{"code": "inline typename V::VariantType FBUnserializer<V>::unserializeThing() {\n  size_t code = nextCode();\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap());\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector());\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList());\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet());\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}", "target": 1}
{"code": "static int logi_dj_recv_switch_to_dj_mode(struct dj_receiver_dev *djrcv_dev,\n\t\t\t\t\t  unsigned timeout)\n{\n\tstruct dj_report *dj_report;\n\tint retval;\n\tdj_report = kzalloc(sizeof(struct dj_report), GFP_KERNEL);\n\tif (!dj_report)\n\t\treturn -ENOMEM;\n\tdj_report->report_id = REPORT_ID_DJ_SHORT;\n\tdj_report->device_index = 0xFF;\n\tdj_report->report_type = REPORT_TYPE_CMD_SWITCH;\n\tdj_report->report_params[CMD_SWITCH_PARAM_DEVBITFIELD] = 0x3F;\n\tdj_report->report_params[CMD_SWITCH_PARAM_TIMEOUT_SECONDS] = (u8)timeout;\n\tretval = logi_dj_recv_send_report(djrcv_dev, dj_report);\n\tkfree(dj_report);\n\tmsleep(50);\n\treturn retval;\n}", "target": 0}
{"code": "void mctp_dev_put(struct mctp_dev *mdev)\n{\n\tif (mdev && refcount_dec_and_test(&mdev->refs)) {\n\t\tkfree(mdev->addrs);\n\t\tdev_put(mdev->dev);\n\t\tkfree_rcu(mdev, rcu);\n\t}\n}", "target": 0}
{"code": "  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    if (mirror_pad_) {\n      const TfLiteMirrorPaddingParams* tf_options;\n      RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n      if (tf_options->mode !=\n          TfLiteMirrorPaddingMode::kTfLiteMirrorPaddingReflect) {\n        return absl::InvalidArgumentError(\n            \"Only Reflective padding is supported for Mirror Pad operation.\");\n      }\n    }\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 2));\n    RETURN_IF_ERROR(CheckInputsOutputs(context, tflite_node,\n                                       1, 1));\n    RETURN_IF_ERROR(CheckTensorIsAvailable(context, tflite_node, 1));\n    auto pad_tensor = tflite::GetInput(context, tflite_node, 1);\n    if (pad_tensor->dims->size != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor dimension: expected 2 dim, got \",\n          pad_tensor->dims->size, \" dim\"));\n    }\n    bool supported =\n        pad_tensor->dims->data[0] == 3 || pad_tensor->dims->data[0] == 4;\n    if (!supported || pad_tensor->dims->data[1] != 2) {\n      return absl::InvalidArgumentError(absl::StrCat(\n          \"Invalid paddings tensor shape: expected 4x2 or 3x2, got \",\n          pad_tensor->dims->data[0], \"x\", pad_tensor->dims->data[1]));\n    }\n    return absl::OkStatus();\n  }", "target": 1}
{"code": "SPL_METHOD(SplFileObject, fgets)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} ", "target": 0}
{"code": "Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t size_bound =\n      ss->ByteSize() + kTensorProtoHeaderBytes +\n      (MaxBytesPerElement(DataTypeToEnum<T>::value) * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}", "target": 1}
{"code": "int ext4_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tjournal = EXT4_JOURNAL(inode);\n\tif (!journal)\n\t\treturn 0;\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\tinode_dio_wait(inode);\n\tif (val) {\n\t\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\t\terr = filemap_write_and_wait(inode->i_mapping);\n\t\tif (err < 0) {\n\t\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\t\t\treturn err;\n\t\t}\n\t}\n\tpercpu_down_write(&sbi->s_journal_flag_rwsem);\n\tjbd2_journal_lock_updates(journal);\n\tif (val)\n\t\text4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\telse {\n\t\terr = jbd2_journal_flush(journal);\n\t\tif (err < 0) {\n\t\t\tjbd2_journal_unlock_updates(journal);\n\t\t\tpercpu_up_write(&sbi->s_journal_flag_rwsem);\n\t\t\treturn err;\n\t\t}\n\t\text4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\t}\n\text4_set_aops(inode);\n\tjbd2_journal_unlock_updates(journal);\n\tpercpu_up_write(&sbi->s_journal_flag_rwsem);\n\tif (val)\n\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_handle_sync(handle);\n\text4_journal_stop(handle);\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}", "target": 0}
{"code": "int64_t BZ2File::readImpl(char * buf, int64_t length) {\n  if (length == 0) {\n    return 0;\n  }\n  assertx(m_bzFile);\n  int len = BZ2_bzread(m_bzFile, buf, length);\n  if (len <= 0) {\n    setEof(true);\n    if (len < 0) {\n      return -1;\n    }\n  }\n  return len;\n}", "target": 1}
{"code": "TEE_Result syscall_hash_update(unsigned long state, const void *chunk,\n\t\t\tsize_t chunk_size)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tif (!chunk && chunk_size)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif (!chunk_size)\n\t\treturn TEE_SUCCESS;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t)chunk, chunk_size);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tswitch (TEE_ALG_GET_CLASS(cs->algo)) {\n\tcase TEE_OPERATION_DIGEST:\n\t\tres = crypto_hash_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tres = crypto_mac_update(cs->ctx, cs->algo, chunk, chunk_size);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}", "target": 1}
{"code": "void rose_stop_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "null_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int length = h->len;\n\tu_int caplen = h->caplen;\n\tu_int family;\n\tif (caplen < NULL_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|null]\"));\n\t\treturn (NULL_HDRLEN);\n\t}\n\tmemcpy((char *)&family, (const char *)p, sizeof(family));\n\tif ((family & 0xFFFF0000) != 0)\n\t\tfamily = SWAPLONG(family);\n\tif (ndo->ndo_eflag)\n\t\tnull_hdr_print(ndo, family, length);\n\tlength -= NULL_HDRLEN;\n\tcaplen -= NULL_HDRLEN;\n\tp += NULL_HDRLEN;\n\tswitch (family) {\n\tcase BSD_AFNUM_INET:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_INET6_BSD:\n\tcase BSD_AFNUM_INET6_FREEBSD:\n\tcase BSD_AFNUM_INET6_DARWIN:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_ISO:\n\t\tisoclns_print(ndo, p, length, caplen);\n\t\tbreak;\n\tcase BSD_AFNUM_APPLETALK:\n\t\tatalk_print(ndo, p, length);\n\t\tbreak;\n\tcase BSD_AFNUM_IPX:\n\t\tipx_print(ndo, p, length);\n\t\tbreak;\n\tdefault:\n\t\tif (!ndo->ndo_eflag)\n\t\t\tnull_hdr_print(ndo, family, length + NULL_HDRLEN);\n\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\tND_DEFAULTPRINT(p, caplen);\n\t}\n\treturn (NULL_HDRLEN);\n}", "target": 1}
{"code": "int rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n\tif (args->nr_local == 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\t\ttot_pages += nr_pages;\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn tot_pages * sizeof(struct scatterlist);\n}", "target": 0}
{"code": "static void __exit xfrm6_tunnel_fini(void)\n{\n\tunregister_pernet_subsys(&xfrm6_tunnel_net_ops);\n\txfrm6_tunnel_spi_fini();\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\n}", "target": 1}
{"code": "exit_sg(void)\n{\n#ifdef CONFIG_SCSI_PROC_FS\n\tremove_proc_subtree(\"scsi/sg\", NULL);\n#endif\t\t\t\t\n\tscsi_unregister_interface(&sg_interface);\n\tclass_destroy(sg_sysfs_class);\n\tsg_sysfs_valid = 0;\n\tunregister_chrdev_region(MKDEV(SCSI_GENERIC_MAJOR, 0),\n\t\t\t\t SG_MAX_DEVS);\n\tidr_destroy(&sg_index_idr);\n}", "target": 0}
{"code": "static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,\n\t\t\tstruct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint unit, err = -EFAULT;\n\tstruct ppp *ppp;\n\tstruct channel *chan;\n\tstruct ppp_net *pn;\n\tint __user *p = (int __user *)arg;\n\tmutex_lock(&ppp_mutex);\n\tswitch (cmd) {\n\tcase PPPIOCNEWUNIT:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\tppp = ppp_create_interface(net, unit, file, &err);\n\t\tif (!ppp)\n\t\t\tbreak;\n\t\tfile->private_data = &ppp->file;\n\t\terr = -EFAULT;\n\t\tif (put_user(ppp->file.index, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCATTACH:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = -ENXIO;\n\t\tpn = ppp_pernet(net);\n\t\tmutex_lock(&pn->all_ppp_mutex);\n\t\tppp = ppp_find_unit(pn, unit);\n\t\tif (ppp) {\n\t\t\tatomic_inc(&ppp->file.refcnt);\n\t\t\tfile->private_data = &ppp->file;\n\t\t\terr = 0;\n\t\t}\n\t\tmutex_unlock(&pn->all_ppp_mutex);\n\t\tbreak;\n\tcase PPPIOCATTCHAN:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = -ENXIO;\n\t\tpn = ppp_pernet(net);\n\t\tspin_lock_bh(&pn->all_channels_lock);\n\t\tchan = ppp_find_channel(pn, unit);\n\t\tif (chan) {\n\t\t\tatomic_inc(&chan->file.refcnt);\n\t\t\tfile->private_data = &chan->file;\n\t\t\terr = 0;\n\t\t}\n\t\tspin_unlock_bh(&pn->all_channels_lock);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\tmutex_unlock(&ppp_mutex);\n\treturn err;\n}", "target": 0}
{"code": "set_lenIV(char *line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 1}
{"code": "void rose_start_t2timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t2;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}", "target": 1}
{"code": "static bool torture_winbind_struct_getpwent(struct torture_context *torture)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tstruct winbindd_pw *pwent;\n\ttorture_comment(torture, \"Running WINBINDD_GETPWENT (struct based)\\n\");\n\ttorture_comment(torture, \" - Running WINBINDD_SETPWENT first\\n\");\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_SETPWENT, &req, &rep);\n\ttorture_comment(torture, \" - Running WINBINDD_GETPWENT now\\n\");\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\treq.data.num_entries = 1;\n\tif (torture_setting_bool(torture, \"samba3\", false)) {\n\t\tDO_STRUCT_REQ_REP_EXT(WINBINDD_GETPWENT, &req, &rep,\n\t\t\t\t      NSS_STATUS_SUCCESS, false, _STRUCT_NOOP,\n\t\t\t\t      NULL);\n\t} else {\n\t\tDO_STRUCT_REQ_REP(WINBINDD_GETPWENT, &req, &rep);\n\t}\n\tpwent = (struct winbindd_pw *)rep.extra_data.data;\n\tif (!torture_setting_bool(torture, \"samba3\", false)) {\n\t\ttorture_assert(torture, (pwent != NULL), \"NULL pwent\");\n\t}\n\tif (pwent) {\n\t\ttorture_comment(torture, \"name: %s, uid: %d, gid: %d, shell: %s\\n\",\n\t\t\t\tpwent->pw_name, pwent->pw_uid, pwent->pw_gid,\n\t\t\t\tpwent->pw_shell);\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "is_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}", "target": 0}
{"code": "void ConnPoolImplBase::closeIdleConnectionsForDrainingPool() {\n  Common::AutoDebugRecursionChecker assert_not_in(recursion_checker_);\n  std::list<ActiveClient*> to_close;\n  for (auto& client : ready_clients_) {\n    if (client->numActiveStreams() == 0) {\n      to_close.push_back(client.get());\n    }\n  }\n  if (pending_streams_.empty()) {\n    for (auto& client : connecting_clients_) {\n      to_close.push_back(client.get());\n    }\n  }\n  for (auto& entry : to_close) {\n    ENVOY_LOG_EVENT(debug, \"closing_idle_client\", \"closing idle client {} for cluster {}\",\n                    entry->id(), host_->cluster().name());\n    entry->close();\n  }\n}", "target": 0}
{"code": "static int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 flags = 0;\n\tbool have_flags = false;\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tpr_info(\"PF_BRIDGE: RTM_SETLINK with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS) {\n\t\t\t\tif (nla_len(attr) < sizeof(flags))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_setlink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\terr = br_dev->netdev_ops->ndo_bridge_setlink(dev, nlh, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_setlink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_setlink(dev, nlh,\n\t\t\t\t\t\t\t\t  flags);\n\t\tif (!err) {\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\t\t\terr = rtnl_bridge_notify(dev);\n\t\t}\n\t}\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\nout:\n\treturn err;\n}", "target": 0}
{"code": "static int nfs4_xdr_dec_readdir(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t\t\tstruct nfs4_readdir_res *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_readdir(xdr, rqstp, res);\nout:\n\treturn status;\n}", "target": 0}
{"code": "file_pipe2file(struct magic_set *ms, int fd, const void *startbuf,\n    size_t nbytes)\n{\n\tchar buf[4096];\n\tssize_t r;\n\tint tfd;\n\t(void)strlcpy(buf, \"/tmp/file.XXXXXX\", sizeof buf);\n#ifndef HAVE_MKSTEMP\n\t{\n\t\tchar *ptr = mktemp(buf);\n\t\ttfd = open(ptr, O_RDWR|O_TRUNC|O_EXCL|O_CREAT, 0600);\n\t\tr = errno;\n\t\t(void)unlink(ptr);\n\t\terrno = r;\n\t}\n#else\n\t{\n\t\tint te;\n\t\ttfd = mkstemp(buf);\n\t\tte = errno;\n\t\t(void)unlink(buf);\n\t\terrno = te;\n\t}\n#endif\n\tif (tfd == -1) {\n\t\tfile_error(ms, errno,\n\t\t    \"cannot create temporary file for pipe copy\");\n\t\treturn -1;\n\t}\n\tif (swrite(tfd, startbuf, nbytes) != (ssize_t)nbytes)\n\t\tr = 1;\n\telse {\n\t\twhile ((r = sread(fd, buf, sizeof(buf), 1)) > 0)\n\t\t\tif (swrite(tfd, buf, (size_t)r) != r)\n\t\t\t\tbreak;\n\t}\n\tswitch (r) {\n\tcase -1:\n\t\tfile_error(ms, errno, \"error copying from pipe to temp file\");\n\t\treturn -1;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\tfile_error(ms, errno, \"error while writing to temp file\");\n\t\treturn -1;\n\t}\n\tif ((fd = dup2(tfd, fd)) == -1) {\n\t\tfile_error(ms, errno, \"could not dup descriptor for temp file\");\n\t\treturn -1;\n\t}\n\t(void)close(tfd);\n\tif (FINFO_LSEEK_FUNC(fd, (off_t)0, SEEK_SET) == (off_t)-1) {\n\t\tfile_badseek(ms);\n\t\treturn -1;\n\t}\n\treturn fd;\n}", "target": 0}
{"code": "feed_table_block_tag(struct table *tbl,\n\t\t     char *line, struct table_mode *mode, int indent, int cmd)\n{\n    int offset;\n    if (mode->indent_level <= 0 && indent == -1)\n\treturn;\n    if (mode->indent_level >= CHAR_MAX && indent == 1)\n\treturn;\n    setwidth(tbl, mode);\n    feed_table_inline_tag(tbl, line, mode, -1);\n    clearcontentssize(tbl, mode);\n    if (indent == 1) {\n\tmode->indent_level++;\n\tif (mode->indent_level <= MAX_INDENT_LEVEL)\n\t    tbl->indent += INDENT_INCR;\n    }\n    else if (indent == -1) {\n\tmode->indent_level--;\n\tif (mode->indent_level < MAX_INDENT_LEVEL)\n\t    tbl->indent -= INDENT_INCR;\n    }\n    if (tbl->indent < 0)\n\ttbl->indent = 0;\n    offset = tbl->indent;\n    if (cmd == HTML_DT) {\n\tif (mode->indent_level > 0 && mode->indent_level <= MAX_INDENT_LEVEL)\n\t    offset -= INDENT_INCR;\n\tif (offset < 0)\n\t    offset = 0;\n    }\n    if (tbl->indent > 0) {\n\tcheck_minimum0(tbl, 0);\n\taddcontentssize(tbl, offset);\n    }\n}", "target": 0}
{"code": "de265_error decoder_context::decode_some(bool* did_work)\n{\n  de265_error err = DE265_OK;\n  *did_work = false;\n  if (image_units.empty()) { return DE265_OK; }  \n  if ( ! image_units.empty() ) { \n    image_unit* imgunit = image_units[0];\n    slice_unit* sliceunit = imgunit->get_next_unprocessed_slice_segment();\n    if (sliceunit != NULL) {\n      if (sliceunit->flush_reorder_buffer) {\n        dpb.flush_reorder_buffer();\n      }\n      *did_work = true;\n      err = decode_slice_unit_parallel(imgunit, sliceunit);\n      if (err) {\n        return err;\n      }\n    }\n  }\n  if ( ( image_units.size()>=2 && image_units[0]->all_slice_segments_processed()) ||\n       ( image_units.size()>=1 && image_units[0]->all_slice_segments_processed() &&\n         nal_parser.number_of_NAL_units_pending()==0 &&\n         (nal_parser.is_end_of_stream() || nal_parser.is_end_of_frame()) )) {\n    image_unit* imgunit = image_units[0];\n    *did_work=true;\n    imgunit->img->mark_all_CTB_progress(CTB_PROGRESS_PREFILTER);\n    if (img->decctx->num_worker_threads)\n      run_postprocessing_filters_parallel(imgunit);\n    else\n      run_postprocessing_filters_sequential(imgunit->img);\n    for (int i=0;i<imgunit->suffix_SEIs.size();i++) {\n      const sei_message& sei = imgunit->suffix_SEIs[i];\n      err = process_sei(&sei, imgunit->img);\n      if (err != DE265_OK)\n        break;\n    }\n    push_picture_to_output_queue(imgunit);\n    delete imgunit;\n    pop_front(image_units);\n  }\n  return err;\n}", "target": 0}
{"code": "sraSpanInsertAfter(sraSpan *newspan, sraSpan *after) {\n  newspan->_next = after->_next;\n  newspan->_prev = after;\n  after->_next->_prev = newspan;\n  after->_next = newspan;\n}", "target": 1}
{"code": "COMPAT_SYSCALL_DEFINE5(waitid,\n\t\tint, which, compat_pid_t, pid,\n\t\tstruct compat_siginfo __user *, infop, int, options,\n\t\tstruct compat_rusage __user *, uru)\n{\n\tstruct rusage ru;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err && uru) {\n\t\tif (COMPAT_USE_64BIT_TIME)\n\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n\t\telse\n\t\t\terr = put_compat_rusage(&ru, uru);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "char *LibRaw_buffer_datastream::gets(char *s, int sz)\n{\n  if(sz<1) return NULL;\n  unsigned char *psrc, *pdest, *str;\n  str = (unsigned char *)s;\n  psrc = buf + streampos;\n  pdest = str;\n  if(streampos >= streamsize) return NULL;\n  while ((size_t(psrc - buf) < streamsize) && ((pdest - str) < (sz-1)))\n  {\n    *pdest = *psrc;\n    if (*psrc == '\\n')\n      break;\n    psrc++;\n    pdest++;\n  }\n  if (size_t(psrc - buf) < streamsize)\n    psrc++;\n  if ((pdest - str) < sz-1)\n    *(++pdest) = 0;\n  else\n    s[sz - 1] = 0; \n  streampos = psrc - buf;\n  return s;\n}", "target": 0}
{"code": "static int update_discovery_filter(struct btd_adapter *adapter)\n{\n\tstruct mgmt_cp_start_service_discovery *sd_cp;\n\tGSList *l;\n\tDBG(\"\");\n\tif (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) {\n\t\tbtd_error(adapter->dev_id,\n\t\t\t\t\"discovery_filter_to_mgmt_cp returned error\");\n\t\treturn -ENOMEM;\n\t}\n\tfor (l = adapter->discovery_list; l; l = g_slist_next(l)) {\n\t\tstruct discovery_client *client = l->data;\n\t\tif (!client->discovery_filter)\n\t\t\tcontinue;\n\t\tif (client->discovery_filter->discoverable)\n\t\t\tbreak;\n\t}\n\tset_discovery_discoverable(adapter, l ? true : false);\n\tif (filters_equal(adapter->current_discovery_filter, sd_cp) &&\n\t    adapter->discovering != 0) {\n\t\tDBG(\"filters were equal, deciding to not restart the scan.\");\n\t\tg_free(sd_cp);\n\t\treturn 0;\n\t}\n\tg_free(adapter->current_discovery_filter);\n\tadapter->current_discovery_filter = sd_cp;\n\ttrigger_start_discovery(adapter, 0);\n\treturn -EINPROGRESS;\n}", "target": 1}
{"code": "win_init_some(win_T *newp, win_T *oldp)\n{\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n    win_copy_options(oldp, newp);\n}", "target": 0}
{"code": "acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,\n\t\t\t\t  void *context)\n{\n\tunsigned int irq;\n\tacpi_irq_stats_init();\n\tif (gsi != acpi_gbl_FADT.sci_interrupt)\n\t\treturn AE_BAD_PARAMETER;\n\tif (acpi_irq_handler)\n\t\treturn AE_ALREADY_ACQUIRED;\n\tif (acpi_gsi_to_irq(gsi, &irq) < 0) {\n\t\tprintk(KERN_ERR PREFIX \"SCI (ACPI GSI %d) not registered\\n\",\n\t\t       gsi);\n\t\treturn AE_OK;\n\t}\n\tacpi_irq_handler = handler;\n\tacpi_irq_context = context;\n\tif (request_irq(irq, acpi_irq, IRQF_SHARED, \"acpi\", acpi_irq)) {\n\t\tprintk(KERN_ERR PREFIX \"SCI (IRQ%d) allocation failed\\n\", irq);\n\t\tacpi_irq_handler = NULL;\n\t\treturn AE_NOT_ACQUIRED;\n\t}\n\tacpi_sci_irq = irq;\n\treturn AE_OK;\n}", "target": 0}
{"code": "static inline bool sctp_peer_needs_update(struct sctp_association *asoc)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tswitch (asoc->state) {\n\tcase SCTP_STATE_ESTABLISHED:\n\tcase SCTP_STATE_SHUTDOWN_PENDING:\n\tcase SCTP_STATE_SHUTDOWN_RECEIVED:\n\tcase SCTP_STATE_SHUTDOWN_SENT:\n\t\tif ((asoc->rwnd > asoc->a_rwnd) &&\n\t\t    ((asoc->rwnd - asoc->a_rwnd) >= max_t(__u32,\n\t\t\t   (asoc->base.sk->sk_rcvbuf >> net->sctp.rwnd_upd_shift),\n\t\t\t   asoc->pathmtu)))\n\t\t\treturn true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "int snmp_version(void *context, size_t hdrlen, unsigned char tag,\n\t\t const void *data, size_t datalen)\n{\n\tif (datalen != 1)\n\t\treturn -EINVAL;\n\tif (*(unsigned char *)data > 1)\n\t\treturn -ENOTSUPP;\n\treturn 1;\n}", "target": 0}
{"code": "static int del_balance_item(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key key;\n\tint ret, err;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\ttrans = btrfs_start_transaction(root, 0);\n\tif (IS_ERR(trans)) {\n\t\tbtrfs_free_path(path);\n\t\treturn PTR_ERR(trans);\n\t}\n\tkey.objectid = BTRFS_BALANCE_OBJECTID;\n\tkey.type = BTRFS_TEMPORARY_ITEM_KEY;\n\tkey.offset = 0;\n\tret = btrfs_search_slot(trans, root, &key, path, -1, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tret = btrfs_del_item(trans, root, path);\nout:\n\tbtrfs_free_path(path);\n\terr = btrfs_commit_transaction(trans);\n\tif (err && !ret)\n\t\tret = err;\n\treturn ret;\n}", "target": 0}
{"code": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[4];\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}", "target": 1}
{"code": "\tvoid Execute(CommandSource &source, const std::vector<Anope::string> &params) anope_override\n\t{\n\t\tconst NickAlias *na;\n\t\tif (!(na = NickAlias::Find(params[0])))\n\t\t\tsource.Reply(NICK_X_NOT_REGISTERED, params[0].c_str());\n\t\telse if (na->nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\tsource.Reply(NICK_X_SUSPENDED, na->nc->display.c_str());\n\t\telse if (!na->nc->email.equals_ci(params[1]))\n\t\t\tsource.Reply(_(\"Incorrect email address.\"));\n\t\telse\n\t\t{\n\t\t\tif (SendResetEmail(source.GetUser(), na, source.service))\n\t\t\t{\n\t\t\t\tLog(LOG_COMMAND, source, this) << \"for \" << na->nick << \" (group: \" << na->nc->display << \")\";\n\t\t\t\tsource.Reply(_(\"Password reset email for \\002%s\\002 has been sent.\"), na->nick.c_str());\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}", "target": 0}
{"code": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\tif (more)\n\t\treturn;\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1}
{"code": "static inline neu_msg_t *neu_msg_new(neu_reqresp_type_e t, void *ctx,\n                                     void *data)\n{\n    size_t data_size = neu_reqresp_size(t);\n    size_t body_size = 0;\n    switch (t) {\n    case NEU_REQ_CHECK_SCHEMA:\n        body_size = neu_reqresp_size(NEU_RESP_CHECK_SCHEMA);\n        break;\n    case NEU_REQ_GET_PLUGIN:\n        body_size = neu_reqresp_size(NEU_RESP_GET_PLUGIN);\n        break;\n    case NEU_REQ_UPDATE_GROUP:\n    case NEU_REQ_UPDATE_DRIVER_GROUP:\n        body_size = neu_reqresp_size(NEU_RESP_UPDATE_DRIVER_GROUP);\n        break;\n    case NEU_REQ_UPDATE_NODE:\n    case NEU_REQ_NODE_RENAME:\n        body_size = neu_reqresp_size(NEU_RESP_NODE_RENAME);\n        break;\n    case NEU_REQ_DEL_NODE:\n        body_size = neu_reqresp_size(NEU_RESP_NODE_UNINIT);\n        break;\n    case NEU_REQ_GET_NODE_SETTING:\n        body_size = neu_reqresp_size(NEU_RESP_GET_NODE_SETTING);\n        break;\n    case NEU_REQ_GET_NODES_STATE:\n        body_size = neu_reqresp_size(NEU_RESP_GET_NODES_STATE);\n        break;\n    default:\n        body_size = data_size;\n    }\n    size_t     total = sizeof(neu_msg_t) + body_size;\n    neu_msg_t *msg   = calloc(1, total);\n    if (msg) {\n        msg->head.type = t;\n        msg->head.len  = total;\n        msg->head.ctx  = ctx;\n        if (data) {\n            memcpy(msg->body, data, data_size);\n        }\n    }\n    return msg;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    ValidateInputTensors(ctx, in0, in1);\n    if (!ctx->status().ok()) return;\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);  \n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d1);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchBandedTriangularSolve<Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }", "target": 0}
{"code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\tif (!domain)\n\t\treturn 0;\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\t\tgfn += page_size >> PAGE_SHIFT;\n\t}\n\treturn 0;\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}", "target": 0}
{"code": "static unsigned long mb2_cache_scan(struct shrinker *shrink,\n\t\t\t\t    struct shrink_control *sc)\n{\n\tint nr_to_scan = sc->nr_to_scan;\n\tstruct mb2_cache *cache = container_of(shrink, struct mb2_cache,\n\t\t\t\t\t      c_shrink);\n\tstruct mb2_cache_entry *entry;\n\tstruct hlist_bl_head *head;\n\tunsigned int shrunk = 0;\n\tspin_lock(&cache->c_lru_list_lock);\n\twhile (nr_to_scan-- && !list_empty(&cache->c_lru_list)) {\n\t\tentry = list_first_entry(&cache->c_lru_list,\n\t\t\t\t\t struct mb2_cache_entry, e_lru_list);\n\t\tlist_del_init(&entry->e_lru_list);\n\t\tcache->c_entry_count--;\n\t\tspin_unlock(&cache->c_lru_list_lock);\n\t\thead = entry->e_hash_list_head;\n\t\thlist_bl_lock(head);\n\t\tif (!hlist_bl_unhashed(&entry->e_hash_list)) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t}\n\t\thlist_bl_unlock(head);\n\t\tif (mb2_cache_entry_put(cache, entry))\n\t\t\tshrunk++;\n\t\tcond_resched();\n\t\tspin_lock(&cache->c_lru_list_lock);\n\t}\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn shrunk;\n}", "target": 0}
{"code": "void rds_inc_info_copy(struct rds_incoming *inc,\n\t\t       struct rds_info_iterator *iter,\n\t\t       __be32 saddr, __be32 daddr, int flip)\n{\n\tstruct rds_info_message minfo;\n\tminfo.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo.len = be32_to_cpu(inc->i_hdr.h_len);\n\tif (flip) {\n\t\tminfo.laddr = daddr;\n\t\tminfo.faddr = saddr;\n\t\tminfo.lport = inc->i_hdr.h_dport;\n\t\tminfo.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo.laddr = saddr;\n\t\tminfo.faddr = daddr;\n\t\tminfo.lport = inc->i_hdr.h_sport;\n\t\tminfo.fport = inc->i_hdr.h_dport;\n\t}\n\tminfo.flags = 0;\n\trds_info_copy(iter, &minfo, sizeof(minfo));\n}", "target": 0}
{"code": "ext4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}", "target": 1}
{"code": "static ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n\t\tgoto err3;\n\t}\n\tmutex_lock(&mut);\n\tidr_replace(&multicast_idr, mc, mc->id);\n\tmutex_unlock(&mut);\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn 0;\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}", "target": 0}
{"code": "}\nvoid print_udta(GF_ISOFile *file, u32 track_number, Bool has_itags)\n{\n\tu32 i, count;\n\tcount =  gf_isom_get_udta_count(file, track_number);\n\tif (!count) return;\n\tif (has_itags) {\n\t\tfor (i=0; i<count; i++) {\n\t\t\tu32 type;\n\t\t\tbin128 uuid;\n\t\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\t\tif (type == GF_ISOM_BOX_TYPE_META) {\n\t\t\t\tcount--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!count) return;\n\t}\n\tfprintf(stderr, \"%d UDTA types: \", count);\n\tfor (i=0; i<count; i++) {\n\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}", "target": 1}
{"code": "void CarbonProtocolReader::skip(const FieldType ft) {\n  switch (ft) {\n    case FieldType::True:\n    case FieldType::False: {\n      break;\n    }\n    case FieldType::Int8: {\n      readRaw<int8_t>();\n      break;\n    }\n    case FieldType::Int16: {\n      readRaw<int16_t>();\n      break;\n    }\n    case FieldType::Int32: {\n      readRaw<int32_t>();\n      break;\n    }\n    case FieldType::Int64: {\n      readRaw<int64_t>();\n      break;\n    }\n    case FieldType::Double: {\n      readRaw<double>();\n      break;\n    }\n    case FieldType::Float: {\n      readRaw<float>();\n      break;\n    }\n    case FieldType::Binary: {\n      readRaw<std::string>();\n      break;\n    }\n    case FieldType::List: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Struct: {\n      readStructBegin();\n      while (true) {\n        const auto fieldType = readFieldHeader().first;\n        if (fieldType == FieldType::Stop) {\n          break;\n        }\n        skip(fieldType);\n      }\n      readStructEnd();\n      break;\n    }\n    case FieldType::Set: {\n      skipLinearContainer();\n      break;\n    }\n    case FieldType::Map: {\n      skipKVContainer();\n      break;\n    }\n    default: { break; }\n  }\n}", "target": 1}
{"code": "void client_reset(t_client *client)\n{\n\tchar *hash;\n\tchar *msg;\n\tchar *cidinfo;\n\tdebug(LOG_DEBUG, \"Resetting client [%s]\", client->mac);\n\tclient->counters.incoming = 0;\n\tclient->counters.outgoing = 0;\n\tclient->counters.last_updated = time(NULL);\n\tclient->session_start = 0;\n\tclient->session_end = 0;\n\thash = safe_calloc(STATUS_BUF);\n\tclient->token = safe_calloc(STATUS_BUF);\n\tsafe_snprintf(client->token, STATUS_BUF, \"%04hx%04hx\", rand16(), rand16());\n\thash_str(hash, STATUS_BUF, client->token);\n\tclient->hid = safe_strdup(hash);\n\tfree(hash);\n\tclient->custom = safe_calloc(MID_BUF);\n\tclient->client_type = safe_calloc(STATUS_BUF);\n\tif (client->cid) {\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t\tclient->cid = safe_calloc(SMALL_BUF);\n\t}\n}", "target": 1}
{"code": "static int smm_stub_place_staggered_entry_points(char *base,\n\tconst struct smm_loader_params *params, const struct rmodule *smm_stub)\n{\n\tsize_t stub_entry_offset;\n\tint rc = 1;\n\tstub_entry_offset = rmodule_entry_offset(smm_stub);\n\tif (params->num_concurrent_save_states > 1 || stub_entry_offset != 0) {\n\t\trc = smm_place_entry_code((unsigned int)base,\n\t\t\tparams->num_concurrent_save_states,\n\t\t\t(unsigned int)params->stack_top, params);\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "static void validate_set_si_mode(struct bnx2x *bp)\n{\n\tu8 func = BP_ABS_FUNC(bp);\n\tu32 val;\n\tval = MF_CFG_RD(bp, func_mf_config[func].mac_upper);\n\tif (val != 0xffff) {\n\t\tbp->mf_mode = MULTI_FUNCTION_SI;\n\t\tbp->mf_config[BP_VN(bp)] =\n\t\t\tMF_CFG_RD(bp, func_mf_config[func].config);\n\t} else\n\t\tBNX2X_DEV_INFO(\"illegal MAC address for SI\\n\");\n}", "target": 0}
{"code": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\tINFO(\"console has been setup\");\n\treturn 0;\n}", "target": 1}
{"code": "struct crypto_template *crypto_lookup_template(const char *name)\n{\n\treturn try_then_request_module(__crypto_lookup_template(name), \"%s\",\n\t\t\t\t       name);\n}", "target": 1}
{"code": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}", "target": 1}
{"code": "eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n    WebKitWebFrame *frame;\n    JSGlobalContextRef context;\n    JSObjectRef globalobject;\n    JSStringRef var_name;\n    JSStringRef js_script;\n    JSValueRef js_result;\n    JSStringRef js_result_string;\n    size_t js_result_size;\n    js_init();\n    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));\n    context = webkit_web_frame_get_global_context(frame);\n    globalobject = JSContextGetGlobalObject(context);\n    var_name = JSStringCreateWithUTF8CString(\"Uzbl\");\n    JSObjectSetProperty(context, globalobject, var_name,\n                        JSObjectMake(context, uzbl.js.classref, NULL),\n                        kJSClassAttributeNone, NULL);\n    js_script = JSStringCreateWithUTF8CString(script);\n    js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    if (js_result && !JSValueIsUndefined(context, js_result)) {\n        js_result_string = JSValueToStringCopy(context, js_result, NULL);\n        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);\n        if (js_result_size) {\n            char js_result_utf8[js_result_size];\n            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);\n            g_string_assign(result, js_result_utf8);\n        }\n        JSStringRelease(js_result_string);\n    }\n    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n    JSStringRelease(var_name);\n    JSStringRelease(js_script);\n}", "target": 1}
{"code": "WM_SYMBOL midi *WildMidi_Open(const char *midifile) {\n    uint8_t *mididata = NULL;\n    uint32_t midisize = 0;\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midifile == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL filename)\", 0);\n        return (NULL);\n    }\n    if ((mididata = (uint8_t *) _WM_BufferFile(midifile, &midisize)) == NULL) {\n        return (NULL);\n    }\n    if (midisize < 18) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_CORUPT, \"(too short)\", 0);\n        return (NULL);\n    }\n    if (memcmp(mididata,\"HMIMIDIP\", 8) == 0) {\n        ret = (void *) _WM_ParseNewHmp(mididata, midisize);\n    } else if (memcmp(mididata, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(mididata, midisize);\n    } else if (memcmp(mididata, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(mididata, midisize);\n    } else if (memcmp(mididata, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(mididata, midisize);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(mididata, midisize);\n    }\n    free(mididata);\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}", "target": 0}
{"code": "crm_recv_tls(gnutls_session * session, size_t max_size, size_t *recv_len, int *disconnected)\n{\n    char *buf = NULL;\n    int rc = 0;\n    size_t len = 0;\n    size_t chunk_size = max_size ? max_size : 1024;\n    size_t buf_size = 0;\n    size_t read_size = 0;\n    if (session == NULL) {\n        if (disconnected) {\n            *disconnected = 1;\n        }\n        goto done;\n    }\n    buf = calloc(1, chunk_size + 1);\n    buf_size = chunk_size;\n    while (TRUE) {\n        read_size = buf_size - len;\n        if (!max_size && (read_size < (chunk_size / 2))) {\n            buf_size += chunk_size;\n            crm_trace(\"Grow buffer by %d more bytes. buf is now %d bytes\", (int)chunk_size, buf_size);\n            buf = realloc(buf, buf_size + 1);\n            CRM_ASSERT(buf != NULL);\n            read_size = buf_size - len;\n        }\n        rc = gnutls_record_recv(*session, buf + len, read_size);\n        if (rc > 0) {\n            crm_trace(\"Got %d more bytes.\", rc);\n            len += rc;\n            buf[len] = '\\0';\n        }\n        if (max_size && (max_size == read_size)) {\n            crm_trace(\"Buffer max read size %d met\" , max_size);\n            goto done;\n        }\n        if (rc == GNUTLS_E_INTERRUPTED) {\n            crm_trace(\"EINTR encoutered, retry tls read\");\n        } else if (rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"non-blocking, exiting read on rc = %d\", rc);\n            goto done;\n        } else if (rc <= 0) {\n            if (rc == 0) {\n                crm_debug(\"EOF encoutered during TLS read\");\n            } else {\n                crm_debug(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            }\n            if (disconnected) {\n                *disconnected = 1;\n            }\n            goto done;\n        }\n    }\ndone:\n    if (recv_len) {\n        *recv_len = len;\n    }\n    if (!len) {\n        free(buf);\n        buf = NULL;\n    }\n    return buf;\n}", "target": 0}
{"code": "static int is_cmd_rcvr_exclusive(struct ipmi_smi *intf,\n\t\t\t\t unsigned char netfn,\n\t\t\t\t unsigned char cmd,\n\t\t\t\t unsigned int  chans)\n{\n\tstruct cmd_rcvr *rcvr;\n\tlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link) {\n\t\tif ((rcvr->netfn == netfn) && (rcvr->cmd == cmd)\n\t\t\t\t\t&& (rcvr->chans & chans))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int sclp_ctl_ioctl_sccb(void __user *user_area)\n{\n\tstruct sclp_ctl_sccb ctl_sccb;\n\tstruct sccb_header *sccb;\n\tint rc;\n\tif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\n\t\treturn -EFAULT;\n\tif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\n\t\treturn -EOPNOTSUPP;\n\tsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\n\tif (!sccb)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sizeof(*sccb))) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\tif (sccb->length > PAGE_SIZE || sccb->length < 8)\n\t\treturn -EINVAL;\n\tif (copy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), sccb->length)) {\n\t\trc = -EFAULT;\n\t\tgoto out_free;\n\t}\n\trc = sclp_sync_request(ctl_sccb.cmdw, sccb);\n\tif (rc)\n\t\tgoto out_free;\n\tif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\n\t\trc = -EFAULT;\nout_free:\n\tfree_page((unsigned long) sccb);\n\treturn rc;\n}", "target": 1}
{"code": "uipbuf_clear(void)\n{\n  uip_len = 0;\n  uip_ext_len = 0;\n  uip_last_proto = 0;\n  uipbuf_clear_attr();\n}", "target": 0}
{"code": "Eina_Bool ewk_view_stop(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_stop(smartData->main_frame);\n}", "target": 0}
{"code": "static int _dns_encode_domain(struct dns_context *context, const char *domain)\n{\n\tint num = 0;\n\tint total_len = 0;\n\tunsigned char *ptr_num = context->ptr++;\n\tint dict_offset = 0;\n\tdict_offset = _dns_get_domain_offset(context, domain);\n\ttotal_len++;\n\twhile (_dns_left_len(context) > 1 && *domain != 0) {\n\t\ttotal_len++;\n\t\tif (dict_offset >= 0) {\n\t\t\tint offset = 0xc000 | dict_offset;\n\t\t\tif (_dns_left_len(context) < 2) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t_dns_write_short(&ptr_num, offset);\n\t\t\tcontext->ptr++;\n\t\t\tptr_num = NULL;\n\t\t\treturn total_len;\n\t\t}\n\t\tif (*domain == '.') {\n\t\t\t*ptr_num = num;\n\t\t\tnum = 0;\n\t\t\tptr_num = context->ptr;\n\t\t\tdomain++;\n\t\t\tcontext->ptr++;\n\t\t\tdict_offset = _dns_get_domain_offset(context, domain);\n\t\t\tcontinue;\n\t\t}\n\t\t*context->ptr = *domain;\n\t\tnum++;\n\t\tcontext->ptr++;\n\t\tdomain++;\n\t}\n\tif (_dns_left_len(context) < 1) {\n\t\treturn -1;\n\t}\n\t*ptr_num = num;\n\tif (total_len > 1) {\n\t\t*(context->ptr) = 0;\n\t\ttotal_len++;\n\t\tcontext->ptr++;\n\t}\n\tif (_dns_left_len(context) <= 0) {\n\t\treturn -1;\n\t}\n\treturn total_len;\n}", "target": 0}
{"code": "static void cil_reset_classpermission(struct cil_classpermission *cp)\n{\n\tif (cp == NULL) {\n\t\treturn;\n\t}\n\tcil_reset_classperms_list(cp->classperms);\n}", "target": 1}
{"code": "int anon_vma_fork(struct vm_area_struct *vma, struct vm_area_struct *pvma)\n{\n\tstruct anon_vma_chain *avc;\n\tstruct anon_vma *anon_vma;\n\tint error;\n\tif (!pvma->anon_vma)\n\t\treturn 0;\n\tvma->anon_vma = NULL;\n\terror = anon_vma_clone(vma, pvma);\n\tif (error)\n\t\treturn error;\n\tif (vma->anon_vma)\n\t\treturn 0;\n\tanon_vma = anon_vma_alloc();\n\tif (!anon_vma)\n\t\tgoto out_error;\n\tavc = anon_vma_chain_alloc(GFP_KERNEL);\n\tif (!avc)\n\t\tgoto out_error_free_anon_vma;\n\tanon_vma->root = pvma->anon_vma->root;\n\tanon_vma->parent = pvma->anon_vma;\n\tget_anon_vma(anon_vma->root);\n\tvma->anon_vma = anon_vma;\n\tanon_vma_lock_write(anon_vma);\n\tanon_vma_chain_link(vma, avc, anon_vma);\n\tanon_vma->parent->degree++;\n\tanon_vma_unlock_write(anon_vma);\n\treturn 0;\n out_error_free_anon_vma:\n\tput_anon_vma(anon_vma);\n out_error:\n\tunlink_anon_vmas(vma);\n\treturn -ENOMEM;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64_t>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64_t weights_size = weights.size();\n    OP_REQUIRES(ctx, size_t.dims() == 0,\n                errors::InvalidArgument(\"Shape must be rank 0 but is rank \",\n                                        size_t.dims()));\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    OP_REQUIRES(ctx, splits.size() > 0,\n                errors::InvalidArgument(\"Splits must be non-empty\"));\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 0}
{"code": "xid_map_enter(netdissect_options *ndo,\n              const struct sunrpc_msg *rp, const u_char *bp)\n{\n\tconst struct ip *ip = NULL;\n\tconst struct ip6_hdr *ip6 = NULL;\n\tstruct xid_map_entry *xmep;\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\tswitch (IP_V((const struct ip *)bp)) {\n\tcase 4:\n\t\tip = (const struct ip *)bp;\n\t\tbreak;\n\tcase 6:\n\t\tip6 = (const struct ip6_hdr *)bp;\n\t\tbreak;\n\tdefault:\n\t\treturn (1);\n\t}\n\txmep = &xid_map[xid_map_next];\n\tif (++xid_map_next >= XIDMAPSIZE)\n\t\txid_map_next = 0;\n\tUNALIGNED_MEMCPY(&xmep->xid, &rp->rm_xid, sizeof(xmep->xid));\n\tif (ip) {\n\t\txmep->ipver = 4;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip->ip_src, sizeof(ip->ip_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip->ip_dst, sizeof(ip->ip_dst));\n\t}\n\telse if (ip6) {\n\t\txmep->ipver = 6;\n\t\tUNALIGNED_MEMCPY(&xmep->client, &ip6->ip6_src, sizeof(ip6->ip6_src));\n\t\tUNALIGNED_MEMCPY(&xmep->server, &ip6->ip6_dst, sizeof(ip6->ip6_dst));\n\t}\n\tif (!ND_TTEST(rp->rm_call.cb_proc))\n\t\treturn (0);\n\txmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);\n\tif (!ND_TTEST(rp->rm_call.cb_vers))\n\t\treturn (0);\n\txmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);\n\treturn (1);\n}", "target": 0}
{"code": "int dns_HTTPS_add_ipv4hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_A_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_A_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV4HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_A_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_A_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int __audit_mq_timedreceive(mqd_t mqdes, size_t msg_len,\n\t\t\t\tunsigned int __user *u_msg_prio,\n\t\t\t\tconst struct timespec __user *u_abs_timeout)\n{\n\tstruct audit_aux_data_mq_sendrecv *ax;\n\tstruct audit_context *context = current->audit_context;\n\tif (!audit_enabled)\n\t\treturn 0;\n\tif (likely(!context))\n\t\treturn 0;\n\tax = kmalloc(sizeof(*ax), GFP_ATOMIC);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\tif (u_msg_prio != NULL) {\n\t\tif (get_user(ax->msg_prio, u_msg_prio)) {\n\t\t\tkfree(ax);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else\n\t\tax->msg_prio = 0;\n\tif (u_abs_timeout != NULL) {\n\t\tif (copy_from_user(&ax->abs_timeout, u_abs_timeout, sizeof(ax->abs_timeout))) {\n\t\t\tkfree(ax);\n\t\t\treturn -EFAULT;\n\t\t}\n\t} else\n\t\tmemset(&ax->abs_timeout, 0, sizeof(ax->abs_timeout));\n\tax->mqdes = mqdes;\n\tax->msg_len = msg_len;\n\tax->d.type = AUDIT_MQ_SENDRECV;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\treturn 0;\n}", "target": 0}
{"code": "int ipmi_destroy_user(struct ipmi_user *user)\n{\n\t_ipmi_destroy_user(user);\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkref_put(&user->refcount, free_user);\n\treturn 0;\n}", "target": 1}
{"code": "Adaptation::Ecap::Host::Host()\n{\n    libecap::headerTransferEncoding.assignHostId(Http::HdrType::TRANSFER_ENCODING);\n    libecap::headerReferer.assignHostId(Http::HdrType::REFERER);\n    libecap::headerContentLength.assignHostId(Http::HdrType::CONTENT_LENGTH);\n    libecap::headerVia.assignHostId(Http::HdrType::VIA);\n    libecap::protocolHttp.assignHostId(AnyP::PROTO_HTTP);\n    libecap::protocolHttps.assignHostId(AnyP::PROTO_HTTPS);\n    libecap::protocolFtp.assignHostId(AnyP::PROTO_FTP);\n    libecap::protocolGopher.assignHostId(AnyP::PROTO_GOPHER);\n    libecap::protocolWais.assignHostId(AnyP::PROTO_WAIS);\n    libecap::protocolUrn.assignHostId(AnyP::PROTO_URN);\n    libecap::protocolWhois.assignHostId(AnyP::PROTO_WHOIS);\n    protocolCacheObj.assignHostId(AnyP::PROTO_CACHE_OBJECT);\n    protocolIcp.assignHostId(AnyP::PROTO_ICP);\n#if USE_HTCP\n    protocolHtcp.assignHostId(AnyP::PROTO_HTCP);\n#endif\n    protocolIcy.assignHostId(AnyP::PROTO_ICY);\n    protocolUnknown.assignHostId(AnyP::PROTO_UNKNOWN);\n    metaBypassable.assignHostId(1);\n}", "target": 1}
{"code": "static void on_underlying_io_bytes_received(void *context, const unsigned char *buffer, size_t size)\n{\n    if (context != NULL)\n    {\n        TLS_IO_INSTANCE *tls_io_instance = (TLS_IO_INSTANCE *)context;\n        unsigned char *new_socket_io_read_bytes = (unsigned char *)realloc(tls_io_instance->socket_io_read_bytes, tls_io_instance->socket_io_read_byte_count + size);\n        if (new_socket_io_read_bytes == NULL)\n        {\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else\n        {\n            tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;\n            (void)memcpy(tls_io_instance->socket_io_read_bytes + tls_io_instance->socket_io_read_byte_count, buffer, size);\n            tls_io_instance->socket_io_read_byte_count += size;\n        }\n    }\n    else\n    {\n        LogError(\"NULL value passed in context\");\n    }\n}", "target": 1}
{"code": "static int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t++vcpu->stat.irq_window_exits;\n\tif (!irqchip_in_kernel(vcpu->kvm) &&\n\t    vcpu->run->request_interrupt_window &&\n\t    !kvm_cpu_has_interrupt(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}", "target": 1}
{"code": "int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu64 mode = (*(u64 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\t\tif (!system_supports_32bit_el0())\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\t\tif (!vcpu_el1_is_32bit(vcpu))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tif (vcpu_el1_is_32bit(vcpu))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}", "target": 0}
{"code": "  TfLiteRegistration OkOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int needs_empty_write(sector_t block, struct inode *inode)\n{\n\tint error;\n\tstruct buffer_head bh_map = { .b_state = 0, .b_blocknr = 0 };\n\tbh_map.b_size = 1 << inode->i_blkbits;\n\terror = gfs2_block_map(inode, block, &bh_map, 0);\n\tif (unlikely(error))\n\t\treturn error;\n\treturn !buffer_mapped(&bh_map);\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                    const Variant& module ) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.asCStrRef().data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}", "target": 1}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tif (addr + size > pdi->bar[bidx].addr + pdi->bar[bidx].size) {\n\t\tprintf(\"%s, Out of emulated memory range.\\n\", __func__);\n\t\treturn -ESRCH;\n\t}\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "    **/\n    CImg<T>& log2() {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=4096))\n      cimg_rof(*this,ptrd,T) *ptrd = (T)cimg::log2((double)*ptrd);\n      return *this;", "target": 0}
{"code": "TIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n\t\tif (!TIFFAppendToStrip(tif,\n\t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n\t\t    tif->tif_rawdata, tif->tif_rawcc))\n        {\n            tif->tif_rawcc = 0;\n            tif->tif_rawcp = tif->tif_rawdata;\n\t\t\treturn (0);\n        }\n\t\ttif->tif_rawcc = 0;\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t}\n\treturn (1);\n}", "target": 0}
{"code": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n}", "target": 1}
{"code": "set_option_info(struct archive_string *info, int *opt, const char *key,\n    enum keytype type,  ...)\n{\n\tva_list ap;\n\tchar prefix;\n\tconst char *s;\n\tint d;\n\tprefix = (*opt==0)? ' ':',';\n\tva_start(ap, type);\n\tswitch (type) {\n\tcase KEY_FLG:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s%s\",\n\t\t    prefix, (d == 0)?\"!\":\"\", key);\n\t\tbreak;\n\tcase KEY_STR:\n\t\ts = va_arg(ap, const char *);\n\t\tarchive_string_sprintf(info, \"%c%s=%s\",\n\t\t    prefix, key, s);\n\t\tbreak;\n\tcase KEY_INT:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s=%d\",\n\t\t    prefix, key, d);\n\t\tbreak;\n\tcase KEY_HEX:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s=%x\",\n\t\t    prefix, key, d);\n\t\tbreak;\n\t}\n\tva_end(ap);\n\t*opt = 1;\n}", "target": 0}
{"code": "static MagickBooleanType DrawStrokePolygon(Image *image,\n  const DrawInfo *draw_info,const PrimitiveInfo *primitive_info,\n  ExceptionInfo *exception)\n{\n  DrawInfo\n    *clone_info;\n  MagickBooleanType\n    closed_path;\n  MagickStatusType\n    status;\n  PrimitiveInfo\n    *stroke_polygon;\n  register const PrimitiveInfo\n    *p,\n    *q;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    begin draw-stroke-polygon\");\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  clone_info->fill=draw_info->stroke;\n  if (clone_info->fill_pattern != (Image *) NULL)\n    clone_info->fill_pattern=DestroyImage(clone_info->fill_pattern);\n  if (clone_info->stroke_pattern != (Image *) NULL)\n    clone_info->fill_pattern=CloneImage(clone_info->stroke_pattern,0,0,\n      MagickTrue,exception);\n  clone_info->stroke.alpha=(Quantum) TransparentAlpha;\n  clone_info->stroke_width=0.0;\n  clone_info->fill_rule=NonZeroRule;\n  status=MagickTrue;\n  for (p=primitive_info; p->primitive != UndefinedPrimitive; p+=p->coordinates)\n  {\n    stroke_polygon=TraceStrokePolygon(draw_info,p);\n    status&=DrawPolygonPrimitive(image,clone_info,stroke_polygon,exception);\n    if (status == 0)\n      break;\n    stroke_polygon=(PrimitiveInfo *) RelinquishMagickMemory(stroke_polygon);\n    q=p+p->coordinates-1;\n    closed_path=(q->point.x == p->point.x) && (q->point.y == p->point.y) ?\n      MagickTrue : MagickFalse;\n    if ((draw_info->linecap == RoundCap) && (closed_path == MagickFalse))\n      {\n        DrawRoundLinecap(image,draw_info,p,exception);\n        DrawRoundLinecap(image,draw_info,q,exception);\n      }\n  }\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\n      \"    end draw-stroke-polygon\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "static void vmx_slot_disable_log_dirty(struct kvm *kvm,\n\t\t\t\t       struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_slot_set_dirty(kvm, slot);\n}", "target": 0}
{"code": "infra_wait_limit_netblock_insert(struct infra_cache* infra,\n\tstruct config_file* cfg)\n{\n\tstruct config_str2list* p;\n\tstruct wait_limit_netblock_info* d;\n\tfor(p = cfg->wait_limit_netblock; p; p = p->next) {\n\t\td = wait_limit_netblock_findcreate(infra, p->str, 0);\n\t\tif(!d)\n\t\t\treturn 0;\n\t\td->limit = atoi(p->str2);\n\t}\n\tfor(p = cfg->wait_limit_cookie_netblock; p; p = p->next) {\n\t\td = wait_limit_netblock_findcreate(infra, p->str, 1);\n\t\tif(!d)\n\t\t\treturn 0;\n\t\td->limit = atoi(p->str2);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "njs_string_alloc(njs_vm_t *vm, njs_value_t *value, uint64_t size,\n    uint64_t length)\n{\n    uint32_t      total, map_offset, *map;\n    njs_string_t  *string;\n    if (njs_slow_path(size > NJS_STRING_MAX_LENGTH)) {\n        njs_range_error(vm, \"invalid string length\");\n        return NULL;\n    }\n    value->type = NJS_STRING;\n    njs_string_truth(value, size);\n    if (size <= NJS_STRING_SHORT) {\n        value->short_string.size = size;\n        value->short_string.length = length;\n        return value->short_string.start;\n    }\n    value->short_string.size = NJS_STRING_LONG;\n    value->short_string.length = 0;\n    value->long_string.external = 0;\n    value->long_string.size = size;\n    if (size != length && length > NJS_STRING_MAP_STRIDE) {\n        map_offset = njs_string_map_offset(size);\n        total = map_offset + njs_string_map_size(length);\n    } else {\n        map_offset = 0;\n        total = size;\n    }\n    string = njs_mp_alloc(vm->mem_pool, sizeof(njs_string_t) + total);\n    if (njs_fast_path(string != NULL)) {\n        value->long_string.data = string;\n        string->start = (u_char *) string + sizeof(njs_string_t);\n        string->length = length;\n        string->retain = 1;\n        if (map_offset != 0) {\n            map = (uint32_t *) (string->start + map_offset);\n            map[0] = 0;\n        }\n        return string->start;\n    }\n    njs_memory_error(vm);\n    return NULL;\n}", "target": 0}
{"code": "gss_wrap_aead (minor_status,\n               context_handle,\n               conf_req_flag,\n               qop_req,\n\t       input_assoc_buffer,\n\t       input_payload_buffer,\n               conf_state,\n               output_message_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\tinput_payload_buffer;\nint *\t\t\tconf_state;\ngss_buffer_t\t\toutput_message_buffer;\n{\n    OM_uint32\t\tstatus;\n    gss_mechanism\tmech;\n    gss_union_ctx_id_t\tctx;\n    status = val_wrap_aead_args(minor_status, context_handle,\n\t\t\t\tconf_req_flag, qop_req,\n\t\t\t\tinput_assoc_buffer, input_payload_buffer,\n\t\t\t\tconf_state, output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n    return gssint_wrap_aead(mech, minor_status, ctx,\n\t\t\t    conf_req_flag, qop_req,\n\t\t\t    input_assoc_buffer, input_payload_buffer,\n\t\t\t    conf_state, output_message_buffer);\n}", "target": 0}
{"code": "gstd_accept(int fd, char **display_creds, char **export_name, char **mech)\n{\n\tgss_name_t\t client;\n\tgss_OID\t\t mech_oid;\n\tstruct gstd_tok *tok;\n\tgss_ctx_id_t\t ctx = GSS_C_NO_CONTEXT;\n\tgss_buffer_desc\t in, out;\n\tOM_uint32\t maj, min;\n\tint\t\t ret;\n\t*display_creds = NULL;\n\t*export_name = NULL;\n\tout.length = 0;\n\tin.length = 0;\n\tread_packet(fd, &in, 60000, 1);\nagain:\n\twhile ((ret = read_packet(fd, &in, 60000, 0)) == -2)\n\t\t;\n\tif (ret < 1)\n\t\treturn NULL;\n\tmaj = gss_accept_sec_context(&min, &ctx, GSS_C_NO_CREDENTIAL,\n\t    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,\n\t    NULL, NULL);\n\tgss_release_buffer(&min, &in);\n\tif (out.length && write_packet(fd, &out)) {\n\t\tgss_release_buffer(&min, &out);\n\t\treturn NULL;\n\t}\n\tgss_release_buffer(&min, &out);\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_accept_sec_context\");\n\tif (maj & GSS_S_CONTINUE_NEEDED)\n\t\tgoto again;\n\t*display_creds = gstd_get_display_name(client);\n\t*export_name = gstd_get_export_name(client);\n\t*mech = gstd_get_mech(mech_oid);\n\tgss_release_name(&min, &client);\n\tSETUP_GSTD_TOK(tok, ctx, fd, \"gstd_accept\");\n\treturn tok;\n}", "target": 0}
{"code": "TfLiteStatus PreluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  PreluParams* params = static_cast<PreluParams*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  const TfLiteTensor* alpha = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, alpha != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  return CalculatePreluParams(input, alpha, output, params);\n}", "target": 0}
{"code": "nfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tif ((void *)old > vec->iov_base + vec->iov_len)\n\t\treturn 0;\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "static void *gp_worker_main(void *pvt)\n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n    while (!t->pool->shutdown) {\n        gp_debug_set_conn_id(0);\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_mutex_unlock(&t->cond_mutex);\n                pthread_exit(NULL);\n            }\n        }\n        q = t->query;\n        t->query = NULL;\n        pthread_mutex_unlock(&t->cond_mutex);\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        pthread_mutex_lock(&t->pool->lock);\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n        pthread_mutex_unlock(&t->pool->lock);\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n    pthread_exit(NULL);\n}", "target": 0}
{"code": "d_lite_step(int argc, VALUE *argv, VALUE self)\n{\n    VALUE limit, step, date;\n    int c;\n    rb_scan_args(argc, argv, \"11\", &limit, &step);\n    if (argc < 2)\n\tstep = INT2FIX(1);\n#if 0\n    if (f_zero_p(step))\n\trb_raise(rb_eArgError, \"step can't be 0\");\n#endif\n    RETURN_ENUMERATOR(self, argc, argv);\n    date = self;\n    c = f_cmp(step, INT2FIX(0));\n    if (c < 0) {\n\twhile (FIX2INT(d_lite_cmp(date, limit)) >= 0) {\n\t    rb_yield(date);\n\t    date = d_lite_plus(date, step);\n\t}\n    }\n    else if (c == 0) {\n\twhile (1)\n\t    rb_yield(date);\n    }\n    else  {\n\twhile (FIX2INT(d_lite_cmp(date, limit)) <= 0) {\n\t    rb_yield(date);\n\t    date = d_lite_plus(date, step);\n\t}\n    }\n    return self;\n}", "target": 0}
{"code": "static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\n{\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct sock *sk;\n\tstruct inet_sock *inet;\n\t__be32 daddr;\n\tif (ip_options_echo(&icmp_param->replyopts, skb))\n\t\treturn;\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\tinet = inet_sk(sk);\n\ticmp_param->data.icmph.checksum = 0;\n\tinet->tos = ip_hdr(skb)->tos;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (icmp_param->replyopts.optlen) {\n\t\tipc.opt = &icmp_param->replyopts;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = icmp_param->replyopts.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4 = {\n\t\t\t.daddr = daddr,\n\t\t\t.saddr = rt->rt_spec_dst,\n\t\t\t.flowi4_tos = RT_TOS(ip_hdr(skb)->tos),\n\t\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t};\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto out_unlock;\n\t}\n\tif (icmpv4_xrlim_allow(net, rt, icmp_param->data.icmph.type,\n\t\t\t       icmp_param->data.icmph.code))\n\t\ticmp_push_reply(icmp_param, &ipc, &rt);\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\n}", "target": 1}
{"code": "crm_create_anon_tls_session(int csock, int type , void *credentials)\n{\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, anon_tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n    case GNUTLS_SERVER:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_server_credentials_t) credentials);\n        break;\n    case GNUTLS_CLIENT:\n        gnutls_credentials_set(*session, GNUTLS_CRD_ANON, (gnutls_anon_client_credentials_t) credentials);\n        break;\n    }\n    return session;\n}", "target": 0}
{"code": "avp_enum(struct l2tp_avp *avp, const u_char *pkt, int pktlen, int filldata)\n{\n\tuint16_t flags;\n\tL2TP_SUBR_ASSERT(pktlen >= 6);\n\tif (pktlen < 6)\n\t\treturn -1;\n\tGETSHORT(flags, pkt);\n\tavp->is_mandatory = ((flags & 0x8000) != 0)? 1 : 0;\n\tavp->is_hidden = ((flags & 0x4000) != 0)? 1 : 0;\n\tavp->length = flags & 0x03ff;\n\tGETSHORT(avp->vendor_id, pkt);\n\tavp->attr_type = *pkt << 8;\n\tavp->attr_type |= *(pkt + 1);\n\tpkt += 2;\n\tif (avp->length > pktlen)\n\t\treturn -1;\n\tif (filldata != 0)\n\t\tmemcpy(avp->attr_value, pkt, avp->length - 6);\n\treturn avp->length;\n}", "target": 1}
{"code": "urlInitialize(void)\n{\n    debugs(23, 5, \"urlInitialize: Initializing...\");\n    assert(strcmp(AnyP::ProtocolType_str[AnyP::PROTO_MAX], \"MAX\") == 0);\n    assert(0 == matchDomainName(\"foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"y.x.foo.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"x.foo.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\"foo.com\", \"x.foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \".foo.com\"));\n    assert(0 < matchDomainName(\"zzz.com\", \"foo.com\"));\n    assert(0 > matchDomainName(\"aaa.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"FOO.com\", \"foo.COM\"));\n    assert(0 < matchDomainName(\"bfoo.com\", \"afoo.com\"));\n    assert(0 > matchDomainName(\"afoo.com\", \"bfoo.com\"));\n    assert(0 < matchDomainName(\"x-foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\"y.x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\".x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 == matchDomainName(\"*.foo.com\", \"x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".foo.com\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"*.foo.com\", \"foo.com\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"foo.com\", \"\"));\n    assert(0 != matchDomainName(\"foo.com\", \"\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"foo.com\", \"\", mdnRejectSubsubDomains));\n}", "target": 0}
{"code": "static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)\n{\n#if BITS_PER_LONG == 32\n\treturn (u32)(unsigned long)reply;\n#else\n\tulong flags = 0;\n\tu32 nr, i;\n\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tnr = ARRAY_SIZE(pHba->ioctl_reply_context);\n\tfor (i = 0; i < nr; i++) {\n\t\tif (pHba->ioctl_reply_context[i] == NULL) {\n\t\t\tpHba->ioctl_reply_context[i] = reply;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\tif (i >= nr) {\n\t\tprintk(KERN_WARNING\"%s: Too many outstanding \"\n\t\t\t\t\"ioctl commands\\n\", pHba->name);\n\t\treturn (u32)-1;\n\t}\n\treturn i;\n#endif\n}", "target": 1}
{"code": "parse_key_constraint_extension(struct sshbuf *m, char **sk_providerp)\n{\n\tchar *ext_name = NULL;\n\tint r;\n\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\terror_fr(r, \"parse constraint extension\");\n\t\tgoto out;\n\t}\n\tdebug_f(\"constraint ext %s\", ext_name);\n\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\tif (sk_providerp == NULL) {\n\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (*sk_providerp != NULL) {\n\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_get_cstring(m, sk_providerp, NULL)) != 0) {\n\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\terror_f(\"unsupported constraint \\\"%s\\\"\", ext_name);\n\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\tfree(ext_name);\n\treturn r;\n}", "target": 0}
{"code": "Status TensorShapeFromTensor(const Tensor& t, PartialTensorShape* out) {\n  if (t.shape() == TensorShape({})) {\n    if ((t.dtype() == DT_INT32 && t.scalar<int32>()() == -1) ||\n        (t.dtype() == DT_INT64 && t.scalar<int64_t>()() == -1)) {\n      *out = PartialTensorShape();\n      return OkStatus();\n    }\n    return errors::InvalidArgument(\n        \"The only valid scalar shape tensor is the fully unknown shape \"\n        \"specified as -1.\");\n  } else if (t.shape().dims() != 1) {\n    return errors::InvalidArgument(\"Shape must be at most rank 1 but is rank \",\n                                   t.shape().dims());\n  }\n  if (t.dtype() == DT_INT32) {\n    return PartialTensorShape::MakePartialShape(t.vec<int32>().data(),\n                                                t.NumElements(), out);\n  } else if (t.dtype() == DT_INT64) {\n    return PartialTensorShape::MakePartialShape(t.vec<int64_t>().data(),\n                                                t.NumElements(), out);\n  }\n  return errors::InvalidArgument(\n      \"Expected an int32 or int64 shape tensor; found \",\n      DataTypeString(t.dtype()));\n}", "target": 0}
{"code": "void AuthenticationFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOldOption(\"server.disable-authentication\",\n                        \"server.authentication\");\n  options->addOldOption(\"server.disable-authentication-unix-sockets\",\n                        \"server.authentication-unix-sockets\");\n  options->addOldOption(\"server.authenticate-system-only\",\n                        \"server.authentication-system-only\");\n  options->addOldOption(\"server.allow-method-override\",\n                        \"http.allow-method-override\");\n  options->addOldOption(\"server.hide-product-header\",\n                        \"http.hide-product-header\");\n  options->addOldOption(\"server.keep-alive-timeout\", \"http.keep-alive-timeout\");\n  options->addOldOption(\"server.default-api-compatibility\", \"\");\n  options->addOldOption(\"no-server\", \"server.rest-server\");\n  options->addOption(\"--server.authentication\",\n                     \"enable authentication for ALL client requests\",\n                     new BooleanParameter(&_active));\n  options->addOption(\n      \"--server.authentication-timeout\",\n      \"timeout for the authentication cache in seconds (0 = indefinitely)\",\n      new DoubleParameter(&_authenticationTimeout));\n  options->addOption(\"--server.local-authentication\",\n                     \"enable authentication using the local user database\",\n                     new BooleanParameter(&_localAuthentication));\n  options->addOption(\n      \"--server.authentication-system-only\",\n      \"use HTTP authentication only for requests to /_api and /_admin\",\n      new BooleanParameter(&_authenticationSystemOnly));\n#ifdef ARANGODB_HAVE_DOMAIN_SOCKETS\n  options->addOption(\"--server.authentication-unix-sockets\",\n                     \"authentication for requests via UNIX domain sockets\",\n                     new BooleanParameter(&_authenticationUnixSockets));\n#endif\n  options\n      ->addOption(\"--server.jwt-secret\",\n                  \"secret to use when doing jwt authentication\",\n                  new StringParameter(&_jwtSecretProgramOption))\n      .setDeprecatedIn(30322)\n      .setDeprecatedIn(30402);\n  options->addOption(\n      \"--server.jwt-secret-keyfile\",\n      \"file containing jwt secret to use when doing jwt authentication.\",\n      new StringParameter(&_jwtSecretKeyfileProgramOption));\n  options->addOption(\n      \"--server.jwt-secret-folder\",\n      \"folder containing one or more jwt secret files to use for jwt \"\n      \"authentication. Files are sorted alphabetically: First secret \"\n      \"is used for signing + verifying JWT tokens. The latter secrets \"\n      \"are only used for verifying.\",\n      new StringParameter(&_jwtSecretFolderProgramOption),\n      arangodb::options::makeDefaultFlags(arangodb::options::Flags::Enterprise))\n      .setIntroducedIn(30700);\n}", "target": 1}
{"code": "  Status check_index_ordering(const Tensor& indices) {\n    auto findices = indices.flat<int>();\n    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {\n      if (findices(i) < findices(i + 1)) {\n        continue;\n      }\n      return Status(\n          errors::InvalidArgument(\"Indices are not strictly ordered\"));\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\treturn ret;\n}", "target": 0}
{"code": "struct MACH0_(obj_t) {\n\tstruct MACH0_(mach_header) hdr;\n\tstruct MACH0_(segment_command) *segs;\n\tchar *intrp;\n\tchar *compiler;\n\tint nsegs;\n\tint segs_count;\n\tstruct r_dyld_chained_starts_in_segment **chained_starts;\n\tstruct dyld_chained_fixups_header fixups_header;\n\tut64 fixups_offset;\n\tut64 fixups_size;\n\tstruct MACH0_(section) *sects;\n\tint nsects;\n\tstruct MACH0_(nlist) *symtab;\n\tut8 *symstr;\n\tut8 *func_start; \n\tint symstrlen;\n\tint nsymtab;\n\tut32 *indirectsyms;\n\tint nindirectsyms;\n\tRBinImport **imports_by_ord;\n\tsize_t imports_by_ord_size;\n\tHtPP *imports_by_name;\n\tstruct dysymtab_command dysymtab;\n\tstruct load_command main_cmd;\n\tstruct dyld_info_command *dyld_info;\n\tstruct dylib_table_of_contents *toc;\n\tint ntoc;\n\tstruct MACH0_(dylib_module) *modtab;\n\tint nmodtab;\n\tstruct thread_command thread;\n\tut8 *signature;\n\tunion {\n\t\tstruct x86_thread_state32 x86_32;\n\t\tstruct x86_thread_state64 x86_64;\n\t\tstruct ppc_thread_state32 ppc_32;\n\t\tstruct ppc_thread_state64 ppc_64;\n\t\tstruct arm_thread_state32 arm_32;\n\t\tstruct arm_thread_state64 arm_64;\n\t} thread_state;\n\tchar (*libs)[R_BIN_MACH0_STRING_LENGTH];\n\tint nlibs;\n\tint size;\n\tut64 baddr;\n\tut64 entry;\n\tbool big_endian;\n\tconst char *file;\n\tRBuffer *b;\n\tint os;\n\tSdb *kv;\n\tint has_crypto;\n\tint has_canary;\n\tint has_retguard;\n\tint has_sanitizers;\n\tint has_blocks_ext;\n\tint dbg_info;\n\tconst char *lang;\n\tint uuidn;\n\tint func_size;\n\tbool verbose;\n\tut64 header_at;\n\tut64 symbols_off;\n\tvoid *user;\n\tut64 (*va2pa)(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf);\n\tstruct symbol_t *symbols;\n\tut64 main_addr;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tbool rebasing_buffer;\n};", "target": 0}
{"code": "static int snd_ctl_elem_read_user(struct snd_card *card,\n\t\t\t\t  struct snd_ctl_elem_value __user *_control)\n{\n\tstruct snd_ctl_elem_value *control;\n\tint result;\n\tcontrol = memdup_user(_control, sizeof(*control));\n\tif (IS_ERR(control))\n\t\treturn PTR_ERR(control);\n\tdown_read(&card->controls_rwsem);\n\tresult = snd_ctl_elem_read(card, control);\n\tup_read(&card->controls_rwsem);\n\tif (result < 0)\n\t\tgoto error;\n\tif (copy_to_user(_control, control, sizeof(*control)))\n\t\tresult = -EFAULT;\n error:\n\tkfree(control);\n\treturn result;\n}", "target": 1}
{"code": "void input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)\n{\n\tif (type < EV_CNT && input_max_code[type] &&\n\t    code > input_max_code[type]) {\n\t\tpr_err(\"%s: invalid code %u for type %u\\n\", __func__, code,\n\t\t       type);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\tswitch (type) {\n\tcase EV_KEY:\n\t\t__set_bit(code, dev->keybit);\n\t\tbreak;\n\tcase EV_REL:\n\t\t__set_bit(code, dev->relbit);\n\t\tbreak;\n\tcase EV_ABS:\n\t\tinput_alloc_absinfo(dev);\n\t\t__set_bit(code, dev->absbit);\n\t\tbreak;\n\tcase EV_MSC:\n\t\t__set_bit(code, dev->mscbit);\n\t\tbreak;\n\tcase EV_SW:\n\t\t__set_bit(code, dev->swbit);\n\t\tbreak;\n\tcase EV_LED:\n\t\t__set_bit(code, dev->ledbit);\n\t\tbreak;\n\tcase EV_SND:\n\t\t__set_bit(code, dev->sndbit);\n\t\tbreak;\n\tcase EV_FF:\n\t\t__set_bit(code, dev->ffbit);\n\t\tbreak;\n\tcase EV_PWR:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unknown type %u (code %u)\\n\", __func__, type, code);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\t__set_bit(type, dev->evbit);\n}", "target": 0}
{"code": "void sort_directory(struct dir *dir)\n{\n\tstruct dir_ent *cur, *l1, *l2, *next;\n\tint len1, len2, stride = 1;\n\tif(dir->dir_count < 2)\n\t\treturn;\n\tdo {\n\t\tl2 = dir->dirs; \n\t\tcur = NULL; \n\t\twhile(l2) {\n\t\t\tl1 = l2;\n\t\t\tfor(len1 = 0; l2 && len1 < stride; len1 ++, l2 = l2->next);\n\t\t\tlen2 = stride;\n\t\t\twhile(len1 && l2 && len2) {\n\t\t\t\tif(strcmp(l1->name, l2->name) <= 0) {\n\t\t\t\t\tnext = l1;\n\t\t\t\t\tl1 = l1->next;\n\t\t\t\t\tlen1 --;\n\t\t\t\t} else {\n\t\t\t\t\tnext = l2;\n\t\t\t\t\tl2 = l2->next;\n\t\t\t\t\tlen2 --;\n\t\t\t\t}\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = next;\n\t\t\t\t\tcur = next;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = next;\n\t\t\t}\n\t\t\tfor(; len1; len1 --, l1 = l1->next) {\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = l1;\n\t\t\t\t\tcur = l1;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = l1;\n\t\t\t}\n\t\t\tfor(; l2 && len2; len2 --, l2 = l2->next) {\n\t\t\t\tif(cur) {\n\t\t\t\t\tcur->next = l2;\n\t\t\t\t\tcur = l2;\n\t\t\t\t} else\n\t\t\t\t\tdir->dirs = cur = l2;\n\t\t\t}\n\t\t}\n\t\tcur->next = NULL;\n\t\tstride = stride << 1;\n\t} while(stride < dir->dir_count);\n}", "target": 0}
{"code": "bool Server::MatchViewOrStatic(const std::string& method,\n                               const std::string& url, bool* stream) {\n  if (Router::MatchView(method, url, stream)) {\n    return true;\n  }\n  if (method == methods::kGet && !doc_root_.empty()) {\n    fs::path path = doc_root_ / url;\n    fs::error_code ec;\n    if (!fs::is_directory(path, ec) && fs::exists(path, ec)) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "static void bq24190_remove(struct i2c_client *client)\n{\n\tstruct bq24190_dev_info *bdi = i2c_get_clientdata(client);\n\tint error;\n\tcancel_delayed_work_sync(&bdi->input_current_limit_work);\n\terror = pm_runtime_resume_and_get(bdi->dev);\n\tif (error < 0)\n\t\tdev_warn(bdi->dev, \"pm_runtime_get failed: %i\\n\", error);\n\tbq24190_register_reset(bdi);\n\tif (bdi->battery)\n\t\tpower_supply_unregister(bdi->battery);\n\tpower_supply_unregister(bdi->charger);\n\tif (error >= 0)\n\t\tpm_runtime_put_sync(bdi->dev);\n\tpm_runtime_dont_use_autosuspend(bdi->dev);\n\tpm_runtime_disable(bdi->dev);\n}", "target": 0}
{"code": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tret = mount_entry_create_dir_file(mntent, path);\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\tcull_mntent_opt(mntent);\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n\t\t\t  mntflags, mntdata, optional);\n\tfree(mntdata);\n\treturn ret;\n}", "target": 1}
{"code": "ip_optprint(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n{\n\tregister u_int option_len;\n\tconst char *sep = \"\";\n\tfor (; length > 0; cp += option_len, length -= option_len) {\n\t\tu_int option_code;\n\t\tND_PRINT((ndo, \"%s\", sep));\n\t\tsep = \",\";\n\t\tND_TCHECK(*cp);\n\t\toption_code = *cp;\n\t\tND_PRINT((ndo, \"%s\",\n\t\t          tok2str(ip_option_values,\"unknown %u\",option_code)));\n\t\tif (option_code == IPOPT_NOP ||\n                    option_code == IPOPT_EOL)\n\t\t\toption_len = 1;\n\t\telse {\n\t\t\tND_TCHECK(cp[1]);\n\t\t\toption_len = cp[1];\n\t\t\tif (option_len < 2) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (option_len > length) {\n\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\treturn;\n\t\t}\n\t\tND_TCHECK2(*cp, option_len);\n\t\tswitch (option_code) {\n\t\tcase IPOPT_EOL:\n\t\t\treturn;\n\t\tcase IPOPT_TS:\n\t\t\tif (ip_printts(ndo, cp, option_len) == -1)\n\t\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\tcase IPOPT_RR:       \n\t\tcase IPOPT_SSRR:\n\t\tcase IPOPT_LSRR:\n\t\t\tif (ip_printroute(ndo, cp, option_len) == -1)\n\t\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\tcase IPOPT_RA:\n\t\t\tif (option_len < 4) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_TCHECK(cp[3]);\n\t\t\tif (EXTRACT_16BITS(&cp[2]) != 0)\n\t\t\t\tND_PRINT((ndo, \" value %u\", EXTRACT_16BITS(&cp[2])));\n\t\t\tbreak;\n\t\tcase IPOPT_NOP:       \n\t\tcase IPOPT_SECURITY:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}", "target": 0}
{"code": "static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n  if(!pop3c->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n  return CURLE_OK;\n}", "target": 1}
{"code": "hstore_recv(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tint32\t\ti;\n\tint32\t\tpcount;\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tpcount = pq_getmsgint(buf, 4);\n\tif (pcount == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n\t\tPG_RETURN_POINTER(out);\n\t}\n\tif (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t pcount, (int) (MaxAllocSize / sizeof(Pairs)))));\n\tpairs = palloc(pcount * sizeof(Pairs));\n\tfor (i = 0; i < pcount; ++i)\n\t{\n\t\tint\t\t\trawlen = pq_getmsgint(buf, 4);\n\t\tint\t\t\tlen;\n\t\tif (rawlen < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\t\tpairs[i].key = pq_getmsgtext(buf, rawlen, &len);\n\t\tpairs[i].keylen = hstoreCheckKeyLen(len);\n\t\tpairs[i].needfree = true;\n\t\trawlen = pq_getmsgint(buf, 4);\n\t\tif (rawlen < 0)\n\t\t{\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].vallen = 0;\n\t\t\tpairs[i].isnull = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].val = pq_getmsgtext(buf, rawlen, &len);\n\t\t\tpairs[i].vallen = hstoreCheckValLen(len);\n\t\t\tpairs[i].isnull = false;\n\t\t}\n\t}\n\tpcount = hstoreUniquePairs(pairs, pcount, &buflen);\n\tout = hstorePairs(pairs, pcount, buflen);\n\tPG_RETURN_POINTER(out);\n}", "target": 0}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "usm_clone(netsnmp_pdu *pdu, netsnmp_pdu *new_pdu)\n{\n    struct usmStateReference *ref = pdu->securityStateRef;\n    struct usmStateReference **new_ref =\n        (struct usmStateReference **)&new_pdu->securityStateRef;\n    int ret = 0;\n    if (!ref)\n        return ret;\n    if (pdu->command == SNMP_MSG_TRAP2) {\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference(ref, new_ref);\n    } else {\n        netsnmp_assert(ref == *new_ref);\n        ref->refcnt++;\n    }\n    return ret;\n}", "target": 0}
{"code": "static long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tmutex_lock(&adap->lock);\n\tlog_addrs = adap->log_addrs;\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "suppress_quant_table (JPEGState* sp, int tblno)\n{\n\tJQUANT_TBL* qtbl;\n\tif ((qtbl = sp->cinfo.c.quant_tbl_ptrs[tblno]) != NULL)\n\t\tqtbl->sent_table = TRUE;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_sizes = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    TensorShape input_shape;\n    OP_REQUIRES_OK(context,\n                   Conv2DBackpropComputeInputShape(input_sizes, filter.shape(),\n                                                   out_backprop.shape(),\n                                                   data_format_, &input_shape));\n    Tensor* in_backprop = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    if (input_shape.num_elements() == 0) {\n      return;\n    }\n    if (out_backprop.NumElements() == 0) {\n      functor::SetZeroFunctor<Device, T> set_zero;\n      set_zero(context->eigen_device<Device>(),\n               in_backprop->template flat<T>());\n      return;\n    }\n    const int stride_rows = GetTensorDim(strides_, data_format_, 'H');\n    const int stride_cols = GetTensorDim(strides_, data_format_, 'W');\n    const int dilation_rows = GetTensorDim(dilations_, data_format_, 'H');\n    const int dilation_cols = GetTensorDim(dilations_, data_format_, 'W');\n    VLOG(2) << \"Conv2DBackpropInput:\"\n            << \" input: \" << input_shape.DebugString()\n            << \" filter:\" << filter.shape().DebugString()\n            << \" out_backprop: \" << out_backprop.shape().DebugString()\n            << \" strides: [\" << stride_rows << \", \" << stride_cols << \"]\"\n            << \" dilations: [\" << dilation_rows << \", \" << dilation_cols << \"]\";\n    LaunchConv2DBackpropInputOp<Device, T> launch;\n    launch(context, use_cudnn_, cudnn_use_autotune_, out_backprop, filter,\n           dilation_rows, dilation_cols, stride_rows, stride_cols, padding_,\n           explicit_paddings_, in_backprop, data_format_);\n  }", "target": 0}
{"code": "static u32 psi_group_change(struct psi_group *group, int cpu,\n\t\t\t    unsigned int clear, unsigned int set)\n{\n\tstruct psi_group_cpu *groupc;\n\tunsigned int t, m;\n\tenum psi_states s;\n\tu32 state_mask = 0;\n\tgroupc = per_cpu_ptr(group->pcpu, cpu);\n\twrite_seqcount_begin(&groupc->seq);\n\trecord_times(groupc, cpu, false);\n\tfor (t = 0, m = clear; m; m &= ~(1 << t), t++) {\n\t\tif (!(m & (1 << t)))\n\t\t\tcontinue;\n\t\tif (groupc->tasks[t] == 0 && !psi_bug) {\n\t\t\tprintk_deferred(KERN_ERR \"psi: task underflow! cpu=%d t=%d tasks=[%u %u %u] clear=%x set=%x\\n\",\n\t\t\t\t\tcpu, t, groupc->tasks[0],\n\t\t\t\t\tgroupc->tasks[1], groupc->tasks[2],\n\t\t\t\t\tclear, set);\n\t\t\tpsi_bug = 1;\n\t\t}\n\t\tgroupc->tasks[t]--;\n\t}\n\tfor (t = 0; set; set &= ~(1 << t), t++)\n\t\tif (set & (1 << t))\n\t\t\tgroupc->tasks[t]++;\n\tfor (s = 0; s < NR_PSI_STATES; s++) {\n\t\tif (test_state(groupc->tasks, s))\n\t\t\tstate_mask |= (1 << s);\n\t}\n\tgroupc->state_mask = state_mask;\n\twrite_seqcount_end(&groupc->seq);\n\treturn state_mask;\n}", "target": 0}
{"code": "Pl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                initializeVector();\n            }\n            else\n\t    {\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    getNext()->write(this->outbuf, bytes);\n    this->offset = 0;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, DottedFieldCovering) {\n    addIndex(BSON(\"a.b\" << 1));\n    runQuerySortProj(fromjson(\"{'a.b': 5}\"), BSONObj(), fromjson(\"{_id: 0, 'a.b': 1}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, 'a.b': 1}, node: \"\n        \"{cscan: {dir: 1, filter: {'a.b': 5}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, 'a.b': 1}, node: {ixscan: {filter: null, pattern: {'a.b': 1},\"\n        \"bounds: {'a.b': [[5,5,true,true]]}}}}}\");\n}", "target": 0}
{"code": "#ifndef GPAC_DISABLE_ISOM_HINTING\nvoid dump_isom_sdp(GF_ISOFile *file, char *inName, Bool is_final_name)\n{\n\tconst char *sdp;\n\tu32 size, i;\n\tFILE *dump;\n\tif (inName) {\n\t\tchar szBuf[1024];\n\t\tstrcpy(szBuf, inName);\n\t\tif (!is_final_name) {\n\t\t\tchar *ext = strchr(szBuf, '.');\n\t\t\tif (ext) ext[0] = 0;\n\t\t\tstrcat(szBuf, \"_sdp.txt\");\n\t\t}\n\t\tdump = gf_fopen(szBuf, \"wt\");\n\t\tif (!dump) {\n\t\t\tfprintf(stderr, \"Failed to open %s for dumping\\n\", szBuf);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdump = stdout;\n\t\tfprintf(dump, \"* File SDP content *\\n\\n\");\n\t}\n\tgf_isom_sdp_get(file, &sdp, &size);\n\tfprintf(dump, \"%s\", sdp);\n\tfprintf(dump, \"\\r\\n\");\n\tfor (i=0; i<gf_isom_get_track_count(file); i++) {\n\t\tif (gf_isom_get_media_type(file, i+1) != GF_ISOM_MEDIA_HINT) continue;\n\t\tgf_isom_sdp_track_get(file, i+1, &sdp, &size);\n\t\tfprintf(dump, \"%s\", sdp);\n\t}\n\tfprintf(dump, \"\\n\\n\");", "target": 1}
{"code": "ospf_ls_ack_send_delayed (struct ospf_interface *oi)\n{\n  struct in_addr dst;\n  if (oi->type == OSPF_IFTYPE_NBMA)\n    {\n      struct ospf_neighbor *nbr;\n      struct route_node *rn;\n      for (rn = route_top (oi->nbrs); rn; rn = route_next (rn))\n\tif ((nbr = rn->info) != NULL)\n\t  if (nbr != oi->nbr_self && nbr->state >= NSM_Exchange)\n\t    while (listcount (oi->ls_ack))\n\t      ospf_ls_ack_send_list (oi, oi->ls_ack, nbr->address.u.prefix4);\n      return;\n    }\n  if (oi->type == OSPF_IFTYPE_VIRTUALLINK)\n    dst.s_addr = oi->vl_data->peer_addr.s_addr;\n  else if (oi->state == ISM_DR || oi->state == ISM_Backup)\n    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else if (oi->type == OSPF_IFTYPE_POINTOPOINT)\n    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else if (oi->type == OSPF_IFTYPE_POINTOMULTIPOINT)\n    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);\n  else\n    dst.s_addr = htonl (OSPF_ALLDROUTERS);\n  while (listcount (oi->ls_ack))\n    ospf_ls_ack_send_list (oi, oi->ls_ack, dst);\n}", "target": 0}
{"code": "static GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\tnode->sgprivate->num_instances = 2;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void do_pclose(FILE *fin, FILE *fout) {\n  char buf[BUFFER_SIZE];\n  int64_t fptr = 0;\n  read_buf(fin, buf);\n  sscanf(buf, \"%\" PRId64, &fptr);\n  FILE *f = (FILE *)fptr;\n  int ret = ::pclose(f);\n  fprintf(fout, \"%d\\n\", ret);\n  if (ret < 0) {\n    fprintf(fout, \"%d\\n\", errno);\n  }\n  fflush(fout);\n}", "target": 1}
{"code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\tnp = pdev->dev.of_node;\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -EINVAL;\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\tplatform_set_drvdata(pdev, priv);\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\treturn 0;\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}", "target": 0}
{"code": "static int netlink_realloc_groups(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tunsigned int groups;\n\tunsigned long *new_groups;\n\tint err = 0;\n\tnetlink_table_grab();\n\tgroups = nl_table[sk->sk_protocol].groups;\n\tif (!nl_table[sk->sk_protocol].registered) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\tif (nlk->ngroups >= groups)\n\t\tgoto out_unlock;\n\tnew_groups = krealloc(nlk->groups, NLGRPSZ(groups), GFP_ATOMIC);\n\tif (new_groups == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tmemset((char *)new_groups + NLGRPSZ(nlk->ngroups), 0,\n\t       NLGRPSZ(groups) - NLGRPSZ(nlk->ngroups));\n\tnlk->groups = new_groups;\n\tnlk->ngroups = groups;\n out_unlock:\n\tnetlink_table_ungrab();\n\treturn err;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_iterator_int( const bson_iterator *i ) {\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_INT:\n        return bson_iterator_int_raw( i );\n    case BSON_LONG:\n        return bson_iterator_long_raw( i );\n    case BSON_DOUBLE:\n        return bson_iterator_double_raw( i );\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "gss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n    prf_out->length = 0;\n    prf_out->value = NULL;\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn status;\n    }\n    return GSS_S_BAD_MECH;\n}", "target": 0}
{"code": "TEST_F(HTTP2DownstreamSessionTest, TestDuplicateRequestStream) {\n  auto handler2 = addSimpleStrictHandler();\n  auto handler1 = addSimpleStrictHandler();\n  auto streamID1 = sendRequest(\"/withtrailers\", 0, false);\n  auto streamID2 = sendRequest();\n  HTTPHeaders trailers;\n  trailers.add(\"Foo\", \"Bar\");\n  clientCodec_->generateTrailers(requests_, streamID1, trailers);\n  clientCodec_->generateEOM(requests_, streamID1);\n  clientCodec_->generateHeader(requests_, streamID2, getGetRequest(), false);\n  handler1->expectHeaders();\n  handler2->expectHeaders();\n  handler2->expectEOM();\n  handler1->expectTrailers();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 100);\n      handler2->sendReplyWithBody(200, 100);\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}", "target": 0}
{"code": "do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n}", "target": 1}
{"code": "void mbedtls_ssl_flight_free( mbedtls_ssl_flight_item *flight )\n{\n    mbedtls_ssl_flight_item *cur = flight;\n    mbedtls_ssl_flight_item *next;\n    while( cur != NULL )\n    {\n        next = cur->next;\n        mbedtls_free( cur->p );\n        mbedtls_free( cur );\n        cur = next;\n    }\n}", "target": 0}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = _mm_xor_si128(D[i], S[i]);\n}", "target": 1}
{"code": "int btrfs_init_dev_stats(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_key found_key;\n\tstruct btrfs_root *dev_root = fs_info->dev_root;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct extent_buffer *eb;\n\tint slot;\n\tint ret = 0;\n\tstruct btrfs_device *device;\n\tstruct btrfs_path *path = NULL;\n\tint i;\n\tpath = btrfs_alloc_path();\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tint item_size;\n\t\tstruct btrfs_dev_stats_item *ptr;\n\t\tkey.objectid = BTRFS_DEV_STATS_OBJECTID;\n\t\tkey.type = BTRFS_PERSISTENT_ITEM_KEY;\n\t\tkey.offset = device->devid;\n\t\tret = btrfs_search_slot(NULL, dev_root, &key, path, 0, 0);\n\t\tif (ret) {\n\t\t\t__btrfs_reset_dev_stats(device);\n\t\t\tdevice->dev_stats_valid = 1;\n\t\t\tbtrfs_release_path(path);\n\t\t\tcontinue;\n\t\t}\n\t\tslot = path->slots[0];\n\t\teb = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(eb, &found_key, slot);\n\t\titem_size = btrfs_item_size_nr(eb, slot);\n\t\tptr = btrfs_item_ptr(eb, slot,\n\t\t\t\t     struct btrfs_dev_stats_item);\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {\n\t\t\tif (item_size >= (1 + i) * sizeof(__le64))\n\t\t\t\tbtrfs_dev_stat_set(device, i,\n\t\t\t\t\tbtrfs_dev_stats_value(eb, ptr, i));\n\t\t\telse\n\t\t\t\tbtrfs_dev_stat_reset(device, i);\n\t\t}\n\t\tdevice->dev_stats_valid = 1;\n\t\tbtrfs_dev_stat_print_on_load(device);\n\t\tbtrfs_release_path(path);\n\t}\n\tmutex_unlock(&fs_devices->device_list_mutex);\nout:\n\tbtrfs_free_path(path);\n\treturn ret < 0 ? ret : 0;\n}", "target": 0}
{"code": "add_link_ref(\n\tstruct link_ref **references,\n\tconst uint8_t *name, size_t name_size)\n{\n\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));\n\tif (!ref)\n\t\treturn NULL;\n\tref->id = hash_link_ref(name, name_size);\n\tref->next = references[ref->id % REF_TABLE_SIZE];\n\treferences[ref->id % REF_TABLE_SIZE] = ref;\n\treturn ref;\n}", "target": 1}
{"code": "format_DEC_TTL(const struct ofpact_cnt_ids *a,\n               const struct ofpact_format_params *fp)\n{\n    size_t i;\n    ds_put_format(fp->s, \"%sdec_ttl%s\", colors.paren, colors.end);\n    if (a->ofpact.raw == NXAST_RAW_DEC_TTL_CNT_IDS) {\n        ds_put_format(fp->s, \"%s(%s\", colors.paren, colors.end);\n        for (i = 0; i < a->n_controllers; i++) {\n            if (i) {\n                ds_put_cstr(fp->s, \",\");\n            }\n            ds_put_format(fp->s, \"%\"PRIu16, a->cnt_ids[i]);\n        }\n        ds_put_format(fp->s, \"%s)%s\", colors.paren, colors.end);\n    }\n}", "target": 0}
{"code": "cdf_read_sector(const cdf_info_t *info, void *buf, size_t offs, size_t len,\n    const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SEC_SIZE(h) == len);\n\treturn cdf_read(info, (off_t)CDF_SEC_POS(h, id),\n\t    ((char *)buf) + offs, len);\n}", "target": 1}
{"code": "max3421_urb_done(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint status;\n\tstatus = max3421_hcd->urb_done;\n\tmax3421_hcd->urb_done = 0;\n\tif (status > 0)\n\t\tstatus = 0;\n\turb = max3421_hcd->curr_urb;\n\tif (urb) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\tint rcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tint sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tint epnum = usb_endpoint_num(&urb->ep->desc);\n\t\tusb_settoggle(urb->dev, epnum, 0, rcvtog);\n\t\tusb_settoggle(urb->dev, epnum, 1, sndtog);\n\t\tmax3421_hcd->curr_urb = NULL;\n\t\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\t\tusb_hcd_giveback_urb(hcd, urb, status);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "AP4_HdlrAtom::AP4_HdlrAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_HDLR, size, version, flags)\n{\n    AP4_UI32 predefined;\n    stream.ReadUI32(predefined);\n    stream.ReadUI32(m_HandlerType);\n    stream.ReadUI32(m_Reserved[0]);\n    stream.ReadUI32(m_Reserved[1]);\n    stream.ReadUI32(m_Reserved[2]);\n    if (size < AP4_FULL_ATOM_HEADER_SIZE+20) return;\n    AP4_UI32 name_size = size-(AP4_FULL_ATOM_HEADER_SIZE+20);\n    char* name = new char[name_size+1];\n    if (name == NULL) return;\n    stream.Read(name, name_size);\n    name[name_size] = '\\0'; \n    if ((AP4_UI08)name[0] == (AP4_UI08)(name_size-1)) {\n        m_HandlerName = name+1;\n    } else {\n        m_HandlerName = name;\n    }\n    delete[] name;\n}", "target": 0}
{"code": "Pl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    getNext()->write(&ch, 1);\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n}", "target": 1}
{"code": "static int metachar(char c)\n{\n\treturn (strchr(metachars(), c) != NULL);\n}", "target": 1}
{"code": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n  real_tty_path += 5;\t\t\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n  return result;\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n#ifdef _UNIX\n  setlocale(LC_ALL,\"\");\n#endif\n  InitConsole();\n  ErrHandler.SetSignalHandlers(true);\n#ifdef SFX_MODULE\n  wchar ModuleName[NM];\n#ifdef _WIN_ALL\n  GetModuleFileName(NULL,ModuleName,ASIZE(ModuleName));\n#else\n  CharToWide(argv[0],ModuleName,ASIZE(ModuleName));\n#endif\n#endif\n#ifdef _WIN_ALL\n  SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT|SEM_FAILCRITICALERRORS|SEM_NOOPENFILEERRORBOX);\n#endif\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n  POWER_MODE ShutdownOnClose=POWERMODE_KEEP;\n#endif\n  try \n  {\n    CommandData *Cmd=new CommandData;\n#ifdef SFX_MODULE\n    wcscpy(Cmd->Command,L\"X\");\n    char *Switch=argc>1 ? argv[1]:NULL;\n    if (Switch!=NULL && Cmd->IsSwitch(Switch[0]))\n    {\n      int UpperCmd=etoupper(Switch[1]);\n      switch(UpperCmd)\n      {\n        case 'T':\n        case 'V':\n          Cmd->Command[0]=UpperCmd;\n          break;\n        case '?':\n          Cmd->OutHelp(RARX_SUCCESS);\n          break;\n      }\n    }\n    Cmd->AddArcName(ModuleName);\n    Cmd->ParseDone();\n    Cmd->AbsoluteLinks=true; \n#else \n    Cmd->ParseCommandLine(true,argc,argv);\n    if (!Cmd->ConfigDisabled)\n    {\n      Cmd->ReadConfig();\n      Cmd->ParseEnvVar();\n    }\n    Cmd->ParseCommandLine(false,argc,argv);\n#endif\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n    ShutdownOnClose=Cmd->Shutdown;\n#endif\n    uiInit(Cmd->Sound);\n    InitLogOptions(Cmd->LogName,Cmd->ErrlogCharset);\n    ErrHandler.SetSilent(Cmd->AllYes || Cmd->MsgStream==MSG_NULL);\n    Cmd->OutTitle();\n    Cmd->ProcessCommand();\n    delete Cmd;\n  }\n  catch (RAR_EXIT ErrCode)\n  {\n    ErrHandler.SetErrorCode(ErrCode);\n  }\n  catch (std::bad_alloc&)\n  {\n    ErrHandler.MemoryErrorMsg();\n    ErrHandler.SetErrorCode(RARX_MEMORY);\n  }\n  catch (...)\n  {\n    ErrHandler.SetErrorCode(RARX_FATAL);\n  }\n#if defined(_WIN_ALL) && !defined(SFX_MODULE)\n  if (ShutdownOnClose!=POWERMODE_KEEP && ErrHandler.IsShutdownEnabled())\n    Shutdown(ShutdownOnClose);\n#endif\n  ErrHandler.MainExit=true;\n  return ErrHandler.GetErrorCode();\n}", "target": 0}
{"code": "int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct task_struct *task;\n\tint ret;\n\ttrans = btrfs_start_transaction(tree_root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\tuuid_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t      BTRFS_UUID_TREE_OBJECTID);\n\tif (IS_ERR(uuid_root)) {\n\t\tret = PTR_ERR(uuid_root);\n\t\tbtrfs_abort_transaction(trans, ret);\n\t\tbtrfs_end_transaction(trans);\n\t\treturn ret;\n\t}\n\tfs_info->uuid_root = uuid_root;\n\tret = btrfs_commit_transaction(trans);\n\tif (ret)\n\t\treturn ret;\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_scan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_scan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  Status BuildFeatureReaders(const OpInputList& ragged_values_list,\n                             const OpInputList& ragged_splits_list,\n                             const OpInputList& sparse_indices_list,\n                             const OpInputList& sparse_values_list,\n                             const OpInputList& dense_list, int64 batch_size,\n                             FeatureReaders* features) {\n    features->reserve(input_order_.size());\n    int next_ragged = 0;\n    int next_sparse = 0;\n    int next_dense = 0;\n    for (char c : input_order_) {\n      if (c == 'R') {\n        if (next_ragged >= ragged_values_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a ragged tensor value at index \",\n              next_ragged, \" from a list of \", ragged_values_list.size(),\n              \" values.\");\n        if (next_ragged >= ragged_splits_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a ragged tensor split at index \",\n              next_ragged, \" from a list of \", ragged_splits_list.size(),\n              \" splits.\");\n        TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(\n            ragged_values_list[next_ragged], ragged_splits_list[next_ragged],\n            features));\n        next_ragged++;\n      } else if (c == 'S') {\n        if (next_sparse >= sparse_values_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a sparse tensor value at index \",\n              next_sparse, \" from a list of \", sparse_values_list.size(),\n              \" values.\");\n        if (next_sparse >= sparse_indices_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a sparse tensor index at index \",\n              next_sparse, \" from a list of \", sparse_indices_list.size(),\n              \" indices.\");\n        TF_RETURN_IF_ERROR(BuildSparseFeatureReader(\n            sparse_indices_list[next_sparse], sparse_values_list[next_sparse],\n            batch_size, features));\n        next_sparse++;\n      } else if (c == 'D') {\n        if (next_dense >= dense_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a dense tensor at index \", next_dense,\n              \" from a list of \", dense_list.size(), \" tensors.\");\n        TF_RETURN_IF_ERROR(\n            BuildDenseFeatureReader(dense_list[next_dense++], features));\n      } else {\n        return errors::InvalidArgument(\"Unexpected input_order value.\");\n      }\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "void ipc_rcu_putref(void *ptr)\n{\n\tif (--container_of(ptr, struct ipc_rcu_hdr, data)->refcount > 0)\n\t\treturn;\n\tif (container_of(ptr, struct ipc_rcu_hdr, data)->is_vmalloc) {\n\t\tcall_rcu(&container_of(ptr, struct ipc_rcu_grace, data)->rcu,\n\t\t\t\tipc_schedule_free);\n\t} else {\n\t\tkfree_rcu(container_of(ptr, struct ipc_rcu_grace, data), rcu);\n\t}\n}", "target": 1}
{"code": "Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    if (obj->isarrlist) {\n        if (key >= 0 && (uint)key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}", "target": 0}
{"code": "static inline int ealg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\tif (id >= sizeof(t->ealgos) * 8)\n\t\treturn 0;\n\treturn (t->ealgos >> id) & 1;\n}", "target": 0}
{"code": "static void _ipmi_destroy_user(struct ipmi_user *user)\n{\n\tstruct ipmi_smi  *intf = user->intf;\n\tint              i;\n\tunsigned long    flags;\n\tstruct cmd_rcvr  *rcvr;\n\tstruct cmd_rcvr  *rcvrs = NULL;\n\tif (!acquire_ipmi_user(user, &i)) {\n\t\tsynchronize_srcu(&user->release_barrier);\n\t\treturn;\n\t}\n\trcu_assign_pointer(user->self, NULL);\n\trelease_ipmi_user(user, i);\n\tsynchronize_srcu(&user->release_barrier);\n\tif (user->handler->shutdown)\n\t\tuser->handler->shutdown(user->handler_data);\n\tif (user->handler->ipmi_watchdog_pretimeout)\n\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_WATCHDOG);\n\tif (user->gets_events)\n\t\tatomic_dec(&intf->event_waiters);\n\tspin_lock_irqsave(&intf->seq_lock, flags);\n\tlist_del_rcu(&user->link);\n\tfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++) {\n\t\tif (intf->seq_table[i].inuse\n\t\t    && (intf->seq_table[i].recv_msg->user == user)) {\n\t\t\tintf->seq_table[i].inuse = 0;\n\t\t\tsmi_remove_watch(intf, IPMI_WATCH_MASK_CHECK_MESSAGES);\n\t\t\tipmi_free_recv_msg(intf->seq_table[i].recv_msg);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&intf->seq_lock, flags);\n\tmutex_lock(&intf->cmd_rcvrs_mutex);\n\tlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link) {\n\t\tif (rcvr->user == user) {\n\t\t\tlist_del_rcu(&rcvr->link);\n\t\t\trcvr->next = rcvrs;\n\t\t\trcvrs = rcvr;\n\t\t}\n\t}\n\tmutex_unlock(&intf->cmd_rcvrs_mutex);\n\tsynchronize_rcu();\n\twhile (rcvrs) {\n\t\trcvr = rcvrs;\n\t\trcvrs = rcvr->next;\n\t\tkfree(rcvr);\n\t}\n\tkref_put(&intf->refcount, intf_free);\n\tmodule_put(intf->owner);\n}", "target": 0}
{"code": "static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}", "target": 1}
{"code": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\treturn ret;\n}", "target": 1}
{"code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    return get_bits_count(&gb);\n}", "target": 1}
{"code": "void RtmpProtocol::sendInvoke(const string &cmd, const AMFValue &val) {\n    AMFEncoder enc;\n    enc << cmd << ++_send_req_id << val;\n    sendRequest(MSG_CMD, enc.data());\n}", "target": 0}
{"code": "void SetSitesMuted(const TabStripModel& tab_strip,\n                   const std::vector<int>& indices,\n                   const bool mute) {\n  for (int tab_index : indices) {\n    content::WebContents* web_contents = tab_strip.GetWebContentsAt(tab_index);\n    GURL url = web_contents->GetLastCommittedURL();\n    if (url.SchemeIs(content::kChromeUIScheme)) {\n      SetTabAudioMuted(web_contents, mute,\n                       TabMutedReason::CONTENT_SETTING_CHROME, std::string());\n    } else {\n      Profile* profile =\n          Profile::FromBrowserContext(web_contents->GetBrowserContext());\n      HostContentSettingsMap* settings =\n          HostContentSettingsMapFactory::GetForProfile(profile);\n      ContentSetting setting =\n          mute ? CONTENT_SETTING_BLOCK : CONTENT_SETTING_ALLOW;\n      if (setting == settings->GetDefaultContentSetting(\n                         CONTENT_SETTINGS_TYPE_SOUND, nullptr)) {\n        setting = CONTENT_SETTING_DEFAULT;\n      }\n      settings->SetContentSettingDefaultScope(\n          url, url, CONTENT_SETTINGS_TYPE_SOUND, std::string(), setting);\n    }\n  }\n}", "target": 0}
{"code": "QPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    std::set<qpdf_offset_t> visited;\n    while (xref_offset)\n    {\n        visited.insert(xref_offset);\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n\tthis->m->file->seek(xref_offset, SEEK_SET);\n\tthis->m->file->read(buf, sizeof(buf) - 1);\n        if ((strncmp(buf, \"xref\", 4) == 0) &&\n            QUtil::is_space(buf[4]))\n\t{\n            QTC::TC(\"qpdf\", \"QPDF xref space\",\n                    ((buf[4] == '\\n') ? 0 :\n                     (buf[4] == '\\r') ? 1 :\n                     (buf[4] == ' ') ? 2 : 9999));\n            int skip = 4;\n            while (QUtil::is_space(buf[skip]))\n            {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n\t}\n\telse\n\t{\n\t    xref_offset = read_xrefStream(xref_offset);\n\t}\n        if (visited.count(xref_offset) != 0)\n        {\n            xref_offset = 0;\n        }\n    }\n    if (! this->m->trailer.isInitialized())\n    {\n        throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n                      \"unable to find trailer while reading xref\");\n    }\n    int size = this->m->trailer.getKey(\"/Size\").getIntValue();\n    int max_obj = 0;\n    if (! this->m->xref_table.empty())\n    {\n\tmax_obj = (*(this->m->xref_table.rbegin())).first.getObj();\n    }\n    if (! this->m->deleted_objects.empty())\n    {\n\tmax_obj = std::max(max_obj, *(this->m->deleted_objects.rbegin()));\n    }\n    if (size != max_obj + 1)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n\t\t     std::string(\"reported number of objects (\") +\n\t\t     QUtil::int_to_string(size) +\n\t\t     \") inconsistent with actual number of objects (\" +\n\t\t     QUtil::int_to_string(max_obj + 1) + \")\"));\n    }\n    this->m->deleted_objects.clear();\n}", "target": 0}
{"code": "decode_string(CBORDecoderObject *self, uint8_t subtype)\n{\n    uint64_t length = 0;\n    bool indefinite = true;\n    PyObject *ret;\n    char length_hex[17];\n    if (decode_length(self, subtype, &length, &indefinite) == -1)\n        return NULL;\n    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {\n        sprintf(length_hex, \"%llX\", length);\n        PyErr_Format(\n                _CBOR2_CBORDecodeValueError,\n                \"excessive string size 0x%s\", length_hex);\n        return NULL;\n    }\n    if (indefinite)\n        ret = decode_indefinite_strings(self);\n    else\n        ret = decode_definite_string(self, (Py_ssize_t)length);\n    set_shareable(self, ret);\n    return ret;\n}", "target": 1}
{"code": "static int cg_open(const char *path, struct fuse_file_info *fi)\n{\n\tconst char *cgroup;\n\tchar *fpath = NULL, *path1, *path2, * cgdir = NULL, *controller;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *file_info;\n\tstruct fuse_context *fc = fuse_get_context();\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EIO;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tpath1 = \"/\";\n\t\tpath2 = cgdir;\n\t} else {\n\t\tpath1 = cgdir;\n\t\tpath2 = fpath;\n\t}\n\tk = cgfs_get_key(controller, path1, path2);\n\tif (!k) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfree_key(k);\n\tif (!caller_may_see_dir(fc->pid, controller, path1)) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, controller, path1, path2, fi->flags)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tfile_info = malloc(sizeof(*file_info));\n\tif (!file_info) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tfile_info->controller = must_copy_string(controller);\n\tfile_info->cgroup = must_copy_string(path1);\n\tfile_info->file = must_copy_string(path2);\n\tfile_info->type = LXC_TYPE_CGFILE;\n\tfile_info->buf = NULL;\n\tfile_info->buflen = 0;\n\tfi->fh = (unsigned long)file_info;\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 0}
{"code": "static void sas_eh_defer_cmd(struct scsi_cmnd *cmd)\n{\n\tstruct domain_device *dev = cmd_to_domain_dev(cmd);\n\tstruct sas_ha_struct *ha = dev->port->ha;\n\tstruct sas_task *task = TO_SAS_TASK(cmd);\n\tif (!dev_is_sata(dev)) {\n\t\tsas_eh_finish_cmd(cmd);\n\t\treturn;\n\t}\n\tsas_end_task(cmd, task);\n\tlist_move_tail(&cmd->eh_entry, &ha->eh_ata_q);\n}", "target": 1}
{"code": "int numa_zonelist_order_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *length,\n\t\tloff_t *ppos)\n{\n\tchar *str;\n\tint ret;\n\tif (!write)\n\t\treturn proc_dostring(table, write, buffer, length, ppos);\n\tstr = memdup_user_nul(buffer, 16);\n\tif (IS_ERR(str))\n\t\treturn PTR_ERR(str);\n\tret = __parse_numa_zonelist_order(str);\n\tkfree(str);\n\treturn ret;\n}", "target": 0}
{"code": "int irssi_ssl_handshake(GIOChannel *handle)\n{\n\tGIOSSLChannel *chan = (GIOSSLChannel *)handle;\n\tint ret, err;\n\tX509 *cert;\n\tconst char *errstr;\n\tret = SSL_connect(chan->ssl);\n\tif (ret <= 0) {\n\t\terr = SSL_get_error(chan->ssl, ret);\n\t\tswitch (err) {\n\t\t\tcase SSL_ERROR_WANT_READ:\n\t\t\t\treturn 1;\n\t\t\tcase SSL_ERROR_WANT_WRITE:\n\t\t\t\treturn 3;\n\t\t\tcase SSL_ERROR_ZERO_RETURN:\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", \"server closed connection\");\n\t\t\t\treturn -1;\n\t\t\tcase SSL_ERROR_SYSCALL:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tif (errstr == NULL && ret == -1)\n\t\t\t\t\terrstr = strerror(errno);\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"server closed connection unexpectedly\");\n\t\t\t\treturn -1;\n\t\t\tdefault:\n\t\t\t\terrstr = ERR_reason_error_string(ERR_get_error());\n\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"unknown SSL error\");\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\tcert = SSL_get_peer_certificate(chan->ssl);\n\tif (cert == NULL) {\n\t\tg_warning(\"SSL server supplied no certificate\");\n\t\treturn -1;\n\t}\n\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);\n\tX509_free(cert);\n\treturn ret ? 0 : -1;\n}", "target": 1}
{"code": "static void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tvgacon_scrollback_reset(c->vc_num, size);\n}", "target": 1}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err = -EIO;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\tsymlink = bh->b_data;\n\t}\n\tudf_pc_to_char(inode->i_sb, symlink, inode->i_size, p);\n\tbrelse(bh);\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 1}
{"code": "pthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "decode_definite_long_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *buffer = NULL;\n    Py_ssize_t left = length;\n    while (left) {\n        Py_ssize_t chunk_length = length <= 65536 ? length : 65536;\n        PyObject *chunk = fp_read_object(self, chunk_length);\n        if (!chunk) {\n            break;\n        }\n        if (!PyBytes_CheckExact(chunk)) {\n            Py_DECREF(chunk);\n            break;\n        }\n        if (buffer) {\n            PyObject *new_buffer = PyByteArray_Concat(buffer, chunk);\n            Py_DECREF(chunk);\n            if (!new_buffer)\n                break;\n            if (new_buffer != buffer) {\n                Py_DECREF(buffer);\n                buffer = new_buffer;\n            }\n        } else {\n            buffer = PyByteArray_FromObject(chunk);\n            Py_DECREF(chunk);\n            if (!buffer)\n                break;\n        }\n        left -= chunk_length;\n    }\n    PyObject *ret = NULL;\n    if (buffer) {\n        ret = PyBytes_FromObject(buffer);\n        Py_DECREF(buffer);\n        if (ret && string_namespace_add(self, ret, length) == -1) {\n            Py_DECREF(ret);\n            ret = NULL;\n        }\n    }\n    return ret;\n}", "target": 0}
{"code": "static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id)\n{\n\tstruct elo_priv *priv;\n\tint ret;\n\tstruct usb_device *udev;\n\tif (!hid_is_usb(hdev))\n\t\treturn -EINVAL;\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tINIT_DELAYED_WORK(&priv->work, elo_work);\n\tudev = interface_to_usbdev(to_usb_interface(hdev->dev.parent));\n\tpriv->usbdev = usb_get_dev(udev);\n\thid_set_drvdata(hdev, priv);\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\tif (elo_broken_firmware(priv->usbdev)) {\n\t\thid_info(hdev, \"broken firmware found, installing workaround\\n\");\n\t\tqueue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL);\n\t}\n\treturn 0;\nerr_free:\n\tusb_put_dev(udev);\n\tkfree(priv);\n\treturn ret;\n}", "target": 0}
{"code": "static inline void *get_freepointer(struct kmem_cache *s, void *object)\n{\n\treturn *(void **)(object + s->offset);\n}", "target": 0}
{"code": "    TimeValue::TimeValue(int hour, int minute,\n                         int second, int tzHour,\n                         int tzMinute)\n        : Value(date)\n    {\n        time_.hour = hour;\n        time_.minute = minute;\n        time_.second = second;\n        time_.tzHour = tzHour;\n        time_.tzMinute = tzMinute;\n    }", "target": 0}
{"code": "static int DefragBsdMissingFragmentIpv6Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "  static void launch(OpKernelContext* context, bool cudnn_use_autotune,\n                     const Tensor& input, const Tensor& filter,\n                     const std::array<int64, 3>& dilations,\n                     const std::array<int64, 3>& strides, const Padding padding,\n                     TensorFormat data_format, Tensor* output) {\n    OP_REQUIRES(context, data_format == FORMAT_NHWC,\n                errors::InvalidArgument(\"CPU implementation of Conv3D \"\n                                        \"currently only supports the NHWC \"\n                                        \"tensor format.\"));\n    OP_REQUIRES(context,\n                dilations[0] == 1 && dilations[1] == 1 && dilations[2] == 1,\n                errors::InvalidArgument(\"CPU implementation of Conv3D \"\n                                        \"currently only supports dilated rates \"\n                                        \"of 1.\"));\n    OP_REQUIRES(context, filter.dim_size(3) == input.dim_size(input.dims() - 1),\n                errors::InvalidArgument(\n                    \"Number of channels in filter (\", filter.dim_size(3),\n                    \") must match last dimension of input (\",\n                    input.dim_size(input.dims() - 1), \")\"));\n    functor::CuboidConvolution<CPUDevice, T>()(\n        context->eigen_device<CPUDevice>(), output->tensor<T, 5>(),\n        input.tensor<T, 5>(), filter.tensor<T, 5>(), strides[2], strides[1],\n        strides[0], BrainPadding2EigenPadding(padding));\n  }", "target": 0}
{"code": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}", "target": 1}
{"code": "bool CModules::ValidateModuleName(const CString& sModule, CString& sRetMsg) {\n    for (unsigned int a = 0; a < sModule.length(); a++) {\n        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n            sRetMsg =\n                t_f(\"Module names can only contain letters, numbers and \"\n                    \"underscores, [{1}] is invalid\")(sModule);\n            return false;\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\treturn err;\n}", "target": 1}
{"code": "static void sixpack_close(struct tty_struct *tty)\n{\n\tstruct sixpack *sp;\n\twrite_lock_irq(&disc_data_lock);\n\tsp = tty->disc_data;\n\ttty->disc_data = NULL;\n\twrite_unlock_irq(&disc_data_lock);\n\tif (!sp)\n\t\treturn;\n\tif (!refcount_dec_and_test(&sp->refcnt))\n\t\twait_for_completion(&sp->dead);\n\tnetif_stop_queue(sp->dev);\n\tdel_timer_sync(&sp->tx_t);\n\tdel_timer_sync(&sp->resync_t);\n\tunregister_netdev(sp->dev);\n\tkfree(sp->rbuff);\n\tkfree(sp->xbuff);\n\tfree_netdev(sp->dev);\n}", "target": 1}
{"code": "  explicit FractionalAvgPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\n                    \"pooling_ratio field must specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional average pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "  static TfLiteRegistration DelegateRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      TfLiteTensor* output0 = GetOutput(context, node, 0);\n      TF_LITE_ENSURE(context, IsDynamicTensor(output0));\n      const TfLiteTensor* input = GetInput(context, node, 0);\n      TfLiteTensor* output1 = GetOutput(context, node, 1);\n      TF_LITE_ENSURE(context, input->dims->size == output1->dims->size);\n      TF_LITE_ENSURE(context, input->dims->data[0] == output1->dims->data[0]);\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "int VP8LDecodeImage(VP8LDecoder* const dec) {\n  VP8Io* io = NULL;\n  WebPDecParams* params = NULL;\n  if (dec == NULL) return 0;\n  assert(dec->hdr_.huffman_tables_ != NULL);\n  assert(dec->hdr_.htree_groups_ != NULL);\n  assert(dec->hdr_.num_htree_groups_ > 0);\n  io = dec->io_;\n  assert(io != NULL);\n  params = (WebPDecParams*)io->opaque;\n  assert(params != NULL);\n  if (dec->state_ != READ_DATA) {\n    dec->output_ = params->output;\n    assert(dec->output_ != NULL);\n    if (!WebPIoInitFromOptions(params->options, io, MODE_BGRA)) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n    if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;\n#if !defined(WEBP_REDUCE_SIZE)\n    if (io->use_scaling && !AllocateAndInitRescaler(dec, io)) goto Err;\n#else\n    if (io->use_scaling) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n#endif\n    if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {\n      WebPInitAlphaProcessing();\n    }\n    if (!WebPIsRGBMode(dec->output_->colorspace)) {\n      WebPInitConvertARGBToYUV();\n      if (dec->output_->u.YUVA.a != NULL) WebPInitAlphaProcessing();\n    }\n    if (dec->incremental_) {\n      if (dec->hdr_.color_cache_size_ > 0 &&\n          dec->hdr_.saved_color_cache_.colors_ == NULL) {\n        if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,\n                                dec->hdr_.color_cache_.hash_bits_)) {\n          VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n          goto Err;\n        }\n      }\n    }\n    dec->state_ = READ_DATA;\n  }\n  if (!DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,\n                       io->crop_bottom, ProcessRows)) {\n    goto Err;\n  }\n  params->last_y = dec->last_out_row_;\n  return 1;\n Err:\n  VP8LClear(dec);\n  assert(dec->status_ != VP8_STATUS_OK);\n  return 0;\n}", "target": 1}
{"code": "sync_cookie_isvalid(Sync_Cookie *testcookie, Sync_Cookie *refcookie)\n{\n    if (testcookie == NULL || refcookie == NULL) {\n        return 0;\n    }\n    if ((testcookie->openldap_compat != refcookie->openldap_compat ||\n         strcmp(testcookie->cookie_client_signature, refcookie->cookie_client_signature) ||\n         testcookie->cookie_change_info == -1 ||\n         testcookie->cookie_change_info > refcookie->cookie_change_info)) {\n        return 0;\n    }\n    if (refcookie->openldap_compat) {\n        if (testcookie->cookie_server_signature != NULL ||\n            refcookie->cookie_server_signature != NULL) {\n            return 0;\n        }\n    } else {\n        if (strcmp(testcookie->cookie_server_signature, refcookie->cookie_server_signature)) {\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n  rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "int sr_do_ioctl(Scsi_CD *cd, struct packet_command *cgc)\n{\n\tstruct scsi_device *SDev;\n\tstruct scsi_sense_hdr sshdr;\n\tint result, err = 0, retries = 0;\n\tSDev = cd->device;\n      retry:\n\tif (!scsi_block_when_processing_errors(SDev)) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\tresult = scsi_execute(SDev, cgc->cmd, cgc->data_direction,\n\t\t\t      cgc->buffer, cgc->buflen,\n\t\t\t      (unsigned char *)cgc->sense, &sshdr,\n\t\t\t      cgc->timeout, IOCTL_RETRIES, 0, 0, NULL);\n\tif (driver_byte(result) != 0) {\n\t\tswitch (sshdr.sense_key) {\n\t\tcase UNIT_ATTENTION:\n\t\t\tSDev->changed = 1;\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"disc change detected.\\n\");\n\t\t\tif (retries++ < 10)\n\t\t\t\tgoto retry;\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase NOT_READY:\t\n\t\t\tif (sshdr.asc == 0x04 &&\n\t\t\t    sshdr.ascq == 0x01) {\n\t\t\t\tif (!cgc->quiet)\n\t\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t\t  \"CDROM not ready yet.\\n\");\n\t\t\t\tif (retries++ < 10) {\n\t\t\t\t\tssleep(2);\n\t\t\t\t\tgoto retry;\n\t\t\t\t} else {\n\t\t\t\t\terr = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cgc->quiet)\n\t\t\t\tsr_printk(KERN_INFO, cd,\n\t\t\t\t\t  \"CDROM not ready.  Make sure there \"\n\t\t\t\t\t  \"is a disc in the drive.\\n\");\n\t\t\terr = -ENOMEDIUM;\n\t\t\tbreak;\n\t\tcase ILLEGAL_REQUEST:\n\t\t\terr = -EIO;\n\t\t\tif (sshdr.asc == 0x20 &&\n\t\t\t    sshdr.ascq == 0x00)\n\t\t\t\terr = -EDRIVE_CANT_DO_THIS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EIO;\n\t\t}\n\t}\n      out:\n\tcgc->stat = err;\n\treturn err;\n}", "target": 1}
{"code": "same_url_p(ParsedURL *pu1, ParsedURL *pu2)\n{\n    return (pu1->scheme == pu2->scheme && pu1->port == pu2->port &&\n\t    (pu1->host ? pu2->host ? !strcasecmp(pu1->host, pu2->host) : 0 : 1)\n\t    && (pu1->file ? pu2->\n\t\tfile ? !strcmp(pu1->file, pu2->file) : 0 : 1));\n}", "target": 0}
{"code": "struct clock_source *dce110_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "MagickExport void *ResizeQuantumMemory(void *memory,const size_t count,\n  const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    {\n      memory=RelinquishMagickMemory(memory);\n      return((void *) NULL);\n    }\n  extent=count*quantum;\n  return(ResizeMagickMemory(memory,extent));\n}", "target": 1}
{"code": "static void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  \n\t\tbreak;\n\tcase TUN_TAP_DEV:\n\t\tdev->netdev_ops = &tap_netdev_ops;\n\t\tether_setup(dev);\n\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\trandom_ether_addr(dev->dev_addr);\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  \n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n    if (!frame)\n        return NULL;\n    frame->width  = w;\n    frame->height = h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n    return frame;\n}", "target": 1}
{"code": "be32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)\n{\n  size_t i;\n  uint32_t *d;\n  for (i = 0; i < len / 4; i++) {\n    d = (uint32_t *) (dst + i * 4);\n    *d = folly::Endian::big32(src[i]);\n  }\n}", "target": 1}
{"code": "static pyc_object *get_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void AverageEvalQuantizedUint8(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<uint8_t>(input), GetTensorShape(output), \\\n                    GetTensorData<uint8_t>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "void crypto_bignum_free(struct bignum *s)\n{\n\tmbedtls_mpi_free((mbedtls_mpi *)s);\n\tfree(s);\n}", "target": 1}
{"code": "void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {\n\tbloc = *offset;\n\tsend(huff->loc[ch], NULL, fout);\n\t*offset = bloc;\n}", "target": 1}
{"code": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}", "target": 1}
{"code": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}", "target": 1}
{"code": "NOEXPORT int dh_init(SERVICE_OPTIONS *section) {\n    DH *dh=NULL;\n    int i, n;\n    char description[128];\n    STACK_OF(SSL_CIPHER) *ciphers;\n    section->option.dh_temp_params=0; \n    ciphers=SSL_CTX_get_ciphers(section->ctx);\n    if(!ciphers)\n        return 1; \n    n=sk_SSL_CIPHER_num(ciphers);\n    for(i=0; i<n; ++i) {\n        *description='\\0';\n        SSL_CIPHER_description(sk_SSL_CIPHER_value(ciphers, i),\n            description, sizeof description);\n        if(strstr(description, \" Kx=DH\")) {\n            s_log(LOG_INFO, \"DH initialization needed for %s\",\n                SSL_CIPHER_get_name(sk_SSL_CIPHER_value(ciphers, i)));\n            break;\n        }\n    }\n    if(i==n) { \n        s_log(LOG_INFO, \"DH initialization not needed\");\n        return 0; \n    }\n    s_log(LOG_DEBUG, \"DH initialization\");\n#ifndef OPENSSL_NO_ENGINE\n    if(!section->engine) \n#endif\n        dh=dh_read(section->cert);\n    if(dh) {\n        SSL_CTX_set_tmp_dh(section->ctx, dh);\n        s_log(LOG_INFO, \"%d-bit DH parameters loaded\", 8*DH_size(dh));\n        DH_free(dh);\n        return 0; \n    }\n    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_DH]);\n    SSL_CTX_set_tmp_dh(section->ctx, dh_params);\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_DH]);\n    dh_temp_params=1; \n    section->option.dh_temp_params=1; \n    s_log(LOG_INFO, \"Using dynamic DH parameters\");\n    return 0; \n}", "target": 1}
{"code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "static void sas_destruct_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_DESTRUCT, &port->disc.pending);\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}", "target": 1}
{"code": "static int em_ret(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_REG;\n\tctxt->dst.addr.reg = &ctxt->_eip;\n\tctxt->dst.bytes = ctxt->op_bytes;\n\treturn em_pop(ctxt);\n}", "target": 1}
{"code": "static void ieee80211_if_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &ieee80211_dataif_ops;\n\tdev->destructor = free_netdev;\n}", "target": 0}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 15;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }", "target": 1}
{"code": "sasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\tif (! mu)\n\t{\n\t\tif (! *p->authzeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void rfbClientCleanup(rfbClient* client) {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  int i;\n  for ( i = 0; i < 4; i++ ) {\n    if (client->zlibStreamActive[i] == TRUE ) {\n      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&\n\t  client->zlibStream[i].msg != NULL)\n\trfbClientLog(\"inflateEnd: %s\\n\", client->zlibStream[i].msg);\n    }\n  }\n  if ( client->decompStreamInited == TRUE ) {\n    if (inflateEnd (&client->decompStream) != Z_OK &&\n\tclient->decompStream.msg != NULL)\n      rfbClientLog(\"inflateEnd: %s\\n\", client->decompStream.msg );\n  }\n#endif\n  if (client->ultra_buffer)\n    free(client->ultra_buffer);\n  if (client->raw_buffer)\n    free(client->raw_buffer);\n  FreeTLS(client);\n  while (client->clientData) {\n    rfbClientData* next = client->clientData->next;\n    free(client->clientData);\n    client->clientData = next;\n  }\n  free(client->vncRec);\n  if (client->sock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->sock);\n  if (client->listenSock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->listenSock);\n  free(client->desktopName);\n  free(client->serverHost);\n  if (client->destHost)\n    free(client->destHost);\n  if (client->clientAuthSchemes)\n    free(client->clientAuthSchemes);\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslSecret)\n    free(client->saslSecret);\n#endif \n#ifdef WIN32\n  if(WSACleanup() != 0) {\n      errno=WSAGetLastError();\n      rfbClientErr(\"Could not terminate Windows Sockets: %s\\n\", strerror(errno));\n  }\n#endif\n  free(client);\n}", "target": 0}
{"code": "void pickSlurp(sdbus::MethodCall& call) {\n    const std::string PICK_COLOR_CMD = \"grim -g \\\"$(slurp -p)\\\" -t ppm -\";\n    std::string       ppmColor       = execAndGet(PICK_COLOR_CMD.c_str());\n    ppmColor = std::regex_replace(ppmColor, std::regex(\"\\\\s+\"), std::string(\" \"));\n    if (!ppmColor.starts_with(\"P6 1 1 \")) {\n        Debug::log(ERR, \"grim did not return a PPM Image for us.\");\n        sendEmptyDbusMethodReply(call, 1);\n        return;\n    }\n    try {\n        std::string maxValString = ppmColor.substr(7, ppmColor.size());\n        maxValString             = maxValString.substr(0, maxValString.find(' '));\n        uint32_t maxVal          = std::stoi(maxValString);\n        double r, g, b;\n        if (maxVal < 256) {\n            std::string byteString = ppmColor.substr(11, 14);\n            r = (uint8_t)byteString[0] / (maxVal * 1.0);\n            g = (uint8_t)byteString[1] / (maxVal * 1.0);\n            b = (uint8_t)byteString[2] / (maxVal * 1.0);\n        } else {\n            std::string byteString = ppmColor.substr(11, 17);\n            r = ((byteString[0] << 8) | byteString[1]) / (maxVal * 1.0);\n            g = ((byteString[2] << 8) | byteString[3]) / (maxVal * 1.0);\n            b = ((byteString[4] << 8) | byteString[5]) / (maxVal * 1.0);\n        }\n        auto reply = call.createReply();\n        std::unordered_map<std::string, sdbus::Variant> results;\n        results[\"color\"] = sdbus::Struct(std::tuple{r, g, b});\n        reply << (uint32_t)0;\n        reply << results;\n        reply.send();\n    } catch (...) {\n        Debug::log(ERR, \"Converting PPM to RGB failed. This is likely a string to integer error.\");\n        sendEmptyDbusMethodReply(call, 1);\n    }\n}", "target": 1}
{"code": "ZEND_API void zend_ts_hash_merge_ex(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, uint size, merge_checker_func_t pMergeSource, void *pParam)\n{\n\tbegin_read(source);\n\tbegin_write(target);\n\tzend_hash_merge_ex(TS_HASH(target), TS_HASH(source), pCopyConstructor, size, pMergeSource, pParam);\n\tend_write(target);\n\tend_read(source);\n}", "target": 0}
{"code": "Resource* ResourceHost::getResource(std::string uri) {\n\tif (uri.length() > 255 || uri.empty())\n\t\treturn NULL;\n\tif (uri.find(\"../\") != std::string::npos)\n\t\treturn NULL;\n\tstd::string path = baseDiskPath + uri;\n\tResource* res = NULL;\n\tstruct stat sb;\n\tif (stat(path.c_str(), &sb) == -1)\n\t\treturn NULL; \n\tif (sb.st_mode & S_IFDIR) { \n\t\tres = readDirectory(path, sb);\n\t} else if (sb.st_mode & S_IFREG) { \n\t\tres = readFile(path, sb);\n\t} else { \n\t\treturn NULL;\n\t}\n\treturn res;\n}", "target": 0}
{"code": "static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\treturn -ENOSYS;\n}", "target": 1}
{"code": "void ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n   JpegOutput jpeg( filename );\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n   jpeg.cinfo().density_unit = 2; \n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); \n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}", "target": 1}
{"code": "process_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin;\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\tcount = pkcs11_add_provider(provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(provider);\n\t\t\tid->comment = xstrdup(provider); \n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}", "target": 1}
{"code": "nvkm_vmm_put_region(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\tstruct nvkm_vma *prev, *next;\n\tif ((prev = node(vma, prev)) && !prev->used) {\n\t\trb_erase(&prev->tree, &vmm->free);\n\t\tlist_del(&prev->head);\n\t\tvma->addr  = prev->addr;\n\t\tvma->size += prev->size;\n\t\tkfree(prev);\n\t}\n\tif ((next = node(vma, next)) && !next->used) {\n\t\trb_erase(&next->tree, &vmm->free);\n\t\tlist_del(&next->head);\n\t\tvma->size += next->size;\n\t\tkfree(next);\n\t}\n\tnvkm_vmm_free_insert(vmm, vma);\n}", "target": 1}
{"code": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "PixarLogClose(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\ttd->td_bitspersample = 8;\n\ttd->td_sampleformat = SAMPLEFORMAT_UINT;\n}", "target": 1}
{"code": "static int ext4_split_extent(handle_t *handle,\n\t\t\t      struct inode *inode,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      int split_flag,\n\t\t\t      int flags)\n{\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\tint uninitialized;\n\tint split_flag1, flags1;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tuninitialized = ext4_ext_is_uninitialized(ex);\n\tif (map->m_lblk + map->m_len < ee_block + ee_len) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n\t\t\t\t       EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk + map->m_len, split_flag1, flags1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\text4_ext_drop_refs(path);\n\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (map->m_lblk >= ee_block) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk, split_flag1, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\text4_ext_show_leaf(inode, path);\nout:\n\treturn err ? err : map->m_len;\n}", "target": 1}
{"code": "sysDescr_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, CONTIKI_VERSION_STRING);\n}", "target": 1}
{"code": "int ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,\n\t\t\t  int __user *optlen)\n{\n\tint olr;\n\tint val;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\tswitch (optname) {\n\tcase MRT6_VERSION:\n\t\tval = 0x0305;\n\t\tbreak;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t\tval = mrt->mroute_do_pim;\n\t\tbreak;\n#endif\n\tcase MRT6_ASSERT:\n\t\tval = mrt->mroute_do_assert;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (get_user(olr, optlen))\n\t\treturn -EFAULT;\n\tolr = min_t(int, olr, sizeof(int));\n\tif (olr < 0)\n\t\treturn -EINVAL;\n\tif (put_user(olr, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, olr))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "char *LibRaw_bigfile_datastream::gets(char *str, int sz)\n{\n  if(sz<1) return NULL;\n  LR_BF_CHK();\n  return fgets(str, sz, f);\n}", "target": 0}
{"code": "char* oidc_util_javascript_escape(apr_pool_t *pool, const char *s) {\n    const char *cp;\n    char *output;\n    size_t outputlen;\n    int i;\n    if (s == NULL) {\n        return NULL;\n    }\n    outputlen = 0;\n    for (cp = s; *cp; cp++) {\n        switch (*cp) {\n        case '\\'':\n        case '\"':\n        case '\\\\':\n        case '/':\n        case 0x0D:\n        case 0x0A:\n            outputlen += 2;\n            break;\n        case '<':\n        case '>':\n            outputlen += 4;\n            break;\n        default:\n            outputlen += 1;\n            break;\n        }\n    }\n    i = 0;\n    output = apr_palloc(pool, outputlen + 1);\n    for (cp = s; *cp; cp++) {\n        switch (*cp) {\n        case '\\'':\n            (void)strcpy(&output[i], \"\\\\'\");\n            i += 2;\n            break;\n        case '\"':\n            (void)strcpy(&output[i], \"\\\\\\\"\");\n            i += 2;\n            break;\n        case '\\\\':\n            (void)strcpy(&output[i], \"\\\\\\\\\");\n            i += 2;\n            break;\n        case '/':\n            (void)strcpy(&output[i], \"\\\\/\");\n            i += 2;\n            break;\n        case 0x0D:\n            (void)strcpy(&output[i], \"\\\\r\");\n            i += 2;\n            break;\n        case 0x0A:\n            (void)strcpy(&output[i], \"\\\\n\");\n            i += 2;\n            break;\n        case '<':\n            (void)strcpy(&output[i], \"\\\\x3c\");\n            i += 4;\n            break;\n        case '>':\n            (void)strcpy(&output[i], \"\\\\x3e\");\n            i += 4;\n            break;\n        default:\n            output[i] = *cp;\n            i += 1;\n            break;\n        }\n    }\n    output[i] = '\\0';\n    return output;\n}", "target": 0}
{"code": "static inline bool CheckForOverflow(double as_double, T* out) {\n  return (sizeof(T) < sizeof(double) && std::isinf(*out) &&\n          std::isfinite(as_double));\n}", "target": 0}
{"code": "ftrace_filter_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 0}
{"code": "ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {\n  bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));\n  const std::string server_name_indication = options && options->serverNameOverride().has_value()\n                                                 ? options->serverNameOverride().value()\n                                                 : server_name_indication_;\n  if (!server_name_indication.empty()) {\n    const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());\n    RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  if (options && !options->verifySubjectAltNameListOverride().empty()) {\n    SSL_set_verify(ssl_con.get(), SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);\n  }\n  bool has_alpn_defined = !parsed_alpn_protocols_.empty();\n  if (options) {\n    has_alpn_defined |= parseAndSetAlpn(options->applicationProtocolListOverride(), *ssl_con);\n  }\n  if (options && !has_alpn_defined && !options->applicationProtocolFallback().empty()) {\n    parseAndSetAlpn(options->applicationProtocolFallback(), *ssl_con);\n  }\n  if (allow_renegotiation_) {\n    SSL_set_renegotiate_mode(ssl_con.get(), ssl_renegotiate_freely);\n  }\n  SSL_set_enforce_rsa_key_usage(ssl_con.get(), enforce_rsa_key_usage_);\n  if (max_session_keys_ > 0) {\n    if (session_keys_single_use_) {\n      absl::WriterMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n        if (SSL_SESSION_should_be_single_use(session)) {\n          session_keys_.pop_front();\n        }\n      }\n    } else {\n      absl::ReaderMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n      }\n    }\n  }\n  return ssl_con;\n}", "target": 1}
{"code": "_dbus_credentials_add_from_current_process (DBusCredentials *credentials)\n{\n  _dbus_assert (sizeof (pid_t) <= sizeof (dbus_pid_t));\n  _dbus_assert (sizeof (uid_t) <= sizeof (dbus_uid_t));\n  _dbus_assert (sizeof (gid_t) <= sizeof (dbus_gid_t));\n  if (!_dbus_credentials_add_unix_pid(credentials, _dbus_getpid()))\n    return FALSE;\n  if (!_dbus_credentials_add_unix_uid(credentials, _dbus_geteuid()))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "TEST_F(SecretManagerImplTest, DeprecatedSanMatcher) {\n  envoy::extensions::transport_sockets::tls::v3::Secret secret_config;\n  const std::string yaml =\n      R\"EOF(\n      name: \"abc.com\"\n      validation_context:\n        trusted_ca: { filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\" }\n        allow_expired_certificate: true\n        match_subject_alt_names:\n          exact: \"example.foo\"\n      )EOF\";\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml), secret_config);\n  std::unique_ptr<SecretManager> secret_manager(new SecretManagerImpl(config_tracker_));\n  secret_manager->addStaticSecret(secret_config);\n  ASSERT_EQ(secret_manager->findStaticCertificateValidationContextProvider(\"undefined\"), nullptr);\n  ASSERT_NE(secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\"), nullptr);\n  Ssl::CertificateValidationContextConfigImpl cvc_config(\n      *secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\")->secret(), *api_);\n  EXPECT_EQ(cvc_config.subjectAltNameMatchers().size(), 4);\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[0].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n            cvc_config.subjectAltNameMatchers()[0].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[1].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n            cvc_config.subjectAltNameMatchers()[1].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[2].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n            cvc_config.subjectAltNameMatchers()[2].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[3].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS,\n            cvc_config.subjectAltNameMatchers()[3].san_type());\n}", "target": 0}
{"code": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_request_sock *req_inet;\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\treq_inet = inet_rsk(req);\n\topt = xchg(&req_inet->opt, opt);\n\tkfree(opt);\n\treturn 0;\nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1}
{"code": "static bool em_syscall_is_enabled(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tu32 eax, ebx, ecx, edx;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn true;\n\teax = 0x00000000;\n\tecx = 0x00000000;\n\tif (ops->get_cpuid(ctxt, &eax, &ebx, &ecx, &edx)) {\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_GenuineIntel_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_GenuineIntel_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_GenuineIntel_edx)\n\t\t\treturn false;\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_AuthenticAMD_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_AuthenticAMD_edx)\n\t\t\treturn true;\n\t\tif (ebx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ebx &&\n\t\t    ecx == X86EMUL_CPUID_VENDOR_AMDisbetterI_ecx &&\n\t\t    edx == X86EMUL_CPUID_VENDOR_AMDisbetterI_edx)\n\t\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "        bool operator==(const Key& key) const\n        {\n            return    key.tag_ == tag_\n                   && 0 == strncmp(key.ver_, ver_, strlen(ver_))\n                   && (size_ == 0 || key.size_ == size_);\n        }", "target": 0}
{"code": "krb5_pac_parse(krb5_context context,\n               const void *ptr,\n               size_t len,\n               krb5_pac *ppac)\n{\n    krb5_error_code ret;\n    size_t i;\n    const unsigned char *p = (const unsigned char *)ptr;\n    krb5_pac pac;\n    size_t header_len;\n    krb5_ui_4 cbuffers, version;\n    *ppac = NULL;\n    if (len < PACTYPE_LENGTH)\n        return ERANGE;\n    cbuffers = load_32_le(p);\n    p += 4;\n    version = load_32_le(p);\n    p += 4;\n    if (version != 0)\n        return EINVAL;\n    header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);\n    if (len < header_len)\n        return ERANGE;\n    ret = krb5_pac_init(context, &pac);\n    if (ret != 0)\n        return ret;\n    pac->pac = (PACTYPE *)realloc(pac->pac,\n                                  sizeof(PACTYPE) + ((cbuffers - 1) * sizeof(PAC_INFO_BUFFER)));\n    if (pac->pac == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    pac->pac->cBuffers = cbuffers;\n    pac->pac->Version = version;\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        PAC_INFO_BUFFER *buffer = &pac->pac->Buffers[i];\n        buffer->ulType = load_32_le(p);\n        p += 4;\n        buffer->cbBufferSize = load_32_le(p);\n        p += 4;\n        buffer->Offset = load_64_le(p);\n        p += 8;\n        if (buffer->Offset % PAC_ALIGNMENT) {\n            krb5_pac_free(context, pac);\n            return EINVAL;\n        }\n        if (buffer->Offset < header_len ||\n            buffer->Offset + buffer->cbBufferSize > len) {\n            krb5_pac_free(context, pac);\n            return ERANGE;\n        }\n    }\n    pac->data.data = realloc(pac->data.data, len);\n    if (pac->data.data == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    memcpy(pac->data.data, ptr, len);\n    pac->data.length = len;\n    *ppac = pac;\n    return 0;\n}", "target": 1}
{"code": "gif_read_image(FILE       *fp,\t\t\n\t       image_t    *img,\t\t\n\t       gif_cmap_t cmap,\t\t\n\t       int        interlace,\t\n\t       int        transparent)\t\n{\n  uchar\t\tcode_size,\t\t\n\t\t*temp;\t\t\t\n  int\t\txpos,\t\t\t\n\t\typos,\t\t\t\n\t\tpass;\t\t\t\n  int\t\tpixel;\t\t\t\n  static int\txpasses[4] = { 8, 8, 4, 2 },\n\t\typasses[5] = { 0, 4, 2, 1, 999999 };\n  xpos      = 0;\n  ypos      = 0;\n  pass      = 0;\n  code_size = (uchar)getc(fp);\n  if (code_size > 12)\n  {\n    progress_error(HD_ERROR_READ_ERROR, \"Bad GIF file \\\"%s\\\" - invalid code size %d.\", img->filename, code_size);\n    return (-1);\n  }\n  if (gif_read_lzw(fp, 1, code_size) < 0)\n    return (-1);\n  temp = img->pixels;\n  while ((pixel = gif_read_lzw(fp, 0, code_size)) >= 0 && pixel < 256)\n  {\n    temp[0] = cmap[pixel][0];\n    if (img->depth > 1)\n    {\n      temp[1] = cmap[pixel][1];\n      temp[2] = cmap[pixel][2];\n    }\n    if (pixel == transparent)\n      image_set_mask(img, xpos, ypos);\n    xpos ++;\n    temp += img->depth;\n    if (xpos == img->width)\n    {\n      xpos = 0;\n      if (interlace)\n      {\n        ypos += xpasses[pass];\n        temp += (xpasses[pass] - 1) * img->width * img->depth;\n        if (ypos >= img->height)\n\t{\n\t  pass ++;\n          ypos = ypasses[pass];\n          temp = img->pixels + ypos * img->width * img->depth;\n\t}\n      }\n      else\n\typos ++;\n    }\n    if (ypos >= img->height)\n      break;\n  }\n  return (0);\n}", "target": 0}
{"code": "monitor_init(void)\n{\n\tstruct ssh *ssh = active_state;\t\t\t\n\tstruct monitor *mon;\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n\treturn mon;\n}", "target": 1}
{"code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\tstrict = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}", "target": 0}
{"code": "crm_send_plaintext(int sock, const char *buf, size_t len)\n{\n    int rc = 0;\n    const char *unsent = buf;\n    int total_send;\n    if (buf == NULL) {\n        return -1;\n    }\n    total_send = len;\n    crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n    rc = write(sock, unsent, len);\n    if (rc < 0) {\n        switch (errno) {\n        case EINTR:\n        case EAGAIN:\n            crm_trace(\"Retry\");\n            goto retry;\n        default:\n            crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, (int) len);\n            break;\n        }\n    } else if (rc < len) {\n        crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n        len -= rc;\n        unsent += rc;\n        goto retry;\n     } else {\n        crm_trace(\"Sent %d bytes: %.100s\", rc, buf);\n    }\n    return rc < 0 ? rc : total_send;\n}", "target": 0}
{"code": "static int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->termios_initialized = 0;\n\tpriv->rx_flags = 0;\n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\tport->port.drain_delay = 256;\n\treturn 0;\n}", "target": 0}
{"code": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "static int mmac_rotate(const MMacro *mac, unsigned int n)\n{\n    if (--n < mac->nparam)\n        n = (n + mac->rotate) % mac->nparam;\n    return n+1;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "inline void* aligned_malloc(size_t size, size_t alignment) {\n  return folly::detail::aligned_malloc(size, alignment);\n}", "target": 1}
{"code": "AsfVideo::HeaderReader::HeaderReader(const BasicIo::UniquePtr& io) : IdBuf_(GUID) {\n  if (io->size() >= io->tell() + GUID + QWORD) {\n    IdBuf_ = io->read(GUID);\n    size_ = readQWORDTag(io);\n    if (size_ >= GUID + QWORD)\n      remaining_size_ = size_ - GUID - QWORD;\n  }\n}", "target": 1}
{"code": "Filter::UpstreamRequest::~UpstreamRequest() {\n  if (span_ != nullptr) {\n    Tracing::HttpTracerUtility::finalizeUpstreamSpan(*span_, upstream_headers_.get(),\n                                                     upstream_trailers_.get(), stream_info_,\n                                                     Tracing::EgressConfig::get());\n  }\n  if (per_try_timeout_ != nullptr) {\n    per_try_timeout_->disableTimer();\n  }\n  clearRequestEncoder();\n  stream_info_.setUpstreamTiming(upstream_timing_);\n  stream_info_.onRequestComplete();\n  if (upstream_headers_ != nullptr) {\n    upstream_headers_->refreshByteSize();\n  }\n  if (upstream_trailers_ != nullptr) {\n    upstream_trailers_->refreshByteSize();\n  }\n  for (const auto& upstream_log : parent_.config_.upstream_logs_) {\n    upstream_log->log(parent_.downstream_headers_, upstream_headers_.get(),\n                      upstream_trailers_.get(), stream_info_);\n  }\n}", "target": 0}
{"code": "mesh_state_cleanup(struct mesh_state* mstate)\n{\n\tstruct mesh_area* mesh;\n\tint i;\n\tif(!mstate)\n\t\treturn;\n\tmesh = mstate->s.env->mesh;\n\tif(mstate->s.serve_expired_data && mstate->s.serve_expired_data->timer) {\n\t\tcomm_timer_delete(mstate->s.serve_expired_data->timer);\n\t\tmstate->s.serve_expired_data->timer = NULL;\n\t}\n\tif(!mstate->replies_sent) {\n\t\tstruct mesh_reply* rep = mstate->reply_list;\n\t\tstruct mesh_cb* cb;\n\t\tmstate->reply_list = NULL;\n\t\tfor(; rep; rep=rep->next) {\n\t\t\tinfra_wait_limit_dec(mesh->env->infra_cache,\n\t\t\t\t&rep->query_reply, mesh->env->cfg);\n\t\t\tcomm_point_drop_reply(&rep->query_reply);\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t}\n\t\twhile((cb = mstate->cb_list)!=NULL) {\n\t\t\tmstate->cb_list = cb->next;\n\t\t\tfptr_ok(fptr_whitelist_mesh_cb(cb->cb));\n\t\t\t(*cb->cb)(cb->cb_arg, LDNS_RCODE_SERVFAIL, NULL,\n\t\t\t\tsec_status_unchecked, NULL, 0);\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t}\n\t}\n\tfor(i=0; i<mesh->mods.num; i++) {\n\t\tfptr_ok(fptr_whitelist_mod_clear(mesh->mods.mod[i]->clear));\n\t\t(*mesh->mods.mod[i]->clear)(&mstate->s, i);\n\t\tmstate->s.minfo[i] = NULL;\n\t\tmstate->s.ext_state[i] = module_finished;\n\t}\n\talloc_reg_release(mstate->s.env->alloc, mstate->s.region);\n}", "target": 0}
{"code": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}", "target": 1}
{"code": "static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)\n{\n\treturn kstrdup(name, GFP_KERNEL);\n}", "target": 1}
{"code": "int __nla_validate(const struct nlattr *head, int len, int maxtype,\n\t\t   const struct nla_policy *policy, unsigned int validate,\n\t\t   struct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, NULL);\n}", "target": 1}
{"code": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe9;\t\n\tb->delta = delta;\n\treturn 5;\n}", "target": 1}
{"code": "bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)\n{\n\tswitch (chip->usb_id) {\n\tcase USB_ID(0x045E, 0x075D): \n\tcase USB_ID(0x045E, 0x076D): \n\tcase USB_ID(0x045E, 0x076E): \n\tcase USB_ID(0x045E, 0x076F): \n\tcase USB_ID(0x045E, 0x0772): \n\tcase USB_ID(0x045E, 0x0779): \n\tcase USB_ID(0x047F, 0xAA05): \n\tcase USB_ID(0x04D8, 0xFEEA): \n\tcase USB_ID(0x074D, 0x3553): \n\tcase USB_ID(0x21B4, 0x0081): \n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\tif (WARN_ON(!info))\n\t\treturn;\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\tif (!list_empty(&info->eoi_list))\n\t\tlateeoi_list_del(info);\n\tlist_del(&info->list);\n\tset_info_for_irq(irq, NULL);\n\tWARN_ON(info->refcnt > 0);\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\tkfree(info);\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\tirq_free_desc(irq);\n}", "target": 0}
{"code": "unicode_log2vis (PyUnicodeObject* string,\n                 FriBidiParType base_direction, int clean, int reordernsm)\n{\n    int i;\n    int length = string->length;\n    FriBidiChar *logical = NULL; \n    FriBidiChar *visual = NULL;      \n    FriBidiStrIndex new_len = 0; \n    PyUnicodeObject *result = NULL;\n    logical = PyMem_New (FriBidiChar, length + 1);\n    if (logical == NULL) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    visual = PyMem_New (FriBidiChar, length + 1);\n    if (visual == NULL) {\n        PyErr_NoMemory();\n        goto cleanup;\n    }\n    for (i=0; i<length; ++i) {\n        logical[i] = string->str[i];\n    }\n    fribidi_set_reorder_nsm(reordernsm);\n    if (!fribidi_log2vis (logical, length, &base_direction, visual,\n                          NULL, NULL, NULL)) {\n        PyErr_SetString (PyExc_RuntimeError,\n                         \"fribidi failed to order string\");\n        goto cleanup;\n    }\n    if (clean) {\n        length = fribidi_remove_bidi_marks (visual, length, NULL, NULL, NULL);\n    }\n    result = (PyUnicodeObject*) PyUnicode_FromUnicode(NULL, length);\n    if (result == NULL) {\n        goto cleanup;\n    }\n    for (i=0; i<length; ++i) {\n        result->str[i] = visual[i];\n    }\n  cleanup:\n    PyMem_Del (logical);\n    PyMem_Del (visual);\n    return (PyObject *)result;\n}", "target": 0}
{"code": "bool Item_trigger_field::fix_fields(THD *thd, Item **items)\n{\n  DBUG_ASSERT(fixed == 0);\n  if (field_idx != (uint)-1)\n  {\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n    if (table_grants)\n    {\n      table_grants->want_privilege= want_privilege;\n      if (check_grant_column(thd, table_grants, triggers->trigger_table->s->db.str,\n                             triggers->trigger_table->s->table_name.str, field_name,\n                             strlen(field_name), thd->security_ctx))\n        return TRUE;\n    }\n#endif \n    field= (row_version == OLD_ROW) ? triggers->old_field[field_idx] :\n                                      triggers->new_field[field_idx];\n    set_field(field);\n    fixed= 1;\n    return FALSE;\n  }\n  my_error(ER_BAD_FIELD_ERROR, MYF(0), field_name,\n           (row_version == NEW_ROW) ? \"NEW\" : \"OLD\");\n  return TRUE;\n}", "target": 0}
{"code": "    void assignRemoteEndpoints(\n            const ParticipantProxyData& ) override\n    {\n    }", "target": 1}
{"code": "int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  int rc;\n  if (flags & IMAP_CMD_SINGLE)\n  {\n    if (adata->nextcmd != adata->lastcmd)\n      imap_exec(adata, NULL, IMAP_CMD_POLL);\n  }\n  rc = cmd_start(adata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n  if (flags & IMAP_CMD_QUEUE)\n    return IMAP_EXEC_SUCCESS;\n  if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&\n      ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))\n  {\n    mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n  mutt_sig_allow_interrupt(true);\n  do\n  {\n    rc = imap_cmd_step(adata);\n    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))\n      break;\n  } while (rc == IMAP_RES_CONTINUE);\n  mutt_sig_allow_interrupt(false);\n  if (rc == IMAP_RES_NO)\n    return IMAP_EXEC_ERROR;\n  if (rc != IMAP_RES_OK)\n  {\n    if (adata->status != IMAP_FATAL)\n      return IMAP_EXEC_ERROR;\n    mutt_debug(LL_DEBUG1, \"command failed: %s\\n\", adata->buf);\n    return IMAP_EXEC_FATAL;\n  }\n  return IMAP_EXEC_SUCCESS;\n}", "target": 0}
{"code": "void SetColor(double c, double m, double y, double k,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f K\",c,m,y,k);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f k\",c,m,y,k);\n    }\n}", "target": 1}
{"code": "static inline bool spectre_v2_in_ibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_IBRS ||\n\t       mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 1}
{"code": "njs_json_push_parse_state(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *value)\n{\n    njs_json_state_t  *state;\n    if (njs_slow_path(parse->depth >= NJS_JSON_MAX_DEPTH)) {\n        njs_type_error(vm, \"Nested too deep or a cyclic structure\");\n        return NULL;\n    }\n    state = &parse->states[parse->depth++];\n    state->value = *value;\n    state->index = 0;\n    state->prop = NULL;\n    state->keys = njs_value_own_enumerate(vm, value, NJS_ENUM_KEYS,\n                                          NJS_ENUM_STRING, 0);\n    if (state->keys == NULL) {\n        return NULL;\n    }\n    return state;\n}", "target": 1}
{"code": "snmp_ber_encode_oid(snmp_packet_t *snmp_packet, snmp_oid_t *oid)\n{\n  uint32_t val;\n  uint16_t original_out_len;\n  uint8_t pos;\n  original_out_len = snmp_packet->used;\n  pos = oid->length - 1;\n  while(pos) {\n    val = oid->data[pos];\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n    *snmp_packet->out-- = (uint8_t)(val & 0x7F);\n    snmp_packet->used++;\n    val >>= 7;\n    while(val) {\n      if(snmp_packet->used == snmp_packet->max) {\n        return 0;\n      }\n      *snmp_packet->out-- = (uint8_t)((val & 0x7F) | 0x80);\n      snmp_packet->used++;\n      val >>= 7;\n    }\n    pos--;\n  }\n  if(snmp_packet->used == snmp_packet->max) {\n    return 0;\n  }\n  val = *(snmp_packet->out + 1) + 40 * oid->data[pos];\n  snmp_packet->used--;\n  snmp_packet->out++;\n  if(snmp_packet->used == snmp_packet->max) {\n    return 0;\n  }\n  *snmp_packet->out-- = (uint8_t)(val & 0x7F);\n  snmp_packet->used++;\n  val >>= 7;\n  while(val) {\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n    *snmp_packet->out-- = (uint8_t)((val & 0x7F) | 0x80);\n    snmp_packet->used++;\n    val >>= 7;\n  }\n  if(!snmp_ber_encode_length(snmp_packet, snmp_packet->used - original_out_len)) {\n    return 0;\n  }\n  if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_OBJECT_IDENTIFIER)) {\n    return 0;\n  }\n  return 1;\n}", "target": 0}
{"code": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n\tint newly_acked_sacked = prior_unsacked -\n\t\t\t\t (tp->packets_out - tp->sacked_out);\n\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n\t\treturn;\n\ttp->prr_delivered += newly_acked_sacked;\n\tif (delta < 0) {\n\t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}", "target": 0}
{"code": "yy_symbol_value_print (FILE *yyo,\n                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  FILE *yyoutput = yyo;\n  YY_USE (yyoutput);\n  YY_USE (yylocationp);\n  YY_USE (parm);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yykind < YYNTOKENS)\n    YYPRINT (yyo, yytoknum[yykind], *yyvaluep);\n# endif\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YY_USE (yykind);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}", "target": 1}
{"code": "mldv2_report_print(netdissect_options *ndo, const u_char *bp, u_int len)\n{\n    const struct icmp6_hdr *icp = (const struct icmp6_hdr *) bp;\n    u_int group, nsrcs, ngroups;\n    u_int i, j;\n    if (len < 8) {\n            ND_PRINT((ndo,\" [invalid len %d]\", len));\n            return;\n    }\n    ND_TCHECK(icp->icmp6_data16[1]);\n    ngroups = EXTRACT_16BITS(&icp->icmp6_data16[1]);\n    ND_PRINT((ndo,\", %d group record(s)\", ngroups));\n    if (ndo->ndo_vflag > 0) {\n\tgroup = 8;\n        for (i = 0; i < ngroups; i++) {\n\t    if (len < group + 20) {\n                    ND_PRINT((ndo,\" [invalid number of groups]\"));\n                    return;\n\t    }\n            ND_TCHECK2(bp[group + 4], sizeof(struct in6_addr));\n            ND_PRINT((ndo,\" [gaddr %s\", ip6addr_string(ndo, &bp[group + 4])));\n\t    ND_PRINT((ndo,\" %s\", tok2str(mldv2report2str, \" [v2-report-#%d]\",\n                                         bp[group])));\n            nsrcs = (bp[group + 2] << 8) + bp[group + 3];\n\t    if (len < group + 20 + (nsrcs * sizeof(struct in6_addr))) {\n                    ND_PRINT((ndo,\" [invalid number of sources %d]\", nsrcs));\n                    return;\n\t    }\n            if (ndo->ndo_vflag == 1)\n                    ND_PRINT((ndo,\", %d source(s)\", nsrcs));\n            else {\n                    ND_PRINT((ndo,\" {\"));\n                for (j = 0; j < nsrcs; j++) {\n                    ND_TCHECK2(bp[group + 20 + j * sizeof(struct in6_addr)],\n                            sizeof(struct in6_addr));\n\t\t    ND_PRINT((ndo,\" %s\", ip6addr_string(ndo, &bp[group + 20 + j * sizeof(struct in6_addr)])));\n\t\t}\n                ND_PRINT((ndo,\" }\"));\n            }\n            group += 20 + nsrcs * sizeof(struct in6_addr);\n\t    ND_PRINT((ndo,\"]\"));\n        }\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo,\"[|icmp6]\"));\n    return;\n}", "target": 1}
{"code": "pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n\t\t\tint atomic)\n{\n\tunsigned long copy;\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\t\tif (atomic) {\n\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tto += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "gss_unwrap_aead (minor_status,\n                 context_handle,\n\t\t input_message_buffer,\n\t\t input_assoc_buffer,\n\t\t output_payload_buffer,\n                 conf_state,\n                 qop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\toutput_payload_buffer;\nint \t\t\t*conf_state;\ngss_qop_t\t\t*qop_state;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_unwrap_aead_args(minor_status, context_handle,\n\t\t\t\t  input_message_buffer, input_assoc_buffer,\n\t\t\t\t  output_payload_buffer,\n\t\t\t\t  conf_state, qop_state);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n    return gssint_unwrap_aead(mech, minor_status, ctx,\n\t\t\t      input_message_buffer, input_assoc_buffer,\n\t\t\t      output_payload_buffer, conf_state, qop_state);\n}", "target": 0}
{"code": "TfLiteStatus SoftmaxPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = static_cast<TfLiteSoftmaxParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TFLITE_DCHECK(node->user_data != nullptr);\n  SoftmaxParams* data = static_cast<SoftmaxParams*>(node->user_data);\n  return CalculateSoftmaxParams(context, input, output, params, data);\n}", "target": 0}
{"code": "static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\treturn AvId;\n}", "target": 1}
{"code": "static int nla_validate_array(const struct nlattr *head, int len, int maxtype,\n\t\t\t      const struct nla_policy *policy,\n\t\t\t      struct netlink_ext_ack *extack,\n\t\t\t      unsigned int validate)\n{\n\tconst struct nlattr *entry;\n\tint rem;\n\tnla_for_each_attr(entry, head, len, rem) {\n\t\tint ret;\n\t\tif (nla_len(entry) == 0)\n\t\t\tcontinue;\n\t\tif (nla_len(entry) < NLA_HDRLEN) {\n\t\t\tNL_SET_ERR_MSG_ATTR(extack, entry,\n\t\t\t\t\t    \"Array element too short\");\n\t\t\treturn -ERANGE;\n\t\t}\n\t\tret = __nla_validate(nla_data(entry), nla_len(entry),\n\t\t\t\t     maxtype, policy, validate, extack);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "my_decimal *Item_param::val_decimal(my_decimal *dec)\n{\n  switch (state) {\n  case DECIMAL_VALUE:\n    return &decimal_value;\n  case REAL_VALUE:\n    double2my_decimal(E_DEC_FATAL_ERROR, value.real, dec);\n    return dec;\n  case INT_VALUE:\n    int2my_decimal(E_DEC_FATAL_ERROR, value.integer, unsigned_flag, dec);\n    return dec;\n  case STRING_VALUE:\n  case LONG_DATA_VALUE:\n    string2my_decimal(E_DEC_FATAL_ERROR, &str_value, dec);\n    return dec;\n  case TIME_VALUE:\n  {\n    longlong i= (longlong) TIME_to_ulonglong(&value.time);\n    int2my_decimal(E_DEC_FATAL_ERROR, i, 0, dec);\n    return dec;\n  }\n  case NULL_VALUE:\n    return 0; \n  default:\n    DBUG_ASSERT(0);\n  }\n  return 0;\n}", "target": 0}
{"code": "repodata_schema2id(Repodata *data, Id *schema, int create)\n{\n  int h, len, i;\n  Id *sp, cid;\n  Id *schematahash;\n  if (!*schema)\n    return 0;\t\n  if ((schematahash = data->schematahash) == 0)\n    {\n      data->schematahash = schematahash = solv_calloc(256, sizeof(Id));\n      for (i = 1; i < data->nschemata; i++)\n\t{\n\t  for (sp = data->schemadata + data->schemata[i], h = 0; *sp;)\n\t    h = h * 7 + *sp++;\n\t  h &= 255;\n\t  schematahash[h] = i;\n\t}\n      data->schemadata = solv_extend_resize(data->schemadata, data->schemadatalen, sizeof(Id), SCHEMATADATA_BLOCK);\n      data->schemata = solv_extend_resize(data->schemata, data->nschemata, sizeof(Id), SCHEMATA_BLOCK);\n    }\n  for (sp = schema, len = 0, h = 0; *sp; len++)\n    h = h * 7 + *sp++;\n  h &= 255;\n  len++;\n  cid = schematahash[h];\n  if (cid)\n    {\n      if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n        return cid;\n      for (cid = 1; cid < data->nschemata; cid++)\n        if (!memcmp(data->schemadata + data->schemata[cid], schema, len * sizeof(Id)))\n          return cid;\n    }\n  if (!create)\n    return 0;\n  data->schemadata = solv_extend(data->schemadata, data->schemadatalen, len, sizeof(Id), SCHEMATADATA_BLOCK);\n  data->schemata = solv_extend(data->schemata, data->nschemata, 1, sizeof(Id), SCHEMATA_BLOCK);\n  memcpy(data->schemadata + data->schemadatalen, schema, len * sizeof(Id));\n  data->schemata[data->nschemata] = data->schemadatalen;\n  data->schemadatalen += len;\n  schematahash[h] = data->nschemata;\n#if 0\nfprintf(stderr, \"schema2id: new schema\\n\");\n#endif\n  return data->nschemata++;\n}", "target": 1}
{"code": "virSecuritySELinuxMCSFind(virSecurityManager *mgr,\n                          const char *sens,\n                          int catMin,\n                          int catMax)\n{\n    virSecuritySELinuxData *data = virSecurityManagerGetPrivateData(mgr);\n    int catRange;\n    char *mcs = NULL;\n    catRange = (catMax - catMin) + 1;\n    if (catRange < 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Category range c%d-c%d too small\"),\n                       catMin, catMax);\n        return NULL;\n    }\n    VIR_DEBUG(\"Using sensitivity level '%s' cat min %d max %d range %d\",\n              sens, catMin, catMax, catRange);\n    for (;;) {\n        int c1 = virRandomInt(catRange);\n        int c2 = virRandomInt(catRange);\n        VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n        if (c1 == c2) {\n            continue;\n        } else {\n            if (c1 > c2) {\n                int t = c1;\n                c1 = c2;\n                c2 = t;\n            }\n            mcs = g_strdup_printf(\"%s:c%d,c%d\", sens, catMin + c1, catMin + c2);\n        }\n        if (virHashLookup(data->mcs, mcs) == NULL)\n            break;\n        VIR_FREE(mcs);\n    }\n    return mcs;\n}", "target": 0}
{"code": "static void reds_remove_char_device(RedsState *reds, RedCharDevice *dev)\n{\n    g_return_if_fail(reds != NULL);\n    auto &devs(reds->char_devices);\n    g_warn_if_fail(std::find(devs.begin(), devs.end(),\n                             red::shared_ptr<RedCharDevice>(dev)) != devs.end());\n    devs.remove(red::shared_ptr<RedCharDevice>(dev));\n}", "target": 0}
{"code": "static int midi_setup_noteon(struct _mdi *mdi, uint8_t channel,\n                             uint8_t note, uint8_t velocity) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,channel, note);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_note_on;\n    mdi->events[mdi->event_count].event_data.channel = channel;\n    mdi->events[mdi->event_count].event_data.data.value = (note << 8) | velocity;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    if (mdi->channel[channel].isdrum)\n        _WM_load_patch(mdi, ((mdi->channel[channel].bank << 8) | (note | 0x80)));\n    return (0);\n}", "target": 0}
{"code": "static void HTPStateTransactionFree(void *state, uint64_t id)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    SCLogDebug(\"state %p, id %\"PRIu64, s, id);\n    htp_tx_t *tx = HTPStateGetTx(s, id);\n    if (tx != NULL) {\n        HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n        HtpTxUserDataFree(s, htud);\n        htp_tx_set_user_data(tx, NULL);\n        if (unlikely(!(\n            tx->request_progress == HTP_REQUEST_COMPLETE &&\n            tx->response_progress == HTP_RESPONSE_COMPLETE)))\n        {\n            tx->request_progress = HTP_REQUEST_COMPLETE;\n            tx->response_progress = HTP_RESPONSE_COMPLETE;\n        }\n        htp_tx_destroy(tx);\n    }\n    s->tx_freed += htp_connp_tx_freed(s->connp);\n}", "target": 0}
{"code": "rdr_notification_ctx_init(struct rdr_notification_ctx *ctx)\n{\n\tdeltas_parsed_init(&ctx->deltas);\n\treturn 0;\n}", "target": 1}
{"code": "static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3_request\t\t*req;\n\tint\t\t\t\tstarting;\n\tint\t\t\t\tret;\n\tu32\t\t\t\tcmd;\n\tif (!dwc3_calc_trbs_left(dep))\n\t\treturn 0;\n\tstarting = !(dep->flags & DWC3_EP_BUSY);\n\tdwc3_prepare_trbs(dep);\n\treq = next_request(&dep->started_list);\n\tif (!req) {\n\t\tdep->flags |= DWC3_EP_PENDING_REQUEST;\n\t\treturn 0;\n\t}\n\tmemset(&params, 0, sizeof(params));\n\tif (starting) {\n\t\tparams.param0 = upper_32_bits(req->trb_dma);\n\t\tparams.param1 = lower_32_bits(req->trb_dma);\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\t\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\t\tcmd |= DWC3_DEPCMD_PARAM(dep->frame_number);\n\t} else {\n\t\tcmd = DWC3_DEPCMD_UPDATETRANSFER |\n\t\t\tDWC3_DEPCMD_PARAM(dep->resource_index);\n\t}\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\tif (ret < 0) {\n\t\tif (req->trb)\n\t\t\tmemset(req->trb, 0, sizeof(struct dwc3_trb));\n\t\tdep->queued_requests--;\n\t\tdwc3_gadget_giveback(dep, req, ret);\n\t\treturn ret;\n\t}\n\tdep->flags |= DWC3_EP_BUSY;\n\tif (starting) {\n\t\tdep->resource_index = dwc3_gadget_ep_get_transfer_index(dep);\n\t\tWARN_ON_ONCE(!dep->resource_index);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "pci_emul_add_msicap(struct pci_vdev *dev, int msgnum)\n{\n\tstruct msicap msicap;\n\tpci_populate_msicap(&msicap, msgnum, 0);\n\treturn pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));\n}", "target": 1}
{"code": "  void initialize() override {\n    use_lds_ = false;\n    test_skipped_ = false;\n    setUpstreamCount(1);                         \n    setUpstreamProtocol(Http::CodecType::HTTP2); \n    defer_listener_finalization_ = true;\n    HttpIntegrationTest::initialize();\n    addFakeUpstream(Http::CodecType::HTTP2);\n    addFakeUpstream(Http::CodecType::HTTP2);\n    cluster1_ = ConfigHelper::buildStaticCluster(\n        ClusterName1, fake_upstreams_[UpstreamIndex1]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    cluster2_ = ConfigHelper::buildStaticCluster(\n        ClusterName2, fake_upstreams_[UpstreamIndex2]->localAddress()->ip()->port(),\n        Network::Test::getLoopbackAddressString(ipVersion()));\n    acceptXdsConnection();\n    EXPECT_TRUE(compareDiscoveryRequest(Config::TypeUrl::get().Cluster, \"\", {}, {}, {}, true));\n    sendDiscoveryResponse<envoy::config::cluster::v3::Cluster>(Config::TypeUrl::get().Cluster,\n                                                               {cluster1_}, {cluster1_}, {}, \"55\");\n    test_server_->waitForGaugeGe(\"cluster_manager.active_clusters\", 2);\n    test_server_->waitUntilListenersReady();\n    registerTestServerPorts({\"http\"});\n  }", "target": 1}
{"code": "static bool nvme_nsid_valid(NvmeCtrl *n, uint32_t nsid)\n{\n    return nsid &&\n        (nsid == NVME_NSID_BROADCAST || nsid <= NVME_MAX_NAMESPACES);\n}", "target": 0}
{"code": "u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  u_int16_t read = 0;\n  u_int16_t oldread;\n  u_int32_t c;\n  oldread = read;\n  c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = c << 24;\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 16);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 8);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read)\n    return(0);\n  val = val + c;\n  *bytes_read = *bytes_read + read;\n  return(htonl(val));\n}", "target": 0}
{"code": "static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)\n{\n    int offset = 0;\n    const uint8_t *ptr = NULL;\n    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || \n            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))\n        goto end_get_sig;\n    if (asn1_sig[offset++] != ASN1_OCTET_STRING)\n        goto end_get_sig;\n    *len = get_asn1_length(asn1_sig, &offset);\n    ptr = &asn1_sig[offset];          \nend_get_sig:\n    return ptr;\n}", "target": 1}
{"code": "ev_archive_set_archive_type (EvArchive *archive,\n\t\t\t     EvArchiveType archive_type)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type == EV_ARCHIVE_TYPE_NONE, FALSE);\n\tswitch (archive_type) {\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tlibarchive_set_archive_type (archive, archive_type);\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "njs_promise_resolve(njs_vm_t *vm, njs_value_t *constructor, njs_value_t *x)\n{\n    njs_int_t                 ret;\n    njs_value_t               value;\n    njs_object_t              *object;\n    njs_promise_capability_t  *capability;\n    static const njs_value_t  string_constructor = njs_string(\"constructor\");\n    if (njs_is_object(x)) {\n        object = njs_object_proto_lookup(njs_object(x), NJS_PROMISE,\n                                         njs_object_t);\n        if (object != NULL) {\n            ret = njs_value_property(vm, x, njs_value_arg(&string_constructor),\n                                     &value);\n            if (njs_slow_path(ret == NJS_ERROR)) {\n                return NULL;\n            }\n            if (njs_values_same(&value, constructor)) {\n                return njs_promise(x);\n            }\n        }\n    }\n    capability = njs_promise_new_capability(vm, constructor);\n    if (njs_slow_path(capability == NULL)) {\n        return NULL;\n    }\n    ret = njs_function_call(vm, njs_function(&capability->resolve),\n                            &njs_value_undefined, x, 1, &value);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return NULL;\n    }\n    return njs_promise(&capability->promise);\n}", "target": 1}
{"code": "iso9660_finish_entry(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tif (iso9660->cur_file == NULL)\n\t\treturn (ARCHIVE_OK);\n\tif (archive_entry_filetype(iso9660->cur_file->entry) != AE_IFREG)\n\t\treturn (ARCHIVE_OK);\n\tif (iso9660->cur_file->content.size == 0)\n\t\treturn (ARCHIVE_OK);\n\twhile (iso9660->bytes_remaining > 0) {\n\t\tsize_t s;\n\t\ts = (iso9660->bytes_remaining > a->null_length)?\n\t\t    a->null_length: (size_t)iso9660->bytes_remaining;\n\t\tif (write_iso9660_data(a, a->nulls, s) < 0)\n\t\t\treturn (ARCHIVE_FATAL);\n\t\tiso9660->bytes_remaining -= s;\n\t}\n\tif (iso9660->zisofs.making && zisofs_finish_entry(a) != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tif (wb_write_padding_to_temp(a, iso9660->cur_file->cur_content->size)\n\t    != ARCHIVE_OK)\n\t\treturn (ARCHIVE_FATAL);\n\tiso9660->cur_file->cur_content->blocks = (int)\n\t    ((iso9660->cur_file->cur_content->size\n\t     + LOGICAL_BLOCK_SIZE -1) >> LOGICAL_BLOCK_BITS);\n\tisofile_add_data_file(iso9660, iso9660->cur_file);\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static void mpls_dev_sysctl_unregister(struct net_device *dev,\n\t\t\t\t       struct mpls_dev *mdev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tif (!mdev->sysctl)\n\t\treturn;\n\ttable = mdev->sysctl->ctl_table_arg;\n\tunregister_net_sysctl_table(mdev->sysctl);\n\tkfree(table);\n\tmpls_netconf_notify_devconf(net, RTM_DELNETCONF, 0, mdev);\n}", "target": 0}
{"code": "ORDER *simple_remove_const(ORDER *order, COND *where)\n{\n  if (!order || !where)\n    return order;\n  ORDER *first= NULL, *prev= NULL;\n  for (; order; order= order->next)\n  {\n    DBUG_ASSERT(!order->item[0]->with_sum_func()); \n    if (!const_expression_in_where(where, order->item[0]))\n    {\n      if (!first)\n        first= order;\n      if (prev)\n        prev->next= order;\n      prev= order;\n    }\n  }\n  if (prev)\n    prev->next= NULL;\n  return first;\n}", "target": 0}
{"code": "static mp_obj_t int_to_bytes(size_t n_args, const mp_obj_t *args) {\n    (void)n_args;\n    mp_int_t len = mp_obj_get_int(args[1]);\n    if (len < 0) {\n        mp_raise_ValueError(NULL);\n    }\n    bool big_endian = args[2] != MP_OBJ_NEW_QSTR(MP_QSTR_little);\n    vstr_t vstr;\n    vstr_init_len(&vstr, len);\n    byte *data = (byte *)vstr.buf;\n    memset(data, 0, len);\n    #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n    if (!mp_obj_is_small_int(args[0])) {\n        mp_obj_int_to_bytes_impl(args[0], big_endian, len, data);\n    } else\n    #endif\n    {\n        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(args[0]);\n        size_t l = MIN((size_t)len, sizeof(val));\n        mp_binary_set_int(l, big_endian, data + (big_endian ? (len - l) : 0), val);\n    }\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}", "target": 1}
{"code": "static void mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen) {\n    s32 op = 0, ip = 0;\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n    for (s32 i = 0; i < 32; ++i) {\n        c = in[ip++];\n        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;\n    }\n    while (op < outlen) {\n        c = in[ip++];\n        if (t[c]) {\n            for (run = 0; (pc = in[ip++]) == 255; run += 255)\n                ;\n            run += pc + 1;\n            for (; run > 0 && op < outlen; --run) out[op++] = c;\n        } else\n            out[op++] = c;\n    }\n}", "target": 1}
{"code": "static int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tif (addr == 3)\n\t\treturn 0;\n\ts = &pit_state->channels[addr];\n\tmutex_lock(&pit_state->lock);\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}", "target": 0}
{"code": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\tif (**value == '\"') {\n\t\tend = strchr(*value + 1, '\"');\n\t\tif (!end) {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend++;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\treturn 1;\n}", "target": 1}
{"code": "static const char* get_av_pair_string(UINT16 pair)\n{\n\tswitch (pair)\n\t{\n\t\tcase MsvAvEOL:\n\t\t\treturn \"MsvAvEOL\";\n\t\tcase MsvAvNbComputerName:\n\t\t\treturn \"MsvAvNbComputerName\";\n\t\tcase MsvAvNbDomainName:\n\t\t\treturn \"MsvAvNbDomainName\";\n\t\tcase MsvAvDnsComputerName:\n\t\t\treturn \"MsvAvDnsComputerName\";\n\t\tcase MsvAvDnsDomainName:\n\t\t\treturn \"MsvAvDnsDomainName\";\n\t\tcase MsvAvDnsTreeName:\n\t\t\treturn \"MsvAvDnsTreeName\";\n\t\tcase MsvAvFlags:\n\t\t\treturn \"MsvAvFlags\";\n\t\tcase MsvAvTimestamp:\n\t\t\treturn \"MsvAvTimestamp\";\n\t\tcase MsvAvSingleHost:\n\t\t\treturn \"MsvAvSingleHost\";\n\t\tcase MsvAvTargetName:\n\t\t\treturn \"MsvAvTargetName\";\n\t\tcase MsvChannelBindings:\n\t\t\treturn \"MsvChannelBindings\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t}\n}", "target": 0}
{"code": "int MSADPCM::decodeBlock(const uint8_t *encoded, int16_t *decoded)\n{\n\tms_adpcm_state decoderState[2];\n\tms_adpcm_state *state[2];\n\tint channelCount = m_track->f.channelCount;\n\tint outputLength = m_framesPerPacket * sizeof (int16_t) * channelCount;\n\tstate[0] = &decoderState[0];\n\tif (channelCount == 2)\n\t\tstate[1] = &decoderState[1];\n\telse\n\t\tstate[1] = &decoderState[0];\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->predictorIndex = *encoded++;\n\t\tassert(state[i]->predictorIndex < m_numCoefficients);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->delta = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample1 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tfor (int i=0; i<channelCount; i++)\n\t{\n\t\tstate[i]->sample2 = (encoded[1]<<8) | encoded[0];\n\t\tencoded += sizeof (uint16_t);\n\t}\n\tconst int16_t *coefficient[2] =\n\t{\n\t\tm_coefficients[state[0]->predictorIndex],\n\t\tm_coefficients[state[1]->predictorIndex]\n\t};\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample2;\n\tfor (int i=0; i<channelCount; i++)\n\t\t*decoded++ = state[i]->sample1;\n\tint samplesRemaining = (m_framesPerPacket - 2) * m_track->f.channelCount;\n\twhile (samplesRemaining > 0)\n\t{\n\t\tuint8_t code;\n\t\tint16_t newSample;\n\t\tcode = *encoded >> 4;\n\t\tnewSample = decodeSample(*state[0], code, coefficient[0]);\n\t\t*decoded++ = newSample;\n\t\tcode = *encoded & 0x0f;\n\t\tnewSample = decodeSample(*state[1], code, coefficient[1]);\n\t\t*decoded++ = newSample;\n\t\tencoded++;\n\t\tsamplesRemaining -= 2;\n\t}\n\treturn outputLength;\n}", "target": 1}
{"code": "void AsfVideo::fileProperties() {\n  DataBuf FileIddBuf = io_->read(GUID);\n  xmpData()[\"Xmp.video.FileID\"] = GUIDTag(FileIddBuf.data()).to_string();\n  xmpData()[\"Xmp.video.FileLength\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.CreationDate\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.DataPackets\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.duration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.SendDuration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.Preroll\"] = readQWORDTag(io_);\n  io_->seek(io_->tell() + DWORD + DWORD + DWORD,\n            BasicIo::beg);  \n  xmpData()[\"Xmp.video.MaxBitRate\"] = readDWORDTag(io_);\n}  ", "target": 1}
{"code": "xfs_iget_check_free_state(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tif (flags & XFS_IGET_CREATE) {\n\t\tif (VFS_I(ip)->i_mode != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)\",\n\t\t\t\tip->i_ino, VFS_I(ip)->i_mode);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (ip->i_d.di_nblocks != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tip->i_ino);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (VFS_I(ip)->i_mode == 0)\n\t\treturn -ENOENT;\n\treturn 0;\n}", "target": 0}
{"code": "__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\treturn seq_scale(hash[0]);\n}", "target": 0}
{"code": "static int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n}", "target": 1}
{"code": "xsltSort(xsltTransformContextPtr ctxt,\n\txmlNodePtr node ATTRIBUTE_UNUSED, xmlNodePtr inst,\n\txsltStylePreCompPtr comp) {\n    if (comp == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t     \"xsl:sort : compilation failed\\n\");\n\treturn;\n    }\n    xsltTransformError(ctxt, NULL, inst,\n\t \"xsl:sort : improper use this should not be reached\\n\");\n}", "target": 0}
{"code": "static void handle_post_create(struct http_conn *conn,\n\t\t\t       struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tuint64_t ident;\n\tchar key[256];\n\tint err = 0;\n\tident = 1 + rand_u64() & 0xf;  \n\tre_snprintf(key, sizeof(key), \"%llu\", ident);\n\tinfo(\"POST: new pairing id %llu\\n\", ident);\n\tie = mem_zalloc(sizeof(*ie), ie_destructor);\n\tie->id = ident;\n\tstr_dup(&ie->ident, key);\n\terr = dict_add(verifyd.idents, key, ie);\n\tif (err)\n\t\tgoto out;\n\tmem_deref(ie); \n\thttp_creply(conn, 200, \"OK\",\n\t\t    \"application/json\",\n\t\t    \"{\\\"pairid\\\":\\\"%llu\\\"}\", ident);\n out:\n\tif (err) {\n\t\twarning(\"internal error (%m)\\n\" ,err);\n\t}\n}", "target": 0}
{"code": "infra_create(struct config_file* cfg)\n{\n\tstruct infra_cache* infra = (struct infra_cache*)calloc(1, \n\t\tsizeof(struct infra_cache));\n\tsize_t maxmem = cfg->infra_cache_numhosts * (sizeof(struct infra_key)+\n\t\tsizeof(struct infra_data)+INFRA_BYTES_NAME);\n\tif(!infra) {\n\t\treturn NULL;\n\t}\n\tinfra->hosts = slabhash_create(cfg->infra_cache_slabs,\n\t\tINFRA_HOST_STARTSIZE, maxmem, &infra_sizefunc, &infra_compfunc,\n\t\t&infra_delkeyfunc, &infra_deldatafunc, NULL);\n\tif(!infra->hosts) {\n\t\tfree(infra);\n\t\treturn NULL;\n\t}\n\tinfra->host_ttl = cfg->host_ttl;\n\tinfra->infra_keep_probing = cfg->infra_keep_probing;\n\tinfra_dp_ratelimit = cfg->ratelimit;\n\tinfra->domain_rates = slabhash_create(cfg->ratelimit_slabs,\n\t\tINFRA_HOST_STARTSIZE, cfg->ratelimit_size,\n\t\t&rate_sizefunc, &rate_compfunc, &rate_delkeyfunc,\n\t\t&rate_deldatafunc, NULL);\n\tif(!infra->domain_rates) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tif(!setup_domain_limits(infra, cfg)) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tif(!setup_wait_limits(infra, cfg)) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tinfra_ip_ratelimit = cfg->ip_ratelimit;\n\tinfra->client_ip_rates = slabhash_create(cfg->ip_ratelimit_slabs,\n\t    INFRA_HOST_STARTSIZE, cfg->ip_ratelimit_size, &ip_rate_sizefunc,\n\t    &ip_rate_compfunc, &ip_rate_delkeyfunc, &ip_rate_deldatafunc, NULL);\n\tif(!infra->client_ip_rates) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\treturn infra;\n}", "target": 0}
{"code": "static int mount_notrunc(const char *source, const char *target,\n\t\t\t const char *filesystemtype, unsigned long mountflags,\n\t\t\t const char *data) {\n\tif (strlen(data) > sysconf(_SC_PAGESIZE) - 1) {\n\t\tfprintf(stderr, \"%s: mount options too long\\n\", progname);\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\treturn mount(source, target, filesystemtype, mountflags, data);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& values_tensor = ctx->input(0);\n    const Tensor& value_range_tensor = ctx->input(1);\n    const Tensor& nbins_tensor = ctx->input(2);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(value_range_tensor.shape()),\n                errors::InvalidArgument(\"value_range should be a vector.\"));\n    OP_REQUIRES(ctx, (value_range_tensor.shape().num_elements() == 2),\n                errors::InvalidArgument(\n                    \"value_range should be a vector of 2 elements.\"));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(nbins_tensor.shape()),\n                errors::InvalidArgument(\"nbins should be a scalar.\"));\n    const auto values = values_tensor.flat<T>();\n    const auto value_range = value_range_tensor.flat<T>();\n    const auto nbins = nbins_tensor.scalar<int32>()();\n    OP_REQUIRES(\n        ctx, (value_range(0) < value_range(1)),\n        errors::InvalidArgument(\"value_range should satisfy value_range[0] < \"\n                                \"value_range[1], but got '[\",\n                                value_range(0), \", \", value_range(1), \"]'\"));\n    OP_REQUIRES(\n        ctx, (nbins > 0),\n        errors::InvalidArgument(\"nbins should be a positive number, but got '\",\n                                nbins, \"'\"));\n    Tensor* out_tensor;\n    OP_REQUIRES_OK(ctx,\n                   ctx->allocate_output(0, TensorShape({nbins}), &out_tensor));\n    auto out = out_tensor->flat<Tout>();\n    OP_REQUIRES_OK(\n        ctx, functor::HistogramFixedWidthFunctor<Device, T, Tout>::Compute(\n                 ctx, values, value_range, nbins, out));\n  }", "target": 1}
{"code": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\t\treset_globals();\n\t\treturn e;\n\t}\n}", "target": 1}
{"code": "yang_read_string(struct ly_ctx *ctx, const char *input, char *output, int size, int offset, int indent)\n{\n    int i = 0, out_index = offset, space = 0;\n    while (i < size) {\n        switch (input[i]) {\n        case '\\n':\n            out_index -= space;\n            output[out_index] = '\\n';\n            space = 0;\n            i = read_indent(input, indent, size, i + 1, &out_index, output);\n            break;\n        case ' ':\n        case '\\t':\n            output[out_index] = input[i];\n            ++space;\n            break;\n        case '\\\\':\n            if (input[i + 1] == 'n') {\n                out_index -= space;\n                output[out_index] = '\\n';\n                space = 0;\n                i = read_indent(input, indent, size, i + 2, &out_index, output);\n            } else if (input[i + 1] == 't') {\n                output[out_index] = '\\t';\n                ++i;\n                ++space;\n            } else if (input[i + 1] == '\\\\') {\n                output[out_index] = '\\\\';\n                ++i;\n            } else if ((i + 1) != size && input[i + 1] == '\"') {\n                output[out_index] = '\"';\n                ++i;\n            } else {\n                LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, input + i);\n                return NULL;\n            }\n            break;\n        default:\n            output[out_index] = input[i];\n            space = 0;\n            break;\n        }\n        ++i;\n        ++out_index;\n    }\n    output[out_index] = '\\0';\n    if (size != out_index) {\n        output = realloc(output, out_index + 1);\n        LY_CHECK_ERR_RETURN(!output, LOGMEM(ctx), NULL);\n    }\n    return output;\n}", "target": 0}
{"code": "certstack_create(struct cert_stack **result)\n{\n\tstruct cert_stack *stack;\n\tstack = malloc(sizeof(struct cert_stack));\n\tif (stack == NULL)\n\t\treturn pr_enomem();\n\tstack->x509s = sk_X509_new_null();\n\tif (stack->x509s == NULL) {\n\t\tfree(stack);\n\t\treturn val_crypto_err(\"sk_X509_new_null() returned NULL\");\n\t}\n\tSLIST_INIT(&stack->defers);\n\tSLIST_INIT(&stack->metas);\n\tSLIST_INIT(&stack->levels);\n\t*result = stack;\n\treturn 0;\n}", "target": 1}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "add_key_equal_fields(JOIN *join, KEY_FIELD **key_fields, uint and_level,\n                     Item_bool_func *cond, Item *field_item,\n                     bool eq_func, Item **val,\n                     uint num_values, table_map usable_tables,\n                     SARGABLE_PARAM **sargables, uint row_col_no= 0)\n{\n  Field *field= ((Item_field *) (field_item->real_item()))->field;\n  add_key_field(join, key_fields, and_level, cond, field,\n                eq_func, val, num_values, usable_tables, sargables,\n                row_col_no);\n  Item_equal *item_equal= field_item->get_item_equal();\n  if (item_equal)\n  { \n    Item_equal_fields_iterator it(*item_equal);\n    while (it++)\n    {\n      Field *equal_field= it.get_curr_field();\n      if (!field->eq(equal_field))\n      {\n        add_key_field(join, key_fields, and_level, cond, equal_field,\n                      eq_func, val, num_values, usable_tables,\n                      sargables, row_col_no);\n      }\n    }\n  }\n}", "target": 0}
{"code": "static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC)\n{\n\tuint64_t max_vars = PG(max_input_vars);\n\tvars->ptr = vars->str.c;\n\tvars->end = vars->str.c + vars->str.len;\n\twhile (add_post_var(arr, vars, eof TSRMLS_CC)) {\n\t\tif (++vars->cnt > max_vars) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\n\t\t\t\t\t\"Input variables exceeded %\" PRIu64 \". \"\n\t\t\t\t\t\"To increase the limit change max_input_vars in php.ini.\",\n\t\t\t\t\tmax_vars);\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\tif (!eof) {\n\t\tmemmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr);\n\t}\n\treturn SUCCESS;\n}", "target": 1}
{"code": "  bool IsInUse() { return entry_stack_ != NULL; }", "target": 0}
{"code": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}", "target": 1}
{"code": "static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,\n                                          const unsigned char *end )\n{\n    int ret = 0;\n    size_t n;\n    if( ssl->conf->f_psk == NULL &&\n        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||\n          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"got no pre-shared key\" ) );\n        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );\n    }\n    if( *p + 2 > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    n = ( (*p)[0] << 8 ) | (*p)[1];\n    *p += 2;\n    if( n < 1 || n > 65535 || *p + n > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad client key exchange message\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );\n    }\n    if( ssl->conf->f_psk != NULL )\n    {\n        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n    }\n    else\n    {\n        if( n != ssl->conf->psk_identity_len ||\n            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )\n        {\n            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;\n        }\n    }\n    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )\n    {\n        MBEDTLS_SSL_DEBUG_BUF( 3, \"Unknown PSK identity\", *p, n );\n        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,\n                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );\n        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );\n    }\n    *p += n;\n    return( 0 );\n}", "target": 1}
{"code": "BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, bitmapUpdate->number); \n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT16 count;\n\t\tBITMAP_DATA* newdata;\n\t\tcount = bitmapUpdate->number * 2;\n\t\tnewdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                                 sizeof(BITMAP_DATA) * count);\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}", "target": 1}
{"code": "matchDomainName(const char *h, const char *d, MatchDomainNameFlags flags)\n{\n    int dl;\n    int hl;\n    const bool hostIncludesSubdomains = (*h == '.');\n    while ('.' == *h)\n        ++h;\n    hl = strlen(h);\n    if (hl == 0)\n        return -1;\n    dl = strlen(d);\n    if (dl == 0)\n        return 1;\n    while (xtolower(h[--hl]) == xtolower(d[--dl])) {\n        if (hl == 0 && dl == 0) {\n            return 0;\n        }\n        if (0 == hl) {\n            if (1 == dl && '.' == d[0])\n                return 0;\n            else\n                return -1;\n        }\n        if (0 == dl) {\n            if ('.' == d[0]) {\n                if (flags & mdnRejectSubsubDomains) {\n                    while(--hl >= 0 && h[hl] != '.');\n                    if (hl < 0) {\n                        return hostIncludesSubdomains ? 1 : 0;\n                    } else\n                        return 1; \n                } else\n                    return 0;\n            } else\n                return 1;\n        }\n    }\n    if ((flags & mdnHonorWildcards) && h[hl] == '*' && h[hl + 1] == '.')\n        return 0;\n    if ('.' == d[dl])\n        return 1;\n    if ('.' == h[hl])\n        return -1;\n    return (xtolower(h[hl]) - xtolower(d[dl]));\n}", "target": 0}
{"code": "int yr_object_array_set_item(\n    YR_OBJECT* object,\n    YR_OBJECT* item,\n    int index)\n{\n  YR_OBJECT_ARRAY* array;\n  int i;\n  int count;\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n  array = object_as_array(object);\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n    array->items->count = count;\n  }\n  item->parent = object;\n  array->items->objects[index] = item;\n  return ERROR_SUCCESS;\n}", "target": 1}
{"code": "static struct btrfs_dir_item *btrfs_match_dir_item_name(struct btrfs_root *root,\n\t\t\t      struct btrfs_path *path,\n\t\t\t      const char *name, int name_len)\n{\n\tstruct btrfs_dir_item *dir_item;\n\tunsigned long name_ptr;\n\tu32 total_len;\n\tu32 cur = 0;\n\tu32 this_len;\n\tstruct extent_buffer *leaf;\n\tleaf = path->nodes[0];\n\tdir_item = btrfs_item_ptr(leaf, path->slots[0], struct btrfs_dir_item);\n\tif (verify_dir_item(root, leaf, dir_item))\n\t\treturn NULL;\n\ttotal_len = btrfs_item_size_nr(leaf, path->slots[0]);\n\twhile (cur < total_len) {\n\t\tthis_len = sizeof(*dir_item) +\n\t\t\tbtrfs_dir_name_len(leaf, dir_item) +\n\t\t\tbtrfs_dir_data_len(leaf, dir_item);\n\t\tname_ptr = (unsigned long)(dir_item + 1);\n\t\tif (btrfs_dir_name_len(leaf, dir_item) == name_len &&\n\t\t    memcmp_extent_buffer(leaf, name, name_ptr, name_len) == 0)\n\t\t\treturn dir_item;\n\t\tcur += this_len;\n\t\tdir_item = (struct btrfs_dir_item *)((char *)dir_item +\n\t\t\t\t\t\t     this_len);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "R_API char *r_cons_hud_line_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tr_str_ansi_strip (o);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud_line (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}", "target": 0}
{"code": "int nfc_register_device(struct nfc_dev *dev)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\trc = device_add(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n\tif (rc < 0)\n\t\treturn rc;\n\trc = nfc_llcp_register_device(dev);\n\tif (rc)\n\t\tpr_err(\"Could not register llcp device\\n\");\n\tdevice_lock(&dev->dev);\n\tdev->rfkill = rfkill_alloc(dev_name(&dev->dev), &dev->dev,\n\t\t\t\t   RFKILL_TYPE_NFC, &nfc_rfkill_ops, dev);\n\tif (dev->rfkill) {\n\t\tif (rfkill_register(dev->rfkill) < 0) {\n\t\t\trfkill_destroy(dev->rfkill);\n\t\t\tdev->rfkill = NULL;\n\t\t}\n\t}\n\tdev->shutting_down = false;\n\tdevice_unlock(&dev->dev);\n\trc = nfc_genl_device_added(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s was added\\n\",\n\t\t\t dev_name(&dev->dev));\n\treturn 0;\n}", "target": 0}
{"code": "static int SetupSavePath(const DetectEngineCtx *de_ctx,\n        char *save, size_t save_size)\n{\n    SCLogDebug(\"save %s\", save);\n    int allow_save = 1;\n    if (ConfGetBool(\"datasets.rules.allow-write\", &allow_save)) {\n        if (!allow_save) {\n            SCLogError(SC_ERR_INVALID_SIGNATURE,\n                    \"Rules containing save/state datasets have been disabled\");\n            return -1;\n        }\n    }\n    int allow_absolute = 0;\n    (void)ConfGetBool(\"datasets.rules.allow-absolute-filenames\", &allow_absolute);\n    if (allow_absolute) {\n        SCLogNotice(\"Allowing absolute filename for dataset rule: %s\", save);\n    } else {\n        if (PathIsAbsolute(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Absolute paths not allowed: %s\", save);\n            return -1;\n        }\n        if (SCPathContainsTraversal(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Directory traversals not allowed: %s\", save);\n            return -1;\n        }\n    }\n    const char *dir = ConfigGetDataDirectory();\n    BUG_ON(dir == NULL); \n    char path[PATH_MAX];\n    if (snprintf(path, sizeof(path), \"%s/%s\", dir, save) >= (int)sizeof(path)) \n        return -1;\n    strlcpy(save, path, save_size);\n    return 0;\n}", "target": 0}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        luaL_checkstack(L, 1, \"in function mp_check\");\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "vg_process_cursor_cmd(VuGpu *g, struct virtio_gpu_update_cursor *cursor)\n{\n    switch (cursor->hdr.type) {\n    case VIRTIO_GPU_CMD_MOVE_CURSOR: {\n        VhostUserGpuMsg msg = {\n            .request = cursor->resource_id ?\n                VHOST_USER_GPU_CURSOR_POS : VHOST_USER_GPU_CURSOR_POS_HIDE,\n            .size = sizeof(VhostUserGpuCursorPos),\n            .payload.cursor_pos = {\n                .scanout_id = cursor->pos.scanout_id,\n                .x = cursor->pos.x,\n                .y = cursor->pos.y,\n            }\n        };\n        g_debug(\"%s: move\", G_STRFUNC);\n        vg_send_msg(g, &msg, -1);\n        break;\n    }\n    case VIRTIO_GPU_CMD_UPDATE_CURSOR: {\n        VhostUserGpuMsg msg = {\n            .request = VHOST_USER_GPU_CURSOR_UPDATE,\n            .size = sizeof(VhostUserGpuCursorUpdate),\n            .payload.cursor_update = {\n                .pos = {\n                    .scanout_id = cursor->pos.scanout_id,\n                    .x = cursor->pos.x,\n                    .y = cursor->pos.y,\n                },\n                .hot_x = cursor->hot_x,\n                .hot_y = cursor->hot_y,\n            }\n        };\n        g_debug(\"%s: update\", G_STRFUNC);\n        if (g->virgl) {\n            vg_virgl_update_cursor_data(g, cursor->resource_id,\n                                        msg.payload.cursor_update.data);\n        } else {\n            update_cursor_data_simple(g, cursor->resource_id,\n                                      msg.payload.cursor_update.data);\n        }\n        vg_send_msg(g, &msg, -1);\n        break;\n    }\n    default:\n        g_debug(\"%s: unknown cmd %d\", G_STRFUNC, cursor->hdr.type);\n        break;\n    }\n}", "target": 0}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    memset((char *)&sct, 0, sizeof(sct));\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 0}
{"code": "_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\tfn_size = strlen(cs->function) + 1;\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\tif (chunk == NULL) {\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); \n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\tactual_size += msg_len;\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}", "target": 1}
{"code": "int pam_modutil_drop_priv(pam_handle_t *pamh, struct _ykpam_privs *privs, struct passwd *pw) {\n    privs->saved_euid = geteuid();\n    privs->saved_egid = getegid();\n    if ((privs->saved_euid == pw->pw_uid) && (privs->saved_egid == pw->pw_gid)) {\n        D (privs->debug_file, \"Privilges already dropped, pretend it is all right\");\n        return 0;\n    }\n    privs->saved_groups_length = getgroups(0, NULL);\n    if (privs->saved_groups_length < 0) {\n        D (privs->debug_file, \"getgroups: %s\", strerror(errno));\n        return -1;\n    }\n    if (privs->saved_groups_length > SAVED_GROUPS_MAX_LEN) {\n        D (privs->debug_file, \"too many groups, limiting.\");\n        privs->saved_groups_length = SAVED_GROUPS_MAX_LEN;\n    }\n    if (privs->saved_groups_length > 0) {\n        if (getgroups(privs->saved_groups_length, privs->saved_groups) < 0) {\n            D (privs->debug_file, \"getgroups: %s\", strerror(errno));\n            goto free_out;\n        }\n    }\n    if (initgroups(pw->pw_name, pw->pw_gid) < 0) {\n        D (privs->debug_file, \"initgroups: %s\", strerror(errno));\n        goto free_out;\n    }\n    if (setegid(pw->pw_gid) < 0) {\n        D (privs->debug_file, \"setegid: %s\", strerror(errno));\n        goto free_out;\n    }\n    if (seteuid(pw->pw_uid) < 0) {\n        D (privs->debug_file, \"seteuid: %s\", strerror(errno));\n        goto free_out;\n    }\n    return 0;\nfree_out:\n    return -1;\n}", "target": 0}
{"code": "COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask) {\n\t\terr = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, nodes_addr(bm), alloc_size);\n\t}\n\tif (err)\n\t\treturn -EFAULT;\n\treturn sys_mbind(start, len, mode, nm, nr_bits+1, flags);\n}", "target": 1}
{"code": "static void Process_ipfix_template_withdraw(exporter_ipfix_domain_t *exporter, void *DataPtr, uint32_t size_left, FlowSource_t *fs) {\nipfix_template_record_t *ipfix_template_record;\n\twhile ( size_left ) {\n\t\tuint32_t id;\n\t\tif ( size_left < 4 ) {\n\t\t\tLogError(\"Process_ipfix [%u] Template withdraw size error at %s line %u\" , \n\t\t\t\texporter->info.id, __FILE__, __LINE__, strerror (errno));\n\t\t\tsize_left = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tipfix_template_record = (ipfix_template_record_t *)DataPtr;\n\t\tsize_left \t\t-= 4;\n\t\tid \t  = ntohs(ipfix_template_record->TemplateID);\n\t\tif ( id == IPFIX_TEMPLATE_FLOWSET_ID ) {\n\t\t\tremove_all_translation_tables(exporter);\n\t\t\tReInitExtensionMapList(fs);\n\t\t} else {\n\t\t\tremove_translation_table(fs, exporter, id);\n\t\t}\n\t\tDataPtr = DataPtr + 4;\n\t\tif ( size_left < 4 ) {\n\t\t\tdbg_printf(\"Skip %u bytes padding\\n\", size_left);\n\t\t\tsize_left = 0;\n\t\t}\n\t}\n} ", "target": 0}
{"code": "static int vapic_enter(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct page *page;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn 0;\n\tpage = gfn_to_page(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\treturn -EFAULT;\n\tvcpu->arch.apic->vapic_page = page;\n\treturn 0;\n}", "target": 1}
{"code": "static int parse_timecode_in_framenum_format(AVFormatContext *s, AVStream *st,\n                                             int64_t value, int flags)\n{\n    AVTimecode tc;\n    char buf[AV_TIMECODE_STR_SIZE];\n    AVRational rate = st->avg_frame_rate;\n    int ret = av_timecode_init(&tc, rate, flags, 0, s);\n    if (ret < 0)\n        return ret;\n    av_dict_set(&st->metadata, \"timecode\",\n                av_timecode_make_string(&tc, buf, value), 0);\n    return 0;\n}", "target": 0}
{"code": "static int ndp_sock_open(struct ndp *ndp)\n{\n\tint sock;\n\tint ret;\n\tint err;\n\tint val;\n\tsock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n\tif (sock == -1) {\n\t\terr(ndp, \"Failed to create ICMP6 socket.\");\n\t\treturn -errno;\n\t}\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVPKTINFO.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\tval = 255;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_MULTICAST_HOPS.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVHOPLIMIT,.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\tndp->sock = sock;\n\treturn 0;\nclose_sock:\n\tclose(sock);\n\treturn err;\n}", "target": 0}
{"code": "static void *smm_stub_place_stacks(char *base, size_t size,\n\t\t\t\t   struct smm_loader_params *params)\n{\n\tsize_t total_stack_size;\n\tchar *stacks_top;\n\ttotal_stack_size = params->per_cpu_stack_size *\n\t\t\t   params->num_concurrent_stacks;\n\tprintk(BIOS_DEBUG, \"%s: cpus: %zx : stack space: needed -> %zx\\n\",\n\t\t__func__, params->num_concurrent_stacks,\n\t\ttotal_stack_size);\n\tprintk(BIOS_DEBUG, \"  available -> %zx : per_cpu_stack_size : %zx\\n\",\n\t\tsize, params->per_cpu_stack_size);\n\tif (params->num_concurrent_stacks < 1)\n\t\treturn NULL;\n\tif (total_stack_size > size)\n\t\treturn NULL;\n\tstacks_top = &base[total_stack_size];\n\tprintk(BIOS_DEBUG, \"%s: exit, stack_top %p\\n\", __func__, stacks_top);\n\treturn stacks_top;\n}", "target": 0}
{"code": "void luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {\n  int i;\n  int nextra = ci->u.l.nextraargs;\n  if (wanted < 0) {\n    wanted = nextra;  \n    checkstackp(L, nextra, where);  \n    L->top = where + nextra;  \n  }\n  for (i = 0; i < wanted && i < nextra; i++)\n    setobjs2s(L, where + i, ci->func - nextra + i);\n  for (; i < wanted; i++)   \n    setnilvalue(s2v(where + i));\n}", "target": 1}
{"code": "acpi_os_create_semaphore(u32 max_units, u32 initial_units, acpi_handle * handle)\n{\n\tstruct semaphore *sem = NULL;\n\tsem = acpi_os_allocate_zeroed(sizeof(struct semaphore));\n\tif (!sem)\n\t\treturn AE_NO_MEMORY;\n\tsema_init(sem, initial_units);\n\t*handle = (acpi_handle *) sem;\n\tACPI_DEBUG_PRINT((ACPI_DB_MUTEX, \"Creating semaphore[%p|%d].\\n\",\n\t\t\t  *handle, initial_units));\n\treturn AE_OK;\n}", "target": 0}
{"code": "ossl_cipher_init(int argc, VALUE *argv, VALUE self, int mode)\n{\n    EVP_CIPHER_CTX *ctx;\n    unsigned char key[EVP_MAX_KEY_LENGTH], *p_key = NULL;\n    unsigned char iv[EVP_MAX_IV_LENGTH], *p_iv = NULL;\n    VALUE pass, init_v;\n    if(rb_scan_args(argc, argv, \"02\", &pass, &init_v) > 0){\n\tVALUE cname  = rb_class_path(rb_obj_class(self));\n\trb_warn(\"arguments for %\"PRIsVALUE\"#encrypt and %\"PRIsVALUE\"#decrypt were deprecated; \"\n                \"use %\"PRIsVALUE\"#pkcs5_keyivgen to derive key and IV\",\n                cname, cname, cname);\n\tStringValue(pass);\n\tGetCipher(self, ctx);\n\tif (NIL_P(init_v)) memcpy(iv, \"OpenSSL for Ruby rulez!\", sizeof(iv));\n\telse{\n\t    StringValue(init_v);\n\t    if (EVP_MAX_IV_LENGTH > RSTRING_LEN(init_v)) {\n\t\tmemset(iv, 0, EVP_MAX_IV_LENGTH);\n\t\tmemcpy(iv, RSTRING_PTR(init_v), RSTRING_LEN(init_v));\n\t    }\n\t    else memcpy(iv, RSTRING_PTR(init_v), sizeof(iv));\n\t}\n\tEVP_BytesToKey(EVP_CIPHER_CTX_cipher(ctx), EVP_md5(), iv,\n\t\t       (unsigned char *)RSTRING_PTR(pass), RSTRING_LENINT(pass), 1, key, NULL);\n\tp_key = key;\n\tp_iv = iv;\n    }\n    else {\n\tGetCipher(self, ctx);\n    }\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, p_key, p_iv, mode) != 1) {\n\tossl_raise(eCipherError, NULL);\n    }\n    if (p_key)\n\trb_ivar_set(self, id_key_set, Qtrue);\n    return self;\n}", "target": 0}
{"code": "static inline bool cfs_rq_is_decayed(struct cfs_rq *cfs_rq)\n{\n\tif (cfs_rq->load.weight)\n\t\treturn false;\n\tif (cfs_rq->avg.load_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.util_sum)\n\t\treturn false;\n\tif (cfs_rq->avg.runnable_load_sum)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "void TestSocketLineReader::initTestCase()\n{\n    m_server = new Server(this);\n    QVERIFY2(m_server->listen(QHostAddress::LocalHost, 8694), \"Failed to create local tcp server\");\n    m_timer.setInterval(4000);\n    m_timer.setSingleShot(true);\n    connect(&m_timer, &QTimer::timeout, &m_loop, &QEventLoop::quit);\n    m_conn = new QSslSocket(this);\n    m_conn->connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &QAbstractSocket::connected, &m_loop, &QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n    QVERIFY2(m_conn->isOpen(), \"Could not connect to local tcp server\");\n}", "target": 1}
{"code": "TfLiteStatus MultiplyAndCheckOverflow(size_t a, size_t b, size_t* product) {\n  constexpr size_t size_t_bits = 8 * sizeof(size_t);\n  constexpr size_t overflow_upper_half_bit_position = size_t_bits / 2;\n  *product = a * b;\n  if (TFLITE_EXPECT_FALSE((a | b) >> overflow_upper_half_bit_position != 0)) {\n    if (a != 0 && *product / a != b) return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n\t\t\t  proto_tree *tree, guint8 *drep _U_, char **data,\n\t\t\t  int hf_name)\n{\n\tgint len, remaining;\n\tchar *text;\n\tif (offset % 2)\n\t\toffset += 2 - (offset % 2);\n\tremaining = tvb_captured_length_remaining(tvb, offset);\n\tif (remaining <= 0) {\n\t\tif (data)\n\t\t\t*data = g_strdup(\"\");\n\t\treturn offset;\n\t}\n\ttext = tvb_get_string_enc(NULL, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\tlen = (int)strlen(text);\n\tproto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);\n\tif (data)\n\t\t*data = text;\n\telse\n\t\tg_free(text);\n\treturn offset + (len + 1) * 2;\n}", "target": 1}
{"code": "cib_tls_close(cib_t * cib)\n{\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    shutdown(private->command.socket, SHUT_RDWR);       \n    shutdown(private->callback.socket, SHUT_RDWR);      \n    close(private->command.socket);\n    close(private->callback.socket);\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (private->command.encrypted) {\n        gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->command.session));\n        gnutls_free(private->command.session);\n        gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->callback.session));\n        gnutls_free(private->callback.session);\n        gnutls_anon_free_client_credentials(anon_cred_c);\n        gnutls_global_deinit();\n    }\n#endif\n    return 0;\n}", "target": 1}
{"code": "void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  if (MinCapacity > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  size_t NewCapacity = 2 * capacity() + 1; \n  NewCapacity =\n      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n    memcpy(NewElts, this->BeginX, size() * TSize);\n  } else {\n    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);\n  }\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}", "target": 1}
{"code": "NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {\n    SSL *ssl;\n    CLI *c;\n    ssl=X509_STORE_CTX_get_ex_data(callback_ctx,\n        SSL_get_ex_data_X509_STORE_CTX_idx());\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n    if(!c->opt->option.verify_chain && !c->opt->option.verify_peer) {\n        s_log(LOG_INFO, \"Certificate verification disabled\");\n        return 1; \n    }\n    if(verify_checks(c, preverify_ok, callback_ctx)) {\n        SSL_SESSION *sess=SSL_get1_session(c->ssl);\n        if(sess) {\n            int ok=SSL_SESSION_set_ex_data(sess, index_session_authenticated,\n                (void *)(-1));\n            SSL_SESSION_free(sess);\n            if(!ok) {\n                sslerror(\"SSL_SESSION_set_ex_data\");\n                return 0; \n            }\n        }\n        return 1; \n    }\n    if(c->opt->option.client || c->opt->protocol)\n        return 0; \n    if(c->opt->redirect_addr.names)\n        return 1; \n    return 0; \n}", "target": 1}
{"code": "void test_checkout_nasty__git_tilde1(void)\n{\n#ifdef GIT_WIN32\n\ttest_checkout_fails(\"refs/heads/git_tilde1\", \".git/foobar\");\n#endif\n}", "target": 1}
{"code": "ResourceHandle::ResourceHandle(const ResourceHandleProto& proto) {\n  FromProto(proto);\n}", "target": 1}
{"code": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\tlen = cb->dump(skb, cb);\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\tnl_dump_check_consistent(cb, nlh);\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\tif (cb->done)\n\t\tcb->done(cb);\n\tnlk->cb_running = false;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n\treturn 0;\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}", "target": 1}
{"code": "FramebufferModel::FramebufferModel(QObject* parent)\n  : QObject(parent)\n  , m_pixelBuffer(nullptr)\n  , m_width(0)\n  , m_height(0)\n  , m_isImageLoaded(false)\n  , m_exposure(0)\n  , m_imageLoadingWatcher(new QFutureWatcher<void>(this))\n  , m_imageEditingWatcher(new QFutureWatcher<void>(this))\n  , m_pixelAspectRatio(1.f)\n{}", "target": 1}
{"code": "static void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n    pj_scan_get_newline(scanner);\n}", "target": 1}
{"code": "  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }", "target": 1}
{"code": "kg_seal_iov(OM_uint32 *minor_status,\n            gss_ctx_id_t context_handle,\n            int conf_req_flag,\n            gss_qop_t qop_req,\n            int *conf_state,\n            gss_iov_buffer_desc *iov,\n            int iov_count,\n            int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32)G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (conf_req_flag && kg_integ_only_iov(iov, iov_count)) {\n        conf_req_flag = FALSE;\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto) {\n    case 0:\n        code = make_seal_token_v1_iov(context, ctx, conf_req_flag,\n                                      conf_state, iov, iov_count, toktype);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3_iov(context, ctx, conf_req_flag,\n                                                  conf_state, iov, iov_count, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;\n        break;\n    }\n    if (code != 0) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return GSS_S_FAILURE;\n    }\n    *minor_status = 0;\n    return GSS_S_COMPLETE;\n}", "target": 1}
{"code": "int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options *opt;\n\topt = inet_sk(sk)->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn -ENOMSG;\n\treturn cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),\n\t\t\t\tsecattr);\n}", "target": 1}
{"code": "static inline bool is_nmi(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);\n}", "target": 0}
{"code": "int rpc_type_of_NPNVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPNVjavascriptEnabledBool:\n  case NPNVasdEnabledBool:\n  case NPNVisOfflineBool:\n  case NPNVSupportsXEmbedBool:\n  case NPNVSupportsWindowless:\n  case NPNVprivateModeBool:\n  case NPNVsupportsAdvancedKeyHandling:\n\ttype = RPC_TYPE_BOOLEAN;\n\tbreak;\n  case NPNVToolkit:\n  case NPNVnetscapeWindow:\n\ttype = RPC_TYPE_UINT32;\n\tbreak;\n  case NPNVWindowNPObject:\n  case NPNVPluginElementNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}", "target": 0}
{"code": "TfLiteStatus ScatterNd(const TfLiteTensor* indices, const TfLiteTensor* updates,\n                       TfLiteTensor* output) {\n  reference_ops::ScatterNd(\n      GetTensorShape(indices), GetTensorData<IndicesT>(indices),\n      GetTensorShape(updates), GetTensorData<UpdatesT>(updates),\n      GetTensorShape(output), GetTensorData<UpdatesT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct pfkey_sock *pfk = pfkey_sk(sk);\n\tstruct sk_buff *supp_skb;\n\tif (hdr->sadb_msg_satype > SADB_SATYPE_MAX)\n\t\treturn -EINVAL;\n\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) {\n\t\tif (pfk->registered&(1<<hdr->sadb_msg_satype))\n\t\t\treturn -EEXIST;\n\t\tpfk->registered |= (1<<hdr->sadb_msg_satype);\n\t}\n\tmutex_lock(&pfkey_mutex);\n\txfrm_probe_algs();\n\tsupp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO);\n\tmutex_unlock(&pfkey_mutex);\n\tif (!supp_skb) {\n\t\tif (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC)\n\t\t\tpfk->registered &= ~(1<<hdr->sadb_msg_satype);\n\t\treturn -ENOBUFS;\n\t}\n\tpfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,\n\t\t\tsock_net(sk));\n\treturn 0;\n}", "target": 0}
{"code": "libarchive_set_archive_type (EvArchive *archive,\n\t\t\t     EvArchiveType archive_type)\n{\n\tarchive->type = archive_type;\n\tarchive->libar = archive_read_new ();\n\tif (archive_type == EV_ARCHIVE_TYPE_ZIP)\n\t\tarchive_read_support_format_zip (archive->libar);\n\telse if (archive_type == EV_ARCHIVE_TYPE_7Z)\n\t\tarchive_read_support_format_7zip (archive->libar);\n\telse if (archive_type == EV_ARCHIVE_TYPE_TAR)\n\t\tarchive_read_support_format_tar (archive->libar);\n\telse if (archive_type == EV_ARCHIVE_TYPE_RAR) {\n\t\tarchive_read_support_format_rar (archive->libar);\n\t\tarchive_read_support_format_rar5 (archive->libar);\n\t} else\n\t\tg_assert_not_reached ();\n}", "target": 0}
{"code": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\tif (nla_len(rp) < ulen ||\n\t    xfrm_replay_state_esn_len(replay_esn) != ulen ||\n\t    replay_esn->bmp_len != up->bmp_len)\n\t\treturn -EINVAL;\n\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "static inline int pfkey_mode_to_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase IPSEC_MODE_ANY:\t\n\tcase IPSEC_MODE_TRANSPORT:\n\t\treturn XFRM_MODE_TRANSPORT;\n\tcase IPSEC_MODE_TUNNEL:\n\t\treturn XFRM_MODE_TUNNEL;\n\tcase IPSEC_MODE_BEET:\n\t\treturn XFRM_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}", "target": 0}
{"code": "static int fsmOpenat(int dirfd, const char *path, int flags)\n{\n    struct stat lsb, sb;\n    int sflags = flags | O_NOFOLLOW;\n    int fd = openat(dirfd, path, sflags);\n    if (fd < 0 && errno == ELOOP && flags != sflags) {\n\tint ffd = openat(dirfd, path, flags);\n\tif (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {\n\t    if (fstat(ffd, &sb) == 0) {\n\t\tif (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {\n\t\t    fd = ffd;\n\t\t} else {\n\t\t    close(ffd);\n\t\t}\n\t    }\n\t}\n    }\n    return fd;\n}", "target": 0}
{"code": "  TfLiteStatus status() const { return status_; }", "target": 0}
{"code": "u16 inverse_translate(struct vc_data *conp, int glyph, int use_unicode)\n{\n\tstruct uni_pagedir *p;\n\tint m;\n\tif (glyph < 0 || glyph >= MAX_GLYPH)\n\t\treturn 0;\n\telse {\n\t\tp = *conp->vc_uni_pagedir_loc;\n\t\tif (!p)\n\t\t\treturn glyph;\n\t\telse if (use_unicode) {\n\t\t\tif (!p->inverse_trans_unicode)\n\t\t\t\treturn glyph;\n\t\t\telse\n\t\t\t\treturn p->inverse_trans_unicode[glyph];\n\t\t\t} else {\n\t\t\tm = inv_translate[conp->vc_num];\n\t\t\tif (!p->inverse_translations[m])\n\t\t\t\treturn glyph;\n\t\t\telse\n\t\t\t\treturn p->inverse_translations[m][glyph];\n\t\t\t}\n\t}\n}", "target": 0}
{"code": "bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid) &&\n\t\tkgid_has_mapping(ns, inode->i_gid);\n}", "target": 0}
{"code": "snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static int dr_domain_init_resources(struct mlx5dr_domain *dmn)\n{\n\tint ret;\n\tdmn->ste_ctx = mlx5dr_ste_get_ctx(dmn->info.caps.sw_format_ver);\n\tif (!dmn->ste_ctx) {\n\t\tmlx5dr_err(dmn, \"SW Steering on this device is unsupported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tret = mlx5_core_alloc_pd(dmn->mdev, &dmn->pdn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate PD, ret: %d\", ret);\n\t\treturn ret;\n\t}\n\tdmn->uar = mlx5_get_uars_page(dmn->mdev);\n\tif (!dmn->uar) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate UAR\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_pd;\n\t}\n\tdmn->ste_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_STE);\n\tif (!dmn->ste_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_uar;\n\t}\n\tdmn->action_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_MODIFY_ACTION);\n\tif (!dmn->action_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get action icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_ste_icm_pool;\n\t}\n\tret = mlx5dr_send_ring_alloc(dmn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't create send-ring\\n\");\n\t\tgoto free_action_icm_pool;\n\t}\n\treturn 0;\nfree_action_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->action_icm_pool);\nfree_ste_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->ste_icm_pool);\nclean_uar:\n\tmlx5_put_uars_page(dmn->mdev, dmn->uar);\nclean_pd:\n\tmlx5_core_dealloc_pd(dmn->mdev, dmn->pdn);\n\treturn ret;\n}", "target": 1}
{"code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\tif (line == NULL)\n\t\t\treturn;\n\t\tfilter_data(fs->id, line);\n\t\tgoto nextline;\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static void _sched_arq_timeout(gnrc_sixlowpan_frag_fb_t *fbuf, uint32_t offset)\n{\n    if (IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_MOCK_ARQ_TIMER)) {\n        return;\n    }\n    if (fbuf->sfr.arq_timeout_event.msg.content.ptr != NULL) {\n        DEBUG(\"6lo sfr: ARQ timeout for datagram %u already scheduled\\n\",\n              (uint8_t)fbuf->tag);\n        return;\n    }\n    DEBUG(\"6lo sfr: arming ACK timeout in %lums for datagram %u\\n\",\n          (long unsigned)offset, fbuf->tag);\n    fbuf->sfr.arq_timeout_event.event.offset = offset;\n    fbuf->sfr.arq_timeout_event.msg.content.ptr = fbuf;\n    fbuf->sfr.arq_timeout_event.msg.type = GNRC_SIXLOWPAN_FRAG_SFR_ARQ_TIMEOUT_MSG;\n    evtimer_add_msg(&_arq_timer, &fbuf->sfr.arq_timeout_event,\n                    _getpid());\n}", "target": 1}
{"code": "static int ext4_statfs_project(struct super_block *sb,\n\t\t\t       kprojid_t projid, struct kstatfs *buf)\n{\n\tstruct kqid qid;\n\tstruct dquot *dquot;\n\tu64 limit;\n\tu64 curblock;\n\tqid = make_kqid_projid(projid);\n\tdquot = dqget(sb, qid);\n\tif (IS_ERR(dquot))\n\t\treturn PTR_ERR(dquot);\n\tspin_lock(&dquot->dq_dqb_lock);\n\tlimit = (dquot->dq_dqb.dqb_bsoftlimit ?\n\t\t dquot->dq_dqb.dqb_bsoftlimit :\n\t\t dquot->dq_dqb.dqb_bhardlimit) >> sb->s_blocksize_bits;\n\tif (limit && buf->f_blocks > limit) {\n\t\tcurblock = dquot->dq_dqb.dqb_curspace >> sb->s_blocksize_bits;\n\t\tbuf->f_blocks = limit;\n\t\tbuf->f_bfree = buf->f_bavail =\n\t\t\t(buf->f_blocks > curblock) ?\n\t\t\t (buf->f_blocks - curblock) : 0;\n\t}\n\tlimit = dquot->dq_dqb.dqb_isoftlimit ?\n\t\tdquot->dq_dqb.dqb_isoftlimit :\n\t\tdquot->dq_dqb.dqb_ihardlimit;\n\tif (limit && buf->f_files > limit) {\n\t\tbuf->f_files = limit;\n\t\tbuf->f_ffree =\n\t\t\t(buf->f_files > dquot->dq_dqb.dqb_curinodes) ?\n\t\t\t (buf->f_files - dquot->dq_dqb.dqb_curinodes) : 0;\n\t}\n\tspin_unlock(&dquot->dq_dqb_lock);\n\tdqput(dquot);\n\treturn 0;\n}", "target": 0}
{"code": "static int adpt_reset(struct scsi_cmnd* cmd)\n{\n\tint rc;\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __adpt_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\treturn rc;\n}", "target": 1}
{"code": "void builtinFetchurl(const BasicDerivation & drv)\n{\n    auto url = drv.env.find(\"url\");\n    if (url == drv.env.end()) throw Error(\"attribute url missing\");\n    printMsg(lvlInfo, format(\"downloading %1%...\") % url->second);\n    auto data = downloadFile(url->second); \n    auto out = drv.env.find(\"out\");\n    if (out == drv.env.end()) throw Error(\"attribute url missing\");\n    writeFile(out->second, data.data);\n    auto executable = drv.env.find(\"executable\");\n    if (executable != drv.env.end() && executable->second == \"1\") {\n        if (chmod(out->second.c_str(), 0755) == -1)\n            throw SysError(format(\"making %1% executable\") % out->second);\n    }\n}", "target": 1}
{"code": "static int sr_write_reg(struct usbnet *dev, u8 reg, u8 value)\n{\n\treturn usbnet_write_cmd(dev, SR_WR_REGS, SR_REQ_WR_REG,\n\t\t\t\tvalue, reg, NULL, 0);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto value = ctx->input(0);\n    OP_REQUIRES(ctx, value.dims() >= 1,\n                errors::InvalidArgument(\"value should be at least rank 1.\"));\n    OP_REQUIRES(\n        ctx, value.dim_size(0) > loc_,\n        errors::InvalidArgument(\"0th dimension of value = \", value.dim_size(0),\n                                \" must be greater than loc_ = \", loc_));\n    auto update = ctx->input(1);\n    OP_REQUIRES(\n        ctx, value.dims() == update.dims(),\n        errors::InvalidArgument(\"value and update shape doesn't match: \",\n                                value.shape().DebugString(), \" vs. \",\n                                update.shape().DebugString()));\n    for (int i = 1; i < value.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, value.dim_size(i) == update.dim_size(i),\n          errors::InvalidArgument(\"value and update shape doesn't match \",\n                                  value.shape().DebugString(), \" vs. \",\n                                  update.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, 1 == update.dim_size(0),\n                errors::InvalidArgument(\"update shape doesn't match: \",\n                                        update.shape().DebugString()));\n    Tensor output = value;  \n    const auto& d = ctx->eigen_device<Device>();\n    OP_REQUIRES_OK(\n        ctx, ::tensorflow::functor::DoParallelConcat(d, update, loc_, &output));\n    ctx->set_output(0, output);\n  }", "target": 0}
{"code": "static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newbufsize;\n\tlong newpos;\n\tassert(buf);\n\tassert(cnt >= 0);\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\tnewbufsize <<= 1;\n\t\t\tassert(newbufsize >= 0);\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %z\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %ul\\n\", m->bufsize_,\n\t\t  JAS_CAST(unsigned long, newbufsize)));\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_tensor = context->input(0);\n    const auto input_tensor_flat = input_tensor.flat<int32>();\n    const Tensor& input_splits = context->input(1);\n    const auto input_splits_flat = input_splits.flat<SPLITS_TYPE>();\n    OP_REQUIRES(\n        context, input_splits.NumElements() > 0,\n        errors::InvalidArgument(\"Input_splits should contain elements, but \"\n                                \"given input_values has 0 elements\"));\n    OP_REQUIRES(\n        context, input_splits_flat(0) == 0,\n        errors::InvalidArgument(\"First value in input_splits must be zero.\"));\n    OP_REQUIRES(context,\n                input_splits_flat(input_splits_flat.size() - 1) ==\n                    input_tensor_flat.size(),\n                errors::InvalidArgument(\"Last value in input_splits must be \"\n                                        \"equal to length of input_tensor.\"));\n    TensorShape output_shape({input_splits.dim_size(0) - 1});\n    Tensor* output_tensor;\n    OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                     &output_tensor));\n    auto output_tensor_flat = output_tensor->flat<tstring>();\n    int idx = 0;\n    for (int i = 1; i < input_splits_flat.size(); ++i) {\n      icu::UnicodeString unicode_string;\n      icu::UnicodeStringAppendable appendable_unicode_string(unicode_string);\n      OP_REQUIRES(\n          context, input_splits_flat(i - 1) <= input_splits_flat(i),\n          errors::InvalidArgument(\n              \"Values in input_splits must be equal or in ascending order.\"));\n      OP_REQUIRES(\n          context, input_splits_flat(i) <= input_tensor_flat.size(),\n          errors::InvalidArgument(\"Values in input_splits must be less than or \"\n                                  \"equal to input_tensor length.\"));\n      for (; idx < input_splits_flat(i); ++idx) {\n        int32_t code_point = input_tensor_flat(idx);\n        if (!U_IS_UNICODE_CHAR(code_point)) {\n          if (error_options_.error_on_malformatting) {\n            context->CtxFailure(errors::InvalidArgument(\n                \"Code point is out of range for Unicode, or a noncharacter.\"));\n            return;\n          } else if (!error_options_.elide_replacement) {\n            code_point = error_options_.subst;\n          }\n        }\n        appendable_unicode_string.appendCodePoint(code_point);\n      }\n      tstring result;\n      Encode(encoding_, unicode_string, &result);\n      output_tensor_flat(i - 1) = std::move(result);\n    }\n  }", "target": 0}
{"code": "static void on_underlying_io_bytes_received(void* context, const unsigned char* buffer, size_t size)\n{\n    if (context != NULL)\n    {\n        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)context;\n        unsigned char* new_socket_io_read_bytes = (unsigned char*)realloc(tls_io_instance->socket_io_read_bytes, tls_io_instance->socket_io_read_byte_count + size);\n        if (new_socket_io_read_bytes == NULL)\n        {\n            LogError(\"Failed allocating memory for received bytes\");\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else\n        {\n            tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;\n            (void)memcpy(tls_io_instance->socket_io_read_bytes + tls_io_instance->socket_io_read_byte_count, buffer, size);\n            tls_io_instance->socket_io_read_byte_count += size;\n        }\n    }\n    else\n    {\n        LogInfo(\"Supplied context is NULL on bytes_received\");\n    }\n}", "target": 1}
{"code": "\tEventReturn OnPreCommand(CommandSource &source, Command *command, std::vector<Anope::string> &params) anope_override\n\t{\n\t\tif (command->name == \"nickserv/confirm\" && params.size() > 1)\n\t\t{\n\t\t\tif (Anope::ReadOnly)\n\t\t\t{\n\t\t\t\tsource.Reply(READ_ONLY_MODE);\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t\tNickAlias *na = NickAlias::Find(params[0]);\n\t\t\tResetInfo *ri = na ? reset.Get(na->nc) : NULL;\n\t\t\tif (na && ri)\n\t\t\t{\n\t\t\t\tNickCore *nc = na->nc;\n\t\t\t\tif (nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\t\t{\n\t\t\t\t\tsource.Reply(NICK_X_SUSPENDED, nc->display.c_str());\n\t\t\t\t\treturn EVENT_STOP;\n\t\t\t\t}\n\t\t\t\tconst Anope::string &passcode = params[1];\n\t\t\t\tif (ri->time < Anope::CurTime - 3600)\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tsource.Reply(_(\"Your password reset request has expired.\"));\n\t\t\t\t}\n\t\t\t\telse if (passcode.equals_cs(ri->code))\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tnc->Shrink<bool>(\"UNCONFIRMED\");\n\t\t\t\t\tLog(LOG_COMMAND, source, &commandnsresetpass) << \"to confirm RESETPASS and forcefully identify as \" << na->nick;\n\t\t\t\t\tif (source.GetUser())\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.GetUser()->Identify(na);\n\t\t\t\t\t}\n\t\t\t\t\tsource.Reply(_(\"You are now identified for your nick. Change your password now.\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn EVENT_CONTINUE;\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t}\n\t\treturn EVENT_CONTINUE;\n\t}", "target": 0}
{"code": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "bool QODBCResult::prepare(const QString& query)\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    SQLRETURN r;\n    d->rInf.clear();\n    if (d->hStmt && d->isStmtHandleValid()) {\n        r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCResult::prepare: Unable to close statement\"_L1, d);\n            return false;\n        }\n    }\n    r  = SQLAllocHandle(SQL_HANDLE_STMT,\n                         d->dpDbc(),\n                         &d->hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCResult::prepare: Unable to allocate statement handle\"_L1, d);\n        return false;\n    }\n    d->updateStmtHandleState();\n    if (isForwardOnly()) {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                            SQL_IS_UINTEGER);\n    } else {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_STATIC,\n                            SQL_IS_UINTEGER);\n    }\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n            \"QODBCResult::reset: Unable to set 'SQL_CURSOR_STATIC' as statement attribute. \"\n            \"Please check your ODBC driver configuration\"), QSqlError::StatementError, d));\n        return false;\n    }\n    r = SQLPrepare(d->hStmt,\n                    toSQLTCHAR(query).data(),\n                    (SQLINTEGER) query.length());\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to prepare statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "ParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}", "target": 1}
{"code": "static int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}", "target": 0}
{"code": "static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *\n        p_code_block)\n{\n    if (! p_code_block->data) {\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE);\n        if (! p_code_block->data) {\n            return OPJ_FALSE;\n        }\n        p_code_block->data_max_size = OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE;\n        p_code_block->segs = (opj_tcd_seg_t *) opj_calloc(OPJ_J2K_DEFAULT_NB_SEGS,\n                             sizeof(opj_tcd_seg_t));\n        if (! p_code_block->segs) {\n            return OPJ_FALSE;\n        }\n        p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;\n    } else {\n        OPJ_BYTE* l_data = p_code_block->data;\n        OPJ_UINT32 l_data_max_size = p_code_block->data_max_size;\n        opj_tcd_seg_t * l_segs = p_code_block->segs;\n        OPJ_UINT32 l_current_max_segs = p_code_block->m_current_max_segs;\n        memset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t));\n        p_code_block->data = l_data;\n        p_code_block->data_max_size = l_data_max_size;\n        p_code_block->segs = l_segs;\n        p_code_block->m_current_max_segs = l_current_max_segs;\n    }\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "MODULE_ENTRY (fill_info) (GdkPixbufFormat *info)\n{\n\tstatic const GdkPixbufModulePattern signature[] = {\n\t\t{ \"  \\x1   \", \"zz znz\", 100 }, \n\t\t{ \"  \\x2   \", \"zz znz\", 100 },\n\t\t{ NULL, NULL, 0 }\n\t};\n\tstatic const gchar *mime_types[] = {\n\t\t\"image/x-icon\",\n\t\t\"image/x-ico\",\n\t\t\"image/x-win-bitmap\",\n                \"image/vnd.microsoft.icon\",\n                \"application/ico\",\n                \"image/ico\",\n                \"image/icon\",\n                \"text/ico\",\n\t\tNULL\n\t};\n\tstatic const gchar *extensions[] = {\n\t\t\"ico\",\n\t\t\"cur\",\n\t\tNULL\n\t};\n\tinfo->name = \"ico\";\n\tinfo->signature = (GdkPixbufModulePattern *) signature;\n\tinfo->description = NC_(\"image format\", \"Windows icon\");\n\tinfo->mime_types = (gchar **) mime_types;\n\tinfo->extensions = (gchar **) extensions;\n\tinfo->flags = GDK_PIXBUF_FORMAT_WRITABLE | GDK_PIXBUF_FORMAT_THREADSAFE;\n\tinfo->license = \"LGPL\";\n}", "target": 0}
{"code": "is_note (Elf_Internal_Phdr *p, asection *s)\n{\n  return (p->p_type == PT_NOTE\n\t  && elf_section_type (s) == SHT_NOTE\n\t  && (ufile_ptr) s->filepos >= p->p_offset\n\t  && p->p_filesz >= s->size\n\t  && ((ufile_ptr) s->filepos - p->p_offset\n\t      <= p->p_filesz - s->size));\n}", "target": 0}
{"code": "   Clears flags on messages */\nPHP_FUNCTION(imap_clearflag_full)\n{\n\tzval *streamind;\n\tzend_string *sequence, *flag;\n\tzend_long flags = 0;\n\tpils *imap_le_struct;\n\tint argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc, \"rSS|l\", &streamind, &sequence, &flag, &flags) ==FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tmail_clearflag_full(imap_le_struct->imap_stream, ZSTR_VAL(sequence), ZSTR_VAL(flag), (argc == 4 ? flags : NIL));\n\tRETURN_TRUE;", "target": 0}
{"code": "static inline ut64 dwarf_read_address(size_t size, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\t\tcase 2:\n\t\tresult = READ16 (*buf); break;\n\t\tcase 4:\n\t\tresult = READ32 (*buf); break;\n\t\tcase 8:\n\t\tresult = READ64 (*buf); break;\n\t\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf (\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "findoprnd(ITEM *ptr, int32 *pos)\n{\n\tcheck_stack_depth();\n\tif (ptr[*pos].type == VAL || ptr[*pos].type == VALTRUE)\n\t{\n\t\tptr[*pos].left = 0;\n\t\t(*pos)++;\n\t}\n\telse if (ptr[*pos].val == (int32) '!')\n\t{\n\t\tptr[*pos].left = 1;\n\t\t(*pos)++;\n\t\tfindoprnd(ptr, pos);\n\t}\n\telse\n\t{\n\t\tITEM\t   *curitem = &ptr[*pos];\n\t\tint32\t\ttmp = *pos;\n\t\t(*pos)++;\n\t\tfindoprnd(ptr, pos);\n\t\tcuritem->left = *pos - tmp;\n\t\tfindoprnd(ptr, pos);\n\t}\n}", "target": 0}
{"code": "void Filter::onUpstreamEvent(Network::ConnectionEvent event) {\n  bool connecting = connecting_;\n  connecting_ = false;\n  if (event == Network::ConnectionEvent::RemoteClose ||\n      event == Network::ConnectionEvent::LocalClose) {\n    upstream_.reset();\n    disableIdleTimer();\n    if (connecting) {\n      if (event == Network::ConnectionEvent::RemoteClose) {\n        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);\n        read_callbacks_->upstreamHost()->outlierDetector().putResult(\n            Upstream::Outlier::Result::LocalOriginConnectFailed);\n      }\n      initializeUpstreamConnection();\n    } else {\n      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {\n        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);\n      }\n    }\n  }\n}", "target": 1}
{"code": "static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XSAVES\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XSAVE\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "static bool is_subdir(const char *subdir, const char *dir, size_t len)\n{\n\tsize_t subdirlen = strlen(subdir);\n\tif (subdirlen < len)\n\t\treturn false;\n\tif (strncmp(subdir, dir, len) != 0)\n\t\treturn false;\n\tif (dir[len-1] == '/')\n\t\treturn true;\n\tif (subdir[len] == '/' || subdirlen == len)\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "void SSH2_update_kex_myproposal(PTInstVar pvar)\n{\n\tstatic char buf[512]; \n\tint index;\n\tint i;\n\tif (pvar->socket != INVALID_SOCKET) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c\");\n\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c\") == 0) {\n\t\t\t\tmyproposal[PROPOSAL_KEX_ALGS][pos] = '\\0';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tbuf[0] = '\\0';\n\tfor (i = 0 ; pvar->settings.KexOrder[i] != 0 ; i++) {\n\t\tindex = pvar->settings.KexOrder[i] - '0';\n\t\tif (index == KEX_DH_NONE) \n\t\t\tbreak;\n\t\tstrncat_s(buf, sizeof(buf), get_kex_algorithm_name(index), _TRUNCATE);\n\t\tstrncat_s(buf, sizeof(buf), \",\", _TRUNCATE);\n\t}\n\tstrncat_s(buf, sizeof(buf), \"ext-info-c\", _TRUNCATE);\n\tmyproposal[PROPOSAL_KEX_ALGS] = buf; \n}", "target": 1}
{"code": "static void ptrace_unfreeze_traced(struct task_struct *task)\n{\n\tif (task->state != __TASK_TRACED)\n\t\treturn;\n\tWARN_ON(!task->ptrace || task->parent != current);\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (__fatal_signal_pending(task))\n\t\twake_up_state(task, __TASK_TRACED);\n\telse\n\t\ttask->state = TASK_TRACED;\n\tspin_unlock_irq(&task->sighand->siglock);\n}", "target": 0}
{"code": "chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& weights = context->input(1);\n    bool use_weights = weights.NumElements() > 0;\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(data.shape()) ||\n                    TensorShapeUtils::IsMatrix(data.shape()),\n                errors::InvalidArgument(\n                    \"Input must be a 1 or 2-dimensional tensor. Got: \",\n                    data.shape().DebugString()));\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == data.shape(),\n          errors::InvalidArgument(\n              \"Weights and data must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; data shape: \", data.shape().DebugString()));\n    }\n    bool is_1d = TensorShapeUtils::IsVector(data.shape());\n    int negative_valued_axis = -1;\n    int num_batch_dimensions = (data.shape().dims() + negative_valued_axis);\n    int num_batch_elements = 1;\n    for (int i = 0; i < num_batch_dimensions; ++i) {\n      OP_REQUIRES(context, data.shape().dim_size(i) != 0,\n                  errors::InvalidArgument(\n                      \"Invalid input: Shapes dimension cannot be 0.\"));\n      num_batch_elements *= data.shape().dim_size(i);\n    }\n    int num_value_elements = data.shape().num_elements() / num_batch_elements;\n    auto per_batch_counts = BatchedMap<W>(num_batch_elements);\n    T max_value = 0;\n    const auto data_values = data.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int i = 0;\n    for (int b = 0; b < num_batch_elements; ++b) {\n      for (int v = 0; v < num_value_elements; ++v) {\n        const auto& value = data_values(i);\n        if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n          if (binary_output_) {\n            per_batch_counts[b][value] = 1;\n          } else if (use_weights) {\n            per_batch_counts[b][value] += weight_values(i);\n          } else {\n            per_batch_counts[b][value]++;\n          }\n          if (value > max_value) {\n            max_value = value;\n          }\n        }\n        ++i;\n      }\n    }\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }", "target": 0}
{"code": "\t__releases(rcu_bh)\n{\n\trcu_read_unlock_bh();\n}", "target": 0}
{"code": "spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}", "target": 1}
{"code": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}", "target": 0}
{"code": "  Value GetValueOrCreatePlaceholder(StringRef full_name) {\n    StringRef node_name;\n    StringRef output_name = \"\";\n    bool is_control_dep = full_name[0] == '^';\n    int output_num = 0;\n    if (is_control_dep) full_name = full_name.drop_front();\n    {\n      size_t colon_sep = full_name.find_first_of(':');\n      if (colon_sep == StringRef::npos) {\n        node_name = full_name;\n      } else {\n        node_name = full_name.take_front(colon_sep);\n        output_name = full_name.drop_front(colon_sep + 1);\n      }\n      colon_sep = output_name.find_last_of(':');\n      if (colon_sep != StringRef::npos) {\n        unsigned long long value;\n        if (!llvm::getAsUnsignedInteger(output_name.drop_front(colon_sep + 1),\n                                        10, value))\n          output_num = value;\n        output_name = output_name.take_front(colon_sep);\n      }\n    }\n    llvm::StringMap<SmallVector<Value, 1>>& op_info = values_map_[node_name];\n    SmallVector<Value, 1>& base_operation = op_info[\"^\"];\n    if (base_operation.empty()) {\n      OperationState state(loc_, mlir_placeholder_);\n      state.addAttribute(TFGraphDialect::getNameAttrKey(),\n                         builder_.getStringAttr(node_name));\n      state.types.push_back(placeholder_ty_);\n      state.types.push_back(control_ty_);\n      Operation* placeholder = builder_.create(state);\n      base_operation.push_back(placeholder->getResult(1));\n      base_operation.push_back(placeholder->getResult(0));\n    }\n    if (is_control_dep) return base_operation[0];\n    SmallVector<Value, 1>& value_info = op_info[output_name];\n    if (value_info.size() <= output_num)\n      value_info.resize(output_num + 1, Value{});\n    if (!value_info[output_num]) {\n      value_info[output_num] = builder_.create<GetResultOp>(\n          loc_, base_operation[1], output_name, output_num);\n    }\n    return value_info[output_num];\n  }", "target": 1}
{"code": "static int adpt_hba_reset(adpt_hba* pHba)\n{\n\tint rcode;\n\tpHba->state |= DPTI_STATE_RESET;\n\tif ((rcode=adpt_i2o_activate_hba(pHba)) < 0) {\n\t\tprintk(KERN_ERR \"%s: Could not activate\\n\", pHba->name);\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tif ((rcode=adpt_i2o_build_sys_table()) < 0) {\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tPDEBUG(\"%s: in HOLD state\\n\",pHba->name);\n\tif ((rcode=adpt_i2o_online_hba(pHba)) < 0) {\n\t\tadpt_i2o_delete_hba(pHba);\t\n\t\treturn rcode;\n\t}\n\tPDEBUG(\"%s: in OPERATIONAL state\\n\",pHba->name);\n\tif ((rcode=adpt_i2o_lct_get(pHba)) < 0){\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tpHba->state &= ~DPTI_STATE_RESET;\n\tscsi_host_complete_all_commands(pHba->host, DID_RESET);\n\treturn 0;\t\n}", "target": 1}
{"code": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}", "target": 1}
{"code": "ff_layout_choose_valid_ds_for_read(struct pnfs_layout_segment *lseg,\n\t\t\t\t   u32 start_idx, u32 *best_idx)\n{\n\treturn ff_layout_choose_ds_for_read(lseg, start_idx, best_idx, true);\n}", "target": 0}
{"code": "void cql_server::response::serialize(const event::schema_change& event, uint8_t version)\n{\n    if (version >= 3) {\n        write_string(to_string(event.change));\n        write_string(to_string(event.target));\n        write_string(event.keyspace);\n        switch (event.target) {\n        case event::schema_change::target_type::KEYSPACE:\n            break;\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::TABLE:\n            write_string(event.arguments[0]);\n            break;\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(event.arguments[0]);\n            write_string_list(std::vector<sstring>(event.arguments.begin() + 1, event.arguments.end()));\n            break;\n        }\n    } else {\n        switch (event.target) {\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(to_string(event::schema_change::change_type::UPDATED));\n            write_string(event.keyspace);\n            write_string(\"\");\n            break;\n        case event::schema_change::target_type::TABLE:\n        case event::schema_change::target_type::KEYSPACE:\n            write_string(to_string(event.change));\n            write_string(event.keyspace);\n            if (event.target == event::schema_change::target_type::TABLE) {\n                write_string(event.arguments[0]);\n            } else {\n                write_string(\"\");\n            }\n        }\n    }\n}", "target": 0}
{"code": "struct net *get_net_ns_by_id(struct net *net, int id)\n{\n\tstruct net *peer;\n\tif (id < 0)\n\t\treturn NULL;\n\trcu_read_lock();\n\tspin_lock_bh(&net->nsid_lock);\n\tpeer = idr_find(&net->netns_ids, id);\n\tif (peer)\n\t\tget_net(peer);\n\tspin_unlock_bh(&net->nsid_lock);\n\trcu_read_unlock();\n\treturn peer;\n}", "target": 1}
{"code": "setkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal((void *)handle, arg->princ,\n                                          arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n\tstruct inode *inode = io->inode;\n\tint ret = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret >= 0) {\n\t\tif (!list_empty(&io->list))\n\t\t\tlist_del_init(&io->list);\n\t\text4_free_io_end(io);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n}", "target": 1}
{"code": "void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {\n  auto* entry = getExistingInline(key.getStringView());\n  if (entry != nullptr) {\n    appendToHeader(entry->value(), value.getStringView());\n    key.clear();\n    value.clear();\n  } else {\n    insertByKey(std::move(key), std::move(value));\n  }\n}", "target": 1}
{"code": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}", "target": 1}
{"code": "int key_default_cmp(const struct key *key,\n\t\t    const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}", "target": 0}
{"code": "pixBlockconv(PIX     *pix,\n             l_int32  wc,\n             l_int32  hc)\n{\nl_int32  w, h, d;\nPIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\n    PROCNAME(\"pixBlockconv\");\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pix);\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\"pix has colormap; removing\\n\", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32 bpp\", procName, NULL);\n    }\n    if (d == 8) {\n        pixd = pixBlockconvGray(pixs, NULL, wc, hc);\n    } else { \n        pixr = pixGetRGBComponent(pixs, COLOR_RED);\n        pixrc = pixBlockconvGray(pixr, NULL, wc, hc);\n        pixDestroy(&pixr);\n        pixg = pixGetRGBComponent(pixs, COLOR_GREEN);\n        pixgc = pixBlockconvGray(pixg, NULL, wc, hc);\n        pixDestroy(&pixg);\n        pixb = pixGetRGBComponent(pixs, COLOR_BLUE);\n        pixbc = pixBlockconvGray(pixb, NULL, wc, hc);\n        pixDestroy(&pixb);\n        pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);\n        pixDestroy(&pixrc);\n        pixDestroy(&pixgc);\n        pixDestroy(&pixbc);\n    }\n    pixDestroy(&pixs);\n    return pixd;\n}", "target": 1}
{"code": "static int acurite_leak_detector_decode(r_device* decoder, uint8_t* bb)\n{\n    int parity = parity_bytes(&bb[2], 4);\n    if (parity) {\n        decoder_log_bitrow(decoder, 1, __func__, bb, 7 * 8, \"bad parity\");\n        return DECODE_FAIL_MIC;\n    }\n    char const* channel_str = acurite_getChannel(bb[0]);\n    if (*channel_str == 'E') {\n        decoder_logf(decoder, 1, __func__, \"Acurite TXR sensor : bad channel Ch %s\", channel_str);\n        return DECODE_FAIL_SANITY;\n    }\n    int sensor_id = ((bb[0] & 0x3f) << 8) | bb[1];\n    int battery_low = (bb[2] & 0x40) == 0;\n    int is_wet = (bb[3] & 0x10) >> 4;\n    data_t* data;\n    data = data_make(\n            \"model\",                \"\",             DATA_STRING, \"Acurite-Leak\",\n            \"id\",                   \"\",             DATA_INT,    sensor_id,\n            \"channel\",              NULL,           DATA_STRING, channel_str,\n            \"battery_ok\",           \"Battery\",      DATA_INT,    !battery_low,\n            \"leak_detected\",        \"Leak\",         DATA_INT,    is_wet,\n            \"mic\",                  \"Integrity\",    DATA_STRING, \"CHECKSUM\",\n            NULL);\n    decoder_output_data(decoder, data);\n    return 1;\n}", "target": 0}
{"code": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs, uid_t uid, gid_t gid)\n{\n    FILE *fp = fopen(dest_filename, \"wx\");\n    if (!fp)\n        return false;\n    unsigned fd = 0;\n    while (fd <= 99999) \n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    const int dest_fd = fileno(fp);\n    if (fchown(dest_fd, uid, gid) < 0)\n    {\n        perror_msg(\"Can't change '%s' ownership to %lu:%lu\", dest_filename, (long)uid, (long)gid);\n        fclose(fp);\n        unlink(dest_filename);\n        return false;\n    }\n    fclose(fp);\n    return true;\n}", "target": 0}
{"code": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\treturn opt;\n}", "target": 1}
{"code": "MagickExport void *AcquireQuantumMemory(const size_t count,const size_t quantum)\n{\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  extent=count*quantum;\n  return(AcquireMagickMemory(extent));\n}", "target": 1}
{"code": "void smp_enc_cmpl(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t enc_enable = p_data->status;\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  tSMP_INT_DATA smp_int_data;\n  smp_int_data.status = enc_enable ? SMP_SUCCESS : SMP_ENC_FAIL;\n  smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n}", "target": 0}
{"code": "void AuthChecker::PassUserInfoOnSuccess() {\n  char *json_buf = auth::WriteUserInfoToJson(user_info_);\n  if (json_buf == nullptr) {\n    return;\n  }\n  char *base64_json_buf = auth::esp_base64_encode(\n      json_buf, strlen(json_buf), true, false, true );\n  context_->request()->AddHeaderToBackend(auth::kEndpointApiUserInfo,\n                                          base64_json_buf);\n  auth::esp_grpc_free(json_buf);\n  auth::esp_grpc_free(base64_json_buf);\n  TRACE(trace_span_) << \"Authenticated.\";\n  trace_span_.reset();\n  on_done_(Status::OK);\n}", "target": 1}
{"code": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\tif (too_many_unix_fds(current))\n\t\treturn -ETOOMANYREFS;\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\tunix_inflight(scm->fp->user, scm->fp->fp[i]);\n\treturn max_level;\n}", "target": 0}
{"code": "child_setup_func (gpointer user_data)\n{\n  ChildSetupData *data = (ChildSetupData *) user_data;\n  FdMapEntry *fd_map = data->fd_map;\n  sigset_t set;\n  int i;\n  flatpak_close_fds_workaround (3);\n  if (data->instance_id_fd != -1)\n    drop_cloexec (data->instance_id_fd);\n  if (data->env_fd != -1)\n    drop_cloexec (data->env_fd);\n  sigemptyset (&set);\n  if (pthread_sigmask (SIG_SETMASK, &set, NULL) == -1)\n    {\n      g_warning (\"Failed to unblock signals when starting child\");\n      return;\n    }\n  for (i = 1; i < NSIG; i++)\n    {\n      if (i != SIGSTOP && i != SIGKILL)\n        signal (i, SIG_DFL);\n    }\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].from != fd_map[i].to)\n        {\n          dup2 (fd_map[i].from, fd_map[i].to);\n          close (fd_map[i].from);\n        }\n    }\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].to != fd_map[i].final)\n        {\n          dup2 (fd_map[i].to, fd_map[i].final);\n          close (fd_map[i].to);\n        }\n      drop_cloexec (fd_map[i].final);\n    }\n  setsid ();\n  setpgid (0, 0);\n  if (data->set_tty)\n    {\n      for (i = 0; i < data->fd_map_len; i++)\n        {\n          if (fd_map[i].from == data->tty)\n            {\n              if (ioctl (fd_map[i].final, TIOCSCTTY, 0) == -1)\n                g_debug (\"ioctl(%d, TIOCSCTTY, 0) failed: %s\",\n                         fd_map[i].final, strerror (errno));\n              break;\n            }\n        }\n    }\n}", "target": 0}
{"code": "void vers_select_conds_t::print(String *str, enum_query_type query_type) const\n{\n  switch (orig_type) {\n  case SYSTEM_TIME_UNSPECIFIED:\n    break;\n  case SYSTEM_TIME_AS_OF:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME AS OF \"));\n    break;\n  case SYSTEM_TIME_FROM_TO:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME FROM \"));\n    end.print(str, query_type, STRING_WITH_LEN(\" TO \"));\n    break;\n  case SYSTEM_TIME_BETWEEN:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME BETWEEN \"));\n    end.print(str, query_type, STRING_WITH_LEN(\" AND \"));\n    break;\n  case SYSTEM_TIME_BEFORE:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME BEFORE \"));\n    break;\n  case SYSTEM_TIME_HISTORY:\n    break;\n  case SYSTEM_TIME_ALL:\n    str->append(\" FOR SYSTEM_TIME ALL\");\n    break;\n  }\n}", "target": 0}
{"code": "GF_Err moof_on_child_box(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tif (ptr->mfhd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->mfhd = (GF_MovieFragmentHeaderBox *) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\treturn gf_list_add(ptr->TrackList, a);\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\tif (!ptr->PSSHs) ptr->PSSHs = gf_list_new();\n\t\treturn gf_list_add(ptr->PSSHs, a);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int get_rx_bufs(struct vhost_virtqueue *vq,\n\t\t       struct vring_used_elem *heads,\n\t\t       int datalen,\n\t\t       unsigned *iovcount,\n\t\t       struct vhost_log *log,\n\t\t       unsigned *log_num,\n\t\t       unsigned int quota)\n{\n\tunsigned int out, in;\n\tint seg = 0;\n\tint headcount = 0;\n\tunsigned d;\n\tint r, nlogs = 0;\n\twhile (datalen > 0 && headcount < quota) {\n\t\tif (unlikely(seg >= UIO_MAXIOV)) {\n\t\t\tr = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\td = vhost_get_vq_desc(vq->dev, vq, vq->iov + seg,\n\t\t\t\t      ARRAY_SIZE(vq->iov) - seg, &out,\n\t\t\t\t      &in, log, log_num);\n\t\tif (d == vq->num) {\n\t\t\tr = 0;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(out || in <= 0)) {\n\t\t\tvq_err(vq, \"unexpected descriptor format for RX: \"\n\t\t\t\t\"out %d, in %d\\n\", out, in);\n\t\t\tr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tif (unlikely(log)) {\n\t\t\tnlogs += *log_num;\n\t\t\tlog += *log_num;\n\t\t}\n\t\theads[headcount].id = d;\n\t\theads[headcount].len = iov_length(vq->iov + seg, in);\n\t\tdatalen -= heads[headcount].len;\n\t\t++headcount;\n\t\tseg += in;\n\t}\n\theads[headcount - 1].len += datalen;\n\t*iovcount = seg;\n\tif (unlikely(log))\n\t\t*log_num = nlogs;\n\tif (unlikely(datalen > 0)) {\n\t\tr = UIO_MAXIOV + 1;\n\t\tgoto err;\n\t}\n\treturn headcount;\nerr:\n\tvhost_discard_vq_desc(vq, headcount);\n\treturn r;\n}", "target": 0}
{"code": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tpte_unmap(page_table);\n\tif (!vma->vm_ops->fault)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}", "target": 0}
{"code": "static int bmpr_read_rle(struct iwbmprcontext *rctx)\n{\n\tint retval = 0;\n\tif(!(rctx->compression==IWBMP_BI_RLE8 && rctx->bitcount==8) &&\n\t\t!(rctx->compression==IWBMP_BI_RLE4 && rctx->bitcount==4))\n\t{\n\t\tiw_set_error(rctx->ctx,\"Compression type incompatible with image type\");\n\t\tgoto done;\n\t}\n\tif(rctx->topdown) {\n\t\tiw_set_error(rctx->ctx,\"Compression not allowed with top-down images\");\n\t\tgoto done;\n\t}\n\trctx->img->imgtype = IW_IMGTYPE_RGBA;\n\trctx->img->bit_depth = 8;\n\trctx->img->bpr = iw_calc_bytesperrow(rctx->width,32);\n\trctx->img->pixels = (iw_byte*)iw_malloc_large(rctx->ctx,rctx->img->bpr,rctx->img->height);\n\tif(!rctx->img->pixels) goto done;\n\tif(!bmpr_read_rle_internal(rctx)) goto done;\n\tif(!bmpr_has_transparency(rctx->img)) {\n\t\tbmpr_strip_alpha(rctx->img);\n\t}\n\tretval = 1;\ndone:\n\treturn retval;\n}", "target": 0}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}", "target": 1}
{"code": "static int ip_options_get_finish(struct net *net, struct ip_options **optp,\n\t\t\t\t struct ip_options *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->__data[optlen++] = IPOPT_END;\n\topt->optlen = optlen;\n\tif (optlen && ip_options_compile(net, opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}", "target": 1}
{"code": "static inline long div_ll_X_l_rem(long long divs, long div, long *rem)\n{\n\tlong dum2;\n\tasm(\"divl %2\":\"=a\"(dum2), \"=d\"(*rem)\n\t    : \"rm\"(div), \"A\"(divs));\n\treturn dum2;\n}", "target": 1}
{"code": "static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_skcipher_setkey(private, key, keylen);\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n    FILE *iplist = NULL;\n    plist_t root_node = NULL;\n    char *plist_out = NULL;\n    uint32_t size = 0;\n    int read_size = 0;\n    char *plist_entire = NULL;\n    struct stat filestats;\n    options_t *options = parse_arguments(argc, argv);\n    if (!options)\n    {\n        print_usage(argc, argv);\n        return 0;\n    }\n    iplist = fopen(options->in_file, \"rb\");\n    if (!iplist) {\n        free(options);\n        return 1;\n    }\n    stat(options->in_file, &filestats);\n    if (filestats.st_size < 8) {\n        printf(\"ERROR: Input file is too small to contain valid plist data.\\n\");\n        return -1;\n    }\n    plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1));\n    read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist);\n    fclose(iplist);\n    if (memcmp(plist_entire, \"bplist00\", 8) == 0)\n    {\n        plist_from_bin(plist_entire, read_size, &root_node);\n        plist_to_xml(root_node, &plist_out, &size);\n    }\n    else\n    {\n        plist_from_xml(plist_entire, read_size, &root_node);\n        plist_to_bin(root_node, &plist_out, &size);\n    }\n    plist_free(root_node);\n    free(plist_entire);\n    if (plist_out)\n    {\n        if (options->out_file != NULL)\n        {\n            FILE *oplist = fopen(options->out_file, \"wb\");\n            if (!oplist) {\n                free(options);\n                return 1;\n            }\n            fwrite(plist_out, size, sizeof(char), oplist);\n            fclose(oplist);\n        }\n        else\n            fwrite(plist_out, size, sizeof(char), stdout);\n        free(plist_out);\n    }\n    else\n        printf(\"ERROR: Failed to convert input file.\\n\");\n    free(options);\n    return 0;\n}", "target": 0}
{"code": "static int send_header(void *data, const char *key, const char *val)\n{\n    ap_fputstrs(((hdr_ptr*)data)->f, ((hdr_ptr*)data)->bb,\n                key, \": \", val, CRLF, NULL);\n    return 1;\n}", "target": 0}
{"code": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\ttimer = &pit->pit_state.timer;\n\tmutex_lock(&pit->pit_state.lock);\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n\tmutex_unlock(&pit->pit_state.lock);\n}", "target": 0}
{"code": "static void sctp_process_ext_param(struct sctp_association *asoc,\n\t\t\t\t   union sctp_params param)\n{\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(struct sctp_paramhdr);\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint i;\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_RECONF:\n\t\t\tif (asoc->reconf_enable &&\n\t\t\t    !asoc->peer.reconf_capable)\n\t\t\t\tasoc->peer.reconf_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_FWD_TSN:\n\t\t\tif (asoc->prsctp_enable && !asoc->peer.prsctp_capable)\n\t\t\t\tasoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_AUTH:\n\t\t\tif (asoc->ep->auth_enable)\n\t\t\t\tasoc->peer.auth_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\tif (net->sctp.addip_enable)\n\t\t\t\tasoc->peer.asconf_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_I_DATA:\n\t\t\tif (sctp_sk(asoc->base.sk)->strm_interleave)\n\t\t\t\tasoc->intl_enable = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 0}
{"code": "void Wifipcap::handle_packet(WifipcapCallbacks *cbs,int header_type,\n                             const struct pcap_pkthdr *header, const u_char * packet) \n{\n    if (startTime == TIME_NONE) {\n\tstartTime = header->ts;\n\tlastPrintTime = header->ts;\n    }\n    if (header->ts.tv_sec > lastPrintTime.tv_sec + Wifipcap::PRINT_TIME_INTERVAL) {\n\tif (verbose) {\n\t    int hours = (header->ts.tv_sec - startTime.tv_sec)/3600;\n\t    int days  = hours/24;\n\t    int left  = hours%24;\n\t    fprintf(stderr, \"wifipcap: %2d days %2d hours, %10\" PRId64 \" pkts\\n\", \n\t\t    days, left, packetsProcessed);\n\t}\n\tlastPrintTime = header->ts;\n    }\n    packetsProcessed++;\n    WifiPacket pkt(cbs,header_type,header,packet);\n    cbs->PacketBegin(pkt, packet, header->caplen, header->len);\n    switch(header_type) {\n    case DLT_PRISM_HEADER:\n        pkt.handle_prism(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11_RADIO:\n        pkt.handle_radiotap(packet,header->caplen);\n        break;\n    case DLT_IEEE802_11:\n        pkt.handle_80211(packet,header->caplen);\n        break;\n    case DLT_EN10MB:\n        pkt.handle_ether(packet,header->caplen);\n        break;\n    default:\n#if 0\n        pkt.handle_ip(packet,header->caplen);\n#endif\n        break;\n    }\n    cbs->PacketEnd(pkt);\n}", "target": 0}
{"code": "static unsigned char *AcquireCompactPixels(const Image *image,\n  ExceptionInfo *exception)\n{\n  size_t\n    packet_size;\n  unsigned char\n    *compact_pixels;\n  packet_size=image->depth > 8UL ? 2UL : 1UL;\n  compact_pixels=(unsigned char *) AcquireQuantumMemory((9*\n    image->columns)+1,packet_size*sizeof(*compact_pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        image->filename);\n    }\n  return(compact_pixels);\n}", "target": 1}
{"code": "void zrandmemberCommand(client *c) {\n    long l;\n    int withscores = 0;\n    robj *zset;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withscores\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withscores = 1;\n            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        zrandmemberWithCountCommand(c, l, withscores);\n        return;\n    }\n    if ((zset = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,zset,OBJ_ZSET)) {\n        return;\n    }\n    zsetTypeRandomElement(zset, zsetLength(zset), &ele,NULL);\n    zsetReplyFromListpackEntry(c,&ele);\n}", "target": 0}
{"code": "decode_definite_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL;\n    ret = PyBytes_FromStringAndSize(NULL, length);\n    if (!ret)\n        return NULL;\n    if (fp_read(self, PyBytes_AS_STRING(ret), length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 1}
{"code": "DLLEXPORT int DLLCALL tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,\n\tint pad, int subsamp, unsigned char *dstBuf, int width, int pitch,\n\tint height, int pixelFormat, int flags)\n{\n\tconst unsigned char *srcPlanes[3];\n\tint pw0, ph0, strides[3], retval=-1;\n\ttjinstance *this=(tjinstance *)handle;\n\tif(!this) _throwg(\"tjDecodeYUV(): Invalid handle\");\n\tthis->isInstanceError=FALSE;\n\tif(srcBuf==NULL || pad<0 || !isPow2(pad) || subsamp<0 || subsamp>=NUMSUBOPT\n\t\t|| width<=0 || height<=0)\n\t\t_throw(\"tjDecodeYUV(): Invalid argument\");\n\tpw0=tjPlaneWidth(0, width, subsamp);\n\tph0=tjPlaneHeight(0, height, subsamp);\n\tsrcPlanes[0]=srcBuf;\n\tstrides[0]=PAD(pw0, pad);\n\tif(subsamp==TJSAMP_GRAY)\n\t{\n\t\tstrides[1]=strides[2]=0;\n\t\tsrcPlanes[1]=srcPlanes[2]=NULL;\n\t}\n\telse\n\t{\n\t\tint pw1=tjPlaneWidth(1, width, subsamp);\n\t\tint ph1=tjPlaneHeight(1, height, subsamp);\n\t\tstrides[1]=strides[2]=PAD(pw1, pad);\n\t\tsrcPlanes[1]=srcPlanes[0]+strides[0]*ph0;\n\t\tsrcPlanes[2]=srcPlanes[1]+strides[1]*ph1;\n\t}\n\treturn tjDecodeYUVPlanes(handle, srcPlanes, strides, subsamp, dstBuf, width,\n\t\tpitch, height, pixelFormat, flags);\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "  SPLITS_TYPE RangeSize(T start, T limit, T delta) {\n    if (((delta > 0) && (limit < start)) || ((delta < 0) && (limit > start))) {\n      return 0;\n    }\n    return (std::is_integral<T>::value\n                ? ((std::abs(limit - start) + std::abs(delta) - 1) /\n                   std::abs(delta))\n                : std::ceil(std::abs((limit - start) / delta)));\n  }", "target": 1}
{"code": "int copy_strings_kernel(int argc,char ** argv, struct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, (char __user * __user *)argv, bprm);\n\tset_fs(oldfs);\n\treturn r;\n}", "target": 0}
{"code": "static int install_process_keyring(void)\n{\n\tstruct cred *new;\n\tint ret;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tret = install_process_keyring_to_cred(new);\n\tif (ret < 0) {\n\t\tabort_creds(new);\n\t\treturn ret != -EEXIST ? ret : 0;\n\t}\n\treturn commit_creds(new);\n}", "target": 1}
{"code": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n    return TPM_SUCCESS;\n}", "target": 1}
{"code": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\treturn 0;\n}", "target": 1}
{"code": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}", "target": 1}
{"code": "Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[100];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}", "target": 1}
{"code": "static unsigned short get_ushort(const unsigned char *data)\n{\n    unsigned short val = *(const unsigned short *)data;\n#ifdef OPJ_BIG_ENDIAN\n    val = ((val & 0xffU) << 8) | (val >> 8);\n#endif\n    return val;\n}", "target": 1}
{"code": "inline bool ResolveAxis(const int num_dims, const int* axis,\n                        const int64_t num_axis, int* out_axis,\n                        int* out_num_axis) {\n  *out_num_axis = 0;  \n  if (num_dims == 0) {\n    return true;\n  }\n  for (int64_t idx = 0; idx < num_axis; ++idx) {\n    int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];\n    TFLITE_DCHECK(current >= 0 && current < num_dims);\n    if (current < 0 || current >= num_dims) {\n      return false;\n    }\n    bool is_dup = false;\n    for (int j = 0; j < *out_num_axis; ++j) {\n      if (out_axis[j] == current) {\n        is_dup = true;\n        break;\n      }\n    }\n    if (!is_dup) {\n      out_axis[*out_num_axis] = current;\n      *out_num_axis += 1;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "  const uint8_t *getBytecode(uint32_t) const override {\n    llvm_unreachable(\"Accessing bytecode from a lazy module\");\n  }", "target": 1}
{"code": "void MainWindow::showUpgradePrompt()\n{\n    if (Settings.checkUpgradeAutomatic()) {\n        showStatusMessage(\"Checking for upgrade...\");\n        QNetworkRequest request(QUrl(\"https:\n        QSslConfiguration sslConfig = request.sslConfiguration();\n        sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);\n        request.setSslConfiguration(sslConfig);\n        m_network.get(request);\n    } else {\n        m_network.setStrictTransportSecurityEnabled(false);\n        QAction* action = new QAction(tr(\"Click here to check for a new version of Shotcut.\"), 0);\n        connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered()));\n        showStatusMessage(action, 15 );\n    }\n}", "target": 1}
{"code": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n    for (i = 0; argv[i]; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n    if (ogs_app()->parameter.no_hss == 0)\n        hss_thread = test_child_create(\"hss\", argv_out);\n    if (ogs_app()->parameter.no_pcrf == 0)\n        pcrf_thread = test_child_create(\"pcrf\", argv_out);\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_sgwu == 0)\n        sgwu_thread = test_child_create(\"sgwu\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_sgwc == 0)\n        sgwc_thread = test_child_create(\"sgwc\", argv_out);\n    if (ogs_app()->parameter.no_mme == 0)\n        mme_thread = test_child_create(\"mme\", argv_out);\n    ogs_msleep(5000);\n    return OGS_OK;;\n}", "target": 1}
{"code": "static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}", "target": 0}
{"code": "virDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n    virResetLastError();\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    if (dom->conn->driver->domainGetTime) {\n        int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}", "target": 0}
{"code": "void TakeScreenshot(const char *fileName)\n{\n#if defined(SUPPORT_MODULE_RTEXTURES)\n    if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }\n    Vector2 scale = GetWindowScaleDPI();\n    unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n    Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };\n    char path[2048] = { 0 };\n    strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));\n    ExportImage(image, path);           \n    RL_FREE(imgData);\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", GetFileName(path), GetFileName(path)));\n#endif\n    TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);\n#else\n    TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");\n#endif\n}", "target": 0}
{"code": "static int rm_read_extradata(AVFormatContext *s, AVIOContext *pb, AVCodecParameters *par, unsigned size)\n{\n    if (size >= 1<<24) {\n        av_log(s, AV_LOG_ERROR, \"extradata size %u too large\\n\", size);\n        return -1;\n    }\n    if (ff_get_extradata(s, par, pb, size) < 0)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 0}
{"code": "static int req_ssl_var_lookup(lua_State *L)\n{\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    const char *s = luaL_checkstring(L, 2);\n    const char *res = ap_lua_ssl_val(r->pool, r->server, r->connection, r, \n                                     (char *)s);\n    lua_pushstring(L, res);\n    return 1;\n}", "target": 0}
{"code": "void handle_get_plugin_schema_resp(nng_aio *aio, neu_resp_check_schema_t *resp)\n{\n    if (resp->exist) {\n        char * schema_path = NULL;\n        size_t len         = 0;\n        char * buf         = NULL;\n        if (0 > neu_asprintf(&schema_path, \"%s/schema/%s.json\", g_plugin_dir,\n                             resp->schema)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n        if (NULL == buf) {\n            free(schema_path);\n            if (0 > neu_asprintf(&schema_path, \"%s/custom/schema/%s.json\",\n                                 g_plugin_dir, resp->schema)) {\n                NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                    neu_http_response(aio, error_code.error, result_error);\n                });\n                return;\n            }\n            buf = file_string_read(&len, schema_path);\n        }\n        if (NULL == buf) {\n            free(schema_path);\n            if (0 > neu_asprintf(&schema_path, \"%s/system/schema/%s.json\",\n                                 g_plugin_dir, resp->schema)) {\n                NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                    neu_http_response(aio, error_code.error, result_error);\n                });\n                return;\n            }\n            buf = file_string_read(&len, schema_path);\n        }\n        if (NULL == buf) {\n            nlog_info(\"open %s error: %d\", schema_path, errno);\n            neu_http_not_found(aio, \"{\\\"status\\\": \\\"error\\\"}\");\n            free(schema_path);\n            return;\n        }\n        neu_http_ok(aio, buf);\n        free(buf);\n        free(schema_path);\n    } else {\n        NEU_JSON_RESPONSE_ERROR(NEU_ERR_PLUGIN_NOT_FOUND, {\n            neu_http_response(aio, error_code.error, result_error);\n        });\n    }\n}", "target": 0}
{"code": "static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\tif(d_len<8) return;\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n\te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n\tifd = iw_get_ui32_e(&d[4],e.endian);\n\tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n}", "target": 1}
{"code": "string SummarizeArray<bool>(int64_t limit, int64_t num_elts,\n                            const TensorShape& tensor_shape, const char* data,\n                            const bool print_v2) {\n  if (data == nullptr) {\n    return strings::StrCat(\"\");  \n  }\n  auto mutable_data = std::unique_ptr<char[]>(new char[num_elts]);\n  for (int64_t i = 0; i < num_elts; ++i)\n    mutable_data.get()[i] = data[i] ? 1 : 0;\n  bool* array = reinterpret_cast<bool*>(mutable_data.get());\n  return SummarizeArrayInternal<bool>(limit, num_elts, tensor_shape, array,\n                                      print_v2);\n}", "target": 0}
{"code": "print_prefix(netdissect_options *ndo, const u_char *prefix, u_int max_length)\n{\n    int plenbytes;\n    char buf[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx::/128\")];\n    if (prefix[0] >= 96 && max_length >= IPV4_MAPPED_HEADING_LEN + 1 &&\n        is_ipv4_mapped_address(&prefix[1])) {\n        struct in_addr addr;\n        u_int plen;\n        plen = prefix[0]-96;\n        if (32 < plen)\n            return -1;\n        max_length -= 1;\n        memset(&addr, 0, sizeof(addr));\n        plenbytes = (plen + 7) / 8;\n        if (max_length < (u_int)plenbytes + IPV4_MAPPED_HEADING_LEN)\n            return -3;\n        memcpy(&addr, &prefix[1 + IPV4_MAPPED_HEADING_LEN], plenbytes);\n        if (plen % 8) {\n\t\t((u_char *)&addr)[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, sizeof(buf), \"%s/%d\", ipaddr_string(ndo, &addr), plen);\n        plenbytes += 1 + IPV4_MAPPED_HEADING_LEN;\n    } else {\n        plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));\n        if (plenbytes < 0)\n            return plenbytes;\n    }\n    ND_PRINT((ndo, \"%s\", buf));\n    return plenbytes;\n}", "target": 0}
{"code": "    void Encode(Key, const Value& value) {\n      AddToSummary(Key::key(), Key::Encode(value).size());\n    }", "target": 1}
{"code": "void ndpi_search_oracle(struct ndpi_detection_module_struct *ndpi_struct, struct ndpi_flow_struct *flow)\n{\n  struct ndpi_packet_struct *packet = &flow->packet;\n  u_int16_t dport = 0, sport = 0;\n  NDPI_LOG_DBG(ndpi_struct, \"search ORACLE\\n\");\n  if(packet->tcp != NULL) {\n    sport = ntohs(packet->tcp->source), dport = ntohs(packet->tcp->dest);\n    NDPI_LOG_DBG2(ndpi_struct, \"calculating ORACLE over tcp\\n\");\n    if ((dport == 1521 || sport == 1521)\n\t&&  (((packet->payload[0] == 0x07) && (packet->payload[1] == 0xff) && (packet->payload[2] == 0x00))\n\t     || ((packet->payload_packet_len >= 232) && ((packet->payload[0] == 0x00) || (packet->payload[0] == 0x01)) \n\t     && (packet->payload[1] != 0x00)\n\t     && (packet->payload[2] == 0x00)\n\t\t && (packet->payload[3] == 0x00)))) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    } else if (packet->payload_packet_len == 213 && packet->payload[0] == 0x00 &&\n               packet->payload[1] == 0xd5 && packet->payload[2] == 0x00 &&\n               packet->payload[3] == 0x00 ) {\n      NDPI_LOG_INFO(ndpi_struct, \"found oracle\\n\");\n      ndpi_int_oracle_add_connection(ndpi_struct, flow);\n    }\n  } else {\n    NDPI_EXCLUDE_PROTO(ndpi_struct, flow);\n  }\n}", "target": 1}
{"code": "bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "static void update_read_synchronize(rdpUpdate* update, wStream* s)\n{\n\tWINPR_UNUSED(update);\n\tStream_Seek_UINT16(s); \n}", "target": 1}
{"code": "bool CMerkleTx::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs) {\n    return(CTransaction::AcceptToMemoryPool(txdb, fCheckInputs));\n}", "target": 1}
{"code": "static int rr_handle_error(READ_RECORD *info, int error)\n{\n  if (info->thd->killed)\n  {\n    info->thd->send_kill_message();\n    return 1;\n  }\n  if (error == HA_ERR_END_OF_FILE)\n    error= -1;\n  else\n  {\n    if (info->print_error)\n      info->table->file->print_error(error, MYF(0));\n    if (error < 0)                            \n      error= 1;\n  }\n  return error;\n}", "target": 0}
{"code": "    void SetArcInMem(byte *Data,size_t Size)\n    {\n      ArcMemData=Data;\n      ArcMemSize=Size;\n      ArcInMem=Data!=NULL && Size>0;\n    }", "target": 0}
{"code": "imapx_untagged_list (CamelIMAPXServer *is,\n                     GInputStream *input_stream,\n                     GCancellable *cancellable,\n                     GError **error)\n{\n\tCamelIMAPXListResponse *response;\n\tCamelIMAPXStore *imapx_store;\n\tconst gchar *mailbox_name;\n\tgchar separator;\n\tg_return_val_if_fail (CAMEL_IS_IMAPX_SERVER (is), FALSE);\n\tresponse = camel_imapx_list_response_new (\n\t\tCAMEL_IMAPX_INPUT_STREAM (input_stream), cancellable, error);\n\tif (response == NULL)\n\t\treturn FALSE;\n\tmailbox_name = camel_imapx_list_response_get_mailbox_name (response);\n\tseparator = camel_imapx_list_response_get_separator (response);\n\tif (camel_imapx_mailbox_is_inbox (mailbox_name))\n\t\tis->priv->inbox_separator = separator;\n\timapx_store = camel_imapx_server_ref_store (is);\n\tcamel_imapx_store_handle_list_response (imapx_store, is, response);\n\tg_clear_object (&imapx_store);\n\tg_clear_object (&response);\n\treturn TRUE;\n}", "target": 0}
{"code": "void rds6_inc_info_copy(struct rds_incoming *inc,\n\t\t\tstruct rds_info_iterator *iter,\n\t\t\tstruct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\tint flip)\n{\n\tstruct rds6_info_message minfo6;\n\tminfo6.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo6.len = be32_to_cpu(inc->i_hdr.h_len);\n\tminfo6.tos = inc->i_conn->c_tos;\n\tif (flip) {\n\t\tminfo6.laddr = *daddr;\n\t\tminfo6.faddr = *saddr;\n\t\tminfo6.lport = inc->i_hdr.h_dport;\n\t\tminfo6.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo6.laddr = *saddr;\n\t\tminfo6.faddr = *daddr;\n\t\tminfo6.lport = inc->i_hdr.h_sport;\n\t\tminfo6.fport = inc->i_hdr.h_dport;\n\t}\n\tminfo6.flags = 0;\n\trds_info_copy(iter, &minfo6, sizeof(minfo6));\n}", "target": 0}
{"code": "static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\topl3_set_instr(dev, voice, info->pgm_num);\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}", "target": 1}
{"code": "RawTile KakaduImage::getRegion( int seq, int ang, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h )\n{\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w*h*channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w*h*channels];\n  else throw file_error( \"Kakadu :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"Kakadu :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "int CommandData::IsProcessFile(FileHeader &FileHead,bool *ExactMatch,int MatchType,\n                               wchar *MatchedArg,uint MatchedArgSize)\n{\n  if (MatchedArg!=NULL && MatchedArgSize>0)\n    *MatchedArg=0;\n  if (wcslen(FileHead.FileName)>=NM)\n    return 0;\n  bool Dir=FileHead.Dir;\n  if (ExclCheck(FileHead.FileName,Dir,false,true))\n    return 0;\n#ifndef SFX_MODULE\n  if (TimeCheck(FileHead.mtime))\n    return 0;\n  if ((FileHead.FileAttr & ExclFileAttr)!=0 || InclAttrSet && (FileHead.FileAttr & InclFileAttr)==0)\n    return 0;\n  if (!Dir && SizeCheck(FileHead.UnpSize))\n    return 0;\n#endif\n  wchar *ArgName;\n  FileArgs.Rewind();\n  for (int StringCount=1;(ArgName=FileArgs.GetString())!=NULL;StringCount++)\n    if (CmpName(ArgName,FileHead.FileName,MatchType))\n    {\n      if (ExactMatch!=NULL)\n        *ExactMatch=wcsicompc(ArgName,FileHead.FileName)==0;\n      if (MatchedArg!=NULL)\n        wcsncpyz(MatchedArg,ArgName,MatchedArgSize);\n      return StringCount;\n    }\n  return 0;\n}", "target": 1}
{"code": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->value = GETVAL32H(buf, 4);\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[kHeightRank];\n  const int input_width = input->dims->data[kWidthRank];\n  const int input_channels = input->dims->data[kDepthRank];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteEvalTensor* output_eval =\n      tflite::micro::GetEvalOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_OK(context, tflite::micro::CreateWritableTensorDimsWithCopy(\n                                 context, output, output_eval));\n  output->dims->data[kBatchRank] = input->dims->data[kBatchRank];\n  output->dims->data[kHeightRank] = output_height;\n  output->dims->data[kWidthRank] = output_width;\n  output->dims->data[kDepthRank] = output_channels;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void RequestContext::StartBackendSpanAndSetTraceContext() {\n  backend_span_.reset(CreateSpan(cloud_trace_.get(), \"Backend\"));\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                  filter_sizes.vec<int32>(), &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context,\n                   ConvBackpropComputeDimensions(\n                       \"Conv3DBackpropFilterOp\", 3,\n                       input_shape, filter_shape, out_backprop_shape, stride_,\n                       padding_, data_format_, &dims));\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n    if (input_shape.num_elements() == 0) {\n      filter_backprop->template flat<T>().setZero();\n      return;\n    }\n    functor::CuboidConvolutionBackwardFilter<Device, T>()(\n        context->eigen_device<Device>(),\n        filter_backprop->tensor<T, 5>(),                 \n        input.tensor<T, 5>(),                            \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){\n  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);\n  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);\n  if( p ){\n    p->aSortOrder = (u8*)&p->aColl[N+X];\n    p->nKeyField = (u16)N;\n    p->nAllField = (u16)(N+X);\n    p->enc = ENC(db);\n    p->db = db;\n    p->nRef = 1;\n    memset(&p[1], 0, nExtra);\n  }else{\n    sqlite3OomFault(db);\n  }\n  return p;\n}", "target": 0}
{"code": "kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\n        input_message_buffer, conf_state, output_message_buffer, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    int conf_req_flag;\n    gss_qop_t qop_req;\n    gss_buffer_t input_message_buffer;\n    int *conf_state;\n    gss_buffer_t output_message_buffer;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    output_message_buffer->length = 0;\n    output_message_buffer->value = NULL;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto)\n    {\n    case 0:\n        code = make_seal_token_v1(context, ctx->enc, ctx->seq,\n                                  &ctx->seq_send, ctx->initiate,\n                                  input_message_buffer, output_message_buffer,\n                                  ctx->signalg, ctx->cksum_size, ctx->sealalg,\n                                  conf_req_flag, toktype, ctx->mech_used);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3(context, ctx,\n                                              input_message_buffer,\n                                              output_message_buffer,\n                                              conf_req_flag, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;   \n        break;\n    }\n    if (code) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n    if (conf_state)\n        *conf_state = conf_req_flag;\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}", "target": 1}
{"code": "static int ccid3_hc_tx_getsockopt(struct sock *sk, const int optname, int len,\n\t\t\t\t  u32 __user *optval, int __user *optlen)\n{\n\tconst struct ccid3_hc_tx_sock *hc = ccid3_hc_tx_sk(sk);\n\tstruct tfrc_tx_info tfrc;\n\tconst void *val;\n\tswitch (optname) {\n\tcase DCCP_SOCKOPT_CCID_TX_INFO:\n\t\tif (len < sizeof(tfrc))\n\t\t\treturn -EINVAL;\n\t\tmemset(&tfrc, 0, sizeof(tfrc));\n\t\ttfrc.tfrctx_x\t   = hc->tx_x;\n\t\ttfrc.tfrctx_x_recv = hc->tx_x_recv;\n\t\ttfrc.tfrctx_x_calc = hc->tx_x_calc;\n\t\ttfrc.tfrctx_rtt\t   = hc->tx_rtt;\n\t\ttfrc.tfrctx_p\t   = hc->tx_p;\n\t\ttfrc.tfrctx_rto\t   = hc->tx_t_rto;\n\t\ttfrc.tfrctx_ipi\t   = hc->tx_t_ipi;\n\t\tlen = sizeof(tfrc);\n\t\tval = &tfrc;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (put_user(len, optlen) || copy_to_user(optval, val, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n\t}\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NoKeepWithGeoNear) {\n    params.options = QueryPlannerParams::KEEP_MUTATIONS;\n    addIndex(BSON(\"a\"\n                  << \"2d\"));\n    runQuery(fromjson(\"{a: {$near: [0,0], $maxDistance:0.3 }}\"));\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\"{geoNear2d: {a: '2d'}}\");\n}", "target": 0}
{"code": "CallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *newCodeBlock) {\n  newCodeBlock->lazyCompile(*this);\n#if defined(HERMES_MEMORY_INSTRUMENTATION) || !defined(NDEBUG)\n  const inst::Inst *ip = getCurrentIP();\n  (void)ip;\n#endif\n#ifdef HERMES_MEMORY_INSTRUMENTATION\n  if (ip) {\n    const CodeBlock *codeBlock;\n    std::tie(codeBlock, ip) = getCurrentInterpreterLocation(ip);\n    if (codeBlock) {\n      pushCallStack(codeBlock, ip);\n    } else {\n      pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n    }\n  } else {\n    pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n  }\n#endif\n  InterpreterState state{newCodeBlock, 0};\n  if (HERMESVM_CRASH_TRACE &&\n      (getVMExperimentFlags() & experiments::CrashTrace)) {\n    return Interpreter::interpretFunction<false, true>(*this, state);\n  } else {\n    return Interpreter::interpretFunction<false, false>(*this, state);\n  }\n}", "target": 1}
{"code": "static void init_once(void *foo)\n{\n\tstruct ext4_inode_info *ei = (struct ext4_inode_info *) foo;\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\tinit_rwsem(&ei->xattr_sem);\n\tinit_rwsem(&ei->i_data_sem);\n\tinit_rwsem(&ei->i_mmap_sem);\n\tinode_init_once(&ei->vfs_inode);\n}", "target": 0}
{"code": "void EditorClientBlackBerry::didWriteSelectionToPasteboard()\n{\n    notImplemented();\n}", "target": 0}
{"code": "struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *sock)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tconn->sd = accept(sock->sd, NULL, NULL);\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 1}
{"code": "buf_copy(const buf_t *buf)\n{\n  chunk_t *ch;\n  buf_t *out = buf_new();\n  out->default_chunk_size = buf->default_chunk_size;\n  for (ch = buf->head; ch; ch = ch->next) {\n    chunk_t *newch = chunk_copy(ch);\n    if (out->tail) {\n      out->tail->next = newch;\n      out->tail = newch;\n    } else {\n      out->head = out->tail = newch;\n    }\n  }\n  out->datalen = buf->datalen;\n  return out;\n}", "target": 0}
{"code": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}", "target": 1}
{"code": "TfLiteStatus EvalHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  auto* output_data = GetTensorData<std::int64_t>(output_tensor);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  output_data[0] = lookup->Size();\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}", "target": 1}
{"code": "  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"Missing context\");\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }", "target": 1}
{"code": "CoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,\n                     Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m):\n\tparams(p),\n\tdenomination(coin.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((coin.getSerialNumber())),\n\taccumulatorPoK(&p->accumulatorParams),\n\tserialNumberSoK(p),\n\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\tif (!HasValidSerial()) {\n\t\tthrow ZerocoinException(\"Invalid serial # range\");\n\t}\n\tconst Commitment fullCommitmentToCoinUnderSerialParams(&p->serialNumberSoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = fullCommitmentToCoinUnderSerialParams.getCommitmentValue();\n\tconst Commitment fullCommitmentToCoinUnderAccParams(&p->accumulatorParams.accumulatorPoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = fullCommitmentToCoinUnderAccParams.getCommitmentValue();\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup, fullCommitmentToCoinUnderSerialParams, fullCommitmentToCoinUnderAccParams);\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&p->accumulatorParams, fullCommitmentToCoinUnderAccParams, witness, a);\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(p, coin, fullCommitmentToCoinUnderSerialParams, signatureHash(m));\n}", "target": 0}
{"code": "FragmentedSampleReader::ReadSample(AP4_Sample& sample, AP4_DataBuffer& sample_data)\n{\n    return m_FragmentReader.ReadNextSample(m_TrackId, sample, sample_data);\n}", "target": 0}
{"code": "static int bnx2x_get_cmng_fns_mode(struct bnx2x *bp)\n{\n\tif (CHIP_REV_IS_SLOW(bp))\n\t\treturn CMNG_FNS_NONE;\n\tif (IS_MF(bp))\n\t\treturn CMNG_FNS_MINMAX;\n\treturn CMNG_FNS_NONE;\n}", "target": 0}
{"code": "static inline bool unconditional(const struct ip6t_ip6 *ipv6)\n{\n\tstatic const struct ip6t_ip6 uncond;\n\treturn memcmp(ipv6, &uncond, sizeof(uncond)) == 0;\n}", "target": 1}
{"code": "bool jas_image_cmpt_domains_same(jas_image_t *image)\n{\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_cmpt_t *cmpt0;\n\tcmpt0 = image->cmpts_[0];\n\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\tif (cmpt->tlx_ != cmpt0->tlx_ || cmpt->tly_ != cmpt0->tly_ ||\n\t\t  cmpt->hstep_ != cmpt0->hstep_ || cmpt->vstep_ != cmpt0->vstep_ ||\n\t\t  cmpt->width_ != cmpt0->width_ || cmpt->height_ != cmpt0->height_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "int git_treebuilder_write(git_oid *oid, git_repository *repo, git_treebuilder *bld)\n{\n\tint error = 0;\n\tsize_t i;\n\tgit_buf tree = GIT_BUF_INIT;\n\tgit_odb *odb;\n\tassert(bld);\n\tgit_vector_sort(&bld->entries);\n\terror = git_buf_grow(&tree, bld->entries.length * 72);\n\tfor (i = 0; i < bld->entries.length && !error; ++i) {\n\t\tgit_tree_entry *entry = git_vector_get(&bld->entries, i);\n\t\tif (entry->removed)\n\t\t\tcontinue;\n\t\tgit_buf_printf(&tree, \"%o \", entry->attr);\n\t\tgit_buf_put(&tree, entry->filename, entry->filename_len + 1);\n\t\tgit_buf_put(&tree, (char *)entry->oid.id, GIT_OID_RAWSZ);\n\t\tif (git_buf_oom(&tree))\n\t\t\terror = -1;\n\t}\n\tif (!error &&\n\t\t!(error = git_repository_odb__weakptr(&odb, repo)))\n\t\terror = git_odb_write(oid, odb, tree.ptr, tree.size, GIT_OBJ_TREE);\n\tgit_buf_free(&tree);\n\treturn error;\n}", "target": 0}
{"code": "static void __attribute__((destructor)) fio_lib_destroy(void) {\n  uint8_t add_eol = fio_is_master();\n  fio_data->active = 0;\n  fio_on_fork();\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_AT_EXIT);\n  fio_state_callback_clear_all();\n  fio_defer_perform();\n  fio_poll_close();\n  fio_timer_clear_all();\n  fio_free(fio_data);\n  fio_mem_destroy();\n  FIO_LOG_DEBUG(\"(%d) facil.io resources released, exit complete.\",\n                (int)getpid());\n  if (add_eol)\n    fprintf(stderr, \"\\n\"); \n}", "target": 1}
{"code": "getRootParserOf(XML_Parser parser, unsigned int *outLevelDiff) {\n  XML_Parser rootParser = parser;\n  unsigned int stepsTakenUpwards = 0;\n  while (rootParser->m_parentParser) {\n    rootParser = rootParser->m_parentParser;\n    stepsTakenUpwards++;\n  }\n  assert(! rootParser->m_parentParser);\n  if (outLevelDiff != NULL) {\n    *outLevelDiff = stepsTakenUpwards;\n  }\n  return rootParser;\n}", "target": 0}
{"code": "void lcdSetPixels_ArrayBuffer_flat(JsGraphics *gfx, short x, short y, short pixelCount, unsigned int col) {\n  unsigned char *ptr = (unsigned char*)gfx->backendData;\n  unsigned int idx = lcdGetPixelIndex_ArrayBuffer(gfx,x,y,pixelCount);\n  ptr += idx>>3;\n  unsigned int whiteMask = (1U<<gfx->data.bpp)-1;\n  bool shortCut = (col==0 || (col&whiteMask)==whiteMask) && (!(gfx->data.flags&JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE)); \n  while (pixelCount--) { \n    if (gfx->data.bpp&7) {\n      idx = idx & 7;\n      if (shortCut && idx==0) {\n        int wholeBytes = (gfx->data.bpp*(pixelCount+1)) >> 3;\n        if (wholeBytes) {\n          char c = (char)(col?0xFF:0);\n          pixelCount = (short)(pixelCount+1 - (wholeBytes*8/gfx->data.bpp));\n          while (wholeBytes--) {\n            *ptr = c;\n            ptr++;\n          }\n          continue;\n        }\n      }\n      unsigned int mask = (unsigned int)(1<<gfx->data.bpp)-1;\n      unsigned int existing = (unsigned int)*ptr;\n      unsigned int bitIdx = (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB) ? 8-(idx+gfx->data.bpp) : idx;\n      assert(ptr>=gfx->backendData && ptr<((char*)gfx->backendData + graphicsGetMemoryRequired(gfx)));\n      *ptr = (char)((existing&~(mask<<bitIdx)) | ((col&mask)<<bitIdx));\n      if (gfx->data.flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE) {\n        ptr++;\n      } else {\n        idx += gfx->data.bpp;\n        if (idx>=8) ptr++;\n      }\n    } else { \n      int i;\n      for (i=0;i<gfx->data.bpp;i+=8) {\n        *ptr = (char)(col >> i);\n        ptr++;\n      }\n    }\n  }\n}", "target": 0}
{"code": "void altivec_unavailable_exception(struct pt_regs *regs)\n{\n#if !defined(CONFIG_ALTIVEC)\n\tif (user_mode(regs)) {\n\t\t_exception(SIGILL, regs, ILL_ILLOPC, regs->nip);\n\t\treturn;\n\t}\n#endif\n\tprintk(KERN_EMERG \"Unrecoverable VMX/Altivec Unavailable Exception \"\n\t\t\t\"%lx at %lx\\n\", regs->trap, regs->nip);\n\tdie(\"Unrecoverable VMX/Altivec Unavailable Exception\", regs, SIGABRT);\n}", "target": 1}
{"code": "TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,\n                    const TfLiteTensor* positions, TfLiteTensor* output) {\n  tflite::GatherParams op_params;\n  op_params.axis = params.axis;\n  op_params.batch_dims = params.batch_dims;\n  optimized_ops::Gather(op_params, GetTensorShape(input),\n                        GetTensorData<InputT>(input), GetTensorShape(positions),\n                        GetTensorData<PositionsT>(positions),\n                        GetTensorShape(output), GetTensorData<InputT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "Tss2_RC_Decode(TSS2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_NAME_MAX + TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n    clearbuf(buf);\n    UINT8 layer = tss2_rc_layer_number_get(rc);\n    TSS2_RC_HANDLER handler = layer_handler[layer].handler;\n    const char *lname = layer_handler[layer].name;\n    if (lname[0]) {\n        catbuf(buf, \"%s:\", lname);\n    } else {\n        catbuf(buf, \"%u:\", layer);\n    }\n    handler = !handler ? unknown_layer_handler : handler;\n    UINT16 err_bits = tpm2_error_get(rc);\n    const char *e = err_bits ? handler(err_bits) : \"success\";\n    if (e) {\n        catbuf(buf, \"%s\", e);\n    } else {\n        catbuf(buf, \"0x%X\", err_bits);\n    }\n    return buf;\n}", "target": 1}
{"code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\tspin_unlock(q->lock_ptr);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "R_API bool r_anal_vtable_begin(RAnal *anal, RVTableContext *context) {\n\tcontext->anal = anal;\n\tcontext->abi = anal->cxxabi;\n\tcontext->word_size = (ut8) (anal->config->bits / 8);\n\tconst bool is_arm = anal->cur->arch && r_str_startswith (anal->cur->arch, \"arm\");\n\tif (is_arm && context->word_size < 4) {\n\t\tcontext->word_size = 4;\n\t}\n\tconst bool be = anal->config->big_endian;\n\tswitch (context->word_size) {\n\tcase 1:\n\t\tcontext->read_addr = be? vtable_read_addr_be8 : vtable_read_addr_le8;\n\t\tbreak;\n\tcase 2:\n\t\tcontext->read_addr = be? vtable_read_addr_be16 : vtable_read_addr_le16;\n\t\tbreak;\n\tcase 4:\n\t\tcontext->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;\n\t\tbreak;\n\tcase 8:\n\t\tcontext->read_addr = be? vtable_read_addr_be64 : vtable_read_addr_le64;\n\t\tbreak;\n\tdefault:\n\t\tcontext->read_addr = be? vtable_read_addr_be32 : vtable_read_addr_le32;\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "content::ColorChooser* Browser::OpenColorChooser(\n      WebContents* web_contents,\n      SkColor initial_color,\n      const std::vector<content::ColorSuggestion>& suggestions) {\n  return chrome::ShowColorChooser(web_contents, initial_color);\n}", "target": 0}
{"code": "unsigned int munlock_vma_page(struct page *page)\n{\n\tunsigned int nr_pages;\n\tstruct zone *zone = page_zone(page);\n\tBUG_ON(!PageLocked(page));\n\tspin_lock_irq(&zone->lru_lock);\n\tnr_pages = hpage_nr_pages(page);\n\tif (!TestClearPageMlocked(page))\n\t\tgoto unlock_out;\n\t__mod_zone_page_state(zone, NR_MLOCK, -nr_pages);\n\tif (__munlock_isolate_lru_page(page, true)) {\n\t\tspin_unlock_irq(&zone->lru_lock);\n\t\t__munlock_isolated_page(page);\n\t\tgoto out;\n\t}\n\t__munlock_isolation_failed(page);\nunlock_out:\n\tspin_unlock_irq(&zone->lru_lock);\nout:\n\treturn nr_pages - 1;\n}", "target": 0}
{"code": "void GfxImageColorMap::getGrayLine(unsigned char *in, unsigned char *out, int length)\n{\n    int i, j;\n    unsigned char *inp, *tmp_line;\n    if ((colorSpace2 && !colorSpace2->useGetGrayLine()) || (!colorSpace2 && !colorSpace->useGetGrayLine())) {\n        GfxGray gray;\n        inp = in;\n        for (i = 0; i < length; i++) {\n            getGray(inp, &gray);\n            out[i] = colToByte(gray);\n            inp += nComps;\n        }\n        return;\n    }\n    switch (colorSpace->getMode()) {\n    case csIndexed:\n    case csSeparation:\n        tmp_line = (unsigned char *)gmallocn(length, nComps2);\n        for (i = 0; i < length; i++) {\n            for (j = 0; j < nComps2; j++) {\n                unsigned char c = in[i];\n                if (byte_lookup)\n                    c = byte_lookup[c * nComps2 + j];\n                tmp_line[i * nComps2 + j] = c;\n            }\n        }\n        colorSpace2->getGrayLine(tmp_line, out, length);\n        gfree(tmp_line);\n        break;\n    default:\n        if (byte_lookup) {\n            inp = in;\n            for (j = 0; j < length; j++)\n                for (i = 0; i < nComps; i++) {\n                    *inp = byte_lookup[*inp * nComps + i];\n                    inp++;\n                }\n        }\n        colorSpace->getGrayLine(in, out, length);\n        break;\n    }\n}", "target": 0}
{"code": "txid_current_snapshot(PG_FUNCTION_ARGS)\n{\n\tTxidSnapshot *snap;\n\tuint32\t\tnxip,\n\t\t\t\ti,\n\t\t\t\tsize;\n\tTxidEpoch\tstate;\n\tSnapshot\tcur;\n\tcur = GetActiveSnapshot();\n\tif (cur == NULL)\n\t\telog(ERROR, \"no active snapshot set\");\n\tload_xid_epoch(&state);\n\tStaticAssertStmt(MAX_BACKENDS * 2 <= TXID_SNAPSHOT_MAX_NXIP,\n\t\t\t\t\t \"possible overflow in txid_current_snapshot()\");\n\tnxip = cur->xcnt;\n\tsize = TXID_SNAPSHOT_SIZE(nxip);\n\tsnap = palloc(size);\n\tSET_VARSIZE(snap, size);\n\tsnap->xmin = convert_xid(cur->xmin, &state);\n\tsnap->xmax = convert_xid(cur->xmax, &state);\n\tsnap->nxip = nxip;\n\tfor (i = 0; i < nxip; i++)\n\t\tsnap->xip[i] = convert_xid(cur->xip[i], &state);\n\tsort_snapshot(snap);\n\tPG_RETURN_POINTER(snap);\n}", "target": 0}
{"code": "  bool IsSupported(const NodeDef* node) const override {\n    if (!node || node->input_size() < 2) {\n      return false;\n    }\n    return IsAnyMul(*node) && node->input(0) == node->input(1);\n  }", "target": 0}
{"code": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\tStream_Read_UINT32(s, scopeCount); \n        if (Stream_GetRemainingLength(s) / sizeof(LICENSE_BLOB) < scopeCount)\n                return FALSE;  \n\tscopeList->count = scopeCount;\n\tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;\n}", "target": 1}
{"code": "static ssize_t __disk_events_show(unsigned int events, char *buf)\n{\n\tconst char *delim = \"\";\n\tssize_t pos = 0;\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(disk_events_strs); i++)\n\t\tif (events & (1 << i)) {\n\t\t\tpos += sprintf(buf + pos, \"%s%s\",\n\t\t\t\t       delim, disk_events_strs[i]);\n\t\t\tdelim = \" \";\n\t\t}\n\tif (pos)\n\t\tpos += sprintf(buf + pos, \"\\n\");\n\treturn pos;\n}", "target": 0}
{"code": "static s32 adpt_send_nop(adpt_hba*pHba,u32 m)\n{\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 5*HZ;\n\twhile(m == EMPTY_QUEUE){\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif(m != EMPTY_QUEUE){\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_ERR \"%s: Timeout waiting for message frame!\\n\",pHba->name);\n\t\t\treturn 2;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tmsg = (u32 __iomem *)(pHba->msg_addr_virt + m);\n\twritel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);\n\twritel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);\n\twritel( 0,&msg[2]);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "static char *pool_strdup(const char *s)\n{\n\tchar *r = pool_alloc(strlen(s) + 1);\n\tstrcpy(r, s);\n\treturn r;\n}", "target": 1}
{"code": "SendScaleSetting(rfbClient* client,int scaleSetting)\n{\n  rfbSetScaleMsg ssm;\n  ssm.scale = scaleSetting;\n  ssm.pad = 0;\n  if (SupportsClient2Server(client, rfbSetScale)) {\n      ssm.type = rfbSetScale;\n      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))\n          return FALSE;\n  }\n  if (SupportsClient2Server(client, rfbPalmVNCSetScaleFactor)) {\n      ssm.type = rfbPalmVNCSetScaleFactor;\n      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))\n          return FALSE;\n  }\n  return TRUE;\n}", "target": 0}
{"code": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n  req.body.assign(body, content_length);\n  return send_(std::move(req));\n}", "target": 1}
{"code": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tif (!timr->it_interval)\n\t\treturn;\n\ttimr->it_overrun += (unsigned int) hrtimer_forward(timer,\n\t\t\t\t\t\ttimer->base->get_time(),\n\t\t\t\t\t\ttimr->it_interval);\n\thrtimer_restart(timer);\n}", "target": 1}
{"code": "static Variant HHVM_FUNCTION(simplexml_import_dom,\n  const Object& node,\n  const String& class_name ) {\n  auto domnode = Native::data<DOMNode>(node);\n  xmlNodePtr nodep = domnode->nodep();\n  if (nodep) {\n    if (nodep->doc == nullptr) {\n      raise_warning(\"Imported Node must have associated Document\");\n      return init_null();\n    }\n    if (nodep->type == XML_DOCUMENT_NODE ||\n        nodep->type == XML_HTML_DOCUMENT_NODE) {\n      nodep = xmlDocGetRootElement((xmlDocPtr) nodep);\n    }\n  }\n  if (nodep && nodep->type == XML_ELEMENT_NODE) {\n    auto cls = class_from_name(class_name, \"simplexml_import_dom\");\n    if (!cls) {\n      return init_null();\n    }\n    Object obj = create_object(cls->nameStr(), Array(), false);\n    auto sxe = Native::data<SimpleXMLElement>(obj.get());\n    sxe->node = libxml_register_node(nodep);\n    return obj;\n  } else {\n    raise_warning(\"Invalid Nodetype to import\");\n    return init_null();\n  }\n  return false;\n}", "target": 1}
{"code": "int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max)\n{\n    int i, j, k = 0;\n    BN_ULONG mask;\n    if (BN_is_zero(a))\n        return 0;\n    for (i = a->top - 1; i >= 0; i--) {\n        if (!a->d[i])\n            continue;\n        mask = BN_TBIT;\n        for (j = BN_BITS2 - 1; j >= 0; j--) {\n            if (a->d[i] & mask) {\n                if (k < max)\n                    p[k] = BN_BITS2 * i + j;\n                k++;\n            }\n            mask >>= 1;\n        }\n    }\n    if (k < max) {\n        p[k] = -1;\n        k++;\n    }\n    return k;\n}", "target": 1}
{"code": "int mp_invmod_mont_ct (mp_int * a, mp_int * b, mp_int * c, mp_digit mp)\n{\n  return fp_invmod_mont_ct(a, b, c, mp);\n}", "target": 0}
{"code": "static struct mb2_cache_entry *__entry_find(struct mb2_cache *cache,\n\t\t\t\t\t    struct mb2_cache_entry *entry,\n\t\t\t\t\t    u32 key)\n{\n\tstruct mb2_cache_entry *old_entry = entry;\n\tstruct hlist_bl_node *node;\n\tstruct hlist_bl_head *head;\n\tif (entry)\n\t\thead = entry->e_hash_list_head;\n\telse\n\t\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\thlist_bl_lock(head);\n\tif (entry && !hlist_bl_unhashed(&entry->e_hash_list))\n\t\tnode = entry->e_hash_list.next;\n\telse\n\t\tnode = hlist_bl_first(head);\n\twhile (node) {\n\t\tentry = hlist_bl_entry(node, struct mb2_cache_entry,\n\t\t\t\t       e_hash_list);\n\t\tif (entry->e_key == key) {\n\t\t\tatomic_inc(&entry->e_refcnt);\n\t\t\tgoto out;\n\t\t}\n\t\tnode = node->next;\n\t}\n\tentry = NULL;\nout:\n\thlist_bl_unlock(head);\n\tif (old_entry)\n\t\tmb2_cache_entry_put(cache, old_entry);\n\treturn entry;\n}", "target": 0}
{"code": "void j2k_dump (opj_j2k_t* p_j2k, OPJ_INT32 flag, FILE* out_stream)\n{\n        if ( (flag & OPJ_JP2_INFO) || (flag & OPJ_JP2_IND)){\n                fprintf(out_stream, \"Wrong flag\\n\");\n                return;\n        }\n        if (flag & OPJ_IMG_INFO){\n                if (p_j2k->m_private_image)\n                        j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);\n        }\n        if (flag & OPJ_J2K_MH_INFO){\n                opj_j2k_dump_MH_info(p_j2k, out_stream);\n        }\n        if (flag & OPJ_J2K_TCH_INFO){\n          OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;\n          OPJ_UINT32 i;\n          opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;\n          for (i=0;i<l_nb_tiles;++i) {\n            opj_j2k_dump_tile_info( l_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);\n            ++l_tcp;\n          }\n        }\n        if (flag & OPJ_J2K_TH_INFO){\n        }\n        if (flag & OPJ_J2K_MH_IND){\n                opj_j2k_dump_MH_index(p_j2k, out_stream);\n        }\n        if (flag & OPJ_J2K_TH_IND){\n        }\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_assert(pj_cis_match(spec,0)==0);\n    if (!pj_cis_match(spec, *s)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    do {\n\t++s;\n    } while (pj_cis_match(spec, *s));\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}", "target": 1}
{"code": "static void prefetch_table(const volatile byte *tab, size_t len)\n{\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)tab[i + 0 * 32];\n      (void)tab[i + 1 * 32];\n      (void)tab[i + 2 * 32];\n      (void)tab[i + 3 * 32];\n      (void)tab[i + 4 * 32];\n      (void)tab[i + 5 * 32];\n      (void)tab[i + 6 * 32];\n      (void)tab[i + 7 * 32];\n    }\n  (void)tab[len - 1];\n}", "target": 1}
{"code": "mem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\tif (log_op)\n\t\tfclose(log_op);\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen(log_name, \"a\");\n\tif (log_op == NULL) {\n\t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n\t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\t\tsetlinebuf(log_op);\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\tfree(log_name);\n\tterminate_banner = banner;\n}", "target": 1}
{"code": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\treturn do_send_specific(tgid, pid, sig, &info);\n}", "target": 1}
{"code": "static int orinoco_ioctl_setrate(struct net_device *dev,\n\t\t\t\t struct iw_request_info *info,\n\t\t\t\t struct iw_param *rrq,\n\t\t\t\t char *extra)\n{\n\tstruct orinoco_private *priv = ndev_priv(dev);\n\tint ratemode;\n\tint bitrate; \n\tunsigned long flags;\n\tif (rrq->value == -1)\n\t\tbitrate = 110;\n\telse {\n\t\tif (rrq->value % 100000)\n\t\t\treturn -EINVAL;\n\t\tbitrate = rrq->value / 100000;\n\t}\n\tratemode = orinoco_get_bitratemode(bitrate, !rrq->fixed);\n\tif (ratemode == -1)\n\t\treturn -EINVAL;\n\tif (orinoco_lock(priv, &flags) != 0)\n\t\treturn -EBUSY;\n\tpriv->bitratemode = ratemode;\n\torinoco_unlock(priv, &flags);\n\treturn -EINPROGRESS;\n}", "target": 0}
{"code": "void main_cleanup() {\n#ifdef USE_OS_THREADS\n    CLI *c;\n    unsigned i, threads;\n    THREAD_ID *thread_list;\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_THREAD_LIST]);\n    threads=0;\n    for(c=thread_head; c; c=c->thread_next) \n        threads++;\n    thread_list=str_alloc((threads+1)*sizeof(THREAD_ID));\n    i=0;\n    for(c=thread_head; c; c=c->thread_next) { \n        thread_list[i++]=c->thread_id;\n        s_log(LOG_DEBUG, \"Terminating a thread for [%s]\", c->opt->servname);\n    }\n    if(cron_thread_id) { \n        thread_list[threads++]=cron_thread_id;\n        s_log(LOG_DEBUG, \"Terminating the cron thread\");\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_THREAD_LIST]);\n    if(threads) {\n        s_log(LOG_NOTICE, \"Terminating %u service thread(s)\", threads);\n        writesocket(terminate_pipe[1], \"\", 1);\n        for(i=0; i<threads; ++i) { \n#ifdef USE_PTHREAD\n            if(pthread_join(thread_list[i], NULL))\n                s_log(LOG_ERR, \"pthread_join() failed\");\n#endif\n#ifdef USE_WIN32\n            if(WaitForSingleObject(thread_list[i], INFINITE)==WAIT_FAILED)\n                ioerror(\"WaitForSingleObject\");\n            if(!CloseHandle(thread_list[i]))\n                ioerror(\"CloseHandle\");\n#endif\n        }\n        s_log(LOG_NOTICE, \"Service threads terminated\");\n    }\n    str_free(thread_list);\n#endif \n    unbind_ports();\n    s_poll_free(fds);\n    fds=NULL;\n#if 0\n    str_stats(); \n#endif\n    log_flush(LOG_MODE_ERROR);\n    log_close(SINK_SYSLOG|SINK_OUTFILE);\n}", "target": 1}
{"code": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\treturn task;\n}", "target": 1}
{"code": "static void fio_signal_handler_setup(void) {\n  struct sigaction act;\n  if (fio_old_sig_int.sa_handler)\n    return;\n  memset(&act, 0, sizeof(act));\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}", "target": 1}
{"code": "monitor_valid_hostbasedblob(u_char *data, u_int datalen, char *cuser,\n    char *chost)\n{\n\tBuffer b;\n\tchar *p;\n\tu_int len;\n\tint fail = 0;\n\tbuffer_init(&b);\n\tbuffer_append(&b, data, datalen);\n\tp = buffer_get_string(&b, &len);\n\tif ((session_id2 == NULL) ||\n\t    (len != session_id2_len) ||\n\t    (memcmp(p, session_id2, session_id2_len) != 0))\n\t\tfail++;\n\txfree(p);\n\tif (buffer_get_char(&b) != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tp = buffer_get_string(&b, NULL);\n\tif (strcmp(authctxt->user, p) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: expected %s != %.100s\",\n\t\t    authctxt->user, p);\n\t\tfail++;\n\t}\n\txfree(p);\n\tbuffer_skip_string(&b);\t\n\tp = buffer_get_string(&b, NULL);\n\tif (strcmp(p, \"hostbased\") != 0)\n\t\tfail++;\n\txfree(p);\n\tbuffer_skip_string(&b);\t\n\tbuffer_skip_string(&b);\t\n\tp = buffer_get_string(&b, NULL);\n\tif (((len = strlen(p)) > 0) && p[len - 1] == '.')\n\t\tp[len - 1] = '\\0';\n\tif (strcmp(p, chost) != 0)\n\t\tfail++;\n\txfree(p);\n\tp = buffer_get_string(&b, NULL);\n\tif (strcmp(p, cuser) != 0)\n\t\tfail++;\n\txfree(p);\n\tif (buffer_len(&b) != 0)\n\t\tfail++;\n\tbuffer_free(&b);\n\treturn (fail == 0);\n}", "target": 0}
{"code": "void fput(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tfile_sb_list_del(file);\n\t\tif (likely(!in_interrupt() && !(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&file->f_u.fu_rcuhead, ____fput);\n\t\t\tif (!task_work_add(task, &file->f_u.fu_rcuhead, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&file->f_u.fu_llist, &delayed_fput_list))\n\t\t\tschedule_work(&delayed_fput_work);\n\t}\n}", "target": 1}
{"code": "CodingReturnValue LeptonCodec::ThreadState::vp8_decode_thread(unsigned int thread_id,\n                                                              UncompressedComponents *const colldata) {\n    Sirikata::Array1d<uint32_t, (uint32_t)ColorChannel::NumBlockTypes> component_size_in_blocks;\n    BlockBasedImagePerChannel<false> image_data;\n    for (int i = 0; i < colldata->get_num_components(); ++i) {\n        component_size_in_blocks[i] = colldata->component_size_in_blocks(i);\n        image_data[i] = &colldata->full_component_write((BlockType)i);\n    }\n    Sirikata::Array1d<uint32_t,\n                      (size_t)ColorChannel::NumBlockTypes> max_coded_heights\n        = colldata->get_max_coded_heights();\n    dev_assert(luma_splits_.size() == 2); \n    always_assert(luma_splits_.size() >= 2);\n    int min_y = luma_splits_[0];\n    int max_y = luma_splits_[1];\n    while(true) {\n        RowSpec cur_row = row_spec_from_index(decode_index_++, image_data, colldata->get_mcu_count_vertical(), max_coded_heights);\n        if (cur_row.done) {\n            break;\n        }\n        if (cur_row.luma_y >= max_y && thread_id + 1 != NUM_THREADS) {\n            break;\n        }\n        if (cur_row.skip) {\n            continue;\n        }\n        if (cur_row.luma_y < min_y) {\n            continue;\n        }\n        decode_rowf(image_data,\n                   component_size_in_blocks,\n                   cur_row.component,\n                   cur_row.curr_y);\n        if (thread_id == 0) {\n            colldata->worker_update_cmp_progress((BlockType)cur_row.component,\n                                                 image_data[cur_row.component]->block_width() );\n        }\n        return CODING_PARTIAL;\n    }\n    return CODING_DONE;\n}", "target": 0}
{"code": "void ArcMemory::Load(const byte *Data,size_t Size)\n{\n  ArcData.Alloc(Size);\n  memcpy(&ArcData[0],Data,Size);\n  Loaded=true;\n  SeekPos=0;\n}", "target": 0}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}", "target": 1}
{"code": "pci_set_cfgdata32(struct pci_vdev *dev, int offset, uint32_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\t*(uint32_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "Suite *cjose_jwe_suite()\n{\n    Suite *suite = suite_create(\"jwe\");\n    TCase *tc_jwe = tcase_create(\"core\");\n    tcase_set_timeout(tc_jwe, 120.0);\n    tcase_add_test(tc_jwe, test_cjose_jwe_node_jose_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_iv);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_short);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_empty);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_large);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_many);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes_gcm);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_rsa);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_header);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_key);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_content);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_export_compare);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_invalid_serialization);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_bad_params);\n    tcase_add_test(tc_jwe, test_cjose_jwe_multiple_recipients);\n    suite_add_tcase(suite, tc_jwe);\n    return suite;\n}", "target": 0}
{"code": "static int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}", "target": 1}
{"code": "push_tag(struct readbuffer *obuf, char *cmdname, int cmd)\n{\n    obuf->tag_stack[obuf->tag_sp] = New(struct cmdtable);\n    obuf->tag_stack[obuf->tag_sp]->cmdname = allocStr(cmdname, -1);\n    obuf->tag_stack[obuf->tag_sp]->cmd = cmd;\n    obuf->tag_sp++;\n    if (obuf->tag_sp >= TAG_STACK_SIZE || obuf->flag & (RB_SPECIAL & ~RB_NOBR))\n\tappend_tags(obuf);\n}", "target": 0}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}", "target": 0}
{"code": "vg_ctrl_response(VuGpu *g,\n                 struct virtio_gpu_ctrl_command *cmd,\n                 struct virtio_gpu_ctrl_hdr *resp,\n                 size_t resp_len)\n{\n    size_t s;\n    if (cmd->cmd_hdr.flags & VIRTIO_GPU_FLAG_FENCE) {\n        resp->flags |= VIRTIO_GPU_FLAG_FENCE;\n        resp->fence_id = cmd->cmd_hdr.fence_id;\n        resp->ctx_id = cmd->cmd_hdr.ctx_id;\n    }\n    virtio_gpu_ctrl_hdr_bswap(resp);\n    s = iov_from_buf(cmd->elem.in_sg, cmd->elem.in_num, 0, resp, resp_len);\n    if (s != resp_len) {\n        g_critical(\"%s: response size incorrect %zu vs %zu\",\n                   __func__, s, resp_len);\n    }\n    vu_queue_push(&g->dev.parent, cmd->vq, &cmd->elem, s);\n    vu_queue_notify(&g->dev.parent, cmd->vq);\n    cmd->state = VG_CMD_STATE_FINISHED;\n}", "target": 0}
{"code": "static GF_SampleGroupDescriptionBox *get_sgdp(GF_SampleTableBox *stbl, void *traf, u32 grouping_type, Bool *is_traf_sgdp)\n#endif \n{\n\tGF_List *groupList=NULL;\n\tGF_List **parent=NULL;\n\tGF_SampleGroupDescriptionBox *sgdesc=NULL;\n\tu32 count, i;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!stbl && traf && traf->trex->track->Media->information->sampleTable)\n\t\tstbl = traf->trex->track->Media->information->sampleTable;\n#endif\n\tif (stbl) {\n\t\tif (!stbl->sampleGroupsDescription && !traf)\n\t\t\tstbl->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = stbl->sampleGroupsDescription;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_FALSE;\n\t\tparent = &stbl->child_boxes;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tif (!sgdesc && traf) {\n\t\tif (!traf->sampleGroupsDescription)\n\t\t\ttraf->sampleGroupsDescription = gf_list_new();\n\t\tgroupList = traf->sampleGroupsDescription;\n\t\tparent = &traf->child_boxes;\n\t\tif (is_traf_sgdp) *is_traf_sgdp = GF_TRUE;\n\t\tcount = gf_list_count(groupList);\n\t\tfor (i=0; i<count; i++) {\n\t\t\tsgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(groupList, i);\n\t\t\tif (sgdesc->grouping_type==grouping_type) break;\n\t\t\tsgdesc = NULL;\n\t\t}\n\t}\n#endif\n\tif (!sgdesc) {\n\t\tsgdesc = (GF_SampleGroupDescriptionBox *) gf_isom_box_new_parent(parent, GF_ISOM_BOX_TYPE_SGPD);\n\t\tif (!sgdesc) return NULL;\n\t\tsgdesc->grouping_type = grouping_type;\n\t\tassert(groupList);\n\t\tgf_list_add(groupList, sgdesc);\n\t}\n\treturn sgdesc;\n}", "target": 1}
{"code": "hb_set_intersect (hb_set_t       *set,\n\t\t  const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->intersect (*other);\n}", "target": 1}
{"code": "int hns_ppe_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ETH_PPE_STATIC_NUM;\n\treturn 0;\n}", "target": 1}
{"code": "get_manuf_name(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    manuf_value = manuf_name_lookup(addr);\n    if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)\n        return manuf_value->resolved_name;\n    return manuf_value->hexaddr;\n} ", "target": 1}
{"code": "nvkm_vmm_node_merge(struct nvkm_vmm *vmm, struct nvkm_vma *prev,\n\t\t    struct nvkm_vma *vma, struct nvkm_vma *next, u64 size)\n{\n\tif (next) {\n\t\tif (vma->size == size) {\n\t\t\tvma->size += next->size;\n\t\t\tnvkm_vmm_node_delete(vmm, next);\n\t\t\tif (prev) {\n\t\t\t\tprev->size += vma->size;\n\t\t\t\tnvkm_vmm_node_delete(vmm, vma);\n\t\t\t\treturn prev;\n\t\t\t}\n\t\t\treturn vma;\n\t\t}\n\t\tBUG_ON(prev);\n\t\tnvkm_vmm_node_remove(vmm, next);\n\t\tvma->size -= size;\n\t\tnext->addr -= size;\n\t\tnext->size += size;\n\t\tnvkm_vmm_node_insert(vmm, next);\n\t\treturn next;\n\t}\n\tif (prev) {\n\t\tif (vma->size != size) {\n\t\t\tnvkm_vmm_node_remove(vmm, vma);\n\t\t\tprev->size += size;\n\t\t\tvma->addr += size;\n\t\t\tvma->size -= size;\n\t\t\tnvkm_vmm_node_insert(vmm, vma);\n\t\t} else {\n\t\t\tprev->size += vma->size;\n\t\t\tnvkm_vmm_node_delete(vmm, vma);\n\t\t}\n\t\treturn prev;\n\t}\n\treturn vma;\n}", "target": 0}
{"code": "int db__close(void)\n{\n\tsubhier_clean(&db.subs);\n\tretain__clean(&db.retains);\n\tdb__msg_store_clean();\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n    for (i = 0; argv[i]; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n    if (ogs_app()->parameter.no_nrf == 0)\n        nrf_thread = test_child_create(\"nrf\", argv_out);\n    if (ogs_app()->parameter.no_scp == 0)\n        scp_thread = test_child_create(\"scp\", argv_out);\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_amf == 0)\n        amf_thread = test_child_create(\"amf\", argv_out);\n    if (ogs_app()->parameter.no_ausf == 0)\n        ausf_thread = test_child_create(\"ausf\", argv_out);\n    if (ogs_app()->parameter.no_udm == 0)\n        udm_thread = test_child_create(\"udm\", argv_out);\n    if (ogs_app()->parameter.no_pcf == 0)\n        pcf_thread = test_child_create(\"pcf\", argv_out);\n    if (ogs_app()->parameter.no_nssf == 0)\n        nssf_thread = test_child_create(\"nssf\", argv_out);\n    if (ogs_app()->parameter.no_bsf == 0)\n        bsf_thread = test_child_create(\"bsf\", argv_out);\n    if (ogs_app()->parameter.no_udr == 0)\n        udr_thread = test_child_create(\"udr\", argv_out);\n    ogs_msleep(300);\n    return OGS_OK;;\n}", "target": 1}
{"code": "static void kvm_pv_disable_apf(void)\n{\n\tif (!__this_cpu_read(apf_reason.enabled))\n\t\treturn;\n\twrmsrl(MSR_KVM_ASYNC_PF_EN, 0);\n\t__this_cpu_write(apf_reason.enabled, 0);\n\tprintk(KERN_INFO\"Unregister pv shared memory for cpu %d\\n\",\n\t       smp_processor_id());\n}", "target": 0}
{"code": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\treturn ptr;\n}", "target": 1}
{"code": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n\trefcount_set(&net->count, 1);\n\trefcount_set(&net->passive, 1);\n\tget_random_bytes(&net->hash_mix, sizeof(u32));\n\tnet->dev_base_seq = 1;\n\tnet->user_ns = user_ns;\n\tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\nout_undo:\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\trcu_barrier();\n\tgoto out;\n}", "target": 0}
{"code": "void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 1}
{"code": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n{\n\tstruct sk_buff *skb;\n\tstruct frag_hdr fhdr;\n\tint err;\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->csum = 0;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\tipv6_select_ident(&fhdr, rt);\n\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}", "target": 0}
{"code": "static int tipc_nl_compat_media_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t     struct nlattr **attrs)\n{\n\tstruct nlattr *media[TIPC_NLA_MEDIA_MAX + 1];\n\tint err;\n\tif (!attrs[TIPC_NLA_MEDIA])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(media, TIPC_NLA_MEDIA_MAX, attrs[TIPC_NLA_MEDIA],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_MEDIA_NAME,\n\t\t\t    nla_data(media[TIPC_NLA_MEDIA_NAME]),\n\t\t\t    nla_len(media[TIPC_NLA_MEDIA_NAME]));\n}", "target": 0}
{"code": "static void spl_array_update_pos(spl_array_object* intern) \n{\n\tBucket *pos = intern->pos;\n\tif (pos != NULL) {\n\t\tintern->pos_h = pos->h;\n\t}\n} ", "target": 0}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  register int rindex = rgb_red[cinfo->in_color_space];\n  register int gindex = rgb_green[cinfo->in_color_space];\n  register int bindex = rgb_blue[cinfo->in_color_space];\n  register int aindex = alpha_index[cinfo->in_color_space];\n  register int ps = rgb_pixelsize[cinfo->in_color_space];\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[rindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[gindex] = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    ptr[bindex] = rescale[temp];\n    if (aindex >= 0)\n      ptr[aindex] = 0xFF;\n    ptr += ps;\n  }\n  return 1;\n}", "target": 0}
{"code": "static int php_curl_option_url(php_curl *ch, const char *url, const int len) \n{\n\tif (PG(open_basedir) && *PG(open_basedir)) {\n#if LIBCURL_VERSION_NUM >= 0x071304\n\t\tcurl_easy_setopt(ch->cp, CURLOPT_PROTOCOLS, CURLPROTO_ALL & ~CURLPROTO_FILE);\n#else\n\t\tphp_url *uri;\n\t\tif (!(uri = php_url_parse_ex(url, len))) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Invalid URL '%s'\", url);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (uri->scheme && !strncasecmp(\"file\", uri->scheme, sizeof(\"file\"))) {\n\t\t\tphp_error_docref(NULL, E_WARNING, \"Protocol 'file' disabled in cURL\");\n\t\t\tphp_url_free(uri);\n\t\t\treturn FAILURE;\n\t\t}\n\t\tphp_url_free(uri);\n#endif\n\t}\n\treturn php_curl_option_str(ch, CURLOPT_URL, url, len, 0);\n}", "target": 0}
{"code": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu64 seq;\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = net_secret[15];\n\tmd5_transform(hash, net_secret);\n\tseq = hash[0] | (((u64)hash[1]) << 32);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 0}
{"code": "backref_match_at_nested_level(regex_t* reg,\n                              StackType* top, StackType* stk_base,\n                              int ignore_case, int case_fold_flag,\n                              int nest, int mem_num, MemNumType* memp,\n                              UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  StackType* k;\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pstart = k->u.mem.pstr;\n          if (IS_NOT_NULL(pend)) {\n            if (pend - pstart > send - *s) return 0; \n            p  = pstart;\n            ss = *s;\n            if (ignore_case != 0) {\n              if (string_cmp_ic(reg->enc, case_fold_flag,\n                                pstart, &ss, (int )(pend - pstart)) == 0)\n                return 0; \n            }\n            else {\n              while (p < pend) {\n                if (*p++ != *ss++) return 0; \n              }\n            }\n            *s = ss;\n            return 1;\n          }\n        }\n      }\n      else if (k->type == STK_MEM_END) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pend = k->u.mem.pstr;\n        }\n      }\n    }\n    k--;\n  }\n  return 0;\n}", "target": 0}
{"code": "static int on_security_message(struct nvnc_client* client)\n{\n\tif (client->buffer_len - client->buffer_index < 1)\n\t\treturn 0;\n\tuint8_t type = client->msg_buffer[client->buffer_index];\n\tnvnc_log(NVNC_LOG_DEBUG, \"Client chose security type: %d\", type);\n\tif (!is_allowed_security_type(client->server, type)) {\n\t\tsecurity_handshake_failed(client, NULL, \"Illegal security type\");\n\t\treturn sizeof(type);\n\t}\n\tswitch (type) {\n\tcase RFB_SECURITY_TYPE_NONE:\n\t\tsecurity_handshake_ok(client, NULL);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_INIT;\n\t\tbreak;\n#ifdef ENABLE_TLS\n\tcase RFB_SECURITY_TYPE_VENCRYPT:\n\t\tvencrypt_send_version(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_VENCRYPT_VERSION;\n\t\tbreak;\n#endif\n#ifdef HAVE_CRYPTO\n\tcase RFB_SECURITY_TYPE_APPLE_DH:\n\t\tapple_dh_send_public_key(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_APPLE_DH_RESPONSE;\n\t\tbreak;\n\tcase RFB_SECURITY_TYPE_RSA_AES:\n\t\tclient->rsa.hash_type = CRYPTO_HASH_SHA1;\n\t\tclient->rsa.cipher_type = CRYPTO_CIPHER_AES_EAX;\n\t\tclient->rsa.challenge_len = 16;\n\t\trsa_aes_send_public_key(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_RSA_AES_PUBLIC_KEY;\n\t\tbreak;\n\tcase RFB_SECURITY_TYPE_RSA_AES256:\n\t\tclient->rsa.hash_type = CRYPTO_HASH_SHA256;\n\t\tclient->rsa.cipher_type = CRYPTO_CIPHER_AES256_EAX;\n\t\tclient->rsa.challenge_len = 32;\n\t\trsa_aes_send_public_key(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_RSA_AES_PUBLIC_KEY;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tsecurity_handshake_failed(client, NULL,\n\t\t\t\t\"Unsupported security type\");\n\t\tbreak;\n\t}\n\treturn sizeof(type);\n}", "target": 0}
{"code": "\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\tset_current_state(TASK_TRACED);\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\ttask_clear_jobctl_trapping(current);\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\trecalc_sigpending_tsk(current);\n}", "target": 0}
{"code": "static int stv06xx_isoc_init(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\talt->endpoint[0].desc.wMaxPacketSize =\n\t\tcpu_to_le16(sd->sensor->max_packet_size[gspca_dev->curr_mode]);\n\treturn 0;\n}", "target": 1}
{"code": "void file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tif (likely(!(file->f_mode & FMODE_WRITE)))\n\t\treturn;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\treturn;\n\tlg_local_lock(&files_lglock);\n\t__file_sb_list_add(file, sb);\n\tlg_local_unlock(&files_lglock);\n}", "target": 1}
{"code": "static void RemoveResolutionFromResourceBlock(StringInfo *bim_profile)\n{\n  register const unsigned char\n    *p;\n  size_t\n    length;\n  unsigned char\n    *datum;\n  unsigned int\n    count,\n    long_sans;\n  unsigned short\n    id,\n    short_sans;\n  length=GetStringInfoLength(bim_profile);\n  if (length < 16)\n    return;\n  datum=GetStringInfoDatum(bim_profile);\n  for (p=datum; (p >= datum) && (p < (datum+length-16)); )\n  {\n    register unsigned char\n      *q;\n    q=(unsigned char *) p;\n    if (LocaleNCompare((const char *) p,\"8BIM\",4) != 0)\n      break;\n    p=PushLongPixel(MSBEndian,p,&long_sans);\n    p=PushShortPixel(MSBEndian,p,&id);\n    p=PushShortPixel(MSBEndian,p,&short_sans);\n    p=PushLongPixel(MSBEndian,p,&count);\n    if ((id == 0x000003ed) && (PSDQuantum(count) < (ssize_t) (length-12)))\n      {\n        (void) CopyMagickMemory(q,q+PSDQuantum(count)+12,length-\n          (PSDQuantum(count)+12)-(q-datum));\n        SetStringInfoLength(bim_profile,length-(PSDQuantum(count)+12));\n        break;\n      }\n    p+=count;\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}", "target": 1}
{"code": "int ossl_policy_cache_set_mapping(X509 *x, POLICY_MAPPINGS *maps)\n{\n    POLICY_MAPPING *map;\n    X509_POLICY_DATA *data;\n    X509_POLICY_CACHE *cache = x->policy_cache;\n    int i;\n    int ret = 0;\n    if (sk_POLICY_MAPPING_num(maps) == 0) {\n        ret = -1;\n        goto bad_mapping;\n    }\n    for (i = 0; i < sk_POLICY_MAPPING_num(maps); i++) {\n        map = sk_POLICY_MAPPING_value(maps, i);\n        if ((OBJ_obj2nid(map->subjectDomainPolicy) == NID_any_policy)\n            || (OBJ_obj2nid(map->issuerDomainPolicy) == NID_any_policy)) {\n            ret = -1;\n            goto bad_mapping;\n        }\n        data = ossl_policy_cache_find_data(cache, map->issuerDomainPolicy);\n        if (data == NULL && !cache->anyPolicy)\n            continue;\n        if (data == NULL) {\n            data = ossl_policy_data_new(NULL, map->issuerDomainPolicy,\n                                        cache->anyPolicy->flags\n                                        & POLICY_DATA_FLAG_CRITICAL);\n            if (data == NULL)\n                goto bad_mapping;\n            data->qualifier_set = cache->anyPolicy->qualifier_set;\n            data->flags |= POLICY_DATA_FLAG_MAPPED_ANY;\n            data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n            if (!sk_X509_POLICY_DATA_push(cache->data, data)) {\n                ossl_policy_data_free(data);\n                goto bad_mapping;\n            }\n        } else\n            data->flags |= POLICY_DATA_FLAG_MAPPED;\n        if (!sk_ASN1_OBJECT_push(data->expected_policy_set,\n                                 map->subjectDomainPolicy))\n            goto bad_mapping;\n        map->subjectDomainPolicy = NULL;\n    }\n    ret = 1;\n bad_mapping:\n    if (ret == -1 && CRYPTO_THREAD_write_lock(x->lock)) {\n        x->ex_flags |= EXFLAG_INVALID_POLICY;\n        CRYPTO_THREAD_unlock(x->lock);\n    }\n    sk_POLICY_MAPPING_pop_free(maps, POLICY_MAPPING_free);\n    return ret;\n}", "target": 1}
{"code": "int fp_invmod_mont_ct(fp_int *a, fp_int *b, fp_int *c, fp_digit mp)\n{\n  int i, j;\n#ifndef WOLFSSL_SMALL_STACK\n  fp_int t[1], e[1];\n  fp_int pre[CT_INV_MOD_PRE_CNT];\n#else\n  fp_int* t;\n  fp_int* e;\n  fp_int* pre;\n#endif\n#ifdef WOLFSSL_SMALL_STACK\n  t = (fp_int*)XMALLOC(sizeof(fp_int) * (2 + CT_INV_MOD_PRE_CNT), NULL,\n                                                           DYNAMIC_TYPE_BIGINT);\n  if (t == NULL)\n    return FP_MEM;\n  e = t + 1;\n  pre = t + 2;\n#endif\n  fp_init(t);\n  fp_init(e);\n  fp_init(&pre[0]);\n  fp_copy(a, &pre[0]);\n  for (i = 1; i < CT_INV_MOD_PRE_CNT; i++) {\n    fp_init(&pre[i]);\n    fp_sqr(&pre[i-1], &pre[i]);\n    fp_montgomery_reduce(&pre[i], b, mp);\n    fp_mul(&pre[i], a, &pre[i]);\n    fp_montgomery_reduce(&pre[i], b, mp);\n  }\n  fp_sub_d(b, 2, e);\n  for (i = fp_count_bits(e)-2, j = 1; i >= 0; i--, j++) {\n      if (!fp_is_bit_set(e, i) || j == CT_INV_MOD_PRE_CNT)\n          break;\n  }\n  fp_copy(&pre[j-1], t);\n  for (j = 0; i >= 0; i--) {\n    int set = fp_is_bit_set(e, i);\n    if ((j == CT_INV_MOD_PRE_CNT) || (!set && j > 0)) {\n      fp_mul(t, &pre[j-1], t);\n      fp_montgomery_reduce(t, b, mp);\n      j = 0;\n    }\n    fp_sqr(t, t);\n    fp_montgomery_reduce(t, b, mp);\n    j += set;\n  }\n  if (j > 0) {\n    fp_mul(t, &pre[j-1], c);\n    fp_montgomery_reduce(c, b, mp);\n  }\n  else \n    fp_copy(t, c);\n#ifdef WOLFSSL_SMALL_STACK\n  XFREE(t, NULL, DYNAMIC_TYPE_BIGINT);\n#endif\n  return FP_OKAY;\n}", "target": 0}
{"code": "void rose_stop_idletimer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->idletimer);\n}", "target": 1}
{"code": "bqarr_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *buf = (char *) PG_GETARG_POINTER(0);\n\tWORKSTATE\tstate;\n\tint32\t\ti;\n\tQUERYTYPE  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n#ifdef BS_DEBUG\n\tStringInfoData pbuf;\n#endif\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"empty query\")));\n\tif (state.num > QUERYTYPEMAXITEMS)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\terrmsg(\"number of query items (%d) exceeds the maximum allowed (%d)\",\n\t\t\t   state.num, (int) QUERYTYPEMAXITEMS)));\n\tcommonlen = COMPUTESIZE(state.num);\n\tquery = (QUERYTYPE *) palloc(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = state.num;\n\tptr = GETQUERY(query);\n\tfor (i = state.num - 1; i >= 0; i--)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\tpos = query->size - 1;\n\tfindoprnd(ptr, &pos);\n#ifdef BS_DEBUG\n\tinitStringInfo(&pbuf);\n\tfor (i = 0; i < query->size; i++)\n\t{\n\t\tif (ptr[i].type == OPR)\n\t\t\tappendStringInfo(&pbuf, \"%c(%d) \", ptr[i].val, ptr[i].left);\n\t\telse\n\t\t\tappendStringInfo(&pbuf, \"%d \", ptr[i].val);\n\t}\n\telog(DEBUG3, \"POR: %s\", pbuf.data);\n\tpfree(pbuf.data);\n#endif\n\tPG_RETURN_POINTER(query);\n}", "target": 0}
{"code": "static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,\n                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn FALSE;\n\treturn ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),\n\t                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));\n}", "target": 1}
{"code": "static int open_handlers(void)\n{\n\tstruct dirent **dirent_list;\n\tint num_handlers;\n\tint num_good = 0;\n\tint i;\n\tnum_handlers = scandir(handler_path, &dirent_list, is_handler, alphasort);\n\tif (num_handlers == -1)\n\t\treturn -1;\n\tfor (i = 0; i < num_handlers; i++) {\n\t\tchar *path;\n\t\tvoid *handle;\n\t\tint (*handler_init)(void);\n\t\tint ret;\n\t\tret = asprintf(&path, \"%s/%s\", handler_path, dirent_list[i]->d_name);\n\t\tif (ret == -1) {\n\t\t\ttcmu_err(\"ENOMEM\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\thandle = dlopen(path, RTLD_NOW|RTLD_LOCAL);\n\t\tif (!handle) {\n\t\t\ttcmu_err(\"Could not open handler at %s: %s\\n\", path, dlerror());\n\t\t\tfree(path);\n\t\t\tcontinue;\n\t\t}\n\t\thandler_init = dlsym(handle, \"handler_init\");\n\t\tif (!handler_init) {\n\t\t\ttcmu_err(\"dlsym failure on %s\\n\", path);\n\t\t\tfree(path);\n\t\t\tcontinue;\n\t\t}\n\t\tret = handler_init();\n\t\tfree(path);\n\t\tif (ret == 0)\n\t\t\tnum_good++;\n\t}\n\tfor (i = 0; i < num_handlers; i++)\n\t\tfree(dirent_list[i]);\n\tfree(dirent_list);\n\treturn num_good;\n}", "target": 0}
{"code": "static void coroutine_fn v9fs_symlink(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsString name;\n    V9fsString symname;\n    V9fsFidState *dfidp;\n    V9fsQID qid;\n    struct stat stbuf;\n    int32_t dfid;\n    int err = 0;\n    gid_t gid;\n    size_t offset = 7;\n    v9fs_string_init(&name);\n    v9fs_string_init(&symname);\n    err = pdu_unmarshal(pdu, offset, \"dssd\", &dfid, &name, &symname, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_symlink(pdu->tag, pdu->id, dfid, name.data, symname.data, gid);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    err = v9fs_co_symlink(pdu, dfidp, &name, symname.data, gid, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_qid(pdu, &stbuf, &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err =  pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_symlink_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n    v9fs_string_free(&symname);\n}", "target": 0}
{"code": "static BOOL update_read_bitmap_data(rdpUpdate* update, wStream* s, BITMAP_DATA* bitmapData)\n{\n\tWINPR_UNUSED(update);\n\tif (Stream_GetRemainingLength(s) < 18)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, bitmapData->destLeft);\n\tStream_Read_UINT16(s, bitmapData->destTop);\n\tStream_Read_UINT16(s, bitmapData->destRight);\n\tStream_Read_UINT16(s, bitmapData->destBottom);\n\tStream_Read_UINT16(s, bitmapData->width);\n\tStream_Read_UINT16(s, bitmapData->height);\n\tStream_Read_UINT16(s, bitmapData->bitsPerPixel);\n\tStream_Read_UINT16(s, bitmapData->flags);\n\tStream_Read_UINT16(s, bitmapData->bitmapLength);\n\tif (bitmapData->flags & BITMAP_COMPRESSION)\n\t{\n\t\tif (!(bitmapData->flags & NO_BITMAP_COMPRESSION_HDR))\n\t\t{\n\t\t\tif (Stream_GetRemainingLength(s) < 8)\n\t\t\t\treturn FALSE;\n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompFirstRowSize); \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbCompMainBodySize); \n\t\t\tStream_Read_UINT16(s, bitmapData->cbScanWidth);     \n\t\t\tStream_Read_UINT16(s,\n\t\t\t                   bitmapData->cbUncompressedSize); \n\t\t\tbitmapData->bitmapLength = bitmapData->cbCompMainBodySize;\n\t\t}\n\t\tbitmapData->compressed = TRUE;\n\t}\n\telse\n\t\tbitmapData->compressed = FALSE;\n\tif (Stream_GetRemainingLength(s) < bitmapData->bitmapLength)\n\t\treturn FALSE;\n\tif (bitmapData->bitmapLength > 0)\n\t{\n\t\tbitmapData->bitmapDataStream = malloc(bitmapData->bitmapLength);\n\t\tif (!bitmapData->bitmapDataStream)\n\t\t\treturn FALSE;\n\t\tmemcpy(bitmapData->bitmapDataStream, Stream_Pointer(s), bitmapData->bitmapLength);\n\t\tStream_Seek(s, bitmapData->bitmapLength);\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "static inline int mpeg4_get_dc_length(int level, int n)\n{\n    if (n < 4)\n        return uni_DCtab_lum_len[level + 256];\n    else\n        return uni_DCtab_chrom_len[level + 256];\n}", "target": 0}
{"code": "nfsd4_getattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getattr *getattr = &u->getattr;\n\t__be32 status;\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\tif (getattr->ga_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\tgetattr->ga_bmval[0] &= nfsd_suppattrs[cstate->minorversion][0];\n\tgetattr->ga_bmval[1] &= nfsd_suppattrs[cstate->minorversion][1];\n\tgetattr->ga_bmval[2] &= nfsd_suppattrs[cstate->minorversion][2];\n\tgetattr->ga_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}", "target": 0}
{"code": "context_parse_args (FlatpakContext *context,\n                    ...)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n  va_start (ap, context);\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n  va_end (ap);\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, &local_error);\n  g_assert_no_error (local_error);\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n}", "target": 1}
{"code": "static int ext4_dax_pfn_mkwrite(struct vm_area_struct *vma,\n\t\t\t\tstruct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tint ret = VM_FAULT_NOPAGE;\n\tloff_t size;\n\tsb_start_pagefault(sb);\n\tfile_update_time(vma->vm_file);\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size)\n\t\tret = VM_FAULT_SIGBUS;\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\tsb_end_pagefault(sb);\n\treturn ret;\n}", "target": 0}
{"code": "void slice_segment_header::set_defaults()\n{\n  slice_index = 0;\n  first_slice_segment_in_pic_flag = 1;\n  no_output_of_prior_pics_flag = 0;\n  slice_pic_parameter_set_id = 0;\n  dependent_slice_segment_flag = 0;\n  slice_segment_address = 0;\n  slice_type = SLICE_TYPE_I;\n  pic_output_flag = 1;\n  colour_plane_id = 0;\n  slice_pic_order_cnt_lsb = 0;\n  short_term_ref_pic_set_sps_flag = 1;\n  short_term_ref_pic_set_idx = 0;\n  num_long_term_sps = 0;\n  num_long_term_pics = 0;\n  slice_temporal_mvp_enabled_flag = 0;\n  slice_sao_luma_flag = 0;\n  slice_sao_chroma_flag = 0;\n  num_ref_idx_active_override_flag = 0;\n  num_ref_idx_l0_active=1; \n  num_ref_idx_l1_active=1; \n  ref_pic_list_modification_flag_l0 = 0;\n  ref_pic_list_modification_flag_l1 = 0;\n  mvd_l1_zero_flag = 0;\n  cabac_init_flag = 0;\n  collocated_from_l0_flag = 0;\n  collocated_ref_idx = 0;\n  luma_log2_weight_denom=0; \n  ChromaLog2WeightDenom=0;  \n  five_minus_max_num_merge_cand = 0;\n  slice_qp_delta = 0;\n  slice_cb_qp_offset = 0;\n  slice_cr_qp_offset = 0;\n  cu_chroma_qp_offset_enabled_flag = 0;\n  deblocking_filter_override_flag = 0;\n  slice_deblocking_filter_disabled_flag = 0;\n  slice_beta_offset=0; \n  slice_tc_offset=0;   \n  slice_loop_filter_across_slices_enabled_flag = 0;\n  num_entry_point_offsets = 0;\n  slice_segment_header_extension_length = 0;\n  SliceAddrRS = slice_segment_address;\n}", "target": 0}
{"code": "static void sas_resume_port(struct asd_sas_phy *phy)\n{\n\tstruct domain_device *dev;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt);\n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\tif (port->suspended)\n\t\tport->suspended = 0;\n\telse {\n\t\treturn;\n\t}\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tint i, rc;\n\t\trc = sas_notify_lldd_dev_found(dev);\n\t\tif (rc) {\n\t\t\tsas_unregister_dev(port, dev);\n\t\t\tsas_destruct_devices(port);\n\t\t\tcontinue;\n\t\t}\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tdev->ex_dev.ex_change_count = -1;\n\t\t\tfor (i = 0; i < dev->ex_dev.num_phys; i++) {\n\t\t\t\tstruct ex_phy *phy = &dev->ex_dev.ex_phy[i];\n\t\t\t\tphy->phy_change_count = -1;\n\t\t\t}\n\t\t}\n\t}\n\tsas_discover_event(port, DISCE_RESUME);\n}", "target": 0}
{"code": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn 0;\n}", "target": 1}
{"code": "atol10(const char *p, size_t char_cnt)\n{\n\tuint64_t l;\n\tint digit;\n\tif (char_cnt == 0)\n\t\treturn (0);\n\tl = 0;\n\tdigit = *p - '0';\n\twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {\n\t\tl = (l * 10) + digit;\n\t\tdigit = *++p - '0';\n\t}\n\treturn (l);\n}", "target": 0}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "static int restrictedFile(const char *filename)\n{\n\tif (!live_dangerously && !strncasecmp(filename, \"/\", 1) &&\n\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "gopherCachable(const HttpRequest * req)\n{\n    int cachable = 1;\n    char type_id;\n    gopher_request_parse(req,\n                         &type_id,\n                         nullptr);\n    switch (type_id) {\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        cachable = 0;\n        break;\n    default:\n        cachable = 1;\n    }\n    return cachable;\n}", "target": 1}
{"code": "eb_get_object(struct eb_objects *eb, unsigned long handle)\n{\n\tif (eb->and < 0) {\n\t\tif (handle >= -eb->and)\n\t\t\treturn NULL;\n\t\treturn eb->lut[handle];\n\t} else {\n\t\tstruct hlist_head *head;\n\t\tstruct hlist_node *node;\n\t\thead = &eb->buckets[handle & eb->and];\n\t\thlist_for_each(node, head) {\n\t\t\tstruct drm_i915_gem_object *obj;\n\t\t\tobj = hlist_entry(node, struct drm_i915_gem_object, exec_node);\n\t\t\tif (obj->exec_handle == handle)\n\t\t\t\treturn obj;\n\t\t}\n\t\treturn NULL;\n\t}\n}", "target": 0}
{"code": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }", "target": 1}
{"code": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnd->flags &= ~LOOKUP_PARENT;\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n\tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n\t\treturn 1;\n\tfollow_mount(path);\n\terror = 0;\nout:\n\tterminate_walk(nd);\n\treturn error;\n}", "target": 1}
{"code": "TEST_P(LocalJwksIntegrationTest, ConnectRequestWithRegExMatch) {\n  config_helper_.prependFilter(getAuthFilterConfig(ExampleConfigWithRegEx, true));\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"CONNECT\"},\n      {\":authority\", \"host.com:80\"},\n      {\"authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  if (downstreamProtocol() == Http::CodecType::HTTP1) {\n    ASSERT_TRUE(response->waitForEndStream());\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"404\", response->headers().getStatusValue());\n  } else {\n    ASSERT_TRUE(response->waitForReset());\n    ASSERT_TRUE(codec_client_->waitForDisconnect());\n  }\n}", "target": 0}
{"code": "int check_name(char *name, int size)\n{\n\tchar *start = name;\n\tif(name[0] == '.') {\n\t\tif(name[1] == '.')\n\t\t\tname++;\n\t\tif(name[1] == '/' || name[1] == '\\0')\n\t\t\treturn FALSE;\n\t}\n\twhile(name[0] != '/' && name[0] != '\\0')\n\t\tname ++;\n\tif(name[0] == '/')\n\t\treturn FALSE;\n\tif((name - start) != size)\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "CSecurityTLS::CSecurityTLS(bool _anon) : session(0), anon_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  cafile = X509CA.getData();\n  crlfile = X509CRL.getData();\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}", "target": 0}
{"code": "CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {\n  if (!callable) {\n    return false;\n  }\n  while (BoundFunction *b = dyn_vmcast<BoundFunction>(callable)) {\n    callable = b->getTarget(runtime);\n  }\n  if (auto *func = dyn_vmcast<JSFunction>(callable)) {\n    auto *cb = func->getCodeBlock(runtime);\n    cb->lazyCompile(runtime);\n    return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n        true);\n  }\n  if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {\n    return true;\n  }\n  if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {\n    return cproxy->isConstructor(runtime);\n  }\n  return false;\n}", "target": 1}
{"code": "u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,\n\t\t\t       __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + (__force u32) daddr[i];\n\tsecret[4] = net_secret[4] + (__force u32)dport;\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "static void check_serverpath(request_rec *r)\n{\n    server_rec *s;\n    server_rec *last_s;\n    name_chain *src;\n    apr_port_t port;\n    port = r->connection->local_addr->port;\n    last_s = NULL;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        if (src->sar->host_port != 0 && port != src->sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s == last_s) {\n            continue;\n        }\n        last_s = s;\n        if (s->path && !strncmp(r->uri, s->path, s->pathlen) &&\n            (s->path[s->pathlen - 1] == '/' ||\n             r->uri[s->pathlen] == '/' ||\n             r->uri[s->pathlen] == '\\0')) {\n            r->server = s;\n            return;\n        }\n    }\n}", "target": 1}
{"code": "void fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_libs %s\\n\", full_path);\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"cannot find %s for private-lib, skipping...\\n\", full_path);\n\t\treturn;\n\t}\n\tunlink(RUN_LIB_FILE);\t\t\t  \n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\"chown\");\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    running fldd %s\\n\", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\tFILE *fp = fopen(RUN_LIB_FILE, \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n\tunlink(RUN_LIB_FILE);\n}", "target": 0}
{"code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}", "target": 1}
{"code": "snmp_oid_decode_oid(uint8_t *buf, uint32_t *buff_len, uint32_t *oid, uint32_t *oid_len)\n{\n  uint32_t *start;\n  uint8_t *buf_end, type;\n  uint8_t len;\n  div_t first;\n  start = oid;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL) {\n    return NULL;\n  }\n  if(type != SNMP_DATA_TYPE_OBJECT) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL) {\n    return NULL;\n  }\n  buf_end = buf + len;\n  (*buff_len)--;\n  first = div(*buf++, 40);\n  *oid++ = (uint32_t)first.quot;\n  *oid++ = (uint32_t)first.rem;\n  while(buf != buf_end) {\n    --(*oid_len);\n    if(*oid_len == 0) {\n      return NULL;\n    }\n    int i;\n    *oid = (uint32_t)(*buf & 0x7F);\n    for(i = 0; i < 4; i++) {\n      (*buff_len)--;\n      if((*buf++ & 0x80) == 0) {\n        break;\n      }\n      *oid <<= 7;\n      *oid |= (*buf & 0x7F);\n    }\n    ++oid;\n  }\n  *oid++ = ((uint32_t)-1);\n  *oid_len = (uint32_t)(oid - start);\n  return buf;\n}", "target": 1}
{"code": "main (int argc, char **argv)\n{\n\tEvArchive *ar;\n\tEvArchiveType ar_type;\n\tGError *error = NULL;\n\tgboolean printed_header = FALSE;\n\tif (argc != 3) {\n\t\tusage (argv[0]);\n\t\treturn 1;\n\t}\n\tar_type = str_to_archive_type (argv[1]);\n\tif (ar_type == EV_ARCHIVE_TYPE_NONE)\n\t\treturn 1;\n\tar = ev_archive_new ();\n\tif (!ev_archive_set_archive_type (ar, ar_type)) {\n\t\tg_warning (\"Failed to set archive type\");\n\t\tgoto out;\n\t}\n\tif (!ev_archive_open_filename (ar, argv[2], &error)) {\n\t\tg_warning (\"Failed to open '%s': %s\",\n\t\t\t   argv[2], error->message);\n\t\tg_error_free (error);\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tconst char *name;\n\t\tgboolean is_encrypted;\n\t\tgint64 size;\n\t\tif (!ev_archive_read_next_header (ar, &error)) {\n\t\t\tif (error != NULL) {\n\t\t\t\tg_warning (\"Fatal error handling archive: %s\", error->message);\n\t\t\t\tg_clear_error (&error);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tname = ev_archive_get_entry_pathname (ar);\n\t\tis_encrypted = ev_archive_get_entry_is_encrypted (ar);\n\t\tsize = ev_archive_get_entry_size (ar);\n\t\tif (!printed_header) {\n\t\t\tg_print (\"P\\tSIZE\\tNAME\\n\");\n\t\t\tprinted_header = TRUE;\n\t\t}\n\t\tg_print (\"%c\\t%\"G_GINT64_FORMAT\"\\t%s\\n\",\n\t\t\t is_encrypted ? 'P' : ' ',\n\t\t\t size, name);\n\t}\n\tev_archive_reset (ar);\n\tg_clear_object (&ar);\n\treturn 0;\nout:\n\tg_clear_object (&ar);\n\treturn 1;\n}", "target": 0}
{"code": "  RectangleRequest(const struct RectangleRequest &req)\n    : Explicit()\n  {\n    memcpy(this,&req,sizeof(struct RectangleRequest));\n    rr_pNext = NULL;\n  }", "target": 1}
{"code": "static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t len, loff_t *pos)\n{\n\tstruct ib_ucm_file *file = filp->private_data;\n\tstruct ib_ucm_cmd_hdr hdr;\n\tssize_t result;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tresult = ucm_cmd_table[hdr.cmd](file, buf + sizeof(hdr),\n\t\t\t\t\thdr.in, hdr.out);\n\tif (!result)\n\t\tresult = len;\n\treturn result;\n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n{\n\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n}", "target": 1}
{"code": "void CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / get2();\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / getreal(type);\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / (num * mul[c]);\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}", "target": 0}
{"code": "set_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\tumask_long = strtoll(optarg, &endptr, 0);\n\tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n\t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn 0;\n\t}\n\tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\tumask_cmdline = true;\n\treturn umask_val;\n}", "target": 0}
{"code": "int btrfs_run_qgroups(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint ret = 0;\n\tif (trans->transaction->state != TRANS_STATE_COMMIT_DOING)\n\t\tlockdep_assert_held(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_root)\n\t\treturn ret;\n\tspin_lock(&fs_info->qgroup_lock);\n\twhile (!list_empty(&fs_info->dirty_qgroups)) {\n\t\tstruct btrfs_qgroup *qgroup;\n\t\tqgroup = list_first_entry(&fs_info->dirty_qgroups,\n\t\t\t\t\t  struct btrfs_qgroup, dirty);\n\t\tlist_del_init(&qgroup->dirty);\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tret = update_qgroup_info_item(trans, qgroup);\n\t\tif (ret)\n\t\t\tqgroup_mark_inconsistent(fs_info);\n\t\tret = update_qgroup_limit_item(trans, qgroup);\n\t\tif (ret)\n\t\t\tqgroup_mark_inconsistent(fs_info);\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t}\n\tif (test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;\n\telse\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tret = update_qgroup_status_item(trans);\n\tif (ret)\n\t\tqgroup_mark_inconsistent(fs_info);\n\treturn ret;\n}", "target": 0}
{"code": "HIDDEN int zlib_compress(struct transaction_t *txn, unsigned flags,\n                         const char *buf, unsigned len)\n{\n    z_stream *zstrm = txn->zstrm;\n    unsigned flush;\n    if (flags & COMPRESS_START) deflateReset(zstrm);\n    if (txn->ws_ctx) flush = Z_SYNC_FLUSH;\n    else {\n        if (flags & COMPRESS_END) flush = Z_FINISH;\n        else flush = Z_NO_FLUSH;\n    }\n    zstrm->next_in = (Bytef *) buf;\n    zstrm->avail_in = len;\n    buf_ensure(&txn->zbuf, deflateBound(zstrm, zstrm->avail_in));\n    buf_reset(&txn->zbuf);\n    do {\n        int zr;\n        if (!zstrm->avail_out) {\n            unsigned pending;\n            zr = deflatePending(zstrm, &pending, Z_NULL);\n            if (zr != Z_OK) {\n                syslog(LOG_ERR, \"zlib deflate error: %d %s\", zr, zstrm->msg);\n                return -1;\n            }\n            buf_ensure(&txn->zbuf, pending);\n        }\n        zstrm->next_out = (Bytef *) txn->zbuf.s + txn->zbuf.len;\n        zstrm->avail_out = txn->zbuf.alloc - txn->zbuf.len;\n        zr = deflate(zstrm, flush);\n        if (!(zr == Z_OK || zr == Z_STREAM_END || zr == Z_BUF_ERROR)) {\n            syslog(LOG_ERR, \"zlib deflate error: %d %s\", zr, zstrm->msg);\n            return -1;\n        }\n        txn->zbuf.len = txn->zbuf.alloc - zstrm->avail_out;\n    } while (!zstrm->avail_out);\n    return 0;\n}", "target": 0}
{"code": "static int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\tint delta = (state.delta * adaptationTable[code]) >> 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\treturn static_cast<int16_t>(linearSample);\n}", "target": 1}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *last,\n\t\t\tvoid *data)\n{\n\tchar *name = path_name(path, last);\n\tadd_preferred_base_object(name);\n\tadd_object_entry(obj->oid.hash, obj->type, name, 0);\n\tobj->flags |= OBJECT_ADDED;\n\tfree((char *)name);\n}", "target": 1}
{"code": "    void resize (std::size_t new_size_) { _buf_size = new_size_; }", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const float min_input = context->input(1).flat<float>()(0);\n    const float max_input = context->input(2).flat<float>()(0);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    const T min_as_quantized = FloatToQuantized<T>(0.0f, min_input, max_input);\n    const T max_as_quantized = FloatToQuantized<T>(6.0f, min_input, max_input);\n    if (meta::IsSupportedAndEnabled() && std::is_same<T, quint8>()) {\n      auto input_ui8_array = input.flat<quint8>();\n      meta::Clamp(context, input_ui8_array.data(), input_ui8_array.size(),\n                  min_as_quantized, max_as_quantized,\n                  output->flat<quint8>().data());\n    } else {\n      output->flat<T>().device(context->eigen_cpu_device()) =\n          input.flat<T>()\n              .cwiseMax(min_as_quantized)\n              .cwiseMin(max_as_quantized)\n              .template cast<T>();\n    }\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 1}
{"code": "void init_xml_relax_ng()\n{\n  VALUE nokogiri = rb_define_module(\"Nokogiri\");\n  VALUE xml = rb_define_module_under(nokogiri, \"XML\");\n  VALUE klass = rb_define_class_under(xml, \"RelaxNG\", cNokogiriXmlSchema);\n  cNokogiriXmlRelaxNG = klass;\n  rb_define_singleton_method(klass, \"read_memory\", read_memory, 1);\n  rb_define_singleton_method(klass, \"from_document\", from_document, 1);\n  rb_define_private_method(klass, \"validate_document\", validate_document, 1);\n}", "target": 1}
{"code": "find_method_in_class (MonoClass *klass, const char *name, const char *qname, const char *fqname,\n\t\t      MonoMethodSignature *sig, MonoClass *from_class)\n{\n \tint i;\n\tif (klass->type_token && !klass->image->dynamic && !klass->methods && !klass->rank && klass == from_class && !from_class->generic_class) {\n\t\tfor (i = 0; i < klass->method.count; ++i) {\n\t\t\tguint32 cols [MONO_METHOD_SIZE];\n\t\t\tMonoMethod *method;\n\t\t\tconst char *m_name;\n\t\t\tMonoMethodSignature *other_sig;\n\t\t\tmono_metadata_decode_table_row (klass->image, MONO_TABLE_METHOD, klass->method.first + i, cols, MONO_METHOD_SIZE);\n\t\t\tm_name = mono_metadata_string_heap (klass->image, cols [MONO_METHOD_NAME]);\n\t\t\tif (!((fqname && !strcmp (m_name, fqname)) ||\n\t\t\t\t  (qname && !strcmp (m_name, qname)) ||\n\t\t\t\t  (name && !strcmp (m_name, name))))\n\t\t\t\tcontinue;\n\t\t\tmethod = mono_get_method (klass->image, MONO_TOKEN_METHOD_DEF | (klass->method.first + i + 1), klass);\n\t\t\tother_sig = mono_method_signature (method);\n\t\t\tif (method && other_sig && (sig->call_convention != MONO_CALL_VARARG) && mono_metadata_signature_equal (sig, other_sig))\n\t\t\t\treturn method;\n\t\t}\n\t}\n\tmono_class_setup_methods (klass);\n\tif (!klass->methods)\n\t\treturn NULL;\n\tfor (i = 0; i < klass->method.count; ++i) {\n\t\tMonoMethod *m = klass->methods [i];\n\t\tMonoMethodSignature *msig;\n\t\tif (!((fqname && !strcmp (m->name, fqname)) ||\n\t\t      (qname && !strcmp (m->name, qname)) ||\n\t\t      (name && !strcmp (m->name, name))))\n\t\t\tcontinue;\n\t\tmsig = mono_method_signature (m);\n\t\tif (!msig)\n\t\t\tcontinue;\n\t\tif (sig->call_convention == MONO_CALL_VARARG) {\n\t\t\tif (mono_metadata_signature_vararg_match (sig, msig))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (mono_metadata_signature_equal (sig, msig))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (i < klass->method.count)\n\t\treturn mono_class_get_method_by_index (from_class, i);\n\treturn NULL;\n}", "target": 0}
{"code": "CBORTag_hash(CBORTagObject *self)\n{\n    if (!_CBOR2_thread_locals && _CBOR2_init_thread_locals() == -1)\n        return -1;\n    Py_hash_t ret = -1;\n    PyObject *running_hashes = NULL;\n    PyObject *tmp = NULL;\n    PyObject *self_id = PyLong_FromVoidPtr(self);\n    if (!self_id)\n        goto exit;\n    running_hashes = PyObject_GetAttrString(_CBOR2_thread_locals, \"running_hashes\");\n    if (!running_hashes) {\n        PyErr_Clear();\n        running_hashes = PySet_New(NULL);\n        if (PyObject_SetAttrString(_CBOR2_thread_locals, \"running_hashes\", running_hashes) == -1)\n            goto exit;\n    } else {\n        switch (PySet_Contains(running_hashes, self_id)) {\n            case -1:  \n                goto exit;\n            case 1:  \n                PyErr_SetString(\n                    PyExc_RuntimeError,\n                    \"This CBORTag is not hashable because it contains a reference to itself\"\n                );\n                goto exit;\n        }\n    }\n    if (PySet_Add(running_hashes, self_id) == -1)\n        goto exit;\n    tmp = Py_BuildValue(\"(KO)\", self->tag, self->value);\n    if (!tmp)\n        goto exit;\n    ret = PyObject_Hash(tmp);\n    if (ret == -1)\n        goto exit;\n    if (PySet_Discard(running_hashes, self_id) == -1) {\n        ret = -1;\n        goto exit;\n    }\n    Py_ssize_t length = PySequence_Length(running_hashes);\n    if (length == -1) {\n        ret = -1;\n        goto exit;\n    }\n    if (length == 0 && PyObject_DelAttrString(_CBOR2_thread_locals, \"running_hashes\") == -1) {\n        ret = -1;\n        goto exit;\n    }\nexit:\n    Py_CLEAR(self_id);\n    Py_CLEAR(running_hashes);\n    Py_CLEAR(tmp);\n    return ret;\n}", "target": 0}
{"code": "Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) {\n  DCHECK_EQ(t.args_size(), 3);\n  const auto& cont = t.args(0);\n  const auto& tmpl = t.args(1);\n  const auto& t_var = t.args(2);\n  StringPiece var_name = t_var.s();\n  if (!attrs.contains(var_name)) {\n    return Status(\n        error::INVALID_ARGUMENT,\n        absl::StrCat(\"could not find an attribute for key '\", var_name, \"'\"));\n  }\n  const AttrValue* attr = attrs.at(var_name);\n  FullTypeDef result;\n  result.set_type_id(cont.type_id());\n  const auto attr_type = attr->value_case();\n  if (attr_type == AttrValue::kType) {\n    FullTypeDef* target = result.add_args();\n    *target = tmpl;\n    TF_RETURN_WITH_CONTEXT_IF_ERROR(\n        SubstituteFromAttrs(attrs, *target), \"while substituting '\", var_name,\n        \"' from\\n\", attr->DebugString(), \"\\ninto \", target->DebugString());\n  } else if (attr_type == AttrValue::kList) {\n    const auto& attr_list = attr->list();\n    int tsize = attr_list.type_size();\n    if (tsize == 0) {\n      return Status(error::UNIMPLEMENTED,\n                    absl::StrCat(\"unsupported list attribute type\\n\",\n                                 attr_list.DebugString(), \"\\nkey=\", var_name));\n    }\n    AttrValue replacement;\n    attrs[var_name] = &replacement;\n    for (int i = 0; i < tsize; i++) {\n      replacement.set_type(attr_list.type(i));\n      FullTypeDef* target = result.add_args();\n      *target = tmpl;\n      TF_RETURN_WITH_CONTEXT_IF_ERROR(SubstituteFromAttrs(attrs, *target),\n                                      \"while substituting '\", var_name,\n                                      \"' from\\n\", attr->DebugString(), \"\\n[\", i,\n                                      \"] into\\n\", target->DebugString());\n    }\n    attrs[var_name] = attr;\n  } else {\n    return Status(error::UNIMPLEMENTED,\n                  absl::StrCat(\"unsupported attribute type\\n\",\n                               attr->DebugString(), \"\\nfor name \", var_name));\n  }\n  t = result;\n  return OkStatus();\n}", "target": 1}
{"code": "mark_desktop_file_executable (CommonJob    *common,\n                              GCancellable *cancellable,\n                              GFile        *file,\n                              gboolean      interactive)\n{\n    GError *error;\n    guint32 current_perms, new_perms;\n    int response;\n    GFileInfo *info;\nretry:\n    error = NULL;\n    info = g_file_query_info (file,\n                              G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n                              G_FILE_ATTRIBUTE_UNIX_MODE,\n                              G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                              common->cancellable,\n                              &error);\n    if (info == NULL)\n    {\n        if (interactive)\n        {\n            response = run_error (common,\n                                  g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                  error->message,\n                                  NULL,\n                                  FALSE,\n                                  CANCEL, RETRY,\n                                  NULL);\n        }\n        else\n        {\n            response = 0;\n        }\n        if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n        {\n            abort_job (common);\n        }\n        else if (response == 1)\n        {\n            goto retry;\n        }\n        else\n        {\n            g_assert_not_reached ();\n        }\n        goto out;\n    }\n    if (g_file_info_has_attribute (info, G_FILE_ATTRIBUTE_UNIX_MODE))\n    {\n        current_perms = g_file_info_get_attribute_uint32 (info, G_FILE_ATTRIBUTE_UNIX_MODE);\n        new_perms = current_perms | S_IXGRP | S_IXUSR | S_IXOTH;\n        if ((current_perms != new_perms) &&\n            !g_file_set_attribute_uint32 (file, G_FILE_ATTRIBUTE_UNIX_MODE,\n                                          new_perms, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                          common->cancellable, &error))\n        {\n            g_object_unref (info);\n            if (interactive)\n            {\n                response = run_error (common,\n                                      g_strdup (_(\"Unable to mark launcher trusted (executable)\")),\n                                      error->message,\n                                      NULL,\n                                      FALSE,\n                                      CANCEL, RETRY,\n                                      NULL);\n            }\n            else\n            {\n                response = 0;\n            }\n            if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT)\n            {\n                abort_job (common);\n            }\n            else if (response == 1)\n            {\n                goto retry;\n            }\n            else\n            {\n                g_assert_not_reached ();\n            }\n            goto out;\n        }\n    }\n    g_object_unref (info);\nout:\n    ;\n}", "target": 0}
{"code": "learn_min_len(uint16_t header)\n{\n    int n_bits = header & NX_LEARN_N_BITS_MASK;\n    int src_type = header & NX_LEARN_SRC_MASK;\n    int dst_type = header & NX_LEARN_DST_MASK;\n    unsigned int min_len;\n    min_len = 0;\n    if (src_type == NX_LEARN_SRC_FIELD) {\n        min_len += sizeof(ovs_be32); \n        min_len += sizeof(ovs_be16); \n    } else {\n        min_len += 2 * DIV_ROUND_UP(n_bits, 16);\n    }\n    if (dst_type == NX_LEARN_DST_MATCH ||\n        dst_type == NX_LEARN_DST_LOAD) {\n        min_len += sizeof(ovs_be32); \n        min_len += sizeof(ovs_be16); \n    }\n    return min_len;\n}", "target": 0}
{"code": "static void preinit_thread (lua_State *L, global_State *g) {\n  G(L) = g;\n  L->stack = NULL;\n  L->ci = NULL;\n  L->nci = 0;\n  L->stacksize = 0;\n  L->twups = L;  \n  L->errorJmp = NULL;\n  L->hook = NULL;\n  L->hookmask = 0;\n  L->basehookcount = 0;\n  L->allowhook = 1;\n  resethookcount(L);\n  L->openupval = NULL;\n  L->status = LUA_OK;\n  L->errfunc = 0;\n  L->oldpc = 0;\n}", "target": 0}
{"code": "static void request_end(struct fuse_conn *fc, struct fuse_req *req)\n{\n\tstruct fuse_iqueue *fiq = &fc->iq;\n\tif (test_and_set_bit(FR_FINISHED, &req->flags))\n\t\tgoto put_request;\n\tspin_lock(&fiq->waitq.lock);\n\tlist_del_init(&req->intr_entry);\n\tspin_unlock(&fiq->waitq.lock);\n\tWARN_ON(test_bit(FR_PENDING, &req->flags));\n\tWARN_ON(test_bit(FR_SENT, &req->flags));\n\tif (test_bit(FR_BACKGROUND, &req->flags)) {\n\t\tspin_lock(&fc->bg_lock);\n\t\tclear_bit(FR_BACKGROUND, &req->flags);\n\t\tif (fc->num_background == fc->max_background) {\n\t\t\tfc->blocked = 0;\n\t\t\twake_up(&fc->blocked_waitq);\n\t\t} else if (!fc->blocked) {\n\t\t\tif (waitqueue_active(&fc->blocked_waitq))\n\t\t\t\twake_up(&fc->blocked_waitq);\n\t\t}\n\t\tif (fc->num_background == fc->congestion_threshold && fc->sb) {\n\t\t\tclear_bdi_congested(fc->sb->s_bdi, BLK_RW_SYNC);\n\t\t\tclear_bdi_congested(fc->sb->s_bdi, BLK_RW_ASYNC);\n\t\t}\n\t\tfc->num_background--;\n\t\tfc->active_background--;\n\t\tflush_bg_queue(fc);\n\t\tspin_unlock(&fc->bg_lock);\n\t}\n\twake_up(&req->waitq);\n\tif (req->end)\n\t\treq->end(fc, req);\nput_request:\n\tfuse_put_request(fc, req);\n}", "target": 0}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n        comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n        return true;\n    }", "target": 1}
{"code": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};", "target": 1}
{"code": "static x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n{\n\tif (tree->free_node_index >= tree->total_node_index)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n  x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n  t->branch[0] = NULL;\n  t->branch[1] = NULL;\n  t->leaf = UNDEFINED_LEAF;\n  tree->free_node_index++;\n  return t;\n}", "target": 0}
{"code": "perf_output_sample_regs(struct perf_output_handle *handle,\n\t\t\tstruct pt_regs *regs, u64 mask)\n{\n\tint bit;\n\tfor_each_set_bit(bit, (const unsigned long *) &mask,\n\t\t\t sizeof(mask) * BITS_PER_BYTE) {\n\t\tu64 val;\n\t\tval = perf_reg_value(regs, bit);\n\t\tperf_output_put(handle, val);\n\t}\n}", "target": 0}
{"code": "int mem_check_range(struct rxe_mem *mem, u64 iova, size_t length)\n{\n\tswitch (mem->type) {\n\tcase RXE_MEM_TYPE_DMA:\n\t\treturn 0;\n\tcase RXE_MEM_TYPE_MR:\n\tcase RXE_MEM_TYPE_FMR:\n\t\treturn ((iova < mem->iova) ||\n\t\t\t((iova + length) > (mem->iova + mem->length))) ?\n\t\t\t-EFAULT : 0;\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}", "target": 1}
{"code": "static void log_handler(uint32_t level, const char *msg, void *arg)\n{\n\tfprintf(stdout, msg, arg);\n}", "target": 0}
{"code": "static unsigned int seedsize(struct crypto_alg *alg)\n{\n\tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n\treturn alg->cra_rng.rng_make_random ?\n\t       alg->cra_rng.seedsize : ralg->seedsize;\n}", "target": 1}
{"code": "bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n    {\n        LOCK(mempool.cs);\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}", "target": 1}
{"code": "void blog_post(char post_path[]) {\n\tif(strlen(post_path) != 0 || post_path[0] == '.'\n\t\t\t|| strchr(post_path, '/') == NULL) {\n\t\tsend_header(\"Content-type\", \"text/plain\");\n\t\tterminate_headers();\n\t\tprintf(\"No, my dear h4xxx0r :)\\nYou won\\'t do that :p\\n\");\n\t\treturn;\n\t}\n\tif(file_exists(post_path) > 0) {\n\t\tstruct blogpost post = make_blogpost(post_path);\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_post_single_entry(post);\n\t} else {\n\t\tsend_header(\"Content-type\", \"text/html\");\n\t\tsend_header(\"Status\", \"404 Not Found\");\n\t\tterminate_headers();\n\t\ttemplate_header();\n\t\ttemplate_error_404();\n\t}\n\ttemplate_footer();\n}", "target": 0}
{"code": "static int userns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct user_namespace *user_ns = ns;\n\tstruct cred *cred;\n\tif (user_ns == current_user_ns())\n\t\treturn -EINVAL;\n\tif (atomic_read(&current->mm->mm_users) > 1)\n\t\treturn -EINVAL;\n\tif (current->fs->users != 1)\n\t\treturn -EINVAL;\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\tput_user_ns(cred->user_ns);\n\tset_cred_user_ns(cred, get_user_ns(user_ns));\n\treturn commit_creds(cred);\n}", "target": 0}
{"code": "checked_xcalloc (size_t num, size_t size)\n{\n    alloc_limit_assert (\"checked_xcalloc\", (num *size));\n    return xcalloc (num, size);\n}", "target": 1}
{"code": "void *bson_realloc( void *ptr, int size ) {\n    void *p;\n    p = bson_realloc_func( ptr, size );\n    bson_fatal_msg( !!p, \"realloc() failed\" );\n    return p;\n}", "target": 1}
{"code": "bool __fastcall TSiteRawDialog::Execute(TSessionData * Data)\n{\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\n  std::unique_ptr<TSessionData> RawData(new TSessionData(L\"\"));\n  RawData->Assign(Data);\n  if (RawData->FSProtocol != fsSFTPonly)\n  {\n    RawData->FSProtocol = FactoryDefaults->FSProtocol;\n  }\n  RawData->HostName = FactoryDefaults->HostName;\n  RawData->PortNumber = FactoryDefaults->PortNumber;\n  RawData->UserName = FactoryDefaults->UserName;\n  RawData->Password = FactoryDefaults->Password;\n  RawData->Ftps = FactoryDefaults->Ftps;\n  std::unique_ptr<TStrings> Options(RawData->SaveToOptions(FactoryDefaults.get(), false, false));\n  SettingsMemo->Lines = Options.get();\n  bool Result = TCustomDialog::Execute();\n  if (Result)\n  {\n    std::unique_ptr<TSessionData> BackupData(new TSessionData(L\"\"));\n    BackupData->Assign(Data);\n    Data->DefaultSettings();\n    Data->FSProtocol = BackupData->FSProtocol;\n    Data->HostName = BackupData->HostName;\n    Data->PortNumber = BackupData->PortNumber;\n    Data->UserName = BackupData->UserName;\n    Data->Password = BackupData->Password;\n    Data->Ftps = BackupData->Ftps;\n    Data->ApplyRawSettings(SettingsMemo->Lines);\n  }\n  return Result;\n}", "target": 1}
{"code": "void ComparisonQuantized(const TfLiteTensor* input1, const TfLiteTensor* input2,\n                         TfLiteTensor* output, bool requires_broadcast) {\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int left_shift = 8;\n    int32 input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(input1->params.scale,\n                                        &input1_multiplier, &input1_shift);\n    int32 input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(input2->params.scale,\n                                        &input2_multiplier, &input2_shift);\n    ComparisonParams op_params;\n    op_params.left_shift = left_shift;\n    op_params.input1_offset = input1_offset;\n    op_params.input1_multiplier = input1_multiplier;\n    op_params.input1_shift = input1_shift;\n    op_params.input2_offset = input2_offset;\n    op_params.input2_multiplier = input2_multiplier;\n    op_params.input2_shift = input2_shift;\n    if (requires_broadcast) {\n      reference_ops::BroadcastComparison4DSlowWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    } else {\n      reference_ops::ComparisonWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    }\n  }\n}", "target": 1}
{"code": "static void _isdn_setup(struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->header_ops = NULL;\n\tdev->netdev_ops = &isdn_netdev_ops;\n\tdev->tx_queue_len = 30;\n\tlp->p_encap = ISDN_NET_ENCAP_RAWIP;\n\tlp->magic = ISDN_NET_MAGIC;\n\tlp->last = lp;\n\tlp->next = lp;\n\tlp->isdn_device = -1;\n\tlp->isdn_channel = -1;\n\tlp->pre_device = -1;\n\tlp->pre_channel = -1;\n\tlp->exclusive = -1;\n\tlp->ppp_slot = -1;\n\tlp->pppbind = -1;\n\tskb_queue_head_init(&lp->super_tx_queue);\n\tlp->l2_proto = ISDN_PROTO_L2_X75I;\n\tlp->l3_proto = ISDN_PROTO_L3_TRANS;\n\tlp->triggercps = 6000;\n\tlp->slavedelay = 10 * HZ;\n\tlp->hupflags = ISDN_INHUP;\t\n\tlp->onhtime = 10;\t\n\tlp->dialmax = 1;\n\tlp->flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL;\n\tlp->cbdelay = 25;\t\n\tlp->dialtimeout = -1;  \n\tlp->dialwait = 5 * HZ; \n\tlp->dialstarted = 0;   \n\tlp->dialwait_timer = 0;  \n}", "target": 0}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t}\n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n   {\n      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n      size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit=PNG_UINT_31_MAX;\n      else\n         idat_limit = png_ptr->height * row_factor;\n      row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); \n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "void mb2_cache_entry_touch(struct mb2_cache *cache,\n\t\t\t   struct mb2_cache_entry *entry)\n{\n\tspin_lock(&cache->c_lru_list_lock);\n\tif (!list_empty(&entry->e_lru_list))\n\t\tlist_move_tail(&cache->c_lru_list, &entry->e_lru_list);\n\tspin_unlock(&cache->c_lru_list_lock);\n}", "target": 0}
{"code": "modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "xfs_bmap_alloc(\n\tstruct xfs_bmalloca\t*ap)\t\n{\n\tif (XFS_IS_REALTIME_INODE(ap->ip) &&\n\t    xfs_alloc_is_userdata(ap->datatype))\n\t\treturn xfs_bmap_rtalloc(ap);\n\treturn xfs_bmap_btalloc(ap);\n}", "target": 0}
{"code": "order_notification_deltas(struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head **ptr;\n\tarray_index i;\n\tint error;\n\terror = deltas_head_set_size(ctx->notification->deltas_list,\n\t    ctx->deltas.len);\n\tif (error)\n\t\treturn error;\n\tARRAYLIST_FOREACH(&ctx->deltas, ptr, i) {\n\t\terror = deltas_head_add(ctx->notification->deltas_list,\n\t\t    ctx->notification->global_data.serial,\n\t\t    (*ptr)->serial,\n\t\t    (*ptr)->doc_data.uri,\n\t\t    (*ptr)->doc_data.hash,\n\t\t    (*ptr)->doc_data.hash_len);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\tif (error == -EINVAL)\n\t\t\treturn pr_val_err(\"Serial '%lu' at delta elements isn't part of a contiguous list of serials.\",\n\t\t\t    (*ptr)->serial);\n\t\tif (error == -EEXIST)\n\t\t\treturn pr_val_err(\"Duplicated serial '%lu' at delta elements.\",\n\t\t\t    (*ptr)->serial);\n\t\treturn error;\n\t}\n\tif (!deltas_head_values_set(ctx->notification->deltas_list))\n\t\treturn pr_val_err(\"Deltas listed don't have a contiguous sequence of serial numbers\");\n\treturn 0;\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "static unsigned int unix_dgram_poll(struct file *file, struct socket *sock,\n\t\t\t\t    poll_table *wait)\n{\n\tstruct sock *sk = sock->sk, *other;\n\tunsigned int mask, writable;\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tif (sk->sk_err || !skb_queue_empty(&sk->sk_error_queue))\n\t\tmask |= POLLERR |\n\t\t\t(sock_flag(sk, SOCK_SELECT_ERR_QUEUE) ? POLLPRI : 0);\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP | POLLIN | POLLRDNORM;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sk->sk_type == SOCK_SEQPACKET) {\n\t\tif (sk->sk_state == TCP_CLOSE)\n\t\t\tmask |= POLLHUP;\n\t\tif (sk->sk_state == TCP_SYN_SENT)\n\t\t\treturn mask;\n\t}\n\tif (!(poll_requested_events(wait) & (POLLWRBAND|POLLWRNORM|POLLOUT)))\n\t\treturn mask;\n\twritable = unix_writable(sk);\n\tother = unix_peer_get(sk);\n\tif (other) {\n\t\tif (unix_peer(other) != sk) {\n\t\t\tsock_poll_wait(file, &unix_sk(other)->peer_wait, wait);\n\t\t\tif (unix_recvq_full(other))\n\t\t\t\twritable = 0;\n\t\t}\n\t\tsock_put(other);\n\t}\n\tif (writable)\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\telse\n\t\tset_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags);\n\treturn mask;\n}", "target": 1}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->file_offset = buf_offset;\n\tse->tag = buffer[offset];\n\toffset += 1;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t}\n\tif (R_BIN_JAVA_STACKMAP_UNINIT < se->tag) {\n\t\tr_bin_java_verification_info_free (se);\n\t\treturn NULL;\n\t}\n\tse->size = offset;\n\treturn se;\n}", "target": 0}
{"code": "flush_buf_tls(tor_tls_t *tls, buf_t *buf, size_t flushlen,\n              size_t *buf_flushlen)\n{\n  int r;\n  size_t flushed = 0;\n  ssize_t sz;\n  tor_assert(buf_flushlen);\n  tor_assert(*buf_flushlen <= buf->datalen);\n  tor_assert(flushlen <= *buf_flushlen);\n  sz = (ssize_t) flushlen;\n  check_no_tls_errors();\n  check();\n  do {\n    size_t flushlen0;\n    if (buf->head) {\n      if ((ssize_t)buf->head->datalen >= sz)\n        flushlen0 = sz;\n      else\n        flushlen0 = buf->head->datalen;\n    } else {\n      flushlen0 = 0;\n    }\n    r = flush_chunk_tls(tls, buf, buf->head, flushlen0, buf_flushlen);\n    check();\n    if (r < 0)\n      return r;\n    flushed += r;\n    sz -= r;\n    if (r == 0) \n      break;\n  } while (sz > 0);\n  tor_assert(flushed < INT_MAX);\n  return (int)flushed;\n}", "target": 0}
{"code": "FNAME(prefetch_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t     u64 *spte, pt_element_t gpte, bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\tunsigned pte_access;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, spte, gpte))\n\t\treturn false;\n\tpgprintk(\"%s: gpte %llx spte %p\\n\", __func__, (u64)gpte, spte);\n\tgfn = gpte_to_gfn(gpte);\n\tpte_access = sp->role.access & FNAME(gpte_access)(gpte);\n\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn,\n\t\t\tno_dirty_log && (pte_access & ACC_WRITE_MASK));\n\tif (!slot)\n\t\treturn false;\n\tpfn = gfn_to_pfn_memslot_atomic(slot, gfn);\n\tif (is_error_pfn(pfn))\n\t\treturn false;\n\tmmu_set_spte(vcpu, slot, spte, pte_access, gfn, pfn, NULL);\n\tkvm_release_pfn_clean(pfn);\n\treturn true;\n}", "target": 0}
{"code": "processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n#ifdef XML_DTD\n  entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (const char *)entity->textPtr;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif \n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE,\n                       XML_ACCOUNT_ENTITY_EXPANSION);\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n#ifdef XML_DTD\n      entityTrackingOnClose(parser, entity, __LINE__);\n#endif \n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}", "target": 1}
{"code": "static struct dentry *proc_pid_instantiate(struct inode *dir,\n\t\t\t\t\t   struct dentry * dentry,\n\t\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\tinode->i_nlink = 5;\n#ifdef CONFIG_SECURITY\n\tinode->i_nlink += 1;\n#endif\n\tdentry->d_op = &pid_dentry_operations;\n\td_add(dentry, inode);\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}", "target": 0}
{"code": "krb5_gss_export_sec_context(minor_status, context_handle, interprocess_token)\n    OM_uint32           *minor_status;\n    gss_ctx_id_t        *context_handle;\n    gss_buffer_t        interprocess_token;\n{\n    krb5_context        context = NULL;\n    krb5_error_code     kret;\n    OM_uint32           retval;\n    size_t              bufsize, blen;\n    krb5_gss_ctx_id_t   ctx;\n    krb5_octet          *obuffer, *obp;\n    obuffer = (krb5_octet *) NULL;\n    retval = GSS_S_FAILURE;\n    *minor_status = 0;\n    ctx = (krb5_gss_ctx_id_t) *context_handle;\n    if (ctx->terminated) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return (GSS_S_NO_CONTEXT);\n    }\n    context = ctx->k5_context;\n    kret = krb5_gss_ser_init(context);\n    if (kret)\n        goto error_out;\n    bufsize = 0;\n    if ((kret = kg_ctx_size(context, (krb5_pointer) ctx,\n                            &bufsize)))\n        goto error_out;\n    if ((obuffer = gssalloc_malloc(bufsize)) == NULL) {\n        kret = ENOMEM;\n        goto error_out;\n    }\n    obp = obuffer;\n    blen = bufsize;\n    if ((kret = kg_ctx_externalize(context,\n                                   (krb5_pointer) ctx, &obp, &blen)))\n        goto error_out;\n    interprocess_token->length = bufsize - blen;\n    interprocess_token->value = obuffer;\n    *minor_status = 0;\n    retval = GSS_S_COMPLETE;\n    (void)krb5_gss_delete_sec_context(minor_status, context_handle, NULL);\n    *context_handle = GSS_C_NO_CONTEXT;\n    return (GSS_S_COMPLETE);\nerror_out:\n    if (retval != GSS_S_COMPLETE)\n        if (kret != 0 && context != 0)\n            save_error_info((OM_uint32)kret, context);\n    if (obuffer && bufsize) {\n        memset(obuffer, 0, bufsize);\n        xfree(obuffer);\n    }\n    if (*minor_status == 0)\n        *minor_status = (OM_uint32) kret;\n    return(retval);\n}", "target": 0}
{"code": "static void ext4_invalidatepage(struct page *page, unsigned long offset)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\tif (ext4_should_dioread_nolock(page->mapping->host))\n\t\text4_invalidatepage_free_endio(page, offset);\n\tif (offset == 0)\n\t\tClearPageChecked(page);\n\tif (journal)\n\t\tjbd2_journal_invalidatepage(journal, page, offset);\n\telse\n\t\tblock_invalidatepage(page, offset);\n}", "target": 0}
{"code": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "TEE_Result syscall_authenc_update_aad(unsigned long state,\n\t\t\tconst void *aad_data, size_t aad_data_len)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),\n\t\t\t\t\t  TEE_MEMORY_ACCESS_READ |\n\t\t\t\t\t  TEE_MEMORY_ACCESS_ANY_OWNER,\n\t\t\t\t\t  (uaddr_t) aad_data,\n\t\t\t\t\t  aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs->state != CRYP_STATE_INITIALIZED)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tif (TEE_ALG_GET_CLASS(cs->algo) != TEE_OPERATION_AE)\n\t\treturn TEE_ERROR_BAD_STATE;\n\tres = crypto_authenc_update_aad(cs->ctx, cs->algo, cs->mode,\n\t\t\t\t\taad_data, aad_data_len);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "bool Tensor::FromProto(Allocator* a, const TensorProto& proto) {\n  CHECK_NOTNULL(a);\n  TensorBuffer* p = nullptr;\n  if (!TensorShape::IsValid(proto.tensor_shape())) return false;\n  if (proto.dtype() == DT_INVALID) return false;\n  TensorShape shape(proto.tensor_shape());\n  const int64_t N = shape.num_elements();\n  if (N > 0 && proto.dtype()) {\n    bool dtype_error = false;\n    if (!proto.tensor_content().empty()) {\n      const auto& content = proto.tensor_content();\n      CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N),\n                         dtype_error = true, dtype_error = true);\n    } else {\n      CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N),\n                         dtype_error = true, dtype_error = true);\n    }\n    if (dtype_error || p == nullptr) return false;\n  } else {\n    bool dtype_error = false;\n    CASES_WITH_DEFAULT(proto.dtype(), break, dtype_error = true,\n                       dtype_error = true);\n    if (dtype_error) return false;\n  }\n  shape_ = shape;\n  set_dtype(proto.dtype());\n  UnrefIfNonNull(buf_);\n  buf_ = p;\n  if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) {\n    LogMemory::RecordTensorAllocation(\"Unknown (from Proto)\",\n                                      LogMemory::UNKNOWN_STEP_ID, *this);\n  }\n  return true;\n}", "target": 0}
{"code": "void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n\t\t    gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n\tvoid *memory;\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\treturn __dma_alloc(dev, size, handle, gfp, prot, false,\n\t\t\t   __builtin_return_address(0));\n}", "target": 1}
{"code": "void __init set_dma_reserve(unsigned long new_dma_reserve)\n{\n\tdma_reserve = new_dma_reserve;\n}", "target": 0}
{"code": "BOOL update_write_cache_bitmap_v3_order(wStream* s, CACHE_BITMAP_V3_ORDER* cache_bitmap_v3,\n                                        UINT16* flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tif (!Stream_EnsureRemainingCapacity(\n\t        s, update_approximate_cache_bitmap_v3_order(cache_bitmap_v3, flags)))\n\t\treturn FALSE;\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tbitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];\n\t*flags = (cache_bitmap_v3->cacheId & 0x00000003) |\n\t         ((cache_bitmap_v3->flags << 7) & 0x0000FF80) | ((bitsPerPixelId << 3) & 0x00000078);\n\tStream_Write_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Write_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Write_UINT32(s, cache_bitmap_v3->key2);       \n\tStream_Write_UINT8(s, bitmapData->bpp);\n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, 0);                   \n\tStream_Write_UINT8(s, bitmapData->codecID); \n\tStream_Write_UINT16(s, bitmapData->width);  \n\tStream_Write_UINT16(s, bitmapData->height); \n\tStream_Write_UINT32(s, bitmapData->length); \n\tStream_Write(s, bitmapData->data, bitmapData->length);\n\treturn TRUE;\n}", "target": 1}
{"code": "static inline int tcp_in_quickack_mode(const struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\treturn icsk->icsk_ack.quick && !icsk->icsk_ack.pingpong;\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "MOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    if (huffcdic->index_count != huffcdic->index_read) {\n        debug_print(\"CDIC: wrong read index count: %zu, total: %zu\\n\", huffcdic->index_read, huffcdic->index_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}", "target": 0}
{"code": "void gitn_box_del(GF_Box *s)\n{\n\tu32 i;\n\tGroupIdToNameBox *ptr = (GroupIdToNameBox *)s;\n\tif (ptr == NULL) return;\n\tfor (i=0; i<ptr->nb_entries; i++) {\n\t\tif (ptr->entries[i].name) gf_free(ptr->entries[i].name);\n\t}\n\tif (ptr->entries) gf_free(ptr->entries);\n\tgf_free(ptr);", "target": 1}
{"code": "static int smtp_open(struct Connection *conn, bool esmtp)\n{\n  int rc;\n  if (mutt_socket_open(conn))\n    return -1;\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n    return rc;\n  rc = smtp_helo(conn, esmtp);\n  if (rc != 0)\n    return rc;\n#ifdef USE_SSL\n  enum QuadOption ans = MUTT_NO;\n  if (conn->ssf)\n    ans = MUTT_NO;\n  else if (C_SslForceTls)\n    ans = MUTT_YES;\n  else if ((Capabilities & SMTP_CAP_STARTTLS) &&\n           ((ans = query_quadoption(C_SslStarttls,\n                                    _(\"Secure connection with TLS?\"))) == MUTT_ABORT))\n  {\n    return -1;\n  }\n  if (ans == MUTT_YES)\n  {\n    if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0)\n      return SMTP_ERR_WRITE;\n    rc = smtp_get_resp(conn);\n    mutt_socket_empty(conn);\n    if (rc != 0)\n      return rc;\n    if (mutt_ssl_starttls(conn))\n    {\n      mutt_error(_(\"Could not negotiate TLS connection\"));\n      return -1;\n    }\n    rc = smtp_helo(conn, esmtp);\n    if (rc != 0)\n      return rc;\n  }\n#endif\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!(Capabilities & SMTP_CAP_AUTH))\n    {\n      mutt_error(_(\"SMTP server does not support authentication\"));\n      return -1;\n    }\n    return smtp_auth(conn);\n  }\n  return 0;\n}", "target": 0}
{"code": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}", "target": 1}
{"code": "bool RenderWidgetHostImpl::SurfacePropertiesMismatch(\n    const RenderWidgetSurfaceProperties& first,\n    const RenderWidgetSurfaceProperties& second) const {\n#ifdef OS_ANDROID\n  if (enable_surface_synchronization_) {\n    RenderWidgetSurfaceProperties second_reduced = second;\n    second_reduced.top_controls_height = first.top_controls_height;\n    second_reduced.top_controls_shown_ratio = first.top_controls_shown_ratio;\n    second_reduced.bottom_controls_height = first.bottom_controls_height;\n    second_reduced.bottom_controls_shown_ratio =\n        first.bottom_controls_shown_ratio;\n    second_reduced.selection = first.selection;\n    return first != second_reduced;\n  }\n#endif\n  return first != second;\n}", "target": 0}
{"code": "hstore_slice_to_hstore(PG_FUNCTION_ARGS)\n{\n\tHStore\t   *hs = PG_GETARG_HS(0);\n\tHEntry\t   *entries = ARRPTR(hs);\n\tchar\t   *ptr = STRPTR(hs);\n\tArrayType  *key_array = PG_GETARG_ARRAYTYPE_P(1);\n\tHStore\t   *out;\n\tint\t\t\tnkeys;\n\tPairs\t   *key_pairs = hstoreArrayToPairs(key_array, &nkeys);\n\tPairs\t   *out_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\tlastidx = 0;\n\tint\t\t\ti;\n\tint\t\t\tout_count = 0;\n\tif (nkeys == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n\t\tPG_RETURN_POINTER(out);\n\t}\n\tout_pairs = palloc(sizeof(Pairs) * nkeys);\n\tbufsiz = 0;\n\tfor (i = 0; i < nkeys; ++i)\n\t{\n\t\tint\t\t\tidx = hstoreFindKey(hs, &lastidx,\n\t\t\t\t\t\t\t\t\t  key_pairs[i].key, key_pairs[i].keylen);\n\t\tif (idx >= 0)\n\t\t{\n\t\t\tout_pairs[out_count].key = key_pairs[i].key;\n\t\t\tbufsiz += (out_pairs[out_count].keylen = key_pairs[i].keylen);\n\t\t\tout_pairs[out_count].val = HS_VAL(entries, ptr, idx);\n\t\t\tbufsiz += (out_pairs[out_count].vallen = HS_VALLEN(entries, idx));\n\t\t\tout_pairs[out_count].isnull = HS_VALISNULL(entries, idx);\n\t\t\tout_pairs[out_count].needfree = false;\n\t\t\t++out_count;\n\t\t}\n\t}\n\tout = hstorePairs(out_pairs, out_count, bufsiz);\n\tPG_RETURN_POINTER(out);\n}", "target": 0}
{"code": "create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)\n{\n    std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x)\n    {\n        if(ext.remove_emoji)\n            x.Remark = trim(removeEmoji(x.Remark));\n        nodeRename(x, ext.rename_array, ext);\n        if(ext.add_emoji)\n            x.Remark = addEmoji(x, ext.emoji_array, ext);\n    });\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size())\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                try\n                {\n                    ctx.eval(script);\n                    auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(\"compare\");\n                    auto comparer = [&](const Proxy &a, const Proxy &b)\n                    {\n                        if(a.Type == ProxyType::Unknow)\n                            return 1;\n                        if(b.Type == ProxyType::Unknow)\n                            return 0;\n                        return compare(a, b);\n                    };\n                    std::stable_sort(nodes.begin(), nodes.end(), comparer);\n                    failed = false;\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n        }\n        if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b)\n        {\n            return a.Remark < b.Remark;\n        });\n    }\n}", "target": 1}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 0}
{"code": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\twhile (isspace(*numstr))\n\t\tnumstr++;\n\tif (*numstr == '-')\n\t\treturn -EINVAL;\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno == ERANGE && uli == ULONG_MAX)\n\t\treturn -ERANGE;\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}", "target": 0}
{"code": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *mac_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\tint type = skb_shinfo(skb)->gso_type;\n\t\tif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +\n\t\t     unfrag_ip6hlen;\n\tmac_start = skb_mac_header(skb);\n\tmemmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);\n\tskb->mac_header -= frag_hdr_sz;\n\tskb->network_header -= frag_hdr_sz;\n\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\tfptr->nexthdr = nexthdr;\n\tfptr->reserved = 0;\n\tipv6_select_ident(fptr);\n\tsegs = skb_segment(skb, features);\nout:\n\treturn segs;\n}", "target": 1}
{"code": "njs_typed_array_set_value(njs_vm_t *vm, njs_typed_array_t *array,\n    uint32_t index, njs_value_t *setval)\n{\n    double              num;\n    njs_int_t           ret;\n    njs_array_buffer_t  *buffer;\n    ret = njs_value_to_number(vm, setval, &num);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n    buffer = njs_typed_array_writable(vm, array);\n    if (njs_slow_path(buffer == NULL)) {\n        return NJS_ERROR;\n    }\n    njs_typed_array_prop_set(vm, array, index, num);\n    njs_set_number(setval, num);\n    return NJS_OK;\n}", "target": 1}
{"code": "fu_plugin_set_secure_config_value(FuPlugin *self,\n\t\t\t\t  const gchar *key,\n\t\t\t\t  const gchar *value,\n\t\t\t\t  GError **error)\n{\n\tg_autofree gchar *conf_path = fu_plugin_get_config_filename(self);\n\tgint ret;\n\tg_return_val_if_fail(FU_IS_PLUGIN(self), FALSE);\n\tg_return_val_if_fail(error == NULL || *error == NULL, FALSE);\n\tif (!g_file_test(conf_path, G_FILE_TEST_EXISTS)) {\n\t\tg_set_error(error, FWUPD_ERROR, FWUPD_ERROR_NOT_FOUND, \"%s is missing\", conf_path);\n\t\treturn FALSE;\n\t}\n\tret = g_chmod(conf_path, 0660);\n\tif (ret == -1) {\n\t\tg_set_error(error,\n\t\t\t    FWUPD_ERROR,\n\t\t\t    FWUPD_ERROR_INTERNAL,\n\t\t\t    \"failed to set permissions on %s\",\n\t\t\t    conf_path);\n\t\treturn FALSE;\n\t}\n\treturn fu_plugin_set_config_value(self, key, value, error);\n}", "target": 1}
{"code": "static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)\n{\n\tint x, y, pos;\n\tWbmp *wbmp;\n\tif((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {\n\t\tgd_error(\"Could not create WBMP\\n\");\n\t\treturn 1;\n\t}\n\tpos = 0;\n\tfor(y = 0; y < gdImageSY(image); y++) {\n\t\tfor(x = 0; x < gdImageSX(image); x++) {\n\t\t\tif(gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\twbmp->bitmap[pos] = WBMP_BLACK;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\tif(writewbmp(wbmp, &gd_putout, out)) {\n\t\tfreewbmp(wbmp);\n\t\tgd_error(\"Could not save WBMP\\n\");\n\t\treturn 1;\n\t}\n\tfreewbmp(wbmp);\n\treturn 0;\n}", "target": 0}
{"code": "void gnrc_sixlowpan_iphc_send(gnrc_pktsnip_t *pkt, void *ctx, unsigned page)\n{\n    gnrc_netif_hdr_t *netif_hdr = pkt->data;\n    gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(netif_hdr);\n    gnrc_pktsnip_t *tmp;\n    size_t orig_datagram_size = gnrc_pkt_len(pkt->next);\n    ipv6_hdr_t *ipv6_hdr = pkt->next->data;\n    ipv6_addr_t dst;\n    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n        dst = ipv6_hdr->dst;    \n    }\n    if ((tmp = _iphc_encode(pkt, pkt->data, netif))) {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) && (ctx != NULL) &&\n            (gnrc_sixlowpan_frag_minfwd_frag_iphc(tmp, orig_datagram_size, &dst,\n                                                  ctx) == 0)) {\n            DEBUG(\"6lo iphc minfwd: putting slack in first fragment\\n\");\n            return;\n        }\n        gnrc_sixlowpan_multiplex_by_size(tmp, orig_datagram_size, netif, page);\n    }\n    else {\n        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD)) {\n            gnrc_sixlowpan_frag_fb_t *fb = ctx;\n            if (fb->pkt == pkt) {\n                fb->pkt = NULL;\n            }\n        }\n        gnrc_pktbuf_release(pkt);\n    }\n}", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tif (buf_offset + 8 > sz) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.annotation_array.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "static int ipv6_route_open(struct inode *inode, struct file *file)\n{\n\treturn single_open_net(inode, file, ipv6_route_show);\n}", "target": 0}
{"code": "static void freeInstParams (AFPVu *values, int fileFormat)\n{\n\tint\ti;\n\tint\tparameterCount = _af_units[fileFormat].instrumentParameterCount;\n\tfor (i=0; i<parameterCount; i++)\n\t{\n\t\tif (_af_units[fileFormat].instrumentParameters[i].type == AU_PVTYPE_PTR)\n\t\t\tif (values[i].v != NULL)\n\t\t\t\tfree(values[i].v);\n\t}\n\tfree(values);\n}", "target": 0}
{"code": "snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length)\n{\n  *out-- = length;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OID;\n  varbind->value.oid = ret_oid;\n}", "target": 1}
{"code": "bool inode_capable(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);\n}", "target": 1}
{"code": "void* ipc_alloc(int size)\n{\n\tvoid* out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}", "target": 1}
{"code": "MmkvHostObject::MmkvHostObject(const std::string& instanceId, std::string path,\n                               std::string cryptKey) {\n  __android_log_print(ANDROID_LOG_INFO, \"RNMMKV\",\n                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encryption-Key: %s)\",\n                      instanceId.c_str(), path.c_str(), cryptKey.c_str());\n  std::string* pathPtr = path.size() > 0 ? &path : nullptr;\n  std::string* cryptKeyPtr = cryptKey.size() > 0 ? &cryptKey : nullptr;\n  instance = MMKV::mmkvWithID(instanceId, mmkv::DEFAULT_MMAP_SIZE, MMKV_SINGLE_PROCESS, cryptKeyPtr,\n                              pathPtr);\n  if (instance == nullptr) {\n    if (instanceId.empty()) {\n      throw std::runtime_error(\"Failed to create MMKV instance! `id` cannot be empty!\");\n    }\n    if (cryptKey.size() > 16) {\n      throw std::runtime_error(\n          \"Failed to create MMKV instance! `encryptionKey` cannot be longer than 16 bytes!\");\n    }\n    throw std::runtime_error(\"Failed to create MMKV instance!\");\n  }\n}", "target": 1}
{"code": "int tpm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct tpm_chip *chip = NULL, *pos;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pos, &tpm_chip_list, list) {\n\t\tif (pos->vendor.miscdev.minor == minor) {\n\t\t\tchip = pos;\n\t\t\tget_device(chip->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tif (!chip)\n\t\treturn -ENODEV;\n\tif (test_and_set_bit(0, &chip->is_open)) {\n\t\tdev_dbg(chip->dev, \"Another process owns this TPM\\n\");\n\t\tput_device(chip->dev);\n\t\treturn -EBUSY;\n\t}\n\tchip->data_buffer = kmalloc(TPM_BUFSIZE * sizeof(u8), GFP_KERNEL);\n\tif (chip->data_buffer == NULL) {\n\t\tclear_bit(0, &chip->is_open);\n\t\tput_device(chip->dev);\n\t\treturn -ENOMEM;\n\t}\n\tatomic_set(&chip->data_pending, 0);\n\tfile->private_data = chip;\n\treturn 0;\n}", "target": 1}
{"code": "int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;\n\t\t}\n\t\tif (dev->ops->check_presence)\n\t\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\trc = dev->ops->im_transceive(dev, dev->active_target, skb, cb,\n\t\t\t\t\t     cb_context);\n\t\tif (!rc && dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t} else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) {\n\t\trc = dev->ops->tm_send(dev, skb);\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int evtchn_fifo_percpu_deinit(unsigned int cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, true);\n\treturn 0;\n}", "target": 1}
{"code": "static int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\thwc->state = !(flags & PERF_EF_START);\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\tWARN_ON_ONCE(swhash->online);\n\t\treturn -EINVAL;\n\t}\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\treturn 0;\n}", "target": 1}
{"code": "static inline bool nvme_is_write(NvmeRequest *req)\n{\n    NvmeRwCmd *rw = (NvmeRwCmd *)&req->cmd;\n    return rw->opcode == NVME_CMD_WRITE ||\n           rw->opcode == NVME_CMD_ZONE_APPEND ||\n           rw->opcode == NVME_CMD_WRITE_ZEROES;\n}", "target": 0}
{"code": "optional<ARN> ARN::parse(const string& s, bool wildcards) {\n  static const char str_wild[] = \"arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)\";\n  static const regex rx_wild(str_wild,\n\t\t\t\t    sizeof(str_wild) - 1,\n\t\t\t\t    ECMAScript | optimize);\n  static const char str_no_wild[]\n    = \"arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)\";\n  static const regex rx_no_wild(str_no_wild,\n\t\t\t\tsizeof(str_no_wild) - 1,\n\t\t\t\tECMAScript | optimize);\n  smatch match;\n  if ((s == \"*\") && wildcards) {\n    return ARN(Partition::wildcard, Service::wildcard, \"*\", \"*\", \"*\");\n  } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {\n    ceph_assert(match.size() == 6);\n    ARN a;\n    {\n      auto p = to_partition(match[1], wildcards);\n      if (!p)\n\treturn none;\n      a.partition = *p;\n    }\n    {\n      auto s = to_service(match[2], wildcards);\n      if (!s) {\n\treturn none;\n      }\n      a.service = *s;\n    }\n    a.region = match[3];\n    a.account = match[4];\n    a.resource = match[5];\n    return a;\n  }\n  return none;\n}", "target": 1}
{"code": "static inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)\n{\n\tswitch (endian) {\n\tdefault:\n\t\t*s = (wchar_t) c;\n\t\tbreak;\n\tcase UTF16_LITTLE_ENDIAN:\n\t\t*s = __cpu_to_le16(c);\n\t\tbreak;\n\tcase UTF16_BIG_ENDIAN:\n\t\t*s = __cpu_to_be16(c);\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "bool RequestParser::OnHeadersEnd() {\n  bool matched = view_matcher_(request_->method(), request_->url().path(),\n                               &stream_);\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             request_->url().path().c_str());\n  }\n  return matched;\n}", "target": 1}
{"code": "R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAnnotation *annotation = NULL;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tannotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\tfor (i = 0; i < annotation->num_element_value_pairs; i++) {\n\t\tif (offset > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tevps = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (evps) {\n\t\t\toffset += evps->size;\n\t\t\tr_list_append (annotation->element_value_pairs, (void *) evps);\n\t\t}\n\t}\n\tannotation->size = offset;\n\treturn annotation;\n}", "target": 1}
{"code": "static inline int sector_in_part(struct hd_struct *part, sector_t sector)\n{\n\treturn part->start_sect <= sector &&\n\t\tsector < part->start_sect + part_nr_sects_read(part);\n}", "target": 0}
{"code": "errno_t sss_filter_sanitize_ex(TALLOC_CTX *mem_ctx,\n                               const char *input,\n                               char **sanitized,\n                               const char *ignore)\n{\n    char *output;\n    size_t i = 0;\n    size_t j = 0;\n    char *allowed;\n    output = talloc_array(mem_ctx, char, strlen(input) * 3 + 1);\n    if (!output) {\n        return ENOMEM;\n    }\n    while (input[i]) {\n        if (ignore == NULL) {\n            allowed = NULL;\n        } else {\n            allowed = strchr(ignore, input[i]);\n        }\n        if (allowed) {\n            output[j++] = input[i++];\n            continue;\n        }\n        switch(input[i]) {\n        case '\\t':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = '9';\n            break;\n        case ' ':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '0';\n            break;\n        case '*':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = 'a';\n            break;\n        case '(':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '8';\n            break;\n        case ')':\n            output[j++] = '\\\\';\n            output[j++] = '2';\n            output[j++] = '9';\n            break;\n        case '\\\\':\n            output[j++] = '\\\\';\n            output[j++] = '5';\n            output[j++] = 'c';\n            break;\n        case '\\r':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = 'd';\n            break;\n        case '\\n':\n            output[j++] = '\\\\';\n            output[j++] = '0';\n            output[j++] = 'a';\n            break;\n        default:\n            output[j++] = input[i];\n        }\n        i++;\n    }\n    output[j] = '\\0';\n    *sanitized = talloc_realloc(mem_ctx, output, char, j+1);\n    if (!*sanitized) {\n        talloc_free(output);\n        return ENOMEM;\n    }\n    return EOK;\n}", "target": 1}
{"code": "int cil_build_ast(struct cil_db *db, struct cil_tree_node *parse_tree, struct cil_tree_node *ast)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_build extra_args;\n\tif (db == NULL || parse_tree == NULL || ast == NULL) {\n\t\tgoto exit;\n\t}\n\textra_args.ast = ast;\n\textra_args.db = db;\n\textra_args.tunif = NULL;\n\textra_args.in = NULL;\n\textra_args.macro = NULL;\n\textra_args.optional = NULL;\n\textra_args.boolif = NULL;\n\trc = cil_tree_walk(parse_tree, __cil_build_ast_node_helper, __cil_build_ast_first_child_helper, __cil_build_ast_last_child_helper, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\treturn SEPOL_OK;\nexit:\n\treturn rc;\n}", "target": 0}
{"code": "  void ValidateInputTensors(OpKernelContext* ctx, const Tensor& in0,\n                            const Tensor& in1) override {\n    OP_REQUIRES(\n        ctx, in0.dims() >= 2,\n        errors::InvalidArgument(\"In[0] ndims must be >= 2: \", in0.dims()));\n    OP_REQUIRES(\n        ctx, in1.dims() >= 2,\n        errors::InvalidArgument(\"In[0] ndims must be >= 2: \", in1.dims()));\n  }", "target": 1}
{"code": "static const jpc_mstabent_t *jpc_mstab_lookup(int id)\n{\n\tconst jpc_mstabent_t *mstabent;\n\tfor (mstabent = jpc_mstab;; ++mstabent) {\n\t\tif (mstabent->id == id || mstabent->id < 0) {\n\t\t\treturn mstabent;\n\t\t}\n\t}\n\tassert(0);\n\treturn 0;\n}", "target": 0}
{"code": "void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n{\n\tstruct rdma_umap_priv *priv, *next_priv;\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\twhile (1) {\n\t\tstruct mm_struct *mm = NULL;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\twhile (!list_empty(&ufile->umaps)) {\n\t\t\tint ret;\n\t\t\tpriv = list_first_entry(&ufile->umaps,\n\t\t\t\t\t\tstruct rdma_umap_priv, list);\n\t\t\tmm = priv->vma->vm_mm;\n\t\t\tret = mmget_not_zero(mm);\n\t\t\tif (!ret) {\n\t\t\t\tlist_del_init(&priv->list);\n\t\t\t\tmm = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tif (!mm)\n\t\t\treturn;\n\t\tdown_write(&mm->mmap_sem);\n\t\tif (!mmget_still_valid(mm))\n\t\t\tgoto skip_mm;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n\t\t\t\t\t  list) {\n\t\t\tstruct vm_area_struct *vma = priv->vma;\n\t\t\tif (vma->vm_mm != mm)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&priv->list);\n\t\t\tzap_vma_ptes(vma, vma->vm_start,\n\t\t\t\t     vma->vm_end - vma->vm_start);\n\t\t\tvma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\tskip_mm:\n\t\tup_write(&mm->mmap_sem);\n\t\tmmput(mm);\n\t}\n}", "target": 0}
{"code": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}", "target": 1}
{"code": "static int can_open_delegated(struct nfs_delegation *delegation, mode_t open_flags)\n{\n\tif ((delegation->type & open_flags) != open_flags)\n\t\treturn 0;\n\tif (test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags))\n\t\treturn 0;\n\tnfs_mark_delegation_referenced(delegation);\n\treturn 1;\n}", "target": 1}
{"code": "void BlockCodec::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tAFframecount framesRead = 0;\n\tassert(framesToRead % m_framesPerPacket == 0);\n\tint blockCount = framesToRead / m_framesPerPacket;\n\tssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);\n\tint blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;\n\tfor (int i=0; i<blocksRead; i++)\n\t{\n\t\tdecodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,\n\t\t\tstatic_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount);\n\t\tframesRead += m_framesPerPacket;\n\t}\n\tm_track->nextfframe += framesRead;\n\tassert(tell() == m_track->fpos_next_frame);\n\tif (framesRead < framesToRead)\n\t\treportReadError(framesRead, framesToRead);\n\tm_outChunk->frameCount = framesRead;\n}", "target": 1}
{"code": "static UINT urb_bulk_or_interrupt_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                           wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                           IUDEVMAN* udevman, int transferDir)\n{\n\tUINT32 EndpointAddress, PipeHandle;\n\tUINT32 TransferFlags, OutputBufferSize;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\tif (!pdev || !callback || !s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(s, PipeHandle);\n\tStream_Read_UINT32(s, TransferFlags); \n\tStream_Read_UINT32(s, OutputBufferSize);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (!Stream_CheckAndLogRequiredLength(TAG, s, OutputBufferSize))\n\t\t{\n\t\t\treturn ERROR_INVALID_DATA;\n\t\t}\n\t}\n\treturn pdev->bulk_or_interrupt_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, noAck,\n\t    OutputBufferSize, (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_bulk_transfer_cb, 10000);\n}", "target": 0}
{"code": "static void mark_all_scalars_precise(struct bpf_verifier_env *env,\n\t\t\t\t     struct bpf_verifier_state *st)\n{\n\tstruct bpf_func_state *func;\n\tstruct bpf_reg_state *reg;\n\tint i, j;\n\tfor (; st; st = st->parent)\n\t\tfor (i = 0; i <= st->curframe; i++) {\n\t\t\tfunc = st->frame[i];\n\t\t\tfor (j = 0; j < BPF_REG_FP; j++) {\n\t\t\t\treg = &func->regs[j];\n\t\t\t\tif (reg->type != SCALAR_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\treg->precise = true;\n\t\t\t}\n\t\t\tfor (j = 0; j < func->allocated_stack / BPF_REG_SIZE; j++) {\n\t\t\t\tif (!is_spilled_reg(&func->stack[j]))\n\t\t\t\t\tcontinue;\n\t\t\t\treg = &func->stack[j].spilled_ptr;\n\t\t\t\tif (reg->type != SCALAR_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\treg->precise = true;\n\t\t\t}\n\t\t}\n}", "target": 0}
{"code": "int fit_check_format(const void *fit, ulong size)\n{\n\tint ret;\n\tret = fdt_check_header(fit);\n\tif (ret) {\n\t\tlog_debug(\"Wrong FIT format: not a flattened device tree (err=%d)\\n\",\n\t\t\t  ret);\n\t\treturn -ENOEXEC;\n\t}\n\tif (CONFIG_IS_ENABLED(FIT_FULL_CHECK)) {\n\t\tif (size == IMAGE_SIZE_INVAL)\n\t\t\tsize = fdt_totalsize(fit);\n\t\tret = fdt_check_full(fit, size);\n\t\tif (ret)\n\t\t\tret = -EINVAL;\n\t\tif (!ret && CONFIG_IS_ENABLED(FIT_SIGNATURE)) {\n\t\t\tret = fdt_check_no_at(fit, 0);\n\t\t\tif (ret) {\n\t\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (ret) {\n\t\t\tlog_debug(\"FIT check error %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (!fdt_getprop(fit, 0, FIT_DESC_PROP, NULL)) {\n\t\tlog_debug(\"Wrong FIT format: no description\\n\");\n\t\treturn -ENOMSG;\n\t}\n\tif (IMAGE_ENABLE_TIMESTAMP) {\n\t\tif (!fdt_getprop(fit, 0, FIT_TIMESTAMP_PROP, NULL)) {\n\t\t\tlog_debug(\"Wrong FIT format: no timestamp\\n\");\n\t\t\treturn -ENODATA;\n\t\t}\n\t}\n\tif (fdt_path_offset(fit, FIT_IMAGES_PATH) < 0) {\n\t\tlog_debug(\"Wrong FIT format: no images parent node\\n\");\n\t\treturn -ENOENT;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "absl::StatusOr<tensorflow::Tensor> DecompressTensorFromProto(\n    const tensorflow::TensorProto& proto) {\n  if (!IsSupported(proto.dtype())) {\n    return absl::InvalidArgumentError(absl::StrCat(\n        \"Tensor of dtype \", tensorflow::DataTypeString(proto.dtype()),\n        \" is not supported for decompression.\"));\n  }\n  if (proto.dtype() == tensorflow::DT_STRING) {\n    tensorflow::Tensor tensor;\n    REVERB_CHECK(tensor.FromProto(proto));\n    return tensor;\n  } else {\n    tensorflow::Tensor tensor(proto.dtype(),\n                              tensorflow::TensorShape(proto.tensor_shape()));\n    const auto& tensor_content = proto.tensor_content();\n    SnappyUncompressToString(tensor_content, tensor.tensor_data().size(),\n                             const_cast<char*>(tensor.tensor_data().data()));\n    return tensor;\n  }\n}", "target": 0}
{"code": "double enclave_check_abi()\n{\n    double retval = NAN;\n    oe_result_t result = OE_UNEXPECTED;\n    abi_state_t before_ocall_state = {};\n    abi_state_t after_ocall_state = {};\n    typedef struct _host_check_abi_args_t\n    {\n        oe_result_t _result;\n        void* deepcopy_out_buffer;\n        size_t deepcopy_out_buffer_size;\n        double _retval;\n    } host_check_abi_args_t;\n    typedef struct _flat_ocall_args\n    {\n        oe_call_host_function_args_t host_function_args;\n        host_check_abi_args_t check_abi_args;\n    } flat_ocall_args_t;\n    static const size_t abi_fcn_id_host_check_abi = 0;\n    const flat_ocall_args_t args_template = {\n        {.function_id = abi_fcn_id_host_check_abi,\n         .input_buffer = NULL,\n         .input_buffer_size = sizeof(args_template.check_abi_args),\n         .output_buffer = NULL,\n         .output_buffer_size = sizeof(args_template.check_abi_args),\n         .output_bytes_written = 0,\n         .result = OE_UNEXPECTED},\n        {._result = OE_UNEXPECTED,\n         .deepcopy_out_buffer = NULL,\n         .deepcopy_out_buffer_size = 0,\n         ._retval = 0}};\n    flat_ocall_args_t* args =\n        (flat_ocall_args_t*)oe_allocate_ocall_buffer(sizeof(args_template));\n    if (!args)\n        goto done;\n    memcpy(args, &args_template, sizeof(args_template));\n    args->host_function_args.input_buffer = &args->check_abi_args;\n    args->host_function_args.output_buffer = &args->check_abi_args;\n    set_test_abi_state();\n    read_abi_state(&before_ocall_state);\n    result = oe_ocall(OE_OCALL_CALL_HOST_FUNCTION, (uint64_t)args, NULL);\n    read_abi_state(&after_ocall_state);\n    reset_test_abi_state();\n    if (result != OE_OK)\n        goto done;\n    if (args->host_function_args.result != OE_OK)\n        goto done;\n    if (args->host_function_args.output_bytes_written !=\n        sizeof(args_template.check_abi_args))\n        goto done;\n    if (args->check_abi_args._retval != EXPECTED_CHECK_ABI_RETURN_VALUE)\n        goto done;\n    if (!is_same_abi_state(&before_ocall_state, &after_ocall_state))\n        goto done;\n    retval = args->check_abi_args._retval;\ndone:\n    return retval;\n}", "target": 1}
{"code": "void LosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE i;\n  for(i = 0;i < m_ucCount;i++) {\n    class HuffmanDecoder *dc = m_pDCDecoder[i];\n    struct Line *line = top[i];\n    struct Line *pline= prev[i];\n    UBYTE ym = m_ucMCUHeight[i];\n    class PredictorBase *mcupred = m_pPredict[i];\n    LONG *lp = line->m_pData + m_ulX[i];\n    LONG *pp = (pline)?(pline->m_pData + m_ulX[i]):(NULL);\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[i];\n      do {\n        LONG v;\n        UBYTE symbol = dc->Get(&m_Stream);\n        if (symbol == 0) {\n          v = 0;\n        } else if (symbol == 16) {\n          v = -32768;\n        } else if (symbol > 16) {\n          JPG_THROW(MALFORMED_STREAM,\"LosslessScan::ParseMCU\",\n                    \"received an out-of-bounds symbol in a lossless JPEG scan\");\n        } else {\n          LONG thre = 1L << (symbol - 1);\n          LONG diff = m_Stream.Get(symbol); \n          if (diff < thre) {\n            diff += (-1L << symbol) + 1;\n          }\n          v = diff;\n        }\n        lp[0] = pred->DecodeSample(v,lp,pp);\n      } while(--xm && (lp++,pp++,pred = pred->MoveRight(),true));\n    } while(--ym && (pp = line->m_pData + m_ulX[i],line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + m_ulX[i],mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}", "target": 0}
{"code": "static int ras_putdata(jas_stream_t *out, ras_hdr_t *hdr, jas_image_t *image, int numcmpts, int *cmpts)\n{\n\tint ret;\n\tswitch (hdr->type) {\n\tcase RAS_TYPE_STD:\n\t\tret = ras_putdatastd(out, hdr, image, numcmpts, cmpts);\n\t\tbreak;\n\tdefault:\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\tmemcpy (res, dbg_data, nb10sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}", "target": 1}
{"code": "void mlock_vma_page(struct page *page)\n{\n\tBUG_ON(!PageLocked(page));\n\tif (!TestSetPageMlocked(page)) {\n\t\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t\tif (!isolate_lru_page(page))\n\t\t\tputback_lru_page(page);\n\t}\n}", "target": 0}
{"code": "sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  memcpy(dest, src, len);\n}", "target": 1}
{"code": "static void __nfs4_close(struct path *path, struct nfs4_state *state, mode_t mode, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tint newstate;\n\tatomic_inc(&owner->so_count);\n\tspin_lock(&owner->so_lock);\n\tswitch (mode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(path, state, wait);\n}", "target": 1}
{"code": "static inline int checkSettingSecurity(lua_State* L, const std::string &name)\n{\n\tif (ScriptApiSecurity::isSecure(L) && name.compare(0, 7, \"secure.\") == 0)\n\t\tthrow LuaError(\"Attempt to set secure setting.\");\n\tbool is_mainmenu = false;\n#ifndef SERVER\n\tis_mainmenu = ModApiBase::getGuiEngine(L) != nullptr;\n#endif\n\tif (!is_mainmenu && (name == \"mg_name\" || name == \"mg_flags\")) {\n\t\terrorstream << \"Tried to set global setting \" << name << \", ignoring. \"\n\t\t\t\"minetest.set_mapgen_setting() should be used instead.\" << std::endl;\n\t\tinfostream << script_get_backtrace(L) << std::endl;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}", "target": 1}
{"code": "static int rmqueue_bulk(struct zone *zone, unsigned int order,\n\t\t\tunsigned long count, struct list_head *list,\n\t\t\tint migratetype)\n{\n\tint i, alloced = 0;\n\tspin_lock(&zone->lock);\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct page *page = __rmqueue(zone, order, migratetype);\n\t\tif (unlikely(page == NULL))\n\t\t\tbreak;\n\t\tif (unlikely(check_pcp_refill(page)))\n\t\t\tcontinue;\n\t\tlist_add_tail(&page->lru, list);\n\t\talloced++;\n\t\tif (is_migrate_cma(get_pcppage_migratetype(page)))\n\t\t\t__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,\n\t\t\t\t\t      -(1 << order));\n\t}\n\t__mod_zone_page_state(zone, NR_FREE_PAGES, -(i << order));\n\tspin_unlock(&zone->lock);\n\treturn alloced;\n}", "target": 0}
{"code": "void ArrowHead()\n{\n    int k;\n    double length;\n    SaveGraphicsState;\n    if ( flip ) length = -arrow.length;\n    else        length =  arrow.length;\n    SetDashSize(0,0);\n    if ( arrow.stroke ) {\n        SetLineWidth(arrow.stroke);\n        for (k = 1; k <= 2; k++ ) {\n            SaveGraphicsState;\n            MoveTo(length*0.5,0);\n            LineTo(-length*0.5,arrow.width);\n            LineTo(-length*0.5+length*arrow.inset,0);\n            LineTo(-length*0.5,-arrow.width);\n            if (k == 1) {\n                SetBackgroundColor(NONSTROKING);\n                outpos += sprintf(outpos,\" h f\");\n            }\n            else {\n                outpos += sprintf(outpos,\" s\");\n            }\n            RestoreGraphicsState;\n        }\n    }\n    else {\n        MoveTo(length*0.5,0);\n        LineTo(-length*0.5,arrow.width);\n        LineTo(-length*0.5+length*arrow.inset,0);\n        LineTo(-length*0.5,-arrow.width);\n        outpos += sprintf(outpos,\" h f\");\n    }\n    RestoreGraphicsState;\n}", "target": 1}
{"code": "static int nfs4_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tint error;\n\tnfs_fattr_init(fsinfo->fattr);\n\terror = nfs4_do_fsinfo(server, fhandle, fsinfo);\n\tif (error == 0) {\n\t\tserver->pnfs_blksize = fsinfo->blksize;\n\t\tset_pnfs_layoutdriver(server, fhandle, fsinfo->layouttype);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "static bool parseUrlAddrFromRtspUrlString(const char* rtspUrlString, char* destination, size_t destinationLength) {\n    char* rtspUrlScratchBuffer;\n    char* portSeparator;\n    char* v6EscapeEndChar;\n    char* urlPathSeparator;\n    int prefixLen;\n    rtspUrlScratchBuffer = strdup(rtspUrlString);\n    if (rtspUrlScratchBuffer == NULL) {\n        return false;\n    }\n    portSeparator = strrchr(rtspUrlScratchBuffer, ':');\n    v6EscapeEndChar = strchr(rtspUrlScratchBuffer, ']');\n    for (prefixLen = 2; rtspUrlScratchBuffer[prefixLen - 2] != 0 && (rtspUrlScratchBuffer[prefixLen - 2] != '/' || rtspUrlScratchBuffer[prefixLen - 1] != '/'); prefixLen++);\n    if (rtspUrlScratchBuffer[prefixLen - 2] == 0) {\n        free(rtspUrlScratchBuffer);\n        return false;\n    }\n    urlPathSeparator = strchr(rtspUrlScratchBuffer + prefixLen, '/');\n    if (v6EscapeEndChar) {\n        *(v6EscapeEndChar + 1) = 0;\n    }\n    else if (portSeparator) {\n        *portSeparator = 0;\n    }\n    else if (urlPathSeparator) {\n        *urlPathSeparator = 0;\n    }\n    PltSafeStrcpy(destination, destinationLength, rtspUrlScratchBuffer + prefixLen);\n    destination[destinationLength - 1] = '\\0';\n    free(rtspUrlScratchBuffer);\n    return true;\n}", "target": 0}
{"code": "_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  char *last_elem, *wp;\n  last_elem = wp = result;\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n  *wp = '\\0';\n  return result;\n}", "target": 1}
{"code": "static void perform_renew(void)\n{\n\tbb_info_msg(\"Performing a DHCP renew\");\n\tswitch (state) {\n\tcase BOUND:\n\t\tchange_listen_mode(LISTEN_KERNEL);\n\tcase RENEWING:\n\tcase REBINDING:\n\t\tstate = RENEW_REQUESTED;\n\t\tbreak;\n\tcase RENEW_REQUESTED: \n\t\tudhcp_run_script(NULL, \"deconfig\");\n\tcase REQUESTING:\n\tcase RELEASED:\n\t\tchange_listen_mode(LISTEN_RAW);\n\t\tstate = INIT_SELECTING;\n\t\tbreak;\n\tcase INIT_SELECTING:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pcu)\n{\n\tconst struct usb_cdc_union_desc *union_desc;\n\tstruct usb_host_interface *alt;\n\tunion_desc = ims_pcu_get_cdc_union_desc(intf);\n\tif (!union_desc)\n\t\treturn -EINVAL;\n\tpcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bMasterInterface0);\n\tif (!pcu->ctrl_intf)\n\t\treturn -EINVAL;\n\talt = pcu->ctrl_intf->cur_altsetting;\n\tpcu->ep_ctrl = &alt->endpoint[0].desc;\n\tpcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);\n\tpcu->data_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bSlaveInterface0);\n\tif (!pcu->data_intf)\n\t\treturn -EINVAL;\n\talt = pcu->data_intf->cur_altsetting;\n\tif (alt->desc.bNumEndpoints != 2) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Incorrect number of endpoints on data interface (%d)\\n\",\n\t\t\talt->desc.bNumEndpoints);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_out = &alt->endpoint[0].desc;\n\tif (!usb_endpoint_is_bulk_out(pcu->ep_out)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"First endpoint on data interface is not BULK OUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_out_size = usb_endpoint_maxp(pcu->ep_out);\n\tif (pcu->max_out_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max OUT packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_out_size);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_in = &alt->endpoint[1].desc;\n\tif (!usb_endpoint_is_bulk_in(pcu->ep_in)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Second endpoint on data interface is not BULK IN\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_in_size = usb_endpoint_maxp(pcu->ep_in);\n\tif (pcu->max_in_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max IN packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_in_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;", "target": 0}
{"code": "long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n)\n{\n\tlong v;\n\tint u;\n\tassert(n >= 0 && n < 32);\n\tv = 0;\n\twhile (--n >= 0) {\n\t\tif ((u = jpc_bitstream_getbit(bitstream)) < 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tv = (v << 1) | u;\n\t}\n\treturn v;\n}", "target": 1}
{"code": "void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)\n{\n\t__issue_discard_cmd(sbi, false);\n\t__drop_discard_cmd(sbi);\n\t__wait_discard_cmd(sbi, false);\n}", "target": 1}
{"code": "Bool rfbOptPamAuth(void)\n{\n  SecTypeData *s;\n  for (s = secTypes; s->name != NULL; s++) {\n    if ((!strcmp(s->name, \"unixlogin\") ||\n         !strcmp(&s->name[strlen(s->name) - 5], \"plain\")) && s->enabled)\n      return TRUE;\n  }\n  return FALSE;\n}", "target": 1}
{"code": "scrypt_SHA256_Update(struct SHA256_CTX * ctx, const void *in, size_t len)\n{\n  uint32_t bitlen[2];\n  uint32_t r;\n  const unsigned char *src = (unsigned char *) in;\n  r = (ctx->count[1] >> 3) & 0x3f;\n  bitlen[1] = ((uint32_t)len) << 3;\n  bitlen[0] = (uint32_t)(len >> 29);\n  if ((ctx->count[1] += bitlen[1]) < bitlen[1])\n    ctx->count[0]++;\n  ctx->count[0] += bitlen[0];\n  if (len < 64 - r) {\n    memcpy(&ctx->buf[r], src, len);\n    return;\n  }\n  memcpy(&ctx->buf[r], src, 64 - r);\n  SHA256_Transform(ctx->state, ctx->buf);\n  src += 64 - r;\n  len -= 64 - r;\n  while (len >= 64) {\n    SHA256_Transform(ctx->state, src);\n    src += 64;\n    len -= 64;\n  }\n  memcpy(ctx->buf, src, len);\n}", "target": 1}
{"code": "static int cdrom_ioctl_drive_status(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_DRIVE_STATUS\\n\");\n\tif (!(cdi->ops->capability & CDC_DRIVE_STATUS))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) ||\n\t    (arg == CDSL_CURRENT || arg == CDSL_NONE))\n\t\treturn cdi->ops->drive_status(cdi, CDSL_CURRENT);\n\tif (((int)arg >= cdi->capacity))\n\t\treturn -EINVAL;\n\treturn cdrom_slot_status(cdi, arg);\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr || sz < 10) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_ENCLOSING_METHOD_ATTR;\n\tattr->info.enclosing_method_attr.class_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.enclosing_method_attr.method_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.enclosing_method_attr.class_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.class_idx);\n\tif (attr->info.enclosing_method_attr.class_name == NULL) {\n\t\teprintf (\"Could not resolve enclosing class name for the enclosed method.\\n\");\n\t}\n\tattr->info.enclosing_method_attr.method_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);\n\tif (attr->info.enclosing_method_attr.class_name == NULL) {\n\t\teprintf (\"Could not resolve method descriptor for the enclosed method.\\n\");\n\t}\n\tattr->info.enclosing_method_attr.method_descriptor = r_bin_java_get_desc_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);\n\tif (attr->info.enclosing_method_attr.method_name == NULL) {\n\t\teprintf (\"Could not resolve method name for the enclosed method.\\n\");\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "target": 0}
{"code": "static void msg_read_tiny(const uint8_t *msg, size_t len) {\n    if (len != 64)\n        return;\n    uint8_t buf[64];\n    memcpy(buf, msg, sizeof(buf));\n    if (buf[0] != '?' || buf[1] != '#' || buf[2] != '#') {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n        return;\n    }\n    uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n    uint32_t msgSize = buf[8]        |\n            ((uint32_t)buf[7]) <<  8 |\n            ((uint32_t)buf[6]) << 16 |\n            ((uint32_t)buf[5]) << 24;\n    if (msgSize > 64 - 9) {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n        return;\n    }\n    const pb_field_t *fields = NULL;\n    pb_istream_t stream = pb_istream_from_buffer(buf + 9, msgSize);\n    switch (msgId) {\n    case MessageType_MessageType_PinMatrixAck:\n        fields = PinMatrixAck_fields;\n        break;\n    case MessageType_MessageType_ButtonAck:\n        fields = ButtonAck_fields;\n        break;\n    case MessageType_MessageType_PassphraseAck:\n        fields = PassphraseAck_fields;\n        break;\n    case MessageType_MessageType_Cancel:\n        fields = Cancel_fields;\n        break;\n    case MessageType_MessageType_Initialize:\n        fields = Initialize_fields;\n        break;\n#if DEBUG_LINK\n    case MessageType_MessageType_DebugLinkDecision:\n        fields = DebugLinkDecision_fields;\n        break;\n    case MessageType_MessageType_DebugLinkGetState:\n        fields = DebugLinkGetState_fields;\n        break;\n#endif\n    }\n    if (fields) {\n        bool status = pb_decode(&stream, fields, msg_tiny);\n        if (status) {\n            msg_tiny_id = msgId;\n        } else {\n            (*msg_failure)(FailureType_Failure_SyntaxError, stream.errmsg);\n            msg_tiny_id = 0xffff;\n        }\n    } else {\n        (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n        msg_tiny_id = 0xffff;\n    }\n}", "target": 0}
{"code": "json_t *json_object(void)\n{\n    json_object_t *object = jsonp_malloc(sizeof(json_object_t));\n    if(!object)\n        return NULL;\n    if (!hashtable_seed) {\n        json_object_seed(0);\n    }\n    json_init(&object->json, JSON_OBJECT);\n    if(hashtable_init(&object->hashtable))\n    {\n        jsonp_free(object);\n        return NULL;\n    }\n    object->serial = 0;\n    object->visited = 0;\n    return &object->json;\n}", "target": 0}
{"code": "void ip_options_build(struct sk_buff * skb, struct ip_options * opt,\n\t\t\t    __be32 daddr, struct rtable *rt, int is_frag)\n{\n\tunsigned char *iph = skb_network_header(skb);\n\tmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\n\tmemcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);\n\topt = &(IPCB(skb)->opt);\n\tif (opt->srr)\n\t\tmemcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);\n\tif (!is_frag) {\n\t\tif (opt->rr_needaddr)\n\t\t\tip_rt_get_source(iph+opt->rr+iph[opt->rr+2]-5, rt);\n\t\tif (opt->ts_needaddr)\n\t\t\tip_rt_get_source(iph+opt->ts+iph[opt->ts+2]-9, rt);\n\t\tif (opt->ts_needtime) {\n\t\t\tstruct timespec tv;\n\t\t\t__be32 midtime;\n\t\t\tgetnstimeofday(&tv);\n\t\t\tmidtime = htonl((tv.tv_sec % 86400) * MSEC_PER_SEC + tv.tv_nsec / NSEC_PER_MSEC);\n\t\t\tmemcpy(iph+opt->ts+iph[opt->ts+2]-5, &midtime, 4);\n\t\t}\n\t\treturn;\n\t}\n\tif (opt->rr) {\n\t\tmemset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);\n\t\topt->rr = 0;\n\t\topt->rr_needaddr = 0;\n\t}\n\tif (opt->ts) {\n\t\tmemset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);\n\t\topt->ts = 0;\n\t\topt->ts_needaddr = opt->ts_needtime = 0;\n\t}\n}", "target": 1}
{"code": "Eina_Bool ewk_view_editable_set(Evas_Object* ewkView, Eina_Bool editable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_editable_set(smartData->main_frame, editable);\n}", "target": 0}
{"code": "  static void setAppend(SetType& set, const VariantType& v) {\n    auto value_type = type(v);\n    if (value_type != HPHP::serialize::Type::INT64 &&\n        value_type != HPHP::serialize::Type::STRING) {\n      throw HPHP::serialize::UnserializeError(\n          \"Unsupported keyset element of type \" +\n          folly::to<std::string>(value_type));\n    }\n    set.append(v);\n  }", "target": 1}
{"code": "int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)\n{\n  char **atimes, **aranges = NULL;\n  int numtimes=0,i=0,numranges=0;\n  size_t buffer_size = 512;\n  char buffer[512], bufferTmp[512];\n  buffer[0] = '\\0';\n  bufferTmp[0] = '\\0';\n  if (!lp || !timestring || !timefield)\n    return MS_FALSE;\n  if( strchr(timestring,'\\'') || strchr(timestring, '\\\\') ) {\n     msSetError(MS_MISCERR, \"Invalid time filter.\", \"msPostGISLayerSetTimeFilter()\");\n     return MS_FALSE;\n  }\n  if (strstr(timestring, \",\") == NULL &&\n      strstr(timestring, \"/\") == NULL) { \n    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);\n  } else {\n    atimes = msStringSplit (timestring, ',', &numtimes);\n    if (atimes == NULL || numtimes < 1)\n      return MS_FALSE;\n    strlcat(buffer, \"(\", buffer_size);\n    for(i=0; i<numtimes; i++) {\n      if(i!=0) {\n        strlcat(buffer, \" OR \", buffer_size);\n      }\n      strlcat(buffer, \"(\", buffer_size);\n      aranges = msStringSplit(atimes[i],  '/', &numranges);\n      if(!aranges) return MS_FALSE;\n      if(numranges == 1) {\n        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else if(numranges == 2) {\n        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else {\n        return MS_FALSE;\n      }\n      msFreeCharArray(aranges, numranges);\n      strlcat(buffer, \")\", buffer_size);\n    }\n    strlcat(buffer, \")\", buffer_size);\n    msFreeCharArray(atimes, numtimes);\n  }\n  if(!*buffer) {\n    return MS_FALSE;\n  }\n  if(lp->filteritem) free(lp->filteritem);\n  lp->filteritem = msStrdup(timefield);\n  if (&lp->filter) {\n    if (lp->filter.type == MS_EXPRESSION) {\n      snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);\n      loadExpressionString(&lp->filter, bufferTmp);\n    } else {\n      freeExpression(&lp->filter);\n      loadExpressionString(&lp->filter, buffer);\n    }\n  }\n  return MS_TRUE;\n}", "target": 0}
{"code": "int CLua::execstring(const char *s, const char *context, int nresults)\n{\n    int err = 0;\n    if ((err = loadstring(s, context)))\n        return err;\n    lua_State *ls = state();\n    lua_call_throttle strangler(this);\n    err = lua_pcall(ls, 0, nresults, 0);\n    set_error(err, ls);\n    return err;\n}", "target": 0}
{"code": "int mp_unpack_full(lua_State *L, int limit, int offset) {\n    size_t len;\n    const char *s;\n    mp_cur c;\n    int cnt; \n    int decode_all = (!limit && !offset);\n    s = luaL_checklstring(L,1,&len); \n    if (offset < 0 || limit < 0) \n        return luaL_error(L,\n            \"Invalid request to unpack with offset of %d and limit of %d.\",\n            offset, len);\n    else if (offset > len)\n        return luaL_error(L,\n            \"Start offset %d greater than input length %d.\", offset, len);\n    if (decode_all) limit = INT_MAX;\n    mp_cur_init(&c,(const unsigned char *)s+offset,len-offset);\n    for(cnt = 0; c.left > 0 && cnt < limit; cnt++) {\n        mp_decode_to_lua_type(L,&c);\n        if (c.err == MP_CUR_ERROR_EOF) {\n            return luaL_error(L,\"Missing bytes in input.\");\n        } else if (c.err == MP_CUR_ERROR_BADFMT) {\n            return luaL_error(L,\"Bad data format in input.\");\n        }\n    }\n    if (!decode_all) {\n        int offset = len - c.left;\n        luaL_checkstack(L, 1, \"in function mp_unpack_full\");\n        lua_pushinteger(L, c.left == 0 ? -1 : offset);\n        lua_insert(L, 2);\n        cnt += 1; \n    }\n    return cnt;\n}", "target": 0}
{"code": "static int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\tif (!addr || addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tret = -EADDRINUSE;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\tsk->sk_state = LLCP_BOUND;\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 0}
{"code": "int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb)\n{\n\tint ret;\n\tint size;\n\tif (ud->side == USBIP_STUB) {\n\t\tif (usb_pipein(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->transfer_buffer_length;\n\t} else {\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\treturn 0;\n\t\tsize = urb->actual_length;\n\t}\n\tif (!(size > 0))\n\t\treturn 0;\n\tif (size > urb->transfer_buffer_length) {\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\tret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size);\n\tif (ret != size) {\n\t\tdev_err(&urb->dev->dev, \"recv xbuf, %d\\n\", ret);\n\t\tif (ud->side == USBIP_STUB) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\t} else {\n\t\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -EPIPE;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)\n{\n\tunsigned int first = 0;\n\tunsigned int last = ARR_SIZE(insn_regs_intel) - 1;\n\tunsigned int mid = ARR_SIZE(insn_regs_intel) / 2;\n\tif (!intel_regs_sorted) {\n\t\tmemcpy(insn_regs_intel_sorted, insn_regs_intel,\n\t\t\t\tsizeof(insn_regs_intel_sorted));\n\t\tqsort(insn_regs_intel_sorted,\n\t\t\t\tARR_SIZE(insn_regs_intel_sorted),\n\t\t\t\tsizeof(struct insn_reg), regs_cmp);\n\t\tintel_regs_sorted = true;\n\t}\n\twhile (first <= last) {\n\t\tif (insn_regs_intel_sorted[mid].insn < id) {\n\t\t\tfirst = mid + 1;\n\t\t} else if (insn_regs_intel_sorted[mid].insn == id) {\n\t\t\tif (access) {\n\t\t\t\t*access = insn_regs_intel_sorted[mid].access;\n\t\t\t}\n\t\t\treturn insn_regs_intel_sorted[mid].reg;\n\t\t} else {\n\t\t\tif (mid == 0)\n\t\t\t\tbreak;\n\t\t\tlast = mid - 1;\n\t\t}\n\t\tmid = (first + last) / 2;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "im_vips2dz( IMAGE *in, const char *filename )\n{\n\tchar *p, *q;\n\tchar name[FILENAME_MAX];\n\tchar mode[FILENAME_MAX];\n\tchar buf[FILENAME_MAX];\n\tint i;\n\tVipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ; \n\tchar *suffix = \".jpeg\";\n\tint overlap = 0;\n\tint tile_size = 256;\n\tVipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL; \n\tgboolean centre = FALSE;\n\tVipsAngle angle = VIPS_ANGLE_D0; \n\tim_strncpy( name, filename, FILENAME_MAX ); \n\tif( (p = strchr( name, ':' )) ) {\n\t\t*p = '\\0';\n\t\tim_strncpy( mode, p + 1, FILENAME_MAX ); \n\t}\n\telse \n\t\tstrcpy( mode, \"\" ); \n\tstrcpy( buf, mode ); \n\tp = &buf[0];\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 ) \n\t\t\treturn( -1 );\n\t\tlayout = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) \n\t\tsuffix = g_strdup( q );\n\tif( (q = im_getnextoption( &p )) ) \n\t\toverlap = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) \n\t\ttile_size = atoi( q ); \n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tdepth = i;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( im_isprefix( \"cen\", q ) ) \n\t\t\tcentre = TRUE;\n\t}\n\tif( (q = im_getnextoption( &p )) ) {\n\t\tif( (i = vips_enum_from_nick( \"im_vips2dz\", \n\t\t\tVIPS_TYPE_ANGLE, q )) < 0 )\n\t\t\treturn( -1 );\n\t\tangle = i;\n\t}\n\tif( vips_dzsave( in, name,\n\t\t\"layout\", layout,\n\t\t\"suffix\", suffix,\n\t\t\"overlap\", overlap,\n\t\t\"tile_size\", tile_size,\n\t\t\"depth\", depth,\n\t\t\"centre\", centre,\n\t\t\"angle\", angle,\n\t\tNULL ) )\n\t\treturn( -1 );\n\treturn( 0 );\n}", "target": 0}
{"code": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}", "target": 0}
{"code": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "void __init xen_init_IRQ(void)\n{\n\tint ret = -EINVAL;\n\tevtchn_port_t evtchn;\n\tif (fifo_events)\n\t\tret = xen_evtchn_fifo_init();\n\tif (ret < 0)\n\t\txen_evtchn_2l_init();\n\txen_cpu_init_eoi(smp_processor_id());\n\tcpuhp_setup_state_nocalls(CPUHP_XEN_EVTCHN_PREPARE,\n\t\t\t\t  \"xen/evtchn:prepare\",\n\t\t\t\t  xen_evtchn_cpu_prepare, xen_evtchn_cpu_dead);\n\tevtchn_to_irq = kcalloc(EVTCHN_ROW(xen_evtchn_max_channels()),\n\t\t\t\tsizeof(*evtchn_to_irq), GFP_KERNEL);\n\tBUG_ON(!evtchn_to_irq);\n\tfor (evtchn = 0; evtchn < xen_evtchn_nr_channels(); evtchn++)\n\t\tmask_evtchn(evtchn);\n\tpirq_needs_eoi = pirq_needs_eoi_flag;\n#ifdef CONFIG_X86\n\tif (xen_pv_domain()) {\n\t\tif (xen_initial_domain())\n\t\t\tpci_xen_initial_domain();\n\t}\n\tif (xen_feature(XENFEAT_hvm_callback_vector)) {\n\t\txen_setup_callback_vector();\n\t\txen_alloc_callback_vector();\n\t}\n\tif (xen_hvm_domain()) {\n\t\tnative_init_IRQ();\n\t\tpci_xen_hvm_init();\n\t} else {\n\t\tint rc;\n\t\tstruct physdev_pirq_eoi_gmfn eoi_gmfn;\n\t\tpirq_eoi_map = (void *)__get_free_page(GFP_KERNEL|__GFP_ZERO);\n\t\teoi_gmfn.gmfn = virt_to_gfn(pirq_eoi_map);\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_pirq_eoi_gmfn_v2, &eoi_gmfn);\n\t\tif (rc != 0) {\n\t\t\tfree_page((unsigned long) pirq_eoi_map);\n\t\t\tpirq_eoi_map = NULL;\n\t\t} else\n\t\t\tpirq_needs_eoi = pirq_check_eoi_map;\n\t}\n#endif\n}", "target": 0}
{"code": "GF_Err paen_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}", "target": 0}
{"code": "cgiGetVariable(const char *name)\t\n{\n  const _cgi_var_t\t*var;\t\t\n  var = cgi_find_variable(name);\n  return ((var == NULL) ? NULL : _cupsStrRetain(var->values[var->nvalues - 1]));\n}", "target": 0}
{"code": "static void fio_cluster_listen_on_close(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  free(protocol);\n  cluster_data.uuid = -1;\n  if (fio_parent_pid() == getpid()) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) stopped listening for cluster connections\",\n                  (int)getpid());\n#endif\n    if (fio_data->active)\n      fio_stop();\n  }\n  (void)uuid;\n}", "target": 1}
{"code": "static void nalm_dump(FILE * trace, char *data, u32 data_size)\n{\n\tGF_BitStream *bs;\n\tBool rle, large_size;\n\tu32 entry_count;\n\tif (!data) {\n\t\tfprintf(trace, \"<NALUMap rle=\\\"\\\" large_size=\\\"\\\">\\n\");\n\t\tfprintf(trace, \"<NALUMapEntry NALU_startNumber=\\\"\\\" groupID=\\\"\\\"/>\\n\");\n\t\tfprintf(trace, \"</NALUMap>\\n\");\n\t\treturn;\n\t}\n\tbs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);\n\tgf_bs_read_int(bs, 6);\n\tlarge_size = gf_bs_read_int(bs, 1);\n\trle = gf_bs_read_int(bs, 1);\n\tentry_count = gf_bs_read_int(bs, large_size ? 16 : 8);\n\tfprintf(trace, \"<NALUMap rle=\\\"%d\\\" large_size=\\\"%d\\\">\\n\", rle, large_size);\n\twhile (entry_count) {\n\t\tu32 ID;\n\t\tfprintf(trace, \"<NALUMapEntry \");\n\t\tif (rle) {\n\t\t\tu32 start_num = gf_bs_read_int(bs, large_size ? 16 : 8);\n\t\t\tfprintf(trace, \"NALU_startNumber=\\\"%d\\\" \", start_num);\n\t\t}\n\t\tID = gf_bs_read_u16(bs);\n\t\tfprintf(trace, \"groupID=\\\"%d\\\"/>\\n\", ID);\n\t\tentry_count--;\n\t}\n\tgf_bs_del(bs);\n\tfprintf(trace, \"</NALUMap>\\n\");\n\treturn;\n}", "target": 1}
{"code": "static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\tmutex_lock(&client->lock);\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\tmutex_unlock(&client->lock);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 1}
{"code": "void KPasswordDlg::keyPressed( QKeyEvent *e )\n{\n  static bool waitForAuthentication = false;\n  if (!waitForAuthentication) {\n\tswitch ( e->key() )\n\t{\n\t\tcase Key_Backspace:\n\t\t\t{\n\t\t\t\tint len = password.length();\n\t\t\t\tif ( len ) {\n\t\t\t\t\tpassword.truncate( len - 1 );\n\t\t\t\t\tif( stars )\n\t\t\t\t\t\tshowStars();\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Key_Return:\n            timer.stop();\n\t\t\twaitForAuthentication = true;\n\t\t\tif ( tryPassword() )\n\t\t\t\temit passOk();\n\t\t\telse\n\t\t\t{\n\t\t\t\tlabel->setText( glocale->translate(\"Failed\") );\n\t\t\t\tpassword = \"\";\n\t\t\t\ttimerMode = 1;\n\t\t\t\ttimer.start( 1500, TRUE );\n\t\t\t}\n\t\t\twaitForAuthentication = false;\n\t\t\tbreak;\n\t\tcase Key_Escape:\n\t\t\temit passCancel();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ( password.length() < MAX_PASSWORD_LENGTH )\n\t\t\t{\n\t\t\t\tpassword += (char)e->ascii();\n\t\t\t\tif( stars )\n\t\t\t\t\tshowStars();\n\t\t\t\ttimer.changeInterval( 10000 );\n\t\t\t}\n\t}\n  }\n}", "target": 0}
{"code": "TfLiteStatus GetInputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                          int index, const TfLiteTensor** tensor) {\n  return GetMutableInputSafe(context, node, index, tensor);\n}", "target": 0}
{"code": "char *Elf_(r_bin_elf_get_rpath)(ELFOBJ *bin) {\n\tchar *ret = NULL;\n\tint j;\n\tif (!bin || !bin->phdr || !bin->dyn_buf || !bin->strtab) {\n\t\treturn NULL;\n\t}\n\tfor (j = 0; j< bin->dyn_entries; j++) {\n\t\tif (bin->dyn_buf[j].d_tag == DT_RPATH || bin->dyn_buf[j].d_tag == DT_RUNPATH) {\n\t\t\tif (!(ret = calloc (1, ELF_STRING_LENGTH))) {\n\t\t\t\tperror (\"malloc (rpath)\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (bin->dyn_buf[j].d_un.d_val > bin->strtab_size) {\n\t\t\t\tfree (ret);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tstrncpy (ret, bin->strtab + bin->dyn_buf[j].d_un.d_val, ELF_STRING_LENGTH);\n\t\t\tret[ELF_STRING_LENGTH - 1] = '\\0';\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}", "target": 1}
{"code": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\tif (*vm_flags & (VM_HUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\tif (*vm_flags & (VM_NOHUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void recovery_character(const char *character)\n{\n    if (!awaiting_character) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");\n        layoutHome();\n        return;\n    }\n    char *pos = strchr(cipher, character[0]);\n    if (character[0] != ' ' && pos == NULL) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError, \"Character must be from a to z\");\n        layoutHome();\n        return;\n    }\n    static int uncyphered_word_count = 0;\n    static bool definitely_using_cipher = false;\n    static CONFIDENTIAL char coded_word[12];\n    static CONFIDENTIAL char decoded_word[12];\n    if (!mnemonic[0]) {\n        uncyphered_word_count = 0;\n        definitely_using_cipher = false;\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n    char decoded_character[2] = \" \";\n    if (character[0] != ' ') {\n        decoded_character[0] = english_alphabet[(int)(pos - cipher)];\n        strlcat(coded_word, character, sizeof(coded_word));\n        strlcat(decoded_word, decoded_character, sizeof(decoded_word));\n        if (enforce_wordlist && 4 <= strlen(coded_word)) {\n            bool maybe_not_using_cipher = attempt_auto_complete(coded_word);\n            bool maybe_using_cipher = attempt_auto_complete(decoded_word);\n            if (!maybe_not_using_cipher && maybe_using_cipher) {\n                definitely_using_cipher = true;\n            } else if (maybe_not_using_cipher && !definitely_using_cipher &&\n                       MAX_UNCYPHERED_WORDS < uncyphered_word_count++) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_SyntaxError,\n                                \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n                layoutHome();\n                return;\n            }\n        }\n    } else {\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n    strlcat(mnemonic, decoded_character, MNEMONIC_BUF);\n    next_character();\n}", "target": 1}
{"code": "static void unix_dgram_peer_wake_disconnect_wakeup(struct sock *sk,\n\t\t\t\t\t\t   struct sock *other)\n{\n\tunix_dgram_peer_wake_disconnect(sk, other);\n\twake_up_interruptible_poll(sk_sleep(sk),\n\t\t\t\t   POLLOUT |\n\t\t\t\t   POLLWRNORM |\n\t\t\t\t   POLLWRBAND);\n}", "target": 0}
{"code": "static void nhml_node_end(void *sax_cbck, const char *node_name, const char *name_space)\n{\n\tXMLBreaker *breaker = (XMLBreaker *)sax_cbck;\n\tchar *node_id = (char *)gf_list_last(breaker->id_stack);\n\tgf_list_rem_last(breaker->id_stack);\n\tif (breaker->from_is_end && breaker->from_id && !strcmp(breaker->from_id, node_id)) {\n\t\tbreaker->from_pos = gf_xml_sax_get_node_end_pos(breaker->sax);\n\t\tbreaker->from_is_end = GF_FALSE;\n\t}\n\tif (breaker->to_is_end && breaker->to_id && !strcmp(breaker->to_id, node_id)) {\n\t\tbreaker->to_pos = gf_xml_sax_get_node_end_pos(breaker->sax);\n\t\tbreaker->to_is_end = GF_FALSE;\n\t}\n\tgf_free(node_id);\n\tif (!breaker->to_is_start && !breaker->from_is_start && !breaker->to_is_end && !breaker->from_is_end) {\n\t\tgf_xml_sax_suspend(breaker->sax, GF_TRUE);\n\t}\n}", "target": 0}
{"code": "  explicit HashContext(const HashContext* ctx) {\n    assert(ctx->ops);\n    assert(ctx->ops->context_size >= 0);\n    ops = ctx->ops;\n    context = malloc(ops->context_size);\n    ops->hash_copy(context, ctx->context);\n    options = ctx->options;\n    key = ctx->key ? strdup(ctx->key) : nullptr;\n  }", "target": 1}
{"code": "static void perf_event_exit_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tperf_event_exit_cpu_context(cpu);\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&swhash->hlist_mutex);\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<T>& operator+=(const t value) {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=524288))\n      cimg_rof(*this,ptrd,T) *ptrd = (T)(*ptrd + value);\n      return *this;", "target": 0}
{"code": "purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    funcname = \"kadm5_purgekeys\";\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp)\n         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                                arg->princ, NULL))) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_purgekeys((void *)handle, arg->princ,\n                                   arg->keepkvno);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "TEST_F(HTTP2CodecTest, TrailersNotLatest) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n  upstreamCodec_.generateHeader(output_, 3, req);\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n  upstreamCodec_.generateHeader(output_, 3, req);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 2);\n  EXPECT_EQ(callbacks_.headersComplete, 2);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}", "target": 0}
{"code": "static void do_change_user(FILE *fin, FILE *fout) {\n  char uname[BUFFER_SIZE];\n  read_buf(fin, uname);\n  if (strlen(uname) > 0) {\n    struct passwd *pw = getpwnam(uname);\n    if (pw) {\n      if (pw->pw_gid) {\n        setgid(pw->pw_gid);\n      }\n      if (pw->pw_uid) {\n        setuid(pw->pw_uid);\n      }\n    }\n  }\n}", "target": 1}
{"code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n    free(ptr);\n    return nullptr;\n}", "target": 1}
{"code": "static void handle_put_publish(struct http_conn *conn,\n\t\t\t       const struct http_msg *msg,\n\t\t\t       struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"publish: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"publish: saving content(%zu): %b\\n\",\n\t\t  clen, mbuf_buf(mb), mbuf_get_left(mb));\n\tmbuf_strdup(mb, &ie->content.publish, clen);\n\thttp_reply(conn, 200, \"OK\", NULL);\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "SIZED_STRING* sized_string_dup(\n    SIZED_STRING* s)\n{\n  SIZED_STRING* result = (SIZED_STRING*) yr_malloc(\n      sizeof(SIZED_STRING) + s->length);\n  if (result == NULL)\n    return NULL;\n  result->length = s->length;\n  result->flags = s->flags;\n  strncpy(result->c_string, s->c_string, s->length + 1);\n  return result;\n}", "target": 0}
{"code": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else if (ctx->might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((uint)(++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 0}
{"code": "static gboolean irssi_ssl_verify_hostname(X509 *cert, const char *hostname)\n{\n\tint gen_index, gen_count;\n\tgboolean matched = FALSE, has_dns_name = FALSE;\n\tconst char *cert_dns_name;\n\tchar *cert_subject_cn;\n\tconst GENERAL_NAME *gn;\n\tSTACK_OF(GENERAL_NAME) * gens;\n\tgens = X509_get_ext_d2i(cert, NID_subject_alt_name, 0, 0);\n\tif (gens) {\n\t\tgen_count = sk_GENERAL_NAME_num(gens);\n\t\tfor (gen_index = 0; gen_index < gen_count && !matched; ++gen_index) {\n\t\t\tgn = sk_GENERAL_NAME_value(gens, gen_index);\n\t\t\tif (gn->type != GEN_DNS)\n\t\t\t\tcontinue;\n\t\t\thas_dns_name = TRUE;\n\t\t\tcert_dns_name = tls_dns_name(gn);\n\t\t\tif (cert_dns_name && *cert_dns_name) {\n\t\t\t\tmatched = match_hostname(cert_dns_name, hostname);\n\t\t\t}\n    \t}\n\t    sk_GENERAL_NAME_pop_free(gens, GENERAL_NAME_free);\n\t}\n\tif (has_dns_name) {\n\t\tif (! matched) {\n\t\t\tg_warning(\"None of the Subject Alt Names in the certificate match hostname '%s'\", hostname);\n\t\t}\n\t\treturn matched;\n\t} else { \n\t\tcert_subject_cn = tls_text_name(X509_get_subject_name(cert), NID_commonName);\n\t    if (cert_subject_cn && *cert_subject_cn) {\n\t    \tmatched = match_hostname(cert_subject_cn, hostname);\n\t    \tif (! matched) {\n\t\t\t\tg_warning(\"SSL certificate common name '%s' doesn't match host name '%s'\", cert_subject_cn, hostname);\n\t    \t}\n\t    } else {\n\t    \tg_warning(\"No subjectAltNames and no valid common name in certificate\");\n\t    }\n\t    free(cert_subject_cn);\n\t}\n\treturn matched;\n}", "target": 0}
{"code": "print_perm_line (int        idx,\n                 GPtrArray *items,\n                 int        cols)\n{\n  g_autoptr(GString) res = g_string_new (NULL);\n  int i;\n  g_string_append_printf (res, \"    [%d] %s\", idx, (char *) items->pdata[0]);\n  for (i = 1; i < items->len; i++)\n    {\n      char *p;\n      int len;\n      p = strrchr (res->str, '\\n');\n      if (!p)\n        p = res->str;\n      len = (res->str + strlen (res->str)) - p;\n      if (len + strlen ((char *) items->pdata[i]) + 2 >= cols)\n        g_string_append_printf (res, \",\\n        %s\", (char *) items->pdata[i]);\n      else\n        g_string_append_printf (res, \", %s\", (char *) items->pdata[i]);\n    }\n  g_print (\"%s\\n\", res->str);\n}", "target": 1}
{"code": "htc_request_check_hdrs(struct sess *sp, struct http *hp)\n{\n\tint u;\n\tint seen_host = 0;\n\tint seen_cl = 0;\n\tfor (u = HTTP_HDR_FIRST; u < hp->nhd; u++) {\n\t\tif (hp->hd[u].b == NULL)\n\t\t\tcontinue;\n\t\tAN(hp->hd[u].b);\n\t\tAN(hp->hd[u].e);\n\t\tif (http_IsHdr(&hp->hd[u], H_Host)) {\n\t\t\tif (seen_host) {\n\t\t\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_host = 1;\n\t\t}\n\t\tif (http_IsHdr(&hp->hd[u], H_Content_Length)) {\n\t\t\tif (seen_cl) {\n\t\t\t\tWSP(sp, SLT_Error,\n\t\t\t\t    \"Duplicated Content-Length header\");\n\t\t\t\treturn (400);\n\t\t\t}\n\t\t\tseen_cl = 1;\n\t\t}\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "decode_bytestring(CBORDecoderObject *self, uint8_t subtype)\n{\n    uint64_t length = 0;\n    bool indefinite = true;\n    PyObject *ret;\n    char length_hex[17];\n    if (decode_length(self, subtype, &length, &indefinite) == -1)\n        return NULL;\n    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {\n        sprintf(length_hex, \"%llX\", length);\n        PyErr_Format(\n                _CBOR2_CBORDecodeValueError,\n                \"excessive bytestring size 0x%s\", length_hex);\n        return NULL;\n    }\n    if (indefinite)\n        ret = decode_indefinite_bytestrings(self);\n    else\n        ret = decode_definite_bytestring(self, (Py_ssize_t)length);\n    set_shareable(self, ret);\n    return ret;\n}", "target": 1}
{"code": "static void nft_objref_map_activate(const struct nft_ctx *ctx,\n\t\t\t\t    const struct nft_expr *expr)\n{\n\tstruct nft_objref_map *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n    return &pair->list;\n}", "target": 1}
{"code": "TEST(GifTest, Gif) {\n  Env* env = Env::Default();\n  const string testdata_path = kTestData;\n  std::vector<DecodeGifTestCase> testcases(\n      {\n       {testdata_path + \"lena.gif\", 1, 51, 26, 3},\n       {testdata_path + \"optimized.gif\", 12, 20, 40, 3},\n       {testdata_path + \"red_black.gif\", 1, 16, 16, 3},\n       {testdata_path + \"scan.gif\", 12, 20, 40, 3},\n       {testdata_path + \"squares.gif\", 2, 16, 16, 3}});\n  for (const auto& tc : testcases) {\n    TestDecodeGif(env, tc);\n  }\n}", "target": 1}
{"code": "ev_archive_get_entry_is_encrypted (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, -1);\n\t\treturn archive_entry_is_encrypted (archive->libar_entry);\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return (*field_rtrn != NULL);\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return (*elem_rtrn != NULL && *field_rtrn != NULL);\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n\tif (expr->array_ref.element != XKB_ATOM_NONE && *elem_rtrn == NULL)\n\t\treturn false;\n\tif (*field_rtrn == NULL)\n\t\treturn false;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 0}
{"code": "int cap_bprm_set_creds(struct linux_binprm *bprm)\n{\n\tconst struct cred *old = current_cred();\n\tstruct cred *new = bprm->cred;\n\tbool effective, has_cap = false;\n\tint ret;\n\teffective = false;\n\tret = get_file_caps(bprm, &effective, &has_cap);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!issecure(SECURE_NOROOT)) {\n\t\tif (has_cap && new->uid != 0 && new->euid == 0) {\n\t\t\twarn_setuid_and_fcaps_mixed(bprm->filename);\n\t\t\tgoto skip;\n\t\t}\n\t\tif (new->euid == 0 || new->uid == 0) {\n\t\t\tnew->cap_permitted = cap_combine(old->cap_bset,\n\t\t\t\t\t\t\t old->cap_inheritable);\n\t\t}\n\t\tif (new->euid == 0)\n\t\t\teffective = true;\n\t}\nskip:\n\tif (!cap_issubset(new->cap_permitted, old->cap_permitted))\n\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\tif ((new->euid != old->uid ||\n\t     new->egid != old->gid ||\n\t     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&\n\t    bprm->unsafe & ~LSM_UNSAFE_PTRACE_CAP) {\n\t\tif (!capable(CAP_SETUID)) {\n\t\t\tnew->euid = new->uid;\n\t\t\tnew->egid = new->gid;\n\t\t}\n\t\tnew->cap_permitted = cap_intersect(new->cap_permitted,\n\t\t\t\t\t\t   old->cap_permitted);\n\t}\n\tnew->suid = new->fsuid = new->euid;\n\tnew->sgid = new->fsgid = new->egid;\n\tif (effective)\n\t\tnew->cap_effective = new->cap_permitted;\n\telse\n\t\tcap_clear(new->cap_effective);\n\tbprm->cap_effective = effective;\n\tif (!cap_isclear(new->cap_effective)) {\n\t\tif (!cap_issubset(CAP_FULL_SET, new->cap_effective) ||\n\t\t    new->euid != 0 || new->uid != 0 ||\n\t\t    issecure(SECURE_NOROOT)) {\n\t\t\tret = audit_log_bprm_fcaps(bprm, new, old);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\tnew->securebits &= ~issecure_mask(SECURE_KEEP_CAPS);\n\treturn 0;\n}", "target": 0}
{"code": "std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(\n    hbc::LazyCompilationData *lazyData) {\n  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});\n  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};\n  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(\n      topLevelContext, &topLevelFunctionContext);\n  auto *node = cast<ESTree::FunctionLikeNode>(Root);\n  lexicalScopeChain = lazyData->parentScope;\n  materializeScopesInChain(\n      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);\n  Variable *parentVar = nullptr;\n  if (lazyData->closureAlias.isValid()) {\n    assert(lazyData->originalName.isValid() && \"Original name invalid\");\n    assert(\n        lazyData->originalName != lazyData->closureAlias &&\n        \"Original name must be different from the alias\");\n    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));\n    nameTable_.insert(lazyData->originalName, parentVar);\n  }\n  assert(\n      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&\n      \"lazy compilation not supported for arrow functions\");\n  auto *func = genES5Function(lazyData->originalName, parentVar, node);\n  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);\n  return {func, topLevel};\n}", "target": 1}
{"code": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n  if (strcasecmp(key.c_str(), \"HTTP_PROXY\") == 0) return;\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n  m_requestParams[key] = value;\n}", "target": 0}
{"code": "BOOL freerdp_image_copy(BYTE* pDstData, DWORD DstFormat, UINT32 nDstStep, UINT32 nXDst,\n                        UINT32 nYDst, UINT32 nWidth, UINT32 nHeight, const BYTE* pSrcData,\n                        DWORD SrcFormat, UINT32 nSrcStep, UINT32 nXSrc, UINT32 nYSrc,\n                        const gdiPalette* palette, UINT32 flags)\n{\n\tconst UINT32 dstByte = FreeRDPGetBytesPerPixel(DstFormat);\n\tconst UINT32 srcByte = FreeRDPGetBytesPerPixel(SrcFormat);\n\tif ((nHeight > INT32_MAX) || (nWidth > INT32_MAX))\n\t\treturn FALSE;\n\tif (!pDstData || !pSrcData)\n\t\treturn FALSE;\n\tif ((nWidth == 0) || (nHeight == 0))\n\t\treturn TRUE;\n\tif (nDstStep == 0)\n\t\tnDstStep = nWidth * FreeRDPGetBytesPerPixel(DstFormat);\n\tif (nSrcStep == 0)\n\t\tnSrcStep = nWidth * FreeRDPGetBytesPerPixel(SrcFormat);\n\tconst BOOL ovl = overlapping(pDstData, nXDst, nYDst, nDstStep, dstByte, pSrcData, nXSrc, nYSrc,\n\t                             nSrcStep, srcByte, nWidth, nHeight);\n\tif (ovl)\n\t\treturn freerdp_image_copy_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,\n\t\t                                  nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,\n\t\t                                  palette, flags);\n\treturn freerdp_image_copy_no_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,\n\t                                     nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,\n\t                                     palette, flags);\n}", "target": 0}
{"code": "u8 *nfc_llcp_general_bytes(struct nfc_dev *dev, size_t *general_bytes_len)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\t*general_bytes_len = 0;\n\t\treturn NULL;\n\t}\n\tnfc_llcp_build_gb(local);\n\t*general_bytes_len = local->gb_len;\n\tnfc_llcp_local_put(local);\n\treturn local->gb;\n}", "target": 0}
{"code": "static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n{\n    return primes[hashtable->num_buckets];\n}", "target": 1}
{"code": "static int ecryptfs_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tif (!lower_file->f_op->mmap)\n\t\treturn -ENODEV;\n\treturn generic_file_mmap(file, vma);\n}", "target": 0}
{"code": "static int perf_release(struct inode *inode, struct file *file)\n{\n\tput_event(file->private_data);\n\treturn 0;\n}", "target": 0}
{"code": "static int dns_resolver_cmp(const struct key *key,\n\t\t\t    const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\tkenter(\"%s,%s\", src, dsp);\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "static void setup_test_dir(char *tmp_dir, const char *files, ...) {\n        va_list ap;\n        assert_se(mkdtemp(tmp_dir) != NULL);\n        va_start(ap, files);\n        while (files != NULL) {\n                _cleanup_free_ char *path = strappend(tmp_dir, files);\n                assert_se(touch_file(path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0) == 0);\n                files = va_arg(ap, const char *);\n        }\n        va_end(ap);\n}", "target": 1}
{"code": "dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int sleep)\n{\n\tupdate_curr(cfs_rq);\n\tupdate_stats_dequeue(cfs_rq, se);\n\tif (sleep) {\n#ifdef CONFIG_SCHEDSTATS\n\t\tif (entity_is_task(se)) {\n\t\t\tstruct task_struct *tsk = task_of(se);\n\t\t\tif (tsk->state & TASK_INTERRUPTIBLE)\n\t\t\t\tse->sleep_start = rq_of(cfs_rq)->clock;\n\t\t\tif (tsk->state & TASK_UNINTERRUPTIBLE)\n\t\t\t\tse->block_start = rq_of(cfs_rq)->clock;\n\t\t}\n#endif\n\t}\n\tif (se != cfs_rq->curr)\n\t\t__dequeue_entity(cfs_rq, se);\n\taccount_entity_dequeue(cfs_rq, se);\n}", "target": 0}
{"code": "int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n  return 0;\n}", "target": 1}
{"code": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); \n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); \n\treturn TRUE;\n}", "target": 1}
{"code": "GF_Err gf_isom_freeze_order(GF_ISOFile *file)\n{\n\tu32 i=0;\n\tGF_Box *box;\n\tif (!file) return GF_BAD_PARAM;\n\twhile ((box=gf_list_enum(file->TopBoxes, &i))) {\n\t\tgf_isom_box_freeze_order(box);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void Rectangle(double x,double y,double w,double h) {\n    outpos += sprintf(outpos,\"\\n %12.3f %12.3f %12.3f %12.3f re\",x,y,w,h);\n}", "target": 1}
{"code": "static pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n    if (rec_counter > 10) {\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            pj_uint16_t offset;\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n            if (status != PJ_SUCCESS)\n                return status;\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            pj_memcpy(name->ptr + name->slen, p+1, label_len);\n            name->slen += label_len;\n            p += label_len + 1;\n            if (*p != 0) {\n                *(name->ptr + name->slen) = '.';\n                ++name->slen;\n            }\n        }\n    }\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "int ConnectionImpl::saveHeader(const nghttp2_frame* frame, HeaderString&& name,\n                               HeaderString&& value) {\n  StreamImpl* stream = getStream(frame->hd.stream_id);\n  if (!stream) {\n    stats_.headers_cb_no_stream_.inc();\n    return 0;\n  }\n  stream->saveHeader(std::move(name), std::move(value));\n  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {\n    stats_.header_overflow_.inc();\n    return NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE;\n  } else {\n    return 0;\n  }\n}", "target": 1}
{"code": "test_validate_path_characters (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (paths); idx++)\n    {\n      PathValidityData *data = &paths[idx];\n      gboolean ret = FALSE;\n      ret = flatpak_validate_path_characters (data->path, NULL);\n      g_assert_cmpint (ret, ==, data->ret);\n    }\n}", "target": 0}
{"code": "static const char *set_trace_enable(cmd_parms *cmd, void *dummy,\n                                    const char *arg1)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    if (ap_cstr_casecmp(arg1, \"on\") == 0) {\n        conf->trace_enable = AP_TRACE_ENABLE;\n    }\n    else if (ap_cstr_casecmp(arg1, \"off\") == 0) {\n        conf->trace_enable = AP_TRACE_DISABLE;\n    }\n    else if (ap_cstr_casecmp(arg1, \"extended\") == 0) {\n        conf->trace_enable = AP_TRACE_EXTENDED;\n    }\n    else {\n        return \"TraceEnable must be one of 'on', 'off', or 'extended'\";\n    }\n    return NULL;\n}", "target": 0}
{"code": "  Status CalculateOutputIndexValueRowID(\n      const RowPartitionTensor& value_rowids,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    const INDEX_TYPE index_size = value_rowids.size();\n    result->reserve(index_size);\n    if (index_size == 0) {\n      return Status::OK();\n    }\n    INDEX_TYPE current_output_column = 0;\n    INDEX_TYPE current_value_rowid = value_rowids(0);\n    if (current_value_rowid >= parent_output_index.size()) {\n      return errors::InvalidArgument(\n          \"Got current_value_rowid=\", current_value_rowid,\n          \" which is not less than \", parent_output_index.size());\n    }\n    INDEX_TYPE current_output_index = parent_output_index[current_value_rowid];\n    result->push_back(current_output_index);\n    for (INDEX_TYPE i = 1; i < index_size; ++i) {\n      INDEX_TYPE next_value_rowid = value_rowids(i);\n      if (next_value_rowid == current_value_rowid) {\n        if (current_output_index >= 0) {\n          ++current_output_column;\n          if (current_output_column < output_size) {\n            current_output_index += output_index_multiplier;\n          } else {\n            current_output_index = -1;\n          }\n        }\n      } else {\n        current_output_column = 0;\n        current_value_rowid = next_value_rowid;\n        if (next_value_rowid >= parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Got next_value_rowid=\", next_value_rowid,\n              \" which is not less than \", parent_output_index.size());\n        }\n        current_output_index = parent_output_index[next_value_rowid];\n      }\n      result->push_back(current_output_index);\n    }\n    if (result->size() != value_rowids.size()) {\n      return errors::InvalidArgument(\"Invalid row ids.\");\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "static inline size_t GetPSDRowSize(Image *image)\n{\n  if (image->depth == 1)\n    return((image->columns+7)/8);\n  else\n    return(image->columns*GetPSDPacketSize(image));\n}", "target": 1}
{"code": "BOOL rdp_read_share_control_header(wStream* s, UINT16* length, UINT16* type, UINT16* channel_id)\n{\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *length); \n\tif (*length == 0x8000)\n\t{\n\t\trdp_read_flow_control_pdu(s, type);\n\t\t*channel_id = 0;\n\t\t*length = 8; \n\t\treturn TRUE;\n\t}\n\tif (((size_t)*length - 2) > Stream_GetRemainingLength(s))\n\t\treturn FALSE;\n\tStream_Read_UINT16(s, *type); \n\t*type &= 0x0F;                \n\tif (*length > 4)\n\t\tStream_Read_UINT16(s, *channel_id); \n\telse\n\t\t*channel_id = 0; \n\treturn TRUE;\n}", "target": 1}
{"code": "void SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}", "target": 1}
{"code": "static int sysfs_slab_add(struct kmem_cache *s)\n{\n\tint err;\n\tconst char *name;\n\tstruct kset *kset = cache_kset(s);\n\tint unmergeable = slab_unmergeable(s);\n\tINIT_WORK(&s->kobj_remove_work, sysfs_slab_remove_workfn);\n\tif (!kset) {\n\t\tkobject_init(&s->kobj, &slab_ktype);\n\t\treturn 0;\n\t}\n\tif (!unmergeable && disable_higher_order_debug &&\n\t\t\t(slub_debug & DEBUG_METADATA_FLAGS))\n\t\tunmergeable = 1;\n\tif (unmergeable) {\n\t\tsysfs_remove_link(&slab_kset->kobj, s->name);\n\t\tname = s->name;\n\t} else {\n\t\tname = create_unique_id(s);\n\t}\n\ts->kobj.kset = kset;\n\terr = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, \"%s\", name);\n\tif (err)\n\t\tgoto out;\n\terr = sysfs_create_group(&s->kobj, &slab_attr_group);\n\tif (err)\n\t\tgoto out_del_kobj;\n#ifdef CONFIG_MEMCG\n\tif (is_root_cache(s) && memcg_sysfs_enabled) {\n\t\ts->memcg_kset = kset_create_and_add(\"cgroup\", NULL, &s->kobj);\n\t\tif (!s->memcg_kset) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_kobj;\n\t\t}\n\t}\n#endif\n\tkobject_uevent(&s->kobj, KOBJ_ADD);\n\tif (!unmergeable) {\n\t\tsysfs_slab_alias(s, s->name);\n\t}\nout:\n\tif (!unmergeable)\n\t\tkfree(name);\n\treturn err;\nout_del_kobj:\n\tkobject_del(&s->kobj);\n\tgoto out;", "target": 0}
{"code": "register_for_each_vma(struct uprobe *uprobe, struct uprobe_consumer *new)\n{\n\tbool is_register = !!new;\n\tstruct map_info *info;\n\tint err = 0;\n\tpercpu_down_write(&dup_mmap_sem);\n\tinfo = build_map_info(uprobe->inode->i_mapping,\n\t\t\t\t\tuprobe->offset, is_register);\n\tif (IS_ERR(info)) {\n\t\terr = PTR_ERR(info);\n\t\tgoto out;\n\t}\n\twhile (info) {\n\t\tstruct mm_struct *mm = info->mm;\n\t\tstruct vm_area_struct *vma;\n\t\tif (err && is_register)\n\t\t\tgoto free;\n\t\tdown_write(&mm->mmap_sem);\n\t\tvma = find_vma(mm, info->vaddr);\n\t\tif (!vma || !valid_vma(vma, is_register) ||\n\t\t    file_inode(vma->vm_file) != uprobe->inode)\n\t\t\tgoto unlock;\n\t\tif (vma->vm_start > info->vaddr ||\n\t\t    vaddr_to_offset(vma, info->vaddr) != uprobe->offset)\n\t\t\tgoto unlock;\n\t\tif (is_register) {\n\t\t\tif (consumer_filter(new,\n\t\t\t\t\tUPROBE_FILTER_REGISTER, mm))\n\t\t\t\terr = install_breakpoint(uprobe, mm, vma, info->vaddr);\n\t\t} else if (test_bit(MMF_HAS_UPROBES, &mm->flags)) {\n\t\t\tif (!filter_chain(uprobe,\n\t\t\t\t\tUPROBE_FILTER_UNREGISTER, mm))\n\t\t\t\terr |= remove_breakpoint(uprobe, mm, info->vaddr);\n\t\t}\n unlock:\n\t\tup_write(&mm->mmap_sem);\n free:\n\t\tmmput(mm);\n\t\tinfo = free_map_info(info);\n\t}\n out:\n\tpercpu_up_write(&dup_mmap_sem);\n\treturn err;\n}", "target": 0}
{"code": "static int ivr_probe(AVProbeData *p)\n{\n    if (memcmp(p->buf, \".R1M\\x0\\x1\\x1\", 7) &&\n        memcmp(p->buf, \".REC\", 4))\n        return 0;\n    return AVPROBE_SCORE_MAX;\n}", "target": 0}
{"code": "static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n  int res, xerrno = 0;\n  struct stat st;\n  char *ptr;\n  if (pathlen == 0) {\n    return 0;\n  }\n  pr_fs_clear_cache();\n  res = pr_fsio_lstat(path, &st);\n  if (res < 0) {\n    xerrno = errno;\n    pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n      strerror(xerrno));\n    errno = xerrno;\n    return -1;\n  }\n  if (S_ISLNK(st.st_mode)) {\n    errno = EPERM;\n    return -1;\n  }\n  ptr = strrchr(path, '/');\n  if (ptr != NULL) {\n    char *new_path;\n    size_t new_pathlen;\n    pr_signals_handle();\n    new_pathlen = ptr - path;\n    if (new_pathlen == pathlen) {\n      return 0;\n    }\n    new_path = pstrndup(p, path, new_pathlen);\n    pr_log_debug(DEBUG10,\n      \"AllowChrootSymlink: path '%s' not a symlink, checking '%s'\", path,\n      new_path);\n    res = is_symlink_path(p, new_path, new_pathlen);\n    if (res < 0) {\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "sds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen, reqlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n    if (avail >= addlen) return s;\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    reqlen = newlen = (len+addlen);\n    assert(newlen > len);   \n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n    type = sdsReqType(newlen);\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > reqlen);  \n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}", "target": 0}
{"code": "static void spl_array_it_get_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC) \n{\n\tspl_array_it       *iterator = (spl_array_it *)iter;\n\tspl_array_object   *object   = iterator->object;\n\tHashTable          *aht      = spl_array_get_hash_table(object, 0 TSRMLS_CC);\n\tif (object->ar_flags & SPL_ARRAY_OVERLOADED_KEY) {\n\t\tzend_user_it_get_current_key(iter, key TSRMLS_CC);\n\t} else {\n\t\tif (spl_array_object_verify_pos_ex(object, aht, \"ArrayIterator::current(): \" TSRMLS_CC) == FAILURE) {\n\t\t\tZVAL_NULL(key);\n\t\t} else {\n\t\t\tzend_hash_get_current_key_zval_ex(aht, key, &object->pos);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static bool validate_net_dev(struct net_device *net_dev,\n\t\t\t     const struct sockaddr *daddr,\n\t\t\t     const struct sockaddr *saddr)\n{\n\tconst struct sockaddr_in *daddr4 = (const struct sockaddr_in *)daddr;\n\tconst struct sockaddr_in *saddr4 = (const struct sockaddr_in *)saddr;\n\tconst struct sockaddr_in6 *daddr6 = (const struct sockaddr_in6 *)daddr;\n\tconst struct sockaddr_in6 *saddr6 = (const struct sockaddr_in6 *)saddr;\n\tswitch (daddr->sa_family) {\n\tcase AF_INET:\n\t\treturn saddr->sa_family == AF_INET &&\n\t\t       validate_ipv4_net_dev(net_dev, daddr4, saddr4);\n\tcase AF_INET6:\n\t\treturn saddr->sa_family == AF_INET6 &&\n\t\t       validate_ipv6_net_dev(net_dev, daddr6, saddr6);\n\tdefault:\n\t\treturn false;\n\t}\n}", "target": 0}
{"code": "static void gfs2_evict_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct gfs2_sbd *sdp = sb->s_fs_info;\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct gfs2_holder gh;\n\tint ret;\n\tif (inode->i_nlink || sb_rdonly(sb) || !ip->i_no_addr)\n\t\tgoto out;\n\tif (!sdp->sd_jdesc)\n\t\tgoto out;\n\tgfs2_holder_mark_uninitialized(&gh);\n\tret = evict_should_delete(inode, &gh);\n\tif (ret == SHOULD_DEFER_EVICTION)\n\t\tgoto out;\n\tif (ret == SHOULD_DELETE_DINODE)\n\t\tret = evict_unlinked_inode(inode);\n\telse\n\t\tret = evict_linked_inode(inode);\n\tif (gfs2_rs_active(&ip->i_res))\n\t\tgfs2_rs_deltree(&ip->i_res);\n\tif (gfs2_holder_initialized(&gh))\n\t\tgfs2_glock_dq_uninit(&gh);\n\tif (ret && ret != GLR_TRYFAILED && ret != -EROFS)\n\t\tfs_warn(sdp, \"gfs2_evict_inode: %d\\n\", ret);\nout:\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (ip->i_qadata)\n\t\tgfs2_assert_warn(sdp, ip->i_qadata->qa_ref == 0);\n\tgfs2_rs_deltree(&ip->i_res);\n\tgfs2_ordered_del_inode(ip);\n\tclear_inode(inode);\n\tgfs2_dir_hash_inval(ip);\n\tif (gfs2_holder_initialized(&ip->i_iopen_gh)) {\n\t\tstruct gfs2_glock *gl = ip->i_iopen_gh.gh_gl;\n\t\tglock_clear_object(gl, ip);\n\t\tgfs2_glock_hold(gl);\n\t\tip->i_iopen_gh.gh_flags |= GL_NOCACHE;\n\t\tgfs2_glock_dq_uninit(&ip->i_iopen_gh);\n\t\tgfs2_glock_put_eventually(gl);\n\t}\n\tif (ip->i_gl) {\n\t\tglock_clear_object(ip->i_gl, ip);\n\t\twait_on_bit_io(&ip->i_flags, GIF_GLOP_PENDING, TASK_UNINTERRUPTIBLE);\n\t\tgfs2_glock_add_to_lru(ip->i_gl);\n\t\tgfs2_glock_put_eventually(ip->i_gl);\n\t\tip->i_gl = NULL;\n\t}\n}", "target": 0}
{"code": "Http::FilterDataStatus Context::onRequestBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onRequestBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onRequestBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                               static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}", "target": 1}
{"code": "static int sctp_getsockopt_assoc_stats(struct sock *sk, int len,\n\t\t\t\t       char __user *optval,\n\t\t\t\t       int __user *optlen)\n{\n\tstruct sctp_assoc_stats sas;\n\tstruct sctp_association *asoc = NULL;\n\tif (len < sizeof(sctp_assoc_t))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&sas, optval, len))\n\t\treturn -EFAULT;\n\tasoc = sctp_id2assoc(sk, sas.sas_assoc_id);\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tsas.sas_rtxchunks = asoc->stats.rtxchunks;\n\tsas.sas_gapcnt = asoc->stats.gapcnt;\n\tsas.sas_outofseqtsns = asoc->stats.outofseqtsns;\n\tsas.sas_osacks = asoc->stats.osacks;\n\tsas.sas_isacks = asoc->stats.isacks;\n\tsas.sas_octrlchunks = asoc->stats.octrlchunks;\n\tsas.sas_ictrlchunks = asoc->stats.ictrlchunks;\n\tsas.sas_oodchunks = asoc->stats.oodchunks;\n\tsas.sas_iodchunks = asoc->stats.iodchunks;\n\tsas.sas_ouodchunks = asoc->stats.ouodchunks;\n\tsas.sas_iuodchunks = asoc->stats.iuodchunks;\n\tsas.sas_idupchunks = asoc->stats.idupchunks;\n\tsas.sas_opackets = asoc->stats.opackets;\n\tsas.sas_ipackets = asoc->stats.ipackets;\n\tsas.sas_maxrto = asoc->stats.max_obs_rto;\n\tmemcpy(&sas.sas_obs_rto_ipaddr, &asoc->stats.obs_rto_ipaddr,\n\t\tsizeof(struct sockaddr_storage));\n\tasoc->stats.max_obs_rto = asoc->rto_min;\n\tlen = min_t(size_t, len, sizeof(sas));\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\tSCTP_DEBUG_PRINTK(\"sctp_getsockopt_assoc_stat(%d): %d\\n\",\n\t\t\t  len, sas.sas_assoc_id);\n\tif (copy_to_user(optval, &sas, len))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "static void chase_port(struct edgeport_port *port, unsigned long timeout,\n\t\t\t\t\t\t\t\tint flush)\n{\n\tint baud_rate;\n\tstruct tty_struct *tty = tty_port_tty_get(&port->port->port);\n\tstruct usb_serial *serial = port->port->serial;\n\twait_queue_t wait;\n\tunsigned long flags;\n\tif (!tty)\n\t\treturn;\n\tif (!timeout)\n\t\ttimeout = (HZ * EDGE_CLOSING_WAIT)/100;\n\tspin_lock_irqsave(&port->ep_lock, flags);\n\tinit_waitqueue_entry(&wait, current);\n\tadd_wait_queue(&tty->write_wait, &wait);\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kfifo_len(&port->write_fifo) == 0\n\t\t|| timeout == 0 || signal_pending(current)\n\t\t|| serial->disconnected)\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\t\ttimeout = schedule_timeout(timeout);\n\t\tspin_lock_irqsave(&port->ep_lock, flags);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&tty->write_wait, &wait);\n\tif (flush)\n\t\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->ep_lock, flags);\n\ttty_kref_put(tty);\n\ttimeout += jiffies;\n\twhile ((long)(jiffies - timeout) < 0 && !signal_pending(current)\n\t\t\t\t\t\t&& !serial->disconnected) {\n\t\tif (!tx_active(port))\n\t\t\tbreak;\n\t\tmsleep(10);\n\t}\n\tif (serial->disconnected)\n\t\treturn;\n\tbaud_rate = port->baud_rate;\n\tif (baud_rate == 0)\n\t\tbaud_rate = 50;\n\tmsleep(max(1, DIV_ROUND_UP(10000, baud_rate)));\n}", "target": 0}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "CString CZNC::FixupEncoding(const CString& sEncoding) const {\n    if (sEncoding.empty() && m_uiForceEncoding) {\n        return \"UTF-8\";\n    }\n    return sEncoding;\n}", "target": 1}
{"code": "void hashtable_clear(hashtable_t *hashtable)\n{\n    size_t i;\n    hashtable_do_clear(hashtable);\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list_init(&hashtable->list);\n    hashtable->size = 0;\n}", "target": 1}
{"code": "static int hashKey(DIGEST_CTX hash, const struct pgpPkt *pkt, int exptag)\n{\n    int rc = -1;\n    if (pkt->tag == exptag) {\n\tuint8_t head[] = {\n\t    0x99,\n\t    (pkt->blen >> 8),\n\t    (pkt->blen     ),\n\t};\n\trpmDigestUpdate(hash, head, 3);\n\trpmDigestUpdate(hash, pkt->body, pkt->blen);\n\trc = 0;\n    }\n    return rc;\n}", "target": 0}
{"code": "static void set_fdc(int drive)\n{\n\tif (drive >= 0 && drive < N_DRIVE) {\n\t\tfdc = FDC(drive);\n\t\tcurrent_drive = drive;\n\t}\n\tif (fdc != 1 && fdc != 0) {\n\t\tpr_info(\"bad fdc value\\n\");\n\t\treturn;\n\t}\n\tset_dor(fdc, ~0, 8);\n#if N_FDC > 1\n\tset_dor(1 - fdc, ~8, 0);\n#endif\n\tif (FDCS->rawcmd == 2)\n\t\treset_fdc_info(1);\n\tif (fd_inb(FD_STATUS) != STATUS_READY)\n\t\tFDCS->reset = 1;\n}", "target": 1}
{"code": "max3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum,\n\t\t    int force_toggles)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint old_epnum, same_ep, rcvtog, sndtog;\n\tstruct usb_device *old_dev;\n\tu8 hctl;\n\told_dev = max3421_hcd->loaded_dev;\n\told_epnum = max3421_hcd->loaded_epnum;\n\tsame_ep = (dev == old_dev && epnum == old_epnum);\n\tif (same_ep && !force_toggles)\n\t\treturn;\n\tif (old_dev && !same_ep) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\trcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tsndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tusb_settoggle(old_dev, old_epnum, 0, rcvtog);\n\t\tusb_settoggle(old_dev, old_epnum, 1, sndtog);\n\t}\n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\tmax3421_hcd->loaded_epnum = epnum;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\tmax3421_hcd->loaded_dev = dev;\n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}", "target": 1}
{"code": "static int rsi_send_beacon(struct rsi_common *common)\n{\n\tstruct sk_buff *skb = NULL;\n\tu8 dword_align_bytes = 0;\n\tskb = dev_alloc_skb(MAX_MGMT_PKT_SIZE);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tmemset(skb->data, 0, MAX_MGMT_PKT_SIZE);\n\tdword_align_bytes = ((unsigned long)skb->data & 0x3f);\n\tif (dword_align_bytes)\n\t\tskb_pull(skb, (64 - dword_align_bytes));\n\tif (rsi_prepare_beacon(common, skb)) {\n\t\trsi_dbg(ERR_ZONE, \"Failed to prepare beacon\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\tskb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb);\n\trsi_set_event(&common->tx_thread.event);\n\trsi_dbg(DATA_TX_ZONE, \"%s: Added to beacon queue\\n\", __func__);\n\treturn 0;\n}", "target": 0}
{"code": "static int udf_encode_fh(struct inode *inode, __u32 *fh, int *lenp,\n\t\t\t struct inode *parent)\n{\n\tint len = *lenp;\n\tstruct kernel_lb_addr location = UDF_I(inode)->i_location;\n\tstruct fid *fid = (struct fid *)fh;\n\tint type = FILEID_UDF_WITHOUT_PARENT;\n\tif (parent && (len < 5)) {\n\t\t*lenp = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*lenp = 3;\n\t\treturn 255;\n\t}\n\t*lenp = 3;\n\tfid->udf.block = location.logicalBlockNum;\n\tfid->udf.partref = location.partitionReferenceNum;\n\tfid->udf.parent_partref = 0;\n\tfid->udf.generation = inode->i_generation;\n\tif (parent) {\n\t\tlocation = UDF_I(parent)->i_location;\n\t\tfid->udf.parent_block = location.logicalBlockNum;\n\t\tfid->udf.parent_partref = location.partitionReferenceNum;\n\t\tfid->udf.parent_generation = inode->i_generation;\n\t\t*lenp = 5;\n\t\ttype = FILEID_UDF_WITH_PARENT;\n\t}\n\treturn type;\n}", "target": 0}
{"code": "void *Sys_LoadDll( const char *name, qboolean useSystemLib )\n{\n\tvoid *dllhandle = NULL;\n\tif ( COM_CompareExtension( name, \".pk3\" ) )\n\t{\n\t\tCom_Printf( S_COLOR_YELLOW \"WARNING: Rejecting DLL named \\\"%s\\\"\", name );\n\t\treturn NULL;\n\t}\n\tif ( useSystemLib )\n\t{\n\t\tCom_Printf( \"Trying to load \\\"%s\\\"...\\n\", name );\n\t\tdllhandle = Sys_LoadLibrary( name );\n\t\tif ( dllhandle )\n\t\t\treturn dllhandle;\n\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", __FUNCTION__, name, Sys_LibraryError() );\n\t}\n\tconst char *binarypath = Sys_BinaryPath();\n\tconst char *basepath = Cvar_VariableString( \"fs_basepath\" );\n\tif ( !*binarypath )\n\t\tbinarypath = \".\";\n\tconst char *searchPaths[] = {\n\t\tbinarypath,\n\t\tbasepath,\n\t};\n\tconst size_t numPaths = ARRAY_LEN( searchPaths );\n\tfor ( size_t i = 0; i < numPaths; i++ )\n\t{\n\t\tconst char *libDir = searchPaths[i];\n\t\tif ( !libDir[0] )\n\t\t\tcontinue;\n\t\tCom_Printf( \"Trying to load \\\"%s\\\" from \\\"%s\\\"...\\n\", name, libDir );\n\t\tchar *fn = va( \"%s%c%s\", libDir, PATH_SEP, name );\n\t\tdllhandle = Sys_LoadLibrary( fn );\n\t\tif ( dllhandle )\n\t\t\treturn dllhandle;\n\t\tCom_Printf( \"%s(%s) failed: \\\"%s\\\"\\n\", __FUNCTION__, fn, Sys_LibraryError() );\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void CoreNetwork::putCmd(const QString &cmd, const QList<QList<QByteArray>> &params, const QByteArray &prefix)\n{\n    QListIterator<QList<QByteArray>> i(params);\n    while (i.hasNext()) {\n        QList<QByteArray> msg = i.next();\n        putCmd(cmd, msg, prefix);\n    }\n}", "target": 0}
{"code": "dane_query_status_t dane_query_status(dane_query_t q)\n{\n\treturn q->status;\n}", "target": 0}
{"code": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 1}
{"code": "next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,\n\t\t enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  if (*state == CCS_RANGE)\n    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;\n  if (*state == CCS_VALUE && *type != CCV_CLASS) {\n    if (*type == CCV_SB)\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n  }\n  *state = CCS_VALUE;\n  *type  = CCV_CLASS;\n  return 0;\n}", "target": 1}
{"code": "static int get_gate_page(struct mm_struct *mm, unsigned long address,\n\t\tunsigned int gup_flags, struct vm_area_struct **vma,\n\t\tstruct page **page)\n{\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpud_t *pud;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tint ret = -EFAULT;\n\tif (gup_flags & FOLL_WRITE)\n\t\treturn -EFAULT;\n\tif (address > TASK_SIZE)\n\t\tpgd = pgd_offset_k(address);\n\telse\n\t\tpgd = pgd_offset_gate(mm, address);\n\tBUG_ON(pgd_none(*pgd));\n\tp4d = p4d_offset(pgd, address);\n\tBUG_ON(p4d_none(*p4d));\n\tpud = pud_offset(p4d, address);\n\tBUG_ON(pud_none(*pud));\n\tpmd = pmd_offset(pud, address);\n\tif (!pmd_present(*pmd))\n\t\treturn -EFAULT;\n\tVM_BUG_ON(pmd_trans_huge(*pmd));\n\tpte = pte_offset_map(pmd, address);\n\tif (pte_none(*pte))\n\t\tgoto unmap;\n\t*vma = get_gate_vma(mm);\n\tif (!page)\n\t\tgoto out;\n\t*page = vm_normal_page(*vma, address, *pte);\n\tif (!*page) {\n\t\tif ((gup_flags & FOLL_DUMP) || !is_zero_pfn(pte_pfn(*pte)))\n\t\t\tgoto unmap;\n\t\t*page = pte_page(*pte);\n\t\tif (is_device_public_page(*page))\n\t\t\tgoto unmap;\n\t}\n\tget_page(*page);\nout:\n\tret = 0;\nunmap:\n\tpte_unmap(pte);\n\treturn ret;\n}", "target": 1}
{"code": "static int nl80211_dump_survey(struct sk_buff *skb,\n\t\t\tstruct netlink_callback *cb)\n{\n\tstruct survey_info survey;\n\tstruct cfg80211_registered_device *dev;\n\tstruct net_device *netdev;\n\tint survey_idx = cb->args[1];\n\tint res;\n\tres = nl80211_prepare_netdev_dump(skb, cb, &dev, &netdev);\n\tif (res)\n\t\treturn res;\n\tif (!dev->ops->dump_survey) {\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\twhile (1) {\n\t\tstruct ieee80211_channel *chan;\n\t\tres = rdev_dump_survey(dev, netdev, survey_idx, &survey);\n\t\tif (res == -ENOENT)\n\t\t\tbreak;\n\t\tif (res)\n\t\t\tgoto out_err;\n\t\tif (!survey.channel) {\n\t\t\tres = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tchan = ieee80211_get_channel(&dev->wiphy,\n\t\t\t\t\t     survey.channel->center_freq);\n\t\tif (!chan || chan->flags & IEEE80211_CHAN_DISABLED) {\n\t\t\tsurvey_idx++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (nl80211_send_survey(skb,\n\t\t\t\tNETLINK_CB(cb->skb).portid,\n\t\t\t\tcb->nlh->nlmsg_seq, NLM_F_MULTI,\n\t\t\t\tnetdev,\n\t\t\t\t&survey) < 0)\n\t\t\tgoto out;\n\t\tsurvey_idx++;\n\t}\n out:\n\tcb->args[1] = survey_idx;\n\tres = skb->len;\n out_err:\n\tnl80211_finish_netdev_dump(dev);\n\treturn res;\n}", "target": 0}
{"code": "void shut_down(int code)\n{\n    int i;\n    int bytes_in = 0;\n    int bytes_out = 0;\n    in_shutdown = 1;\n    if (allow_cors) free_wildmats(allow_cors);\n    for (i = 0; http_namespaces[i]; i++) {\n        if (http_namespaces[i]->enabled && http_namespaces[i]->shutdown)\n            http_namespaces[i]->shutdown();\n    }\n    xmlCleanupParser();\n    proc_cleanup();\n    i = 0;\n    while (backend_cached && backend_cached[i]) {\n        proxy_downserver(backend_cached[i]);\n        free(backend_cached[i]->context);\n        free(backend_cached[i]);\n        i++;\n    }\n    if (backend_cached) free(backend_cached);\n    index_text_extractor_destroy();\n    annotatemore_close();\n    if (httpd_in) {\n        prot_NONBLOCK(httpd_in);\n        prot_fill(httpd_in);\n        bytes_in = prot_bytes_in(httpd_in);\n        prot_free(httpd_in);\n    }\n    if (httpd_out) {\n        prot_flush(httpd_out);\n        bytes_out = prot_bytes_out(httpd_out);\n        prot_free(httpd_out);\n        prometheus_decrement(CYRUS_HTTP_ACTIVE_CONNECTIONS);\n    }\n    else {\n        prometheus_decrement(CYRUS_HTTP_READY_LISTENERS);\n    }\n    prometheus_increment(code ? CYRUS_HTTP_SHUTDOWN_TOTAL_STATUS_ERROR\n                              : CYRUS_HTTP_SHUTDOWN_TOTAL_STATUS_OK);\n    if (protin) protgroup_free(protin);\n    if (config_auditlog)\n        syslog(LOG_NOTICE,\n               \"auditlog: traffic sessionid=<%s> bytes_in=<%d> bytes_out=<%d>\",\n               session_id(), bytes_in, bytes_out);\n#ifdef HAVE_SSL\n    tls_shutdown_serverengine();\n#endif\n    saslprops_free(&saslprops);\n    http2_done();\n    cyrus_done();\n    exit(code);\n}", "target": 0}
{"code": "mmsClient_handleFileOpenRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId, ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n        switch(tag) {\n        case 0xa0: \n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n            hasFileName = true;\n            break;\n        case 0x81: \n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n        case 0x00: \n            break;\n        default: \n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n    if (hasFileName) {\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n        if (frsm != NULL) {\n            MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n            if (obtainFileCall) {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n                obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n            }\n            FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n            if (fileHandle != NULL) {\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n                frsm->obtainRequest = obtainFileCall;\n                mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n    return;\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}", "target": 1}
{"code": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tbpf_map_inc(map, true);\n\tfdput(f);\n\treturn map;\n}", "target": 1}
{"code": "static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = iocb->private;\n\tstruct workqueue_struct *wq;\n\tif (!io_end || !size)\n\t\treturn;\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p\"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %llu\\n\",\n \t\t  iocb->private, io_end->inode->i_ino, iocb, offset,\n\t\t  size);\n\tif (io_end->flag != EXT4_IO_UNWRITTEN){\n\t\text4_free_io_end(io_end);\n\t\tiocb->private = NULL;\n\t\treturn;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\twq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;\n\tqueue_work(wq, &io_end->work);\n\tlist_add_tail(&io_end->list,\n\t\t &EXT4_I(io_end->inode)->i_completed_io_list);\n\tiocb->private = NULL;\n}", "target": 1}
{"code": "static struct timespec fio_timer_calc_due(size_t interval) {\n  struct timespec now = fio_last_tick();\n  if (interval > 1000) {\n    now.tv_sec += interval / 1000;\n    interval -= interval / 1000;\n  }\n  now.tv_nsec += (interval * 1000000UL);\n  if (now.tv_nsec > 1000000000L) {\n    now.tv_nsec -= 1000000000L;\n    now.tv_sec += 1;\n  }\n  return now;\n}", "target": 1}
{"code": "static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tint error = 0;\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\tif (sp->sa_protocol != PX_PROTO_PPTP)\n\t\treturn -EINVAL;\n\tif (lookup_chan_dst(sp->sa_addr.pptp.call_id, sp->sa_addr.pptp.sin_addr.s_addr))\n\t\treturn -EALREADY;\n\tlock_sock(sk);\n\tif (sk->sk_state & PPPOX_CONNECTED) {\n\t\terror = -EBUSY;\n\t\tgoto end;\n\t}\n\tif (sk->sk_state & PPPOX_DEAD) {\n\t\terror = -EALREADY;\n\t\tgoto end;\n\t}\n\tif (!opt->src_addr.sin_addr.s_addr || !sp->sa_addr.pptp.sin_addr.s_addr) {\n\t\terror = -EINVAL;\n\t\tgoto end;\n\t}\n\tpo->chan.private = sk;\n\tpo->chan.ops = &pptp_chan_ops;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk,\n\t\t\t\t   opt->dst_addr.sin_addr.s_addr,\n\t\t\t\t   opt->src_addr.sin_addr.s_addr,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_GRE, RT_CONN_FLAGS(sk), 0);\n\tif (IS_ERR(rt)) {\n\t\terror = -EHOSTUNREACH;\n\t\tgoto end;\n\t}\n\tsk_setup_caps(sk, &rt->dst);\n\tpo->chan.mtu = dst_mtu(&rt->dst);\n\tif (!po->chan.mtu)\n\t\tpo->chan.mtu = PPP_MRU;\n\tip_rt_put(rt);\n\tpo->chan.mtu -= PPTP_HEADER_OVERHEAD;\n\tpo->chan.hdrlen = 2 + sizeof(struct pptp_gre_header);\n\terror = ppp_register_channel(&po->chan);\n\tif (error) {\n\t\tpr_err(\"PPTP: failed to register PPP channel (%d)\\n\", error);\n\t\tgoto end;\n\t}\n\topt->dst_addr = sp->sa_addr.pptp;\n\tsk->sk_state = PPPOX_CONNECTED;\n end:\n\trelease_sock(sk);\n\treturn error;\n}", "target": 0}
{"code": "static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_name) {\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\tskb_free_datagram(sk, skb);\n\terr = copied;\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "CertificateValidationContextConfigImpl::getSubjectAltNameMatchers(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config) {\n  if (!config.match_typed_subject_alt_names().empty() &&\n      !config.match_subject_alt_names().empty()) {\n    throw EnvoyException(\"SAN-based verification using both match_typed_subject_alt_names and \"\n                         \"the deprecated match_subject_alt_names is not allowed\");\n  }\n  std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>\n      subject_alt_name_matchers(config.match_typed_subject_alt_names().begin(),\n                                config.match_typed_subject_alt_names().end());\n  for (const envoy::type::matcher::v3::StringMatcher& matcher : config.match_subject_alt_names()) {\n    static constexpr std::array<\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::SanType, 4>\n        san_types{envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS};\n    for (const auto san_type : san_types) {\n      subject_alt_name_matchers.emplace_back();\n      subject_alt_name_matchers.back().set_san_type(san_type);\n      *subject_alt_name_matchers.back().mutable_matcher() = matcher;\n    }\n  }\n  return subject_alt_name_matchers;\n}", "target": 0}
{"code": "static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n\t\t\t     char *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal, args,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\treturn result;\n}", "target": 0}
{"code": "static u_int mp_dss_len(const  struct mp_dss *m, int csum)\n{\n        u_int len;\n        len = 4;\n        if (m->flags & MP_DSS_A) {\n                len += (m->flags & MP_DSS_a) ? 8 : 4;\n        }\n        if (m->flags & MP_DSS_M) {\n                len += (m->flags & MP_DSS_m) ? 14 : 10;\n                if (csum)\n                        len += 2;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "win_enter(win_T *wp, int undo_sync)\n{\n    win_enter_ext(wp, undo_sync, FALSE, FALSE, TRUE, TRUE);\n}", "target": 0}
{"code": "struct mb2_cache_entry *mb2_cache_entry_find_next(struct mb2_cache *cache,\n\t\t\t\t\t\t  struct mb2_cache_entry *entry)\n{\n\treturn __entry_find(cache, entry, entry->e_key);\n}", "target": 0}
{"code": "manuf_name_lookup(const guint8 *addr)\n{\n    guint32       manuf_key;\n    guint8       oct;\n    hashmanuf_t  *manuf_value;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL) {\n        return manuf_value;\n    }\n    if ((manuf_key & 0x00010000) != 0) {\n        manuf_key &= 0x00FEFFFF;\n        manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n        if (manuf_value != NULL) {\n            return manuf_value;\n        }\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return manuf_hash_new_entry(addr, short_name, long_name);\n    }\n    return manuf_hash_new_entry(addr, NULL, NULL);\n} ", "target": 1}
{"code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "static void* socketio_CloneOption(const char* name, const void* value)\n{\n    void* result;\n    if (name != NULL)\n    {\n        result = NULL;\n        if (strcmp(name, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n            if (value == NULL)\n            {\n                LogError(\"Failed cloning option %s (value is NULL)\", name);\n            }\n            else\n            {\n                if ((result = malloc(sizeof(char) * (strlen((char*)value) + 1))) == NULL)\n                {\n                    LogError(\"Failed cloning option %s (malloc failed)\", name);\n                }\n                else\n                {\n                    strcpy((char *)result, (char *)value);\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Cannot clone option %s (not suppported)\", name);\n        }\n    }\n    else\n    {\n        result = NULL;\n    }\n    return result;\n}", "target": 1}
{"code": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static int adpt_open(struct inode *inode, struct file *file)\n{\n\tint minor;\n\tadpt_hba* pHba;\n\tmutex_lock(&adpt_mutex);\n\tminor = iminor(inode);\n\tif (minor >= hba_count) {\n\t\tmutex_unlock(&adpt_mutex);\n\t\treturn -ENXIO;\n\t}\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->unit == minor) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tif (pHba == NULL) {\n\t\tmutex_unlock(&adpt_configuration_lock);\n\t\tmutex_unlock(&adpt_mutex);\n\t\treturn -ENXIO;\n\t}\n\tpHba->in_use = 1;\n\tmutex_unlock(&adpt_configuration_lock);\n\tmutex_unlock(&adpt_mutex);\n\treturn 0;\n}", "target": 1}
{"code": "CompileResult generateBytecodeForExecution(\n    Module &M,\n    const BytecodeGenerationOptions &genOptions) {\n  std::shared_ptr<Context> context = M.shareContext();\n  CompileResult result{Success};\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    result.bytecodeProvider = hbc::BCProviderFromSrc::createBCProviderFromSrc(\n        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions));\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind for execution\");\n    result = InvalidFlags;\n  }\n  return result;\n}", "target": 1}
{"code": "unsigned int get_random_int(void)\n{\n\tstruct keydata *keyptr;\n\t__u32 *hash = get_cpu_var(get_random_int_hash);\n\tint ret;\n\tkeyptr = get_keyptr();\n\thash[0] += current->pid + jiffies + get_cycles();\n\tret = half_md4_transform(hash, keyptr->secret);\n\tput_cpu_var(get_random_int_hash);\n\treturn ret;\n}", "target": 1}
{"code": "static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){\n  ExprList *pOrderBy = p->pOrderBy;\n  int nOrderBy = p->pOrderBy->nExpr;\n  sqlite3 *db = pParse->db;\n  KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);\n  if( pRet ){\n    int i;\n    for(i=0; i<nOrderBy; i++){\n      struct ExprList_item *pItem = &pOrderBy->a[i];\n      Expr *pTerm = pItem->pExpr;\n      CollSeq *pColl;\n      if( pTerm->flags & EP_Collate ){\n        pColl = sqlite3ExprCollSeq(pParse, pTerm);\n      }else{\n        pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);\n        if( pColl==0 ) pColl = db->pDfltColl;\n        pOrderBy->a[i].pExpr =\n          sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);\n      }\n      assert( sqlite3KeyInfoIsWriteable(pRet) );\n      pRet->aColl[i] = pColl;\n      pRet->aSortFlags[i] = pOrderBy->a[i].sortFlags;\n    }\n  }\n  return pRet;\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_version)\n{\n\tphp_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_VERSION);\n}", "target": 0}
{"code": "parsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "static optional<Principal> parse_principal(CephContext* cct, TokenID t,\n\t\t\t\t    string&& s) {\n  if ((t == TokenID::AWS) && (s == \"*\")) {\n    return Principal::wildcard();\n  } else if (t == TokenID::CanonicalUser) {\n  } else if (t == TokenID::AWS) {\n    auto a = ARN::parse(s);\n    if (!a) {\n      if (std::none_of(s.begin(), s.end(),\n\t\t       [](const char& c) {\n\t\t\t return (c == ':') || (c == '/');\n\t\t       })) {\n\treturn Principal::tenant(std::move(s));\n      }\n    }\n    if (a->resource == \"root\") {\n      return Principal::tenant(std::move(a->account));\n    }\n    static const char rx_str[] = \"([^/]*)/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      ceph_assert(match.size() == 3);\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }\n      if (match[1] == \"role\") {\n\treturn Principal::role(std::move(a->account),\n\t\t\t       match[2]);\n      }\n    }\n  }\n  ldout(cct, 0) << \"Supplied principal is discarded: \" << s << dendl;\n  return boost::none;\n}", "target": 1}
{"code": "apr_byte_t oidc_enabled(request_rec *r) {\n\tif (ap_auth_type(r) == NULL)\n\t\treturn FALSE;\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_CONNECT) == 0)\n\t\treturn TRUE;\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0)\n\t\treturn TRUE;\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn TRUE;\n\treturn FALSE;\n}", "target": 0}
{"code": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\treturn usb_serial_generic_open(tty, port);\n}", "target": 1}
{"code": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); \n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\treturn nh.nh_type;\n}", "target": 1}
{"code": "pci_get_cfgdata8(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= PCI_REGMAX);\n\treturn (*(uint8_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "dirserv_get_bandwidth_for_router_kb(const routerinfo_t *ri)\n{\n  uint32_t bw_kb = 0;\n  long mbw_kb = 0;\n  if (ri) {\n    if (dirserv_query_measured_bw_cache_kb(ri->cache_info.identity_digest,\n                                        &mbw_kb, NULL)) {\n      bw_kb = (uint32_t)mbw_kb;\n    } else {\n      bw_kb = router_get_advertised_bandwidth(ri) / 1000;\n    }\n  }\n  return bw_kb;\n}", "target": 0}
{"code": "void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct completion *vfork_done = tsk->vfork_done;\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list))\n\t\texit_robust_list(tsk);\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list))\n\t\tcompat_exit_robust_list(tsk);\n#endif\n#endif\n\tdeactivate_mm(tsk, mm);\n\tif (vfork_done) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork_done);\n\t}\n\tif (tsk->clear_child_tid\n\t    && !(tsk->flags & PF_SIGNALED)\n\t    && atomic_read(&mm->mm_users) > 1) {\n\t\tu32 __user * tidptr = tsk->clear_child_tid;\n\t\ttsk->clear_child_tid = NULL;\n\t\tput_user(0, tidptr);\n\t\tsys_futex(tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);\n\t}\n}", "target": 0}
{"code": "static int __ptrace_may_access(struct task_struct *task, unsigned int mode)\n{\n\tconst struct cred *cred = current_cred(), *tcred;\n\tint dumpable = 0;\n\tif (same_thread_group(task, current))\n\t\treturn 0;\n\trcu_read_lock();\n\ttcred = __task_cred(task);\n\tif (uid_eq(cred->uid, tcred->euid) &&\n\t    uid_eq(cred->uid, tcred->suid) &&\n\t    uid_eq(cred->uid, tcred->uid)  &&\n\t    gid_eq(cred->gid, tcred->egid) &&\n\t    gid_eq(cred->gid, tcred->sgid) &&\n\t    gid_eq(cred->gid, tcred->gid))\n\t\tgoto ok;\n\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\treturn security_ptrace_access_check(task, mode);\n}", "target": 1}
{"code": "static inline void pfkey_hdr_dup(struct sadb_msg *new,\n\t\t\t\t const struct sadb_msg *orig)\n{\n\t*new = *orig;\n}", "target": 0}
{"code": "static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n\t\tunsigned long arg)\n{\n\tstruct sem_undo *un;\n\tstruct sem_array *sma;\n\tstruct sem* curr;\n\tint err;\n\tint nsems;\n\tstruct list_head tasks;\n\tint val;\n#if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\n\tval = arg >> 32;\n#else\n\tval = arg;\n#endif\n\tsma = sem_lock_check(ns, semid);\n\tif (IS_ERR(sma))\n\t\treturn PTR_ERR(sma);\n\tINIT_LIST_HEAD(&tasks);\n\tnsems = sma->sem_nsems;\n\terr = -EACCES;\n\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO))\n\t\tgoto out_unlock;\n\terr = security_sem_semctl(sma, SETVAL);\n\tif (err)\n\t\tgoto out_unlock;\n\terr = -EINVAL;\n\tif(semnum < 0 || semnum >= nsems)\n\t\tgoto out_unlock;\n\tcurr = &sma->sem_base[semnum];\n\terr = -ERANGE;\n\tif (val > SEMVMX || val < 0)\n\t\tgoto out_unlock;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry(un, &sma->list_id, list_id)\n\t\tun->semadj[semnum] = 0;\n\tcurr->semval = val;\n\tcurr->sempid = task_tgid_vnr(current);\n\tsma->sem_ctime = get_seconds();\n\tdo_smart_update(sma, NULL, 0, 0, &tasks);\n\terr = 0;\nout_unlock:\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\treturn err;\n}", "target": 1}
{"code": "sysObjectID_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  OID(sysObjectID_oid, 1, 3, 6, 1, 4, 1, 54352);\n  snmp_api_set_oid(varbind, oid, sysObjectID_oid);\n}", "target": 1}
{"code": "static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32,\n\t\t\tunsigned int size_left, enum compat_mwt type,\n\t\t\tstruct ebt_entries_buf_state *state, const void *base)\n{\n\tint growth = 0;\n\tchar *buf;\n\tif (size_left == 0)\n\t\treturn 0;\n\tbuf = (char *) match32;\n\twhile (size_left >= sizeof(*match32)) {\n\t\tstruct ebt_entry_match *match_kern;\n\t\tint ret;\n\t\tmatch_kern = (struct ebt_entry_match *) state->buf_kern_start;\n\t\tif (match_kern) {\n\t\t\tchar *tmp;\n\t\t\ttmp = state->buf_kern_start + state->buf_kern_offset;\n\t\t\tmatch_kern = (struct ebt_entry_match *) tmp;\n\t\t}\n\t\tret = ebt_buf_add(state, buf, sizeof(*match32));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tsize_left -= sizeof(*match32);\n\t\tret = ebt_buf_add_pad(state, ebt_compat_entry_padsize());\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (match32->match_size > size_left)\n\t\t\treturn -EINVAL;\n\t\tsize_left -= match32->match_size;\n\t\tret = compat_mtw_from_user(match32, type, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (WARN_ON(ret < match32->match_size))\n\t\t\treturn -EINVAL;\n\t\tgrowth += ret - match32->match_size;\n\t\tgrowth += ebt_compat_entry_padsize();\n\t\tbuf += sizeof(*match32);\n\t\tbuf += match32->match_size;\n\t\tif (match_kern)\n\t\t\tmatch_kern->match_size = ret;\n\t\tWARN_ON(type == EBT_COMPAT_TARGET && size_left);\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t}\n\treturn growth;\n}", "target": 1}
{"code": "spawn_child()\n{\n        pid_t pid;\n        sigset_t newset;\n        sigset_t oldset;\n        sigemptyset(&newset);\n        sigaddset(&newset, SIGCHLD);\n        sigaddset(&newset, SIGTERM);\n        sigprocmask(SIG_BLOCK, &newset, &oldset);\n        pid = fork();\n        if (pid < 0) {\n                msg(LOG_ERR, \"Could not fork (%s)\", strerror(errno));\n                goto out;\n        }\n        if (pid > 0) { \n                pid_t *pidp;\n                pidp = g_malloc(sizeof(pid_t));\n                *pidp = pid;\n                g_hash_table_insert(children, pidp, pidp);\n                goto out;\n        }\n        signal(SIGCHLD, SIG_DFL);\n        signal(SIGTERM, SIG_DFL);\n        signal(SIGHUP, SIG_DFL);\nout:\n        sigprocmask(SIG_SETMASK, &oldset, NULL);\n        return pid;\n}", "target": 0}
{"code": "void ax25_disconnect(ax25_cb *ax25, int reason)\n{\n\tax25_clear_queues(ax25);\n\tif (!ax25->sk || !sock_flag(ax25->sk, SOCK_DESTROY))\n\t\tax25_stop_heartbeat(ax25);\n\tax25_stop_t1timer(ax25);\n\tax25_stop_t2timer(ax25);\n\tax25_stop_t3timer(ax25);\n\tax25_stop_idletimer(ax25);\n\tax25->state = AX25_STATE_0;\n\tax25_link_failed(ax25, reason);\n\tif (ax25->sk != NULL) {\n\t\tlocal_bh_disable();\n\t\tbh_lock_sock(ax25->sk);\n\t\tax25->sk->sk_state     = TCP_CLOSE;\n\t\tax25->sk->sk_err       = reason;\n\t\tax25->sk->sk_shutdown |= SEND_SHUTDOWN;\n\t\tif (!sock_flag(ax25->sk, SOCK_DEAD)) {\n\t\t\tax25->sk->sk_state_change(ax25->sk);\n\t\t\tsock_set_flag(ax25->sk, SOCK_DEAD);\n\t\t}\n\t\tbh_unlock_sock(ax25->sk);\n\t\tlocal_bh_enable();\n\t}\n}", "target": 1}
{"code": "epass2003_hook_path(struct sc_path *path, int inc)\n{\n\tu8 fid_h = path->value[path->len - 2];\n\tu8 fid_l = path->value[path->len - 1];\n\tswitch (fid_h) {\n\tcase 0x29:\n\tcase 0x30:\n\tcase 0x31:\n\tcase 0x32:\n\tcase 0x33:\n\tcase 0x34:\n\t\tif (inc)\n\t\t\tfid_l = fid_l * FID_STEP;\n\t\telse\n\t\t\tfid_l = fid_l / FID_STEP;\n\t\tpath->value[path->len - 1] = fid_l;\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen)\n{\n  struct host_query *hquery = (struct host_query*)arg;\n  int addinfostatus = ARES_SUCCESS;\n  hquery->timeouts += timeouts;\n  hquery->remaining--;\n  if (status == ARES_SUCCESS)\n    {\n      addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n    }\n  else if (status == ARES_EDESTRUCTION)\n    {\n      end_hquery(hquery, status);\n      return;\n    }\n  if (!hquery->remaining)\n    {\n      if (addinfostatus != ARES_SUCCESS)\n        {\n          end_hquery(hquery, addinfostatus);\n        }\n      else if (hquery->ai->nodes)\n        {\n          end_hquery(hquery, ARES_SUCCESS);\n        }\n      else if (status == ARES_ENOTFOUND)\n        {\n          next_lookup(hquery, status);\n        }\n      else\n        {\n          end_hquery(hquery, status);\n        }\n    }\n}", "target": 0}
{"code": "  StringTableEntry getStringTableEntry(uint32_t index) const override {\n    llvm_unreachable(\"Accessing string table from a lazy module\");\n  }", "target": 1}
{"code": "_client_list_free_node(t_client *client)\n{\n\tchar *msg;\n\tchar *cidinfo;\n\tif (client->cid) {\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\tfree(client->token);\n\tfree(client->hid);\n\tfree(client->custom);\n\tfree(client->client_type);\n\tfree(client->cid);\n\tif (strcmp(client->cpi_query, \"\") == 0) {\n\t\tfree(client->cpi_query);\n\t}\n\tfree(client);\n}", "target": 0}
{"code": "SWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->leftFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\treturn;\n\t}\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) \n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n\t\t\treturn;\t\t\n\t\tidx = getFillIdx(shape, fill);\n\t}\n\telse if (idx >= 255 && shape->useVersion == SWF_SHAPE1)\n\t{\n\t\tSWF_error(\"Too many fills for SWFShape V1.\\n\" \n\t\t\t  \"Use a higher SWFShape version\\n\");\n\t}\n\trecord = addStyleRecord(shape);\n\trecord.record.stateChange->leftFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n}", "target": 0}
{"code": "gopherTimeout(const CommTimeoutCbParams &io)\n{\n    GopherStateData *gopherState = static_cast<GopherStateData *>(io.data);\n    debugs(10, 4, io.conn << \": '\" << gopherState->entry->url() << \"'\" );\n    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, gopherState->fwd->request, gopherState->fwd->al));\n    if (Comm::IsConnOpen(io.conn))\n        io.conn->close();\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}", "target": 1}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  bool indices_has_only_positive_elements = true;\n  const auto* indices_values = GetTensorData<IndicesT>(indices);\n  const size_t num_indices = indices->bytes / sizeof(IndicesT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indices_values[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      context->ReportError(context,\n                           \"Params type '%s' are not supported by gather_nd.\",\n                           TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 0}
{"code": "int pkey_gost_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key,\n                      size_t *key_len, const unsigned char *in, size_t in_len)\n{\n    struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx);\n    if (key == NULL) {\n        *key_len = 32;\n        return 1;\n    }\n    if (key != NULL && *key_len < 32) {\n        GOSTerr(GOST_F_PKEY_GOST2018_ENCRYPT, GOST_R_INVALID_BUFFER_SIZE);\n        return 0;\n    }\n    switch (gctx->cipher_nid)\n    {\n        case NID_id_Gost28147_89:\n        case NID_undef: \n            return pkey_GOST_ECcp_decrypt(pctx, key, key_len, in, in_len);\n        case NID_kuznyechik_ctr:\n        case NID_magma_ctr:\n            return pkey_gost2018_decrypt(pctx, key, key_len, in, in_len);\n        default:\n      GOSTerr(GOST_F_PKEY_GOST_DECRYPT, ERR_R_INTERNAL_ERROR);\n      return -1;\n    }\n}", "target": 0}
{"code": "comics_document_init (ComicsDocument *comics_document)\n{\n\tcomics_document->archive = NULL;\n\tcomics_document->page_names = NULL;\n\tcomics_document->extract_command = NULL;\n}", "target": 1}
{"code": "bool CModules::GetModPathInfo(CModInfo& ModInfo, const CString& sModule,\n                              const CString& sModPath, CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    ModInfo.SetName(sModule);\n    ModInfo.SetPath(sModPath);\n    ModHandle p = OpenModule(sModule, sModPath, ModInfo, sRetMsg);\n    if (!p) return false;\n    dlclose(p);\n    return true;\n}", "target": 0}
{"code": "static void vgacon_scrollback_startup(void)\n{\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[0];\n\tvgacon_scrollback_init(0);\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr && sz >= offset) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;\n\t\tattr->info.annotation_default_attr.default_value = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (attr->info.annotation_default_attr.default_value) {\n\t\t\toffset += attr->info.annotation_default_attr.default_value->size;\n\t\t}\n\t}\n\tr_bin_java_print_annotation_default_attr_summary (attr);\n\treturn attr;\n}", "target": 1}
{"code": "fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\tswitch (port->hwif) {\n\tcase E1:\n\t\tifr->ifr_settings.type = IF_IFACE_E1;\n\t\tbreak;\n\tcase T1:\n\t\tifr->ifr_settings.type = IF_IFACE_T1;\n\t\tbreak;\n\tcase V35:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tbreak;\n\tcase V24:\n\t\tifr->ifr_settings.type = IF_IFACE_V24;\n\t\tbreak;\n\tcase X21D:\n\t\tifr->ifr_settings.type = IF_IFACE_X21D;\n\t\tbreak;\n\tcase X21:\n\tdefault:\n\t\tifr->ifr_settings.type = IF_IFACE_X21;\n\t\tbreak;\n\t}\n\tif (ifr->ifr_settings.size == 0) {\n\t\treturn 0;\t\n\t}\n\tif (ifr->ifr_settings.size < sizeof (sync)) {\n\t\treturn -ENOMEM;\n\t}\n\ti = port->index;\n\tmemset(&sync, 0, sizeof(sync));\n\tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n\tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n\t    INTCLK ? CLOCK_INT : CLOCK_EXT;\n\tsync.loopback = 0;\n\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\tifr->ifr_settings.size = sizeof (sync);\n\treturn 0;\n}", "target": 0}
{"code": "int dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype)\n{\n\tif (rr_nested == NULL || rr_nested->rr_start == NULL) {\n\t\treturn -1;\n\t}\n\tint len = rr_nested->context.ptr - rr_nested->rr_start;\n\tunsigned char *ptr = rr_nested->rr_len_ptr;\n\tif (ptr == NULL || _dns_left_len(&rr_nested->context) < 2) {\n\t\treturn -1;\n\t}\n\tif (len <= 14) {\n\t\trr_nested->context.ptr = rr_nested->rr_start;\n\t\treturn 0;\n\t}\n\t_dns_write_short(&ptr, len - rr_nested->rr_head_len);\n\treturn _dns_rr_add_end(rr_nested->context.packet, rr_nested->type, rtype, len);\n}", "target": 0}
{"code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,\n\t\t\t\t int op_flag,\n\t\t\t\t unsigned int size,\n\t\t\t\t unsigned int __user *tlv)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tint change = 0;\n\tvoid *new_data;\n\tif (op_flag > 0) {\n\t\tif (size > 1024 * 128)\t\n\t\t\treturn -EINVAL;\n\t\tnew_data = memdup_user(tlv, size);\n\t\tif (IS_ERR(new_data))\n\t\t\treturn PTR_ERR(new_data);\n\t\tchange = ue->tlv_data_size != size;\n\t\tif (!change)\n\t\t\tchange = memcmp(ue->tlv_data, new_data, size);\n\t\tkfree(ue->tlv_data);\n\t\tue->tlv_data = new_data;\n\t\tue->tlv_data_size = size;\n\t} else {\n\t\tif (! ue->tlv_data_size || ! ue->tlv_data)\n\t\t\treturn -ENXIO;\n\t\tif (size < ue->tlv_data_size)\n\t\t\treturn -ENOSPC;\n\t\tif (copy_to_user(tlv, ue->tlv_data, ue->tlv_data_size))\n\t\t\treturn -EFAULT;\n\t}\n\treturn change;\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n   libettercap_init();\n   ef_globals_alloc();\n   select_text_interface();\n   libettercap_ui_init();\n   fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", \n                      PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);\n   EF_GBL->lineno = 1;\n   parse_options(argc, argv);\n   if (EF_GBL_OPTIONS->source_file) {\n      yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");\n      if (yyin == NULL)\n         FATAL_ERROR(\"Input file not found !\");\n   } else {\n      FATAL_ERROR(\"No source file.\");\n   }\n   setbuf(yyin, NULL);\n   setbuf(stdout, NULL);\n   setbuf(stderr, NULL);\n   load_tables();\n   load_constants();\n   fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);\n   fflush(stdout);\n   ef_debug(1, \"\\n\");\n   if (yyparse() == 0)\n      fprintf(stdout, \" done.\\n\\n\");\n   else\n      fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n   if (write_output() != E_SUCCESS)\n      FATAL_ERROR(\"Cannot write output file (%s)\", EF_GBL_OPTIONS->output_file);\n   ef_globals_free();\n   return 0;\n}", "target": 1}
{"code": "void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)\n{\n\tspin_lock(&dentry->d_lock);\n\tif (unlikely(dname_external(dentry))) {\n\t\tstruct external_name *p = external_name(dentry);\n\t\tatomic_inc(&p->u.count);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = p->name;\n\t} else {\n\t\tmemcpy(name->inline_name, dentry->d_iname, DNAME_INLINE_LEN);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tname->name = name->inline_name;\n\t}\n}", "target": 0}
{"code": "static void adpt_alpha_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_ALPHA;\n}", "target": 1}
{"code": "void Transform::interpolate_nearestneighbour( RawTile& in, unsigned int resampled_width, unsigned int resampled_height ){\n  unsigned char *input = (unsigned char*) in.data;\n  int channels = in.channels;\n  unsigned int width = in.width;\n  unsigned int height = in.height;\n  unsigned char *output;\n  bool new_buffer = false;\n  if( resampled_width*resampled_height > in.width*in.height ){\n    new_buffer = true;\n    output = new unsigned char[(unsigned long long)resampled_width*resampled_height*in.channels];\n  }\n  else output = (unsigned char*) in.data;\n  float xscale = (float)width / (float)resampled_width;\n  float yscale = (float)height / (float)resampled_height;\n  for( unsigned int j=0; j<resampled_height; j++ ){\n    for( unsigned int i=0; i<resampled_width; i++ ){\n      unsigned long ii = (unsigned int) floorf(i*xscale);\n      unsigned long jj = (unsigned int) floorf(j*yscale);\n      unsigned long pyramid_index = (unsigned int) channels * ( ii + jj*width );\n      unsigned long long resampled_index = (unsigned long long)(i + j*resampled_width)*channels;\n      for( int k=0; k<in.channels; k++ ){\n\toutput[resampled_index+k] = input[pyramid_index+k];\n      }\n    }\n  }\n  if( new_buffer ) delete[] (unsigned char*) input;\n  in.width = resampled_width;\n  in.height = resampled_height;\n  in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);\n  in.data = output;\n}", "target": 1}
{"code": "static void __exit inet6_exit(void)\n{\n\tsock_unregister(PF_INET6);\n\trtnl_unregister_all(PF_INET6);\n#ifdef CONFIG_SYSCTL\n\tipv6_sysctl_unregister();\n#endif\n\tudpv6_exit();\n\tudplitev6_exit();\n\ttcpv6_exit();\n\tipv6_packet_cleanup();\n\tipv6_frag_exit();\n\tipv6_exthdrs_exit();\n\taddrconf_cleanup();\n\tip6_flowlabel_cleanup();\n\tip6_route_cleanup();\n#ifdef CONFIG_PROC_FS\n\tif6_proc_exit();\n\tipv6_misc_proc_exit();\n\tudplite6_proc_exit();\n\traw6_proc_exit();\n#endif\n\tipv6_netfilter_fini();\n\tigmp6_cleanup();\n\tndisc_cleanup();\n\ticmpv6_cleanup();\n\trawv6_exit();\n\tunregister_pernet_subsys(&inet6_net_ops);\n\tcleanup_ipv6_mibs();\n\tproto_unregister(&rawv6_prot);\n\tproto_unregister(&udplitev6_prot);\n\tproto_unregister(&udpv6_prot);\n\tproto_unregister(&tcpv6_prot);\n}", "target": 0}
{"code": "static int count_ah_combs(const struct xfrm_tmpl *t)\n{\n\tint i, sz = 0;\n\tfor (i = 0; ; i++) {\n\t\tconst struct xfrm_algo_desc *aalg = xfrm_aalg_get_byidx(i);\n\t\tif (!aalg)\n\t\t\tbreak;\n\t\tif (!aalg->pfkey_supported)\n\t\t\tcontinue;\n\t\tif (aalg_tmpl_set(t, aalg) && aalg->available)\n\t\t\tsz += sizeof(struct sadb_comb);\n\t}\n\treturn sz + sizeof(struct sadb_prop);\n}", "target": 0}
{"code": "script_autoload(\n    char_u\t*name,\n    int\t\treload)\t    \n{\n    char_u\t*p;\n    char_u\t*scriptname, *tofree;\n    int\t\tret = FALSE;\n    int\t\ti;\n    int\t\tret_sid;\n    p = vim_strchr(name, AUTOLOAD_CHAR);\n    if (p == NULL || p == name)\n\treturn FALSE;\n    tofree = scriptname = autoload_name(name);\n    if (scriptname == NULL)\n\treturn FALSE;\n    for (i = 0; i < ga_loaded.ga_len; ++i)\n\tif (STRCMP(((char_u **)ga_loaded.ga_data)[i] + 9, scriptname + 9) == 0)\n\t    break;\n    if (!reload && i < ga_loaded.ga_len)\n\tret = FALSE;\t    \n    else\n    {\n\tif (i == ga_loaded.ga_len && ga_grow(&ga_loaded, 1) == OK)\n\t{\n\t    ((char_u **)ga_loaded.ga_data)[ga_loaded.ga_len++] = scriptname;\n\t    tofree = NULL;\n\t}\n\tif (source_in_path(p_rtp, scriptname, DIP_START, &ret_sid) == OK)\n\t    ret = TRUE;\n    }\n    vim_free(tofree);\n    return ret;\n}", "target": 0}
{"code": "static NO_INLINE JsVar *jspGetNamedFieldInParents(JsVar *object, const char* name, bool returnName) {\n  JsVar * child = jspeiFindChildFromStringInParents(object, name);\n  if (!child) {\n    child = jswFindBuiltInFunction(object, name);\n  }\n  if (child && returnName) {\n    if (jsvIsName(child)) {\n      JsVar *t = jsvGetValueOfName(child);\n      jsvUnLock(child);\n      child = t;\n    }\n    JsVar *nameVar = jsvNewFromString(name);\n    JsVar *newChild = jsvCreateNewChild(object, nameVar, child);\n    jsvUnLock2(nameVar, child);\n    child = newChild;\n  }\n  if (!child) {\n    if (jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      JsVar *proto = jsvNewObject();\n      jsvObjectSetChild(proto, JSPARSE_CONSTRUCTOR_VAR, object);\n      child = jsvAddNamedChild(object, proto, JSPARSE_PROTOTYPE_VAR);\n      jspEnsureIsPrototype(object, child);\n      jsvUnLock(proto);\n    } else if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {\n      const char *objName = jswGetBasicObjectName(object);\n      if (objName) {\n        child = jspNewPrototype(objName);\n      }\n    }\n  }\n  return child;\n}", "target": 1}
{"code": "    uint32_t TiffEntryBase::doSizeImage() const\n    {\n        return 0;\n    } ", "target": 0}
{"code": "bool DSClientEvent::event()\n{\n    bool restart = false;\n    ParticipantProxyData* part_proxy_data;\n    eprosima::shared_lock<eprosima::shared_mutex> lock(mp_PDP->mp_builtin->getDiscoveryMutex());\n    for (auto server: mp_PDP->remote_server_attributes())\n    {\n        std::unique_lock<std::recursive_mutex> pdp_lock(*mp_PDP->getMutex());\n        part_proxy_data = mp_PDP->get_participant_proxy_data(server.guidPrefix);\n        if (nullptr != part_proxy_data)\n        {\n            if (!mp_EDP->areRemoteEndpointsMatched(part_proxy_data))\n            {\n                mp_EDP->assignRemoteEndpoints(*(part_proxy_data));\n            }\n        }\n        else\n        {\n            restart = true;\n        }\n    }\n    if (restart)\n    {\n        mp_PDP->_serverPing = true;\n        mp_PDP->announceParticipantState(false);\n        EPROSIMA_LOG_INFO(CLIENT_PDP_THREAD,\n                \"Client \" << mp_PDP->getRTPSParticipant()->getGuid() << \" PDP announcement\");\n    }\n    return restart;\n}", "target": 1}
{"code": "static void bnx2x_clear_func_ilt(struct bnx2x *bp, u32 func)\n{\n\tu32 i, base = FUNC_ILT_BASE(func);\n\tfor (i = base; i < base + ILT_PER_FUNC; i++)\n\t\tbnx2x_ilt_wr(bp, i, 0);\n}", "target": 0}
{"code": "static inline item* limited_get(char *key, size_t nkey, conn *c) {\n    item *it = item_get(key, nkey, c, DO_UPDATE);\n    if (it && it->refcount > IT_REFCOUNT_LIMIT) {\n        item_remove(it);\n        it = NULL;\n    }\n    return it;\n}", "target": 0}
{"code": "void DetectHttpResponseHeaderRegister(void)\n{\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].name = \"http.response_header\";\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].desc =\n            \"sticky buffer to match on only one HTTP header name and value\";\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].url = \"/rules/http2-keywords.html#response_header\";\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].Setup = DetectHTTPResponseHeaderSetup;\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].flags |=\n            SIGMATCH_NOOPT | SIGMATCH_INFO_STICKY_BUFFER;\n    DetectAppLayerMpmRegister2(\"http_response_header\", SIG_FLAG_TOCLIENT, 2,\n            PrefilterMpmHttp2HeaderRegister, NULL, ALPROTO_HTTP2, HTTP2StateOpen);\n    DetectAppLayerInspectEngineRegister2(\"http_response_header\", ALPROTO_HTTP2, SIG_FLAG_TOCLIENT,\n            HTTP2StateOpen, DetectEngineInspectHttp2Header, NULL);\n    DetectAppLayerMpmRegister2(\"http_response_header\", SIG_FLAG_TOCLIENT, 2,\n            PrefilterMpmHttp1HeaderRegister, NULL, ALPROTO_HTTP1, 0);\n    DetectAppLayerInspectEngineRegister2(\"http_response_header\", ALPROTO_HTTP1, SIG_FLAG_TOCLIENT,\n            HTP_RESPONSE_HEADERS, DetectEngineInspectHttp1Header, NULL);\n    DetectBufferTypeSetDescriptionByName(\"http_response_header\", \"HTTP header name and value\");\n    g_http_response_header_buffer_id = DetectBufferTypeGetByName(\"http_response_header\");\n    DetectBufferTypeSupportsMultiInstance(\"http_response_header\");\n    g_response_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_response_header\",\n            HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);\n}", "target": 0}
{"code": "static int StreamTcpPacketStateClosed(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n    if (p->tcph->th_flags & TH_RST) {\n        SCLogDebug(\"RST on closed state\");\n        return 0;\n    }\n    TcpStream *stream = NULL, *ostream = NULL;\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n    SCLogDebug(\"stream %s ostream %s\",\n            stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV?\"true\":\"false\",\n            ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV ? \"true\":\"false\");\n    if ((stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) == 0) {\n        if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {\n            if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)\n                return -1;\n            if (ssn->state == TCP_CLOSED)\n                ssn->state = ssn->pstate;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, headroom);\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\tmutex_lock(&wmi->op_mutex);\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\tmutex_unlock(&wmi->op_mutex);\n\treturn 0;\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n#else\n    (void)secret;\n#endif\n    UNUSED(info);\n    UNUSED(sig);\n    serverLogFromHandler(LL_WARNING,\"\\n--- WATCHDOG TIMER EXPIRED ---\");\n#ifdef HAVE_BACKTRACE\n    logStackTrace(getMcontextEip(uc), 1);\n#else\n    serverLogFromHandler(LL_WARNING,\"Sorry: no support for backtrace().\");\n#endif\n    serverLogFromHandler(LL_WARNING,\"--------\\n\");\n}", "target": 1}
{"code": "xps_parse_digits(char *s, int *digit)\n{\n    *digit = 0;\n    while (*s >= '0' && *s <= '9')\n    {\n        *digit = *digit * 10 + (*s - '0');\n        s ++;\n    }\n    return s;\n}", "target": 0}
{"code": "static int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err)\n\t\terr = compat_put_timeval(up, &ktv);\n\treturn err;\n}", "target": 1}
{"code": "static int msr_open(struct inode *inode, struct file *file)\n{\n\tunsigned int cpu;\n\tstruct cpuinfo_x86 *c;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tcpu = iminor(file->f_path.dentry->d_inode);\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\t\n\tc = &cpu_data(cpu);\n\tif (!cpu_has(c, X86_FEATURE_MSR))\n\t\treturn -EIO;\t\n\treturn 0;\n}", "target": 0}
{"code": "crm_recv_remote_ready(void *session, gboolean encrypted, int timeout )\n{\n    struct pollfd fds = { 0, };\n    int sock = 0;\n    void *sock_ptr = NULL;\n    int rc = 0;\n    time_t start;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        gnutls_session *tls_session = session;\n        sock_ptr = gnutls_transport_get_ptr(*tls_session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        sock_ptr = session;\n    }\n    sock = GPOINTER_TO_INT(sock_ptr);\n    if (sock <= 0) {\n        return -ENOTCONN;\n    }\n    start = time(NULL);\n    errno = 0;\n    do {\n        fds.fd = sock;\n        fds.events = POLLIN;\n        if (errno == EINTR && (timeout > 0)) {\n            timeout = timeout - ((time(NULL) - start) * 1000);\n            if (timeout < 1000) {\n                timeout = 1000;\n            }\n        }\n        rc = poll(&fds, 1, timeout);\n    } while (rc < 0 && errno == EINTR);\n    return rc;\n}", "target": 0}
{"code": "log2vis_utf8 (PyObject * string, int unicode_length,\n\t      FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tFriBidiChar *logical = NULL; \n\tFriBidiChar *visual = NULL;\t \n\tchar *visual_utf8 = NULL;    \n\tFriBidiStrIndex new_len = 0; \n\tPyObject *result = NULL;\t \n\tlogical = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (logical == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\tvisual = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (visual == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\tfribidi_set_reorder_nsm(reordernsm);\n\tfribidi_utf8_to_unicode (PyString_AS_STRING (string),\n\t\t\t\t PyString_GET_SIZE (string), logical);\n\tif (!fribidi_log2vis (logical, unicode_length, &base_direction, visual,\n\t\t\t      NULL, NULL, NULL))\n\t{\n\t\tPyErr_SetString (PyExc_RuntimeError,\n\t\t\t\t \"fribidi failed to order string\");\n\t\tgoto cleanup;\n\t}\n\tif (clean)\n\t\tfribidi_remove_bidi_marks (visual, unicode_length, NULL, NULL, NULL);\n\tvisual_utf8 = PyMem_New(char, (unicode_length * 4)+1);\n\tif (visual_utf8 == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t\"failed to allocate UTF-8 buffer\");\n\t\tgoto cleanup;\n\t}\n\tnew_len = fribidi_unicode_to_utf8 (visual, unicode_length, visual_utf8);\n\tresult = PyString_FromStringAndSize (visual_utf8, new_len);\n\tif (result == NULL)\n\t\tgoto cleanup;\n      cleanup:\n\tPyMem_Del (logical);\n\tPyMem_Del (visual);\n\tPyMem_Del (visual_utf8);\n\treturn result;\n}", "target": 1}
{"code": "static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\n\tu16 scid, dcid, result, status;\n\tstruct sock *sk;\n\tu8 req[128];\n\tscid   = __le16_to_cpu(rsp->scid);\n\tdcid   = __le16_to_cpu(rsp->dcid);\n\tresult = __le16_to_cpu(rsp->result);\n\tstatus = __le16_to_cpu(rsp->status);\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x\", dcid, scid, result, status);\n\tif (scid) {\n\t\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\t\tif (!sk)\n\t\t\treturn 0;\n\t} else {\n\t\tsk = l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);\n\t\tif (!sk)\n\t\t\treturn 0;\n\t}\n\tswitch (result) {\n\tcase L2CAP_CR_SUCCESS:\n\t\tsk->sk_state = BT_CONFIG;\n\t\tl2cap_pi(sk)->ident = 0;\n\t\tl2cap_pi(sk)->dcid = dcid;\n\t\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;\n\t\tl2cap_pi(sk)->conf_state &= ~L2CAP_CONF_CONNECT_PEND;\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\tl2cap_pi(sk)->num_conf_req++;\n\t\tbreak;\n\tcase L2CAP_CR_PEND:\n\t\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;\n\t\tbreak;\n\tdefault:\n\t\tl2cap_chan_del(sk, ECONNREFUSED);\n\t\tbreak;\n\t}\n\tbh_unlock_sock(sk);\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err dinf_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e = gf_isom_box_array_read(s, bs, dinf_AddBox);\n\tif (e) {\n\t\treturn e;\n\t}\n\tif (!((GF_DataInformationBox *)s)->dref) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] Missing dref box in dinf\\n\"));\n\t\t((GF_DataInformationBox *)s)->dref = (GF_DataReferenceBox *)gf_isom_box_new(GF_ISOM_BOX_TYPE_DREF);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "comics_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n\t\t\t\t\t   EvRenderContext      *rc,\n\t\t\t\t\t   gint                 *width,\n\t\t\t\t\t   gint                 *height)\n{\n\tgdouble page_width, page_height;\n\tcomics_document_get_page_size (EV_DOCUMENT (document), rc->page,\n\t\t\t\t       &page_width, &page_height);\n\tif (rc->rotation == 90 || rc->rotation == 270) {\n\t\t*width = (gint) (page_height * rc->scale);\n\t\t*height = (gint) (page_width * rc->scale);\n\t} else {\n\t\t*width = (gint) (page_width * rc->scale);\n\t\t*height = (gint) (page_height * rc->scale);\n\t}\n}", "target": 1}
{"code": "static const char *findNextNonWSBack(const char *q, const char *start)\n{\n    while (q > start &&\n\t   (*q == 0 || *q == 9 || *q == 0xa || *q == 0xc || *q == 0xd || *q == 0x20))\n    {\n\tq--;\n    }\n    return q;\n}", "target": 0}
{"code": "uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = lduw_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "ZEND_API char* ZEND_FASTCALL zend_str_tolower_copy(char *dest, const char *source, size_t length) \n{\n\tregister unsigned char *str = (unsigned char*)source;\n\tregister unsigned char *result = (unsigned char*)dest;\n\tregister unsigned char *end = str + length;\n\twhile (str < end) {\n\t\t*result++ = zend_tolower_ascii(*str++);\n\t}\n\t*result = '\\0';\n\treturn dest;\n}", "target": 0}
{"code": "static int wanxl_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tconst size_t size = sizeof(sync_serial_settings);\n\tsync_serial_settings line;\n\tport_t *port = dev_to_port(dev);\n\tif (cmd != SIOCWANDEV)\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_IFACE:\n\t\tifr->ifr_settings.type = IF_IFACE_SYNC_SERIAL;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; \n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemset(&line, 0, sizeof(line));\n\t\tline.clock_type = get_status(port)->clocking;\n\t\tline.clock_rate = 0;\n\t\tline.loopback = 0;\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &line, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase IF_IFACE_SYNC_SERIAL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\t\tif (copy_from_user(&line, ifr->ifr_settings.ifs_ifsu.sync,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (line.clock_type != CLOCK_EXT &&\n\t\t    line.clock_type != CLOCK_TXFROMRX)\n\t\t\treturn -EINVAL; \n\t\tif (line.loopback != 0)\n\t\t\treturn -EINVAL;\n\t\tget_status(port)->clocking = line.clock_type;\n\t\treturn 0;\n\tdefault:\n\t\treturn hdlc_ioctl(dev, ifr, cmd);\n        }\n}", "target": 0}
{"code": "snmp_ber_encode_timeticks(snmp_packet_t *snmp_packet, uint32_t timeticks)\n{\n  return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_TIMETICKS, timeticks);\n}", "target": 0}
{"code": "spnego_gss_inquire_names_for_mech(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tgss_OID\t\tmechanism,\n\t\t\t\tgss_OID_set\t*name_types)\n{\n\tOM_uint32   major, minor;\n\tdsyslog(\"Entering inquire_names_for_mech\\n\");\n\tif ((mechanism != GSS_C_NULL_OID) &&\n\t    !g_OID_equal(gss_mech_spnego, mechanism)) {\n\t\t*minor_status = 0;\n\t\treturn (GSS_S_FAILURE);\n\t}\n\tmajor = gss_create_empty_oid_set(minor_status, name_types);\n\tif (major == GSS_S_COMPLETE) {\n\t\tif (((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_USER_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_MACHINE_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE) &&\n\t\t    ((major = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_STRING_UID_NAME,\n\t\t\t\tname_types)) == GSS_S_COMPLETE)) {\n\t\t\tmajor = gss_add_oid_set_member(minor_status,\n\t\t\t\t(gss_OID) GSS_C_NT_HOSTBASED_SERVICE,\n\t\t\t\tname_types);\n\t\t}\n\t\tif (major != GSS_S_COMPLETE)\n\t\t\t(void) gss_release_oid_set(&minor, name_types);\n\t}\n\tdsyslog(\"Leaving inquire_names_for_mech\\n\");\n\treturn (major);\n}", "target": 0}
{"code": "static void check_registration_keywords(hook_user_register_check_t *hdata)\n{\n\tif (hdata->approved || !anope_flags_compat)\n\t{\n\t\treturn;\n\t}\n\tif (!strcasecmp(hdata->account, \"LIST\") || !strcasecmp(hdata->account, \"CLEAR\") || !strcasecmp(hdata->account, \"MODIFY\"))\n\t{\n\t\tcommand_fail(hdata->si, fault_badparams, \"The nick \\2%s\\2 is reserved and cannot be registered.\", hdata->account);\n\t\thdata->approved = 1;\n\t}\n}", "target": 0}
{"code": "  virtual bool ms_verify_authorizer(Connection *con,\n\t\t\t\t    int peer_type,\n\t\t\t\t    int protocol,\n\t\t\t\t    ceph::bufferlist& authorizer,\n\t\t\t\t    ceph::bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid,\n\t\t\t\t    CryptoKey& session_key) { return false; }", "target": 1}
{"code": "GF_Err chnl_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\tISOM_DECREASE_SIZE(s, 1)\n\tptr->layout.stream_structure = gf_bs_read_u8(bs);\n\tif (ptr->layout.stream_structure & 1) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.definedLayout = gf_bs_read_u8(bs);\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 remain = (u32) ptr->size;\n\t\t\tif (ptr->layout.stream_structure & 2) remain--;\n\t\t\tptr->layout.channels_count = 0;\n\t\t\twhile (remain) {\n\t\t\t\tISOM_DECREASE_SIZE(s, 1)\n\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].position = gf_bs_read_u8(bs);\n\t\t\t\tremain--;\n\t\t\t\tif (ptr->layout.layouts[ptr->layout.channels_count].position == 126) {\n\t\t\t\t\tISOM_DECREASE_SIZE(s, 3)\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].azimuth = gf_bs_read_int(bs, 16);\n\t\t\t\t\tptr->layout.layouts[ptr->layout.channels_count].elevation = gf_bs_read_int(bs, 8);\n\t\t\t\t\tremain-=3;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(s, 8)\n\t\t\tptr->layout.omittedChannelsMap = gf_bs_read_u64(bs);\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\tISOM_DECREASE_SIZE(s, 1)\n\t\tptr->layout.object_count = gf_bs_read_u8(bs);\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "  explicit FractionalAvgPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\n                    \"pooling_ratio field must specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional average pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "static inline VALUE fiobj_mustache_find_obj_absolute(VALUE udata,\n                                                     const char *name,\n                                                     uint32_t name_len) {\n  VALUE tmp;\n  if (!RB_TYPE_P(udata, T_HASH)) {\n    if (name_len == 1 && name[0] == '.')\n      return udata;\n    ID name_id = rb_intern2(name, name_len);\n    if (rb_respond_to(udata, name_id)) {\n      return IodineCaller.call(udata, name_id);\n    }\n    return Qnil;\n  }\n  ID name_id = rb_intern2(name, name_len);\n  VALUE key = ID2SYM(name_id);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  key = rb_sym2str(key);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  rb_str_free(key);\n  if (tmp != Qundef)\n    return tmp;\n  tmp = Qnil;\n  if (rb_respond_to(udata, name_id)) {\n    tmp = IodineCaller.call(udata, name_id);\n  }\n  return tmp;\n}", "target": 0}
{"code": "ExprResolveBoolean(struct xkb_context *ctx, const ExprDef *expr,\n                   bool *set_rtrn)\n{\n    bool ok = false;\n    const char *ident;\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_BOOLEAN) {\n            log_err(ctx,\n                    \"Found constant of type %s where boolean was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *set_rtrn = expr->boolean.set;\n        return true;\n    case EXPR_IDENT:\n        ident = xkb_atom_text(ctx, expr->ident.ident);\n        if (ident) {\n            if (istreq(ident, \"true\") ||\n                istreq(ident, \"yes\") ||\n                istreq(ident, \"on\")) {\n                *set_rtrn = true;\n                return true;\n            }\n            else if (istreq(ident, \"false\") ||\n                     istreq(ident, \"no\") ||\n                     istreq(ident, \"off\")) {\n                *set_rtrn = false;\n                return true;\n            }\n        }\n        log_err(ctx, \"Identifier \\\"%s\\\" of type boolean is unknown\\n\", ident);\n        return false;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type boolean is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n    case EXPR_INVERT:\n    case EXPR_NOT:\n        ok = ExprResolveBoolean(ctx, expr, set_rtrn);\n        if (ok)\n            *set_rtrn = !*set_rtrn;\n        return ok;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n    case EXPR_ASSIGN:\n    case EXPR_NEGATE:\n    case EXPR_UNARY_PLUS:\n        log_err(ctx, \"%s of boolean values not permitted\\n\",\n                expr_op_type_to_string(expr->expr.op));\n        break;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveBoolean\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}", "target": 1}
{"code": "int do_set_thread_area(struct task_struct *p, int idx,\n\t\t       struct user_desc __user *u_info,\n\t\t       int can_allocate)\n{\n\tstruct user_desc info;\n\tif (copy_from_user(&info, u_info, sizeof(info)))\n\t\treturn -EFAULT;\n\tif (!tls_desc_okay(&info))\n\t\treturn -EINVAL;\n\tif (idx == -1)\n\t\tidx = info.entry_number;\n\tif (idx == -1 && can_allocate) {\n\t\tidx = get_free_idx();\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\t\tif (put_user(idx, &u_info->entry_number))\n\t\t\treturn -EFAULT;\n\t}\n\tif (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)\n\t\treturn -EINVAL;\n\tset_tls_desc(p, idx, &info, 1);\n\treturn 0;\n}", "target": 0}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 1}
{"code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t\n\t    ip += n + stride - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "int blk_init_allocated_queue(struct request_queue *q)\n{\n\tWARN_ON_ONCE(q->mq_ops);\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, q->cmd_size);\n\tif (!q->fq)\n\t\treturn -ENOMEM;\n\tif (q->init_rq_fn && q->init_rq_fn(q, q->fq->flush_rq, GFP_KERNEL))\n\t\tgoto out_free_flush_queue;\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto out_exit_flush_rq;\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\tblk_queue_make_request(q, blk_queue_bio);\n\tq->sg_reserved_size = INT_MAX;\n\tif (elevator_init(q))\n\t\tgoto out_exit_flush_rq;\n\treturn 0;\nout_exit_flush_rq:\n\tif (q->exit_rq_fn)\n\t\tq->exit_rq_fn(q, q->fq->flush_rq);\nout_free_flush_queue:\n\tblk_free_flush_queue(q->fq);\n\tq->fq = NULL;\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "static CURLcode imap_parse_url_path(struct connectdata *conn)\n{\n  struct imap_conn *imapc = &conn->proto.imapc;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n  int len;\n  if(!*path)\n    path = \"INBOX\";\n  imapc->mailbox = curl_easy_unescape(data, path, 0, &len);\n  if(!imapc->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n  return CURLE_OK;\n}", "target": 1}
{"code": "Status RangeSize(const Tensor* start_t, const Tensor* limit_t,\n                 const Tensor* delta_t, InferenceContext* const c) {\n  T start = start_t->scalar<T>()();\n  T limit = limit_t->scalar<T>()();\n  T delta = delta_t->scalar<T>()();\n  if (start > limit && delta > T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start <= limit when delta > 0: \", start, \"/\", limit);\n  }\n  if (start < limit && delta < T(0)) {\n    return errors::InvalidArgument(\n        \"Requires start >= limit when delta < 0: \", start, \"/\", limit);\n  }\n  if (delta == T(0)) {\n    return errors::InvalidArgument(\"Requires delta != 0\");\n  }\n  auto size = (std::is_integral<T>::value\n                   ? ((Eigen::numext::abs(limit - start) +\n                       Eigen::numext::abs(delta) - T(1)) /\n                      Eigen::numext::abs(delta))\n                   : (Eigen::numext::ceil(\n                         Eigen::numext::abs((limit - start) / delta))));\n  if (size > std::numeric_limits<int64_t>::max()) {\n    return errors::InvalidArgument(\"Requires ((limit - start) / delta) <= \",\n                                   std::numeric_limits<int64_t>::max());\n  }\n  c->set_output(0, c->Vector(static_cast<int64_t>(size)));\n  return Status::OK();\n}", "target": 1}
{"code": "void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n    header = get_header(fp);\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n    free(header);\n}", "target": 1}
{"code": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tbool done;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p))\n\t\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tstruct mount *parent = last_source->mnt_parent;\n\t\t\tif (last_source == first_source)\n\t\t\t\tbreak;\n\t\t\tdone = parent->mnt_master == p;\n\t\t\tif (done && peers(n, parent))\n\t\t\t\tbreak;\n\t\t\tlast_source = last_source->mnt_master;\n\t\t} while (!done);\n\t\ttype = CL_SLAVE;\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn count_mounts(m->mnt_ns, child);\n}", "target": 0}
{"code": "int64_t OutputFile::readImpl(char* , int64_t ) {\n  raise_warning(\"cannot read from a php:\n  return -1;\n}", "target": 1}
{"code": "TRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback,\n                                                    TRIO_CONST char* name)\n{\n\ttrio_userdef_t* def;\n\ttrio_userdef_t* prev = NULL;\n\tif (callback == NULL)\n\t\treturn NULL;\n\tif (name)\n\t{\n\t\tif (name[0] == ':')\n\t\t{\n\t\t\tif (trio_equal(name, \":enter\"))\n\t\t\t{\n\t\t\t\tinternalEnterCriticalRegion = callback;\n\t\t\t}\n\t\t\telse if (trio_equal(name, \":leave\"))\n\t\t\t{\n\t\t\t\tinternalLeaveCriticalRegion = callback;\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tif (trio_length(name) >= MAX_USER_NAME)\n\t\t\treturn NULL;\n\t\tdef = TrioFindNamespace(name, &prev);\n\t\tif (def)\n\t\t\treturn NULL;\n\t}\n\tdef = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t));\n\tif (def)\n\t{\n\t\tif (internalEnterCriticalRegion)\n\t\t\t(void)internalEnterCriticalRegion(NULL);\n\t\tif (name)\n\t\t{\n\t\t\tif (prev == NULL)\n\t\t\t\tinternalUserDef = def;\n\t\t\telse\n\t\t\t\tprev->next = def;\n\t\t}\n\t\tdef->callback = callback;\n\t\tdef->name = (name == NULL) ? NULL : trio_duplicate(name);\n\t\tdef->next = NULL;\n\t\tif (internalLeaveCriticalRegion)\n\t\t\t(void)internalLeaveCriticalRegion(NULL);\n\t}\n\treturn (trio_pointer_t)def;\n}", "target": 1}
{"code": "static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,\n\t\t\t\t     int event,\n\t\t\t\t     struct timespec *tstamp,\n\t\t\t\t     unsigned long resolution)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread r1;\n\tunsigned long flags;\n\tif (event >= SNDRV_TIMER_EVENT_START &&\n\t    event <= SNDRV_TIMER_EVENT_PAUSE)\n\t\ttu->tstamp = *tstamp;\n\tif ((tu->filter & (1 << event)) == 0 || !tu->tread)\n\t\treturn;\n\tmemset(&r1, 0, sizeof(r1));\n\tr1.event = event;\n\tr1.tstamp = *tstamp;\n\tr1.val = resolution;\n\tspin_lock_irqsave(&tu->qlock, flags);\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tspin_unlock_irqrestore(&tu->qlock, flags);\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 0}
{"code": "sixel_allocator_realloc(\n    sixel_allocator_t    *allocator,  \n    void                 *p,          \n    size_t               n)           \n{\n    assert(allocator);\n    assert(allocator->fn_realloc);\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n    return allocator->fn_realloc(p, n);\n}", "target": 0}
{"code": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "njs_promise_perform_any_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = pargs->args.data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value, 1,\n                            &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_rejected = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n    on_rejected->u.native = njs_promise_any_reject_element_functions;\n    on_rejected->args_count = 1;\n    context = on_rejected->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    (*pargs->remaining)++;\n    arguments[0] = capability->resolve;\n    njs_set_function(&arguments[1], on_rejected);\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)\n{\n    int result;\n    if ((message == NULL) ||\n        (sequence_list == NULL))\n    {\n        LogError(\"Bad arguments: message = %p, sequence_list = %p\",\n            message, sequence_list);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            LogError(\"Body is already set to another body type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n            if (new_body_amqp_sequence_items == NULL)\n            {\n                LogError(\"Cannot allocate enough memory for sequence items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n                message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n                {\n                    LogError(\"Cloning sequence failed\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_sequence_count++;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "int blkdev_issue_flush(struct block_device *bdev, gfp_t gfp_mask,\n\t\tsector_t *error_sector)\n{\n\tstruct request_queue *q;\n\tstruct bio *bio;\n\tint ret = 0;\n\tif (bdev->bd_disk == NULL)\n\t\treturn -ENXIO;\n\tq = bdev_get_queue(bdev);\n\tif (!q)\n\t\treturn -ENXIO;\n\tif (!q->make_request_fn)\n\t\treturn -ENXIO;\n\tbio = bio_alloc(gfp_mask, 0);\n\tbio->bi_bdev = bdev;\n\tret = submit_bio_wait(WRITE_FLUSH, bio);\n\tif (error_sector)\n\t\t*error_sector = bio->bi_iter.bi_sector;\n\tbio_put(bio);\n\treturn ret;\n}", "target": 0}
{"code": "get_supported_image_extensions(void)\n{\n\tGSList *extensions = NULL;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\textensions = g_slist_append (extensions,\n\t\t\t\t\t\t     g_strdup (ext[i]));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\treturn extensions;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  auto* params = reinterpret_cast<TfLiteL2NormParams*>(node->builtin_data);\n  L2NormalizationParams* data =\n      static_cast<L2NormalizationParams*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE(context, NumDimensions(input) <= 4);\n  TF_LITE_ENSURE(context, output->type == kTfLiteFloat32 ||\n                              output->type == kTfLiteUInt8 ||\n                              output->type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    data->input_zero_point = input->params.zero_point;\n  } else if (output->type == kTfLiteFloat32) {\n    data->input_zero_point = 0;\n  }\n  TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "ZEND_API int zend_declare_property(zend_class_entry *ce, const char *name, int name_length, zval *property, int access_type TSRMLS_DC) \n{\n\treturn zend_declare_property_ex(ce, name, name_length, property, access_type, NULL, 0 TSRMLS_CC);\n}", "target": 0}
{"code": "date_strftime_internal(int argc, VALUE *argv, VALUE self,\n\t\t       const char *default_fmt,\n\t\t       void (*func)(VALUE, struct tmx *))\n{\n    VALUE vfmt;\n    const char *fmt;\n    long len;\n    char buffer[SMALLBUF], *buf = buffer;\n    struct tmx tmx;\n    VALUE str;\n    rb_scan_args(argc, argv, \"01\", &vfmt);\n    if (argc < 1)\n\tvfmt = rb_usascii_str_new2(default_fmt);\n    else {\n\tStringValue(vfmt);\n\tif (!rb_enc_str_asciicompat_p(vfmt)) {\n\t    rb_raise(rb_eArgError,\n\t\t     \"format should have ASCII compatible encoding\");\n\t}\n    }\n    fmt = RSTRING_PTR(vfmt);\n    len = RSTRING_LEN(vfmt);\n    (*func)(self, &tmx);\n    if (memchr(fmt, '\\0', len)) {\n\tconst char *p = fmt, *pe = fmt + len;\n\tstr = rb_str_new(0, 0);\n\twhile (p < pe) {\n\t    len = date_strftime_alloc(&buf, p, &tmx);\n\t    rb_str_cat(str, buf, len);\n\t    p += strlen(p);\n\t    if (buf != buffer) {\n\t\txfree(buf);\n\t\tbuf = buffer;\n\t    }\n\t    for (fmt = p; p < pe && !*p; ++p);\n\t    if (p > fmt) rb_str_cat(str, fmt, p - fmt);\n\t}\n\trb_enc_copy(str, vfmt);\n\treturn str;\n    }\n    else\n\tlen = date_strftime_alloc(&buf, fmt, &tmx);\n    str = rb_str_new(buf, len);\n    if (buf != buffer) xfree(buf);\n    rb_enc_copy(str, vfmt);\n    return str;\n}", "target": 0}
{"code": "propname2ctype(ScanEnv* env, const char* propname)\n{\n  UChar* name = (UChar* )propname;\n  int ctype = env->enc->property_name_to_ctype(ONIG_ENCODING_ASCII,\n      name, name + strlen(propname));\n  return ctype;\n}", "target": 0}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\tfree_tga(tga);\n\treturn image;\n}", "target": 1}
{"code": "static int snd_timer_user_release(struct inode *inode, struct file *file)\n{\n\tstruct snd_timer_user *tu;\n\tif (file->private_data) {\n\t\ttu = file->private_data;\n\t\tfile->private_data = NULL;\n\t\tmutex_lock(&tu->ioctl_lock);\n\t\tif (tu->timeri)\n\t\t\tsnd_timer_close(tu->timeri);\n\t\tmutex_unlock(&tu->ioctl_lock);\n\t\tkfree(tu->queue);\n\t\tkfree(tu->tqueue);\n\t\tkfree(tu);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int pfkey_flush(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tunsigned int proto;\n\tstruct km_event c;\n\tint err, err2;\n\tproto = pfkey_satype2proto(hdr->sadb_msg_satype);\n\tif (proto == 0)\n\t\treturn -EINVAL;\n\terr = xfrm_state_flush(net, proto, true, false);\n\terr2 = unicast_flush_resp(sk, hdr);\n\tif (err || err2) {\n\t\tif (err == -ESRCH) \n\t\t\terr = 0;\n\t\treturn err ? err : err2;\n\t}\n\tc.data.proto = proto;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tc.event = XFRM_MSG_FLUSHSA;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\treturn 0;\n}", "target": 0}
{"code": "    PngImage::PngImage(BasicIo::UniquePtr io, bool create)\n            : Image(ImageType::png, mdExif | mdIptc | mdXmp | mdComment, std::move(io))\n    {\n        if (create)\n        {\n            if (io_->open() == 0)\n            {\n#ifdef DEBUG\n                std::cerr << \"Exiv2::PngImage:: Creating PNG image to memory\\n\";\n#endif\n                IoCloser closer(*io_);\n                if (io_->write(pngBlank, sizeof(pngBlank)) != sizeof(pngBlank))\n                {\n#ifdef DEBUG\n                    std::cerr << \"Exiv2::PngImage:: Failed to create PNG image on memory\\n\";\n#endif\n                }\n            }\n        }\n    } ", "target": 0}
{"code": "R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {\n\tRSocket *s;\n\tbool ssl = r_str_startswith (url, \"https:\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\tchar *host = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\tprintf (\"Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tchar *port = strchr (host, ':');\n\tif (!port) {\n\t\tport = (ssl)? \"443\": \"80\";\n\t} else {\n\t\t*port++ = 0;\n\t}\n\tchar *path = strchr (host, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\tprintf (\"Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (!r_socket_connect_tcp (s, host, port, 0)) {\n\t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tr_socket_printf (s,\n\t\t\t\"POST /%s HTTP/1.0\\r\\n\"\n\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\"Accept: *", "target": 1}
{"code": "GF_Box *mp4s_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_MP4S);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "ikev2_ke_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct ikev2_ke ke;\n\tconst struct ikev2_ke *k;\n\tk = (const struct ikev2_ke *)ext;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&ke, ext, sizeof(ke));\n\tikev2_pay_print(ndo, NPSTR(tpay), ke.h.critical);\n\tND_PRINT((ndo,\" len=%u group=%s\", ntohs(ke.h.len) - 8,\n\t\t  STR_OR_ID(ntohs(ke.ke_group), dh_p_map)));\n\tif (2 < ndo->ndo_vflag && 8 < ntohs(ke.h.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(k + 1), ntohs(ke.h.len) - 8))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(ke.h.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "pthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "absl::Status SslSocket::initialize(InitialState state,\n                                   Ssl::HandshakerFactoryCb handshaker_factory_cb) {\n  auto status_or_ssl = ctx_->newSsl(transport_socket_options_);\n  if (!status_or_ssl.ok()) {\n    return status_or_ssl.status();\n  }\n  info_ = std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n      std::move(status_or_ssl.value()), ctx_->sslExtendedSocketInfoIndex(), this));\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n  return absl::OkStatus();\n}", "target": 0}
{"code": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\tnfcmrvl_fw_dnld_deinit(priv);\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}", "target": 1}
{"code": "static int create_mr(PVRDMADev *dev, union pvrdma_cmd_req *req,\n                     union pvrdma_cmd_resp *rsp)\n{\n    struct pvrdma_cmd_create_mr *cmd = &req->create_mr;\n    struct pvrdma_cmd_create_mr_resp *resp = &rsp->create_mr_resp;\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n    void *host_virt = NULL;\n    int rc = 0;\n    memset(resp, 0, sizeof(*resp));\n    if (!(cmd->flags & PVRDMA_MR_FLAG_DMA)) {\n        host_virt = pvrdma_map_to_pdir(pci_dev, cmd->pdir_dma, cmd->nchunks,\n                                       cmd->length);\n        if (!host_virt) {\n            rdma_error_report(\"Failed to map to pdir\");\n            return -EINVAL;\n        }\n    }\n    rc = rdma_rm_alloc_mr(&dev->rdma_dev_res, cmd->pd_handle, cmd->start,\n                          cmd->length, host_virt, cmd->access_flags,\n                          &resp->mr_handle, &resp->lkey, &resp->rkey);\n    if (rc && host_virt) {\n        munmap(host_virt, cmd->length);\n    }\n    return rc;\n}", "target": 0}
{"code": "static bool get_user_list(struct torture_context *torture, char ***users)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tchar **u = NULL;\n\tuint32_t count;\n\tchar name[256];\n\tconst char *extra_data;\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_LIST_USERS, &req, &rep);\n\textra_data = (char *)rep.extra_data.data;\n\ttorture_assert(torture, extra_data, \"NULL extra data\");\n\tfor(count = 0;\n\t    next_token(&extra_data, name, \",\", sizeof(name));\n\t    count++)\n\t{\n\t\tu = talloc_realloc(torture, u, char *, count + 2);\n\t\tu[count+1] = NULL;\n\t\tu[count] = talloc_strdup(u, name);\n\t}\n\tSAFE_FREE(rep.extra_data.data);\n\t*users = u;\n\treturn true;\n}", "target": 0}
{"code": "static void bson_append( bson *b, const void *data, int len ) {\n    memcpy( b->cur , data , len );\n    b->cur += len;\n}", "target": 1}
{"code": "_TIFFmalloc(tsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\treturn (malloc((size_t) s));\n}", "target": 0}
{"code": "PrintBackend *cpdbCreateBackendFromFile(GDBusConnection *connection,\n                                        const char *backend_file_name)\n{\n    FILE *file = NULL;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    char *path, *backend_name;\n    const char *info_dir_name;\n    char obj_path[CPDB_BSIZE];\n    backend_name = cpdbGetStringCopy(backend_file_name);\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    proxy = print_backend_proxy_new_sync(connection,\n                                         0,\n                                         backend_name,\n                                         obj_path,\n                                         NULL,\n                                         &error);\n    if (error)\n    {\n        logerror(\"Error creating backend proxy for %s : %s\\n\",\n                    backend_name, error->message);\n        return NULL;\n    }\n    return proxy;\n}", "target": 1}
{"code": "const char *string_of_NPPVariable(int variable)\n{\n  const char *str;\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPPVpluginNameString);\n\t_(NPPVpluginDescriptionString);\n\t_(NPPVpluginWindowBool);\n\t_(NPPVpluginTransparentBool);\n\t_(NPPVjavaClass);\n\t_(NPPVpluginWindowSize);\n\t_(NPPVpluginTimerInterval);\n\t_(NPPVpluginScriptableInstance);\n\t_(NPPVpluginScriptableIID);\n\t_(NPPVjavascriptPushCallerBool);\n\t_(NPPVpluginKeepLibraryInMemory);\n\t_(NPPVpluginNeedsXEmbed);\n\t_(NPPVpluginScriptableNPObject);\n\t_(NPPVformValue);\n\t_(NPPVpluginUrlRequestsDisplayedBool);\n\t_(NPPVpluginWantsAllNetworkStreams);\n\t_(NPPVpluginNativeAccessibleAtkPlugId);\n\t_(NPPVpluginCancelSrcStream);\n\t_(NPPVSupportsAdvancedKeyHandling);\n#undef _\n  default:\n\tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPPVpluginScriptableInstance);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n  return str;\n}", "target": 0}
{"code": "NOEXPORT void print_cipher(CLI *c) { \n    SSL_CIPHER *cipher;\n#ifndef OPENSSL_NO_COMP\n    const COMP_METHOD *compression, *expansion;\n#endif\n    if(c->opt->log_level<LOG_INFO) \n        return;\n    s_log(LOG_INFO, \"TLS %s: %s\",\n        c->opt->option.client ? \"connected\" : \"accepted\",\n        SSL_session_reused(c->ssl) && !c->flag.psk ?\n            \"previous session reused\" : \"new session negotiated\");\n    cipher=(SSL_CIPHER *)SSL_get_current_cipher(c->ssl);\n    s_log(LOG_INFO, \"%s ciphersuite: %s (%d-bit encryption)\",\n        SSL_get_version(c->ssl), SSL_CIPHER_get_name(cipher),\n        SSL_CIPHER_get_bits(cipher, NULL));\n#if OPENSSL_VERSION_NUMBER >= 0x10101000L\n    print_tmp_key(c->ssl);\n#endif\n#ifndef OPENSSL_NO_COMP\n    compression=SSL_get_current_compression(c->ssl);\n    expansion=SSL_get_current_expansion(c->ssl);\n    s_log(compression||expansion ? LOG_INFO : LOG_DEBUG,\n        \"Compression: %s, expansion: %s\",\n        compression ? SSL_COMP_get_name(compression) : \"null\",\n        expansion ? SSL_COMP_get_name(expansion) : \"null\");\n#endif\n}", "target": 0}
{"code": "static void addDimensions(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n    IODMultiframeDimensionModule &dims = ct->getDimensions();\n    OFCHECK(dims.addDimensionIndex(\n                    DCM_StackID, \"2.25.30855560781715986879861690673941231222\", DCM_FrameContentSequence, \"STACK_DIM\")\n                .good());\n    OFCHECK(dims.addDimensionIndex(DCM_InStackPositionNumber,\n                                   \"2.25.30855560781715986879861690673941231222\",\n                                   DCM_FrameContentSequence,\n                                   \"STACK_DIM\")\n                .good());\n    OFunique_ptr<IODMultiframeDimensionModule::DimensionOrganizationItem> org(\n        new IODMultiframeDimensionModule::DimensionOrganizationItem);\n    if (org)\n    {\n        org->setDimensionOrganizationUID(\"2.25.30855560781715986879861690673941231222\");\n        dims.getDimensionOrganizationSequence().push_back(org.release());\n    }\n}", "target": 0}
{"code": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n\tint r;\n\tstruct kvm_vcpu *vcpu, *v;\n\tif (id >= KVM_MAX_VCPUS)\n\t\treturn -EINVAL;\n\tvcpu = kvm_arch_vcpu_create(kvm, id);\n\tif (IS_ERR(vcpu))\n\t\treturn PTR_ERR(vcpu);\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}", "target": 0}
{"code": "static int seed_from_urandom(uint32_t *seed) {\n    char data[sizeof(uint32_t)];\n    int ok;\n#if defined(HAVE_OPEN) && defined(HAVE_CLOSE) && defined(HAVE_READ)\n    int urandom;\n    urandom = open(\"/dev/urandom\", O_RDONLY);\n    if (urandom == -1)\n        return 1;\n    ok = read(urandom, data, sizeof(uint32_t)) == sizeof(uint32_t);\n    close(urandom);\n#else\n    FILE *urandom;\n    urandom = fopen(\"/dev/urandom\", \"rb\");\n    if (!urandom)\n        return 1;\n    ok = fread(data, 1, sizeof(uint32_t), urandom) == sizeof(uint32_t);\n    fclose(urandom);\n#endif\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32(data);\n    return 0;\n}", "target": 0}
{"code": "static struct task_struct *dup_task_struct(struct task_struct *orig)\n{\n\tstruct task_struct *tsk;\n\tstruct thread_info *ti;\n\tunsigned long *stackend;\n\tint err;\n\tprepare_to_copy(orig);\n\ttsk = alloc_task_struct();\n\tif (!tsk)\n\t\treturn NULL;\n\tti = alloc_thread_info(tsk);\n\tif (!ti) {\n\t\tfree_task_struct(tsk);\n\t\treturn NULL;\n\t}\n \terr = arch_dup_task_struct(tsk, orig);\n\tif (err)\n\t\tgoto out;\n\ttsk->stack = ti;\n\terr = prop_local_init_single(&tsk->dirties);\n\tif (err)\n\t\tgoto out;\n\tsetup_thread_stack(tsk, orig);\n\tclear_user_return_notifier(tsk);\n\tclear_tsk_need_resched(tsk);\n\tstackend = end_of_stack(tsk);\n\t*stackend = STACK_END_MAGIC;\t\n#ifdef CONFIG_CC_STACKPROTECTOR\n\ttsk->stack_canary = get_random_int();\n#endif\n\tatomic_set(&tsk->usage,2);\n\tatomic_set(&tsk->fs_excl, 0);\n#ifdef CONFIG_BLK_DEV_IO_TRACE\n\ttsk->btrace_seq = 0;\n#endif\n\ttsk->splice_pipe = NULL;\n\taccount_kernel_stack(ti, 1);\n\treturn tsk;\nout:\n\tfree_thread_info(ti);\n\tfree_task_struct(tsk);\n\treturn NULL;\n}", "target": 0}
{"code": "static int decode_preamble(void *p, struct ceph_frame_desc *desc)\n{\n\tvoid *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN;\n\tu32 crc, expected_crc;\n\tint i;\n\tcrc = crc32c(0, p, crcp - p);\n\texpected_crc = get_unaligned_le32(crcp);\n\tif (crc != expected_crc) {\n\t\tpr_err(\"bad preamble crc, calculated %u, expected %u\\n\",\n\t\t       crc, expected_crc);\n\t\treturn -EBADMSG;\n\t}\n\tmemset(desc, 0, sizeof(*desc));\n\tdesc->fd_tag = ceph_decode_8(&p);\n\tdesc->fd_seg_cnt = ceph_decode_8(&p);\n\tif (desc->fd_seg_cnt < 1 ||\n\t    desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) {\n\t\tpr_err(\"bad segment count %d\\n\", desc->fd_seg_cnt);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < desc->fd_seg_cnt; i++) {\n\t\tdesc->fd_lens[i] = ceph_decode_32(&p);\n\t\tdesc->fd_aligns[i] = ceph_decode_16(&p);\n\t}\n\tif (!desc->fd_lens[desc->fd_seg_cnt - 1]) {\n\t\tpr_err(\"last segment empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) {\n\t\tpr_err(\"control segment too big %d\\n\", desc->fd_lens[0]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) {\n\t\tpr_err(\"front segment too big %d\\n\", desc->fd_lens[1]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) {\n\t\tpr_err(\"middle segment too big %d\\n\", desc->fd_lens[2]);\n\t\treturn -EINVAL;\n\t}\n\tif (desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) {\n\t\tpr_err(\"data segment too big %d\\n\", desc->fd_lens[3]);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "ikev2_sa_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext1,\n\t\tu_int osa_length, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth)\n{\n\tconst struct isakmp_gen *ext;\n\tstruct isakmp_gen e;\n\tu_int sa_length;\n\tconst u_char *cp;\n\tint i;\n\tint pcount;\n\tu_char np;\n\tu_int item_len;\n\tND_TCHECK(*ext1);\n\tUNALIGNED_MEMCPY(&e, ext1, sizeof(e));\n\tikev2_pay_print(ndo, \"sa\", e.critical);\n\tosa_length= ntohs(e.len);\n\tsa_length = osa_length - 4;\n\tND_PRINT((ndo,\" len=%d\", sa_length));\n\tcp = (const u_char *)(ext1 + 1);\n\tpcount = 0;\n\tfor (np = ISAKMP_NPTYPE_P; np != 0; np = e.np) {\n\t\tpcount++;\n\t\text = (const struct isakmp_gen *)cp;\n\t\tif (sa_length < sizeof(*ext))\n\t\t\tgoto toolong;\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\titem_len = ntohs(e.len);\n\t\tif (item_len <= 4)\n\t\t\tgoto trunc;\n\t\tif (sa_length < item_len)\n\t\t\tgoto toolong;\n\t\tND_TCHECK2(*cp, item_len);\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tif (np == ISAKMP_NPTYPE_P) {\n\t\t\tcp = ikev2_p_print(ndo, np, pcount, ext, item_len,\n\t\t\t\t\t   ep, depth);\n\t\t\tif (cp == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s\", NPSTR(np)));\n\t\t\tcp += item_len;\n\t\t}\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tsa_length -= item_len;\n\t}\n\treturn cp;\ntoolong:\n\tcp += sa_length;\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "GF_Err gf_media_change_pl(GF_ISOFile *file, u32 track, u32 profile, u32 compat, u32 level)\n{\n\tu32 i, count, stype;\n\tGF_Err e;\n\tGF_AVCConfig *avcc;\n\tstype = gf_isom_get_media_subtype(file, track, 1);\n\tswitch (stype) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\tavcc = gf_isom_avc_config_get(file, track, 1);\n\tif (!avcc)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tif (level) avcc->AVCLevelIndication = level;\n\tif (compat) avcc->profile_compatibility = compat;\n\tif (profile) avcc->AVCProfileIndication = profile;\n\tcount = gf_list_count(avcc->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *slc = gf_list_get(avcc->sequenceParameterSets, i);\n\t\tif (profile) slc->data[1] = profile;\n\t\tif (level) slc->data[3] = level;\n\t}\n\te = gf_isom_avc_config_update(file, track, 1, avcc);\n\tgf_odf_avc_cfg_del(avcc);\n\treturn e;\n}", "target": 0}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 0}
{"code": "void free_pipe_info(struct pipe_inode_info *pipe)\n{\n\tint i;\n\taccount_pipe_buffers(pipe, pipe->buffers, 0);\n\tfree_uid(pipe->user);\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\t\tif (buf->ops)\n\t\t\tbuf->ops->release(pipe, buf);\n\t}\n\tif (pipe->tmp_page)\n\t\t__free_page(pipe->tmp_page);\n\tkfree(pipe->bufs);\n\tkfree(pipe);\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_check_request_header(request_rec *r)\n{\n    core_server_config *conf;\n    int strict_host_check;\n    const char *expect;\n    int access_status;\n    conf = ap_get_core_module_config(r->server->module_config);\n    strict_host_check = (conf->strict_host_check == AP_CORE_CONFIG_ON);\n    access_status = ap_update_vhost_from_headers_ex(r, strict_host_check);\n    if (strict_host_check && access_status != HTTP_OK) { \n        if (r->server == ap_server_conf) { \n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10156)\n                          \"Requested hostname '%s' did not match any ServerName/ServerAlias \"\n                          \"in the global server configuration \", r->hostname);\n        }\n        else { \n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10157)\n                          \"Requested hostname '%s' did not match any ServerName/ServerAlias \"\n                          \"in the matching virtual host (default vhost for \"\n                          \"current connection is %s:%u)\", \n                          r->hostname, r->server->defn_name, r->server->defn_line_number);\n        }\n        r->status = access_status;\n    }\n    if (r->status != HTTP_OK) { \n        return 0;\n    }\n    if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1, 1)))\n        || ((r->proto_num == HTTP_VERSION(1, 1))\n            && !apr_table_get(r->headers_in, \"Host\"))) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00569)\n                      \"client sent HTTP/1.1 request without hostname \"\n                      \"(see RFC2616 section 14.23): %s\", r->uri);\n        r->status = HTTP_BAD_REQUEST;\n        return 0;\n    }\n    if (((expect = apr_table_get(r->headers_in, \"Expect\")) != NULL)\n        && (expect[0] != '\\0')) {\n        if (ap_cstr_casecmp(expect, \"100-continue\") == 0) {\n            r->expecting_100 = 1;\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00570)\n                          \"client sent an unrecognized expectation value \"\n                          \"of Expect: %s\", expect);\n            r->status = HTTP_EXPECTATION_FAILED;\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "static char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n    if (size)\n      *size = 0;\n    if (is_stream)\n      *is_stream = 0;\n    start = ftell(fp);\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n    if (!entry)\n      return NULL;\n    fseek(fp, entry->offset, SEEK_SET);\n    obj_sz = 0;    \n    total_sz = 0;  \n    n_blks = 1;\n    data = safe_calloc(blk_sz * n_blks);\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n        *(data + total_sz) = '\\0';\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n        if (!data) {\n          ERR(\"Failed to reallocate buffer.\\n\");\n          exit(EXIT_FAILURE);\n        }\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (char *)strstr(data + search, \"endobj\") - (char *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n    if (size) {\n      *size = obj_sz;\n      if (!obj_sz && data) {\n        free(data);\n        data = NULL;\n      }\n    }\n    if (is_stream)\n      *is_stream = stream;\n    return data;\n}", "target": 0}
{"code": "static TEE_Result do_allocate_keypair(struct dh_keypair *key, size_t size_bits)\n{\n\tDH_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(size_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(size_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(size_bits);\n\tif (!key->q)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDH_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "sctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\tif (unlikely(chunk->pdiscard))\n\t\treturn 0;\n\tif (unlikely(chunk_length < required_length))\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "make_month(const char *s)\n{\n    int i;\n    char month[3];\n    month[0] = xtoupper(*s);\n    if (!month[0])\n        return -1; \n    month[1] = xtolower(*(s + 1));\n    if (!month[1])\n        return -1; \n    month[2] = xtolower(*(s + 2));\n    for (i = 0; i < 12; i++)\n        if (!strncmp(month_names[i], month, 3))\n            return i;\n    return -1;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = Jsi_ObjGetLength(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "static const tls12_hash_info *tls12_get_hash_info(unsigned char hash_alg)\n\t{\n\tif (hash_alg == 0)\n\t\treturn NULL;\n\tif (hash_alg > sizeof(tls12_md_info)/sizeof(tls12_md_info[0]))\n\t\treturn NULL;\n\treturn tls12_md_info + hash_alg - 1;\n\t}", "target": 0}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = S[i];\n}", "target": 1}
{"code": "got_headers (SoupMessage *req, SoupClientContext *client)\n{\n\tSoupServer *server = client->server;\n\tSoupServerPrivate *priv = SOUP_SERVER_GET_PRIVATE (server);\n\tSoupURI *uri;\n\tSoupDate *date;\n\tchar *date_string;\n\tSoupAuthDomain *domain;\n\tGSList *iter;\n\tgboolean rejected = FALSE;\n\tchar *auth_user;\n\tif (!priv->raw_paths) {\n\t\tchar *decoded_path;\n\t\turi = soup_message_get_uri (req);\n\t\tdecoded_path = soup_uri_decode (uri->path);\n\t\tif (strstr (decoded_path, \"/../\") ||\n\t\t    g_str_has_suffix (decoded_path, \"/..\")) {\n\t\t\tg_free (decoded_path);\n\t\t\tsoup_message_set_status (req, SOUP_STATUS_BAD_REQUEST);\n\t\t\treturn;\n\t\t}\n\t\tsoup_uri_set_path (uri, decoded_path);\n\t\tg_free (decoded_path);\n\t}\n\tdate = soup_date_new_from_now (0);\n\tdate_string = soup_date_to_string (date, SOUP_DATE_HTTP);\n\tsoup_message_headers_replace (req->response_headers, \"Date\",\n\t\t\t\t      date_string);\n\tg_free (date_string);\n\tsoup_date_free (date);\n\tfor (iter = priv->auth_domains; iter; iter = iter->next) {\n\t\tdomain = iter->data;\n\t\tif (soup_auth_domain_covers (domain, req)) {\n\t\t\tauth_user = soup_auth_domain_accepts (domain, req);\n\t\t\tif (auth_user) {\n\t\t\t\tclient->auth_domain = g_object_ref (domain);\n\t\t\t\tclient->auth_user = auth_user;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trejected = TRUE;\n\t\t}\n\t}\n\tif (!rejected)\n\t\treturn;\n\tfor (iter = priv->auth_domains; iter; iter = iter->next) {\n\t\tdomain = iter->data;\n\t\tif (soup_auth_domain_covers (domain, req))\n\t\t\tsoup_auth_domain_challenge (domain, req);\n\t}\n}", "target": 0}
{"code": "RequestHandler::RequestHandler(\n    std::shared_ptr<CheckWorkflow> check_workflow,\n    std::shared_ptr<context::ServiceContext> service_context,\n    std::unique_ptr<Request> request_data)\n    : context_(new context::RequestContext(service_context,\n                                           std::move(request_data))),\n      check_workflow_(check_workflow) {\n  std::string buffer;\n  if (context_->request()->FindHeader(\n          google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n    context_->request()->AddHeaderToBackend(\n        google::api_manager::auth::kEndpointApiUserInfo, \"\");\n  }\n}", "target": 1}
{"code": "  const std::string& get_id() const {\n    ceph_assert(t != Wildcard && t != Tenant);\n    return u.id;\n  }", "target": 1}
{"code": "Item_bool_func2::add_key_fields_optimize_op(JOIN *join, KEY_FIELD **key_fields,\n                                            uint *and_level,\n                                            table_map usable_tables,\n                                            SARGABLE_PARAM **sargables,\n                                            bool equal_func)\n{\n  if (is_local_field(args[0]))\n  {\n    add_key_equal_fields(join, key_fields, *and_level, this,\n                         (Item_field*) args[0]->real_item(), equal_func,\n                         args + 1, 1, usable_tables, sargables);\n  }\n  if (is_local_field(args[1]))\n  {\n    add_key_equal_fields(join, key_fields, *and_level, this, \n                         (Item_field*) args[1]->real_item(), equal_func,\n                         args, 1, usable_tables, sargables);\n  }\n}", "target": 0}
{"code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}", "target": 1}
{"code": "resolve_superior_type_check(struct lys_type *type)\n{\n    uint32_t i;\n    if (type->base == LY_TYPE_DER) {\n        return EXIT_FAILURE;\n    } else if (type->base == LY_TYPE_UNION) {\n        for (i = 0; i < type->info.uni.count; ++i) {\n            if (resolve_superior_type_check(&type->info.uni.types[i])) {\n                return EXIT_FAILURE;\n            }\n        }\n    } else if (type->base == LY_TYPE_LEAFREF) {\n        while (!type->info.lref.path) {\n            assert(type->der);\n            type = &type->der->type;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "static HashTable *php_zip_get_gc(zval *object, zval ***gc_data, int *gc_data_count TSRMLS_DC) \n{\n\t*gc_data = NULL;\n\t*gc_data_count = 0;\n\treturn zend_std_get_properties(object TSRMLS_CC);\n}", "target": 0}
{"code": "bool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 );\n  return true;\n}", "target": 1}
{"code": "static int lsm_openat(int procfd, pid_t pid, int on_exec)\n{\n\tint ret = -1;\n\tint labelfd = -1;\n\tconst char* name;\n#define __LSMATTRLEN  (5 +  21 +  7 +  1)\n\tchar path[__LSMATTRLEN];\n\tname = lsm_name();\n\tif (strcmp(name, \"nop\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"none\") == 0)\n\t\treturn 0;\n\tif (strcmp(name, \"AppArmor\") == 0)\n\t\ton_exec = 0;\n\tif (on_exec) {\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/exec\", pid);\n\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\t\treturn -1;\n\t\tlabelfd = openat(procfd, path, O_RDWR);\n\t} else {\n\t\tret = snprintf(path, __LSMATTRLEN, \"%d/attr/current\", pid);\n\t\tif (ret < 0 || ret >= __LSMATTRLEN)\n\t\t\treturn -1;\n\t\tlabelfd = openat(procfd, path, O_RDWR);\n\t}\n\tif (labelfd < 0) {\n\t\tSYSERROR(\"Unable to open LSM label\");\n\t\treturn -1;\n\t}\n\treturn labelfd;\n}", "target": 0}
{"code": "int gru_handle_user_call_os(unsigned long cb)\n{\n\tstruct gru_tlb_fault_handle *tfh;\n\tstruct gru_thread_state *gts;\n\tvoid *cbk;\n\tint ucbnum, cbrnum, ret = -EINVAL;\n\tSTAT(call_os);\n\tucbnum = get_cb_number((void *)cb);\n\tif ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n\t\treturn -EINVAL;\n\tgts = gru_find_lock_gts(cb);\n\tif (!gts)\n\t\treturn -EINVAL;\n\tgru_dbg(grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);\n\tif (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n\t\tgoto exit;\n\tgru_check_context_placement(gts);\n\tif (gts->ts_gru && gts->ts_force_cch_reload) {\n\t\tgts->ts_force_cch_reload = 0;\n\t\tgru_update_cch(gts);\n\t}\n\tret = -EAGAIN;\n\tcbrnum = thread_cbr_number(gts, ucbnum);\n\tif (gts->ts_gru) {\n\t\ttfh = get_tfh_by_index(gts->ts_gru, cbrnum);\n\t\tcbk = get_gseg_base_address_cb(gts->ts_gru->gs_gru_base_vaddr,\n\t\t\t\tgts->ts_ctxnum, ucbnum);\n\t\tret = gru_user_dropin(gts, tfh, cbk);\n\t}\nexit:\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "is_query(const char *query)\n{\n\tconst char *query_list[] = {\"insert\", \"update\", \"delete\", \"replace\",\n\t\t\"alter\", \"load\", \"select\", \"do\", \"handler\", \"call\", \"execute\",\n\t\t\"begin\", NULL};\n\treturn is_query_from_list(query, query_list);\n}", "target": 0}
{"code": "void rose_start_t3timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t3;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "size_t TensorSliceWriter::MaxBytesPerElement(DataType dt) {\n  switch (dt) {\n    case DT_FLOAT:\n      return 4;\n    case DT_DOUBLE:\n      return 8;\n    case DT_INT32:\n      return 10;\n    case DT_UINT8:\n      return 2;\n    case DT_INT16:\n      return 10;\n    case DT_INT8:\n      return 10;\n    case DT_COMPLEX64:\n      return 8;\n    case DT_INT64:\n      return 10;\n    case DT_BOOL:\n      return 1;\n    case DT_QINT8:\n      return 10;\n    case DT_QUINT8:\n      return 2;\n    case DT_QINT32:\n      return 10;\n    case DT_QINT16:\n      return 10;\n    case DT_QUINT16:\n      return 3;\n    case DT_UINT16:\n      return 3;\n    case DT_COMPLEX128:\n      return 16;\n    case DT_HALF:\n      return 3;\n    case DT_INVALID:\n    case DT_STRING:\n    case DT_BFLOAT16:\n    default:\n      LOG(FATAL) << \"MaxBytesPerElement not implemented for dtype: \" << dt;\n  }\n  return 0;\n}", "target": 1}
{"code": "MemoryRegion *memory_map_ptr(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms, void *ptr)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram_ptr(uc, ram, size, ptr);\n    ram->perms = perms;\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tint chk_addr_ret;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_l2tpip))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip_lock);\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n\t\tgoto out;\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  \n\tsk_dst_reset(sk);\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\nout:\n\trelease_sock(sk);\n\treturn ret;\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\treturn ret;\n}", "target": 1}
{"code": "GF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration)\n{\n\tu32 i=0;\n\tu32 k, l;\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\t*nb_samples = 0;\n\t*duration = 0;\n\twhile ((moof=(GF_MovieFragmentBox*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tu32 j=0;\n\t\tif (moof->type!=GF_ISOM_BOX_TYPE_MOOF) continue;\n\t\twhile ((traf=(GF_TrackFragmentBox*)gf_list_enum( moof->TrackList, &j))) {\n\t\t\tu64 def_duration, samp_dur=0;\n\t\t\tif (traf->tfhd->trackID != trackID)\n\t\t\t\tcontinue;\n\t\t\tdef_duration = 0;\n\t\t\tif (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) def_duration = traf->tfhd->def_sample_duration;\n\t\t\telse if (traf->trex) def_duration = traf->trex->def_sample_duration;\n\t\t\tfor (k=0; k<gf_list_count(traf->TrackRuns); k++) {\n\t\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, k);\n\t\t\t\t*nb_samples += trun->sample_count;\n\t\t\t\tfor (l=0; l<trun->nb_samples; l++) {\n\t\t\t\t\tGF_TrunEntry *ent = &trun->samples[l];\n\t\t\t\t\tsamp_dur = def_duration;\n\t\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) samp_dur = ent->Duration;\n\t\t\t\t\tif (trun->nb_samples == trun->sample_count)\n\t\t\t\t\t\t*duration += samp_dur;\n\t\t\t\t}\n\t\t\t\tif (trun->nb_samples != trun->sample_count)\n\t\t\t\t\t*duration += samp_dur * trun->sample_count;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1}
{"code": "    CImg<intT> get_select(CImgDisplay &disp,\n\t\t          const unsigned int feature_type=2, unsigned int *const XYZ=0,\n                          const bool exit_on_anykey=false) const {\n      return _select(disp,0,feature_type,XYZ,0,0,0,exit_on_anykey,true,false);", "target": 0}
{"code": "test_function (char * (*my_asnprintf) (char *, size_t *, const char *, ...))\n{\n  char buf[8];\n  int size;\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length = size;\n      char *result = my_asnprintf (NULL, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      free (result);\n    }\n  for (size = 0; size <= 8; size++)\n    {\n      size_t length;\n      char *result;\n      memcpy (buf, \"DEADBEEF\", 8);\n      length = size;\n      result = my_asnprintf (buf, &length, \"%d\", 12345);\n      ASSERT (result != NULL);\n      ASSERT (strcmp (result, \"12345\") == 0);\n      ASSERT (length == 5);\n      if (size < 6)\n        ASSERT (result != buf);\n      ASSERT (memcmp (buf + size, &\"DEADBEEF\"[size], 8 - size) == 0);\n      if (result != buf)\n        free (result);\n    }\n}", "target": 1}
{"code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}", "target": 1}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb)\n{\n\tkiocb->ki_iovec = &kiocb->ki_inline_vec;\n\tkiocb->ki_iovec->iov_base = kiocb->ki_buf;\n\tkiocb->ki_iovec->iov_len = kiocb->ki_left;\n\tkiocb->ki_nr_segs = 1;\n\tkiocb->ki_cur_seg = 0;\n\treturn 0;\n}", "target": 1}
{"code": "int audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_aux_data_execve *ax;\n\tstruct audit_context *context = current->audit_context;\n\tif (likely(!audit_enabled || !context || context->dummy))\n\t\treturn 0;\n\tif (bprm->argv_len > (audit_argv_kb << 10))\n\t\treturn -E2BIG;\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\tax->argc = bprm->argc;\n\tax->envc = bprm->envc;\n\tax->mm = bprm->mm;\n\tax->d.type = AUDIT_EXECVE;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\treturn 0;\n}", "target": 0}
{"code": "static int lua_websocket_close(lua_State *L) \n{\n    apr_socket_t *sock;\n    char prelude[2];\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    sock = ap_get_conn_socket(r->connection);\n    prelude[0] = 0x88; \n    prelude[1] = 0; \n    ap_rwrite(prelude, 2, r);\n    apr_socket_close(sock);\n    r->output_filters = NULL;\n    r->connection->keepalive = AP_CONN_CLOSE;\n    return 0;\n}", "target": 0}
{"code": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\tif (!(rcv->flags & IFF_UP))\n\t\tgoto tx_drop;\n\tif (dev->features & NETIF_F_NO_CSUM)\n\t\tskb->ip_summed = rcv_priv->ip_summed;\n\tlength = skb->len + ETH_HLEN;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\treturn NETDEV_TX_OK;\ntx_drop:\n\tkfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\nrx_drop:\n\tkfree_skb(skb);\n\trcv_stats->rx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "static void adpt_sparc_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_ULTRASPARC;\n}", "target": 1}
{"code": "static void LodePNGIText_init(LodePNGInfo* info)\n{\n  info->itext_num = 0;\n  info->itext_keys = NULL;\n  info->itext_langtags = NULL;\n  info->itext_transkeys = NULL;\n  info->itext_strings = NULL;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_STATUS(CalculateOpData(context, params, input, output, data));\n  if (input->type == kTfLiteFloat32) {\n    CalculateActivationRange(params->activation, &data->activation_min_f32,\n                             &data->activation_max_f32);\n  } else if (input->type == kTfLiteInt8 || input->type == kTfLiteUInt8) {\n    CalculateActivationRangeQuantized(context, params->activation, output,\n                                      &data->activation_min,\n                                      &data->activation_max);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "int main(int argc, char *argv[] ) {\n\tint i, fails_count=0;\n\tCU_pSuite cryptoUtilsTestSuite, parserTestSuite;\n\tCU_pSuite *suites[] = {\n\t\t&cryptoUtilsTestSuite,\n\t\t&parserTestSuite,\n\t\tNULL\n\t};\n\tif (argc>1) {\n\t\tif (argv[1][0] == '-') {\n\t\t\tif (strcmp(argv[1], \"-verbose\") == 0) {\n\t\t\t\tverbose = 1;\n\t\t\t} else {\n\t\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n#ifdef HAVE_LIBXML2\n\txmlInitParser();\n#endif\n\tif (CUE_SUCCESS != CU_initialize_registry()) {\n\t\treturn CU_get_error();\n\t}\n\tcryptoUtilsTestSuite = CU_add_suite(\"Bzrtp Crypto Utils\", NULL, NULL);\n\tCU_add_test(cryptoUtilsTestSuite, \"zrtpKDF\", test_zrtpKDF);\n\tCU_add_test(cryptoUtilsTestSuite, \"CRC32\", test_CRC32);\n\tCU_add_test(cryptoUtilsTestSuite, \"algo agreement\", test_algoAgreement);\n\tCU_add_test(cryptoUtilsTestSuite, \"context algo setter and getter\", test_algoSetterGetter);\n\tCU_add_test(cryptoUtilsTestSuite, \"adding mandatory crypto algorithms if needed\", test_addMandatoryCryptoTypesIfNeeded);\n\tparserTestSuite = CU_add_suite(\"Bzrtp ZRTP Packet Parser\", NULL, NULL);\n\tCU_add_test(parserTestSuite, \"Parse\", test_parser);\n\tCU_add_test(parserTestSuite, \"Parse hvi check fail\", test_parser_hvi);\n\tCU_add_test(parserTestSuite, \"Parse Exchange\", test_parserComplete);\n\tCU_add_test(parserTestSuite, \"State machine\", test_stateMachine);\n\tfor(i=0; suites[i]; i++){\n\t\tCU_basic_run_suite(*suites[i]);\n\t\tfails_count += CU_get_number_of_tests_failed();\n\t}\n\tCU_cleanup_registry();\n#ifdef HAVE_LIBXML2\n\txmlCleanupParser();\n#endif\n\treturn (fails_count == 0 ? 0 : 1);\n}", "target": 0}
{"code": "static void rb_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      struct ring_buffer_event *event)\n{\n\tlocal_inc(&cpu_buffer->entries);\n\trb_update_write_stamp(cpu_buffer, event);\n\trb_end_commit(cpu_buffer);\n}", "target": 0}
{"code": "int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}", "target": 1}
{"code": "static void get_info_from_frame (mpeg2ps_stream_t *sptr,\n                                 u8 *buffer,\n                                 u32 buflen)\n{\n\tif (sptr->is_video) {\n\t\tif (MPEG12_ParseSeqHdr(buffer, buflen,\n\t\t                       &sptr->have_mpeg2,\n\t\t                       &sptr->h,\n\t\t                       &sptr->w,\n\t\t                       &sptr->frame_rate,\n\t\t                       &sptr->bit_rate,\n\t\t                       &sptr->par) < 0) {\n\t\t\tsptr->m_stream_id = 0;\n\t\t\tsptr->m_fd = FDNULL;\n\t\t\treturn;\n\t\t}\n\t\tsptr->ticks_per_frame = (u64)(90000.0 / sptr->frame_rate);\n\t\treturn;\n\t}\n\tif (sptr->m_stream_id >= 0xc0) {\n\t\tu32 hdr = GF_4CC((u32)buffer[0],buffer[1],buffer[2],buffer[3]);\n\t\tsptr->channels = gf_mp3_num_channels(hdr);\n\t\tsptr->freq = gf_mp3_sampling_rate(hdr);\n\t\tsptr->samples_per_frame = gf_mp3_window_size(hdr);\n\t\tsptr->bitrate = gf_mp3_bit_rate(hdr) * 1000; \n\t\tsptr->layer = gf_mp3_layer(hdr);\n\t} else if (sptr->m_stream_id == 0xbd) {\n\t\tif (sptr->m_substream_id >= 0xa0) {\n\t\t} else if (sptr->m_substream_id >= 0x80) {\n\t\t\tu32 pos;\n\t\t\tGF_AC3Config hdr;\n\t\t\tmemset(&hdr, 0, sizeof(GF_AC3Config));\n\t\t\tgf_ac3_parser(buffer, buflen, &pos, &hdr, 0);\n\t\t\tsptr->bitrate = gf_ac3_get_bitrate(hdr.brcode);\n\t\t\tsptr->freq = hdr.sample_rate;\n\t\t\tsptr->channels = hdr.streams[0].channels;\n\t\t\tsptr->samples_per_frame = 256 * 6;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "static int check_swap_activate(struct file *swap_file, unsigned int max)\n{\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tunsigned blocks_per_page;\n\tunsigned long page_no;\n\tunsigned blkbits;\n\tsector_t probe_block;\n\tsector_t last_block;\n\tsector_t lowest_block = -1;\n\tsector_t highest_block = 0;\n\tblkbits = inode->i_blkbits;\n\tblocks_per_page = PAGE_SIZE >> blkbits;\n\tprobe_block = 0;\n\tpage_no = 0;\n\tlast_block = i_size_read(inode) >> blkbits;\n\twhile ((probe_block + blocks_per_page) <= last_block && page_no < max) {\n\t\tunsigned block_in_page;\n\t\tsector_t first_block;\n\t\tcond_resched();\n\t\tfirst_block = bmap(inode, probe_block);\n\t\tif (first_block == 0)\n\t\t\tgoto bad_bmap;\n\t\tif (first_block & (blocks_per_page - 1)) {\n\t\t\tprobe_block++;\n\t\t\tgoto reprobe;\n\t\t}\n\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;\n\t\t\t\t\tblock_in_page++) {\n\t\t\tsector_t block;\n\t\t\tblock = bmap(inode, probe_block + block_in_page);\n\t\t\tif (block == 0)\n\t\t\t\tgoto bad_bmap;\n\t\t\tif (block != first_block + block_in_page) {\n\t\t\t\tprobe_block++;\n\t\t\t\tgoto reprobe;\n\t\t\t}\n\t\t}\n\t\tfirst_block >>= (PAGE_SHIFT - blkbits);\n\t\tif (page_no) {\t\n\t\t\tif (first_block < lowest_block)\n\t\t\t\tlowest_block = first_block;\n\t\t\tif (first_block > highest_block)\n\t\t\t\thighest_block = first_block;\n\t\t}\n\t\tpage_no++;\n\t\tprobe_block += blocks_per_page;\nreprobe:\n\t\tcontinue;\n\t}\n\treturn 0;\nbad_bmap:\n\tpr_err(\"swapon: swapfile has holes\\n\");\n\treturn -EINVAL;\n}", "target": 0}
{"code": "f_indent(typval_T *argvars, typval_T *rettv)\n{\n    linenr_T\tlnum;\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n\trettv->vval.v_number = get_indent_lnum(lnum);\n    else\n    {\n\tif (in_vim9script())\n\t    semsg(_(e_invalid_line_number_nr), lnum);\n\trettv->vval.v_number = -1;\n    }\n}", "target": 0}
{"code": "static int efi_capsule_release(struct inode *inode, struct file *file)\n{\n\tstruct capsule_info *cap_info = file->private_data;\n\tif (cap_info->index > 0 &&\n\t    (cap_info->header.headersize == 0 ||\n\t     cap_info->count < cap_info->total_size)) {\n\t\tpr_err(\"capsule upload not complete\\n\");\n\t\tefi_free_all_buff_pages(cap_info);\n\t}\n\tkfree(cap_info->pages);\n\tkfree(cap_info->phys);\n\tkfree(file->private_data);\n\tfile->private_data = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "void AOClient::pktRemoveEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->deleteEvidence(idx);\n    }\n    sendEvidenceList(area);\n}", "target": 1}
{"code": "static int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\tint r;\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu->kvm, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu->kvm, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}", "target": 0}
{"code": "findoprnd(ITEM *ptr, int32 *pos)\n{\n\tcheck_stack_depth();\n#ifdef BS_DEBUG\n\telog(DEBUG3, (ptr[*pos].type == OPR) ?\n\t\t \"%d  %c\" : \"%d  %d\", *pos, ptr[*pos].val);\n#endif\n\tif (ptr[*pos].type == VAL)\n\t{\n\t\tptr[*pos].left = 0;\n\t\t(*pos)--;\n\t}\n\telse if (ptr[*pos].val == (int32) '!')\n\t{\n\t\tptr[*pos].left = -1;\n\t\t(*pos)--;\n\t\tfindoprnd(ptr, pos);\n\t}\n\telse\n\t{\n\t\tITEM\t   *curitem = &ptr[*pos];\n\t\tint32\t\ttmp = *pos;\n\t\t(*pos)--;\n\t\tfindoprnd(ptr, pos);\n\t\tcuritem->left = *pos - tmp;\n\t\tfindoprnd(ptr, pos);\n\t}\n}", "target": 0}
{"code": "parse_SET_IP_ECN(char *arg, const struct ofpact_parse_params *pp)\n{\n    uint8_t ecn;\n    char *error;\n    error = str_to_u8(arg, \"ECN\", &ecn);\n    if (error) {\n        return error;\n    }\n    if (ecn & ~IP_ECN_MASK) {\n        return xasprintf(\"%s: not a valid ECN\", arg);\n    }\n    ofpact_put_SET_IP_ECN(pp->ofpacts)->ecn = ecn;\n    return NULL;\n}", "target": 0}
{"code": "parse_ranges(struct client *clt, char *str, size_t file_sz)\n{\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\tmemset(r, 0, sizeof(*r));\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (-1);\n\t*p++ = '\\0';\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (-1);\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\t\tif (parse_range_spec(p, file_sz, &r->range[i]) == 0)\n\t\t\tcontinue;\n\t\ti++;\n\t\tif (i == SERVER_MAX_RANGES)\n\t\t\treturn (-1);\n\t\tp = q;\n\t}\n\tif (parse_range_spec(p, file_sz, &r->range[i]) != 0)\n\t\ti++;\n\tr->range_total = file_sz;\n\tr->range_count = i;\n\treturn (i);\n}", "target": 0}
{"code": "cdf_unpack_dir(cdf_directory_t *d, char *buf)\n{\n\tsize_t len = 0;\n\tCDF_UNPACKA(d->d_name);\n\tCDF_UNPACK(d->d_namelen);\n\tCDF_UNPACK(d->d_type);\n\tCDF_UNPACK(d->d_color);\n\tCDF_UNPACK(d->d_left_child);\n\tCDF_UNPACK(d->d_right_child);\n\tCDF_UNPACK(d->d_storage);\n\tCDF_UNPACKA(d->d_storage_uuid);\n\tCDF_UNPACK(d->d_flags);\n\tCDF_UNPACK(d->d_created);\n\tCDF_UNPACK(d->d_modified);\n\tCDF_UNPACK(d->d_stream_first_sector);\n\tCDF_UNPACK(d->d_size);\n\tCDF_UNPACK(d->d_unused0);\n}", "target": 0}
{"code": "void *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree (mo->symbols[i].name);\n\t\t}\n\t\tfree (mo->symbols);\n\t}\n\tfree (mo->segs);\n\tfree (mo->sects);\n\tfree (mo->symtab);\n\tfree (mo->symstr);\n\tfree (mo->indirectsyms);\n\tfree (mo->imports_by_ord);\n\tht_pp_free (mo->imports_by_name);\n\tfree (mo->dyld_info);\n\tfree (mo->toc);\n\tfree (mo->modtab);\n\tfree (mo->libs);\n\tfree (mo->func_start);\n\tfree (mo->signature);\n\tfree (mo->intrp);\n\tfree (mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nsegs; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree (mo->chained_starts[i]->page_start);\n\t\t\t\tfree (mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree (mo->chained_starts);\n\t}\n\tr_buf_free (mo->b);\n\tfree (mo);\n\treturn NULL;\n}", "target": 1}
{"code": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n    if (SMALL_OBJ(lb))\n        return(GC_generic_malloc((word)lb, k));\n    lg = ROUNDED_UP_GRANULES(lb);\n    lb_rounded = GRANULES_TO_BYTES(lg);\n    if (lb_rounded < lb)\n        return((*GC_get_oom_fn())(lb));\n    n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n    init = GC_obj_kinds[k].ok_init;\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}", "target": 0}
{"code": "int smm_setup_relocation_handler(struct smm_loader_params *params)\n{\n\tvoid *smram = (void *)(SMM_DEFAULT_BASE);\n\tprintk(BIOS_SPEW, \"%s: enter\\n\", __func__);\n\tif (params->num_concurrent_save_states > 1)\n\t\treturn -1;\n\tif (params->handler == NULL)\n\t\treturn -1;\n\tif (params->num_concurrent_stacks == 0)\n\t\tparams->num_concurrent_stacks = CONFIG_MAX_CPUS;\n\tparams->smm_main_entry_offset = SMM_ENTRY_OFFSET;\n\tparams->smram_start = SMM_DEFAULT_BASE;\n\tparams->smram_end = SMM_DEFAULT_BASE + SMM_DEFAULT_SIZE;\n\treturn smm_module_setup_stub(smram, SMM_DEFAULT_SIZE,\n\t\t\t\tparams, fxsave_area_relocation);\n\tprintk(BIOS_SPEW, \"%s: exit\\n\", __func__);\n}", "target": 0}
{"code": "ecma_op_function_call_native_built_in (ecma_object_t *func_obj_p, \n                                       ecma_value_t this_arg_value, \n                                       const ecma_value_t *arguments_list_p, \n                                       uint32_t arguments_list_len) \n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION);\n  ECMA_CHECK_STACK_USAGE ();\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  ecma_extended_object_t *ext_func_obj_p = (ecma_extended_object_t *) func_obj_p;\n  JERRY_CONTEXT (global_object_p) =\n    ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, ext_func_obj_p->u.built_in.realm_value);\n#endif \n  ecma_value_t ret_value =\n    ecma_builtin_dispatch_call (func_obj_p, this_arg_value, arguments_list_p, arguments_list_len);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  return ret_value;\n} ", "target": 0}
{"code": "lrmd_remote_client_msg(gpointer data)\n{\n    int id = 0;\n    int rc = 0;\n    int disconnected = 0;\n    xmlNode *request = NULL;\n    crm_client_t *client = data;\n    if (client->remote->tls_handshake_complete == FALSE) {\n        int rc = 0;\n        do {\n            rc = gnutls_handshake(*client->remote->tls_session);\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote lrmd tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n        if (rc == 0) {\n            crm_debug(\"Remote lrmd tls handshake completed\");\n            client->remote->tls_handshake_complete = TRUE;\n            if (client->remote->auth_timeout) {\n                g_source_remove(client->remote->auth_timeout);\n            }\n            client->remote->auth_timeout = 0;\n            notify_of_new_client(client);\n        }\n        return 0;\n    }\n    rc = crm_remote_ready(client->remote, 0);\n    if (rc == 0) {\n        return 0;\n    } else if (rc < 0) {\n        crm_info(\"Client disconnected during remote client read\");\n        return -1;\n    }\n    crm_remote_recv(client->remote, -1, &disconnected);\n    request = crm_remote_parse_buffer(client->remote);\n    while (request) {\n        crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);\n        crm_trace(\"processing request from remote client with remote msg id %d\", id);\n        if (!client->name) {\n            const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);\n            if (value) {\n                client->name = strdup(value);\n            }\n        }\n        lrmd_call_id++;\n        if (lrmd_call_id < 1) {\n            lrmd_call_id = 1;\n        }\n        crm_xml_add(request, F_LRMD_CLIENTID, client->id);\n        crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);\n        crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);\n        process_lrmd_message(client, id, request);\n        free_xml(request);\n        request = crm_remote_parse_buffer(client->remote);\n    }\n    if (disconnected) {\n        crm_info(\"Client disconnect detected in tls msg dispatcher.\");\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "void ext4_es_insert_delayed_block(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t  bool allocated)\n{\n\tstruct extent_status newes;\n\tint err1 = 0;\n\tint err2 = 0;\n\tstruct extent_status *es1 = NULL;\n\tstruct extent_status *es2 = NULL;\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\tes_debug(\"add [%u/1) delayed to extent status tree of inode %lu\\n\",\n\t\t lblk, inode->i_ino);\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = 1;\n\text4_es_store_pblock_status(&newes, ~0, EXTENT_STATUS_DELAYED);\n\ttrace_ext4_es_insert_delayed_block(inode, &newes, allocated);\n\text4_es_insert_extent_check(inode, &newes);\nretry:\n\tif (err1 && !es1)\n\t\tes1 = __es_alloc_extent(true);\n\tif ((err1 || err2) && !es2)\n\t\tes2 = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr1 = __es_remove_extent(inode, lblk, lblk, NULL, es1);\n\tif (err1 != 0)\n\t\tgoto error;\n\terr2 = __es_insert_extent(inode, &newes, es2);\n\tif (err2 != 0)\n\t\tgoto error;\n\tif (allocated)\n\t\t__insert_pending(inode, lblk);\n\tif (es1 && !es1->es_len)\n\t\t__es_free_extent(es1);\n\tif (es2 && !es2->es_len)\n\t\t__es_free_extent(es2);\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err1 || err2)\n\t\tgoto retry;\n\text4_es_print_tree(inode);\n\text4_print_pending_tree(inode);\n\treturn;\n}", "target": 1}
{"code": "static int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\tif (!parent_path) {\n\t\terr = count_mounts(ns, source_mnt);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\treturn 0;\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n\t\tumount_tree(child, UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\tns->pending_mounts = 0;\n\treturn err;\n}", "target": 0}
{"code": "inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n  return t->dims->data[dim];\n}", "target": 1}
{"code": "static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode)\n{\n\text4_io_end_t *io_end;\n\tstruct page *page = bh->b_page;\n\tloff_t offset = (sector_t)page->index << PAGE_CACHE_SHIFT;\n\tsize_t size = bh->b_size;\nretry:\n\tio_end = ext4_init_io_end(inode, GFP_ATOMIC);\n\tif (!io_end) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"%s: allocation fail\\n\", __func__);\n\t\tschedule();\n\t\tgoto retry;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\tio_end->page = page;\n\tget_page(io_end->page);\n\tbh->b_private = io_end;\n\tbh->b_end_io = ext4_end_io_buffer_write;\n\treturn 0;\n}", "target": 0}
{"code": "http_rxchunk(struct http *hp)\n{\n\tchar *q;\n\tint l, i;\n\tl = hp->prxbuf;\n\tdo\n\t\t(void)http_rxchar(hp, 1, 0);\n\twhile (hp->rxbuf[hp->prxbuf - 1] != '\\n');\n\tvtc_dump(hp->vl, 4, \"len\", hp->rxbuf + l, -1);\n\ti = strtoul(hp->rxbuf + l, &q, 16);\n\tbprintf(hp->chunklen, \"%d\", i);\n\tif ((q == hp->rxbuf + l) ||\n\t\t(*q != '\\0' && !vct_islws(*q))) {\n\t\tvtc_log(hp->vl, hp->fatal, \"chunked fail %02x @ %d\",\n\t\t    *q, q - (hp->rxbuf + l));\n\t}\n\tassert(q != hp->rxbuf + l);\n\tassert(*q == '\\0' || vct_islws(*q));\n\thp->prxbuf = l;\n\tif (i > 0) {\n\t\t(void)http_rxchar(hp, i, 0);\n\t\tvtc_dump(hp->vl, 4, \"chunk\",\n\t\t    hp->rxbuf + l, i);\n\t}\n\tl = hp->prxbuf;\n\t(void)http_rxchar(hp, 2, 0);\n\tif(!vct_iscrlf(hp->rxbuf[l]))\n\t\tvtc_log(hp->vl, hp->fatal,\n\t\t    \"Wrong chunk tail[0] = %02x\",\n\t\t    hp->rxbuf[l] & 0xff);\n\tif(!vct_iscrlf(hp->rxbuf[l + 1]))\n\t\tvtc_log(hp->vl, hp->fatal,\n\t\t    \"Wrong chunk tail[1] = %02x\",\n\t\t    hp->rxbuf[l + 1] & 0xff);\n\thp->prxbuf = l;\n\thp->rxbuf[l] = '\\0';\n\treturn (i);\n}", "target": 1}
{"code": "static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,\n\t\t\t\t\t\tint id)\n{\n\tstruct ion_handle *handle;\n\thandle = idr_find(&client->idr, id);\n\tif (handle)\n\t\tion_handle_get(handle);\n\treturn handle ? handle : ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n    return crc;\n}", "target": 1}
{"code": "externalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: \n    default:\n      break;\n    }\n  }\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "init_ext2_xattr(void)\n{\n\treturn 0;\n}", "target": 1}
{"code": "nfsd4_layout_verify(struct svc_export *exp, unsigned int layout_type)\n{\n\tif (!exp->ex_layout_types) {\n\t\tdprintk(\"%s: export does not support pNFS\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tif (!(exp->ex_layout_types & (1 << layout_type))) {\n\t\tdprintk(\"%s: layout type %d not supported\\n\",\n\t\t\t__func__, layout_type);\n\t\treturn NULL;\n\t}\n\treturn nfsd4_layout_ops[layout_type];\n}", "target": 1}
{"code": "static inline bool unconditional(const struct ipt_ip *ip)\n{\n\tstatic const struct ipt_ip uncond;\n\treturn memcmp(ip, &uncond, sizeof(uncond)) == 0;\n#undef FWINV\n}", "target": 1}
{"code": "void HeaderTable::setCapacity(uint32_t capacity) {\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ <= oldCapacity) {\n    evict(0);\n  } else {\n    auto oldTail = tail();\n    auto oldLength = table_.size();\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    table_.resize(newLength);\n    if (size_ > 0 && oldTail > head_) {\n      std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                table_.begin() + newLength - (oldLength - oldTail));\n      for (auto& names_it: names_) {\n        for (auto& idx: names_it.second) {\n          if (idx >= oldTail) {\n            DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n            idx += (table_.size() - oldLength);\n          } else {\n            break;\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "void G711::describe()\n{\n\tif (mode() == Compress)\n\t{\n\t\tm_outChunk->f.compressionType = m_track->f.compressionType;\n\t}\n\telse\n\t{\n\t\tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n\t}\n}", "target": 0}
{"code": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int32_t virtio_net_rsc_sanity_check4(VirtioNetRscChain *chain,\n                                            struct ip_header *ip,\n                                            const uint8_t *buf, size_t size)\n{\n    uint16_t ip_len;\n    if (((ip->ip_ver_len & 0xF0) >> 4) != IP_HEADER_VERSION_4) {\n        chain->stat.ip_option++;\n        return RSC_BYPASS;\n    }\n    if ((ip->ip_ver_len & 0xF) != VIRTIO_NET_IP4_HEADER_LENGTH) {\n        chain->stat.ip_option++;\n        return RSC_BYPASS;\n    }\n    if (ip->ip_p != IPPROTO_TCP) {\n        chain->stat.bypass_not_tcp++;\n        return RSC_BYPASS;\n    }\n    if (!(htons(ip->ip_off) & IP_DF)) {\n        chain->stat.ip_frag++;\n        return RSC_BYPASS;\n    }\n    if (IPTOS_ECN(ip->ip_tos)) {\n        chain->stat.ip_ecn++;\n        return RSC_BYPASS;\n    }\n    ip_len = htons(ip->ip_len);\n    if (ip_len < (sizeof(struct ip_header) + sizeof(struct tcp_header))\n        || ip_len > (size - chain->n->guest_hdr_len -\n                     sizeof(struct eth_header))) {\n        chain->stat.ip_hacked++;\n        return RSC_BYPASS;\n    }\n    return RSC_CANDIDATE;\n}", "target": 0}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t\tmsg->msg_namelen = sizeof(*sax);\n\t}\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn copied;\n}", "target": 0}
{"code": "int cg_write(const char *path, const char *buf, size_t size, off_t offset,\n\t     struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *localbuf = NULL;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *f = (struct file_info *)fi->fh;\n\tbool r;\n\tif (f->type != LXC_TYPE_CGFILE) {\n\t\tfprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");\n\t\treturn -EIO;\n\t}\n\tif (offset)\n\t\treturn 0;\n\tif (!fc)\n\t\treturn -EIO;\n\tlocalbuf = alloca(size+1);\n\tlocalbuf[size] = '\\0';\n\tmemcpy(localbuf, buf, size);\n\tif ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {\n\t\tsize = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\tif (!r)\n\t\tsize = -EINVAL;\nout:\n\tfree_key(k);\n\treturn size;\n}", "target": 1}
{"code": "struct torture_suite *torture_smb2_notify_inotify_init(TALLOC_CTX *ctx)\n{\n\tstruct torture_suite *suite = torture_suite_create(ctx, \"notify-inotify\");\n\tsuite->description = talloc_strdup(suite, \"SMB2-NOTIFY tests that use inotify\");\n\ttorture_suite_add_2smb2_test(suite, \"inotify-rename\", torture_smb2_inotify_rename);\n\treturn suite;\n}", "target": 0}
{"code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}", "target": 1}
{"code": "static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)\n{\n\tstatic u32 challenge_timestamp;\n\tstatic unsigned int challenge_count;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 now;\n\tif (tcp_oow_rate_limited(sock_net(sk), skb,\n\t\t\t\t LINUX_MIB_TCPACKSKIPPEDCHALLENGE,\n\t\t\t\t &tp->last_oow_ack_time))\n\t\treturn;\n\tnow = jiffies / HZ;\n\tif (now != challenge_timestamp) {\n\t\tchallenge_timestamp = now;\n\t\tchallenge_count = 0;\n\t}\n\tif (++challenge_count <= sysctl_tcp_challenge_ack_limit) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);\n\t\ttcp_send_ack(sk);\n\t}\n}", "target": 1}
{"code": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\tpr_debug(\"sock=%p\\n\", sock);\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)\n\t\tnfc_sock_link(&raw_sk_list, sk);\n\telse {\n\t\tINIT_WORK(&nfc_rawsock(sk)->tx_work, rawsock_tx_work);\n\t\tnfc_rawsock(sk)->tx_work_scheduled = false;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct qmp *qmp_get(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct qmp *qmp;\n\tif (!dev || !dev->of_node)\n\t\treturn ERR_PTR(-EINVAL);\n\tnp = of_parse_phandle(dev->of_node, \"qcom,qmp\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\tqmp = platform_get_drvdata(pdev);\n\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n}", "target": 1}
{"code": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "int CLua::loadfile(lua_State *ls, const char *filename, bool trusted,\n                   bool die_on_fail)\n{\n    if (!ls)\n        return -1;\n    if (!is_path_safe(filename, trusted))\n    {\n        lua_pushstring(\n            ls,\n            make_stringf(\"invalid filename: %s\", filename).c_str());\n        return -1;\n    }\n    string file = datafile_path(filename, die_on_fail);\n    if (file.empty())\n    {\n        lua_pushstring(ls,\n                       make_stringf(\"Can't find \\\"%s\\\"\", filename).c_str());\n        return -1;\n    }\n    FileLineInput f(file.c_str());\n    string script;\n    while (!f.eof())\n        script += f.get_line() + \"\\n\";\n    if (script[0] == 0x1b)\n        abort();\n    return luaL_loadbuffer(ls, &script[0], script.length(),\n                           (\"@\" + file).c_str());\n}", "target": 0}
{"code": "void RootWindowHostLinux::ShowCursor(bool show) {\n  if (show == cursor_shown_)\n    return;\n  cursor_shown_ = show;\n  SetCursorInternal(show ? current_cursor_ : ui::kCursorNone);\n}", "target": 0}
{"code": "int dns_add_rr_nested_memcpy(struct dns_rr_nested *rr_nested, void *data, int data_len)\n{\n\tif (rr_nested == NULL || data == NULL || data_len <= 0) {\n\t\treturn -1;\n\t}\n\tif (_dns_left_len(&rr_nested->context) < data_len) {\n\t\treturn -1;\n\t}\n\tmemcpy(rr_nested->context.ptr, data, data_len);\n\trr_nested->context.ptr += data_len;\n\treturn 0;\n}", "target": 1}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}", "target": 1}
{"code": "void test_base64_decode(void)\n{\n  char buffer[16];\n  int len = mutt_b64_decode(buffer, encoded);\n  if (!TEST_CHECK(len == sizeof(clear) - 1))\n  {\n    TEST_MSG(\"Expected: %zu\", sizeof(clear) - 1);\n    TEST_MSG(\"Actual  : %zu\", len);\n  }\n  buffer[len] = '\\0';\n  if (!TEST_CHECK(strcmp(buffer, clear) == 0))\n  {\n    TEST_MSG(\"Expected: %s\", clear);\n    TEST_MSG(\"Actual  : %s\", buffer);\n  }\n}", "target": 1}
{"code": "juniper_atm2_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM2;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        ND_TCHECK2(p[0], 3);\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && \n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            return l2info.header_len;\n        }\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_atm2]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "int cipso_v4_sock_setattr(struct sock *sk,\n\t\t\t  const struct cipso_v4_doi *doi_def,\n\t\t\t  const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_sock *sk_inet;\n\tstruct inet_connection_sock *sk_conn;\n\tif (sk == NULL)\n\t\treturn 0;\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto socket_setattr_failure;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto socket_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\tsk_inet = inet_sk(sk);\n\tif (sk_inet->is_icsk) {\n\t\tsk_conn = inet_csk(sk);\n\t\tif (sk_inet->opt)\n\t\t\tsk_conn->icsk_ext_hdr_len -= sk_inet->opt->optlen;\n\t\tsk_conn->icsk_ext_hdr_len += opt->optlen;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n\topt = xchg(&sk_inet->opt, opt);\n\tkfree(opt);\n\treturn 0;\nsocket_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1}
{"code": "bool current_chrooted(void)\n{\n\tstruct path ns_root;\n\tstruct path fs_root;\n\tbool chrooted;\n\tns_root.mnt = &current->nsproxy->mnt_ns->root->mnt;\n\tns_root.dentry = ns_root.mnt->mnt_root;\n\tpath_get(&ns_root);\n\twhile (d_mountpoint(ns_root.dentry) && follow_down_one(&ns_root))\n\t\t;\n\tget_fs_root(current->fs, &fs_root);\n\tchrooted = !path_equal(&fs_root, &ns_root);\n\tpath_put(&fs_root);\n\tpath_put(&ns_root);\n\treturn chrooted;\n}", "target": 0}
{"code": "  void setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n    san_matchers_ = san_matchers;\n  };", "target": 1}
{"code": "int htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "  void ValidateOpDimensionsFromInputs(const int n, const int h, const int w,\n                                      const int c, const int kx, const int ky,\n                                      const int sx, const int sy,\n                                      const string& data_format,\n                                      const string& padding) {\n    OpContext op_context;\n    int ho;\n    int wo;\n    if (data_format == \"NHWC\") {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, h, w, c}, {1, kx, ky, 1},\n                                     {1, sx, sy, 1}, \"NHWC\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(1).size();\n      wo = op_context.op_info.outputs(0).shape().dim(2).size();\n    } else {\n      op_context = DescribePoolingOp(\"MaxPool\", {n, c, h, w}, {1, 1, kx, ky},\n                                     {1, 1, sx, sy}, \"NCHW\", padding);\n      ho = op_context.op_info.outputs(0).shape().dim(2).size();\n      wo = op_context.op_info.outputs(0).shape().dim(3).size();\n    }\n    bool found_unknown_shapes;\n    auto dims = OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n    Padding padding_enum;\n    if (padding == \"VALID\") {\n      padding_enum = Padding::VALID;\n    } else {\n      padding_enum = Padding::SAME;\n    }\n    EXPECT_EQ(n, dims.batch);\n    EXPECT_EQ(h, dims.ix);\n    EXPECT_EQ(w, dims.iy);\n    EXPECT_EQ(c, dims.iz);\n    EXPECT_EQ(kx, dims.kx);\n    EXPECT_EQ(ky, dims.ky);\n    EXPECT_EQ(sx, dims.sx);\n    EXPECT_EQ(sy, dims.sy);\n    EXPECT_EQ(ho, dims.ox);\n    EXPECT_EQ(wo, dims.oy);\n    EXPECT_EQ(c, dims.oz);\n    EXPECT_EQ(padding_enum, dims.padding);\n  }", "target": 1}
{"code": "static int get_filter(struct sss_certmap_ctx *ctx,\n                      struct ldap_mapping_rule *parsed_mapping_rule,\n                      struct sss_cert_content *cert_content,\n                      char **filter)\n{\n    struct ldap_mapping_rule_comp *comp;\n    char *result = NULL;\n    char *expanded = NULL;\n    int ret;\n    result = talloc_strdup(ctx, \"\");\n    if (result == NULL) {\n        return ENOMEM;\n    }\n    for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) {\n        if (comp->type == comp_string) {\n            result = talloc_strdup_append(result, comp->val);\n        } else if (comp->type == comp_template) {\n            ret = expand_template(ctx, comp->parsed_template, cert_content,\n                                  &expanded);\n            if (ret != 0) {\n                CM_DEBUG(ctx, \"Failed to expanded template.\");\n                goto done;\n            }\n            result = talloc_strdup_append(result, expanded);\n            talloc_free(expanded);\n            expanded = NULL;\n            if (result == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else {\n            ret = EINVAL;\n            CM_DEBUG(ctx, \"Unsupported component type.\");\n            goto done;\n        }\n    }\n    ret = 0;\ndone:\n    talloc_free(expanded);\n    if (ret == 0) {\n        *filter = result;\n    } else {\n        talloc_free(result);\n    }\n    return ret;\n}", "target": 1}
{"code": "SHA256_Pad(struct SHA256_CTX * ctx)\n{\n  unsigned char len[8];\n  uint32_t r, plen;\n  be32enc_vect(len, ctx->count, 8);\n  r = (ctx->count[1] >> 3) & 0x3f;\n  plen = (r < 56) ? (56 - r) : (120 - r);\n  scrypt_SHA256_Update(ctx, PAD, (size_t)plen);\n  scrypt_SHA256_Update(ctx, len, 8);\n}", "target": 1}
{"code": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}", "target": 1}
{"code": "static inline long div_long_long_rem_signed(const long long dividend,\n\t\t\t\t\t    const long divisor, long *remainder)\n{\n\tlong res;\n\tif (unlikely(dividend < 0)) {\n\t\tres = -div_long_long_rem(-dividend, divisor, remainder);\n\t\t*remainder = -(*remainder);\n\t} else\n\t\tres = div_long_long_rem(dividend, divisor, remainder);\n\treturn res;\n}", "target": 1}
{"code": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\tif (S_ISDIR(inode->i_mode)) {\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (inode_capable(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (inode_capable(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\treturn -EACCES;\n}", "target": 1}
{"code": "static inline void switch_to_bitmap(unsigned long tifp)\n{\n\tif (tifp & _TIF_IO_BITMAP)\n\t\ttss_invalidate_io_bitmap(this_cpu_ptr(&cpu_tss_rw));\n}", "target": 1}
{"code": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n    m_messages.push_back(temp);\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n    emit newLogMessage(temp);\n}", "target": 1}
{"code": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n    }\n    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n    buf4--;\n    while (len >= 32) {\n        DOBIG32;\n        len -= 32;\n    }\n    while (len >= 4) {\n        DOBIG4;\n        len -= 4;\n    }\n    buf4++;\n    buf = (const unsigned char FAR *)buf4;\n    if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}", "target": 1}
{"code": "static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tif (fault_in_pages_writeable(iov->iov_base, this_len))\n\t\t\tbreak;\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "setup_arch (char **cmdline_p)\n{\n\tunw_init();\n\tia64_patch_vtop((u64) __start___vtop_patchlist, (u64) __end___vtop_patchlist);\n\t*cmdline_p = __va(ia64_boot_param->command_line);\n\tstrlcpy(boot_command_line, *cmdline_p, COMMAND_LINE_SIZE);\n\tefi_init();\n\tio_port_init();\n#ifdef CONFIG_IA64_GENERIC\n\tmachvec_init_from_cmdline(*cmdline_p);\n#endif\n\tparse_early_param();\n\tif (early_console_setup(*cmdline_p) == 0)\n\t\tmark_bsp_online();\n#ifdef CONFIG_ACPI\n\tacpi_table_init();\n# ifdef CONFIG_ACPI_NUMA\n\tacpi_numa_init();\n\tper_cpu_scan_finalize((cpus_weight(early_cpu_possible_map) == 0 ?\n\t\t32 : cpus_weight(early_cpu_possible_map)), additional_cpus);\n# endif\n#else\n# ifdef CONFIG_SMP\n\tsmp_build_cpu_map();\t\n# endif\n#endif \n\tfind_memory();\n\tia64_sal_init(__va(efi.sal_systab));\n#ifdef CONFIG_ITANIUM\n\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n#else\n\t{\n\t\tu64 num_phys_stacked;\n\t\tif (ia64_pal_rse_info(&num_phys_stacked, 0) == 0 && num_phys_stacked > 96)\n\t\t\tia64_patch_rse((u64) __start___rse_patchlist, (u64) __end___rse_patchlist);\n\t}\n#endif\n#ifdef CONFIG_SMP\n\tcpu_physical_id(0) = hard_smp_processor_id();\n#endif\n\tcpu_init();\t\n\tmmu_context_init();\t\n\tcheck_sal_cache_flush();\n#ifdef CONFIG_ACPI\n\tacpi_boot_init();\n#endif\n#ifdef CONFIG_VT\n\tif (!conswitchp) {\n# if defined(CONFIG_DUMMY_CONSOLE)\n\t\tconswitchp = &dummy_con;\n# endif\n# if defined(CONFIG_VGA_CONSOLE)\n\t\tif (efi_mem_type(0xA0000) != EFI_CONVENTIONAL_MEMORY)\n\t\t\tconswitchp = &vga_con;\n# endif\n\t}\n#endif\n\tif (!nomca)\n\t\tia64_mca_init();\n\tplatform_setup(cmdline_p);\n\tpaging_init();\n}", "target": 0}
{"code": "chdlc_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p)\n{\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\tif (caplen < CHDLC_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|chdlc]\"));\n\t\treturn (caplen);\n\t}\n        return (chdlc_print(ndo, p,length));\n}", "target": 1}
{"code": "suffix_requires_dir_check (char const *end)\n{\n  while (ISSLASH (*end))\n    {\n      do\n        end++;\n      while (ISSLASH (*end));\n      switch (*end++)\n        {\n        default: return false;  \n        case '\\0': return true; \n        case '.': break;        \n        }\n      if (!*end || (*end == '.' && (!end[1] || ISSLASH (end[1]))))\n        return true;\n    }\n  return false;\n}", "target": 0}
{"code": "ikev1_nonce_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t  const struct isakmp_gen *ext,\n\t\t  u_int item_len _U_,\n\t\t  const u_char *ep,\n\t\t  uint32_t phase _U_, uint32_t doi _U_,\n\t\t  uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" n len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t} else if (1 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!ike_show_somedata(ndo, (const u_char *)(const uint8_t *)(ext + 1), ep))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_NONCE)));\n\treturn NULL;\n}", "target": 1}
{"code": "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\tlockdep_assert_held(&cfs_b->lock);\n\tif (cfs_b->period_active)\n\t\treturn;\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}", "target": 1}
{"code": "    ThreadState* thread_state() const { return thread_state_; }", "target": 0}
{"code": "int LuaSettings::l_write(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\tif (!o->m_write_allowed) {\n\t\tthrow LuaError(\"Settings: writing \" + o->m_filename +\n\t\t\t\t\" not allowed with mod security on.\");\n\t}\n\tbool success = o->m_settings->updateConfigFile(o->m_filename.c_str());\n\tlua_pushboolean(L, success);\n\treturn 1;\n}", "target": 0}
{"code": "rfbReleaseClientIterator(rfbClientIteratorPtr iterator)\n{\n  if(iterator->next) rfbDecrClientRef(iterator->next);\n  free(iterator);\n}", "target": 1}
{"code": "static int is_integer(char *string)\n{\n  if (isdigit(string[0]) || string[0] == '-' || string[0] == '+') {\n    while (*++string && isdigit(*string))\n      ;                                           \n    if (!*string)\n      return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictMaxPoolGrad(const OpContext& op_context,\n                                                NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;\n  } else if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy);\n  } else {\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy * 2);\n  }\n  node_costs->num_compute_ops = ops;\n  const int64_t input0_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  const int64_t input2_size =\n      CalculateTensorSize(op_info.inputs(2), &found_unknown_shapes);\n  node_costs->num_input_bytes_accessed = {input0_size, 0, input2_size};\n  const int64_t output_size =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\tdelete[] audioDriverName;\n\tdelete listener;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_host)\n{\n\tphp_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_HOST);\n}", "target": 0}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb,\n\t\t\t\t       int rw, char __user *buf,\n\t\t\t\t       unsigned long *nr_segs,\n\t\t\t\t       size_t len,\n\t\t\t\t       struct iovec *iovec)\n{\n\tif (unlikely(!access_ok(!rw, buf, len)))\n\t\treturn -EFAULT;\n\tiovec->iov_base = buf;\n\tiovec->iov_len = len;\n\t*nr_segs = 1;\n\treturn 0;\n}", "target": 1}
{"code": "void gtkui_conf_read(void) {\n   FILE *fd;\n   const char *path;\n   char line[100], name[30];\n   short value;\n#ifdef OS_WINDOWS\n   path = ec_win_get_user_dir();\n#else\n   path = g_get_tmp_dir();\n#endif\n   filename = g_build_filename(path, \".ettercap_gtk\", NULL);\n   DEBUG_MSG(\"gtkui_conf_read: %s\", filename);\n   fd = fopen(filename, \"r\");\n   if(!fd) \n      return;\n   while(fgets(line, 100, fd)) {\n      sscanf(line, \"%s = %hd\", name, &value);\n      gtkui_conf_set(name, value);\n   }\n   fclose(fd);\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf)\n{\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\tsctp_addip_param_t\t*asconf_param;\n\tstruct sctp_chunk\t*asconf_ack;\n\t__be16\terr_code;\n\tint\tlength = 0;\n\tint\tchunk_len;\n\t__u32\tserial;\n\tint\tall_param_pass = 1;\n\tchunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n\thdr = (sctp_addiphdr_t *)asconf->skb->data;\n\tserial = ntohl(hdr->serial);\n\tlength = sizeof(sctp_addiphdr_t);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tchunk_len -= length;\n\tlength = ntohs(addr_param->p.length);\n\tasconf_param = (void *)addr_param + length;\n\tchunk_len -= length;\n\tasconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4);\n\tif (!asconf_ack)\n\t\tgoto done;\n\twhile (chunk_len > 0) {\n\t\terr_code = sctp_process_asconf_param(asoc, asconf,\n\t\t\t\t\t\t     asconf_param);\n\t\tif (SCTP_ERROR_NO_ERROR != err_code)\n\t\t\tall_param_pass = 0;\n\t\tif (!all_param_pass)\n\t\t\tsctp_add_asconf_response(asconf_ack,\n\t\t\t\t\t\t asconf_param->crr_id, err_code,\n\t\t\t\t\t\t asconf_param);\n\t\tif (SCTP_ERROR_RSRC_LOW == err_code)\n\t\t\tgoto done;\n\t\tlength = ntohs(asconf_param->param_hdr.length);\n\t\tasconf_param = (void *)asconf_param + length;\n\t\tchunk_len -= length;\n\t}\ndone:\n\tasoc->peer.addip_serial++;\n\tif (asconf_ack) {\n\t\tsctp_chunk_hold(asconf_ack);\n\t\tlist_add_tail(&asconf_ack->transmitted_list,\n\t\t\t      &asoc->asconf_ack_list);\n\t}\n\treturn asconf_ack;\n}", "target": 1}
{"code": "static const EVP_MD *tpm_algorithm_to_openssl_digest(TPMI_ALG_HASH algorithm) {\n    switch(algorithm) {\n    case TPM_ALG_SHA1:\n        return EVP_sha1();\n    case ALG_SHA256_VALUE:\n        return EVP_sha256();\n    case TPM_ALG_SHA384:\n        return EVP_sha384();\n    case TPM_ALG_SHA512:\n        return EVP_sha512();\n    default:\n        return NULL;\n    }\n}", "target": 0}
{"code": "u64 gf_isom_get_sample_dts(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu64 dts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tif (!sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts) != GF_OK) return 0;\n\treturn dts;\n}", "target": 0}
{"code": "OE_INLINE void _handle_oret(\n    oe_sgx_td_t* td,\n    uint16_t func,\n    uint16_t result,\n    uint64_t arg)\n{\n    oe_callsite_t* callsite = td->callsites;\n    if (!callsite)\n        return;\n    td->oret_func = func;\n    td->oret_result = result;\n    td->oret_arg = arg;\n    asm volatile(\"pushq %[rflags] \\n\\t\" \n                 \"popfq \\n\\t\"\n                 \"fldcw %[fcw] \\n\\t\"     \n                 \"ldmxcsr %[mxcsr] \\n\\t\" \n                 : [mxcsr] \"=m\"(callsite->mxcsr),\n                   [fcw] \"=m\"(callsite->fcw),\n                   [rflags] \"=m\"(callsite->rflags)\n                 :\n                 : \"cc\");\n    oe_longjmp(&callsite->jmpbuf, 1);\n}", "target": 1}
{"code": "static int userfaultfd_release(struct inode *inode, struct file *file)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct userfaultfd_wake_range range = { .len = 0, };\n\tunsigned long new_flags;\n\tWRITE_ONCE(ctx->released, true);\n\tif (!mmget_not_zero(mm))\n\t\tgoto wakeup;\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto skip_mm;\n\tprev = NULL;\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tcond_resched();\n\t\tBUG_ON(!!vma->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\t\tif (vma->vm_userfaultfd_ctx.ctx != ctx) {\n\t\t\tprev = vma;\n\t\t\tcontinue;\n\t\t}\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,\n\t\t\t\t new_flags, vma->anon_vma,\n\t\t\t\t vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev)\n\t\t\tvma = prev;\n\t\telse\n\t\t\tprev = vma;\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t}\nskip_mm:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nwakeup:\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL, &range);\n\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, &range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\twake_up_all(&ctx->event_wqh);\n\twake_up_poll(&ctx->fd_wqh, EPOLLHUP);\n\tuserfaultfd_ctx_put(ctx);\n\treturn 0;\n}", "target": 0}
{"code": "void fmtutil_macbitmap_read_pixmap_only_fields(deark *c, dbuf *f, struct fmtutil_macbitmap_info *bi,\n\ti64 pos)\n{\n\ti64 pixmap_version;\n\ti64 pack_size;\n\ti64 plane_bytes;\n\ti64 n;\n\tde_dbg(c, \"additional PixMap header fields, at %d\", (int)pos);\n\tde_dbg_indent(c, 1);\n\tpixmap_version = dbuf_getu16be(f, pos+0);\n\tde_dbg(c, \"pixmap version: %d\", (int)pixmap_version);\n\tbi->packing_type = dbuf_getu16be(f, pos+2);\n\tde_dbg(c, \"packing type: %d\", (int)bi->packing_type);\n\tpack_size = dbuf_getu32be(f, pos+4);\n\tde_dbg(c, \"pixel data length: %d\", (int)pack_size);\n\tbi->hdpi = pict_read_fixed(f, pos+8);\n\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n\tn = dbuf_getu32be(f, pos+32);\n\tde_dbg(c, \"pmReserved: 0x%08x\", (unsigned int)n);\n\tde_dbg_indent(c, -1);\n}", "target": 1}
{"code": "void pdo_stmt_init(TSRMLS_D)\n{\n\tzend_class_entry ce;\n\tINIT_CLASS_ENTRY(ce, \"PDOStatement\", pdo_dbstmt_functions);\n\tpdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tpdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;\n\tpdo_dbstmt_ce->create_object = pdo_dbstmt_new;\n\tzend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);\n\tzend_declare_property_null(pdo_dbstmt_ce, \"queryString\", sizeof(\"queryString\")-1, ZEND_ACC_PUBLIC TSRMLS_CC);\n\tmemcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));\n\tpdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;\n\tpdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;\n\tpdo_dbstmt_object_handlers.get_method = dbstmt_method_get;\n\tpdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;\n\tpdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;\n\tINIT_CLASS_ENTRY(ce, \"PDORow\", pdo_row_functions);\n\tpdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; \n\tpdo_row_ce->create_object = pdo_row_new;\n\tpdo_row_ce->serialize = pdo_row_serialize;\n\tpdo_row_ce->unserialize = zend_class_unserialize_deny;", "target": 0}
{"code": "\t~Chunk()\n\t{\n\t\tif (ownsMemory)\n\t\t\t::operator delete(buffer);\n\t\tbuffer = NULL;\n\t}", "target": 0}
{"code": "int BUFFER_append_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)\n{\n    int result;\n    if (handle == NULL || source == NULL || size == 0)\n    {\n        LogError(\"BUFFER_append_build failed invalid parameter handle: %p, source: %p, size: %lu\", handle, source, (unsigned long)size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        if (handle->buffer == NULL)\n        {\n            if (BUFFER_safemalloc(handle, size) != 0 || handle->buffer == NULL)\n            {\n                LogError(\"Failure with BUFFER_safemalloc\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                (void)memcpy(handle->buffer, source, size);\n                result = 0;\n            }\n        }\n        else\n        {\n            unsigned char* temp = (unsigned char*)realloc(handle->buffer, handle->size + size);\n            if (temp == NULL)\n            {\n                LogError(\"Failure reallocating temporary buffer\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                handle->buffer = temp;\n                (void)memcpy(&handle->buffer[handle->size], source, size);\n                handle->size += size;\n                result = 0;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static TEE_Result do_allocate_publickey(struct ecc_public_key *key,\n\t\t\t\t\tuint32_t type __unused,\n\t\t\t\t\tsize_t size_bits)\n{\n\tECC_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tECC_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static void sco_sock_timeout(struct work_struct *work)\n{\n\tstruct sco_conn *conn = container_of(work, struct sco_conn,\n\t\t\t\t\t     timeout_work.work);\n\tstruct sock *sk;\n\tsco_conn_lock(conn);\n\tsk = conn->sk;\n\tif (sk)\n\t\tsock_hold(sk);\n\tsco_conn_unlock(conn);\n\tif (!sk)\n\t\treturn;\n\tBT_DBG(\"sock %p state %d\", sk, sk->sk_state);\n\tlock_sock(sk);\n\tsk->sk_err = ETIMEDOUT;\n\tsk->sk_state_change(sk);\n\trelease_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "static void pdfobj_flag(struct pdf_struct *pdf, struct pdf_obj *obj, enum pdf_flag flag)\n{\n    const char *s= \"\";\n    pdf->flags |= 1 << flag;\n    if (!cli_debug_flag)\n\treturn;\n    switch (flag) {\n\tcase UNTERMINATED_OBJ_DICT:\n\t    s = \"dictionary not terminated\";\n\t    break;\n\tcase ESCAPED_COMMON_PDFNAME:\n\t    s = \"escaped common pdfname\";\n\t    break;\n\tcase BAD_STREAM_FILTERS:\n\t    s = \"duplicate stream filters\";\n\t    break;\n\tcase BAD_PDF_VERSION:\n\t    s = \"bad pdf version\";\n\t    break;\n\tcase BAD_PDF_HEADERPOS:\n\t    s = \"bad pdf header position\";\n\t    break;\n\tcase BAD_PDF_TRAILER:\n\t    s = \"bad pdf trailer\";\n\t    break;\n\tcase BAD_PDF_TOOMANYOBJS:\n\t    s = \"too many pdf objs\";\n\t    break;\n\tcase BAD_FLATE:\n\t    s = \"bad deflate stream\";\n\t    break;\n\tcase BAD_FLATESTART:\n\t    s = \"bad deflate stream start\";\n\t    break;\n\tcase BAD_STREAMSTART:\n\t    s = \"bad stream start\";\n\t    break;\n\tcase UNKNOWN_FILTER:\n\t    s = \"unknown filter used\";\n\t    break;\n\tcase BAD_ASCIIDECODE:\n\t    s = \"bad ASCII decode\";\n\t    break;\n\tcase HEX_JAVASCRIPT:\n\t    s = \"hex javascript\";\n\t    break;\n\tcase BAD_INDOBJ:\n\t    s = \"referencing nonexistent obj\";\n\t    break;\n\tcase HAS_OPENACTION:\n\t    s = \"has /OpenAction\";\n\t    break;\n\tcase HAS_LAUNCHACTION:\n\t    s = \"has /LaunchAction\";\n\t    break;\n\tcase BAD_STREAMLEN:\n\t    s = \"bad /Length, too small\";\n\t    break;\n\tcase ENCRYPTED_PDF:\n\t    s = \"PDF is encrypted\";\n\t    break;\n\tcase LINEARIZED_PDF:\n\t    s = \"linearized PDF\";\n\t    break;\n\tcase MANY_FILTERS:\n\t    s = \"more than 2 filters per obj\";\n\t    break;\n\tcase DECRYPTABLE_PDF:\n\t    s = \"decryptable PDF\";\n\t    break;\n    }\n    cli_dbgmsg(\"cli_pdf: %s flagged in object %u %u\\n\", s, obj->id>>8, obj->id&0xff);\n}", "target": 0}
{"code": "static void handle_get_publish(struct http_conn *conn,\n\t\t\t       const struct http_msg *msg,\n\t\t\t       struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\tinfo(\"handle get publish\\n\");\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"publish: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"handle get publish (content=%s)\\n\", ie->content.publish);\n\tif (ie->content.publish) {\n\t\thttp_creply(conn, 200, \"OK\",\n\t\t\t    \"application/json\", \"%s\", ie->content.publish);\n\t}\n\telse {\n\t\thttp_ereply(conn, 404, \"Not Yet\");\n\t}\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "GlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face, bool(face_options & gr_face_dumbRendering))),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),\n  _num_attrs(_glyphs ? _glyph_loader->num_attrs() : 0),\n  _upem(_glyphs ? _glyph_loader->units_per_em() : 0)\n{\n    if ((face_options & gr_face_preloadGlyphs) && _glyph_loader && _glyphs)\n    {\n        int numsubs = 0;\n        GlyphFace * const glyphs = new GlyphFace [_num_glyphs];\n        if (!glyphs)\n            return;\n        _glyphs[0] = _glyph_loader->read_glyph(0, glyphs[0], &numsubs);\n        const GlyphFace * loaded = _glyphs[0];\n        for (uint16 gid = 1; loaded && gid != _num_glyphs; ++gid)\n            _glyphs[gid] = loaded = _glyph_loader->read_glyph(gid, glyphs[gid], &numsubs);\n        if (!loaded)\n        {\n            _glyphs[0] = 0;\n            delete [] glyphs;\n        }\n        else if (numsubs > 0 && _boxes)\n        {\n            GlyphBox * boxes = (GlyphBox *)gralloc<char>(_num_glyphs * sizeof(GlyphBox) + numsubs * 8 * sizeof(float));\n            GlyphBox * currbox = boxes;\n            for (uint16 gid = 0; currbox && gid != _num_glyphs; ++gid)\n            {\n                _boxes[gid] = currbox;\n                currbox = _glyph_loader->read_box(gid, currbox, *_glyphs[gid]);\n            }\n            if (!currbox)\n            {\n                free(boxes);\n                _boxes[0] = 0;\n            }\n        }\n        delete _glyph_loader;\n        _glyph_loader = 0;\n    }\n    if (_glyphs && glyph(0) == 0)\n    {\n        free(_glyphs);\n        _glyphs = 0;\n        if (_boxes)\n        {\n            free(_boxes);\n            _boxes = 0;\n        }\n        _num_glyphs = _num_attrs = _upem = 0;\n    }\n}", "target": 1}
{"code": "crm_parse_remote_buffer(char **msg_buf)\n{\n    char *buf = NULL;\n    char *start = NULL;\n    char *end = NULL;\n    xmlNode *xml = NULL;\n    if (*msg_buf == NULL) {\n        return NULL;\n    }\n    buf = *msg_buf;\n    *msg_buf = NULL;\n    start = buf;\n    end = strstr(start, REMOTE_MSG_TERMINATOR);\n    while (!xml && end) {\n        end[0] = '\\0';\n        end += strlen(REMOTE_MSG_TERMINATOR);\n        xml = string2xml(start);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", start);\n        }\n        start = end;\n        end = strstr(start, REMOTE_MSG_TERMINATOR);\n    }\n    if (xml && start) {\n        *msg_buf = strdup(start);\n        free(buf);\n    } else if (!xml) {\n        *msg_buf = buf;\n    }\n    return xml;\n}", "target": 0}
{"code": "pdf_t *pdf_new(const char *name)\n{\n    const char *n;\n    pdf_t      *pdf;\n    pdf = calloc(1, sizeof(pdf_t));\n    if (name)\n    {\n        if ((n = strrchr(name, '/')))\n          ++n;\n        else\n          n = name;\n        pdf->name = malloc(strlen(n) + 1);\n        strcpy(pdf->name, n);\n    }\n    else \n    {\n        pdf->name = malloc(strlen(\"Unknown\") + 1);\n        strcpy(pdf->name, \"Unknown\");\n    }\n    return pdf;\n}", "target": 1}
{"code": "static void urlParsePostBody(struct URL *url,\n                             const struct HttpConnection *http,\n                             const char *buf, int len) {\n  struct HashMap contentType;\n  initHashMap(&contentType, urlDestroyHashMapEntry, NULL);\n  const char *ctHeader     = getFromHashMap(&http->header, \"content-type\");\n  urlParseHeaderLine(&contentType, ctHeader, ctHeader ? strlen(ctHeader) : 0);\n  if (getRefFromHashMap(&contentType, \"application/x-www-form-urlencoded\")) {\n    urlParseQueryString(&url->args, buf, len);\n  } else if (getRefFromHashMap(&contentType, \"multipart/form-data\")) {\n    const char *boundary   = getFromHashMap(&contentType, \"boundary\");\n    if (boundary && *boundary) {\n      const char *lastPart = NULL;\n      for (const char *part = buf; len > 0; ) {\n        const char *ptr;\n        if ((part == buf && (ptr = urlMemstr(part, len, \"--\")) != NULL) ||\n            (ptr = urlMemstr(part, len, \"\\r\\n--\")) != NULL) {\n          len             -= ptr - part + (part == buf ? 2 : 4);\n          part             = ptr + (part == buf ? 2 : 4);\n          if (!urlMemcmp(part, len, boundary)) {\n            int i          = strlen(boundary);\n            len           -= i;\n            part          += i;\n            if (!urlMemcmp(part, len, \"\\r\\n\")) {\n              len         -= 2;\n              part        += 2;\n              if (lastPart) {\n                urlParsePart(url, lastPart, ptr - lastPart);\n              } else {\n                if (ptr != buf) {\n                  info(\"[http] Ignoring prologue before \\\"multipart/form-data\\\"!\");\n                }\n              }\n              lastPart     = part;\n            } else if (!urlMemcmp(part, len, \"--\\r\\n\")) {\n              len         -= 4;\n              part        += 4;\n              urlParsePart(url, lastPart, ptr - lastPart);\n              lastPart     = NULL;\n              if (len > 0) {\n                info(\"[http] Ignoring epilogue past end of \\\"multipart/\"\n\t\t\t\t     \"form-data\\\"!\");\n              }\n            }\n          }\n        }\n        else {\n          warn (\"[http] Ignorning broken multipart/form-data\");\n          break;\n        }\n      }\n      if (lastPart) {\n        warn(\"[http] Missing final \\\"boundary\\\" for \\\"multipart/form-data\\\"!\");\n      }\n    } else {\n      warn(\"[http] Missing \\\"boundary\\\" information for \\\"multipart/form-data\\\"!\");\n    }\n  }\n  destroyHashMap(&contentType);\n}", "target": 0}
{"code": "static int extractRDNSequence(struct ndpi_packet_struct *packet,\n\t\t\t      u_int offset, char *buffer, u_int buffer_len,\n\t\t\t      char *rdnSeqBuf, u_int *rdnSeqBuf_offset,\n\t\t\t      u_int rdnSeqBuf_len,\n\t\t\t      const char *label) {\n  u_int8_t str_len = packet->payload[offset+4], is_printable = 1;\n  char *str;\n  u_int len, j;\n  if (*rdnSeqBuf_offset >= rdnSeqBuf_len) {\n#ifdef DEBUG_TLS\n    printf(\"[TLS] %s() [buffer capacity reached][%u]\\n\",\n           __FUNCTION__, rdnSeqBuf_len);\n#endif\n    return -1;\n  }\n  if((offset+4+str_len) >= packet->payload_packet_len)\n    return(-1);\n  str = (char*)&packet->payload[offset+5];\n  len = (u_int)ndpi_min(str_len, buffer_len-1);\n  strncpy(buffer, str, len);\n  buffer[len] = '\\0';\n  for(j = 0; j < len; j++) {\n    if(!ndpi_isprint(buffer[j])) {\n      is_printable = 0;\n      break;\n    }\n  }\n  if(is_printable) {\n    int rc = snprintf(&rdnSeqBuf[*rdnSeqBuf_offset],\n\t\t      rdnSeqBuf_len-(*rdnSeqBuf_offset),\n\t\t      \"%s%s=%s\", (*rdnSeqBuf_offset > 0) ? \", \" : \"\",\n\t\t      label, buffer);\n    if(rc > 0)\n      (*rdnSeqBuf_offset) += rc;\n  }\n  return(is_printable);\n}", "target": 0}
{"code": "__acquires(&fc->lock)\n{\n\tstruct fuse_inode *fi = get_fuse_inode(req->inode);\n\tloff_t size = i_size_read(req->inode);\n\tstruct fuse_write_in *inarg = &req->misc.write.in;\n\tif (!fc->connected)\n\t\tgoto out_free;\n\tif (inarg->offset + PAGE_CACHE_SIZE <= size) {\n\t\tinarg->size = PAGE_CACHE_SIZE;\n\t} else if (inarg->offset < size) {\n\t\tinarg->size = size & (PAGE_CACHE_SIZE - 1);\n\t} else {\n\t\tgoto out_free;\n\t}\n\treq->in.args[1].size = inarg->size;\n\tfi->writectr++;\n\tfuse_request_send_background_locked(fc, req);\n\treturn;\n out_free:\n\tfuse_writepage_finish(fc, req);\n\tspin_unlock(&fc->lock);\n\tfuse_writepage_free(fc, req);\n\tfuse_put_request(fc, req);\n\tspin_lock(&fc->lock);\n}", "target": 0}
{"code": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}", "target": 1}
{"code": "modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_modify_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_modify_principal((void *)handle, &arg->rec,\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "    unsigned int readBits(int n)\n    {\n        unsigned int bit, bits;\n        if (n < 0) {\n            return -1;\n        }\n        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n            return readBit();\n        }\n        bit = readBit();\n        if (bit == (unsigned int)-1) {\n            return -1;\n        }\n        bit = bit << (n - 1);\n        bits = readBits(n - 1);\n        if (bits == (unsigned int)-1) {\n            return -1;\n        }\n        return bit | bits;\n    }", "target": 0}
{"code": "      static double mp_normp(_cimg_math_parser& mp) {\n        const unsigned int i_end = (unsigned int)mp.opcode[2];\n        if (i_end==4) return cimg::abs(_mp_arg(3));\n        const double p = (double)mp.opcode[3];\n        double res = 0;\n        for (unsigned int i = 4; i<i_end; ++i)\n          res+=std::pow(cimg::abs(_mp_arg(i)),p);\n        res = std::pow(res,1/p);\n        return res>0?res:0.0;", "target": 0}
{"code": "static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s64 imm_min = S32_MIN, imm_max = S32_MAX;\n\ts64 imm = insn->imm;\n\tif (curr < pos && curr + imm + 1 > pos)\n\t\timm += delta;\n\telse if (curr > pos + delta && curr + imm + 1 <= pos + delta)\n\t\timm -= delta;\n\tif (imm < imm_min || imm > imm_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->imm = imm;\n\treturn 0;\n}", "target": 0}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n    mpz_as_bytes(&self->mpz, big_endian, len, buf);\n}", "target": 1}
{"code": "static void unix_dgram_peer_wake_disconnect(struct sock *sk,\n\t\t\t\t\t    struct sock *other)\n{\n\tstruct unix_sock *u, *u_other;\n\tu = unix_sk(sk);\n\tu_other = unix_sk(other);\n\tspin_lock(&u_other->peer_wait.lock);\n\tif (u->peer_wake.private == other) {\n\t\t__remove_wait_queue(&u_other->peer_wait, &u->peer_wake);\n\t\tu->peer_wake.private = NULL;\n\t}\n\tspin_unlock(&u_other->peer_wait.lock);\n}", "target": 0}
{"code": "crm_remote_tcp_connect(const char *host, int port)\n{\n    struct addrinfo *res;\n    struct addrinfo *rp;\n    struct addrinfo hints;\n    const char *server = host;\n    int ret_ga;\n    int sock;\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;    \n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_CANONNAME;\n    crm_debug(\"Looking up %s\", server);\n    ret_ga = getaddrinfo(server, NULL, &hints, &res);\n    if (ret_ga) {\n        crm_err(\"getaddrinfo: %s\", gai_strerror(ret_ga));\n        return -1;\n    }\n    if (!res || !res->ai_addr) {\n        crm_err(\"getaddrinfo failed\");\n        return -1;\n    }\n    for (rp = res; rp != NULL; rp = rp->ai_next) {\n        struct sockaddr *addr = rp->ai_addr;\n        int flag = 0;\n        if (!addr) {\n            continue;\n        }\n        if (rp->ai_canonname) {\n            server = res->ai_canonname;\n        }\n        crm_debug(\"Got address %s for %s\", server, host);\n        sock = socket(rp->ai_family, SOCK_STREAM, IPPROTO_TCP);\n        if (sock == -1) {\n            crm_err(\"Socket creation failed for remote client connection.\");\n            continue;\n        }\n        if (addr->sa_family == AF_INET6) {\n            struct sockaddr_in6 *addr_in = (struct sockaddr_in6 *) addr;\n            addr_in->sin6_port = htons(port);\n        } else {\n            struct sockaddr_in *addr_in = (struct sockaddr_in *) addr;\n            addr_in->sin_port = htons(port);\n            crm_info(\"Attempting to connect to remote server at %s:%d\", inet_ntoa(addr_in->sin_addr), port);\n        }\n        if (connect(sock, rp->ai_addr, rp->ai_addrlen) == 0) {\n            if ((flag = fcntl(sock, F_GETFL)) >= 0) {\n                if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) < 0) {\n                    crm_err( \"fcntl() write failed\");\n                    close(sock);\n                    sock = -1;\n                    continue;\n                }\n            }\n            break;                  \n        }\n        close(sock);\n        sock = -1;\n    }\n    freeaddrinfo(res);\n    return sock;\n}", "target": 0}
{"code": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\twhile (ptr) {\n\t\tret = copy_to_user(param, ptr, sizeof(*ptr));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tptr = ptr->next;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "xmlCopyEnumeration(xmlEnumerationPtr cur) {\n    xmlEnumerationPtr ret;\n    if (cur == NULL) return(NULL);\n    ret = xmlCreateEnumeration((xmlChar *) cur->name);\n    if (ret == NULL) return(NULL);\n    if (cur->next != NULL) ret->next = xmlCopyEnumeration(cur->next);\n    else ret->next = NULL;\n    return(ret);\n}", "target": 0}
{"code": "xfs_attr_calc_size(\n\tstruct xfs_inode \t*ip,\n\tint\t\t\tnamelen,\n\tint\t\t\tvaluelen,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount \t*mp = ip->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\tsize = xfs_attr_leaf_newentsize(namelen, valuelen,\n\t\t\t\t\tmp->m_sb.sb_blocksize, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (mp->m_sb.sb_blocksize >> 1)) {\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\tuint\tdblocks = XFS_B_TO_FSB(mp, valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\treturn nblks;\n}", "target": 1}
{"code": "cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n    return TRUE;\n}", "target": 1}
{"code": "  absl::Status IsSupported(const TfLiteContext* context,\n                           const TfLiteNode* tflite_node,\n                           const TfLiteRegistration* registration) final {\n    RETURN_IF_ERROR(CheckMaxSupportedOpVersion(registration, 3));\n    if (tflite_node->inputs->size != 2) {\n      return absl::UnimplementedError(\"MUL requires two input tensors.\");\n    }\n    auto input0 = tflite::GetInput(context, tflite_node, 0);\n    auto input1 = tflite::GetInput(context, tflite_node, 1);\n    if (input0 == nullptr || input1 == nullptr) {\n      return absl::InvalidArgumentError(\"At least one input tensor is null\");\n    }\n    if (input0->dims->size == input1->dims->size) {\n      bool first_has_smaller_dim = false;\n      bool second_has_smaller_dim = false;\n      for (int i = 0; i < input0->dims->size; ++i) {\n        if (input0->dims->data[i] < input1->dims->data[i]) {\n          first_has_smaller_dim = true;\n        }\n        if (input1->dims->data[i] < input0->dims->data[i]) {\n          second_has_smaller_dim = true;\n        }\n      }\n      if (first_has_smaller_dim && second_has_smaller_dim) {\n        return absl::UnimplementedError(\n            \"MUL requires one tensor that not less than second in all \"\n            \"dimensions.\");\n      }\n    }\n    const TfLiteMulParams* tf_options;\n    RETURN_IF_ERROR(RetrieveBuiltinData(tflite_node, &tf_options));\n    return IsActivationSupported(tf_options->activation);\n  }", "target": 0}
{"code": "static uint32_t color_string_to_rgba(const char *p, int len)\n{\n    uint32_t ret = 0xFF000000;\n    const ColorEntry *entry;\n    char color_name[100];\n    len = FFMIN(FFMAX(len, 0), sizeof(color_name) - 1);\n    if (*p == '#') {\n        p++;\n        len--;\n        if (len == 3) {\n            ret |= (hex_char_to_number(p[2]) <<  4) |\n                   (hex_char_to_number(p[1]) << 12) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 4) {\n            ret  = (hex_char_to_number(p[3]) <<  4) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 20) |\n                   (hex_char_to_number(p[0]) << 28);\n        } else if (len == 6) {\n            ret |=  hex_char_to_number(p[5])        |\n                   (hex_char_to_number(p[4]) <<  4) |\n                   (hex_char_to_number(p[3]) <<  8) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 16) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 8) {\n            ret  =  hex_char_to_number(p[7])        |\n                   (hex_char_to_number(p[6]) <<  4) |\n                   (hex_char_to_number(p[5]) <<  8) |\n                   (hex_char_to_number(p[4]) << 12) |\n                   (hex_char_to_number(p[3]) << 16) |\n                   (hex_char_to_number(p[2]) << 20) |\n                   (hex_char_to_number(p[1]) << 24) |\n                   (hex_char_to_number(p[0]) << 28);\n        }\n    } else {\n        strncpy(color_name, p, len);\n        color_name[len] = '\\0';\n        entry = bsearch(color_name,\n                        color_table,\n                        FF_ARRAY_ELEMS(color_table),\n                        sizeof(ColorEntry),\n                        color_table_compare);\n        if (!entry)\n            return ret;\n        ret = entry->rgb_color;\n    }\n    return ret;\n}", "target": 0}
{"code": "mailimap_mailbox_data_status_free(struct mailimap_mailbox_data_status * info)\n{\n  mailimap_mailbox_free(info->st_mailbox);\n  clist_foreach(info->st_info_list, (clist_func) mailimap_status_info_free,\n\t\t NULL);\n  clist_free(info->st_info_list);\n  free(info);\n}", "target": 1}
{"code": "static void settings_changed(struct btd_adapter *adapter, uint32_t settings)\n{\n\tuint32_t changed_mask;\n\tchanged_mask = adapter->current_settings ^ settings;\n\tadapter->current_settings = settings;\n\tadapter->pending_settings &= ~changed_mask;\n\tDBG(\"Changed settings: 0x%08x\", changed_mask);\n\tDBG(\"Pending settings: 0x%08x\", adapter->pending_settings);\n\tif (changed_mask & MGMT_SETTING_POWERED) {\n\t        g_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Powered\");\n\t\tif (adapter->current_settings & MGMT_SETTING_POWERED) {\n\t\t\tadapter_start(adapter);\n\t\t} else {\n\t\t\tadapter_stop(adapter);\n\t\t\tif (powering_down) {\n\t\t\t\tadapter_remaining--;\n\t\t\t\tif (!adapter_remaining)\n\t\t\t\t\tbtd_exit();\n\t\t\t}\n\t\t}\n\t}\n\tif ((changed_mask & MGMT_SETTING_LE) &&\n\t\t\t\tbtd_adapter_get_powered(adapter) &&\n\t\t\t\t(adapter->current_settings & MGMT_SETTING_LE))\n\t\ttrigger_passive_scanning(adapter);\n\tif (changed_mask & MGMT_SETTING_DISCOVERABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discoverable\");\n\t\tstore_adapter_info(adapter);\n\t\tbtd_adv_manager_refresh(adapter->adv_manager);\n\t}\n\tif (changed_mask & MGMT_SETTING_BONDABLE) {\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Pairable\");\n\t\ttrigger_pairable_timeout(adapter);\n\t}\n}", "target": 1}
{"code": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}", "target": 1}
{"code": "on_response(void *data, krb5_error_code retval, otp_response response)\n{\n    struct request_state rs = *(struct request_state *)data;\n    free(data);\n    if (retval == 0 && response != otp_response_success)\n        retval = KRB5_PREAUTH_FAILED;\n    if (retval == 0)\n        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n    rs.respond(rs.arg, retval, NULL, NULL, NULL);\n}", "target": 0}
{"code": "l_strnstart(const char *tstr1, u_int tl1, const char *str2, u_int l2)\n{\n\tif (tl1 > l2)\n\t\treturn 0;\n\treturn (strncmp(tstr1, str2, tl1) == 0 ? 1 : 0);\n}", "target": 1}
{"code": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "uint64_t HeaderMapImpl::byteSize() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 1}
{"code": "Node* Graph::AddNode(NodeDef node_def, Status* status) {\n  const OpRegistrationData* op_reg_data;\n  status->Update(ops_.LookUp(node_def.op(), &op_reg_data));\n  if (!status->ok()) return nullptr;\n  DataTypeVector inputs;\n  DataTypeVector outputs;\n  status->Update(\n      InOutTypesForNode(node_def, op_reg_data->op_def, &inputs, &outputs));\n  if (!status->ok()) {\n    *status = AttachDef(*status, node_def);\n    return nullptr;\n  }\n  Node::NodeClass node_class = op_reg_data->is_function_op\n                                   ? Node::NC_FUNCTION_OP\n                                   : Node::GetNodeClassForOp(node_def.op());\n  if (op_reg_data->type_ctor != nullptr) {\n    VLOG(3) << \"AddNode: found type constructor for \" << node_def.name();\n    const auto ctor_type =\n        full_type::SpecializeType(AttrSlice(node_def), op_reg_data->op_def);\n    if (!ctor_type.ok()) {\n      *status = errors::InvalidArgument(\"type error: \",\n                                        ctor_type.status().ToString());\n      return nullptr;\n    }\n    const FullTypeDef ctor_typedef = ctor_type.ValueOrDie();\n    if (ctor_typedef.type_id() != TFT_UNSET) {\n      *(node_def.mutable_experimental_type()) = ctor_typedef;\n    }\n  } else {\n    VLOG(3) << \"AddNode: no type constructor for \" << node_def.name();\n  }\n  Node* node = AllocateNode(std::make_shared<NodeProperties>(\n                                &op_reg_data->op_def, std::move(node_def),\n                                inputs, outputs, op_reg_data->fwd_type_fn),\n                            nullptr, node_class);\n  return node;\n}", "target": 0}
{"code": "raptor_rdfxml_parse_start(raptor_parser* rdf_parser)\n{\n  raptor_uri *uri = rdf_parser->base_uri;\n  raptor_rdfxml_parser* rdf_xml_parser;\n  rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;\n  if(!uri)\n    return 1;\n  raptor_sax2_set_option(rdf_xml_parser->sax2,\n                         RAPTOR_OPTION_NORMALIZE_LANGUAGE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NORMALIZE_LANGUAGE));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_NO_NET, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_NO_FILE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_FILE));\n  raptor_sax2_set_option(rdf_xml_parser->sax2, \n                         RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES));\n  if(rdf_parser->uri_filter)\n    raptor_sax2_set_uri_filter(rdf_xml_parser->sax2, rdf_parser->uri_filter,\n                               rdf_parser->uri_filter_user_data);\n  raptor_sax2_parse_start(rdf_xml_parser->sax2, uri);\n  if(rdf_xml_parser->id_set) {\n    raptor_free_id_set(rdf_xml_parser->id_set);\n    rdf_xml_parser->id_set = NULL;\n  }\n  if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID)) {\n    rdf_xml_parser->id_set = raptor_new_id_set(rdf_parser->world);\n    if(!rdf_xml_parser->id_set)\n      return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "static size_t ssl_compute_padding_length( size_t len,\n                                          size_t granularity )\n{\n    return( ( granularity - ( len + 1 ) % granularity ) % granularity );\n}", "target": 0}
{"code": "Value sendrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 1)\n        throw runtime_error(\n            \"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n    RPCTypeCheck(params, list_of(str_type));\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(-22, \"TX decode failed\");\n    }\n    uint256 hashTx = tx.GetHash();\n    CTransaction existingTx;\n    uint256 hashBlock = 0;\n    if (GetTransaction(hashTx, existingTx, hashBlock))\n    {\n        if (hashBlock != 0)\n            throw JSONRPCError(-5, string(\"transaction already in block \")+hashBlock.GetHex());\n    }\n    else\n    {\n        CTxDB txdb(\"r\");\n        if (!tx.AcceptToMemoryPool(txdb))\n            throw JSONRPCError(-22, \"TX rejected\");\n        SyncWithWallets(tx, NULL, true);\n    }\n    RelayMessage(CInv(MSG_TX, hashTx), tx);\n    return hashTx.GetHex();\n}", "target": 1}
{"code": "SMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n{\n  if ((afi == AFI_IP6 && *safi == BGP_SAFI_VPNV4)\n      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n    {\n      zlog_warn (\"Invalid afi/safi combination (%u/%u)\", afi, *safi);\n      return 0;\n    }\n  switch (afi)\n    {\n      case AFI_IP:\n#ifdef HAVE_IPV6\n      case AFI_IP6:\n#endif\n        switch (*safi)\n          {\n            case BGP_SAFI_VPNV4:\n            case BGP_SAFI_VPNV6:\n              *safi = SAFI_MPLS_VPN;\n            case SAFI_UNICAST:\n            case SAFI_MULTICAST:\n            case SAFI_MPLS_VPN:\n              return 1;\n          }\n    }\n  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n  return 0;\n}", "target": 0}
{"code": "oftrace_node_list_destroy(struct ovs_list *nodes)\n{\n    if (nodes) {\n        struct oftrace_node *node, *next;\n        LIST_FOR_EACH_SAFE (node, next, node, nodes) {\n            ovs_list_remove(&node->node);\n            oftrace_node_destroy(node);\n        }\n    }\n}", "target": 0}
{"code": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "process_pointer_pdu(STREAM s)\n{\n\tuint16 message_type;\n\tuint16 x, y;\n\tin_uint16_le(s, message_type);\n\tin_uint8s(s, 2);\t\n\tswitch (message_type)\n\t{\n\t\tcase RDP_POINTER_MOVE:\n\t\t\tin_uint16_le(s, x);\n\t\t\tin_uint16_le(s, y);\n\t\t\tif (s_check(s))\n\t\t\t\tui_move_pointer(x, y);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_COLOR:\n\t\t\tprocess_colour_pointer_pdu(s);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_CACHED:\n\t\t\tprocess_cached_pointer_pdu(s);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_SYSTEM:\n\t\t\tprocess_system_pointer_pdu(s);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_NEW:\n\t\t\tprocess_new_pointer_pdu(s);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tunimpl(\"Pointer message 0x%x\\n\", message_type);\n\t}\n}", "target": 0}
{"code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}", "target": 0}
{"code": "std::shared_ptr<SQLiteDBInstance> getTestDBC() {\n  auto dbc = SQLiteDBManager::getUnique();\n  char* err = nullptr;\n  std::vector<std::string> queries = {\n      \"CREATE TABLE test_table (username varchar(30) primary key, age int)\",\n      \"INSERT INTO test_table VALUES (\\\"mike\\\", 23)\",\n      \"INSERT INTO test_table VALUES (\\\"matt\\\", 24)\"};\n  for (auto q : queries) {\n    sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err);\n    if (err != nullptr) {\n      throw std::domain_error(std::string(\"Cannot create testing DBC's db: \") +\n                              err);\n    }\n  }\n  return dbc;\n}", "target": 1}
{"code": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\tstruct msr_data msr;\n\tu32 ecx = svm->vcpu.arch.regs[VCPU_REGS_RCX];\n\tu64 data = (svm->vcpu.arch.regs[VCPU_REGS_RAX] & -1u)\n\t\t| ((u64)(svm->vcpu.arch.regs[VCPU_REGS_RDX] & -1u) << 32);\n\tmsr.data = data;\n\tmsr.index = ecx;\n\tmsr.host_initiated = false;\n\tsvm->next_rip = kvm_rip_read(&svm->vcpu) + 2;\n\tif (svm_set_msr(&svm->vcpu, &msr)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t} else {\n\t\ttrace_kvm_msr_write(ecx, data);\n\t\tskip_emulated_instruction(&svm->vcpu);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n                                const pj_uint8_t *start, const pj_uint8_t *max, \n                                int *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n    if (rec_counter > 10) {\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            int ptr_len = 0;\n            int dummy;\n            pj_uint16_t offset;\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n                                  &dummy, &ptr_len);\n            if (status != PJ_SUCCESS)\n                return status;\n            *parsed_len += 2;\n            *name_len += ptr_len;\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n            p += (label_len + 1);\n            *parsed_len += (label_len + 1);\n            if (*p != 0)\n                ++label_len;\n            *name_len += label_len;\n        }\n    }\n    ++p;\n    (*parsed_len)++;\n    return PJ_SUCCESS;\n}", "target": 0}
{"code": "static bool caller_may_see_dir(pid_t pid, const char *contrl, const char *cg)\n{\n\tbool answer = false;\n\tchar *c2, *task_cg;\n\tsize_t target_len, task_len;\n\tif (strcmp(cg, \"/\") == 0)\n\t\treturn true;\n\tc2 = get_pid_cgroup(pid, contrl);\n\tif (!c2)\n\t\treturn false;\n\ttask_cg = c2 + 1;\n\ttarget_len = strlen(cg);\n\ttask_len = strlen(task_cg);\n\tif (strcmp(cg, task_cg) == 0) {\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len < task_len) {\n\t\tif (strncmp(task_cg, cg, target_len) == 0 && task_cg[target_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\n\tif (target_len > task_len) {\n\t\tif (strncmp(task_cg, cg, task_len) == 0 && cg[task_len] == '/')\n\t\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfree(c2);\n\treturn answer;\n}", "target": 0}
{"code": "static void bump_cpu_timer(struct k_itimer *timer, u64 now)\n{\n\tint i;\n\tu64 delta, incr;\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}", "target": 1}
{"code": "static void rose_heartbeat_expiry(struct timer_list *t)\n{\n\tstruct sock *sk = from_timer(sk, t, sk_timer);\n\tstruct rose_sock *rose = rose_sk(sk);\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_0:\n\t\tif (sock_flag(sk, SOCK_DESTROY) ||\n\t\t    (sk->sk_state == TCP_LISTEN && sock_flag(sk, SOCK_DEAD))) {\n\t\t\tbh_unlock_sock(sk);\n\t\t\trose_destroy_socket(sk);\n\t\t\tsock_put(sk);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase ROSE_STATE_3:\n\t\tif (atomic_read(&sk->sk_rmem_alloc) < (sk->sk_rcvbuf / 2) &&\n\t\t    (rose->condition & ROSE_COND_OWN_RX_BUSY)) {\n\t\t\trose->condition &= ~ROSE_COND_OWN_RX_BUSY;\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose->vl         = rose->vr;\n\t\t\trose_write_internal(sk, ROSE_RR);\n\t\t\trose_stop_timer(sk);\t\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\trose_start_heartbeat(sk);\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "int dccp_destroy_sock(struct sock *sk)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_minisock *dmsk = dccp_msk(sk);\n\tif (sk->sk_send_head != NULL) {\n\t\tkfree_skb(sk->sk_send_head);\n\t\tsk->sk_send_head = NULL;\n\t}\n\tif (inet_csk(sk)->icsk_bind_hash != NULL)\n\t\tinet_put_port(&dccp_hashinfo, sk);\n\tkfree(dp->dccps_service_list);\n\tdp->dccps_service_list = NULL;\n\tif (dmsk->dccpms_send_ack_vector) {\n\t\tdccp_ackvec_free(dp->dccps_hc_rx_ackvec);\n\t\tdp->dccps_hc_rx_ackvec = NULL;\n\t}\n\tccid_hc_rx_delete(dp->dccps_hc_rx_ccid, sk);\n\tccid_hc_tx_delete(dp->dccps_hc_tx_ccid, sk);\n\tdp->dccps_hc_rx_ccid = dp->dccps_hc_tx_ccid = NULL;\n\tdccp_feat_clean(dmsk);\n\treturn 0;\n}", "target": 0}
{"code": "flatpak_escape_string (const char        *s,\n                       FlatpakEscapeFlags flags)\n{\n  g_autoptr(GString) res = g_string_new (\"\");\n  gboolean did_escape = FALSE;\n  while (*s)\n    {\n      gunichar c = g_utf8_get_char_validated (s, -1);\n      if (c == (gunichar)-2 || c == (gunichar)-1)\n        {\n          append_hex_escaped_character (res, (unsigned char)*s++);\n          did_escape = TRUE;\n          continue;\n        }\n      else if (should_hex_escape (c, flags))\n        {\n          append_hex_escaped_character (res, c);\n          did_escape = TRUE;\n        }\n      else if (c == '\\\\' || (!(flags & FLATPAK_ESCAPE_DO_NOT_QUOTE) && c == '\\''))\n        {\n          g_string_append_printf (res, \"\\\\%c\", (char) c);\n          did_escape = TRUE;\n        }\n      else\n        g_string_append_unichar (res, c);\n      s = g_utf8_find_next_char (s, NULL);\n    }\n  if (did_escape && !(flags & FLATPAK_ESCAPE_DO_NOT_QUOTE))\n    {\n      g_string_prepend_c (res, '\\'');\n      g_string_append_c (res, '\\'');\n    }\n  return g_string_free (g_steal_pointer (&res), FALSE);\n}", "target": 0}
{"code": "jas_matrix_t *jas_matrix_create(int numrows, int numcols)\n{\n\tjas_matrix_t *matrix;\n\tint i;\n\tsize_t size;\n\tmatrix = 0;\n\tif (numrows < 0 || numcols < 0) {\n\t\tgoto error;\n\t}\n\tif (!(matrix = jas_malloc(sizeof(jas_matrix_t)))) {\n\t\tgoto error;\n\t}\n\tmatrix->flags_ = 0;\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\tmatrix->rows_ = 0;\n\tmatrix->maxrows_ = numrows;\n\tmatrix->data_ = 0;\n\tmatrix->datasize_ = 0;\n\tif (!jas_safe_size_mul(numrows, numcols, &size)) {\n\t\tgoto error;\n\t}\n\tmatrix->datasize_ = size;\n\tif (matrix->maxrows_ > 0) {\n\t\tif (!(matrix->rows_ = jas_alloc2(matrix->maxrows_,\n\t\t  sizeof(jas_seqent_t *)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (matrix->datasize_ > 0) {\n\t\tif (!(matrix->data_ = jas_alloc2(matrix->datasize_,\n\t\t  sizeof(jas_seqent_t)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tfor (i = 0; i < numrows; ++i) {\n\t\tmatrix->rows_[i] = &matrix->data_[i * matrix->numcols_];\n\t}\n\tfor (i = 0; i < matrix->datasize_; ++i) {\n\t\tmatrix->data_[i] = 0;\n\t}\n\tmatrix->xstart_ = 0;\n\tmatrix->ystart_ = 0;\n\tmatrix->xend_ = matrix->numcols_;\n\tmatrix->yend_ = matrix->numrows_;\n\treturn matrix;\nerror:\n\tif (matrix) {\n\t\tjas_matrix_destroy(matrix);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int create_constraints(struct powercap_zone *power_zone,\n\t\t\tint nr_constraints,\n\t\t\tconst struct powercap_zone_constraint_ops *const_ops)\n{\n\tint i;\n\tint ret = 0;\n\tint count;\n\tstruct powercap_zone_constraint *pconst;\n\tif (!power_zone || !const_ops || !const_ops->get_power_limit_uw ||\n\t\t\t\t\t!const_ops->set_power_limit_uw ||\n\t\t\t\t\t!const_ops->get_time_window_us ||\n\t\t\t\t\t!const_ops->set_time_window_us)\n\t\treturn -EINVAL;\n\tcount = power_zone->zone_attr_count;\n\tfor (i = 0; i < nr_constraints; ++i) {\n\t\tpconst = &power_zone->constraints[i];\n\t\tpconst->ops = const_ops;\n\t\tpconst->id = power_zone->const_id_cnt;\n\t\tpower_zone->const_id_cnt++;\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].power_limit_attr.attr;\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].time_window_attr.attr;\n\t\tif (pconst->ops->get_name)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].name_attr.attr;\n\t\tif (pconst->ops->get_max_power_uw)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].max_power_attr.attr;\n\t\tif (pconst->ops->get_min_power_uw)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].min_power_attr.attr;\n\t\tif (pconst->ops->get_max_time_window_us)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].max_time_window_attr.attr;\n\t\tif (pconst->ops->get_min_time_window_us)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].min_time_window_attr.attr;\n\t}\n\tpower_zone->zone_attr_count = count;\n\treturn ret;\n}", "target": 0}
{"code": "void xenvif_disconnect(struct xenvif *vif)\n{\n\tstruct net_device *dev = vif->dev;\n\tif (netif_carrier_ok(dev)) {\n\t\trtnl_lock();\n\t\tnetif_carrier_off(dev); \n\t\tif (netif_running(dev))\n\t\t\txenvif_down(vif);\n\t\trtnl_unlock();\n\t\txenvif_put(vif);\n\t}\n\tatomic_dec(&vif->refcnt);\n\twait_event(vif->waiting_to_free, atomic_read(&vif->refcnt) == 0);\n\tdel_timer_sync(&vif->credit_timeout);\n\tif (vif->irq)\n\t\tunbind_from_irqhandler(vif->irq, vif);\n\tunregister_netdev(vif->dev);\n\txen_netbk_unmap_frontend_rings(vif);\n\tfree_netdev(vif->dev);\n}", "target": 1}
{"code": "static int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh = NULL;\n\tint idx = 0, s_idx;\n\ts_idx = cb->args[0];\n\trcu_read_lock();\n\tcb->seq = net->dev_base_seq + br_mdb_rehash_seq;\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_EBRIDGE) {\n\t\t\tstruct br_port_msg *bpm;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\t\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB,\n\t\t\t\t\tsizeof(*bpm), NLM_F_MULTI);\n\t\t\tif (nlh == NULL)\n\t\t\t\tbreak;\n\t\t\tbpm = nlmsg_data(nlh);\n\t\t\tmemset(bpm, 0, sizeof(*bpm));\n\t\t\tbpm->ifindex = dev->ifindex;\n\t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tif (br_rports_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tcb->args[1] = 0;\n\t\t\tnlmsg_end(skb, nlh);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\tif (nlh)\n\t\tnlmsg_end(skb, nlh);\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "SHA256_Init(struct SHA256_CTX * ctx)\n{\n  ctx->count[0] = ctx->count[1] = 0;\n  ctx->state[0] = 0x6A09E667;\n  ctx->state[1] = 0xBB67AE85;\n  ctx->state[2] = 0x3C6EF372;\n  ctx->state[3] = 0xA54FF53A;\n  ctx->state[4] = 0x510E527F;\n  ctx->state[5] = 0x9B05688C;\n  ctx->state[6] = 0x1F83D9AB;\n  ctx->state[7] = 0x5BE0CD19;\n}", "target": 1}
{"code": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}", "target": 1}
{"code": "static void lateeoi_list_add(struct irq_info *info)\n{\n\tstruct lateeoi_work *eoi = &per_cpu(lateeoi, info->eoi_cpu);\n\tstruct irq_info *elem;\n\tu64 now = get_jiffies_64();\n\tunsigned long delay;\n\tunsigned long flags;\n\tif (now < info->eoi_time)\n\t\tdelay = info->eoi_time - now;\n\telse\n\t\tdelay = 1;\n\tspin_lock_irqsave(&eoi->eoi_list_lock, flags);\n\tif (list_empty(&eoi->eoi_list)) {\n\t\tlist_add(&info->eoi_list, &eoi->eoi_list);\n\t\tmod_delayed_work_on(info->eoi_cpu, system_wq,\n\t\t\t\t    &eoi->delayed, delay);\n\t} else {\n\t\tlist_for_each_entry_reverse(elem, &eoi->eoi_list, eoi_list) {\n\t\t\tif (elem->eoi_time <= info->eoi_time)\n\t\t\t\tbreak;\n\t\t}\n\t\tlist_add(&info->eoi_list, &elem->eoi_list);\n\t}\n\tspin_unlock_irqrestore(&eoi->eoi_list_lock, flags);\n}", "target": 0}
{"code": "static int check_line_charstring(void)\n{\n  char *p = line;\n  while (isspace(*p))\n    p++;\n  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));\n}", "target": 1}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}", "target": 1}
{"code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "target": 1}
{"code": "const char * RtmpProtocol::handle_C0C1(const char *data, size_t len) {\n    if (len < 1 + C1_HANDSHARK_SIZE) {\n        return nullptr;\n    }\n    if (data[0] != HANDSHAKE_PLAINTEXT) {\n        throw std::runtime_error(\"only plaintext[0x03] handshake supported\");\n    }\n    if (memcmp(data + 5, \"\\x00\\x00\\x00\\x00\", 4) == 0) {\n        handle_C1_simple(data);\n    } else {\n#ifdef ENABLE_OPENSSL\n        handle_C1_complex(data);\n#else\n        WarnL << \"ENABLE_OPENSSLflash\";\n        handle_C1_simple(data);\n#endif\n    }\n    return data + 1 + C1_HANDSHARK_SIZE;\n}", "target": 0}
{"code": "HIDDEN void log_cachehdr(const char *name, const char *contents,\n                         const char *raw, void *rock)\n{\n    struct buf *buf = (struct buf *) rock;\n    if (name[0] == ':') return;\n    if (!strcasecmp(name, \"authorization\")) {\n        const char *creds = strchr(contents, ' ') + 1;\n        buf_printf(buf, \"%c%s: %.*s%-*s\\r\\n\", toupper(name[0]), name+1,\n                   (int) (creds - contents), contents,\n                   (int) strlen(creds), \"...\");\n    }\n    else if (raw)\n        buf_appendcstr(buf, raw);\n    else\n        buf_printf(buf, \"%c%s: %s\\r\\n\", toupper(name[0]), name+1, contents);\n}", "target": 0}
{"code": "static int em_ret_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned long eip, cs;\n\tu16 old_cs;\n\tint cpl = ctxt->ops->cpl(ctxt);\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_cs, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\trc = emulate_pop(ctxt, &eip, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = emulate_pop(ctxt, &cs, ctxt->op_bytes);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\trc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_RET,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, eip, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS);\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "static void perf_event_task_event(struct perf_task_event *task_event)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint ctxn;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tgoto next;\n\t\tperf_event_task_ctx(&cpuctx->ctx, task_event);\n\t\tctx = task_event->task_ctx;\n\t\tif (!ctx) {\n\t\t\tctxn = pmu->task_ctx_nr;\n\t\t\tif (ctxn < 0)\n\t\t\t\tgoto next;\n\t\t\tctx = rcu_dereference(current->perf_event_ctxp[ctxn]);\n\t\t\tif (ctx)\n\t\t\t\tperf_event_task_ctx(ctx, task_event);\n\t\t}\nnext:\n\t\tput_cpu_ptr(pmu->pmu_cpu_context);\n\t}\n\tif (task_event->task_ctx)\n\t\tperf_event_task_ctx(task_event->task_ctx, task_event);\n\trcu_read_unlock();\n}", "target": 0}
{"code": "static bool identifyCallsites(\n    Function *F,\n    llvh::DenseSet<CallInst *> &callSites) {\n  if (!F->isStrictMode()) {\n    return false;\n  }\n  for (auto *CU : F->getUsers()) {\n    if (auto *CI = llvh::dyn_cast<CallInst>(CU)) {\n      if (!isDirectCallee(F, CI))\n        return false;\n      callSites.insert(CI);\n    } else if (auto *CFI = llvh::dyn_cast<CreateFunctionInst>(CU)) {\n      for (auto *CL : CFI->getUsers()) {\n        auto *CI = llvh::dyn_cast<CallInst>(CL);\n        if (!CI)\n          return false;\n        if (!isDirectCallee(CFI, CI))\n          return false;\n        callSites.insert(CI);\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "inline bool loadModule(const char* filename, IR::Module& outModule)\n{\n\tstd::vector<U8> fileBytes;\n\tif(!loadFile(filename, fileBytes)) { return false; }\n\tif(*(U32*)fileBytes.data() == 0x6d736100)\n\t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n\telse\n\t{\n\t\tfileBytes.push_back(0);\n\t\tstd::vector<WAST::Error> parseErrors;\n\t\tif(!WAST::parseModule(\n\t\t\t   (const char*)fileBytes.data(), fileBytes.size(), outModule, parseErrors))\n\t\t{\n\t\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\t\treportParseErrors(filename, parseErrors);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}", "target": 1}
{"code": "static int on_version_message(struct nvnc_client* client)\n{\n\tstruct nvnc* server = client->server;\n\tif (client->buffer_len - client->buffer_index < 12)\n\t\treturn 0;\n\tchar version_string[13];\n\tmemcpy(version_string, client->msg_buffer + client->buffer_index, 12);\n\tversion_string[12] = '\\0';\n\tif (strcmp(RFB_VERSION_MESSAGE, version_string) != 0)\n\t\treturn handle_unsupported_version(client);\n\tuint8_t buf[sizeof(struct rfb_security_types_msg) +\n\t\tSECURITY_TYPES_MAX] = {};\n\tstruct rfb_security_types_msg* security =\n\t\t(struct rfb_security_types_msg*)buf;\n\tsecurity->n = 0;\n\tif (server->auth_flags & NVNC_AUTH_REQUIRE_AUTH) {\n\t\tassert(server->auth_fn);\n#ifdef ENABLE_TLS\n\t\tif (server->tls_creds) {\n\t\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_VENCRYPT;\n\t\t}\n#endif\n#ifdef HAVE_CRYPTO\n\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES256;\n\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_RSA_AES;\n\t\tif (!(server->auth_flags & NVNC_AUTH_REQUIRE_ENCRYPTION)) {\n\t\t\tsecurity->types[security->n++] = RFB_SECURITY_TYPE_APPLE_DH;\n\t\t}\n#endif\n\t} else {\n\t\tsecurity->n = 1;\n\t\tsecurity->types[0] = RFB_SECURITY_TYPE_NONE;\n\t}\n\tif (security->n == 0) {\n\t\tnvnc_log(NVNC_LOG_PANIC, \"Failed to satisfy requested security constraints\");\n\t}\n\tstream_write(client->net_stream, security, sizeof(*security) +\n\t\t\tsecurity->n, NULL, NULL);\n\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_SECURITY;\n\treturn 12;\n}", "target": 1}
{"code": "PHPAPI int php_execute_simple_script(zend_file_handle *primary_file, zval *ret)\n{\n\tchar *old_cwd;\n\tALLOCA_FLAG(use_heap)\n\tEG(exit_status) = 0;\n#define OLD_CWD_SIZE 4096\n\told_cwd = do_alloca(OLD_CWD_SIZE, use_heap);\n\told_cwd[0] = '\\0';\n\tzend_try {\n#ifdef PHP_WIN32\n\t\tif(primary_file->filename) {\n\t\t\tUpdateIniFromRegistry((char*)primary_file->filename);\n\t\t}\n#endif\n\t\tPG(during_request_startup) = 0;\n\t\tif (primary_file->filename && !(SG(options) & SAPI_OPTION_NO_CHDIR)) {\n\t\t\tphp_ignore_value(VCWD_GETCWD(old_cwd, OLD_CWD_SIZE-1));\n\t\t\tVCWD_CHDIR_FILE(primary_file->filename);\n\t\t}\n\t\tzend_execute_scripts(ZEND_REQUIRE, ret, 1, primary_file);\n\t} zend_end_try();\n\tif (old_cwd[0] != '\\0') {\n\t\tphp_ignore_value(VCWD_CHDIR(old_cwd));\n\t}\n\tfree_alloca(old_cwd, use_heap);\n\treturn EG(exit_status);\n}", "target": 0}
{"code": "mktime(const unsigned int year0, const unsigned int mon0,\n       const unsigned int day, const unsigned int hour,\n       const unsigned int min, const unsigned int sec)\n{\n\tunsigned int mon = mon0, year = year0;\n\tif (0 >= (int) (mon -= 2)) {\n\t\tmon += 12;\t\n\t\tyear -= 1;\n\t}\n\treturn ((((unsigned long)\n\t\t  (year/4 - year/100 + year/400 + 367*mon/12 + day) +\n\t\t  year*365 - 719499\n\t    )*24 + hour \n\t  )*60 + min \n\t)*60 + sec; \n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    if (input.dims() > 0) {\n      OP_REQUIRES(\n          context, input.dim_size(0) != 0,\n          errors::InvalidArgument(\"Invalid input first dimension. Found 0.\"));\n    }\n    const Tensor& dims = context->input(1);\n    if (TensorShapeUtils::IsScalar(input.shape())) {\n      context->set_output(0, input);\n    } else {\n      const int input_dims = input.dims();\n      OP_REQUIRES(context, TensorShapeUtils::IsVector(dims.shape()),\n                  errors::InvalidArgument(\"'dims' must be 1-dimension, not \",\n                                          dims.dims()));\n      OP_REQUIRES(\n          context, input_dims == dims.dim_size(0),\n          errors::InvalidArgument(\n              \"'dims' must have the same number of values as 'input' has \"\n              \"dimensions. 'input' has \",\n              input_dims, \"'dims' has \", dims.dim_size(0), \" values\"));\n      OP_REQUIRES(context, input_dims <= 8,\n                  errors::Unimplemented(\n                      \"reverse is not implemented for tensors of rank > 8.\"));\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, input.shape(), &output));\n#define HANDLE_REVERSE(NDIMS)                                               \\\n  case NDIMS:                                                               \\\n    HandleReverseCase<Device, T, NDIMS>(context, dims.vec<bool>(), output); \\\n    return;\n      switch (input_dims) {\n        HANDLE_REVERSE(0);\n        HANDLE_REVERSE(1);\n        HANDLE_REVERSE(2);\n        HANDLE_REVERSE(3);\n        HANDLE_REVERSE(4);\n        HANDLE_REVERSE(5);\n        HANDLE_REVERSE(6);\n        HANDLE_REVERSE(7);\n        HANDLE_REVERSE(8);\n      }\n#undef HANDLE_REVERSE\n    }\n  }", "target": 0}
{"code": "update_request_allow_commands (UpdateRequest *request, gboolean allowCommands)\n{\n\trequest->allowCommands = allowCommands;\n}", "target": 0}
{"code": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}\n\tvmcs_write64(MSR_BITMAP, __pa(msr_bitmap));\n}", "target": 1}
{"code": "static SDL_Surface *Create_Surface_Blended(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf = NULL;\n    Uint32 bgcolor;\n    bgcolor = (fg.r << 16) | (fg.g << 8) | fg.b;\n    *color = bgcolor | (fg.a << 24);\n    if (width != 0) {\n        Sint64 size;\n        void *pixels, *ptr;\n        Sint64 pitch = (width + alignment) * 4;\n        pitch += alignment;\n        pitch &= ~alignment;\n        size = height * pitch + sizeof (void *) + alignment;\n        if (size < 0 || size > SDL_MAX_SINT32) {\n            return NULL;\n        }\n        ptr = SDL_malloc((size_t)size);\n        if (ptr == NULL) {\n            return NULL;\n        }\n        pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n        ((void **)pixels)[-1] = ptr;\n        textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_ARGB8888);\n        if (textbuf == NULL) {\n            SDL_free(ptr);\n            return NULL;\n        }\n        textbuf->flags &= ~SDL_PREALLOC;\n        textbuf->flags |= SDL_SIMD_ALIGNED;\n        SDL_memset4(pixels, bgcolor, (height * pitch) / 4);\n        if (fg.a != SDL_ALPHA_OPAQUE) {\n            SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);\n        }\n    }\n    return textbuf;", "target": 1}
{"code": "void codingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}\n}", "target": 1}
{"code": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\tusb_msg.dlc = cf->len;\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\treturn NETDEV_TX_OK;\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "TRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn strlen(string);\n}", "target": 1}
{"code": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n{\n\tstruct rtable *rt;\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options *opt = inet_rsk(req)->opt;\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto route_err;\n\treturn &rt->dst;\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}", "target": 1}
{"code": "NOEXPORT char *pgsql_server(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {\n    uint8_t buffer[8], ssl_ok[1]={'S'};\n    static const uint8_t gss_request[8]={0, 0, 0, 8, 0x04, 0xd2, 0x16, 0x30};\n    static const uint8_t gss_response[62]=\n        {'E', 0, 0, 0, 61, 'S', 'E', 'R', 'R', 'O', 'R', 0, 'C', 'X', 'X', '0',\n        '0', '0', 0, 'M', 'S', 'S', 'L', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd',\n        ' ', 'b', 'u', 't', ' ', 'n', 'o', 't', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't',\n        'e', 'd', ' ', 'b', 'y', ' ', 'c', 'l', 'i', 'e', 'n', 't', 0, 0};\n    (void)opt; \n    if(phase!=PROTOCOL_EARLY)\n        return NULL;\n    s_log(LOG_DEBUG, \"Started server-side psql protcol negotiation\");\n    memset(buffer, 0, sizeof buffer);\n    s_read(c, c->local_rfd.fd, buffer, sizeof buffer);\n    if(!safe_memcmp(buffer, gss_request, sizeof gss_request)) {\n        s_log(LOG_INFO, \"GSSAPI encryption requested, rejecting gracefully\");\n        s_write(c, c->local_wfd.fd, gss_response, sizeof gss_response);\n        throw_exception(c, 2); \n    }\n    if(safe_memcmp(buffer, ssl_request, sizeof ssl_request)) {\n        s_log(LOG_ERR, \"PostgreSQL client did not request TLS, rejecting\");\n        throw_exception(c, 1);\n    }\n    s_log(LOG_DEBUG, \"SSLRequest received\");\n    s_write(c, c->local_wfd.fd, ssl_ok, sizeof ssl_ok);\n    return NULL;\n}", "target": 0}
{"code": "int HttpStreamParser::DoLoop(int result) {\n  bool can_do_more = true;\n  do {\n    switch (io_state_) {\n      case STATE_SENDING_HEADERS:\n        if (result < 0)\n          can_do_more = false;\n        else\n          result = DoSendHeaders(result);\n        break;\n      case STATE_SENDING_BODY:\n        if (result < 0)\n          can_do_more = false;\n        else\n          result = DoSendBody(result);\n        break;\n      case STATE_SEND_REQUEST_READING_BODY:\n        result = DoSendRequestReadingBody(result);\n        break;\n      case STATE_REQUEST_SENT:\n        DCHECK(result != ERR_IO_PENDING);\n        can_do_more = false;\n        break;\n      case STATE_READ_HEADERS:\n        net_log_.BeginEvent(NetLog::TYPE_HTTP_STREAM_PARSER_READ_HEADERS);\n        result = DoReadHeaders();\n        break;\n      case STATE_READ_HEADERS_COMPLETE:\n        result = DoReadHeadersComplete(result);\n        net_log_.EndEventWithNetErrorCode(\n            NetLog::TYPE_HTTP_STREAM_PARSER_READ_HEADERS, result);\n        break;\n      case STATE_BODY_PENDING:\n        DCHECK(result != ERR_IO_PENDING);\n        can_do_more = false;\n        break;\n      case STATE_READ_BODY:\n        result = DoReadBody();\n        break;\n      case STATE_READ_BODY_COMPLETE:\n        result = DoReadBodyComplete(result);\n        break;\n      case STATE_DONE:\n        DCHECK(result != ERR_IO_PENDING);\n        can_do_more = false;\n        break;\n      default:\n        NOTREACHED();\n        can_do_more = false;\n        break;\n    }\n  } while (result != ERR_IO_PENDING && can_do_more);\n  return result;\n}", "target": 0}
{"code": "static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 total_sg_needed, unsigned char init_payload)\n{\n\tu32 i = 0, j, page_offset = 0, sg_per_table;\n\tu32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /\n\t\t\t\tsizeof(struct scatterlist));\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tunsigned char *p;\n\twhile (total_sg_needed) {\n\t\tsg_per_table = (total_sg_needed > max_sg_per_table) ?\n\t\t\tmax_sg_per_table : total_sg_needed;\n\t\tsg = kzalloc(sg_per_table * sizeof(struct scatterlist),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!sg) {\n\t\t\tpr_err(\"Unable to allocate scatterlist array\"\n\t\t\t\t\" for struct rd_dev\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tsg_init_table(sg, sg_per_table);\n\t\tsg_table[i].sg_table = sg;\n\t\tsg_table[i].rd_sg_count = sg_per_table;\n\t\tsg_table[i].page_start_offset = page_offset;\n\t\tsg_table[i++].page_end_offset = (page_offset + sg_per_table)\n\t\t\t\t\t\t- 1;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = alloc_pages(GFP_KERNEL, 0);\n\t\t\tif (!pg) {\n\t\t\t\tpr_err(\"Unable to allocate scatterlist\"\n\t\t\t\t\t\" pages for struct rd_dev_sg_table\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsg_assign_page(&sg[j], pg);\n\t\t\tsg[j].length = PAGE_SIZE;\n\t\t\tp = kmap(pg);\n\t\t\tmemset(p, init_payload, PAGE_SIZE);\n\t\t\tkunmap(pg);\n\t\t}\n\t\tpage_offset += sg_per_table;\n\t\ttotal_sg_needed -= sg_per_table;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}", "target": 1}
{"code": "static bool open_match_attributes(connection_struct *conn,\n\t\t\t\t  uint32 old_dos_attr,\n\t\t\t\t  uint32 new_dos_attr,\n\t\t\t\t  mode_t existing_unx_mode,\n\t\t\t\t  mode_t new_unx_mode,\n\t\t\t\t  mode_t *returned_unx_mode)\n{\n\tuint32 noarch_old_dos_attr, noarch_new_dos_attr;\n\tnoarch_old_dos_attr = (old_dos_attr & ~FILE_ATTRIBUTE_ARCHIVE);\n\tnoarch_new_dos_attr = (new_dos_attr & ~FILE_ATTRIBUTE_ARCHIVE);\n\tif((noarch_old_dos_attr == 0 && noarch_new_dos_attr != 0) || \n\t   (noarch_old_dos_attr != 0 && ((noarch_old_dos_attr & noarch_new_dos_attr) == noarch_old_dos_attr))) {\n\t\t*returned_unx_mode = new_unx_mode;\n\t} else {\n\t\t*returned_unx_mode = (mode_t)0;\n\t}\n\tDEBUG(10,(\"open_match_attributes: old_dos_attr = 0x%x, \"\n\t\t  \"existing_unx_mode = 0%o, new_dos_attr = 0x%x \"\n\t\t  \"returned_unx_mode = 0%o\\n\",\n\t\t  (unsigned int)old_dos_attr,\n\t\t  (unsigned int)existing_unx_mode,\n\t\t  (unsigned int)new_dos_attr,\n\t\t  (unsigned int)*returned_unx_mode ));\n\tif (lp_map_system(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {\n\t\tif ((old_dos_attr & FILE_ATTRIBUTE_SYSTEM) &&\n\t\t    !(new_dos_attr & FILE_ATTRIBUTE_SYSTEM)) {\n\t\t\treturn False;\n\t\t}\n\t}\n\tif (lp_map_hidden(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {\n\t\tif ((old_dos_attr & FILE_ATTRIBUTE_HIDDEN) &&\n\t\t    !(new_dos_attr & FILE_ATTRIBUTE_HIDDEN)) {\n\t\t\treturn False;\n\t\t}\n\t}\n\treturn True;\n}", "target": 0}
{"code": "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}", "target": 1}
{"code": "bool MemoryManager::validate_user_read(const Process& process, VirtualAddress vaddr) const\n{\n    auto* region = region_from_vaddr(process, vaddr);\n    return region && region->is_readable();\n}", "target": 1}
{"code": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}", "target": 1}
{"code": "static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)\n{\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tif (offset <= curr_off && test_clear_buffer_uninit(bh)\n\t\t\t\t\t&& bh->b_private) {\n\t\t\text4_free_io_end(bh->b_private);\n\t\t\tbh->b_private = NULL;\n\t\t\tbh->b_end_io = NULL;\n\t\t}\n\t\tcurr_off = curr_off + bh->b_size;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}", "target": 0}
{"code": "static u16 swf_get_16(SWFReader *read)\n{\n\tu16 val, res;\n\tval = swf_read_int(read, 16);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d,\n                  typename TTypes<T, 3>::ConstTensor gradient,\n                  typename TTypes<T, 3>::ConstTensor input,\n                  const Tensor* input_min_tensor,\n                  const Tensor* input_max_tensor,\n                  typename TTypes<T, 3>::Tensor input_backprop,\n                  typename TTypes<T>::Flat input_min_backprop,\n                  typename TTypes<T>::Flat input_max_backprop) {\n    QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "void gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}", "target": 1}
{"code": "static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (mc->id < 0)\n\t\tgoto error;\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\nerror:\n\tkfree(mc);\n\treturn NULL;\n}", "target": 1}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "static int show_stat(struct kmem_cache *s, char *buf, enum stat_item si)\n{\n\tunsigned long sum  = 0;\n\tint cpu;\n\tint len;\n\tint *data = kmalloc(nr_cpu_ids * sizeof(int), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tfor_each_online_cpu(cpu) {\n\t\tunsigned x = get_cpu_slab(s, cpu)->stat[si];\n\t\tdata[cpu] = x;\n\t\tsum += x;\n\t}\n\tlen = sprintf(buf, \"%lu\", sum);\n#ifdef CONFIG_SMP\n\tfor_each_online_cpu(cpu) {\n\t\tif (data[cpu] && len < PAGE_SIZE - 20)\n\t\t\tlen += sprintf(buf + len, \" C%d=%u\", cpu, data[cpu]);\n\t}\n#endif\n\tkfree(data);\n\treturn len + sprintf(buf + len, \"\\n\");\n}", "target": 0}
{"code": "static void perf_adjust_freq_unthr_context(struct perf_event_context *ctx,\n\t\t\t\t\t   int needs_unthr)\n{\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tu64 now, period = TICK_NSEC;\n\ts64 delta;\n\tif (!(ctx->nr_freq || needs_unthr))\n\t\treturn;\n\traw_spin_lock(&ctx->lock);\n\tperf_pmu_disable(ctx->pmu);\n\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\tif (event->state != PERF_EVENT_STATE_ACTIVE)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\t\thwc = &event->hw;\n\t\tif (needs_unthr && hwc->interrupts == MAX_INTERRUPTS) {\n\t\t\thwc->interrupts = 0;\n\t\t\tperf_log_throttle(event, 1);\n\t\t\tevent->pmu->start(event, 0);\n\t\t}\n\t\tif (!event->attr.freq || !event->attr.sample_freq)\n\t\t\tcontinue;\n\t\tevent->pmu->stop(event, PERF_EF_UPDATE);\n\t\tnow = local64_read(&event->count);\n\t\tdelta = now - hwc->freq_count_stamp;\n\t\thwc->freq_count_stamp = now;\n\t\tif (delta > 0)\n\t\t\tperf_adjust_period(event, period, delta, false);\n\t\tevent->pmu->start(event, delta > 0 ? PERF_EF_RELOAD : 0);\n\t}\n\tperf_pmu_enable(ctx->pmu);\n\traw_spin_unlock(&ctx->lock);\n}", "target": 0}
{"code": "update_job_run (updateJobPtr job)\n{\n\tif (*(job->request->source) == '|') {\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n\t\tupdate_exec_cmd (job);\n\t\treturn;\n\t}\n\tif (strstr (job->request->source, \":\n\t\tnetwork_process_request (job);\n\t\treturn;\n\t}\n\t{\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized file URI: %s\", job->request->source);\n\t\tupdate_load_file (job);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "static int config_req_handler(void *arg)\n{\n\tprintf(\"requesing config\\n\");\n\treturn rest_request(NULL, engine_get_restcli(engine), 0,\n\t\t\t    \"GET\", cfg_resp_handler, NULL,\n\t\t\t    \"/calls/config/v2\", NULL);\n}", "target": 0}
{"code": "gss_verify_mic (minor_status,\n\t\tcontext_handle,\n\t\tmessage_buffer,\n\t\ttoken_buffer,\n\t\tqop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\ttoken_buffer;\ngss_qop_t *\t\tqop_state;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    if ((message_buffer == GSS_C_NO_BUFFER) ||\n\tGSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_verify_mic) {\n\t    status = mech->gss_verify_mic(\n\t\t\t\t\t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  message_buffer,\n\t\t\t\t\t  token_buffer,\n\t\t\t\t\t  qop_state);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "int io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}", "target": 1}
{"code": "acpi_parse_lapic_nmi(acpi_table_entry_header * header, const unsigned long end)\n{\n\tstruct acpi_table_lapic_nmi *lapic_nmi = NULL;\n\tlapic_nmi = (struct acpi_table_lapic_nmi *)header;\n\tif (BAD_MADT_ENTRY(lapic_nmi, end))\n\t\treturn -EINVAL;\n\tacpi_table_print_madt_entry(header);\n\tif (lapic_nmi->lint != 1)\n\t\tprintk(KERN_WARNING PREFIX \"NMI not connected to LINT 1!\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "int sanity_check_ckpt(struct f2fs_sb_info *sbi)\n{\n\tunsigned int total, fsmeta;\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tunsigned int ovp_segments, reserved_segments;\n\tunsigned int main_segs, blocks_per_seg;\n\tint i;\n\ttotal = le32_to_cpu(raw_super->segment_count);\n\tfsmeta = le32_to_cpu(raw_super->segment_count_ckpt);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_sit);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_nat);\n\tfsmeta += le32_to_cpu(ckpt->rsvd_segment_count);\n\tfsmeta += le32_to_cpu(raw_super->segment_count_ssa);\n\tif (unlikely(fsmeta >= total))\n\t\treturn 1;\n\tovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\treserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tif (unlikely(fsmeta < F2FS_MIN_SEGMENTS ||\n\t\t\tovp_segments == 0 || reserved_segments == 0)) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR,\n\t\t\t\"Wrong layout: check mkfs.f2fs version\");\n\t\treturn 1;\n\t}\n\tmain_segs = le32_to_cpu(raw_super->segment_count_main);\n\tblocks_per_seg = sbi->blocks_per_seg;\n\tfor (i = 0; i < NR_CURSEG_NODE_TYPE; i++) {\n\t\tif (le32_to_cpu(ckpt->cur_node_segno[i]) >= main_segs ||\n\t\t\tle16_to_cpu(ckpt->cur_node_blkoff[i]) >= blocks_per_seg)\n\t\t\treturn 1;\n\t}\n\tfor (i = 0; i < NR_CURSEG_DATA_TYPE; i++) {\n\t\tif (le32_to_cpu(ckpt->cur_data_segno[i]) >= main_segs ||\n\t\t\tle16_to_cpu(ckpt->cur_data_blkoff[i]) >= blocks_per_seg)\n\t\t\treturn 1;\n\t}\n\tif (unlikely(f2fs_cp_error(sbi))) {\n\t\tf2fs_msg(sbi->sb, KERN_ERR, \"A bug case: need to run fsck\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int jpc_tsfb_synthesize(jpc_tsfb_t *tsfb, jas_seq2d_t *a)\n{\n\treturn (tsfb->numlvls > 0) ? jpc_tsfb_synthesize2(tsfb,\n\t  jas_seq2d_getref(a, jas_seq2d_xstart(a), jas_seq2d_ystart(a)),\n\t  jas_seq2d_xstart(a), jas_seq2d_ystart(a), jas_seq2d_width(a),\n\t  jas_seq2d_height(a), jas_seq2d_rowstep(a), tsfb->numlvls - 1) : 0;\n}", "target": 1}
{"code": "void ExtensionPrefs::InitPrefStore() {\n  ExtensionIdSet extension_ids;\n  GetExtensions(&extension_ids);\n  for (ExtensionIdSet::iterator ext_id = extension_ids.begin();\n       ext_id != extension_ids.end(); ++ext_id) {\n    ScopedExtensionPrefUpdate update(prefs_, *ext_id);\n    update.Get();\n  }\n  FixMissingPrefs(extension_ids);\n  for (ExtensionIdSet::iterator ext_id = extension_ids.begin();\n       ext_id != extension_ids.end(); ++ext_id) {\n    extension_pref_value_map_->RegisterExtension(\n        *ext_id,\n        GetInstallTime(*ext_id),\n        GetExtensionState(*ext_id) == Extension::ENABLED);\n    content_settings_store_->RegisterExtension(\n        *ext_id,\n        GetInstallTime(*ext_id),\n        GetExtensionState(*ext_id) == Extension::ENABLED);\n    const DictionaryValue* prefs = GetExtensionControlledPrefs(*ext_id, false);\n    for (DictionaryValue::key_iterator i = prefs->begin_keys();\n         i != prefs->end_keys(); ++i) {\n      Value* value;\n      if (!prefs->GetWithoutPathExpansion(*i, &value))\n        continue;\n      extension_pref_value_map_->SetExtensionPref(\n          *ext_id, *i, kExtensionPrefsScopeRegular, value->DeepCopy());\n    }\n    prefs = GetExtensionControlledPrefs(*ext_id, true);\n    for (DictionaryValue::key_iterator i = prefs->begin_keys();\n         i != prefs->end_keys(); ++i) {\n      Value* value;\n      if (!prefs->GetWithoutPathExpansion(*i, &value))\n        continue;\n      extension_pref_value_map_->SetExtensionPref(\n          *ext_id, *i, kExtensionPrefsScopeIncognitoPersistent,\n          value->DeepCopy());\n    }\n    const DictionaryValue* extension_prefs = GetExtensionPref(*ext_id);\n    DCHECK(extension_prefs);\n    ListValue* content_settings = NULL;\n    if (extension_prefs->GetList(kPrefContentSettings,\n                                 &content_settings)) {\n      content_settings_store_->SetExtensionContentSettingsFromList(\n          *ext_id, content_settings,\n          kExtensionPrefsScopeRegular);\n    }\n    if (extension_prefs->GetList(kPrefIncognitoContentSettings,\n                                 &content_settings)) {\n      content_settings_store_->SetExtensionContentSettingsFromList(\n          *ext_id, content_settings,\n          kExtensionPrefsScopeIncognitoPersistent);\n    }\n  }\n  extension_pref_value_map_->NotifyInitializationCompleted();\n}", "target": 0}
{"code": "static uint16_t nvme_get_mgmt_zone_slba_idx(NvmeNamespace *ns, NvmeCmd *c,\n                                            uint64_t *slba, uint32_t *zone_idx)\n{\n    uint32_t dw10 = le32_to_cpu(c->cdw10);\n    uint32_t dw11 = le32_to_cpu(c->cdw11);\n    if (!ns->params.zoned) {\n        trace_pci_nvme_err_invalid_opc(c->opcode);\n        return NVME_INVALID_OPCODE | NVME_DNR;\n    }\n    *slba = ((uint64_t)dw11) << 32 | dw10;\n    if (unlikely(*slba >= ns->id_ns.nsze)) {\n        trace_pci_nvme_err_invalid_lba_range(*slba, 0, ns->id_ns.nsze);\n        *slba = 0;\n        return NVME_LBA_RANGE | NVME_DNR;\n    }\n    *zone_idx = nvme_zone_idx(ns, *slba);\n    assert(*zone_idx < ns->num_zones);\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)\n{\n\tstruct pipe_buffer *bufs;\n\tif (nr_pages < pipe->nrbufs)\n\t\treturn -EBUSY;\n\tbufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\tif (pipe->nrbufs) {\n\t\tunsigned int tail;\n\t\tunsigned int head;\n\t\ttail = pipe->curbuf + pipe->nrbufs;\n\t\tif (tail < pipe->buffers)\n\t\t\ttail = 0;\n\t\telse\n\t\t\ttail &= (pipe->buffers - 1);\n\t\thead = pipe->nrbufs - tail;\n\t\tif (head)\n\t\t\tmemcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));\n\t\tif (tail)\n\t\t\tmemcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));\n\t}\n\taccount_pipe_buffers(pipe, pipe->buffers, nr_pages);\n\tpipe->curbuf = 0;\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->buffers = nr_pages;\n\treturn nr_pages * PAGE_SIZE;\n}", "target": 0}
{"code": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stl_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "static int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void sunkbd_enable(struct sunkbd *sunkbd, bool enable)\n{\n\tserio_pause_rx(sunkbd->serio);\n\tsunkbd->enabled = enable;\n\tserio_continue_rx(sunkbd->serio);\n\tif (!enable) {\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tcancel_work_sync(&sunkbd->tq);\n\t}\n}", "target": 0}
{"code": "    explicit DialogHandler(v8::Handle<v8::Value> dialogArguments, ScriptState* scriptState)\n        : m_scriptState(scriptState)\n        , m_dialogArguments(dialogArguments)\n    {\n    }", "target": 0}
{"code": "mrb_io_initialize_copy(mrb_state *mrb, mrb_value copy)\n{\n  mrb_value orig;\n  mrb_value buf;\n  struct mrb_io *fptr_copy;\n  struct mrb_io *fptr_orig;\n  mrb_bool failed = TRUE;\n  mrb_get_args(mrb, \"o\", &orig);\n  fptr_copy = (struct mrb_io *)DATA_PTR(copy);\n  if (fptr_copy != NULL) {\n    fptr_finalize(mrb, fptr_copy, FALSE);\n    mrb_free(mrb, fptr_copy);\n  }\n  fptr_copy = (struct mrb_io *)mrb_io_alloc(mrb);\n  fptr_orig = io_get_open_fptr(mrb, orig);\n  DATA_TYPE(copy) = &mrb_io_type;\n  DATA_PTR(copy) = fptr_copy;\n  buf = mrb_iv_get(mrb, orig, mrb_intern_cstr(mrb, \"@buf\"));\n  mrb_iv_set(mrb, copy, mrb_intern_cstr(mrb, \"@buf\"), buf);\n  fptr_copy->fd = mrb_dup(mrb, fptr_orig->fd, &failed);\n  if (failed) {\n    mrb_sys_fail(mrb, 0);\n  }\n  mrb_fd_cloexec(mrb, fptr_copy->fd);\n  if (fptr_orig->fd2 != -1) {\n    fptr_copy->fd2 = mrb_dup(mrb, fptr_orig->fd2, &failed);\n    if (failed) {\n      close(fptr_copy->fd);\n      mrb_sys_fail(mrb, 0);\n    }\n    mrb_fd_cloexec(mrb, fptr_copy->fd2);\n  }\n  fptr_copy->pid = fptr_orig->pid;\n  fptr_copy->readable = fptr_orig->readable;\n  fptr_copy->writable = fptr_orig->writable;\n  fptr_copy->sync = fptr_orig->sync;\n  fptr_copy->is_socket = fptr_orig->is_socket;\n  return copy;\n}", "target": 1}
{"code": "std::string RestAuthHandler::generateJwt(std::string const& username,\n                                         std::string const& password) {\n  AuthenticationFeature* af = AuthenticationFeature::instance();\n  TRI_ASSERT(af != nullptr);\n  return fuerte::jwt::generateUserToken(af->tokenCache().jwtSecret(), username, _validFor);\n}", "target": 1}
{"code": "Archive::Archive(RAROptions *InitCmd)\n{\n  Cmd=NULL; \n  DummyCmd=(InitCmd==NULL);\n  Cmd=DummyCmd ? (new RAROptions):InitCmd;\n  OpenShared=Cmd->OpenShared;\n  Format=RARFMT15;\n  Solid=false;\n  Volume=false;\n  MainComment=false;\n  Locked=false;\n  Signed=false;\n  FirstVolume=false;\n  NewNumbering=false;\n  SFXSize=0;\n  LatestTime.Reset();\n  Protected=false;\n  Encrypted=false;\n  FailedHeaderDecryption=false;\n  BrokenHeader=false;\n  LastReadBlock=0;\n  CurBlockPos=0;\n  NextBlockPos=0;\n  RecoverySize=-1;\n  RecoveryPercent=-1;\n  memset(&MainHead,0,sizeof(MainHead));\n  memset(&CryptHead,0,sizeof(CryptHead));\n  memset(&EndArcHead,0,sizeof(EndArcHead));\n  VolNumber=0;\n  VolWrite=0;\n  AddingFilesSize=0;\n  AddingHeadersSize=0;\n  *FirstVolumeName=0;\n  Splitting=false;\n  NewArchive=false;\n  SilentOpen=false;\n#ifdef USE_QOPEN\n  ProhibitQOpen=false;\n#endif\n}", "target": 0}
{"code": "int js_isuserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\treturn !strcmp(tag, v->u.object->u.user.tag);\n\treturn 0;\n}", "target": 0}
{"code": "Status TensorSliceReader::GetTensor(\n    const string& name, std::unique_ptr<tensorflow::Tensor>* out_tensor) const {\n  DataType type;\n  TensorShape shape;\n  TensorSlice slice;\n  {\n    mutex_lock l(mu_);\n    const TensorSliceSet* tss = gtl::FindPtrOrNull(tensors_, name);\n    if (tss == nullptr) {\n      return errors::NotFound(name, \" not found in checkpoint file\");\n    }\n    if (tss->Slices().size() > 1) {\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n  switch (type) {\n    READER_COPY(DT_FLOAT);\n    READER_COPY(DT_DOUBLE);\n    READER_COPY(DT_INT32);\n    READER_COPY(DT_UINT8);\n    READER_COPY(DT_INT16);\n    READER_COPY(DT_INT8);\n    READER_COPY(DT_INT64);\n    READER_COPY(DT_STRING);\n    default:\n      return errors::Unimplemented(\"Data type not supported\");\n  }\n#undef READER_COPY\n  if (!success) {\n    return errors::NotFound(name, \" not found in checkpoint file\");\n  }\n  std::swap(*out_tensor, t);\n  return Status::OK();\n}", "target": 1}
{"code": "int rose_add_loopback_node(const rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\tint err = 0;\n\tspin_lock_bh(&rose_node_list_lock);\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t     (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t     rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\tif (rose_node != NULL)\n\t\tgoto out;\n\tif ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\trose_node->address      = *address;\n\trose_node->mask         = 10;\n\trose_node->count        = 1;\n\trose_node->loopback     = 1;\n\trose_node->neighbour[0] = rose_loopback_neigh;\n\trose_node->next = rose_node_list;\n\trose_node_list  = rose_node;\n\trose_loopback_neigh->count++;\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n\treturn err;\n}", "target": 0}
{"code": "CMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\tif ((parv[1][0] == ':') || strchr(parv[1], ' '))\n\t{\n\t\tsendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, \"*\", \"AUTHENTICATE\", \"Invalid parameter\");\n\t\treturn 0;\n\t}\n\tif (strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\tsptr->local->sasl_out++;\n\treturn 0;\n}", "target": 0}
{"code": "static int ext4_dax_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\treturn dax_mkwrite(vma, vmf, ext4_get_block_dax,\n\t\t\t\text4_end_io_unwritten);\n}", "target": 1}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,const ssize_t row,\n  const PixelChannel channel,const unsigned char *pixels,\n  ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  const unsigned char\n    *p;\n  Quantum\n    *q;\n  ssize_t\n    x;\n  size_t\n    packet_size;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      if (packet_size == 2)\n        {\n          unsigned short\n            nibble;\n          p=PushShortPixel(MSBEndian,p,&nibble);\n          pixel=ScaleShortToQuantum(nibble);\n        }\n      else\n        {\n          MagickFloatType\n            nibble;\n          p=PushFloatPixel(MSBEndian,p,&nibble);\n          pixel=ClampToQuantum(((MagickRealType) QuantumRange)*nibble);\n        }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channel,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=(ssize_t) image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < (ssize_t) number_bits; bit++)\n        {\n          SetPSDPixel(image,channel,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : QuantumRange,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != (ssize_t) image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 1}
{"code": "find_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n    if (!is_referral_req(kdc_active_realm, request))\n        goto cleanup;\n    hostname = data2string(krb5_princ_component(kdc_context,\n                                                request->server, 1));\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(kdc_context, hostname, &realms);\n    if (retval) {\n        kdc_err(kdc_context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    if (realms == NULL || realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(kdc_context, realms);\n    free(hostname);\n    return retval;\n}", "target": 1}
{"code": "static void huffman_decode_row(x3f_info_t *I, x3f_directory_entry_t *DE,\n                               int bits, int row, int offset, int *minimum)\n{\n  x3f_directory_entry_header_t *DEH = &DE->header;\n  x3f_image_data_t *ID = &DEH->data_subsection.image_data;\n  x3f_huffman_t *HUF = ID->huffman;\n  int16_t c[3] = {(int16_t)offset, (int16_t)offset, (int16_t)offset};\n  int col;\n  bit_state_t BS;\n  if (HUF->row_offsets.element[row] > ID->data_size - 1)\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  set_bit_state(&BS, (uint8_t *)ID->data + HUF->row_offsets.element[row]);\n  for (col = 0; col < ID->columns; col++)\n  {\n    int color;\n    for (color = 0; color < 3; color++)\n    {\n      uint16_t c_fix;\n      c[color] += get_huffman_diff(&BS, &HUF->tree);\n      if (c[color] < 0)\n      {\n        c_fix = 0;\n        if (c[color] < *minimum)\n          *minimum = c[color];\n      }\n      else\n      {\n        c_fix = c[color];\n      }\n      switch (ID->type_format)\n      {\n      case X3F_IMAGE_RAW_HUFFMAN_X530:\n      case X3F_IMAGE_RAW_HUFFMAN_10BIT:\n        HUF->x3rgb16.data[3 * (row * ID->columns + col) + color] =\n            (uint16_t)c_fix;\n        break;\n      case X3F_IMAGE_THUMB_HUFFMAN:\n        HUF->rgb8.data[3 * (row * ID->columns + col) + color] = (uint8_t)c_fix;\n        break;\n      default:\n        throw LIBRAW_EXCEPTION_IO_CORRUPT;\n      }\n    }\n  }\n}", "target": 0}
{"code": "  void decode(bufferlist::iterator& bl) {\n    __u8 struct_v;\n    ::decode(struct_v, bl);\n    ::decode(server_challenge, bl);\n  }", "target": 0}
{"code": "void *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc called with %zu\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}", "target": 1}
{"code": "count_new_keys(int n_key_data, krb5_key_data *key_data)\n{\n    int n;\n    for (n = 1; n < n_key_data; n++) {\n        if (key_data[n - 1].key_data_kvno != key_data[n].key_data_kvno)\n            return n;\n    }\n    return n_key_data;\n}", "target": 0}
{"code": "gerb_fopen(char const * filename)\n{\n    gerb_file_t *fd;\n    struct stat statinfo;\n    dprintf(\"---> Entering gerb_fopen, filename = %s\\n\", filename);\n    fd = g_new(gerb_file_t, 1);\n    if (fd == NULL) {\n\treturn NULL;\n    }\n    dprintf(\"     Doing fopen\\n\");\n    fd->fd = g_fopen(filename, \"rb\");\n    if (fd->fd == NULL) {\n\tg_free(fd);\n\treturn NULL;\n    }\n    dprintf(\"     Doing fstat\\n\");\n    fd->ptr = 0;\n    fd->fileno = fileno(fd->fd);\n    if (fstat(fd->fileno, &statinfo) < 0) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\treturn NULL;\n    }\n    dprintf(\"     Checking S_ISREG\\n\");\n    if (!S_ISREG(statinfo.st_mode)) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\terrno = EISDIR;\n\treturn NULL;\n    }\n    dprintf(\"     Checking statinfo.st_size\\n\");\n    if ((int)statinfo.st_size == 0) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\terrno = EIO; \n\treturn NULL;\n    }\n#ifdef HAVE_SYS_MMAN_H\n    dprintf(\"     Doing mmap\\n\");\n    fd->datalen = (int)statinfo.st_size;\n    fd->data = (char *)mmap(0, statinfo.st_size, PROT_READ, MAP_PRIVATE, \n\t\t\t    fd->fileno, 0);\n    if(fd->data == MAP_FAILED) {\n\tfclose(fd->fd);\n\tg_free(fd);\n\tfd = NULL;\n    }\n#else\n    dprintf(\"     Doing calloc\\n\");\n    fd->datalen = (int)statinfo.st_size;\n    fd->data = calloc(1, statinfo.st_size + 1);\n    if (fd->data == NULL) {\n        fclose(fd->fd);\n        g_free(fd);\n        return NULL;\n    }\n    if (fread((void*)fd->data, 1, statinfo.st_size, fd->fd) != statinfo.st_size) {\n        fclose(fd->fd);\n\tg_free(fd->data);\n        g_free(fd);\n\treturn NULL;\n    }\n    rewind (fd->fd);\n#endif\n    dprintf(\"     Setting filename\\n\");\n    fd->filename = g_strdup(filename);\n    dprintf(\"<--- Leaving gerb_fopen\\n\");\n    return fd;\n} ", "target": 0}
{"code": "escape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\tif (!strlen(text)) return \"\";\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  \n\treturn escaped;\n}", "target": 0}
{"code": "void ide_atapi_cmd(IDEState *s)\n{\n    uint8_t *buf;\n    buf = s->io_buffer;\n#ifdef DEBUG_IDE_ATAPI\n    {\n        int i;\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n            printf(\" %02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n    if (s->sense_key == UNIT_ATTENTION &&\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n        ide_atapi_cmd_check_status(s);\n        return;\n    }\n    if (!s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n        s->cdrom_changed = 0;\n        s->sense_key = UNIT_ATTENTION;\n        s->asc = ASC_MEDIUM_MAY_HAVE_CHANGED;\n        return;\n    }\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n    {\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n        return;\n    }\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n        return;\n    }\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n}", "target": 0}
{"code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                return status;\n            }\n            else\n            {\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                return func(stream, iter->pos, pItem);\n            }\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}", "target": 1}
{"code": "cib_recv_plaintext(int sock)\n{\n    char *buf = NULL;\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = 512;\n    buf = calloc(1, chunk_size);\n    while (1) {\n        errno = 0;\n        rc = read(sock, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n        if (errno == EINTR || errno == EAGAIN) {\n            crm_trace(\"Retry: %d\", (int)rc);\n            if (rc > 0) {\n                len += rc;\n                buf = realloc(buf, len + chunk_size);\n                CRM_ASSERT(buf != NULL);\n            }\n        } else if (rc < 0) {\n            crm_perror(LOG_ERR, \"Error receiving message: %d\", (int)rc);\n            goto bail;\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else {\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n}", "target": 1}
{"code": "int scsi_cmd_blk_ioctl(struct block_device *bd, fmode_t mode,\n\t\t       unsigned int cmd, void __user *arg)\n{\n\tint ret;\n\tret = scsi_verify_blk_ioctl(bd, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn scsi_cmd_ioctl(bd->bd_disk->queue, bd->bd_disk, mode, cmd, arg);\n}", "target": 0}
{"code": "static int manager_setup_time_change(Manager *m) {\n        int r;\n        struct itimerspec its = {\n                .it_value.tv_sec = TIME_T_MAX,\n        };\n        assert(m);\n        assert_cc(sizeof(time_t) == sizeof(TIME_T_MAX));\n        if (m->test_run)\n                return 0;\n        m->time_change_fd = timerfd_create(CLOCK_REALTIME, TFD_NONBLOCK|TFD_CLOEXEC);\n        if (m->time_change_fd < 0)\n                return log_error_errno(errno, \"Failed to create timerfd: %m\");\n        if (timerfd_settime(m->time_change_fd, TFD_TIMER_ABSTIME|TFD_TIMER_CANCEL_ON_SET, &its, NULL) < 0) {\n                log_debug_errno(errno, \"Failed to set up TFD_TIMER_CANCEL_ON_SET, ignoring: %m\");\n                m->time_change_fd = safe_close(m->time_change_fd);\n                return 0;\n        }\n        r = sd_event_add_io(m->event, &m->time_change_event_source, m->time_change_fd, EPOLLIN, manager_dispatch_time_change_fd, m);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to create time change event source: %m\");\n        log_debug(\"Set up TFD_TIMER_CANCEL_ON_SET timerfd.\");\n        return 0;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_buffer_size( const bson *b ) {\n    return (b->cur - b->data + 1);\n}", "target": 1}
{"code": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tinit_emulate_ctxt(vcpu);\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\treturn r;\n}", "target": 1}
{"code": "unique_ptr<IOBuf> IOBuf::createCombined(std::size_t capacity) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t requiredStorage = offsetof(HeapFullStorage, align) + capacity;\n  size_t mallocSize = goodMallocSize(requiredStorage);\n  auto storage = static_cast<HeapFullStorage*>(checkedMalloc(mallocSize));\n  new (&storage->hs.prefix) HeapPrefix(kIOBufInUse | kDataInUse, mallocSize);\n  new (&storage->shared) SharedInfo(freeInternalBuf, storage);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, mallocSize);\n  }\n  auto bufAddr = reinterpret_cast<uint8_t*>(&storage->align);\n  uint8_t* storageEnd = reinterpret_cast<uint8_t*>(storage) + mallocSize;\n  auto actualCapacity = size_t(storageEnd - bufAddr);\n  unique_ptr<IOBuf> ret(new (&storage->hs.buf) IOBuf(\n      InternalConstructor(),\n      packFlagsAndSharedInfo(0, &storage->shared),\n      bufAddr,\n      actualCapacity,\n      bufAddr,\n      0));\n  return ret;\n}", "target": 0}
{"code": "spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n\t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n\t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n{\n    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n\t\t\t\t  iov_count);\n}", "target": 1}
{"code": "struct mb2_cache *mb2_cache_create(int bucket_bits)\n{\n\tstruct mb2_cache *cache;\n\tint bucket_count = 1 << bucket_bits;\n\tint i;\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn NULL;\n\tcache = kzalloc(sizeof(struct mb2_cache), GFP_KERNEL);\n\tif (!cache)\n\t\tgoto err_out;\n\tcache->c_bucket_bits = bucket_bits;\n\tINIT_LIST_HEAD(&cache->c_lru_list);\n\tspin_lock_init(&cache->c_lru_list_lock);\n\tcache->c_hash = kmalloc(bucket_count * sizeof(struct hlist_bl_head),\n\t\t\t\tGFP_KERNEL);\n\tif (!cache->c_hash) {\n\t\tkfree(cache);\n\t\tgoto err_out;\n\t}\n\tfor (i = 0; i < bucket_count; i++)\n\t\tINIT_HLIST_BL_HEAD(&cache->c_hash[i]);\n\tcache->c_shrink.count_objects = mb2_cache_count;\n\tcache->c_shrink.scan_objects = mb2_cache_scan;\n\tcache->c_shrink.seeks = DEFAULT_SEEKS;\n\tregister_shrinker(&cache->c_shrink);\n\treturn cache;\nerr_out:\n\tmodule_put(THIS_MODULE);\n\treturn NULL;\n}", "target": 0}
{"code": "static void packet_dev_mclist_delete(struct net_device *dev,\n\t\t\t\t     struct packet_mclist **mlp)\n{\n\tstruct packet_mclist *ml;\n\twhile ((ml = *mlp) != NULL) {\n\t\tif (ml->ifindex == dev->ifindex) {\n\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\t\t*mlp = ml->next;\n\t\t\tkfree(ml);\n\t\t} else\n\t\t\tmlp = &ml->next;\n\t}\n}", "target": 0}
{"code": "static void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->n);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->qp);\n\tcrypto_bignum_free(key->dp);\n\tcrypto_bignum_free(key->dq);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() == 2,\n        errors::InvalidArgument(absl::StrCat(\n            \"Shape must be rank 2 but is rank \", sorted_inputs_t.shape().dims(),\n            \" for \"\n            \"`sorted_inputs` argument\")));\n    OP_REQUIRES(ctx, values_t.shape().dims() == 2,\n                errors::InvalidArgument(absl::StrCat(\n                    \"Shape must be rank 2 but is rank \",\n                    values_t.shape().dims(), \" for `values` argument\")));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::UpperBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "ref_stack_pop_block(ref_stack_t *pstack)\n{\n    s_ptr bot = pstack->bot;\n    uint count = pstack->p + 1 - bot;\n    ref_stack_block *pcur =\n    (ref_stack_block *) pstack->current.value.refs;\n    ref_stack_block *pnext =\n    (ref_stack_block *) pcur->next.value.refs;\n    uint used;\n    ref *body;\n    ref next;\n    if (pnext == 0)\n        return_error(pstack->params->underflow_error);\n    used = r_size(&pnext->used);\n    body = (ref *) (pnext + 1) + pstack->params->bot_guard;\n    next = pcur->next;\n    if (used + count > pstack->body_size) {\n        uint moved = pstack->body_size - count;\n        uint left;\n        if (moved == 0)\n            return_error(gs_error_Fatal);\n        memmove(bot + moved, bot, count * sizeof(ref));\n        left = used - moved;\n        memcpy(bot, body + left, moved * sizeof(ref));\n        refset_null_new(body + left, moved, 0);\n        r_dec_size(&pnext->used, moved);\n        pstack->p = pstack->top;\n        pstack->extension_used -= moved;\n    } else {\n        memcpy(body + used, bot, count * sizeof(ref));\n        pstack->bot = bot = body;\n        pstack->top = bot + pstack->body_size - 1;\n        gs_free_ref_array(pstack->memory, &pstack->current,\n                          \"ref_stack_pop_block\");\n        pstack->current = next;\n        pstack->p = bot + (used + count - 1);\n        pstack->extension_size -= pstack->body_size;\n        pstack->extension_used -= used;\n    }\n    return 0;\n}", "target": 0}
{"code": "static gpa_t FNAME(gva_to_gpa_nested)(struct kvm_vcpu *vcpu, gva_t vaddr,\n\t\t\t\t      u32 access,\n\t\t\t\t      struct x86_exception *exception)\n{\n\tstruct guest_walker walker;\n\tgpa_t gpa = UNMAPPED_GVA;\n\tint r;\n\tr = FNAME(walk_addr_nested)(&walker, vcpu, vaddr, access);\n\tif (r) {\n\t\tgpa = gfn_to_gpa(walker.gfn);\n\t\tgpa |= vaddr & ~PAGE_MASK;\n\t} else if (exception)\n\t\t*exception = walker.fault;\n\treturn gpa;\n}", "target": 0}
{"code": "int con_set_default_unimap(struct vc_data *vc)\n{\n\tint i, j, err = 0, err1;\n\tu16 *q;\n\tstruct uni_pagedir *p;\n\tif (dflt) {\n\t\tp = *vc->vc_uni_pagedir_loc;\n\t\tif (p == dflt)\n\t\t\treturn 0;\n\t\tdflt->refcount++;\n\t\t*vc->vc_uni_pagedir_loc = dflt;\n\t\tif (p && !--p->refcount) {\n\t\t\tcon_release_unimap(p);\n\t\t\tkfree(p);\n\t\t}\n\t\treturn 0;\n\t}\n\terr = con_do_clear_unimap(vc);\n\tif (err)\n\t\treturn err;\n\tp = *vc->vc_uni_pagedir_loc;\n\tq = dfont_unitable;\n\tfor (i = 0; i < 256; i++)\n\t\tfor (j = dfont_unicount[i]; j; j--) {\n\t\t\terr1 = con_insert_unipair(p, *(q++), i);\n\t\t\tif (err1)\n\t\t\t\terr = err1;\n\t\t}\n\tif (con_unify_unimap(vc, p)) {\n\t\tdflt = *vc->vc_uni_pagedir_loc;\n\t\treturn err;\n\t}\n\tfor (i = 0; i <= 3; i++)\n\t\tset_inverse_transl(vc, p, i);\t\n\tset_inverse_trans_unicode(vc, p);\n\tdflt = p;\n\treturn err;\n}", "target": 0}
{"code": "void APE::Properties::analyzeCurrent()\n{\n  d->file->seek(2, File::Current);\n  ByteVector descriptor = d->file->readBlock(44);\n  uint descriptorBytes = descriptor.mid(0,4).toUInt(false);\n  if ((descriptorBytes - 52) > 0)\n    d->file->seek(descriptorBytes - 52, File::Current);\n  ByteVector header = d->file->readBlock(24);\n  d->channels = header.mid(18, 2).toShort(false);\n  d->sampleRate = header.mid(20, 4).toUInt(false);\n  d->bitsPerSample = header.mid(16, 2).toShort(false);\n  uint totalFrames = header.mid(12, 4).toUInt(false);\n  uint blocksPerFrame = header.mid(4, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(8, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks / d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}", "target": 1}
{"code": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n        if (rom->romsize > rom->datasize) {\n            d += l;\n            l = rom->romsize - rom->datasize;\n            if ((d + l) > (dest + size)) {\n                l = dest - d;\n            }\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n    return (d + l) - dest;\n}", "target": 1}
{"code": "int CLASS parse_jpeg(int offset)\n{\n  int len, save, hlen, mark;\n  fseek(ifp, offset, SEEK_SET);\n  if (fgetc(ifp) != 0xff || fgetc(ifp) != 0xd8)\n    return 0;\n  while (fgetc(ifp) == 0xff && (mark = fgetc(ifp)) != 0xda)\n  {\n    order = 0x4d4d;\n    len = get2() - 2;\n    save = ftell(ifp);\n    if (mark == 0xc0 || mark == 0xc3 || mark == 0xc9)\n    {\n      fgetc(ifp);\n      raw_height = get2();\n      raw_width = get2();\n    }\n    order = get2();\n    hlen = get4();\n    if (get4() == 0x48454150) \n    {\n#ifdef LIBRAW_LIBRARY_BUILD\n      imgdata.lens.makernotes.CameraMount = LIBRAW_MOUNT_FixedLens;\n      imgdata.lens.makernotes.LensMount = LIBRAW_MOUNT_FixedLens;\n#endif\n      parse_ciff(save + hlen, len - hlen, 0);\n    }\n    if (parse_tiff(save + 6))\n      apply_tiff();\n    fseek(ifp, save + len, SEEK_SET);\n  }\n  return 1;\n}", "target": 1}
{"code": "static int kvm_set_guest_paused(struct kvm_vcpu *vcpu)\n{\n\tif (!vcpu->arch.time_page)\n\t\treturn -EINVAL;\n\tvcpu->arch.pvclock_set_guest_stopped_request = true;\n\tkvm_make_request(KVM_REQ_CLOCK_UPDATE, vcpu);\n\treturn 0;\n}", "target": 1}
{"code": "pci_get_cfgdata32(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\treturn (*(uint32_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n\t}\n}", "target": 1}
{"code": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  int output_height = input_height / block_size;\n  int output_width = input_width / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height * block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width * block_size);\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = input->dims->data[3] * block_size * block_size;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 0}
{"code": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tint ret;\n\tif (current_chrooted())\n\t\treturn -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\tset_cred_user_ns(new, ns);\n\treturn 0;\n}", "target": 0}
{"code": "TEST_P(TcpTunnelingIntegrationTest, UpstreamConnectingDownstreamDisconnect) {\n  if (upstreamProtocol() == Http::CodecType::HTTP1) {\n    return;\n  }\n#if defined(WIN32)\n  return;\n#endif\n  config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {\n    envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;\n    proxy_config.set_stat_prefix(\"tcp_stats\");\n    proxy_config.set_cluster(\"cluster_0\");\n    proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");\n    proxy_config.mutable_max_connect_attempts()->set_value(2);\n    auto* listeners = bootstrap.mutable_static_resources()->mutable_listeners();\n    for (auto& listener : *listeners) {\n      if (listener.name() != \"tcp_proxy\") {\n        continue;\n      }\n      auto* filter_chain = listener.mutable_filter_chains(0);\n      auto* filter = filter_chain->mutable_filters(0);\n      filter->mutable_typed_config()->PackFrom(proxy_config);\n      envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n      ConfigHelper::initializeTls({}, *tls_context.mutable_common_tls_context());\n      filter_chain->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n      filter_chain->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);\n      break;\n    }\n  });\n  enableHalfClose(false);\n  initialize();\n  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n  tcp_client->close();\n  ASSERT_TRUE(upstream_request_->waitForReset());\n  ASSERT_TRUE(fake_upstream_connection_->close());\n}", "target": 0}
{"code": "YCPBoolean as_boolean (const YCPValue& v, const char * context)\n{\n    if (v->isBoolean ())\n\treturn v->asBoolean ();\n    ycp2error (\"Expected a boolean for %s, got %s %s\",\n\t       context, v->valuetype_str(), v->toString().c_str());\n    return YCPNull ();\n}", "target": 0}
{"code": "static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\treturn ret;\n}", "target": 1}
{"code": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "DLLIMPORT int cfg_setint(cfg_t *cfg, const char *name, long int value)\n{\n\treturn cfg_setnint(cfg, name, value, 0);\n}", "target": 0}
{"code": "static BOOL gdi_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,\n                                  const BYTE* pSrcData, UINT32 DstWidth, UINT32 DstHeight,\n                                  UINT32 bpp, UINT32 length, BOOL compressed,\n                                  UINT32 codecId)\n{\n\tUINT32 SrcSize = length;\n\trdpGdi* gdi = context->gdi;\n\tbitmap->compressed = FALSE;\n\tbitmap->format = gdi->dstFormat;\n\tbitmap->length = DstWidth * DstHeight * GetBytesPerPixel(bitmap->format);\n\tbitmap->data = (BYTE*) _aligned_malloc(bitmap->length, 16);\n\tif (!bitmap->data)\n\t\treturn FALSE;\n\tif (compressed)\n\t{\n\t\tif (bpp < 32)\n\t\t{\n\t\t\tif (!interleaved_decompress(context->codecs->interleaved,\n\t\t\t                            pSrcData, SrcSize,\n\t\t\t                            DstWidth, DstHeight,\n\t\t\t                            bpp,\n\t\t\t                            bitmap->data, bitmap->format,\n\t\t\t                            0, 0, 0, DstWidth, DstHeight,\n\t\t\t                            &gdi->palette))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (!planar_decompress(context->codecs->planar, pSrcData, SrcSize,\n\t\t\t                       DstWidth, DstHeight,\n\t\t\t                       bitmap->data, bitmap->format, 0, 0, 0,\n\t\t\t                       DstWidth, DstHeight, TRUE))\n\t\t\t\treturn FALSE;\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst UINT32 SrcFormat = gdi_get_pixel_format(bpp);\n\t\tconst size_t sbpp = GetBytesPerPixel(SrcFormat);\n\t\tconst size_t dbpp = GetBytesPerPixel(bitmap->format);\n\t\tif ((sbpp == 0) || (dbpp == 0))\n\t\t\treturn FALSE;\n\t\telse\n\t\t{\n\t\t\tconst size_t dstSize = SrcSize * dbpp / sbpp;\n\t\t\tif (dstSize  < bitmap->length)\n\t\t\t\treturn FALSE;\n\t\t}\n\t\tif (!freerdp_image_copy(bitmap->data, bitmap->format, 0, 0, 0,\n\t\t                        DstWidth, DstHeight, pSrcData, SrcFormat,\n\t\t                        0, 0, 0, &gdi->palette, FREERDP_FLIP_VERTICAL))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "bool ArcMemory::Tell(int64 *Pos)\n{\n  if (!Loaded)\n    return false;\n  *Pos=SeekPos;\n  return true;\n}", "target": 0}
{"code": "smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\n\tint rc;\n\tunsigned char key2[8];\n\tstruct crypto_skcipher *tfm_des;\n\tstruct scatterlist sgin, sgout;\n\tstruct skcipher_request *req;\n\tstr_to_key(key, key2);\n\ttfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_des)) {\n\t\trc = PTR_ERR(tfm_des);\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_err;\n\t}\n\treq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_free_skcipher;\n\t}\n\tcrypto_skcipher_setkey(tfm_des, key2, 8);\n\tsg_init_one(&sgin, in, 8);\n\tsg_init_one(&sgout, out, 8);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\n\trc = crypto_skcipher_encrypt(req);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);\n\tskcipher_request_free(req);\nsmbhash_free_skcipher:\n\tcrypto_free_skcipher(tfm_des);\nsmbhash_err:\n\treturn rc;\n}", "target": 1}
{"code": "void pid_ns_release_proc(struct pid_namespace *ns)\n{\n\tmntput(ns->proc_mnt);\n}", "target": 1}
{"code": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char *print_buffer;\n    print_buffer = curlx_mvaprintf(fmt, ap);\n    if(!print_buffer)\n      return;\n    len = strlen(print_buffer);\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n      if(len > width) {\n        size_t cut = width-1;\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          cut = width-1;\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut + 1; \n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n    curl_free(print_buffer);\n  }\n}", "target": 1}
{"code": "static inline void init_idle_pids(struct pid_link *links)\n{\n\tenum pid_type type;\n\tfor (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {\n\t\tINIT_HLIST_NODE(&links[type].node); \n\t\tlinks[type].pid = &init_struct_pid;\n\t}\n}", "target": 0}
{"code": "smb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n\tstruct socket *ssocket = server->ssocket;\n\tint val = 1;\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\tcFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);\n\tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\ttotal_len += sent;\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\ttotal_len += sent;\n\t}\nuncork:\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcFYI(1, \"partial send (wanted=%u sent=%zu): terminating \"\n\t\t\t\"session\", smb_buf_length + 4, total_len);\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\tif (rc < 0 && rc != -EINTR)\n\t\tcERROR(1, \"Error %d sending data on socket to server\", rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}", "target": 0}
{"code": "smtp_log_no_mail(void)\n{\nint i;\nuschar * sep, * s;\ngstring * g = NULL;\nif (smtp_mailcmd_count > 0 || !LOGGING(smtp_no_mail))\n  return;\nif (sender_host_authenticated)\n  {\n  g = string_append(g, 2, US\" A=\", sender_host_authenticated);\n  if (authenticated_id) g = string_append(g, 2, US\":\", authenticated_id);\n  }\n#ifdef SUPPORT_TLS\ng = s_tlslog(g);\n#endif\nsep = smtp_connection_had[SMTP_HBUFF_SIZE-1] != SCH_NONE ?  US\" C=...\" : US\" C=\";\nfor (i = smtp_ch_index; i < SMTP_HBUFF_SIZE; i++)\n  if (smtp_connection_had[i] != SCH_NONE)\n    {\n    g = string_append(g, 2, sep, smtp_names[smtp_connection_had[i]]);\n    sep = US\",\";\n    }\nfor (i = 0; i < smtp_ch_index; i++)\n  {\n  g = string_append(g, 2, sep, smtp_names[smtp_connection_had[i]]);\n  sep = US\",\";\n  }\nif (!(s = string_from_gstring(g))) s = US\"\";\nlog_write(0, LOG_MAIN, \"no MAIL in %sSMTP connection from %s D=%s%s\",\n  f.tcp_in_fastopen ? f.tcp_in_fastopen_data ? US\"TFO* \" : US\"TFO \" : US\"\",\n  host_and_ident(FALSE), string_timesince(&smtp_connection_start), s);\n}", "target": 0}
{"code": "TensorBuffer* FromProtoField<ResourceHandle>(Allocator* a,\n                                             const TensorProto& in, int64_t n) {\n  CHECK_GT(n, 0);\n  Buffer<ResourceHandle>* buf = new Buffer<ResourceHandle>(a, n);\n  ResourceHandle* data = buf->template base<ResourceHandle>();\n  if (data == nullptr) {\n    buf->Unref();\n    return nullptr;\n  }\n  const int64_t in_n = ProtoHelper<ResourceHandle>::NumElements(in);\n  if (in_n <= 0) {\n    std::fill_n(data, n, ResourceHandle());\n  } else {\n    const int64_t real_n = n < in_n ? n : in_n;\n    for (int64_t i = 0; i < real_n; ++i) {\n      Status s = ResourceHandle::BuildResourceHandle(in.resource_handle_val(i),\n                                                     &data[i]);\n      if (!s.ok()) {\n        LOG(ERROR) << \"Could not decode resource handle from proto \\\"\"\n                   << in.resource_handle_val(i).ShortDebugString()\n                   << \"\\\", returned status: \" << s.ToString();\n        buf->Unref();\n        return nullptr;\n      }\n    }\n    for (int64_t i = in_n; i < n; ++i) {\n      data[i] = ResourceHandle();\n    }\n  }\n  return buf;\n}", "target": 0}
{"code": "void ServerSecurityFeature::collectOptions(\n    std::shared_ptr<ProgramOptions> options) {\n  options\n      ->addOption(\n          \"--server.harden\",\n          \"lock down REST APIs that reveal version information or server \"\n          \"internals for non-admin users\",\n          new BooleanParameter(&_hardenedRestApi))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\"--foxx.api\", \"enables Foxx management REST APIs\",\n                  new BooleanParameter(&_enableFoxxApi),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\"--foxx.store\", \"enables Foxx store in web interface\",\n                  new BooleanParameter(&_enableFoxxStore),\n                  arangodb::options::makeFlags(\n                      arangodb::options::Flags::DefaultNoComponents,\n                      arangodb::options::Flags::OnCoordinator,\n                      arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30500);\n  options\n      ->addOption(\n          \"--foxx.allow-install-from-remote\",\n          \"allow installing Foxx apps from remote URLs other than Github\",\n          new BooleanParameter(&_foxxAllowInstallFromRemote),\n          arangodb::options::makeFlags(\n              arangodb::options::Flags::DefaultNoComponents,\n              arangodb::options::Flags::OnCoordinator,\n              arangodb::options::Flags::OnSingle))\n      .setIntroducedIn(30805);\n}", "target": 0}
{"code": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\treturn true;\n}", "target": 1}
{"code": "static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\nout:\n\tkfree(same);\n\treturn ret;\n}", "target": 0}
{"code": "bool test_r_str_escape_sh(void) {\n\tchar *escaped = r_str_escape_sh (\"Hello, \\\"World\\\"\");\n\tmu_assert_streq (escaped, \"Hello, \\\\\\\"World\\\\\\\"\", \"escaped \\\"double quotes\\\"\");\n\tfree (escaped);\n\tescaped = r_str_escape_sh (\"Hello, \\\\World\\\\\");\n\tmu_assert_streq (escaped, \"Hello, \\\\\\\\World\\\\\\\\\", \"escaped backspace\");\n\tfree (escaped);\n#if __UNIX__\n\tescaped = r_str_escape_sh (\"Hello, $(World)\");\n\tmu_assert_streq (escaped, \"Hello, \\\\$(World)\", \"escaped $(command)\");\n\tfree (escaped);\n\tescaped = r_str_escape_sh (\"Hello, `World`\");\n\tmu_assert_streq (escaped, \"Hello, \\\\`World\\\\`\", \"escaped `command`\");\n\tfree (escaped);\n#endif\n\tmu_end;\n}", "target": 0}
{"code": "void vlan_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n\tdev->tx_queue_len\t= 0;\n\tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}", "target": 1}
{"code": "mrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb_free(mrb, p);\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n  return p2;\n}", "target": 1}
{"code": "static bool add_ref_to_table_cond(THD *thd, JOIN_TAB *join_tab)\n{\n  DBUG_ENTER(\"add_ref_to_table_cond\");\n  if (!join_tab->ref.key_parts)\n    DBUG_RETURN(FALSE);\n  Item_cond_and *cond= new (thd->mem_root) Item_cond_and(thd);\n  TABLE *table=join_tab->table;\n  int error= 0;\n  if (!cond)\n    DBUG_RETURN(TRUE);\n  for (uint i=0 ; i < join_tab->ref.key_parts ; i++)\n  {\n    Field *field=table->field[table->key_info[join_tab->ref.key].key_part[i].\n\t\t\t      fieldnr-1];\n    Item *value=join_tab->ref.items[i];\n    cond->add(new (thd->mem_root)\n              Item_func_equal(thd, new (thd->mem_root) Item_field(thd, field),\n                              value),\n              thd->mem_root);\n  }\n  if (thd->is_fatal_error)\n    DBUG_RETURN(TRUE);\n  if (!cond->fixed)\n  {\n    Item *tmp_item= (Item*) cond;\n    cond->fix_fields(thd, &tmp_item);\n    DBUG_ASSERT(cond == tmp_item);\n  }\n  if (join_tab->select)\n  {\n    Item *UNINIT_VAR(cond_copy);\n    if (join_tab->select->pre_idx_push_select_cond)\n      cond_copy= cond->copy_andor_structure(thd);\n    if (join_tab->select->cond)\n      error=(int) cond->add(join_tab->select->cond, thd->mem_root);\n    join_tab->select->cond= cond;\n    if (join_tab->select->pre_idx_push_select_cond)\n    {\n      Item *new_cond= and_conds(thd, cond_copy,\n                                join_tab->select->pre_idx_push_select_cond);\n      if (!new_cond->fixed && new_cond->fix_fields(thd, &new_cond))\n        error= 1;\n      join_tab->pre_idx_push_select_cond=\n        join_tab->select->pre_idx_push_select_cond= new_cond;\n    }\n    join_tab->set_select_cond(cond, __LINE__);\n  }\n  else if ((join_tab->select= make_select(join_tab->table, 0, 0, cond,\n                                          (SORT_INFO*) 0, 0, &error)))\n    join_tab->set_select_cond(cond, __LINE__);\n  DBUG_RETURN(error ? TRUE : FALSE);\n}", "target": 0}
{"code": "static int fts3ExprGlobalHitsCb(\n  Fts3Expr *pExpr,                \n  int iPhrase,                    \n  void *pCtx                      \n){\n  MatchInfo *p = (MatchInfo *)pCtx;\n  return sqlite3Fts3EvalPhraseStats(\n      p->pCursor, pExpr, &p->aMatchinfo[3*iPhrase*p->nCol]\n  );\n}", "target": 0}
{"code": "static int __init setup_psi(char *str)\n{\n\treturn kstrtobool(str, &psi_enable) == 0;\n}", "target": 0}
{"code": "void unbind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    s_poll_init(fds, 1);\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n    opt=service_options.next;\n    service_options.next=NULL;\n    service_free(&service_options);\n    while(opt) {\n        unsigned i;\n        s_log(LOG_DEBUG, \"Unbinding service [%s]\", opt->servname);\n        for(i=0; i<opt->local_addr.num; ++i)\n            unbind_port(opt, i);\n        if(opt->exec_name && opt->connect_addr.names) {\n            opt->option.retry=0;\n        }\n        if(opt->ctx)\n            SSL_CTX_flush_sessions(opt->ctx,\n                (long)time(NULL)+opt->session_timeout+1);\n        s_log(LOG_DEBUG, \"Service [%s] closed\", opt->servname);\n        {\n            SERVICE_OPTIONS *garbage=opt;\n            opt=opt->next;\n            garbage->next=NULL;\n            service_free(garbage);\n        }\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}", "target": 1}
{"code": "static void handle_get_accept(struct http_conn *conn,\n\t\t\t      const struct http_msg *msg,\n\t\t\t      struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\tinfo(\"handle get accept\\n\");\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"accept: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"handle get accept (content=%s)\\n\", ie->content.accept);\n\tif (ie->content.accept) {\n\t\thttp_creply(conn, 200, \"OK\",\n\t\t\t    \"application/json\", \"%s\", ie->content.accept);\n\t}\n\telse {\n\t\thttp_ereply(conn, 404, \"Not Yet\");\n\t}\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "static struct btrfs_fs_devices *find_fsid_changed(\n\t\t\t\t\tstruct btrfs_super_block *disk_super)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\tlist_for_each_entry(fs_devices, &fs_uuids, fs_list) {\n\t\tif (memcmp(fs_devices->metadata_uuid, fs_devices->fsid,\n\t\t\t   BTRFS_FSID_SIZE) != 0 &&\n\t\t    memcmp(fs_devices->metadata_uuid, disk_super->metadata_uuid,\n\t\t\t   BTRFS_FSID_SIZE) == 0 &&\n\t\t    memcmp(fs_devices->fsid, disk_super->fsid,\n\t\t\t   BTRFS_FSID_SIZE) != 0) {\n\t\t\treturn fs_devices;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "TfLiteStatus ReluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  ReluOpData* data = static_cast<ReluOpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  if (input->type == kTfLiteInt8) {\n    CalculateReluOpData<int8_t>(input, output, data);\n  } else if (input->type == kTfLiteUInt8) {\n    CalculateReluOpData<uint8_t>(input, output, data);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "lha_read_file_header_1(struct archive_read *a, struct lha *lha)\n{\n\tconst unsigned char *p;\n\tsize_t extdsize;\n\tint i, err, err2;\n\tint namelen, padding;\n\tunsigned char headersum, sum_calculated;\n\terr = ARCHIVE_OK;\n\tif ((p = __archive_read_ahead(a, H1_FIXED_SIZE, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tlha->header_size = p[H1_HEADER_SIZE_OFFSET] + 2;\n\theadersum = p[H1_HEADER_SUM_OFFSET];\n\tlha->compsize = archive_le32dec(p + H1_COMP_SIZE_OFFSET);\n\tlha->origsize = archive_le32dec(p + H1_ORIG_SIZE_OFFSET);\n\tlha->mtime = lha_dos_time(p + H1_DOS_TIME_OFFSET);\n\tnamelen = p[H1_NAME_LEN_OFFSET];\n\tpadding = ((int)lha->header_size) - H1_FIXED_SIZE - namelen;\n\tif (namelen > 230 || padding < 0)\n\t\tgoto invalid;\n\tif ((p = __archive_read_ahead(a, lha->header_size, NULL)) == NULL)\n\t\treturn (truncated_error(a));\n\tfor (i = 0; i < namelen; i++) {\n\t\tif (p[i + H1_FILE_NAME_OFFSET] == 0xff)\n\t\t\tgoto invalid;\n\t}\n\tarchive_strncpy(&lha->filename, p + H1_FILE_NAME_OFFSET, namelen);\n\tlha->crc = archive_le16dec(p + H1_FILE_NAME_OFFSET + namelen);\n\tlha->setflag |= CRC_IS_SET;\n\tsum_calculated = lha_calcsum(0, p, 2, lha->header_size - 2);\n\t__archive_read_consume(a, lha->header_size - 2);\n\terr2 = lha_read_file_extended_header(a, lha, NULL, 2,\n\t    (size_t)(lha->compsize + 2), &extdsize);\n\tif (err2 < ARCHIVE_WARN)\n\t\treturn (err2);\n\tif (err2 < err)\n\t\terr = err2;\n\tlha->compsize -= extdsize - 2;\n\tif (lha->compsize < 0)\n\t\tgoto invalid;\t\n\tif (sum_calculated != headersum) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"LHa header sum error\");\n\t\treturn (ARCHIVE_FATAL);\n\t}\n\treturn (err);\ninvalid:\n\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n\t    \"Invalid LHa header\");\n\treturn (ARCHIVE_FATAL);\n}", "target": 0}
{"code": "name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n\tfor (;;) {\n\t\tu8 label_len;\n\t\tif (j >= length) return -1;\n\t\tGET8(label_len);\n\t\tif (!label_len) break;\n\t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n\t\t\t*cp++ = '.';\n\t\t}\n\t\tif (cp + label_len >= end) return -1;\n\t\tmemcpy(cp, packet + j, label_len);\n\t\tcp += label_len;\n\t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}", "target": 1}
{"code": "srs_timestamp_check(srs_t *srs, const char *stamp)\n{\n\tconst char\t*sp;\n\tchar\t\t*bp;\n\tint\t\t\t off;\n\ttime_t\t\t now;\n\ttime_t\t\t then;\n\tif (strlen(stamp) != 2) return SRS_ETIMESTAMPOUTOFDATE;\n\tthen = 0;\n\tfor (sp = stamp; *sp; sp++) {\n\t\tbp = strchr(SRS_TIME_BASECHARS, toupper(*sp));\n\t\tif (bp == NULL)\n\t\t\treturn SRS_EBADTIMESTAMPCHAR;\n\t\toff = bp - SRS_TIME_BASECHARS;\n\t\tthen = (then << SRS_TIME_BASEBITS) | off;\n\t}\n\ttime(&now);\n\tnow = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS;\n\twhile (now < then)\n\t\tnow = now + SRS_TIME_SLOTS;\n\tif (now <= then + srs->maxage)\n\t\treturn SRS_SUCCESS;\n\treturn SRS_ETIMESTAMPOUTOFDATE;\n}", "target": 0}
{"code": "static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t   int fromlen, unsigned char *to)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tunsigned char *p = to;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\tcase 2:\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n\t\t\t\t\t      pc->lengthComponentIdent);\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n}", "target": 1}
{"code": "static inline FILE *xfmkstemp(char **tmpname, char *dir)\n{\n\tint fd;\n\tFILE *ret;\n\tfd = xmkstemp(tmpname, dir);\n\tif (fd == -1)\n\t\treturn NULL;\n\tif (!(ret = fdopen(fd, \"w+\" UL_CLOEXECSTR))) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "vrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tdump_data_vrrp(file);\n\tfclose(file);\n}", "target": 1}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "static void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n\tdev->features |= NETIF_F_LLTX;\n\tdev->destructor = veth_dev_free;\n\tdev->hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM;\n}", "target": 0}
{"code": "void tcp_rcv_space_adjust(struct sock *sk)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint time;\n\tint copied;\n\ttime = tcp_time_stamp - tp->rcvq_space.time;\n\tif (time < (tp->rcv_rtt_est.rtt >> 3) || tp->rcv_rtt_est.rtt == 0)\n\t\treturn;\n\tcopied = tp->copied_seq - tp->rcvq_space.seq;\n\tif (copied <= tp->rcvq_space.space)\n\t\tgoto new_measure;\n\tif (sysctl_tcp_moderate_rcvbuf &&\n\t    !(sk->sk_userlocks & SOCK_RCVBUF_LOCK)) {\n\t\tint rcvwin, rcvmem, rcvbuf;\n\t\trcvwin = (copied << 1) + 16 * tp->advmss;\n\t\tif (copied >=\n\t\t    tp->rcvq_space.space + (tp->rcvq_space.space >> 2)) {\n\t\t\tif (copied >=\n\t\t\t    tp->rcvq_space.space + (tp->rcvq_space.space >> 1))\n\t\t\t\trcvwin <<= 1;\n\t\t\telse\n\t\t\t\trcvwin += (rcvwin >> 1);\n\t\t}\n\t\trcvmem = SKB_TRUESIZE(tp->advmss + MAX_TCP_HEADER);\n\t\twhile (tcp_win_from_space(rcvmem) < tp->advmss)\n\t\t\trcvmem += 128;\n\t\trcvbuf = min(rcvwin / tp->advmss * rcvmem, sysctl_tcp_rmem[2]);\n\t\tif (rcvbuf > sk->sk_rcvbuf) {\n\t\t\tsk->sk_rcvbuf = rcvbuf;\n\t\t\ttp->window_clamp = rcvwin;\n\t\t}\n\t}\n\ttp->rcvq_space.space = copied;\nnew_measure:\n\ttp->rcvq_space.seq = tp->copied_seq;\n\ttp->rcvq_space.time = tcp_time_stamp;\n}", "target": 0}
{"code": "const FieldID& activeUnionMemberId(const void* object, ptrdiff_t offset) {\n  return *reinterpret_cast<const FieldID*>(\n      offset + static_cast<const char*>(object));\n}", "target": 1}
{"code": "ieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ps_data *ps;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    tx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!tx->sdata->bss)\n\t\t\treturn TX_CONTINUE;\n\t\tps = &tx->sdata->bss->ps;\n\t} else if (ieee80211_vif_is_mesh(&tx->sdata->vif)) {\n\t\tps = &tx->sdata->u.mesh.ps;\n\t} else {\n\t\treturn TX_CONTINUE;\n\t}\n\tif (ieee80211_has_order(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\tif (tx->local->hw.flags & IEEE80211_HW_QUEUE_CONTROL)\n\t\tinfo->hw_queue = tx->sdata->vif.cab_queue;\n\tif (!atomic_read(&ps->num_sta_ps))\n\t\treturn TX_CONTINUE;\n\tinfo->flags |= IEEE80211_TX_CTL_SEND_AFTER_DTIM;\n\tif (!(tx->local->hw.flags & IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING))\n\t\treturn TX_CONTINUE;\n\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\tpurge_old_ps_buffers(tx->local);\n\tif (skb_queue_len(&ps->bc_buf) >= AP_MAX_BC_BUFFER) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"BC TX buffer full - dropping the oldest frame\\n\");\n\t\tdev_kfree_skb(skb_dequeue(&ps->bc_buf));\n\t} else\n\t\ttx->local->total_ps_buffered++;\n\tskb_queue_tail(&ps->bc_buf, tx->skb);\n\treturn TX_QUEUED;\n}", "target": 0}
{"code": "mmsMsg_isFilenameSave(const char* filename)\n{\n    if (filename)\n    {\n        if (strstr(filename, \"..\"))\n            return false;\n        if (strstr(filename, \"./\"))\n            return false;\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "target": 0}
{"code": "TEST_P(SslIntegrationTest, LogPeerIpSanUnsupportedIpVersion) {\n  useListenerAccessLog(\"%DOWNSTREAM_PEER_IP_SAN%\");\n  config_helper_.addFilter(\"name: sni-to-header-filter\");\n  ConnectionCreationFunction creator = [&]() -> Network::ClientConnectionPtr {\n    return makeSslClientConnection(ClientSslTransportOptions().setSni(\"host.com\"));\n  };\n  initialize();\n  codec_client_ = makeHttpConnection(\n      makeSslClientConnection(ClientSslTransportOptions().setSni(\"www.host.com\")));\n  auto disabler = (version_ == Network::Address::IpVersion::v4)\n                      ? Network::Address::Ipv6Instance::forceProtocolUnsupportedForTest\n                      : Network::Address::Ipv4Instance::forceProtocolUnsupportedForTest;\n  Cleanup cleaner(disabler(true));\n  Http::TestRequestHeaderMapImpl request_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/\"}, {\":scheme\", \"https\"}, {\":authority\", \"host.com\"}};\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  waitForNextUpstreamRequest();\n  EXPECT_EQ(\"www.host.com\", upstream_request_->headers()\n                                .get(Http::LowerCaseString(\"x-envoy-client-sni\"))[0]\n                                ->value()\n                                .getStringView());\n  Http::TestResponseHeaderMapImpl response_headers{{\":status\", \"200\"}};\n  upstream_request_->encodeHeaders(response_headers, true);\n  RELEASE_ASSERT(response->waitForEndStream(), \"unexpected timeout\");\n  codec_client_->close();\n  checkStats();\n  auto result = waitForAccessLog(listener_access_log_name_);\n  if (version_ == Network::Address::IpVersion::v4) {\n    EXPECT_EQ(result, \"1.2.3.4\");\n  } else {\n    EXPECT_EQ(result, \"0:1:2:3::4\");\n  }\n}", "target": 0}
{"code": "static __init int seqgen_init(void)\n{\n\trekey_seq_generator(NULL);\n\treturn 0;\n}", "target": 1}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}", "target": 1}
{"code": "void blk_mq_all_tag_busy_iter(struct blk_mq_tags *tags, busy_tag_iter_fn *fn,\n\t\tvoid *priv)\n{\n\tif (tags->nr_reserved_tags)\n\t\tbt_tags_for_each(tags, &tags->breserved_tags, 0, fn, priv, true);\n\tbt_tags_for_each(tags, &tags->bitmap_tags, tags->nr_reserved_tags, fn, priv,\n\t\t\tfalse);\n}", "target": 0}
{"code": "static void mspack_fmap_free(void *mem)\n{\n\tfree(mem);\n}", "target": 1}
{"code": "int kvm_deassign_device(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tstruct pci_dev *pdev = NULL;\n\tif (!domain)\n\t\treturn 0;\n\tpdev = assigned_dev->dev;\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\tiommu_detach_device(domain, &pdev->dev);\n\tpci_clear_dev_assigned(pdev);\n\tdev_info(&pdev->dev, \"kvm deassign device\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "int IniParser::write_file(const string & filename, IniSection & section)\n{\n    Pathname pn(filename);\n    PathInfo::assert_dir (pn.dirname ());\n    mode_t file_umask = section.isPrivate()? 0077: 0022;\n    mode_t orig_umask = umask(file_umask);\n    unlink(filename.c_str());\n    ofstream of(filename.c_str());\n    if (!of.good()) {\n        y2error (\"Can not open file %s for write\", filename.c_str());\n        return -1;\n    }\n    write_helper (section, of, 0);\n    of.close();\n    umask(orig_umask);\n    return 0;\n}", "target": 0}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\n    out[outlen] = '\\0';\ndone:\n    if (ret) {\n        safefree(out);\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "local void init_block(s)\n    deflate_state *s;\n{\n    int n; \n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->last_lit = s->matches = 0;\n}", "target": 1}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[1]) << 32) + X[0]);\n}", "target": 1}
{"code": "static int unix_dgram_peer_wake_connect(struct sock *sk, struct sock *other)\n{\n\tstruct unix_sock *u, *u_other;\n\tint rc;\n\tu = unix_sk(sk);\n\tu_other = unix_sk(other);\n\trc = 0;\n\tspin_lock(&u_other->peer_wait.lock);\n\tif (!u->peer_wake.private) {\n\t\tu->peer_wake.private = other;\n\t\t__add_wait_queue(&u_other->peer_wait, &u->peer_wake);\n\t\trc = 1;\n\t}\n\tspin_unlock(&u_other->peer_wait.lock);\n\treturn rc;\n}", "target": 0}
{"code": "static int snmp6_alloc_dev(struct inet6_dev *idev)\n{\n\tif (snmp_mib_init((void __percpu **)idev->stats.ipv6,\n\t\t\t  sizeof(struct ipstats_mib),\n\t\t\t  __alignof__(struct ipstats_mib)) < 0)\n\t\tgoto err_ip;\n\tidev->stats.icmpv6dev = kzalloc(sizeof(struct icmpv6_mib_device),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!idev->stats.icmpv6dev)\n\t\tgoto err_icmp;\n\tidev->stats.icmpv6msgdev = kzalloc(sizeof(struct icmpv6msg_mib_device),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!idev->stats.icmpv6msgdev)\n\t\tgoto err_icmpmsg;\n\treturn 0;\nerr_icmpmsg:\n\tkfree(idev->stats.icmpv6dev);\nerr_icmp:\n\tsnmp_mib_free((void __percpu **)idev->stats.ipv6);\nerr_ip:\n\treturn -ENOMEM;\n}", "target": 0}
{"code": "void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint hstartcol;\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\thstartcol = (numrows + 1 - parity) >> 1;\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tsrcptr += stride;\n\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "u32 gf_isom_find_od_id_for_track(GF_ISOFile *file, u32 track)\n{\n\tu32 i, j, di, the_od_id;\n\tGF_TrackBox *od_tk;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(file, track);\n\tif (!tk) return 0;\n\ti=0;\n\twhile ( (od_tk = (GF_TrackBox*)gf_list_enum(file->moov->trackList, &i))) {\n\t\tif (!od_tk || !od_tk->Media || !od_tk->Media->handler  || !od_tk->Media->information ||\n\t\t\t!od_tk->Media->information->sampleTable || !od_tk->Media->information->sampleTable->SampleSize ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (od_tk->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\t\tfor (j=0; j<od_tk->Media->information->sampleTable->SampleSize->sampleCount; j++) {\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, i, j+1, &di);\n\t\t\tthe_od_id = Media_FindOD_ID(od_tk->Media, samp, tk->Header->trackID);\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tif (the_od_id) return the_od_id;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  CallOpDimensionsFromInputs(const int n, const int h, const int w, const int c,\n                             const int kx, const int ky, const int sx,\n                             const int sy, const string& data_format,\n                             const string& padding) {\n    OpContext op_context;\n    const std::vector<int> x = {n, h, w, c};\n    const std::vector<int> ksize = {1, kx, ky, 1};\n    std::vector<int> strides;\n    if (data_format == \"NHWC\") {\n      strides = {1, sy, sx, 1};\n    } else {\n      strides = {1, 1, sy, sx};\n    }\n    auto& op_info = op_context.op_info;\n    SetCpuDevice(&op_info);\n    op_info.set_op(\"MaxPool\");\n    DescribeTensor4D(x[0], x[1], x[2], x[3], op_info.add_inputs());\n    auto* attr = op_info.mutable_attr();\n    SetAttrValue(data_format, &(*attr)[\"data_format\"]);\n    SetAttrValue(padding, &(*attr)[\"padding\"]);\n    SetAttrValue(strides, &(*attr)[\"strides\"]);\n    SetAttrValue(ksize, &(*attr)[\"ksize\"]);\n    bool found_unknown_shapes;\n    return OpLevelCostEstimator::OpDimensionsFromInputs(\n        op_context.op_info.inputs(0).shape(), op_context.op_info,\n        &found_unknown_shapes);\n  }", "target": 0}
{"code": "sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {\n  newspan->_next = before;\n  newspan->_prev = before->_prev;\n  before->_prev->_next = newspan;\n  before->_prev = newspan;\n}", "target": 1}
{"code": "static BOOL rdp_redirection_read_base64_wchar(UINT32 flag, wStream* s, UINT32* pLength,\n                                              BYTE** pData)\n{\n\tBOOL rc = FALSE;\n\tchar buffer[64] = { 0 };\n\tconst BYTE* ptr = NULL;\n\tif (!rdp_redirection_get_data(s, pLength, &ptr))\n\t\treturn FALSE;\n\tconst WCHAR* wchar = (const WCHAR*)ptr;\n\tsize_t utf8_len = 0;\n\tchar* utf8 = ConvertWCharNToUtf8Alloc(wchar, *pLength, &utf8_len);\n\tif (!utf8)\n\t\tgoto fail;\n\tredirection_free_data(pData, NULL);\n\tutf8_len = strnlen(utf8, utf8_len);\n\t*pData = calloc(utf8_len, sizeof(BYTE));\n\tif (!*pData)\n\t\tgoto fail;\n\tsize_t rlen = utf8_len;\n\tsize_t wpos = 0;\n\tchar* tok = strtok(utf8, \"\\r\\n\");\n\twhile (tok)\n\t{\n\t\tconst size_t len = strnlen(tok, rlen);\n\t\trlen -= len;\n\t\tsize_t bplen = 0;\n\t\tBYTE* bptr = NULL;\n\t\tcrypto_base64_decode(tok, len, &bptr, &bplen);\n\t\tif (!bptr)\n\t\t\tgoto fail;\n\t\tmemcpy(&(*pData)[wpos], bptr, bplen);\n\t\twpos += bplen;\n\t\tfree(bptr);\n\t\ttok = strtok(NULL, \"\\r\\n\");\n\t}\n\t*pLength = wpos;\n\tWLog_DBG(TAG, \"%s:\", rdp_redirection_flags_to_string(flag, buffer, sizeof(buffer)));\n\trc = TRUE;\nfail:\n\tif (!rc)\n\t\tWLog_ERR(TAG, \"failed to read base64 data\");\n\tfree(utf8);\n\treturn rc;\n}", "target": 1}
{"code": "get_html_data (MAPI_Attr *a)\n{\n    VarLenData **body = XCALLOC(VarLenData*, a->num_values + 1);\n    int j;\n    for (j = 0; j < a->num_values; j++)\n    {\n\tbody[j] = XMALLOC(VarLenData, 1);\n\tbody[j]->len = a->values[j].len;\n\tbody[j]->data = CHECKED_XCALLOC(unsigned char, a->values[j].len);\n\tmemmove (body[j]->data, a->values[j].data.buf, body[j]->len);\n    }\n    return body;\n}", "target": 1}
{"code": "int wc_SignatureGenerateHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    return wc_SignatureGenerateHash_ex(hash_type, sig_type, hash_data, hash_len,\n        sig, sig_len, key, key_len, rng, 1);\n}", "target": 0}
{"code": "cpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}", "target": 1}
{"code": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n        g_return_val_if_fail (client != NULL, TRUE);\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n        return TRUE;\n}", "target": 1}
{"code": "static FormatCode getFormatCode(const _AudioFormat &format)\n{\n\tif (format.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\treturn kFloat;\n\tif (format.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\treturn kDouble;\n\tif (format.isInteger())\n\t{\n\t\tswitch (format.bytesPerSample(false))\n\t\t{\n\t\t\tcase 1: return kInt8;\n\t\t\tcase 2: return kInt16;\n\t\t\tcase 3: return kInt24;\n\t\t\tcase 4: return kInt32;\n\t\t}\n\t}\n\tassert(false);\n\treturn kUndefined;\n}", "target": 0}
{"code": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n    return -1;\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageWBMPPtr(gdImagePtr im, int *size, int fg)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageWBMPCtx(im, fg, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "\tChunk *outChunk() { return m_outChunk.get(); }", "target": 0}
{"code": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "RPVector *r_bin_wasm_get_types(RBinWasmObj *bin) {\n\tr_return_val_if_fail (bin && bin->g_sections, NULL);\n\treturn bin->g_types? bin->g_types: parse_unique_subsec_vec_by_id (bin, R_BIN_WASM_SECTION_TYPE);\n}", "target": 0}
{"code": "    std::ostream& DataValue::write(std::ostream& os) const\n    {\n        std::vector<byte>::size_type end = value_.size();\n        for (std::vector<byte>::size_type i = 0; i != end; ++i) {\n            os << static_cast<int>(value_[i]);\n            if (i < end - 1) os << \" \";\n        }\n        return os;\n    }", "target": 0}
{"code": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; \n    if(_members->Get(key,temp) && _isfield(temp)) \n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n\tif (_members->CountUsed() >= MEMBER_MAX_COUNT) {\n\t\treturn false;\n\t}\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); \n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}", "target": 0}
{"code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\ncheck:\n\twhile ((ptr = strstr(dir, \"\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\treturn rpath;\n}", "target": 1}
{"code": "xsltVariableComp(xsltStylesheetPtr style, xmlNodePtr inst) {\n#ifdef XSLT_REFACTORED\n    xsltStyleItemVariablePtr comp;\n#else\n    xsltStylePreCompPtr comp;\n#endif\n    if ((style == NULL) || (inst == NULL) || (inst->type != XML_ELEMENT_NODE))\n\treturn;\n#ifdef XSLT_REFACTORED\n    comp = (xsltStyleItemVariablePtr)\n\txsltNewStylePreComp(style, XSLT_FUNC_VARIABLE);\n#else\n    comp = xsltNewStylePreComp(style, XSLT_FUNC_VARIABLE);\n#endif\n    if (comp == NULL)\n\treturn;\n    inst->psvi = comp;\n    comp->inst = inst;\n    xsltGetQNameProperty(style, inst, BAD_CAST \"name\",\n\t1, &(comp->has_name), &(comp->ns), &(comp->name));\n    if (comp->ns)\n\tcomp->has_ns = 1;\n    comp->select = xsltGetCNsProp(style, inst, (const xmlChar *)\"select\",\n\t                        XSLT_NAMESPACE);\n    if (comp->select != NULL) {\n#ifndef XSLT_REFACTORED\n        xmlNodePtr cur;\n#endif\n\tcomp->comp = xsltXPathCompile(style, comp->select);\n\tif (comp->comp == NULL) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"XSLT-variable: Failed to compile the XPath expression '%s'.\\n\",\n\t\tcomp->select);\n\t    style->errors++;\n\t}\n#ifdef XSLT_REFACTORED\n\tif (inst->children != NULL) {\n\t    xsltTransformError(NULL, style, inst,\n\t\t\"XSLT-variable: There must be no child nodes, since the \"\n\t\t\"attribute 'select' was specified.\\n\");\n\t    style->errors++;\n\t}\n#else\n        for (cur = inst->children; cur != NULL; cur = cur->next) {\n            if (cur->type != XML_COMMENT_NODE &&\n                (cur->type != XML_TEXT_NODE || !xsltIsBlank(cur->content)))\n            {\n                xsltTransformError(NULL, style, inst,\n                    \"XSLT-variable: There must be no child nodes, since the \"\n                    \"attribute 'select' was specified.\\n\");\n                style->errors++;\n            }\n        }\n#endif\n    }\n}", "target": 0}
{"code": "absl::Status CompressTensorAsProto(const tensorflow::Tensor& tensor,\n                                   tensorflow::TensorProto* proto) {\n  if (!IsSupported(tensor.dtype())) {\n    return absl::InvalidArgumentError(absl::StrCat(\n        \"Tensor of dtype \", tensorflow::DataTypeString(tensor.dtype()),\n        \" is not supported for compression.\"));\n  }\n  if (tensor.dtype() == tensorflow::DT_STRING) {\n    tensor.AsProtoTensorContent(proto);\n    return absl::OkStatus();\n  } else {\n    proto->set_dtype(tensor.dtype());\n    tensor.shape().AsProto(proto->mutable_tensor_shape());\n    SnappyCompressFromString(tensor.tensor_data(),\n                             proto->mutable_tensor_content());\n    return absl::OkStatus();\n  }\n}", "target": 0}
{"code": "static void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->id, &x->id, sizeof(p->id));\n\tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n\tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tmemcpy(&p->stats, &x->stats, sizeof(p->stats));\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}", "target": 0}
{"code": "int __ref online_pages(unsigned long pfn, unsigned long nr_pages)\n{\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\tlock_memory_hotplug();\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\targ.status_change_nid = -1;\n\tnid = page_to_nid(pfn_to_page(pfn));\n\tif (node_present_pages(nid) == 0)\n\t\targ.status_change_nid = nid;\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone = page_zone(pfn_to_page(pfn));\n\tmutex_lock(&zonelists_mutex);\n\tif (!populated_zone(zone))\n\t\tneed_zonelists_rebuild = 1;\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tmutex_unlock(&zonelists_mutex);\n\t\tprintk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t       (unsigned long long) pfn << PAGE_SHIFT,\n\t\t       (((unsigned long long) pfn + nr_pages)\n\t\t\t    << PAGE_SHIFT) - 1);\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone->present_pages += onlined_pages;\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tif (need_zonelists_rebuild)\n\t\tbuild_all_zonelists(NULL, zone);\n\telse\n\t\tzone_pcp_update(zone);\n\tmutex_unlock(&zonelists_mutex);\n\tinit_per_zone_wmark_min();\n\tif (onlined_pages) {\n\t\tkswapd_run(zone_to_nid(zone));\n\t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);\n\t}\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tunlock_memory_hotplug();\n\treturn 0;\n}", "target": 1}
{"code": "close_msg_fds(struct VhostUserMsg *msg)\n{\n\tint i;\n\tfor (i = 0; i < msg->fd_num; i++)\n\t\tclose(msg->fds[i]);\n}", "target": 0}
{"code": "void Item_decimal::print(String *str, enum_query_type query_type)\n{\n  my_decimal2string(E_DEC_FATAL_ERROR, &decimal_value, 0, 0, 0, &str_value);\n  str->append(str_value);\n}", "target": 0}
{"code": "int nfc_dep_link_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tif (!dev->ops->dep_link_down)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == false) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_down(dev);\n\tif (!rc) {\n\t\tdev->dep_link_up = false;\n\t\tdev->active_target = NULL;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t\tnfc_llcp_mac_is_down(dev);\n\t\tnfc_genl_dep_link_down_event(dev);\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "uint32_t virtio_config_readb(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldub_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "bool Router::MatchView(const std::string& method, const std::string& url,\n                       bool* stream) {\n  assert(stream != nullptr);\n  *stream = false;\n  for (auto& route : routes_) {\n    if (std::find(route.methods.begin(), route.methods.end(), method) ==\n        route.methods.end()) {\n      continue;\n    }\n    if (route.url.empty()) {\n      std::smatch match;\n      if (std::regex_match(url, match, route.url_regex)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    } else {\n      if (boost::iequals(route.url, url)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(4, context->num_inputs());\n    const Tensor& gradient = context->input(0);\n    const Tensor& input = context->input(1);\n    OP_REQUIRES(context, input.IsSameSize(gradient),\n                InvalidArgument(\"gradient and input must be the same size\"));\n    const Tensor& min = context->input(2);\n    const Tensor& max = context->input(3);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(min.shape()),\n        InvalidArgument(\"`min` must be rank 0 but is rank \", min.dims()));\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(max.shape()),\n        InvalidArgument(\"`max` must be rank 0 but is rank \", max.dims()));\n    Tensor* grad_wrt_input;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &grad_wrt_input));\n    TensorShape scalar_shape;\n    Tensor* grad_wrt_min;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, scalar_shape, &grad_wrt_min));\n    Tensor* grad_wrt_max;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, scalar_shape, &grad_wrt_max));\n    FakeQuantWithMinMaxVarsGradientFunctor<Device> functor;\n    functor(context->eigen_device<Device>(), gradient.flat<float>(),\n            input.flat<float>(), min.scalar<float>(), max.scalar<float>(),\n            quant_min_, quant_max_, grad_wrt_input->flat<float>(),\n            grad_wrt_min->scalar<float>(), grad_wrt_max->scalar<float>());\n  }", "target": 0}
{"code": "std::string ExpandFilePath(const std::string &filepath, void *) {\n  return filepath;\n#if 0\n#ifdef _WIN32\n  std::wstring wfilepath = UTF8ToWchar(filepath);\n  DWORD wlen = ExpandEnvironmentStringsW(wfilepath.c_str(), nullptr, 0);\n  wchar_t *wstr = new wchar_t[wlen];\n  ExpandEnvironmentStringsW(wfilepath.c_str(), wstr, wlen);\n  std::wstring ws(wstr);\n  delete[] wstr;\n  return WcharToUTF8(ws);\n#else\n#if defined(TARGET_OS_IPHONE) || defined(TARGET_IPHONE_SIMULATOR) || \\\n    defined(__ANDROID__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__)\n  std::string s = filepath;\n#else\n  std::string s;\n  wordexp_t p;\n  if (filepath.empty()) {\n    return \"\";\n  }\n  std::string quoted_path = \"\\\"\" + filepath + \"\\\"\";\n  int ret = wordexp(quoted_path.c_str(), &p, 0);\n  if (ret) {\n    s = filepath;\n    return s;\n  }\n  if (p.we_wordv) {\n    s = std::string(p.we_wordv[0]);\n    wordfree(&p);\n  } else {\n    s = filepath;\n  }\n#endif\n  return s;\n#endif\n#endif\n}", "target": 0}
{"code": "static int do_io_accounting(struct task_struct *task, char *buffer, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\treturn -EACCES;\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\treturn sprintf(buffer,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\n}", "target": 0}
{"code": "static int sgi_timer_set(struct k_itimer *timr, int flags,\n\tstruct itimerspec * new_setting,\n\tstruct itimerspec * old_setting)\n{\n\tunsigned long when, period, irqflags;\n\tint err = 0;\n\tcnodeid_t nodeid;\n\tstruct mmtimer *base;\n\tstruct rb_node *n;\n\tif (old_setting)\n\t\tsgi_timer_get(timr, old_setting);\n\tsgi_timer_del(timr);\n\twhen = timespec_to_ns(new_setting->it_value);\n\tperiod = timespec_to_ns(new_setting->it_interval);\n\tif (when == 0)\n\t\treturn 0;\n\tbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\n\tif (base == NULL)\n\t\treturn -ENOMEM;\n\tif (flags & TIMER_ABSTIME) {\n\t\tstruct timespec n;\n\t\tunsigned long now;\n\t\tgetnstimeofday(&n);\n\t\tnow = timespec_to_ns(n);\n\t\tif (when > now)\n\t\t\twhen -= now;\n\t\telse\n\t\t\twhen = 0;\n\t}\n\twhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\n\tperiod = (period + sgi_clock_period - 1)  / sgi_clock_period;\n\tpreempt_disable();\n\tnodeid =  cpu_to_node(smp_processor_id());\n\tspin_lock_irqsave(&timers[nodeid].lock, irqflags);\n\tbase->timer = timr;\n\tbase->cpu = smp_processor_id();\n\ttimr->it.mmtimer.clock = TIMER_SET;\n\ttimr->it.mmtimer.node = nodeid;\n\ttimr->it.mmtimer.incr = period;\n\ttimr->it.mmtimer.expires = when;\n\tn = timers[nodeid].next;\n\tmmtimer_add_list(base);\n\tif (timers[nodeid].next == n) {\n\t\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\t\tpreempt_enable();\n\t\treturn err;\n\t}\n\tif (n)\n\t\tmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\n\tmmtimer_set_next_timer(nodeid);\n\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\tpreempt_enable();\n\treturn err;\n}", "target": 1}
{"code": "TfLiteStatus GetIntermediatesSafe(const TfLiteContext* context,\n                                  const TfLiteNode* node, int index,\n                                  TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->intermediates->size,\n                                 node->intermediates->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 1}
{"code": "static gboolean restart_dhcp_timeout(gpointer user_data)\n{\n\tGDHCPClient *dhcp_client = user_data;\n\tdebug(dhcp_client, \"restart DHCP timeout\");\n\tif (dhcp_client->state == REBOOTING) {\n\t\tg_free(dhcp_client->last_address);\n\t\tdhcp_client->last_address = NULL;\n\t\trestart_dhcp(dhcp_client, 0);\n\t} else {\n\t\tdhcp_client->ack_retry_times++;\n\t\trestart_dhcp(dhcp_client, dhcp_client->ack_retry_times);\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}", "target": 0}
{"code": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n  auto sep = file.rfind('/');\n  if (sep != std::string::npos) {\n    auto path = to + file.substr(0, sep);\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n    if (sep == file.length() - 1) {\n      return true;\n    }\n  }\n  to.append(file);\n  struct zip_stat zipStat;\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "static ssize_t aio_setup_vectored_rw(int type, struct kiocb *kiocb, bool compat)\n{\n\tssize_t ret;\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tret = compat_rw_copy_check_uvector(type,\n\t\t\t\t(struct compat_iovec __user *)kiocb->ki_buf,\n\t\t\t\tkiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,\n\t\t\t\t&kiocb->ki_iovec, 1);\n\telse\n#endif\n\t\tret = rw_copy_check_uvector(type,\n\t\t\t\t(struct iovec __user *)kiocb->ki_buf,\n\t\t\t\tkiocb->ki_nbytes, 1, &kiocb->ki_inline_vec,\n\t\t\t\t&kiocb->ki_iovec, 1);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = rw_verify_area(type, kiocb->ki_filp, &kiocb->ki_pos, ret);\n\tif (ret < 0)\n\t\tgoto out;\n\tkiocb->ki_nr_segs = kiocb->ki_nbytes;\n\tkiocb->ki_cur_seg = 0;\n\tkiocb->ki_nbytes = ret;\n\tkiocb->ki_left = ret;\n\tret = 0;\nout:\n\treturn ret;\n}", "target": 0}
{"code": "merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "static inline int use_cpu_reloc(struct drm_i915_gem_object *obj)\n{\n\treturn (obj->base.write_domain == I915_GEM_DOMAIN_CPU ||\n\t\t!obj->map_and_fenceable ||\n\t\tobj->cache_level != I915_CACHE_NONE);\n}", "target": 0}
{"code": "hybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)\n{\n  int nextState = WS_HYBI_STATE_ERR;\n  if (wsctx->readlen > 0) {\n    if (wsctx->readlen > len) {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", len, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, len);\n      *nWritten = len;\n      wsctx->readlen -= len;\n      wsctx->readPos += len;\n      nextState = WS_HYBI_STATE_DATA_AVAILABLE;\n    } else {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", wsctx->readlen, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, wsctx->readlen);\n      *nWritten = wsctx->readlen;\n      wsctx->readlen = 0;\n      wsctx->readPos = NULL;\n      if (hybiRemaining(wsctx) == 0) {\n        nextState = WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        nextState = WS_HYBI_STATE_DATA_NEEDED;\n      }\n    }\n    rfbLog(\"after copy: readPos=%p, readLen=%d\\n\", wsctx->readPos, wsctx->readlen);\n  } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_CLOSE_REASON_PENDING) {\n    nextState = WS_HYBI_STATE_CLOSE_REASON_PENDING;\n  }\n  return nextState;\n}", "target": 0}
{"code": "static inline u32 dma_low(dma_addr_t addr)\n{\n\treturn (u32)addr;\n}", "target": 1}
{"code": "static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tint error = 0;\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\topt->src_addr = sp->sa_addr.pptp;\n\tif (add_chan(po))\n\t\terror = -EBUSY;\n\trelease_sock(sk);\n\treturn error;\n}", "target": 0}
{"code": "static BOOL handle_SSH2_newkeys(PTInstVar pvar)\n{\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_NEWKEYS was received(DH key generation is completed).\");\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\n\t\tsave_memdump(LOGDUMP);\n\t}\n\tfinish_memdump();\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED;\n\tssh2_set_newkeys(pvar, MODE_IN);\n\tif (!CRYPT_start_encryption(pvar, 0, 1)) {\n\t}\n\tpvar->ssh2_keys[MODE_IN].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_IN].comp.enabled = 1;\n\tenable_recv_compression(pvar);\n\tif (pvar->server_strict_kex) {\n\t\tpvar->ssh_state.receiver_sequence_number = 0;\n\t}\n\tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint i;\n\t\t\tChannel_t *c;\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\t\t\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\n\t\t\t\tc = &channels[i];\n\t\t\t\tif (c->used) {\n\t\t\t\t\tssh2_channel_retry_send_bufchain(pvar, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tssh2_finish_encryption_setup(pvar);\n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "void CodeBlock::lazyCompileImpl(Runtime &runtime) {\n  assert(isLazy() && \"Laziness has not been checked\");\n  PerfSection perf(\"Lazy function compilation\");\n  auto *provider = (hbc::BCProviderLazy *)runtimeModule_->getBytecode();\n  auto *func = provider->getBytecodeFunction();\n  auto *lazyData = func->getLazyCompilationData();\n  auto bcModule = compileLazyFunction(lazyData);\n  runtimeModule_->initializeLazyMayAllocate(\n      hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(bcModule)));\n  functionID_ = runtimeModule_->getBytecode()->getGlobalFunctionIndex();\n  functionHeader_ =\n      runtimeModule_->getBytecode()->getFunctionHeader(functionID_);\n  bytecode_ = runtimeModule_->getBytecode()->getBytecode(functionID_);\n}", "target": 1}
{"code": "int bridge__remap_topic_in(struct mosquitto *context, char **topic)\n{\n\tstruct mosquitto__bridge_topic *cur_topic;\n\tchar *topic_temp;\n\tint i;\n\tsize_t len;\n\tint rc;\n\tbool match;\n\tif(context->bridge && context->bridge->topics && context->bridge->topic_remapping){\n\t\tfor(i=0; i<context->bridge->topic_count; i++){\n\t\t\tcur_topic = &context->bridge->topics[i];\n\t\t\tif((cur_topic->direction == bd_both || cur_topic->direction == bd_in)\n\t\t\t\t\t&& (cur_topic->remote_prefix || cur_topic->local_prefix)){\n\t\t\t\trc = mosquitto_topic_matches_sub(cur_topic->remote_topic, *topic, &match);\n\t\t\t\tif(rc){\n\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t*topic = NULL;\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\t\t\t\tif(match){\n\t\t\t\t\tif(cur_topic->remote_prefix){\n\t\t\t\t\t\tif(!strncmp(cur_topic->remote_prefix, *topic, strlen(cur_topic->remote_prefix))){\n\t\t\t\t\t\t\ttopic_temp = mosquitto__strdup((*topic)+strlen(cur_topic->remote_prefix));\n\t\t\t\t\t\t\tif(!topic_temp){\n\t\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t\t*topic = NULL;\n\t\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t*topic = topic_temp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(cur_topic->local_prefix){\n\t\t\t\t\t\tlen = strlen(*topic) + strlen(cur_topic->local_prefix)+1;\n\t\t\t\t\t\ttopic_temp = mosquitto__malloc(len+1);\n\t\t\t\t\t\tif(!topic_temp){\n\t\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t\t*topic = NULL;\n\t\t\t\t\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsnprintf(topic_temp, len, \"%s%s\", cur_topic->local_prefix, *topic);\n\t\t\t\t\t\ttopic_temp[len] = '\\0';\n\t\t\t\t\t\tmosquitto__free(*topic);\n\t\t\t\t\t\t*topic = topic_temp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"code": "static inline bool can_follow_write_pte(pte_t pte, unsigned int flags)\n{\n\treturn pte_write(pte) ||\n\t\t((flags & FOLL_FORCE) && (flags & FOLL_COW) && pte_dirty(pte));\n}", "target": 0}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tconst UINT64 tmp = (UINT64)context->maxWidth * context->maxHeight;\n\tif (tmp > UINT32_MAX)\n\t\treturn FALSE;\n\tcontext->maxPlaneSize = tmp;\n\tif (context->maxWidth > UINT32_MAX / 4)\n\t\treturn FALSE;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tmemset(context->planes, 0, sizeof(context->planes));\n\tmemset(context->rlePlanes, 0, sizeof(context->rlePlanes));\n\tmemset(context->deltaPlanes, 0, sizeof(context->deltaPlanes));\n\tif (context->maxPlaneSize > 0)\n\t{\n\t\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->planesBuffer = tmp;\n\t\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->pTempData = tmp;\n\t\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->deltaPlanesBuffer = tmp;\n\t\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->rlePlanesBuffer = tmp;\n\t\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\t\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\t\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\t\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\t\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\t\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\t\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\t\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "static int seed_from_windows_cryptoapi(uint32_t *seed)\n{\n    HINSTANCE hAdvAPI32 = NULL;\n    CRYPTACQUIRECONTEXTA pCryptAcquireContext = NULL;\n    CRYPTGENRANDOM pCryptGenRandom = NULL;\n    CRYPTRELEASECONTEXT pCryptReleaseContext = NULL;\n    HCRYPTPROV hCryptProv = 0;\n    BYTE data[sizeof(uint32_t)];\n    int ok;\n    hAdvAPI32 = GetModuleHandle(\"advapi32.dll\");\n    if(hAdvAPI32 == NULL)\n        return 1;\n    pCryptAcquireContext = (CRYPTACQUIRECONTEXTA)GetProcAddress(hAdvAPI32, \"CryptAcquireContextA\");\n    if (!pCryptAcquireContext)\n        return 1;\n    pCryptGenRandom = (CRYPTGENRANDOM)GetProcAddress(hAdvAPI32, \"CryptGenRandom\");\n    if (!pCryptGenRandom)\n        return 1;\n    pCryptReleaseContext = (CRYPTRELEASECONTEXT)GetProcAddress(hAdvAPI32, \"CryptReleaseContext\");\n    if (!pCryptReleaseContext)\n        return 1;\n    if (!pCryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))\n        return 1;\n    ok = CryptGenRandom(hCryptProv, sizeof(uint32_t), data);\n    pCryptReleaseContext(hCryptProv, 0);\n    if (!ok)\n        return 1;\n    *seed = buf_to_uint32((char *)data);\n    return 0;\n}", "target": 0}
{"code": "static void __free_slab(struct kmem_cache *s, struct page *page)\n{\n\tint order = compound_order(page);\n\tint pages = 1 << order;\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tvoid *p;\n\t\tslab_pad_check(s, page);\n\t\tfor_each_object(p, s, page_address(page),\n\t\t\t\t\t\tpage->objects)\n\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\n\t}\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage->mapping = NULL;\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += pages;\n\tuncharge_slab_page(page, order, s);\n\t__free_pages(page, order);\n}", "target": 0}
{"code": "parse_notification_delta(xmlTextReaderPtr reader,\n    struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head *tmp;\n\tunsigned long serial;\n\tint error;\n\terror = delta_head_create(&tmp);\n\tif (error)\n\t\treturn error;\n\terror = parse_long(reader, RRDP_ATTR_SERIAL, &serial);\n\tif (error)\n\t\tgoto delta_destroy;\n\ttmp->serial = serial;\n\terror = parse_doc_data(reader, true, true, &tmp->doc_data);\n\tif (error)\n\t\tgoto delta_destroy;\n\terror = deltas_parsed_add(&ctx->deltas, &tmp);\n\tif (error)\n\t\tgoto delta_destroy;\n\treturn 0;\ndelta_destroy:\n\tdelta_head_destroy(tmp);\n\treturn error;\n}", "target": 1}
{"code": "pango_glyph_string_set_size (PangoGlyphString *string, gint new_len)\n{\n  g_return_if_fail (new_len >= 0);\n  while (new_len > string->space)\n    {\n      if (string->space == 0)\n\tstring->space = 1;\n      else\n\tstring->space *= 2;\n      if (string->space < 0)\n\t{\n\t  g_warning (\"glyph string length overflows maximum integer size, truncated\");\n\t  new_len = string->space = G_MAXINT - 8;\n\t}\n    }\n  string->glyphs = g_realloc (string->glyphs, string->space * sizeof (PangoGlyphInfo));\n  string->log_clusters = g_realloc (string->log_clusters, string->space * sizeof (gint));\n  string->num_glyphs = new_len;\n}", "target": 1}
{"code": "static void rekey_seq_generator(struct work_struct *work)\n{\n\tstruct keydata *keyptr = &ip_keydata[1 ^ (ip_cnt & 1)];\n\tget_random_bytes(keyptr->secret, sizeof(keyptr->secret));\n\tkeyptr->count = (ip_cnt & COUNT_MASK) << HASH_BITS;\n\tsmp_wmb();\n\tip_cnt++;\n\tschedule_delayed_work(&rekey_work,\n\t\t\t      round_jiffies_relative(REKEY_INTERVAL));\n}", "target": 1}
{"code": "static size_t consume_init_expr (ut8 *buf, ut8 *max, ut8 eoc, void *out, ut32 *offset) {\n\tut32 i = 0;\n\twhile (buf + i < max && buf[i] != eoc) {\n\t\ti += 1;\n\t}\n\tif (buf[i] != eoc) {\n\t\treturn 0;\n\t}\n\tif (offset) {\n\t\t*offset += i + 1;\n\t}\n\treturn i + 1;\n}", "target": 1}
{"code": "Status CreateTempFile(Env* env, float value, uint64 size, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", value));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  for (uint64 i = 0; i < size; ++i) {\n    StringPiece sp(static_cast<char*>(static_cast<void*>(&value)),\n                   sizeof(value));\n    TF_RETURN_IF_ERROR(file->Append(sp));\n  }\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 1}
{"code": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\two = (rbuf == NULL || rlen == 0); \n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "main_get_appheader (xd3_stream *stream, main_file *ifile,\n\t\t    main_file *output, main_file *sfile)\n{\n  uint8_t *apphead;\n  usize_t appheadsz;\n  int ret;\n  if (! option_use_appheader) { return; }\n  ret = xd3_get_appheader (stream, & apphead, & appheadsz);\n  if (ret != 0) { return; }\n  if (appheadsz > 0)\n    {\n      char *start = (char*)apphead;\n      char *slash;\n      int   place = 0;\n      char *parsed[4];\n      memset (parsed, 0, sizeof (parsed));\n      while ((slash = strchr (start, '/')) != NULL)\n\t{\n\t  *slash = 0;\n\t  parsed[place++] = start;\n\t  start = slash + 1;\n\t}\n      parsed[place++] = start;\n      if (place == 2 || place == 4)\n\t{\n\t  main_get_appheader_params (output, parsed, 1, \"output\", ifile);\n\t}\n      if (place == 4)\n\t{\n\t  main_get_appheader_params (sfile, parsed+2, 0, \"source\", ifile);\n\t}\n    }\n  option_use_appheader = 0;\n  return;\n}", "target": 1}
{"code": "static void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\trc_unregister_device(dev->rdev);\n\tkfree(dev);\n}", "target": 1}
{"code": "snmp_ber_encode_type(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  *out-- = type;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "new_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct fixup_entry *fe;\n\tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n\tif (fe == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for a fixup\");\n\t\treturn (NULL);\n\t}\n\tfe->next = a->fixup_list;\n\ta->fixup_list = fe;\n\tfe->fixup = 0;\n\tfe->mode = 0;\n\tfe->name = strdup(pathname);\n\treturn (fe);\n}", "target": 0}
{"code": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\nbox = 0;\nout = 0;\n\treturn -1;\n}", "target": 1}
{"code": "static int inotify_release(struct inode *ignored, struct file *file)\n{\n\tstruct fsnotify_group *group = file->private_data;\n\tstruct user_struct *user = group->inotify_data.user;\n\tpr_debug(\"%s: group=%p\\n\", __func__, group);\n\tfsnotify_clear_marks_by_group(group);\n\tfsnotify_put_group(group);\n\tatomic_dec(&user->inotify_devs);\n\treturn 0;\n}", "target": 1}
{"code": "bool MainWindow::serverArgs(QStringList& args, QString& app)\n{\n    app = appPath(appConfig().barriersName());\n    if (!QFile::exists(app))\n    {\n        QMessageBox::warning(this, tr(\"Barrier server not found\"),\n                             tr(\"The executable for the barrier server does not exist.\"));\n        return false;\n    }\n#if defined(Q_OS_WIN)\n    app = QString(\"\\\"%1\\\"\").arg(app);\n#endif\n    if (appConfig().logToFile())\n    {\n        appConfig().persistLogDir();\n        args << \"--log\" << appConfig().logFilenameCmd();\n    }\n    if (!appConfig().getRequireClientCertificate()) {\n        args << \"--disable-client-cert-checking\";\n    }\n    QString configFilename = this->configFilename();\n#if defined(Q_OS_WIN)\n    configFilename = QString(\"\\\"%1\\\"\").arg(configFilename);\n#endif\n    args << \"-c\" << configFilename << \"--address\" << address();\n    return true;\n}", "target": 0}
{"code": "PackLinuxElf64::elf_find_dynamic(unsigned int key) const\n{\n    Elf64_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {\n        upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));\n        if (t) {\n            return &((unsigned char const *)file_image)[(size_t)t];\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_msnd *chip = dev_id;\n\tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n\t\tu16 wTmp;\n\t\tsnd_msnd_eval_dsp_msg(chip,\n\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n\t}\n\tinb(chip->io + HP_RXL);\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "void CefLayeredWindowUpdaterOSR::OnAllocatedSharedMemory(\n    const gfx::Size& pixel_size,\n    base::UnsafeSharedMemoryRegion region) {\n  size_t expected_bytes;\n  bool size_result = viz::ResourceSizes::MaybeSizeInBytes(\n      pixel_size, viz::SinglePlaneFormat::kRGBA_8888, &expected_bytes);\n  if (!size_result) {\n    return;\n  }\n  pixel_size_ = pixel_size;\n  shared_memory_ = region.Map();\n  DCHECK(shared_memory_.IsValid());\n}", "target": 1}
{"code": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}", "target": 1}
{"code": "switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n\tif (userInfo != NULL) {\n\t\tbool setgroupsCalled = false;\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n\t\t\t#ifdef __APPLE__\n\t\t\t\tint groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(int);\n\t\t\t#else\n\t\t\t\tgid_t groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(gid_t);\n\t\t\t#endif\n\t\t\tboost::scoped_array<gid_t> gidset;\n\t\t\tint ret = getgrouplist(userInfo->pw_name, gid,\n\t\t\t\tgroups, &ngroups);\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\t\texit(1);\n\t\t\t}\n\t\t\tif (ngroups <= NGROUPS_MAX) {\n\t\t\t\tsetgroupsCalled = true;\n\t\t\t\tgidset.reset(new gid_t[ngroups]);\n\t\t\t\tfor (int i = 0; i < ngroups; i++) {\n\t\t\t\t\tgidset[i] = groups[i];\n\t\t\t\t}\n\t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\tngroups, strerror(e), e);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\t\tif (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\texit(1);\n\t\t}\n\t}\n\tif (setgid(gid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) gid, strerror(e), e);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static void xfrm6_tunnel_spi_fini(void)\n{\n\tkmem_cache_destroy(xfrm6_tunnel_spi_kmem);\n}", "target": 1}
{"code": "ssize_t tcp_splice_read(struct socket *sock, loff_t *ppos,\n\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\tunsigned int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct tcp_splice_state tss = {\n\t\t.pipe = pipe,\n\t\t.len = len,\n\t\t.flags = flags,\n\t};\n\tlong timeo;\n\tssize_t spliced;\n\tint ret;\n\tsock_rps_record_flow(sk);\n\tif (unlikely(*ppos))\n\t\treturn -ESPIPE;\n\tret = spliced = 0;\n\tlock_sock(sk);\n\ttimeo = sock_rcvtimeo(sk, sock->file->f_flags & O_NONBLOCK);\n\twhile (tss.len) {\n\t\tret = __tcp_splice_read(sk, &tss);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (spliced)\n\t\t\t\tbreak;\n\t\t\tif (sock_flag(sk, SOCK_DONE))\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_err) {\n\t\t\t\tret = sock_error(sk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\t\tbreak;\n\t\t\tif (sk->sk_state == TCP_CLOSE) {\n\t\t\t\tif (!sock_flag(sk, SOCK_DONE))\n\t\t\t\t\tret = -ENOTCONN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!timeo) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\t\t\tbreak;\n\t\t\tsk_wait_data(sk, &timeo, NULL);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tret = sock_intr_errno(timeo);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttss.len -= ret;\n\t\tspliced += ret;\n\t\tif (!timeo)\n\t\t\tbreak;\n\t\trelease_sock(sk);\n\t\tlock_sock(sk);\n\t\tif (sk->sk_err || sk->sk_state == TCP_CLOSE ||\n\t\t    (sk->sk_shutdown & RCV_SHUTDOWN) ||\n\t\t    signal_pending(current))\n\t\t\tbreak;\n\t}\n\trelease_sock(sk);\n\tif (spliced)\n\t\treturn spliced;\n\treturn ret;\n}", "target": 0}
{"code": "mrb_class_real(struct RClass* cl)\n{\n  if (cl == 0)\n    return NULL;\n  while ((cl->tt == MRB_TT_SCLASS) || (cl->tt == MRB_TT_ICLASS)) {\n    cl = cl->super;\n  }\n  return cl;\n}", "target": 1}
{"code": "static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (cs > CQSPI_MAX_CHIPSELECT) {\n\t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n\t\t\tgoto err;\n\t\t}\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\t\tmtd->priv = nor;\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tf_pdata->registered = true;\n\t}\n\treturn 0;\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}", "target": 1}
{"code": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  response->waitForEndStream();\n  return response;\n}", "target": 1}
{"code": "static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "ikev2_sub_print(netdissect_options *ndo,\n\t\tstruct isakmp *base,\n\t\tu_char np, const struct isakmp_gen *ext, const u_char *ep,\n\t\tuint32_t phase, uint32_t doi, uint32_t proto, int depth)\n{\n\tconst u_char *cp;\n\tint i;\n\tstruct isakmp_gen e;\n\tcp = (const u_char *)ext;\n\twhile (np) {\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\tND_TCHECK2(*ext, ntohs(e.len));\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tcp = ikev2_sub0_print(ndo, base, np,\n\t\t\t\t      ext, ep, phase, doi, proto, depth);\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tif (cp == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tnp = e.np;\n\t\text = (const struct isakmp_gen *)cp;\n\t}\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(np)));\n\treturn NULL;\n}", "target": 1}
{"code": "check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tret = check_entry((struct arpt_entry *)e);\n\tif (ret)\n\t\treturn ret;\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "goto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    set_keep_msg(NULL, 0);\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}", "target": 0}
{"code": "static int ntlm_decode_u16l_str_hdr(struct ntlm_ctx *ctx,\n                                    struct wire_field_hdr *str_hdr,\n                                    struct ntlm_buffer *buffer,\n                                    size_t payload_offs, char **str)\n{\n    char *in, *out = NULL;\n    uint16_t str_len;\n    uint32_t str_offs;\n    size_t outlen = 0;\n    int ret = 0;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    in = (char *)&buffer->data[str_offs];\n    out = malloc(str_len * 2 + 1);\n    if (!out) return ENOMEM;\n    ret = ntlm_str_convert(ctx->to_oem, in, out, str_len, &outlen);\ndone:\n    if (ret) {\n        safefree(out);\n    } else {\n        out[outlen] = '\\0';\n    }\n    *str = out;\n    return ret;\n}", "target": 0}
{"code": "hb_map_clear (hb_map_t *map)\n{\n  if (unlikely (hb_object_is_immutable (map)))\n    return;\n  return map->clear ();\n}", "target": 1}
{"code": "void SSecurityTLS::initGlobal()\n{\n  static bool globalInitDone = false;\n  if (!globalInitDone) {\n    if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_global_init failed\");\n    globalInitDone = true;\n  }\n}", "target": 1}
{"code": "av_cold int ff_vc2enc_init_transforms(VC2TransformContext *s, int p_width, int p_height)\n{\n    s->vc2_subband_dwt[VC2_TRANSFORM_9_7]    = vc2_subband_dwt_97;\n    s->vc2_subband_dwt[VC2_TRANSFORM_5_3]    = vc2_subband_dwt_53;\n    s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));\n    if (!s->buffer)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "static int get_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_GET_REGS, RTL8150_REQT_READ,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tif (id.index > UINT_MAX - kcontrol->count)\n\t\tgoto error;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tdev_err(card->dev, \"control %i:%i:%i:%s:%i is already present\\n\",\n\t\t\t\t\tid.iface,\n\t\t\t\t\tid.device,\n\t\t\t\t\tid.subdevice,\n\t\t\t\t\tid.name,\n\t\t\t\t\tid.index);\n\t\terr = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}", "target": 0}
{"code": "int rdma_create_qp(struct rdma_cm_id *id, struct ib_pd *pd,\n\t\t   struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct rdma_id_private *id_priv;\n\tstruct ib_qp *qp;\n\tint ret;\n\tid_priv = container_of(id, struct rdma_id_private, id);\n\tif (id->device != pd->device) {\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\tqp_init_attr->port_num = id->port_num;\n\tqp = ib_create_qp(pd, qp_init_attr);\n\tif (IS_ERR(qp)) {\n\t\tret = PTR_ERR(qp);\n\t\tgoto out_err;\n\t}\n\tif (id->qp_type == IB_QPT_UD)\n\t\tret = cma_init_ud_qp(id_priv, qp);\n\telse\n\t\tret = cma_init_conn_qp(id_priv, qp);\n\tif (ret)\n\t\tgoto out_destroy;\n\tid->qp = qp;\n\tid_priv->qp_num = qp->qp_num;\n\tid_priv->srq = (qp->srq != NULL);\n\ttrace_cm_qp_create(id_priv, pd, qp_init_attr, 0);\n\treturn 0;\nout_destroy:\n\tib_destroy_qp(qp);\nout_err:\n\ttrace_cm_qp_create(id_priv, pd, qp_init_attr, ret);\n\treturn ret;\n}", "target": 0}
{"code": "static unsigned int get_exif_ui16(struct iw_exif_state *e, unsigned int pos)\n{\n\tif(e->d_len<2 || pos>e->d_len-2) return 0;\n\treturn iw_get_ui16_e(&e->d[pos], e->endian);\n}", "target": 0}
{"code": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}", "target": 1}
{"code": "static void ext4_end_io_buffer_write(struct buffer_head *bh, int uptodate)\n{\n\text4_io_end_t *io_end = bh->b_private;\n\tstruct workqueue_struct *wq;\n\tstruct inode *inode;\n\tunsigned long flags;\n\tif (!test_clear_buffer_uninit(bh) || !io_end)\n\t\tgoto out;\n\tif (!(io_end->inode->i_sb->s_flags & MS_ACTIVE)) {\n\t\tprintk(\"sb umounted, discard end_io request for inode %lu\\n\",\n\t\t\tio_end->inode->i_ino);\n\t\text4_free_io_end(io_end);\n\t\tgoto out;\n\t}\n\tio_end->flag = EXT4_IO_UNWRITTEN;\n\tinode = io_end->inode;\n\tspin_lock_irqsave(&EXT4_I(inode)->i_completed_io_lock, flags);\n\tlist_add_tail(&io_end->list, &EXT4_I(inode)->i_completed_io_list);\n\tspin_unlock_irqrestore(&EXT4_I(inode)->i_completed_io_lock, flags);\n\twq = EXT4_SB(inode->i_sb)->dio_unwritten_wq;\n\tqueue_work(wq, &io_end->work);\nout:\n\tbh->b_private = NULL;\n\tbh->b_end_io = NULL;\n\tclear_buffer_uninit(bh);\n\tend_buffer_async_write(bh, uptodate);\n}", "target": 0}
{"code": "void infra_wait_limit_dec(struct infra_cache* infra, struct comm_reply* rep,\n\tstruct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 1);\n\tif(entry) {\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\tif(d->mesh_wait > 0)\n\t\t\td->mesh_wait--;\n\t\tlock_rw_unlock(&entry->lock);\n\t}\n}", "target": 0}
{"code": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\tmod_alias_patch_connection(srv, con, p);\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n\t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n\t\t\tif (uri_ptr[alias_len] == '.') {\n\t\t\t\tchar *s = uri_ptr + alias_len + 1;\n\t\t\t\tif (*s == '.') ++s;\n\t\t\t\tif (*s == '/' || *s == '\\0') {\n\t\t\t\t\tsize_t vlen = buffer_string_length(ds->value);\n\t\t\t\t\tif (0 != alias_len && ds->key->ptr[alias_len-1] != '/'\n\t\t\t\t\t    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {\n\t\t\t\t\t\tcon->http_status = 403;\n\t\t\t\t\t\treturn HANDLER_FINISHED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n\t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n\t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\treturn HANDLER_GO_ON;\n}", "target": 0}
{"code": "inline void ScatterNd(const RuntimeShape& indices_shape,\n                      const IndicesT* indices_data,\n                      const RuntimeShape& updates_shape,\n                      const UpdatesT* updates_data,\n                      const RuntimeShape& output_shape, UpdatesT* output_data) {\n  ruy::profiler::ScopeLabel label(\"ScatterNd\");\n  int n_slices = 1;\n  int slice_size = 1;\n  const int outer_dims = indices_shape.DimensionsCount() - 1;\n  const int indices_nd = indices_shape.Dims(outer_dims);\n  const int updates_dims = updates_shape.DimensionsCount();\n  for (int i = 0; i < outer_dims; ++i) {\n    n_slices *= indices_shape.Dims(i);\n  }\n  for (int i = outer_dims; i < updates_dims; ++i) {\n    slice_size *= updates_shape.Dims(i);\n  }\n  int output_flat_size = output_shape.FlatSize();\n  int remain_flat_size = output_flat_size;\n  std::vector<int> dims_to_count(indices_nd, 0);\n  for (int i = 0; i < indices_nd; ++i) {\n    dims_to_count[i] = remain_flat_size / output_shape.Dims(i);\n    remain_flat_size = dims_to_count[i];\n  }\n  memset(output_data, 0, sizeof(UpdatesT) * output_flat_size);\n  for (int i = 0; i < n_slices; ++i) {\n    int to_pos = 0;\n    for (int j = 0; j < indices_nd; ++j) {\n      IndicesT idx = indices_data[i * indices_nd + j];\n      TFLITE_DCHECK(0 <= idx && idx < output_shape.Dims(j));\n      to_pos += idx * dims_to_count[j];\n    }\n    for (int j = 0; j < slice_size; j++) {\n      output_data[to_pos + j] += updates_data[i * slice_size + j];\n    }\n  }\n}", "target": 1}
{"code": "__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tu32 id;\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n\treturn htonl(id);\n}", "target": 1}
{"code": "int nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n\tint rc = 0;\n\tu8 *gb;\n\tsize_t gb_len;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\tif (!dev->ops->dep_link_up)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == true) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tgb = nfc_llcp_general_bytes(dev, &gb_len);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_index);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\treturn ret;\n}", "target": 1}
{"code": "void prefetch_table(const void *tab, size_t len)\n{\n  const volatile byte *vtab = tab;\n  size_t i;\n  for (i = 0; i < len; i += 8 * 32)\n    {\n      (void)vtab[i + 0 * 32];\n      (void)vtab[i + 1 * 32];\n      (void)vtab[i + 2 * 32];\n      (void)vtab[i + 3 * 32];\n      (void)vtab[i + 4 * 32];\n      (void)vtab[i + 5 * 32];\n      (void)vtab[i + 6 * 32];\n      (void)vtab[i + 7 * 32];\n    }\n  (void)vtab[len - 1];\n}", "target": 1}
{"code": "void CClient::EchoMessage(const CMessage& Message) {\n    CMessage EchoedMessage = Message;\n    for (CClient* pClient : GetClients()) {\n        if (pClient->HasEchoMessage() ||\n            (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) ||\n                                 pClient->HasSelfMessage()))) {\n            EchoedMessage.SetNick(GetNickMask());\n            pClient->PutClient(EchoedMessage);\n        }\n    }\n}", "target": 1}
{"code": "int compat_get_fd_set(unsigned long nr, compat_ulong_t __user *ufdset,\n\t\t\tunsigned long *fdset)\n{\n\tnr = DIV_ROUND_UP(nr, __COMPAT_NFDBITS);\n\tif (ufdset) {\n\t\tunsigned long odd;\n\t\tif (!access_ok(VERIFY_WRITE, ufdset, nr*sizeof(compat_ulong_t)))\n\t\t\treturn -EFAULT;\n\t\todd = nr & 1UL;\n\t\tnr &= ~1UL;\n\t\twhile (nr) {\n\t\t\tunsigned long h, l;\n\t\t\tif (__get_user(l, ufdset) || __get_user(h, ufdset+1))\n\t\t\t\treturn -EFAULT;\n\t\t\tufdset += 2;\n\t\t\t*fdset++ = h << 32 | l;\n\t\t\tnr -= 2;\n\t\t}\n\t\tif (odd && __get_user(*fdset, ufdset))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(fdset, 0, ((nr + 1) & ~1)*sizeof(compat_ulong_t));\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int X509_REQ_add1_attr_by_OBJ(X509_REQ *req,\n                              const ASN1_OBJECT *obj, int type,\n                              const unsigned char *bytes, int len)\n{\n    if (X509at_add1_attr_by_OBJ(&req->req_info->attributes, obj,\n                                type, bytes, len))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n{\n    const char *s;\n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n\t(*pptr)++;\n\t(*len)--;\n    }\n    (*pptr)++;\n    (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    return s;\n}", "target": 1}
{"code": "MATCHER_P(HeaderMapEqualIgnoreOrder, expected, \"\") {\n  const bool equal = TestUtility::headerMapEqualIgnoreOrder(*arg, *expected);\n  if (!equal) {\n    *result_listener << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"Expected header map:\") << \"\\n\"\n                     << *expected\n                     << TestUtility::addLeftAndRightPadding(\"is not equal to actual header map:\")\n                     << \"\\n\"\n                     << *arg << TestUtility::addLeftAndRightPadding(\"\") \n                     << \"\\n\";\n  }\n  return equal;\n}", "target": 0}
{"code": "static void __pam_log(const pam_handle_t *pamh, int ctrl, int err, const char *format, ...)\n{\n\tva_list args;\n\tif (_pam_log_is_silent(ctrl)) {\n\t\treturn;\n\t}\n\tva_start(args, format);\n\t_pam_log_int(pamh, err, format, args);\n\tva_end(args);\n}", "target": 0}
{"code": "xcalloc (size_t num, size_t size)\n{\n    void *ptr = malloc(num * size);\n    if (ptr)\n    {\n        memset (ptr, '\\0', (num * size));\n    }\n    return ptr;\n}", "target": 1}
{"code": "int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)\n{\n\tunsigned long vm_len, pfn, pages;\n\tif (start + len < start)\n\t\treturn -EINVAL;\n\tlen += start & ~PAGE_MASK;\n\tpfn = start >> PAGE_SHIFT;\n\tpages = (len + ~PAGE_MASK) >> PAGE_SHIFT;\n\tif (pfn + pages < pfn)\n\t\treturn -EINVAL;\n\tif (vma->vm_pgoff > pages)\n\t\treturn -EINVAL;\n\tpfn += vma->vm_pgoff;\n\tpages -= vma->vm_pgoff;\n\tvm_len = vma->vm_end - vma->vm_start;\n\tif (vm_len >> PAGE_SHIFT > pages)\n\t\treturn -EINVAL;\n\treturn io_remap_pfn_range(vma, vma->vm_start, pfn, vm_len, vma->vm_page_prot);\n}", "target": 0}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct tcp_sock_t *tcp6_open(uint16_t port)\n{\n\tstruct tcp_sock_t *this = calloc(1, sizeof *this);\n\tif (this == NULL) {\n\t\tERR(\"IPv6: callocing this failed\");\n\t\tgoto error;\n\t}\n\tthis->sd = -1;\n\tthis->sd = socket(AF_INET6, SOCK_STREAM, 0);\n\tif (this->sd < 0) {\n\t\tERR(\"Ipv6 socket open failed\");\n\t\tgoto error;\n\t}\n\tstruct sockaddr_in6 addr;\n\tmemset(&addr, 0, sizeof addr);\n\taddr.sin6_family = AF_INET6;\n\taddr.sin6_port = htons(port);\n\taddr.sin6_addr = in6addr_loopback;\n\tif (bind(this->sd,\n\t        (struct sockaddr *)&addr,\n\t        sizeof addr) < 0) {\n\t\tif (g_options.only_desired_port == 1)\n\t\t\tERR(\"IPv6 bind on port failed. \"\n\t\t\t    \"Requested port may be taken or require root permissions.\");\n\t\tgoto error;\n\t}\n\tif (listen(this->sd, HTTP_MAX_PENDING_CONNS) < 0) {\n\t\tERR(\"IPv6 listen failed on socket\");\n\t\tgoto error;\n\t}\n\treturn this;\nerror:\n\tif (this != NULL) {\n\t\tif (this->sd != -1) {\n\t\t\tclose(this->sd);\n\t\t}\n\t\tfree(this);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int scanbraces(const char* in) {\n    if (strncmp(in, \"{\\\\an\", 4) != 0) {\n        return 0;\n    }\n    if (!isdigit(in[4])) {\n        return 0;\n    }\n    if (in[5] != '}') {\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "static void array_cleanup( char* arr[] , int arr_size)\n{\n\tint i=0;\n\tfor( i=0; i< arr_size; i++ ){ \n\t\tif( arr[i*2] ){\n\t\t\tefree( arr[i*2]);\n\t\t}\n\t}\n\tefree(arr);\n}", "target": 1}
{"code": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}", "target": 1}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[13]) << 32) + X[0]);\n}", "target": 1}
{"code": "struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\tpr_debug(\"No device found\\n\");\n\treturn NULL;\n}", "target": 1}
{"code": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(port);\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\treturn sfd;\n}", "target": 1}
{"code": "static int install_relocation_handler(int num_cpus, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_STUB_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = 1,\n\t\t.handler = smm_do_relocation,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 0);\n\tif (smm_setup_relocation_handler(&smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}", "target": 1}
{"code": "static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}", "target": 1}
{"code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0)\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static gboolean printable_str(const char *str)\n{\n    do {\n        if ((unsigned char)(*str) < ' ' || *str == 0x7f)\n            return FALSE;\n        str++;\n    } while (*str);\n    return TRUE;\n}", "target": 1}
{"code": "GF_Err dfla_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->dataSize = (u32) ptr->size;\n\tptr->size=0;\n\tptr->data = gf_malloc(ptr->dataSize);\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}", "target": 0}
{"code": "hybiPayloadStart(ws_ctx_t *wsctx)\n{\n  return wsctx->codeBufDecode + wsctx->header.headerLen;\n}", "target": 0}
{"code": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\tvoid *vapic;\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\tdata = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));\n\tkunmap_atomic(vapic);\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}", "target": 1}
{"code": "void OneHotComputeImpl(const OneHotContext& op_context) {\n  int prefix_dim_size = 1;\n  for (int i = 0; i < op_context.axis; ++i) {\n    prefix_dim_size *= op_context.indices->dims->data[i];\n  }\n  if (prefix_dim_size == 0) {\n    return;\n  }\n  const int suffix_dim_size = NumElements(op_context.indices) / prefix_dim_size;\n  const int depth = *op_context.depth->data.i32;\n  const T on_value = *GetTensorData<T>(op_context.on_value);\n  const T off_value = *GetTensorData<T>(op_context.off_value);\n  T* output = GetTensorData<T>(op_context.output);\n  const TI* indices = GetTensorData<TI>(op_context.indices);\n  for (int i = 0; i < prefix_dim_size; ++i) {\n    for (int j = 0; j < depth; ++j) {\n      for (int k = 0; k < suffix_dim_size; ++k, ++output) {\n        *output = static_cast<int>(indices[i * suffix_dim_size + k]) == j\n                      ? on_value\n                      : off_value;\n      }\n    }\n  }\n}", "target": 0}
{"code": "asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct oabi_flock64 user;\n\tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; \n\tunsigned long local_arg = arg;\n\tint ret;\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static UINT ExtractRunLengthMegaMega(const BYTE* pbOrderHdr, const BYTE* pbEnd, UINT32* advance)\n{\n\tUINT runLength = 0;\n\tWINPR_ASSERT(pbOrderHdr);\n\tWINPR_ASSERT(pbEnd);\n\tWINPR_ASSERT(advance);\n\tif (!buffer_within_range(pbOrderHdr, 2, pbEnd))\n\t{\n\t\t*advance = 0;\n\t\treturn 0;\n\t}\n\trunLength = ((UINT16)pbOrderHdr[1]) | (((UINT16)pbOrderHdr[2]) << 8);\n\t(*advance) += 2;\n\treturn runLength;\n}", "target": 1}
{"code": "ssh_packet_set_compress_state(struct ssh *ssh, struct sshbuf *m)\n{\n\tstruct session_state *state = ssh->state;\n\tstruct sshbuf *b = NULL;\n\tint r;\n\tconst u_char *inblob, *outblob;\n\tsize_t inl, outl;\n\tif ((r = sshbuf_froms(m, &b)) != 0)\n\t\tgoto out;\n\tif ((r = sshbuf_get_string_direct(b, &inblob, &inl)) != 0 ||\n\t    (r = sshbuf_get_string_direct(b, &outblob, &outl)) != 0)\n\t\tgoto out;\n\tif (inl == 0)\n\t\tstate->compression_in_started = 0;\n\telse if (inl != sizeof(state->compression_in_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_in_started = 1;\n\t\tmemcpy(&state->compression_in_stream, inblob, inl);\n\t}\n\tif (outl == 0)\n\t\tstate->compression_out_started = 0;\n\telse if (outl != sizeof(state->compression_out_stream)) {\n\t\tr = SSH_ERR_INTERNAL_ERROR;\n\t\tgoto out;\n\t} else {\n\t\tstate->compression_out_started = 1;\n\t\tmemcpy(&state->compression_out_stream, outblob, outl);\n\t}\n\tr = 0;\n out:\n\tsshbuf_free(b);\n\treturn r;\n}", "target": 1}
{"code": "  llvh::ArrayRef<hbc::HBCExceptionHandlerInfo> getExceptionTable(\n      uint32_t) const override {\n    llvm_unreachable(\"Accessing exception info from a lazy module\");\n  }", "target": 1}
{"code": "static int __init personal_pci_init(void)\n{\n\tif (machine_is_personal_server())\n\t\tpci_common_init(&personal_server_pci);\n\treturn 0;\n}", "target": 1}
{"code": "void RequestContext::AddInstanceIdentityToken() {\n  if (!method()) {\n    return;\n  }\n  const auto &audience = method()->backend_jwt_audience();\n  if (!audience.empty()) {\n    auto &token = service_context()\n                      ->global_context()\n                      ->GetInstanceIdentityToken(audience)\n                      ->GetAuthToken();\n    if (!token.empty()) {\n      std::string origin_auth_header;\n      if (request()->FindHeader(kAuthorizationHeader, &origin_auth_header)) {\n        Status status = request()->AddHeaderToBackend(\n            kXForwardedAuthorizationHeader, origin_auth_header);\n        if (!status.ok()) {\n          service_context()->env()->LogError(\n              \"Failed to set X-Forwarded-Authorization header to backend.\");\n        }\n      }\n      Status status = request()->AddHeaderToBackend(kAuthorizationHeader,\n                                                    kBearerPrefix + token);\n      if (!status.ok()) {\n        service_context()->env()->LogError(\n            \"Failed to set authorization header to backend.\");\n      }\n    }\n  }\n}", "target": 1}
{"code": "struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tkey_ref = search_process_keyrings(&ctx);\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}", "target": 1}
{"code": "static int logi_dj_raw_event(struct hid_device *hdev,\n\t\t\t     struct hid_report *report, u8 *data,\n\t\t\t     int size)\n{\n\tstruct dj_receiver_dev *djrcv_dev = hid_get_drvdata(hdev);\n\tstruct dj_report *dj_report = (struct dj_report *) data;\n\tunsigned long flags;\n\tbool report_processed = false;\n\tdbg_hid(\"%s, size:%d\\n\", __func__, size);\n\tif ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||\n\t    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {\n\t\tdev_err(&hdev->dev, \"%s: invalid device index:%d\\n\",\n\t\t\t\t__func__, dj_report->device_index);\n\t\treturn false;\n\t}\n\tspin_lock_irqsave(&djrcv_dev->lock, flags);\n\tif (dj_report->report_id == REPORT_ID_DJ_SHORT) {\n\t\tswitch (dj_report->report_type) {\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_PAIRED:\n\t\tcase REPORT_TYPE_NOTIF_DEVICE_UNPAIRED:\n\t\t\tlogi_dj_recv_queue_notification(djrcv_dev, dj_report);\n\t\t\tbreak;\n\t\tcase REPORT_TYPE_NOTIF_CONNECTION_STATUS:\n\t\t\tif (dj_report->report_params[CONNECTION_STATUS_PARAM_STATUS] ==\n\t\t\t    STATUS_LINKLOSS) {\n\t\t\t\tlogi_dj_recv_forward_null_report(djrcv_dev, dj_report);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlogi_dj_recv_forward_report(djrcv_dev, dj_report);\n\t\t}\n\t\treport_processed = true;\n\t}\n\tspin_unlock_irqrestore(&djrcv_dev->lock, flags);\n\treturn report_processed;\n}", "target": 0}
{"code": "inline int TensorProtoDataSize<qint32>(const TensorProto& t) {\n  return t.int_val_size();\n}", "target": 0}
{"code": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\treturn (attr->attrib_type);\n}", "target": 1}
{"code": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "static void php_html_entities(INTERNAL_FUNCTION_PARAMETERS, int all)\n{\n\tchar *str, *hint_charset = NULL;\n\tint str_len, hint_charset_len = 0;\n\tsize_t new_len;\n\tlong flags = ENT_COMPAT;\n\tchar *replaced;\n\tzend_bool double_encode = 1;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|ls!b\", &str, &str_len, &flags, &hint_charset, &hint_charset_len, &double_encode) == FAILURE) {\n\t\treturn;\n\t}\n\treplaced = php_escape_html_entities_ex(str, str_len, &new_len, all, (int) flags, hint_charset, double_encode TSRMLS_CC);\n\tif (new_len > INT_MAX) {\n\t\tefree(replaced);\n\t\tRETURN_FALSE;\n\t}\n\tRETVAL_STRINGL(replaced, (int)new_len, 0);\n}", "target": 0}
{"code": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n    if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n    incode = code;\n    if (code == avail) {      \n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}", "target": 0}
{"code": "static int jpegxl_anim_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    JXLAnimDemuxContext *ctx = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int ret;\n    int64_t size;\n    size_t offset = 0;\n    size = avio_size(pb);\n    if (size < 0)\n        return size;\n    if (size > INT_MAX)\n        return AVERROR(EDOM);\n    if (size == 0)\n        size = 4096;\n    if (ctx->initial && size < ctx->initial->size)\n        size = ctx->initial->size;\n    ret = av_new_packet(pkt, size);\n    if (ret < 0)\n        return ret;\n    if (ctx->initial) {\n        offset = ctx->initial->size;\n        memcpy(pkt->data, ctx->initial->data, offset);\n        av_buffer_unref(&ctx->initial);\n    }\n    ret = avio_read(pb, pkt->data + offset, size - offset);\n    if (ret < 0)\n        return ret;\n    if (ret < size - offset)\n        pkt->size = ret + offset;\n    return 0;\n}", "target": 0}
{"code": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  size_t i;\n  for (_Length=0, i=0; i<UTF8string.length(); _Length++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80)\n      i++;\n    else if ((lead >> 5) == 0x6)\n      i += 2;\n    else if ((lead >> 4) == 0xe)\n      i += 3;\n    else if ((lead >> 3) == 0x1e)\n      i += 4;\n    else\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<UTF8string.length(); j++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80) {\n      _Data[j] = lead;\n      i++;\n    } else if ((lead >> 5) == 0x6) {\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n      i += 2;\n    } else if ((lead >> 4) == 0xe) {\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n      i += 3;\n    } else if ((lead >> 3) == 0x1e) {\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n      i += 4;\n    } else\n      break;\n  }\n  _Data[j] = 0;\n}", "target": 1}
{"code": "redraw_win_toolbar(win_T *wp)\n{\n    vimmenu_T\t*menu;\n    int\t\titem_idx = 0;\n    int\t\titem_count = 0;\n    int\t\tcol = 0;\n    int\t\tnext_col;\n    int\t\toff = (int)(current_ScreenLine - ScreenLines);\n    int\t\tfill_attr = syn_name2attr((char_u *)\"ToolbarLine\");\n    int\t\tbutton_attr = syn_name2attr((char_u *)\"ToolbarButton\");\n    vim_free(wp->w_winbar_items);\n    FOR_ALL_CHILD_MENUS(wp->w_winbar, menu)\n\t++item_count;\n    wp->w_winbar_items = ALLOC_CLEAR_MULT(winbar_item_T, item_count + 1);\n    for (menu = wp->w_winbar->children;\n\t\t\t  menu != NULL && col < wp->w_width; menu = menu->next)\n    {\n\tspace_to_screenline(off + col, fill_attr);\n\tif (++col >= wp->w_width)\n\t    break;\n\tif (col > 1)\n\t{\n\t    space_to_screenline(off + col, fill_attr);\n\t    if (++col >= wp->w_width)\n\t\tbreak;\n\t}\n\twp->w_winbar_items[item_idx].wb_startcol = col;\n\tspace_to_screenline(off + col, button_attr);\n\tif (++col >= wp->w_width)\n\t    break;\n\tnext_col = text_to_screenline(wp, menu->name, col);\n\twhile (col < next_col)\n\t{\n\t    ScreenAttrs[off + col] = button_attr;\n\t    ++col;\n\t}\n\twp->w_winbar_items[item_idx].wb_endcol = col;\n\twp->w_winbar_items[item_idx].wb_menu = menu;\n\t++item_idx;\n\tif (col >= wp->w_width)\n\t    break;\n\tspace_to_screenline(off + col, button_attr);\n\t++col;\n    }\n    while (col < wp->w_width)\n    {\n\tspace_to_screenline(off + col, fill_attr);\n\t++col;\n    }\n    wp->w_winbar_items[item_idx].wb_menu = NULL; \n    screen_line(wp->w_winrow, wp->w_wincol, (int)wp->w_width,\n\t\t\t\t\t\t\t  (int)wp->w_width, 0);\n}", "target": 0}
{"code": "static void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       union cpu_time_count cpu,\n\t\t\t       struct timespec *tp)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ttp->tv_sec = div_long_long_rem(cpu.sched,\n\t\t\t\t\t       NSEC_PER_SEC, &tp->tv_nsec);\n\t} else {\n\t\tcputime_to_timespec(cpu.cpu, tp);\n\t}\n}", "target": 1}
{"code": "int __hnbad(const char *dotted)\n{\n\tunsigned char c, n, *cp;\n\tunsigned char buf[NS_MAXCDNAME];\n\tcp = (unsigned char *)dotted;\n\twhile ((c = *cp++))\n\t\tif (c < 0x21 || c > 0x7E)\n\t\t\treturn (1);\n\tif (ns_name_pton(dotted, buf, sizeof(buf)) < 0)\n\t\treturn (2);\n\tif (buf[0] > 0 && buf[1] == '-')\n\t\treturn (3);\n\tcp = buf;\n\twhile ((n = *cp++)) {\n\t\tif (n > 63)\n\t\t\treturn (4);\n\t\twhile (n--) {\n\t\t\tc = *cp++;\n\t\t\tif (c < '-' ||\n\t\t\t    (c > '-' && c < '0') ||\n\t\t\t    (c > '9' && c < 'A') ||\n\t\t\t    (c > 'Z' && c < '_') ||\n\t\t\t    (c > '_' && c < 'a') ||\n\t\t\t    c > 'z')\n\t\t\t\treturn (5);\n\t\t}\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "START_TEST(test_log_long_msg)\n{\n\tint lpc;\n\tint rc;\n\tint i, max = 1000;\n\tchar *buffer = calloc(1, max);\n\tqb_log_init(\"test\", LOG_USER, LOG_DEBUG);\n\trc = qb_log_ctl(QB_LOG_SYSLOG, QB_LOG_CONF_ENABLED, QB_FALSE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_SIZE, 1024);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_ctl(QB_LOG_BLACKBOX, QB_LOG_CONF_ENABLED, QB_TRUE);\n\tck_assert_int_eq(rc, 0);\n\trc = qb_log_filter_ctl(QB_LOG_BLACKBOX, QB_LOG_FILTER_ADD,\n\t\t\t  QB_LOG_FILTER_FILE, \"*\", LOG_TRACE);\n\tck_assert_int_eq(rc, 0);\n\tfor (lpc = 500; lpc < max; lpc++) {\n\t\tlpc++;\n\t\tfor(i = 0; i < max; i++) {\n\t\t\tbuffer[i] = 'a' + (i % 10);\n\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}", "target": 1}
{"code": "static int amf_get_field_value2(GetByteContext *gb,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n    while (bytestream2_peek_byte(gb) != AMF_DATA_TYPE_OBJECT && bytestream2_get_bytes_left(gb) > 0) {\n        int ret = amf_tag_skip(gb);\n        if (ret < 0)\n            return -1;\n    }\n    if (bytestream2_get_bytes_left(gb) < 3)\n        return -1;\n    bytestream2_get_byte(gb);\n    for (;;) {\n        int size = bytestream2_get_be16(gb);\n        if (!size)\n            break;\n        if (size < 0 || size >= bytestream2_get_bytes_left(gb))\n            return -1;\n        bytestream2_skip(gb, size);\n        if (size == namelen && !memcmp(gb->buffer-size, name, namelen)) {\n            switch (bytestream2_get_byte(gb)) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(bytestream2_get_be64(gb)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", bytestream2_get_byte(gb) ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream2_get_be16(gb);\n                if (dst_size < 1)\n                    return -1;\n                if (dst_size < len + 1)\n                    len = dst_size - 1;\n                bytestream2_get_buffer(gb, dst, len);\n                dst[len] = 0;\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = amf_tag_skip(gb);\n        if (len < 0 || bytestream2_get_bytes_left(gb) <= 0)\n            return -1;\n    }\n    return -1;\n}", "target": 0}
{"code": "unsigned int X509v3_addr_get_afi(const IPAddressFamily *f)\n{\n    return ((f != NULL &&\n             f->addressFamily != NULL && f->addressFamily->data != NULL)\n            ? ((f->addressFamily->data[0] << 8) | (f->addressFamily->data[1]))\n            : 0);\n}", "target": 1}
{"code": "static Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "validate_commit_metadata (GVariant   *commit_data,\n                          const char *ref,\n                          const char *required_metadata,\n                          gsize       required_metadata_size,\n                          GError   **error)\n{\n  g_autoptr(GVariant) commit_metadata = NULL;\n  g_autoptr(GVariant) xa_metadata_v = NULL;\n  const char *xa_metadata = NULL;\n  gsize xa_metadata_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  if (commit_metadata != NULL)\n    {\n      xa_metadata_v = g_variant_lookup_value (commit_metadata,\n                                              \"xa.metadata\",\n                                              G_VARIANT_TYPE_STRING);\n      if (xa_metadata_v)\n        xa_metadata = g_variant_get_string (xa_metadata_v, &xa_metadata_size);\n    }\n  if (xa_metadata == NULL ||\n      xa_metadata_size != required_metadata_size ||\n      memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                   _(\"Commit metadata for %s not matching expected metadata\"), ref);\n      return FALSE;\n    }\n  return TRUE;\n}", "target": 0}
{"code": "atmarp_spaddr_print(netdissect_options *ndo,\n\t\t    const struct atmarp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (ATMSPROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong splen>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, ATMSPA(ap))));\n}", "target": 0}
{"code": "comics_check_decompress_support\t(gchar          *mime_type,\n\t\t\t\t ComicsDocument *comics_document,\n\t\t\t\t GError         **error)\n{\n\tif (g_content_type_is_a (mime_type, \"application/x-cbr\") ||\n\t    g_content_type_is_a (mime_type, \"application/x-rar\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_RAR))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/zip\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_ZIP))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_7Z))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-tar\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_TAR))\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Not a comic book MIME type: %s\"),\n\t\t\t     mime_type);\n\t\t\t     return FALSE;\n\t}\n\tg_set_error_literal (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"libarchive lacks support for this comic books \"\n\t\t\t     \"compression, please contact your distributor\"));\n\treturn FALSE;\n}", "target": 0}
{"code": "Status ResourceHandle::BuildResourceHandle(const ResourceHandleProto& proto,\n                                           ResourceHandle* out) {\n  if (out == nullptr)\n    return errors::Internal(\n        \"BuildResourceHandle() was called with nullptr for the output\");\n  return out->FromProto(proto);\n}", "target": 0}
{"code": "void sctp_auth_calculate_hmac(const struct sctp_association *asoc,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      struct sctp_auth_chunk *auth,\n\t\t\t      gfp_t gfp)\n{\n\tstruct scatterlist sg;\n\tstruct hash_desc desc;\n\tstruct sctp_auth_bytes *asoc_key;\n\t__u16 key_id, hmac_id;\n\t__u8 *digest;\n\tunsigned char *end;\n\tint free_key = 0;\n\tkey_id = ntohs(auth->auth_hdr.shkey_id);\n\thmac_id = ntohs(auth->auth_hdr.hmac_id);\n\tif (key_id == asoc->active_key_id)\n\t\tasoc_key = asoc->asoc_shared_key;\n\telse {\n\t\tstruct sctp_shared_key *ep_key;\n\t\tep_key = sctp_auth_get_shkey(asoc, key_id);\n\t\tif (!ep_key)\n\t\t\treturn;\n\t\tasoc_key = sctp_auth_asoc_create_secret(asoc, ep_key, gfp);\n\t\tif (!asoc_key)\n\t\t\treturn;\n\t\tfree_key = 1;\n\t}\n\tend = skb_tail_pointer(skb);\n\tsg_init_one(&sg, auth, end - (unsigned char *)auth);\n\tdesc.tfm = asoc->ep->auth_hmacs[hmac_id];\n\tdesc.flags = 0;\n\tdigest = auth->auth_hdr.hmac;\n\tif (crypto_hash_setkey(desc.tfm, &asoc_key->data[0], asoc_key->len))\n\t\tgoto free;\n\tcrypto_hash_digest(&desc, &sg, sg.length, digest);\nfree:\n\tif (free_key)\n\t\tsctp_auth_key_put(asoc_key);\n}", "target": 0}
{"code": "int ip_options_get(struct net *net, struct ip_options **optp,\n\t\t   unsigned char *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen)\n\t\tmemcpy(opt->__data, data, optlen);\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}", "target": 1}
{"code": "static void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->card && timer->card->shutdown)\n\t\t\tcontinue;\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tif (timer->hw.resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    timer->hw.resolution / 1000,\n\t\t\t\t    timer->hw.resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}", "target": 0}
{"code": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}", "target": 1}
{"code": "Network::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}", "target": 1}
{"code": "void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)\n{\n    Q_UNUSED(bufferInfo);\n    if (!msg.contains(' '))\n        return;\n    QString target = msg.section(' ', 0, 0);\n    QByteArray encMsg = userEncode(target, msg.section(' ', 1));\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));\n#else\n    putPrivmsg(serverEncode(target), encMsg);\n#endif\n}", "target": 1}
{"code": "QTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\tcntsize(in, &sumlen, &nnode);\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\tfillQT(&state, in);\n\treturn out;\n}", "target": 0}
{"code": "  void encode(bufferlist& bl) const {\n    __u8 struct_v = 1;\n    ::encode(struct_v, bl);\n    ::encode(nonce, bl);\n  }", "target": 1}
{"code": "pick_table_access_method(JOIN_TAB *tab)\n{\n  switch (tab->type) \n  {\n  case JT_REF:\n    tab->read_first_record= join_read_always_key;\n    tab->read_record.read_record_func= join_read_next_same;\n    break;\n  case JT_REF_OR_NULL:\n    tab->read_first_record= join_read_always_key_or_null;\n    tab->read_record.read_record_func= join_read_next_same_or_null;\n    break;\n  case JT_CONST:\n    tab->read_first_record= join_read_const;\n    tab->read_record.read_record_func= join_no_more_records;\n    break;\n  case JT_EQ_REF:\n    tab->read_first_record= join_read_key;\n    tab->read_record.read_record_func= join_no_more_records;\n    break;\n  case JT_FT:\n    tab->read_first_record= join_ft_read_first;\n    tab->read_record.read_record_func= join_ft_read_next;\n    break;\n  case JT_SYSTEM:\n    tab->read_first_record= join_read_system;\n    tab->read_record.read_record_func= join_no_more_records;\n    break;\n  default:\n    break;  \n  }\n}", "target": 0}
{"code": "char *RootdExpandPathName(const char *name)\n{\n   const char *patbuf = name;\n   while (*patbuf == ' ')\n      patbuf++;\n   for (const char *p = patbuf; *p; p++)\n      if (strchr(shellMeta, *p))\n         goto needshell;\n   return strdup(name);\nneedshell:\n   char escPatbuf[kMAXPATHLEN];\n   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);\n   char cmd[kMAXPATHLEN];\n#ifdef __hpux\n   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));\n#else\n   strlcpy(cmd, \"echo \", sizeof(cmd));\n#endif\n   if (escPatbuf[0] == '~') {\n      const char *hd;\n      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {\n         char uname[70], *p, *q;\n         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)\n            *q++ = *p++;\n         *q = '\\0';\n         hd = HomeDirectory(uname);\n         if (hd == 0)\n            strcat(cmd, escPatbuf);\n         else {\n            strcat(cmd, hd);\n            strcat(cmd, p);\n         }\n      } else {\n         hd = HomeDirectory(0);\n         if (hd == 0) {\n            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");\n            return 0;\n         }\n         strcat(cmd, hd);\n         strcat(cmd, &escPatbuf[1]);\n      }\n   } else\n      strcat(cmd, escPatbuf);\n   FILE *pf;\n   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {\n      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);\n      return 0;\n   }\n   char expPatbuf[kMAXPATHLEN];\n   int  ch, i, cnt = 0;\nagain:\n   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {\n      expPatbuf[i] = ch;\n      cnt++;\n   }\n   if (cnt == 0 && ch == EOF) goto again;\n   expPatbuf[cnt] = '\\0';\n   while (ch != EOF) {\n      ch = fgetc(pf);\n      if (ch == ' ' || ch == '\\t') {\n         ::pclose(pf);\n         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");\n         return 0;\n      }\n   }\n   ::pclose(pf);\n   return strdup(expPatbuf);\n}", "target": 1}
{"code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\tmutex_lock(&dev->lock);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = 0;\nexit:\n\tmutex_unlock(&dev->lock);\n\treturn ret < 0 ? ret : -EIO;\n}", "target": 0}
{"code": "static bool php_mb_parse_encoding(const Variant& encoding,\n                                  mbfl_encoding ***return_list,\n                                  int *return_size, bool persistent) {\n  bool ret;\n  if (encoding.isArray()) {\n    ret = php_mb_parse_encoding_array(encoding.toArray(),\n                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}", "target": 1}
{"code": "static int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tstruct floppy_struct *g;\n\tint ret;\n\tret = get_floppy_geometry(drive, type, &g);\n\tif (ret)\n\t\treturn ret;\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\treturn 0;\n}", "target": 0}
{"code": "CoreBasicHandler::CoreBasicHandler(CoreNetwork *parent)\n    : BasicHandler(parent),\n    _network(parent)\n{\n    connect(this, SIGNAL(displayMsg(Message::Type, BufferInfo::Type, const QString &, const QString &, const QString &, Message::Flags)),\n        network(), SLOT(displayMsg(Message::Type, BufferInfo::Type, const QString &, const QString &, const QString &, Message::Flags)));\n    connect(this, SIGNAL(putCmd(QString, const QList<QByteArray> &, const QByteArray &)),\n        network(), SLOT(putCmd(QString, const QList<QByteArray> &, const QByteArray &)));\n    connect(this, SIGNAL(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)),\n        network(), SLOT(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)));\n    connect(this, SIGNAL(putRawLine(const QByteArray &)),\n        network(), SLOT(putRawLine(const QByteArray &)));\n}", "target": 0}
{"code": "static inline void skb_queue_splice_tail(const struct sk_buff_head *list,\n\t\t\t\t\t struct sk_buff_head *head)\n{\n\tif (!skb_queue_empty(list)) {\n\t\t__skb_queue_splice(list, head->prev, (struct sk_buff *) head);\n\t\thead->qlen += list->qlen;\n\t}\n}", "target": 0}
{"code": "get_char(_pdfio_token_t *tb)\t\t\n{\n  ssize_t\tbytes;\t\t\t\n  if (tb->bufptr >= tb->bufend)\n  {\n    if (tb->bufend > tb->buffer)\n    {\n      PDFIO_DEBUG(\"get_char: Consuming %d bytes.\\n\", (int)(tb->bufend - tb->buffer));\n      (tb->consume_cb)(tb->cb_data, (size_t)(tb->bufend - tb->buffer));\n    }\n    if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) <= 0)\n    {\n      tb->bufptr = tb->bufend = tb->buffer;\n      return (EOF);\n    }\n    tb->bufptr = tb->buffer;\n    tb->bufend = tb->buffer + bytes;\n#if 0\n#ifdef DEBUG\n    unsigned char *ptr;\t\t\t\n    PDFIO_DEBUG(\"get_char: Read '\");\n    for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)\n    {\n      if (*ptr < ' ' || *ptr == 0x7f)\n        PDFIO_DEBUG(\"\\\\%03o\", *ptr);\n      else\n        PDFIO_DEBUG(\"%c\", *ptr);\n    }\n    PDFIO_DEBUG(\"'\\n\");\n#endif \n#endif \n  }\n  return (*(tb->bufptr)++);\n}", "target": 0}
{"code": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n\tstruct se_cmd *cmd;\n\tstruct se_session *sess = ch->sess;\n\tuint64_t unpacked_lun;\n\tuint32_t tag = 0;\n\tint tcm_tmr;\n\tint rc;\n\tBUG_ON(!send_ioctx);\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n\tsend_ioctx->cmd.tag = srp_tsk->tag;\n\ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tif (tcm_tmr < 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\tgoto fail;\n\t}\n\tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n\t\t\t\t       sizeof(srp_tsk->lun));\n\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n\t\tif (rc < 0) {\n\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n\t\t\tgoto fail;\n\t\t}\n\t\ttag = srp_tsk->task_tag;\n\t}\n\trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n\t\t\t\tTARGET_SCF_ACK_KREF);\n\tif (rc != 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); \n}", "target": 1}
{"code": "snmp_oid_copy(uint32_t *dst, uint32_t *src)\n{\n  uint8_t i;\n  i = 0;\n  while(src[i] != ((uint32_t)-1)) {\n    dst[i] = src[i];\n    i++;\n  }\n  dst[i] = src[i];\n}", "target": 1}
{"code": "static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t     u64 param3, u64 param4)\n{\n\tint rc;\n\tu64 base_addr, size;\n\tif (get_securelevel() > 0)\n\t\treturn -EPERM;\n\tif (flags && (flags &\n\t\t~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))\n\t\treturn -EINVAL;\n\tif (!(param_extension || acpi5))\n\t\tgoto inject;\n\tif (type & ACPI5_VENDOR_BIT) {\n\t\tif (vendor_flags != SETWA_FLAGS_MEM)\n\t\t\tgoto inject;\n\t} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))\n\t\tgoto inject;\n\tbase_addr = param1 & param2;\n\tsize = ~param2 + 1;\n\tif (((param2 & PAGE_MASK) != PAGE_MASK) ||\n\t    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)\n\t\t\t\t!= REGION_INTERSECTS) &&\n\t     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)\n\t\t\t\t!= REGION_INTERSECTS)))\n\t\treturn -EINVAL;\ninject:\n\tmutex_lock(&einj_mutex);\n\trc = __einj_error_inject(type, flags, param1, param2, param3, param4);\n\tmutex_unlock(&einj_mutex);\n\treturn rc;\n}", "target": 0}
{"code": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}", "target": 1}
{"code": "    bool IsLoaded() {return Loaded;}", "target": 0}
{"code": "struct chunk *error_message(struct session *s, int msgnum)\n{\n\tif (s->be->errmsg[msgnum].str)\n\t\treturn &s->be->errmsg[msgnum];\n\telse if (s->fe->errmsg[msgnum].str)\n\t\treturn &s->fe->errmsg[msgnum];\n\telse\n\t\treturn &http_err_chunks[msgnum];\n}", "target": 0}
{"code": "njs_json_pop_parse_state(njs_vm_t *vm, njs_json_parse_t *parse)\n{\n    njs_json_state_t  *state;\n    state = &parse->states[parse->depth - 1];\n    njs_array_destroy(vm, state->keys);\n    state->keys = NULL;\n    if (parse->depth > 1) {\n        parse->depth--;\n        return &parse->states[parse->depth - 1];\n    }\n    return NULL;\n}", "target": 1}
{"code": "static gboolean match_hostname(const char *cert_hostname, const char *hostname)\n{\n\tconst char *hostname_left;\n\tif (!strcasecmp(cert_hostname, hostname)) { \n\t\treturn TRUE;\n\t} else if (cert_hostname[0] == '*' && cert_hostname[1] == '.' && cert_hostname[2] != 0) { \n\t\thostname_left = strchr(hostname, '.');\n\t\tif (hostname_left != NULL && ! strcasecmp(hostname_left + 1, cert_hostname + 2)) {\n\t\t\treturn TRUE;\n\t\t}\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,\n        const DetectEngineTransforms *transforms, Flow *f, const struct MpmListIdDataArgs *cbdata,\n        int list_id)\n{\n    SCEnter();\n    InspectionBuffer *buffer =\n            InspectionBufferMultipleForListGet(det_ctx, list_id, cbdata->local_id);\n    if (buffer == NULL)\n        return NULL;\n    if (buffer->initialized)\n        return buffer;\n    HttpHeaderThreadData *hdr_td = NULL;\n    HttpHeaderBuffer *buf =\n            HttpHeaderGetBufferSpace(det_ctx, f, flags, g_keyword_thread_id, &hdr_td);\n    if (unlikely(buf == NULL)) {\n        return NULL;\n    }\n    htp_tx_t *tx = (htp_tx_t *)cbdata->txv;\n    htp_table_t *headers;\n    if (flags & STREAM_TOSERVER) {\n        headers = tx->request_headers;\n    } else {\n        headers = tx->response_headers;\n    }\n    if (cbdata->local_id < htp_table_size(headers)) {\n        htp_header_t *h = htp_table_get_index(headers, cbdata->local_id, NULL);\n        size_t size1 = bstr_size(h->name);\n        size_t size2 = bstr_size(h->value);\n        size_t b_len = size1 + 2 + size2;\n        if (b_len > buf->size) {\n            if (HttpHeaderExpandBuffer(hdr_td, buf, b_len) != 0) {\n                return NULL;\n            }\n        }\n        memcpy(buf->buffer, bstr_ptr(h->name), bstr_size(h->name));\n        buf->buffer[size1] = ':';\n        buf->buffer[size1 + 1] = ' ';\n        memcpy(buf->buffer + size1 + 2, bstr_ptr(h->value), bstr_size(h->value));\n        buf->len = b_len;\n    } else {\n        InspectionBufferSetupMultiEmpty(buffer);\n        return NULL;\n    }\n    if (buf->len == 0) {\n        InspectionBufferSetupMultiEmpty(buffer);\n        return NULL;\n    }\n    InspectionBufferSetupMulti(buffer, transforms, buf->buffer, buf->len);\n    SCReturnPtr(buffer, \"InspectionBuffer\");\n}", "target": 1}
{"code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\tif (!rdp || !rdp->fips_decrypt)\n\t\treturn FALSE;\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "  explicit ThreadPoolHandleOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"display_name\", &display_name_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_threads\", &num_threads_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"max_intra_op_parallelism\",\n                                     &max_intra_op_parallelism_));\n    OP_REQUIRES(\n        ctx, num_threads_ > 0,\n        errors::InvalidArgument(\"`num_threads` must be greater than zero.\"));\n  }", "target": 1}
{"code": "GF_Box *encs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_MPEGSampleEntryBox, GF_ISOM_BOX_TYPE_ENCS);\n\tgf_isom_sample_entry_init((GF_SampleEntryBox*)tmp);\n\ttmp->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n\treturn (GF_Box *)tmp;\n}", "target": 1}
{"code": "TfLiteStatus EvalHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n  const int resource_id = std::hash<std::string>{}(params->table_name);\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  auto* resource_handle_data =\n      GetTensorData<std::int32_t>(resource_handle_tensor);\n  resource_handle_data[0] = resource_id;\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  resource::CreateHashtableResourceIfNotAvailable(\n      &resources, resource_id, params->key_dtype, params->value_dtype);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "inline int MatchingDim(const RuntimeShape& shape1, int index1,\n                       const RuntimeShape& shape2, int index2) {\n  TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2));\n  return shape1.Dims(index1);\n}", "target": 1}
{"code": "static int find_low_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=0;i<=31;i++) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int user_match(const struct key *key, const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             TfLiteMulParams* params, OpData* data) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInput1Tensor);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInput2Tensor);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n    double real_multiplier = static_cast<double>(input1->params.scale) *\n                             static_cast<double>(input2->params.scale) /\n                             static_cast<double>(output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier,\n                       &data->output_shift);\n    data->input1_zero_point = input1->params.zero_point;\n    data->input2_zero_point = input2->params.zero_point;\n    data->output_zero_point = output->params.zero_point;\n  } else {\n    CalculateActivationRange(params->activation,\n                             &data->output_activation_min_f32,\n                             &data->output_activation_max_f32);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int mov_read_covr(MOVContext *c, AVIOContext *pb, int type, int len)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    int ret;\n    switch (type) {\n    case 0xd:  id = AV_CODEC_ID_MJPEG; break;\n    case 0xe:  id = AV_CODEC_ID_PNG;   break;\n    case 0x1b: id = AV_CODEC_ID_BMP;   break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown cover type: 0x%x.\\n\", type);\n        avio_skip(pb, len);\n        return 0;\n    }\n    sc = av_mallocz(sizeof(*sc));\n    if (!sc)\n        return AVERROR(ENOMEM);\n    ret = ff_add_attached_pic(c->fc, NULL, pb, NULL, len);\n    if (ret < 0) {\n        av_free(sc);\n        return ret;\n    }\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    st->priv_data = sc;\n    if (st->attached_pic.size >= 8 && id != AV_CODEC_ID_BMP) {\n        if (AV_RB64(st->attached_pic.data) == 0x89504e470d0a1a0a) {\n            id = AV_CODEC_ID_PNG;\n        } else {\n            id = AV_CODEC_ID_MJPEG;\n        }\n    }\n    st->codecpar->codec_id   = id;\n    return 0;\n}", "target": 0}
{"code": "static RList* entries(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinAddr* addr = NULL;\n\tpsxexe_header psxheader;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tif (!(addr = R_NEW0 (RBinAddr))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"PSXEXE Header truncated\\n\");\n\t\tr_list_free (ret);\n\t\tfree (addr);\n\t\treturn NULL;\n\t}\n\taddr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;\n\taddr->vaddr = psxheader.pc0;\n\tr_list_append (ret, addr);\n\treturn ret;\n}", "target": 1}
{"code": "spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}", "target": 1}
{"code": "authDigestNonceLink(digest_nonce_h * nonce)\n{\n    assert(nonce != NULL);\n    ++nonce->references;\n    assert(nonce->references != 0); \n    debugs(29, 9, \"nonce '\" << nonce << \"' now at '\" << nonce->references << \"'.\");\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_string_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_STRING );\n}", "target": 1}
{"code": "void _WM_do_pitch(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pitch = data->data.value - 0x2000;\n    if (mdi->channel[ch].pitch < 0) {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8192;\n    } else {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8191;\n    }\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->sample_inc = get_inc(mdi, note_data);\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}", "target": 0}
{"code": "static BOOL rectangle_contained_in_band(const RECTANGLE_16* band, const RECTANGLE_16* endPtr,\n                                        const RECTANGLE_16* rect)\n{\n\tUINT16 refY = band->top;\n\tif ((band->top > rect->top) || (rect->bottom > band->bottom))\n\t\treturn FALSE;\n\twhile ((band < endPtr) && (band->top == refY) && (band->left <= rect->left))\n\t{\n\t\tif (rect->right <= band->right)\n\t\t\treturn TRUE;\n\t\tband++;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "ecma_op_function_call_native (ecma_object_t *func_obj_p, \n                              ecma_value_t this_arg_value, \n                              const ecma_value_t *arguments_list_p, \n                              uint32_t arguments_list_len) \n{\n  JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_NATIVE_FUNCTION);\n  ECMA_CHECK_STACK_USAGE ();\n  ecma_native_function_t *native_function_p = (ecma_native_function_t *) func_obj_p;\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) =\n    ECMA_GET_INTERNAL_VALUE_POINTER (ecma_global_object_t, native_function_p->realm_value);\n#endif \n  jerry_call_info_t call_info;\n  call_info.function = ecma_make_object_value (func_obj_p);\n  call_info.this_value = this_arg_value;\n  ecma_object_t *new_target_p = JERRY_CONTEXT (current_new_target_p);\n  call_info.new_target = (new_target_p == NULL) ? ECMA_VALUE_UNDEFINED : ecma_make_object_value (new_target_p);\n  JERRY_ASSERT (native_function_p->native_handler_cb != NULL);\n  ecma_value_t ret_value = native_function_p->native_handler_cb (&call_info, arguments_list_p, arguments_list_len);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  if (JERRY_UNLIKELY (ecma_is_value_exception (ret_value)))\n  {\n    ecma_throw_exception (ret_value);\n    return ECMA_VALUE_ERROR;\n  }\n#if JERRY_DEBUGGER\n  JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);\n#endif \n  return ret_value;\n} ", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_indices_in = context->input(0);\n    const Tensor& input_shape_in = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n                errors::InvalidArgument(\"Input must be a matrix.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector.\"));\n    OP_REQUIRES(context,\n                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),\n                errors::InvalidArgument(\n                    \"Input tensor rank must match input shape length.\"));\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 0}
{"code": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + pos + s_len, s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}", "target": 1}
{"code": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n  m_version = data[0];\n  m_flags = data[1];\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n    return Error(heif_error_Unsupported_feature,\n                 heif_suberror_Unsupported_data_version,\n                 sstr.str());\n  }\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n  m_offsets.resize(num_images);\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n  return Error::Ok;\n}", "target": 1}
{"code": "void MoveTo(double x1,double y1) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f m\",x1,y1);\n}", "target": 1}
{"code": "static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\tu32 off;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "    std::ostream& operator<<(std::ostream& os, const Rational& r)\n    {\n        return os << r.first << \"/\" << r.second;\n    }", "target": 0}
{"code": "addnode(struct env *env, const char *key, const char *value)\n{\n\tstruct envnode *node;\n\tnode = createnode(key, value);\n\tRB_INSERT(envtree, &env->root, node);\n\tenv->count++;\n}", "target": 0}
{"code": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\tgpio_dev = platform_get_drvdata(pdev);\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\treturn 0;\n}", "target": 1}
{"code": "void LinkResolver::check_field_loader_constraints(Symbol* field, Symbol* sig,\n                                                  Klass* current_klass,\n                                                  Klass* sel_klass, TRAPS) {\n  Handle ref_loader(THREAD, current_klass->class_loader());\n  Handle sel_loader(THREAD, sel_klass->class_loader());\n  ResourceMark rm(THREAD);  \n  Symbol* failed_type_symbol =\n    SystemDictionary::check_signature_loaders(sig,\n                                              ref_loader, sel_loader,\n                                              false,\n                                              CHECK);\n  if (failed_type_symbol != NULL) {\n    stringStream ss;\n    const char* failed_type_name = failed_type_symbol->as_klass_external_name();\n    ss.print(\"loader constraint violation: when resolving field\"\n             \" \\\"%s\\\" of type %s, the class loader %s of the current class, \"\n             \"%s, and the class loader %s for the field's defining \"\n             \"type, %s, have different Class objects for type %s (%s; %s)\",\n             field->as_C_string(),\n             failed_type_name,\n             current_klass->class_loader_data()->loader_name_and_id(),\n             current_klass->external_name(),\n             sel_klass->class_loader_data()->loader_name_and_id(),\n             sel_klass->external_name(),\n             failed_type_name,\n             current_klass->class_in_module_of_loader(false, true),\n             sel_klass->class_in_module_of_loader(false, true));\n    THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n  }\n}", "target": 0}
{"code": "MYSOFA_EXPORT struct MYSOFA_HRTF* mysofa_load(const char *filename, int *err) {\n\tstruct READER reader;\n\tstruct MYSOFA_HRTF *hrtf = NULL;\n\tif (filename == NULL)\n\t\tfilename = CMAKE_INSTALL_PREFIX \"/share/libmysofa/default.sofa\";\n\tif (strcmp(filename, \"-\"))\n\t\treader.fhd = fopen(filename, \"rb\");\n\telse\n\t\treader.fhd = stdin;\n\tif (!reader.fhd) {\n\t\tlog(\"cannot open file %s\\n\", filename);\n\t\t*err = errno;\n\t\treturn NULL;\n\t}\n\treader.gcol = NULL;\n\treader.all = NULL;\n\treader.recursive_counter = 0;\n\t*err = superblockRead(&reader, &reader.superblock);\n\tif (!*err) {\n\t\thrtf = getHrtf(&reader, err);\n\t}\n\tsuperblockFree(&reader, &reader.superblock);\n\tgcolFree(reader.gcol);\n\tif (strcmp(filename, \"-\"))\n\t\tfclose(reader.fhd);\n\treturn hrtf;\n}", "target": 0}
{"code": "CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config,\n    Api::Api& api)\n    : ca_cert_(Config::DataSource::read(config.trusted_ca(), true, api)),\n      ca_cert_path_(Config::DataSource::getPath(config.trusted_ca())\n                        .value_or(ca_cert_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      certificate_revocation_list_(Config::DataSource::read(config.crl(), true, api)),\n      certificate_revocation_list_path_(\n          Config::DataSource::getPath(config.crl())\n              .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      subject_alt_name_matchers_(config.match_subject_alt_names().begin(),\n                                 config.match_subject_alt_names().end()),\n      verify_certificate_hash_list_(config.verify_certificate_hash().begin(),\n                                    config.verify_certificate_hash().end()),\n      verify_certificate_spki_list_(config.verify_certificate_spki().begin(),\n                                    config.verify_certificate_spki().end()),\n      allow_expired_certificate_(config.allow_expired_certificate()),\n      trust_chain_verification_(config.trust_chain_verification()),\n      custom_validator_config_(\n          config.has_custom_validator_config()\n              ? absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>(\n                    config.custom_validator_config())\n              : absl::nullopt),\n      api_(api), only_verify_leaf_cert_crl_(config.only_verify_leaf_cert_crl()) {\n  if (ca_cert_.empty() && custom_validator_config_ == absl::nullopt) {\n    if (!certificate_revocation_list_.empty()) {\n      throw EnvoyException(fmt::format(\"Failed to load CRL from {} without trusted CA\",\n                                       certificateRevocationListPath()));\n    }\n    if (!subject_alt_name_matchers_.empty()) {\n      throw EnvoyException(\"SAN-based verification of peer certificates without \"\n                           \"trusted CA is insecure and not allowed\");\n    }\n    if (allow_expired_certificate_) {\n      throw EnvoyException(\"Certificate validity period is always ignored without trusted CA\");\n    }\n  }\n}", "target": 1}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,\n                                     const gss_ctx_id_t context_handle,\n                                     const gss_OID desired_object,\n                                     gss_buffer_set_t *data_set)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    size_t i;\n    if (minor_status == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n    *minor_status = 0;\n    if (desired_object == GSS_C_NO_OID)\n        return GSS_S_CALL_INACCESSIBLE_READ;\n    if (data_set == NULL)\n        return GSS_S_CALL_INACCESSIBLE_WRITE;\n    *data_set = GSS_C_NO_BUFFER_SET;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (!ctx->established)\n        return GSS_S_NO_CONTEXT;\n    for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/\n             sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {\n        if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {\n            return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,\n                                                                      context_handle,\n                                                                      desired_object,\n                                                                      data_set);\n        }\n    }\n    *minor_status = EINVAL;\n    return GSS_S_UNAVAILABLE;\n}", "target": 1}
{"code": "bgp_capability_mp (struct peer *peer, struct capability *cap)\n{\n  if (ntohs (cap->mpc.afi) == AFI_IP)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST) \n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == BGP_SAFI_VPNV4)\n\t{\n\t  peer->afc_recv[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  if (peer->afc[AFI_IP][SAFI_MPLS_VPN])\n\t    peer->afc_nego[AFI_IP][SAFI_MPLS_VPN] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#ifdef HAVE_IPV6\n  else if (ntohs (cap->mpc.afi) == AFI_IP6)\n    {\n      if (cap->mpc.safi == SAFI_UNICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_UNICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else if (cap->mpc.safi == SAFI_MULTICAST)\n\t{\n\t  peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  if (peer->afc[AFI_IP6][SAFI_MULTICAST])\n\t    peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 1;\n\t  else\n\t    return -1;\n\t}\n      else\n\treturn -1;\n    }\n#endif \n  else\n    {\n      return -1;\n    }\n  return 0;\n}", "target": 1}
{"code": "void mb2_cache_destroy(struct mb2_cache *cache)\n{\n\tstruct mb2_cache_entry *entry, *next;\n\tunregister_shrinker(&cache->c_shrink);\n\tlist_for_each_entry_safe(entry, next, &cache->c_lru_list, e_lru_list) {\n\t\tif (!hlist_bl_unhashed(&entry->e_hash_list)) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t} else\n\t\t\tWARN_ON(1);\n\t\tlist_del(&entry->e_lru_list);\n\t\tWARN_ON(atomic_read(&entry->e_refcnt) != 1);\n\t\tmb2_cache_entry_put(cache, entry);\n\t}\n\tkfree(cache->c_hash);\n\tkfree(cache);\n\tmodule_put(THIS_MODULE);\n}", "target": 0}
{"code": "bgp_attr_unintern (struct attr **attr)\n{\n  struct attr *ret;\n  struct attr tmp;\n  (*attr)->refcnt--;\n  tmp = *(*attr);\n  if ((*attr)->extra)\n    {\n      tmp.extra = bgp_attr_extra_new ();\n      memcpy (tmp.extra, (*attr)->extra, sizeof (struct attr_extra));\n    }\n  if ((*attr)->refcnt == 0)\n    {    \n      ret = hash_release (attrhash, *attr);\n      assert (ret != NULL);\n      bgp_attr_extra_free (*attr);\n      XFREE (MTYPE_ATTR, *attr);\n      *attr = NULL;\n    }\n  bgp_attr_unintern_sub (&tmp);\n  bgp_attr_extra_free (&tmp);\n}", "target": 0}
{"code": "void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Write(s, fields->Buffer, fields->Len);\n\t}\n}", "target": 1}
{"code": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\treturn sprintf(buf, \"%d\\n\", count);\n}", "target": 1}
{"code": "yang_free_nodes(struct ly_ctx *ctx, struct lys_node *node)\n{\n    struct lys_node *tmp, *child, *sibling;\n    if (!node) {\n        return;\n    }\n    tmp = node;\n    while (tmp) {\n        child = tmp->child;\n        sibling = tmp->next;\n        lydict_remove(ctx, tmp->name);\n        if (!(tmp->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            lys_iffeature_free(ctx, tmp->iffeature, tmp->iffeature_size, 0, NULL);\n            lydict_remove(ctx, tmp->dsc);\n            lydict_remove(ctx, tmp->ref);\n        }\n        switch (tmp->nodetype) {\n        case LYS_GROUPING:\n        case LYS_RPC:\n        case LYS_ACTION:\n            yang_free_grouping(ctx, (struct lys_node_grp *)tmp);\n            break;\n        case LYS_CONTAINER:\n            yang_free_container(ctx, (struct lys_node_container *)tmp);\n            break;\n        case LYS_LEAF:\n            yang_free_leaf(ctx, (struct lys_node_leaf *)tmp);\n            break;\n        case LYS_LEAFLIST:\n            yang_free_leaflist(ctx, (struct lys_node_leaflist *)tmp);\n            break;\n        case LYS_LIST:\n            yang_free_list(ctx, (struct lys_node_list *)tmp);\n            break;\n        case LYS_CHOICE:\n            yang_free_choice(ctx, (struct lys_node_choice *)tmp);\n            break;\n        case LYS_CASE:\n            lys_when_free(ctx, ((struct lys_node_case *)tmp)->when, NULL);\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            yang_free_anydata(ctx, (struct lys_node_anydata *)tmp);\n            break;\n        case LYS_INPUT:\n        case LYS_OUTPUT:\n            yang_free_inout(ctx, (struct lys_node_inout *)tmp);\n            break;\n        case LYS_NOTIF:\n            yang_free_notif(ctx, (struct lys_node_notif *)tmp);\n            break;\n        case LYS_USES:\n            yang_free_uses(ctx, (struct lys_node_uses *)tmp);\n            break;\n        default:\n            break;\n        }\n        lys_extension_instances_free(ctx, tmp->ext, tmp->ext_size, NULL);\n        yang_free_nodes(ctx, child);\n        free(tmp);\n        tmp = sibling;\n    }\n}", "target": 0}
{"code": "void flash_option_bytes_init(int boot_from_dfu)\n{\n    uint32_t val = 0xfffff8aa;\n    if (boot_from_dfu){\n        val &= ~(1<<27); \n    }\n    else {\n        if (solo_is_locked())\n        {\n            val = 0xfffff8cc;\n        }\n    }\n    val &= ~(1<<26); \n    val &= ~(1<<25); \n    val &= ~(1<<24); \n    if (FLASH->OPTR == val)\n    {\n        return;\n    }\n    __disable_irq();\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_unlock();\n    if (FLASH->CR & (1<<30))\n    {\n        FLASH->OPTKEYR = 0x08192A3B;\n        FLASH->OPTKEYR = 0x4C5D6E7F;\n    }\n    FLASH->OPTR =val;\n    FLASH->CR |= (1<<17);\n    while (FLASH->SR & (1<<16))\n        ;\n    flash_lock();\n    __enable_irq();\n}", "target": 1}
{"code": "mm_memvalid(struct mm_master *mm, void *address, size_t size)\n{\n\tvoid *end = (char *)address + size;\n\tif (address < mm->address)\n\t\tfatal(\"mm_memvalid: address too small: %p\", address);\n\tif (end < address)\n\t\tfatal(\"mm_memvalid: end < address: %p < %p\", end, address);\n\tif (end > MM_ADDRESS_END(mm))\n\t\tfatal(\"mm_memvalid: address too large: %p\", address);\n}", "target": 1}
{"code": "Client::connect()\n{\n    if (m_stream != NULL) {\n        return;\n    }\n    if (m_suspended) {\n        m_connectOnResume = true;\n        return;\n    }\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (m_useSecureNetwork) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n    }\n    try {\n        m_serverAddress.resolve();\n        if (m_serverAddress.getAddress() != NULL) {\n          LOG((CLOG_NOTE \"connecting to '%s': %s:%i\",\n          m_serverAddress.getHostname().c_str(),\n          ARCH->addrToString(m_serverAddress.getAddress()).c_str(),\n          m_serverAddress.getPort()));\n        }\n        IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),\n                                                      security_level);\n        m_socket = dynamic_cast<TCPSocket*>(socket);\n        m_stream = socket;\n        m_stream = new PacketStreamFilter(m_events, m_stream, true);\n        LOG((CLOG_DEBUG1 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        socket->connect(m_serverAddress);\n    }\n    catch (XBase& e) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((CLOG_DEBUG1 \"connection failed\"));\n        sendConnectionFailedEvent(e.what());\n        return;\n    }\n}", "target": 1}
{"code": "static int __init xfrm6_tunnel_init(void)\n{\n\tint rv;\n\trv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);\n\tif (rv < 0)\n\t\tgoto err;\n\trv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);\n\tif (rv < 0)\n\t\tgoto unreg;\n\trv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);\n\tif (rv < 0)\n\t\tgoto dereg6;\n\trv = xfrm6_tunnel_spi_init();\n\tif (rv < 0)\n\t\tgoto dereg46;\n\trv = register_pernet_subsys(&xfrm6_tunnel_net_ops);\n\tif (rv < 0)\n\t\tgoto deregspi;\n\treturn 0;\nderegspi:\n\txfrm6_tunnel_spi_fini();\ndereg46:\n\txfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);\ndereg6:\n\txfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);\nunreg:\n\txfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);\nerr:\n\treturn rv;\n}", "target": 1}
{"code": "static TEE_Result do_allocate_publickey(struct dsa_public_key *key,\n\t\t\t\t\tsize_t l_bits, size_t n_bits)\n{\n\tDSA_TRACE(\"DSA Allocate Public of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "gopherSendRequest(int, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *)data;\n    MemBuf mb;\n    mb.init();\n    if (gopherState->type_id == GOPHER_CSO) {\n        const char *t = strchr(gopherState->request, '?');\n        if (t)\n            ++t;        \n        else\n            t = \"\";\n        mb.appendf(\"query %s\\r\\nquit\", t);\n    } else {\n        if (gopherState->type_id == GOPHER_INDEX) {\n            if (char *t = strchr(gopherState->request, '?'))\n                *t = '\\t';\n        }\n        mb.append(gopherState->request, strlen(gopherState->request));\n    }\n    mb.append(\"\\r\\n\", 2);\n    debugs(10, 5, gopherState->serverConn);\n    AsyncCall::Pointer call = commCbCall(5,5, \"gopherSendComplete\",\n                                         CommIoCbPtrFun(gopherSendComplete, gopherState));\n    Comm::Write(gopherState->serverConn, &mb, call);\n    if (!gopherState->entry->makePublic())\n        gopherState->entry->makePrivate(true);\n}", "target": 1}
{"code": "static void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t index = size > 0? (size - 1) % s: 0;\n\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\tindex = 0;\n\t\t}\n\t\tut64 mask = bitmask_by_width[index];\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\t\tif (shift > 0 && shift < 64) {\n\t\t\tr_strbuf_appendf (sb, \"%d,SWAP,0x%\"PFMT64x\",&,<<,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tshift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);\n\t\t} else {\n\t\t\tint dimsize = size % 64;\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",&,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tmask, REG64 (n), regc, VEC64_MASK (shift, dimsize), REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}", "target": 1}
{"code": "int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  char **_filter, char ***_domains)\n{\n    int ret;\n    struct match_map_rule *r;\n    struct priority_list *p;\n    struct sss_cert_content *cert_content = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    size_t c;\n    if (_filter == NULL || _domains == NULL) {\n        return EINVAL;\n    }\n    ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content);\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to get certificate content [%d].\", ret);\n        return ret;\n    }\n    if (ctx->prio_list == NULL) {\n        if (ctx->default_mapping_rule == NULL) {\n            CM_DEBUG(ctx, \"No matching or mapping rules available.\");\n            return EINVAL;\n        }\n        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, &filter);\n        goto done;\n    }\n    for (p = ctx->prio_list; p != NULL; p = p->next) {\n        for (r = p->rule_list; r != NULL; r = r->next) {\n            ret = do_match(ctx, r->parsed_match_rule, cert_content);\n            if (ret == 0) {\n                ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n                                 &filter);\n                if (ret != 0) {\n                    CM_DEBUG(ctx, \"Failed to get filter\");\n                    goto done;\n                }\n                if (r->domains != NULL) {\n                    for (c = 0; r->domains[c] != NULL; c++);\n                    domains = talloc_zero_array(ctx, char *, c + 1);\n                    if (domains == NULL) {\n                        ret = ENOMEM;\n                        goto done;\n                    }\n                    for (c = 0; r->domains[c] != NULL; c++) {\n                        domains[c] = talloc_strdup(domains, r->domains[c]);\n                        if (domains[c] == NULL) {\n                            ret = ENOMEM;\n                            goto done;\n                        }\n                    }\n                }\n                ret = 0;\n                goto done;\n            }\n        }\n    }\n    ret = ENOENT;\ndone:\n    talloc_free(cert_content);\n    if (ret == 0) {\n        *_filter = filter;\n        *_domains = domains;\n    } else {\n        talloc_free(filter);\n        talloc_free(domains);\n    }\n    return ret;\n}", "target": 1}
{"code": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}", "target": 1}
{"code": "tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n\t\tif (sctp_chunk_pending(ack))\n\t\t\tcontinue;\n\t\tif (ack->subh.addip_hdr->serial == serial) {\n\t\t\tsctp_chunk_hold(ack);\n\t\t\treturn ack;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "_XimEncodeSavedStatusValue(\n    Xic\t\t\t  ic,\n    XIMResourceList\t  res,\n    XPointer\t\t  value)\n{\n    int\t\t\t  list_ret;\n    XFontStruct\t\t**struct_list;\n    char\t\t**name_list;\n    char\t\t *tmp;\n    int\t\t\t  len;\n    register int\t  i;\n    if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tif (!value)\n\t    return False;\n\tXfree(ic->private.proto.status_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)value,\n\t\t\t\t\t\t&struct_list, &name_list);\n\tfor(i = 0, len = 0; i < list_ret; i++) {\n\t    len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif(!(tmp = Xmalloc(len + 1))) {\n\t    ic->private.proto.status_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.status_font        = tmp;\n\tic->private.proto.status_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "delete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_DELETE;\n        log_unauth(\"kadm5_delete_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_delete_principal((void *)handle, arg->princ);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_delete_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "int IniSection::Write (const YCPPath&p, const YCPValue&v, bool rewrite)\n{\n    if (ip->isFlat ())\n\treturn setValueFlat (p, v);\n    if (p->length() >= 1 && p->component_str (0) == \"all\")\n    {\n\treturn setAll (p, v, 1);\n    }\n    if (p->length() < 2)\n    {\n\ty2error (\"I do not know what to write to %s.\", p->toString().c_str());\n\treturn -1;\n    }\n    string s = p->component_str (0);\n    if (s == \"v\" || s == \"value\")\n\treturn setValue (p, v, 0, 1);\n    if (s == \"vc\" || s == \"value_comment\" || s == \"valuecomment\")\n      return setValue (p, v, 1, 1);\n    if (s == \"vt\" || s == \"value_type\" || s == \"valuetype\")\n      return setValue (p, v, 2, 1);\n    if (s == \"s\" || s == \"section\" || s == \"sc\" || s == \"section_comment\" || s == \"sectioncomment\")\n      return setSectionProp (p, v, 0, 1);\n    if (s == \"st\" || s == \"section_type\" || s == \"sectiontype\")\n      return setSectionProp (p, v, rewrite? 1:2, 1);\n    if (s == \"section_private\")\n      return setSectionProp (p, v, 3, 1);\n    return -1;\n}", "target": 0}
{"code": "xfs_bmap_unmap_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_defer_ops\t*dfops,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*PREV)\n{\n\tif (!xfs_bmap_is_update_needed(PREV))\n\t\treturn 0;\n\treturn __xfs_bmap_add(mp, dfops, XFS_BMAP_UNMAP, ip,\n\t\t\tXFS_DATA_FORK, PREV);\n}", "target": 0}
{"code": "static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint opts;\n\tResub m;\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushboolean(J, 0);\n}", "target": 1}
{"code": "agoo_con_create(agooErr err, int sock, uint64_t id, agooBind b) {\n    agooCon\tc;\n    if (NULL == (c = (agooCon)AGOO_CALLOC(1, sizeof(struct _agooCon)))) {\n\tAGOO_ERR_MEM(err, \"Connection\");\n    } else {\n\tstruct sockaddr_storage\taddr;\n\tsocklen_t\t\tlen = sizeof(addr);\n\tgetpeername(sock, (struct sockaddr*)&addr, &len);\n\tif (addr.ss_family == AF_INET) {\n\t    struct sockaddr_in\t*s = (struct sockaddr_in*)&addr;\n\t    inet_ntop(AF_INET, &s->sin_addr, c->remote, sizeof(c->remote));\n\t} else {\n\t    struct sockaddr_in6\t*s = (struct sockaddr_in6*)&addr;\n\t    inet_ntop(AF_INET6, &s->sin6_addr, c->remote, sizeof(c->remote));\n\t}\n\tc->sock = sock;\n\tc->id = id;\n\tc->timeout = dtime() + CON_TIMEOUT;\n\tc->bind = b;\n\tc->loop = NULL;\n\tpthread_mutex_init(&c->res_lock, 0);\n    }\n    return c;\n}", "target": 0}
{"code": "static char *get_header(FILE *fp)\n{\n    long start;\n    char *header;\n    header = calloc(1, 1024);\n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}", "target": 1}
{"code": "static void spl_array_rewind_ex(spl_array_object *intern, HashTable *aht TSRMLS_DC) \n{\n\tzend_hash_internal_pointer_reset_ex(aht, &intern->pos);\n\tspl_array_update_pos(intern);\n\tspl_array_skip_protected(intern, aht TSRMLS_CC);\n} ", "target": 0}
{"code": "static int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct br_mdb_entry *entry, u32 pid,\n\t\t\t\t   u32 seq, int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *nest, *nest2;\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\tgoto cancel;\n\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\tif (nest2 == NULL)\n\t\tgoto end;\n\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\n\t\tgoto end;\n\tnla_nest_end(skb, nest2);\n\tnla_nest_end(skb, nest);\n\treturn nlmsg_end(skb, nlh);\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static int oidc_cache_crypto_decrypt_impl(request_rec *r,\n\t\tunsigned char *ciphertext, int ciphertext_len, const unsigned char *aad,\n\t\tint aad_len, const unsigned char *tag, int tag_len, unsigned char *key,\n\t\tconst unsigned char *iv, int iv_len, unsigned char *plaintext) {\n\tEVP_CIPHER_CTX *ctx;\n\tint len;\n\tint plaintext_len;\n\tint ret;\n\tif (!(ctx = EVP_CIPHER_CTX_new())) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_new\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptInit_ex(ctx, OIDC_CACHE_CIPHER, NULL, NULL, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_IVLEN, iv_len, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptUpdate(ctx, NULL, &len, aad, aad_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate aad: aad_len=%d\",\n\t\t\t\taad_len);\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate ciphertext\");\n\t\treturn -1;\n\t}\n\tplaintext_len = len;\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_TAG, tag_len,\n\t\t\t(void *) tag)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tret = EVP_DecryptFinal_ex(ctx, plaintext + len, &len);\n\tEVP_CIPHER_CTX_free(ctx);\n\tif (ret > 0) {\n\t\tplaintext_len += len;\n\t\treturn plaintext_len;\n\t} else {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptFinal_ex\");\n\t\treturn -1;\n\t}\n}", "target": 1}
{"code": "gopherEndHTML(GopherStateData * gopherState)\n{\n    StoreEntry *e = gopherState->entry;\n    if (!gopherState->HTML_header_added) {\n        gopherHTMLHeader(e, \"Server Return Nothing\", nullptr);\n        storeAppendPrintf(e, \"<P>The Gopher query resulted in a blank response</P>\");\n    } else if (gopherState->HTML_pre) {\n        storeAppendPrintf(e, \"</PRE>\\n\");\n    }\n    gopherHTMLFooter(e);\n}", "target": 1}
{"code": "  static const char* ConvertScalar(PyObject* v, Eigen::half* out) {\n    Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v));\n    double v_double = PyFloat_AS_DOUBLE(as_float.get());\n    *out = Eigen::half(v_double);\n    return nullptr;\n  }", "target": 1}
{"code": "__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\tseq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;\n\tseq += keyptr->count;\n\tseq += ktime_to_ns(ktime_get_real()) >> 6;\n\treturn seq;\n}", "target": 1}
{"code": "static inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}", "target": 0}
{"code": "static void adjust_branches(struct bpf_prog *prog, int pos, int delta)\n{\n\tstruct bpf_insn *insn = prog->insnsi;\n\tint insn_cnt = prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++, insn++) {\n\t\tif (BPF_CLASS(insn->code) != BPF_JMP ||\n\t\t    BPF_OP(insn->code) == BPF_CALL ||\n\t\t    BPF_OP(insn->code) == BPF_EXIT)\n\t\t\tcontinue;\n\t\tif (i < pos && i + insn->off + 1 > pos)\n\t\t\tinsn->off += delta;\n\t\telse if (i > pos && i + insn->off + 1 < pos)\n\t\t\tinsn->off -= delta;\n\t}\n}", "target": 1}
{"code": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length / 2; i++) {\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, 4); \n    s->has_trns = 1;\n    return 0;\n}", "target": 1}
{"code": "static int tcos_list_files(sc_card_t *card, u8 *buf, size_t buflen)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tu8 rbuf[SC_MAX_APDU_BUFFER_SIZE], p1;\n\tint r, count = 0;\n\tassert(card != NULL);\n\tctx = card->ctx;\n\tfor (p1=1; p1<=2; p1++) {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_2_SHORT, 0xAA, p1, 0);\n\t\tapdu.cla = 0x80;\n\t\tapdu.resp = rbuf;\n\t\tapdu.resplen = sizeof(rbuf);\n\t\tapdu.le = 256;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\t\tif (apdu.sw1==0x6A && (apdu.sw2==0x82 || apdu.sw2==0x88)) continue;\n\t\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\t\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"List Dir failed\");\n\t\tif (apdu.resplen > buflen) return SC_ERROR_BUFFER_TOO_SMALL;\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t \"got %\"SC_FORMAT_LEN_SIZE_T\"u %s-FileIDs\\n\",\n\t\t\t apdu.resplen / 2, p1 == 1 ? \"DF\" : \"EF\");\n\t\tmemcpy(buf, apdu.resp, apdu.resplen);\n\t\tbuf += apdu.resplen;\n\t\tbuflen -= apdu.resplen;\n\t\tcount += apdu.resplen;\n\t}\n\treturn count;\n}", "target": 0}
{"code": "certstack_destroy(struct cert_stack *stack)\n{\n\tunsigned int stack_size;\n\tstruct metadata_node *meta;\n\tstruct defer_node *post;\n\tstruct repo_level_node *level;\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->defers)) {\n\t\tpost = SLIST_FIRST(&stack->defers);\n\t\tSLIST_REMOVE_HEAD(&stack->defers, next);\n\t\tdefer_destroy(post);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u deferred certificates.\", stack_size);\n\tpr_val_debug(\"Deleting %d stacked x509s.\", sk_X509_num(stack->x509s));\n\tsk_X509_pop_free(stack->x509s, X509_free);\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->metas)) {\n\t\tmeta = SLIST_FIRST(&stack->metas);\n\t\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\t\tmeta_destroy(meta);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u metadatas.\", stack_size);\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->levels)) {\n\t\tlevel = SLIST_FIRST(&stack->levels);\n\t\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\t\tfree(level);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u stacked levels.\", stack_size);\n\tfree(stack);\n}", "target": 1}
{"code": "int sqlite3ExpandSubquery(Parse *pParse, struct SrcList_item *pFrom){\n  Select *pSel = pFrom->pSelect;\n  Table *pTab;\n  assert( pSel );\n  pFrom->pTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));\n  if( pTab==0 ) return SQLITE_NOMEM;\n  pTab->nTabRef = 1;\n  if( pFrom->zAlias ){\n    pTab->zName = sqlite3DbStrDup(pParse->db, pFrom->zAlias);\n  }else{\n    pTab->zName = sqlite3MPrintf(pParse->db, \"subquery_%u\", pSel->selId);\n  }\n  while( pSel->pPrior ){ pSel = pSel->pPrior; }\n  sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);\n  pTab->iPKey = -1;\n  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n  pTab->tabFlags |= TF_Ephemeral;\n  return pParse->nErr ? SQLITE_ERROR : SQLITE_OK;\n}", "target": 0}
{"code": "static int samldb_spn_uniqueness_check(struct samldb_ctx *ac,\n\t\t\t\t       struct ldb_message_element *spn_el)\n{\n\tstruct ldb_context *ldb = ldb_module_get_ctx(ac->module);\n\tint ret;\n\tconst char *spn = NULL;\n\tsize_t i;\n\tTALLOC_CTX *tmp_ctx = talloc_new(ac->msg);\n\tif (tmp_ctx == NULL) {\n\t\treturn ldb_oom(ldb);\n\t}\n\tfor (i = 0; i < spn_el->num_values; i++) {\n\t\tint n_components;\n\t\tspn = (char *)spn_el->values[i].data;\n\t\tn_components = count_spn_components(spn_el->values[i]);\n\t\tif (n_components > 3 || n_components < 2) {\n\t\t\tldb_asprintf_errstring(ldb,\n\t\t\t\t\t       \"samldb: spn[%s] invalid with %u components\",\n\t\t\t\t\t       spn, n_components);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_ERR_CONSTRAINT_VIOLATION;\n\t\t}\n\t\tret = check_spn_direct_collision(ldb,\n\t\t\t\t\t\t tmp_ctx,\n\t\t\t\t\t\t spn,\n\t\t\t\t\t\t ac->msg->dn);\n\t\tif (ret == LDB_ERR_COMPARE_TRUE) {\n\t\t\tDBG_INFO(\"SPN %s re-added to the same object\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn LDB_SUCCESS;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed direct uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tret = check_spn_alias_collision(ldb,\n\t\t\t\t\t\ttmp_ctx,\n\t\t\t\t\t\tspn,\n\t\t\t\t\t\tac->msg->dn);\n\t\tif (ret == LDB_ERR_NO_SUCH_OBJECT) {\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != LDB_SUCCESS) {\n\t\t\tDBG_ERR(\"SPN %s failed alias uniqueness check\\n\", spn);\n\t\t\ttalloc_free(tmp_ctx);\n\t\t\treturn ret;\n\t\t}\n\t\tDBG_INFO(\"SPN %s seems to be unique\\n\", spn);\n\t}\n\ttalloc_free(tmp_ctx);\n\treturn LDB_SUCCESS;\n}", "target": 1}
{"code": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}", "target": 1}
{"code": "static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "void ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        LONG v;\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); \n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            while(m_Coder.Get(mset.X[i])) {\n              m <<= 1;\n              i++;\n            }\n            m >>= 1;\n            sz  = m;\n            while((m >>= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}", "target": 1}
{"code": "static pfunc check_literal(struct jv_parser* p) {\n  if (p->tokenpos == 0) return 0;\n  const char* pattern = 0;\n  int plen;\n  jv v;\n  switch (p->tokenbuf[0]) {\n  case 't': pattern = \"true\"; plen = 4; v = jv_true(); break;\n  case 'f': pattern = \"false\"; plen = 5; v = jv_false(); break;\n  case 'n': pattern = \"null\"; plen = 4; v = jv_null(); break;\n  }\n  if (pattern) {\n    if (p->tokenpos != plen) return \"Invalid literal\";\n    for (int i=0; i<plen; i++)\n      if (p->tokenbuf[i] != pattern[i])\n        return \"Invalid literal\";\n    TRY(value(p, v));\n  } else {\n    p->tokenbuf[p->tokenpos] = 0; \n    char* end = 0;\n    double d = jvp_strtod(&p->dtoa, p->tokenbuf, &end);\n    if (end == 0 || *end != 0)\n      return \"Invalid numeric literal\";\n    TRY(value(p, jv_number(d)));\n  }\n  p->tokenpos = 0;\n  return 0;\n}", "target": 1}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "static void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\tmbochs_used_mbytes -= mdev_state->type->mbytes;\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}", "target": 1}
{"code": "static bool shm_may_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\treturn (shp->shm_nattch == 0) &&\n\t       (ns->shm_rmid_forced ||\n\t\t(shp->shm_perm.mode & SHM_DEST));\n}", "target": 0}
{"code": "    inline PluginEndpointSecurityAttributesMask mask() const\n    {\n        PluginEndpointSecurityAttributesMask rv = PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_submessage_encrypted) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ENCRYPTED;\n        if (is_submessage_origin_authenticated) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_ORIGIN_AUTHENTICATED;\n        if (is_payload_encrypted) rv |= PLUGIN_ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_ENCRYPTED;\n        return rv;\n    }", "target": 1}
{"code": "static freelist_idx_t next_random_slot(union freelist_init_state *state)\n{\n\treturn (state->list[state->pos++] + state->rand) % state->count;\n}", "target": 1}
{"code": "asmlinkage long compat_sys_ptrace(compat_long_t request, compat_long_t pid,\n\t\t\t\t  compat_long_t addr, compat_long_t data)\n{\n\tstruct task_struct *child;\n\tlong ret;\n\tif (request == PTRACE_TRACEME) {\n\t\tret = ptrace_traceme();\n\t\tgoto out;\n\t}\n\tchild = ptrace_get_task_struct(pid);\n\tif (IS_ERR(child)) {\n\t\tret = PTR_ERR(child);\n\t\tgoto out;\n\t}\n\tif (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n\t\tret = ptrace_attach(child, request, addr, data);\n\t\tif (!ret)\n\t\t\tarch_ptrace_attach(child);\n\t\tgoto out_put_task_struct;\n\t}\n\tret = ptrace_check_attach(child, request == PTRACE_KILL ||\n\t\t\t\t  request == PTRACE_INTERRUPT);\n\tif (!ret)\n\t\tret = compat_arch_ptrace(child, request, addr, data);\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}", "target": 1}
{"code": "cib_remote_connection_destroy(gpointer user_data)\n{\n    cib_client_t *client = user_data;\n    int csock = 0;\n    if (client == NULL) {\n        return;\n    }\n    crm_trace(\"Cleaning up after client disconnect: %s/%s\",\n              crm_str(client->name), client->id);\n    if (client->id != NULL) {\n        if (!g_hash_table_remove(client_list, client->id)) {\n            crm_err(\"Client %s not found in the hashtable\", client->name);\n        }\n    }\n    crm_trace(\"Destroying %s (%p)\", client->name, user_data);\n    num_clients--;\n    crm_trace(\"Num unfree'd clients: %d\", num_clients);\n    if (client->remote_auth_timeout) {\n        g_source_remove(client->remote_auth_timeout);\n    }\n    if (client->encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        if (client->session) {\n            void *sock_ptr = gnutls_transport_get_ptr(*client->session);\n            csock = GPOINTER_TO_INT(sock_ptr);\n            if (client->handshake_complete) {\n                gnutls_bye(*client->session, GNUTLS_SHUT_WR);\n            }\n            gnutls_deinit(*client->session);\n            gnutls_free(client->session);\n        }\n#endif\n    } else {\n        csock = GPOINTER_TO_INT(client->session);\n    }\n    client->session = NULL;\n    if (csock > 0) {\n        close(csock);\n    }\n    free(client->name);\n    free(client->callback_id);\n    free(client->id);\n    free(client->user);\n    free(client->recv_buf);\n    free(client);\n    crm_trace(\"Freed the cib client\");\n    if (cib_shutdown_flag) {\n        cib_shutdown(0);\n    }\n    return;\n}", "target": 0}
{"code": "Fraction::Fraction(int32_t num,int32_t den)\n{\n  int32_t g = gcd(num, den);\n  if (num == std::numeric_limits<int32_t>::min() && g == -1) {\n    num++;\n  }\n  if (den == std::numeric_limits<int32_t>::min() && g == -1) {\n    den++;\n  }\n  numerator = num / g;\n  denominator = den / g;\n  while (denominator > MAX_FRACTION_DENOMINATOR) {\n    numerator >>= 1;\n    denominator >>= 1;\n  }\n}", "target": 1}
{"code": "ZEND_API int zend_register_class_alias_ex(const char *name, int name_len, zend_class_entry *ce TSRMLS_DC) \n{\n\tchar *lcname = zend_str_tolower_dup(name, name_len);\n\tint ret;\n\tif (lcname[0] == '\\\\') {\n\t\tret = zend_hash_add(CG(class_table), lcname+1, name_len, &ce, sizeof(zend_class_entry *), NULL);\n\t} else {\n\t\tret = zend_hash_add(CG(class_table), lcname, name_len+1, &ce, sizeof(zend_class_entry *), NULL);\n\t}\n\tefree(lcname);\n\tif (ret == SUCCESS) {\n\t\tce->refcount++;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "ConnectClientToUnixSock(const char *sockFile)\n{\n#ifdef WIN32\n  rfbClientErr(\"Windows doesn't support UNIX sockets\\n\");\n  return -1;\n#else\n  int sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  if(strlen(sockFile) + 1 > sizeof(addr.sun_path)) {\n      rfbClientErr(\"ConnectToUnixSock: socket file name too long\\n\");\n      return -1;\n  }\n  strcpy(addr.sun_path, sockFile);\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\"ConnectToUnixSock: socket (%s)\\n\",strerror(errno));\n    return -1;\n  }\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0) {\n    rfbClientErr(\"ConnectToUnixSock: connect\\n\");\n    close(sock);\n    return -1;\n  }\n  return sock;\n#endif\n}", "target": 0}
{"code": "static void domain_remove_dev_info(struct dmar_domain *domain)\n{\n\tstruct device_domain_info *info, *tmp;\n\tunsigned long flags;\n\tspin_lock_irqsave(&device_domain_lock, flags);\n\tlist_for_each_entry_safe(info, tmp, &domain->devices, link)\n\t\t__dmar_remove_one_dev_info(info);\n\tspin_unlock_irqrestore(&device_domain_lock, flags);\n}", "target": 0}
{"code": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\tre = js_toregexp(J, -1);\n\tif (!js_regexec(re->prog, text, &m, 0))\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\telse\n\t\tjs_pushnumber(J, -1);\n}", "target": 1}
{"code": "static void rd_release_device_space(struct rd_dev *rd_dev)\n{\n\tu32 i, j, page_count = 0, sg_per_table;\n\tstruct rd_dev_sg_table *sg_table;\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n\t\treturn;\n\tsg_table = rd_dev->sg_table_array;\n\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n\t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n\t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n\t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n\tkfree(sg_table);\n\trd_dev->sg_table_array = NULL;\n\trd_dev->sg_table_count = 0;\n}", "target": 1}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        return CalculateOutputIndexValueRowID(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        return CalculateOutputIndexRowSplit(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "  static TfLiteRegistration DynamicCopyOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      TfLiteTensor* output0 = GetOutput(context, node, 0);\n      SetTensorToDynamic(output0);\n      const TfLiteTensor* input = GetInput(context, node, 0);\n      TfLiteTensor* output1 = GetOutput(context, node, 1);\n      TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n          context, output1, TfLiteIntArrayCopy(input->dims)));\n      return kTfLiteOk;\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "void LineTo(double x1,double y1) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f l\",x1,y1);\n}", "target": 1}
{"code": "void rose_stop_timer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->timer);\n}", "target": 1}
{"code": "mark_op_resolved (FlatpakTransactionOperation *op,\n                  const char                  *commit,\n                  GFile                       *sideload_path,\n                  GBytes                      *metadata,\n                  GBytes                      *old_metadata)\n{\n  g_debug (\"marking op %s:%s resolved to %s\", kind_to_str (op->kind), flatpak_decomposed_get_ref (op->ref), commit ? commit : \"-\");\n  g_assert (op != NULL);\n  g_assert (commit != NULL);\n  op->resolved = TRUE;\n  if (op->resolved_commit != commit)\n    {\n      g_free (op->resolved_commit); \n      op->resolved_commit = g_strdup (commit);\n    }\n  if (sideload_path)\n    op->resolved_sideload_path = g_object_ref (sideload_path);\n  if (metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_metadata = g_bytes_ref (metadata);\n          op->resolved_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n  if (old_metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, old_metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_old_metadata = g_bytes_ref (old_metadata);\n          op->resolved_old_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n}", "target": 1}
{"code": "bool neu_plugin_manager_schema_exist(neu_plugin_manager_t *mgr,\n                                     const char *          schema)\n{\n    bool             exist = false;\n    plugin_entity_t *el = NULL, *tmp = NULL;\n    HASH_ITER(hh, mgr->plugins, el, tmp)\n    {\n        if (strcmp(el->schema, schema) == 0) {\n            exist = true;\n            break;\n        }\n    }\n    return exist;\n}", "target": 0}
{"code": "IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n{\n\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n}", "target": 1}
{"code": "void HeaderMapImpl::appendToHeader(HeaderString& header, absl::string_view data) {\n  if (data.empty()) {\n    return;\n  }\n  if (!header.empty()) {\n    header.append(\",\", 1);\n  }\n  header.append(data.data(), data.size());\n}", "target": 1}
{"code": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}", "target": 1}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringRef data      = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "int nfc_stop_poll(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->polling) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tdev->ops->stop_poll(dev);\n\tdev->polling = false;\n\tdev->rf_mode = NFC_RF_NONE;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "void SFS_ObjectMethodCall(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \".\");\n\tSFS_Identifier(parser);\n\tSFS_AddString(parser, \"(\");\n\tSFS_Params(parser);\n\tSFS_AddString(parser, \")\");\n}", "target": 0}
{"code": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "TfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n  const int32_t* input_data = input->data.i32;\n  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);\n  const uint8_t* weight_data = weight->data.uint8;\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  int32_t* output_data = output->data.i32;\n  output_data[0] =\n      0;  \n  output_data[0] = input_data[0] + weight_data[0];\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct sock *sk;\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x\",\n\t\t\tscid, flags, result);\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tbreak;\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {\n\t\t\tchar req[128];\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\t\tgoto done;\n\t\t}\n\tdefault:\n\t\tsk->sk_state = BT_DISCONN;\n\t\tsk->sk_err = ECONNRESET;\n\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t{\n\t\t\tstruct l2cap_disconn_req req;\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (flags & 0x01)\n\t\tgoto done;\n\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t}\ndone:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}", "target": 1}
{"code": "int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags)\n{\n    STACK_OF(X509_ALGOR) *mdalgs;\n    int ctype_nid = OBJ_obj2nid(p7->type);\n    const PKCS7_CTX *ctx = ossl_pkcs7_get0_ctx(p7);\n    if (ctype_nid == NID_pkcs7_signed)\n        mdalgs = p7->d.sign->md_algs;\n    else\n        mdalgs = NULL;\n    flags ^= SMIME_OLDMIME;\n    return SMIME_write_ASN1_ex(bio, (ASN1_VALUE *)p7, data, flags, ctype_nid,\n                               NID_undef, mdalgs, ASN1_ITEM_rptr(PKCS7),\n                               ossl_pkcs7_ctx_get0_libctx(ctx),\n                               ossl_pkcs7_ctx_get0_propq(ctx));\n}", "target": 1}
{"code": "int LibRaw::subtract_black()\n{\n\tCHECK_ORDER_LOW(LIBRAW_PROGRESS_RAW2_IMAGE);\n\ttry {\n    if(!is_phaseone_compressed() && (C.cblack[0] || C.cblack[1] || C.cblack[2] || C.cblack[3]))\n        {\n#define BAYERC(row,col,c) imgdata.image[((row) >> IO.shrink)*S.iwidth + ((col) >> IO.shrink)][c] \n            int cblk[4],i;\n            for(i=0;i<4;i++)\n                cblk[i] = C.cblack[i];\n            int size = S.iheight * S.iwidth;\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n#define MAX(a,b) ((a) > (b) ? (a) : (b))\n#define LIM(x,min,max) MAX(min,MIN(x,max))\n#define CLIP(x) LIM(x,0,65535)\n            for(i=0; i< size*4; i++)\n              {\n                int val = imgdata.image[0][i];\n                val -= cblk[i & 3];\n                imgdata.image[0][i] = CLIP(val);\n                if(C.data_maximum < val) C.data_maximum = val;\n              }\n#undef MIN\n#undef MAX\n#undef LIM\n#undef CLIP\n            C.maximum -= C.black;\n            ZERO(C.cblack);\n            C.black = 0;\n#undef BAYERC\n        }\n    else\n        {\n          int idx;\n          ushort *p = (ushort*)imgdata.image;\n          C.data_maximum = 0;\n          for(idx=0;idx<S.iheight*S.iwidth*4;idx++)\n            if(C.data_maximum < p[idx]) C.data_maximum = p[idx];\n        }\n\t\treturn 0;\n\t}\n\tcatch ( LibRaw_exceptions err) {\n\t\tEXCEPTION_HANDLER(err);\n\t}\n}", "target": 1}
{"code": "_public_ int sd_bus_enqueue_for_read(sd_bus *bus, sd_bus_message *m) {\n        int r;\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(m, -EINVAL);\n        assert_return(m->sealed, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n        bus->rqueue[bus->rqueue_size++] = bus_message_ref_queued(m, bus);\n        return 0;\n}", "target": 0}
{"code": "bool TABLE_REF::tmp_table_index_lookup_init(THD *thd,\n                                            KEY *tmp_key,\n                                            Item_iterator &it,\n                                            bool value,\n                                            uint skip)\n{\n  uint tmp_key_parts= tmp_key->user_defined_key_parts;\n  uint i;\n  DBUG_ENTER(\"TABLE_REF::tmp_table_index_lookup_init\");\n  key= 0; \n  key_length= tmp_key->key_length;\n  if (!(key_buff=\n        (uchar*) thd->calloc(ALIGN_SIZE(tmp_key->key_length) * 2)) ||\n      !(key_copy=\n        (store_key**) thd->alloc((sizeof(store_key*) *\n                                  (tmp_key_parts + 1)))) ||\n      !(items=\n        (Item**) thd->alloc(sizeof(Item*) * tmp_key_parts)))\n    DBUG_RETURN(TRUE);\n  key_buff2= key_buff + ALIGN_SIZE(tmp_key->key_length);\n  KEY_PART_INFO *cur_key_part= tmp_key->key_part;\n  store_key **ref_key= key_copy;\n  uchar *cur_ref_buff= key_buff;\n  it.open();\n  for (i= 0; i < skip; i++) it.next();\n  for (i= 0; i < tmp_key_parts; i++, cur_key_part++, ref_key++)\n  {\n    Item *item= it.next();\n    DBUG_ASSERT(item);\n    items[i]= item;\n    int null_count= MY_TEST(cur_key_part->field->real_maybe_null());\n    *ref_key= new store_key_item(thd, cur_key_part->field,\n                                 cur_ref_buff + null_count,\n                                 null_count ? cur_ref_buff : 0,\n                                 cur_key_part->length, items[i], value);\n    cur_ref_buff+= cur_key_part->store_length;\n  }\n  *ref_key= NULL; \n  key_err= 1;\n  key_parts= tmp_key_parts;\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   \n    size_t dsize;                  \n    unsigned char *buf = 0;\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}", "target": 1}
{"code": "static uint16_t nvme_changed_nslist(NvmeCtrl *n, uint8_t rae, uint32_t buf_len,\n                                    uint64_t off, NvmeRequest *req)\n{\n    uint32_t nslist[1024];\n    uint32_t trans_len;\n    int i = 0;\n    uint32_t nsid;\n    if (off >= sizeof(nslist)) {\n        trace_pci_nvme_err_invalid_log_page_offset(off, sizeof(nslist));\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n    memset(nslist, 0x0, sizeof(nslist));\n    trans_len = MIN(sizeof(nslist) - off, buf_len);\n    while ((nsid = find_first_bit(n->changed_nsids, NVME_CHANGED_NSID_SIZE)) !=\n            NVME_CHANGED_NSID_SIZE) {\n        if (i == ARRAY_SIZE(nslist)) {\n            memset(nslist, 0x0, sizeof(nslist));\n            nslist[0] = 0xffffffff;\n            break;\n        }\n        nslist[i++] = nsid;\n        clear_bit(nsid, n->changed_nsids);\n    }\n    if (nslist[0] == 0xffffffff) {\n        bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);\n    }\n    if (!rae) {\n        nvme_clear_events(n, NVME_AER_TYPE_NOTICE);\n    }\n    return nvme_c2h(n, ((uint8_t *)nslist) + off, trans_len, req);\n}", "target": 0}
{"code": "void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\tif (need_software_tstamp && skb->tstamp == 0)\n\t\t__net_timestamp(skb);\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))\n\t\tempty = 0;\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n\t\tif (skb_is_err_queue(skb) && skb->len &&\n\t\t    SKB_EXT_ERR(skb)->opt_stats)\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n\t\t\t\t skb->len, skb->data);\n\t}\n}", "target": 0}
{"code": "static int netbk_set_skb_gso(struct xenvif *vif,\n\t\t\t     struct sk_buff *skb,\n\t\t\t     struct xen_netif_extra_info *gso)\n{\n\tif (!gso->u.gso.size) {\n\t\tnetdev_dbg(vif->dev, \"GSO size must not be zero.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (gso->u.gso.type != XEN_NETIF_GSO_TYPE_TCPV4) {\n\t\tnetdev_dbg(vif->dev, \"Bad GSO type %d.\\n\", gso->u.gso.type);\n\t\treturn -EINVAL;\n\t}\n\tskb_shinfo(skb)->gso_size = gso->u.gso.size;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\tskb_shinfo(skb)->gso_segs = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\t\tif (len >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\treturn ret;\n}", "target": 1}
{"code": "static int t220_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x87, 0 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x86;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 0;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(50);\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0x51;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n\t\t\t\t\t&d->dev->i2c_adap, NULL);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,\n\t\t\t\t\t&d->dev->i2c_adap, &tda18271_config)) {\n\t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    OP_REQUIRES(context, input.dims() == 1 || input.dims() == 2,\n                errors::InvalidArgument(\n                    \"input must be a vector or 2D tensor, but got shape \",\n                    input.shape().DebugString()));\n    if (input.dims() == 1) {\n      OP_REQUIRES(context,\n                  input.NumElements() == 2 || input.NumElements() == 4 ||\n                      input.NumElements() == 5,\n                  errors::InvalidArgument(\n                      \"1D input must be of size 2, 4 or 5, but got shape \",\n                      input.shape().DebugString()));\n    } else if (input.dims() == 2) {\n      OP_REQUIRES(context, input.dim_size(0) == 2 || input.dim_size(0) == 4,\n                  errors::InvalidArgument(\"First dimension of 2D input must be \"\n                                          \"of size 2 or 4, but got shape \",\n                                          input.shape().DebugString()));\n      OP_REQUIRES(\n          context, input.dim_size(1) == 2,\n          errors::InvalidArgument(\n              \"Second dimension of 2D input must be of size 2, but got shape \",\n              input.shape().DebugString()));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    Eigen::DSizes<Eigen::DenseIndex, 8> dst_idx;\n    string src_format_str = src_format_;\n    string dst_format_str = dst_format_;\n    if (input.dim_size(0) == 2) {\n      auto keep_only_spatial_dimensions = [](string* format_str) -> void {\n        auto new_end = std::remove_if(\n            format_str->begin(), format_str->end(),\n            [](const char dim) { return dim != 'H' && dim != 'W'; });\n        format_str->erase(new_end, format_str->end());\n      };\n      keep_only_spatial_dimensions(&src_format_str);\n      keep_only_spatial_dimensions(&dst_format_str);\n      OP_REQUIRES(context,\n                  src_format_str.size() == 2 && dst_format_str.size() == 2,\n                  errors::InvalidArgument(\n                      \"Format specifier must contain H and W for 2D case\"));\n    }\n    ComputeDstIndex(src_format_str, dst_format_str, input.dims(), &dst_idx);\n    functor::DataFormatVecPermute<Device, T>()(context->eigen_device<Device>(),\n                                               input.flat<T>(),\n                                               output->flat<T>(), dst_idx);\n  }", "target": 0}
{"code": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}", "target": 1}
{"code": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}", "target": 1}
{"code": "static void vgacon_scrollback_reset(int vc_num, size_t reset_size)\n{\n\tstruct vgacon_scrollback_info *scrollback = &vgacon_scrollbacks[vc_num];\n\tif (scrollback->data && reset_size > 0)\n\t\tmemset(scrollback->data, 0, reset_size);\n\tscrollback->cnt  = 0;\n\tscrollback->tail = 0;\n\tscrollback->cur  = 0;\n}", "target": 1}
{"code": "irc_nick_realloc_prefixes (struct t_irc_server *server,\n                           int old_length, int new_length)\n{\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n    char *new_prefixes;\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        for (ptr_nick = ptr_channel->nicks; ptr_nick;\n             ptr_nick = ptr_nick->next_nick)\n        {\n            if (ptr_nick->prefixes)\n            {\n                new_prefixes = realloc (ptr_nick->prefixes, new_length + 1);\n                if (new_prefixes)\n                {\n                    ptr_nick->prefixes = new_prefixes;\n                    if (new_length > old_length)\n                    {\n                        memset (ptr_nick->prefixes + old_length,\n                                ' ',\n                                new_length - old_length);\n                    }\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n            else\n            {\n                ptr_nick->prefixes = malloc (new_length + 1);\n                if (ptr_nick->prefixes)\n                {\n                    memset (ptr_nick->prefixes, ' ', new_length);\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n        }\n    }\n}", "target": 0}
{"code": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\tif (!(dev->flags & IFF_UP))\n\t\treturn NET_RX_DROP;\n\tif (skb->len > (dev->mtu + dev->hard_header_len))\n\t\treturn NET_RX_DROP;\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}", "target": 1}
{"code": "static Quantum *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  Quantum\n    *magick_restrict pixels;\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return((Quantum *) NULL);\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}", "target": 0}
{"code": "std::string sanitizeNameForWindowList(const std::string& name) {\n    std::string result = name;\n    if (result[0] == '\\\"')\n        result[0] = ' ';\n    for (size_t i = 1; i < result.size(); ++i) {\n        if (result[i - 1] == '>' && result[i] == ']')\n            result[i] = ' ';\n        if (result[i] == '\\\"')\n            result[i] = ' ';\n    }\n    return result;\n}", "target": 1}
{"code": "win_free_lsize(win_T *wp)\n{\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}", "target": 0}
{"code": "static int fts3ExprTermOffsetInit(Fts3Expr *pExpr, int iPhrase, void *ctx){\n  TermOffsetCtx *p = (TermOffsetCtx *)ctx;\n  int nTerm;                      \n  int iTerm;                      \n  char *pList;                    \n  int iPos = 0;                   \n  int rc;\n  UNUSED_PARAMETER(iPhrase);\n  rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, &pList);\n  nTerm = pExpr->pPhrase->nToken;\n  if( pList ){\n    fts3GetDeltaPosition(&pList, &iPos);\n    assert( iPos>=0 );\n  }\n  for(iTerm=0; iTerm<nTerm; iTerm++){\n    TermOffset *pT = &p->aTerm[p->iTerm++];\n    pT->iOff = nTerm-iTerm-1;\n    pT->pList = pList;\n    pT->iPos = iPos;\n  }\n  return rc;\n}", "target": 0}
{"code": "static bool packet_use_direct_xmit(const struct packet_sock *po)\n{\n\treturn po->xmit == packet_direct_xmit;\n}", "target": 0}
{"code": "void TestSocketLineReader::badData()\n{\n    const QList<QByteArray> dataToSend = { \"data1\\n\", \"data\" }; \n    for (const QByteArray& line : qAsConst(dataToSend)) {\n        m_conn->write(line);\n    }\n    m_conn->flush();\n    QSignalSpy spy(m_server, &QTcpServer::newConnection);\n    QVERIFY(m_server->hasPendingConnections() || spy.wait(1000));\n    QSslSocket* sock = m_server->nextPendingConnection();\n    QVERIFY2(sock != nullptr, \"Could not open a connection to the client\");\n    m_reader = new SocketLineReader(sock, this);\n    connect(m_reader, &SocketLineReader::readyRead, this, &TestSocketLineReader::newPacket);\n    m_timer.start();\n    m_loop.exec();\n    QCOMPARE(m_packets.count(), 1);\n    QCOMPARE(m_packets[0], dataToSend[0]);\n}", "target": 0}
{"code": "isdn_ppp_poll(struct file *file, poll_table *wait)\n{\n\tu_int mask;\n\tstruct ippp_buf_queue *bf, *bl;\n\tu_long flags;\n\tstruct ippp_struct *is;\n\tis = file->private_data;\n\tif (is->debug & 0x2)\n\t\tprintk(KERN_DEBUG \"isdn_ppp_poll: minor: %d\\n\",\n\t\t       iminor(file_inode(file)));\n\tpoll_wait(file, &is->wq, wait);\n\tif (!(is->state & IPPP_OPEN)) {\n\t\tif (is->state == IPPP_CLOSEWAIT)\n\t\t\treturn POLLHUP;\n\t\tprintk(KERN_DEBUG \"isdn_ppp: device not open\\n\");\n\t\treturn POLLERR;\n\t}\n\tmask = POLLOUT | POLLWRNORM;\n\tspin_lock_irqsave(&is->buflock, flags);\n\tbl = is->last;\n\tbf = is->first;\n\tif (bf->next != bl || (is->state & IPPP_NOBLOCK)) {\n\t\tis->state &= ~IPPP_NOBLOCK;\n\t\tmask |= POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock_irqrestore(&is->buflock, flags);\n\treturn mask;\n}", "target": 0}
{"code": "void *HtpGetTxForH2(void *alstate)\n{\n    HtpState *http_state = (HtpState *)alstate;\n    if (http_state != NULL && http_state->conn != NULL) {\n        size_t txid = htp_list_array_size(http_state->conn->transactions);\n        if (txid > 0) {\n            return htp_list_get(http_state->conn->transactions, txid - 1);\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "static void Sp_match(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint len;\n\tconst char *a, *b, *c, *e;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\tre = js_toregexp(J, -1);\n\tif (!(re->flags & JS_REGEXP_G)) {\n\t\tjs_RegExp_prototype_exec(J, re, text);\n\t\treturn;\n\t}\n\tre->last = 0;\n\tjs_newarray(J);\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\t\ta = c;\n\t\tif (c - b == 0)\n\t\t\t++a;\n\t}\n\tif (len == 0) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushnull(J);\n\t}\n}", "target": 1}
{"code": "int cmd_upload_pack(int argc, const char **argv, const char *prefix)\n{\n\tconst char *dir;\n\tint strict = 0;\n\tint advertise_refs = 0;\n\tint stateless_rpc = 0;\n\tint timeout = 0;\n\tstruct option options[] = {\n\t\tOPT_BOOL(0, \"stateless-rpc\", &stateless_rpc,\n\t\t\t N_(\"quit after a single request/response exchange\")),\n\t\tOPT_HIDDEN_BOOL(0, \"http-backend-info-refs\", &advertise_refs,\n\t\t\t\tN_(\"serve up the info/refs for git-http-backend\")),\n\t\tOPT_ALIAS(0, \"advertise-refs\", \"http-backend-info-refs\"),\n\t\tOPT_BOOL(0, \"strict\", &strict,\n\t\t\t N_(\"do not try <directory>/.git/ if <directory> is no Git directory\")),\n\t\tOPT_INTEGER(0, \"timeout\", &timeout,\n\t\t\t    N_(\"interrupt transfer after <n> seconds of inactivity\")),\n\t\tOPT_END()\n\t};\n\tpacket_trace_identity(\"upload-pack\");\n\tread_replace_refs = 0;\n\txsetenv(\"GIT_NO_LAZY_FETCH\", \"1\", 0);\n\targc = parse_options(argc, argv, prefix, options, upload_pack_usage, 0);\n\tif (argc != 1)\n\t\tusage_with_options(upload_pack_usage, options);\n\tsetup_path();\n\tdir = argv[0];\n\tif (!enter_repo(dir, strict))\n\t\tdie(\"'%s' does not appear to be a git repository\", dir);\n\tswitch (determine_protocol_version_server()) {\n\tcase protocol_v2:\n\t\tif (advertise_refs)\n\t\t\tprotocol_v2_advertise_capabilities();\n\t\telse\n\t\t\tprotocol_v2_serve_loop(stateless_rpc);\n\t\tbreak;\n\tcase protocol_v1:\n\t\tif (advertise_refs || !stateless_rpc)\n\t\t\tpacket_write_fmt(1, \"version 1\\n\");\n\tcase protocol_v0:\n\t\tupload_pack(advertise_refs, stateless_rpc, timeout);\n\t\tbreak;\n\tcase protocol_unknown_version:\n\t\tBUG(\"unknown protocol version\");\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int ha_quic_add_handshake_data(SSL *ssl, enum ssl_encryption_level_t level,\n                                      const uint8_t *data, size_t len)\n{\n\tint ret = 0;\n\tstruct quic_conn *qc = SSL_get_ex_data(ssl, ssl_qc_app_data_index);\n\tstruct quic_enc_level **qel = ssl_to_qel_addr(qc, level);\n\tstruct quic_pktns **pktns = ssl_to_quic_pktns(qc, level);\n\tTRACE_ENTER(QUIC_EV_CONN_ADDDATA, qc);\n\tTRACE_PROTO(\"ha_quic_add_handshake_data() called\", QUIC_EV_CONN_IO_CB, qc, NULL, ssl);\n#ifdef HAVE_SSL_0RTT_QUIC\n\tif ((qc->flags & QUIC_FL_CONN_NO_TOKEN_RCVD) && qc_ssl_eary_data_accepted(ssl)) {\n\t\tTRACE_PROTO(\"connection to be killed\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tqc->flags |= QUIC_FL_CONN_TO_KILL|QUIC_FL_CONN_SEND_RETRY;\n\t\tgoto leave;\n\t}\n#endif\n\tif (qc->flags & QUIC_FL_CONN_TO_KILL) {\n\t\tTRACE_PROTO(\"connection to be killed\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tgoto out;\n\t}\n\tif (qc->flags & QUIC_FL_CONN_IMMEDIATE_CLOSE) {\n\t\tTRACE_PROTO(\"CC required\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tgoto out;\n\t}\n\tif (!*qel && !qc_enc_level_alloc(qc, pktns, qel, level))\n\t\tgoto leave;\n\tif (!qc_ssl_crypto_data_cpy(qc, *qel, data, len)) {\n\t\tTRACE_ERROR(\"Could not bufferize\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tgoto leave;\n\t}\n\tTRACE_DEVEL(\"CRYPTO data buffered\", QUIC_EV_CONN_ADDDATA,\n\t            qc, &level, &len);\n out:\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_ADDDATA, qc);\n\treturn ret;\n}", "target": 0}
{"code": "ipf_extract_frags_from_batch(struct ipf *ipf, struct dp_packet_batch *pb,\n                             ovs_be16 dl_type, uint16_t zone, long long now,\n                             uint32_t hash_basis)\n{\n    const size_t pb_cnt = dp_packet_batch_size(pb);\n    int pb_idx; \n    struct dp_packet *pkt;\n    DP_PACKET_BATCH_REFILL_FOR_EACH (pb_idx, pb_cnt, pkt, pb) {\n        if (OVS_UNLIKELY((dl_type == htons(ETH_TYPE_IP) &&\n                          ipf_is_valid_v4_frag(ipf, pkt))\n                          ||\n                          (dl_type == htons(ETH_TYPE_IPV6) &&\n                          ipf_is_valid_v6_frag(ipf, pkt)))) {\n            ovs_mutex_lock(&ipf->ipf_lock);\n            if (!ipf_handle_frag(ipf, pkt, dl_type, zone, now, hash_basis)) {\n                dp_packet_batch_refill(pb, pkt, pb_idx);\n            } else {\n                dp_packet_delete(pkt);\n            }\n            ovs_mutex_unlock(&ipf->ipf_lock);\n        } else {\n            dp_packet_batch_refill(pb, pkt, pb_idx);\n        }\n    }\n}", "target": 0}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    next_start_code_studio(gb);\n}", "target": 1}
{"code": "comics_remove_dir (gchar *path_name) \n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path = \n\t\t\t\tg_build_filename (path_name, \n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 0}
{"code": "rfbClientIteratorNext(rfbClientIteratorPtr i)\n{\n  if (!i)\n    return NULL;\n  if(i->next == 0) {\n    LOCK(rfbClientListMutex);\n    i->next = i->screen->clientHead;\n    UNLOCK(rfbClientListMutex);\n  } else {\n    rfbClientPtr cl = i->next;\n    i->next = i->next->next;\n    rfbDecrClientRef(cl);\n  }\n#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)\n    if(!i->closedToo)\n      while(i->next && i->next->sock<0)\n        i->next = i->next->next;\n    if(i->next)\n      rfbIncrClientRef(i->next);\n#endif\n    return i->next;\n}", "target": 0}
{"code": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}", "target": 1}
{"code": "int jvp_number_cmp(jv a, jv b) {\n  assert(JVP_HAS_KIND(a, JV_KIND_NUMBER));\n  assert(JVP_HAS_KIND(b, JV_KIND_NUMBER));\n#ifdef USE_DECNUM\n  if (JVP_HAS_FLAGS(a, JVP_FLAGS_NUMBER_LITERAL) && JVP_HAS_FLAGS(b, JVP_FLAGS_NUMBER_LITERAL)) {\n    decNumber res;\n    decNumberCompare(&res,\n                     jvp_dec_number_ptr(a),\n                     jvp_dec_number_ptr(b),\n                     DEC_CONTEXT()\n                     );\n    if (decNumberIsZero(&res)) {\n      return 0;\n    } else if (decNumberIsNegative(&res)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }\n#endif\n  double da = jv_number_value(a), db = jv_number_value(b);\n  if (da < db) {\n    return -1;\n  } else if (da == db) {\n    return 0;\n  } else {\n    return 1;\n  }\n}", "target": 1}
{"code": "  ~SubgraphGuard() {\n    if (status_ == kTfLiteOk) {\n      *is_subgraph_in_use_ = false;\n    }\n  }", "target": 0}
{"code": "int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tcm_id_priv = container_of(id, struct cm_id_private, id);\n\tif (smac != NULL)\n\t\tmemcpy(cm_id_priv->av.smac, smac, sizeof(cm_id_priv->av.smac));\n\tif (alt_smac != NULL)\n\t\tmemcpy(cm_id_priv->alt_av.smac, alt_smac,\n\t\t       sizeof(cm_id_priv->alt_av.smac));\n\treturn 0;\n}", "target": 1}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4151 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "vmxnet3_rq_cleanup(struct vmxnet3_rx_queue *rq,\n\t\t   struct vmxnet3_adapter *adapter)\n{\n\tu32 i, ring_idx;\n\tstruct Vmxnet3_RxDesc *rxd;\n\tif (!rq->rx_ring[0].base)\n\t\treturn;\n\tfor (ring_idx = 0; ring_idx < 2; ring_idx++) {\n\t\tfor (i = 0; i < rq->rx_ring[ring_idx].size; i++) {\n#ifdef __BIG_ENDIAN_BITFIELD\n\t\t\tstruct Vmxnet3_RxDesc rxDesc;\n#endif\n\t\t\tvmxnet3_getRxDesc(rxd,\n\t\t\t\t&rq->rx_ring[ring_idx].base[i].rxd, &rxDesc);\n\t\t\tif (rxd->btype == VMXNET3_RXD_BTYPE_HEAD &&\n\t\t\t\t\trq->buf_info[ring_idx][i].skb) {\n\t\t\t\tdma_unmap_single(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t\t rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tdev_kfree_skb(rq->buf_info[ring_idx][i].skb);\n\t\t\t\trq->buf_info[ring_idx][i].skb = NULL;\n\t\t\t} else if (rxd->btype == VMXNET3_RXD_BTYPE_BODY &&\n\t\t\t\t\trq->buf_info[ring_idx][i].page) {\n\t\t\t\tdma_unmap_page(&adapter->pdev->dev, rxd->addr,\n\t\t\t\t\t       rxd->len, DMA_FROM_DEVICE);\n\t\t\t\tput_page(rq->buf_info[ring_idx][i].page);\n\t\t\t\trq->buf_info[ring_idx][i].page = NULL;\n\t\t\t}\n\t\t}\n\t\trq->rx_ring[ring_idx].gen = VMXNET3_INIT_GEN;\n\t\trq->rx_ring[ring_idx].next2fill =\n\t\t\t\t\trq->rx_ring[ring_idx].next2comp = 0;\n\t}\n\trq->comp_ring.gen = VMXNET3_INIT_GEN;\n\trq->comp_ring.next2proc = 0;\n}", "target": 0}
{"code": "QSqlRecord QODBCDriver::record(const QString& tablename) const\n{\n    Q_D(const QODBCDriver);\n    QSqlRecord fil;\n    if (!isOpen())\n        return fil;\n    SQLHANDLE hStmt;\n    QString catalog, schema, table;\n    const_cast<QODBCDriverPrivate*>(d)->splitTableQualifier(tablename, catalog, schema, table);\n    if (isIdentifierEscaped(catalog, QSqlDriver::TableName))\n        catalog = stripDelimiters(catalog, QSqlDriver::TableName);\n    else\n        catalog = d->adjustCase(catalog);\n    if (isIdentifierEscaped(schema, QSqlDriver::TableName))\n        schema = stripDelimiters(schema, QSqlDriver::TableName);\n    else\n        schema = d->adjustCase(schema);\n    if (isIdentifierEscaped(table, QSqlDriver::TableName))\n        table = stripDelimiters(table, QSqlDriver::TableName);\n    else\n        table = d->adjustCase(table);\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::record: Unable to allocate handle\"_L1, d);\n        return fil;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    r =  SQLColumns(hStmt,\n                     catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),\n                     catalog.length(),\n                     schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),\n                     schema.length(),\n                     toSQLTCHAR(table).data(),\n                     table.length(),\n                     NULL,\n                     0);\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::record: Unable to execute column list\"_L1, d);\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n    while (r == SQL_SUCCESS) {\n        fil.append(qMakeFieldInfo(hStmt, d));\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle \"_L1 + QString::number(r), d);\n    return fil;\n}", "target": 1}
{"code": "static MagickBooleanType SkipRGBMipmaps(Image *image,DDSInfo *dds_info,\n  int pixel_size,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    offset;\n  register ssize_t\n    i;\n  size_t\n    h,\n    w;\n  if (EOFBlob(image) != MagickFalse)\n    {\n      ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n        image->filename);\n      return(MagickFalse);\n    }\n  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP\n      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE\n          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))\n    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}", "target": 1}
{"code": "unsigned Cache::deadCapacity() const \n{\n    unsigned capacity = m_capacity - min(m_liveSize, m_capacity); \n    capacity = max(capacity, m_minDeadCapacity); \n    capacity = min(capacity, m_maxDeadCapacity); \n    return capacity;\n}", "target": 0}
{"code": "get_image_extensions(void)\n{\n\tGHashTable *extensions;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tguint i;\n\tconst char *known_image_formats[] = {\n\t\t\"png\",\n\t\t\"jpg\",\n\t\t\"jpeg\",\n\t\t\"webp\"\n\t};\n\textensions = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t\t    g_free, NULL);\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (ext[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_SUPPORTED));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\tfor (i = 0; i < G_N_ELEMENTS (known_image_formats); i++) {\n\t\tif (!g_hash_table_lookup (extensions, known_image_formats[i])) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (known_image_formats[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_UNSUPPORTED));\n\t\t}\n\t}\n\treturn extensions;\n}", "target": 0}
{"code": "int tcp_filter(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcphdr *th = (struct tcphdr *)skb->data;\n\tunsigned int eaten = skb->len;\n\tint err;\n\terr = sk_filter_trim_cap(sk, skb, th->doff * 4);\n\tif (!err) {\n\t\teaten -= skb->len;\n\t\tTCP_SKB_CB(skb)->end_seq -= eaten;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  guchar *match;\n  int i;\n  if (client->auth_end_offset > 0)\n    {\n      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n      gsize to_match = MIN (left, buffer->pos);\n      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n        {\n          client->auth_end_offset += to_match;\n          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n            return to_match;\n          return -1;\n        }\n      client->auth_end_offset = -1;\n    }\n  match = memmem (buffer, buffer->pos,\n                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n  if (match != NULL)\n    return match - buffer->data + strlen (AUTH_END_STRING);\n  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n    {\n      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n        {\n          client->auth_end_offset = i;\n          break;\n        }\n    }\n  return -1;\n}", "target": 1}
{"code": "    int FixCom::run(const std::string& path)\n    {\n        try {\n            if (!Exiv2::fileExists(path, true)) {\n                std::cerr << path << \": \" << _(\"Failed to open the file\\n\");\n                return -1;\n            }\n            Timestamp ts;\n            if (Params::instance().preserve_)\n                ts.read(path);\n            Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open(path);\n            image->readMetadata();\n            Exiv2::ExifData& exifData = image->exifData();\n            if (exifData.empty()) {\n                std::cerr << path << \": \" << _(\"No Exif data found in the file\\n\");\n                return -3;\n            }\n            auto pos = exifData.findKey(Exiv2::ExifKey(\"Exif.Photo.UserComment\"));\n            if (pos == exifData.end()) {\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"No Exif user comment found\") << \"\\n\";\n                }\n                return 0;\n            }\n            Exiv2::Value::UniquePtr v = pos->getValue();\n            const Exiv2::CommentValue* pcv = dynamic_cast<const Exiv2::CommentValue*>(v.get());\n            if (!pcv) {\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"Found Exif user comment with unexpected value type\") << \"\\n\";\n                }\n                return 0;\n            }\n            Exiv2::CommentValue::CharsetId csId = pcv->charsetId();\n            if (csId != Exiv2::CommentValue::unicode) {\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"No Exif UNICODE user comment found\") << \"\\n\";\n                }\n                return 0;\n            }\n            std::string comment = pcv->comment(Params::instance().charset_.c_str());\n            if (Params::instance().verbose_) {\n                std::cout << _(\"Setting Exif UNICODE user comment to\") << \" \\\"\" << comment << \"\\\"\\n\";\n            }\n            comment = std::string(\"charset=\\\"\") + Exiv2::CommentValue::CharsetInfo::name(csId) + \"\\\" \" + comment;\n            pos->setValue(comment);\n            image->writeMetadata();\n            if (Params::instance().preserve_)\n                ts.touch(path);\n            return 0;\n        } catch (const Exiv2::AnyError& e) {\n            std::cerr << \"Exiv2 exception in fixcom action for file \" << path << \":\\n\" << e << \"\\n\";\n            return 1;\n        }\n    }", "target": 0}
{"code": "static void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}", "target": 1}
{"code": "XML_GetFeatureList(void) {\n  static const XML_Feature features[] = {\n    {XML_FEATURE_SIZEOF_XML_CHAR, XML_L(\"sizeof(XML_Char)\"), sizeof(XML_Char)},\n    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L(\"sizeof(XML_LChar)\"),\n     sizeof(XML_LChar)},\n#ifdef XML_UNICODE\n    {XML_FEATURE_UNICODE, XML_L(\"XML_UNICODE\"), 0},\n#endif\n#ifdef XML_UNICODE_WCHAR_T\n    {XML_FEATURE_UNICODE_WCHAR_T, XML_L(\"XML_UNICODE_WCHAR_T\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_DTD, XML_L(\"XML_DTD\"), 0},\n#endif\n#if XML_CONTEXT_BYTES > 0\n    {XML_FEATURE_CONTEXT_BYTES, XML_L(\"XML_CONTEXT_BYTES\"), XML_CONTEXT_BYTES},\n#endif\n#ifdef XML_MIN_SIZE\n    {XML_FEATURE_MIN_SIZE, XML_L(\"XML_MIN_SIZE\"), 0},\n#endif\n#ifdef XML_NS\n    {XML_FEATURE_NS, XML_L(\"XML_NS\"), 0},\n#endif\n#ifdef XML_LARGE_SIZE\n    {XML_FEATURE_LARGE_SIZE, XML_L(\"XML_LARGE_SIZE\"), 0},\n#endif\n#ifdef XML_ATTR_INFO\n    {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n     XML_L(\"XML_BLAP_MAX_AMP\"),\n     (long int)\n         EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT},\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT,\n     XML_L(\"XML_BLAP_ACT_THRES\"),\n     EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT},\n#endif\n    {XML_FEATURE_END, NULL, 0}\n  };\n  return features;\n}", "target": 1}
{"code": "static int __init unittest_data_add(void)\n{\n\tvoid *unittest_data;\n\tstruct device_node *unittest_data_node, *np;\n\textern uint8_t __dtb_testcases_begin[];\n\textern uint8_t __dtb_testcases_end[];\n\tconst int size = __dtb_testcases_end - __dtb_testcases_begin;\n\tint rc;\n\tif (!size) {\n\t\tpr_warn(\"%s: No testcase data to attach; not running tests\\n\",\n\t\t\t__func__);\n\t\treturn -ENODATA;\n\t}\n\tunittest_data = kmemdup(__dtb_testcases_begin, size, GFP_KERNEL);\n\tif (!unittest_data)\n\t\treturn -ENOMEM;\n\tof_fdt_unflatten_tree(unittest_data, NULL, &unittest_data_node);\n\tif (!unittest_data_node) {\n\t\tpr_warn(\"%s: No tree to attach; not running tests\\n\", __func__);\n\t\tkfree(unittest_data);\n\t\treturn -ENODATA;\n\t}\n\tof_overlay_mutex_lock();\n\trc = of_resolve_phandles(unittest_data_node);\n\tif (rc) {\n\t\tpr_err(\"%s: Failed to resolve phandles (rc=%i)\\n\", __func__, rc);\n\t\tof_overlay_mutex_unlock();\n\t\treturn -EINVAL;\n\t}\n\tif (!of_root) {\n\t\tof_root = unittest_data_node;\n\t\tfor_each_of_allnodes(np)\n\t\t\t__of_attach_node_sysfs(np);\n\t\tof_aliases = of_find_node_by_path(\"/aliases\");\n\t\tof_chosen = of_find_node_by_path(\"/chosen\");\n\t\tof_overlay_mutex_unlock();\n\t\treturn 0;\n\t}\n\tnp = unittest_data_node->child;\n\twhile (np) {\n\t\tstruct device_node *next = np->sibling;\n\t\tnp->parent = of_root;\n\t\tattach_node_and_children(np);\n\t\tnp = next;\n\t}\n\tof_overlay_mutex_unlock();\n\treturn 0;\n}", "target": 0}
{"code": "void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\tStream_Write_UINT16(s, fields->Len); \n\tStream_Write_UINT16(s, fields->MaxLen); \n\tStream_Write_UINT32(s, fields->BufferOffset); \n}", "target": 1}
{"code": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\tif (pid == INT_MIN)\n\t\treturn -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 0}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, event) >= 0;\n}", "target": 0}
{"code": "static void enqueue_huge_page(struct hstate *h, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tlockdep_assert_held(&hugetlb_lock);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\tlist_move(&page->lru, &h->hugepage_freelists[nid]);\n\th->free_huge_pages++;\n\th->free_huge_pages_node[nid]++;\n\tSetHPageFreed(page);\n}", "target": 0}
{"code": "char *redisProtocolToLuaType(lua_State *lua, char* reply) {\n    if (!lua_checkstack(lua, 5)) {\n        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n    }\n    char *p = reply;\n    switch(*p) {\n    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;\n    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;\n    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;\n    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;\n    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;\n    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;\n    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;\n    }\n    return p;\n}", "target": 0}
{"code": "static void context__cleanup_out_packets(struct mosquitto *context)\n{\n\tstruct mosquitto__packet *packet;\n\tif(!context) return;\n\tif(context->current_out_packet){\n\t\tpacket__cleanup(context->current_out_packet);\n\t\tmosquitto__free(context->current_out_packet);\n\t\tcontext->current_out_packet = NULL;\n\t}\n\twhile(context->out_packet){\n\t\tpacket__cleanup(context->out_packet);\n\t\tpacket = context->out_packet;\n\t\tcontext->out_packet = context->out_packet->next;\n\t\tmosquitto__free(packet);\n\t}\n\tcontext->out_packet_count = 0;\n}", "target": 0}
{"code": "initpyfribidi (void)\n{\n\tPyObject *module;\n\tmodule = Py_InitModule3 (\"pyfribidi\", PyfribidiMethods,\n\t\t\t\t _pyfribidi__doc__);\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n\tPyModule_AddStringConstant (module, \"__author__\",\n\t\t\t\t    \"Yaacov Zamir and Nir Soffer\");\n}", "target": 1}
{"code": "char *gf_bt_get_next(GF_BTParser *parser, Bool point_break)\n{\n\tu32 has_quote;\n\tBool go = 1;\n\ts32 i;\n\tgf_bt_check_line(parser);\n\ti=0;\n\thas_quote = 0;\n\twhile (go) {\n\t\tif (parser->line_buffer[parser->line_pos + i] == '\\\"') {\n\t\t\tif (!has_quote) has_quote = 1;\n\t\t\telse has_quote = 0;\n\t\t\tparser->line_pos += 1;\n\t\t\tif (parser->line_pos+i==parser->line_size) break;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!has_quote) {\n\t\t\tswitch (parser->line_buffer[parser->line_pos + i]) {\n\t\t\tcase 0:\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase '\\r':\n\t\t\tcase '\\n':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase ']':\n\t\t\tcase '[':\n\t\t\tcase ',':\n\t\t\t\tgo = 0;\n\t\t\t\tbreak;\n\t\t\tcase '.':\n\t\t\t\tif (point_break) go = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!go) break;\n\t\t}\n\t\tparser->cur_buffer[i] = parser->line_buffer[parser->line_pos + i];\n\t\ti++;\n\t\tif (parser->line_pos+i==parser->line_size) break;\n\t}\n\tparser->cur_buffer[i] = 0;\n\tparser->line_pos += i;\n\treturn parser->cur_buffer;\n}", "target": 1}
{"code": "static size_t hash_str(const void *ptr)\n{\n    const char *str = (const char *)ptr;\n    size_t hash = 5381;\n    size_t c;\n    while((c = (size_t)*str))\n    {\n        hash = ((hash << 5) + hash) + c;\n        str++;\n    }\n    return hash;\n}", "target": 1}
{"code": "gopherHTMLHeader(StoreEntry * e, const char *title, const char *substring)\n{\n    storeAppendPrintf(e, \"<!DOCTYPE HTML PUBLIC \\\"-\n    storeAppendPrintf(e, \"<HTML><HEAD><TITLE>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</TITLE>\");\n    storeAppendPrintf(e, \"<STYLE type=\\\"text/css\\\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\\n\");\n    storeAppendPrintf(e, \"</HEAD>\\n<BODY><H1>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</H1>\\n\");\n}", "target": 1}
{"code": "static inline void inc_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}", "target": 0}
{"code": "findNextBorderPixel(l_int32    w,\n                    l_int32    h,\n                    l_uint32  *data,\n                    l_int32    wpl,\n                    l_int32    px,\n                    l_int32    py,\n                    l_int32   *pqpos,\n                    l_int32   *pnpx,\n                    l_int32   *pnpy)\n{\nl_int32    qpos, i, pos, npx, npy, val;\nl_uint32  *line;\n    qpos = *pqpos;\n    for (i = 1; i < 8; i++) {\n        pos = (qpos + i) % 8;\n        npx = px + xpostab[pos];\n        npy = py + ypostab[pos];\n        if (npx < 0 || npx >= w || npy < 0 || npy >= h)\n            continue;\n        line = data + npy * wpl;\n        val = GET_DATA_BIT(line, npx);\n        if (val) {\n            *pnpx = npx;\n            *pnpy = npy;\n            *pqpos = qpostab[pos];\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {\n    zl = zrealloc(zl,len);\n    ZIPLIST_BYTES(zl) = intrev32ifbe(len);\n    zl[len-1] = ZIP_END;\n    return zl;\n}", "target": 1}
{"code": "Status KernelAndDeviceOp::Run(\n    ScopedStepContainer* step_container, const EagerKernelArgs& inputs,\n    std::vector<EagerKernelRet>* outputs,\n    CancellationManager* cancellation_manager,\n    const absl::optional<EagerRemoteFunctionParams>& remote_func_params) {\n  OpKernelContext::Params params;\n  params.device = device_;\n  params.frame_iter = FrameAndIter(0, 0);\n  params.inputs = inputs.GetTensorValues();\n  params.op_kernel = kernel_.get();\n  params.resource_manager = device_->resource_manager();\n  params.input_alloc_attrs = &input_alloc_attrs_;\n  params.output_attr_array = output_alloc_attrs_.data();\n  params.function_library = flr_;\n  params.slice_reader_cache = &slice_reader_cache_;\n  params.rendezvous = rendezvous_;\n  OpExecutionState* op_execution_state = nullptr;\n  CancellationManager default_cancellation_manager;\n  if (cancellation_manager) {\n    params.cancellation_manager = cancellation_manager;\n  } else if (kernel_->is_deferred()) {\n    op_execution_state = new OpExecutionState;\n    params.cancellation_manager = &op_execution_state->cancellation_manager;\n    params.inc_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Ref();\n    };\n    params.dec_num_deferred_ops_function = [op_execution_state]() {\n      op_execution_state->Unref();\n    };\n  } else {\n    params.cancellation_manager = &default_cancellation_manager;\n  }\n  params.log_memory = log_memory_;\n  params.runner = get_runner();\n  params.step_container =\n      step_container == nullptr ? &step_container_ : step_container;\n  auto step_container_cleanup = gtl::MakeCleanup([step_container, this] {\n    if (step_container == nullptr) {\n      this->step_container_.CleanUp();\n    }\n  });\n  params.collective_executor =\n      collective_executor_ ? collective_executor_->get() : nullptr;\n  OpKernelContext context(&params);\n  {\n    port::ScopedFlushDenormal flush;\n    port::ScopedSetRound round(FE_TONEAREST);\n    profiler::AnnotatedTraceMe activity(\n        [&] { return kernel_->TraceString(context, false); },\n        profiler::TraceMeLevel::kInfo);\n    device_->Compute(kernel_.get(), &context);\n  }\n  if (op_execution_state != nullptr) {\n    op_execution_state->Unref();\n  }\n  if (!context.status().ok()) return context.status();\n  if (outputs != nullptr) {\n    outputs->clear();\n    for (int i = 0; i < context.num_outputs(); ++i) {\n      outputs->push_back(Tensor(*context.mutable_output(i)));\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "static int __init acpi_os_name_setup(char *str)\n{\n\tchar *p = acpi_os_name;\n\tint count = ACPI_MAX_OVERRIDE_LEN - 1;\n\tif (!str || !*str)\n\t\treturn 0;\n\tfor (; count-- && *str; str++) {\n\t\tif (isalnum(*str) || *str == ' ' || *str == ':')\n\t\t\t*p++ = *str;\n\t\telse if (*str == '\\'' || *str == '\"')\n\t\t\tcontinue;\n\t\telse\n\t\t\tbreak;\n\t}\n\t*p = 0;\n\treturn 1;\n}", "target": 0}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tif (inode->i_size > inode->i_sb->s_blocksize) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_unmap;\n\t}\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tsymlink = bh->b_data;\n\t}\n\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n\tbrelse(bh);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout_unlock_inode:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\nout_unmap:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 0}
{"code": "ev_archive_read_data (EvArchive *archive,\n\t\t      void      *buf,\n\t\t      gsize      count,\n\t\t      GError   **error)\n{\n\tgssize r = -1;\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, -1);\n\t\tr = archive_read_data (archive->libar, buf, count);\n\t\tif (r < 0) {\n\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t\t     \"Failed to decompress data: %s\", archive_error_string (archive->libar));\n\t\t}\n\t\tbreak;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "static void update_db_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, DB_VECTOR);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (svm->nmi_singlestep)\n\t\tset_exception_intercept(svm, DB_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug &\n\t\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\tset_exception_intercept(svm, DB_VECTOR);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 1}
{"code": "static bool torture_smb2_notify_rmdir1(struct torture_context *torture,\n\t\t\t\t       struct smb2_tree *tree)\n{\n\treturn torture_smb2_notify_rmdir(torture, tree, tree, false);\n}", "target": 0}
{"code": "    LoaderExifDataJpeg::LoaderExifDataJpeg(PreviewId id, const Image &image, int parIdx)\n        : Loader(id, image),\n          dataKey_(param_[parIdx].dataKey_)\n    {\n        ExifData::const_iterator pos = image_.exifData().findKey(dataKey_);\n        if (pos != image_.exifData().end()) {\n            size_ = pos->sizeDataArea(); \n            if (size_ == 0 && pos->typeId() == undefined)\n                size_ = pos->size(); \n        }\n        if (size_ == 0) return;\n        valid_ = true;\n    }", "target": 0}
{"code": "static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tWARN_ON(req->buf == NULL);\n\tkfree(req->buf);\n\treq->buf = NULL;\n\tusb_ep_free_request(ep, req);\n}", "target": 0}
{"code": "find_script_callback(char_u *fname, void *cookie)\n{\n    int sid;\n    int error = OK;\n    int *ret_sid = cookie;\n    sid = find_script_by_name(fname);\n    if (sid < 0)\n    {\n\tsid = get_new_scriptitem(&error);\n\tif (error == OK)\n\t{\n\t    scriptitem_T *si = SCRIPT_ITEM(sid);\n\t    si->sn_name = vim_strsave(fname);\n\t    si->sn_state = SN_STATE_NOT_LOADED;\n\t}\n    }\n    *ret_sid = sid;\n}", "target": 0}
{"code": "static int slim_rx_mux_get(struct snd_kcontrol *kc,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kc);\n\tstruct wcd9335_codec *wcd = dev_get_drvdata(dapm->dev);\n\tucontrol->value.enumerated.item[0] = wcd->rx_port_value;\n\treturn 0;\n}", "target": 0}
{"code": "    uint32_t TiffEntryBase::doWriteImage(IoWrapper&,\n                                         ByteOrder ) const\n    {\n        return 0;\n    } ", "target": 0}
{"code": "static void scsi_dma_restart_bh(void *opaque)\n{\n    SCSIDiskState *s = opaque;\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    qemu_bh_delete(s->bh);\n    s->bh = NULL;\n    QTAILQ_FOREACH(req, &s->qdev.requests, next) {\n        r = DO_UPCAST(SCSIDiskReq, req, req);\n        if (r->status & SCSI_REQ_STATUS_RETRY) {\n            int status = r->status;\n            int ret;\n            r->status &=\n                ~(SCSI_REQ_STATUS_RETRY | SCSI_REQ_STATUS_RETRY_TYPE_MASK);\n            switch (status & SCSI_REQ_STATUS_RETRY_TYPE_MASK) {\n            case SCSI_REQ_STATUS_RETRY_READ:\n                scsi_read_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_WRITE:\n                scsi_write_data(&r->req);\n                break;\n            case SCSI_REQ_STATUS_RETRY_FLUSH:\n                ret = scsi_disk_emulate_command(r, r->iov.iov_base);\n                if (ret == 0) {\n                    scsi_req_complete(&r->req, GOOD);\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": "int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_tail = quicklist->tail;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {\n        quicklist->tail->zl =\n            ziplistPush(quicklist->tail->zl, value, sz, ZIPLIST_TAIL);\n        quicklistNodeUpdateSz(quicklist->tail);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);\n    }\n    quicklist->count++;\n    quicklist->tail->count++;\n    return (orig_tail != quicklist->tail);\n}", "target": 0}
{"code": "win_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}", "target": 0}
{"code": "cib_recv_tls(gnutls_session * session)\n{\n    char *buf = NULL;\n    int rc = 0;\n    int len = 0;\n    int chunk_size = 1024;\n    if (session == NULL) {\n        return NULL;\n    }\n    buf = calloc(1, chunk_size);\n    while (TRUE) {\n        errno = 0;\n        rc = gnutls_record_recv(*session, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", rc, errno);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_trace(\"Retry\");\n        } else if (rc == GNUTLS_E_UNEXPECTED_PACKET_LENGTH) {\n            crm_trace(\"Session disconnected\");\n            goto bail;\n        } else if (rc < 0) {\n            crm_err(\"Error receiving message: %s (%d)\", gnutls_strerror(rc), rc);\n            goto bail;\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else {\n            crm_trace(\"Got %d more bytes\", (int)rc);\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n}", "target": 1}
{"code": "int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n{\n\tResub scratch;\n\tint i;\n\tif (!sub)\n\t\tsub = &scratch;\n\tsub->nsub = prog->nsub;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n}", "target": 1}
{"code": "hb_set_union (hb_set_t       *set,\n\t      const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->union_ (*other);\n}", "target": 1}
{"code": "MagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n  PolicyRights\n    rights;\n  const CoderInfo\n    *p;\n  size_t\n    extent;\n  ssize_t\n    i;\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights|WritePolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}", "target": 0}
{"code": "deltas_head_for_each(struct deltas_head *deltas, unsigned long max_serial,\n    unsigned long from_serial, delta_head_cb cb, void *arg)\n{\n\tsize_t index;\n\tsize_t from;\n\tint error;\n\tif (deltas->capacity == 0) {\n\t\tpr_val_warn(\"There's no delta list to process.\");\n\t\treturn -ENOENT;\n\t}\n\tpr_val_debug(\"Getting RRDP deltas from serial %lu to %lu.\", from_serial,\n\t    max_serial);\n\tfrom = deltas->capacity - (max_serial - from_serial);\n\tfor (index = from; index < deltas->capacity; index++) {\n\t\terror = cb(deltas->array[index], arg);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}", "target": 1}
{"code": "static bool pmc_overflow(unsigned long val)\n{\n\tif ((int)val < 0)\n\t\treturn true;\n\tif (__is_processor(PV_POWER7) && ((0x80000000 - val) <= 256))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}", "target": 1}
{"code": "AP_DECLARE(request_rec *) ap_create_request(conn_rec *conn)\n{\n    request_rec *r;\n    apr_pool_t *p;\n    apr_pool_create(&p, conn->pool);\n    apr_pool_tag(p, \"request\");\n    r = apr_pcalloc(p, sizeof(request_rec));\n    AP_READ_REQUEST_ENTRY((intptr_t)r, (uintptr_t)conn);\n    r->pool            = p;\n    r->connection      = conn;\n    r->server          = conn->base_server;\n    r->user            = NULL;\n    r->ap_auth_type    = NULL;\n    r->allowed_methods = ap_make_method_list(p, 2);\n    r->headers_in      = apr_table_make(r->pool, 25);\n    r->trailers_in     = apr_table_make(r->pool, 5);\n    r->subprocess_env  = apr_table_make(r->pool, 25);\n    r->headers_out     = apr_table_make(r->pool, 12);\n    r->err_headers_out = apr_table_make(r->pool, 5);\n    r->trailers_out    = apr_table_make(r->pool, 5);\n    r->notes           = apr_table_make(r->pool, 5);\n    r->request_config  = ap_create_request_config(r->pool);\n    r->proto_output_filters = conn->output_filters;\n    r->output_filters  = r->proto_output_filters;\n    r->proto_input_filters = conn->input_filters;\n    r->input_filters   = r->proto_input_filters;\n    ap_run_create_request(r);\n    r->per_dir_config  = r->server->lookup_defaults;\n    r->sent_bodyct     = 0;                      \n    r->read_length     = 0;\n    r->read_body       = REQUEST_NO_BODY;\n    r->status          = HTTP_OK;  \n    r->header_only     = 0;\n    r->the_request     = NULL;\n    r->used_path_info = AP_REQ_DEFAULT_PATH_INFO;\n    r->useragent_addr = conn->client_addr;\n    r->useragent_ip = conn->client_ip;\n    return r;\n}", "target": 0}
{"code": "static int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tstruct inode *inode = nd->inode;\n\tif (!nd->root.mnt)\n\t\tset_root_rcu(nd);\n\twhile (1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\t\t\tinode = parent->d_inode;\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tnd->path.dentry = parent;\n\t\t\tnd->seq = seq;\n\t\t\tif (unlikely(!path_connected(&nd->path)))\n\t\t\t\treturn -ENOENT;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n\t\t\tstruct mount *mparent = mnt->mnt_parent;\n\t\t\tstruct dentry *mountpoint = mnt->mnt_mountpoint;\n\t\t\tstruct inode *inode2 = mountpoint->d_inode;\n\t\t\tunsigned seq = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tif (&mparent->mnt == nd->path.mnt)\n\t\t\t\tbreak;\n\t\t\tnd->path.dentry = mountpoint;\n\t\t\tnd->path.mnt = &mparent->mnt;\n\t\t\tinode = inode2;\n\t\t\tnd->seq = seq;\n\t\t}\n\t}\n\twhile (unlikely(d_mountpoint(nd->path.dentry))) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\treturn -ECHILD;\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tinode = nd->path.dentry->d_inode;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\tnd->inode = inode;\n\treturn 0;\n}", "target": 0}
{"code": "void sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& val = ctx->input(0);\n    int64 id = ctx->session_state()->GetNewId();\n    TensorStore::TensorAndKey tk{val, id, requested_device()};\n    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));\n    Tensor* handle = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));\n    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {\n      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(\n          ctx, SessionState::kTensorHandleResourceTypeName,\n          tk.GetHandle(name()));\n      resource_handle.set_maybe_type_name(\n          SessionState::kTensorHandleResourceTypeName);\n      handle->scalar<ResourceHandle>()() = resource_handle;\n    } else {\n      handle->flat<tstring>().setConstant(tk.GetHandle(name()));\n    }\n  }", "target": 1}
{"code": "static int handle_vmon(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tgpa_t vmptr;\n\tstruct page *page;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED\n\t\t| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_VMXE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tif (vmx->nested.vmxon) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif ((vmx->msr_ia32_feature_control & VMXON_NEEDED_FEATURES)\n\t\t\t!= VMXON_NEEDED_FEATURES) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\tif (nested_vmx_get_vmptr(vcpu, &vmptr))\n\t\treturn 1;\n\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> cpuid_maxphyaddr(vcpu))) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tpage = kvm_vcpu_gpa_to_page(vcpu, vmptr);\n\tif (is_error_page(page)) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (*(u32 *)kmap(page) != VMCS12_REVISION) {\n\t\tkunmap(page);\n\t\tkvm_release_page_clean(page);\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tkunmap(page);\n\tkvm_release_page_clean(page);\n\tvmx->nested.vmxon_ptr = vmptr;\n\tret = enter_vmx_operation(vcpu);\n\tif (ret)\n\t\treturn ret;\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 0}
{"code": "void *mempool_getbuffer(MemoryPoolHandle handle, size_t expected_buffer_size) {\n  int rc;\n  int bufs_to_allocate;\n  int bufs_that_can_be_allocated = 0;\n  struct memory_pool_element *pool_item = NULL;\n  struct mempool *pool = (struct mempool *)handle;\n  char *log_msg_fmt =\n      \"mempool(%p): mempool_getbuffer called for invalid \"\n      \"expected_buffer_size(%zu), current pool manages only \"\n      \"mempool_item_size(%zu)\";\n  char log_msg[300];\n  if (pool == NULL) {\n    return NULL;\n  }\n  if (pool->mempool_item_size != expected_buffer_size) {\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               expected_buffer_size, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_FATAL, log_msg);\n      return NULL;\n    }\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n  if (pool->free_bufs_in_pool == 0) {\n    bufs_to_allocate = pool->expandable_size / pool->mempool_item_size;\n    bufs_that_can_be_allocated = pool_can_expand_by(pool);\n    if (bufs_that_can_be_allocated > 0) {\n      bufs_to_allocate = ((bufs_to_allocate > bufs_that_can_be_allocated)\n                              ? bufs_that_can_be_allocated\n                              : bufs_to_allocate);\n      rc = freelist_allocate(pool, bufs_to_allocate);\n      if (rc != 0) {\n        if ((pool->flags & ENABLE_LOCKING) != 0) {\n          pthread_mutex_unlock(&pool->lock);\n        }\n        return NULL;\n      }\n    } else {\n      if ((pool->flags & ENABLE_LOCKING) != 0) {\n        pthread_mutex_unlock(&pool->lock);\n      }\n      return NULL;\n    }\n  }\n  if (pool->free_list != NULL) {\n    pool_item = pool->free_list;\n    pool->free_list = pool_item->next;\n    pool_item->next = (struct memory_pool_element *)NULL;\n    pool->free_bufs_in_pool--;\n  }\n  if (pool_item) {\n    pool->number_of_bufs_shared++;\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n  }\n  return (void *)pool_item;\n}", "target": 0}
{"code": "blockmix_salsa8(uint32_t * Bin, uint32_t * Bout, uint32_t * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[(2 * r - 1) * 16], 64);\n  for (i = 0; i < 2 * r; i += 2) {\n    blkxor(X, &Bin[i * 16], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 8], X, 64);\n    blkxor(X, &Bin[i * 16 + 16], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 8 + r * 16], X, 64);\n  }\n}", "target": 1}
{"code": "tpaddr_print_ip(netdissect_options *ndo,\n\t        const struct arp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (PROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong len>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, TPA(ap))));\n}", "target": 0}
{"code": "rndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\tBUFPUTSL(ob, \"<q>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</q>\");\n\treturn 1;\n}", "target": 1}
{"code": "ErrorCode HTTP2Codec::checkNewStream(uint32_t streamId, bool trailersAllowed) {\n  if (streamId == 0) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: received streamID=\", streamId,\n        \" as invalid new stream for lastStreamID_=\", lastStreamID_);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  }\n  parsingDownstreamTrailers_ = trailersAllowed && (streamId <= lastStreamID_);\n  if (parsingDownstreamTrailers_) {\n    VLOG(4) << \"Parsing downstream trailers streamId=\" << streamId;\n  }\n  if (sessionClosing_ != ClosingState::CLOSED) {\n    lastStreamID_ = streamId;\n  }\n  if (isInitiatedStream(streamId)) {\n    goawayErrorMessage_ = folly::to<string>(\n        \"GOAWAY error: invalid new stream received with streamID=\", streamId);\n    VLOG(4) << goawayErrorMessage_;\n    return ErrorCode::PROTOCOL_ERROR;\n  } else {\n    return ErrorCode::NO_ERROR;\n  }\n}", "target": 1}
{"code": "static gboolean is_correct_filename(const char *value)\n{\n    return printable_str(value) && !strchr(value, '/') && !strchr(value, '.');\n}", "target": 1}
{"code": "static void O_getOwnPropertyDescriptor(js_State *J)\n{\n\tjs_Object *obj;\n\tjs_Property *ref;\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\tref = jsV_getproperty(J, obj, js_tostring(J, 2));\n\tif (!ref) {\n\t\tjs_pushundefined(J);\n\t} else {\n\t\tjs_newobject(J);\n\t\tif (!ref->getter && !ref->setter) {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t\tjs_setproperty(J, -2, \"value\");\n\t\t\tjs_pushboolean(J, !(ref->atts & JS_READONLY));\n\t\t\tjs_setproperty(J, -2, \"writable\");\n\t\t} else {\n\t\t\tif (ref->getter)\n\t\t\t\tjs_pushobject(J, ref->getter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_setproperty(J, -2, \"get\");\n\t\t\tif (ref->setter)\n\t\t\t\tjs_pushobject(J, ref->setter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_setproperty(J, -2, \"set\");\n\t\t}\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTENUM));\n\t\tjs_setproperty(J, -2, \"enumerable\");\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTCONF));\n\t\tjs_setproperty(J, -2, \"configurable\");\n\t}\n}", "target": 1}
{"code": "static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\tif (la.l2_cid)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && !la.l2_psm) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\tswitch (sk->sk_state) {\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\t\tgoto wait;\n\tcase BT_CONNECTED:\n\t\tgoto done;\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\t\tbreak;\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tbacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);\n\tl2cap_pi(sk)->psm = la.l2_psm;\n\terr = l2cap_do_connect(sk);\n\tif (err)\n\t\tgoto done;\nwait:\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "absl::Status Ipv6Instance::validateProtocolSupported() {\n  static const bool supported = SocketInterfaceSingleton::get().ipFamilySupported(AF_INET6);\n  if (supported) {\n    return absl::OkStatus();\n  }\n  return absl::FailedPreconditionError(\"IPv6 addresses are not supported on this machine\");\n}", "target": 1}
{"code": "static void atomic2gen (lua_State *L, global_State *g) {\n  g->gcstate = GCSswpallgc;\n  sweep2old(L, &g->allgc);\n  g->reallyold = g->old = g->survival = g->allgc;\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;\n  sweep2old(L, &g->tobefnz);\n  g->gckind = KGC_GEN;\n  g->lastatomic = 0;\n  g->GCestimate = gettotalbytes(g);  \n  finishgencycle(L, g);\n}", "target": 0}
{"code": "TfLiteStatus SimpleOpEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = tflite::GetInput(context, node, 0);\n  const TfLiteTensor* input2 = tflite::GetInput(context, node, 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  int32_t* output_data = output->data.i32;\n  *output_data = *(input1->data.i32) + *(input2->data.i32);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getRangeLongFromObjectOrReply(c,c->argv[2],-LONG_MAX,LONG_MAX,&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withvalues = 1;\n            if (l < -LONG_MAX/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 0}
{"code": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  VALUE rb_schema;\n  VALUE errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n   schema = xmlSchemaParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "OFTEST(dcmect_overflow)\n{\n    if (!dcmDataDict.isDictionaryLoaded())\n    {\n        OFCHECK(dcmDataDict.isDictionaryLoaded());\n    }\n    EctEnhancedCT *ct = create();\n    configureIOD(ct);\n    setGenericValues(ct);\n    addSharedFGs(ct);\n    addFrames(ct);\n    addDimensions(ct);\n    DcmFileFormat dcmff;\n    OFTempFile tf(O_RDWR, \"\", \"t_overflow\", \".dcm\");\n    OFCondition result;\n    result = ct->saveFile(\"output.dcm\", EXS_LittleEndianExplicit);\n    OFCHECK_MSG(result == ECT_InvalidPixelInfo, result.text());\n}", "target": 0}
{"code": "static unsigned int caif_poll(struct file *file,\n\t\t\t\tstruct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tunsigned int mask;\n\tstruct caifsock *cf_sk = container_of(sk, struct caifsock, sk);\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tif (sk->sk_err)\n\t\tmask |= POLLERR;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue) ||\n\t\t(sk->sk_shutdown & RCV_SHUTDOWN))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock_writeable(sk) && tx_flow_is_on(cf_sk))\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\treturn mask;\n}", "target": 0}
{"code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                return;\n            }\n            iterator = it->second;\n        }\n        iterator->messages[messageId] = message;\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }", "target": 1}
{"code": "ip_printroute(netdissect_options *ndo,\n              register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tif (length < 3) {\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn;\n\t}\n\tif ((length + 1) & 3)\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n\t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n\tfor (len = 3; len < length; len += 4) {\n\t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n\t\tif (ptr > len)\n\t\t\tND_PRINT((ndo, \",\"));\n\t}\n}", "target": 1}
{"code": "static void do_free_publickey(struct rsa_public_key *s)\n{\n\tif (s) {\n\t\tcrypto_bignum_free(s->n);\n\t\tcrypto_bignum_free(s->e);\n\t}\n}", "target": 1}
{"code": "static void dnss_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,\nstruct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port)\n{\n\tint ret=0;\n\tstruct dns_hdr *dns_rsp;\n\tdns_rsp = (struct dns_hdr*) udp_packet_buffer->payload;\n\tdns_rsp->flags1 |= 0x80; \n\tdns_rsp->flags2 = 0x05;  \n\tret = udp_sendto(udp_pcb, udp_packet_buffer, sender_addr, sender_port);\n\tudp_disconnect(udp_pcb);\n\tpbuf_free(udp_packet_buffer);\n}", "target": 0}
{"code": "void ssl_update_cache(SSL_CONNECTION *s, int mode)\n{\n    int i;\n    if (s->session->session_id_length == 0)\n        return;\n    if (s->server && s->session->sid_ctx_length == 0\n            && (s->verify_mode & SSL_VERIFY_PEER) != 0)\n        return;\n    i = s->session_ctx->session_cache_mode;\n    if ((i & mode) != 0\n        && (!s->hit || SSL_CONNECTION_IS_TLS13(s))) {\n        if ((i & SSL_SESS_CACHE_NO_INTERNAL_STORE) == 0\n                && (!SSL_CONNECTION_IS_TLS13(s)\n                    || !s->server\n                    || (s->max_early_data > 0\n                        && (s->options & SSL_OP_NO_ANTI_REPLAY) == 0)\n                    || s->session_ctx->remove_session_cb != NULL\n                    || (s->options & SSL_OP_NO_TICKET) != 0))\n            SSL_CTX_add_session(s->session_ctx, s->session);\n        if (s->session_ctx->new_session_cb != NULL) {\n            SSL_SESSION_up_ref(s->session);\n            if (!s->session_ctx->new_session_cb(SSL_CONNECTION_GET_SSL(s),\n                                                s->session))\n                SSL_SESSION_free(s->session);\n        }\n    }\n    if ((!(i & SSL_SESS_CACHE_NO_AUTO_CLEAR)) && ((i & mode) == mode)) {\n        TSAN_QUALIFIER int *stat;\n        if (mode & SSL_SESS_CACHE_CLIENT)\n            stat = &s->session_ctx->stats.sess_connect_good;\n        else\n            stat = &s->session_ctx->stats.sess_accept_good;\n        if ((ssl_tsan_load(s->session_ctx, stat) & 0xff) == 0xff)\n            SSL_CTX_flush_sessions(s->session_ctx, (unsigned long)time(NULL));\n    }\n}", "target": 1}
{"code": "sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}", "target": 1}
{"code": "static void recovery_abort(void) {\n    if (!dry_run) {\n        storage_reset();\n    }\n    recovery_started = false;\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n}", "target": 0}
{"code": "static handler_t wstunnel_create_env(gw_handler_ctx *gwhctx) {\n    handler_ctx *hctx = (handler_ctx *)gwhctx;\n    request_st * const r = hctx->gw.r;\n    handler_t rc;\n    if (0 == r->reqbody_length || r->http_version > HTTP_VERSION_1_1) {\n        http_response_upgrade_read_body_unknown(r);\n        chunkqueue_append_chunkqueue(&r->reqbody_queue, &r->read_queue);\n    }\n    rc = mod_wstunnel_handshake_create_response(hctx);\n    if (rc != HANDLER_GO_ON) return rc;\n    r->http_status = (r->http_version > HTTP_VERSION_1_1)\n      ? 200  \n      : 101; \n    r->resp_body_started = 1;\n    hctx->ping_ts = log_monotonic_secs;\n    gw_set_transparent(&hctx->gw);\n    return HANDLER_GO_ON;\n}", "target": 0}
{"code": "static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(vcpu);\n}", "target": 0}
{"code": "static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cmap_t *cmap = &box->data.cmap;\n\tjp2_cmapent_t *ent;\n\tunsigned int i;\n\tcmap->ents = 0;\n\tcmap->numchans = (box->datalen) / 4;\n\tif (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < cmap->numchans; ++i) {\n\t\tent = &cmap->ents[i];\n\t\tif (jp2_getuint16(in, &ent->cmptno) ||\n\t\t  jp2_getuint8(in, &ent->map) ||\n\t\t  jp2_getuint8(in, &ent->pcol)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void inet_get_ping_group_range_net(struct net *net, kgid_t *low,\n\t\t\t\t\t  kgid_t *high)\n{\n\tkgid_t *data = net->ipv4.ping_group_range.range;\n\tunsigned int seq;\n\tdo {\n\t\tseq = read_seqbegin(&net->ipv4.ping_group_range.lock);\n\t\t*low = data[0];\n\t\t*high = data[1];\n\t} while (read_seqretry(&net->ipv4.ping_group_range.lock, seq));\n}", "target": 0}
{"code": "void kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n\tshared_msrs_global.msrs[slot] = msr;\n\tsmp_wmb();\n}", "target": 0}
{"code": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\treturn 0;\n}", "target": 0}
{"code": "void ___might_sleep(const char *file, int line, int preempt_offset)\n{\n\tstatic unsigned long prev_jiffy;\t\n\trcu_sleep_check(); \n\tif ((preempt_count_equals(preempt_offset) && !irqs_disabled() &&\n\t     !is_idle_task(current)) ||\n\t    system_state != SYSTEM_RUNNING || oops_in_progress)\n\t\treturn;\n\tif (time_before(jiffies, prev_jiffy + HZ) && prev_jiffy)\n\t\treturn;\n\tprev_jiffy = jiffies;\n\tprintk(KERN_ERR\n\t\t\"BUG: sleeping function called from invalid context at %s:%d\\n\",\n\t\t\tfile, line);\n\tprintk(KERN_ERR\n\t\t\"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\",\n\t\t\tin_atomic(), irqs_disabled(),\n\t\t\tcurrent->pid, current->comm);\n\tif (task_stack_end_corrupted(current))\n\t\tprintk(KERN_EMERG \"Thread overran stack, or stack corrupted\\n\");\n\tdebug_show_held_locks(current);\n\tif (irqs_disabled())\n\t\tprint_irqtrace_events(current);\n#ifdef CONFIG_DEBUG_PREEMPT\n\tif (!preempt_count_equals(preempt_offset)) {\n\t\tpr_err(\"Preemption disabled at:\");\n\t\tprint_ip_sym(current->preempt_disable_ip);\n\t\tpr_cont(\"\\n\");\n\t}\n#endif\n\tdump_stack();\n}", "target": 0}
{"code": "ev_archive_get_archive_type (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), EV_ARCHIVE_TYPE_NONE);\n\treturn archive->type;\n}", "target": 0}
{"code": "static void naldmx_switch_timestamps(GF_NALUDmxCtx *ctx, GF_FilterPacket *pck)\n{\n\tif (!ctx->notime) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tctx->prev_cts = ctx->cts;\n\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (ctx->full_au_source) {\n\t\t\t\tctx->prev_dts = ctx->dts;\n\t\t\t\tctx->dts = ts;\n\t\t\t} else {\n\t\t\t\tGF_FilterClockType ck_type = gf_filter_pid_get_clock_info(ctx->ipid, NULL, NULL);\n\t\t\t\tif (ck_type==GF_FILTER_CLOCK_PCR_DISC)\n\t\t\t\t\tctx->dts = ts;\n\t\t\t\telse if (ctx->dts<ts)\n\t\t\t\t\tctx->dts=ts;\n\t\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\t\tu64 diff = ts;\n\t\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\t\tif (!ctx->cur_fps.den)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\tctx->prev_dts = ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx->pck_duration = gf_filter_pck_get_duration(pck);\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, NULL);\n\t}\n}", "target": 0}
{"code": "static Jsi_RC SysVerConvertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *flag = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!val) goto bail;\n    if (Jsi_ValueIsNumber(interp, val)) {\n        char buf[200];\n        Jsi_Number n;\n        if (Jsi_GetNumberFromValue(interp, val, &n) != JSI_OK)\n            goto bail;\n        jsi_VersionNormalize(n, buf, sizeof(buf));\n        int trunc = 0;\n        if (flag && (Jsi_GetIntFromValue(interp, flag, &trunc) != JSI_OK\n            || trunc<0 || trunc>2))\n            return Jsi_LogError(\"arg2: bad trunc: expected int between 0 and 2\");\n        if (trunc) {\n            int len = Jsi_Strlen(buf)-1;\n            while (trunc>0 && len>1) {\n                if (buf[len] == '0' && buf[len-1] == '.')\n                    buf[len-1] = 0;\n                len -= 2;\n                trunc--;\n            }\n        }\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsString(interp, val)) {\n        Jsi_Number n;\n        if (jsi_GetVerFromVal(interp, val, &n, 0) == JSI_OK) {\n            Jsi_ValueMakeNumber(interp, ret, n);\n            return JSI_OK;\n        }\n    }\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}", "target": 1}
{"code": "int __init nfc_llcp_sock_init(void)\n{\n\treturn nfc_proto_register(&llcp_nfc_proto);\n}", "target": 0}
{"code": "static inline short key_read_state(const struct key *key)\n{\n\treturn smp_load_acquire(&key->state);\n}", "target": 0}
{"code": "de265_error decoder_context::read_pps_NAL(bitreader& reader)\n{\n  logdebug(LogHeaders,\"----> read PPS\\n\");\n  std::shared_ptr<pic_parameter_set> new_pps = std::make_shared<pic_parameter_set>();\n  bool success = new_pps->read(&reader,this);\n  if (param_pps_headers_fd>=0) {\n    new_pps->dump(param_pps_headers_fd);\n  }\n  if (success) {\n    pps[ (int)new_pps->pic_parameter_set_id ] = new_pps;\n  }\n  return success ? DE265_OK : DE265_WARNING_PPS_HEADER_INVALID;\n}", "target": 1}
{"code": "sysLocation_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"\");\n}", "target": 1}
{"code": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = \\\"%s\\\";\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, oidc_util_javascript_escape(r->pool, original_url));\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 0}
{"code": "static const char *tls_dns_name(const GENERAL_NAME * gn)\n{\n\tconst char *dnsname;\n\tif (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {\n\t\tg_warning(\"Invalid ASN1 value type in subjectAltName\");\n\t\treturn NULL;\n\t}\n\tdnsname = (char *) ASN1_STRING_data(gn->d.ia5);\n\tif (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {\n\t\tg_warning(\"Internal NUL in subjectAltName\");\n\t\treturn NULL;\n\t}\n\treturn dnsname;\n}", "target": 0}
{"code": "static int ct_play(struct media_player *mp, void *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\treturn ct_press(player, AVC_PLAY);\n}", "target": 0}
{"code": "static void cswitch(JF, js_Ast *ref, js_Ast *head)\n{\n\tjs_Ast *node, *clause, *def = NULL;\n\tint end;\n\tcexp(J, F, ref);\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tif (clause->type == STM_DEFAULT) {\n\t\t\tif (def)\n\t\t\t\tjsC_error(J, clause, \"more than one default label in switch\");\n\t\t\tdef = clause;\n\t\t} else {\n\t\t\tcexp(J, F, clause->a);\n\t\t\tclause->casejump = emitjump(J, F, OP_JCASE);\n\t\t}\n\t}\n\temit(J, F, OP_POP);\n\tif (def) {\n\t\tdef->casejump = emitjump(J, F, OP_JUMP);\n\t\tend = 0;\n\t} else {\n\t\tend = emitjump(J, F, OP_JUMP);\n\t}\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tlabel(J, F, clause->casejump);\n\t\tif (clause->type == STM_DEFAULT)\n\t\t\tcstmlist(J, F, clause->a);\n\t\telse\n\t\t\tcstmlist(J, F, clause->b);\n\t}\n\tif (end)\n\t\tlabel(J, F, end);\n}", "target": 0}
{"code": "static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t     struct file *out, loff_t *ppos,\n\t\t\t\t     size_t len, unsigned int flags)\n{\n\tunsigned nbuf;\n\tunsigned idx;\n\tstruct pipe_buffer *bufs;\n\tstruct fuse_copy_state cs;\n\tstruct fuse_dev *fud;\n\tsize_t rem;\n\tssize_t ret;\n\tfud = fuse_get_dev(out);\n\tif (!fud)\n\t\treturn -EPERM;\n\tpipe_lock(pipe);\n\tbufs = kvmalloc_array(pipe->nrbufs, sizeof(struct pipe_buffer),\n\t\t\t      GFP_KERNEL);\n\tif (!bufs) {\n\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tpipe_buf_get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\tfuse_copy_init(&cs, 0, NULL);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\tret = fuse_dev_do_write(fud, &cs, len);\n\tpipe_lock(pipe);\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\nout:\n\tkvfree(bufs);\n\treturn ret;\n}", "target": 1}
{"code": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}", "target": 1}
{"code": "void Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tif (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY\n\t      || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))\n\t\treturn;\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\texit_intr_info = vmx->exit_intr_info;\n\tif (is_machine_check(exit_intr_info))\n\t\tkvm_machine_check();\n\tif ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&\n\t    (exit_intr_info & INTR_INFO_VALID_MASK)) {\n\t\tkvm_before_handle_nmi(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_handle_nmi(&vmx->vcpu);\n\t}\n}", "target": 1}
{"code": "static void vmx_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\tvmx->rdtscp_enabled = false;\n\tif (vmx_rdtscp_supported()) {\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\tif (exec_control & SECONDARY_EXEC_RDTSCP) {\n\t\t\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\t\tif (best && (best->edx & bit(X86_FEATURE_RDTSCP)))\n\t\t\t\tvmx->rdtscp_enabled = true;\n\t\t\telse {\n\t\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\t\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\t\texec_control);\n\t\t\t}\n\t\t}\n\t}\n\tbest = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tif (vmx_invpcid_supported() &&\n\t    best && (best->ebx & bit(X86_FEATURE_INVPCID)) &&\n\t    guest_cpuid_has_pcid(vcpu)) {\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\texec_control |= SECONDARY_EXEC_ENABLE_INVPCID;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t     exec_control);\n\t} else {\n\t\tif (cpu_has_secondary_exec_ctrls()) {\n\t\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t     exec_control);\n\t\t}\n\t\tif (best)\n\t\t\tbest->ebx &= ~bit(X86_FEATURE_INVPCID);\n\t}\n}", "target": 0}
{"code": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}", "target": 1}
{"code": "static int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tuint32_t stride;\n\tchunk_t next_free;\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\te->new_chunk = ps->next_free;\n\tstride = (ps->exceptions_per_area + 1);\n\tnext_free = ++ps->next_free;\n\tif (sector_div(next_free, stride) == 1)\n\t\tps->next_free++;\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}", "target": 1}
{"code": "static int db__message_reconnect_reset_incoming(struct mosquitto *context)\n{\n\tstruct mosquitto_client_msg *msg, *tmp;\n\tcontext->msgs_in.inflight_bytes = 0;\n\tcontext->msgs_in.inflight_bytes12 = 0;\n\tcontext->msgs_in.inflight_count = 0;\n\tcontext->msgs_in.inflight_count12 = 0;\n\tcontext->msgs_in.queued_bytes = 0;\n\tcontext->msgs_in.queued_bytes12 = 0;\n\tcontext->msgs_in.queued_count = 0;\n\tcontext->msgs_in.queued_count12 = 0;\n\tcontext->msgs_in.inflight_quota = context->msgs_in.inflight_maximum;\n\tDL_FOREACH_SAFE(context->msgs_in.inflight, msg, tmp){\n\t\tdb__msg_add_to_inflight_stats(&context->msgs_in, msg);\n\t\tif(msg->qos > 0){\n\t\t\tutil__decrement_receive_quota(context);\n\t\t}\n\t\tif(msg->qos != 2){\n\t\t\tdb__message_remove_from_inflight(&context->msgs_in, msg);\n\t\t}else{\n\t\t\tmsg->dup = 0;\n\t\t}\n\t}\n\tDL_FOREACH_SAFE(context->msgs_in.queued, msg, tmp){\n\t\tmsg->dup = 0;\n\t\tdb__msg_add_to_queued_stats(&context->msgs_in, msg);\n\t\tif(db__ready_for_flight(context, mosq_md_in, msg->qos)){\n\t\t\tswitch(msg->qos){\n\t\t\t\tcase 0:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tmsg->state = mosq_ms_publish_qos2;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdb__message_dequeue_first(context, &context->msgs_in);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 0}
{"code": "void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\tif (!handle)\n\t\treturn NULL;\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\treturn pointer;\n}", "target": 1}
{"code": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n      if (jsvHasChildren(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}", "target": 1}
{"code": "bool __net_get_random_once(void *buf, int nbytes, bool *done,\n\t\t\t   struct static_key *done_key)\n{\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long flags;\n\tspin_lock_irqsave(&lock, flags);\n\tif (*done) {\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t\treturn false;\n\t}\n\tget_random_bytes(buf, nbytes);\n\t*done = true;\n\tspin_unlock_irqrestore(&lock, flags);\n\t__net_random_once_disable_jump(done_key);\n\treturn true;\n}", "target": 1}
{"code": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\ttimr->it_interval = 0;\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}", "target": 1}
{"code": "static void resv_map_put(struct vm_area_struct *vma)\n{\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tif (!reservations)\n\t\treturn;\n\tkref_put(&reservations->refs, resv_map_release);\n}", "target": 0}
{"code": "OPJ_BOOL opj_j2k_encoding_validation (  opj_j2k_t * p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager )\n{\n        OPJ_BOOL l_is_valid = OPJ_TRUE;\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NONE);\n        l_is_valid &= (p_j2k->m_procedure_list != 00);\n        l_is_valid &= (p_j2k->m_validation_list != 00);\n        if ((p_j2k->m_cp.tcps->tccps->numresolutions <= 0) || (p_j2k->m_cp.tcps->tccps->numresolutions > 32)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n        if ((p_j2k->m_cp.tdx) < (OPJ_UINT32) (1 << (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n        if ((p_j2k->m_cp.tdy) < (OPJ_UINT32) (1 << (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n        return l_is_valid;\n}", "target": 0}
{"code": "bool cli_check_msdfs_proxy(TALLOC_CTX *ctx,\n\t\t\t\tstruct cli_state *cli,\n\t\t\t\tconst char *sharename,\n\t\t\t\tchar **pp_newserver,\n\t\t\t\tchar **pp_newshare,\n\t\t\t\tbool force_encrypt,\n\t\t\t\tconst char *username,\n\t\t\t\tconst char *password,\n\t\t\t\tconst char *domain)\n{\n\tstruct client_dfs_referral *refs = NULL;\n\tsize_t num_refs = 0;\n\tsize_t consumed = 0;\n\tchar *fullpath = NULL;\n\tbool res;\n\tuint16_t cnum;\n\tchar *newextrapath = NULL;\n\tNTSTATUS status;\n\tconst char *remote_name;\n\tif (!cli || !sharename) {\n\t\treturn false;\n\t}\n\tremote_name = smbXcli_conn_remote_name(cli->conn);\n\tcnum = cli_state_get_tid(cli);\n\tif (strequal(sharename, \"IPC$\")) {\n\t\treturn false;\n\t}\n\tfullpath = talloc_asprintf(ctx, \"\\\\%s\\\\%s\", remote_name, sharename);\n\tif (!fullpath) {\n\t\treturn false;\n\t}\n\tif (!NT_STATUS_IS_OK(cli_tree_connect(cli, \"IPC$\", \"IPC\", NULL, 0))) {\n\t\treturn false;\n\t}\n\tif (force_encrypt) {\n\t\tstatus = cli_cm_force_encryption(cli,\n\t\t\t\t\tusername,\n\t\t\t\t\tpassword,\n\t\t\t\t\tdomain,\n\t\t\t\t\t\"IPC$\");\n\t\tif (!NT_STATUS_IS_OK(status)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tstatus = cli_dfs_get_referral(ctx, cli, fullpath, &refs,\n\t\t\t\t      &num_refs, &consumed);\n\tres = NT_STATUS_IS_OK(status);\n\tstatus = cli_tdis(cli);\n\tif (!NT_STATUS_IS_OK(status)) {\n\t\treturn false;\n\t}\n\tcli_state_set_tid(cli, cnum);\n\tif (!res || !num_refs) {\n\t\treturn false;\n\t}\n\tif (!refs[0].dfspath) {\n\t\treturn false;\n\t}\n\tif (!split_dfs_path(ctx, refs[0].dfspath, pp_newserver,\n\t\t\t    pp_newshare, &newextrapath)) {\n\t\treturn false;\n\t}\n\tif (strequal(remote_name, *pp_newserver) &&\n\t\t\tstrequal(sharename, *pp_newshare)) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tconst QFileInfo outputInfo(outputFile);\n\tconst QDir dir=outputInfo.dir(); \n\tconst QFileInfo newFileNameInfo(name);\n\tconst bool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\tif (name.contains(\"config.ini\"))\n\t{\n\t\tqWarning() << \"SCRIPTING ERROR: You are trying to overwrite config.ini. Ignoring.\";\n\t\treturn;\n\t}\n\tif (!okToSaveToAbsolutePath && ((newFileNameInfo.isAbsolute() || (name.contains(\"..\"))))) \n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname or move up in directories.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}", "target": 0}
{"code": "test_custom_handler(void **state)\n{\n    (void) state;\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1, \"cstm\", custom_err_handler);\n    assert_null(old);\n    unsigned i;\n    for (i = 1; i < 4; i++) {\n        TSS2_RC rc = TSS2_RC_LAYER(1) | i;\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"cstm:error %u\", i);\n        const char *e = Tss2_RC_Decode(rc);\n        assert_string_equal(e, buf);\n    }\n    TSS2_RC rc = TSS2_RC_LAYER(1) | 42;\n    const char *e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"cstm:0x2A\");\n    old = Tss2_RC_SetHandler(1, \"cstm\", NULL);\n    assert_ptr_equal(old, custom_err_handler);\n    e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"1:0x2A\");\n}", "target": 1}
{"code": "local block_state deflate_fast(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    IPos hash_head;       \n    int bflush;           \n    for (;;) {\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; \n        }\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n            s->match_length = longest_match (s, hash_head);\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n            s->lookahead -= s->match_length;\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--; \n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                } while (--s->match_length != 0);\n                s->strstart++;\n            } else\n#endif\n            {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window[s->strstart];\n                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n            }\n        } else {\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "void lremCommand(client *c) {\n    robj *subject, *obj;\n    obj = c->argv[3];\n    long toremove;\n    long removed = 0;\n    if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))\n        return;\n    subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);\n    if (subject == NULL || checkType(c,subject,OBJ_LIST)) return;\n    listTypeIterator *li;\n    if (toremove < 0) {\n        toremove = -toremove;\n        li = listTypeInitIterator(subject,-1,LIST_HEAD);\n    } else {\n        li = listTypeInitIterator(subject,0,LIST_TAIL);\n    }\n    listTypeEntry entry;\n    while (listTypeNext(li,&entry)) {\n        if (listTypeEqual(&entry,obj)) {\n            listTypeDelete(li, &entry);\n            server.dirty++;\n            removed++;\n            if (toremove && removed == toremove) break;\n        }\n    }\n    listTypeReleaseIterator(li);\n    if (removed) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,\"lrem\",c->argv[1],c->db->id);\n    }\n    if (listTypeLength(subject) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n    addReplyLongLong(c,removed);\n}", "target": 0}
{"code": "kdc_process_s4u_x509_user(krb5_context context,\n                          krb5_kdc_req *request,\n                          krb5_pa_data *pa_data,\n                          krb5_keyblock *tgs_subkey,\n                          krb5_keyblock *tgs_session,\n                          krb5_pa_s4u_x509_user **s4u_x509_user,\n                          const char **status)\n{\n    krb5_error_code             code;\n    krb5_data                   req_data;\n    req_data.length = pa_data->length;\n    req_data.data = (char *)pa_data->contents;\n    code = decode_krb5_pa_s4u_x509_user(&req_data, s4u_x509_user);\n    if (code)\n        return code;\n    code = verify_s4u_x509_user_checksum(context,\n                                         tgs_subkey ? tgs_subkey :\n                                         tgs_session,\n                                         &req_data,\n                                         request->nonce, *s4u_x509_user);\n    if (code) {\n        *status = \"INVALID_S4U2SELF_CHECKSUM\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return code;\n    }\n    if (krb5_princ_size(context, (*s4u_x509_user)->user_id.user) == 0 ||\n        (*s4u_x509_user)->user_id.subject_cert.length != 0) {\n        *status = \"INVALID_S4U2SELF_REQUEST\";\n        krb5_free_pa_s4u_x509_user(context, *s4u_x509_user);\n        *s4u_x509_user = NULL;\n        return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN;\n    }\n    return 0;\n}", "target": 1}
{"code": "static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,\n\tstruct oz_usb_hdr *usb_hdr, int len)\n{\n\tstruct oz_data *data_hdr = (struct oz_data *)usb_hdr;\n\tswitch (data_hdr->format) {\n\tcase OZ_DATA_F_MULTIPLE_FIXED: {\n\t\t\tstruct oz_multiple_fixed *body =\n\t\t\t\t(struct oz_multiple_fixed *)data_hdr;\n\t\t\tu8 *data = body->data;\n\t\t\tunsigned int n;\n\t\t\tif (!body->unit_size ||\n\t\t\t\tlen < sizeof(struct oz_multiple_fixed) - 1)\n\t\t\t\tbreak;\n\t\t\tn = (len - (sizeof(struct oz_multiple_fixed) - 1))\n\t\t\t\t/ body->unit_size;\n\t\t\twhile (n--) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport, body->endpoint,\n\t\t\t\t\tdata, body->unit_size);\n\t\t\t\tdata += body->unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OZ_DATA_F_ISOC_FIXED: {\n\t\t\tstruct oz_isoc_fixed *body =\n\t\t\t\t(struct oz_isoc_fixed *)data_hdr;\n\t\t\tint data_len = len-sizeof(struct oz_isoc_fixed)+1;\n\t\t\tint unit_size = body->unit_size;\n\t\t\tu8 *data = body->data;\n\t\t\tint count;\n\t\t\tint i;\n\t\t\tif (!unit_size)\n\t\t\t\tbreak;\n\t\t\tcount = data_len/unit_size;\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\toz_hcd_data_ind(usb_ctx->hport,\n\t\t\t\t\tbody->endpoint, data, unit_size);\n\t\t\t\tdata += unit_size;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t\treturn 0;\n\t}\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t}\n\tif (retval_ptr)\n\t\tzval_ptr_dtor(&retval_ptr);\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 0}
{"code": "static void drive_file_fix_path(WCHAR* path)\n{\n\tsize_t i;\n\tsize_t length = _wcslen(path);\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n#ifdef WIN32\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn;\n#else\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn;\n#endif\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n}", "target": 1}
{"code": "  Status Init(DataType input_type, const string& fill = \"\", int width = -1,\n              int precision = -1, bool scientific = false,\n              bool shortest = false) {\n    TF_CHECK_OK(NodeDefBuilder(\"op\", \"AsString\")\n                    .Input(FakeInput(input_type))\n                    .Attr(\"fill\", fill)\n                    .Attr(\"precision\", precision)\n                    .Attr(\"scientific\", scientific)\n                    .Attr(\"shortest\", shortest)\n                    .Attr(\"width\", width)\n                    .Finalize(node_def()));\n    return InitOp();\n  }", "target": 0}
{"code": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n{\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}", "target": 1}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    CHECK_GE(dtypes.size(), size_t{1});\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      DCHECK_EQ(arg_index, result_.nodes.size());\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "static void vapic_exit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint idx;\n\tif (!apic || !apic->vapic_addr)\n\t\treturn;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tkvm_release_page_dirty(apic->vapic_page);\n\tmark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n}", "target": 1}
{"code": "static void TEST_sub_add_single(void)\n{\n\tstruct mosquitto__config config;\n\tstruct mosquitto__listener listener;\n\tstruct mosquitto context;\n\tstruct mosquitto__subhier *sub;\n\tint rc;\n\tmemset(&db, 0, sizeof(struct mosquitto_db));\n\tmemset(&config, 0, sizeof(struct mosquitto__config));\n\tmemset(&listener, 0, sizeof(struct mosquitto__listener));\n\tmemset(&context, 0, sizeof(struct mosquitto));\n\tcontext.id = \"client\";\n\tdb.config = &config;\n\tlistener.port = 1883;\n\tconfig.listeners = &listener;\n\tconfig.listener_count = 1;\n\tdb__open(&config);\n\trc = sub__add(&context, \"a/b/c/d/e\", 0, 0, 0);\n\tCU_ASSERT_EQUAL(rc, MOSQ_ERR_SUCCESS);\n\tCU_ASSERT_PTR_NOT_NULL(db.subs);\n\tif(db.subs){\n\t\tsub = db.subs;\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"a\");\n\t\thier_quick_check(&sub, NULL, \"b\");\n\t\thier_quick_check(&sub, NULL, \"c\");\n\t\thier_quick_check(&sub, NULL, \"d\");\n\t\thier_quick_check(&sub, &context, \"e\");\n\t\tCU_ASSERT_PTR_NULL(sub);\n\t}\n\tmosquitto__free(context.subs);\n\tdb__close();\n}", "target": 1}
{"code": "file_push_buffer(struct magic_set *ms)\n{\n\tfile_pushbuf_t *pb;\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\tif ((pb = (CAST(file_pushbuf_t *, malloc(sizeof(*pb))))) == NULL)\n\t\treturn NULL;\n\tpb->buf = ms->o.buf;\n\tpb->offset = ms->offset;\n\tms->o.buf = NULL;\n\tms->offset = 0;\n\treturn pb;\n}", "target": 0}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(bufsize >= 0);\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  if (input == nullptr) {\n    VLOG(1) << \"node = \" << node.name() << \" input = \" << node.input(0);\n    return false;\n  }\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint res;\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\tif (IS_ERR(dst)) {\n\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\tsk->sk_route_caps = 0;\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(dst);\n\t}\n\trcu_read_lock();\n\tskb_dst_set_noref(skb, dst);\n\tfl6.daddr = sk->sk_v6_daddr;\n\tres = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\trcu_read_unlock();\n\treturn res;\n}", "target": 1}
{"code": "static u32 swf_get_32(SWFReader *read)\n{\n\tu32 val, res;\n\tval = swf_read_int(read, 32);\n\tres = (val&0xFF);\n\tres <<=8;\n\tres |= ((val>>8)&0xFF);\n\tres<<=8;\n\tres |= ((val>>16)&0xFF);\n\tres<<=8;\n\tres|= ((val>>24)&0xFF);\n\treturn res;\n}", "target": 1}
{"code": "static bool checkCurl() {\n\tconst char nul[] = R_SYS_DEVNULL;\n\tif (r_sys_cmdf (\"curl --version > %s\", nul) != 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static int cipso_v4_delopt(struct ip_options **opt_ptr)\n{\n\tint hdr_delta = 0;\n\tstruct ip_options *opt = *opt_ptr;\n\tif (opt->srr || opt->rr || opt->ts || opt->router_alert) {\n\t\tu8 cipso_len;\n\t\tu8 cipso_off;\n\t\tunsigned char *cipso_ptr;\n\t\tint iter;\n\t\tint optlen_new;\n\t\tcipso_off = opt->cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->__data[cipso_off];\n\t\tcipso_len = cipso_ptr[1];\n\t\tif (opt->srr > opt->cipso)\n\t\t\topt->srr -= cipso_len;\n\t\tif (opt->rr > opt->cipso)\n\t\t\topt->rr -= cipso_len;\n\t\tif (opt->ts > opt->cipso)\n\t\t\topt->ts -= cipso_len;\n\t\tif (opt->router_alert > opt->cipso)\n\t\t\topt->router_alert -= cipso_len;\n\t\topt->cipso = 0;\n\t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->optlen - cipso_off - cipso_len);\n\t\titer = 0;\n\t\toptlen_new = 0;\n\t\twhile (iter < opt->optlen)\n\t\t\tif (opt->__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->__data[iter + 1];\n\t\t\t\toptlen_new = iter;\n\t\t\t} else\n\t\t\t\titer++;\n\t\thdr_delta = opt->optlen;\n\t\topt->optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->optlen;\n\t} else {\n\t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->optlen;\n\t\tkfree(opt);\n\t}\n\treturn hdr_delta;\n}", "target": 1}
{"code": "deinit_pci(struct vmctx *ctx)\n{\n\tstruct pci_vdev_ops *ops;\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct funcinfo *fi;\n\tint bus, slot, func;\n\tsize_t lowmem;\n\tstruct mem_range mr;\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI ECFG\";\n\tmr.base = PCI_EMUL_ECFG_BASE;\n\tmr.size = PCI_EMUL_ECFG_SIZE;\n\tunregister_mem(&mr);\n\tlowmem = vm_get_lowmem_size(ctx);\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI hole (32-bit)\";\n\tmr.base = lowmem;\n\tmr.size = (4ULL * 1024 * 1024 * 1024) - lowmem;\n\tunregister_mem_fallback(&mr);\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI hole (64-bit)\";\n\tmr.base = PCI_EMUL_MEMBASE64;\n\tmr.size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64;\n\tunregister_mem_fallback(&mr);\n\tfor (bus = 0; bus < MAXBUSES; bus++) {\n\t\tbi = pci_businfo[bus];\n\t\tif (bi == NULL)\n\t\t\tcontinue;\n\t\tfor (slot = 0; slot < MAXSLOTS; slot++) {\n\t\t\tsi = &bi->slotinfo[slot];\n\t\t\tfor (func = 0; func < MAXFUNCS; func++) {\n\t\t\t\tfi = &si->si_funcs[func];\n\t\t\t\tif (fi->fi_name == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tops = pci_emul_finddev(fi->fi_name);\n\t\t\t\tassert(ops != NULL);\n\t\t\t\tpr_notice(\"pci deinit %s\\n\", fi->fi_name);\n\t\t\t\tpci_emul_deinit(ctx, ops, bus, slot,\n\t\t\t\t    func, fi);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "mark_context_stack(mrb_state *mrb, struct mrb_context *c)\n{\n  size_t i;\n  size_t e;\n  if (c->stack == NULL) return;\n  e = c->stack - c->stbase;\n  if (c->ci) e += c->ci->nregs;\n  if (c->stbase + e > c->stend) e = c->stend - c->stbase;\n  for (i=0; i<e; i++) {\n    mrb_value v = c->stbase[i];\n    if (!mrb_immediate_p(v)) {\n      if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) {\n        c->stbase[i] = mrb_nil_value();\n      }\n      else {\n        mrb_gc_mark(mrb, mrb_basic_ptr(v));\n      }\n    }\n  }\n}", "target": 1}
{"code": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\tkenter(\"%p{%u}\", user, uid);\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\tif (!user->uid_keyring) {\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "set_interface_var(const char *iface,\n\t\t  const char *var, const char *name,\n\t\t  uint32_t val)\n{\n\tFILE *fp;\n\tchar spath[64+IFNAMSIZ];\t\n\tif (snprintf(spath, sizeof(spath), var, iface) >= sizeof(spath))\n\t\treturn -1;\n\tif (strstr(name, \"..\") || strchr(name, '/'))\n\t\treturn -1;\n\tif (access(spath, F_OK) != 0)\n\t\treturn -1;\n\tfp = fopen(spath, \"w\");\n\tif (!fp) {\n\t\tif (name)\n\t\t\tflog(LOG_ERR, \"failed to set %s (%u) for %s: %s\",\n\t\t\t     name, val, iface, strerror(errno));\n\t\treturn -1;\n\t}\n\tfprintf(fp, \"%u\", val);\n\tfclose(fp);\n\treturn 0;\n}", "target": 0}
{"code": "bool CSecurityTLS::processMsg(CConnection* cc)\n{\n  rdr::InStream* is = cc->getInStream();\n  rdr::OutStream* os = cc->getOutStream();\n  client = cc;\n  initGlobal();\n  if (!session) {\n    if (!is->checkNoWait(1))\n      return false;\n    if (is->readU8() == 0) {\n      rdr::U32 result = is->readU32();\n      CharArray reason;\n      if (result == secResultFailed || result == secResultTooMany)\n        reason.buf = is->readString();\n      else\n        reason.buf = strDup(\"Authentication failure (protocol error)\");\n      throw AuthFailureException(reason.buf);\n    }\n    if (gnutls_init(&session, GNUTLS_CLIENT) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n    setParam();\n  }\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n    if (!gnutls_error_is_fatal(err))\n      return false;\n    vlog.error(\"TLS Handshake failed: %s\\n\", gnutls_strerror (err));\n    shutdown(false);\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n  checkSession();\n  cc->setStreams(fis = tlsis, fos = tlsos);\n  return true;\n}", "target": 1}
{"code": "krb5_gss_context_time(minor_status, context_handle, time_rec)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    OM_uint32 *time_rec;\n{\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    if ((code = krb5_timeofday(ctx->k5_context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, ctx->k5_context);\n        return(GSS_S_FAILURE);\n    }\n    if ((lifetime = ctx->krb_times.endtime - now) <= 0) {\n        *time_rec = 0;\n        *minor_status = 0;\n        return(GSS_S_CONTEXT_EXPIRED);\n    } else {\n        *time_rec = lifetime;\n        *minor_status = 0;\n        return(GSS_S_COMPLETE);\n    }\n}", "target": 1}
{"code": "static void frag_kfree_skb(struct netns_frags *nf, struct sk_buff *skb)\n{\n\tatomic_sub(skb->truesize, &nf->mem);\n\tkfree_skb(skb);\n}", "target": 1}
{"code": "void ldbRedis(lua_State *lua, sds *argv, int argc) {\n    int j, saved_rc = server.lua_replicate_commands;\n    if (!lua_checkstack(lua, argc + 1)) {\n        ldbLogRedisReply(\"max lua stack reached\");\n        return;\n    }\n    lua_getglobal(lua,\"redis\");\n    lua_pushstring(lua,\"call\");\n    lua_gettable(lua,-2);       \n    for (j = 1; j < argc; j++)\n        lua_pushlstring(lua,argv[j],sdslen(argv[j]));\n    ldb.step = 1;               \n    server.lua_replicate_commands = 1;\n    lua_pcall(lua,argc-1,1,0);  \n    ldb.step = 0;               \n    server.lua_replicate_commands = saved_rc;\n    lua_pop(lua,2);             \n}", "target": 0}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if ((EncISO_8859_2_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code = ENC_ISO_8859_2_TO_LOWER_CASE(code);\n    }\n    else if ((EncISO_8859_2_CtypeTable[code] & BIT_CTYPE_LOWER)\n       && (flags & ONIGENC_CASE_UPCASE)) {\n      if (code >= 0xB1 && code <= 0xBF) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode -= 0x10;\n      }\n      else {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode -= 0x20;\n      }\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "static void php_mcrypt_module_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC) \n{\n\tphp_mcrypt *pm = (php_mcrypt *) rsrc->ptr;\n\tif (pm) {\t\n\t\tmcrypt_generic_deinit(pm->td);\n\t\tmcrypt_module_close(pm->td);\n\t\tefree(pm);\n\t\tpm = NULL;\n\t}", "target": 1}
{"code": "void AICast_ScriptLoad( void ) {\n\tchar filename[MAX_QPATH];\n\tvmCvar_t mapname;\n\tfileHandle_t f;\n\tint len;\n\tlevel.scriptAI = NULL;\n\ttrap_Cvar_VariableStringBuffer( \"ai_scriptName\", filename, sizeof( filename ) );\n\tif ( strlen( filename ) > 0 ) {\n\t\ttrap_Cvar_Register( &mapname, \"ai_scriptName\", \"\", CVAR_ROM );\n\t} else {\n\t\ttrap_Cvar_Register( &mapname, \"mapname\", \"\", CVAR_SERVERINFO | CVAR_ROM );\n\t}\n\tQ_strncpyz( filename, \"maps/\", sizeof( filename ) );\n\tQ_strcat( filename, sizeof( filename ), mapname.string );\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tQ_strcat( filename, sizeof( filename ), \".coop.ai\" );\n\t} else {\n\t\tQ_strcat( filename, sizeof( filename ), \".ai\" );\n\t}\n\tlen = trap_FS_FOpenFile( filename, &f, FS_READ );\n\tG_Printf( \"Loading: %s\\n\", filename );\n\tif ( len < 0 ) {\n\t\treturn;\n\t}\n\tlevel.scriptAI = G_Alloc( len );\n\ttrap_FS_Read( level.scriptAI, len, f );\n\ttrap_FS_FCloseFile( f );\n\treturn;\n}", "target": 1}
{"code": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE(context, input->type == kTfLiteUInt8 ||\n                              input->type == kTfLiteInt8 ||\n                              input->type == kTfLiteInt16);\n  TF_LITE_ENSURE(\n      context, output->type == kTfLiteFloat32 || output->type == kTfLiteInt32);\n  if (output->type == kTfLiteInt32) {\n    const double effective_output_scale =\n        static_cast<double>(input->params.scale) /\n        static_cast<double>(output->params.scale);\n    QuantizeMultiplier(effective_output_scale, &data->output_multiplier,\n                       &data->output_shift);\n  }\n  data->quantization_params.zero_point = input->params.zero_point;\n  data->quantization_params.scale = static_cast<double>(input->params.scale);\n  data->output_zero_point = output->params.zero_point;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "Variant HHVM_FUNCTION(mcrypt_create_iv, int size, int source ) {\n  if (size <= 0 || size >= INT_MAX) {\n    raise_warning(\"Can not create an IV with a size of less than 1 or \"\n                    \"greater than %d\", INT_MAX);\n    return false;\n  }\n  int n = 0;\n  char *iv = (char*)calloc(size + 1, 1);\n  if (source == RANDOM || source == URANDOM) {\n    int fd = open(source == RANDOM ? \"/dev/random\" : \"/dev/urandom\", O_RDONLY);\n    if (fd < 0) {\n      free(iv);\n      raise_warning(\"Cannot open source device\");\n      return false;\n    }\n    int read_bytes;\n    for (read_bytes = 0; read_bytes < size && n >= 0; read_bytes += n) {\n      n = read(fd, iv + read_bytes, size - read_bytes);\n    }\n    n = read_bytes;\n    close(fd);\n    if (n < size) {\n      free(iv);\n      raise_warning(\"Could not gather sufficient random data\");\n      return false;\n    }\n  } else {\n    n = size;\n    while (size) {\n      iv[--size] = (char)(255.0 * rand() / RAND_MAX);\n    }\n  }\n  return String(iv, n, AttachString);\n}", "target": 1}
{"code": "static int dcbnl_getperm_hwaddr(struct net_device *netdev, struct nlmsghdr *nlh,\n\t\t\t\tu32 seq, struct nlattr **tb, struct sk_buff *skb)\n{\n\tu8 perm_addr[MAX_ADDR_LEN];\n\tif (!netdev->dcbnl_ops->getpermhwaddr)\n\t\treturn -EOPNOTSUPP;\n\tmemset(perm_addr, 0, sizeof(perm_addr));\n\tnetdev->dcbnl_ops->getpermhwaddr(netdev, perm_addr);\n\treturn nla_put(skb, DCB_ATTR_PERM_HWADDR, sizeof(perm_addr), perm_addr);\n}", "target": 0}
{"code": "static ssize_t module_xz_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0xfd, '7', 'z', 'X', 'Z', 0 };\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tsize_t new_size = 0;\n\tssize_t retval;\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not an xz compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\txz_buf.in_size = size;\n\txz_buf.in = buf;\n\txz_buf.in_pos = 0;\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\t\tnew_size += xz_buf.out_pos;\n\t} while (xz_buf.out_pos == PAGE_SIZE && xz_ret == XZ_OK);\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", xz_ret);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tretval = new_size;\n out:\n\txz_dec_end(xz_dec);\n\treturn retval;\n}", "target": 1}
{"code": "static void adpt_i386_info(sysInfo_S* si)\n{\n\tswitch (boot_cpu_data.x86) {\n\tcase CPU_386:\n\t\tsi->processorType = PROC_386;\n\t\tbreak;\n\tcase CPU_486:\n\t\tsi->processorType = PROC_486;\n\t\tbreak;\n\tcase CPU_586:\n\t\tsi->processorType = PROC_PENTIUM;\n\t\tbreak;\n\tdefault:  \n\t\tsi->processorType = PROC_PENTIUM;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\tif (fpl) {\n\t\tscm->fp = NULL;\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tfput(fpl->fp[i]);\n\t\tfree_uid(fpl->user);\n\t\tkfree(fpl);\n\t}\n}", "target": 0}
{"code": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  xmlRelaxNGPtr schema;\n  VALUE errors = rb_ary_new();\n  VALUE rb_schema;\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlRelaxNGParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "static int DefragBsdMissingFragmentIpv4Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "static struct dentry *proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\tinode->i_nlink = 4;\n#ifdef CONFIG_SECURITY\n\tinode->i_nlink += 1;\n#endif\n\tdentry->d_op = &pid_dentry_operations;\n\td_add(dentry, inode);\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}", "target": 0}
{"code": "void TestDecodeGif(Env* env, DecodeGifTestCase testcase) {\n  string gif;\n  ReadFileToStringOrDie(env, testcase.filepath, &gif);\n  std::unique_ptr<uint8[]> imgdata;\n  int nframes, w, h, c;\n  string error_string;\n  imgdata.reset(gif::Decode(\n      gif.data(), gif.size(),\n      [&](int frame_cnt, int width, int height, int channels) -> uint8* {\n        nframes = frame_cnt;\n        w = width;\n        h = height;\n        c = channels;\n        return new uint8[frame_cnt * height * width * channels];\n      },\n      &error_string));\n  ASSERT_NE(imgdata, nullptr);\n  ASSERT_EQ(nframes, testcase.num_frames);\n  ASSERT_EQ(w, testcase.width);\n  ASSERT_EQ(h, testcase.height);\n  ASSERT_EQ(c, testcase.channels);\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensor(TfLiteContext* context,\n                                SpaceToBatchNDContext* op_context) {\n  TfLiteIntArray* input_size = op_context->input->dims;\n  const int32* block_shape = GetTensorData<int32>(op_context->block_shape);\n  const int32* paddings_data = GetTensorData<int32>(op_context->paddings);\n  int spatial_dims_num = input_size->size - 2;\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->block_shape), 1);\n  TF_LITE_ENSURE_EQ(context, op_context->block_shape->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(op_context->paddings), 2);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[0],\n                    spatial_dims_num);\n  TF_LITE_ENSURE_EQ(context, op_context->paddings->dims->data[1], 2);\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input_size);\n  int output_batch_size = input_size->data[0];\n  for (int dim = 0; dim < spatial_dims_num; ++dim) {\n    int final_dim_size = (input_size->data[dim + 1] + paddings_data[dim * 2] +\n                          paddings_data[dim * 2 + 1]);\n    TF_LITE_ENSURE(context, block_shape[dim] != 0);\n    TF_LITE_ENSURE_EQ(context, final_dim_size % block_shape[dim], 0);\n    output_size->data[dim + 1] = final_dim_size / block_shape[dim];\n    output_batch_size *= block_shape[dim];\n  }\n  output_size->data[0] = output_batch_size;\n  output_size->data[input_size->size - 1] =\n      input_size->data[input_size->size - 1];\n  return context->ResizeTensor(context, op_context->output, output_size);\n}", "target": 0}
{"code": "void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}", "target": 1}
{"code": "Status InferenceContext::Multiply(DimensionHandle first,\n                                  DimensionOrConstant second,\n                                  DimensionHandle* out) {\n  const int64_t first_value = Value(first);\n  const int64_t second_value = Value(second);\n  if (first_value == 0) {\n    *out = first;\n  } else if (second_value == 0) {\n    *out = MakeDim(second);\n  } else if (first_value == 1) {\n    *out = MakeDim(second);\n  } else if (second_value == 1) {\n    *out = first;\n  } else if (first_value == kUnknownDim || second_value == kUnknownDim) {\n    *out = UnknownDim();\n  } else {\n    const int64_t product = first_value * second_value;\n    if (product < 0) {\n      return errors::InvalidArgument(\n          \"Negative dimension size caused by overflow when multiplying \",\n          first_value, \" and \", second_value);\n    }\n    *out = MakeDim(product);\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    output.setConstant(InitialValueF()());\n    if (data_size == 0) {\n      return;\n    }\n    const int64 N = segment_ids.dimension(0);\n    ReductionF reduction;\n    auto data_flat = typename TTypes<T, 2>::ConstTensor(data, N, data_size / N);\n    for (int64 i = 0; i < N; ++i) {\n      Index j = internal::SubtleMustCopy(segment_ids(i));\n      if (j < 0) {\n        continue;\n      }\n      OP_REQUIRES(ctx, FastBoundsCheck(j, num_segments),\n                  errors::InvalidArgument(\n                      \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                      \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n      reduction(data_flat.template chip<0>(i), output.template chip<0>(j));\n    }\n  }", "target": 1}
{"code": "static int handle_invept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 vmx_instruction_info, types;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand;\n\tif (!(vmx->nested.nested_vmx_secondary_ctls_high &\n\t      SECONDARY_EXEC_ENABLE_EPT) ||\n\t    !(vmx->nested.nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\ttypes = (vmx->nested.nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n\tif (!(types & (1UL << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn 1;\n\t}\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, false, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n\t\t\t\tsizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tswitch (type) {\n\tcase VMX_EPT_EXTENT_GLOBAL:\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tnested_vmx_succeed(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n            if (pos < 0 || pos > *decoded_size) {\n                debug_print(\"Position setting failed (%s)\\n\", decoded);\n                return MOBI_DATA_CORRUPT;\n            }\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "static void mark_commit(struct commit *c, void *data)\n{\n\tmark_object(&c->object, NULL, NULL, data);\n}", "target": 1}
{"code": "spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "static inline int mk_vhost_fdt_open(int id, unsigned int hash,\n                                    struct session_request *sr)\n{\n    int i;\n    int fd;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n    if (config->fdt == MK_FALSE) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        hc->readers++;\n        return hc->fd;\n    }\n    fd = open(sr->real_path.data, sr->file_info.flags_read_only);\n    if (fd == -1) {\n        return -1;\n    }\n    if (ht->av_slots <= 0) {\n        return fd;\n    }\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->fd == -1) {\n            hc->fd   = fd;\n            hc->hash = hash;\n            hc->readers++;\n            ht->av_slots--;\n            sr->vhost_fdt_id   = id;\n            sr->vhost_fdt_hash = hash;\n            sr->fd_is_fdt      = MK_TRUE;\n            return fd;\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "static void sctp_auto_asconf_init(struct sctp_sock *sp)\n{\n\tstruct net *net = sock_net(&sp->inet.sk);\n\tif (net->sctp.default_auto_asconf) {\n\t\tspin_lock(&net->sctp.addr_wq_lock);\n\t\tlist_add_tail(&sp->auto_asconf_list, &net->sctp.auto_asconf_splist);\n\t\tspin_unlock(&net->sctp.addr_wq_lock);\n\t\tsp->do_auto_asconf = 1;\n\t}\n}", "target": 1}
{"code": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n        ctx->cid = cid;\n    }\n    return 0;\n}", "target": 1}
{"code": "untrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n    switch (response_id)\n    {\n        case RESPONSE_RUN:\n        {\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n        }\n        break;\n        case RESPONSE_MARK_TRUSTED:\n        {\n            file = nautilus_file_get_location (parameters->file);\n            nautilus_file_mark_desktop_file_trusted (file,\n                                                     parameters->parent_window,\n                                                     TRUE,\n                                                     NULL, NULL);\n            g_object_unref (file);\n        }\n        break;\n        default:\n        {\n        }\n        break;\n    }\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n    activate_parameters_desktop_free (parameters);\n}", "target": 1}
{"code": "int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,\n                          const unsigned char *server,\n                          unsigned int server_len,\n                          const unsigned char *client, unsigned int client_len)\n{\n    unsigned int i, j;\n    const unsigned char *result;\n    int status = OPENSSL_NPN_UNSUPPORTED;\n    for (i = 0; i < server_len;) {\n        for (j = 0; j < client_len;) {\n            if (server[i] == client[j] &&\n                memcmp(&server[i + 1], &client[j + 1], server[i]) == 0) {\n                result = &server[i];\n                status = OPENSSL_NPN_NEGOTIATED;\n                goto found;\n            }\n            j += client[j];\n            j++;\n        }\n        i += server[i];\n        i++;\n    }\n    result = client;\n    status = OPENSSL_NPN_NO_OVERLAP;\n found:\n    *out = (unsigned char *)result + 1;\n    *outlen = result[0];\n    return status;\n}", "target": 1}
{"code": "  void Messageheader::Parser::checkHeaderspace(unsigned chars) const\n  {\n    if (headerdataPtr + chars >= header.rawdata + sizeof(header.rawdata))\n    {\n      header.rawdata[sizeof(header.rawdata) - 1] = '\\0';\n      throw HttpError(HTTP_REQUEST_ENTITY_TOO_LARGE, \"header too large\");\n    }\n  }", "target": 0}
{"code": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  end=strxmov(query,\"show table status from `\",db,\"`\",NullS);\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "AP4_StszAtom::AP4_StszAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_STSZ, size, version, flags)\n{\n    stream.ReadUI32(m_SampleSize);\n    stream.ReadUI32(m_SampleCount);\n    if (m_SampleSize == 0) { \n        if (m_SampleCount > (size-8)/4) {\n            m_SampleCount = 0;\n            return;\n        }\n        AP4_Cardinal sample_count = m_SampleCount;\n        m_Entries.SetItemCount(sample_count);\n        unsigned char* buffer = new unsigned char[sample_count*4];\n        AP4_Result result = stream.Read(buffer, sample_count*4);\n        if (AP4_FAILED(result)) {\n            delete[] buffer;\n            return;\n        }\n        for (unsigned int i=0; i<sample_count; i++) {\n            m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]);\n        }\n        delete[] buffer;\n    }\n}", "target": 0}
{"code": "TfLiteRegistration AddOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.custom_name = \"my_add\";\n  reg.builtin_code = tflite::BuiltinOperator_CUSTOM;\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* input1 = GetInput(context, node, 0);\n    const TfLiteTensor* input2 = GetInput(context, node, 1);\n    TfLiteTensor* output = GetOutput(context, node, 0);\n    TF_LITE_ENSURE_EQ(context, input1->dims->size, input2->dims->size);\n    for (int i = 0; i < input1->dims->size; ++i) {\n      TF_LITE_ENSURE_EQ(context, input1->dims->data[i], input2->dims->data[i]);\n    }\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n        context, output, TfLiteIntArrayCopy(input1->dims)));\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    TF_LITE_ENSURE(context, a0);\n    TF_LITE_ENSURE(context, a0->data.f);\n    const TfLiteTensor* a1 = GetInput(context, node, 1);\n    TF_LITE_ENSURE(context, a1);\n    TF_LITE_ENSURE(context, a1->data.f);\n    TfLiteTensor* out = GetOutput(context, node, 0);\n    TF_LITE_ENSURE(context, out);\n    TF_LITE_ENSURE(context, out->data.f);\n    int num = a0->dims->data[0];\n    for (int i = 0; i < num; i++) {\n      out->data.f[i] = a0->data.f[i] + a1->data.f[i];\n    }\n    return kTfLiteOk;\n  };\n  return reg;\n}", "target": 1}
{"code": "static int sd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdp = sdkp->device;\n\tvoid __user *p = (void __user *)arg;\n\tint error;\n\tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, \"sd_ioctl: disk=%s, \"\n\t\t\t\t    \"cmd=0x%x\\n\", disk->disk_name, cmd));\n\terror = scsi_verify_blk_ioctl(bdev, cmd);\n\tif (error < 0)\n\t\treturn error;\n\terror = scsi_nonblockable_ioctl(sdp, cmd, p,\n\t\t\t\t\t(mode & FMODE_NDELAY) != 0);\n\tif (!scsi_block_when_processing_errors(sdp) || !error)\n\t\tgoto out;\n\tswitch (cmd) {\n\t\tcase SCSI_IOCTL_GET_IDLUN:\n\t\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = scsi_cmd_blk_ioctl(bdev, mode, cmd, p);\n\t\t\tif (error != -ENOTTY)\n\t\t\t\tbreak;\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t}\nout:\n\treturn error;\n}", "target": 0}
{"code": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }\n    for (int i = 1; i < rpl->ref_pic_num; ++i) {\n        delta_poc_st = get_ue_golomb_long(gb);\n        if (delta_poc_st != 0)\n            strp_entry_sign_flag = get_bits(gb, 1);\n        rpl->ref_pics[i] = rpl->ref_pics[i - 1] + delta_poc_st * (1 - (strp_entry_sign_flag << 1));\n    }\n    return 0;\n}", "target": 1}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "bool ZlibInStream::decompress(bool wait)\n{\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  zs->next_out = (U8*)end;\n  zs->avail_out = start + bufSize - end;\n  int n = underlying->check(1, 1, wait);\n  if (n == 0) return false;\n  zs->next_in = (U8*)underlying->getptr();\n  zs->avail_in = underlying->getend() - underlying->getptr();\n  if ((int)zs->avail_in > bytesIn)\n    zs->avail_in = bytesIn;\n  int rc = inflate(zs, Z_SYNC_FLUSH);\n  if (rc != Z_OK) {\n    throw Exception(\"ZlibInStream: inflate failed\");\n  }\n  bytesIn -= zs->next_in - underlying->getptr();\n  end = zs->next_out;\n  underlying->setptr(zs->next_in);\n  return true;\n}", "target": 0}
{"code": "bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        if (h.first == \"Strict-Transport-Security\") {\n            header = h.second;\n            if (parseSTSHeader() && maxAgeFound) {\n                expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge);\n                return true;\n            }\n        }\n    }\n    subDomainsFound = false;\n    return false;\n}", "target": 1}
{"code": "Envoy::Ssl::ClientValidationStatus DefaultCertValidator::verifyCertificate(\n    X509* cert, const std::vector<std::string>& verify_san_list,\n    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n        subject_alt_name_matchers) {\n  Envoy::Ssl::ClientValidationStatus validated = Envoy::Ssl::ClientValidationStatus::NotValidated;\n  if (!verify_san_list.empty()) {\n    if (!verifySubjectAltName(cert, verify_san_list)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  if (!subject_alt_name_matchers.empty()) {\n    if (!matchSubjectAltName(cert, subject_alt_name_matchers)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  if (!verify_certificate_hash_list_.empty() || !verify_certificate_spki_list_.empty()) {\n    const bool valid_certificate_hash =\n        !verify_certificate_hash_list_.empty() &&\n        verifyCertificateHashList(cert, verify_certificate_hash_list_);\n    const bool valid_certificate_spki =\n        !verify_certificate_spki_list_.empty() &&\n        verifyCertificateSpkiList(cert, verify_certificate_spki_list_);\n    if (!valid_certificate_hash && !valid_certificate_spki) {\n      stats_.fail_verify_cert_hash_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  return validated;\n}", "target": 1}
{"code": "void TEMPLATE(process_block_dec)(decoder_info_t *decoder_info,int size,int yposY,int xposY,int sub)\n{\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  stream_t *stream = decoder_info->stream;\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int split_flag = 0;\n  if (yposY >= height || xposY >= width)\n    return;\n  int decode_this_size = (yposY + size <= height) && (xposY + size <= width);\n  int decode_rectangular_size = !decode_this_size && frame_type != I_FRAME;\n  int bit_start = stream->bitcnt;\n  int mode = MODE_SKIP;\n  block_context_t block_context;\n  TEMPLATE(find_block_contexts)(yposY, xposY, height, width, size, decoder_info->deblock_data, &block_context, decoder_info->use_block_contexts);\n  decoder_info->block_context = &block_context;\n  split_flag = decode_super_mode(decoder_info,size,decode_this_size);\n  mode = decoder_info->mode;\n  if (size == (1<<decoder_info->log2_sb_size) && (split_flag || mode != MODE_SKIP) && decoder_info->max_delta_qp > 0) {\n    int delta_qp = read_delta_qp(stream);\n    int prev_qp;\n    if (yposY == 0 && xposY == 0)\n      prev_qp = decoder_info->frame_info.qp;\n    else\n      prev_qp = decoder_info->frame_info.qpb;\n    decoder_info->frame_info.qpb = prev_qp + delta_qp;\n  }\n  decoder_info->bit_count.super_mode[decoder_info->bit_count.stat_frame_type] += (stream->bitcnt - bit_start);\n  if (split_flag){\n    int new_size = size/2;\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+1*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+1*new_size,sub);\n  }\n  else if (decode_this_size || decode_rectangular_size){\n    decode_block(decoder_info,size,yposY,xposY,sub);\n  }\n}", "target": 1}
{"code": "pci_lintr_release(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tsi->si_intpins[pin].ii_count = 0;\n\t\tsi->si_intpins[pin].ii_pirq_pin = 0;\n\t\tsi->si_intpins[pin].ii_ioapic_irq = 0;\n\t}\n}", "target": 1}
{"code": "  UsageAndQuotaDispatcherTask(\n      QuotaManager* manager,\n      const std::string& host,\n      StorageType type)\n      : QuotaTask(manager),\n        host_(host),\n        type_(type),\n        quota_(-1),\n        global_usage_(-1),\n        global_unlimited_usage_(-1),\n        host_usage_(-1),\n        quota_status_(kQuotaStatusUnknown),\n        waiting_callbacks_(1),\n        callback_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {}", "target": 0}
{"code": "ServerApp::openClientListener(const NetworkAddress& address)\n{\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (args().m_enableCrypto) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n        if (args().check_client_certificates) {\n            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n        }\n    }\n    ClientListener* listen = new ClientListener(\n        address,\n        new TCPSocketFactory(m_events, getSocketMultiplexer()),\n        m_events, security_level);\n    m_events->adoptHandler(\n        m_events->forClientListener().connected(), listen,\n        new TMethodEventJob<ServerApp>(\n            this, &ServerApp::handleClientConnected, listen));\n    return listen;\n}", "target": 0}
{"code": "GSList* menu_cache_list_all_apps(MenuCache* cache)\n{\n    GSList* list;\n    MENU_CACHE_LOCK;\n    if (G_UNLIKELY(!cache->root_dir)) \n        list = NULL;\n    else\n        list = list_app_in_dir(cache->root_dir, NULL);\n    MENU_CACHE_UNLOCK;\n    return list;\n}", "target": 0}
{"code": "GF_Err urn_Read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 i, to_read;\n\tchar *tmpName;\n\tGF_DataEntryURNBox *ptr = (GF_DataEntryURNBox *)s;\n\tif (! ptr->size ) return GF_OK;\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\tgf_bs_read_data(bs, tmpName, to_read);\n\ti = 0;\n\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n\t\ti++;\n\t}\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;\n\t\tptr->location = NULL;\n\t\treturn GF_OK;\n\t}\n\tptr->nameURN = (char*)gf_malloc(sizeof(char) * (i+1));\n\tif (!ptr->nameURN) {\n\t\tgf_free(tmpName);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tptr->location = (char*)gf_malloc(sizeof(char) * (to_read - i - 1));\n\tif (!ptr->location) {\n\t\tgf_free(tmpName);\n\t\tgf_free(ptr->nameURN);\n\t\tptr->nameURN = NULL;\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tmemcpy(ptr->nameURN, tmpName, i + 1);\n\tmemcpy(ptr->location, tmpName + i + 1, (to_read - i - 1));\n\tgf_free(tmpName);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static int x25_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tstruct sock *sk;\n\tstruct x25_sock *x25;\n\tint rc = -EAFNOSUPPORT;\n\tif (!net_eq(net, &init_net))\n\t\tgoto out;\n\trc = -ESOCKTNOSUPPORT;\n\tif (sock->type != SOCK_SEQPACKET)\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (protocol)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tif ((sk = x25_alloc_socket(net, kern)) == NULL)\n\t\tgoto out;\n\tx25 = x25_sk(sk);\n\tsock_init_data(sock, sk);\n\tx25_init_timers(sk);\n\tsock->ops    = &x25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tsk->sk_backlog_rcv = x25_backlog_rcv;\n\tx25->t21   = sysctl_x25_call_request_timeout;\n\tx25->t22   = sysctl_x25_reset_request_timeout;\n\tx25->t23   = sysctl_x25_clear_request_timeout;\n\tx25->t2    = sysctl_x25_ack_holdback_timeout;\n\tx25->state = X25_STATE_0;\n\tx25->cudmatchlength = 0;\n\tset_bit(X25_ACCPT_APPRV_FLAG, &x25->flags);\t\n\tx25->facilities.winsize_in  = X25_DEFAULT_WINDOW_SIZE;\n\tx25->facilities.winsize_out = X25_DEFAULT_WINDOW_SIZE;\n\tx25->facilities.pacsize_in  = X25_DEFAULT_PACKET_SIZE;\n\tx25->facilities.pacsize_out = X25_DEFAULT_PACKET_SIZE;\n\tx25->facilities.throughput  = 0;\t\n\tx25->facilities.reverse     = X25_DEFAULT_REVERSE;\n\tx25->dte_facilities.calling_len = 0;\n\tx25->dte_facilities.called_len = 0;\n\tmemset(x25->dte_facilities.called_ae, '\\0',\n\t\t\tsizeof(x25->dte_facilities.called_ae));\n\tmemset(x25->dte_facilities.calling_ae, '\\0',\n\t\t\tsizeof(x25->dte_facilities.calling_ae));\n\trc = 0;\nout:\n\treturn rc;\n}", "target": 0}
{"code": "is_link_trusted (NautilusFile *file,\n                 gboolean      is_launcher)\n{\n    GFile *location;\n    gboolean res;\n    if (!is_launcher)\n    {\n        return TRUE;\n    }\n    if (nautilus_file_can_execute (file))\n    {\n        return TRUE;\n    }\n    res = FALSE;\n    if (nautilus_file_is_local (file))\n    {\n        location = nautilus_file_get_location (file);\n        res = nautilus_is_in_system_dir (location);\n        g_object_unref (location);\n    }\n    return res;\n}", "target": 1}
{"code": "static int mxf_read_primer_pack(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)\n{\n    MXFContext *mxf = arg;\n    int item_num = avio_rb32(pb);\n    int item_len = avio_rb32(pb);\n    if (item_len != 18) {\n        avpriv_request_sample(pb, \"Primer pack item length %d\", item_len);\n        return AVERROR_PATCHWELCOME;\n    }\n    if (item_num > 65536) {\n        av_log(mxf->fc, AV_LOG_ERROR, \"item_num %d is too large\\n\", item_num);\n        return AVERROR_INVALIDDATA;\n    }\n    if (mxf->local_tags)\n        av_log(mxf->fc, AV_LOG_VERBOSE, \"Multiple primer packs\\n\");\n    av_free(mxf->local_tags);\n    mxf->local_tags_count = 0;\n    mxf->local_tags = av_calloc(item_num, item_len);\n    if (!mxf->local_tags)\n        return AVERROR(ENOMEM);\n    mxf->local_tags_count = item_num;\n    avio_read(pb, mxf->local_tags, item_num*item_len);\n    return 0;\n}", "target": 1}
{"code": "TIFFNumberOfStrips(TIFF* tif)\n{\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 nstrips;\n    if( td->td_nstrips )\n        return td->td_nstrips;\n\tnstrips = (td->td_rowsperstrip == (uint32) -1 ? 1 :\n\t     TIFFhowmany_32(td->td_imagelength, td->td_rowsperstrip));\n\tif (td->td_planarconfig == PLANARCONFIG_SEPARATE)\n\t\tnstrips = _TIFFMultiply32(tif, nstrips, (uint32)td->td_samplesperpixel,\n\t\t    \"TIFFNumberOfStrips\");\n\treturn (nstrips);\n}", "target": 1}
{"code": "snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = SNMP_DATA_TYPE_TIME_TICKS;\n  varbind->value.integer = integer;\n}", "target": 1}
{"code": "BZIP3_API struct bz3_state * bz3_new(s32 block_size) {\n    if (block_size < KiB(65) || block_size > MiB(511)) {\n        return NULL;\n    }\n    struct bz3_state * bz3_state = malloc(sizeof(struct bz3_state));\n    if (!bz3_state) {\n        return NULL;\n    }\n    bz3_state->cm_state = malloc(sizeof(state));\n    bz3_state->swap_buffer = malloc(bz3_bound(block_size));\n    bz3_state->sais_array = malloc((block_size + 128) * sizeof(s32));\n    memset(bz3_state->sais_array, 0, sizeof(s32) * (block_size + 128));\n    bz3_state->lzp_lut = calloc(1 << LZP_DICTIONARY, sizeof(s32));\n    if (!bz3_state->cm_state || !bz3_state->swap_buffer || !bz3_state->sais_array || !bz3_state->lzp_lut) {\n        if (bz3_state->cm_state) free(bz3_state->cm_state);\n        if (bz3_state->swap_buffer) free(bz3_state->swap_buffer);\n        if (bz3_state->sais_array) free(bz3_state->sais_array);\n        if (bz3_state->lzp_lut) free(bz3_state->lzp_lut);\n        free(bz3_state);\n        return NULL;\n    }\n    bz3_state->block_size = block_size;\n    bz3_state->last_error = BZ3_OK;\n    return bz3_state;\n}", "target": 1}
{"code": "R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fread (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}", "target": 1}
{"code": "int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num)\n{\n\tif (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_IPV6HINT;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = addr_num * DNS_RR_AAAA_LEN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tfor (int i = 0; i < addr_num; i++) {\n\t\tdns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n    if (t -> Data) return;    \n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n    }\n}", "target": 1}
{"code": "static long adpt_unlocked_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tstruct inode *inode;\n\tlong ret;\n\tinode = file_inode(file);\n\tmutex_lock(&adpt_mutex);\n\tret = adpt_ioctl(inode, file, cmd, arg);\n\tmutex_unlock(&adpt_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}", "target": 1}
{"code": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\tif (!MSR_TM_SUSPENDED(mfmsr()))\n\t\treturn;\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\tthr->regs->msr |= msr_diff;\n}", "target": 0}
{"code": "ldns_str2rdf_tag(ldns_rdf **rd, const char *str)\n{\n\tuint8_t *data;\n\tconst char* ptr;\n\tif (strlen(str) > 255) {\n\t\treturn LDNS_STATUS_INVALID_TAG;\n\t}\n\tfor (ptr = str; *ptr; ptr++) {\n\t\tif (! isalnum((unsigned char)*ptr)) {\n\t\t\treturn LDNS_STATUS_INVALID_TAG;\n\t\t}\n\t}\n\tdata = LDNS_XMALLOC(uint8_t, strlen(str) + 1);\n        if (!data) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\tdata[0] = strlen(str);\n\tmemcpy(data + 1, str, strlen(str));\n\t*rd = ldns_rdf_new(LDNS_RDF_TYPE_TAG, strlen(str) + 1, data);\n\tif (!*rd) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}", "target": 0}
{"code": "BuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http:\n\t\t\"s:encodingStyle=\\\"http:\n\t\t\"<s:Body>\";\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\tSendRespAndClose_upnphttp(h);\n}", "target": 0}
{"code": "ossl_cipher_initialize(VALUE self, VALUE str)\n{\n    EVP_CIPHER_CTX *ctx;\n    const EVP_CIPHER *cipher;\n    char *name;\n    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };\n    name = StringValueCStr(str);\n    GetCipherInit(self, ctx);\n    if (ctx) {\n\tossl_raise(rb_eRuntimeError, \"Cipher already inititalized!\");\n    }\n    AllocCipher(self, ctx);\n    if (!(cipher = EVP_get_cipherbyname(name))) {\n\tossl_raise(rb_eRuntimeError, \"unsupported cipher algorithm (%\"PRIsVALUE\")\", str);\n    }\n    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    return self;\n}", "target": 1}
{"code": "static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t  struct msghdr *m, size_t total_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\terror = -EIO;\n\t\tgoto end;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &error);\n\tif (error < 0)\n\t\tgoto end;\n\tm->msg_namelen = 0;\n\tif (skb) {\n\t\ttotal_len = min_t(size_t, total_len, skb->len);\n\t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\n\t\tif (error == 0) {\n\t\t\tconsume_skb(skb);\n\t\t\treturn total_len;\n\t\t}\n\t}\n\tkfree_skb(skb);\nend:\n\treturn error;\n}", "target": 1}
{"code": "int ossl_dsa_check_priv_key(const DSA *dsa, const BIGNUM *priv_key, int *ret)\n{\n    *ret = 0;\n    return (dsa->params.q != NULL\n            && ossl_ffc_validate_private_key(dsa->params.q, priv_key, ret));\n}", "target": 1}
{"code": "void lsetCommand(client *c) {\n    robj *o = lookupKeyWriteOrReply(c,c->argv[1],shared.nokeyerr);\n    if (o == NULL || checkType(c,o,OBJ_LIST)) return;\n    long index;\n    robj *value = c->argv[3];\n    if (sdslen(value->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((getLongFromObjectOrReply(c, c->argv[2], &index, NULL) != C_OK))\n        return;\n    if (o->encoding == OBJ_ENCODING_QUICKLIST) {\n        quicklist *ql = o->ptr;\n        int replaced = quicklistReplaceAtIndex(ql, index,\n                                               value->ptr, sdslen(value->ptr));\n        if (!replaced) {\n            addReply(c,shared.outofrangeerr);\n        } else {\n            addReply(c,shared.ok);\n            signalModifiedKey(c,c->db,c->argv[1]);\n            notifyKeyspaceEvent(NOTIFY_LIST,\"lset\",c->argv[1],c->db->id);\n            server.dirty++;\n        }\n    } else {\n        serverPanic(\"Unknown list encoding\");\n    }\n}", "target": 0}
{"code": "static void evdev_queue_syn_dropped(struct evdev_client *client)\n{\n\tunsigned long flags;\n\tstruct input_event ev;\n\tktime_t time;\n\ttime = ktime_get();\n\tif (client->clkid != CLOCK_MONOTONIC)\n\t\ttime = ktime_sub(time, ktime_get_monotonic_offset());\n\tev.time = ktime_to_timeval(time);\n\tev.type = EV_SYN;\n\tev.code = SYN_DROPPED;\n\tev.value = 0;\n\tspin_lock_irqsave(&client->buffer_lock, flags);\n\tclient->buffer[client->head++] = ev;\n\tclient->head &= client->bufsize - 1;\n\tif (unlikely(client->head == client->tail)) {\n\t\tclient->tail = (client->head - 1) & (client->bufsize - 1);\n\t\tclient->packet_head = client->tail;\n\t}\n\tspin_unlock_irqrestore(&client->buffer_lock, flags);\n}", "target": 0}
{"code": "void CScreenshotPortal::onScreenshot(sdbus::MethodCall& call) {\n    sdbus::ObjectPath requestHandle;\n    call >> requestHandle;\n    std::string appID;\n    call >> appID;\n    std::string parentWindow;\n    call >> parentWindow;\n    std::unordered_map<std::string, sdbus::Variant> options;\n    call >> options;\n    Debug::log(LOG, \"[screenshot] New screenshot request:\");\n    Debug::log(LOG, \"[screenshot]  | {}\", requestHandle.c_str());\n    Debug::log(LOG, \"[screenshot]  | appid: {}\", appID);\n    bool isInteractive = options.count(\"interactive\") && options[\"interactive\"].get<bool>() && inShellPath(\"slurp\");\n    const std::string HYPR_DIR             = \"/tmp/hypr/\";\n    const std::string SNAP_FILE            = \"xdph_screenshot.png\";\n    const std::string FILE_PATH            = HYPR_DIR + SNAP_FILE;\n    const std::string SNAP_CMD             = \"grim \" + FILE_PATH;\n    const std::string SNAP_INTERACTIVE_CMD = \"grim -g \\\"$(slurp)\\\" \" + FILE_PATH;\n    std::unordered_map<std::string, sdbus::Variant> results;\n    results[\"uri\"] = \"file:\n    std::filesystem::remove(FILE_PATH);\n    std::filesystem::create_directory(HYPR_DIR);\n    if (isInteractive)\n        execAndGet(SNAP_INTERACTIVE_CMD.c_str());\n    else\n        execAndGet(SNAP_CMD.c_str());\n    uint32_t responseCode = std::filesystem::exists(FILE_PATH) ? 0 : 1;\n    auto reply = call.createReply();\n    reply << responseCode;\n    reply << results;\n    reply.send();\n}", "target": 1}
{"code": "void conn_close_all(void) {\n    int i;\n    for (i = 0; i < max_fds; i++) {\n        if (conns[i] && conns[i]->state != conn_closed) {\n            conn_close(conns[i]);\n        }\n    }\n}", "target": 0}
{"code": "static int http1_on_error(http1_parser_s *parser) {\n  FIO_LOG_DEBUG(\"HTTP parser error at HTTP/1.1 buffer position %zu/%zu\",\n                parser->state.next - parser2http(parser)->buf,\n                parser2http(parser)->buf_len);\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}", "target": 1}
{"code": "int jas_stream_read(jas_stream_t *stream, void *buf, int cnt)\n{\n\tint n;\n\tint c;\n\tchar *bufptr;\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_read\");\n\t}\n\tbufptr = buf;\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif ((c = jas_stream_getc(stream)) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t++n;\n\t}\n\treturn n;\n}", "target": 0}
{"code": "njs_array_expand(njs_vm_t *vm, njs_array_t *array, uint32_t prepend,\n    uint32_t append)\n{\n    uint32_t     free_before, free_after;\n    uint64_t     size;\n    njs_value_t  *start, *old;\n    njs_assert(array->object.fast_array);\n    free_before = array->start - array->data;\n    free_after = array->size - array->length - free_before;\n    if (njs_fast_path(free_before >= prepend && free_after >= append)) {\n        return NJS_OK;\n    }\n    size = (uint64_t) prepend + array->length + append;\n    if (size < 16) {\n        size *= 2;\n    } else {\n        size += size / 2;\n    }\n    if (njs_slow_path(size > (UINT32_MAX / sizeof(njs_value_t)))) {\n        goto memory_error;\n    }\n    start = njs_mp_align(vm->mem_pool, sizeof(njs_value_t),\n                         size * sizeof(njs_value_t));\n    if (njs_slow_path(start == NULL)) {\n        goto memory_error;\n    }\n    array->size = size;\n    old = array->data;\n    array->data = start;\n    start += prepend;\n    if (array->length != 0) {\n        memcpy(start, array->start, array->length * sizeof(njs_value_t));\n    }\n    array->start = start;\n    njs_mp_free(vm->mem_pool, old);\n    return NJS_OK;\nmemory_error:\n    njs_memory_error(vm);\n    return NJS_ERROR;\n}", "target": 0}
{"code": "pktap_if_print(netdissect_options *ndo,\n               const struct pcap_pkthdr *h, const u_char *p)\n{\n\tuint32_t dlt, hdrlen, rectype;\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tif_printer printer;\n\tconst pktap_header_t *hdr;\n\tif (caplen < sizeof(pktap_header_t) || length < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\thdr = (const pktap_header_t *)p;\n\tdlt = EXTRACT_LE_32BITS(&hdr->pkt_dlt);\n\thdrlen = EXTRACT_LE_32BITS(&hdr->pkt_len);\n\tif (hdrlen < sizeof(pktap_header_t)) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (0);\n\t}\n\tif (caplen < hdrlen || length < hdrlen) {\n\t\tND_PRINT((ndo, \"[|pktap]\"));\n\t\treturn (hdrlen);\n\t}\n\tif (ndo->ndo_eflag)\n\t\tpktap_header_print(ndo, p, length);\n\tlength -= hdrlen;\n\tcaplen -= hdrlen;\n\tp += hdrlen;\n\trectype = EXTRACT_LE_32BITS(&hdr->pkt_rectype);\n\tswitch (rectype) {\n\tcase PKT_REC_NONE:\n\t\tND_PRINT((ndo, \"no data\"));\n\t\tbreak;\n\tcase PKT_REC_PACKET:\n\t\tif ((printer = lookup_printer(dlt)) != NULL) {\n\t\t\thdrlen += printer(ndo, h, p);\n\t\t} else {\n\t\t\tif (!ndo->ndo_eflag)\n\t\t\t\tpktap_header_print(ndo, (const u_char *)hdr,\n\t\t\t\t\t\tlength + hdrlen);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p, caplen);\n\t\t}\n\t\tbreak;\n\t}\n\treturn (hdrlen);\n}", "target": 1}
{"code": "uint16_t nvme_bounce_data(NvmeCtrl *n, uint8_t *ptr, uint32_t len,\n                          NvmeTxDirection dir, NvmeRequest *req)\n{\n    NvmeNamespace *ns = req->ns;\n    NvmeRwCmd *rw = (NvmeRwCmd *)&req->cmd;\n    bool pi = !!NVME_ID_NS_DPS_TYPE(ns->id_ns.dps);\n    bool pract = !!(le16_to_cpu(rw->control) & NVME_RW_PRINFO_PRACT);\n    if (nvme_ns_ext(ns) && !(pi && pract && ns->lbaf.ms == 8)) {\n        return nvme_tx_interleaved(n, &req->sg, ptr, len, ns->lbasz,\n                                   ns->lbaf.ms, 0, dir);\n    }\n    return nvme_tx(n, &req->sg, ptr, len, dir);\n}", "target": 0}
{"code": "static zend_always_inline zend_string* __zval_get_string_func(zval *op, zend_bool try) \n{\ntry_again:\n\tswitch (Z_TYPE_P(op)) {\n\t\tcase IS_UNDEF:\n\t\tcase IS_NULL:\n\t\tcase IS_FALSE:\n\t\t\treturn ZSTR_EMPTY_ALLOC();\n\t\tcase IS_TRUE:\n\t\t\treturn ZSTR_CHAR('1');\n\t\tcase IS_RESOURCE: {\n\t\t\treturn zend_strpprintf(0, \"Resource id #\" ZEND_LONG_FMT, (zend_long)Z_RES_HANDLE_P(op));\n\t\t}\n\t\tcase IS_LONG: {\n\t\t\treturn zend_long_to_str(Z_LVAL_P(op));\n\t\t}\n\t\tcase IS_DOUBLE: {\n\t\t\treturn zend_strpprintf(0, \"%.*G\", (int) EG(precision), Z_DVAL_P(op));\n\t\t}\n\t\tcase IS_ARRAY:\n\t\t\tzend_error(E_NOTICE, \"Array to string conversion\");\n\t\t\treturn (try && UNEXPECTED(EG(exception))) ?\n\t\t\t\tNULL : ZSTR_KNOWN(ZEND_STR_ARRAY_CAPITALIZED);\n\t\tcase IS_OBJECT: {\n\t\t\tzval tmp;\n\t\t\tif (Z_OBJ_HT_P(op)->cast_object) {\n\t\t\t\tif (Z_OBJ_HT_P(op)->cast_object(op, &tmp, IS_STRING) == SUCCESS) {\n\t\t\t\t\treturn Z_STR(tmp);\n\t\t\t\t}\n\t\t\t} else if (Z_OBJ_HT_P(op)->get) {\n\t\t\t\tzval *z = Z_OBJ_HT_P(op)->get(op, &tmp);\n\t\t\t\tif (Z_TYPE_P(z) != IS_OBJECT) {\n\t\t\t\t\tzend_string *str = try ? zval_try_get_string(z) : zval_get_string(z);\n\t\t\t\t\tzval_ptr_dtor(z);\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(z);\n\t\t\t}\n\t\t\tif (!EG(exception)) {\n\t\t\t\tzend_throw_error(NULL, \"Object of class %s could not be converted to string\", ZSTR_VAL(Z_OBJCE_P(op)->name));\n\t\t\t}\n\t\t\treturn try ? NULL : ZSTR_EMPTY_ALLOC();\n\t\t}\n\t\tcase IS_REFERENCE:\n\t\t\top = Z_REFVAL_P(op);\n\t\t\tgoto try_again;\n\t\tcase IS_STRING:\n\t\t\treturn zend_string_copy(Z_STR_P(op));\n\t\tEMPTY_SWITCH_DEFAULT_CASE()\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (acpi_debugfs_dir == NULL)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (cm_dentry == NULL)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 0}
{"code": "void gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct)\n{\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\ttoy = dstY;\n\tfor (y = srcY; y < (srcY + h); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; x < (srcX + w); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel(src, x, y);\n\t\t\tif (gdImageGetTransparent(src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel(dst, tox, toy);\n \t\t\t\tncR = (int)(gdImageRed (src, c) * (pct / 100.0) + gdImageRed (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncG = (int)(gdImageGreen (src, c) * (pct / 100.0) + gdImageGreen (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncB = (int)(gdImageBlue (src, c) * (pct / 100.0) + gdImageBlue (dst, dc) * ((100 - pct) / 100.0));\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}", "target": 1}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg{};\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 0}
{"code": "static void dns_handler(int dns_err, const struct sa *srv, void *arg)\n{\n\tstruct lookup_entry *lent = arg;\n\tstruct sa turn_srv;\n\tre_printf(\"DNS lookup for: %s err=%d\\n\", lent->host, dns_err);\n\tif (dns_err)\n\t\tgoto out;\n\tsa_cpy(&turn_srv, srv);\n\tsa_set_port(&turn_srv, lent->port);\n\tre_printf(\"DNS lookup success: %s -> %J(proto=%s secure=%d)\\n\",\n\t\t  lent->host, &turn_srv, net_proto2name(lent->proto),\n\t\t  lent->secure);\n\tstart_netprobe(&turn_srv, lent->proto, lent->secure,\n\t\t       lent->turn.username, lent->turn.credential);\n out:\n\tmem_deref(lent);\n}", "target": 0}
{"code": "void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}", "target": 1}
{"code": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}", "target": 0}
{"code": "void TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n    for (c = 0; c < 3; c++)\n      pix[c] += prevRow[c];\n    memcpy(thisRow, pix, sizeof(pix));\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "create_durable_v2_buf(struct cifs_open_parms *oparms)\n{\n\tstruct cifs_fid *pfid = oparms->fid;\n\tstruct create_durable_v2 *buf;\n\tbuf = kzalloc(sizeof(struct create_durable_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable_v2, dcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct durable_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->dcontext.Timeout = cpu_to_le32(oparms->tcon->handle_timeout);\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tgenerate_random_uuid(buf->dcontext.CreateGuid);\n\tmemcpy(pfid->create_guid, buf->dcontext.CreateGuid, 16);\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}", "target": 0}
{"code": "inline bool operator ==(const MaskedIP& l, const MaskedIP& r) {\n  auto shift = std::max((l.v6 ? 128 : 32) - l.prefix,\n\t\t\t(r.v6 ? 128 : 32) - r.prefix);\n  ceph_assert(shift > 0);\n  return (l.addr >> shift) == (r.addr >> shift);\n}", "target": 1}
{"code": "ServerSecurityFeature::ServerSecurityFeature(\n    application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)\n{\n\tGC_REFCOUNT(ht) = 1;\n\tGC_TYPE_INFO(ht) = IS_ARRAY;\n\tht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;\n\tht->nTableSize = zend_hash_check_size(nSize);\n\tht->nTableMask = HT_MIN_MASK;\n\tHT_SET_DATA_ADDR(ht, &uninitialized_bucket);\n\tht->nNumUsed = 0;\n\tht->nNumOfElements = 0;\n\tht->nInternalPointer = HT_INVALID_IDX;\n\tht->nNextFreeElement = 0;\n\tht->pDestructor = pDestructor;\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             const TfLiteConvParams* params, int width,\n                             int height, int filter_width, int filter_height,\n                             int out_width, int out_height,\n                             const TfLiteType data_type, OpData* data) {\n  bool has_bias = node->inputs->size == 3;\n  TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  auto padding = params->padding;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width,\n      params->dilation_height_factor, params->dilation_width_factor, height,\n      width, filter_height, filter_width, padding, &out_height, &out_width);\n  if (data_type != kTfLiteFloat32) {\n    const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n    TF_LITE_ENSURE(context, input != nullptr);\n    const TfLiteTensor* filter = GetInput(context, node, kFilterTensor);\n    TF_LITE_ENSURE(context, filter != nullptr);\n    const TfLiteTensor* bias =\n        GetOptionalInputTensor(context, node, kBiasTensor);\n    TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n    TF_LITE_ENSURE(context, output != nullptr);\n    int output_channels = filter->dims->data[kConvQuantizedDimension];\n    TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(\n        context, input, filter, bias, output, params->activation,\n        &data->output_multiplier, &data->output_shift,\n        &data->output_activation_min, &data->output_activation_max,\n        data->per_channel_output_multiplier,\n        reinterpret_cast<int*>(data->per_channel_output_shift),\n        output_channels));\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static CallResult<HermesValue> getCodeBlockFileName(\n    Runtime &runtime,\n    const CodeBlock *codeBlock,\n    OptValue<hbc::DebugSourceLocation> location) {\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  if (location) {\n    auto debugInfo = runtimeModule->getBytecode()->getDebugInfo();\n    return StringPrimitive::createEfficient(\n        runtime, debugInfo->getFilenameByID(location->filenameId));\n  } else {\n    llvh::StringRef sourceURL = runtimeModule->getSourceURL();\n    if (!sourceURL.empty()) {\n      return StringPrimitive::createEfficient(runtime, sourceURL);\n    }\n  }\n  return HermesValue::encodeUndefinedValue();\n}", "target": 1}
{"code": "Status GetTensorArray(OpKernelContext* ctx, TensorArray** tensor_array) {\n  string container;\n  string ta_handle;\n  if (ctx->input_dtype(0) != DT_RESOURCE) {\n    TF_RETURN_IF_ERROR(GetHandle(ctx, &container, &ta_handle));\n    ResourceMgr* rm = ctx->resource_manager();\n    if (rm == nullptr) return errors::Internal(\"No resource manager.\");\n    TF_RETURN_IF_ERROR(\n        ctx->step_container()->Lookup(rm, container + ta_handle, tensor_array));\n    return OkStatus();\n  } else {\n    return LookupResource(ctx, HandleFromInput(ctx, 0), tensor_array);\n  }\n}", "target": 1}
{"code": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  \n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}", "target": 1}
{"code": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n\tif (nlmsg_len(nlh) < sizeof(*req))\n\t\treturn -EINVAL;\n\tif (req->sdiag_family >= AF_MAX)\n\t\treturn -EINVAL;\n\thndl = sock_diag_lock_handler(req->sdiag_family);\n\tif (hndl == NULL)\n\t\terr = -ENOENT;\n\telse\n\t\terr = hndl->dump(skb, nlh);\n\tsock_diag_unlock_handler(hndl);\n\treturn err;\n}", "target": 0}
{"code": "void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}", "target": 1}
{"code": "ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)\n{\n\tint totlen;\n\tuint32_t t;\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tt = p[2];\n\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}", "target": 1}
{"code": "sf_flac_write_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tpflac->frame = frame ;\n\tpflac->bufferpos = 0 ;\n\tpflac->bufferbackup = SF_FALSE ;\n\tpflac->wbuffer = buffer ;\n\tflac_buffer_copy (psf) ;\n\treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ;\n} ", "target": 1}
{"code": "std::unique_ptr<BytecodeModule> hbc::generateBytecode(\n    Module *M,\n    raw_ostream &OS,\n    const BytecodeGenerationOptions &options,\n    const SHA1 &sourceHash,\n    hermes::OptValue<uint32_t> segment,\n    SourceMapGenerator *sourceMapGen,\n    std::unique_ptr<BCProviderBase> baseBCProvider) {\n  auto BM = generateBytecodeModule(\n      M,\n      M->getTopLevelFunction(),\n      options,\n      segment,\n      sourceMapGen,\n      std::move(baseBCProvider));\n  if (!BM) {\n    return {};\n  }\n  if (options.format == OutputFormatKind::EmitBundle) {\n    assert(BM != nullptr);\n    BytecodeSerializer BS{OS, options};\n    BS.serialize(*BM, sourceHash);\n  }\n  if (sourceMapGen)\n    BM->populateSourceMap(sourceMapGen);\n  return BM;\n}", "target": 0}
{"code": "static char *http_get_w32(const char *url, int *code, int *rlen) {\n\tHINTERNET hInternet = InternetOpenA (\"radare2 \"R2_VERSION, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);\n\tif (!hInternet) {\n\t\tr_sys_perror (\"InternetOpenA\");\n\t\treturn NULL;\n\t}\n\tHINTERNET hOpenUrl = InternetOpenUrlA (hInternet, url, NULL, 0, 0, 0);\n\tif (!hOpenUrl) {\n\t\tr_sys_perror (\"InternetOpenUrlA\");\n\t\tInternetCloseHandle (hInternet);\n\t\treturn NULL;\n\t}\n\tchar *ret = NULL;\n\tsize_t read_sz = 0x100000;\n\tDWORD r = 0, w = 0;\n\tbool res = true;\n\tdo {\n\t\tw += r;\n\t\tif (!res && GetLastError () == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\tread_sz *= 2;\n\t\t}\n\t\tchar *tmp = realloc (ret, read_sz + w);\n\t\tif (!tmp) {\n\t\t\tR_FREE (ret);\n\t\t\tgoto exit;\n\t\t}\n\t\tret = tmp;\n\t} while (!(res = InternetReadFile (hOpenUrl, ret + w, read_sz, &r)) || r);\n\tif (w) {\n\t\tchar *tmp = realloc (ret, (size_t)w + 1);\n\t\tif (tmp) {\n\t\t\tret = tmp;\n\t\t\tret[w] = 0;\n\t\t} else {\n\t\t\tR_FREE (ret);\n\t\t}\n\t} else {\n\t\tR_FREE (ret);\n\t}\nexit:\n\tif (rlen) {\n\t\t*rlen = w;\n\t}\n\tif (code && w) {\n\t\t*code = 200;\n\t}\n\tInternetCloseHandle (hInternet);\n\tInternetCloseHandle (hOpenUrl);\n\treturn ret;\n}", "target": 0}
{"code": "static void put_prev_task(struct rq *rq, struct task_struct *prev)\n{\n\tif (prev->se.on_rq)\n\t\tupdate_rq_clock(rq);\n\trq->skip_clock_update = 0;\n\tprev->sched_class->put_prev_task(rq, prev);\n}", "target": 1}
{"code": "static struct sk_buff *tcp_sacktag_walk(struct sk_buff *skb, struct sock *sk,\n\t\t\t\t\tstruct tcp_sack_block *next_dup,\n\t\t\t\t\tstruct tcp_sacktag_state *state,\n\t\t\t\t\tu32 start_seq, u32 end_seq,\n\t\t\t\t\tint dup_sack_in)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *tmp;\n\ttcp_for_write_queue_from(skb, sk) {\n\t\tint in_sack = 0;\n\t\tint dup_sack = dup_sack_in;\n\t\tif (skb == tcp_send_head(sk))\n\t\t\tbreak;\n\t\tif (!before(TCP_SKB_CB(skb)->seq, end_seq))\n\t\t\tbreak;\n\t\tif ((next_dup != NULL) &&\n\t\t    before(TCP_SKB_CB(skb)->seq, next_dup->end_seq)) {\n\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\tnext_dup->start_seq,\n\t\t\t\t\t\t\tnext_dup->end_seq);\n\t\t\tif (in_sack > 0)\n\t\t\t\tdup_sack = 1;\n\t\t}\n\t\tif (in_sack <= 0) {\n\t\t\ttmp = tcp_shift_skb_data(sk, skb, state,\n\t\t\t\t\t\t start_seq, end_seq, dup_sack);\n\t\t\tif (tmp != NULL) {\n\t\t\t\tif (tmp != skb) {\n\t\t\t\t\tskb = tmp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tin_sack = 0;\n\t\t\t} else {\n\t\t\t\tin_sack = tcp_match_skb_to_sack(sk, skb,\n\t\t\t\t\t\t\t\tstart_seq,\n\t\t\t\t\t\t\t\tend_seq);\n\t\t\t}\n\t\t}\n\t\tif (unlikely(in_sack < 0))\n\t\t\tbreak;\n\t\tif (in_sack) {\n\t\t\tTCP_SKB_CB(skb)->sacked = tcp_sacktag_one(skb, sk,\n\t\t\t\t\t\t\t\t  state,\n\t\t\t\t\t\t\t\t  dup_sack,\n\t\t\t\t\t\t\t\t  tcp_skb_pcount(skb));\n\t\t\tif (!before(TCP_SKB_CB(skb)->seq,\n\t\t\t\t    tcp_highest_sack_seq(tp)))\n\t\t\t\ttcp_advance_highest_sack(sk, skb);\n\t\t}\n\t\tstate->fack_count += tcp_skb_pcount(skb);\n\t}\n\treturn skb;\n}", "target": 0}
{"code": "static int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qual;\n\tif (kvm_event_needs_reinjection(vcpu))\n\t\treturn -EBUSY;\n\tif (vcpu->arch.exception.pending &&\n\t\tnested_vmx_check_exception(vcpu, &exit_qual)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_inject_exception_vmexit(vcpu, exit_qual);\n\t\tvcpu->arch.exception.pending = false;\n\t\treturn 0;\n\t}\n\tif (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&\n\t    vmx->nested.preemption_timer_expired) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);\n\t\treturn 0;\n\t}\n\tif (vcpu->arch.nmi_pending && nested_exit_on_nmi(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,\n\t\t\t\t  NMI_VECTOR | INTR_TYPE_NMI_INTR |\n\t\t\t\t  INTR_INFO_VALID_MASK, 0);\n\t\tvcpu->arch.nmi_pending = 0;\n\t\tvmx_set_nmi_mask(vcpu, true);\n\t\treturn 0;\n\t}\n\tif ((kvm_cpu_has_interrupt(vcpu) || external_intr) &&\n\t    nested_exit_on_intr(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);\n\t\treturn 0;\n\t}\n\tvmx_complete_nested_posted_interrupt(vcpu);\n\treturn 0;\n}", "target": 0}
{"code": "static void my_free(void *ptr)\n{\n    free_called += 1;\n    free(ptr);\n}", "target": 1}
{"code": "std::string encodeBase64(const std::string& input) {\n  using namespace boost::archive::iterators;\n  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;\n  auto data = input.data();\n  std::string encoded(b64it(data), b64it(data + (input.length())));\n  encoded.append((3 - (input.length() % 3)) % 3, '=');\n  return encoded;\n}", "target": 1}
{"code": "int nfs4_lock_delegation_recall(struct nfs4_state *state, struct file_lock *fl)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_exception exception = { };\n\tint err;\n\terr = nfs4_set_lock_state(state, fl);\n\tif (err != 0)\n\t\tgoto out;\n\tdo {\n\t\terr = _nfs4_do_setlk(state, F_SETLK, fl, NFS_LOCK_NEW);\n\t\tswitch (err) {\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_ERR \"NFS: %s: unhandled error \"\n\t\t\t\t\t\"%d.\\n\", __func__, err);\n\t\t\tcase 0:\n\t\t\tcase -ESTALE:\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_EXPIRED:\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tcase -NFS4ERR_STALE_STATEID:\n\t\t\t\tnfs4_schedule_lease_recovery(server->nfs_client);\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_BADSESSION:\n\t\t\tcase -NFS4ERR_BADSLOT:\n\t\t\tcase -NFS4ERR_BAD_HIGH_SLOT:\n\t\t\tcase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\n\t\t\tcase -NFS4ERR_DEADSESSION:\n\t\t\t\tnfs4_schedule_session_recovery(server->nfs_client->cl_session, err);\n\t\t\t\tgoto out;\n\t\t\tcase -ERESTARTSYS:\n\t\t\tcase -NFS4ERR_DELEG_REVOKED:\n\t\t\tcase -NFS4ERR_ADMIN_REVOKED:\n\t\t\tcase -NFS4ERR_BAD_STATEID:\n\t\t\tcase -NFS4ERR_OPENMODE:\n\t\t\t\tnfs4_schedule_stateid_recovery(server, state);\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -EKEYEXPIRED:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -ENOMEM:\n\t\t\tcase -NFS4ERR_DENIED:\n\t\t\t\terr = 0;\n\t\t\t\tgoto out;\n\t\t\tcase -NFS4ERR_DELAY:\n\t\t\t\tbreak;\n\t\t}\n\t\terr = nfs4_handle_exception(server, err, &exception);\n\t} while (exception.retry);\nout:\n\treturn err;\n}", "target": 0}
{"code": "static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int g2m_init_buffers(G2MContext *c)\n{\n    int aligned_height;\n    if (!c->framebuf || c->old_width < c->width || c->old_height < c->height) {\n        c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;\n        aligned_height     = c->height + 15;\n        av_free(c->framebuf);\n        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n        if (!c->framebuf)\n            return AVERROR(ENOMEM);\n    }\n    if (!c->synth_tile || !c->jpeg_tile ||\n        c->old_tile_w < c->tile_width ||\n        c->old_tile_h < c->tile_height) {\n        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;\n        aligned_height = FFALIGN(c->tile_height,    16);\n        av_free(c->synth_tile);\n        av_free(c->jpeg_tile);\n        av_free(c->kempf_buf);\n        av_free(c->kempf_flags);\n        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n        if (!c->synth_tile || !c->jpeg_tile ||\n            !c->kempf_buf || !c->kempf_flags)\n            return AVERROR(ENOMEM);\n    }\n    return 0;\n}", "target": 0}
{"code": "static void split_certinfo(char *string, zval *hash)\n{\n\tchar *org = estrdup(string);\n\tchar *s = org;\n\tchar *split;\n\tif(org) {\n\t\tdo {\n\t\t\tchar *key;\n\t\t\tchar *val;\n\t\t\tchar *tmp;\n\t\t\tsplit = strstr(s, \"; \");\n\t\t\tif(split)\n\t\t\t\t*split = '\\0';\n\t\t\tkey = s;\n\t\t\ttmp = memchr(key, '=', 64);\n\t\t\tif(tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tval = tmp+1;\n\t\t\t\tadd_assoc_string(hash, key, val, 1);\n\t\t\t}\n\t\t\ts = split+2;\n\t\t} while(split);\n\t\tefree(org);\n\t}\n}", "target": 0}
{"code": "static bool dir_is_in_dump_location(const char *dump_dir_name)\n{\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dump_dir_name, g_settings_dump_location, len) == 0\n     && dump_dir_name[len] == '/'\n     && !strstr(dump_dir_name + len, \"/.\")\n    ) {\n        return 1;\n    }\n    return 0;\n}", "target": 1}
{"code": "static bool append_rets(RStrBuf *sb, RBinWasmTypeVec *rets) {\n\tbool ret = true;\n\tif (!rets->count) {\n\t\tret &= r_strbuf_append (sb, \"nil\");\n\t} else if (rets->count == 1) {\n\t\tret &= r_strbuf_append (sb, r_bin_wasm_valuetype_to_string (rets->types[0]));\n\t} else {\n\t\tret &= strbuf_append_type_vec (sb, rets);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int sas_discover_sata(struct domain_device *dev)\n{\n\tint res;\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, MaxMinSelectCorrectlyOrderedIndex) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"a\" << -1));\n    runQueryFull(\n        BSONObj(), BSONObj(), BSONObj(), 0, 0, BSONObj(), fromjson(\"{a: 8}\"), fromjson(\"{a: 2}\"));\n    assertNumSolutions(1);\n    assertSolutionExists(\"{fetch: {node: {ixscan: {filter: null, dir: 1, pattern: {a: -1}}}}}\");\n    runQueryFull(\n        BSONObj(), BSONObj(), BSONObj(), 0, 0, BSONObj(), fromjson(\"{a: 2}\"), fromjson(\"{a: 8}\"));\n    assertNumSolutions(1);\n    assertSolutionExists(\"{fetch: {node: {ixscan: {filter: null, dir: 1, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "    long PreviewImage::writeFile(const std::wstring& wpath) const\n    {\n        std::wstring name = wpath + wextension();\n        DataBuf buf(pData_, size_);\n        return Exiv2::writeFile(buf, name);\n    }", "target": 0}
{"code": "static int rb_check_list(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t struct list_head *list)\n{\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->prev) != list->prev))\n\t\treturn 1;\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->next) != list->next))\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "decode_definite_long_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL, *chunk = NULL, *string = NULL;\n    Py_ssize_t left = length;\n    Py_ssize_t consumed;\n    Py_ssize_t buffer_size = 0;  \n    Py_ssize_t buffer_length = 0;  \n    char *buffer = NULL;\n    while (left) {\n        Py_ssize_t chunk_length = 65536 - buffer_size;\n        if (left < chunk_length)\n            chunk_length = left;\n        PyObject *chunk = fp_read_object(self, chunk_length);\n        left -= chunk_length;\n        if (!chunk)\n            goto error;\n        char *bytes_buffer = PyBytes_AsString(chunk);\n        if (!bytes_buffer)\n            goto error;\n        char *source_buffer;\n        if (buffer) {\n            if (buffer_length + chunk_length > buffer_size) {\n                buffer_size = buffer_length + chunk_length;\n                char *new_buffer = PyMem_Realloc(buffer, buffer_size);\n                if (!new_buffer)\n                    goto error;\n                buffer = new_buffer;\n            }\n            memcpy(buffer + buffer_length, bytes_buffer, chunk_length);\n            buffer_length += chunk_length;\n            source_buffer = buffer;\n            chunk_length = buffer_length;\n        } else {\n            source_buffer = bytes_buffer;\n        }\n        string = PyUnicode_DecodeUTF8Stateful(source_buffer, chunk_length, NULL, &consumed);\n        if (!string)\n            goto error;\n        if (ret) {\n            PyObject *joined = PyUnicode_Concat(ret, string);\n            if (!joined)\n                goto error;\n            Py_DECREF(string);\n            string = NULL;\n            ret = joined;\n        } else {\n            ret = string;\n        }\n        Py_ssize_t unconsumed = chunk_length - consumed;\n        if (consumed != chunk_length) {\n            if (buffer) {\n                memmove(buffer, buffer + consumed, unconsumed);\n            } else {\n                buffer = PyMem_Malloc(unconsumed);\n                if (!buffer)\n                    goto error;\n                memcpy(buffer, bytes_buffer + consumed, unconsumed);\n            }\n            buffer_length = unconsumed;\n        }\n    }\n    if (ret && string_namespace_add(self, ret, length) == -1)\n        goto error;\n    return ret;\nerror:\n    Py_XDECREF(ret);\n    Py_XDECREF(chunk);\n    Py_XDECREF(string);\n    if (buffer)\n        PyMem_Free(buffer);\n    return NULL;\n}", "target": 0}
{"code": "static inline void skb_mac_header_rebuild(struct sk_buff *skb)\n{\n\tif (skb_mac_header_was_set(skb)) {\n\t\tconst unsigned char *old_mac = skb_mac_header(skb);\n\t\tskb_set_mac_header(skb, -skb->mac_len);\n\t\tmemmove(skb_mac_header(skb), old_mac, skb->mac_len);\n\t}\n}", "target": 0}
{"code": "m_hour(union DateData *x)\n{\n    if (simple_dat_p(x))\n\treturn 0;\n    else {\n\tget_c_time(x);\n#ifndef USE_PACK\n\treturn x->c.hour;\n#else\n\treturn EX_HOUR(x->c.pc);\n#endif\n    }\n}", "target": 0}
{"code": "static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,\n\t\t\t     size_t outlen, int invert)\n{\n\tconst u8 *in = inbuf;\n\tu8 *out = (u8 *) outbuf;\n\tint zero_bits = *in & 0x07;\n\tsize_t octets_left = inlen - 1;\n\tint i, count = 0;\n\tmemset(outbuf, 0, outlen);\n\tin++;\n\tif (outlen < octets_left)\n\t\treturn SC_ERROR_BUFFER_TOO_SMALL;\n\tif (inlen < 1)\n\t\treturn SC_ERROR_INVALID_ASN1_OBJECT;\n\twhile (octets_left) {\n\t\tint bits_to_go;\n\t\t*out = 0;\n\t\tif (octets_left == 1)\n\t\t\tbits_to_go = 8 - zero_bits;\n\t\telse\n\t\t\tbits_to_go = 8;\n\t\tif (invert)\n\t\t\tfor (i = 0; i < bits_to_go; i++) {\n\t\t\t\t*out |= ((*in >> (7 - i)) & 1) << i;\n\t\t\t}\n\t\telse {\n\t\t\t*out = *in;\n\t\t}\n\t\tout++;\n\t\tin++;\n\t\toctets_left--;\n\t\tcount++;\n\t}\n\treturn (count * 8) - zero_bits;\n}", "target": 1}
{"code": "void XfccIntegrationTest::initialize() {\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        hcm.set_forward_client_cert_details(fcc_);\n        hcm.mutable_set_current_client_cert_details()->CopyFrom(sccd_);\n      });\n  config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {\n    auto transport_socket =\n        bootstrap.mutable_static_resources()->mutable_clusters(0)->mutable_transport_socket();\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext context;\n    auto* validation_context = context.mutable_common_tls_context()->mutable_validation_context();\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    validation_context->add_match_subject_alt_names()->set_suffix(\"lyft.com\");\n    transport_socket->set_name(\"envoy.transport_sockets.tls\");\n    transport_socket->mutable_typed_config()->PackFrom(context);\n  });\n  if (tls_) {\n    config_helper_.addSslConfig();\n  }\n  context_manager_ =\n      std::make_unique<Extensions::TransportSockets::Tls::ContextManagerImpl>(timeSystem());\n  client_tls_ssl_ctx_ = createClientSslContext(false);\n  client_mtls_ssl_ctx_ = createClientSslContext(true);\n  HttpIntegrationTest::initialize();\n}", "target": 1}
{"code": "xdr_krb5_principal(XDR *xdrs, krb5_principal *objp)\n{\n    int\t    ret;\n    char\t    *p = NULL;\n    krb5_principal  pr = NULL;\n    static krb5_context context = NULL;\n    if (!context &&\n\tkadm5_init_krb5_context(&context))\n       return(FALSE);\n    switch(xdrs->x_op) {\n    case XDR_ENCODE:\n\tif (*objp) {\n\t     if((ret = krb5_unparse_name(context, *objp, &p)) != 0)\n\t\t  return FALSE;\n\t}\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) free(p);\n\tbreak;\n    case XDR_DECODE:\n\tif(!xdr_nullstring(xdrs, &p))\n\t    return FALSE;\n\tif (p) {\n\t     ret = krb5_parse_name(context, p, &pr);\n\t     if(ret != 0)\n\t\t  return FALSE;\n\t     *objp = pr;\n\t     free(p);\n\t} else\n\t     *objp = NULL;\n\tbreak;\n    case XDR_FREE:\n\tif(*objp != NULL)\n\t    krb5_free_principal(context, *objp);\n\t*objp = NULL;\n\tbreak;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static int string_check(char *buf, const char *buf2)\n{\n  if(strcmp(buf, buf2)) {\n    printf(\"sprintf failed:\\nwe '%s'\\nsystem: '%s'\\n\",\n           buf, buf2);\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static int llcp_raw_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\tif (!addr || alen < offsetofend(struct sockaddr, sa_family) ||\n\t    addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\tlock_sock(sk);\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\tsk->sk_state = LLCP_BOUND;\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 1}
{"code": "sraSpanRemove(sraSpan *span) {\n  span->_prev->_next = span->_next;\n  span->_next->_prev = span->_prev;\n}", "target": 1}
{"code": "static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint dio_credits;\n\text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\tcreate = EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\tmax_blocks = DIO_MAX_BLOCKS;\n\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n\thandle = ext4_journal_start(inode, dio_credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,\n\t\t\t      create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "static void encode_test_stateid(struct xdr_stream *xdr,\n\t\t\t\tstruct nfs41_test_stateid_args *args,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\tencode_op_hdr(xdr, OP_TEST_STATEID, decode_test_stateid_maxsz, hdr);\n\tencode_uint32(xdr, 1);\n\tencode_nfs4_stateid(xdr, args->stateid);\n}", "target": 0}
{"code": "static void accumulate_steal_time(struct kvm_vcpu *vcpu)\n{\n\tu64 delta;\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\tdelta = current->sched_info.run_delay - vcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\tvcpu->arch.st.accum_steal = delta;\n}", "target": 0}
{"code": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n\t\treturn -EINVAL;\n\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "static inline void http1_consume_data(intptr_t uuid, http1pr_s *p) {\n  if (fio_pending(uuid) > 4) {\n    goto throttle;\n  }\n  ssize_t i = 0;\n  size_t org_len = p->buf_len;\n  int pipeline_limit = 8;\n  if (!p->buf_len)\n    return;\n  do {\n    i = http1_fio_parser(.parser = &p->parser,\n                         .buffer = p->buf + (org_len - p->buf_len),\n                         .length = p->buf_len, .on_request = http1_on_request,\n                         .on_response = http1_on_response,\n                         .on_method = http1_on_method,\n                         .on_status = http1_on_status, .on_path = http1_on_path,\n                         .on_query = http1_on_query,\n                         .on_http_version = http1_on_http_version,\n                         .on_header = http1_on_header,\n                         .on_body_chunk = http1_on_body_chunk,\n                         .on_error = http1_on_error);\n    p->buf_len -= i;\n    --pipeline_limit;\n  } while (i && p->buf_len && pipeline_limit && !p->stop);\n  if (p->buf_len && org_len != p->buf_len) {\n    memmove(p->buf, p->buf + (org_len - p->buf_len), p->buf_len);\n  }\n  if (p->buf_len == HTTP_MAX_HEADER_LENGTH) {\n    if (p->request.method)\n      http_send_error(&p->request, 413);\n    else {\n      p->request.method = fiobj_str_tmp();\n      http_send_error(&p->request, 413);\n    }\n  }\n  if (!pipeline_limit) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return;\nthrottle:\n  fio_suspend(uuid);\n  p->stop |= 4;\n  FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",\n                (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n}", "target": 1}
{"code": "xfs_dinode_verify_fork(\n\tstruct xfs_dinode\t*dip,\n\tstruct xfs_mount\t*mp,\n\tint\t\t\twhichfork)\n{\n\tuint32_t\t\tdi_nextents = XFS_DFORK_NEXTENTS(dip, whichfork);\n\tswitch (XFS_DFORK_FORMAT(dip, whichfork)) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\tif (whichfork == XFS_DATA_FORK) {\n\t\t\tif (S_ISREG(be16_to_cpu(dip->di_mode)))\n\t\t\t\treturn __this_address;\n\t\t\tif (be64_to_cpu(dip->di_size) >\n\t\t\t\t\tXFS_DFORK_SIZE(dip, mp, whichfork))\n\t\t\t\treturn __this_address;\n\t\t}\n\t\tif (di_nextents)\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\tif (di_nextents > XFS_DFORK_MAXEXT(dip, mp, whichfork))\n\t\t\treturn __this_address;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tif (whichfork == XFS_ATTR_FORK) {\n\t\t\tif (di_nextents > MAXAEXTNUM)\n\t\t\t\treturn __this_address;\n\t\t} else if (di_nextents > MAXEXTNUM) {\n\t\t\treturn __this_address;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn __this_address;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "int64_t OpLevelCostEstimator::CalculateTensorSize(\n    const OpInfo::TensorProperties& tensor, bool* found_unknown_shapes) {\n  int64_t count = CalculateTensorElementCount(tensor, found_unknown_shapes);\n  int size = DataTypeSize(BaseType(tensor.dtype()));\n  VLOG(2) << \"Count: \" << count << \" DataTypeSize: \" << size;\n  return count * size;\n}", "target": 1}
{"code": "CallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n  ComputedPropertyDescriptor desc;\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}", "target": 1}
{"code": "get_manuf_name_if_known(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    guint manuf_key;\n    guint8 oct;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {\n        return manuf_value->resolved_longname;\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return long_name;\n    }\n    return NULL;\n} ", "target": 1}
{"code": "nfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tstruct kvec *tail = rqstp->rq_arg.tail;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\tif ((void *)p > head->iov_base + head->iov_len)\n\t\treturn 0;\n\tif (args->count != args->len)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "INST_HANDLER (sts) {\t\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\top->cycles = 2;\n}", "target": 0}
{"code": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int kLeftShift = 8;\n    int32_t input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(\n        static_cast<double>(input1->params.scale), &input1_multiplier,\n        &input1_shift);\n    int32_t input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(\n        static_cast<double>(input2->params.scale), &input2_multiplier,\n        &input2_shift);\n    data->params.left_shift = kLeftShift;\n    data->params.input1_offset = input1_offset;\n    data->params.input1_multiplier = input1_multiplier;\n    data->params.input1_shift = input1_shift;\n    data->params.input2_offset = input2_offset;\n    data->params.input2_multiplier = input2_multiplier;\n    data->params.input2_shift = input2_shift;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\tfor (n = 0; n < count; n++) {\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n\t\t    value[n] >= min && value[n] <= max &&\n\t\t    value[n] - min < field->maxusage &&\n\t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n\t\t\tgoto exit;\n\t}\n\tfor (n = 0; n < count; n++) {\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (field->value[n] >= min && field->value[n] <= max\n\t\t\t&& field->value[n] - min < field->maxusage\n\t\t\t&& field->usage[field->value[n] - min].hid\n\t\t\t&& search(value, field->value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n\t\tif (value[n] >= min && value[n] <= max\n\t\t\t&& value[n] - min < field->maxusage\n\t\t\t&& field->usage[value[n] - min].hid\n\t\t\t&& search(field->value, value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}", "target": 0}
{"code": "void nfc_unregister_device(struct nfc_dev *dev)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\trc = nfc_genl_device_removed(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s \"\n\t\t\t \"was removed\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (dev->rfkill) {\n\t\trfkill_unregister(dev->rfkill);\n\t\trfkill_destroy(dev->rfkill);\n\t}\n\tdevice_unlock(&dev->dev);\n\tif (dev->ops->check_presence) {\n\t\tdevice_lock(&dev->dev);\n\t\tdev->shutting_down = true;\n\t\tdevice_unlock(&dev->dev);\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\tcancel_work_sync(&dev->check_pres_work);\n\t}\n\tnfc_llcp_unregister_device(dev);\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\tdevice_del(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n}", "target": 1}
{"code": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\tif (KVM_BUG_ON(!lapic_in_kernel(vcpu), vcpu->kvm))\n\t\treturn -EINVAL;\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}", "target": 0}
{"code": "mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tconst u8 *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = vendor_ie;\n\t\tif (*(wmm_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie +\n\t\t       sizeof(struct ieee_types_header), *(wmm_ie + 1));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}", "target": 0}
{"code": "static void zep_print_ts(netdissect_options *ndo, const u_char *p)\n{\n\tint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tfloat ff;\n\ti = GET_BE_U_4(p);\n\tuf = GET_BE_U_4(p + 4);\n\tff = (float) uf;\n\tif (ff < 0.0)           \n\t\tff += FMAXINT;\n\tff = (float) (ff / FMAXINT); \n\tf = (uint32_t) (ff * 1000000000.0);  \n\tND_PRINT(\"%u.%09d\", i, f);\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tstruct tm *tm;\n\t\tchar time_buf[128];\n\t\ttm = localtime(&seconds);\n\t\tstrftime(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\", tm);\n\t\tND_PRINT(\" (%s)\", time_buf);\n\t}\n}", "target": 1}
{"code": "bool AuthNoneAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n  try {\n    __u8 struct_v = 1;\n    ::decode(struct_v, iter);\n    ::decode(entity_name, iter);\n    ::decode(global_id, iter);\n  } catch (const buffer::error &err) {\n    ldout(cct, 0) << \"AuthNoneAuthorizeHandle::verify_authorizer() failed to decode\" << dendl;\n    return false;\n  }\n  caps_info.allow_all = true;\n  return true;\n}", "target": 1}
{"code": "static uint8_t *extend_raw_data(LHAFileHeader **header,\n                                LHAInputStream *stream,\n                                size_t nbytes)\n{\n\tLHAFileHeader *new_header;\n\tsize_t new_raw_len;\n\tuint8_t *result;\n\tif (nbytes > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn NULL;\n\t}\n\tnew_raw_len = RAW_DATA_LEN(header) + nbytes;\n\tnew_header = realloc(*header, sizeof(LHAFileHeader) + new_raw_len);\n\tif (new_header == NULL) {\n\t\treturn NULL;\n\t}\n\t*header = new_header;\n\tnew_header->raw_data = (uint8_t *) (new_header + 1);\n\tresult = new_header->raw_data + new_header->raw_data_len;\n\tif (!lha_input_stream_read(stream, result, nbytes)) {\n\t\treturn NULL;\n\t}\n\tnew_header->raw_data_len = new_raw_len;\n\treturn result;\n}", "target": 0}
{"code": "void rose_link_failed(ax25_cb *ax25, int reason)\n{\n\tstruct rose_neigh *rose_neigh;\n\tspin_lock_bh(&rose_neigh_list_lock);\n\trose_neigh = rose_neigh_list;\n\twhile (rose_neigh != NULL) {\n\t\tif (rose_neigh->ax25 == ax25)\n\t\t\tbreak;\n\t\trose_neigh = rose_neigh->next;\n\t}\n\tif (rose_neigh != NULL) {\n\t\trose_neigh->ax25 = NULL;\n\t\tax25_cb_put(ax25);\n\t\trose_del_route_by_neigh(rose_neigh);\n\t\trose_kill_by_neigh(rose_neigh);\n\t}\n\tspin_unlock_bh(&rose_neigh_list_lock);\n}", "target": 0}
{"code": "    PreviewProperties LoaderExifJpeg::getProperties() const\n    {\n        PreviewProperties prop = Loader::getProperties();\n        prop.mimeType_ = \"image/jpeg\";\n        prop.extension_ = \".jpg\";\n#ifdef EXV_UNICODE_PATH\n        prop.wextension_ = EXV_WIDEN(\".jpg\");\n#endif\n        return prop;\n    }", "target": 0}
{"code": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}", "target": 1}
{"code": "int hashtable_init(hashtable_t *hashtable)\n{\n    size_t i;\n    hashtable->size = 0;\n    hashtable->num_buckets = 0;  \n    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    list_init(&hashtable->list);\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    return 0;\n}", "target": 1}
{"code": "boost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt(\n    const SaplingOutCiphertext &ciphertext,\n    const uint256& ovk,\n    const uint256& cv,\n    const uint256& cm,\n    const uint256& epk\n)\n{\n    auto pt = AttemptSaplingOutDecryption(ciphertext, ovk, cv, cm, epk);\n    if (!pt) {\n        return boost::none;\n    }\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n    SaplingOutgoingPlaintext ret;\n    ss >> ret;\n    assert(ss.size() == 0);\n    return ret;\n}", "target": 1}
{"code": "cleanup_pathname_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)\n{\n\tchar *dest, *src;\n\tchar separator = '\\0';\n\tdest = src = path;\n\tif (*src == '\\0') {\n\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\tif (error_string)\n\t\t    archive_string_sprintf(error_string,\n\t\t\t    \"Invalid empty pathname\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n#if defined(__CYGWIN__)\n\tcleanup_pathname_win(a);\n#endif\n\tif (*src == '/') {\n\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS) {\n\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\t\tif (error_string)\n\t\t\t    archive_string_sprintf(error_string,\n\t\t\t\t    \"Path is absolute\");\n\t\t\treturn (ARCHIVE_FAILED);\n\t\t}\n\t\tseparator = *src++;\n\t}\n\tfor (;;) {\n\t\tif (src[0] == '\\0') {\n\t\t\tbreak;\n\t\t} else if (src[0] == '/') {\n\t\t\tsrc++;\n\t\t\tcontinue;\n\t\t} else if (src[0] == '.') {\n\t\t\tif (src[1] == '\\0') {\n\t\t\t\tbreak;\n\t\t\t} else if (src[1] == '/') {\n\t\t\t\tsrc += 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (src[1] == '.') {\n\t\t\t\tif (src[2] == '/' || src[2] == '\\0') {\n\t\t\t\t\tif (flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {\n\t\t\t\t\t\tif (error_number) *error_number = ARCHIVE_ERRNO_MISC;\n\t\t\t\t\t\tif (error_string)\n\t\t\t\t\t\t    archive_string_sprintf(error_string,\n\t\t\t\t\t\t\t    \"Path contains '..'\");\n\t\t\t\t\t\treturn (ARCHIVE_FAILED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\twhile (*src != '\\0' && *src != '/') {\n\t\t\t*dest++ = *src++;\n\t\t}\n\t\tif (*src == '\\0')\n\t\t\tbreak;\n\t\tseparator = *src++;\n\t}\n\tif (dest == path) {\n\t\tif (separator)\n\t\t\t*dest++ = '/';\n\t\telse\n\t\t\t*dest++ = '.';\n\t}\n\t*dest = '\\0';\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "  explicit DataFormatVecPermuteOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n                errors::InvalidArgument(\n                    \"Source format must be of length 4 or 5, received \"\n                    \"src_format = \",\n                    src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    OP_REQUIRES(context, dst_format.size() == 4 || dst_format.size() == 5,\n                errors::InvalidArgument(\"Destination format must be of length \"\n                                        \"4 or 5, received dst_format = \",\n                                        dst_format));\n    OP_REQUIRES(\n        context, IsValidPermutation(src_format, dst_format),\n        errors::InvalidArgument(\n            \"Destination and source format must determine a permutation, got \",\n            src_format, \" and \", dst_format));\n    src_format_ = src_format;\n    dst_format_ = dst_format;\n  }", "target": 0}
{"code": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stb_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\tr_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (1, bin->ne_header->EntryTableLength);\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}", "target": 1}
{"code": "static struct sock *__udp4_lib_mcast_demux_lookup(struct net *net,\n\t\t\t\t\t\t  __be16 loc_port, __be32 loc_addr,\n\t\t\t\t\t\t  __be16 rmt_port, __be32 rmt_addr,\n\t\t\t\t\t\t  int dif)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(loc_port);\n\tunsigned int count, slot = udp_hashfn(net, hnum, udp_table.mask);\n\tstruct udp_hslot *hslot = &udp_table.hash[slot];\n\tif (hslot->count > 10)\n\t\treturn NULL;\n\trcu_read_lock();\nbegin:\n\tcount = 0;\n\tresult = NULL;\n\tsk_nulls_for_each_rcu(sk, node, &hslot->head) {\n\t\tif (__udp_is_mcast_sock(net, sk,\n\t\t\t\t\tloc_port, loc_addr,\n\t\t\t\t\trmt_port, rmt_addr,\n\t\t\t\t\tdif, hnum)) {\n\t\t\tresult = sk;\n\t\t\t++count;\n\t\t}\n\t}\n\tif (get_nulls_value(node) != slot)\n\t\tgoto begin;\n\tif (result) {\n\t\tif (count != 1 ||\n\t\t    unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(!__udp_is_mcast_sock(net, result,\n\t\t\t\t\t\t       loc_port, loc_addr,\n\t\t\t\t\t\t       rmt_port, rmt_addr,\n\t\t\t\t\t\t       dif, hnum))) {\n\t\t\tsock_put(result);\n\t\t\tresult = NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn result;\n}", "target": 0}
{"code": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "njs_function_frame_save(njs_vm_t *vm, njs_frame_t *frame, u_char *pc)\n{\n    size_t              value_count, n;\n    njs_value_t         *start, *end, *p, **new, *value, **local;\n    njs_function_t      *function;\n    njs_native_frame_t  *active, *native;\n    *frame = *vm->active_frame;\n    frame->previous_active_frame = NULL;\n    native = &frame->native;\n    native->size = 0;\n    native->free = NULL;\n    native->free_size = 0;\n    active = &vm->active_frame->native;\n    value_count = njs_function_frame_value_count(active);\n    function = active->function;\n    new = (njs_value_t **) ((u_char *) native + NJS_FRAME_SIZE);\n    value = (njs_value_t *) (new + value_count\n                             + function->u.lambda->temp);\n    native->arguments = value;\n    native->arguments_offset = value + (function->args_offset - 1);\n    native->local = new + njs_function_frame_args_count(active);\n    native->temp = new + value_count;\n    native->pc = pc;\n    start = njs_function_frame_values(active, &end);\n    p = native->arguments;\n    while (start < end) {\n        *p = *start++;\n        *new++ = p++;\n    }\n    p = native->arguments;\n    local = native->local + function->args_offset;\n    for (n = 0; n < function->args_count; n++) {\n        if (!njs_is_valid(p)) {\n            njs_set_undefined(p);\n        }\n        *local++ = p++;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "static int v2g_incoming_v2gtp(struct v2g_connection* conn) {\n    int rv;\n    rv = connection_read(conn, conn->buffer, V2GTP_HEADER_LENGTH);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv == 0)\n        return 1;\n    if (rv != V2GTP_HEADER_LENGTH) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) too short: expected %d, got %d\", V2GTP_HEADER_LENGTH, rv);\n        return -1;\n    }\n    rv = read_v2gtpHeader(conn->buffer, &conn->payload_len);\n    if (rv == -1) {\n        dlog(DLOG_LEVEL_ERROR, \"Invalid v2gtp header\");\n        return -1;\n    }\n    if (conn->payload_len + V2GTP_HEADER_LENGTH > DEFAULT_BUFFER_SIZE) {\n        dlog(DLOG_LEVEL_ERROR, \"payload too long: have %d, would need %d\", DEFAULT_BUFFER_SIZE,\n             conn->payload_len + V2GTP_HEADER_LENGTH);\n        return -1;\n    }\n    rv = connection_read(conn, &conn->buffer[V2GTP_HEADER_LENGTH], conn->payload_len);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv != conn->payload_len) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) too short: expected %d, got %d\", conn->payload_len, rv);\n        return -1;\n    }\n    conn->buffer_pos = V2GTP_HEADER_LENGTH;\n    conn->stream.size = conn->payload_len + V2GTP_HEADER_LENGTH;\n    return 0;\n}", "target": 1}
{"code": "void Context::onDownstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onDownstreamConnectionClose_) {\n    wasm_->onDownstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "void check_system_chunk(struct btrfs_trans_handle *trans, u64 type)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_space_info *info;\n\tu64 left;\n\tu64 thresh;\n\tint ret = 0;\n\tu64 num_devs;\n\tlockdep_assert_held(&fs_info->chunk_mutex);\n\tinfo = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);\nagain:\n\tspin_lock(&info->lock);\n\tleft = info->total_bytes - btrfs_space_info_used(info, true);\n\tspin_unlock(&info->lock);\n\tnum_devs = get_profile_num_devs(fs_info, type);\n\tthresh = btrfs_calc_metadata_size(fs_info, num_devs) +\n\t\tbtrfs_calc_insert_metadata_size(fs_info, 1);\n\tif (left < thresh && btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {\n\t\tbtrfs_info(fs_info, \"left=%llu, need=%llu, flags=%llu\",\n\t\t\t   left, thresh, type);\n\t\tbtrfs_dump_space_info(fs_info, info, 0, 0);\n\t}\n\tif (left < thresh) {\n\t\tu64 flags = btrfs_system_alloc_profile(fs_info);\n\t\tu64 reserved = atomic64_read(&cur_trans->chunk_bytes_reserved);\n\t\tif (reserved > trans->chunk_bytes_reserved) {\n\t\t\tconst u64 min_needed = reserved - thresh;\n\t\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\t\twait_event(cur_trans->chunk_reserve_wait,\n\t\t\t   atomic64_read(&cur_trans->chunk_bytes_reserved) <=\n\t\t\t   min_needed);\n\t\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\t\tgoto again;\n\t\t}\n\t\tret = btrfs_alloc_chunk(trans, flags);\n\t}\n\tif (!ret) {\n\t\tret = btrfs_block_rsv_add(fs_info->chunk_root,\n\t\t\t\t\t  &fs_info->chunk_block_rsv,\n\t\t\t\t\t  thresh, BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret) {\n\t\t\tatomic64_add(thresh, &cur_trans->chunk_bytes_reserved);\n\t\t\ttrans->chunk_bytes_reserved += thresh;\n\t\t}\n\t}\n}", "target": 1}
{"code": "CallResult<PseudoHandle<>> GeneratorInnerFunction::callInnerFunction(\n    Handle<GeneratorInnerFunction> selfHandle,\n    Runtime &runtime,\n    Handle<> arg,\n    Action action) {\n  auto self = Handle<GeneratorInnerFunction>::vmcast(selfHandle);\n  SmallHermesValue shv =\n      SmallHermesValue::encodeHermesValue(arg.getHermesValue(), runtime);\n  self->result_.set(shv, runtime.getHeap());\n  self->action_ = action;\n  auto ctx = runtime.makeMutableHandle(selfHandle->savedContext_);\n  const uint32_t argCount = self->argCount_;\n  HermesValue newTarget = HermesValue::encodeUndefinedValue();\n  ScopedNativeCallFrame frame{\n      runtime,\n      argCount, \n      selfHandle.getHermesValue(),\n      newTarget,\n      ctx->at(0)};\n  if (LLVM_UNLIKELY(frame.overflowed()))\n    return runtime.raiseStackOverflow(Runtime::StackOverflowKind::NativeStack);\n  for (ArrayStorage::size_type i = 0, e = argCount; i < e; ++i) {\n    frame->getArgRef(i) = ctx->at(i + 1);\n  }\n  if (LLVM_UNLIKELY(selfHandle->getCodeBlock(runtime)->isLazy())) {\n    selfHandle->getCodeBlock(runtime)->lazyCompile(runtime);\n    if (LLVM_UNLIKELY(\n            ArrayStorage::resize(\n                ctx,\n                runtime,\n                getContextSize(\n                    selfHandle->getCodeBlock(runtime),\n                    selfHandle->argCount_)) == ExecutionStatus::EXCEPTION)) {\n      return ExecutionStatus::EXCEPTION;\n    }\n    selfHandle->savedContext_.set(runtime, ctx.get(), runtime.getHeap());\n  }\n  return JSFunction::_callImpl(selfHandle, runtime);\n}", "target": 1}
{"code": "deltas_head_create(struct deltas_head **deltas)\n{\n\tstruct deltas_head *tmp;\n\ttmp = malloc(sizeof(struct deltas_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdeltas_head_init(tmp);\n\t*deltas = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "static int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "hb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->symmetric_difference (*other);\n}", "target": 1}
{"code": "int Dispatcher::getparam( size_t N, int defaultval )\n{\n  int ret = defaultval;\n  if ( !parsed ) {\n    parse_params();\n  }\n  if ( parsed_params.size() > N ) {\n    ret = parsed_params[ N ];\n  }\n  if ( ret > PARAM_MAX ) {\n    ret = defaultval;\n  }\n  if ( ret < 1 ) ret = defaultval;\n  return ret;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    OP_REQUIRES(context,\n                batch == out_backprop.dim_size(0) &&\n                    out_rows == out_backprop.dim_size(1) &&\n                    out_cols == out_backprop.dim_size(2) &&\n                    depth == out_backprop.dim_size(3),\n                errors::InvalidArgument(\"out_backprop has incompatible size.\"));\n    Tensor* in_backprop = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &in_backprop));\n    if (input.shape().num_elements() == 0) {\n      return;\n    }\n    functor::DilationBackpropInput<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,\n        stride_cols, rate_rows, rate_cols, pad_top, pad_left,\n        in_backprop->tensor<T, 4>());\n  }", "target": 0}
{"code": "CURLcode Curl_urldecode(struct SessionHandle *data,\n                        const char *string, size_t length,\n                        char **ostring, size_t *olen,\n                        bool reject_ctrl)\n{\n  size_t alloc = (length?length:strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  size_t strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return CURLE_OUT_OF_MEMORY;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && (alloc > 2) &&\n       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(data, &in, 1);\n      if(res) {\n        free(ns);\n        return res;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    if(reject_ctrl && (in < 0x20)) {\n      free(ns);\n      return CURLE_URL_MALFORMAT;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  if(ostring)\n    *ostring = ns;\n  return CURLE_OK;\n}", "target": 0}
{"code": "static struct port_buffer *get_inbuf(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tif (port->inbuf)\n\t\treturn port->inbuf;\n\tbuf = virtqueue_get_buf(port->in_vq, &len);\n\tif (buf) {\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\tport->stats.bytes_received += len;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)\n{\n\tstruct xenvif *vif;\n\tstruct pending_tx_info *pending_tx_info;\n\tpending_ring_idx_t index;\n\tif (netbk->mmap_pages[pending_idx] == NULL)\n\t\treturn;\n\tpending_tx_info = &netbk->pending_tx_info[pending_idx];\n\tvif = pending_tx_info->vif;\n\tmake_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);\n\tindex = pending_index(netbk->pending_prod++);\n\tnetbk->pending_ring[index] = pending_idx;\n\txenvif_put(vif);\n\tnetbk->mmap_pages[pending_idx]->mapping = 0;\n\tput_page(netbk->mmap_pages[pending_idx]);\n\tnetbk->mmap_pages[pending_idx] = NULL;\n}", "target": 1}
{"code": "int BUFFER_enlarge(BUFFER_HANDLE handle, size_t enlargeSize)\n{\n    int result;\n    if (handle == NULL)\n    {\n        LogError(\"Failure: handle is invalid.\");\n        result = MU_FAILURE;\n    }\n    else if (enlargeSize == 0)\n    {\n        LogError(\"Failure: enlargeSize size is 0.\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        BUFFER* b = (BUFFER*)handle;\n        unsigned char* temp = (unsigned char*)realloc(b->buffer, b->size + enlargeSize);\n        if (temp == NULL)\n        {\n            LogError(\"Failure: allocating temp buffer.\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            b->buffer = temp;\n            b->size += enlargeSize;\n            result = 0;\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "void HTTPSession::onCertificate(uint16_t certId,\n                                std::unique_ptr<IOBuf> authenticator) {\n  DestructorGuard dg(this);\n  VLOG(4) << \"CERTIFICATE on\" << *this << \", certId=\" << certId;\n  if (!secondAuthManager_) {\n    return;\n  }\n  bool isValid = false;\n  auto fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();\n  if (fizzBase) {\n    if (isUpstream()) {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::UPSTREAM,\n          certId,\n          std::move(authenticator));\n    } else {\n      isValid = secondAuthManager_->validateAuthenticator(\n          *fizzBase,\n          TransportDirection::DOWNSTREAM,\n          certId,\n          std::move(authenticator));\n    }\n  } else {\n    VLOG(4) << \"Underlying transport does not support secondary \"\n               \"authentication.\";\n    return;\n  }\n  if (isValid) {\n    VLOG(4) << \"Successfully validated the authenticator provided by the peer.\";\n  } else {\n    VLOG(4) << \"Failed to validate the authenticator provided by the peer\";\n  }\n}", "target": 0}
{"code": "void gf_filter_pid_inst_del(GF_FilterPidInst *pidinst)\n{\n\tassert(pidinst);\n\tgf_filter_pid_inst_reset(pidinst);\n \tgf_fq_del(pidinst->packets, (gf_destruct_fun) pcki_del);\n\tgf_mx_del(pidinst->pck_mx);\n\tgf_list_del(pidinst->pck_reassembly);\n\tif (pidinst->props) {\n\t\tassert(pidinst->props->reference_count);\n\t\tif (safe_int_dec(&pidinst->props->reference_count) == 0) {\n\t\t\tgf_mx_p(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_list_del_item(pidinst->pid->properties, pidinst->props);\n\t\t\tgf_mx_v(pidinst->pid->filter->tasks_mx);\n\t\t\tgf_props_del(pidinst->props);\n\t\t}\n\t}\n\tgf_free(pidinst);\n}", "target": 1}
{"code": "static int do_remount(struct path *path, int flags, int mnt_flags,\n\t\t      void *data)\n{\n\tint err;\n\tstruct super_block *sb = path->mnt->mnt_sb;\n\tstruct mount *mnt = real_mount(path->mnt);\n\tif (!check_mnt(mnt))\n\t\treturn -EINVAL;\n\tif (path->dentry != path->mnt->mnt_root)\n\t\treturn -EINVAL;\n\terr = security_sb_remount(sb, data);\n\tif (err)\n\t\treturn err;\n\tdown_write(&sb->s_umount);\n\tif (flags & MS_BIND)\n\t\terr = change_mount_flags(path->mnt, flags);\n\telse if (!capable(CAP_SYS_ADMIN))\n\t\terr = -EPERM;\n\telse\n\t\terr = do_remount_sb(sb, flags, data, 0);\n\tif (!err) {\n\t\tlock_mount_hash();\n\t\tmnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;\n\t\tmnt->mnt.mnt_flags = mnt_flags;\n\t\ttouch_mnt_namespace(mnt->mnt_ns);\n\t\tunlock_mount_hash();\n\t}\n\tup_write(&sb->s_umount);\n\treturn err;\n}", "target": 1}
{"code": "gsm_xsmp_client_disconnect (GsmXSMPClient *client)\n{\n        if (client->priv->watch_id > 0) {\n                g_source_remove (client->priv->watch_id);\n        }\n        if (client->priv->conn != NULL) {\n                SmsCleanUp (client->priv->conn);\n        }\n        if (client->priv->ice_connection != NULL) {\n                IceSetShutdownNegotiation (client->priv->ice_connection, FALSE);\n                IceCloseConnection (client->priv->ice_connection);\n        }\n        if (client->priv->protocol_timeout > 0) {\n                g_source_remove (client->priv->protocol_timeout);\n        }\n}", "target": 1}
{"code": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->arp))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}", "target": 1}
{"code": "static int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops->get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tdefault: \n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int proc_sys_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct ctl_table_header *head = grab_header(file_inode(file));\n\tstruct ctl_table_header *h = NULL;\n\tstruct ctl_table *entry;\n\tstruct ctl_dir *ctl_dir;\n\tunsigned long pos;\n\tif (IS_ERR(head))\n\t\treturn PTR_ERR(head);\n\tctl_dir = container_of(head, struct ctl_dir, header);\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\tpos = 2;\n\tfor (first_entry(ctl_dir, &h, &entry); h; next_entry(&h, &entry)) {\n\t\tif (!scan(h, entry, &pos, file, ctx)) {\n\t\t\tsysctl_head_finish(h);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsysctl_head_finish(head);\n\treturn 0;\n}", "target": 1}
{"code": "int nfc_fw_download(struct nfc_dev *dev, const char *firmware_name)\n{\n\tint rc = 0;\n\tpr_debug(\"%s do firmware %s\\n\", dev_name(&dev->dev), firmware_name);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dev_up) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->fw_download) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tdev->fw_download_in_progress = true;\n\trc = dev->ops->fw_download(dev, firmware_name);\n\tif (rc)\n\t\tdev->fw_download_in_progress = false;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "imap_client_notify_starttls(struct client *client,\n\t\t\t    bool success, const char *text)\n{\n\tif (success)\n\t\tclient_send_reply(client, IMAP_CMD_REPLY_OK, text);\n\telse\n\t\tclient_send_reply(client, IMAP_CMD_REPLY_BAD, text);\n}", "target": 0}
{"code": "smb3_free_compound_rqst(int num_rqst, struct smb_rqst *rqst)\n{\n\tint i, j;\n\tfor (i = 0; i < num_rqst; i++) {\n\t\tif (rqst[i].rq_pages) {\n\t\t\tfor (j = rqst[i].rq_npages - 1; j >= 0; j--)\n\t\t\t\tput_page(rqst[i].rq_pages[j]);\n\t\t\tkfree(rqst[i].rq_pages);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static bool gguf_ex_read_0(const std::string & fname) {\n    struct gguf_init_params params = {\n         false,\n         NULL,\n    };\n    struct gguf_context * ctx = gguf_init_from_file(fname.c_str(), params);\n    if (!ctx) {\n        fprintf(stderr, \"%s: failed to load '%s'\\n\", __func__, fname.c_str());\n        return false;\n    }\n    printf(\"%s: version:      %d\\n\", __func__, gguf_get_version(ctx));\n    printf(\"%s: alignment:   %zu\\n\", __func__, gguf_get_alignment(ctx));\n    printf(\"%s: data offset: %zu\\n\", __func__, gguf_get_data_offset(ctx));\n    {\n        const int n_kv = gguf_get_n_kv(ctx);\n        printf(\"%s: n_kv: %d\\n\", __func__, n_kv);\n        for (int i = 0; i < n_kv; ++i) {\n            const char * key = gguf_get_key(ctx, i);\n            printf(\"%s: kv[%d]: key = %s\\n\", __func__, i, key);\n        }\n    }\n    {\n        const char * findkey = \"some.parameter.string\";\n        const int keyidx = gguf_find_key(ctx, findkey);\n        if (keyidx == -1) {\n            printf(\"%s: find key: %s not found.\\n\", __func__, findkey);\n        } else {\n            const char * key_value = gguf_get_val_str(ctx, keyidx);\n            printf(\"%s: find key: %s found, kv[%d] value = %s\\n\", __func__, findkey, keyidx, key_value);\n        }\n    }\n    {\n        const int n_tensors = gguf_get_n_tensors(ctx);\n        printf(\"%s: n_tensors: %d\\n\", __func__, n_tensors);\n        for (int i = 0; i < n_tensors; ++i) {\n            const char * name   = gguf_get_tensor_name  (ctx, i);\n            const size_t offset = gguf_get_tensor_offset(ctx, i);\n            printf(\"%s: tensor[%d]: name = %s, offset = %zu\\n\", __func__, i, name, offset);\n        }\n    }\n    gguf_free(ctx);\n    return true;\n}", "target": 0}
{"code": "static int __net_init sctp_ctrlsock_init(struct net *net)\n{\n\tint status;\n\tstatus = sctp_ctl_sock_init(net);\n\tif (status)\n\t\tpr_err(\"Failed to initialize the SCTP control sock\\n\");\n\treturn status;\n}", "target": 0}
{"code": "GF_Err text_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu16 pSize;\n\tGF_TextSampleEntryBox *ptr = (GF_TextSampleEntryBox*)s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_data(bs, ptr->reserved, 6);\n\tgf_bs_write_u16(bs, ptr->dataReferenceIndex);\n\tgf_bs_write_u32(bs, ptr->displayFlags);\t\t\t\n\tgf_bs_write_u32(bs, ptr->textJustification);\t\n\tgf_bs_write_data(bs, ptr->background_color, 6);\t\n\tgpp_write_box(bs, &ptr->default_box);\t\t\t\n\tgf_bs_write_data(bs, ptr->reserved1, 8);\t\t\n\tgf_bs_write_u16(bs, ptr->fontNumber);\t\t\t\n\tgf_bs_write_u16(bs, ptr->fontFace);\t\t\t\t\n\tgf_bs_write_u8(bs, ptr->reserved2);\t\t\t\t\n\tgf_bs_write_u16(bs, ptr->reserved3);\t\t\t\n\tgf_bs_write_data(bs, ptr->foreground_color, 6);\t\n\tif (ptr->textName && (pSize = (u16) strlen(ptr->textName))) {\n\t\tgf_bs_write_u8(bs, pSize);\t\t\t\t\t\n\t\tgf_bs_write_data(bs, ptr->textName, pSize);\t\n\t} else {\n\t\tgf_bs_write_u8(bs, 0);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "local block_state deflate_rle(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    uInt prev;              \n    Bytef *scan, *strend;   \n    for (;;) {\n        if (s->lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; \n        }\n        s->match_length = 0;\n        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {\n            scan = s->window + s->strstart - 1;\n            prev = *scan;\n            if (prev == *++scan && prev == *++scan && prev == *++scan) {\n                strend = s->window + s->strstart + MAX_MATCH;\n                do {\n                } while (prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         scan < strend);\n                s->match_length = MAX_MATCH - (uInt)(strend - scan);\n                if (s->match_length > s->lookahead)\n                    s->match_length = s->lookahead;\n            }\n            Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->strstart - 1, s->match_length);\n            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);\n            s->lookahead -= s->match_length;\n            s->strstart += s->match_length;\n            s->match_length = 0;\n        } else {\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "static struct sock *sctp_v6_create_accept_sk(struct sock *sk,\n\t\t\t\t\t     struct sctp_association *asoc,\n\t\t\t\t\t     bool kern)\n{\n\tstruct sock *newsk;\n\tstruct ipv6_pinfo *newnp, *np = inet6_sk(sk);\n\tstruct sctp6_sock *newsctp6sk;\n\tstruct ipv6_txoptions *opt;\n\tnewsk = sk_alloc(sock_net(sk), PF_INET6, GFP_KERNEL, sk->sk_prot, kern);\n\tif (!newsk)\n\t\tgoto out;\n\tsock_init_data(NULL, newsk);\n\tsctp_copy_sock(newsk, sk, asoc);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\tnewsctp6sk = (struct sctp6_sock *)newsk;\n\tinet_sk(newsk)->pinet6 = &newsctp6sk->inet6;\n\tsctp_sk(newsk)->v4mapped = sctp_sk(sk)->v4mapped;\n\tnewnp = inet6_sk(newsk);\n\tmemcpy(newnp, np, sizeof(struct ipv6_pinfo));\n\tnewnp->ipv6_mc_list = NULL;\n\tnewnp->ipv6_ac_list = NULL;\n\tnewnp->ipv6_fl_list = NULL;\n\trcu_read_lock();\n\topt = rcu_dereference(np->opt);\n\tif (opt)\n\t\topt = ipv6_dup_options(newsk, opt);\n\tRCU_INIT_POINTER(newnp->opt, opt);\n\trcu_read_unlock();\n\tsctp_v6_to_sk_daddr(&asoc->peer.primary_addr, newsk);\n\tnewsk->sk_v6_rcv_saddr = sk->sk_v6_rcv_saddr;\n\tsk_refcnt_debug_inc(newsk);\n\tif (newsk->sk_prot->init(newsk)) {\n\t\tsk_common_release(newsk);\n\t\tnewsk = NULL;\n\t}\nout:\n\treturn newsk;\n}", "target": 0}
{"code": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "SMB2_open_free(struct smb_rqst *rqst)\n{\n\tint i;\n\tif (rqst && rqst->rq_iov) {\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base);\n\t\tfor (i = 1; i < rqst->rq_nvec; i++)\n\t\t\tif (rqst->rq_iov[i].iov_base != smb2_padding)\n\t\t\t\tkfree(rqst->rq_iov[i].iov_base);\n\t}\n}", "target": 0}
{"code": "fp_read(CBORDecoderObject *self, char *buf, const Py_ssize_t size)\n{\n    PyObject *obj, *size_obj;\n    char *data;\n    int ret = -1;\n    size_obj = PyLong_FromSsize_t(size);\n    if (size_obj) {\n        obj = PyObject_CallFunctionObjArgs(self->read, size_obj, NULL);\n        if (obj) {\n            assert(PyBytes_CheckExact(obj));\n            if (PyBytes_GET_SIZE(obj) == (Py_ssize_t) size) {\n                data = PyBytes_AS_STRING(obj);\n                memcpy(buf, data, size);\n                ret = 0;\n            } else {\n                PyErr_Format(\n                    _CBOR2_CBORDecodeEOF,\n                    \"premature end of stream (expected to read %zd bytes, \"\n                    \"got %zd instead)\", size, PyBytes_GET_SIZE(obj));\n            }\n            Py_DECREF(obj);\n        }\n        Py_DECREF(size_obj);\n    }\n    return ret;\n}", "target": 1}
{"code": "void send( char* str ) {\n    fprintf(outfile, \"%s\",str);\n}", "target": 0}
{"code": "static struct ib_ucontext *hns_roce_alloc_ucontext(struct ib_device *ib_dev,\n\t\t\t\t\t\t   struct ib_udata *udata)\n{\n\tint ret = 0;\n\tstruct hns_roce_ucontext *context;\n\tstruct hns_roce_ib_alloc_ucontext_resp resp;\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_dev);\n\tresp.qp_tab_size = hr_dev->caps.num_qps;\n\tcontext = kmalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn ERR_PTR(-ENOMEM);\n\tret = hns_roce_uar_alloc(hr_dev, &context->uar);\n\tif (ret)\n\t\tgoto error_fail_uar_alloc;\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_RECORD_DB) {\n\t\tINIT_LIST_HEAD(&context->page_list);\n\t\tmutex_init(&context->page_mutex);\n\t}\n\tret = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (ret)\n\t\tgoto error_fail_copy_to_udata;\n\treturn &context->ibucontext;\nerror_fail_copy_to_udata:\n\thns_roce_uar_free(hr_dev, &context->uar);\nerror_fail_uar_alloc:\n\tkfree(context);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "int removeifnotchanged(const file_t *file, char **errorstring)\n{\n  int result;\n  struct stat st;\n  static char *filechanged = \"File contents changed during processing\";\n  static char *unknownerror = \"Unknown error\";\n  stat(file->d_name, &st);\n  if (file->device != st.st_dev ||\n      file->inode != st.st_ino ||\n      file->ctime != st.st_ctime ||\n      file->mtime != st.st_mtime ||\n      file->size != st.st_size)\n  {\n    if (errorstring != 0)\n        *errorstring = filechanged;\n    return -2;\n  }\n  else\n  {\n    result = remove(file->d_name);\n    if (result != 0 && errorstring != 0)\n    {\n      *errorstring = strerror(errno);\n      if (*errorstring == 0)\n        *errorstring = unknownerror;\n    }\n    return result;\n  }\n}", "target": 0}
{"code": "inline void aligned_free(void* ptr) {\n  folly::detail::aligned_free(ptr);\n}", "target": 1}
{"code": "long kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (ioctl) {\n\tcase KVM_ARM_VCPU_INIT: {\n\t\tstruct kvm_vcpu_init init;\n\t\tif (copy_from_user(&init, argp, sizeof(init)))\n\t\t\treturn -EFAULT;\n\t\treturn kvm_vcpu_set_target(vcpu, &init);\n\t}\n\tcase KVM_SET_ONE_REG:\n\tcase KVM_GET_ONE_REG: {\n\t\tstruct kvm_one_reg reg;\n\t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n\t\t\treturn -ENOEXEC;\n\t\tif (copy_from_user(&reg, argp, sizeof(reg)))\n\t\t\treturn -EFAULT;\n\t\tif (ioctl == KVM_SET_ONE_REG)\n\t\t\treturn kvm_arm_set_reg(vcpu, &reg);\n\t\telse\n\t\t\treturn kvm_arm_get_reg(vcpu, &reg);\n\t}\n\tcase KVM_GET_REG_LIST: {\n\t\tstruct kvm_reg_list __user *user_list = argp;\n\t\tstruct kvm_reg_list reg_list;\n\t\tunsigned n;\n\t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n\t\t\treturn -ENOEXEC;\n\t\tif (copy_from_user(&reg_list, user_list, sizeof(reg_list)))\n\t\t\treturn -EFAULT;\n\t\tn = reg_list.n;\n\t\treg_list.n = kvm_arm_num_regs(vcpu);\n\t\tif (copy_to_user(user_list, &reg_list, sizeof(reg_list)))\n\t\t\treturn -EFAULT;\n\t\tif (n < reg_list.n)\n\t\t\treturn -E2BIG;\n\t\treturn kvm_arm_copy_reg_indices(vcpu, user_list->reg);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "int seccomp_restrict_realtime(void) {\n        static const int permitted_policies[] = {\n                SCHED_OTHER,\n                SCHED_BATCH,\n                SCHED_IDLE,\n        };\n        int r, max_policy = 0;\n        uint32_t arch;\n        unsigned i;\n        for (i = 0; i < ELEMENTSOF(permitted_policies); i++)\n                if (permitted_policies[i] > max_policy)\n                        max_policy = permitted_policies[i];\n        SECCOMP_FOREACH_LOCAL_ARCH(arch) {\n                _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;\n                int p;\n                log_debug(\"Operating on architecture: %s\", seccomp_arch_to_string(arch));\n                r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);\n                if (r < 0)\n                        return r;\n                for (p = 0; p < max_policy; p++) {\n                        bool good = false;\n                        for (i = 0; i < ELEMENTSOF(permitted_policies); i++)\n                                if (permitted_policies[i] == p) {\n                                        good = true;\n                                        break;\n                                }\n                        if (good)\n                                continue;\n                        r = seccomp_rule_add_exact(\n                                        seccomp,\n                                        SCMP_ACT_ERRNO(EPERM),\n                                        SCMP_SYS(sched_setscheduler),\n                                        1,\n                                        SCMP_A1(SCMP_CMP_EQ, p));\n                        if (r < 0) {\n                                log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                                continue;\n                        }\n                }\n                r = seccomp_rule_add_exact(\n                                seccomp,\n                                SCMP_ACT_ERRNO(EPERM),\n                                SCMP_SYS(sched_setscheduler),\n                                1,\n                                SCMP_A1(SCMP_CMP_GT, max_policy));\n                if (r < 0) {\n                        log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                        continue;\n                }\n                r = seccomp_load(seccomp);\n                if (IN_SET(r, -EPERM, -EACCES))\n                        return r;\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to install realtime protection rules for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n        }\n        return 0;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif(im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif(!pim) {\n\t\t\treturn;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\tGIFEncode(\n\t    out, tim->sx, tim->sy, interlace, 0, tim->transparent, BitsPerPixel,\n\t    tim->red, tim->green, tim->blue, tim);\n\tif(pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n}", "target": 1}
{"code": "void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      value.clear();\n    }\n  } else {\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}", "target": 1}
{"code": "static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\n\t\t\t    int *uaddr_len, int peer)\n{\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\n\tlsa->l2tp_family = AF_INET6;\n\tlsa->l2tp_flowinfo = 0;\n\tlsa->l2tp_scope_id = 0;\n\tlsa->l2tp_unused = 0;\n\tif (peer) {\n\t\tif (!lsk->peer_conn_id)\n\t\t\treturn -ENOTCONN;\n\t\tlsa->l2tp_conn_id = lsk->peer_conn_id;\n\t\tlsa->l2tp_addr = np->daddr;\n\t\tif (np->sndflow)\n\t\t\tlsa->l2tp_flowinfo = np->flow_label;\n\t} else {\n\t\tif (ipv6_addr_any(&np->rcv_saddr))\n\t\t\tlsa->l2tp_addr = np->saddr;\n\t\telse\n\t\t\tlsa->l2tp_addr = np->rcv_saddr;\n\t\tlsa->l2tp_conn_id = lsk->conn_id;\n\t}\n\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\tlsa->l2tp_scope_id = sk->sk_bound_dev_if;\n\t*uaddr_len = sizeof(*lsa);\n\treturn 0;\n}", "target": 0}
{"code": "folly::Optional<Param> ReadRecordLayer::readEvent(\n    folly::IOBufQueue& socketBuf) {\n  if (!unparsedHandshakeData_.empty()) {\n    auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n    if (param) {\n      VLOG(8) << \"Received handshake message \"\n              << toString(boost::apply_visitor(EventVisitor(), *param));\n      return param;\n    }\n  }\n  while (true) {\n    auto message = read(socketBuf);\n    if (!message) {\n      return folly::none;\n    }\n    if (!unparsedHandshakeData_.empty() &&\n        message->type != ContentType::handshake) {\n      throw std::runtime_error(\"spliced handshake data\");\n    }\n    switch (message->type) {\n      case ContentType::alert: {\n        auto alert = decode<Alert>(std::move(message->fragment));\n        if (alert.description == AlertDescription::close_notify) {\n          return Param(CloseNotify(socketBuf.move()));\n        } else {\n          return Param(std::move(alert));\n        }\n      }\n      case ContentType::handshake: {\n        unparsedHandshakeData_.append(std::move(message->fragment));\n        auto param = decodeHandshakeMessage(unparsedHandshakeData_);\n        if (param) {\n          VLOG(8) << \"Received handshake message \"\n                  << toString(boost::apply_visitor(EventVisitor(), *param));\n          return param;\n        } else {\n          continue;\n        }\n      }\n      case ContentType::application_data:\n        return Param(AppData(std::move(message->fragment)));\n      default:\n        throw std::runtime_error(\"unknown content type\");\n    }\n  }\n}", "target": 1}
{"code": "static void addrconf_ip6_tnl_config(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\tASSERT_RTNL();\n\tidev = addrconf_add_dev(dev);\n\tif (IS_ERR(idev)) {\n\t\tpr_debug(\"init ip6-ip6: add_dev failed\\n\");\n\t\treturn;\n\t}\n\tip6_tnl_add_linklocal(idev);\n}", "target": 0}
{"code": "static void vc_uniscr_delete(struct vc_data *vc, unsigned int nr)\n{\n\tstruct uni_screen *uniscr = get_vc_uniscr(vc);\n\tif (uniscr) {\n\t\tchar32_t *ln = uniscr->lines[vc->vc_y];\n\t\tunsigned int x = vc->vc_x, cols = vc->vc_cols;\n\t\tmemcpy(&ln[x], &ln[x + nr], (cols - x - nr) * sizeof(*ln));\n\t\tmemset32(&ln[cols - nr], ' ', nr);\n\t}\n}", "target": 0}
{"code": "    bool isPrivate() const { return is_private; }", "target": 0}
{"code": "BOOL update_recv(rdpUpdate* update, wStream* s)\n{\n\tBOOL rc = FALSE;\n\tUINT16 updateType;\n\trdpContext* context = update->context;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t{\n\t\tWLog_ERR(TAG, \"Stream_GetRemainingLength(s) < 2\");\n\t\treturn FALSE;\n\t}\n\tStream_Read_UINT16(s, updateType); \n\tWLog_Print(update->log, WLOG_TRACE, \"%s Update Data PDU\", UPDATE_TYPE_STRINGS[updateType]);\n\tif (!update_begin_paint(update))\n\t\tgoto fail;\n\tswitch (updateType)\n\t{\n\t\tcase UPDATE_TYPE_ORDERS:\n\t\t\trc = update_recv_orders(update, s);\n\t\t\tbreak;\n\t\tcase UPDATE_TYPE_BITMAP:\n\t\t{\n\t\t\tBITMAP_UPDATE* bitmap_update = update_read_bitmap_update(update, s);\n\t\t\tif (!bitmap_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_BITMAP - update_read_bitmap_update() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->BitmapUpdate, context, bitmap_update);\n\t\t\tfree_bitmap_update(update->context, bitmap_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_PALETTE:\n\t\t{\n\t\t\tPALETTE_UPDATE* palette_update = update_read_palette(update, s);\n\t\t\tif (!palette_update)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\nfail:\n\tif (!update_end_paint(update))\n\t\trc = FALSE;\n\tif (!rc)\n\t{\n\t\tWLog_ERR(TAG, \"UPDATE_TYPE %s [%\" PRIu16 \"] failed\", update_type_to_string(updateType),\n\t\t         updateType);\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "njs_vmcode_array(njs_vm_t *vm, u_char *pc)\n{\n    uint32_t            length;\n    njs_array_t         *array;\n    njs_value_t         *value;\n    njs_vmcode_array_t  *code;\n    code = (njs_vmcode_array_t *) pc;\n    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);\n    if (njs_fast_path(array != NULL)) {\n        if (code->ctor) {\n            value = array->start;\n            length = array->length;\n            do {\n                njs_set_invalid(value);\n                value++;\n                length--;\n            } while (length != 0);\n        } else {\n            array->length = 0;\n        }\n        njs_set_array(&vm->retval, array);\n        return sizeof(njs_vmcode_array_t);\n    }\n    return NJS_ERROR;\n}", "target": 1}
{"code": "ldns_str2rdf_str(ldns_rdf **rd, const char *str)\n{\n\tuint8_t *data, *dp, ch = 0;\n\tsize_t length;\n\tdp = data = LDNS_XMALLOC(uint8_t, strlen(str) > 255 ? 256 : (strlen(str) + 1));\n\tif (! data) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\twhile (parse_char(&ch, &str)) {\n\t\tif (dp - data >= 255) {\n\t\t\tLDNS_FREE(data);\n\t\t\treturn LDNS_STATUS_INVALID_STR;\n\t\t}\n\t\t*++dp = ch;\n\t}\n\tif (! str) {\n\t\treturn LDNS_STATUS_SYNTAX_BAD_ESCAPE;\n\t}\n\tlength = (size_t)(dp - data);\n\tdata[0] = (uint8_t)length;\n\tdata = LDNS_XREALLOC(dp = data, uint8_t, length + 1);\n\tif (! data) {\n\t\tLDNS_FREE(dp);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\t*rd = ldns_rdf_new(LDNS_RDF_TYPE_STR, length + 1, data);\n\tif (! *rd) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}", "target": 0}
{"code": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_urb(urb);\n\t\tgoto error;\n\t}\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < index->item_count; i++) {\n        int64_t time, offset;\n        if (avio_feof(f)) {\n            index->item_count = 0;\n            av_freep(&index->items);\n            return AVERROR_INVALIDDATA;\n        }\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}", "target": 0}
{"code": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu64 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\tseq = half_md4_transform(hash, keyptr->secret);\n\tseq |= ((u64)keyptr->count) << (32 - HASH_BITS);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 1}
{"code": "static int dump_seek(struct file *file, loff_t off)\n{\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (file->f_op->llseek(file, off, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t} else {\n\t\tchar *buf = (char *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn 0;\n\t\twhile (off > 0) {\n\t\t\tunsigned long n = off;\n\t\t\tif (n > PAGE_SIZE)\n\t\t\t\tn = PAGE_SIZE;\n\t\t\tif (!dump_write(file, buf, n))\n\t\t\t\treturn 0;\n\t\t\toff -= n;\n\t\t}\n\t\tfree_page((unsigned long)buf);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "lzw_result lzw_decode(struct lzw_ctx *ctx,\n\t\tconst uint8_t ** const stack_pos_out)\n{\n\tlzw_result res;\n\tuint32_t code_new;\n\tuint32_t code_out;\n\tuint8_t last_value;\n\tuint8_t *stack_pos = ctx->stack_base;\n\tuint32_t clear_code = ctx->clear_code;\n\tuint32_t current_entry = ctx->current_entry;\n\tstruct lzw_dictionary_entry * const table = ctx->table;\n\tres = lzw__next_code(&ctx->input, ctx->current_code_size, &code_new);\n\tif (res != LZW_OK) {\n\t\treturn res;\n\t}\n\tif (code_new == clear_code) {\n\t\treturn lzw__clear_codes(ctx, stack_pos_out);\n\t} else if (code_new == ctx->eoi_code) {\n\t\treturn LZW_EOI_CODE;\n\t} else if (code_new > current_entry) {\n\t\treturn LZW_BAD_CODE;\n\t} else if (code_new >= 1 << LZW_CODE_MAX) {\n\t\treturn LZW_BAD_CODE;\n\t} else if (code_new < current_entry) {\n\t\tcode_out = code_new;\n\t\tlast_value = table[code_new].first_value;\n\t} else {\n\t\t*stack_pos++ = ctx->previous_code_first;\n\t\tcode_out = ctx->previous_code;\n\t\tlast_value = ctx->previous_code_first;\n\t}\n\tif (current_entry < (1 << LZW_CODE_MAX)) {\n\t\tstruct lzw_dictionary_entry *entry = table + current_entry;\n\t\tentry->last_value     = last_value;\n\t\tentry->first_value    = ctx->previous_code_first;\n\t\tentry->previous_entry = ctx->previous_code;\n\t\tctx->current_entry++;\n\t}\n\tif (current_entry == ctx->current_code_size_max) {\n\t\tif (ctx->current_code_size < LZW_CODE_MAX) {\n\t\t\tctx->current_code_size++;\n\t\t\tctx->current_code_size_max =\n\t\t\t\t\t(1 << ctx->current_code_size) - 1;\n\t\t}\n\t}\n\tctx->previous_code_first = table[code_new].first_value;\n\tctx->previous_code = code_new;\n\twhile (code_out > clear_code) {\n\t\tstruct lzw_dictionary_entry *entry = table + code_out;\n\t\t*stack_pos++ = entry->last_value;\n\t\tcode_out = entry->previous_entry;\n\t}\n\t*stack_pos++ = table[code_out].last_value;\n\t*stack_pos_out = stack_pos;\n\treturn LZW_OK;\n}", "target": 0}
{"code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}", "target": 1}
{"code": "static int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tstruct ati_remote2 *ar2;\n\tint r;\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n\tar2->udev = udev;\n\tar2->intf[0] = interface;\n\tar2->ep[0] = &alt->endpoint[0].desc;\n\tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n\tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n\tif (r)\n\t\tgoto fail1;\n\talt = ar2->intf[1]->cur_altsetting;\n\tar2->ep[1] = &alt->endpoint[0].desc;\n\tr = ati_remote2_urb_init(ar2);\n\tif (r)\n\t\tgoto fail2;\n\tar2->channel_mask = channel_mask;\n\tar2->mode_mask = mode_mask;\n\tr = ati_remote2_setup(ar2, ar2->channel_mask);\n\tif (r)\n\t\tgoto fail2;\n\tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n\tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n\tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n\tif (r)\n\t\tgoto fail2;\n\tr = ati_remote2_input_init(ar2);\n\tif (r)\n\t\tgoto fail3;\n\tusb_set_intfdata(interface, ar2);\n\tinterface->needs_remote_wakeup = 1;\n\treturn 0;\n fail3:\n\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail2:\n\tati_remote2_urb_cleanup(ar2);\n\tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n fail1:\n\tkfree(ar2);\n\treturn r;\n}", "target": 1}
{"code": "_pdfioDictRead(pdfio_file_t   *pdf,\t\n               pdfio_obj_t    *obj,\t\n               _pdfio_token_t *tb,\t\n               size_t         depth)\t\n{\n  pdfio_dict_t\t\t*dict;\t\t\n  char\t\t\tkey[256];\t\n  _pdfio_value_t\tvalue;\t\t\n  PDFIO_DEBUG(\"_pdfioDictRead(pdf=%p)\\n\", pdf);\n  if ((dict = pdfioDictCreate(pdf)) == NULL)\n    return (NULL);\n  while (_pdfioTokenGet(tb, key, sizeof(key)))\n  {\n    if (!strcmp(key, \">>\"))\n    {\n      return (dict);\n    }\n    else if (key[0] != '/')\n    {\n      _pdfioFileError(pdf, \"Invalid dictionary contents.\");\n      break;\n    }\n    else if (_pdfioDictGetValue(dict, key + 1))\n    {\n      _pdfioFileError(pdf, \"Duplicate dictionary key '%s'.\", key + 1);\n      return (NULL);\n    }\n    PDFIO_DEBUG(\"_pdfioDictRead: Reading value for '%s'.\\n\", key + 1);\n    if (!_pdfioValueRead(pdf, obj, tb, &value, depth))\n    {\n      _pdfioFileError(pdf, \"Missing value for dictionary key.\");\n      break;\n    }\n    if (!_pdfioDictSetValue(dict, pdfioStringCreate(pdf, key + 1), &value))\n      break;\n  }\n  return (NULL);\n}", "target": 0}
{"code": "av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)\n{\n    av_freep(&s->buffer);\n}", "target": 1}
{"code": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}", "target": 1}
{"code": "create_new_keys(const char* jwkdir)\n{\n    const char* alg[] = {\"ES512\", \"ECMR\", NULL};\n    char path[PATH_MAX];\n    umask(0337);\n    for (int i = 0; alg[i] != NULL; i++) {\n        json_auto_t* jwk = jwk_generate(alg[i]);\n        if (!jwk) {\n            return 0;\n        }\n        __attribute__ ((__cleanup__(cleanup_str))) char* thp = jwk_thumbprint(jwk, DEFAULT_THP_HASH);\n        if (!thp) {\n            return 0;\n        }\n        if (snprintf(path, PATH_MAX, \"%s/%s.jwk\", jwkdir, thp) < 0) {\n            fprintf(stderr, \"Unable to prepare variable with file full path (%s)\\n\", thp);\n            return 0;\n        }\n        path[sizeof(path) - 1] = '\\0';\n        if (json_dump_file(jwk, path, 0) == -1) {\n            fprintf(stderr, \"Error saving JWK to file (%s)\\n\", path);\n            return 0;\n        }\n        if (chmod(path, S_IRUSR | S_IRGRP) == -1) {\n            fprintf(stderr, \"Unable to set permissions for JWK file (%s)\\n\", path);\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "callbacks_screen2board(gdouble *X, gdouble *Y, gint x, gint y) {\n\tif ((screenRenderInfo.scaleFactorX > 0.001)||(screenRenderInfo.scaleFactorY > 0.001)) {\n\t\t*X = screenRenderInfo.lowerLeftX + (x / screenRenderInfo.scaleFactorX);\n\t\t*Y = screenRenderInfo.lowerLeftY + ((screenRenderInfo.displayHeight - y)\n\t\t\t/ screenRenderInfo.scaleFactorY);\n\t}\n\telse {\n\t\t*X = *Y = 0.0;\n\t}\n}", "target": 0}
{"code": "MagickExport MagickBooleanType DrawClipPath(Image *image,\n  const DrawInfo *draw_info,const char *name,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n  Image\n    *clip_mask;\n  const char\n    *value;\n  DrawInfo\n    *clone_info;\n  MagickStatusType\n    status;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(draw_info != (const DrawInfo *) NULL);\n  (void) FormatLocaleString(filename,MagickPathExtent,\"%s\",name);\n  value=GetImageArtifact(image,filename);\n  if (value == (const char *) NULL)\n    return(MagickFalse);\n  clip_mask=CloneImage(image,image->columns,image->rows,MagickTrue,exception);\n  if (clip_mask == (Image *) NULL)\n    return(MagickFalse);\n  (void) QueryColorCompliance(\"#0000\",AllCompliance,\n    &clip_mask->background_color,exception);\n  clip_mask->background_color.alpha=(Quantum) TransparentAlpha;\n  (void) SetImageBackgroundColor(clip_mask,exception);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"\\nbegin clip-path %s\",\n      draw_info->clip_mask);\n  clone_info=CloneDrawInfo((ImageInfo *) NULL,draw_info);\n  (void) CloneString(&clone_info->primitive,value);\n  (void) QueryColorCompliance(\"#ffffff\",AllCompliance,&clone_info->fill,\n    exception);\n  clone_info->clip_mask=(char *) NULL;\n  status=NegateImage(clip_mask,MagickFalse,exception);\n  (void) SetImageMask(image,ReadPixelMask,clip_mask,exception);\n  clip_mask=DestroyImage(clip_mask);\n  status&=DrawImage(image,clone_info,exception);\n  clone_info=DestroyDrawInfo(clone_info);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(DrawEvent,GetMagickModule(),\"end clip-path\");\n  return(status != 0 ? MagickTrue : MagickFalse);\n}", "target": 1}
{"code": "void ewk_view_scrollbars_visible_get(Evas_Object* ewkView, bool* visible)\n{\n    DBG(\"%s, o=%p\", __func__, ewkView);\n    *visible = false;\n    evas_object_smart_callback_call(ewkView, \"scrollbars,visible,get\", visible);\n}", "target": 0}
{"code": "inline typename V::MapType FBUnserializer<V>::unserializeMap() {\n  p_ += CODE_SIZE;\n  typename V::MapType ret = V::createMap();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    switch (code) {\n      case FB_SERIALIZE_VARCHAR:\n      case FB_SERIALIZE_STRING:\n        {\n          auto key = unserializeString();\n          auto value = unserializeThing();\n          V::mapSet(ret, std::move(key), std::move(value));\n        }\n        break;\n      default:\n        {\n          auto key = unserializeInt64();\n          auto value = unserializeThing();\n          V::mapSet(ret, std::move(key), std::move(value));\n        }\n    }\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "void RootWindow::OnWindowBoundsChanged(Window* window,\n                                       bool contained_mouse_point) {\n  if (contained_mouse_point ||\n      (window->IsVisible() &&\n       window->ContainsPointInRoot(last_mouse_location_))) {\n    PostMouseMoveEventAfterWindowChange();\n  }\n}", "target": 0}
{"code": "void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t\t\t&req->request, req->direction);\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\tspin_unlock(&dwc->lock);\n\tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n\tspin_lock(&dwc->lock);\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}", "target": 1}
{"code": "static tjhandle _tjInitDecompress(tjinstance *this)\n{\n\tstatic unsigned char buffer[1];\n\tthis->dinfo.err=jpeg_std_error(&this->jerr.pub);\n\tthis->jerr.pub.error_exit=my_error_exit;\n\tthis->jerr.pub.output_message=my_output_message;\n\tthis->jerr.emit_message=this->jerr.pub.emit_message;\n\tthis->jerr.pub.emit_message=my_emit_message;\n\tif(setjmp(this->jerr.setjmp_buffer))\n\t{\n\t\tif(this) free(this);\n\t\treturn NULL;\n\t}\n\tjpeg_create_decompress(&this->dinfo);\n\tjpeg_mem_src_tj(&this->dinfo, buffer, 1);\n\tthis->init|=DECOMPRESS;\n\treturn (tjhandle)this;\n}", "target": 0}
{"code": "snmp_oid_print(uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  LOG_DBG(\"{\");\n  while(oid[i] != ((uint32_t)-1)) {\n    LOG_DBG_(\"%lu\", (unsigned long)oid[i]);\n    i++;\n    if(oid[i] != ((uint32_t)-1)) {\n      LOG_DBG_(\".\");\n    }\n  }\n  LOG_DBG_(\"}\\n\");\n}", "target": 1}
{"code": "GF_EXPORT\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *file, s64 byte_offset)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->read_byte_offset = byte_offset;\n\treturn GF_OK;", "target": 0}
{"code": "pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)\n{\n\tint error;\n\tstruct pci_emul_dummy *dummy;\n\tdummy = calloc(1, sizeof(struct pci_emul_dummy));\n\tdev->arg = dummy;\n\tpci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001);\n\tpci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD);\n\tpci_set_cfgdata8(dev, PCIR_CLASS, 0x02);\n\terror = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\treturn 0;\n}", "target": 1}
{"code": "static ssize_t process_output_block(struct tty_struct *tty,\n\t\t\t\t    const unsigned char *buf, unsigned int nr)\n{\n\tstruct n_tty_data *ldata = tty->disc_data;\n\tint\tspace;\n\tint\ti;\n\tconst unsigned char *cp;\n\tmutex_lock(&ldata->output_lock);\n\tspace = tty_write_room(tty);\n\tif (!space) {\n\t\tmutex_unlock(&ldata->output_lock);\n\t\treturn 0;\n\t}\n\tif (nr > space)\n\t\tnr = space;\n\tfor (i = 0, cp = buf; i < nr; i++, cp++) {\n\t\tunsigned char c = *cp;\n\t\tswitch (c) {\n\t\tcase '\\n':\n\t\t\tif (O_ONLRET(tty))\n\t\t\t\tldata->column = 0;\n\t\t\tif (O_ONLCR(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column;\n\t\t\tbreak;\n\t\tcase '\\r':\n\t\t\tif (O_ONOCR(tty) && ldata->column == 0)\n\t\t\t\tgoto break_out;\n\t\t\tif (O_OCRNL(tty))\n\t\t\t\tgoto break_out;\n\t\t\tldata->canon_column = ldata->column = 0;\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tgoto break_out;\n\t\tcase '\\b':\n\t\t\tif (ldata->column > 0)\n\t\t\t\tldata->column--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!iscntrl(c)) {\n\t\t\t\tif (O_OLCUC(tty))\n\t\t\t\t\tgoto break_out;\n\t\t\t\tif (!is_continuation(c, tty))\n\t\t\t\t\tldata->column++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nbreak_out:\n\ti = tty->ops->write(tty, buf, i);\n\tmutex_unlock(&ldata->output_lock);\n\treturn i;\n}", "target": 0}
{"code": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}", "target": 1}
{"code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "kex_input_kexinit(int type, u_int32_t seq, void *ctxt)\n{\n\tstruct ssh *ssh = ctxt;\n\tstruct kex *kex = ssh->kex;\n\tconst u_char *ptr;\n\tu_int i;\n\tsize_t dlen;\n\tint r;\n\tdebug(\"SSH2_MSG_KEXINIT received\");\n\tif (kex == NULL)\n\t\treturn SSH_ERR_INVALID_ARGUMENT;\n\tssh_dispatch_set(ssh, SSH2_MSG_KEXINIT, NULL);\n\tptr = sshpkt_ptr(ssh, &dlen);\n\tif ((r = sshbuf_put(kex->peer, ptr, dlen)) != 0)\n\t\treturn r;\n\tfor (i = 0; i < KEX_COOKIE_LEN; i++)\n\t\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0)\n\t\t\treturn r;\n\tfor (i = 0; i < PROPOSAL_MAX; i++)\n\t\tif ((r = sshpkt_get_string(ssh, NULL, NULL)) != 0)\n\t\t\treturn r;\n\tif ((r = sshpkt_get_u8(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_u32(ssh, NULL)) != 0 ||\t\n\t    (r = sshpkt_get_end(ssh)) != 0)\n\t\t\treturn r;\n\tif (!(kex->flags & KEX_INIT_SENT))\n\t\tif ((r = kex_send_kexinit(ssh)) != 0)\n\t\t\treturn r;\n\tif ((r = kex_choose_conf(ssh)) != 0)\n\t\treturn r;\n\tif (kex->kex_type < KEX_MAX && kex->kex[kex->kex_type] != NULL)\n\t\treturn (kex->kex[kex->kex_type])(ssh);\n\treturn SSH_ERR_INTERNAL_ERROR;\n}", "target": 0}
{"code": "void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}", "target": 1}
{"code": "static int mpls_dev_sysctl_register(struct net_device *dev,\n\t\t\t\t    struct mpls_dev *mdev)\n{\n\tchar path[sizeof(\"net/mpls/conf/\") + IFNAMSIZ];\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tint i;\n\ttable = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\tfor (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++) {\n\t\ttable[i].data = (char *)mdev + (uintptr_t)table[i].data;\n\t\ttable[i].extra1 = mdev;\n\t\ttable[i].extra2 = net;\n\t}\n\tsnprintf(path, sizeof(path), \"net/mpls/conf/%s\", dev->name);\n\tmdev->sysctl = register_net_sysctl(net, path, table);\n\tif (!mdev->sysctl)\n\t\tgoto free;\n\tmpls_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL, mdev);\n\treturn 0;\nfree:\n\tkfree(table);\nout:\n\tmdev->sysctl = NULL;\n\treturn -ENOBUFS;\n}", "target": 0}
{"code": "int khugepaged_enter_vma_merge(struct vm_area_struct *vma)\n{\n\tunsigned long hstart, hend;\n\tif (!vma->anon_vma)\n\t\treturn 0;\n\tif (vma->vm_file || vma->vm_ops)\n\t\treturn 0;\n\tVM_BUG_ON(is_linear_pfn_mapping(vma) || is_pfn_mapping(vma));\n\thstart = (vma->vm_start + ~HPAGE_PMD_MASK) & HPAGE_PMD_MASK;\n\thend = vma->vm_end & HPAGE_PMD_MASK;\n\tif (hstart < hend)\n\t\treturn khugepaged_enter(vma);\n\treturn 0;\n}", "target": 1}
{"code": "int hugetlb_reserve_pages(struct inode *inode,\n\t\t\t\t\tlong from, long to,\n\t\t\t\t\tstruct vm_area_struct *vma,\n\t\t\t\t\tvm_flags_t vm_flags)\n{\n\tlong ret, chg;\n\tstruct hstate *h = hstate_inode(inode);\n\tstruct hugepage_subpool *spool = subpool_inode(inode);\n\tif (vm_flags & VM_NORESERVE)\n\t\treturn 0;\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tchg = region_chg(&inode->i_mapping->private_list, from, to);\n\telse {\n\t\tstruct resv_map *resv_map = resv_map_alloc();\n\t\tif (!resv_map)\n\t\t\treturn -ENOMEM;\n\t\tchg = to - from;\n\t\tset_vma_resv_map(vma, resv_map);\n\t\tset_vma_resv_flags(vma, HPAGE_RESV_OWNER);\n\t}\n\tif (chg < 0) {\n\t\tret = chg;\n\t\tgoto out_err;\n\t}\n\tif (hugepage_subpool_get_pages(spool, chg)) {\n\t\tret = -ENOSPC;\n\t\tgoto out_err;\n\t}\n\tret = hugetlb_acct_memory(h, chg);\n\tif (ret < 0) {\n\t\thugepage_subpool_put_pages(spool, chg);\n\t\tgoto out_err;\n\t}\n\tif (!vma || vma->vm_flags & VM_MAYSHARE)\n\t\tregion_add(&inode->i_mapping->private_list, from, to);\n\treturn 0;\nout_err:\n\tresv_map_put(vma);\n\treturn ret;\n}", "target": 0}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tapply_proxy_config(t);\n\terror = git_stream_connect(t->io);\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n#endif\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\treturn link->doit(skb, nlh, attrs);\n}", "target": 0}
{"code": "IW_IMPL(unsigned int) iw_get_ui16be(const iw_byte *b)\n{\n\treturn (b[0]<<8) | b[1];\n}", "target": 1}
{"code": "    Iptcdatum& Iptcdatum::operator=(const Iptcdatum& rhs)\n    {\n        if (this == &rhs) return *this;\n        Metadatum::operator=(rhs);\n        key_.reset();\n        if (rhs.key_.get() != 0) key_ = rhs.key_->clone(); \n        value_.reset();\n        if (rhs.value_.get() != 0) value_ = rhs.value_->clone(); \n        return *this;\n    } ", "target": 0}
{"code": "unsigned long get_pfnblock_flags_mask(struct page *page, unsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, end_bitidx, mask);\n}", "target": 0}
{"code": "  friend bool operator==(const TensorKey& t1, const TensorKey& t2) {\n    if (t1.dtype() != t2.dtype() || t1.shape() != t2.shape()) {\n      return false;\n    }\n    if (DataTypeCanUseMemcpy(t1.dtype())) {\n      return t1.tensor_data() == t2.tensor_data();\n    }\n    if (t1.dtype() == DT_STRING) {\n      const auto s1 = t1.unaligned_flat<tstring>();\n      const auto s2 = t2.unaligned_flat<tstring>();\n      for (int64_t i = 0, n = t1.NumElements(); i < n; ++i) {\n        if (TF_PREDICT_FALSE(s1(i) != s2(i))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }", "target": 1}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if(length == SIZE_MAX || length > INT_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 0}
{"code": "static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  if ((p->stop & 4)) {\n    p->stop ^= 4;\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}", "target": 1}
{"code": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n\t    EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "void sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){\n  assert( bFree==0 || (pParse->pWith==0 && pParse->pWithToFree==0) );\n  if( pWith ){\n    assert( pParse->pWith!=pWith );\n    pWith->pOuter = pParse->pWith;\n    pParse->pWith = pWith;\n    if( bFree ) pParse->pWithToFree = pWith;\n  }\n}", "target": 0}
{"code": "static bool allowed_problem_dir(const char *dir_name)\n{\n#if 0\n    unsigned len = strlen(g_settings_dump_location);\n    if (strncmp(dir_name, g_settings_dump_location, len) != 0\n     || (dir_name[len] != '/' && dir_name[len] != '\\0')\n     || strstr(dir_name + len, \"/.\")\n    ) {\n        return false;\n    }\n#endif\n    return true;\n}", "target": 1}
{"code": "static int skcipher_setkey_unaligned(struct crypto_skcipher *tfm,\n\t\t\t\t     const u8 *key, unsigned int keylen)\n{\n\tunsigned long alignmask = crypto_skcipher_alignmask(tfm);\n\tstruct skcipher_alg *cipher = crypto_skcipher_alg(tfm);\n\tu8 *buffer, *alignbuffer;\n\tunsigned long absize;\n\tint ret;\n\tabsize = keylen + alignmask;\n\tbuffer = kmalloc(absize, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\talignbuffer = (u8 *)ALIGN((unsigned long)buffer, alignmask + 1);\n\tmemcpy(alignbuffer, key, keylen);\n\tret = cipher->setkey(tfm, alignbuffer, keylen);\n\tkzfree(buffer);\n\treturn ret;\n}", "target": 0}
{"code": "ApplyChannelMatrix::~ApplyChannelMatrix()\n{\n\tdelete [] m_matrix;\n}", "target": 0}
{"code": "Status genTableRowsForSqliteTable(const fs::path& sqlite_db,\n                                  const std::string& sqlite_query,\n                                  TableRows& results,\n                                  bool respect_locking) {\n  sqlite3* db = nullptr;\n  if (!pathExists(sqlite_db).ok()) {\n    return Status(1, \"Database path does not exist\");\n  }\n  auto rc = sqlite3_open_v2(\n      sqlite_db.string().c_str(),\n      &db,\n      (SQLITE_OPEN_READONLY | SQLITE_OPEN_PRIVATECACHE | SQLITE_OPEN_NOMUTEX),\n      getSystemVFS(respect_locking));\n  if (rc != SQLITE_OK || db == nullptr) {\n    VLOG(1) << \"Cannot open specified database: \"\n            << getStringForSQLiteReturnCode(rc);\n    if (db != nullptr) {\n      sqlite3_close(db);\n    }\n    return Status(1, \"Could not open database\");\n  }\n  rc = sqlite3_set_authorizer(db, &sqliteAuthorizer, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    auto errMsg =\n        std::string(\"Failed to set sqlite authorizer: \") + sqlite3_errmsg(db);\n    return Status(1, errMsg);\n  }\n  sqlite3_stmt* stmt = nullptr;\n  rc = sqlite3_prepare_v2(db, sqlite_query.c_str(), -1, &stmt, nullptr);\n  if (rc != SQLITE_OK) {\n    sqlite3_close(db);\n    VLOG(1) << \"ATC table: Could not prepare database at path: \" << sqlite_db;\n    return Status(rc, \"Could not prepare database\");\n  }\n  while ((sqlite3_step(stmt)) == SQLITE_ROW) {\n    auto s = genSqliteTableRow(stmt, results, sqlite_db);\n    if (!s.ok()) {\n      break;\n    }\n  }\n  sqlite3_finalize(stmt);\n  sqlite3_close(db);\n  return Status{};\n}", "target": 0}
{"code": "static int __init snd_mem_init(void)\n{\n#ifdef CONFIG_PROC_FS\n\tsnd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);\n\tif (snd_mem_proc)\n\t\tsnd_mem_proc->proc_fops = &snd_mem_proc_fops;\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "void hsr_del_node(struct list_head *self_node_db)\n{\n\tstruct hsr_node *node;\n\trcu_read_lock();\n\tnode = list_first_or_null_rcu(self_node_db, struct hsr_node, mac_list);\n\trcu_read_unlock();\n\tif (node) {\n\t\tlist_del_rcu(&node->mac_list);\n\t\tkfree(node);\n\t}\n}", "target": 0}
{"code": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    sys->free(lzx->inbuf);\n    sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}", "target": 1}
{"code": "static int muscle_delete_file(sc_card_t *card, const sc_path_t *path_in)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmscfs_file_t *file_data = NULL;\n\tint r = 0;\n\tr = mscfs_loadFileInfo(fs, path_in->value, path_in->len, &file_data, NULL);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\tr = muscle_delete_mscfs_file(card, file_data);\n\tmscfs_clear_cache(fs);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\treturn 0;\n}", "target": 0}
{"code": "static int append_session_tasks_max(pam_handle_t *handle, sd_bus_message *m, const char *limit) {\n        uint64_t val;\n        int r;\n        if (isempty(limit) || streq(limit, \"infinity\"))\n                return 0;\n        r = safe_atou64(limit, &val);\n        if (r >= 0) {\n                r = sd_bus_message_append(m, \"(sv)\", \"TasksMax\", \"t\", val);\n                if (r < 0) {\n                        pam_syslog(handle, LOG_ERR, \"Failed to append to bus message: %s\", strerror(-r));\n                        return r;\n                }\n        } else\n                pam_syslog(handle, LOG_WARNING, \"Failed to parse systemd.limit: %s, ignoring.\", limit);\n        return 0;\n}", "target": 0}
{"code": "std::wstring Utf8ToUtf16(const std::string& utf8_string) {\n  return MB2WC(utf8_string, CP_UTF8);\n}", "target": 1}
{"code": "static struct sk_buff **sit_gro_receive(struct sk_buff **head,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\treturn ipv6_gro_receive(head, skb);\n}", "target": 0}
{"code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context,\n                          const TfLiteEvalTensor* params,\n                          const TfLiteEvalTensor* indices,\n                          TfLiteEvalTensor* output) {\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n      break;\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Params type '%s' are not supported by gather_nd.\",\n                         TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct hidp_connadd_req ca;\n\tstruct hidp_conndel_req cd;\n\tstruct hidp_connlist_req cl;\n\tstruct hidp_conninfo ci;\n\tstruct socket *csock;\n\tstruct socket *isock;\n\tint err;\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\tswitch (cmd) {\n\tcase HIDPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n\t\t\tsockfd_put(csock);\n\t\t\treturn err;\n\t\t}\n\t\tca.name[sizeof(ca.name)-1] = 0;\n\t\terr = hidp_connection_add(&ca, csock, isock);\n\t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\terr = -EFAULT;\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\t\treturn err;\n\tcase HIDPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn hidp_connection_del(&cd);\n\tcase HIDPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = hidp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase HIDPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = hidp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "int nego_recv(rdpTransport* transport, wStream* s, void* extra)\n{\n\tBYTE li;\n\tBYTE type;\n\tUINT16 length;\n\trdpNego* nego = (rdpNego*)extra;\n\tif (!tpkt_read_header(s, &length))\n\t\treturn -1;\n\tif (!tpdu_read_connection_confirm(s, &li, length))\n\t\treturn -1;\n\tif (li > 6)\n\t{\n\t\tStream_Read_UINT8(s, type); \n\t\tswitch (type)\n\t\t{\n\t\t\tcase TYPE_RDP_NEG_RSP:\n\t\t\t\tnego_process_negotiation_response(nego, s);\n\t\t\t\tWLog_DBG(TAG, \"selected_protocol: %\" PRIu32 \"\", nego->SelectedProtocol);\n\t\t\t\tif (nego->SelectedProtocol)\n\t\t\t\t{\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_HYBRID) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_HYBRID]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t\tif ((nego->SelectedProtocol == PROTOCOL_SSL) &&\n\t\t\t\t\t    (!nego->EnabledProtocols[PROTOCOL_SSL]))\n\t\t\t\t\t{\n\t\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\t\t{\n\t\t\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase TYPE_RDP_NEG_FAILURE:\n\t\t\t\tnego_process_negotiation_failure(nego, s);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\telse if (li == 6)\n\t{\n\t\tWLog_DBG(TAG, \"no rdpNegData\");\n\t\tif (!nego->EnabledProtocols[PROTOCOL_RDP])\n\t\t\tnego->state = NEGO_STATE_FAIL;\n\t\telse\n\t\t\tnego->state = NEGO_STATE_FINAL;\n\t}\n\telse\n\t{\n\t\tWLog_ERR(TAG, \"invalid negotiation response\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t}\n\tif (!tpkt_ensure_stream_consumed(s, length))\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "void nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settings &ext)\n{\n    std::string &remark = node.Remark, original_remark = node.Remark, returned_remark, real_rule;\n    for(const RegexMatchConfig &x : rename_array)\n    {\n        if(!x.Script.empty())\n        {\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto rename = (std::function<std::string(const Proxy&)>) ctx.eval(\"rename\");\n                    returned_remark = rename(node);\n                    if(!returned_remark.empty())\n                        remark = returned_remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            continue;\n        }\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size())\n            remark = regReplace(remark, real_rule, x.Replace);\n    }\n    if(remark.empty())\n        remark = original_remark;\n    return;\n}", "target": 1}
{"code": "\tclass BadDistanceErr : public Err {public: BadDistanceErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in bit distance\") {}};", "target": 0}
{"code": "snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned char *out, uint32_t *out_len)\n{\n  static snmp_header_t header;\n  static snmp_varbind_t varbinds[SNMP_MAX_NR_VALUES];\n  static uint32_t varbind_length = SNMP_MAX_NR_VALUES;\n  buff = snmp_message_decode(buff, buff_len, &header, varbinds, &varbind_length);\n  if(buff == NULL) {\n    return NULL;\n  }\n  if(header.version != SNMP_VERSION_1) {\n    if(strncmp(header.community.community, SNMP_COMMUNITY, header.community.length)) {\n      LOG_ERR(\"Request with invalid community\\n\");\n      return NULL;\n    }\n  }\n  switch(header.pdu_type) {\n  case SNMP_DATA_TYPE_PDU_GET_REQUEST:\n    if(snmp_engine_get(&header, varbinds, varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  case SNMP_DATA_TYPE_PDU_GET_NEXT_REQUEST:\n    if(snmp_engine_get_next(&header, varbinds, varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  case SNMP_DATA_TYPE_PDU_GET_BULK:\n    if(snmp_engine_get_bulk(&header, varbinds, &varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  default:\n    LOG_ERR(\"Invalid request type\");\n    return NULL;\n  }\n  header.pdu_type = SNMP_DATA_TYPE_PDU_GET_RESPONSE;\n  out = snmp_message_encode(out, out_len, &header, varbinds, varbind_length);\n  return ++out;\n}", "target": 1}
{"code": "test_save_copy (const char *origname)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", origname, TEST_COPY_FILE);\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tint count, i;\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "static void xml_parser_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n{\n\txml_parser *parser = (xml_parser *)rsrc->ptr;\n\tif (parser->parser) {\n\t\tXML_ParserFree(parser->parser);\n\t}\n\tif (parser->ltags) {\n\t\tint inx;\n\t\tfor (inx = 0; ((inx < parser->level) && (inx < XML_MAXLEVEL)); inx++)\n\t\t\tefree(parser->ltags[ inx ]);\n\t\tefree(parser->ltags);\n\t}\n\tif (parser->startElementHandler) {\n\t\tzval_ptr_dtor(&parser->startElementHandler);\n\t}\n\tif (parser->endElementHandler) {\n\t\tzval_ptr_dtor(&parser->endElementHandler);\n\t}\n\tif (parser->characterDataHandler) {\n\t\tzval_ptr_dtor(&parser->characterDataHandler);\n\t}\n\tif (parser->processingInstructionHandler) {\n\t\tzval_ptr_dtor(&parser->processingInstructionHandler);\n\t}\n\tif (parser->defaultHandler) {\n\t\tzval_ptr_dtor(&parser->defaultHandler);\n\t}\n\tif (parser->unparsedEntityDeclHandler) {\n\t\tzval_ptr_dtor(&parser->unparsedEntityDeclHandler);\n\t}\n\tif (parser->notationDeclHandler) {\n\t\tzval_ptr_dtor(&parser->notationDeclHandler);\n\t}\n\tif (parser->externalEntityRefHandler) {\n\t\tzval_ptr_dtor(&parser->externalEntityRefHandler);\n\t}\n\tif (parser->unknownEncodingHandler) {\n\t\tzval_ptr_dtor(&parser->unknownEncodingHandler);\n\t}\n\tif (parser->startNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->startNamespaceDeclHandler);\n\t}\n\tif (parser->endNamespaceDeclHandler) {\n\t\tzval_ptr_dtor(&parser->endNamespaceDeclHandler);\n\t}\n\tif (parser->baseURI) {\n\t\tefree(parser->baseURI);\n\t}\n\tif (parser->object) {\n\t\tzval_ptr_dtor(&parser->object);\n\t}\n\tefree(parser);\n}", "target": 0}
{"code": "nl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[IEEE80211_NUM_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}", "target": 0}
{"code": "  virtual bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "int multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) \n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}", "target": 0}
{"code": "file_pop_buffer(struct magic_set *ms, file_pushbuf_t *pb)\n{\n\tchar *rbuf;\n\tif (ms->event_flags & EVENT_HAD_ERR) {\n\t\tfree(pb->buf);\n\t\tfree(pb);\n\t\treturn NULL;\n\t}\n\trbuf = ms->o.buf;\n\tms->o.buf = pb->buf;\n\tms->offset = pb->offset;\n\tfree(pb);\n\treturn rbuf;\n}", "target": 0}
{"code": "REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,\n                                          const quicklistNode *b,\n                                          const int fill) {\n    if (!a || !b)\n        return 0;\n    unsigned int merge_sz = a->sz + b->sz - 11;\n    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(merge_sz, fill)))\n        return 1;\n    else if (!sizeMeetsSafetyLimit(merge_sz))\n        return 0;\n    else if ((int)(a->count + b->count) <= fill)\n        return 1;\n    else\n        return 0;\n}", "target": 0}
{"code": "void ResourceHandle::FromProto(const ResourceHandleProto& proto) {\n  set_device(proto.device());\n  set_container(proto.container());\n  set_name(proto.name());\n  set_hash_code(proto.hash_code());\n  set_maybe_type_name(proto.maybe_type_name());\n  std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes;\n  for (const auto& dtype_and_shape : proto.dtypes_and_shapes()) {\n    DataType dtype = dtype_and_shape.dtype();\n    PartialTensorShape shape(dtype_and_shape.shape());\n    dtypes_and_shapes.push_back(DtypeAndPartialTensorShape{dtype, shape});\n  }\n  dtypes_and_shapes_ = std::move(dtypes_and_shapes);\n}", "target": 1}
{"code": "    TiffIfdMakernote::TiffIfdMakernote(uint16_t  tag,\n                                       IfdId     group,\n                                       IfdId     mnGroup,\n                                       MnHeader* pHeader,\n                                       bool      hasNext)\n        : TiffComponent(tag, group),\n          pHeader_(pHeader),\n          ifd_(tag, mnGroup, hasNext),\n          mnOffset_(0),\n          imageByteOrder_(invalidByteOrder)\n    {\n    }", "target": 0}
{"code": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}", "target": 1}
{"code": "cib_send_tls(gnutls_session * session, xmlNode * msg)\n{\n    char *xml_text = NULL;\n#  if 0\n    const char *name = crm_element_name(msg);\n    if (safe_str_neq(name, \"cib_command\")) {\n        xmlNodeSetName(msg, \"cib_result\");\n    }\n#  endif\n    xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        int rc = 0;\n        len++;                  \n        crm_trace(\"Message size: %d\", len);\n        while (TRUE) {\n            rc = gnutls_record_send(*session, unsent, len);\n            crm_debug(\"Sent %d bytes\", rc);\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n                crm_debug(\"Retry\");\n            } else if (rc < 0) {\n                crm_debug(\"Connection terminated\");\n                break;\n            } else if (rc < len) {\n                crm_debug(\"Only sent %d of %d bytes\", rc, len);\n                len -= rc;\n                unsent += rc;\n            } else {\n                break;\n            }\n        }\n    }\n    free(xml_text);\n    return NULL;\n}", "target": 1}
{"code": "process_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\tdebug2_f(\"entering\");\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}", "target": 1}
{"code": "string_copy(uschar *s)\n{\nint len = Ustrlen(s) + 1;\nuschar *ss = store_get(len);\nmemcpy(ss, s, len);\nreturn ss;\n}", "target": 0}
{"code": "    template<typename tc>\n    CImg<T>& draw_circle(const int x0, const int y0, int radius,\n                         const tc *const color, const float opacity=1) {\n      if (is_empty()) return *this;\n      if (!color)\n        throw CImgArgumentException(_cimg_instance\n                                    \"draw_circle(): Specified color is (null).\",\n                                    cimg_instance);\n      cimg_init_scanline(color,opacity);\n      if (radius<0 || x0 - radius>=width() || y0 + radius<0 || y0 - radius>=height()) return *this;\n      if (y0>=0 && y0<height()) cimg_draw_scanline(x0 - radius,x0 + radius,y0,color,opacity,1);\n      for (int f = 1 - radius, ddFx = 0, ddFy = -(radius<<1), x = 0, y = radius; x<y; ) {\n        if (f>=0) {\n          const int x1 = x0 - x, x2 = x0 + x, y1 = y0 - y, y2 = y0 + y;\n          if (y1>=0 && y1<height()) cimg_draw_scanline(x1,x2,y1,color,opacity,1);\n          if (y2>=0 && y2<height()) cimg_draw_scanline(x1,x2,y2,color,opacity,1);\n          f+=(ddFy+=2); --y;\n        }\n        const bool no_diag = y!=(x++);\n        ++(f+=(ddFx+=2));\n        const int x1 = x0 - y, x2 = x0 + y, y1 = y0 - x, y2 = y0 + x;\n        if (no_diag) {\n          if (y1>=0 && y1<height()) cimg_draw_scanline(x1,x2,y1,color,opacity,1);\n          if (y2>=0 && y2<height()) cimg_draw_scanline(x1,x2,y2,color,opacity,1);\n        }\n      }\n      return *this;", "target": 0}
{"code": "  static Status Compute(OpKernelContext* context,\n                        const typename TTypes<T, 1>::ConstTensor& values,\n                        const typename TTypes<T, 1>::ConstTensor& value_range,\n                        int32_t nbins, typename TTypes<Tout, 1>::Tensor& out) {\n    const CPUDevice& d = context->eigen_device<CPUDevice>();\n    Tensor index_to_bin_tensor;\n    TF_RETURN_IF_ERROR(context->forward_input_or_allocate_temp(\n        {0}, DataTypeToEnum<int32>::value, TensorShape({values.size()}),\n        &index_to_bin_tensor));\n    auto index_to_bin = index_to_bin_tensor.flat<int32>();\n    const double step = static_cast<double>(value_range(1) - value_range(0)) /\n                        static_cast<double>(nbins);\n    const double nbins_minus_1 = static_cast<double>(nbins - 1);\n    const Eigen::Tensor<int32, 1, 1> nans_tensor =\n        values.isnan().template cast<int32>();\n    const Eigen::Tensor<int32, 0, 1> reduced_tensor = nans_tensor.sum();\n    const int num_nans = reduced_tensor(0);\n    if (num_nans > 0) {\n      return errors::InvalidArgument(\"Histogram values must not contain NaN\");\n    }\n    index_to_bin.device(d) =\n        ((values.cwiseMax(value_range(0)) - values.constant(value_range(0)))\n             .template cast<double>() /\n         step)\n            .cwiseMin(nbins_minus_1)\n            .template cast<int32>();\n    out.setZero();\n    for (int32_t i = 0; i < index_to_bin.size(); i++) {\n      out(index_to_bin(i)) += Tout(1);\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& prefix = context->input(0);\n    const Tensor& tensor_names = context->input(1);\n    const Tensor& shape_and_slices = context->input(2);\n    OP_REQUIRES(context, tensor_names.NumElements() == dtypes_.size(),\n                errors::InvalidArgument(\"Got \", tensor_names.NumElements(),\n                                        \" tensor names, but \", dtypes_.size(),\n                                        \" expected dtypes.\"));\n    ValidateInputs(false , context, prefix, tensor_names,\n                   shape_and_slices);\n    if (!context->status().ok()) return;\n    const string& prefix_string = prefix.scalar<tstring>()();\n    Env* env = Env::Default();\n    std::vector<string> paths;\n    if (!env->GetMatchingPaths(MetaFilename(prefix_string), &paths).ok() ||\n        paths.empty()) {\n      for (size_t i = 0; i < tensor_names.NumElements(); ++i) {\n        RestoreTensor(context, &checkpoint::OpenTableTensorSliceReader,\n                       -1,  true,\n                       i);\n        if (!context->status().ok()) {\n          return;\n        }\n      }\n      return;\n    }\n    OP_REQUIRES_OK(context, RestoreTensorsV2(context, prefix, tensor_names,\n                                             shape_and_slices, dtypes_));\n  }", "target": 0}
{"code": "void nego_process_negotiation_response(rdpNego* nego, wStream* s)\n{\n\tUINT16 length;\n\tWLog_DBG(TAG, \"RDP_NEG_RSP\");\n\tif (Stream_GetRemainingLength(s) < 7)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid RDP_NEG_RSP\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\tStream_Read_UINT8(s, nego->flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->SelectedProtocol);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "guestfs___first_line_of_file (guestfs_h *g, const char *filename)\n{\n  CLEANUP_FREE char **lines = NULL; \n  int64_t size;\n  char *ret;\n  size = guestfs_filesize (g, filename);\n  if (size == -1)\n    return NULL;\n  if (size > MAX_SMALL_FILE_SIZE) {\n    error (g, _(\"size of %s is unreasonably large (%\" PRIi64 \" bytes)\"),\n           filename, size);\n    return NULL;\n  }\n  lines = guestfs_head_n (g, 1, filename);\n  if (lines == NULL)\n    return NULL;\n  if (lines[0] == NULL) {\n    guestfs___free_string_list (lines);\n    return safe_strdup (g, \"\");\n  }\n  ret = lines[0];               \n  return ret;\n}", "target": 1}
{"code": "SWFInput_readSBits(SWFInput input, int number)\n{\n\tint num = SWFInput_readBits(input, number);\n\tif ( num & (1<<(number-1)) )\n\t\treturn num - (1<<number);\n\telse\n\t\treturn num;\n}", "target": 1}
{"code": "hybiWsFrameComplete(ws_ctx_t *wsctx)\n{\n  return wsctx != NULL && hybiRemaining(wsctx) == 0;\n}", "target": 0}
{"code": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\twrite_lock_bh(&ping_table.lock);\n\tif (sk_hashed(sk)) {\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n}", "target": 0}
{"code": "UnicodeString DecimalQuantity::toScientificString() const {\n    U_ASSERT(!isApproximate);\n    UnicodeString result;\n    if (isNegative()) {\n        result.append(u'-');\n    }\n    if (precision == 0) {\n        result.append(u\"0E+0\", -1);\n        return result;\n    }\n    int32_t upperPos = std::min(precision + scale, lOptPos) - scale - 1;\n    int32_t lowerPos = std::max(scale, rOptPos) - scale;\n    int32_t p = upperPos;\n    result.append(u'0' + getDigitPos(p));\n    if ((--p) >= lowerPos) {\n        result.append(u'.');\n        for (; p >= lowerPos; p--) {\n            result.append(u'0' + getDigitPos(p));\n        }\n    }\n    result.append(u'E');\n    int32_t _scale = upperPos + scale;\n    if (_scale < 0) {\n        _scale *= -1;\n        result.append(u'-');\n    } else {\n        result.append(u'+');\n    }\n    if (_scale == 0) {\n        result.append(u'0');\n    }\n    int32_t insertIndex = result.length();\n    while (_scale > 0) {\n        std::div_t res = std::div(_scale, 10);\n        result.insert(insertIndex, u'0' + res.rem);\n        _scale = res.quot;\n    }\n    return result;\n}", "target": 1}
{"code": "int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT16(s, fields->Len); \n\tStream_Read_UINT16(s, fields->MaxLen); \n\tStream_Read_UINT32(s, fields->BufferOffset); \n\treturn 1;\n}", "target": 1}
{"code": "UrlQuery::UrlQuery(const std::string& encoded_str) {\n  if (!encoded_str.empty()) {\n    for (std::size_t i = 0; i != std::string::npos;) {\n      std::size_t j = encoded_str.find_first_of('&', i);\n      std::string kv;\n      if (j == std::string::npos) {\n        kv = encoded_str.substr(i);\n        i = std::string::npos;\n      } else {\n        kv = encoded_str.substr(i, j - i);\n        i = j + 1;\n      }\n      string_view key;\n      string_view value;\n      if (SplitKV(kv, '=', false, &key, &value)) {\n        parameters_.push_back({ DecodeUnsafe(key), DecodeUnsafe(value) });\n      }\n    }\n  }\n}", "target": 1}
{"code": "    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (silf)   options &= ~gr_face_dumbRendering;\n        else if (!(options &  gr_face_dumbRendering))\n            return false;\n        if (!face.readGlyphs(options))\n            return false;\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return options & gr_face_dumbRendering;\n    }", "target": 1}
{"code": "test_compressed_stream_overflow (xd3_stream *stream, int ignore)\n{\n  int ret;\n  int i;\n  uint8_t *buf;\n  if ((buf = (uint8_t*) malloc (TWO_MEGS_AND_DELTA)) == NULL) { return ENOMEM; }\n  memset (buf, 0, TWO_MEGS_AND_DELTA);\n  for (i = 0; i < (2 << 20); i += 256) \n    {\n      int j;\n      int off = mt_random(& static_mtrand) % 10;\n      for (j = 0; j < 256; j++) \n\t{\n\t  buf[i + j] = j + off;\n\t}\n    }\n  if (SIZEOF_XOFF_T == 4)\n    {\n      ret = test_streaming (stream, buf, buf + (1 << 20), buf + (2 << 20), (1 << 12) + 1);\n      if (ret == XD3_INVALID_INPUT && MSG_IS (\"decoder file offset overflow\"))\n\t{\n\t  ret = 0;\n\t}\n      else\n\t{\n          XPR(NT XD3_LIB_ERRMSG (stream, ret));\n\t  stream->msg = \"expected overflow condition\";\n\t  ret = XD3_INTERNAL;\n\t  goto fail;\n\t}\n    }\n  if ((ret = test_streaming (stream, \n\t\t\t     buf, \n\t\t\t     buf + (1 << 20), \n\t\t\t     buf + (2 << 20), \n\t\t\t     1 << 12))) \n    {\n      goto fail;\n    }\n fail:\n  free (buf);\n  return ret;\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command,\n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out,\n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "gboolean session_info_session_is_locked(struct session_info *si)\n{\n    gboolean locked;\n    g_return_val_if_fail (si != NULL, FALSE);\n    si_dbus_read_signals(si);\n    si_dbus_read_properties(si);\n    locked = (si->session_is_locked || si->session_locked_hint);\n    if (si->verbose) {\n        syslog(LOG_DEBUG, \"(systemd-login) session is locked: %s\",\n               locked ? \"yes\" : \"no\");\n    }\n    return locked;\n}", "target": 0}
{"code": "  Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values,\n                            const FunctionDef::ArgAttrs* arg_attrs,\n                            bool ints_on_device,\n                            int64_t resource_arg_unique_id) {\n    bool is_type_list;\n    DataTypeVector dtypes;\n    TF_RETURN_IF_ERROR(\n        ArgNumType(attr_values, arg_def, &is_type_list, &dtypes));\n    if (dtypes.size() < size_t{1}) {\n      return errors::Internal(\"Expected a list of at least one dtype\");\n    }\n    int arg_index = result_.nodes.size();\n    TF_RETURN_IF_ERROR(\n        AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes}));\n    for (size_t i = 0; i < dtypes.size(); ++i) {\n      TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), \":\", i),\n                                 {true, arg_index, 0, false, {dtypes[i]}}));\n      if (arg_index != result_.nodes.size()) {\n        return errors::Internal(\n            \"Expected arg_index to be equal to the number of nodes in result.\",\n            \" Got \", arg_index, \" and \", result_.nodes.size());\n      }\n      string name = arg_def.name();\n      if (dtypes.size() > 1) {\n        strings::StrAppend(&name, \"_\", i);\n      }\n      NodeDef* gnode = AddNode(name);\n      if (ints_on_device && dtypes[i] == DataType::DT_INT32) {\n        gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp);\n      } else {\n        gnode->set_op(FunctionLibraryDefinition::kArgOp);\n      }\n      DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i];\n      AddAttr(\"T\", dtype, gnode);\n      AddAttr(\"index\", arg_index, gnode);\n      if (resource_arg_unique_id >= 0) {\n        AddAttr(\"_resource_arg_unique_id\", resource_arg_unique_id, gnode);\n      }\n      if (arg_attrs) {\n        for (const auto& arg_attr : arg_attrs->attr()) {\n          AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr());\n        }\n      }\n      result_.arg_types.push_back(dtypes[i]);\n      ++arg_index;\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}", "target": 1}
{"code": "static inline struct keydata *get_keyptr(void)\n{\n\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n\tsmp_rmb();\n\treturn keyptr;\n}", "target": 1}
{"code": "static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tif (!sctp_is_ep_boundall(sk) && val)\n\t\treturn -EINVAL;\n\tif ((val && sp->do_auto_asconf) || (!val && !sp->do_auto_asconf))\n\t\treturn 0;\n\tspin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\tif (val == 0 && sp->do_auto_asconf) {\n\t\tlist_del(&sp->auto_asconf_list);\n\t\tsp->do_auto_asconf = 0;\n\t} else if (val && !sp->do_auto_asconf) {\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &sock_net(sk)->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t}\n\tspin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\treturn 0;\n}", "target": 0}
{"code": "void MutateSavedTensorSlices(\n    const std::string& fname,\n    const std::function<std::string(SavedTensorSlices)>& mutator) {\n  table::Options options;\n  options.compression = table::kNoCompression;\n  std::vector<std::pair<std::string, std::string>> entries;\n  {\n    std::unique_ptr<RandomAccessFile> file;\n    TF_CHECK_OK(Env::Default()->NewRandomAccessFile(fname, &file));\n    uint64 file_size;\n    TF_CHECK_OK(Env::Default()->GetFileSize(fname, &file_size));\n    table::Table* t;\n    TF_CHECK_OK(table::Table::Open(options, file.get(), file_size, &t));\n    std::unique_ptr<table::Table> table(t);\n    std::unique_ptr<table::Iterator> it(table->NewIterator());\n    for (it->Seek(\"\"); it->Valid(); it->Next()) {\n      entries.emplace_back(it->key(), it->value());\n    }\n    TF_CHECK_OK(it->status());\n  }\n  {\n    std::unique_ptr<WritableFile> file;\n    TF_CHECK_OK(Env::Default()->NewWritableFile(fname, &file));\n    table::TableBuilder builder(options, file.get());\n    for (const auto& entry : entries) {\n      SavedTensorSlices sts;\n      CHECK(sts.ParseFromString(entry.second));\n      builder.Add(entry.first, mutator(std::move(sts)));\n    }\n    TF_CHECK_OK(builder.Finish());\n    TF_CHECK_OK(file->Close());\n  }\n}", "target": 0}
{"code": "static void do_free_publickey(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "aodv_extension(netdissect_options *ndo,\n               const struct aodv_ext *ep, u_int length)\n{\n\tconst struct aodv_hello *ah;\n\tND_TCHECK(*ep);\n\tswitch (ep->type) {\n\tcase AODV_EXT_HELLO:\n\t\tah = (const struct aodv_hello *)(const void *)ep;\n\t\tND_TCHECK(*ah);\n\t\tif (length < sizeof(struct aodv_hello))\n\t\t\tgoto trunc;\n\t\tif (ep->length < 4) {\n\t\t\tND_PRINT((ndo, \"\\n\\text HELLO - bad length %u\", ep->length));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\text HELLO %ld ms\",\n\t\t    (unsigned long)EXTRACT_32BITS(&ah->interval)));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"\\n\\text %u %u\", ep->type, ep->length));\n\t\tbreak;\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \" [|hello]\"));\n}", "target": 0}
{"code": "pid_t LightProcess::waitpid(pid_t pid, int *stat_loc, int options,\n                            int timeout) {\n  if (!Available()) {\n    return ::waitpid(pid, stat_loc, options);\n  }\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  fprintf(g_procs[id].m_fout, \"waitpid\\n%\" PRId64 \" %d %d\\n\", (int64_t)pid, options,\n          timeout);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (!buf[0]) return -1;\n  int64_t ret;\n  int stat;\n  sscanf(buf, \"%\" PRId64 \" %d\", &ret, &stat);\n  *stat_loc = stat;\n  if (ret < 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n  }\n  return (pid_t)ret;\n}", "target": 1}
{"code": "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n{\n\tGIOChannel *handle, *ssl_handle;\n\thandle = net_connect_ip(ip, port, my_ip);\n\tif (handle == NULL)\n\t\treturn NULL;\n\tssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);\n\tif (ssl_handle == NULL)\n\t\tg_io_channel_unref(handle);\n\treturn ssl_handle;\n}", "target": 1}
{"code": "kg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n    return code;\n}", "target": 1}
{"code": "static inline unsigned char unimap_bsearch(const uni_to_enc *table, unsigned code_key_a, size_t num)\n{\n\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\tcode_key = (unsigned short) code_key_a;\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "isofs_export_encode_fh(struct inode *inode,\n\t\t       __u32 *fh32,\n\t\t       int *max_len,\n\t\t       struct inode *parent)\n{\n\tstruct iso_inode_info * ei = ISOFS_I(inode);\n\tint len = *max_len;\n\tint type = 1;\n\t__u16 *fh16 = (__u16*)fh32;\n\tif (parent && (len < 5)) {\n\t\t*max_len = 5;\n\t\treturn 255;\n\t} else if (len < 3) {\n\t\t*max_len = 3;\n\t\treturn 255;\n\t}\n\tlen = 3;\n\tfh32[0] = ei->i_iget5_block;\n \tfh16[2] = (__u16)ei->i_iget5_offset;  \n\tfh16[3] = 0;  \n\tfh32[2] = inode->i_generation;\n\tif (parent) {\n\t\tstruct iso_inode_info *eparent;\n\t\teparent = ISOFS_I(parent);\n\t\tfh32[3] = eparent->i_iget5_block;\n\t\tfh16[3] = (__u16)eparent->i_iget5_offset;  \n\t\tfh32[4] = parent->i_generation;\n\t\tlen = 5;\n\t\ttype = 2;\n\t}\n\t*max_len = len;\n\treturn type;\n}", "target": 0}
{"code": "static MYSQL *db_connect(char *host, char *database,\n                         char *user, char *passwd)\n{\n  MYSQL *mysql;\n  if (verbose)\n    fprintf(stdout, \"Connecting to %s\\n\", host ? host : \"localhost\");\n  if (!(mysql= mysql_init(NULL)))\n    return 0;\n  if (opt_compress)\n    mysql_options(mysql,MYSQL_OPT_COMPRESS,NullS);\n  if (opt_local_file)\n    mysql_options(mysql,MYSQL_OPT_LOCAL_INFILE,\n\t\t  (char*) &opt_local_file);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*)&opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(mysql,MYSQL_OPT_BIND,opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(mysql,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(mysql, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(mysql, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(mysql, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(mysql, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(mysql, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlimport\");\n  if (!(mysql_real_connect(mysql,host,user,passwd,\n                           database,opt_mysql_port,opt_mysql_unix_port,\n                           0)))\n  {\n    ignore_errors=0;\t  \n    db_error(mysql);\n  }\n  mysql->reconnect= 0;\n  if (verbose)\n    fprintf(stdout, \"Selecting database %s\\n\", database);\n  if (mysql_select_db(mysql, database))\n  {\n    ignore_errors=0;\n    db_error(mysql);\n  }\n  return mysql;\n}", "target": 1}
{"code": "static int nested_vmx_check_msr_switch(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned long count_field,\n\t\t\t\t       unsigned long addr_field)\n{\n\tint maxphyaddr;\n\tu64 count, addr;\n\tif (vmcs12_read_any(vcpu, count_field, &count) ||\n\t    vmcs12_read_any(vcpu, addr_field, &addr)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tif (count == 0)\n\t\treturn 0;\n\tmaxphyaddr = cpuid_maxphyaddr(vcpu);\n\tif (!IS_ALIGNED(addr, 16) || addr >> maxphyaddr ||\n\t    (addr + count * sizeof(struct vmx_msr_entry) - 1) >> maxphyaddr) {\n\t\tpr_warn_ratelimited(\n\t\t\t\"nVMX: invalid MSR switch (0x%lx, %d, %llu, 0x%08llx)\",\n\t\t\taddr_field, maxphyaddr, count, addr);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "hb_set_clear (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->clear ();\n}", "target": 1}
{"code": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}", "target": 1}
{"code": "static int srpt_rx_mgmt_fn_tag(struct srpt_send_ioctx *ioctx, u64 tag)\n{\n\tstruct srpt_device *sdev;\n\tstruct srpt_rdma_ch *ch;\n\tstruct srpt_send_ioctx *target;\n\tint ret, i;\n\tret = -EINVAL;\n\tch = ioctx->ch;\n\tBUG_ON(!ch);\n\tBUG_ON(!ch->sport);\n\tsdev = ch->sport->sdev;\n\tBUG_ON(!sdev);\n\tspin_lock_irq(&sdev->spinlock);\n\tfor (i = 0; i < ch->rq_size; ++i) {\n\t\ttarget = ch->ioctx_ring[i];\n\t\tif (target->cmd.se_lun == ioctx->cmd.se_lun &&\n\t\t    target->cmd.tag == tag &&\n\t\t    srpt_get_cmd_state(target) != SRPT_STATE_DONE) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&sdev->spinlock);\n\treturn ret;\n}", "target": 1}
{"code": "      return *ptr_min;\n    }\n    const T& min() const {\n      if (is_empty())\n        throw CImgInstanceException(_cimglist_instance\n                                    \"min(): Empty instance.\",\n                                    cimglist_instance);\n      const T *ptr_min = _data->_data;\n      T min_value = *ptr_min;\n      cimglist_for(*this,l) {\n        const CImg<T>& img = _data[l];", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& min_input_tensor = context->input(1);\n    const Tensor& max_input_tensor = context->input(2);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(min_input_tensor.shape()),\n                errors::InvalidArgument(\n                    \"min_input shape must be rank 0 but is rank \",\n                    min_input_tensor.dims(),\n                    \", received shape: \", min_input_tensor.shape()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(max_input_tensor.shape()),\n                errors::InvalidArgument(\n                    \"max_input shape must be rank 0 but is rank \",\n                    max_input_tensor.dims(),\n                    \", received shape: \", max_input_tensor.shape()));\n    const float min_input = context->input(1).scalar<float>()();\n    const float max_input = context->input(2).scalar<float>()();\n    MaxPoolingOp<Device, T>::Compute(context);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &output_min));\n    output_min->flat<float>()(0) = min_input;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &output_max));\n    output_max->flat<float>()(0) = max_input;\n  }", "target": 0}
{"code": "PHP_FUNCTION(linkinfo)\n{\n\tchar *link;\n\tchar *dirname;\n\tsize_t link_len;\n\tzend_stat_t sb;\n\tint ret;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) {\n\t\treturn;\n\t}\n\tdirname = estrndup(link, link_len);\n\tphp_dirname(dirname, link_len);\n\tif (php_check_open_basedir(dirname)) {\n\t\tefree(dirname);\n\t\tRETURN_FALSE;\n\t}\n\tret = VCWD_STAT(link, &sb);\n\tif (ret == -1) {\n\t\tphp_error_docref(NULL, E_WARNING, \"%s\", strerror(errno));\n\t\tefree(dirname);\n\t\tRETURN_LONG(Z_L(-1));\n\t}\n\tefree(dirname);\n\tRETURN_LONG((zend_long) sb.st_dev);\n}", "target": 0}
{"code": "static void *create_core_server_config(apr_pool_t *a, server_rec *s)\n{\n    core_server_config *conf;\n    int is_virtual = s->is_virtual;\n    conf = (core_server_config *)apr_pcalloc(a, sizeof(core_server_config));\n    if (!is_virtual) {\n        conf->ap_document_root = DOCUMENT_LOCATION;\n        conf->access_name = DEFAULT_ACCESS_FNAME;\n        conf->accf_map = apr_table_make(a, 5);\n#if APR_HAS_SO_ACCEPTFILTER\n        apr_table_setn(conf->accf_map, \"http\", ACCEPT_FILTER_NAME);\n        apr_table_setn(conf->accf_map, \"https\", \"dataready\");\n#elif defined(WIN32)\n        apr_table_setn(conf->accf_map, \"http\", \"connect\");\n        apr_table_setn(conf->accf_map, \"https\", \"connect\");\n#else\n        apr_table_setn(conf->accf_map, \"http\", \"data\");\n        apr_table_setn(conf->accf_map, \"https\", \"data\");\n#endif\n        conf->flush_max_threshold = AP_FLUSH_MAX_THRESHOLD;\n        conf->flush_max_pipelined = AP_FLUSH_MAX_PIPELINED;\n    }\n    else {\n        conf->flush_max_pipelined = -1;\n    }\n    conf->sec_dir = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->sec_url = apr_array_make(a, 40, sizeof(ap_conf_vector_t *));\n    conf->trace_enable = AP_TRACE_UNSET;\n    conf->protocols = apr_array_make(a, 5, sizeof(const char *));\n    conf->protocols_honor_order = -1;\n    conf->merge_slashes = AP_CORE_CONFIG_UNSET; \n    conf->strict_host_check= AP_CORE_CONFIG_UNSET; \n    return (void *)conf;\n}", "target": 0}
{"code": "static long snd_seq_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tstruct snd_seq_client *client = file->private_data;\n\tunion {\n\t\tint pversion;\n\t\tint client_id;\n\t\tstruct snd_seq_system_info\tsystem_info;\n\t\tstruct snd_seq_running_info\trunning_info;\n\t\tstruct snd_seq_client_info\tclient_info;\n\t\tstruct snd_seq_port_info\tport_info;\n\t\tstruct snd_seq_port_subscribe\tport_subscribe;\n\t\tstruct snd_seq_queue_info\tqueue_info;\n\t\tstruct snd_seq_queue_status\tqueue_status;\n\t\tstruct snd_seq_queue_tempo\ttempo;\n\t\tstruct snd_seq_queue_timer\tqueue_timer;\n\t\tstruct snd_seq_queue_client\tqueue_client;\n\t\tstruct snd_seq_client_pool\tclient_pool;\n\t\tstruct snd_seq_remove_events\tremove_events;\n\t\tstruct snd_seq_query_subs\tquery_subs;\n\t} buf;\n\tconst struct ioctl_handler *handler;\n\tunsigned long size;\n\tint err;\n\tif (snd_BUG_ON(!client))\n\t\treturn -ENXIO;\n\tfor (handler = ioctl_handlers; handler->cmd > 0; ++handler) {\n\t\tif (handler->cmd == cmd)\n\t\t\tbreak;\n\t}\n\tif (handler->cmd == 0)\n\t\treturn -ENOTTY;\n\tmemset(&buf, 0, sizeof(buf));\n\tsize = _IOC_SIZE(handler->cmd);\n\tif (handler->cmd & IOC_IN) {\n\t\tif (copy_from_user(&buf, (const void __user *)arg, size))\n\t\t\treturn -EFAULT;\n\t}\n\tmutex_lock(&client->ioctl_mutex);\n\terr = handler->func(client, &buf);\n\tmutex_unlock(&client->ioctl_mutex);\n\tif (err >= 0) {\n\t\tif (handler->cmd == SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT ||\n\t\t    handler->cmd == SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ||\n\t\t    (handler->cmd & IOC_OUT))\n\t\t\tif (copy_to_user((void __user *)arg, &buf, size))\n\t\t\t\treturn -EFAULT;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "static int em_sysexit(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tint usermode;\n\tu16 cs_sel = 0, ss_sel = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_gp(ctxt, 0);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif ((ctxt->rex_prefix & 0x8) != 0x0)\n\t\tusermode = X86EMUL_MODE_PROT64;\n\telse\n\t\tusermode = X86EMUL_MODE_PROT32;\n\tcs.dpl = 3;\n\tss.dpl = 3;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (usermode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tcs_sel = (u16)(msr_data + 16);\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = (u16)(msr_data + 24);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tcs_sel = (u16)(msr_data + 32);\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tss_sel = cs_sel + 8;\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t\tbreak;\n\t}\n\tcs_sel |= SELECTOR_RPL_MASK;\n\tss_sel |= SELECTOR_RPL_MASK;\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->_eip = reg_read(ctxt, VCPU_REGS_RDX);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = reg_read(ctxt, VCPU_REGS_RCX);\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \"client authentication failure\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}", "target": 1}
{"code": "static int r_jws_verify_sig_hmac(jws_t * jws, jwk_t * jwk) {\n  unsigned char * sig = r_jws_sign_hmac(jws, jwk);\n  int ret;\n  if (sig != NULL && 0 == o_strcmp((const char *)jws->signature_b64url, (const char *)sig)) {\n    ret = RHN_OK;\n  } else {\n    ret = RHN_ERROR_INVALID;\n  }\n  o_free(sig);\n  return ret;\n}", "target": 1}
{"code": "static inline void dec_snd_pages(int order)\n{\n\tsnd_allocated_pages -= 1 << order;\n}", "target": 0}
{"code": "SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\tif (size > INT_MAX)\n\t\tsize = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov = &iov;\n\tiov.iov_len = size;\n\tiov.iov_base = ubuf;\n\tmsg.msg_name = (struct sockaddr *)&address;\n\tmsg.msg_namelen = sizeof(address);\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, size, flags);\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user(&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}", "target": 1}
{"code": "static int hci_sock_getsockopt(struct socket *sock, int level, int optname,\n\t\t\t       char __user *optval, int __user *optlen)\n{\n\tstruct hci_ufilter uf;\n\tstruct sock *sk = sock->sk;\n\tint len, opt, err = 0;\n\tBT_DBG(\"sk %p, opt %d\", sk, optname);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tif (hci_pi(sk)->channel != HCI_CHANNEL_RAW) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tswitch (optname) {\n\tcase HCI_DATA_DIR:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_DIR)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase HCI_TIME_STAMP:\n\t\tif (hci_pi(sk)->cmsg_mask & HCI_CMSG_TSTAMP)\n\t\t\topt = 1;\n\t\telse\n\t\t\topt = 0;\n\t\tif (put_user(opt, optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase HCI_FILTER:\n\t\t{\n\t\t\tstruct hci_filter *f = &hci_pi(sk)->filter;\n\t\t\tmemset(&uf, 0, sizeof(uf));\n\t\t\tuf.type_mask = f->type_mask;\n\t\t\tuf.opcode    = f->opcode;\n\t\t\tuf.event_mask[0] = *((u32 *) f->event_mask + 0);\n\t\t\tuf.event_mask[1] = *((u32 *) f->event_mask + 1);\n\t\t}\n\t\tlen = min_t(unsigned int, len, sizeof(uf));\n\t\tif (copy_to_user(optval, &uf, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "vmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}", "target": 0}
{"code": "struct page *alloc_huge_page_nodemask(struct hstate *h, int preferred_nid,\n\t\tnodemask_t *nmask, gfp_t gfp_mask)\n{\n\tspin_lock_irq(&hugetlb_lock);\n\tif (h->free_huge_pages - h->resv_huge_pages > 0) {\n\t\tstruct page *page;\n\t\tpage = dequeue_huge_page_nodemask(h, gfp_mask, preferred_nid, nmask);\n\t\tif (page) {\n\t\t\tspin_unlock_irq(&hugetlb_lock);\n\t\t\treturn page;\n\t\t}\n\t}\n\tspin_unlock_irq(&hugetlb_lock);\n\treturn alloc_migrate_huge_page(h, gfp_mask, preferred_nid, nmask);\n}", "target": 0}
{"code": "static MagickBooleanType DecodeLabImage(Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n  MagickBooleanType\n    status;\n  ssize_t\n    y;\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    PixelPacket\n      *magick_restrict q;\n    ssize_t\n      x;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        break;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double\n        a,\n        b;\n      a=QuantumScale*GetPixela(q)+0.5;\n      if (a > 1.0)\n        a-=1.0;\n      b=QuantumScale*GetPixelb(q)+0.5;\n      if (b > 1.0)\n        b-=1.0;\n      SetPixela(q,QuantumRange*a);\n      SetPixelb(q,QuantumRange*b);\n      q++;\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        break;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}", "target": 0}
{"code": "static int do_prlimit(struct task_struct *tsk, unsigned int resource,\n\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)\n{\n\tstruct rlimit *rlim;\n\tint retval = 0;\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n\t\t\treturn -EINVAL;\n\t\tif (resource == RLIMIT_NOFILE &&\n\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n\t\t\treturn -EPERM;\n\t}\n\trlim = tsk->signal->rlim + resource;\n\ttask_lock(tsk->group_leader);\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\t\tretval = -EPERM;\n\t\tif (!retval)\n\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);\n\t}\n\tif (!retval) {\n\t\tif (old_rlim)\n\t\t\t*old_rlim = *rlim;\n\t\tif (new_rlim)\n\t\t\t*rlim = *new_rlim;\n\t}\n\ttask_unlock(tsk->group_leader);\n\tif (!retval && new_rlim && resource == RLIMIT_CPU &&\n\t    new_rlim->rlim_cur != RLIM_INFINITY &&\n\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {\n\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static void vgacon_restore_screen(struct vc_data *c)\n{\n\tc->vc_origin = c->vc_visible_origin;\n\tvgacon_scrollback_cur->save = 0;\n\tif (!vga_is_gfx && !vgacon_scrollback_cur->restore) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t    vga_vram_size : c->vc_screenbuf_size);\n\t\tvgacon_scrollback_cur->restore = 1;\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}", "target": 1}
{"code": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}", "target": 1}
{"code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}", "target": 0}
{"code": "static void wait_limit_netblock_del(rbnode_type* n, void* ATTR_UNUSED(arg))\n{\n\tfree(n);\n}", "target": 0}
{"code": "static inline bool set_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype)\n{\n\tstruct page_ext *page_ext;\n\tif (!debug_guardpage_enabled())\n\t\treturn false;\n\tif (order >= debug_guardpage_minorder())\n\t\treturn false;\n\tpage_ext = lookup_page_ext(page);\n\tif (unlikely(!page_ext))\n\t\treturn false;\n\t__set_bit(PAGE_EXT_DEBUG_GUARD, &page_ext->flags);\n\tINIT_LIST_HEAD(&page->lru);\n\tset_page_private(page, order);\n\t__mod_zone_freepage_state(zone, -(1 << order), migratetype);\n\treturn true;\n}", "target": 0}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    long long val = self->val;\n    if (big_endian) {\n        byte *b = buf + len;\n        while (b > buf) {\n            *--b = val;\n            val >>= 8;\n        }\n    } else {\n        for (; len > 0; --len) {\n            *buf++ = val;\n            val >>= 8;\n        }\n    }\n}", "target": 1}
{"code": "init_connection_options(MYSQL *mysql)\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(mysql, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(mysql, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(mysql, MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*) &opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(mysql, MYSQL_OPT_PROTOCOL, (char*) &opt_protocol);\n#ifdef HAVE_SMEM\n  if (shared_memory_base_name)\n    mysql_options(mysql, MYSQL_SHARED_MEMORY_BASE_NAME, shared_memory_base_name);\n#endif\n}", "target": 1}
{"code": "static const char *describe_object(struct fsck_options *o, struct object *obj)\n{\n\tstatic struct strbuf buf = STRBUF_INIT;\n\tchar *name;\n\tstrbuf_reset(&buf);\n\tstrbuf_addstr(&buf, oid_to_hex(&obj->oid));\n\tif (o->object_names && (name = lookup_decoration(o->object_names, obj)))\n\t\tstrbuf_addf(&buf, \" (%s)\", name);\n\treturn buf.buf;\n}", "target": 0}
{"code": "void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n    int index = 1;\n    lua_newtable(L);\n    luaL_checkstack(L, 1, \"in function mp_decode_to_lua_array\");\n    while(len--) {\n        lua_pushnumber(L,index++);\n        mp_decode_to_lua_type(L,c);\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}", "target": 0}
{"code": "BOOL security_decrypt(BYTE* data, int length, rdpRdp* rdp)\n{\n\tif (rdp->rc4_decrypt_key == NULL)\n\t\treturn FALSE;\n\tif (rdp->decrypt_use_count >= 4096)\n\t{\n\t\tsecurity_key_update(rdp->decrypt_key, rdp->decrypt_update_key, rdp->rc4_key_len);\n\t\tcrypto_rc4_free(rdp->rc4_decrypt_key);\n\t\trdp->rc4_decrypt_key = crypto_rc4_init(rdp->decrypt_key, rdp->rc4_key_len);\n\t\trdp->decrypt_use_count = 0;\n\t}\n\tcrypto_rc4(rdp->rc4_decrypt_key, length, data, data);\n\trdp->decrypt_use_count += 1;\n\trdp->decrypt_checksum_use_count++;\n\treturn TRUE;\n}", "target": 0}
{"code": "MagickExport void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n{\n#define AlignedExtent(size,alignment) \\\n  (((size)+((alignment)-1)) & ~((alignment)-1))\n  size_t\n    alignment,\n    extent,\n    size;\n  void\n    *memory;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  memory=NULL;\n  alignment=CACHE_LINE_SIZE;\n  size=count*quantum;\n  extent=AlignedExtent(size,alignment);\n  if ((size == 0) || (alignment < sizeof(void *)) || (extent < size))\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  if (posix_memalign(&memory,alignment,extent) != 0)\n    memory=NULL;\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  memory=_aligned_malloc(extent,alignment);\n#else\n  {\n    void\n      *p;\n    extent=(size+alignment-1)+sizeof(void *);\n    if (extent > size)\n      {\n        p=malloc(extent);\n        if (p != NULL)\n          {\n            memory=(void *) AlignedExtent((size_t) p+sizeof(void *),alignment);\n            *((void **) memory-1)=p;\n          }\n      }\n  }\n#endif\n  return(memory);\n}", "target": 1}
{"code": "h2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tassert(!WS_IsReserved(r2->req->ws));\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t\n\tif (req->req_body_status == NULL) {\n\t\tif (!http_GetHdr(req->http, H_Content_Length, NULL))\n\t\t\treq->req_body_status = BS_EOF;\n\t\telse\n\t\t\treq->req_body_status = BS_LENGTH;\n\t} else {\n\t\tassert (req->req_body_status == BS_NONE);\n\t\tr2->state = H2_S_CLOS_REM;\n\t\tif (http_GetContentLength(req->http) > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task->func = h2_do_req;\n\treq->task->priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); \n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)\n{\n\tstruct Scsi_Host *host;\n\thost = scsi_host_alloc(sht, sizeof(adpt_hba*));\n\tif (host == NULL) {\n\t\tprintk(\"%s: scsi_host_alloc returned NULL\\n\", pHba->name);\n\t\treturn -1;\n\t}\n\thost->hostdata[0] = (unsigned long)pHba;\n\tpHba->host = host;\n\thost->irq = pHba->pDev->irq;\n\thost->io_port = 0;\n\thost->n_io_port = 0;\n\thost->max_id = 16;\n\thost->max_lun = 256;\n\thost->max_channel = pHba->top_scsi_channel + 1;\n\thost->cmd_per_lun = 1;\n\thost->unique_id = (u32)sys_tbl_pa + pHba->unit;\n\thost->sg_tablesize = pHba->sg_tablesize;\n\thost->can_queue = pHba->post_fifo_size;\n\treturn 0;\n}", "target": 1}
{"code": "static int proc_pid_schedstat(struct task_struct *task, char *buffer)\n{\n\treturn sprintf(buffer, \"%llu %llu %lu\\n\",\n\t\t\ttask->sched_info.cpu_time,\n\t\t\ttask->sched_info.run_delay,\n\t\t\ttask->sched_info.pcount);\n}", "target": 0}
{"code": "static int check_ptrace_options(unsigned long data)\n{\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "StatusOr<FullTypeDef> SpecializeType(const AttrSlice& attrs,\n                                     const OpDef& op_def) {\n  FullTypeDef ft;\n  ft.set_type_id(TFT_PRODUCT);\n  for (int i = 0; i < op_def.output_arg_size(); i++) {\n    auto* t = ft.add_args();\n    *t = op_def.output_arg(i).experimental_full_type();\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(j);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n        } else {\n          return Status(error::UNIMPLEMENTED,\n                        absl::StrCat(\"unknown attribute type\",\n                                     attrs.DebugString(), \" key=\", arg->s()));\n        }\n        arg->clear_s();\n      }\n    }\n  }\n  return ft;\n}", "target": 0}
{"code": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\t*ie_ptr = ie;\n\treturn 0;\n}", "target": 0}
{"code": "inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(\n    Request &req, const char *body, size_t content_length,\n    ContentProvider content_provider,\n    ContentProviderWithoutLength content_provider_without_length,\n    const std::string &content_type, Error &error) {\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_) { req.headers.emplace(\"Content-Encoding\", \"gzip\"); }\n#endif\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_ && !content_provider_without_length) {\n    detail::gzip_compressor compressor;\n    if (content_provider) {\n      auto ok = true;\n      size_t offset = 0;\n      DataSink data_sink;\n      data_sink.write = [&](const char *data, size_t data_len) -> bool {\n        if (ok) {\n          auto last = offset + data_len == content_length;\n          auto ret = compressor.compress(\n              data, data_len, last,\n              [&](const char *compressed_data, size_t compressed_data_len) {\n                req.body.append(compressed_data, compressed_data_len);\n                return true;\n              });\n          if (ret) {\n            offset += data_len;\n          } else {\n            ok = false;\n          }\n        }\n        return ok;\n      };\n      while (ok && offset < content_length) {\n        if (!content_provider(offset, content_length - offset, data_sink)) {\n          error = Error::Canceled;\n          return nullptr;\n        }\n      }\n    } else {\n      if (!compressor.compress(body, content_length, true,\n                               [&](const char *data, size_t data_len) {\n                                 req.body.append(data, data_len);\n                                 return true;\n                               })) {\n        error = Error::Compression;\n        return nullptr;\n      }\n    }\n  } else\n#endif\n  {\n    if (content_provider) {\n      req.content_length_ = content_length;\n      req.content_provider_ = std::move(content_provider);\n      req.is_chunked_content_provider_ = false;\n    } else if (content_provider_without_length) {\n      req.content_length_ = 0;\n      req.content_provider_ = detail::ContentProviderAdapter(\n          std::move(content_provider_without_length));\n      req.is_chunked_content_provider_ = true;\n      req.headers.emplace(\"Transfer-Encoding\", \"chunked\");\n    } else {\n      req.body.assign(body, content_length);\n      ;\n    }\n  }\n  auto res = detail::make_unique<Response>();\n  return send(req, *res, error) ? std::move(res) : nullptr;\n}", "target": 1}
{"code": "transientObjectPutErrorMessage(Runtime *runtime, Handle<> base, SymbolID id) {\n  StringView propName =\n      runtime->getIdentifierTable().getStringView(runtime, id);\n  Handle<StringPrimitive> baseType =\n      runtime->makeHandle(vmcast<StringPrimitive>(typeOf(runtime, base)));\n  StringView baseTypeAsString =\n      StringPrimitive::createStringView(runtime, baseType);\n  MutableHandle<StringPrimitive> valueAsString{runtime};\n  if (base->isSymbol()) {\n    auto str = symbolDescriptiveString(runtime, Handle<SymbolID>::vmcast(base));\n    if (str != ExecutionStatus::EXCEPTION) {\n      valueAsString = *str;\n    } else {\n      runtime->clearThrownValue();\n      valueAsString = StringPrimitive::createNoThrow(\n          runtime, \"<<Exception occurred getting the value>>\");\n    }\n  } else {\n    auto str = toString_RJS(runtime, base);\n    assert(\n        str != ExecutionStatus::EXCEPTION &&\n        \"Primitives should be convertible to string without exceptions\");\n    valueAsString = std::move(*str);\n  }\n  StringView valueAsStringPrintable =\n      StringPrimitive::createStringView(runtime, valueAsString);\n  SmallU16String<32> tmp;\n  return runtime->raiseTypeError(\n      TwineChar16(\"Cannot create property '\") + propName + \"' on \" +\n      baseTypeAsString.getUTF16Ref(tmp) + \" '\" +\n      valueAsStringPrintable.getUTF16Ref(tmp) + \"'\");\n}", "target": 1}
{"code": "MagickExport void RegisterStaticModules(void)\n{\n  PolicyRights\n    rights;\n  size_t\n    extent;\n  ssize_t\n    i;\n  rights=ReadPolicyRights|WritePolicyRights;\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered == MagickFalse)\n      {\n        if (IsRightsAuthorized(ModulePolicyDomain,rights,\n              MagickModules[i].module) == MagickFalse)\n          continue;\n        (void) (MagickModules[i].register_module)();\n        MagickModules[i].registered=MagickTrue;\n      }\n  }\n}", "target": 0}
{"code": "static bool map_info2_flags_to_sbuf(const SMB_STRUCT_STAT *psbuf,\n\t\t\t\tconst uint32_t smb_fflags,\n\t\t\t\tconst uint32_t smb_fmask,\n\t\t\t\tint *stat_fflags)\n{\n\tuint32_t max_fmask = 0;\n\tint i;\n\t*stat_fflags = psbuf->st_ex_flags;\n\tfor (i = 0; i < ARRAY_SIZE(info2_flags_map); ++i) {\n\t    max_fmask |= info2_flags_map[i].smb_fflag;\n\t    if (smb_fmask & info2_flags_map[i].smb_fflag) {\n\t\t    if (smb_fflags & info2_flags_map[i].smb_fflag) {\n\t\t\t    *stat_fflags |= info2_flags_map[i].stat_fflag;\n\t\t    } else {\n\t\t\t    *stat_fflags &= ~info2_flags_map[i].stat_fflag;\n\t\t    }\n\t    }\n\t}\n\tif ((smb_fmask & max_fmask) != smb_fmask) {\n\t\treturn False;\n\t}\n\treturn True;\n}", "target": 0}
{"code": "TfLiteStatus HardSwishPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    HardSwishParams* params = static_cast<HardSwishParams*>(node->user_data);\n    params->input_zero_point = input->params.zero_point;\n    params->output_zero_point = output->params.zero_point;\n    const float input_scale = input->params.scale;\n    const float hires_input_scale = (1.0f / 128.0f) * input_scale;\n    const float reluish_scale = 3.0f / 32768.0f;\n    const float output_scale = output->params.scale;\n    const double output_multiplier =\n        static_cast<double>(hires_input_scale / output_scale);\n    int32_t output_multiplier_fixedpoint_int32;\n    QuantizeMultiplier(output_multiplier, &output_multiplier_fixedpoint_int32,\n                       &params->output_multiplier_exponent);\n    DownScaleInt32ToInt16Multiplier(\n        output_multiplier_fixedpoint_int32,\n        &params->output_multiplier_fixedpoint_int16);\n    TF_LITE_ENSURE(context, params->output_multiplier_exponent <= 0);\n    const double reluish_multiplier =\n        static_cast<double>(hires_input_scale / reluish_scale);\n    int32_t reluish_multiplier_fixedpoint_int32;\n    QuantizeMultiplier(reluish_multiplier, &reluish_multiplier_fixedpoint_int32,\n                       &params->reluish_multiplier_exponent);\n    DownScaleInt32ToInt16Multiplier(\n        reluish_multiplier_fixedpoint_int32,\n        &params->reluish_multiplier_fixedpoint_int16);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin || !bin->segment_entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 0}
{"code": "ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)\n{\n\tstruct ipv6_txoptions *opt2;\n\topt2 = sock_kmalloc(sk, opt->tot_len, GFP_ATOMIC);\n\tif (opt2) {\n\t\tlong dif = (char *)opt2 - (char *)opt;\n\t\tmemcpy(opt2, opt, opt->tot_len);\n\t\tif (opt2->hopopt)\n\t\t\t*((char **)&opt2->hopopt) += dif;\n\t\tif (opt2->dst0opt)\n\t\t\t*((char **)&opt2->dst0opt) += dif;\n\t\tif (opt2->dst1opt)\n\t\t\t*((char **)&opt2->dst1opt) += dif;\n\t\tif (opt2->srcrt)\n\t\t\t*((char **)&opt2->srcrt) += dif;\n\t\tatomic_set(&opt2->refcnt, 1);\n\t}\n\treturn opt2;\n}", "target": 0}
{"code": "xfs_ip2xflags(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_icdinode\t*dic = &ip->i_d;\n\treturn _xfs_dic2xflags(dic->di_flags, dic->di_flags2, XFS_IFORK_Q(ip));\n}", "target": 0}
{"code": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}", "target": 1}
{"code": "DeletePortMappingRange(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r = -1;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tconst char * protocol;\n\tconst char * startport_s, * endport_s;\n\tunsigned short startport, endport;\n\tunsigned short * port_list;\n\tunsigned int i, number = 0;\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tstartport_s = GetValueFromNameValueList(&data, \"NewStartPort\");\n\tendport_s = GetValueFromNameValueList(&data, \"NewEndPort\");\n\tprotocol = GetValueFromNameValueList(&data, \"NewProtocol\");\n\tif(startport_s == NULL || endport_s == NULL || protocol == NULL ||\n\t   !is_numeric(startport_s) || !is_numeric(endport_s)) {\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\tstartport = (unsigned short)atoi(startport_s);\n\tendport = (unsigned short)atoi(endport_s);\n\tif(startport > endport)\n\t{\n\t\tSoapError(h, 733, \"InconsistentParameter\");\n\t\tClearNameValueList(&data);\n\t\treturn;\n\t}\n\tsyslog(LOG_INFO, \"%s: deleting external ports: %hu-%hu, protocol: %s\",\n\t       action, startport, endport, protocol);\n\tport_list = upnp_get_portmappings_in_range(startport, endport,\n\t                                           protocol, &number);\n\tif(number == 0)\n\t{\n\t\tSoapError(h, 730, \"PortMappingNotFound\");\n\t\tClearNameValueList(&data);\n\t\tfree(port_list);\n\t\treturn;\n\t}\n\tfor(i = 0; i < number; i++)\n\t{\n\t\tr = upnp_delete_redirection(port_list[i], protocol);\n\t\tsyslog(LOG_INFO, \"%s: deleting external port: %hu, protocol: %s: %s\",\n\t\t       action, port_list[i], protocol, r < 0 ? \"failed\" : \"ok\");\n\t}\n\tfree(port_list);\n\tbodylen = snprintf(body, sizeof(body), resp,\n\t                   action, ns, action);\n\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\tClearNameValueList(&data);\n}", "target": 0}
{"code": "static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}", "target": 1}
{"code": "bool ValidateInput<Variant>(const Tensor& updates) {\n  return true;\n}", "target": 0}
{"code": "ModuleExport size_t RegisterPSImage(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"PS\",\"EPI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPS\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSF\",\"Encapsulated PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"EPSI\",\n    \"Encapsulated PostScript Interchange format\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  (void) RegisterMagickInfo(entry);\n  entry=AcquireMagickInfo(\"PS\",\"PS\",\"PostScript\");\n  entry->decoder=(DecodeImageHandler *) ReadPSImage;\n  entry->encoder=(EncodeImageHandler *) WritePSImage;\n  entry->magick=(IsImageFormatHandler *) IsPS;\n  entry->mime_type=ConstantString(\"application/postscript\");\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderBlobSupportFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,\n\t\t\t\t      void *key)\n{\n\tstruct unix_sock *u;\n\twait_queue_head_t *u_sleep;\n\tu = container_of(q, struct unix_sock, peer_wake);\n\t__remove_wait_queue(&unix_sk(u->peer_wake.private)->peer_wait,\n\t\t\t    q);\n\tu->peer_wake.private = NULL;\n\tu_sleep = sk_sleep(&u->sk);\n\tif (u_sleep)\n\t\twake_up_interruptible_poll(u_sleep, key);\n\treturn 0;\n}", "target": 0}
{"code": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\tp->replacement_session_keyring = NULL;\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\tnew->user_ns = new->user->user_ns;\n#ifdef CONFIG_KEYS\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}", "target": 0}
{"code": "DEFINE_TRACE(ContainerNode)\n{\n    visitor->trace(m_firstChild);\n    visitor->trace(m_lastChild);\n    Node::trace(visitor);\n}", "target": 0}
{"code": "poly_path(PG_FUNCTION_ARGS)\n{\n\tPOLYGON    *poly = PG_GETARG_POLYGON_P(0);\n\tPATH\t   *path;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * poly->npts;\n\tpath = (PATH *) palloc(size);\n\tSET_VARSIZE(path, size);\n\tpath->npts = poly->npts;\n\tpath->closed = TRUE;\n\tpath->dummy = 0;\n\tfor (i = 0; i < poly->npts; i++)\n\t{\n\t\tpath->p[i].x = poly->p[i].x;\n\t\tpath->p[i].y = poly->p[i].y;\n\t}\n\tPG_RETURN_PATH_P(path);\n}", "target": 0}
{"code": "void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces->setTorrent(m_torrent);\n    pieces_availability->setTorrent(m_torrent);\n    if (!m_torrent) return;\n    updateSavePath(m_torrent);\n    hash_lbl->setText(m_torrent->hash());\n    PropListModel->model()->clear();\n    if (m_torrent->hasMetadata()) {\n        lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate));\n        label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n        comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment()));\n        loadUrlSeeds();\n        label_created_by_val->setText(m_torrent->creator());\n        PropListModel->model()->setupModelData(m_torrent->info());\n        filesList->setExpanded(PropListModel->index(0, 0), true);\n        PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities());\n    }\n    loadDynamicData();\n}", "target": 1}
{"code": "GF_Err pssh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox *)s;\n\tgf_bs_read_data(bs, (char *) ptr->SystemID, 16);\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tif (ptr->version > 0) {\n\t\tptr->KID_count = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tif (ptr->KID_count) {\n\t\t\tu32 i;\n\t\t\tif (ptr->size / sizeof(bin128) < ptr->KID_count)\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tptr->KIDs = gf_malloc(ptr->KID_count*sizeof(bin128));\n\t\t\tif (!ptr->KIDs)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<ptr->KID_count; i++) {\n\t\t\t\tgf_bs_read_data(bs, (char *) ptr->KIDs[i], 16);\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\t}\n\t\t}\n\t}\n\tptr->private_data_size = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->private_data_size) {\n\t\tif (ptr->size < ptr->private_data_size)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->private_data = gf_malloc(sizeof(char)*ptr->private_data_size);\n\t\tif (!ptr->private_data)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->private_data_size);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "const wchar_t *LibRaw_file_datastream::wfname()\n{\n  return wfilename.size() > 0 ? wfilename.c_str() : NULL;\n}", "target": 0}
{"code": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}", "target": 1}
{"code": "static int bad_format_check(const char *pattern, char *fmt) {\n    GError *gerr = NULL;\n    GRegex *re = g_regex_new(pattern, G_REGEX_EXTENDED, 0, &gerr);\n    GMatchInfo *mi;\n    if (gerr != NULL) {\n        rrd_set_error(\"cannot compile regular expression: %s (%s)\", gerr->message,pattern);\n        return 1;\n    }\n    int m = g_regex_match(re, fmt, 0, &mi);\n    g_match_info_free (mi);\n    g_regex_unref(re);\n    if (!m) {\n        rrd_set_error(\"invalid format string '%s' (should match '%s')\",fmt,pattern);\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)\n{\n#if BITS_PER_LONG == 32\n\treturn (void *)(unsigned long)context;\n#else\n\tvoid *p = pHba->ioctl_reply_context[context];\n\tpHba->ioctl_reply_context[context] = NULL;\n\treturn p;\n#endif\n}", "target": 1}
{"code": "void AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)av1, GF_FALSE);\n\tif (av1->emul_esd) gf_odf_desc_del((GF_Descriptor *)av1->emul_esd);\n\tav1->emul_esd = gf_odf_desc_esd_new(2);\n\tav1->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\tav1->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;\n\tif (btrt) {\n\t\tav1->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tav1->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tav1->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (av1->av1_config) {\n\t\tGF_AV1Config *av1_cfg = AV1_DuplicateConfig(av1->av1_config->config);\n\t\tif (av1_cfg) {\n\t\t\tgf_odf_av1_cfg_write(av1_cfg, &av1->emul_esd->decoderConfig->decoderSpecificInfo->data, &av1->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_av1_cfg_del(av1_cfg);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static Fixed lsr_translate_scale(GF_LASeRCodec *lsr, u32 val)\n{\n\tif (val >> (lsr->coord_bits-1) ) {\n\t\ts32 v = val - (1<<lsr->coord_bits);\n\t\treturn INT2FIX(v) / 256 ;\n\t} else {\n\t\treturn INT2FIX(val) / 256;\n\t}\n}", "target": 1}
{"code": "theme_adium_match_with_format (const gchar **str,\n\t\t\t       const gchar *match,\n\t\t\t       gchar **format)\n{\n\tconst gchar *cur = *str;\n\tconst gchar *end;\n\tif (!theme_adium_match (&cur, match)) {\n\t\treturn FALSE;\n\t}\n\tcur++;\n\tend = strstr (cur, \"}%\");\n\tif (!end) {\n\t\treturn FALSE;\n\t}\n\t*format = g_strndup (cur , end - cur);\n\t*str = end + 1;\n\treturn TRUE;\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_update_vhost_from_headers_ex(request_rec *r, int require_match)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n    int rc = HTTP_OK;\n    if (r->hostname) {\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (!require_match && r->status != HTTP_OK)\n        return HTTP_OK;\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_setn(r->headers_in, \"Host\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"Replacing host header '%s' with host '%s' given \"\n                          \"in the request uri\", host_header, repl);\n        }\n    }\n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            rc = update_server_from_aliases(r);\n        else\n            check_serverpath(r);\n    }\n    else if (require_match && r->hostname) { \n        rc = update_server_from_aliases(r);\n    }\n    return rc;\n}", "target": 0}
{"code": "int blk_rq_map_user_iov(struct request_queue *q, struct request *rq,\n\t\t\tstruct rq_map_data *map_data,\n\t\t\tconst struct iov_iter *iter, gfp_t gfp_mask)\n{\n\tbool copy = false;\n\tunsigned long align = q->dma_pad_mask | queue_dma_alignment(q);\n\tstruct bio *bio = NULL;\n\tstruct iov_iter i;\n\tint ret;\n\tif (!iter_is_iovec(iter))\n\t\tgoto fail;\n\tif (map_data)\n\t\tcopy = true;\n\telse if (iov_iter_alignment(iter) & align)\n\t\tcopy = true;\n\telse if (queue_virt_boundary(q))\n\t\tcopy = queue_virt_boundary(q) & iov_iter_gap_alignment(iter);\n\ti = *iter;\n\tdo {\n\t\tret =__blk_rq_map_user_iov(rq, map_data, &i, gfp_mask, copy);\n\t\tif (ret)\n\t\t\tgoto unmap_rq;\n\t\tif (!bio)\n\t\t\tbio = rq->bio;\n\t} while (iov_iter_count(&i));\n\tif (!bio_flagged(bio, BIO_USER_MAPPED))\n\t\trq->cmd_flags |= REQ_COPY_USER;\n\treturn 0;\nunmap_rq:\n\t__blk_rq_unmap_user(bio);\nfail:\n\trq->bio = NULL;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "gss_context_time (minor_status,\n                  context_handle,\n                  time_rec)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nOM_uint32 *\t\ttime_rec;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (time_rec == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_context_time) {\n\t    status = mech->gss_context_time(\n\t\t\t\t\t    minor_status,\n\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t    time_rec);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "void options_defaults() {\n    SERVICE_OPTIONS *service;\n    memset(&new_global_options, 0, sizeof(GLOBAL_OPTIONS));\n    memset(&new_service_options, 0, sizeof(SERVICE_OPTIONS));\n    new_service_options.next=NULL;\n    parse_global_option(CMD_SET_DEFAULTS, NULL, NULL);\n    service=&new_service_options;\n    parse_service_option(CMD_SET_DEFAULTS, &service, NULL, NULL);\n}", "target": 1}
{"code": "GF_Err pcmC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->format_flags);\n\tgf_bs_write_u8(bs, ptr->PCM_sample_size);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void usage(void)\n{\n  PRINT_VERSION;\n  puts(\"Copyright (c) 2011, Oracle and/or its affiliates. \"\n       \"All rights reserved.\\n\");\n  puts(\"Enable or disable plugins.\");\n  printf(\"\\nUsage: %s [options] <plugin> ENABLE|DISABLE\\n\\nOptions:\\n\",\n     my_progname);\n  my_print_help(my_long_options);\n  puts(\"\\n\");\n}", "target": 1}
{"code": "static const char *set_add_default_charset(cmd_parms *cmd,\n                                           void *d_, const char *arg)\n{\n    core_dir_config *d = d_;\n    if (!ap_cstr_casecmp(arg, \"Off\")) {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_OFF;\n    }\n    else if (!ap_cstr_casecmp(arg, \"On\")) {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;\n       d->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;\n    }\n    else {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;\n       d->add_default_charset_name = arg;\n    }\n    return NULL;\n}", "target": 0}
{"code": "static int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tstruct l2cap_chan *chan;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (!sk)\n\t\treturn 0;\n\tl2cap_sock_cleanup_listen(sk);\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\terr = l2cap_sock_shutdown(sock, SHUT_RDWR);\n\tchan = l2cap_pi(sk)->chan;\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\treturn err;\n}", "target": 0}
{"code": "static int bcm_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net;\n\tstruct bcm_sock *bo;\n\tstruct bcm_op *op, *next;\n\tif (!sk)\n\t\treturn 0;\n\tnet = sock_net(sk);\n\tbo = bcm_sk(sk);\n\tspin_lock(&bcm_notifier_lock);\n\twhile (bcm_busy_notifier == bo) {\n\t\tspin_unlock(&bcm_notifier_lock);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tspin_lock(&bcm_notifier_lock);\n\t}\n\tlist_del(&bo->notifier);\n\tspin_unlock(&bcm_notifier_lock);\n\tlock_sock(sk);\n\tlist_for_each_entry_safe(op, next, &bo->tx_ops, list)\n\t\tbcm_remove_op(op);\n\tlist_for_each_entry_safe(op, next, &bo->rx_ops, list) {\n\t\tif (op->ifindex) {\n\t\t\tif (op->rx_reg_dev) {\n\t\t\t\tstruct net_device *dev;\n\t\t\t\tdev = dev_get_by_index(net, op->ifindex);\n\t\t\t\tif (dev) {\n\t\t\t\t\tbcm_rx_unreg(dev, op);\n\t\t\t\t\tdev_put(dev);\n\t\t\t\t}\n\t\t\t}\n\t\t} else\n\t\t\tcan_rx_unregister(net, NULL, op->can_id,\n\t\t\t\t\t  REGMASK(op->can_id),\n\t\t\t\t\t  bcm_rx_handler, op);\n\t\tbcm_remove_op(op);\n\t}\n#if IS_ENABLED(CONFIG_PROC_FS)\n\tif (net->can.bcmproc_dir && bo->bcm_proc_read)\n\t\tremove_proc_entry(bo->procname, net->can.bcmproc_dir);\n#endif \n\tif (bo->bound) {\n\t\tbo->bound   = 0;\n\t\tbo->ifindex = 0;\n\t}\n\tsock_orphan(sk);\n\tsock->sk = NULL;\n\trelease_sock(sk);\n\tsock_put(sk);\n\treturn 0;\n}", "target": 1}
{"code": "void sw_crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}", "target": 1}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}", "target": 1}
{"code": "static int allocDynamic(dynamicPtr *dp, int initialSize, void *data)\n{\n\tif(data == NULL) {\n\t\tdp->logicalSize = 0;\n\t\tdp->dataGood = FALSE;\n\t\tdp->data = gdMalloc(initialSize);\n\t} else {\n\t\tdp->logicalSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->data = data;\n\t}\n\tif(dp->data != NULL) {\n\t\tdp->realSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->pos = 0;\n\t\treturn TRUE;\n\t} else {\n\t\tdp->realSize = 0;\n\t\treturn FALSE;\n\t}\n}", "target": 0}
{"code": "static void initialize_typed_array_from_array_buffer(GlobalObject& global_object, TypedArrayBase& typed_array, ArrayBuffer& array_buffer, Value byte_offset, Value length)\n{\n    auto& vm = global_object.vm();\n    auto element_size = typed_array.element_size();\n    auto offset = byte_offset.to_index(global_object);\n    if (vm.exception())\n        return;\n    if (offset % element_size != 0) {\n        vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidByteOffset, typed_array.class_name(), element_size, offset);\n        return;\n    }\n    size_t new_length { 0 };\n    if (!length.is_undefined()) {\n        new_length = length.to_index(global_object);\n        if (vm.exception())\n            return;\n    }\n    auto buffer_byte_length = array_buffer.byte_length();\n    size_t new_byte_length;\n    if (length.is_undefined()) {\n        if (buffer_byte_length % element_size != 0) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayInvalidBufferLength, typed_array.class_name(), element_size, buffer_byte_length);\n            return;\n        }\n        if (offset > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffset, offset, buffer_byte_length);\n            return;\n        }\n        new_byte_length = buffer_byte_length - offset;\n    } else {\n        new_byte_length = new_length * element_size;\n        if (offset + new_byte_length > buffer_byte_length) {\n            vm.throw_exception<RangeError>(global_object, ErrorType::TypedArrayOutOfRangeByteOffsetOrLength, offset, offset + new_byte_length, buffer_byte_length);\n            return;\n        }\n    }\n    typed_array.set_viewed_array_buffer(&array_buffer);\n    typed_array.set_byte_length(new_byte_length);\n    typed_array.set_byte_offset(offset);\n    typed_array.set_array_length(new_byte_length / element_size);\n}", "target": 1}
{"code": "updateDevice(const struct header * headers, time_t t)\n{\n\tstruct device ** pp = &devlist;\n\tstruct device * p = *pp;\t\n\twhile(p)\n\t{\n\t\tif(  p->headers[HEADER_NT].l == headers[HEADER_NT].l\n\t\t  && (0==memcmp(p->headers[HEADER_NT].p, headers[HEADER_NT].p, headers[HEADER_NT].l))\n\t\t  && p->headers[HEADER_USN].l == headers[HEADER_USN].l\n\t\t  && (0==memcmp(p->headers[HEADER_USN].p, headers[HEADER_USN].p, headers[HEADER_USN].l)) )\n\t\t{\n\t\t\tsyslog(LOG_DEBUG, \"device updated : %.*s\", headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t\t\tp->t = t;\n\t\t\tif(headers[HEADER_LOCATION].l > p->headers[HEADER_LOCATION].l)\n\t\t\t{\n\t\t\t\tstruct device * tmp;\n\t\t\t\ttmp = realloc(p, sizeof(struct device)\n\t\t\t\t    + headers[0].l+headers[1].l+headers[2].l);\n\t\t\t\tif(!tmp)\t\n\t\t\t\t{\n\t\t\t\t\tsyslog(LOG_ERR, \"updateDevice() : memory allocation error\");\n\t\t\t\t\t*pp = p->next;\t\n\t\t\t\t\tfree(p);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tp = tmp;\n\t\t\t\t*pp = p;\n\t\t\t}\n\t\t\tmemcpy(p->data + p->headers[0].l + p->headers[1].l,\n\t\t\t       headers[2].p, headers[2].l);\n\t\t\treturn 0;\n\t\t}\n\t\tpp = &p->next;\n\t\tp = *pp;\t\n\t}\n\tsyslog(LOG_INFO, \"new device discovered : %.*s\",\n\t       headers[HEADER_USN].l, headers[HEADER_USN].p);\n\t{\n\t\tchar * pc;\n\t\tint i;\n\t\tp = malloc(  sizeof(struct device)\n\t\t           + headers[0].l+headers[1].l+headers[2].l );\n\t\tif(!p) {\n\t\t\tsyslog(LOG_ERR, \"updateDevice(): cannot allocate memory\");\n\t\t\treturn -1;\n\t\t}\n\t\tp->next = devlist;\n\t\tp->t = t;\n\t\tpc = p->data;\n\t\tfor(i = 0; i < 3; i++)\n\t\t{\n\t\t\tp->headers[i].p = pc;\n\t\t\tp->headers[i].l = headers[i].l;\n\t\t\tmemcpy(pc, headers[i].p, headers[i].l);\n\t\t\tpc += headers[i].l;\n\t\t}\n\t\tdevlist = p;\n\t\tsendNotifications(NOTIF_NEW, p, NULL);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "ssize_t enc_untrusted_read(int fd, void *buf, size_t count) {\n  return static_cast<ssize_t>(EnsureInitializedAndDispatchSyscall(\n      asylo::system_call::kSYS_read, fd, buf, count));\n}", "target": 1}
{"code": "int nfc_disable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_DISABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->disable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_DISABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\tskcipher->setkey = alg->setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\treturn 0;\n}", "target": 1}
{"code": "static void vnc_refresh(DisplayChangeListener *dcl)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    int has_dirty, rects = 0;\n    if (QTAILQ_EMPTY(&vd->clients)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n        return;\n    }\n    graphic_hw_update(vd->dcl.con);\n    if (vnc_trylock_display(vd)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n        return;\n    }\n    has_dirty = vnc_refresh_server_surface(vd);\n    vnc_unlock_display(vd);\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        rects += vnc_update_client(vs, has_dirty, false);\n    }\n    if (has_dirty && rects) {\n        vd->dcl.update_interval /= 2;\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n        }\n    } else {\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n        }\n    }\n}", "target": 0}
{"code": "TEST(NNOpsTest, FractionalPool_ShapeFn) {\n  for (const char* op_name : {\"FractionalAvgPool\", \"FractionalMaxPool\"}) {\n    ShapeInferenceTestOp op(op_name);\n    auto set_op = [&op, op_name](const std::vector<float>& pooling_ratio) {\n      TF_ASSERT_OK(NodeDefBuilder(\"test\", op_name)\n                       .Input(\"input\", 0, DT_FLOAT)\n                       .Attr(\"pooling_ratio\", pooling_ratio)\n                       .Finalize(&op.node_def));\n    };\n    set_op(std::vector<float>{2.0f, 1, 1 / 1.5f, 1 / 2.0f});\n    INFER_ERROR(\"must be rank 4\", op, \"[?,?,?]\");\n    INFER_OK(op, \"?\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[?,?,?,?]\", \"[?,?,?,?];[?];[?]\");\n    INFER_OK(op, \"[10,20,30,40]\", \"[5,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[?,20,30,40]\", \"[?,20,45,80];[20];[45]\");\n    INFER_OK(op, \"[10,?,30,40]\", \"[5,?,45,80];[?];[45]\");\n    INFER_OK(op, \"[10,20,?,40]\", \"[5,20,?,80];[20];[?]\");\n    INFER_OK(op, \"[10,20,30,?]\", \"[5,20,45,?];[20];[45]\");\n    set_op(std::vector<float>{.5, 1.0, 1.5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{1, 2, 3, 4, 5});\n    INFER_ERROR(\"pooling_ratio field\", op, \"?\");\n    set_op(std::vector<float>{-1, 2, 3, 4});\n    INFER_ERROR(\"is negative\", op, \"[1,2,3,4]\");\n  }\n}", "target": 1}
{"code": "static inline void pipe_truncate(struct iov_iter *i)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tif (pipe->nrbufs) {\n\t\tsize_t off = i->iov_offset;\n\t\tint idx = i->idx;\n\t\tint nrbufs = (idx - pipe->curbuf) & (pipe->buffers - 1);\n\t\tif (off) {\n\t\t\tpipe->bufs[idx].len = off - pipe->bufs[idx].offset;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tnrbufs++;\n\t\t}\n\t\twhile (pipe->nrbufs > nrbufs) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n\t}\n}", "target": 0}
{"code": "double JOIN_TAB::scan_time()\n{\n  double res;\n  if (table->is_created())\n  {\n    if (table->is_filled_at_execution())\n    {\n      get_delayed_table_estimates(table, &records, &read_time,\n                                    &startup_cost);\n      found_records= records;\n      table->quick_condition_rows= records;\n    }\n    else\n    {\n      found_records= records= table->stat_records();\n      read_time= table->file->scan_time();\n    }\n    res= read_time;\n  }\n  else\n  {\n    found_records= records=table->stat_records();\n    read_time= found_records ? (double)found_records: 10.0;\n    res= read_time;\n  }\n  return res;\n}", "target": 0}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (!acpi_debugfs_dir)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (!cm_dentry)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 1}
{"code": "void btrfs_trans_release_chunk_metadata(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tif (!trans->chunk_bytes_reserved)\n\t\treturn;\n\tWARN_ON_ONCE(!list_empty(&trans->new_bgs));\n\tbtrfs_block_rsv_release(fs_info, &fs_info->chunk_block_rsv,\n\t\t\t\ttrans->chunk_bytes_reserved, NULL);\n\tatomic64_sub(trans->chunk_bytes_reserved, &cur_trans->chunk_bytes_reserved);\n\tcond_wake_up(&cur_trans->chunk_reserve_wait);\n\ttrans->chunk_bytes_reserved = 0;\n}", "target": 1}
{"code": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00 };\n\tif (cmd->msg_len > sizeof(b) - 4)\n\t\treturn -EINVAL;\n\tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n\tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\treturn 0;\n}", "target": 0}
{"code": "sdev_iter_snapshots(struct vnode *dvp, char *name)\n{\n\tsdev_iter_datasets(dvp, ZFS_IOC_SNAPSHOT_LIST_NEXT, name);\n}", "target": 0}
{"code": "static int fetch_uidl(char *line, void *data)\n{\n  int i, index;\n  struct Context *ctx = (struct Context *) data;\n  struct PopData *pop_data = (struct PopData *) ctx->data;\n  char *endp = NULL;\n  errno = 0;\n  index = strtol(line, &endp, 10);\n  if (errno)\n    return -1;\n  while (*endp == ' ')\n    endp++;\n  memmove(line, endp, strlen(endp) + 1);\n  if (strlen(line) == 0)\n    return -1;\n  for (i = 0; i < ctx->msgcount; i++)\n    if (mutt_str_strcmp(line, ctx->hdrs[i]->data) == 0)\n      break;\n  if (i == ctx->msgcount)\n  {\n    mutt_debug(1, \"new header %d %s\\n\", index, line);\n    if (i >= ctx->hdrmax)\n      mx_alloc_memory(ctx);\n    ctx->msgcount++;\n    ctx->hdrs[i] = mutt_header_new();\n    ctx->hdrs[i]->data = mutt_str_strdup(line);\n  }\n  else if (ctx->hdrs[i]->index != index - 1)\n    pop_data->clear_cache = true;\n  ctx->hdrs[i]->refno = index;\n  ctx->hdrs[i]->index = index - 1;\n  return 0;\n}", "target": 0}
{"code": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n  struct mailimf_group * group;\n  int r;\n  int res;\n  clist * list;\n  cur_token = * indx;\n  mailbox_list = NULL;\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto free_display_name;\n    }\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_display_name;\n    }\n    mailbox_list = mailimf_mailbox_list_new(list);\n    if (mailbox_list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      clist_free(list);\n      goto free_display_name;\n    }\n    break;\n  default:\n    res = r;\n    goto free_display_name;\n  }\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n  * indx = cur_token;\n  * result = group;\n  return MAILIMF_NO_ERROR;\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}", "target": 0}
{"code": "static bool translation_pre_enabled(struct intel_iommu *iommu)\n{\n\treturn (iommu->flags & VTD_FLAG_TRANS_PRE_ENABLED);\n}", "target": 0}
{"code": "static int em_fxsave(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tsize_t size;\n\tint rc;\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->ops->get_fpu(ctxt);\n\trc = asm_safe(\"fxsave %[fx]\", , [fx] \"+m\"(fx_state));\n\tctxt->ops->put_fpu(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)\n\t\tsize = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);\n\telse\n\t\tsize = offsetof(struct fxregs_state, xmm_space[0]);\n\treturn segmented_write(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n}", "target": 1}
{"code": "void big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\tkey_payload_reserve(key, 0);\n\tif (key_is_instantiated(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}", "target": 1}
{"code": "bgp_capability_restart (struct peer *peer, struct capability_header *caphdr)\n{\n  struct stream *s = BGP_INPUT (peer);\n  u_int16_t restart_flag_time;\n  int restart_bit = 0;\n  size_t end = stream_get_getp (s) + caphdr->length;\n  SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n  restart_flag_time = stream_getw(s);\n  if (CHECK_FLAG (restart_flag_time, RESTART_R_BIT))\n    restart_bit = 1;\n  UNSET_FLAG (restart_flag_time, 0xF000);\n  peer->v_gr_restart = restart_flag_time;\n  if (BGP_DEBUG (normal, NORMAL))\n    {\n      zlog_debug (\"%s OPEN has Graceful Restart capability\", peer->host);\n      zlog_debug (\"%s Peer has%srestarted. Restart Time : %d\",\n                  peer->host, restart_bit ? \" \" : \" not \",\n                  peer->v_gr_restart);\n    }\n  while (stream_get_getp (s) + 4 < end)\n    {\n      afi_t afi = stream_getw (s);\n      safi_t safi = stream_getc (s);\n      u_char flag = stream_getc (s);\n      if (!bgp_afi_safi_valid_indices (afi, &safi))\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Addr-family %d/%d(afi/safi) not supported.\"\n                        \" Ignore the Graceful Restart capability\",\n                        peer->host, afi, safi);\n        }\n      else if (!peer->afc[afi][safi])\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Addr-family %d/%d(afi/safi) not enabled.\"\n                        \" Ignore the Graceful Restart capability\",\n                        peer->host, afi, safi);\n        }\n      else\n        {\n          if (BGP_DEBUG (normal, NORMAL))\n            zlog_debug (\"%s Address family %s is%spreserved\", peer->host,\n                        afi_safi_print (afi, safi),\n                        CHECK_FLAG (peer->af_cap[afi][safi],\n                                    PEER_CAP_RESTART_AF_PRESERVE_RCV)\n                        ? \" \" : \" not \");\n          SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n          if (CHECK_FLAG (flag, RESTART_F_BIT))\n            SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);\n        }\n    }\n  return 0;\n}", "target": 0}
{"code": "void thread_func(unsigned int start, unsigned int end, int fd)\n{\n\tstruct qcedev_cipher_op_req req = { 0 };\n\tunsigned int i;\n\tchar *data;\n\tdata = mmap(NULL, 0xFFFFFF * 3, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE|MAP_POPULATE, -1, 0);\n\tif (data == MAP_FAILED) {\n\t\tprintf(\"mmap failed, get a better phone\\n\");\n\t\texit(0);\n\t}\n\tfor (i = 0; i < 0xFFFFFF * 3; i += sizeof(void*))\n\t\t*((unsigned long *)(data + i)) = 0xABADACC355001337;\n\treq.in_place_op = 1;\n\treq.entries = 2;\n\treq.byteoffset = 15;\n\treq.mode = QCEDEV_AES_MODE_CTR;\n\treq.op = QCEDEV_OPER_ENC;\n\treq.ivlen = 1;\n\treq.data_len = 0xFFFFFFFE;\n\treq.vbuf.src[0].len = 4;\n\treq.vbuf.src[1].len = 0xFFFFFFFE - 4;\n\treq.vbuf.src[0].vaddr = (uint8_t*)data;\n\treq.vbuf.src[1].vaddr = (uint8_t*)data;\n\treq.vbuf.dst[0].len = 4;\n\treq.vbuf.dst[1].len = 0xFFFFFFFE - 4;\n\treq.vbuf.dst[0].vaddr = (uint8_t*)data;\n\treq.vbuf.dst[1].vaddr = (uint8_t*)data;\n\tioctl(fd, QCEDEV_IOCTL_ENC_REQ, &req);\n\tprintf(\"exiting\\n\");\n\texit(0);\n}", "target": 0}
{"code": "long do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, siginfo_t *info)\n{\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\tif (info->si_code >= 0)\n\t\treturn -EPERM;\n\tinfo->si_signo = sig;\n\treturn do_send_specific(tgid, pid, sig, info);\n}", "target": 1}
{"code": "tar_directory_for_file (GsfInfileTar *dir, const char *name, gboolean last)\n{\n\tconst char *s = name;\n\twhile (1) {\n\t\tconst char *s0 = s;\n\t\tchar *dirname;\n\t\twhile (1) {\n\t\t\tif (*s == 0) {\n\t\t\t\tif (last && s != s0)\n\t\t\t\t\tbreak;\n\t\t\t\telse\n\t\t\t\t\treturn dir;\n\t\t\t}\n\t\t\tif (*s == '/')\n\t\t\t\tbreak;\n\t\t\ts++;\n\t\t}\n\t\tdirname = g_strndup (s0, s - s0);\n\t\twhile (*s == '/')\n\t\t\ts++;\n\t\tif (strcmp (dirname, \".\") != 0) {\n\t\t\tGsfInput *subdir =\n\t\t\t\tgsf_infile_child_by_name (GSF_INFILE (dir),\n\t\t\t\t\t\t\t  dirname);\n\t\t\tif (subdir) {\n\t\t\t\tg_object_unref (subdir);\n\t\t\t\tdir = GSF_INFILE_TAR (subdir);\n\t\t\t} else\n\t\t\t\tdir = tar_create_dir (dir, dirname);\n\t\t}\n\t\tg_free (dirname);\n\t}\n}", "target": 1}
{"code": "int authRequired(client *c) {\n    int auth_required = (!(DefaultUser->flags & USER_FLAG_NOPASS) ||\n                          (DefaultUser->flags & USER_FLAG_DISABLED)) &&\n                        !c->authenticated;\n    return auth_required;\n}", "target": 0}
{"code": "TfLiteRegistration GetPassthroughOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.init = [](TfLiteContext* context, const char*, size_t) -> void* {\n    auto* first_new_tensor = new int;\n    context->AddTensors(context, 2, first_new_tensor);\n    return first_new_tensor;\n  };\n  reg.free = [](TfLiteContext* context, void* buffer) {\n    delete static_cast<int*>(buffer);\n  };\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    auto* first_new_tensor = static_cast<int*>(node->user_data);\n    const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n    TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n    TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, tensor1, newSize));\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(2);\n    for (int i = 0; i < 2; ++i) {\n      node->temporaries->data[i] = *(first_new_tensor) + i;\n    }\n    auto setup_temporary = [&](int id) {\n      TfLiteTensor* tmp = &context->tensors[id];\n      tmp->type = kTfLiteFloat32;\n      tmp->allocation_type = kTfLiteArenaRw;\n      return context->ResizeTensor(context, tmp,\n                                   TfLiteIntArrayCopy(tensor0->dims));\n    };\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[0]));\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[1]));\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    auto populate = [&](int id) {\n      TfLiteTensor* t = &context->tensors[id];\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        t->data.f[i] = a0->data.f[i];\n      }\n    };\n    populate(node->outputs->data[0]);\n    populate(node->temporaries->data[0]);\n    populate(node->temporaries->data[1]);\n    return kTfLiteOk;\n  };\n  return reg;\n}", "target": 1}
{"code": "mark_trusted_task_done (GObject      *source_object,\n                        GAsyncResult *res,\n                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 1}
{"code": "TEST_P(RedirectIntegrationTest, InternalRedirectHandledByDirectResponse) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n  redirect_response_.setLocation(\"http:\n  upstream_request_->encodeHeaders(redirect_response_, true);\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"204\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"204 direct_response -\\n\"));\n}", "target": 0}
{"code": "static int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}", "target": 1}
{"code": "static int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS; i++) {\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) {\n  if (MinSize > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2));\n  NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX));\n  T *NewElts = static_cast<T*>(llvh::safe_malloc(NewCapacity*sizeof(T)));\n  this->uninitialized_move(this->begin(), this->end(), NewElts);\n  destroy_range(this->begin(), this->end());\n  if (!this->isSmall())\n    free(this->begin());\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}", "target": 1}
{"code": "void ieee80211_check_fast_rx_iface(struct ieee80211_sub_if_data *sdata)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tmutex_lock(&local->sta_mtx);\n\t__ieee80211_check_fast_rx_iface(sdata);\n\tmutex_unlock(&local->sta_mtx);\n}", "target": 0}
{"code": "static void __init deferred_free_range(unsigned long pfn,\n\t\t\t\t       unsigned long nr_pages)\n{\n\tstruct page *page;\n\tunsigned long i;\n\tif (!nr_pages)\n\t\treturn;\n\tpage = pfn_to_page(pfn);\n\tif (nr_pages == pageblock_nr_pages &&\n\t    (pfn & (pageblock_nr_pages - 1)) == 0) {\n\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, pageblock_order);\n\t\treturn;\n\t}\n\tfor (i = 0; i < nr_pages; i++, page++, pfn++) {\n\t\tif ((pfn & (pageblock_nr_pages - 1)) == 0)\n\t\t\tset_pageblock_migratetype(page, MIGRATE_MOVABLE);\n\t\t__free_pages_boot_core(page, 0);\n\t}\n}", "target": 0}
{"code": "int ndpi_netbios_name_interpret(char *in, size_t in_len, char *out, u_int out_len) {\n  u_int ret = 0, len, idx = in_len, out_idx = 0;\n  len = (*in++)/2;\n  out_len--;\n  out[out_idx] = 0;\n  if((len > out_len) || (len < 1) || ((2*len) > in_len))\n    return(-1);\n  while((len--) && (out_idx < out_len)) {\n    if((idx < 2) || (in[0] < 'A') || (in[0] > 'P') || (in[1] < 'A') || (in[1] > 'P')) {\n      out[out_idx] = 0;\n      break;\n    }\n    out[out_idx] = ((in[0] - 'A') << 4) + (in[1] - 'A');\n    in += 2, idx -= 2;\n    if(isprint(out[out_idx]))\n      out_idx++, ret++;\n  }\n  if(out_idx > 0) {\n    out[out_idx] = 0;\n    out_idx--;\n    while((out_idx > 0) && (out[out_idx] == ' ')) {\n      out[out_idx] = 0;\n      out_idx--;\n    }\n  }\n  return(ret);\n}", "target": 1}
{"code": "static bool kvm_vcpu_check_code_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static void ax25_kill_by_device(struct net_device *dev)\n{\n\tax25_dev *ax25_dev;\n\tax25_cb *s;\n\tstruct sock *sk;\n\tif ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL)\n\t\treturn;\n\tspin_lock_bh(&ax25_list_lock);\nagain:\n\tax25_for_each(s, &ax25_list) {\n\t\tif (s->ax25_dev == ax25_dev) {\n\t\t\tsk = s->sk;\n\t\t\tif (!sk) {\n\t\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\t\ts->ax25_dev = NULL;\n\t\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\t\tgoto again;\n\t\t\t}\n\t\t\tsock_hold(sk);\n\t\t\tspin_unlock_bh(&ax25_list_lock);\n\t\t\tlock_sock(sk);\n\t\t\ts->ax25_dev = NULL;\n\t\t\tif (sk->sk_socket) {\n\t\t\t\tdev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker);\n\t\t\t\tax25_dev_put(ax25_dev);\n\t\t\t}\n\t\t\tax25_disconnect(s, ENETUNREACH);\n\t\t\trelease_sock(sk);\n\t\t\tspin_lock_bh(&ax25_list_lock);\n\t\t\tsock_put(sk);\n\t\t\tgoto again;\n\t\t}\n\t}\n\tspin_unlock_bh(&ax25_list_lock);\n}", "target": 1}
{"code": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ net_hash_mix(net),\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}", "target": 1}
{"code": "int uev_init1(uev_ctx_t *ctx, int maxevents)\n{\n\tif (!ctx || maxevents < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (maxevents > UEV_MAX_EVENTS)\n\t\tmaxevents = UEV_MAX_EVENTS;\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->maxevents = maxevents;\n\treturn _init(ctx, 0);\n}", "target": 0}
{"code": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\tNT_ASSERT(size);\n#pragma prefast(suppress : 30030)\t\t\n\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\treturn block->data;\n}", "target": 1}
{"code": "juniper_ggsn_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_ggsn_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t proto;\n            uint8_t flags;\n            uint8_t vlan_id[2];\n            uint8_t res[2];\n        };\n        const struct juniper_ggsn_header *gh;\n        l2info.pictype = DLT_JUNIPER_GGSN;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        gh = (struct juniper_ggsn_header *)&l2info.cookie;\n        ND_TCHECK(*gh);\n        if (ndo->ndo_eflag) {\n            ND_PRINT((ndo, \"proto %s (%u), vlan %u: \",\n                   tok2str(juniper_protocol_values,\"Unknown\",gh->proto),\n                   gh->proto,\n                   EXTRACT_16BITS(&gh->vlan_id[0])));\n        }\n        switch (gh->proto) {\n        case JUNIPER_PROTO_IPV4:\n            ip_print(ndo, p, l2info.length);\n            break;\n        case JUNIPER_PROTO_IPV6:\n            ip6_print(ndo, p, l2info.length);\n            break;\n        default:\n            if (!ndo->ndo_eflag)\n                ND_PRINT((ndo, \"unknown GGSN proto (%u)\", gh->proto));\n        }\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "int HTPFileOpenWithRange(HtpState *s, HtpTxUserData *txud, const uint8_t *filename,\n        uint16_t filename_len, const uint8_t *data, uint32_t data_len, uint64_t txid,\n        bstr *rawvalue, HtpTxUserData *htud)\n{\n    SCEnter();\n    uint16_t flags;\n    DEBUG_VALIDATE_BUG_ON(s == NULL);\n    HTTPContentRange crparsed;\n    if (HTPParseAndCheckContentRange(rawvalue, &crparsed, s, htud) != 0) {\n        return HTPFileOpen(s, txud, filename, filename_len, data, data_len, txid, STREAM_TOCLIENT);\n    }\n    flags = FileFlowToFlags(s->f, STREAM_TOCLIENT);\n    FileContainer *files = &txud->files_tc;\n    if (FileOpenFileWithId(files, &htp_sbcfg, s->file_track_id++, filename, filename_len, data,\n                data_len, flags) != 0) {\n        SCReturnInt(-1);\n    } else {\n        const HTPCfgDir *cfg = &s->cfg->response;\n        FileSetInspectSizes(files->tail, cfg->inspect_window, cfg->inspect_min_size);\n    }\n    txud->tx_data.files_opened++;\n    if (FileSetRange(files, crparsed.start, crparsed.end) < 0) {\n        SCLogDebug(\"set range failed\");\n    }\n    htp_tx_t *tx = htp_list_get(s->conn->transactions, txid);\n    if (!tx) {\n        SCReturnInt(-1);\n    }\n    uint8_t *keyurl;\n    uint32_t keylen;\n    if (tx->request_hostname != NULL) {\n        keylen = bstr_len(tx->request_hostname) + filename_len;\n        keyurl = SCMalloc(keylen);\n        if (keyurl == NULL) {\n            SCReturnInt(-1);\n        }\n        memcpy(keyurl, bstr_ptr(tx->request_hostname), bstr_len(tx->request_hostname));\n        memcpy(keyurl + bstr_len(tx->request_hostname), filename, filename_len);\n    } else {\n        SCReturnInt(0);\n    }\n    DEBUG_VALIDATE_BUG_ON(htud->file_range);\n    htud->file_range = HttpRangeContainerOpenFile(keyurl, keylen, s->f, &crparsed, &htp_sbcfg,\n            filename, filename_len, flags, data, data_len);\n    SCFree(keyurl);\n    if (htud->file_range == NULL) {\n        SCReturnInt(-1);\n    }\n    SCReturnInt(0);\n}", "target": 1}
{"code": "static bool dccp_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t     unsigned int dataoff, unsigned int *timeouts)\n{\n\tstruct net *net = nf_ct_net(ct);\n\tstruct dccp_net *dn;\n\tstruct dccp_hdr _dh, *dh;\n\tconst char *msg;\n\tu_int8_t state;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tBUG_ON(dh == NULL);\n\tstate = dccp_state_table[CT_DCCP_ROLE_CLIENT][dh->dccph_type][CT_DCCP_NONE];\n\tswitch (state) {\n\tdefault:\n\t\tdn = dccp_pernet(net);\n\t\tif (dn->dccp_loose == 0) {\n\t\t\tmsg = \"nf_ct_dccp: not picking up existing connection \";\n\t\t\tgoto out_invalid;\n\t\t}\n\tcase CT_DCCP_REQUEST:\n\t\tbreak;\n\tcase CT_DCCP_INVALID:\n\t\tmsg = \"nf_ct_dccp: invalid state transition \";\n\t\tgoto out_invalid;\n\t}\n\tct->proto.dccp.role[IP_CT_DIR_ORIGINAL] = CT_DCCP_ROLE_CLIENT;\n\tct->proto.dccp.role[IP_CT_DIR_REPLY] = CT_DCCP_ROLE_SERVER;\n\tct->proto.dccp.state = CT_DCCP_NONE;\n\tct->proto.dccp.last_pkt = DCCP_PKT_REQUEST;\n\tct->proto.dccp.last_dir = IP_CT_DIR_ORIGINAL;\n\tct->proto.dccp.handshake_seq = 0;\n\treturn true;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, nf_ct_l3num(ct), 0, skb, NULL, NULL,\n\t\t\t      NULL, \"%s\", msg);\n\treturn false;\n}", "target": 1}
{"code": "static void account_pipe_buffers(struct pipe_inode_info *pipe,\n                                 unsigned long old, unsigned long new)\n{\n\tatomic_long_add(new - old, &pipe->user->pipe_bufs);\n}", "target": 0}
{"code": "PHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n\t\treturn;\n\t}\n\tif ( input <= 0.0 || output <= 0.0 ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Gamma values should be positive\");\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "int task_statm(struct mm_struct *mm, int *shared, int *text,\n\t       int *data, int *resident)\n{\n\t*shared = get_mm_counter(mm, file_rss);\n\t*text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK))\n\t\t\t\t\t\t\t\t>> PAGE_SHIFT;\n\t*data = mm->total_vm - mm->shared_vm;\n\t*resident = *shared + get_mm_counter(mm, anon_rss);\n\treturn mm->total_vm;\n}", "target": 0}
{"code": "static int cma_accept_iw(struct rdma_id_private *id_priv,\n\t\t  struct rdma_conn_param *conn_param)\n{\n\tstruct iw_cm_conn_param iw_param;\n\tint ret;\n\tif (!conn_param)\n\t\treturn -EINVAL;\n\tret = cma_modify_qp_rtr(id_priv, conn_param);\n\tif (ret)\n\t\treturn ret;\n\tiw_param.ord = conn_param->initiator_depth;\n\tiw_param.ird = conn_param->responder_resources;\n\tiw_param.private_data = conn_param->private_data;\n\tiw_param.private_data_len = conn_param->private_data_len;\n\tif (id_priv->id.qp)\n\t\tiw_param.qpn = id_priv->qp_num;\n\telse\n\t\tiw_param.qpn = conn_param->qp_num;\n\treturn iw_cm_accept(id_priv->cm_id.iw, &iw_param);\n}", "target": 0}
{"code": "cmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "u32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\treturn 0;\n}", "target": 0}
{"code": "static void mmtimer_setup_int_0(int cpu, u64 expires)\n{\n\tu64 val;\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE), 0UL);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPB), -1L);\n\tmmtimer_clr_int_pending(0);\n\tval = ((u64)SGI_MMTIMER_VECTOR << SH_RTC1_INT_CONFIG_IDX_SHFT) |\n\t\t((u64)cpu_physical_id(cpu) <<\n\t\t\tSH_RTC1_INT_CONFIG_PID_SHFT);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_CONFIG), val);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_RTC1_INT_ENABLE), 1UL);\n\tHUB_S((u64 *)LOCAL_MMR_ADDR(SH_INT_CMPB), expires);\n}", "target": 0}
{"code": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n  LOG_DEBUG(5, \"Extracting: \" << path);\n  return extract(*SystemUtilities::oopen(path));\n}", "target": 1}
{"code": "static TEE_Result set_rmem_param(const struct optee_msg_param_rmem *rmem,\n\t\t\t\t struct param_mem *mem)\n{\n\tsize_t req_size = 0;\n\tuint64_t shm_ref = READ_ONCE(rmem->shm_ref);\n\tmem->mobj = mobj_reg_shm_get_by_cookie(shm_ref);\n\tif (!mem->mobj)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tmem->offs = READ_ONCE(rmem->offs);\n\tmem->size = READ_ONCE(rmem->size);\n\tif (ADD_OVERFLOW(mem->offs, mem->size, &req_size) ||\n\t    mem->mobj->size < req_size)\n\t\treturn TEE_ERROR_SECURITY;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "inline void GatherNd(const RuntimeShape& params_shape,\n                     const ParamsT* params_data,\n                     const RuntimeShape& indices_shape,\n                     const IndicesT* indices_data,\n                     const RuntimeShape& output_shape, ParamsT* output_data) {\n  ruy::profiler::ScopeLabel label(\"GatherNd\");\n  const GatherNdHelperResult res = GatherNdHelper(params_shape, indices_shape);\n  for (int i = 0; i < res.n_slices; ++i) {\n    int from_pos = 0;\n    for (int j = 0; j < res.indices_nd; ++j) {\n      from_pos += indices_data[i * res.indices_nd + j] * res.dims_to_count[j];\n    }\n    std::memcpy(output_data + i * res.slice_size, params_data + from_pos,\n                sizeof(ParamsT) * res.slice_size);\n  }\n}", "target": 1}
{"code": "nfs4_xdr_dec_setacl(struct rpc_rqst *rqstp, struct xdr_stream *xdr,\n\t\t    struct nfs_setaclres *res)\n{\n\tstruct compound_hdr hdr;\n\tint status;\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_setattr(xdr);\nout:\n\treturn status;\n}", "target": 0}
{"code": "NOEXPORT void print_tmp_key(SSL *s) {\n    EVP_PKEY *key;\n    if (!SSL_get_peer_tmp_key(s, &key)) {\n        sslerror(\"SSL_get_peer_tmp_key\");\n        return;\n    }\n    switch (EVP_PKEY_id(key)) {\n    case EVP_PKEY_RSA:\n        s_log(LOG_INFO, \"Peer temporary key: RSA, %d bits\", EVP_PKEY_bits(key));\n        break;\n    case EVP_PKEY_DH:\n        s_log(LOG_INFO, \"Peer temporary key: DH, %d bits\", EVP_PKEY_bits(key));\n        break;\n#ifndef OPENSSL_NO_EC\n    case EVP_PKEY_EC:\n        {\n            EC_KEY *ec=EVP_PKEY_get1_EC_KEY(key);\n            int nid=EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));\n            const char *cname=EC_curve_nid2nist(nid);\n            EC_KEY_free(ec);\n            if (cname == NULL)\n                cname=OBJ_nid2sn(nid);\n            s_log(LOG_INFO, \"Peer temporary key: ECDH, %s, %d bits\", cname, EVP_PKEY_bits(key));\n        }\n        break;\n#endif\n    default:\n        s_log(LOG_INFO, \"Peer temporary key: %s, %d bits\", OBJ_nid2sn(EVP_PKEY_id(key)),\n                   EVP_PKEY_bits(key));\n    }\n    EVP_PKEY_free(key);\n}", "target": 0}
{"code": "static char* umocktypes_stringify_bool_ptr(const bool** value)\n{\n    char* result;\n    result = (char*)my_gballoc_malloc(8);\n    if (result != NULL)\n    {\n        if (*value == NULL)\n        {\n            (void)strcpy(result, \"{NULL}\");\n        }\n        else if (*(*value) == true)\n        {\n            (void)strcpy(result, \"{true}\");\n        }\n        else\n        {\n            (void)strcpy(result, \"{false}\");\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "accept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceListenObj    listener;\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n        ice_conn = IceAcceptConnection (listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        g_object_unref (client);\n        return TRUE;\n}", "target": 1}
{"code": "bool ImageIsJPEG( String const& filename ) {\n   try {\n      JpegInput jpeg( filename );\n   } catch( ... ) {\n      return false;\n   }\n   return true;\n}", "target": 1}
{"code": "static int core_map_to_storage(request_rec *r)\n{\n    int access_status;\n    if ((access_status = ap_directory_walk(r))) {\n        return access_status;\n    }\n    if ((access_status = ap_file_walk(r))) {\n        return access_status;\n    }\n    return OK;\n}", "target": 0}
{"code": "static inline __must_check bool try_get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (WARN_ON_ONCE(page_ref_count(page) <= 0))\n\t\treturn false;\n\tpage_ref_inc(page);\n\treturn true;\n}", "target": 0}
{"code": "static const gchar* fcwwn_name_res_str(const address* addr)\n{\n    const guint8 *addrp = (const guint8*)addr->data;\n    int fmt;\n    guint8 oui[6];\n    fmt = (addrp[0] & 0xF0) >> 4;\n    switch (fmt) {\n    case FC_NH_NAA_IEEE:\n    case FC_NH_NAA_IEEE_E:\n        memcpy (oui, &addrp[2], 6);\n        return get_manuf_name(oui);\n    case FC_NH_NAA_IEEE_R:\n        oui[0] = ((addrp[0] & 0x0F) << 4) | ((addrp[1] & 0xF0) >> 4);\n        oui[1] = ((addrp[1] & 0x0F) << 4) | ((addrp[2] & 0xF0) >> 4);\n        oui[2] = ((addrp[2] & 0x0F) << 4) | ((addrp[3] & 0xF0) >> 4);\n        oui[3] = ((addrp[3] & 0x0F) << 4) | ((addrp[4] & 0xF0) >> 4);\n        oui[4] = ((addrp[4] & 0x0F) << 4) | ((addrp[5] & 0xF0) >> 4);\n        oui[5] = ((addrp[5] & 0x0F) << 4) | ((addrp[6] & 0xF0) >> 4);\n        return get_manuf_name(oui);\n    }\n    return \"\";\n}", "target": 1}
{"code": "HMAC_SHA256_Init(struct HMAC_SHA256_CTX * ctx, const void * _K, size_t Klen)\n{\n  unsigned char pad[64];\n  unsigned char khash[32];\n  const unsigned char * K = (unsigned char *) _K;\n  size_t i;\n  if (Klen > 64) {\n    SHA256_Init(&ctx->ictx);\n    scrypt_SHA256_Update(&ctx->ictx, K, Klen);\n    scrypt_SHA256_Final(khash, &ctx->ictx);\n    K = khash;\n    Klen = 32;\n  }\n  SHA256_Init(&ctx->ictx);\n  memset(pad, 0x36, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  scrypt_SHA256_Update(&ctx->ictx, pad, 64);\n  SHA256_Init(&ctx->octx);\n  memset(pad, 0x5c, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  scrypt_SHA256_Update(&ctx->octx, pad, 64);\n  memset(khash, 0, 32);\n}", "target": 1}
{"code": "void SetLineWidth(double w) {\n    outpos +=\n    sprintf(outpos,\" %12.3f w\",w);\n}", "target": 1}
{"code": "int install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\tif (new->thread_keyring)\n\t\treturn 0;\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}", "target": 0}
{"code": "NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void * nedpcalloc(nedpool *p, size_t no, size_t size) THROWSPEC\n{\n\tunsigned flags=NEDMALLOC_FORCERESERVE(p, 0, no*size);\n\treturn nedpmalloc2(p, size*no, 0, M2_ZERO_MEMORY|flags);\n}", "target": 1}
{"code": "static int dns_stream_complete(DnsStream *s, int error) {\n        _cleanup_(dns_stream_unrefp) _unused_ DnsStream *ref = dns_stream_ref(s); \n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n        if (s->complete)\n                s->complete(s, error);\n        else \n                dns_stream_unref(s);\n        return 0;\n}", "target": 0}
{"code": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}", "target": 1}
{"code": "static inline void pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tbuf->ops->get(pipe, buf);\n}", "target": 1}
{"code": "static void iommu_disable_protect_mem_regions(struct intel_iommu *iommu)\n{\n\tu32 pmen;\n\tunsigned long flags;\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\tpmen = readl(iommu->reg + DMAR_PMEN_REG);\n\tpmen &= ~DMA_PMEN_EPM;\n\twritel(pmen, iommu->reg + DMAR_PMEN_REG);\n\tIOMMU_WAIT_OP(iommu, DMAR_PMEN_REG,\n\t\treadl, !(pmen & DMA_PMEN_PRS), pmen);\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}", "target": 0}
{"code": "static int tipc_crypto_key_revoke(struct net *net, u8 tx_key)\n{\n\tstruct tipc_crypto *tx = tipc_net(net)->crypto_tx;\n\tstruct tipc_key key;\n\tspin_lock(&tx->lock);\n\tkey = tx->key;\n\tWARN_ON(!key.active || tx_key != key.active);\n\ttipc_crypto_key_set_state(tx, key.passive, 0, key.pending);\n\ttipc_crypto_key_detach(tx->aead[key.active], &tx->lock);\n\tspin_unlock(&tx->lock);\n\tpr_warn(\"%s: key is revoked\\n\", tx->name);\n\treturn -EKEYREVOKED;\n}", "target": 1}
{"code": "R_API size_t r_str_ansi_strip(char *str) {\n\tsize_t i = 0;\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\tr_str_cpy (str + i + 1, str + i + chlen);\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}", "target": 1}
{"code": "static int dbConnect(char *host, char *user, char *passwd)\n{\n  DBUG_ENTER(\"dbConnect\");\n  if (verbose)\n  {\n    fprintf(stderr, \"# Connecting to %s...\\n\", host ? host : \"localhost\");\n  }\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlcheck\");\n  if (!(sock = mysql_real_connect(&mysql_connection, host, user, passwd,\n         NULL, opt_mysql_port, opt_mysql_unix_port, 0)))\n  {\n    DBerror(&mysql_connection, \"when trying to connect\");\n    DBUG_RETURN(1);\n  }\n  mysql_connection.reconnect= 1;\n  DBUG_RETURN(0);\n} ", "target": 1}
{"code": "int read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n  if (text[1] == EOF)\n    return 0;\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n    if (text[2] == EOF)\n      return 0;\n    text[3] = RE_YY_INPUT(yyscanner);\n    if (text[3] == EOF)\n      return 0;\n  }\n  *escaped_char = escaped_char_value(text);\n  return 1;", "target": 1}
{"code": "Bool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}", "target": 0}
{"code": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n    pop_finished_files();\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n        free = BSIZE - copy;\n    }\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n    return true;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayReduceSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, i;\n    Jsi_Obj *obj;\n    Jsi_Value *func, *vpargs, *ini = Jsi_ValueArrayIndex(interp, args, 1);\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0)\n        Jsi_ObjSetLength(interp, obj, 0);\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_Value *vobjs[4];\n    int n, rev = (op==2);\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>4)\n        maa = 4;\n    for (n = 0, i = (rev?obj->arrCnt-1:0); (rev?i>=0:i < (int)obj->arrCnt) && rc == JSI_OK; n++, i = (rev?i-1:i+1)) {\n        if (!obj->arr[i]) continue;\n        if (n==0 && !ini) {\n            ini = obj->arr[i];\n            continue;\n        }\n        vobjs[0] = ini;\n        vobjs[1] = obj->arr[i];\n        vobjs[2] = (maa>2?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[3] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, NULL);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        ini = nrPtr;\n    }\n    if (rc == JSI_OK && ini)\n        Jsi_ValueCopy(interp, *ret, ini); \n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n}", "target": 1}
{"code": "void dns_server_init(struct netif * pnetif)\n{\n\tuint8_t *ip;\n\tif (dns_server_pcb != NULL) {\n\t\tudp_remove(dns_server_pcb);\n\t\tdns_server_pcb = NULL;\n\t}\n\tdns_server_pcb = udp_new();\n\tif (dns_server_pcb == NULL) {\n\t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n\t\treturn;\n\t}\n\tudp_bind(dns_server_pcb, IP_ADDR_ANY, DNS_SERVER_PORT);\n\tudp_recv(dns_server_pcb, dnss_receive_udp_packet_handler, NULL);\n}", "target": 0}
{"code": "  bool handleBackslash(signed char& out) {\n    char ch = *p++;\n    switch (ch) {\n      case 0: return false;\n      case '\"': out = ch; return true;\n      case '\\\\': out = ch; return true;\n      case '/': out = ch; return true;\n      case 'b': out = '\\b'; return true;\n      case 'f': out = '\\f'; return true;\n      case 'n': out = '\\n'; return true;\n      case 'r': out = '\\r'; return true;\n      case 't': out = '\\t'; return true;\n      case 'u': {\n        if (UNLIKELY(is_tsimplejson)) {\n          auto const ch1 = *p++;\n          auto const ch2 = *p++;\n          auto const dch3 = dehexchar(*p++);\n          auto const dch4 = dehexchar(*p++);\n          if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) {\n            return false;\n          }\n          out = (dch3 << 4) | dch4;\n          return true;\n        } else {\n          uint16_t u16cp = 0;\n          for (int i = 0; i < 4; i++) {\n            auto const hexv = dehexchar(*p++);\n            if (hexv < 0) return false; \n            u16cp <<= 4;\n            u16cp |= hexv;\n          }\n          if (u16cp > 0x7f) {\n            return false;\n          } else {\n            out = u16cp;\n            return true;\n          }\n        }\n      }\n      default: return false;\n    }\n  }", "target": 1}
{"code": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint16 plane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n\trowsperstrip=td->td_rowsperstrip;\n\tif (rowsperstrip>td->td_imagelength)\n\t\trowsperstrip=td->td_imagelength;\n\tstripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip);\n\tstripinplane=(strip%stripsperplane);\n\tplane=(uint16)(strip/stripsperplane);\n\trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}", "target": 1}
{"code": "ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {\n\tut64 addr = 0LL;\n\tstruct symbol_t *symbols;\n\tint i;\n\tif (!(symbols = MACH0_(get_symbols) (bin))) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\taddr = symbols[i].addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (symbols);\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n\t\t\treturn 0;\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\t\t\t}\n\t\t}\n\t}\n\treturn addr;\n}", "target": 1}
{"code": "isdn_receive_skb_callback(int di, int channel, struct sk_buff *skb)\n{\n\tint i;\n\tif ((i = isdn_dc2minor(di, channel)) == -1) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tdev->ibytes[i] += skb->len;\n\tif (isdn_net_rcv_skb(i, skb))\n\t\treturn;\n\tif (dev->v110[i]) {\n\t\tatomic_inc(&dev->v110use[i]);\n\t\tskb = isdn_v110_decode(dev->v110[i], skb);\n\t\tatomic_dec(&dev->v110use[i]);\n\t\tif (!skb)\n\t\t\treturn;\n\t}\n\tif (skb->len) {\n\t\tif (isdn_tty_rcv_skb(i, di, channel, skb))\n\t\t\treturn;\n\t\twake_up_interruptible(&dev->drv[di]->rcv_waitq[channel]);\n\t} else\n\t\tdev_kfree_skb(skb);\n}", "target": 0}
{"code": "void mesh_state_remove_reply(struct mesh_area* mesh, struct mesh_state* m,\n\tstruct comm_point* cp)\n{\n\tstruct mesh_reply* n, *prev = NULL;\n\tn = m->reply_list;\n\tif(!n) return; \n\twhile(n) {\n\t\tif(n->query_reply.c == cp) {\n\t\t\tif(prev) prev->next = n->next;\n\t\t\telse m->reply_list = n->next;\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t\tinfra_wait_limit_dec(mesh->env->infra_cache,\n\t\t\t\t&n->query_reply, mesh->env->cfg);\n\t\t\tn = n->next;\n\t\t\tcontinue;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\tif(!m->reply_list && !m->cb_list\n\t\t&& m->super_set.count == 0) {\n\t\tmesh->num_detached_states++;\n\t}\n\tif(!m->reply_list && !m->cb_list) {\n\t\tlog_assert(mesh->num_reply_states > 0);\n\t\tmesh->num_reply_states--;\n\t}\n}", "target": 0}
{"code": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\t*bounce_buf_ret = bounce_buf;\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}", "target": 1}
{"code": "static BOOL ntlm_av_pair_check_data(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair, size_t size)\n{\n\tsize_t offset;\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR) + size)\n\t\treturn FALSE;\n\tif (!ntlm_av_pair_get_next_offset(pAvPair, cbAvPair, &offset))\n\t\treturn FALSE;\n\treturn cbAvPair >= offset;\n}", "target": 0}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->allgc, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  g->gcstate = GCSswpallgc;\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 0}
{"code": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}", "target": 1}
{"code": "static int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tpvc_device *pvc;\n\tstruct net_device *dev;\n\tint used;\n\tif ((pvc = add_pvc(frad, dlci)) == NULL) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_add_pvc()\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\tif (*get_dev_p(pvc, type))\n\t\treturn -EEXIST;\n\tused = pvc_is_used(pvc);\n\tif (type == ARPHRD_ETHER)\n\t\tdev = alloc_netdev(0, \"pvceth%d\", ether_setup);\n\telse\n\t\tdev = alloc_netdev(0, \"pvc%d\", pvc_setup);\n\tif (!dev) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_pvc()\\n\");\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -ENOBUFS;\n\t}\n\tif (type == ARPHRD_ETHER)\n\t\trandom_ether_addr(dev->dev_addr);\n\telse {\n\t\t*(__be16*)dev->dev_addr = htons(dlci);\n\t\tdlci_to_q922(dev->broadcast, dlci);\n\t}\n\tdev->netdev_ops = &pvc_ops;\n\tdev->mtu = HDLC_MAX_MTU;\n\tdev->tx_queue_len = 0;\n\tdev->ml_priv = pvc;\n\tif (register_netdevice(dev) != 0) {\n\t\tfree_netdev(dev);\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -EIO;\n\t}\n\tdev->destructor = free_netdev;\n\t*get_dev_p(pvc, type) = dev;\n\tif (!used) {\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->dce_pvc_count++;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct timespec ns_to_timespec(const s64 nsec)\n{\n\tstruct timespec ts;\n\tif (!nsec)\n\t\treturn (struct timespec) {0, 0};\n\tts.tv_sec = div_long_long_rem_signed(nsec, NSEC_PER_SEC, &ts.tv_nsec);\n\tif (unlikely(nsec < 0))\n\t\tset_normalized_timespec(&ts, ts.tv_sec, ts.tv_nsec);\n\treturn ts;\n}", "target": 1}
{"code": "void LightProcess::runShadow(int fdin, int fdout) {\n  FILE *fin = fdopen(fdin, \"r\");\n  FILE *fout = fdopen(fdout, \"w\");\n  char buf[BUFFER_SIZE];\n  pollfd pfd[1];\n  pfd[0].fd = fdin;\n  pfd[0].events = POLLIN;\n  while (true) {\n    int ret = poll(pfd, 1, -1);\n    if (ret < 0 && errno == EINTR) {\n      continue;\n    }\n    if (pfd[0].revents & POLLIN) {\n      if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';\n      if (strncmp(buf, \"exit\", 4) == 0) {\n        Logger::Info(\"LightProcess exiting upon request\");\n        break;\n      } else if (strncmp(buf, \"popen\", 5) == 0) {\n        do_popen(fin, fout, m_afdt_fd);\n      } else if (strncmp(buf, \"pclose\", 6) == 0) {\n        do_pclose(fin, fout);\n      } else if (strncmp(buf, \"proc_open\", 9) == 0) {\n        do_proc_open(fin, fout, m_afdt_fd);\n      } else if (strncmp(buf, \"waitpid\", 7) == 0) {\n        do_waitpid(fin, fout);\n      } else if (strncmp(buf, \"change_user\", 11) == 0) {\n        do_change_user(fin, fout);\n      } else if (buf[0]) {\n        Logger::Info(\"LightProcess got invalid command: %.20s\", buf);\n      }\n    } else if (pfd[0].revents & POLLHUP) {\n      Logger::Error(\"Lost parent, LightProcess exiting\");\n      break;\n    }\n  }\n  fclose(fin);\n  fclose(fout);\n  ::close(m_afdt_fd);\n  remove(m_afdtFilename.c_str());\n  _Exit(0);\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "QStringList QODBCDriver::tables(QSql::TableType type) const\n{\n    Q_D(const QODBCDriver);\n    QStringList tl;\n    if (!isOpen())\n        return tl;\n    SQLHANDLE hStmt;\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::tables: Unable to allocate handle\"_L1, d);\n        return tl;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    QStringList tableType;\n    if (type & QSql::Tables)\n        tableType += \"TABLE\"_L1;\n    if (type & QSql::Views)\n        tableType += \"VIEW\"_L1;\n    if (type & QSql::SystemTables)\n        tableType += \"SYSTEM TABLE\"_L1;\n    if (tableType.isEmpty())\n        return tl;\n    QString joinedTableTypeString = tableType.join(u',');\n    r = SQLTables(hStmt,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   toSQLTCHAR(joinedTableTypeString).data(),\n                   joinedTableTypeString.length() );\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::tables Unable to execute table list\"_L1, d);\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r != SQL_NO_DATA) {\n        qWarning() << \"QODBCDriver::tables failed to retrieve table/view list: (\" << r << \",\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << \")\";\n        return QStringList();\n    }\n    while (r == SQL_SUCCESS) {\n        tl.append(qGetStringData(hStmt, 2, -1, d->unicode).toString());\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle\"_L1 + QString::number(r), d);\n    return tl;\n}", "target": 1}
{"code": "cleanup_pathname(struct archive_write_disk *a)\n{\n\tstruct archive_string error_string;\n\tint error_number;\n\tint rc;\n\tarchive_string_init(&error_string);\n\trc = cleanup_pathname_fsobj(a->name, &error_number, &error_string, a->flags);\n\tif (rc != ARCHIVE_OK) {\n\t\tarchive_set_error(&a->archive, error_number, \"%s\", error_string.s);\n\t}\n\tarchive_string_free(&error_string);\n\treturn rc;\n}", "target": 0}
{"code": "static inline __u32 dccp_v6_init_sequence(struct sk_buff *skb)\n{\n\treturn secure_dccpv6_sequence_number(ipv6_hdr(skb)->daddr.s6_addr32,\n\t\t\t\t\t     ipv6_hdr(skb)->saddr.s6_addr32,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_dport,\n\t\t\t\t\t     dccp_hdr(skb)->dccph_sport     );\n}", "target": 1}
{"code": "is_blank_line(char *line, int indent)\n{\n    int i, is_blank = 0;\n    for (i = 0; i < indent; i++) {\n\tif (line[i] == '\\0') {\n\t    is_blank = 1;\n\t}\n\telse if (line[i] != ' ') {\n\t    break;\n\t}\n    }\n    if (i == indent && line[i] == '\\0')\n\tis_blank = 1;\n    return is_blank;\n}", "target": 0}
{"code": "bool bt_att_cancel(struct bt_att *att, unsigned int id)\n{\n\tconst struct queue_entry *entry;\n\tstruct att_send_op *op;\n\tif (!att || !id)\n\t\treturn false;\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\t\tif (bt_att_chan_cancel(chan, id))\n\t\t\treturn true;\n\t}\n\tif (att->in_disc)\n\t\treturn bt_att_disc_cancel(att, id);\n\top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\tif (!op)\n\t\treturn false;\ndone:\n\tdestroy_att_send_op(op);\n\twakeup_writer(att);\n\treturn true;\n}", "target": 0}
{"code": "void UnicodeStringTest::TestLargeAppend() {\n    if(quick) return;\n    IcuTestErrorCode status(*this, \"TestLargeAppend\");\n    int32_t len = 0xAFFFFFF;\n    UnicodeString str;\n    char16_t *buf = str.getBuffer(len);\n    uprv_memset(buf, 0x4e, len * 2);\n    str.releaseBuffer(len);\n    UnicodeString dest;\n    int64_t total = 0;\n    for (int32_t i = 0; i < 16; i++) {\n        dest.append(str);\n        total += len;\n        if (total <= INT32_MAX) {\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n        } else {\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        }\n    }\n    dest.remove();\n    total = 0;\n    for (int32_t i = 0; i < 16; i++) {\n        dest.append(str);\n        total += len;\n        if (total + len <= INT32_MAX) {\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n        } else if (total <= INT32_MAX) {\n            UnicodeString str2;\n            int32_t remain = INT32_MAX - total;\n            char16_t *buf2 = str2.getBuffer(remain);\n            if (buf2 == nullptr) {\n                return;\n            }\n            uprv_memset(buf2, 0x4e, remain * 2);\n            str2.releaseBuffer(remain);\n            dest.append(str2);\n            total += remain;\n            assertEquals(\"When a string of exactly the maximum size works\", (int64_t)INT32_MAX, total);\n            assertEquals(\"When a string of exactly the maximum size works\", INT32_MAX, dest.length());\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n            str2.truncate(1);\n            dest.append(str2);\n            total++;\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        } else {\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        }\n    }\n}", "target": 0}
{"code": "infra_delete(struct infra_cache* infra)\n{\n\tif(!infra)\n\t\treturn;\n\tslabhash_delete(infra->hosts);\n\tslabhash_delete(infra->domain_rates);\n\ttraverse_postorder(&infra->domain_limits, domain_limit_free, NULL);\n\tslabhash_delete(infra->client_ip_rates);\n\ttraverse_postorder(&infra->wait_limits_netblock,\n\t\twait_limit_netblock_del, NULL);\n\ttraverse_postorder(&infra->wait_limits_cookie_netblock,\n\t\twait_limit_netblock_del, NULL);\n\tfree(infra);\n}", "target": 0}
{"code": "do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n            const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t       &dec_tables);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t     &dec_tables);\n#else\n  return do_decrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "static int jp2_cdef_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_cdef_t *cdef = &box->data.cdef;\n\tjp2_cdefchan_t *chan;\n\tunsigned int channo;\n\tcdef->ents = 0;\n\tif (jp2_getuint16(in, &cdef->numchans)) {\n\t\treturn -1;\n\t}\n\tif (!(cdef->ents = jas_alloc2(cdef->numchans, sizeof(jp2_cdefchan_t)))) {\n\t\treturn -1;\n\t}\n\tfor (channo = 0; channo < cdef->numchans; ++channo) {\n\t\tchan = &cdef->ents[channo];\n\t\tif (jp2_getuint16(in, &chan->channo) || jp2_getuint16(in, &chan->type) ||\n\t\t  jp2_getuint16(in, &chan->assoc)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void xen_irq_init(unsigned irq)\n{\n\tstruct irq_info *info;\n#ifdef CONFIG_SMP\n\tcpumask_copy(irq_get_affinity_mask(irq), cpumask_of(0));\n#endif\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL)\n\t\tpanic(\"Unable to allocate metadata for IRQ%d\\n\", irq);\n\tinfo->type = IRQT_UNBOUND;\n\tinfo->refcnt = -1;\n\tset_info_for_irq(irq, info);\n\tINIT_LIST_HEAD(&info->eoi_list);\n\tlist_add_tail(&info->list, &xen_irq_list_head);\n}", "target": 0}
{"code": "expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  size_t cnt;\n  size_t total;\n  char *result;\n  cnt = DL_DST_COUNT (s, 1);\n  if (cnt == 0)\n    return local_strdup (s);\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n  result = (char *) malloc (total + 1);\n  if (result == NULL)\n    return NULL;\n  return DL_DST_SUBSTITUTE (l, s, result, 1);\n}", "target": 1}
{"code": "static TEE_Result do_allocate_keypair(struct ecc_keypair *key,\n\t\t\t\t      uint32_t type __unused,\n\t\t\t\t      size_t size_bits)\n{\n\tECC_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->d = crypto_bignum_allocate(size_bits);\n\tif (!key->d)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tECC_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static inline int cipso_v4_validate(const struct sk_buff *skb,\n\t\t\t\t    unsigned char **option)\n{\n\tunsigned char *opt = *option;\n\tunsigned char err_offset = 0;\n\tu8 opt_len = opt[1];\n\tu8 opt_iter;\n\tif (opt_len < 8) {\n\t\terr_offset = 1;\n\t\tgoto out;\n\t}\n\tif (get_unaligned_be32(&opt[2]) == 0) {\n\t\terr_offset = 2;\n\t\tgoto out;\n\t}\n\tfor (opt_iter = 6; opt_iter < opt_len;) {\n\t\tif (opt[opt_iter + 1] > (opt_len - opt_iter)) {\n\t\t\terr_offset = opt_iter + 1;\n\t\t\tgoto out;\n\t\t}\n\t\topt_iter += opt[opt_iter + 1];\n\t}\nout:\n\t*option = opt + err_offset;\n\treturn err_offset;\n}", "target": 1}
{"code": "static void pageset_init(struct per_cpu_pageset *p)\n{\n\tstruct per_cpu_pages *pcp;\n\tint migratetype;\n\tmemset(p, 0, sizeof(*p));\n\tpcp = &p->pcp;\n\tpcp->count = 0;\n\tfor (migratetype = 0; migratetype < MIGRATE_PCPTYPES; migratetype++)\n\t\tINIT_LIST_HEAD(&pcp->lists[migratetype]);\n}", "target": 0}
{"code": "TfLiteStatus GetTemporarySafe(const TfLiteContext* context,\n                              const TfLiteNode* node, int index,\n                              TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->temporaries->size,\n                                 node->temporaries->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static bool vmci_transport_allow_dgram(struct vsock_sock *vsock, u32 peer_cid)\n{\n\tif (vsock->cached_peer != peer_cid) {\n\t\tvsock->cached_peer = peer_cid;\n\t\tif (!vmci_transport_is_trusted(vsock, peer_cid) &&\n\t\t    (vmci_context_get_priv_flags(peer_cid) &\n\t\t     VMCI_PRIVILEGE_FLAG_RESTRICTED)) {\n\t\t\tvsock->cached_peer_allow_dgram = false;\n\t\t} else {\n\t\t\tvsock->cached_peer_allow_dgram = true;\n\t\t}\n\t}\n\treturn vsock->cached_peer_allow_dgram;\n}", "target": 0}
{"code": "static TEE_Result do_alloc_keypair(struct rsa_keypair *s,\n\t\t\t\t   size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->qp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dq))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number)\n{\n  uint32_t original_out_len;\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER);\n  return out;\n}", "target": 1}
{"code": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc;\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlSchemaParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n  return Qnil;\n}", "target": 1}
{"code": "struct kobject *get_disk(struct gendisk *disk)\n{\n\tstruct module *owner;\n\tstruct kobject *kobj;\n\tif (!disk->fops)\n\t\treturn NULL;\n\towner = disk->fops->owner;\n\tif (owner && !try_module_get(owner))\n\t\treturn NULL;\n\tkobj = kobject_get(&disk_to_dev(disk)->kobj);\n\tif (kobj == NULL) {\n\t\tmodule_put(owner);\n\t\treturn NULL;\n\t}\n\treturn kobj;\n}", "target": 0}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    xmlValidNormalizeString(ID);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "static struct scatterlist *alloc_sgtable(int size)\n{\n\tint alloc_size, nents, i;\n\tstruct page *new_page;\n\tstruct scatterlist *iter;\n\tstruct scatterlist *table;\n\tnents = DIV_ROUND_UP(size, PAGE_SIZE);\n\ttable = kcalloc(nents, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\tsg_init_table(table, nents);\n\titer = table;\n\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\tnew_page = alloc_page(GFP_KERNEL);\n\t\tif (!new_page) {\n\t\t\titer = table;\n\t\t\tfor_each_sg(table, iter, sg_nents(table), i) {\n\t\t\t\tnew_page = sg_page(iter);\n\t\t\t\tif (new_page)\n\t\t\t\t\t__free_page(new_page);\n\t\t\t}\n\t\t\tkfree(table);\n\t\t\treturn NULL;\n\t\t}\n\t\talloc_size = min_t(int, size, PAGE_SIZE);\n\t\tsize -= PAGE_SIZE;\n\t\tsg_set_page(iter, new_page, alloc_size, 0);\n\t}\n\treturn table;\n}", "target": 0}
{"code": "int kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq)\n{\n\tstruct decode_cache *c = &vcpu->arch.emulate_ctxt.decode;\n\tint ret;\n\tinit_emulate_ctxt(vcpu);\n\tvcpu->arch.emulate_ctxt.decode.op_bytes = 2;\n\tvcpu->arch.emulate_ctxt.decode.ad_bytes = 2;\n\tvcpu->arch.emulate_ctxt.decode.eip = vcpu->arch.emulate_ctxt.eip;\n\tret = emulate_int_real(&vcpu->arch.emulate_ctxt, &emulate_ops, irq);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn EMULATE_FAIL;\n\tvcpu->arch.emulate_ctxt.eip = c->eip;\n\tmemcpy(vcpu->arch.regs, c->regs, sizeof c->regs);\n\tkvm_rip_write(vcpu, vcpu->arch.emulate_ctxt.eip);\n\tkvm_x86_ops->set_rflags(vcpu, vcpu->arch.emulate_ctxt.eflags);\n\tif (irq == NMI_VECTOR)\n\t\tvcpu->arch.nmi_pending = false;\n\telse\n\t\tvcpu->arch.interrupt.pending = false;\n\treturn EMULATE_DONE;\n}", "target": 0}
{"code": "void NumberFormatTest::Test20037_ScientificIntegerOverflow() {\n    IcuTestErrorCode status(*this, \"Test20037_ScientificIntegerOverflow\");\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat instance.\");\n        return;\n    }\n    Formattable result;\n    nf->parse(u\"1E-2147483648\", result, status);\n    StringPiece sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should snap to zero\",\n                 u\"0\",\n                 {sp.data(), sp.length(), US_INV});\n    result = Formattable();\n    nf->parse(u\"1E-2147483647E-1\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow and should parse only the first exponent\",\n                 u\"1E-2147483647\",\n                 {sp.data(), sp.length(), US_INV});\n    result = Formattable();\n    nf->parse(u\".0003e-2147483644\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow\",\n                 u\"3E-2147483648\",\n                 {sp.data(), sp.length(), US_INV});\n}", "target": 0}
{"code": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h, *g;\n\tunsigned int i;\n\tvmcb_mark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\tc = &svm->vmcb->control;\n\th = &svm->vmcb01.ptr->control;\n\tg = &svm->nested.ctl;\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] = h->intercepts[i];\n\tif (g->int_ctl & V_INTR_MASKING_MASK) {\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_READ);\n\t\tvmcb_clr_intercept(c, INTERCEPT_CR8_WRITE);\n\t\tvmcb_clr_intercept(c, INTERCEPT_VINTR);\n\t}\n\tvmcb_clr_intercept(c, INTERCEPT_VMMCALL);\n\tfor (i = 0; i < MAX_INTERCEPT; i++)\n\t\tc->intercepts[i] |= g->intercepts[i];\n\tif (!intercept_smi)\n\t\tvmcb_clr_intercept(c, INTERCEPT_SMI);\n\tvmcb_set_intercept(c, INTERCEPT_VMLOAD);\n\tvmcb_set_intercept(c, INTERCEPT_VMSAVE);\n}", "target": 0}
{"code": "static inline int ccid_hc_rx_getsockopt(struct ccid *ccid, struct sock *sk,\n\t\t\t\t\tconst int optname, int len,\n\t\t\t\t\tu32 __user *optval, int __user *optlen)\n{\n\tint rc = -ENOPROTOOPT;\n\tif (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)\n\t\trc = ccid->ccid_ops->ccid_hc_rx_getsockopt(sk, optname, len,\n\t\t\t\t\t\t optval, optlen);\n\treturn rc;\n}", "target": 1}
{"code": "void make_random_permutation(int start) {\n        int i, j;\n        permutation[0] = start;\t\n        for (i = 1; i < ARRAY_SIZE; i++) {\n                j = random() * (double)(i + 1) / RAND_MAX; \n                if (j != i) { \n                  permutation[i] = permutation[j];\n                }\n                permutation[j] = start + i;\n        }\n}", "target": 0}
{"code": "static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n\t\t\tsockfd_put(nsock);\n\t\t\treturn -EBADFD;\n\t\t}\n\t\tca.device[sizeof(ca.device)-1] = 0;\n\t\terr = bnep_add_connection(&ca, nsock);\n\t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\t\treturn err;\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn bnep_del_connection(&cd);\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}", "target": 1}
{"code": "static CURLUcode hostname_check(struct Curl_URL *u, char *hostname)\n{\n  size_t len;\n  size_t hlen = strlen(hostname);\n  if(hostname[0] == '[') {\n    const char *l = \"0123456789abcdefABCDEF:.\";\n    if(hlen < 4) \n      return CURLUE_BAD_IPV6;\n    hostname++;\n    hlen -= 2;\n    if(hostname[hlen] != ']')\n      return CURLUE_BAD_IPV6;\n    len = strspn(hostname, l);\n    if(hlen != len) {\n      hlen = len;\n      if(hostname[len] == '%') {\n        char zoneid[16];\n        int i = 0;\n        char *h = &hostname[len + 1];\n        if(!strncmp(h, \"25\", 2) && h[2] && (h[2] != ']'))\n          h += 2;\n        while(*h && (*h != ']') && (i < 15))\n          zoneid[i++] = *h++;\n        if(!i || (']' != *h))\n          return CURLUE_MALFORMED_INPUT;\n        zoneid[i] = 0;\n        u->zoneid = strdup(zoneid);\n        if(!u->zoneid)\n          return CURLUE_OUT_OF_MEMORY;\n        hostname[len] = ']'; \n        hostname[len + 1] = 0; \n      }\n      else\n        return CURLUE_BAD_IPV6;\n    }\n#ifdef ENABLE_IPV6\n    {\n      char dest[16]; \n      char norm[MAX_IPADR_LEN];\n      hostname[hlen] = 0; \n      if(1 != Curl_inet_pton(AF_INET6, hostname, dest))\n        return CURLUE_BAD_IPV6;\n      if(Curl_inet_ntop(AF_INET6, dest, norm, sizeof(norm)) &&\n         (strlen(norm) < hlen)) {\n        strcpy(hostname, norm);\n        hlen = strlen(norm);\n        hostname[hlen + 1] = 0;\n      }\n      hostname[hlen] = ']'; \n    }\n#endif\n  }\n  else {\n    len = strcspn(hostname, \" \\r\\n\\t/:#?!@\");\n    if(hlen != len)\n      return CURLUE_BAD_HOSTNAME;\n  }\n  if(!hostname[0])\n    return CURLUE_NO_HOST;\n  return CURLUE_OK;\n}", "target": 0}
{"code": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}", "target": 1}
{"code": "static void fio_worker_cleanup(void) {\n  if (fio_data->is_worker)\n    FIO_LOG_INFO(\"(%d) detected exit signal.\", (int)getpid());\n  else\n    FIO_LOG_INFO(\"Server Detected exit signal.\");\n  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol) {\n      fio_defer_push_task(deferred_on_shutdown, (void *)fd2uuid(i), NULL);\n    }\n  }\n  fio_defer_push_task(fio_cycle_unwind, NULL, NULL);\n  fio_defer_perform();\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol || fd_data(i).open) {\n      fio_force_close(fd2uuid(i));\n    }\n  }\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_ON_FINISH);\n  fio_defer_perform();\n  if (!fio_data->is_worker) {\n    fio_cluster_signal_children();\n    while (wait(NULL) != -1)\n      ;\n  }\n  fio_defer_perform();\n  fio_signal_handler_reset();\n  if (fio_data->parent == getpid()) {\n    FIO_LOG_INFO(\"   ---  Shutdown Complete  ---\\n\");\n  } else {\n    FIO_LOG_INFO(\"(%d) cleanup complete.\", (int)getpid());\n  }\n}", "target": 1}
{"code": "static int me_unknown(struct page *p, unsigned long pfn)\n{\n\tpr_err(\"Memory failure: %#lx: Unknown page state\\n\", pfn);\n\treturn MF_FAILED;\n}", "target": 0}
{"code": "static int read_payload_length_info(struct LATMContext *ctx, GetBitContext *gb)\n{\n    uint8_t tmp;\n    if (ctx->frame_length_type == 0) {\n        int mux_slot_length = 0;\n        do {\n            tmp = get_bits(gb, 8);\n            mux_slot_length += tmp;\n        } while (tmp == 255);\n        return mux_slot_length;\n    } else if (ctx->frame_length_type == 1) {\n        return ctx->frame_length;\n    } else if (ctx->frame_length_type == 3 ||\n               ctx->frame_length_type == 5 ||\n               ctx->frame_length_type == 7) {\n        skip_bits(gb, 2);          \n    }\n    return 0;\n}", "target": 0}
{"code": "static int cdrom_ioctl_select_disc(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_SELECT_DISC\\n\");\n\tif (!CDROM_CAN(CDC_SELECT_DISC))\n\t\treturn -ENOSYS;\n\tif (arg != CDSL_CURRENT && arg != CDSL_NONE) {\n\t\tif ((int)arg >= cdi->capacity)\n\t\t\treturn -EINVAL;\n\t}\n\tif (cdi->ops->select_disc)\n\t\treturn cdi->ops->select_disc(cdi, arg);\n\tcd_dbg(CD_CHANGER, \"Using generic cdrom_select_disc()\\n\");\n\treturn cdrom_select_disc(cdi, arg);\n}", "target": 1}
{"code": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "avp_find(struct l2tp_avp *avp, const u_char *pkt, int pktlen,\n    uint16_t vendor_id, uint16_t attr_type, int fill_data)\n{\n\tint avpsz;\n\twhile (pktlen >= 6 &&\n\t    (avpsz = avp_enum(avp, pkt, pktlen, fill_data)) > 0) {\n\t\tif (avp->vendor_id != vendor_id || avp->attr_type != attr_type) {\n\t\t\tif (avpsz < 6)\n\t\t\t\treturn NULL;\n\t\t\tpkt += avpsz;\n\t\t\tpktlen -= avpsz;\n\t\t\tcontinue;\n\t\t}\n\t\treturn avp;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "register_commands (assuan_context_t ctx)\n{\n  static struct {\n    const char *name;\n    assuan_handler_t handler;\n    const char * const help;\n  } table[] = {\n    { \"SERIALNO\",     cmd_serialno, hlp_serialno },\n    { \"LEARN\",        cmd_learn,    hlp_learn },\n    { \"READCERT\",     cmd_readcert, hlp_readcert },\n    { \"READKEY\",      cmd_readkey,  hlp_readkey },\n    { \"SETDATA\",      cmd_setdata,  hlp_setdata },\n    { \"PKSIGN\",       cmd_pksign,   hlp_pksign },\n    { \"PKAUTH\",       cmd_pkauth,   hlp_pkauth },\n    { \"PKDECRYPT\",    cmd_pkdecrypt,hlp_pkdecrypt },\n    { \"INPUT\",        NULL },\n    { \"OUTPUT\",       NULL },\n    { \"GETATTR\",      cmd_getattr,  hlp_getattr },\n    { \"SETATTR\",      cmd_setattr,  hlp_setattr },\n    { \"WRITECERT\",    cmd_writecert,hlp_writecert },\n    { \"WRITEKEY\",     cmd_writekey, hlp_writekey },\n    { \"GENKEY\",       cmd_genkey,   hlp_genkey },\n    { \"RANDOM\",       cmd_random,   hlp_random },\n    { \"PASSWD\",       cmd_passwd,   hlp_passwd },\n    { \"CHECKPIN\",     cmd_checkpin, hlp_checkpin },\n    { \"LOCK\",         cmd_lock,     hlp_lock },\n    { \"UNLOCK\",       cmd_unlock,   hlp_unlock },\n    { \"GETINFO\",      cmd_getinfo,  hlp_getinfo },\n    { \"RESTART\",      cmd_restart,  hlp_restart },\n    { \"DISCONNECT\",   cmd_disconnect,hlp_disconnect },\n    { \"APDU\",         cmd_apdu,     hlp_apdu },\n    { \"KILLSCD\",      cmd_killscd,  hlp_killscd },\n    { NULL }\n  };\n  int i, rc;\n  for (i=0; table[i].name; i++)\n    {\n      rc = assuan_register_command (ctx, table[i].name, table[i].handler,\n                                    table[i].help);\n      if (rc)\n        return rc;\n    }\n  assuan_set_hello_line (ctx, \"GNU Privacy Guard's Smartcard server ready\");\n  assuan_register_reset_notify (ctx, reset_notify);\n  assuan_register_option_handler (ctx, option_handler);\n  return 0;\n}", "target": 0}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1);\n                else\n                    isoclns_print(ndo, p, length);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "static char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections) {\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (!R_STR_ISEMPTY (curl_env) && atoi (curl_env)) {\n\t\tint len;\n\t\tchar *escaped_url = r_str_escape_sh (url);\n\t\tchar *command = r_str_newf (\"curl -sfL -o - \\\"%s\\\"\", escaped_url);\n\t\tchar *res = r_sys_cmd_str (command, NULL, &len);\n\t\tfree (escaped_url);\n\t\tfree (command);\n\t\tfree (curl_env);\n\t\tif (!res) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = len;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tfree (curl_env);\n#if __WINDOWS__\n\treturn http_get_w32 (url, code, rlen);\n#else\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https:\n#if !HAVE_LIB_SSL\n\tif (ssl) {\n\t\teprintf (\"Tried to get '%s', but SSL support is disabled, set R2_CURL=1 to use curl\\n\", url);\n\t\treturn NULL;\n\t}\n#endif\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\thost = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: *", "target": 0}
{"code": "GF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\tif (i > 15) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue[i] = v;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}", "target": 1}
{"code": "urlCheckRequest(const HttpRequest * r)\n{\n    if (r->method == Http::METHOD_CONNECT)\n        return true;\n    if (r->method == Http::METHOD_OPTIONS || r->method == Http::METHOD_TRACE)\n        return (r->header.getInt64(Http::HdrType::MAX_FORWARDS) == 0 || r->url.path() != AnyP::Uri::Asterisk());\n    if (r->method == Http::METHOD_PURGE)\n        return true;\n    switch (r->url.getScheme()) {\n    case AnyP::PROTO_URN:\n    case AnyP::PROTO_HTTP:\n    case AnyP::PROTO_CACHE_OBJECT:\n        return true;\n    case AnyP::PROTO_FTP:\n        if (r->method == Http::METHOD_PUT ||\n                r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD )\n            return true;\n        return false;\n    case AnyP::PROTO_GOPHER:\n    case AnyP::PROTO_WAIS:\n    case AnyP::PROTO_WHOIS:\n        if (r->method == Http::METHOD_GET ||\n                r->method == Http::METHOD_HEAD)\n            return true;\n        return false;\n    case AnyP::PROTO_HTTPS:\n#if USE_OPENSSL || USE_GNUTLS\n        return true;\n#else\n        return false;\n#endif\n    default:\n        return false;\n    }\n    return false;\n}", "target": 1}
{"code": "CbrDetectorRemote::Result CbrDetectorRemote::Decrypt(cricket::MediaType media_type,\n\t\t\t\t\t\tconst std::vector<uint32_t>& csrcs,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> additional_data,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> encrypted_frame,\n\t\t\t\t\t\trtc::ArrayView<uint8_t> frame)\n{\n\tconst uint8_t *src = encrypted_frame.data();\n\tuint8_t *dst = frame.data();\n\tuint32_t data_len = encrypted_frame.size();\n\tif (media_type == cricket::MEDIA_TYPE_AUDIO) {\n\t\tif (data_len == frame_size && frame_size >= 40) {\n\t\t\tframe_count++;\n\t\t\tif (frame_count > 200 && !detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected\\n\");\n\t\t\t\tdetected = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tframe_count = 0;\n\t\t\tframe_size = data_len;\n\t\t\tif (detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");\n\t\t\t\tdetected = false;\n\t\t\t}\n\t\t}\n\t}\n\tmemcpy(dst, src, data_len);\nout:\n\treturn CbrDetectorRemote::Result(CbrDetectorRemote::Status::kOk, data_len);\n}", "target": 1}
{"code": "hstoreArrayToPairs(ArrayType *a, int *npairs)\n{\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tPairs\t   *key_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tdeconstruct_array(a,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\tif (key_count == 0)\n\t{\n\t\t*npairs = 0;\n\t\treturn NULL;\n\t}\n\tif (key_count > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));\n\tkey_pairs = palloc(sizeof(Pairs) * key_count);\n\tfor (i = 0, j = 0; i < key_count; i++)\n\t{\n\t\tif (!key_nulls[i])\n\t\t{\n\t\t\tkey_pairs[j].key = VARDATA(key_datums[i]);\n\t\t\tkey_pairs[j].keylen = VARSIZE(key_datums[i]) - VARHDRSZ;\n\t\t\tkey_pairs[j].val = NULL;\n\t\t\tkey_pairs[j].vallen = 0;\n\t\t\tkey_pairs[j].needfree = 0;\n\t\t\tkey_pairs[j].isnull = 1;\n\t\t\tj++;\n\t\t}\n\t}\n\t*npairs = hstoreUniquePairs(key_pairs, j, &bufsiz);\n\treturn key_pairs;\n}", "target": 0}
{"code": "LogicalSize NGColumnLayoutAlgorithm::CalculateColumnSize(\n    const LogicalSize& content_box_size) {\n  LogicalSize column_size = content_box_size;\n  DCHECK_GE(column_size.inline_size, LayoutUnit());\n  column_size.inline_size =\n      ResolveUsedColumnInlineSize(column_size.inline_size, Style());\n  if (NeedsColumnBalancing(column_size.block_size, Style())) {\n    int used_count =\n        ResolveUsedColumnCount(content_box_size.inline_size, Style());\n    column_size.block_size =\n        CalculateBalancedColumnBlockSize(column_size, used_count);\n  }\n  return column_size;\n}", "target": 0}
{"code": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* const context) override {\n    const Tensor* node_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"node_ids\", &node_ids_t));\n    const auto node_ids = node_ids_t->vec<int32>();\n    const Tensor* gradients_t;\n    OP_REQUIRES_OK(context, context->input(\"gradients\", &gradients_t));\n    const auto gradients = gradients_t->matrix<float>();\n    OP_REQUIRES(\n        context, node_ids.size() == gradients.dimension(0),\n        errors::InvalidArgument(\n            \"node_ids size should match 0th dim of gradients. node ids \"\n            \"size: \",\n            node_ids.size(), \", gradients dim0: \", gradients.dimension(0)));\n    const Tensor* hessians_t;\n    OP_REQUIRES_OK(context, context->input(\"hessians\", &hessians_t));\n    const auto hessians = hessians_t->matrix<float>();\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features_list\",\n                                                &bucketized_features_list));\n    const int64_t batch_size = node_ids_t->dim_size(0);\n    Tensor temp_stats_double_t;\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DT_DOUBLE,\n                                {num_features_, max_splits_, num_buckets_, 2},\n                                &temp_stats_double_t));\n    auto temp_stats_double = temp_stats_double_t.tensor<double, 4>();\n    temp_stats_double.setZero();\n    for (int feature_idx = 0; feature_idx < num_features_; ++feature_idx) {\n      const auto& features = bucketized_features_list[feature_idx].vec<int32>();\n      for (int i = 0; i < batch_size; ++i) {\n        const int32_t node = node_ids(i);\n        const int32_t bucket = features(i);\n        temp_stats_double(feature_idx, node, bucket, 0) += gradients(i, 0);\n        temp_stats_double(feature_idx, node, bucket, 1) += hessians(i, 0);\n      }\n    }\n    Tensor* output_stats_summary_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"stats_summary\", temp_stats_double_t.shape(),\n                                &output_stats_summary_t));\n    output_stats_summary_t->tensor<float, 4>() =\n        temp_stats_double.template cast<float>();\n  }", "target": 0}
{"code": "static noinline int free_debug_processing(\n\tstruct kmem_cache *s, struct page *page,\n\tvoid *head, void *tail, int bulk_cnt,\n\tunsigned long addr)\n{\n\tstruct kmem_cache_node *n = get_node(s, page_to_nid(page));\n\tvoid *object = head;\n\tint cnt = 0;\n\tunsigned long uninitialized_var(flags);\n\tint ret = 0;\n\tspin_lock_irqsave(&n->list_lock, flags);\n\tslab_lock(page);\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!check_slab(s, page))\n\t\t\tgoto out;\n\t}\nnext_object:\n\tcnt++;\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tif (!free_consistency_checks(s, page, object, addr))\n\t\t\tgoto out;\n\t}\n\tif (s->flags & SLAB_STORE_USER)\n\t\tset_track(s, object, TRACK_FREE, addr);\n\ttrace(s, page, object, 0);\n\tinit_object(s, object, SLUB_RED_INACTIVE);\n\tif (object != tail) {\n\t\tobject = get_freepointer(s, object);\n\t\tgoto next_object;\n\t}\n\tret = 1;\nout:\n\tif (cnt != bulk_cnt)\n\t\tslab_err(s, page, \"Bulk freelist count(%d) invalid(%d)\\n\",\n\t\t\t bulk_cnt, cnt);\n\tslab_unlock(page);\n\tspin_unlock_irqrestore(&n->list_lock, flags);\n\tif (!ret)\n\t\tslab_fix(s, \"Object at 0x%p not freed\", object);\n\treturn ret;\n}", "target": 0}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringView data = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "  pin(std::string pin, std::string name) {\n    pt::ptree tree;\n    if (map_id_sess.empty()) {\n      return false;\n    }\n    if (pin.size() != 4) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\n        \"root.<xmlattr>.status_message\", \"Pin must be 4 digits, \" + std::to_string(pin.size()) + \" provided\");\n      return false;\n    }\n    if (!std::all_of(pin.begin(), pin.end(), ::isdigit)) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\"root.<xmlattr>.status_message\", \"Pin must be numeric\");\n      return false;\n    }\n    auto &sess = std::begin(map_id_sess)->second;\n    getservercert(sess, tree, pin);\n    sess.client.name = name;\n    std::ostringstream data;\n    pt::write_xml(data, tree);\n    auto &async_response = sess.async_insert_pin.response;\n    if (async_response.has_left() && async_response.left()) {\n      async_response.left()->write(data.str());\n    }\n    else if (async_response.has_right() && async_response.right()) {\n      async_response.right()->write(data.str());\n    }\n    else {\n      return false;\n    }\n    async_response = std::decay_t<decltype(async_response.left())>();\n    return true;\n  }", "target": 0}
{"code": "open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\tif (!name)\n\t\treturn;\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\tFREE(file_name);\n}", "target": 1}
{"code": "sort_keyuse(KEYUSE *a,KEYUSE *b)\n{\n  int res;\n  if (a->table->tablenr != b->table->tablenr)\n    return (int) (a->table->tablenr - b->table->tablenr);\n  if (a->key != b->key)\n    return (int) (a->key - b->key);\n  if (a->key == MAX_KEY && b->key == MAX_KEY && \n      a->used_tables != b->used_tables)\n    return (int) ((ulong) a->used_tables - (ulong) b->used_tables);\n  if (a->keypart != b->keypart)\n    return (int) (a->keypart - b->keypart);\n  if ((res= MY_TEST((a->used_tables & ~OUTER_REF_TABLE_BIT)) -\n       MY_TEST((b->used_tables & ~OUTER_REF_TABLE_BIT))))\n    return res;\n  return (int) ((a->optimize & KEY_OPTIMIZE_REF_OR_NULL) -\n\t\t(b->optimize & KEY_OPTIMIZE_REF_OR_NULL));\n}", "target": 0}
{"code": "PHP_FUNCTION(snmp2_set)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, SNMP_CMD_SET, SNMP_VERSION_2c);\n}", "target": 0}
{"code": "static inline int mb2_cache_entry_put(struct mb2_cache *cache,\n\t\t\t\t      struct mb2_cache_entry *entry)\n{\n\tif (!atomic_dec_and_test(&entry->e_refcnt))\n\t\treturn 0;\n\t__mb2_cache_entry_free(entry);\n\treturn 1;\n}", "target": 0}
{"code": "ModuleSQL::~ModuleSQL()\n{\n\tif (Dispatcher)\n\t{\n\t\tDispatcher->join();\n\t\tDispatcher->OnNotify();\n\t\tdelete Dispatcher;\n\t}\n\tfor(ConnMap::iterator i = connections.begin(); i != connections.end(); i++)\n\t{\n\t\tdelete i->second;\n\t}\n\tmysql_library_end();\n}", "target": 0}
{"code": "static void stellaris_enet_unrealize(DeviceState *dev, Error **errp)\n{\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    unregister_savevm(DEVICE(s), \"stellaris_enet\", s);\n    memory_region_destroy(&s->mmio);\n}", "target": 1}
{"code": "TfLiteStatus Relu6Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  Relu6OpData* data = static_cast<Relu6OpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  if (input->type == kTfLiteInt8) {\n    data->six_int8 = FloatToAsymmetricQuantizedInt8(6.0f, input->params.scale,\n                                                    input->params.zero_point);\n    data->zero_int8 = input->params.zero_point;\n  } else if (input->type == kTfLiteUInt8) {\n    data->six_uint8 = FloatToAsymmetricQuantizedUInt8(6.0f, input->params.scale,\n                                                      input->params.zero_point);\n    data->zero_uint8 = input->params.zero_point;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "int mutt_b64_decode(char *out, const char *in)\n{\n  int len = 0;\n  unsigned char digit4;\n  do\n  {\n    const unsigned char digit1 = in[0];\n    if ((digit1 > 127) || (base64val(digit1) == BAD))\n      return -1;\n    const unsigned char digit2 = in[1];\n    if ((digit2 > 127) || (base64val(digit2) == BAD))\n      return -1;\n    const unsigned char digit3 = in[2];\n    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))\n      return -1;\n    in += 4;\n    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n    len++;\n    if (digit3 != '=')\n    {\n      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n      len++;\n      if (digit4 != '=')\n      {\n        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n        len++;\n      }\n    }\n  } while (*in && digit4 != '=');\n  return len;\n}", "target": 1}
{"code": "void track_set_index(Track *track, int i, long ind)\n{\n\tif (i > MAXINDEX) {\n\t\tfprintf(stderr, \"too many indexes\\n\");\n                return;\n        }\n\ttrack->index[i] = ind;\n}", "target": 1}
{"code": "dig_t bn_get_prime(int pos) {\n\tif (pos >= BASIC_TESTS) {\n\t\treturn 0;\n\t}\n\treturn primes[pos];\n}", "target": 1}
{"code": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\tif (!sg)\n\t\treturn;\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}", "target": 0}
{"code": "static int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *de;\n\tstruct vfsmount *mnt = NULL;\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &de, &mnt);\n\tif (error)\n\t\tgoto out;\n\terror = do_proc_readlink(de, mnt, buffer, buflen);\n\tdput(de);\n\tmntput(mnt);\nout:\n\treturn error;\n}", "target": 0}
{"code": "\tCommandAuthenticate(Module* Creator, SimpleExtItem<SaslAuthenticator>& ext, GenericCap& Cap)\n\t\t: Command(Creator, \"AUTHENTICATE\", 1), authExt(ext), cap(Cap)\n\t{\n\t\tworks_before_reg = true;\n\t\tallow_empty_last_param = false;\n\t}", "target": 0}
{"code": "static bool tailmatch(const char *little, const char *bigone)\n{\n  size_t littlelen = strlen(little);\n  size_t biglen = strlen(bigone);\n  if(littlelen > biglen)\n    return FALSE;\n  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;\n}", "target": 1}
{"code": "TEST_F(HTTP2CodecTest, DuplicateBadHeaderPriority) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req, true );\n  EXPECT_TRUE(parse([&](IOBuf* ingress) {\n    folly::io::RWPrivateCursor c(ingress);\n    c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n    c.writeBE<uint32_t>(1);\n  }));\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  HTTPMessage nextRequest = getGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, nextRequest, true );\n  parse();\n  EXPECT_EQ(callbacks_.streamErrors, 2);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}", "target": 0}
{"code": "inline int NumInputs(const TfLiteNode* node) { return node->inputs->size; }", "target": 1}
{"code": "yy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}", "target": 1}
{"code": "void RunOneAveragePoolTest(const PoolParams& params,\n                           const RuntimeShape& input_shape,\n                           const int8* input_data,\n                           const RuntimeShape& output_shape) {\n  const int buffer_size = output_shape.FlatSize();\n  std::vector<int8> optimized_averagePool_output(buffer_size);\n  std::vector<int8> reference_averagePool_output(buffer_size);\n  reference_integer_ops::AveragePool(params, input_shape, input_data,\n                                     output_shape,\n                                     reference_averagePool_output.data());\n  optimized_integer_ops::AveragePool(params, input_shape, input_data,\n                                     output_shape,\n                                     optimized_averagePool_output.data());\n  for (int i = 0; i < buffer_size; i++) {\n    EXPECT_TRUE(reference_averagePool_output[i] ==\n                optimized_averagePool_output[i]);\n  }\n}", "target": 1}
{"code": "static bool nested_exit_on_nmi(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_NMI_EXITING;\n}", "target": 0}
{"code": "ConnectToRFBServer(rfbClient* client,const char *hostname, int port)\n{\n  if (client->serverPort==-1) {\n    const char* magic=\"vncLog0.0\";\n    char buffer[10];\n    rfbVNCRec* rec = (rfbVNCRec*)malloc(sizeof(rfbVNCRec));\n    client->vncRec = rec;\n    rec->file = fopen(client->serverHost,\"rb\");\n    rec->tv.tv_sec = 0;\n    rec->readTimestamp = FALSE;\n    rec->doNotSleep = FALSE;\n    if (!rec->file) {\n      rfbClientLog(\"Could not open %s.\\n\",client->serverHost);\n      return FALSE;\n    }\n    setbuf(rec->file,NULL);\n    if (fread(buffer,1,strlen(magic),rec->file) != strlen(magic) || strncmp(buffer,magic,strlen(magic))) {\n      rfbClientLog(\"File %s was not recorded by vncrec.\\n\",client->serverHost);\n      fclose(rec->file);\n      return FALSE;\n    }\n    client->sock = -1;\n    return TRUE;\n  }\n#ifndef WIN32\n  if(IsUnixSocket(hostname))\n    client->sock = ConnectClientToUnixSock(hostname);\n  else\n#endif\n  {\n#ifdef LIBVNCSERVER_IPv6\n    client->sock = ConnectClientToTcpAddr6(hostname, port);\n    if (client->sock == -1)\n#endif\n    {\n      unsigned int host;\n      if (!StringToIPAddr(hostname, &host)) {\n        rfbClientLog(\"Couldn't convert '%s' to host address\\n\", hostname);\n        return FALSE;\n      }\n      client->sock = ConnectClientToTcpAddr(host, port);\n    }\n  }\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC server\\n\");\n    return FALSE;\n  }\n  if(client->QoS_DSCP && !SetDSCP(client->sock, client->QoS_DSCP))\n     return FALSE;\n  return SetNonBlocking(client->sock);\n}", "target": 0}
{"code": "nfp_abm_u32_knode_replace(struct nfp_abm_link *alink,\n\t\t\t  struct tc_cls_u32_knode *knode,\n\t\t\t  __be16 proto, struct netlink_ext_ack *extack)\n{\n\tstruct nfp_abm_u32_match *match = NULL, *iter;\n\tunsigned int tos_off;\n\tu8 mask, val;\n\tint err;\n\tif (!nfp_abm_u32_check_knode(alink->abm, knode, proto, extack))\n\t\tgoto err_delete;\n\ttos_off = proto == htons(ETH_P_IP) ? 16 : 20;\n\tval = be32_to_cpu(knode->sel->keys[0].val) >> tos_off & 0xff;\n\tmask = be32_to_cpu(knode->sel->keys[0].mask) >> tos_off & 0xff;\n\tlist_for_each_entry(iter, &alink->dscp_map, list) {\n\t\tu32 cmask;\n\t\tif (iter->handle == knode->handle) {\n\t\t\tmatch = iter;\n\t\t\tcontinue;\n\t\t}\n\t\tcmask = iter->mask & mask;\n\t\tif ((iter->val & cmask) == (val & cmask) &&\n\t\t    iter->band != knode->res->classid) {\n\t\t\tNL_SET_ERR_MSG_MOD(extack, \"conflict with already offloaded filter\");\n\t\t\tgoto err_delete;\n\t\t}\n\t}\n\tif (!match) {\n\t\tmatch = kzalloc(sizeof(*match), GFP_KERNEL);\n\t\tif (!match)\n\t\t\treturn -ENOMEM;\n\t\tlist_add(&match->list, &alink->dscp_map);\n\t}\n\tmatch->handle = knode->handle;\n\tmatch->band = knode->res->classid;\n\tmatch->mask = mask;\n\tmatch->val = val;\n\terr = nfp_abm_update_band_map(alink);\n\tif (err)\n\t\tgoto err_delete;\n\treturn 0;\nerr_delete:\n\tnfp_abm_u32_knode_delete(alink, knode);\n\treturn -EOPNOTSUPP;\n}", "target": 1}
{"code": "    DataBuf LoaderExifDataJpeg::getData() const\n    {\n        if (!valid()) return DataBuf();\n        ExifData::const_iterator pos = image_.exifData().findKey(dataKey_);\n        if (pos != image_.exifData().end()) {\n            DataBuf buf = pos->dataArea(); \n            if (buf.size_ == 0) { \n                buf = DataBuf(pos->size());\n                pos->copy(buf.pData_, invalidByteOrder);\n            }\n            buf.pData_[0] = 0xff; \n            return buf;\n        }\n        return DataBuf();\n    }", "target": 0}
{"code": "    void setPrivate(bool p) { is_private = p; }", "target": 0}
{"code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n  return clone;\n}", "target": 1}
{"code": "int nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol)\n{\n\tint rc;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s target_idx=%u protocol=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, protocol);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_idx);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->activate_target(dev, target, protocol);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t\tif (dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void rb_inc_iter(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tif (iter->head_page == cpu_buffer->reader_page)\n\t\titer->head_page = rb_set_head_page(cpu_buffer);\n\telse\n\t\trb_inc_page(&iter->head_page);\n\titer->page_stamp = iter->read_stamp = iter->head_page->page->time_stamp;\n\titer->head = 0;\n\titer->next_event = 0;\n}", "target": 0}
{"code": "l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}", "target": 1}
{"code": "void LightProcess::closeShadow() {\n  Lock lock(m_procMutex);\n  if (m_shadowProcess) {\n    fprintf(m_fout, \"exit\\n\");\n    fflush(m_fout);\n    fclose(m_fin);\n    fclose(m_fout);\n    ::waitpid(m_shadowProcess, nullptr, 0);\n  }\n  if (!m_afdtFilename.empty()) {\n    remove(m_afdtFilename.c_str());\n  }\n  if (m_afdt_fd >= 0) {\n    ::close(m_afdt_fd);\n    m_afdt_fd = -1;\n  }\n  m_shadowProcess = 0;\n}", "target": 1}
{"code": "static void test_simple()\n{\n    json_set_alloc_funcs(my_malloc, my_free);\n    create_and_free_complex_object();\n    if(malloc_called != 20 || free_called != 20)\n        fail(\"Custom allocation failed\");\n}", "target": 1}
{"code": "pixBlockconvGray(PIX     *pixs,\n                 PIX     *pixacc,\n                 l_int32  wc,\n                 l_int32  hc)\n{\nl_int32    w, h, d, wpl, wpla;\nl_uint32  *datad, *dataa;\nPIX       *pixd, *pixt;\n    PROCNAME(\"pixBlockconvGray\");\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_WARNING(\"kernel too large; returning a copy\\n\", procName);\n        L_INFO(\"w = %d, wc = %d, h = %d, hc = %d\\n\", procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\"pixacc not 32 bpp; making new one\\n\", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n    }\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pixSetPadBits(pixt, 0);\n    wpl = pixGetWpl(pixd);\n    wpla = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixt);\n    blockconvLow(datad, w, h, wpl, dataa, wpla, wc, hc);\n    pixDestroy(&pixt);\n    return pixd;\n}", "target": 1}
{"code": "static inline int xrstor_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XRSTORS\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XRSTOR\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "static void timer_enter_running(Timer *t) {\n        _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL;\n        int r;\n        assert(t);\n        if (unit_stop_pending(UNIT(t)))\n                return;\n        r = manager_add_job(UNIT(t)->manager, JOB_START, UNIT_TRIGGER(UNIT(t)),\n                            JOB_REPLACE, true, &error, NULL);\n        if (r < 0)\n                goto fail;\n        dual_timestamp_get(&t->last_trigger);\n        if (t->stamp_path)\n                touch_file(t->stamp_path, true, t->last_trigger.realtime, UID_INVALID, GID_INVALID, 0);\n        timer_set_state(t, TIMER_RUNNING);\n        return;\nfail:\n        log_unit_warning(UNIT(t), \"Failed to queue unit startup job: %s\", bus_error_message(&error, r));\n        timer_enter_dead(t, TIMER_FAILURE_RESOURCES);\n}", "target": 1}
{"code": "static int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn 0;\n}", "target": 0}
{"code": "static int rb_head_page_set(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t    struct buffer_page *head,\n\t\t\t    struct buffer_page *prev,\n\t\t\t    int old_flag, int new_flag)\n{\n\tstruct list_head *list;\n\tunsigned long val = (unsigned long)&head->list;\n\tunsigned long ret;\n\tlist = &prev->list;\n\tval &= ~RB_FLAG_MASK;\n\tret = cmpxchg((unsigned long *)&list->next,\n\t\t      val | old_flag, val | new_flag);\n\tif ((ret & ~RB_FLAG_MASK) != val)\n\t\treturn RB_PAGE_MOVED;\n\treturn ret & RB_FLAG_MASK;\n}", "target": 0}
{"code": "njs_vmcode_typeof(njs_vm_t *vm, njs_value_t *value, njs_value_t *invld)\n{\n    static const njs_value_t  *types[NJS_VALUE_TYPE_MAX] = {\n        &njs_string_object,\n        &njs_string_undefined,\n        &njs_string_boolean,\n        &njs_string_number,\n        &njs_string_symbol,\n        &njs_string_string,\n        &njs_string_data,\n        &njs_string_external,\n        &njs_string_invalid,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_undefined,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_function,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n        &njs_string_object,\n    };\n    vm->retval = *types[value->type];\n    return sizeof(njs_vmcode_2addr_t);\n}", "target": 0}
{"code": "static int hns_roce_netdev_event(struct notifier_block *self,\n\t\t\t\t unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\tstruct hns_roce_ib_iboe *iboe = NULL;\n\tstruct hns_roce_dev *hr_dev = NULL;\n\tu8 port = 0;\n\tint ret = 0;\n\thr_dev = container_of(self, struct hns_roce_dev, iboe.nb);\n\tiboe = &hr_dev->iboe;\n\tfor (port = 0; port < hr_dev->caps.num_ports; port++) {\n\t\tif (dev == iboe->netdevs[port]) {\n\t\t\tret = handle_en_event(hr_dev, port, event);\n\t\t\tif (ret)\n\t\t\t\treturn NOTIFY_DONE;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn NOTIFY_DONE;\n}", "target": 0}
{"code": "static inline int check_sticky(struct inode *dir, struct inode *inode)\n{\n\tkuid_t fsuid = current_fsuid();\n\tif (!(dir->i_mode & S_ISVTX))\n\t\treturn 0;\n\tif (uid_eq(inode->i_uid, fsuid))\n\t\treturn 0;\n\tif (uid_eq(dir->i_uid, fsuid))\n\t\treturn 0;\n\treturn !inode_capable(inode, CAP_FOWNER);\n}", "target": 1}
{"code": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "parse_string(xmlTextReaderPtr reader, char const *attr, char **result)\n{\n\txmlChar *xml_value;\n\tchar *tmp;\n\tif (attr == NULL)\n\t\txml_value = xmlTextReaderValue(reader);\n\telse\n\t\txml_value = xmlTextReaderGetAttribute(reader, BAD_CAST attr);\n\tif (xml_value == NULL)\n\t\treturn pr_val_err(\"RRDP file: Couldn't find %s from '%s'\",\n\t\t    (attr == NULL ? \"string content\" : \"xml attribute\"),\n\t\t    xmlTextReaderConstLocalName(reader));\n\ttmp = malloc(xmlStrlen(xml_value) + 1);\n\tif (tmp == NULL) {\n\t\txmlFree(xml_value);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(tmp, xml_value, xmlStrlen(xml_value));\n\ttmp[xmlStrlen(xml_value)] = '\\0';\n\txmlFree(xml_value);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "static uint8_t check_length(uint16_t length, uint16_t offset)\n{\n\tif (length > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\tif (offset > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_OFFSET;\n\tif (length + offset > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\treturn 0;\n}", "target": 0}
{"code": "_asn1_set_default_tag (asn1_node node)\n{\n  asn1_node p;\n  if ((node == NULL) || (type_field (node->type) != ASN1_ETYPE_DEFINITIONS))\n    return ASN1_ELEMENT_NOT_FOUND;\n  p = node;\n  while (p)\n    {\n      if ((type_field (p->type) == ASN1_ETYPE_TAG) &&\n\t  !(p->type & CONST_EXPLICIT) && !(p->type & CONST_IMPLICIT))\n\t{\n\t  if (node->type & CONST_EXPLICIT)\n\t    p->type |= CONST_EXPLICIT;\n\t  else\n\t    p->type |= CONST_IMPLICIT;\n\t}\n      if (p->down)\n\t{\n\t  p = p->down;\n\t}\n      else if (p->right)\n\tp = p->right;\n      else\n\t{\n\t  while (1)\n\t    {\n\t      p = _asn1_get_up (p);\n\t      if (p == node)\n\t\t{\n\t\t  p = NULL;\n\t\t  break;\n\t\t}\n\t      if (p->right)\n\t\t{\n\t\t  p = p->right;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  return ASN1_SUCCESS;\n}", "target": 0}
{"code": "static void pipe_advance(struct iov_iter *i, size_t size)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tint idx = i->idx;\n\tsize_t off = i->iov_offset, orig_sz;\n\tif (unlikely(i->count < size))\n\t\tsize = i->count;\n\torig_sz = size;\n\tif (size) {\n\t\tif (off) \n\t\t\tsize += off - pipe->bufs[idx].offset;\n\t\twhile (1) {\n\t\t\tbuf = &pipe->bufs[idx];\n\t\t\tif (size <= buf->len)\n\t\t\t\tbreak;\n\t\t\tsize -= buf->len;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t}\n\t\tbuf->len = size;\n\t\ti->idx = idx;\n\t\toff = i->iov_offset = buf->offset + size;\n\t}\n\tif (off)\n\t\tidx = next_idx(idx, pipe);\n\tif (pipe->nrbufs) {\n\t\tint unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\twhile (idx != unused) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n\t}\n\ti->count -= orig_sz;\n}", "target": 1}
{"code": "static void local_release(struct kref *ref)\n{\n\tstruct nfc_llcp_local *local;\n\tlocal = container_of(ref, struct nfc_llcp_local, ref);\n\tlist_del(&local->list);\n\tlocal_cleanup(local);\n\tkfree(local);\n}", "target": 1}
{"code": "static gg_action_t gg_handle_send_proxy_gg(struct gg_session *sess, struct gg_event *e, enum gg_state_t next_state, enum gg_state_t alt_state, enum gg_state_t alt2_state)\n{\n\tchar *req, *auth;\n\tsize_t req_len;\n\tint res;\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\tif (sess->connect_index > 1 || sess->connect_port[sess->connect_index] == 0) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_CONNECTING;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\tauth = gg_proxy_auth();\n\treq = gg_saprintf(\"CONNECT %s:%d HTTP/1.0\\r\\n%s\\r\\n\", sess->connect_host, sess->connect_port[sess->connect_index], (auth) ? auth : \"\");\n\tfree(auth);\n\tsess->connect_index++;\n\tif (req == NULL) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\treq_len = strlen(req);\n\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\tres = send(sess->fd, req, req_len, 0);\n\tfree(req);\n\tif (res == -1 && errno != EINTR && errno != EAGAIN) {\n\t\tgg_debug_session(sess, GG_DEBUG_MISC, \"\n\t\te->event.failure = GG_FAILURE_PROXY;\n\t\treturn GG_ACTION_FAIL;\n\t}\n\tif ((size_t) res < req_len) {\n\t\tsess->state = alt_state;\n\t\tsess->check = GG_CHECK_WRITE;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t} else {\n\t\tsess->state = next_state;\n\t\tsess->check = GG_CHECK_READ;\n\t\tsess->timeout = GG_DEFAULT_TIMEOUT;\n\t}\n\treturn GG_ACTION_WAIT;\n}", "target": 0}
{"code": "static inline bool StateSynSentValidateTimestamp(TcpSession *ssn, Packet *p)\n{\n    if (PKT_IS_TOSERVER(p) || !(TCP_HAS_TS(p))) {\n        return true;\n    }\n    TcpStream *receiver_stream = &ssn->client;\n    uint32_t ts_echo = TCP_GET_TSECR(p);\n    if ((receiver_stream->flags & STREAMTCP_STREAM_FLAG_TIMESTAMP) != 0) {\n        if (receiver_stream->last_ts != 0 && ts_echo != 0 &&\n            ts_echo != receiver_stream->last_ts)\n        {\n            SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,\n                    ts_echo, receiver_stream->last_ts);\n            return false;\n        }\n    } else {\n        if (receiver_stream->last_ts == 0 && ts_echo != 0) {\n            SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,\n                    ts_echo, receiver_stream->last_ts);\n            return false;\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "KCleanup::operator= ( const KCleanup &src )\n{\n    copy( src );\n    return *this;\n}", "target": 0}
{"code": "ev_archive_at_entry (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\treturn (archive->libar_entry != NULL);\n}", "target": 0}
{"code": "static void adpt_ia64_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_IA64;\n}", "target": 1}
{"code": "static pjmedia_sdp_attr *parse_attr( pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx)\n{\n    pjmedia_sdp_attr *attr;\n    ctx->last_error = PJMEDIA_SDP_EINATTR;\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn NULL;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get(scanner, &cs_token, &attr->name);\n    if (*scanner->curptr && *scanner->curptr != '\\r' && \n\t*scanner->curptr != '\\n') \n    {\n\tif (*scanner->curptr == ':')\n\t    pj_scan_get_char(scanner);\n\tif (*scanner->curptr != '\\r' && *scanner->curptr != '\\n') {\n\t    pj_scan_get_until_chr(scanner, \"\\r\\n\", &attr->value);\n\t} else {\n\t    attr->value.ptr = NULL;\n\t    attr->value.slen = 0;\n\t}\n    } else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n    pj_scan_skip_line(scanner);\n    return attr;\n}", "target": 1}
{"code": "is_contained_by (asection *section, Elf_Internal_Phdr *segment,\n\t\t bfd_vma paddr, bfd_vma vaddr, unsigned int opb,\n\t\t const struct elf_backend_data *bed)\n{\n  bfd_vma seg_addr = !bed->want_p_paddr_set_to_zero ? paddr : vaddr;\n  bfd_vma addr = !bed->want_p_paddr_set_to_zero ? section->lma : section->vma;\n  bfd_vma octet;\n  if (_bfd_mul_overflow (addr, opb, &octet))\n    return false;\n  return (octet >= seg_addr\n\t  && segment_size (segment) >= section_size (section, segment)\n\t  && (octet - seg_addr\n\t      <= segment_size (segment) - section_size (section, segment)));\n}", "target": 0}
{"code": "static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n\t\t\t\t\tsize_t smsize, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = num_cpus,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n\tprintk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);\n\tif (smm_load_module((void *)smbase, smsize, &smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}", "target": 0}
{"code": "static void handle_put_accept(struct http_conn *conn,\n\t\t\t      const struct http_msg *msg,\n\t\t\t      struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"accept: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"accept: saving content(%zu): %b\\n\",\n\t\t  clen, mbuf_buf(mb), mbuf_get_left(mb));\n\tmbuf_strdup(mb, &ie->content.accept, clen);\n\thttp_reply(conn, 200, \"OK\", NULL);\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "void PDPClient::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n#if HAVE_SECURITY\n    if (mp_RTPSParticipant->is_secure())\n    {\n        eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());\n        for (auto& svr : mp_builtin->m_DiscoveryServers)\n        {\n            if (data_matches_with_prefix(svr.guidPrefix, pdata))\n            {\n                if (nullptr == svr.proxy)\n                {\n                    svr.proxy = get_participant_proxy_data(svr.guidPrefix);\n                }\n                match_pdp_reader_nts_(svr, pdata.m_guid.guidPrefix);\n                match_pdp_writer_nts_(svr, pdata.m_guid.guidPrefix);\n                break;\n            }\n        }\n    }\n#endif \n    perform_builtin_endpoints_matching(pdata);\n}", "target": 1}
{"code": "int rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,\n                               int64_t i_pts )\n{\n    if (fmtp == NULL)\n        return VLC_EGENERIC;\n    char *start = strstr(fmtp, \"configuration=\");\n    assert(start != NULL);\n    start += sizeof(\"configuration=\") - 1;\n    char *end = strchr(start, ';');\n    assert(end != NULL);\n    size_t len = end - start;\n    char b64[len + 1];\n    memcpy(b64, start, len);\n    b64[len] = '\\0';\n    int     i_max   = rtp_mtu (id) - 6; \n    uint8_t *p_orig, *p_data;\n    int i_data;\n    i_data = vlc_b64_decode_binary(&p_orig, b64);\n    if (i_data <= 9)\n    {\n        free(p_orig);\n        return VLC_EGENERIC;\n    }\n    p_data = p_orig + 9;\n    i_data -= 9;\n    int i_count = ( i_data + i_max - 1 ) / i_max;\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (1 << 4) | numpkts;\n        rtp_packetize_common( id, out, 0, i_pts );\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n        out->i_dts    = i_pts;\n        rtp_packetize_send( id, out );\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n    free(p_orig);\n    return VLC_SUCCESS;\n}", "target": 1}
{"code": "static inline void check_buffer(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t struct rb_event_info *info,\n\t\t\t unsigned long tail)\n{\n}", "target": 0}
{"code": "int main(int argc, char **argv)\n{\n  test_cmp_parameters inParam;\n  FILE *fbase=NULL, *ftest=NULL;\n  int same = 0;\n  char lbase[256];\n  char strbase[256];\n  char ltest[256];\n  char strtest[256];\n  if( parse_cmdline_cmp(argc, argv, &inParam) == 1 )\n    {\n    compare_dump_files_help_display();\n    goto cleanup;\n    }\n  printf(\"******Parameters********* \\n\");\n  printf(\" base_filename = %s\\n\"\n    \" test_filename = %s\\n\",\n    inParam.base_filename, inParam.test_filename);\n  printf(\"************************* \\n\");\n  printf(\"Try to open: %s for reading ... \", inParam.base_filename);\n  if((fbase = fopen(inParam.base_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n  printf(\"Try to open: %s for reading ... \", inParam.test_filename);\n  if((ftest = fopen(inParam.test_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n  while (fgets(lbase, sizeof(lbase), fbase) && fgets(ltest,sizeof(ltest),ftest))\n    {\n    int nbase = sscanf(lbase, \"%255[^\\r\\n]\", strbase);\n    int ntest = sscanf(ltest, \"%255[^\\r\\n]\", strtest);\n    assert( nbase != 255 && ntest != 255 );\n    if( nbase != 1 || ntest != 1 )\n      {\n      fprintf(stderr, \"could not parse line from files\\n\" );\n      goto cleanup;\n      }\n    if( strcmp( strbase, strtest ) != 0 )\n      {\n      fprintf(stderr,\"<%s> vs. <%s>\\n\", strbase, strtest);\n      goto cleanup;\n      }\n    }\n  same = 1;\n  printf(\"\\n***** TEST SUCCEED: Files are the same. *****\\n\");\ncleanup:\n  if(fbase) fclose(fbase);\n  if(ftest) fclose(ftest);\n  free(inParam.base_filename);\n  free(inParam.test_filename);\n  return same ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "target": 1}
{"code": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}", "target": 1}
{"code": "static int __init mb2cache_init(void)\n{\n\tmb2_entry_cache = kmem_cache_create(\"mbcache\",\n\t\t\t\tsizeof(struct mb2_cache_entry), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT|SLAB_MEM_SPREAD, NULL);\n\tBUG_ON(!mb2_entry_cache);\n\treturn 0;\n}", "target": 0}
{"code": "static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)\n{\n\tstruct xen_pcibk_dev_data *dev_data;\n\tint err;\n\tu16 val;\n\tstruct pci_cmd_info *cmd = data;\n\tdev_data = pci_get_drvdata(dev);\n\tif (!pci_is_enabled(dev) && is_enable_cmd(value)) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: enable\\n\",\n\t\t\t       pci_name(dev));\n\t\terr = pci_enable_device(dev);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (dev_data)\n\t\t\tdev_data->enable_intx = 1;\n\t} else if (pci_is_enabled(dev) && !is_enable_cmd(value)) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: disable\\n\",\n\t\t\t       pci_name(dev));\n\t\tpci_disable_device(dev);\n\t\tif (dev_data)\n\t\t\tdev_data->enable_intx = 0;\n\t}\n\tif (!dev->is_busmaster && is_master_cmd(value)) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG DRV_NAME \": %s: set bus master\\n\",\n\t\t\t       pci_name(dev));\n\t\tpci_set_master(dev);\n\t}\n\tif (value & PCI_COMMAND_INVALIDATE) {\n\t\tif (unlikely(verbose_request))\n\t\t\tprintk(KERN_DEBUG\n\t\t\t       DRV_NAME \": %s: enable memory-write-invalidate\\n\",\n\t\t\t       pci_name(dev));\n\t\terr = pci_set_mwi(dev);\n\t\tif (err) {\n\t\t\tpr_warn(\"%s: cannot enable memory-write-invalidate (%d)\\n\",\n\t\t\t\tpci_name(dev), err);\n\t\t\tvalue &= ~PCI_COMMAND_INVALIDATE;\n\t\t}\n\t}\n\tcmd->val = value;\n\tif (!permissive && (!dev_data || !dev_data->permissive))\n\t\treturn 0;\n\terr = pci_read_config_word(dev, offset, &val);\n\tif (err || val == value)\n\t\treturn err;\n\tvalue &= PCI_COMMAND_GUEST;\n\tvalue |= val & ~PCI_COMMAND_GUEST;\n\treturn pci_write_config_word(dev, offset, value);\n}", "target": 0}
{"code": "htp_status_t htp_tx_req_process_body_data(htp_tx_t *tx, const void *data, size_t len) {\n    if ((tx == NULL) || (data == NULL)) return HTP_ERROR;\n    if (len == 0) return HTP_OK;\n    return htp_tx_req_process_body_data_ex(tx, data, len);\n}", "target": 0}
{"code": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tu64 rem;\n\tnsec = rtc_time() * sgi_clock_period;\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void Context::onLog() {\n  if (wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}", "target": 1}
{"code": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tiput(io->inode);\n\tkfree(io);\n}", "target": 1}
{"code": "String UnbufferedAsioTlsStream::GetVerifyError() const\n{\n\treturn m_VerifyError;\n}", "target": 1}
{"code": "size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tsize_t skip, copy, left, wanted;\n\tconst struct iovec *iov;\n\tchar __user *buf;\n\tvoid *kaddr, *to;\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\twanted = bytes;\n\tiov = i->iov;\n\tskip = i->iov_offset;\n\tbuf = iov->iov_base + skip;\n\tcopy = min(bytes, iov->iov_len - skip);\n\tif (!fault_in_pages_readable(buf, copy)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tto = kaddr + offset;\n\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n\t\tcopy -= left;\n\t\tskip += copy;\n\t\tto += copy;\n\t\tbytes -= copy;\n\t\twhile (unlikely(!left && bytes)) {\n\t\t\tiov++;\n\t\t\tbuf = iov->iov_base;\n\t\t\tcopy = min(bytes, iov->iov_len);\n\t\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n\t\t\tcopy -= left;\n\t\t\tskip = copy;\n\t\t\tto += copy;\n\t\t\tbytes -= copy;\n\t\t}\n\t\tif (likely(!bytes)) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tgoto done;\n\t\t}\n\t\toffset = to - kaddr;\n\t\tbuf += copy;\n\t\tkunmap_atomic(kaddr);\n\t\tcopy = min(bytes, iov->iov_len - skip);\n\t}\n\tkaddr = kmap(page);\n\tto = kaddr + offset;\n\tleft = __copy_from_user(to, buf, copy);\n\tcopy -= left;\n\tskip += copy;\n\tto += copy;\n\tbytes -= copy;\n\twhile (unlikely(!left && bytes)) {\n\t\tiov++;\n\t\tbuf = iov->iov_base;\n\t\tcopy = min(bytes, iov->iov_len);\n\t\tleft = __copy_from_user(to, buf, copy);\n\t\tcopy -= left;\n\t\tskip = copy;\n\t\tto += copy;\n\t\tbytes -= copy;\n\t}\n\tkunmap(page);\ndone:\n\ti->count -= wanted - bytes;\n\ti->nr_segs -= iov - i->iov;\n\ti->iov = iov;\n\ti->iov_offset = skip;\n\treturn wanted - bytes;\n}", "target": 0}
{"code": "int main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n    gr_face_destroy(face);\n    return 0;\n}", "target": 1}
{"code": "static void __sock_release(struct socket *sock, struct inode *inode)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\t\tif (inode)\n\t\t\tinode_lock(inode);\n\t\tsock->ops->release(sock);\n\t\tif (inode)\n\t\t\tinode_unlock(inode);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}", "target": 0}
{"code": "static char *utf2char(utf16_t *str, char *buffer)\n{\n  char *b = buffer;\n  while (*str != 0x00) {\n    char *chr = (char *)str;\n    *b++ = *chr;\n    str++;\n  }\n  *b = 0;\n  return buffer;\n}", "target": 1}
{"code": "static int adpt_slave_configure(struct scsi_device * device)\n{\n\tstruct Scsi_Host *host = device->host;\n\tif (host->can_queue && device->tagged_supported) {\n\t\tscsi_change_queue_depth(device,\n\t\t\t\thost->can_queue - 1);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void zipfileDequote(char *zIn){\n  char q = zIn[0];\n  if( q=='\"' || q=='\\'' || q=='`' || q=='[' ){\n    int iIn = 1;\n    int iOut = 0;\n    if( q=='[' ) q = ']';\n    while( ALWAYS(zIn[iIn]) ){\n      char c = zIn[iIn++];\n      if( c==q && zIn[iIn++]!=q ) break;\n      zIn[iOut++] = c;\n    }\n    zIn[iOut] = '\\0';\n  }\n}", "target": 0}
{"code": "ext2_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}", "target": 1}
{"code": "mes_lookup (struct message *meslist, int max, int index)\n{\n  if ((index >= 0) && (index < max) && (meslist[index].key == index))\n    return meslist[index].str;\n  {\n    int i;\n    for (i = 0; i < max; i++, meslist++)\n      {\n\tif (meslist->key == index)\n\t  {\n\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\",\n\t\t      index, meslist->str, i, max);\n\t    return meslist->str;\n\t  }\n      }\n  }\n  zlog_err(\"message index %d not found (max is %d)\", index, max);\n  return NULL;\n}", "target": 1}
{"code": "static int __net_init sit_init_net(struct net *net)\n{\n\tstruct sit_net *sitn = net_generic(net, sit_net_id);\n\tstruct ip_tunnel *t;\n\tint err;\n\tsitn->tunnels[0] = sitn->tunnels_wc;\n\tsitn->tunnels[1] = sitn->tunnels_l;\n\tsitn->tunnels[2] = sitn->tunnels_r;\n\tsitn->tunnels[3] = sitn->tunnels_r_l;\n\tif (!net_has_fallback_tunnels(net))\n\t\treturn 0;\n\tsitn->fb_tunnel_dev = alloc_netdev(sizeof(struct ip_tunnel), \"sit0\",\n\t\t\t\t\t   NET_NAME_UNKNOWN,\n\t\t\t\t\t   ipip6_tunnel_setup);\n\tif (!sitn->fb_tunnel_dev) {\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc_dev;\n\t}\n\tdev_net_set(sitn->fb_tunnel_dev, net);\n\tsitn->fb_tunnel_dev->rtnl_link_ops = &sit_link_ops;\n\tsitn->fb_tunnel_dev->features |= NETIF_F_NETNS_LOCAL;\n\terr = register_netdev(sitn->fb_tunnel_dev);\n\tif (err)\n\t\tgoto err_reg_dev;\n\tipip6_tunnel_clone_6rd(sitn->fb_tunnel_dev, sitn);\n\tipip6_fb_tunnel_init(sitn->fb_tunnel_dev);\n\tt = netdev_priv(sitn->fb_tunnel_dev);\n\tstrcpy(t->parms.name, sitn->fb_tunnel_dev->name);\n\treturn 0;\nerr_reg_dev:\n\tipip6_dev_free(sitn->fb_tunnel_dev);\n\tfree_netdev(sitn->fb_tunnel_dev);\nerr_alloc_dev:\n\treturn err;\n}", "target": 0}
{"code": "void crypto_bignum_free(struct bignum *a)\n{\n\tif (a)\n\t\tpanic();\n}", "target": 1}
{"code": "static void numtostr(js_State *J, const char *fmt, int w, double n)\n{\n\tchar buf[32], *e;\n\tsprintf(buf, fmt, w, n);\n\te = strchr(buf, 'e');\n\tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}", "target": 1}
{"code": "int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\treturn 1;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NaturalSortAndHint) {\n    addIndex(BSON(\"x\" << 1));\n    runQuerySortHint(fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << -1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << 1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    runQuerySortHint(\n        fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << -1), BSON(\"$natural\" << -1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(\n        fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << 1), BSON(\"$natural\" << 1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << -1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << 1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << -1), BSON(\"$natural\" << -1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << 1), BSON(\"$natural\" << 1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n}", "target": 0}
{"code": "static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\t\tcase 0xC0:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tl = p[1];\n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\treturn n;\n}", "target": 0}
{"code": "int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state;\n\t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n\t\tif (predictor & 0x8000)\n\t\t\tpredictor -= 0x10000;\n\t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\t\tstate.index = encoded[1] & 0x7f;\n\t\tencoded += 2;\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t e = *encoded;\n\t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n\t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n\t\t\tencoded++;\n\t\t}\n\t}\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}", "target": 1}
{"code": "static bool path_connected(const struct path *path)\n{\n\tstruct vfsmount *mnt = path->mnt;\n\tif (mnt->mnt_root == mnt->mnt_sb->s_root)\n\t\treturn true;\n\treturn is_subdir(path->dentry, mnt->mnt_root);\n}", "target": 0}
{"code": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t    if(Z_TYPE_PP(rval) == IS_OBJECT) {\n\t       zend_hash_clean(Z_OBJPROP_PP(rval));\n\t       zend_object_store_ctor_failed(*rval TSRMLS_CC);\n\t    }\n\t    ZVAL_NULL(*rval);\n\t\treturn 0;\n\t}\n    if (Z_TYPE_PP(rval) != IS_OBJECT) {\n        return 0;\n    }\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 0}
{"code": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\ttmp.name[sizeof(tmp.name) - 1] = 0;\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}", "target": 0}
{"code": "void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}", "target": 1}
{"code": "static void hugetlb_vm_op_close(struct vm_area_struct *vma)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct resv_map *reservations = vma_resv_map(vma);\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tunsigned long reserve;\n\tunsigned long start;\n\tunsigned long end;\n\tif (reservations) {\n\t\tstart = vma_hugecache_offset(h, vma, vma->vm_start);\n\t\tend = vma_hugecache_offset(h, vma, vma->vm_end);\n\t\treserve = (end - start) -\n\t\t\tregion_count(&reservations->regions, start, end);\n\t\tresv_map_put(vma);\n\t\tif (reserve) {\n\t\t\thugetlb_acct_memory(h, -reserve);\n\t\t\thugepage_subpool_put_pages(spool, reserve);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\nskipabs:\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "u64 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t  __be16 sport, __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu64 seq;\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + daddr[i];\n\tsecret[4] = net_secret[4] +\n\t\t(((__force u16)sport << 16) + (__force u16)dport);\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\tseq = hash[0] | (((u64)hash[1]) << 32);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 0}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape;\n    status_ = TensorShape::BuildTensorShapeBase(ssm.shape(), &ssm_shape);\n    if (!status_.ok()) return;\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice;\n      status_ = TensorSlice::BuildTensorSlice(tsp, &ss_slice);\n      if (!status_.ok()) return;\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 0}
{"code": "static void set_inverse_transl(struct vc_data *conp, struct uni_pagedir *p, int i)\n{\n\tint j, glyph;\n\tunsigned short *t = translations[i];\n\tunsigned char *q;\n\tif (!p) return;\n\tq = p->inverse_translations[i];\n\tif (!q) {\n\t\tq = p->inverse_translations[i] = kmalloc(MAX_GLYPH, GFP_KERNEL);\n\t\tif (!q) return;\n\t}\n\tmemset(q, 0, MAX_GLYPH);\n\tfor (j = 0; j < E_TABSZ; j++) {\n\t\tglyph = conv_uni_to_pc(conp, t[j]);\n\t\tif (glyph >= 0 && glyph < MAX_GLYPH && q[glyph] < 32) {\n\t\t  \tq[glyph] = j;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static bool __f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 0}
{"code": "RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server,\n                                 GeneralRequest* request, GeneralResponse* response)\n    : RestVocbaseBaseHandler(server, request, response),\n      _validFor(60 * 60 * 24 * 30) {}", "target": 1}
{"code": "sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "cib_remote_msg(gpointer data)\n{\n    const char *value = NULL;\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n    command = crm_recv_remote_msg(client->session, client->encrypted);\n    if (command == NULL) {\n        return -1;\n    }\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        goto bail;\n    }\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n  bail:\n    free_xml(command);\n    command = NULL;\n    return 0;\n}", "target": 1}
{"code": "generate_ava(cms_context *cms, SECItem *der, CERTAVA *certava)\n{\n\tava ava;\n\tSECOidData *oid;\n\tvoid *arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);\n\tif (arena == NULL)\n\t\tcnreterr(-1, cms, \"could not create arena\");\n\tvoid *real_arena = cms->arena;\n\tcms->arena = arena;\n\toid = SECOID_FindOID(&certava->type);\n\tif (!oid) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcnreterr(-1, cms, \"could not find OID\");\n\t}\n\tint rc = generate_object_id(cms, &ava.type, oid->offset);\n\tif (rc < 0) {\n\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\tcms->arena = real_arena;\n\t\treturn -1;\n\t}\n\tmemcpy(&ava.value, &certava->value, sizeof (ava.value));\n\tvoid *ret;\n\tSECItem tmp;\n\tret = SEC_ASN1EncodeItem(arena, &tmp, &ava, AVATemplate);\n\tif (ret == NULL) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcnreterr(-1, cms, \"could not encode AVA\");\n\t}\n\tder->type = tmp.type;\n\tder->len = tmp.len;\n\tder->data = PORT_ArenaAlloc(real_arena, tmp.len);\n\tif (!der->data) {\n\t\tsave_port_err() {\n\t\t\tPORT_FreeArena(arena, PR_TRUE);\n\t\t}\n\t\tcms->arena = real_arena;\n\t\tcnreterr(-1, cms, \"could not allocate AVA\");\n\t}\n\tmemcpy(der->data, tmp.data, tmp.len);\n\tPORT_FreeArena(arena, PR_TRUE);\n\tcms->arena = real_arena;\n\treturn 0;\n}", "target": 0}
{"code": "int db__open(struct mosquitto__config *config)\n{\n\tstruct mosquitto__subhier *subhier;\n\tif(!config) return MOSQ_ERR_INVAL;\n\tdb.last_db_id = 0;\n\tdb.contexts_by_id = NULL;\n\tdb.contexts_by_sock = NULL;\n\tdb.contexts_for_free = NULL;\n#ifdef WITH_BRIDGE\n\tdb.bridges = NULL;\n\tdb.bridge_count = 0;\n#endif\n\tdb.clientid_index_hash = NULL;\n\tdb.subs = NULL;\n\tsubhier = sub__add_hier_entry(NULL, &db.subs, \"\", 0);\n\tif(!subhier) return MOSQ_ERR_NOMEM;\n\tsubhier = sub__add_hier_entry(NULL, &db.subs, \"$SYS\", (uint16_t)strlen(\"$SYS\"));\n\tif(!subhier) return MOSQ_ERR_NOMEM;\n\tretain__init();\n\tdb.config->security_options.unpwd = NULL;\n#ifdef WITH_PERSISTENCE\n\tif(persist__restore()) return 1;\n#endif\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "int ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)\n{\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn -1;\n\tStream_Read(s, response->Response, 16);\n\treturn ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));\n}", "target": 0}
{"code": "void unix_inflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tspin_lock(&unix_gc_lock);\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t}\n\tuser->unix_inflight++;\n\tspin_unlock(&unix_gc_lock);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 5,\n        errors::InvalidArgument(\"out_grad_backprop must be 5-dimensional\"));\n    Pool3dParameters params{context,  ksize_,       stride_,\n                            padding_, data_format_, tensor_in.shape()};\n    if (!context->status().ok()) return;  \n    OP_REQUIRES(context, tensor_out.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected orig_output shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", tensor_out.shape()));\n    OP_REQUIRES(\n        context, out_grad_backprop.shape() == tensor_in.shape(),\n        errors::InvalidArgument(\"Expected grad shape to be \", tensor_in.shape(),\n                                \", but got \", out_grad_backprop.shape()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {2}, 0, tensor_out.shape(), &output));\n    OP_REQUIRES(context, tensor_in.NumElements() > 0,\n                errors::InvalidArgument(\"received empty tensor tensor_in: \",\n                                        tensor_in.DebugString()));\n    OP_REQUIRES(context, tensor_out.NumElements() > 0,\n                errors::InvalidArgument(\"received empty tensor tensor_out: \",\n                                        tensor_out.DebugString()));\n    OP_REQUIRES(\n        context, out_grad_backprop.NumElements() > 0,\n        errors::InvalidArgument(\"received empty tensor out_grad_backprop: \",\n                                out_grad_backprop.DebugString()));\n    OP_REQUIRES(context,\n                tensor_in.NumElements() == out_grad_backprop.NumElements(),\n                errors::InvalidArgument(\"tensor_in and out_grad_backprop must \"\n                                        \"have same number of elements, got <\",\n                                        tensor_in.DebugString(), \"> and <\",\n                                        out_grad_backprop.DebugString(), \">\"));\n    OP_REQUIRES(\n        context, tensor_out.NumElements() == output->NumElements(),\n        errors::InvalidArgument(\n            \"tensor_out and output must have same number of elements, got <\",\n            tensor_out.DebugString(), \"> and <\", output->DebugString(), \">\"));\n    LaunchMaxPooling3dGradGradOp<Device, T>::launch(\n        context, params, tensor_in, tensor_out, out_grad_backprop, output);\n  }", "target": 0}
{"code": "    void operator = (const IniSection &s)\n\t{\n\t    if (&s == this)\n\t    {\n\t\treturn;\n\t    } \n\t    IniBase::operator = (s);\n\t    ip = s.ip;\n\t    end_comment = s.end_comment; rewrite_by = s.rewrite_by;\n\t    container = s.container;\n\t    reindex ();\n\t}", "target": 1}
{"code": "TiledInputFile::rawTileData (int &dx, int &dy,\n\t\t\t     int &lx, int &ly,\n                             const char *&pixelData,\n\t\t\t     int &pixelDataSize)\n{\n    try\n    {\n        Lock lock (*_data->_streamData);\n        if (!isValidTile (dx, dy, lx, ly))\n            throw IEX_NAMESPACE::ArgExc (\"Tried to read a tile outside \"\n\t\t\t       \"the image file's data window.\");\n        TileBuffer *tileBuffer = _data->getTileBuffer (0);\n        int old_dx=dx;\n        int old_dy=dy;\n        int old_lx=lx;\n        int old_ly=ly;\n        if(isMultiPart(version()))\n        {\n            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));\n        }\n        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,\n\t\t\t  tileBuffer->buffer,\n                          pixelDataSize);\n        if(isMultiPart(version()))\n        {\n            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)\n            {\n                throw IEX_NAMESPACE::ArgExc (\"rawTileData read the wrong tile\");\n            }\n        }\n        else\n        {\n             if(!isValidTile (dx, dy, lx, ly) )\n             {\n                 throw IEX_NAMESPACE::IoExc (\"rawTileData read an invalid tile\");\n             }\n        }\n        pixelData = tileBuffer->buffer;\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}", "target": 0}
{"code": "read_file(gchar* filepath)\n{\n\tFILE * f;\n\tsize_t length;\n\tgchar *ret = NULL;\n\tf = fopen(filepath, \"rb\");\n\tif (f) {\n\t\tfseek(f, 0, SEEK_END);\n\t\tlength = (size_t)ftell(f);\n\t\tfseek(f, 0, SEEK_SET);\n\t\tret = MALLOC(length + 1);\n\t\tif (ret) {\n\t\t\tif (fread(ret, length, 1, f) != 1) {\n\t\t\t\tlog_message(LOG_INFO, \"Failed to read all of %s\", filepath);\n\t\t\t}\n\t\t\tret[length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to read Dbus file %s\", filepath);\n\t\tfclose(f);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "pid_t LightProcess::proc_open(const char *cmd, const std::vector<int> &created,\n                              const std::vector<int> &desired,\n                              const char *cwd,\n                              const std::vector<std::string> &env) {\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  always_assert(Available());\n  always_assert(created.size() == desired.size());\n  if (fprintf(g_procs[id].m_fout, \"proc_open\\n%s\\n%s\\n\", cmd, cwd) <= 0) {\n    Logger::Error(\"Failed to send command proc_open\");\n    return -1;\n  }\n  fprintf(g_procs[id].m_fout, \"%d\\n\", (int)env.size());\n  for (unsigned int i = 0; i < env.size(); i++) {\n    fprintf(g_procs[id].m_fout, \"%s\\n\", env[i].c_str());\n  }\n  fprintf(g_procs[id].m_fout, \"%d\\n\", (int)created.size());\n  for (unsigned int i = 0; i < desired.size(); i++) {\n    fprintf(g_procs[id].m_fout, \"%d\\n\", desired[i]);\n  }\n  fflush(g_procs[id].m_fout);\n  bool error_send = false;\n  int save_errno = 0;\n  for (unsigned int i = 0; i < created.size(); i++) {\n    if (!send_fd(g_procs[id].m_afdt_fd, created[i])) {\n      error_send = true;\n      save_errno = errno;\n      break;\n    }\n  }\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (strncmp(buf, \"error\", 5) == 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n    if (error_send) {\n      errno = save_errno;\n    }\n    return -1;\n  }\n  int64_t pid = -1;\n  sscanf(buf, \"%\" PRId64, &pid);\n  assert(pid);\n  return (pid_t)pid;\n}", "target": 1}
{"code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\t*r = -1;\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\tif (KVM_BUG_ON(!src, kvm)) {\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "std::string DecodeUnsafe(string_view encoded) {\n  std::string raw;\n  if (Decode(encoded, &raw)) {\n    return raw;\n  }\n  return ToString(encoded);\n}", "target": 1}
{"code": "struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)\n{\n\tint err;\n\tstruct nfs_client *clp = nfs_alloc_client(cl_init);\n\tif (IS_ERR(clp))\n\t\treturn clp;\n\terr = nfs_get_cb_ident_idr(clp, cl_init->minorversion);\n\tif (err)\n\t\tgoto error;\n\tif (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\tspin_lock_init(&clp->cl_lock);\n\tINIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);\n\tINIT_LIST_HEAD(&clp->cl_ds_clients);\n\trpc_init_wait_queue(&clp->cl_rpcwaitq, \"NFS client\");\n\tclp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;\n\tclp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];\n\tclp->cl_mig_gen = 1;\n#if IS_ENABLED(CONFIG_NFS_V4_1)\n\tinit_waitqueue_head(&clp->cl_lock_waitq);\n#endif\n\tINIT_LIST_HEAD(&clp->pending_cb_stateids);\n\treturn clp;\nerror:\n\tnfs_free_client(clp);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\treturn raw;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    ReshapeOp::Compute(ctx);\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n    output_max->flat<float>()(0) = input_max_float;\n  }", "target": 1}
{"code": "char *url_canonize2(char *d, char const * const s, size_t n,\n\t\t    unsigned syn33,\n\t\t    unsigned m32, unsigned m64, unsigned m96)\n{\n  size_t i = 0;\n  if (d == s)\n    for (;s[i] && i < n; d++, i++)\n      if (s[i] == '%')\n\tbreak;\n  for (;s[i] && i < n; d++, i++) {\n    unsigned char c = s[i], h1, h2;\n    if (c != '%') {\n      if (!IS_SYN33(syn33, c) && IS_EXCLUDED(c, m32, m64, m96))\n\treturn NULL;\n      *d = c;\n      continue;\n    }\n    h1 = s[i + 1];\n    if (!h1) {\n        *d = '\\0';\n        return NULL;\n    }\n    h2 = s[i + 2];\n    if (!IS_HEX(h1) || !IS_HEX(h2)) {\n      *d = '\\0';\n      return NULL;\n    }\n#define UNHEX(a) (a - (a >= 'a' ? 'a' - 10 : (a >= 'A' ? 'A' - 10 : '0')))\n    c = (UNHEX(h1) << 4) | UNHEX(h2);\n    if (!IS_EXCLUDED(c, m32, m64, m96)) {\n      *d = c, i += 2;\n      continue;\n    }\n    if (h1 >= 'a' )\n      h1 = h1 - 'a' + 'A';\n    if (h2 >= 'a' )\n      h2 = h2 - 'a' + 'A';\n    d[0] = '%', d[1] = h1, d[2] = h2;\n    d +=2, i += 2;\n#undef    UNHEX\n  }\n  *d = '\\0';\n  return d;\n}", "target": 0}
{"code": "void ImapModelOpenConnectionTest::testPreauthWithStartTlsWanted()\n{\n    cleanup(); init(true); \n    cEmpty();\n    cServer(\"* PREAUTH hi there\\r\\n\");\n    QCOMPARE(failedSpy->size(), 1);\n    QVERIFY(completedSpy->isEmpty());\n    QVERIFY(authSpy->isEmpty());\n    QVERIFY(startTlsUpgradeSpy->isEmpty());\n}", "target": 0}
{"code": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\trdata->packet = s->packet;\n\trdata->packet_length = s->packet_length;\n\tmemcpy(&(rdata->rbuf), &(s->s3->rbuf), sizeof(SSL3_BUFFER));\n\tmemcpy(&(rdata->rrec), &(s->s3->rrec), sizeof(SSL3_RECORD));\n\titem->data = rdata;\n#ifndef OPENSSL_NO_SCTP\n\tif (BIO_dgram_is_sctp(SSL_get_rbio(s)) &&\n\t    (s->state == SSL3_ST_SR_FINISHED_A || s->state == SSL3_ST_CR_FINISHED_A)) {\n\t\tBIO_ctrl(SSL_get_rbio(s), BIO_CTRL_DGRAM_SCTP_GET_RCVINFO, sizeof(rdata->recordinfo), &rdata->recordinfo);\n\t}\n#endif\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\treturn(1);\n\t}", "target": 1}
{"code": "int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_snmp_ureq *ureq;\n\tint req_len;\n\tstruct qeth_arp_query_info qinfo = {0, };\n\tint rc = 0;\n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n\t\treturn -EFAULT;\n\tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n\tif (IS_ERR(ureq)) {\n\t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}", "target": 1}
{"code": "void hincrbyfloatCommand(client *c) {\n    long double value, incr;\n    long long ll;\n    robj *o;\n    sds new;\n    unsigned char *vstr;\n    unsigned int vlen;\n    if (getLongDoubleFromObjectOrReply(c,c->argv[3],&incr,NULL) != C_OK) return;\n    if (isnan(incr) || isinf(incr)) {\n        addReplyError(c,\"value is NaN or Infinity\");\n        return;\n    }\n    if ((o = hashTypeLookupWriteOrCreate(c,c->argv[1])) == NULL) return;\n    if (hashTypeGetValue(o,c->argv[2]->ptr,&vstr,&vlen,&ll) == C_OK) {\n        if (vstr) {\n            if (string2ld((char*)vstr,vlen,&value) == 0) {\n                addReplyError(c,\"hash value is not a float\");\n                return;\n            }\n        } else {\n            value = (long double)ll;\n        }\n    } else {\n        value = 0;\n    }\n    value += incr;\n    if (isnan(value) || isinf(value)) {\n        addReplyError(c,\"increment would produce NaN or Infinity\");\n        return;\n    }\n    char buf[MAX_LONG_DOUBLE_CHARS];\n    int len = ld2string(buf,sizeof(buf),value,LD_STR_HUMAN);\n    new = sdsnewlen(buf,len);\n    hashTypeSet(o,c->argv[2]->ptr,new,HASH_SET_TAKE_VALUE);\n    addReplyBulkCBuffer(c,buf,len);\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_HASH,\"hincrbyfloat\",c->argv[1],c->db->id);\n    server.dirty++;\n    robj *newobj;\n    newobj = createRawStringObject(buf,len);\n    rewriteClientCommandArgument(c,0,shared.hset);\n    rewriteClientCommandArgument(c,3,newobj);\n    decrRefCount(newobj);\n}", "target": 0}
{"code": "sudo_lbuf_append_esc_v1(struct sudo_lbuf *lbuf, int flags, const char *fmt, ...)\n{\n    unsigned int saved_len = lbuf->len;\n    bool ret = false;\n    const char *s;\n    va_list ap;\n    debug_decl(sudo_lbuf_append_esc, SUDO_DEBUG_UTIL);\n    if (sudo_lbuf_error(lbuf))\n\tdebug_return_bool(false);\n#define should_escape(ch) \\\n    ((ISSET(flags, LBUF_ESC_CNTRL) && iscntrl((unsigned char)ch)) || \\\n    (ISSET(flags, LBUF_ESC_BLANK) && isblank((unsigned char)ch)))\n#define should_quote(ch) \\\n    (ISSET(flags, LBUF_ESC_QUOTE) && (ch == '\\'' || ch == '\\\\'))\n    va_start(ap, fmt);\n    while (*fmt != '\\0') {\n\tif (fmt[0] == '%' && fmt[1] == 's') {\n\t    if ((s = va_arg(ap, char *)) == NULL)\n\t\ts = \"(NULL)\";\n\t    while (*s != '\\0') {\n\t\tif (should_escape(*s)) {\n\t\t    if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n\t\t\tgoto done;\n\t\t    lbuf->len += escape(*s++, lbuf->buf + lbuf->len);\n\t\t    continue;\n\t\t}\n\t\tif (should_quote(*s)) {\n\t\t    if (!sudo_lbuf_expand(lbuf, 2))\n\t\t\tgoto done;\n\t\t    lbuf->buf[lbuf->len++] = '\\\\';\n\t\t    lbuf->buf[lbuf->len++] = *s++;\n\t\t    continue;\n\t\t}\n\t\tif (!sudo_lbuf_expand(lbuf, 1))\n\t\t    goto done;\n\t\tlbuf->buf[lbuf->len++] = *s++;\n\t    }\n\t    fmt += 2;\n\t    continue;\n\t}\n\tif (should_escape(*fmt)) {\n\t    if (!sudo_lbuf_expand(lbuf, sizeof(\"#0177\") - 1))\n\t\tgoto done;\n\t    if (*fmt == '\\'') {\n\t\tlbuf->buf[lbuf->len++] = '\\\\';\n\t\tlbuf->buf[lbuf->len++] = *fmt++;\n\t    } else {\n\t\tlbuf->len += escape(*fmt++, lbuf->buf + lbuf->len);\n\t    }\n\t    continue;\n\t}\n\tif (!sudo_lbuf_expand(lbuf, 1))\n\t    goto done;\n\tlbuf->buf[lbuf->len++] = *fmt++;\n    }\n    ret = true;\ndone:\n    if (!ret)\n\tlbuf->len = saved_len;\n    if (lbuf->size != 0)\n\tlbuf->buf[lbuf->len] = '\\0';\n    va_end(ap);\n    debug_return_bool(ret);\n}", "target": 0}
{"code": "archive_reopen_if_needed (ComicsDocument  *comics_document,\n\t\t\t  const char      *page_wanted,\n\t\t\t  GError         **error)\n{\n\tconst char *current_page;\n\tguint current_page_idx, page_wanted_idx;\n\tif (ev_archive_at_entry (comics_document->archive)) {\n\t\tcurrent_page = ev_archive_get_entry_pathname (comics_document->archive);\n\t\tif (current_page) {\n\t\t\tcurrent_page_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, current_page));\n\t\t\tpage_wanted_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, page_wanted));\n\t\t\tif (current_page_idx != 0 &&\n\t\t\t    page_wanted_idx != 0 &&\n\t\t\t    page_wanted_idx > current_page_idx)\n\t\t\t\treturn TRUE;\n\t\t}\n\t\tev_archive_reset (comics_document->archive);\n\t}\n\treturn ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error);\n}", "target": 0}
{"code": "static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n{\n\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n}", "target": 1}
{"code": "void zend_throw_exception_internal(zval *exception TSRMLS_DC) \n{\n#ifdef HAVE_DTRACE\n\tif (DTRACE_EXCEPTION_THROWN_ENABLED()) {\n\t\tconst char *classname;\n\t\tzend_uint name_len;\n\t\tif (exception != NULL) {\n\t\t\tzend_get_object_classname(exception, &classname, &name_len TSRMLS_CC);\n\t\t\tDTRACE_EXCEPTION_THROWN((char *)classname);\n\t\t} else {\n\t\t\tDTRACE_EXCEPTION_THROWN(NULL);\n\t\t}\n\t}\n#endif \n\tif (exception != NULL) {\n\t\tzval *previous = EG(exception);\n\t\tzend_exception_set_previous(exception, EG(exception) TSRMLS_CC);\n\t\tEG(exception) = exception;\n\t\tif (previous) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!EG(current_execute_data)) {\n\t\tif(EG(exception)) {\n\t\t\tzend_exception_error(EG(exception), E_ERROR TSRMLS_CC);\n\t\t}\n\t\tzend_error(E_ERROR, \"Exception thrown without a stack frame\");\n\t}\n\tif (zend_throw_exception_hook) {\n\t\tzend_throw_exception_hook(exception TSRMLS_CC);\n\t}\n\tif (EG(current_execute_data)->opline == NULL ||\n\t    (EG(current_execute_data)->opline+1)->opcode == ZEND_HANDLE_EXCEPTION) {\n\t\treturn;\n\t}\n\tEG(opline_before_exception) = EG(current_execute_data)->opline;\n\tEG(current_execute_data)->opline = EG(exception_op);\n}", "target": 0}
{"code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n    clear(); \n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n    return response();\n}", "target": 1}
{"code": "static u64 distribute_cfs_runtime(struct cfs_bandwidth *cfs_b,\n\t\tu64 remaining, u64 expires)\n{\n\tstruct cfs_rq *cfs_rq;\n\tu64 runtime;\n\tu64 starting_runtime = remaining;\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cfs_rq, &cfs_b->throttled_cfs_rq,\n\t\t\t\tthrottled_list) {\n\t\tstruct rq *rq = rq_of(cfs_rq);\n\t\tstruct rq_flags rf;\n\t\trq_lock_irqsave(rq, &rf);\n\t\tif (!cfs_rq_throttled(cfs_rq))\n\t\t\tgoto next;\n\t\truntime = -cfs_rq->runtime_remaining + 1;\n\t\tif (runtime > remaining)\n\t\t\truntime = remaining;\n\t\tremaining -= runtime;\n\t\tcfs_rq->runtime_remaining += runtime;\n\t\tcfs_rq->runtime_expires = expires;\n\t\tif (cfs_rq->runtime_remaining > 0)\n\t\t\tunthrottle_cfs_rq(cfs_rq);\nnext:\n\t\trq_unlock_irqrestore(rq, &rf);\n\t\tif (!remaining)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\treturn starting_runtime - remaining;\n}", "target": 1}
{"code": "GF_Err gf_isom_avc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, 0, GF_FALSE);\n}", "target": 0}
{"code": "static int sd_e_h(GWindow gw, GEvent *event) {\n    struct sd_data *sd = GDrawGetUserData(gw);\n    if ( sd==NULL )\nreturn( true );\n    if ( event->type==et_close ) {\n\tSD_DoCancel( sd );\n    } else if ( event->type==et_controlevent && event->u.control.subtype==et_textchanged ) {\n    sd->fv->script_unsaved = !GTextFieldIsEmpty(GWidgetGetControl(sd->gw,CID_Script));\n    } else if ( event->type==et_controlevent && event->u.control.subtype==et_save ) {\n    sd->fv->script_unsaved = false;\n    } else if ( event->type==et_char ) {\n\tif ( event->u.chr.keysym == GK_F1 || event->u.chr.keysym == GK_Help ) {\n\t    help(\"scripting.html\");\nreturn( true );\n\t}\nreturn( false );\n    } else if ( event->type == et_map )\t\n\tGDrawRaise(gw);\n    else if ( event->type == et_resize )\n\tGDrawRequestExpose(gw,NULL,false);\nreturn( true );\n}", "target": 0}
{"code": "static int umocktypes_are_equal_FLOW_HANDLE(FLOW_HANDLE* left, FLOW_HANDLE* right)\n{\n    int result;\n    if (*left == *right)\n    {\n        result = 1;\n    }\n    else\n    {\n        result = 0;\n    }\n    return result;\n}", "target": 0}
{"code": "int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)\n{\n\tint\terror = 0;\n\tstruct cxio_rdev *rdev;\n\trdev = (struct cxio_rdev *)tdev->ulp;\n\tif (cxio_fatal_error(rdev)) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\terror = cxgb3_ofld_send(tdev, skb);\n\tif (error < 0)\n\t\tkfree_skb(skb);\n\treturn error;\n}", "target": 1}
{"code": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_call_handlers(ndp, msg);;\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}", "target": 1}
{"code": "int __nla_parse(struct nlattr **tb, int maxtype,\n\t\tconst struct nlattr *head, int len,\n\t\tconst struct nla_policy *policy, unsigned int validate,\n\t\tstruct netlink_ext_ack *extack)\n{\n\treturn __nla_validate_parse(head, len, maxtype, policy, validate,\n\t\t\t\t    extack, tb);\n}", "target": 1}
{"code": "      \\param[out] colors At return, contains the list of 3d object colors.\n      \\return List of 3d object vertices.\n    **/\n    template<typename tf, typename tc>", "target": 0}
{"code": "int AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\tAVI->video_pos++;\n\treturn n;\n}", "target": 1}
{"code": "void ida_free(struct ida *ida, unsigned int id)\n{\n\tXA_STATE(xas, &ida->xa, id / IDA_BITMAP_BITS);\n\tunsigned bit = id % IDA_BITMAP_BITS;\n\tstruct ida_bitmap *bitmap;\n\tunsigned long flags;\n\tif ((int)id < 0)\n\t\treturn;\n\txas_lock_irqsave(&xas, flags);\n\tbitmap = xas_load(&xas);\n\tif (xa_is_value(bitmap)) {\n\t\tunsigned long v = xa_to_value(bitmap);\n\t\tif (bit >= BITS_PER_XA_VALUE)\n\t\t\tgoto err;\n\t\tif (!(v & (1UL << bit)))\n\t\t\tgoto err;\n\t\tv &= ~(1UL << bit);\n\t\tif (!v)\n\t\t\tgoto delete;\n\t\txas_store(&xas, xa_mk_value(v));\n\t} else {\n\t\tif (!test_bit(bit, bitmap->bitmap))\n\t\t\tgoto err;\n\t\t__clear_bit(bit, bitmap->bitmap);\n\t\txas_set_mark(&xas, XA_FREE_MARK);\n\t\tif (bitmap_empty(bitmap->bitmap, IDA_BITMAP_BITS)) {\n\t\t\tkfree(bitmap);\ndelete:\n\t\t\txas_store(&xas, NULL);\n\t\t}\n\t}\n\txas_unlock_irqrestore(&xas, flags);\n\treturn;\n err:\n\txas_unlock_irqrestore(&xas, flags);\n\tWARN(1, \"ida_free called for id=%d which is not allocated.\\n\", id);\n}", "target": 1}
{"code": "int pam_modutil_regain_priv(pam_handle_t *pamh, struct _ykpam_privs *privs) {\n    if ((privs->saved_euid == geteuid()) && (privs->saved_egid == getegid())) {\n        D (privs->debug_file, \"Privilges already as requested, pretend it is all right\");\n        return 0;\n    }\n    if (seteuid(privs->saved_euid) < 0) {\n        D (privs->debug_file, \"seteuid: %s\", strerror(errno));\n        return -1;\n    }\n    if (setegid(privs->saved_egid) < 0) {\n        D (privs->debug_file, \"setegid: %s\", strerror(errno));\n        return -1;\n    }\n    if (setgroups(privs->saved_groups_length, privs->saved_groups) < 0) {\n        D (privs->debug_file, \"setgroups: %s\", strerror(errno));\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "template <class T> void testFeatTable(const T & table, const char * testName)\n{\n    FeatureMap testFeatureMap;\n    dummyFace.replace_table(TtfUtil::Tag::Feat, &table, sizeof(T));\n    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n    if (!face) throw std::runtime_error(\"failed to load font\");\n    bool readStatus = testFeatureMap.readFeats(*face);\n    testAssert(\"readFeats\", readStatus);\n    fprintf(stderr, testName, NULL);\n    testAssertEqual(\"test num features %hu,%hu\\n\", testFeatureMap.numFeats(), table.m_header.m_numFeat);\n    for (size_t i = 0; i < sizeof(table.m_defs) / sizeof(FeatDefn); i++)\n    {\n        const FeatureRef * ref = testFeatureMap.findFeatureRef(table.m_defs[i].m_featId);\n        testAssert(\"test feat\\n\", ref);\n        testAssertEqual(\"test feat settings %hu %hu\\n\", ref->getNumSettings(), table.m_defs[i].m_numFeatSettings);\n        testAssertEqual(\"test feat label %hu %hu\\n\", ref->getNameId(), table.m_defs[i].m_label);\n        size_t settingsIndex = (table.m_defs[i].m_settingsOffset - sizeof(FeatHeader)\n            - (sizeof(FeatDefn) * table.m_header.m_numFeat)) / sizeof(FeatSetting);\n        for (size_t j = 0; j < table.m_defs[i].m_numFeatSettings; j++)\n        {\n            testAssertEqual(\"setting label %hu %hu\\n\", ref->getSettingName(j),\n                       table.m_settings[settingsIndex+j].m_label);\n        }\n    }\n    gr_face_destroy(face);\n}", "target": 1}
{"code": "raptor_rss_parse_start(raptor_parser *rdf_parser) \n{\n  raptor_uri *uri = rdf_parser->base_uri;\n  raptor_rss_parser* rss_parser = (raptor_rss_parser*)rdf_parser->context;\n  int n;\n  if(!uri)\n    return 1;\n  for(n = 0; n < RAPTOR_RSS_NAMESPACES_SIZE; n++)\n    rss_parser->nspaces_seen[n] = 'N';\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_NO_NET, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_NO_FILE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_FILE));\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES));\n  if(rdf_parser->uri_filter)\n    raptor_sax2_set_uri_filter(rss_parser->sax2, rdf_parser->uri_filter,\n                               rdf_parser->uri_filter_user_data);\n  raptor_sax2_parse_start(rss_parser->sax2, uri);\n  return 0;\n}", "target": 0}
{"code": "static void sco_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\tBT_DBG(\"parent %p\", parent);\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tsco_sock_close(sk);\n\t\tsco_sock_kill(sk);\n\t}\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}", "target": 0}
{"code": "static void read_conf(FILE *conffile)\n{\n    char *buffer, *line, *val;\n    buffer = loadfile(conffile);\n    for (line = strtok(buffer, \"\\r\\n\"); line; line = strtok(NULL, \"\\r\\n\")) {\n        if (!strncmp(line, \"export \", 7))\n            continue;\n        val = strchr(line, '=');\n        if (!val) {\n            printf(\"invalid configuration line\\n\");\n            break;\n        }\n        *val++ = '\\0';\n        if (!strcmp(line, \"JSON_INDENT\"))\n            conf.indent = atoi(val);\n        if (!strcmp(line, \"JSON_COMPACT\"))\n            conf.compact = atoi(val);\n        if (!strcmp(line, \"JSON_ENSURE_ASCII\"))\n            conf.ensure_ascii = atoi(val);\n        if (!strcmp(line, \"JSON_PRESERVE_ORDER\"))\n            conf.preserve_order = atoi(val);\n        if (!strcmp(line, \"JSON_SORT_KEYS\"))\n            conf.sort_keys = atoi(val);\n        if (!strcmp(line, \"STRIP\"))\n            conf.strip = atoi(val);\n        if (!strcmp(line, \"HASHSEED\")) {\n            conf.have_hashseed = 1;\n            conf.hashseed = atoi(val);\n        } else {\n            conf.have_hashseed = 0;\n        }\n    }\n    free(buffer);\n}", "target": 0}
{"code": "static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq)\n{\n\tunsigned row;\n\tunsigned col;\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -EINVAL;\n\trow = EVTCHN_ROW(evtchn);\n\tcol = EVTCHN_COL(evtchn);\n\tif (evtchn_to_irq[row] == NULL) {\n\t\tif (irq == -1)\n\t\t\treturn 0;\n\t\tevtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL);\n\t\tif (evtchn_to_irq[row] == NULL)\n\t\t\treturn -ENOMEM;\n\t\tclear_evtchn_to_irq_row(row);\n\t}\n\tevtchn_to_irq[row][col] = irq;\n\treturn 0;\n}", "target": 1}
{"code": "int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tint error = 0;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tconst char *name = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (error < 0) {\n\t\t\t\tgossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",\n\t\t\t\t\t   __func__,\n\t\t\t\t\t   error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif (inode->i_mode != mode)\n\t\t\t\tSetModeFlag(orangefs_inode);\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"%s: invalid type %d!\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: inode %pU, key %s type %d\\n\",\n\t\t     __func__, get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     type);\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: name %s, value %p, size %zd, acl %p\\n\",\n\t\t     __func__, name, value, size, acl);\n\terror = orangefs_inode_setxattr(inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "  AvgPoolGradOp(OpKernelConstruction* ctx, int num_spatial_dims)\n      : XlaOpKernel(ctx), num_spatial_dims_(num_spatial_dims) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"ksize\", &ksize_));\n    OP_REQUIRES(ctx, ksize_.size() == num_dims(),\n                errors::InvalidArgument(\"Sliding window ksize field must \"\n                                        \"specify \",\n                                        num_dims(), \" dimensions\"));\n    OP_REQUIRES_OK(ctx, ValidateKernelSizes(ksize_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"strides\", &stride_));\n    OP_REQUIRES(ctx, stride_.size() == num_dims(),\n                errors::InvalidArgument(\"Sliding window strides field must \"\n                                        \"specify \",\n                                        num_dims(), \" dimensions\"));\n    OP_REQUIRES_OK(ctx, ValidateStrides(stride_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"padding\", &padding_));\n    OP_REQUIRES(ctx, padding_ != EXPLICIT,\n                errors::Unimplemented(\n                    \"XLA does not support avgpoolgrad with explicit padding.\"));\n    OP_REQUIRES(ctx, ksize_[0] == 1 && stride_[0] == 1,\n                errors::Unimplemented(\n                    \"Pooling is not yet supported on the batch dimension.\"));\n    string data_format;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"data_format\", &data_format));\n    OP_REQUIRES(ctx, FormatFromString(data_format, &data_format_),\n                errors::InvalidArgument(\"Invalid data format\"));\n  }", "target": 0}
{"code": "  static ::tensorflow::Status ValidateInputs(\n      std::vector<ConstFlatSplits> rt_nested_splits,\n      const Tensor& rt_dense_values_in) {\n    for (int i = 0; i < rt_nested_splits.size(); ++i) {\n      if (rt_nested_splits[i].size() == 0) {\n        return InvalidArgument(\"ragged splits may not be empty.\");\n      }\n      if (rt_nested_splits[i](0) != 0) {\n        return InvalidArgument(\"First value of ragged splits must be 0.\");\n      }\n      for (int j = 1; j < rt_nested_splits[i].size(); ++j) {\n        if (rt_nested_splits[i](j) < rt_nested_splits[i](j - 1)) {\n          return InvalidArgument(\n              \"Ragged splits should be non decreasing, but we got \",\n              rt_nested_splits[i](j - 1), \" followed by \",\n              rt_nested_splits[i](j));\n        }\n      }\n      if (i > 0) {\n        SPLITS_TYPE last_split =\n            rt_nested_splits[i - 1](rt_nested_splits[i - 1].size() - 1);\n        if (rt_nested_splits[i].size() != last_split + 1) {\n          return InvalidArgument(\n              \"Final value of ragged splits must match the length \"\n              \"the corresponding ragged values.\");\n        }\n      }\n    }\n    if (rt_dense_values_in.dim_size(0) !=\n        rt_nested_splits.back()(rt_nested_splits.back().size() - 1)) {\n      return InvalidArgument(\n          \"Final value of ragged splits must match the length \"\n          \"the corresponding ragged values.\");\n    }\n    return ::tensorflow::Status::OK();\n  }", "target": 0}
{"code": "GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns)\n{\n\tint r;\n\tstatic const char resp[] =\n\t\t\"<u:%sResponse \"\n\t\t\"xmlns:u=\\\"%s\\\">\"\n\t\t\"<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>\"\n\t\t\"</u:%sResponse>\";\n\tchar body[512];\n\tint bodylen;\n\tstruct NameValueParserData data;\n\tchar * int_ip, * int_port, * rem_host, * rem_port, * protocol;\n\tint opt=0;\n\tunsigned short iport, rport;\n\tif (GETFLAG(IPV6FCFWDISABLEDMASK))\n\t{\n\t\tSoapError(h, 702, \"FirewallDisabled\");\n\t\treturn;\n\t}\n\tParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data);\n\tint_ip = GetValueFromNameValueList(&data, \"InternalClient\");\n\tint_port = GetValueFromNameValueList(&data, \"InternalPort\");\n\trem_host = GetValueFromNameValueList(&data, \"RemoteHost\");\n\trem_port = GetValueFromNameValueList(&data, \"RemotePort\");\n\tprotocol = GetValueFromNameValueList(&data, \"Protocol\");\n\tif (!int_port || !rem_port || !protocol)\n\t{\n\t\tClearNameValueList(&data);\n\t\tSoapError(h, 402, \"Invalid Args\");\n\t\treturn;\n\t}\n\trport = (unsigned short)atoi(rem_port);\n\tiport = (unsigned short)atoi(int_port);\n\tsyslog(LOG_INFO, \"%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s\", action, int_ip, iport,rem_host, rport, protocol);\n\tr = -1;\n\tswitch(r)\n\t{\n\t\tcase 1:\t\n\t\t\tbodylen = snprintf(body, sizeof(body), resp,\n\t\t\t                   action, ns,\n\t\t\t                   opt, action);\n\t\t\tBuildSendAndCloseSoapResp(h, body, bodylen);\n\t\t\tbreak;\n\t\tcase -5:\t\n\t\t\tSoapError(h, 705, \"ProtocolNotSupported\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tSoapError(h, 501, \"ActionFailed\");\n\t}\n\tClearNameValueList(&data);\n}", "target": 0}
{"code": "long join_session_keyring(const char *name)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\tstruct key *keyring;\n\tlong ret, serial;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\told = current_cred();\n\tif (!name) {\n\t\tret = install_session_keyring_to_cred(new, NULL);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tserial = new->session_keyring->serial;\n\t\tret = commit_creds(new);\n\t\tif (ret == 0)\n\t\t\tret = serial;\n\t\tgoto okay;\n\t}\n\tmutex_lock(&key_session_mutex);\n\tkeyring = find_keyring_by_name(name, false);\n\tif (PTR_ERR(keyring) == -ENOKEY) {\n\t\tkeyring = keyring_alloc(\n\t\t\tname, old->uid, old->gid, old,\n\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ | KEY_USR_LINK,\n\t\t\tKEY_ALLOC_IN_QUOTA, NULL);\n\t\tif (IS_ERR(keyring)) {\n\t\t\tret = PTR_ERR(keyring);\n\t\t\tgoto error2;\n\t\t}\n\t} else if (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error2;\n\t} else if (keyring == new->session_keyring) {\n\t\tkey_put(keyring);\n\t\tret = 0;\n\t\tgoto error2;\n\t}\n\tret = install_session_keyring_to_cred(new, keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\tcommit_creds(new);\n\tmutex_unlock(&key_session_mutex);\n\tret = keyring->serial;\n\tkey_put(keyring);\nokay:\n\treturn ret;\nerror2:\n\tmutex_unlock(&key_session_mutex);\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 0}
{"code": "  inline Eigen::IndexList<int, Eigen::type2index<1>> NByOne(int n) {\n    Eigen::IndexList<int, Eigen::type2index<1>> ret;\n    ret.set(0, n);\n    return ret;\n  }", "target": 1}
{"code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        value += (1 << zeroes) - 1;\n    }\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n    *write_to = value;\n    return 0;\n}", "target": 1}
{"code": "std::string decodeBase64(\n    const std::string& encoded) {\n  if (encoded.size() == 0) {\n    return \"\";\n  }\n  using namespace boost::archive::iterators;\n  using b64it =\n    transform_width<binary_from_base64<std::string::const_iterator>, 8, 6>;\n  std::string decoded = std::string(b64it(std::begin(encoded)),\n                                    b64it(std::end(encoded)));\n  uint32_t numPadding = std::count(encoded.begin(), encoded.end(), '=');\n  decoded.erase(decoded.end() - numPadding, decoded.end());\n  return decoded;\n}", "target": 1}
{"code": "static int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}", "target": 1}
{"code": "static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}", "target": 1}
{"code": "static int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc != 5)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\tdevaddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\tlength = hextoul(argv[3], NULL);\n\tmemaddr = (u_char *)hextoul(argv[4], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, devaddr, memaddr, length);\n#else\n\tret = i2c_read(chip, devaddr, alen, memaddr, length);\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\treturn 0;\n}", "target": 1}
{"code": "static DexString *dex_string_new(RzBuffer *buf, ut64 offset, st64 *pread) {\n\tut64 size = 0;\n\tchar *data = NULL;\n\tst64 read;\n\tDexString *string = NULL;\n\tread = rz_buf_uleb128(buf, &size);\n\tif (UT64_ADD_OVFCHK(size, 1)) {\n\t\treturn NULL;\n\t}\n\tdata = malloc(size + 1);\n\tif (!data || rz_buf_read(buf, (ut8 *)data, size) != size) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\tdata[size] = 0;\n\tstring = RZ_NEW0(DexString);\n\tif (!string) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\t*pread = read;\n\tstring->size = size;\n\tstring->offset = offset;\n\tstring->data = data;\n\treturn string;\n}", "target": 0}
{"code": "w3m_exit(int i)\n{\n#ifdef USE_MIGEMO\n    init_migemo();\t\t\n#endif\n    stopDownload();\n    deleteFiles();\n#ifdef USE_SSL\n    free_ssl_ctx();\n#endif\n    disconnectFTP();\n#ifdef USE_NNTP\n    disconnectNews();\n#endif\n#ifdef __MINGW32_VERSION\n    WSACleanup();\n#endif\n#ifdef HAVE_MKDTEMP\n    if (no_rc_dir && tmp_dir != rc_dir)\n\tif (rmdir(tmp_dir) != 0) {\n\t    fprintf(stderr, \"Can't remove temporary directory (%s)!\\n\", tmp_dir);\n\t    exit(1);\n\t}\n#endif\n    exit(i);\n}", "target": 0}
{"code": "static void tty_set_termios_ldisc(struct tty_struct *tty, int num)\n{\n\tdown_write(&tty->termios_rwsem);\n\ttty->termios.c_line = num;\n\tup_write(&tty->termios_rwsem);\n\ttty->disc_data = NULL;\n\ttty->receive_room = 0;\n}", "target": 0}
{"code": "static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1}
{"code": "x509stack_peek_level(struct cert_stack *stack)\n{\n\tstruct repo_level_node *repo = SLIST_FIRST(&stack->levels);\n\treturn (repo != NULL) ? repo->level : 0;\n}", "target": 1}
{"code": "static unsigned int ip6_hashfn(struct inet_frag_queue *q)\n{\n\tstruct frag_queue *fq;\n\tfq = container_of(q, struct frag_queue, q);\n\treturn inet6_hash_frag(fq->id, &fq->saddr, &fq->daddr, ip6_frags.rnd);\n}", "target": 0}
{"code": "gss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "sg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\tsrp->data.cmd_opcode = cmnd[0];\t\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n\t\treturn k;\t\n\t}\n\tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio)\n\t\t\tblk_end_request_all(srp->rq, -EIO);\n\t\tsg_finish_rem_req(srp);\n\t\treturn -ENODEV;\n\t}\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); \n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}", "target": 1}
{"code": "static int linkSane(FD_t wfd, const char *dest)\n{\n    struct stat sb, lsb;\n    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&\n\t    (sb.st_mode & ~S_IFMT) == S_IWUSR &&\n\t    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&\n\t    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);\n}", "target": 0}
{"code": "int firstBitSet(int x)\n{\n        int position=0;\n        while (x!=0)\n        {\n                x>>=1;\n                ++position;\n        }\n        return position;\n}", "target": 0}
{"code": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\tif (!ns_capable(net->user_ns, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs, XFRMA_MAX,\n\t\t\t  xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\treturn link->doit(skb, nlh, attrs);\n}", "target": 0}
{"code": "Network::TransportSocketPtr ServerSslSocketFactory::createDownstreamTransportSocket() const {\n  Envoy::Ssl::ServerContextSharedPtr ssl_ctx;\n  {\n    absl::ReaderMutexLock l(&ssl_ctx_mu_);\n    ssl_ctx = ssl_ctx_;\n  }\n  if (ssl_ctx) {\n    return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,\n                                       config_->createHandshaker());\n  } else {\n    ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n    stats_.downstream_context_secrets_not_ready_.inc();\n    return std::make_unique<NotReadySslSocket>();\n  }\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_bootstrap_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaBootStrapMethod *bsm = NULL;\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_BOOTSTRAP_METHODS_ATTR;\n\t\tif (offset + 8 > sz)  {\n\t\t\tfree (attr);\n\t\t\treturn NULL;\n\t\t}\n\t\tattr->info.bootstrap_methods_attr.num_bootstrap_methods = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.bootstrap_methods_attr.bootstrap_methods = r_list_newf (r_bin_java_bootstrap_method_free);\n\t\tfor (i = 0; i < attr->info.bootstrap_methods_attr.num_bootstrap_methods; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbsm = r_bin_java_bootstrap_method_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (bsm) {\n\t\t\t\toffset += bsm->size;\n\t\t\t\tr_list_append (attr->info.bootstrap_methods_attr.bootstrap_methods, (void *) bsm);\n\t\t\t} else {\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 0}
{"code": "static int stellaris_enet_post_load(void *opaque, int version_id)\n{\n    stellaris_enet_state *s = opaque;\n    int i;\n    if (s->next_packet >= ARRAY_SIZE(s->rx)) {\n        return -1;\n    }\n    if (s->np > ARRAY_SIZE(s->rx)) {\n        return -1;\n    }\n    for (i = 0; i < ARRAY_SIZE(s->rx); i++) {\n        if (s->rx[i].len > ARRAY_SIZE(s->rx[i].data)) {\n            return -1;\n        }\n    }\n    if (s->rx_fifo_offset > ARRAY_SIZE(s->rx[0].data) - 4) {\n        return -1;\n    }\n    if (s->tx_fifo_len > ARRAY_SIZE(s->tx_fifo)) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "void NotificationService::RemoveObserver(NotificationObserver* observer,\n                                          NotificationType type,\n                                          const NotificationSource& source) {\n   DCHECK(type.value < NotificationType::NOTIFICATION_TYPE_COUNT);\n  CHECK(HasKey(observers_[type.value], source));\n   NotificationObserverList* observer_list =\n       observers_[type.value][source.map_key()];\n  if (observer_list) {\n    observer_list->RemoveObserver(observer);\n#ifndef NDEBUG\n    --observer_counts_[type.value];\n#endif\n  }\n}", "target": 0}
{"code": "void http_buffer_heavy_realign(struct buffer *buf, struct http_msg *msg)\n{\n\tchar *end = buf->data + buf->size;\n\tint off = buf->data + buf->size - buf->w;\n\tif (buf->l) {\n\t\tint block1 = buf->l;\n\t\tint block2 = 0;\n\t\tif (buf->r <= buf->w) {\n\t\t\tblock1 = buf->data + buf->size - buf->w;\n\t\t\tblock2 = buf->r - buf->data;\n\t\t}\n\t\tif (block2)\n\t\t\tmemcpy(swap_buffer, buf->data, block2);\n\t\tmemmove(buf->data, buf->w, block1);\n\t\tif (block2)\n\t\t\tmemcpy(buf->data + block1, swap_buffer, block2);\n\t}\n\tbuf->w    = buf->data;\n\tbuf->lr  += off; if (buf->lr  >= end) buf->lr  -= buf->size;\n\tbuf->r   += off; if (buf->r   >= end) buf->r   -= buf->size;\n\tmsg->sol += off; if (msg->sol >= end) msg->sol -= buf->size;\n\tmsg->eol += off; if (msg->eol >= end) msg->eol -= buf->size;\n\tmsg->som  = 0;\n\tmsg->eoh += off; if (msg->eoh >= buf->size) msg->eoh -= buf->size;\n\tmsg->sov += off; if (msg->sov >= buf->size) msg->sov -= buf->size;\n\tif (msg->err_pos >= 0) {\n\t\tmsg->err_pos += off;\n\t\tif (msg->err_pos >= buf->size)\n\t\t\tmsg->err_pos -= buf->size;\n\t}\n\tbuf->flags &= ~BF_FULL;\n\tif (buf->l >= buffer_max_len(buf))\n\t\tbuf->flags |= BF_FULL;\n}", "target": 0}
{"code": "static int spl_object_storage_compare_info(spl_SplObjectStorageElement *e1, spl_SplObjectStorageElement *e2 TSRMLS_DC) \n{\n\tzval result;\n\tif (compare_function(&result, e1->inf, e2->inf TSRMLS_CC) == FAILURE) {\n\t\treturn 1;\n\t}\n\treturn Z_LVAL(result);\n}", "target": 0}
{"code": "GF_Err tenc_dump(GF_Box *a, FILE * trace)\n{\n\tGF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a;\n\tif (!a) return GF_BAD_PARAM;\n\tgf_isom_box_dump_start(a, \"TrackEncryptionBox\", trace);\n\tfprintf(trace, \"isEncrypted=\\\"%d\\\"\", ptr->isProtected);\n\tif (ptr->Per_Sample_IV_Size)\n\t\tfprintf(trace, \" IV_size=\\\"%d\\\" KID=\\\"\", ptr->Per_Sample_IV_Size);\n\telse {\n\t\tfprintf(trace, \" constant_IV_size=\\\"%d\\\" constant_IV=\\\"\", ptr->constant_IV_size);\n\t\tdump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size);\n\t\tfprintf(trace, \"\\\"  KID=\\\"\");\n\t}\n\tdump_data_hex(trace, (char *) ptr->KID, 16);\n\tif (ptr->version) \n\t\tfprintf(trace, \"\\\" crypt_byte_block=\\\"%d\\\" skip_byte_block=\\\"%d\", ptr->crypt_byte_block, ptr->skip_byte_block);\n\tfprintf(trace, \"\\\">\\n\");\n\tgf_isom_box_dump_done(\"TrackEncryptionBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void finish_object(struct object *obj,\n\t\t\t  struct strbuf *path, const char *name,\n\t\t\t  void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tif (obj->type == OBJ_BLOB && !has_object_file(&obj->oid))\n\t\tdie(\"missing blob object '%s'\", oid_to_hex(&obj->oid));\n\tif (info->revs->verify_objects && !obj->parsed && obj->type != OBJ_COMMIT)\n\t\tparse_object(obj->oid.hash);\n}", "target": 1}
{"code": "delta_head_destroy(struct delta_head *delta_head)\n{\n\tif (delta_head) {\n\t\tdoc_data_cleanup(&delta_head->doc_data);\n\t\tfree(delta_head);\n\t}\n}", "target": 1}
{"code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    krb5_clear_error_message(context);\n    if (pol_dn == NULL)\n        return EINVAL;\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n    ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n    }\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}", "target": 1}
{"code": "static void sunkbd_reinit(struct work_struct *work)\n{\n\tstruct sunkbd *sunkbd = container_of(work, struct sunkbd, tq);\n\twait_event_interruptible_timeout(sunkbd->wait, sunkbd->reset >= 0, HZ);\n\tserio_write(sunkbd->serio, SUNKBD_CMD_SETLED);\n\tserio_write(sunkbd->serio,\n\t\t(!!test_bit(LED_CAPSL,   sunkbd->dev->led) << 3) |\n\t\t(!!test_bit(LED_SCROLLL, sunkbd->dev->led) << 2) |\n\t\t(!!test_bit(LED_COMPOSE, sunkbd->dev->led) << 1) |\n\t\t !!test_bit(LED_NUML,    sunkbd->dev->led));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_NOCLICK - !!test_bit(SND_CLICK, sunkbd->dev->snd));\n\tserio_write(sunkbd->serio,\n\t\tSUNKBD_CMD_BELLOFF - !!test_bit(SND_BELL, sunkbd->dev->snd));\n}", "target": 1}
{"code": "static GroupList collectGroups(const std::string &fulltext)\n{\n\tGroupList groupList; \n\tint lineNo = 1; \n\tbool inString = false; \n\tfor (unsigned int i=0; i<fulltext.length(); ++i) {\n\t\tif (fulltext[i] == '\\n') {\n\t\t\tlineNo++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (inString && fulltext.compare(i, 2, \"\\\\\\\"\") == 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (fulltext[i] == '\"') {\n\t\t\tinString = !inString;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!inString && fulltext.compare(i, 2, \"\n\t\t\ti++;\n\t\t\twhile (fulltext[i] != '\\n' && i<fulltext.length() ) i++;\n\t\t\tlineNo++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!inString && fulltext.compare(i, 2, \" every character is comment\n\t\t\twhile (fulltext.compare(i, 2, \"*/\") != 0 && i<fulltext.length()) {\n\t\t\t\tif(fulltext[i]=='\\n'){\n\t\t\t\t\tlineNo++;\n\t\t\t\t\tisGroup=false;\n\t\t\t\t}\n\t\t\t\tcomment += fulltext[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(isGroup)\n\t\t\t\tgroupList.push_back(createGroup(comment,lineNo));\n\t\t}\n\t}\n\treturn groupList;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    OP_REQUIRES(context, input.dims() == 5,\n                errors::InvalidArgument(\"input must be 5-dimensional\"));\n    OP_REQUIRES(context, filter.dims() == 5,\n                errors::InvalidArgument(\"filter must be 5-dimensional\"));\n    const int64 in_depth = GetTensorDim(input, data_format_, 'C');\n    const int64 in_batch = GetTensorDim(input, data_format_, 'N');\n    const int64 filter_depth = filter.dim_size(3);\n    const int64 out_depth = filter.dim_size(4);\n    OP_REQUIRES(context, filter_depth != 0,\n                errors::InvalidArgument(\"filter_depth must be non-zero\"));\n    OP_REQUIRES(context, in_depth % filter_depth == 0,\n                errors::InvalidArgument(\n                    \"Input depth must be evenly divisible by filter depth: \",\n                    in_depth, \" vs \", filter_depth));\n    std::array<int64, 3> input_size = {\n        {GetTensorDim(input, data_format_, '0'),\n         GetTensorDim(input, data_format_, '1'),\n         GetTensorDim(input, data_format_, '2')}};\n    std::array<int64, 3> filter_size = {\n        {filter.dim_size(0), filter.dim_size(1), filter.dim_size(2)}};\n    std::array<int64, 3> dilations = {\n        {GetTensorDim(dilation_, data_format_, '0'),\n         GetTensorDim(dilation_, data_format_, '1'),\n         GetTensorDim(dilation_, data_format_, '2')}};\n    std::array<int64, 3> strides = {{GetTensorDim(stride_, data_format_, '0'),\n                                     GetTensorDim(stride_, data_format_, '1'),\n                                     GetTensorDim(stride_, data_format_, '2')}};\n    std::array<int64, 3> out, padding;\n    OP_REQUIRES_OK(\n        context, Get3dOutputSizeV2(input_size, filter_size, dilations, strides,\n                                   padding_, &out, &padding));\n    TensorShape out_shape = ShapeFromFormat(\n        data_format_, in_batch, {{out[0], out[1], out[2]}}, out_depth);\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    if (out_shape.num_elements() == 0) return;\n    LaunchConvOp<Device, T>::launch(context, cudnn_use_autotune_, input, filter,\n                                    dilations, strides, padding_, data_format_,\n                                    output);\n  }", "target": 0}
{"code": "lyd_new(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new(parent, snode, 0);\n}", "target": 1}
{"code": "  void readStructEnd() {\n    lastFieldId_ = nestedStructFieldIds_.back();\n    nestedStructFieldIds_.pop_back();\n  }", "target": 1}
{"code": "static noinline_for_stack void scrub_workers_put(struct btrfs_fs_info *fs_info)\n{\n\tif (--fs_info->scrub_workers_refcnt == 0) {\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_wr_completion_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_parity_workers);\n\t}\n\tWARN_ON(fs_info->scrub_workers_refcnt < 0);\n}", "target": 0}
{"code": "static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 sg_table_count)\n{\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tu32 i, j, page_count = 0, sg_per_table;\n\tfor (i = 0; i < sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tkfree(sg_table);\n\treturn page_count;\n}", "target": 0}
{"code": "static long btrfs_ioctl_dev_info(struct btrfs_fs_info *fs_info,\n\t\t\t\t void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_info_args *di_args;\n\tstruct btrfs_device *dev;\n\tint ret = 0;\n\tchar *s_uuid = NULL;\n\tdi_args = memdup_user(arg, sizeof(*di_args));\n\tif (IS_ERR(di_args))\n\t\treturn PTR_ERR(di_args);\n\tif (!btrfs_is_empty_uuid(di_args->uuid))\n\t\ts_uuid = di_args->uuid;\n\trcu_read_lock();\n\tdev = btrfs_find_device(fs_info->fs_devices, di_args->devid, s_uuid,\n\t\t\t\tNULL);\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tdi_args->devid = dev->devid;\n\tdi_args->bytes_used = btrfs_device_get_bytes_used(dev);\n\tdi_args->total_bytes = btrfs_device_get_total_bytes(dev);\n\tmemcpy(di_args->uuid, dev->uuid, sizeof(di_args->uuid));\n\tif (dev->name) {\n\t\tstrncpy(di_args->path, rcu_str_deref(dev->name),\n\t\t\t\tsizeof(di_args->path) - 1);\n\t\tdi_args->path[sizeof(di_args->path) - 1] = 0;\n\t} else {\n\t\tdi_args->path[0] = '\\0';\n\t}\nout:\n\trcu_read_unlock();\n\tif (ret == 0 && copy_to_user(arg, di_args, sizeof(*di_args)))\n\t\tret = -EFAULT;\n\tkfree(di_args);\n\treturn ret;\n}", "target": 1}
{"code": "static uint8_t excluded_channels(bitfile *ld, drc_info *drc)\n{\n    uint8_t i, n = 0;\n    uint8_t num_excl_chan = 7;\n    for (i = 0; i < 7; i++)\n    {\n        drc->exclude_mask[i] = faad_get1bit(ld\n            DEBUGVAR(1,103,\"excluded_channels(): exclude_mask\"));\n    }\n    n++;\n    while ((drc->additional_excluded_chns[n-1] = faad_get1bit(ld\n        DEBUGVAR(1,104,\"excluded_channels(): additional_excluded_chns\"))) == 1)\n    {\n        if (i >= MAX_CHANNELS - num_excl_chan - 7)\n            return n;\n        for (i = num_excl_chan; i < num_excl_chan+7; i++)\n        {\n            drc->exclude_mask[i] = faad_get1bit(ld\n                DEBUGVAR(1,105,\"excluded_channels(): exclude_mask\"));\n        }\n        n++;\n        num_excl_chan += 7;\n    }\n    return n;\n}", "target": 0}
{"code": "ClearServer2Client(rfbClient* client, int messageType)\n{\n  client->supportedMessages.server2client[((messageType & 0xFF)/8)] &= (!(1<<(messageType % 8)));\n}", "target": 0}
{"code": "static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\treturn m->pos_;\n}", "target": 1}
{"code": "find_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    for (pl2 = plist; *pl2; pl2++);\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, tgs_server));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}", "target": 0}
{"code": "  explicit QuantizeAndDequantizeV2Op(OpKernelConstruction* ctx)\n      : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"axis\", &axis_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    string round_mode_string;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"round_mode\", &round_mode_string));\n    OP_REQUIRES(\n        ctx,\n        (round_mode_string == \"HALF_UP\" || round_mode_string == \"HALF_TO_EVEN\"),\n        errors::InvalidArgument(\"Round mode string must be \"\n                                \"'HALF_UP' or \"\n                                \"'HALF_TO_EVEN', is '\" +\n                                round_mode_string + \"'\"));\n    if (round_mode_string == \"HALF_UP\") {\n      round_mode_ = ROUND_HALF_UP;\n    } else if (round_mode_string == \"HALF_TO_EVEN\") {\n      round_mode_ = ROUND_HALF_TO_EVEN;\n    }\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"narrow_range\", &narrow_range_));\n  }", "target": 1}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "inline typename V::SetType FBUnserializer<V>::unserializeSet() {\n  p_ += CODE_SIZE;\n  unserializeInt64();\n  typename V::SetType ret = V::createSet();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::setAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "inline int NumDimensions(const TfLiteTensor* t) { return t->dims->size; }", "target": 1}
{"code": "static bool check_reg_sane_offset(struct bpf_verifier_env *env,\n\t\t\t\t  const struct bpf_reg_state *reg,\n\t\t\t\t  enum bpf_reg_type type)\n{\n\tbool known = tnum_is_const(reg->var_off);\n\ts64 val = reg->var_off.value;\n\ts64 smin = reg->smin_value;\n\tif (known && (val >= BPF_MAX_VAR_OFF || val <= -BPF_MAX_VAR_OFF)) {\n\t\tverbose(env, \"math between %s pointer and %lld is not allowed\\n\",\n\t\t\treg_type_str[type], val);\n\t\treturn false;\n\t}\n\tif (reg->off >= BPF_MAX_VAR_OFF || reg->off <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"%s pointer offset %d is not allowed\\n\",\n\t\t\treg_type_str[type], reg->off);\n\t\treturn false;\n\t}\n\tif (smin == S64_MIN) {\n\t\tverbose(env, \"math between %s pointer and register with unbounded min value is not allowed\\n\",\n\t\t\treg_type_str[type]);\n\t\treturn false;\n\t}\n\tif (smin >= BPF_MAX_VAR_OFF || smin <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"value %lld makes %s pointer be out of bounds\\n\",\n\t\t\tsmin, reg_type_str[type]);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "int use_conf(char *test_path)\n{\n    int ret;\n    size_t flags = 0;\n    char filename[1024], errstr[1024];\n    char *buffer;\n    FILE *infile, *conffile;\n    json_t *json;\n    json_error_t error;\n    sprintf(filename, \"%s%cinput\", test_path, dir_sep);\n    if (!(infile = fopen(filename, \"rb\"))) {\n        fprintf(stderr, \"Could not open \\\"%s\\\"\\n\", filename);\n        return 2;\n    }\n    sprintf(filename, \"%s%cenv\", test_path, dir_sep);\n    conffile = fopen(filename, \"rb\");\n    if (conffile) {\n        read_conf(conffile);\n        fclose(conffile);\n    }\n    if (conf.indent < 0 || conf.indent > 255) {\n        fprintf(stderr, \"invalid value for JSON_INDENT: %d\\n\", conf.indent);\n        return 2;\n    }\n    if (conf.indent)\n        flags |= JSON_INDENT(conf.indent);\n    if (conf.compact)\n        flags |= JSON_COMPACT;\n    if (conf.ensure_ascii)\n        flags |= JSON_ENSURE_ASCII;\n    if (conf.preserve_order)\n        flags |= JSON_PRESERVE_ORDER;\n    if (conf.sort_keys)\n        flags |= JSON_SORT_KEYS;\n    if (conf.have_hashseed)\n        json_object_seed(conf.hashseed);\n    if (conf.strip) {\n        buffer = loadfile(infile);\n        json = json_loads(strip(buffer), 0, &error);\n        free(buffer);\n    }\n    else\n        json = json_loadf(infile, 0, &error);\n    fclose(infile);\n    if (!json) {\n        sprintf(errstr, \"%d %d %d\\n%s\\n\",\n                error.line, error.column, error.position,\n                error.text);\n        ret = cmpfile(errstr, test_path, \"error\");\n        return ret;\n    }\n    buffer = json_dumps(json, flags);\n    ret = cmpfile(buffer, test_path, \"output\");\n    free(buffer);\n    json_decref(json);\n    return ret;\n}", "target": 0}
{"code": "snmp_ber_decode_null(unsigned char *buf, uint32_t *buff_len)\n{\n  buf++;\n  (*buff_len)--;\n  buf++;\n  (*buff_len)--;\n  return buf;\n}", "target": 1}
{"code": "ev_archive_get_entry_pathname (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), NULL);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, NULL);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, NULL);\n\t\treturn archive_entry_pathname (archive->libar_entry);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 1}
{"code": "static int DefragBsdPeose173Ipv4Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "void read_pcm_samples_internal(thread_context* tctx, int x0, int y0, int log2CbSize,\n                               int cIdx, bitreader& br)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n  int nPcmBits;\n  int bitDepth;\n  int w = 1<<log2CbSize;\n  int h = 1<<log2CbSize;\n  if (cIdx>0) {\n    w /= sps.SubWidthC;\n    h /= sps.SubHeightC;\n    x0 /= sps.SubWidthC;\n    y0 /= sps.SubHeightC;\n    nPcmBits = sps.pcm_sample_bit_depth_chroma;\n    bitDepth = sps.BitDepth_C;\n  }\n  else {\n    nPcmBits = sps.pcm_sample_bit_depth_luma;\n    bitDepth = sps.BitDepth_Y;\n  }\n  pixel_t* ptr;\n  int stride;\n  ptr    = tctx->img->get_image_plane_at_pos_NEW<pixel_t>(cIdx,x0,y0);\n  stride = tctx->img->get_image_stride(cIdx);\n  int shift = bitDepth - nPcmBits;\n  if (shift < 0) {\n    shift=0;\n  }\n  for (int y=0;y<h;y++)\n    for (int x=0;x<w;x++)\n      {\n        int value = get_bits(&br, nPcmBits);\n        ptr[y*stride+x] = value << shift;\n      }\n}", "target": 0}
{"code": "AnyP::UriScheme::defaultPort() const\n{\n    switch (theScheme_) {\n    case AnyP::PROTO_HTTP:\n        return 80;\n    case AnyP::PROTO_HTTPS:\n        return 443;\n    case AnyP::PROTO_FTP:\n        return 21;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS:\n        return 5683;\n    case AnyP::PROTO_GOPHER:\n        return 70;\n    case AnyP::PROTO_WAIS:\n        return 210;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return CACHE_HTTP_PORT;\n    case AnyP::PROTO_WHOIS:\n        return 43;\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "int nfc_dev_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->polling || dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_down)\n\t\tdev->ops->dev_down(dev);\n\tdev->dev_up = false;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void sas_revalidate_domain(struct work_struct *work)\n{\n\tint res = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tstruct sas_ha_struct *ha = port->ha;\n\tstruct domain_device *ddev = port->port_dev;\n\tmutex_lock(&ha->disco_mutex);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\tSAS_DPRINTK(\"REVALIDATION DEFERRED on port %d, pid:%d\\n\",\n\t\t\t    port->id, task_pid_nr(current));\n\t\tgoto out;\n\t}\n\tclear_bit(DISCE_REVALIDATE_DOMAIN, &port->disc.pending);\n\tSAS_DPRINTK(\"REVALIDATING DOMAIN on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\tif (ddev && (ddev->dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     ddev->dev_type == SAS_EDGE_EXPANDER_DEVICE))\n\t\tres = sas_ex_revalidate_domain(ddev);\n\tSAS_DPRINTK(\"done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\\n\",\n\t\t    port->id, task_pid_nr(current), res);\n out:\n\tmutex_unlock(&ha->disco_mutex);\n\tsas_destruct_devices(port);\n\tsas_destruct_ports(port);\n\tsas_probe_devices(port);\n}", "target": 0}
{"code": "static void *snd_malloc_sbus_pages(struct device *dev, size_t size,\n\t\t\t\t   dma_addr_t *dma_addr)\n{\n\tstruct sbus_dev *sdev = (struct sbus_dev *)dev;\n\tint pg;\n\tvoid *res;\n\tsnd_assert(size > 0, return NULL);\n\tsnd_assert(dma_addr != NULL, return NULL);\n\tpg = get_order(size);\n\tres = sbus_alloc_consistent(sdev, PAGE_SIZE * (1 << pg), dma_addr);\n\tif (res != NULL)\n\t\tinc_snd_pages(pg);\n\treturn res;\n}", "target": 0}
{"code": "static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma)\n{\n\tif (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS))\n\t\treturn;\n\ttlb_flush_mmu_tlbonly(tlb);\n}", "target": 1}
{"code": "static void handleOutputMode(void* data, struct wl_output* wl_output, uint32_t flags, int32_t width, int32_t height, int32_t refresh) {\n    const auto POUTPUT = (SOutput*)data;\n    POUTPUT->refreshRate = std::round(refresh / 1000.0);\n}", "target": 1}
{"code": "static inline void sctp_copy_descendant(struct sock *sk_to,\n\t\t\t\t\tconst struct sock *sk_from)\n{\n\tint ancestor_size = sizeof(struct inet_sock) +\n\t\t\t    sizeof(struct sctp_sock) -\n\t\t\t    offsetof(struct sctp_sock, auto_asconf_list);\n\tif (sk_from->sk_family == PF_INET6)\n\t\tancestor_size += sizeof(struct ipv6_pinfo);\n\t__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);\n}", "target": 0}
{"code": "void LibRaw::exp_bef(float shift, float smooth)\n{\n    if(shift>8) shift = 8;\n    if(shift<0.25) shift = 0.25;\n    if(smooth < 0.0) smooth = 0.0;\n    if(smooth > 1.0) smooth = 1.0;\n    unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));\n    if(shift <=1.0)\n        {\n            for(int i=0;i<=TBLN;i++)\n                lut[i] = (unsigned short)((float)i*shift);\n        }\n    else\n        {\n            float x1,x2,y1,y2;\n            float cstops = log(shift)/log(2.0f);\n            float room = cstops*2;\n            float roomlin = powf(2.0f,room);\n            x2 = (float)TBLN;\n            x1 = (x2+1)/roomlin-1;\n            y1 = x1*shift;\n            y2 = x2*(1+(1-smooth)*(shift-1));\n            float sq3x=powf(x1*x1*x2,1.0f/3.0f);\n            float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);\n            float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);\n            float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;\n            for(int i=0;i<=TBLN;i++)\n                {\n                    float X = (float)i;\n                    float Y = A*powf(X,1.0f/3.0f)+B*X+CC;\n                    if(i<x1)\n                        lut[i] = (unsigned short)((float)i*shift);\n                    else\n                        lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));\n                }\n        }\n    for(int i=0; i< S.height*S.width; i++)\n        {\n            imgdata.image[i][0] = lut[imgdata.image[i][0]];\n            imgdata.image[i][1] = lut[imgdata.image[i][1]];\n            imgdata.image[i][2] = lut[imgdata.image[i][2]];\n            imgdata.image[i][3] = lut[imgdata.image[i][3]];\n        }\n    C.data_maximum = lut[C.data_maximum];\n    C.maximum = lut[C.maximum];\n    free(lut);\n}", "target": 1}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  size_t * D = (size_t *) dest;\n  size_t * S = (size_t *) src;\n  size_t L = len / sizeof(size_t);\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] ^= S[i];\n}", "target": 1}
{"code": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "comics_document_thumbnails_get_thumbnail (EvDocumentThumbnails *document,\n\t\t\t\t\t  EvRenderContext      *rc,\n\t\t\t\t\t  gboolean              border)\n{\n\tGdkPixbuf *thumbnail;\n\tthumbnail = comics_document_render_pixbuf (EV_DOCUMENT (document), rc);\n\tif (border) {\n\t      GdkPixbuf *tmp_pixbuf = thumbnail;\n\t      thumbnail = ev_document_misc_get_thumbnail_frame (-1, -1, tmp_pixbuf);\n\t      g_object_unref (tmp_pixbuf);\n\t}\n\treturn thumbnail;\n}", "target": 1}
{"code": "static inline u32 dma_high(dma_addr_t addr)\n{\n\treturn upper_32_bits(addr);\n}", "target": 1}
{"code": "static EctEnhancedCT *create()\n{\n    IODEnhGeneralEquipmentModule::EquipmentInfo eq(\"Open Connections\", \"OC CT\", \"4711\", \"0.1\");\n    EctEnhancedCT *ct = NULL;\n    OFCondition result;\n    result = EctEnhancedCT::create(ct,\n                                   NUM_ROWS,\n                                   NUM_COLS,\n                                   OFFalse,\n                                   EctTypes::E_ImageType1_Original,\n                                   EctTypes::DT_ImageType3_Volume,\n                                   EctTypes::DT_ImageType4_Maximum,\n                                   \"1\" ,\n                                   EctTypes::E_ContQuali_Research,\n                                   EctTypes::E_PixelPres_Monochrome,\n                                   EctTypes::E_VolProps_Volume,\n                                   EctTypes::DT_VolBasedCalcTechnique_VolumeRender,\n                                   eq,\n                                   \"20190801120000\" ,\n                                   2.0 );\n    OFCHECK(result.good());\n    OFCHECK(ct != OFnullptr);\n    return ct;\n}", "target": 0}
{"code": "TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}", "target": 1}
{"code": "snmp_mib_find(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(!snmp_oid_cmp_oid(oid, resource->oid)) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             TfLiteDepthwiseConvParams* params, int width,\n                             int height, int filter_width, int filter_height,\n                             const TfLiteType data_type, OpData* data) {\n  bool has_bias = node->inputs->size == 3;\n  TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  int unused_output_height, unused_output_width;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      filter_height, filter_width, params->padding, &unused_output_height,\n      &unused_output_width);\n  if (data_type != kTfLiteFloat32) {\n    const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n    TF_LITE_ENSURE(context, input != nullptr);\n    const TfLiteTensor* filter = GetInput(context, node, kFilterTensor);\n    TF_LITE_ENSURE(context, filter != nullptr);\n    const TfLiteTensor* bias =\n        GetOptionalInputTensor(context, node, kBiasTensor);\n    TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n    TF_LITE_ENSURE(context, output != nullptr);\n    int num_channels = filter->dims->data[kDepthwiseConvQuantizedDimension];\n    return tflite::PopulateConvolutionQuantizationParams(\n        context, input, filter, bias, output, params->activation,\n        &data->output_multiplier, &data->output_shift,\n        &data->output_activation_min, &data->output_activation_max,\n        data->per_channel_output_multiplier,\n        reinterpret_cast<int*>(data->per_channel_output_shift), num_channels);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "int use_env()\n{\n    int indent;\n    size_t flags = 0;\n    json_t *json;\n    json_error_t error;\n    #ifdef _WIN32\n    _setmode(_fileno(stdout), _O_BINARY);\n    _setmode(_fileno(stderr), _O_BINARY);\n    #endif\n    indent = getenv_int(\"JSON_INDENT\");\n    if(indent < 0 || indent > 255) {\n        fprintf(stderr, \"invalid value for JSON_INDENT: %d\\n\", indent);\n        return 2;\n    }\n    if(indent > 0)\n        flags |= JSON_INDENT(indent);\n    if(getenv_int(\"JSON_COMPACT\") > 0)\n        flags |= JSON_COMPACT;\n    if(getenv_int(\"JSON_ENSURE_ASCII\"))\n        flags |= JSON_ENSURE_ASCII;\n    if(getenv_int(\"JSON_PRESERVE_ORDER\"))\n        flags |= JSON_PRESERVE_ORDER;\n    if(getenv_int(\"JSON_SORT_KEYS\"))\n         flags |= JSON_SORT_KEYS;\n    if(getenv_int(\"STRIP\")) {\n        size_t size = 0, used = 0;\n        char *buffer = NULL;\n        while(1) {\n            size_t count;\n            size = (size == 0 ? 128 : size * 2);\n            buffer = realloc(buffer, size);\n            if(!buffer) {\n                fprintf(stderr, \"Unable to allocate %d bytes\\n\", (int)size);\n                return 1;\n            }\n            count = fread(buffer + used, 1, size - used, stdin);\n            if(count < size - used) {\n                buffer[used + count] = '\\0';\n                break;\n            }\n            used += count;\n        }\n        json = json_loads(strip(buffer), 0, &error);\n        free(buffer);\n    }\n    else\n        json = json_loadf(stdin, 0, &error);\n    if(!json) {\n        fprintf(stderr, \"%d %d %d\\n%s\\n\",\n            error.line, error.column,\n            error.position, error.text);\n        return 1;\n    }\n    json_dumpf(json, stdout, flags);\n    json_decref(json);\n    return 0;\n}", "target": 1}
{"code": "void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "int create_history_entry(krb5_context context,\n                         krb5_keyblock *hist_key, int n_key_data,\n                         krb5_key_data *key_data, osa_pw_hist_ent *hist)\n{\n    krb5_error_code ret;\n    krb5_keyblock key;\n    krb5_keysalt salt;\n    int i;\n    hist->key_data = k5calloc(n_key_data, sizeof(krb5_key_data), &ret);\n    if (hist->key_data == NULL)\n        return ret;\n    for (i = 0; i < n_key_data; i++) {\n        ret = krb5_dbe_decrypt_key_data(context, NULL, &key_data[i], &key,\n                                        &salt);\n        if (ret)\n            return ret;\n        ret = krb5_dbe_encrypt_key_data(context, hist_key, &key, &salt,\n                                        key_data[i].key_data_kvno,\n                                        &hist->key_data[i]);\n        if (ret)\n            return ret;\n        krb5_free_keyblock_contents(context, &key);\n    }\n    hist->n_key_data = n_key_data;\n    return 0;\n}", "target": 0}
{"code": "static int update_server_from_aliases(request_rec *r)\n{\n    const char *host = r->hostname;\n    apr_port_t port;\n    server_rec *s;\n    server_rec *virthost_s;\n    server_rec *last_s;\n    name_chain *src;\n    virthost_s = NULL;\n    last_s = NULL;\n    port = r->connection->local_addr->port;\n    for (src = r->connection->vhost_lookup_data; src; src = src->next) {\n        server_addr_rec *sar;\n        sar = src->sar;\n        if (sar->host_port != 0 && port != sar->host_port) {\n            continue;\n        }\n        s = src->server;\n        if (s != last_s) {\n            if (matches_aliases(s, host)) {\n                goto found;\n            }\n        }\n        if (!strcasecmp(host, sar->virthost)) {\n            if (virthost_s == NULL) {\n                virthost_s = s;\n            }\n        }\n        last_s = s;\n    }\n    if (virthost_s) {\n        s = virthost_s;\n        goto found;\n    }\n    if (!r->connection->vhost_lookup_data) { \n        if (matches_aliases(r->server, host)) {\n            s = r->server;\n            goto found;\n        }\n    }\n    return HTTP_BAD_REQUEST;\nfound:\n    r->server = s;\n    return HTTP_OK;\n}", "target": 0}
{"code": "int packet__queue(struct mosquitto *mosq, struct mosquitto__packet *packet)\n{\n#ifndef WITH_BROKER\n\tchar sockpair_data = 0;\n#endif\n\tassert(mosq);\n\tassert(packet);\n\tpacket->pos = 0;\n\tpacket->to_process = packet->packet_length;\n\tpacket->next = NULL;\n\tpthread_mutex_lock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n\tif(mosq->out_packet_count >= db.config->max_queued_messages){\n\t\tmosquitto__free(packet);\n\t\tif(mosq->is_dropping == false){\n\t\t\tmosq->is_dropping = true;\n\t\t\tlog__printf(NULL, MOSQ_LOG_NOTICE,\n\t\t\t\t\t\"Outgoing messages are being dropped for client %s.\",\n\t\t\t\t\tmosq->id);\n\t\t}\n\t\tG_MSGS_DROPPED_INC();\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n\tif(mosq->out_packet){\n\t\tmosq->out_packet_last->next = packet;\n\t}else{\n\t\tmosq->out_packet = packet;\n\t}\n\tmosq->out_packet_last = packet;\n\tmosq->out_packet_count++;\n\tpthread_mutex_unlock(&mosq->out_packet_mutex);\n#ifdef WITH_BROKER\n#  ifdef WITH_WEBSOCKETS\n\tif(mosq->wsi){\n\t\tlws_callback_on_writable(mosq->wsi);\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}else{\n\t\treturn packet__write(mosq);\n\t}\n#  else\n\treturn packet__write(mosq);\n#  endif\n#else\n\tif(mosq->sockpairW != INVALID_SOCKET){\n#ifndef WIN32\n\t\tif(write(mosq->sockpairW, &sockpair_data, 1)){\n\t\t}\n#else\n\t\tsend(mosq->sockpairW, &sockpair_data, 1, 0);\n#endif\n\t}\n\tif(mosq->in_callback == false && mosq->threaded == mosq_ts_none){\n\t\treturn packet__write(mosq);\n\t}else{\n\t\treturn MOSQ_ERR_SUCCESS;\n\t}\n#endif\n}", "target": 0}
{"code": "static int rtnl_bridge_notify(struct net_device *dev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct sk_buff *skb;\n\tint err = -EOPNOTSUPP;\n\tif (!dev->netdev_ops->ndo_bridge_getlink)\n\t\treturn 0;\n\tskb = nlmsg_new(bridge_nlmsg_size(), GFP_ATOMIC);\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto errout;\n\t}\n\terr = dev->netdev_ops->ndo_bridge_getlink(skb, 0, 0, dev, 0, 0);\n\tif (err < 0)\n\t\tgoto errout;\n\tif (!skb->len)\n\t\tgoto errout;\n\trtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\n\treturn 0;\nerrout:\n\tWARN_ON(err == -EMSGSIZE);\n\tkfree_skb(skb);\n\tif (err)\n\t\trtnl_set_sk_err(net, RTNLGRP_LINK, err);\n\treturn err;\n}", "target": 0}
{"code": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}", "target": 1}
{"code": "pixBlockconvGrayUnnormalized(PIX     *pixs,\n                             l_int32  wc,\n                             l_int32  hc)\n{\nl_int32    i, j, w, h, d, wpla, wpld, jmax;\nl_uint32  *linemina, *linemaxa, *lined, *dataa, *datad;\nPIX       *pixsb, *pixacc, *pixd;\n    PROCNAME(\"pixBlockconvGrayUnnormalized\");\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pixs);\n    if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixsb not made\", procName, NULL);\n    pixacc = pixBlockconvAccum(pixsb);\n    pixDestroy(&pixsb);\n    if (!pixacc)\n        return (PIX *)ERROR_PTR(\"pixacc not made\", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL) {\n        pixDestroy(&pixacc);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    wpla = pixGetWpl(pixacc);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixacc);\n    for (i = 0; i < h; i++) {\n        lined = datad + i * wpld;\n        linemina = dataa + i * wpla;\n        linemaxa = dataa + (i + 2 * hc + 1) * wpla;\n        for (j = 0; j < w; j++) {\n            jmax = j + 2 * wc + 1;\n            lined[j] = linemaxa[jmax] - linemaxa[j] -\n                       linemina[jmax] + linemina[j];\n        }\n    }\n    pixDestroy(&pixacc);\n    return pixd;\n}", "target": 1}
{"code": "void TestSocketLineReader::init()\n{\n    m_packets.clear();\n    m_server = new Server(this);\n    QVERIFY2(m_server->listen(QHostAddress::LocalHost, 8694), \"Failed to create local tcp server\");\n    m_timer.setInterval(4000);\n    m_timer.setSingleShot(true);\n    connect(&m_timer, &QTimer::timeout, &m_loop, &QEventLoop::quit);\n    m_conn = new QSslSocket(this);\n    m_conn->connectToHost(QHostAddress::LocalHost, 8694);\n    connect(m_conn, &QAbstractSocket::connected, &m_loop, &QEventLoop::quit);\n    m_timer.start();\n    m_loop.exec();\n    QVERIFY2(m_conn->isOpen(), \"Could not connect to local tcp server\");\n}", "target": 0}
{"code": "static int cuse_channel_release(struct inode *inode, struct file *file)\n{\n\tstruct fuse_dev *fud = file->private_data;\n\tstruct cuse_conn *cc = fc_to_cc(fud->fc);\n\tint rc;\n\tmutex_lock(&cuse_lock);\n\tlist_del_init(&cc->list);\n\tmutex_unlock(&cuse_lock);\n\tif (cc->dev)\n\t\tdevice_unregister(cc->dev);\n\tif (cc->cdev) {\n\t\tunregister_chrdev_region(cc->cdev->dev, 1);\n\t\tcdev_del(cc->cdev);\n\t}\n\tfuse_conn_put(&cc->fc);\n\trc = fuse_dev_release(inode, file);\t\n\treturn rc;\n}", "target": 0}
{"code": "static VncBasicInfoList *qmp_query_server_entry(int socket,\n                                                bool websocket,\n                                                VncBasicInfoList *prev)\n{\n    VncBasicInfoList *list;\n    VncBasicInfo *info;\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    if (getsockname(socket, (struct sockaddr *)&sa, &salen) < 0 ||\n        getnameinfo((struct sockaddr *)&sa, salen,\n                    host, sizeof(host), serv, sizeof(serv),\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n        return prev;\n    }\n    info = g_new0(VncBasicInfo, 1);\n    info->host = g_strdup(host);\n    info->service = g_strdup(serv);\n    info->family = inet_netfamily(sa.ss_family);\n    info->websocket = websocket;\n    list = g_new0(VncBasicInfoList, 1);\n    list->value = info;\n    list->next = prev;\n    return list;\n}", "target": 0}
{"code": "TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* hash;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &hash));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input));\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n  TF_LITE_ENSURE(context, SizeOfDimension(input, 0) >= 1);\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &weight));\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;\n  }\n  return context->ResizeTensor(context, output, outputSize);\n}", "target": 0}
{"code": "rdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\t\tSecInvalidateHandle(&credssp->context);\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"Software\\\\FreeRDP\\\\Server\"),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType, NULL, &dwSize);\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\"Using SSPI Module: %s\\n\"), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn credssp;\n}", "target": 0}
{"code": "pci_set_cfgdata16(struct pci_vdev *dev, int offset, uint16_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\t*(uint16_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "TEE_Result syscall_cryp_state_copy(unsigned long dst, unsigned long src)\n{\n\tTEE_Result res;\n\tstruct tee_cryp_state *cs_dst;\n\tstruct tee_cryp_state *cs_src;\n\tstruct tee_ta_session *sess;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(dst), &cs_dst);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(src), &cs_src);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif (cs_dst->algo != cs_src->algo || cs_dst->mode != cs_src->mode)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tswitch (TEE_ALG_GET_CLASS(cs_src->algo)) {\n\tcase TEE_OPERATION_CIPHER:\n\t\tcrypto_cipher_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_AE:\n\t\tcrypto_authenc_copy_state(cs_dst->ctx, cs_src->ctx,\n\t\t\t\t\t  cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_DIGEST:\n\t\tcrypto_hash_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tcase TEE_OPERATION_MAC:\n\t\tcrypto_mac_copy_state(cs_dst->ctx, cs_src->ctx, cs_src->algo);\n\t\tbreak;\n\tdefault:\n\t\treturn TEE_ERROR_BAD_STATE;\n\t}\n\tcs_dst->state = cs_src->state;\n\treturn TEE_SUCCESS;\n}", "target": 0}
{"code": "RecordFlushAllContexts(CallbackListPtr *pcbl,\n                       void *nulldata, void *calldata)\n{\n    int eci;                    \n    RecordContextPtr pContext;\n    for (eci = 0; eci < numEnabledContexts; eci++) {\n        pContext = ppAllContexts[eci];\n        if (pContext->numBufBytes)\n            RecordFlushReplyBuffer(ppAllContexts[eci], NULL, 0, NULL, 0);\n    }\n}                               ", "target": 0}
{"code": "void AverageEvalFloat(TfLiteContext* context, TfLiteNode* node,\n                      TfLitePoolParams* params, OpData* data,\n                      const TfLiteTensor* input, TfLiteTensor* output) {\n  float activation_min, activation_max;\n  CalculateActivationRange(params->activation, &activation_min,\n                           &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                       \\\n  tflite::PoolParams op_params;                                          \\\n  op_params.stride_height = params->stride_height;                       \\\n  op_params.stride_width = params->stride_width;                         \\\n  op_params.filter_height = params->filter_height;                       \\\n  op_params.filter_width = params->filter_width;                         \\\n  op_params.padding_values.height = data->padding.height;                \\\n  op_params.padding_values.width = data->padding.width;                  \\\n  op_params.float_activation_min = activation_min;                       \\\n  op_params.float_activation_max = activation_max;                       \\\n  type::AveragePool(op_params, GetTensorShape(input),                    \\\n                    GetTensorData<float>(input), GetTensorShape(output), \\\n                    GetTensorData<float>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "comics_document_save (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\treturn ev_xfer_uri_simple (comics_document->archive, uri, error);\n}", "target": 1}
{"code": "static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)\n{\n\tstruct evtchn_fifo_control_block *control_block;\n\tunsigned long ready;\n\tunsigned q;\n\tcontrol_block = per_cpu(cpu_control_block, cpu);\n\tready = xchg(&control_block->ready, 0);\n\twhile (ready) {\n\t\tq = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES);\n\t\tconsume_one_event(cpu, control_block, q, &ready, drop);\n\t\tready |= xchg(&control_block->ready, 0);\n\t}\n}", "target": 1}
{"code": "int PackTmt::readFileHeader() {\n#define H(x) get_le16(h + 2 * (x))\n#define H4(x) get_le32(h + (x))\n    unsigned char h[0x40];\n    int ic;\n    unsigned exe_offset = 0;\n    adam_offset = 0;\n    for (ic = 0; ic < 20; ic++) {\n        fi->seek(adam_offset, SEEK_SET);\n        fi->readx(h, sizeof(h));\n        if (memcmp(h, \"MZ\", 2) == 0) \n        {\n            exe_offset = adam_offset;\n            adam_offset += H(2) * 512 + H(1);\n            if (H(1))\n                adam_offset -= 512;\n            if (H(0x18 / 2) == 0x40 && H4(0x3c))\n                adam_offset = H4(0x3c);\n        } else if (memcmp(h, \"BW\", 2) == 0)\n            adam_offset += H(2) * 512 + H(1);\n        else if (memcmp(h, \"PMW1\", 4) == 0) {\n            fi->seek(adam_offset + H4(0x18), SEEK_SET);\n            adam_offset += H4(0x24);\n            int objs = H4(0x1c);\n            while (objs--) {\n                fi->readx(h, 0x18);\n                adam_offset += H4(4);\n            }\n        } else if (memcmp(h, \"LE\", 2) == 0) {\n            unsigned offs = exe_offset + (H4(0x14) - 1) * H4(0x28) + H4(0x2c);\n            fi->seek(adam_offset + 0x80, SEEK_SET);\n            fi->readx(h, 4);\n            adam_offset = offs + H4(0);\n        } else if (memcmp(h, \"Adam\", 4) == 0)\n            break;\n        else\n            return 0;\n    }\n    if (ic == 20)\n        return 0;\n    fi->seek(adam_offset, SEEK_SET);\n    fi->readx(&ih, sizeof(ih));\n    unsigned const imagesize = ih.imagesize;\n    unsigned const entry = ih.entry;\n    unsigned const relocsize = ih.relocsize;\n    if (!imagesize || file_size <= imagesize || file_size <= entry || file_size <= relocsize) {\n        printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n                  entry, relocsize);\n        return 0;\n    }\n    return UPX_F_TMT_ADAM;\n#undef H4\n#undef H\n}", "target": 1}
{"code": "static int nft_del_setelem(struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t   const struct nlattr *attr)\n{\n\tstruct nlattr *nla[NFTA_SET_ELEM_MAX + 1];\n\tstruct nft_data_desc desc;\n\tstruct nft_set_elem elem;\n\tstruct nft_trans *trans;\n\tint err;\n\terr = nla_parse_nested(nla, NFTA_SET_ELEM_MAX, attr,\n\t\t\t       nft_set_elem_policy);\n\tif (err < 0)\n\t\tgoto err1;\n\terr = -EINVAL;\n\tif (nla[NFTA_SET_ELEM_KEY] == NULL)\n\t\tgoto err1;\n\terr = nft_data_init(ctx, &elem.key, &desc, nla[NFTA_SET_ELEM_KEY]);\n\tif (err < 0)\n\t\tgoto err1;\n\terr = -EINVAL;\n\tif (desc.type != NFT_DATA_VALUE || desc.len != set->klen)\n\t\tgoto err2;\n\terr = set->ops->get(set, &elem);\n\tif (err < 0)\n\t\tgoto err2;\n\ttrans = nft_trans_elem_alloc(ctx, NFT_MSG_DELSETELEM, set);\n\tif (trans == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err2;\n\t}\n\tnft_trans_elem(trans) = elem;\n\tlist_add_tail(&trans->list, &ctx->net->nft.commit_list);\n\treturn 0;\nerr2:\n\tnft_data_uninit(&elem.key, desc.type);\nerr1:\n\treturn err;\n}", "target": 0}
{"code": "vhost_scsi_send_evt(struct vhost_scsi *vs,\n\t\t   struct vhost_scsi_tpg *tpg,\n\t\t   struct se_lun *lun,\n\t\t   u32 event,\n\t\t   u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\tif (tpg && lun) {\n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt & 0xFF;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_work_queue(&vs->dev, &vs->vs_event_work);\n}", "target": 1}
{"code": "static void sanitize_string(char *s, char *new) {\n\tsize_t i,j, l = strlen(s), ls=l;\n\tfor(i=0,j=0;i<ls;i++) {\n\t\tif(s[i] < ' ' || s[i] > 127) {\n\t\t\tsprintf(new + j, \"\\\\x%02x\", s[i] & 0xff);\n\t\t\tj  += 3;\n\t\t} else new[j] = s[i];\n\t\tj++;\n\t}\n\tnew[j] = 0;\n}", "target": 0}
{"code": "int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)\n{\n\tstruct nfc_llcp_local *local;\n\tstruct sk_buff *skb;\n\tu8 *miux_tlv = NULL, miux_tlv_length;\n\tu8 *rw_tlv = NULL, rw_tlv_length, rw;\n\tint err;\n\tu16 size = 0;\n\t__be16 miux;\n\tpr_debug(\"Sending CC\\n\");\n\tlocal = sock->local;\n\tif (local == NULL)\n\t\treturn -ENODEV;\n\tmiux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?\n\t\tlocal->miux : sock->miux;\n\trw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,\n\t\t\t\t      &miux_tlv_length);\n\tif (!miux_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += miux_tlv_length;\n\trw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);\n\tif (!rw_tlv) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tsize += rw_tlv_length;\n\tskb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);\n\tif (skb == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto error_tlv;\n\t}\n\tllcp_add_tlv(skb, miux_tlv, miux_tlv_length);\n\tllcp_add_tlv(skb, rw_tlv, rw_tlv_length);\n\tskb_queue_tail(&local->tx_queue, skb);\n\terr = 0;\nerror_tlv:\n\tif (err)\n\t\tpr_err(\"error %d\\n\", err);\n\tkfree(miux_tlv);\n\tkfree(rw_tlv);\n\treturn err;\n}", "target": 0}
{"code": "void dev_load(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(net, name);\n\trcu_read_unlock();\n\tif (!dev && capable(CAP_NET_ADMIN))\n\t\trequest_module(\"%s\", name);\n}", "target": 1}
{"code": "static ssize_t nr_hugepages_show_common(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long nr_huge_pages;\n\tint nid;\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tnr_huge_pages = h->nr_huge_pages;\n\telse\n\t\tnr_huge_pages = h->nr_huge_pages_node[nid];\n\treturn sysfs_emit(buf, \"%lu\\n\", nr_huge_pages);\n}", "target": 0}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}", "target": 1}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context, const TfLiteTensor* params,\n                          const TfLiteTensor* indices, TfLiteTensor* output) {\n  bool indices_has_only_positive_elements = true;\n  const auto* indices_values = GetTensorData<IndicesT>(indices);\n  const size_t num_indices = indices->bytes / sizeof(IndicesT);\n  for (size_t i = 0; i < num_indices; i++) {\n    if (indices_values[i] < 0) {\n      indices_has_only_positive_elements = false;\n      break;\n    }\n  }\n  TF_LITE_ENSURE(context, indices_has_only_positive_elements);\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n    case kTfLiteUInt8:\n      return GatherNd<uint8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n    case kTfLiteInt16:\n      return GatherNd<int16_t, IndicesT>(params, indices, output);\n    case kTfLiteInt32:\n      return GatherNd<int32_t, IndicesT>(params, indices, output);\n    case kTfLiteInt64:\n      return GatherNd<int64_t, IndicesT>(params, indices, output);\n    case kTfLiteString:\n      return GatherNdString<IndicesT>(params, indices, output);\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Params type '%s' are not supported by gather_nd.\",\n                         TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "struct blk_mq_tags *blk_mq_init_tags(unsigned int total_tags,\n\t\t\t\t     unsigned int reserved_tags,\n\t\t\t\t     int node, int alloc_policy)\n{\n\tstruct blk_mq_tags *tags;\n\tif (total_tags > BLK_MQ_TAG_MAX) {\n\t\tpr_err(\"blk-mq: tag depth too large\\n\");\n\t\treturn NULL;\n\t}\n\ttags = kzalloc_node(sizeof(*tags), GFP_KERNEL, node);\n\tif (!tags)\n\t\treturn NULL;\n\tif (!zalloc_cpumask_var(&tags->cpumask, GFP_KERNEL)) {\n\t\tkfree(tags);\n\t\treturn NULL;\n\t}\n\ttags->nr_tags = total_tags;\n\ttags->nr_reserved_tags = reserved_tags;\n\treturn blk_mq_init_bitmap_tags(tags, node, alloc_policy);\n}", "target": 0}
{"code": "void AsfVideo::decodeHeader() {\n  DataBuf nbHeadersBuf(DWORD + 1);\n  io_->read(nbHeadersBuf.data(), DWORD);\n  uint32_t nb_headers = Exiv2::getULong(nbHeadersBuf.data(), littleEndian);\n  Internal::enforce(nb_headers < std::numeric_limits<uint32_t>::max(), Exiv2::ErrorCode::kerCorruptedMetadata);\n  io_->seekOrThrow(io_->tell() + BYTE * 2, BasicIo::beg,\n                   ErrorCode::kerFailedToReadImageData);  \n  for (uint32_t i = 0; i < nb_headers; i++) {\n    decodeBlock();\n  }\n}", "target": 1}
{"code": "    const char* ExifThumbC::extension() const\n    {\n        Thumbnail::UniquePtr thumbnail = Thumbnail::create(exifData_);\n        if (thumbnail.get() == 0) return \"\";\n        return thumbnail->extension();\n    }", "target": 0}
{"code": "bgp_capability_mp_data (struct stream *s, struct capability_mp_data *mpc)\n{\n  mpc->afi = stream_getw (s);\n  mpc->reserved = stream_getc (s);\n  mpc->safi = stream_getc (s);\n}", "target": 0}
{"code": "int av_reallocp_array(void *ptr, size_t nmemb, size_t size)\n{\n    void **ptrptr = ptr;\n    *ptrptr = av_realloc_f(*ptrptr, nmemb, size);\n    if (!*ptrptr && !(nmemb && size))\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 1}
{"code": "static void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}", "target": 1}
{"code": "void SSH_init(PTInstVar pvar)\n{\n\tint i;\n\tbuf_create(&pvar->ssh_state.outbuf, &pvar->ssh_state.outbuflen);\n\tbuf_create(&pvar->ssh_state.precompress_outbuf,\n\t           &pvar->ssh_state.precompress_outbuflen);\n\tbuf_create(&pvar->ssh_state.postdecompress_inbuf,\n\t           &pvar->ssh_state.postdecompress_inbuflen);\n\tpvar->ssh_state.payload = NULL;\n\tpvar->ssh_state.compressing = FALSE;\n\tpvar->ssh_state.decompressing = FALSE;\n\tpvar->ssh_state.status_flags =\n\t\tSTATUS_DONT_SEND_USER_NAME | STATUS_DONT_SEND_CREDENTIALS;\n\tpvar->ssh_state.payload_datalen = 0;\n\tpvar->ssh_state.hostname = NULL;\n\tpvar->ssh_state.server_ID = NULL;\n\tpvar->ssh_state.receiver_sequence_number = 0;\n\tpvar->ssh_state.sender_sequence_number = 0;\n\tfor (i = 0; i < NUM_ELEM(pvar->ssh_state.packet_handlers); i++) {\n\t\tpvar->ssh_state.packet_handlers[i] = NULL;\n\t}\n\tmemset(pvar->ssh2_keys, 0, sizeof(pvar->ssh2_keys));\n\tpvar->userauth_success = 0;\n\tpvar->shell_id = SSH_CHANNEL_INVALID;\n\tpvar->session_nego_status = 0;\n\tpvar->settings.ssh_protocol_version = 2;  \n\tpvar->kex_status = 0;\n\tpvar->ssh2_autologin = 0;  \n\tpvar->ask4passwd = 0; \n\tpvar->userauth_retry_count = 0;\n\tpvar->decomp_buffer = NULL;\n\tpvar->authbanner_buffer = NULL;\n\tpvar->ssh2_authlist = NULL; \n\tpvar->tryed_ssh2_authlist = FALSE;\n\tpvar->agentfwd_enable = FALSE;\n\tpvar->use_subsystem = FALSE;\n\tpvar->nosession = FALSE;\n\tpvar->server_sig_algs = NULL;\n\tpvar->server_strict_kex = FALSE;\n}", "target": 0}
{"code": "static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n\t    tu->last_resolution != resolution) {\n\t\tmemset(&r1, 0, sizeof(r1));\n\t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n\t\tr1.tstamp = tstamp;\n\t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 0}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tif (le16_to_cpu(vs_param_set->header.len) >\n\t\t\t\tMWIFIEX_MAX_VSIE_LEN) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Invalid param length!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 0}
{"code": "ut64 MACH0_(get_baddr)(struct MACH0_(obj_t)* bin) {\n\tint i;\n\tif (bin->hdr.filetype != MH_EXECUTE && bin->hdr.filetype != MH_DYLINKER)\n\t\treturn 0;\n\tfor (i = 0; i < bin->nsegs; ++i)\n\t\tif (bin->segs[i].fileoff == 0 && bin->segs[i].filesize != 0)\n\t\t\treturn bin->segs[i].vmaddr;\n\treturn 0;\n}", "target": 1}
{"code": "static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inI2outR2_tail(pcrc, r);\n\tif ( e > STF_FAIL) {\n\t\tint v2_notify_num = e - STF_FAIL;\n\t\tDBG_log(\n\t\t\t\"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\",\n\t\t\tenum_name(&ikev2_notify_names, v2_notify_num));\n\t} else if ( e != STF_OK) {\n\t\tDBG_log(\"ikev2_parent_inI2outR2_tail returned %s\",\n\t\t\tenum_name(&stfstatus_name, e));\n\t}\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "kg_unseal(minor_status, context_handle, input_token_buffer,\n          message_buffer, conf_state, qop_state, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t input_token_buffer;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    ptr = (unsigned char *) input_token_buffer->value;\n    err = g_verify_token_header(ctx->mech_used,\n                                &bodysize, &ptr, -1,\n                                input_token_buffer->length,\n                                vfyflags);\n    if (err) {\n        *minor_status = err;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n    toktype2 = load_16_be(ptr);\n    ptr += 2;\n    bodysize -= 2;\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        ret = gss_krb5int_unseal_token_v3(&ctx->k5_context, minor_status, ctx,\n                                          ptr, bodysize, message_buffer,\n                                          conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        ret = kg_unseal_v1(ctx->k5_context, minor_status, ctx, ptr, bodysize,\n                           message_buffer, conf_state, qop_state,\n                           toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        ret = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n    if (ret != 0)\n        save_error_info (*minor_status, ctx->k5_context);\n    return ret;\n}", "target": 1}
{"code": "static bool set_reg_profile(RAnal *anal) {\n\tconst char *p = \\\n\t\t\"=PC\tpc\\n\"\n\t\t\"=SP\tsp\\n\"\n\t\t\"=SN\tr0\\n\"\n\t\t\"=A0\tr12\\n\"\n\t\t\"=A1\tr13\\n\"\n\t\t\"=A2\tr14\\n\"\n\t\t\"=A3\tr15\\n\"\n\t\t\"gpr\tr0\t.16 0   0\\n\"\n\t\t\"gpr\tr1\t.16 2   0\\n\"\n\t\t\"gpr\tr2\t.16 4   0\\n\"\n\t\t\"gpr\tr3\t.16 6   0\\n\"\n\t\t\"gpr\tr4\t.16 8   0\\n\"\n\t\t\"gpr\tr5\t.16 10  0\\n\"\n\t\t\"gpr\tr6\t.16 12  0\\n\"\n\t\t\"gpr\tr7\t.16 14  0\\n\"\n\t\t\"gpr\tr8\t.16 16  0\\n\"\n\t\t\"gpr\tr9\t.16 18  0\\n\"\n\t\t\"gpr\tr10   .16 20  0\\n\"\n\t\t\"gpr\tr11   .16 22  0\\n\"\n\t\t\"gpr\tr12   .16 24  0\\n\"\n\t\t\"gpr\tr13   .16 26  0\\n\"\n\t\t\"gpr\tr14   .16 28  0\\n\"\n\t\t\"gpr\tr15   .16 30  0\\n\"\n\t\t\"gpr\tpc\t.16 0 0\\n\" \n\t\t\"gpr\tsp\t.16 2 0\\n\" \n\t\t\"flg\tsr\t.16 4 0\\n\" \n\t\t\"flg\tc\t.1  4 0\\n\"\n\t\t\"flg\tz\t.1  4.1 0\\n\"\n\t\t\"flg\tn\t.1  4.2 0\\n\"\n\t\t\"flg\tv\t.1  4.8 0\\n\";\n\treturn r_reg_set_profile_string (anal->reg, p);\n}", "target": 0}
{"code": "void pushGenericCommand(client *c, int where) {\n    int j, pushed = 0;\n    for (j = 2; j < c->argc; j++) {\n        if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {\n            addReplyError(c, \"Element too large\");\n            return;\n        }\n    }\n    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);\n    if (lobj && lobj->type != OBJ_LIST) {\n        addReply(c,shared.wrongtypeerr);\n        return;\n    }\n    for (j = 2; j < c->argc; j++) {\n        if (!lobj) {\n            lobj = createQuicklistObject();\n            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,\n                                server.list_compress_depth);\n            dbAdd(c->db,c->argv[1],lobj);\n        }\n        listTypePush(lobj,c->argv[j],where);\n        pushed++;\n    }\n    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));\n    if (pushed) {\n        char *event = (where == LIST_HEAD) ? \"lpush\" : \"rpush\";\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);\n    }\n    server.dirty += pushed;\n}", "target": 0}
{"code": "reverseSamplesBytes (uint16 spp, uint16 bps, uint32 width, \n                     uint8 *src, uint8 *dst)\n  {\n  int i;\n  uint32  col, bytes_per_pixel, col_offset;\n  uint8   bytebuff1;\n  unsigned char swapbuff[32];\n  if ((src == NULL) || (dst == NULL))\n    {\n    TIFFError(\"reverseSamplesBytes\",\"Invalid input or output buffer\");\n    return (1);\n    }\n  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n  if( bytes_per_pixel > sizeof(swapbuff) )\n  {\n    TIFFError(\"reverseSamplesBytes\",\"bytes_per_pixel too large\");\n    return (1);\n  }\n  switch (bps / 8)\n     {\n     case 8:  \n     case 4:\n     case 3:\n     case 2: for (col = 0; col < (width / 2); col++)\n               {\n\t       col_offset = col * bytes_per_pixel;                     \n\t       _TIFFmemcpy (swapbuff, src + col_offset, bytes_per_pixel);\n\t       _TIFFmemcpy (src + col_offset, dst - col_offset - bytes_per_pixel, bytes_per_pixel);\n\t       _TIFFmemcpy (dst - col_offset - bytes_per_pixel, swapbuff, bytes_per_pixel);\n               }\n\t     break;\n     case 1: \n             for (col = 0; col < (width / 2); col++)\n               { \n\t       for (i = 0; i < spp; i++)\n                  {\n\t\t  bytebuff1 = *src;\n\t\t  *src++ = *(dst - spp + i);\n                  *(dst - spp + i) = bytebuff1;\n\t\t  }\n\t\tdst -= spp;\n                }\n\t     break;\n     default: TIFFError(\"reverseSamplesBytes\",\"Unsupported bit depth %d\", bps);\n       return (1);\n     }\n  return (0);\n  } ", "target": 0}
{"code": "static int bn2cf(const BIGNUM *num, u8 *buf)\n{\n\tu8 tmp[512];\n\tint r;\n\tr = BN_bn2bin(num, tmp);\n\tif (r <= 0)\n\t\treturn r;\n\tinvert_buf(buf, tmp, r);\n\treturn r;\n}", "target": 0}
{"code": "merge_agg_lats_step (class ipcp_param_lattices *dest_plats,\n\t\t     HOST_WIDE_INT offset, HOST_WIDE_INT val_size,\n\t\t     struct ipcp_agg_lattice ***aglat,\n\t\t     bool pre_existing, bool *change)\n{\n  gcc_checking_assert (offset >= 0);\n  while (**aglat && (**aglat)->offset < offset)\n    {\n      if ((**aglat)->offset + (**aglat)->size > offset)\n\t{\n\t  set_agg_lats_to_bottom (dest_plats);\n\t  return false;\n\t}\n      *change |= (**aglat)->set_contains_variable ();\n      *aglat = &(**aglat)->next;\n    }\n  if (**aglat && (**aglat)->offset == offset)\n    {\n      if ((**aglat)->size != val_size)\n\t{\n\t  set_agg_lats_to_bottom (dest_plats);\n\t  return false;\n\t}\n      gcc_assert (!(**aglat)->next\n\t\t  || (**aglat)->next->offset >= offset + val_size);\n      return true;\n    }\n  else\n    {\n      struct ipcp_agg_lattice *new_al;\n      if (**aglat && (**aglat)->offset < offset + val_size)\n\t{\n\t  set_agg_lats_to_bottom (dest_plats);\n\t  return false;\n\t}\n      if (dest_plats->aggs_count == param_ipa_max_agg_items)\n\treturn false;\n      dest_plats->aggs_count++;\n      new_al = ipcp_agg_lattice_pool.allocate ();\n      memset (new_al, 0, sizeof (*new_al));\n      new_al->offset = offset;\n      new_al->size = val_size;\n      new_al->contains_variable = pre_existing;\n      new_al->next = **aglat;\n      **aglat = new_al;\n      return true;\n    }\n}", "target": 0}
{"code": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    qemu_vfree(r->iov.iov_base);\n}", "target": 1}
{"code": "static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags)\n{\n\tstruct mem_cgroup *memcg;\n\tstruct page *page;\n\tspinlock_t *ptl;\n\tpte_t entry;\n\tpte_unmap(page_table);\n\tif (vma->vm_flags & VM_SHARED)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (check_stack_guard_page(vma, address) < 0)\n\t\treturn VM_FAULT_SIGSEGV;\n\tif (!(flags & FAULT_FLAG_WRITE) && !mm_forbids_zeropage(mm)) {\n\t\tentry = pte_mkspecial(pfn_pte(my_zero_pfn(address),\n\t\t\t\t\t\tvma->vm_page_prot));\n\t\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\t\tif (!pte_none(*page_table))\n\t\t\tgoto unlock;\n\t\tgoto setpte;\n\t}\n\tif (unlikely(anon_vma_prepare(vma)))\n\t\tgoto oom;\n\tpage = alloc_zeroed_user_highpage_movable(vma, address);\n\tif (!page)\n\t\tgoto oom;\n\tif (mem_cgroup_try_charge(page, mm, GFP_KERNEL, &memcg))\n\t\tgoto oom_free_page;\n\t__SetPageUptodate(page);\n\tentry = mk_pte(page, vma->vm_page_prot);\n\tif (vma->vm_flags & VM_WRITE)\n\t\tentry = pte_mkwrite(pte_mkdirty(entry));\n\tpage_table = pte_offset_map_lock(mm, pmd, address, &ptl);\n\tif (!pte_none(*page_table))\n\t\tgoto release;\n\tinc_mm_counter_fast(mm, MM_ANONPAGES);\n\tpage_add_new_anon_rmap(page, vma, address);\n\tmem_cgroup_commit_charge(page, memcg, false);\n\tlru_cache_add_active_or_unevictable(page, vma);\nsetpte:\n\tset_pte_at(mm, address, page_table, entry);\n\tupdate_mmu_cache(vma, address, page_table);\nunlock:\n\tpte_unmap_unlock(page_table, ptl);\n\treturn 0;\nrelease:\n\tmem_cgroup_cancel_charge(page, memcg);\n\tpage_cache_release(page);\n\tgoto unlock;\noom_free_page:\n\tpage_cache_release(page);\noom:\n\treturn VM_FAULT_OOM;\n}", "target": 0}
{"code": "int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_head = quicklist->head;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {\n        quicklist->head->zl =\n            ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(quicklist->head);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);\n    }\n    quicklist->count++;\n    quicklist->head->count++;\n    return (orig_head != quicklist->head);\n}", "target": 0}
{"code": "envoy::config::cluster::v3::Cluster ConfigHelper::buildH1ClusterWithHighCircuitBreakersLimits(\n    const std::string& name, int port, const std::string& address, const std::string& lb_policy) {\n  return TestUtility::parseYaml<envoy::config::cluster::v3::Cluster>(\n      fmt::format(R\"EOF(\n      name: {}\n      connect_timeout: 50s\n      type: STATIC\n      circuit_breakers:\n        thresholds:\n        - priority: DEFAULT\n          max_connections: 10000\n          max_pending_requests: 10000\n          max_requests: 10000\n          max_retries: 10000\n      load_assignment:\n        cluster_name: {}\n        endpoints:\n        - lb_endpoints:\n          - endpoint:\n              address:\n                socket_address:\n                  address: {}\n                  port_value: {}\n      lb_policy: {}\n    )EOF\",\n                  name, name, address, port, lb_policy));\n}", "target": 0}
{"code": "static const char *virtualhost_section(cmd_parms *cmd, void *dummy,\n                                       const char *arg)\n{\n    server_rec *main_server = cmd->server, *s;\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    apr_pool_t *p = cmd->pool;\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n    if (main_server->is_virtual) {\n        return \"<VirtualHost> doesn't nest!\";\n    }\n    errmsg = ap_init_virtual_host(p, arg, main_server, &s);\n    if (errmsg) {\n        return errmsg;\n    }\n    s->next = main_server->next;\n    main_server->next = s;\n    s->defn_name = cmd->directive->filename;\n    s->defn_line_number = cmd->directive->line_num;\n    cmd->server = s;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd,\n                            s->lookup_defaults);\n    cmd->server = main_server;\n    return errmsg;\n}", "target": 0}
{"code": "static void lsr_read_extend_class(GF_LASeRCodec *lsr, char **out_data, u32 *out_len, const char *name)\n{\n\tu32 len;\n\tGF_LSR_READ_INT(lsr, len, lsr->info->cfg.extensionIDBits, \"reserved\");\n\tlen = lsr_read_vluimsbf5(lsr, \"len\");\n\tgf_bs_read_long_int(lsr->bs, len);\n\tif (out_data) *out_data = NULL;\n\tif (out_len) *out_len = 0;\n}", "target": 1}
{"code": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\t\tgoto out;\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tif (un) {\n\t\tkfree(new);\n\t\tgoto success;\n\t}\n\tnew->semadj = (short *) &new[1];\n\tnew->ulp = ulp;\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}", "target": 1}
{"code": "int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,\n\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct inet6_dev *idev = ctl->extra1;\n\tint min_mtu = IPV6_MIN_MTU;\n\tstruct ctl_table lctl;\n\tlctl = *ctl;\n\tlctl.extra1 = &min_mtu;\n\tlctl.extra2 = idev ? &idev->dev->mtu : NULL;\n\treturn proc_dointvec_minmax(&lctl, write, buffer, lenp, ppos);\n}", "target": 0}
{"code": "static ssize_t ocfs2_direct_IO(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tget_block_t *get_block;\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}", "target": 1}
{"code": "std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type) {\n  std::vector<std::string> subject_alt_names;\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(&cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return subject_alt_names;\n  }\n  for (const GENERAL_NAME* san : san_names.get()) {\n    if (san->type == type) {\n      subject_alt_names.push_back(generalNameAsString(san));\n    }\n  }\n  return subject_alt_names;\n}", "target": 1}
{"code": "static void ssl_reset_sock_state(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    if (ossock->ossl_ssl) {\n\tSSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, NULL);\n    }\n    if (ossock->ossl_ssl && SSL_in_init(ossock->ossl_ssl) == 0) {\n\tint ret = SSL_shutdown(ossock->ossl_ssl);\n\tif (ret == 0) {\n\t    flush_circ_buf_output(ssock, &ssock->shutdown_op_key, 0, 0);\n\t}\n    }\n    pj_lock_acquire(ssock->write_mutex);\n    ssock->ssl_state = SSL_STATE_NULL;\n    pj_lock_release(ssock->write_mutex);\n    ssl_close_sockets(ssock);\n    ERR_clear_error();\n}", "target": 0}
{"code": "static void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\tif (tsk != current)\n\t\treturn;\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}", "target": 1}
{"code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  int pos = 0;\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n  for(int i = 0; i < commentFields; i++) {\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    int commentSeparatorPosition = comment.find(\"=\");\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n    addField(key, value, false);\n  }\n}", "target": 1}
{"code": "char *strdup(const char *s1)\n{\n\tchar *s2 = 0;\n\tif (s1) {\n\t\ts2 = malloc(strlen(s1) + 1);\n\t\tstrcpy(s2, s1);\n\t}\n\treturn s2;\n}", "target": 1}
{"code": "static inline void tss_invalidate_io_bitmap(struct tss_struct *tss)\n{\n\ttss->x86_tss.io_bitmap_base = IO_BITMAP_OFFSET_INVALID;\n}", "target": 1}
{"code": "int snd_ctl_create(struct snd_card *card)\n{\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_ctl_dev_free,\n\t\t.dev_register =\tsnd_ctl_dev_register,\n\t\t.dev_disconnect = snd_ctl_dev_disconnect,\n\t};\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\treturn snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);\n}", "target": 0}
{"code": "hb_set_subtract (hb_set_t       *set,\n\t\t const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->subtract (*other);\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_escape_identifier)\n{\n\tphp_pgsql_escape_internal(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}", "target": 0}
{"code": "externalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; \n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif \n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}", "target": 1}
{"code": "static bool is_allowed_security_type(const struct nvnc* server, uint8_t type)\n{\n\tfor (int i = 0; i < server->n_security_types; ++i) {\n\t\tif ((uint8_t)server->security_types[i] == type) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    int64 signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }", "target": 0}
{"code": "static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_namelen != 0) {\n\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\tskb_free_datagram(sk, skb);\n\terr = copied;\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "GC_API void * GC_CALL GC_generic_malloc(size_t lb, int k)\n{\n    void * result;\n    DCL_LOCK_STATE;\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    if (SMALL_OBJ(lb)) {\n        LOCK();\n        result = GC_generic_malloc_inner((word)lb, k);\n        UNLOCK();\n    } else {\n        size_t lg;\n        size_t lb_rounded;\n        word n_blocks;\n        GC_bool init;\n        lg = ROUNDED_UP_GRANULES(lb);\n        lb_rounded = GRANULES_TO_BYTES(lg);\n        if (lb_rounded < lb)\n            return((*GC_get_oom_fn())(lb));\n        n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n        init = GC_obj_kinds[k].ok_init;\n        LOCK();\n        result = (ptr_t)GC_alloc_large(lb_rounded, k, 0);\n        if (0 != result) {\n          if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n          } else {\n#           ifdef THREADS\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n          }\n        }\n        GC_bytes_allocd += lb_rounded;\n        UNLOCK();\n        if (init && !GC_debugging_started && 0 != result) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n    }\n    if (0 == result) {\n        return((*GC_get_oom_fn())(lb));\n    } else {\n        return(result);\n    }\n}", "target": 0}
{"code": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 1);\n}", "target": 1}
{"code": "static void pcrypt_free(struct crypto_instance *inst)\n{\n\tstruct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);\n\tcrypto_drop_aead(&ctx->spawn);\n\tkfree(inst);\n}", "target": 1}
{"code": "void Statement::GetRow(Row* row, sqlite3_stmt* stmt) {\n    int rows = sqlite3_column_count(stmt);\n    for (int i = 0; i < rows; i++) {\n        int type = sqlite3_column_type(stmt, i);\n        const char* name = sqlite3_column_name(stmt, i);\n        switch (type) {\n            case SQLITE_INTEGER: {\n                row->push_back(new Values::Integer(name, sqlite3_column_int64(stmt, i)));\n            }   break;\n            case SQLITE_FLOAT: {\n                row->push_back(new Values::Float(name, sqlite3_column_double(stmt, i)));\n            }   break;\n            case SQLITE_TEXT: {\n                const char* text = (const char*)sqlite3_column_text(stmt, i);\n                int length = sqlite3_column_bytes(stmt, i);\n                row->push_back(new Values::Text(name, length, text));\n            } break;\n            case SQLITE_BLOB: {\n                const void* blob = sqlite3_column_blob(stmt, i);\n                int length = sqlite3_column_bytes(stmt, i);\n                row->push_back(new Values::Blob(name, length, blob));\n            }   break;\n            case SQLITE_NULL: {\n                row->push_back(new Values::Null(name));\n            }   break;\n            default:\n                assert(false);\n        }\n    }\n}", "target": 0}
{"code": "xmalloc (size_t size)\n{\n    void *ptr = malloc (size);\n    if (!ptr \n        && (size != 0))         \n    {\n        perror (\"xmalloc: Memory allocation failure\");\n        abort();\n    }\n    return ptr;\n}", "target": 1}
{"code": "TfLiteStatus Subgraph::CheckInputAndOutputForOverlap(const int* input_indices,\n                                                     int num_inputs,\n                                                     const int* output_indices,\n                                                     int num_outputs) {\n  for (int i = 0; i < num_inputs; i++) {\n    for (int j = 0; j < num_outputs; j++) {\n      if (input_indices[i] == output_indices[j]) {\n        ReportError(\"Tensor %d is both input %d and output %d\\n\",\n                    input_indices[i], i, j);\n        consistent_ = false;\n        return kTfLiteError;\n      }\n    }\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "    bool Image::isShortType(uint16_t type) {\n         return type == Exiv2::unsignedShort\n             || type == Exiv2::signedShort\n             ;\n    }", "target": 0}
{"code": "user_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member *m)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name,\n\t\tdef_netgroup_tuple ? lhost : NULL,\n\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase USERGROUP:\n\t    if (usergr_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n\t\tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (userpw_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\t\tdisconnect = !(((how & UMOUNT_CONNECTED) &&\n\t\t\t\tmnt_has_parent(p) &&\n\t\t\t\t(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||\n\t\t\t       IS_MNT_LOCKED_AND_LAZY(p));\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}", "target": 0}
{"code": "static inline void assign_eip_near(struct x86_emulate_ctxt *ctxt, ulong dst)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n}", "target": 1}
{"code": "lookup_bytestring(netdissect_options *ndo, register const u_char *bs,\n\t\t  const unsigned int nlen)\n{\n\tstruct enamemem *tp;\n\tregister u_int i, j, k;\n\tif (nlen >= 6) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = (bs[4] << 8) | bs[5];\n\t} else if (nlen >= 4) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = 0;\n\t} else\n\t\ti = j = k = 0;\n\ttp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k &&\n\t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)\n\t\t\treturn tp;\n\t\telse\n\t\t\ttp = tp->e_nxt;\n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n\ttp->e_bs = (u_char *) calloc(1, nlen + 1);\n\tif (tp->e_bs == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\tmemcpy(tp->e_bs, bs, nlen);\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\treturn tp;\n}", "target": 1}
{"code": "gss_unwrap_iov (minor_status,\n                context_handle,\n                conf_state,\n                qop_state,\n                iov,\n                iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint *\t\t\tconf_state;\ngss_qop_t\t\t*qop_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_unwrap_iov_args(minor_status, context_handle,\n\t\t\t\t conf_state, qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_unwrap_iov) {\n\t    status = mech->gss_unwrap_iov(\n\t\t\t\t \t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  conf_state,\n\t\t\t\t\t  qop_state,\n\t\t\t\t\t  iov,\n\t\t\t\t\t  iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "void ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tStream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));\n\tStream_Write_UINT32(s, header->MessageType);\n}", "target": 1}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "ecma_op_function_call_constructor (vm_frame_ctx_shared_args_t *shared_args_p, \n                                   ecma_object_t *scope_p, \n                                   ecma_value_t this_binding) \n{\n  ECMA_CHECK_STACK_USAGE ();\n  shared_args_p->header.status_flags |= VM_FRAME_CTX_SHARED_NON_ARROW_FUNC;\n  ecma_value_t ret_value;\n  if (JERRY_CONTEXT (current_new_target_p) == NULL)\n  {\n    ret_value = ecma_raise_type_error (ECMA_ERR_CLASS_CONSTRUCTOR_REQUIRES_NEW);\n    goto exit;\n  }\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) shared_args_p->header.function_object_p;\n  if (ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp))\n  {\n    this_binding = ECMA_VALUE_UNINITIALIZED;\n  }\n  ecma_op_create_environment_record (scope_p, this_binding, shared_args_p->header.function_object_p);\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) = ecma_op_function_get_realm (shared_args_p->header.bytecode_header_p);\n#endif \n  ret_value = vm_run (&shared_args_p->header, this_binding, scope_p);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  if (JERRY_UNLIKELY (this_binding == ECMA_VALUE_UNINITIALIZED))\n  {\n    if (!ECMA_IS_VALUE_ERROR (ret_value) && !ecma_is_value_object (ret_value))\n    {\n      if (!ecma_is_value_undefined (ret_value))\n      {\n        ecma_free_value (ret_value);\n        ret_value = ecma_raise_type_error (ECMA_ERR_DERIVED_CTOR_RETURN_NOR_OBJECT_OR_UNDEFINED);\n      }\n      else\n      {\n        ret_value = ecma_op_get_this_binding (scope_p);\n      }\n    }\n  }\nexit:\n  if (JERRY_UNLIKELY (shared_args_p->header.status_flags & VM_FRAME_CTX_SHARED_FREE_LOCAL_ENV))\n  {\n    ecma_deref_object (scope_p);\n  }\n  return ret_value;\n} ", "target": 0}
{"code": "static void queue_delete(struct snd_seq_queue *q)\n{\n\tmutex_lock(&q->timer_mutex);\n\tsnd_seq_timer_stop(q->timer);\n\tsnd_seq_timer_close(q);\n\tmutex_unlock(&q->timer_mutex);\n\tsnd_use_lock_sync(&q->use_lock);\n\tsnd_seq_prioq_delete(&q->tickq);\n\tsnd_seq_prioq_delete(&q->timeq);\n\tsnd_seq_timer_delete(&q->timer);\n\tkfree(q);\n}", "target": 0}
{"code": "static void compact(VarEnv* v, Array &ret, const Variant& var) {\n  if (var.isArray()) {\n    for (ArrayIter iter(var.getArrayData()); iter; ++iter) {\n      compact(v, ret, iter.second());\n    }\n  } else {\n    String varname = var.toString();\n    if (!varname.empty() && v->lookup(varname.get()) != NULL) {\n      ret.set(varname, *reinterpret_cast<Variant*>(v->lookup(varname.get())));\n    }\n  }\n}", "target": 1}
{"code": "static int ntlm_decode_oem_str(struct wire_field_hdr *str_hdr,\n                               struct ntlm_buffer *buffer,\n                               size_t payload_offs, char **_str)\n{\n    uint16_t str_len;\n    uint32_t str_offs;\n    char *str = NULL;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    str = strndup((const char *)&buffer->data[str_offs], str_len);\n    if (!str) return ENOMEM;\ndone:\n    *_str = str;\n    return 0;\n}", "target": 0}
{"code": "static int proc_dmesg_restrict(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n}", "target": 0}
{"code": "mmsServer_handleFileDeleteRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    if (buffer[bufPos++] != 0x19)\n        goto exit_reject_invalid_pdu;\n    int length;\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos == -1)\n        goto exit_reject_invalid_pdu;\n    if (length > 255) {\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n        return;\n    }\n    char filename[256];\n    memcpy(filename, buffer + bufPos, length);\n    filename[length] = 0;\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: mms_file_service.c: Delete file (%s)\\n\", filename);\n    if (mmsMsg_isFilenameSave(filename) == false)\n    {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n    if (connection->server->fileAccessHandler != NULL) {\n        MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                            connection, MMS_FILE_ACCESS_TYPE_DELETE, filename, NULL);\n        if (access != MMS_ERROR_NONE) {\n            mmsMsg_createServiceErrorPdu(invokeId, response, access);\n            return;\n        }\n    }\n    if (!getFileInfo(MmsServerConnection_getFilesystemBasepath(connection), filename, NULL, NULL)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  File (%s) not found\\n\", filename);\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n    if (!deleteFile(MmsServerConnection_getFilesystemBasepath(connection), filename)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  Delete file (%s) failed\\n\", filename);\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED);\n        return;\n    }\n    createNullResponseExtendedTag(invokeId, response, 0x4c);\n    return;\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}", "target": 0}
{"code": "void ipc_rcu_getref(void *ptr)\n{\n\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n}", "target": 1}
{"code": "static GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)\n{\n\tu32 size = parser->line_size;\n\tu32 nl_size = (u32) strlen(string);\n\tif (!nl_size) return GF_OK;\n\tif ( (parser->alloc_size < size+nl_size+1)\n\t   )\n\t{\n\t\tparser->alloc_size = size+nl_size+1;\n\t\tparser->alloc_size = 3 * parser->alloc_size / 2;\n\t\tparser->buffer = (char*)gf_realloc(parser->buffer, sizeof(char) * parser->alloc_size);\n\t\tif (!parser->buffer ) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(parser->buffer+size, string, sizeof(char)*nl_size);\n\tparser->buffer[size+nl_size] = 0;\n\tparser->line_size = size+nl_size;\n\treturn GF_OK;\n}", "target": 1}
{"code": "static const char *set_max_reversals(cmd_parms *cmd, void *conf_, const char *arg)\n{\n    core_dir_config *conf = conf_;\n    int val = 0;\n    if (!ap_cstr_casecmp(arg, \"none\")) {\n        val = AP_MAXRANGES_NORANGES;\n    }\n    else if (!ap_cstr_casecmp(arg, \"default\")) {\n        val = AP_MAXRANGES_DEFAULT;\n    }\n    else if (!ap_cstr_casecmp(arg, \"unlimited\")) {\n        val = AP_MAXRANGES_UNLIMITED;\n    }\n    else {\n        val = atoi(arg);\n        if (val <= 0)\n            return \"MaxRangeReversals requires 'none', 'default', 'unlimited' or \"\n            \"a positive integer\";\n    }\n    conf->max_reversals = val;\n    return NULL;\n}", "target": 0}
{"code": "jinit_merged_upsampler(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample;\n  upsample = (my_upsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_upsampler));\n  cinfo->upsample = (struct jpeg_upsampler *)upsample;\n  upsample->pub.start_pass = start_pass_merged_upsample;\n  upsample->pub.need_context_rows = FALSE;\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\n  if (cinfo->max_v_samp_factor == 2) {\n    upsample->pub.upsample = merged_2v_upsample;\n    if (jsimd_can_h2v2_merged_upsample())\n      upsample->upmethod = jsimd_h2v2_merged_upsample;\n    else\n      upsample->upmethod = h2v2_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v2_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v2_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = (JSAMPROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                (size_t)(upsample->out_row_width * sizeof(JSAMPLE)));\n  } else {\n    upsample->pub.upsample = merged_1v_upsample;\n    if (jsimd_can_h2v1_merged_upsample())\n      upsample->upmethod = jsimd_h2v1_merged_upsample;\n    else\n      upsample->upmethod = h2v1_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v1_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v1_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = NULL;\n  }\n  build_ycc_rgb_table(cinfo);\n}", "target": 1}
{"code": "TEST_P(MultiplexedRingHashIntegrationTest,\n       CookieRoutingNoCookieWithNonzeroTtlSetAndWithAttributes) {\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n        cookie->mutable_ttl()->set_seconds(15);\n        auto* attribute_1 = cookie->mutable_attributes()->Add();\n        attribute_1->set_name(\"test1\");\n        attribute_1->set_value(\"value1\");\n        auto* attribute_2 = cookie->mutable_attributes()->Add();\n        attribute_2->set_name(\"test2\");\n        attribute_2->set_value(\"value2\");\n      });\n  std::set<std::string> set_cookies;\n  sendMultipleRequests(\n      1024,\n      Http::TestRequestHeaderMapImpl{{\":method\", \"POST\"},\n                                     {\":path\", \"/test/long/url\"},\n                                     {\":scheme\", \"http\"},\n                                     {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().getStatusValue());\n        std::string value(\n            response.headers().get(Http::Headers::get().SetCookie)[0]->value().getStringView());\n        set_cookies.insert(value);\n        EXPECT_THAT(value,\n                    MatchesRegex(\"foo=.*; Max-Age=15; test1=value1; test2=value2; HttpOnly\"));\n      });\n  EXPECT_EQ(set_cookies.size(), 1);\n}", "target": 0}
{"code": "__u32 secure_ip_id(__be32 daddr)\n{\n\tstruct keydata *keyptr;\n\t__u32 hash[4];\n\tkeyptr = get_keyptr();\n\thash[0] = (__force __u32)daddr;\n\thash[1] = keyptr->secret[9];\n\thash[2] = keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}", "target": 1}
{"code": "static int32_t gcd(int a, int b)\n{\n  if (a == 0 && b == 0) {\n    return 1;\n  }\n  if (a == 0) return b;\n  if (b == 0) return a;\n  int32_t h;\n  do {\n    h = a % b;\n    a = b;\n    b = h;\n  } while (b != 0);\n  return a;\n}", "target": 1}
{"code": "static void list_slab_objects(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\tconst char *text)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\tunsigned long *map;\n\tslab_err(s, page, text, s->name);\n\tslab_lock(page);\n\tmap = get_map(s, page);\n\tfor_each_object(p, s, addr, page->objects) {\n\t\tif (!test_bit(slab_index(p, s, addr), map)) {\n\t\t\tpr_err(\"INFO: Object 0x%p @offset=%tu\\n\", p, p - addr);\n\t\t\tprint_tracking(s, p);\n\t\t}\n\t}\n\tput_map(map);\n\tslab_unlock(page);\n#endif\n}", "target": 0}
{"code": "struct mapped_device *dm_get_from_kobject(struct kobject *kobj)\n{\n\tstruct mapped_device *md;\n\tmd = container_of(kobj, struct mapped_device, kobj_holder.kobj);\n\tif (test_bit(DMF_FREEING, &md->flags) ||\n\t    dm_deleting_md(md))\n\t\treturn NULL;\n\tdm_get(md);\n\treturn md;\n}", "target": 1}
{"code": "static unsigned char *oidc_cache_hash_passphrase(request_rec *r,\n\t\tconst char *passphrase) {\n\tunsigned char *key = NULL;\n\tunsigned int key_len = 0;\n\toidc_jose_error_t err;\n\tif (oidc_jose_hash_bytes(r->pool, OIDC_JOSE_ALG_SHA256,\n\t\t\t(const unsigned char *) passphrase, strlen(passphrase), &key,\n\t\t\t&key_len, &err) == FALSE) {\n\t\toidc_error(r, \"oidc_jose_hash_bytes returned an error: %s\", err.text);\n\t\treturn NULL;\n\t}\n\treturn key;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  auto* params = reinterpret_cast<TfLiteAddParams*>(node->builtin_data);\n  TF_LITE_ENSURE_STATUS(\n      CalculateOpData(context, params, input1, input2, output, data));\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void GTextFieldSave(GTextField *gt,int utf8) {\n    unichar_t *ret;\n    char *cret;\n    FILE *file;\n    unichar_t *pt;\n    if ( _ggadget_use_gettext ) {\n\tchar *temp = GWidgetOpenFile8(_(\"Save\"),NULL,\"*.{txt,py}\",NULL,NULL);\n\tret = utf82u_copy(temp);\n\tfree(temp);\n    } else\n\tret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,\n\t\ttxt,NULL,NULL);\n    if ( ret==NULL )\nreturn;\n    cret = u2def_copy(ret);\n    free(ret);\n    file = fopen(cret,\"w\");\n    if ( file==NULL ) {\n\tif ( _ggadget_use_gettext )\n\t    GWidgetError8(_(\"Could not open file\"), _(\"Could not open %.100s\"),cret);\n\telse\n\t    GWidgetError(errort,error,cret);\n\tfree(cret);\nreturn;\n    }\n    free(cret);\n    if ( utf8 ) {\n\tputc(0xef,file);\t\t\n\tputc(0xbb,file);\n\tputc(0xbf,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    if ( *pt<0x80 )\n\t\tputc(*pt,file);\n\t    else if ( *pt<0x800 ) {\n\t\tputc(0xc0 | (*pt>>6), file);\n\t\tputc(0x80 | (*pt&0x3f), file);\n\t    } else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {\n\t\tint u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);\n\t\tputc( 0xf0 | (u>>2),file );\n\t\tputc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );\n\t\tputc( 0x80 | y,file );\n\t\tputc( 0x80 | (pt[1]&0x3f),file );\n\t    } else {\n\t\tputc( 0xe0 | (*pt>>12),file );\n\t\tputc( 0x80 | ((*pt>>6)&0x3f),file );\n\t\tputc( 0x80 | (*pt&0x3f),file );\n\t    }\n\t}\n    } else {\n\tputc(0xfeff>>8,file);\t\t\n\tputc(0xfeff&0xff,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    putc(*pt>>8,file);\n\t    putc(*pt&0xff,file);\n\t}\n    }\n    fclose(file);\n    GTextFieldSaved(gt);\n}", "target": 0}
{"code": "be32dec_vect(uint32_t *dst, const unsigned char *src, size_t len)\n{\n  size_t i;\n  uint32_t *s;\n  for (i = 0; i < len / 4; i++) {\n    s = (uint32_t *) (src + i * 4);\n    dst[i] = folly::Endian::big32(*s);\n  }\n}", "target": 1}
{"code": "void HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {\n  headers_.remove_if([&](const HeaderEntryImpl& entry) {\n    bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());\n    if (to_remove) {\n      EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(entry.key().getStringView());\n      if (cb) {\n        StaticLookupResponse ref_lookup_response = cb(*this);\n        if (ref_lookup_response.entry_) {\n          *ref_lookup_response.entry_ = nullptr;\n        }\n      }\n    }\n    return to_remove;\n  });\n}", "target": 1}
{"code": "sixel_allocator_malloc(\n    sixel_allocator_t    *allocator,  \n    size_t               n)           \n{\n    assert(allocator);\n    assert(allocator->fn_malloc);\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n    return allocator->fn_malloc(n);\n}", "target": 0}
{"code": "static void tcp_dsack_set(struct sock *sk, u32 seq, u32 end_seq)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tif (tcp_is_sack(tp) && sysctl_tcp_dsack) {\n\t\tint mib_idx;\n\t\tif (before(seq, tp->rcv_nxt))\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOLDSENT;\n\t\telse\n\t\t\tmib_idx = LINUX_MIB_TCPDSACKOFOSENT;\n\t\tNET_INC_STATS_BH(sock_net(sk), mib_idx);\n\t\ttp->rx_opt.dsack = 1;\n\t\ttp->duplicate_sack[0].start_seq = seq;\n\t\ttp->duplicate_sack[0].end_seq = end_seq;\n\t}\n}", "target": 0}
{"code": "static int getid(char ch) {\n\tconst char *keys = \"[]<>+-,.\";\n\tconst char *cidx = strchr (keys, ch);\n\treturn cidx? cidx - keys + 1: 0;\n}", "target": 1}
{"code": "comics_document_class_init (ComicsDocumentClass *klass)\n{\n\tGObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n\tEvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\tgobject_class->finalize = comics_document_finalize;\n\tev_document_class->load = comics_document_load;\n\tev_document_class->save = comics_document_save;\n\tev_document_class->get_n_pages = comics_document_get_n_pages;\n\tev_document_class->get_page_size = comics_document_get_page_size;\n\tev_document_class->render = comics_document_render;\n}", "target": 0}
{"code": "int64_t OpLevelCostEstimator::CalculateOutputSize(const OpInfo& op_info,\n                                                  bool* found_unknown_shapes) {\n  int64_t total_output_size = 0;\n  for (const auto& output : op_info.outputs()) {\n    DataType dt = output.dtype();\n    const auto& original_output_shape = output.shape();\n    int64_t output_size = DataTypeSize(BaseType(dt));\n    int num_dims = std::max(1, original_output_shape.dim_size());\n    auto output_shape = MaybeGetMinimumShape(original_output_shape, num_dims,\n                                             found_unknown_shapes);\n    for (const auto& dim : output_shape.dim()) {\n      output_size *= dim.size();\n    }\n    total_output_size += output_size;\n    VLOG(1) << \"Output Size: \" << output_size\n            << \" Total Output Size:\" << total_output_size;\n  }\n  return total_output_size;\n}", "target": 1}
{"code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}", "target": 0}
{"code": "unsigned paravirt_patch_call(void *insnbuf,\n\t\t\t     const void *target, u16 tgt_clobbers,\n\t\t\t     unsigned long addr, u16 site_clobbers,\n\t\t\t     unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (tgt_clobbers & ~site_clobbers)\n\t\treturn len;\t\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe8; \n\tb->delta = delta;\n\tBUILD_BUG_ON(sizeof(*b) != 5);\n\treturn 5;\n}", "target": 1}
{"code": "static int nr_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t      struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\tsize_t copied;\n\tstruct sk_buff *skb;\n\tint er;\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\trelease_sock(sk);\n\t\treturn -ENOTCONN;\n\t}\n\tif ((skb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT, flags & MSG_DONTWAIT, &er)) == NULL) {\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tskb_reset_transport_header(skb);\n\tcopied     = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\ter = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t}\n\tmsg->msg_namelen = sizeof(*sax);\n\tskb_free_datagram(sk, skb);\n\trelease_sock(sk);\n\treturn copied;\n}", "target": 0}
{"code": "BigInt EC_Group::multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const\n   {\n   return data().multiply_mod_order(x, y, z);\n   }", "target": 0}
{"code": "static void __net_exit sctp_defaults_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}", "target": 0}
{"code": "RunTerminationHelper(HANDLE console_token, DWORD pid) {\n  WCHAR module_path[MAX_PATH];\n  GetModuleFileNameW(NULL, module_path, _countof(module_path));\n  std::wstring command { module_path };\n  command += L\" --terminate \" + std::to_wstring(pid);\n  STARTUPINFOW startup_info = {};\n  startup_info.cb = sizeof(startup_info);\n  startup_info.lpDesktop = (LPWSTR) L\"winsta0\\\\default\";\n  PROCESS_INFORMATION process_info;\n  if (!CreateProcessAsUserW(console_token,\n        NULL,\n        (LPWSTR) command.c_str(),\n        NULL,\n        NULL,\n        FALSE,\n        CREATE_UNICODE_ENVIRONMENT | DETACHED_PROCESS,\n        NULL,\n        NULL,\n        &startup_info,\n        &process_info)) {\n    return false;\n  }\n  WaitForSingleObject(process_info.hProcess, INFINITE);\n  DWORD exit_code;\n  GetExitCodeProcess(process_info.hProcess, &exit_code);\n  CloseHandle(process_info.hProcess);\n  CloseHandle(process_info.hThread);\n  return exit_code == 0;\n}", "target": 1}
{"code": "void ipv4_pktinfo_prepare(const struct sock *sk, struct sk_buff *skb)\n{\n\tstruct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\n\tbool prepare = (inet_sk(sk)->cmsg_flags & IP_CMSG_PKTINFO) ||\n\t\t       ipv6_sk_rxinfo(sk);\n\tif (prepare && skb_rtable(skb)) {\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}", "target": 1}
{"code": "int propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\tuser_ns = current->nsproxy->mnt_ns->user_ns;\n\tlast_dest = dest_mnt;\n\tfirst_source = source_mnt;\n\tlast_source = source_mnt;\n\tmp = dest_mp;\n\tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}", "target": 0}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "void sas_init_disc(struct sas_discovery *disc, struct asd_sas_port *port)\n{\n\tint i;\n\tstatic const work_func_t sas_event_fns[DISC_NUM_EVENTS] = {\n\t\t[DISCE_DISCOVER_DOMAIN] = sas_discover_domain,\n\t\t[DISCE_REVALIDATE_DOMAIN] = sas_revalidate_domain,\n\t\t[DISCE_PROBE] = sas_probe_devices,\n\t\t[DISCE_SUSPEND] = sas_suspend_devices,\n\t\t[DISCE_RESUME] = sas_resume_devices,\n\t\t[DISCE_DESTRUCT] = sas_destruct_devices,\n\t};\n\tdisc->pending = 0;\n\tfor (i = 0; i < DISC_NUM_EVENTS; i++) {\n\t\tINIT_SAS_WORK(&disc->disc_work[i].work, sas_event_fns[i]);\n\t\tdisc->disc_work[i].port = port;\n\t}\n}", "target": 1}
{"code": "videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count++;\n}", "target": 1}
{"code": "static int net_ctl_permissions(struct ctl_table_header *head,\n\t\t\t       struct ctl_table *table)\n{\n\tstruct net *net = container_of(head->set, struct net, sysctls);\n\tkuid_t root_uid = make_kuid(net->user_ns, 0);\n\tkgid_t root_gid = make_kgid(net->user_ns, 0);\n\tif (ns_capable(net->user_ns, CAP_NET_ADMIN) ||\n\t    uid_eq(root_uid, current_uid())) {\n\t\tint mode = (table->mode >> 6) & 7;\n\t\treturn (mode << 6) | (mode << 3) | mode;\n\t}\n\tif (gid_eq(root_gid, current_gid())) {\n\t\tint mode = (table->mode >> 3) & 7;\n\t\treturn (mode << 3) | mode;\n\t}\n\treturn table->mode;\n}", "target": 1}
{"code": "static char *get_nextpath(char *path, int *offsetp, int fulllen)\n{\n\tint offset = *offsetp;\n\tif (offset >= fulllen)\n\t\treturn NULL;\n\twhile (path[offset] != '\\0' && offset < fulllen)\n\t\toffset++;\n\twhile (path[offset] == '\\0' && offset < fulllen)\n\t\toffset++;\n\t*offsetp = offset;\n\treturn (offset < fulllen) ? &path[offset] : NULL;\n}", "target": 0}
{"code": "static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn tfm->seedsize;\n}", "target": 1}
{"code": "static plist_t parse_string_node(const char **bnode, uint64_t size)\n{\n    plist_data_t data = plist_new_plist_data();\n    data->type = PLIST_STRING;\n    data->strval = (char *) malloc(sizeof(char) * (size + 1));\n    if (!data->strval) {\n        plist_free_data(data);\n        PLIST_BIN_ERR(\"%s: Could not allocate %\" PRIu64 \" bytes\\n\", __func__, sizeof(char) * (size + 1));\n        return NULL;\n    }\n    memcpy(data->strval, *bnode, size);\n    data->strval[size] = '\\0';\n    data->length = strlen(data->strval);\n    return node_create(NULL, data);\n}", "target": 0}
{"code": "static int io_timeout_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe,\n\t\t\t   bool is_timeout_link)\n{\n\tstruct io_timeout_data *data;\n\tunsigned flags;\n\tu32 off = READ_ONCE(sqe->off);\n\tif (unlikely(req->ctx->flags & IORING_SETUP_IOPOLL))\n\t\treturn -EINVAL;\n\tif (sqe->ioprio || sqe->buf_index || sqe->len != 1 ||\n\t    sqe->splice_fd_in)\n\t\treturn -EINVAL;\n\tif (off && is_timeout_link)\n\t\treturn -EINVAL;\n\tflags = READ_ONCE(sqe->timeout_flags);\n\tif (flags & ~(IORING_TIMEOUT_ABS | IORING_TIMEOUT_CLOCK_MASK |\n\t\t      IORING_TIMEOUT_ETIME_SUCCESS))\n\t\treturn -EINVAL;\n\tif (hweight32(flags & IORING_TIMEOUT_CLOCK_MASK) > 1)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&req->timeout.list);\n\treq->timeout.off = off;\n\tif (unlikely(off && !req->ctx->off_timeout_used))\n\t\treq->ctx->off_timeout_used = true;\n\tif (WARN_ON_ONCE(req_has_async_data(req)))\n\t\treturn -EFAULT;\n\tif (io_alloc_async_data(req))\n\t\treturn -ENOMEM;\n\tdata = req->async_data;\n\tdata->req = req;\n\tdata->flags = flags;\n\tif (get_timespec64(&data->ts, u64_to_user_ptr(sqe->addr)))\n\t\treturn -EFAULT;\n\tif (data->ts.tv_sec < 0 || data->ts.tv_nsec < 0)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&req->timeout.list);\n\tdata->mode = io_translate_timeout_mode(flags);\n\thrtimer_init(&data->timer, io_timeout_get_clock(data), data->mode);\n\tif (is_timeout_link) {\n\t\tstruct io_submit_link *link = &req->ctx->submit_state.link;\n\t\tif (!link->head)\n\t\t\treturn -EINVAL;\n\t\tif (link->last->opcode == IORING_OP_LINK_TIMEOUT)\n\t\t\treturn -EINVAL;\n\t\treq->timeout.head = link->last;\n\t\tlink->last->flags |= REQ_F_ARM_LTIMEOUT;\n\t}\n\treturn 0;", "target": 0}
{"code": "flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}", "target": 1}
{"code": "static void do_free_publickey(struct rsa_public_key *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n}", "target": 1}
{"code": "ProcAllocColor(ClientPtr client)\n{\n    ColormapPtr pmap;\n    int rc;\n    REQUEST(xAllocColorReq);\n    REQUEST_SIZE_MATCH(xAllocColorReq);\n    rc = dixLookupResourceByType((void **) &pmap, stuff->cmap, RT_COLORMAP,\n                                 client, DixAddAccess);\n    if (rc == Success) {\n        xAllocColorReply acr = {\n            .type = X_Reply,\n            .sequenceNumber = client->sequence,\n            .length = 0,\n            .red = stuff->red,\n            .green = stuff->green,\n            .blue = stuff->blue,\n            .pixel = 0\n        };\n        if ((rc = AllocColor(pmap, &acr.red, &acr.green, &acr.blue,\n                             &acr.pixel, client->index)))\n            return rc;\n#ifdef PANORAMIX\n        if (noPanoramiXExtension || !pmap->pScreen->myNum)\n#endif\n            WriteReplyToClient(client, sizeof(xAllocColorReply), &acr);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "static unsigned long pfn_max_align_down(unsigned long pfn)\n{\n\treturn pfn & ~(max_t(unsigned long, MAX_ORDER_NR_PAGES,\n\t\t\t     pageblock_nr_pages) - 1);\n}", "target": 0}
{"code": "bdat_flush_data(void)\n{\nwhile (chunking_data_left)\n  {\n  unsigned n = chunking_data_left;\n  if (!bdat_getbuf(&n)) break;\n  }\nreceive_getc = lwr_receive_getc;\nreceive_getbuf = lwr_receive_getbuf;\nreceive_ungetc = lwr_receive_ungetc;\nif (chunking_state != CHUNKING_LAST)\n  {\n  chunking_state = CHUNKING_OFFERED;\n  DEBUG(D_receive) debug_printf(\"chunking state %d\\n\", (int)chunking_state);\n  }\n}", "target": 0}
{"code": "void handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n        const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}", "target": 1}
{"code": "SecureSocket::secureAccept(int socket)\n{\n    createSSL();\n    SSL_set_fd(m_ssl->m_ssl, socket);\n    LOG((CLOG_DEBUG2 \"accepting secure socket\"));\n    int r = SSL_accept(m_ssl->m_ssl);\n    static int retry;\n    checkResult(r, retry);\n    if (isFatal()) {\n        LOG((CLOG_ERR \"failed to accept secure socket\"));\n        LOG((CLOG_INFO \"client connection may not be secure\"));\n        m_secureReady = false;\n        ARCH->sleep(1);\n        retry = 0;\n        return -1; \n    }\n    if (retry == 0) {\n        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n            if (verify_cert_fingerprint(\n                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n                LOG((CLOG_INFO \"accepted secure socket\"));\n                if (!ensure_peer_certificate()) {\n                    retry = 0;\n                    disconnect();\n                    return -1;\n                }\n            }\n            else {\n                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));\n                retry = 0;\n                disconnect();\n                return -1; \n            }\n        }\n        m_secureReady = true;\n        LOG((CLOG_INFO \"accepted secure socket\"));\n        if (CLOG->getFilter() >= kDEBUG1) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n    if (retry > 0) {\n        LOG((CLOG_DEBUG2 \"retry accepting secure socket\"));\n        m_secureReady = false;\n        ARCH->sleep(s_retryDelay);\n        return 0;\n    }\n    LOG((CLOG_ERR \"unexpected state attempting to accept connection\"));\n    return -1;\n}", "target": 0}
{"code": "static int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}", "target": 1}
{"code": "static void cma_id_get(struct rdma_id_private *id_priv)\n{\n\trefcount_inc(&id_priv->refcount);\n}", "target": 0}
{"code": "static bool ieee80211_validate_radiotap_len(struct sk_buff *skb)\n{\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *)skb->data;\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\treturn false; \n\tif (unlikely(rthdr->it_version))\n\t\treturn false; \n\tif (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))\n\t\treturn false; \n\treturn true;\n}", "target": 0}
{"code": "static int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\tkey_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\tkey_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\tkey_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\tat91_aes_init();\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (!consttime_memequal(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\treturn rc;\n}", "target": 0}
{"code": "size_t mobi_get_attribute_value(char *value, const unsigned char *data, const size_t size, const char *attribute, bool only_quoted) {\n    if (!data) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return SIZE_MAX;\n    }\n    size_t length = size;\n    size_t attr_length = strlen(attribute);\n    if (attr_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", attr_length);\n        return SIZE_MAX;\n    }\n    char attr[MOBI_ATTRNAME_MAXSIZE + 2];\n    strcpy(attr, attribute);\n    strcat(attr, \"=\");\n    attr_length++;\n    if (size < attr_length) {\n        return SIZE_MAX;\n    }\n    unsigned char last_border = '\\0';\n    do {\n        if (*data == '<' || *data == '>') {\n            last_border = *data;\n        }\n        if (length > attr_length + 1 && memcmp(data, attr, attr_length) == 0) {\n            size_t offset = size - length;\n            if (last_border == '>') {\n                data += attr_length;\n                length -= attr_length - 1;\n                continue;\n            }\n            if (offset > 0) {\n                if (data[-1] != '<' && !isspace(data[-1])) {\n                    data += attr_length;\n                    length -= attr_length - 1;\n                    continue;\n                }\n            }\n            data += attr_length;\n            length -= attr_length;\n            unsigned char separator;\n            if (*data != '\\'' && *data != '\"') {\n                if (only_quoted) {\n                    continue;\n                }\n                separator = ' ';\n            } else {\n                separator = *data;\n                data++;\n                length--;\n            }\n            size_t j;\n            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            if (*(data - 1) == '/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            return size - length - j;\n        }\n        data++;\n    } while (--length);\n    value[0] = '\\0';\n    return SIZE_MAX;\n}", "target": 1}
{"code": "void sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->e);\n}", "target": 1}
{"code": "static pyc_object *get_set_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}", "target": 1}
{"code": "    bool PamBackend::start(const QString &user) {\n        bool result;\n        QString service = QStringLiteral(\"sddm\");\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n        return result;\n    }", "target": 1}
{"code": "cifs_put_tcp_session(struct TCP_Server_Info *server, int from_reconnect)\n{\n\tstruct task_struct *task;\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tWARN_ON(server->srv_count < 0);\n\tput_net(cifs_net_ns(server));\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tif (CIFS_SERVER_IS_CHAN(server))\n\t\tcifs_put_tcp_session(server->primary_server, from_reconnect);\n\tcancel_delayed_work_sync(&server->echo);\n\tcancel_delayed_work_sync(&server->resolve);\n\tif (from_reconnect)\n\t\tcancel_delayed_work(&server->reconnect);\n\telse\n\t\tcancel_delayed_work_sync(&server->reconnect);\n\tspin_lock(&server->srv_lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&server->srv_lock);\n\tcifs_crypto_secmech_release(server);\n\tkfree_sensitive(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tkfree(server->hostname);\n\tserver->hostname = NULL;\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tsend_sig(SIGKILL, task, 1);\n}", "target": 0}
{"code": "static int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tretval = check_ptrace_options(flags);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\taudit_ptrace(task);\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\ttask->ptrace = flags;\n\tptrace_link(task, current);\n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\tspin_lock(&task->sighand->siglock);\n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\tspin_unlock(&task->sighand->siglock);\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\tint i;\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tfor (i = off; i < off + cnt - 1; i++)\n\t\tnew_data[i].seen = true;\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}", "target": 0}
{"code": "static int em_fxrstor(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tint rc;\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = segmented_read(ctxt, ctxt->memop.addr.mem, &fx_state, 512);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (fx_state.mxcsr >> 16)\n\t\treturn emulate_gp(ctxt, 0);\n\tctxt->ops->get_fpu(ctxt);\n\tif (ctxt->mode < X86EMUL_MODE_PROT64)\n\t\trc = fxrstor_fixup(ctxt, &fx_state);\n\tif (rc == X86EMUL_CONTINUE)\n\t\trc = asm_safe(\"fxrstor %[fx]\", : [fx] \"m\"(fx_state));\n\tctxt->ops->put_fpu(ctxt);\n\treturn rc;\n}", "target": 1}
{"code": "void CSecurityTLS::initGlobal()\n{\n  static bool globalInitDone = false;\n  if (!globalInitDone) {\n    gnutls_global_init();\n    globalInitDone = true;\n  }\n}", "target": 1}
{"code": "static int rt6_bind_neighbour(struct rt6_info *rt, struct net_device *dev)\n{\n\tstruct neighbour *n = __ipv6_neigh_lookup(&nd_tbl, dev, &rt->rt6i_gateway);\n\tif (!n) {\n\t\tn = neigh_create(&nd_tbl, &rt->rt6i_gateway, dev);\n\t\tif (IS_ERR(n))\n\t\t\treturn PTR_ERR(n);\n\t}\n\trt->n = n;\n\treturn 0;\n}", "target": 0}
{"code": "struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t       struct request_sock *req,\n\t\t\t\t       struct dst_entry *dst)\n{\n\tstruct inet_request_sock *ireq;\n\tstruct inet_sock *newinet;\n\tstruct sock *newsk;\n\tif (sk_acceptq_is_full(sk))\n\t\tgoto exit_overflow;\n\tif (dst == NULL && (dst = inet_csk_route_req(sk, req)) == NULL)\n\t\tgoto exit;\n\tnewsk = dccp_create_openreq_child(sk, req, skb);\n\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\tsk_setup_caps(newsk, dst);\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;\n\t}\n\t__inet_hash_nolisten(newsk, NULL);\n\treturn newsk;\nexit_overflow:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);\nexit_nonewsk:\n\tdst_release(dst);\nexit:\n\tNET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);\n\treturn NULL;\n}", "target": 1}
{"code": "void LayerTilerChromium::invalidateEntireLayer()\n{\n    for (size_t i = 0; i < m_tiles.size(); ++i) {\n        if (m_tiles[i])\n            m_unusedTiles.append(m_tiles[i].release());\n    }\n    m_tiles.clear();\n    m_layerSize = IntSize();\n    m_layerTileSize = IntSize();\n    m_lastUpdateLayerRect = IntRect();\n}", "target": 0}
{"code": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    return pure_memcmp(s1, s2, strlen(s1) + 1U);\n}", "target": 1}
{"code": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n{\n\tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n\t\treturn -EINVAL;\n\tif (args->gsi >= KVM_MAX_IRQ_ROUTES)\n\t\treturn -EINVAL;\n\tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n\t\treturn kvm_irqfd_deassign(kvm, args);\n\treturn kvm_irqfd_assign(kvm, args);\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &getParameters() const\n    {\n        return parameters();\n    }", "target": 1}
{"code": "checkContentType(Buffer *buf)\n{\n    char *p;\n    Str r;\n    p = checkHeader(buf, \"Content-Type:\");\n    if (p == NULL)\n\treturn NULL;\n    r = Strnew();\n    while (*p && *p != ';' && !IS_SPACE(*p))\n\tStrcat_char(r, *p++);\n#ifdef USE_M17N\n    if ((p = strcasestr(p, \"charset\")) != NULL) {\n\tp += 7;\n\tSKIP_BLANKS(p);\n\tif (*p == '=') {\n\t    p++;\n\t    SKIP_BLANKS(p);\n\t    if (*p == '\"')\n\t\tp++;\n\t    content_charset = wc_guess_charset(p, 0);\n\t}\n    }\n#endif\n    return r->ptr;\n}", "target": 0}
{"code": "void RtmpProtocol::handle_C1_complex(const char *data){\n    const char *c1_start = data + 1;\n    const char *schema_start = c1_start + 8;\n    char *digest_start;\n    try {\n        auto digest = get_C1_digest((uint8_t *) schema_start + C1_SCHEMA_SIZE, &digest_start);\n        string c1_joined(c1_start, C1_HANDSHARK_SIZE);\n        c1_joined.erase(digest_start - c1_start, C1_DIGEST_SIZE);\n        check_C1_Digest(digest, c1_joined);\n        send_complex_S0S1S2(0, digest);\n    } catch (std::exception &) {\n        try {\n            auto digest = get_C1_digest((uint8_t *) schema_start, &digest_start);\n            string c1_joined(c1_start, C1_HANDSHARK_SIZE);\n            c1_joined.erase(digest_start - c1_start, C1_DIGEST_SIZE);\n            check_C1_Digest(digest, c1_joined);\n            send_complex_S0S1S2(1, digest);\n        } catch (std::exception &) {\n            handle_C1_simple(data);\n        }\n    }\n}", "target": 0}
{"code": "static void ida_check_bad_free(struct ida *ida)\n{\n\tunsigned long i;\n\tprintk(\"vvv Ignore \\\"not allocated\\\" warnings\\n\");\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, 3, GFP_KERNEL) != 3);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, 1023, GFP_KERNEL) != 1023);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, (1 << 20) - 1, GFP_KERNEL) != (1 << 20) - 1);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tprintk(\"^^^ \\\"not allocated\\\" warnings over\\n\");\n\tida_free(ida, 3);\n\tida_free(ida, 1023);\n\tida_free(ida, (1 << 20) - 1);\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n}", "target": 0}
{"code": "static int copy_counters_to_user(struct ebt_table *t,\n\t\t\t\t  const struct ebt_counter *oldcounters,\n\t\t\t\t  void __user *user, unsigned int num_counters,\n\t\t\t\t  unsigned int nentries)\n{\n\tstruct ebt_counter *counterstmp;\n\tint ret = 0;\n\tif (num_counters == 0)\n\t\treturn 0;\n\tif (num_counters != nentries) {\n\t\tBUGPRINT(\"Num_counters wrong\\n\");\n\t\treturn -EINVAL;\n\t}\n\tcounterstmp = vmalloc(nentries * sizeof(*counterstmp));\n\tif (!counterstmp)\n\t\treturn -ENOMEM;\n\twrite_lock_bh(&t->lock);\n\tget_counters(oldcounters, counterstmp, nentries);\n\twrite_unlock_bh(&t->lock);\n\tif (copy_to_user(user, counterstmp,\n\t   nentries * sizeof(struct ebt_counter)))\n\t\tret = -EFAULT;\n\tvfree(counterstmp);\n\treturn ret;\n}", "target": 0}
{"code": "jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}", "target": 1}
{"code": "TEST_P(ProxyProtocolTest, V2LocalConnectionFilterState) {\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x20, 0x00, 0x00, 0x07, 0x00, 0x00, 0x04, 0x0a, 0x0b, 0x0c,\n                                0x0d, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  expectData(\"moredata\");\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}", "target": 0}
{"code": "static void dns_callback(void *arg, const struct sockaddr *sa, int salen)\n{\n\tstruct PgSocket *server = arg;\n\tstruct PgDatabase *db = server->pool->db;\n\tstruct sockaddr_in sa_in;\n\tstruct sockaddr_in6 sa_in6;\n\tserver->dns_token = NULL;\n\tif (!sa) {\n\t\tdisconnect_server(server, true, \"server dns lookup failed\");\n\t\treturn;\n\t} else if (sa->sa_family == AF_INET) {\n\t\tchar buf[64];\n\t\tmemcpy(&sa_in, sa, sizeof(sa_in));\n\t\tsa_in.sin_port = htons(db->port);\n\t\tsa = (struct sockaddr *)&sa_in;\n\t\tsalen = sizeof(sa_in);\n\t\tslog_debug(server, \"dns_callback: inet4: %s\",\n\t\t\t   sa2str(sa, buf, sizeof(buf)));\n\t} else if (sa->sa_family == AF_INET6) {\n\t\tchar buf[64];\n\t\tmemcpy(&sa_in6, sa, sizeof(sa_in6));\n\t\tsa_in6.sin6_port = htons(db->port);\n\t\tsa = (struct sockaddr *)&sa_in6;\n\t\tsalen = sizeof(sa_in6);\n\t\tslog_debug(server, \"dns_callback: inet6: %s\",\n\t\t\t   sa2str(sa, buf, sizeof(buf)));\n\t} else {\n\t\tdisconnect_server(server, true, \"unknown address family: %d\", sa->sa_family);\n\t\treturn;\n\t}\n\tconnect_server(server, sa, salen);\n}", "target": 0}
{"code": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n  if (rc == IDN2_OK)\n    {\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n      free(output_u8);\n    }\n  return rc;\n}", "target": 1}
{"code": "static int asymmetric_key_cmp(const struct key *key,\n\t\t\t      const struct key_match_data *match_data)\n{\n\tconst struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);\n\tconst char *description = match_data->raw_data;\n\tconst char *spec = description;\n\tconst char *id;\n\tptrdiff_t speclen;\n\tif (!subtype || !spec || !*spec)\n\t\treturn 0;\n\tif (key->description && strcmp(key->description, description) == 0)\n\t\treturn 1;\n\tid = strchr(spec, ':');\n\tif (!id)\n\t\treturn 0;\n\tspeclen = id - spec;\n\tid++;\n\tif (speclen == 2 && memcmp(spec, \"id\", 2) == 0)\n\t\treturn asymmetric_keyid_match(asymmetric_key_id(key), id);\n\tif (speclen == subtype->name_len &&\n\t    memcmp(spec, subtype->name, speclen) == 0)\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "int rose_parse_facilities(unsigned char *p, unsigned packet_len,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\tfacilities_len = *p++;\n\tif (facilities_len == 0 || (unsigned)facilities_len > packet_len)\n\t\treturn 0;\n\twhile (facilities_len >= 3 && *p == 0x00) {\n\t\tfacilities_len--;\n\t\tp++;\n\t\tswitch (*p) {\n\t\tcase FAC_NATIONAL:\t\t\n\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\t\tcase FAC_CCITT:\t\t\n\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\tlen = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (len < 0)\n\t\t\treturn 0;\n\t\tif (WARN_ON(len >= facilities_len))\n\t\t\treturn 0;\n\t\tfacilities_len -= len + 1;\n\t\tp += len + 1;\n\t}\n\treturn facilities_len == 0;\n}", "target": 0}
{"code": "static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}", "target": 0}
{"code": "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\tfor(y = 0; y < height; y++) {\n\t\tfor(x = 0; x < width; x++) {\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\tgdFree(buffer);\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}", "target": 1}
{"code": "sg_poll(struct file *filp, poll_table * wait)\n{\n\tunsigned int res = 0;\n\tSg_device *sdp;\n\tSg_fd *sfp;\n\tSg_request *srp;\n\tint count = 0;\n\tunsigned long iflags;\n\tsfp = filp->private_data;\n\tif (!sfp)\n\t\treturn POLLERR;\n\tsdp = sfp->parentdp;\n\tif (!sdp)\n\t\treturn POLLERR;\n\tpoll_wait(filp, &sfp->read_wait, wait);\n\tread_lock_irqsave(&sfp->rq_list_lock, iflags);\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif ((0 == res) && (1 == srp->done) && (!srp->sg_io_owned))\n\t\t\tres = POLLIN | POLLRDNORM;\n\t\t++count;\n\t}\n\tread_unlock_irqrestore(&sfp->rq_list_lock, iflags);\n\tif (atomic_read(&sdp->detaching))\n\t\tres |= POLLHUP;\n\telse if (!sfp->cmd_q) {\n\t\tif (0 == count)\n\t\t\tres |= POLLOUT | POLLWRNORM;\n\t} else if (count < SG_MAX_QUEUE)\n\t\tres |= POLLOUT | POLLWRNORM;\n\tSCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp,\n\t\t\t\t      \"sg_poll: res=0x%x\\n\", (int) res));\n\treturn res;\n}", "target": 0}
{"code": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\t__pipe_lock(pipe);\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}", "target": 0}
{"code": "static int f2fs_swap_activate(struct swap_info_struct *sis, struct file *file,\n\t\t\t\tsector_t *span)\n{\n\tstruct inode *inode = file_inode(file);\n\tint ret;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EINVAL;\n\tif (f2fs_readonly(F2FS_I_SB(inode)->sb))\n\t\treturn -EROFS;\n\tret = f2fs_convert_inline_inode(inode);\n\tif (ret)\n\t\treturn ret;\n\tret = check_swap_activate(file, sis->max);\n\tif (ret)\n\t\treturn ret;\n\tset_inode_flag(inode, FI_PIN_FILE);\n\tf2fs_precache_extents(inode);\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME);\n\treturn 0;\n}", "target": 0}
{"code": "static int ncrush_generate_tables(NCRUSH_CONTEXT* context)\n{\n\tUINT32 k, i;\n\tint j, l;\n\tk = 0;\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(28 < ARRAYSIZE(LOMBitsLUT));\n\tfor (i = 0; i < 28; i++)\n\t{\n\t\tfor (j = 0; j < 1 << LOMBitsLUT[i]; j++)\n\t\t{\n\t\t\tl = (k++) + 2;\n\t\t\tcontext->HuffTableLOM[l] = (int)i;\n\t\t}\n\t}\n\tfor (k = 2; k < 4096; k++)\n\t{\n\t\tif ((k - 2) >= 768)\n\t\t\ti = 28;\n\t\telse\n\t\t\ti = context->HuffTableLOM[k];\n\t\tif (i >= ARRAYSIZE(LOMBitsLUT))\n\t\t\treturn -1;\n\t\tif (i >= ARRAYSIZE(LOMBaseLUT))\n\t\t\treturn -1;\n\t\tif (((((1 << LOMBitsLUT[i]) - 1) & (k - 2)) + LOMBaseLUT[i]) != k)\n\t\t\treturn -1;\n\t}\n\tk = 0;\n\tfor (i = 0; i < 16; i++)\n\t{\n\t\tfor (j = 0; j < 1 << CopyOffsetBitsLUT[i]; j++)\n\t\t{\n\t\t\tl = k++ + 2;\n\t\t\tcontext->HuffTableCopyOffset[l] = i;\n\t\t}\n\t}\n\tk /= 128;\n\tfor (i = 16; i < 32; i++)\n\t{\n\t\tfor (j = 0; j < 1 << (CopyOffsetBitsLUT[i] - 7); j++)\n\t\t{\n\t\t\tl = k++ + 2 + 256;\n\t\t\tcontext->HuffTableCopyOffset[l] = i;\n\t\t}\n\t}\n\tif ((k + 256) > 1024)\n\t\treturn -1;\n\treturn 1;\n}", "target": 0}
{"code": "TfLiteStatus PrepareHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input_resource_id_tensor), 1);\n  TF_LITE_ENSURE_EQ(context, SizeOfDimension(input_resource_id_tensor, 0), 1);\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  TF_LITE_ENSURE(context, (key_tensor->type == kTfLiteInt64 &&\n                           value_tensor->type == kTfLiteString) ||\n                              (key_tensor->type == kTfLiteString &&\n                               value_tensor->type == kTfLiteInt64));\n  TF_LITE_ENSURE(context, HaveSameShapes(key_tensor, value_tensor));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "do_pam_chauthtok(void)\n{\n\tstruct pam_conv pam_conv = { pam_chauthtok_conv, NULL };\n\tif (use_privsep)\n\t\tfatal(\"PAM: chauthtok not supprted with privsep\");\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&pam_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tdebug(\"PAM: changing password\");\n\tsshpam_err = pam_chauthtok(sshpam_handle, PAM_CHANGE_EXPIRED_AUTHTOK);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: pam_chauthtok(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}", "target": 0}
{"code": "PHP_FUNCTION(mb_regex_encoding)\n{\n\tsize_t argc = ZEND_NUM_ARGS();\n\tchar *encoding;\n\tint encoding_len;\n\tOnigEncoding mbctype;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &encoding, &encoding_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (argc == 0) {\n\t\tconst char *retval = _php_mb_regex_mbctype2name(MBREX(current_mbctype));\n\t\tif (retval == NULL) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tRETURN_STRING((char *)retval, 1);\n\t} else if (argc == 1) {\n\t\tmbctype = _php_mb_regex_name2mbctype(encoding);\n\t\tif (mbctype == ONIG_ENCODING_UNDEF) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown encoding \\\"%s\\\"\", encoding);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tMBREX(current_mbctype) = mbctype;\n\t\tRETURN_TRUE;\n\t}\n}", "target": 0}
{"code": "wb_print(netdissect_options *ndo,\n         register const void *hdr, register u_int len)\n{\n\tregister const struct pkt_hdr *ph;\n\tph = (const struct pkt_hdr *)hdr;\n\tif (len < sizeof(*ph) || !ND_TTEST(*ph)) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn;\n\t}\n\tlen -= sizeof(*ph);\n\tif (ph->ph_flags)\n\t\tND_PRINT((ndo, \"*\"));\n\tswitch (ph->ph_type) {\n\tcase PT_KILL:\n\t\tND_PRINT((ndo, \" wb-kill\"));\n\t\treturn;\n\tcase PT_ID:\n\t\tif (wb_id(ndo, (const struct pkt_id *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_RREQ:\n\t\tif (wb_rreq(ndo, (const struct pkt_rreq *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_RREP:\n\t\tif (wb_rrep(ndo, (const struct pkt_rrep *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_DRAWOP:\n\t\tif (wb_drawop(ndo, (const struct pkt_dop *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_PREQ:\n\t\tif (wb_preq(ndo, (const struct pkt_preq *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tcase PT_PREP:\n\t\tif (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)\n\t\t\treturn;\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" wb-%d!\", ph->ph_type));\n\t\treturn;\n\t}\n}", "target": 0}
{"code": "psf_bump_header_allocation (SF_PRIVATE * psf, sf_count_t needed)\n{\n\tsf_count_t newlen, smallest = INITAL_HEADER_SIZE ;\n\tvoid * ptr ;\n\tnewlen = (needed > psf->header.len) ? 2 * SF_MAX (needed, smallest) : 2 * psf->header.len ;\n\tif (newlen > 100 * 1024)\n\t{\tpsf_log_printf (psf, \"Request for header allocation of %D denined.\\n\", newlen) ;\n\t\treturn 1 ;\n\t\t}\n\tif ((ptr = realloc (psf->header.ptr, newlen)) == NULL)\n\t{\tpsf_log_printf (psf, \"realloc (%p, %D) failed\\n\", psf->header.ptr, newlen) ;\n\t\tpsf->error = SFE_MALLOC_FAILED ;\n\t\treturn 1 ;\n\t\t} ;\n\tpsf->header.ptr = ptr ;\n\tpsf->header.len = newlen ;\n\treturn 0 ;\n} ", "target": 0}
{"code": "void CompactProtocolReader::readStringBody(StrType& str, int32_t size) {\n  if (static_cast<int32_t>(in_.length()) < size) {\n    if (!in_.canAdvance(size)) {\n      protocol::TProtocolException::throwTruncatedData();\n    }\n    str.reserve(size); \n  }\n  str.clear();\n  size_t size_left = size;\n  while (size_left > 0) {\n    auto data = in_.peekBytes();\n    auto data_avail = std::min(data.size(), size_left);\n    if (data.empty()) {\n      TProtocolException::throwExceededSizeLimit();\n    }\n    str.append((const char*)data.data(), data_avail);\n    size_left -= data_avail;\n    in_.skipNoAdvance(data_avail);\n  }\n}", "target": 0}
{"code": "void _reset_fxsave_state()\n{\n    static OE_ALIGNED(OE_FXSAVE_ALIGNMENT) const uint64_t\n        _initial_fxstate[OE_FXSAVE_AREA_SIZE / sizeof(uint64_t)] = {\n            0x037F, 0, 0, 0xFFFF00001F80,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n        };\n    asm volatile(\"fxrstor %[fx_state] \\n\\t\"\n                 :\n                 : [fx_state] \"m\"(_initial_fxstate)\n                 :);\n}", "target": 1}
{"code": "extract_option(uschar **name, uschar **value)\n{\nuschar *n;\nuschar *v = smtp_cmd_data + Ustrlen(smtp_cmd_data) - 1;\nwhile (isspace(*v)) v--;\nv[1] = 0;\nwhile (v > smtp_cmd_data && *v != '=' && !isspace(*v))\n  {\n  if (*v == '\"') do v--; while (*v != '\"' && v > smtp_cmd_data+1);\n  v--;\n  }\nn = v;\nif (*v == '=')\n  {\n  while(isalpha(n[-1])) n--;\n  if (!isspace(n[-1])) return FALSE;\n  n[-1] = 0;\n  }\nelse\n  {\n  n++;\n  if (v == smtp_cmd_data) return FALSE;\n  }\n*v++ = 0;\n*name = n;\n*value = v;\nreturn TRUE;\n}", "target": 0}
{"code": "int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\n\t\t\t  struct posix_acl **acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error;\n\terror = posix_acl_equiv_mode(*acl, &mode);\n\tif (error < 0)\n\t\treturn error;\n\tif (error == 0)\n\t\t*acl = NULL;\n\tif (!in_group_p(inode->i_gid) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\tmode &= ~S_ISGID;\n\t*mode_p = mode;\n\treturn 0;\n}", "target": 0}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": "static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)\n{\n    int i, length;\n    segment->nb_index_entries = avio_rb32(pb);\n    length = avio_rb32(pb);\n    if(segment->nb_index_entries && length < 11)\n        return AVERROR_INVALIDDATA;\n    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||\n        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||\n        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries)))) {\n        av_freep(&segment->temporal_offset_entries);\n        av_freep(&segment->flag_entries);\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < segment->nb_index_entries; i++) {\n        if(avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n        segment->temporal_offset_entries[i] = avio_r8(pb);\n        avio_r8(pb);                                        \n        segment->flag_entries[i] = avio_r8(pb);\n        segment->stream_offset_entries[i] = avio_rb64(pb);\n        avio_skip(pb, length - 11);\n    }\n    return 0;\n}", "target": 0}
{"code": "__global__ void UnsortedSegmentCustomKernel(const Index input_outer_dim_size,\n                                            const Index inner_dim_size,\n                                            const Index output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const Index input_total_size = input_outer_dim_size * inner_dim_size;\n  const Index output_total_size = output_outer_dim_size * inner_dim_size;\n  for (int input_index : GpuGridRangeX(input_total_size)) {\n    const Index input_segment_index = input_index / inner_dim_size;\n    const Index segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 || output_segment_index >= output_total_size) {\n      continue;\n    }\n    const Index output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}", "target": 1}
{"code": "uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                          char *buffer) {\n  uint16_t offset = 4 + (5 * 32);\n  int16_t len = msg->data_length - offset;\n  if (msg->has_data_length && len > 0) {\n    memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n    return len < 256 ? (uint8_t)len : 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "TEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "void vmacache_flush_all(struct mm_struct *mm)\n{\n\tstruct task_struct *g, *p;\n\tcount_vm_vmacache_event(VMACACHE_FULL_FLUSHES);\n\tif (atomic_read(&mm->mm_users) == 1)\n\t\treturn;\n\trcu_read_lock();\n\tfor_each_process_thread(g, p) {\n\t\tif (mm == p->mm)\n\t\t\tvmacache_flush(p);\n\t}\n\trcu_read_unlock();\n}", "target": 1}
{"code": "void exit_io_context(void)\n{\n\tstruct io_context *ioc;\n\ttask_lock(current);\n\tioc = current->io_context;\n\tcurrent->io_context = NULL;\n\ttask_unlock(current);\n\tif (atomic_dec_and_test(&ioc->nr_tasks)) {\n\t\tif (ioc->aic && ioc->aic->exit)\n\t\t\tioc->aic->exit(ioc->aic);\n\t\tcfq_exit(ioc);\n\t\tput_io_context(ioc);\n\t}\n}", "target": 1}
{"code": "fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\tint ret;\n\tint sav_errno;\n\tif (fifo->name) {\n\t\tsav_errno = 0;\n\t\tif (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))\n\t\t\tfifo->created_fifo = true;\n\t\telse {\n\t\t\tsav_errno = errno;\n\t\t\tif (sav_errno != EEXIST)\n\t\t\t\tlog_message(LOG_INFO, \"Unable to create %snotify fifo %s\", type, fifo->name);\n\t\t}\n\t\tif (!sav_errno || sav_errno == EEXIST) {\n\t\t\tif (fifo->script)\n\t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\n\t\t\t\tif (fifo->created_fifo) {\n\t\t\t\t\tunlink(fifo->name);\n\t\t\t\t\tfifo->created_fifo = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fifo->fd == -1) {\n\t\t\tFREE(fifo->name);\n\t\t\tfifo->name = NULL;\n\t\t}\n\t}\n}", "target": 1}
{"code": "snmp_ber_encode_unsigned_integer(unsigned char *out, uint32_t *out_len, uint8_t type, uint32_t number)\n{\n  uint32_t original_out_len;\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, type);\n  return out;\n}", "target": 1}
{"code": "int rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}", "target": 0}
{"code": "static void http1_on_data_first_time(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  ssize_t i;\n  i = fio_read(uuid, p->buf + p->buf_len, HTTP_MAX_HEADER_LENGTH - p->buf_len);\n  if (i <= 0)\n    return;\n  p->buf_len += i;\n  p->p.protocol.on_data = http1_on_data;\n  if (i >= 24 && !memcmp(p->buf, \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\", 24)) {\n    FIO_LOG_WARNING(\"client claimed unsupported HTTP/2 prior knowledge.\");\n    fio_close(uuid);\n    return;\n  }\n  http1_consume_data(uuid, p);\n}", "target": 1}
{"code": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tsiginfo_t info;\n\tif (copy_from_user(&info, uinfo, sizeof(siginfo_t)))\n\t\treturn -EFAULT;\n\tif (info.si_code >= 0)\n\t\treturn -EPERM;\n\tinfo.si_signo = sig;\n\treturn kill_proc_info(sig, &info, pid);\n}", "target": 1}
{"code": "static void test_double_compare()\n{\n  MYSQL_STMT *stmt;\n  int        rc;\n  char       real_data[10], tiny_data;\n  double     double_data;\n  MYSQL_RES  *result;\n  MYSQL_BIND my_bind[3];\n  ulong      length[3];\n  char query[MAX_TEST_QUERY_LENGTH];\n  myheader(\"test_double_compare\");\n  rc= mysql_autocommit(mysql, TRUE);\n  myquery(rc);\n  rc= mysql_query(mysql, \"DROP TABLE IF EXISTS test_double_compare\");\n  myquery(rc);\n  rc= mysql_query(mysql, \"CREATE TABLE test_double_compare(col1 tinyint, \"\n                         \" col2 float, col3 double )\");\n  myquery(rc);\n  rc= mysql_query(mysql, \"INSERT INTO test_double_compare \"\n                         \"VALUES (1, 10.2, 34.5)\");\n  myquery(rc);\n  strmov(query, \"UPDATE test_double_compare SET col1=100 \"\n                \"WHERE col1 = ? AND col2 = ? AND COL3 = ?\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt(stmt);\n  verify_param_count(stmt, 3);\n  memset(my_bind, 0, sizeof(my_bind));\n  my_bind[0].buffer_type= MYSQL_TYPE_TINY;\n  my_bind[0].buffer= (void *)&tiny_data;\n  my_bind[1].buffer_type= MYSQL_TYPE_STRING;\n  my_bind[1].buffer= (void *)&real_data;\n  my_bind[1].buffer_length= sizeof(real_data);\n  my_bind[1].length= &length[1];\n  length[1]= 10;\n  my_bind[2].buffer_type= MYSQL_TYPE_DOUBLE;\n  my_bind[2].buffer= (void *)&double_data;\n  tiny_data= 1;\n  strmov(real_data, \"10.2\");\n  double_data= 34.5;\n  rc= mysql_stmt_bind_param(stmt, my_bind);\n  check_execute(stmt, rc);\n  rc= mysql_stmt_execute(stmt);\n  check_execute(stmt, rc);\n  verify_affected_rows(0);\n  mysql_stmt_close(stmt);\n  rc= mysql_commit(mysql);\n  myquery(rc);\n  rc= mysql_query(mysql, \"SELECT * FROM test_double_compare\");\n  myquery(rc);\n  result= mysql_store_result(mysql);\n  mytest(result);\n  rc= my_process_result_set(result);\n  DIE_UNLESS((int)tiny_data == rc);\n  mysql_free_result(result);\n}", "target": 0}
{"code": "debug_print_range(const char *msg,\n    int lineno,\n    void *start, signed long len,\n    void *end)\n{\n    char *st = (char *)start;\n    char *en = (char *)end;\n    signed long le = len;\n    if (len) {\n        if (en) {\n            le = (long)(en-st);\n        } else {\n            en= start+len;\n        }\n    } else if (en) {\n        le = (long)(en-st);\n    }\n    printf(\"RANGEdebug %s  st=0x%lx le=%ld en=0x%lx line %d\\n\",\n        msg,(unsigned long)st,le,(unsigned long)en,lineno);\n}", "target": 0}
{"code": "int perf_cpu_time_max_percent_handler(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp,\n\t\t\t\tloff_t *ppos)\n{\n\tint ret = proc_dointvec(table, write, buffer, lenp, ppos);\n\tif (ret || !write)\n\t\treturn ret;\n\tif (sysctl_perf_cpu_time_max_percent == 100 ||\n\t    sysctl_perf_cpu_time_max_percent == 0) {\n\t\tprintk(KERN_WARNING\n\t\t       \"perf: Dynamic interrupt throttling disabled, can hang your system!\\n\");\n\t\tWRITE_ONCE(perf_sample_allowed_ns, 0);\n\t} else {\n\t\tupdate_perf_cpu_limits();\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "sshkey_load_file(int fd, struct sshbuf *blob)\n{\n\tu_char buf[1024];\n\tsize_t len;\n\tstruct stat st;\n\tint r;\n\tif (fstat(fd, &st) < 0)\n\t\treturn SSH_ERR_SYSTEM_ERROR;\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size > MAX_KEY_FILE_SIZE)\n\t\treturn SSH_ERR_INVALID_FORMAT;\n\tfor (;;) {\n\t\tif ((len = atomicio(read, fd, buf, sizeof(buf))) == 0) {\n\t\t\tif (errno == EPIPE)\n\t\t\t\tbreak;\n\t\t\tr = SSH_ERR_SYSTEM_ERROR;\n\t\t\tgoto out;\n\t\t}\n\t\tif ((r = sshbuf_put(blob, buf, len)) != 0)\n\t\t\tgoto out;\n\t\tif (sshbuf_len(blob) > MAX_KEY_FILE_SIZE) {\n\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif ((st.st_mode & (S_IFSOCK|S_IFCHR|S_IFIFO)) == 0 &&\n\t    st.st_size != (off_t)sshbuf_len(blob)) {\n\t\tr = SSH_ERR_FILE_CHANGED;\n\t\tgoto out;\n\t}\n\tr = 0;\n out:\n\texplicit_bzero(buf, sizeof(buf));\n\tif (r != 0)\n\t\tsshbuf_reset(blob);\n\treturn r;\n}", "target": 1}
{"code": "static int ax25_getname(struct socket *sock, struct sockaddr *uaddr,\n\tint *uaddr_len, int peer)\n{\n\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)uaddr;\n\tstruct sock *sk = sock->sk;\n\tunsigned char ndigi, i;\n\tax25_cb *ax25;\n\tint err = 0;\n\tmemset(fsa, 0, sizeof(*fsa));\n\tlock_sock(sk);\n\tax25 = ax25_sk(sk);\n\tif (peer != 0) {\n\t\tif (sk->sk_state != TCP_ESTABLISHED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tgoto out;\n\t\t}\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->dest_addr;\n\t\tif (ax25->digipeat != NULL) {\n\t\t\tndigi = ax25->digipeat->ndigi;\n\t\t\tfsa->fsa_ax25.sax25_ndigis = ndigi;\n\t\t\tfor (i = 0; i < ndigi; i++)\n\t\t\t\tfsa->fsa_digipeater[i] =\n\t\t\t\t\t\tax25->digipeat->calls[i];\n\t\t}\n\t} else {\n\t\tfsa->fsa_ax25.sax25_family = AF_AX25;\n\t\tfsa->fsa_ax25.sax25_call   = ax25->source_addr;\n\t\tfsa->fsa_ax25.sax25_ndigis = 1;\n\t\tif (ax25->ax25_dev != NULL) {\n\t\t\tmemcpy(&fsa->fsa_digipeater[0],\n\t\t\t       ax25->ax25_dev->dev->dev_addr, AX25_ADDR_LEN);\n\t\t} else {\n\t\t\tfsa->fsa_digipeater[0] = null_ax25_address;\n\t\t}\n\t}\n\t*uaddr_len = sizeof (struct full_sockaddr_ax25);\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "bool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n}", "target": 1}
{"code": "static inline int init_new_context(struct task_struct *tsk,\n\t\t\t\t   struct mm_struct *mm)\n{\n\t#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS\n\tif (cpu_feature_enabled(X86_FEATURE_OSPKE)) {\n\t\tmm->context.pkey_allocation_map = 0x1;\n\t\tmm->context.execute_only_pkey = -1;\n\t}\n\t#endif\n\tinit_new_context_ldt(tsk, mm);\n\treturn 0;\n}", "target": 1}
{"code": "__delta_head_destroy(struct delta_head **delta_head)\n{\n\tdelta_head_destroy(*delta_head);\n}", "target": 1}
{"code": "void DetectHttpRequestHeaderRegister(void)\n{\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].name = \"http.request_header\";\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].desc =\n            \"sticky buffer to match on only one HTTP header name and value\";\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].url = \"/rules/http-keywords.html#request_header\";\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].Setup = DetectHTTPRequestHeaderSetup;\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].flags |=\n            SIGMATCH_NOOPT | SIGMATCH_INFO_STICKY_BUFFER;\n    DetectAppLayerMpmRegister2(\"http_request_header\", SIG_FLAG_TOSERVER, 2,\n            PrefilterMpmHttp2HeaderRegister, NULL, ALPROTO_HTTP2, HTTP2StateOpen);\n    DetectAppLayerInspectEngineRegister2(\"http_request_header\", ALPROTO_HTTP2, SIG_FLAG_TOSERVER,\n            HTTP2StateOpen, DetectEngineInspectHttp2Header, NULL);\n    DetectAppLayerMpmRegister2(\"http_request_header\", SIG_FLAG_TOSERVER, 2,\n            PrefilterMpmHttp1HeaderRegister, NULL, ALPROTO_HTTP1, 0);\n    DetectAppLayerInspectEngineRegister2(\"http_request_header\", ALPROTO_HTTP1, SIG_FLAG_TOSERVER,\n            HTP_REQUEST_HEADERS, DetectEngineInspectHttp1Header, NULL);\n    DetectBufferTypeSetDescriptionByName(\"http_request_header\", \"HTTP header name and value\");\n    g_http_request_header_buffer_id = DetectBufferTypeGetByName(\"http_request_header\");\n    DetectBufferTypeSupportsMultiInstance(\"http_request_header\");\n    g_request_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_request_header\",\n            HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);\n}", "target": 0}
{"code": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n\tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\treturn 0;\n}", "target": 1}
{"code": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}", "target": 1}
{"code": "static int raw_cmd_copyin(int cmd, void __user *param,\n\t\t\t\t struct floppy_raw_cmd **rcmd)\n{\n\tstruct floppy_raw_cmd *ptr;\n\tint ret;\n\tint i;\n\t*rcmd = NULL;\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}\n\tif (ptr->flags & FD_RAW_WRITE) {\n\t\tret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ptr->flags & FD_RAW_MORE) {\n\t\trcmd = &(ptr->next);\n\t\tptr->rate &= 0x43;\n\t\tgoto loop;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "xfs_file_splice_write(\n\tstruct pipe_inode_info\t*pipe,\n\tstruct file\t\t*outfilp,\n\tloff_t\t\t\t*ppos,\n\tsize_t\t\t\tcount,\n\tunsigned int\t\tflags)\n{\n\tstruct inode\t\t*inode = outfilp->f_mapping->host;\n\tstruct xfs_inode\t*ip = XFS_I(inode);\n\tint\t\t\tioflags = 0;\n\tssize_t\t\t\tret;\n\tXFS_STATS_INC(xs_write_calls);\n\tif (outfilp->f_mode & FMODE_NOCMTIME)\n\t\tioflags |= IO_INVIS;\n\tif (XFS_FORCED_SHUTDOWN(ip->i_mount))\n\t\treturn -EIO;\n\txfs_ilock(ip, XFS_IOLOCK_EXCL);\n\ttrace_xfs_file_splice_write(ip, count, *ppos, ioflags);\n\tret = generic_file_splice_write(pipe, outfilp, ppos, count, flags);\n\tif (ret > 0)\n\t\tXFS_STATS_ADD(xs_write_bytes, ret);\n\txfs_iunlock(ip, XFS_IOLOCK_EXCL);\n\treturn ret;\n}", "target": 1}
{"code": "static void mpeg4_encode_gop_header(MpegEncContext *s)\n{\n    int hours, minutes, seconds;\n    int64_t time;\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0);  \n    ff_mpeg4_stuffing(&s->pb);\n}", "target": 1}
{"code": "parse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext *ctx = inlink->dst;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    uint32_t plane_checksum[4] = {0}, checksum = 0;\n    int i, plane, vsub = desc->log2_chroma_h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int64_t linesize = av_image_get_linesize(frame->format, frame->width, plane);\n        uint8_t *data = frame->data[plane];\n        int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink->h, vsub) : inlink->h;\n        if (linesize < 0)\n            return linesize;\n        for (i = 0; i < h; i++) {\n            plane_checksum[plane] = av_adler32_update(plane_checksum[plane], data, linesize);\n            checksum = av_adler32_update(checksum, data, linesize);\n            data += frame->linesize[plane];\n        }\n    }\n    av_log(ctx, AV_LOG_INFO,\n           \"n:%\"PRId64\" pts:%s pts_time:%s pos:%\"PRId64\" \"\n           \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \"\n           \"checksum:%08X plane_checksum:[%08X\",\n           inlink->frame_count,\n           av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base), av_frame_get_pkt_pos(frame),\n           desc->name,\n           frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den,\n           frame->width, frame->height,\n           !frame->interlaced_frame ? 'P' :         \n           frame->top_field_first   ? 'T' : 'B',    \n           frame->key_frame,\n           av_get_picture_type_char(frame->pict_type),\n           checksum, plane_checksum[0]);\n    for (plane = 1; plane < 4 && frame->data[plane]; plane++)\n        av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);\n    av_log(ctx, AV_LOG_INFO, \"]\\n\");\n    return ff_filter_frame(inlink->dst->outputs[0], frame);\n}", "target": 1}
{"code": "static int amdgpu_cs_wait_all_fences(struct amdgpu_device *adev,\n\t\t\t\t     struct drm_file *filp,\n\t\t\t\t     union drm_amdgpu_wait_fences *wait,\n\t\t\t\t     struct drm_amdgpu_fence *fences)\n{\n\tuint32_t fence_count = wait->in.fence_count;\n\tunsigned int i;\n\tlong r = 1;\n\tfor (i = 0; i < fence_count; i++) {\n\t\tstruct dma_fence *fence;\n\t\tunsigned long timeout = amdgpu_gem_timeout(wait->in.timeout_ns);\n\t\tfence = amdgpu_cs_get_fence(adev, filp, &fences[i]);\n\t\tif (IS_ERR(fence))\n\t\t\treturn PTR_ERR(fence);\n\t\telse if (!fence)\n\t\t\tcontinue;\n\t\tr = dma_fence_wait_timeout(fence, true, timeout);\n\t\tdma_fence_put(fence);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tif (r == 0)\n\t\t\tbreak;\n\t\tif (fence->error)\n\t\t\treturn fence->error;\n\t}\n\tmemset(wait, 0, sizeof(*wait));\n\twait->out.status = (r > 0);\n\treturn 0;\n}", "target": 1}
{"code": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    end = (start + len) & (target_ulong)(-1);\n    if (start > end) {\n        return;\n    }\n    tb_invalidate_phys_range(uc, start, end);\n}", "target": 1}
{"code": "njs_json_parse(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t             ret;\n    njs_value_t           *text, value, lvalue;\n    const u_char          *p, *end;\n    njs_json_parse_t      *parse, json_parse;\n    const njs_value_t     *reviver;\n    njs_string_prop_t     string;\n    njs_json_parse_ctx_t  ctx;\n    parse = &json_parse;\n    text = njs_lvalue_arg(&lvalue, args, nargs, 1);\n    if (njs_slow_path(!njs_is_string(text))) {\n        ret = njs_value_to_string(vm, text, text);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    (void) njs_string_prop(&string, text);\n    p = string.start;\n    end = p + string.size;\n    ctx.vm = vm;\n    ctx.pool = vm->mem_pool;\n    ctx.depth = NJS_JSON_MAX_DEPTH;\n    ctx.start = string.start;\n    ctx.end = end;\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p == end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected end of input\", p);\n        return NJS_ERROR;\n    }\n    p = njs_json_parse_value(&ctx, &value, p);\n    if (njs_slow_path(p == NULL)) {\n        return NJS_ERROR;\n    }\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p != end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected token\", p);\n        return NJS_ERROR;\n    }\n    reviver = njs_arg(args, nargs, 2);\n    if (njs_slow_path(njs_is_function(reviver) && njs_is_object(&value))) {\n        parse->function = njs_function(reviver);\n        parse->depth = 0;\n        return njs_json_parse_iterator(vm, parse, &value);\n    }\n    vm->retval = value;\n    return NJS_OK;\n}", "target": 1}
{"code": "void mp_encode_lua_table_as_map(lua_State *L, mp_buf *buf, int level) {\n    size_t len = 0;\n    luaL_checkstack(L, 3, \"in function mp_encode_lua_table_as_map\");\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pop(L,1); \n        len++;\n    }\n    mp_encode_map(L,buf,len);\n    lua_pushnil(L);\n    while(lua_next(L,-2)) {\n        lua_pushvalue(L,-2); \n        mp_encode_lua_type(L,buf,level+1); \n        mp_encode_lua_type(L,buf,level+1); \n    }\n}", "target": 0}
{"code": "USHORT CNB::QueryL4HeaderOffset(PVOID PacketData, ULONG IpHeaderOffset) const\n{\n    USHORT Res;\n    auto ppr = ParaNdis_ReviewIPPacket(RtlOffsetToPointer(PacketData, IpHeaderOffset),\n                                       GetDataLength(), __FUNCTION__);\n    if (ppr.ipStatus != ppresNotIP)\n    {\n        Res = static_cast<USHORT>(IpHeaderOffset + ppr.ipHeaderSize);\n    }\n    else\n    {\n        DPrintf(0, (\"[%s] ERROR: NOT an IP packet - expected troubles!\\n\", __FUNCTION__));\n        Res = 0;\n    }\n    return Res;\n}", "target": 1}
{"code": "void unix_notinflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tspin_lock(&unix_gc_lock);\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\t\tBUG_ON(list_empty(&u->link));\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tuser->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}", "target": 0}
{"code": "static bool check_client_passwd(PgSocket *client, const char *passwd)\n{\n\tchar md5[MD5_PASSWD_LEN + 1];\n\tconst char *correct;\n\tPgUser *user = client->auth_user;\n\tif (!user) {\n\t\tslog_error(client, \"Password packet before auth packet?\");\n\t\treturn false;\n\t}\n\tif (!*passwd || !*user->passwd)\n\t\treturn false;\n\tswitch (cf_auth_type) {\n\tcase AUTH_PLAIN:\n\t\treturn strcmp(user->passwd, passwd) == 0;\n\tcase AUTH_CRYPT:\n\t\tcorrect = crypt(user->passwd, (char *)client->tmp_login_salt);\n\t\treturn correct && strcmp(correct, passwd) == 0;\n\tcase AUTH_MD5:\n\t\tif (strlen(passwd) != MD5_PASSWD_LEN)\n\t\t\treturn false;\n\t\tif (!isMD5(user->passwd))\n\t\t\tpg_md5_encrypt(user->passwd, user->name, strlen(user->name), user->passwd);\n\t\tpg_md5_encrypt(user->passwd + 3, (char *)client->tmp_login_salt, 4, md5);\n\t\treturn strcmp(md5, passwd) == 0;\n\t}\n\treturn false;\n}", "target": 0}
{"code": "int smb2_tree_disconnect(struct ksmbd_work *work)\n{\n\tstruct smb2_tree_disconnect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\tksmbd_debug(SMB, \"request\\n\");\n\tif (!tcon) {\n\t\tstruct smb2_tree_disconnect_req *req =\n\t\t\tsmb2_get_msg(work->request_buf);\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\tksmbd_close_tree_conn_fds(work);\n\tksmbd_tree_conn_disconnect(sess, tcon);\n\twork->tcon = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "mysql_stmt_prepare(MYSQL_STMT *stmt, const char *query, ulong length)\n{\n  MYSQL *mysql= stmt->mysql;\n  DBUG_ENTER(\"mysql_stmt_prepare\");\n  if (!mysql)\n  {\n    set_stmt_error(stmt, CR_SERVER_LOST, unknown_sqlstate, NULL);\n    DBUG_RETURN(1);\n  }\n  stmt->last_errno= 0;\n  stmt->last_error[0]= '\\0';\n  if ((int) stmt->state > (int) MYSQL_STMT_INIT_DONE)\n  {\n    uchar buff[MYSQL_STMT_HEADER];               \n    if (reset_stmt_handle(stmt, RESET_LONG_DATA | RESET_STORE_RESULT))\n      DBUG_RETURN(1);\n    stmt->bind_param_done= stmt->bind_result_done= FALSE;\n    stmt->param_count= stmt->field_count= 0;\n    free_root(&stmt->mem_root, MYF(MY_KEEP_PREALLOC));\n    free_root(&stmt->extension->fields_mem_root, MYF(0));\n    int4store(buff, stmt->stmt_id);\n    stmt->state= MYSQL_STMT_INIT_DONE;\n    if (stmt_command(mysql, COM_STMT_CLOSE, buff, 4, stmt))\n    {\n      set_stmt_errmsg(stmt, &mysql->net);\n      DBUG_RETURN(1);\n    }\n  }\n  if (stmt_command(mysql, COM_STMT_PREPARE, (const uchar*) query, length, stmt))\n  {\n    set_stmt_errmsg(stmt, &mysql->net);\n    DBUG_RETURN(1);\n  }\n  if ((*mysql->methods->read_prepare_result)(mysql, stmt))\n  {\n    set_stmt_errmsg(stmt, &mysql->net);\n    DBUG_RETURN(1);\n  }\n  if (!(stmt->params= (MYSQL_BIND *) alloc_root(&stmt->mem_root,\n\t\t\t\t\t\tsizeof(MYSQL_BIND)*\n                                                (stmt->param_count +\n                                                 stmt->field_count))))\n  {\n    set_stmt_error(stmt, CR_OUT_OF_MEMORY, unknown_sqlstate, NULL);\n    DBUG_RETURN(1);\n  }\n  stmt->bind= stmt->params + stmt->param_count;\n  stmt->state= MYSQL_STMT_PREPARE_DONE;\n  DBUG_PRINT(\"info\", (\"Parameter count: %u\", stmt->param_count));\n  DBUG_RETURN(0);\n}", "target": 0}
{"code": "load_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }\n  start = modules_data;\n  while (TRUE)\n    {\n      end = strchr (start, ' ');\n      if (end == NULL)\n        break;\n      g_hash_table_add (modules, g_strndup (start, (end - start)));\n      start = strchr (end, '\\n');\n      if (start == NULL)\n        break;\n      start++;\n    }\n  return modules;\n}", "target": 1}
{"code": "static inline void vmacache_invalidate(struct mm_struct *mm)\n{\n\tmm->vmacache_seqnum++;\n\tif (unlikely(mm->vmacache_seqnum == 0))\n\t\tvmacache_flush_all(mm);\n}", "target": 1}
{"code": "new_unencoding_writer(struct Curl_easy *data,\n                      const struct content_encoding *handler,\n                      struct contenc_writer *downstream)\n{\n  size_t sz = offsetof(struct contenc_writer, params) + handler->paramsize;\n  struct contenc_writer *writer = (struct contenc_writer *)calloc(1, sz);\n  if(writer) {\n    writer->handler = handler;\n    writer->downstream = downstream;\n    if(handler->init_writer(data, writer)) {\n      free(writer);\n      writer = NULL;\n    }\n  }\n  return writer;\n}", "target": 0}
{"code": "bool LinksToDirs(const wchar *SrcName,const wchar *SkipPart,std::wstring &LastChecked)\n{\n  wchar Path[NM];\n  if (wcslen(SrcName)>=ASIZE(Path))\n    return false;  \n  wcsncpyz(Path,SrcName,ASIZE(Path));\n  size_t SkipLength=wcslen(SkipPart);\n  if (SkipLength>0 && wcsncmp(Path,SkipPart,SkipLength)!=0)\n    SkipLength=0; \n  for (uint I=0;Path[I]!=0 && I<LastChecked.size() && Path[I]==LastChecked[I];I++)\n    if (IsPathDiv(Path[I]) && I>SkipLength)\n      SkipLength=I;\n  wchar *Name=Path;\n  if (SkipLength>0)\n  {\n    Name+=SkipLength;\n    while (IsPathDiv(*Name))\n      Name++;\n  }\n  for (wchar *s=Path+wcslen(Path)-1;s>Name;s--)\n    if (IsPathDiv(*s))\n    {\n      *s=0;\n      FindData FD;\n      if (FindFile::FastFind(Path,&FD,true) && FD.IsLink)\n#ifdef _WIN_ALL\n        if (!DelDir(Path))\n#else\n        if (!DelFile(Path))\n#endif\n          return false; \n    }\n  LastChecked=SrcName;\n  return true;\n}", "target": 0}
{"code": "hb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->invert ();\n}", "target": 1}
{"code": "void CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = s;\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "bool TensorSliceReader::CopySliceData(const string& name,\n                                      const TensorSlice& slice, T* data) const {\n  std::vector<std::pair<TensorSlice, string>> details;\n  const TensorSliceSet* tss;\n  {\n    mutex_lock l(mu_);\n    tss = FindTensorSlice(name, slice, &details);\n    if (!tss && !all_shards_loaded_) {\n      VLOG(1) << \"Did not find slice in preferred shard, loading all shards.\"\n              << name << \": \" << slice.DebugString();\n      LoadAllShards();\n      tss = FindTensorSlice(name, slice, &details);\n    }\n    if (!tss) {\n      return false;\n    }\n  }\n  string value;\n  for (const auto& x : details) {\n    const TensorSlice& slice_s = x.first;\n    const string& fname = x.second;\n    int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);\n    CHECK_GE(idx, 0) << \"Failed to find the index for filename \" << fname;\n    const string key = EncodeTensorNameSlice(name, slice_s);\n    if (!sss_[idx]->Get(key, &value)) {\n      VLOG(1) << \"Failed to seek to the record for tensor \" << name\n              << \", slice \" << slice_s.DebugString()\n              << \": computed key = \" << key;\n      return false;\n    }\n    SavedTensorSlices sts;\n    if (!ParseProtoUnlimited(&sts, value)) {\n      VLOG(1) << \"Failed to parse the record for tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": computed key = \" << key;\n      return false;\n    }\n    TensorShape shp_s;\n    Status s = slice_s.SliceTensorShape(tss->shape(), &shp_s);\n    if (!s.ok()) {\n      VLOG(1) << \"Failed to slice tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": \" << s;\n      return false;\n    }\n    if (checkpoint::TensorProtoDataSize<T>(sts.data().data()) !=\n        shp_s.num_elements()) {\n      VLOG(1) << \"Tensor \" << name << \", slice \" << slice_s.DebugString()\n              << \" had an unexpected amount of data: expected = \"\n              << shp_s.num_elements() << \", got = \"\n              << checkpoint::TensorProtoDataSize<T>(sts.data().data());\n      return false;\n    }\n    CopyDataFromTensorSliceToTensorSlice(\n        tss->shape(), slice_s, slice,\n        checkpoint::TensorProtoData<T>(sts.data().data()), data);\n  }\n  return true;\n}", "target": 0}
{"code": "int sub__add(struct mosquitto *context, const char *sub, uint8_t qos, uint32_t identifier, int options)\n{\n\tint rc = 0;\n\tstruct mosquitto__subhier *subhier;\n\tconst char *sharename = NULL;\n\tchar *local_sub;\n\tchar **topics;\n\tsize_t topiclen;\n\tassert(sub);\n\trc = sub__topic_tokenise(sub, &local_sub, &topics, &sharename);\n\tif(rc) return rc;\n\ttopiclen = strlen(topics[0]);\n\tif(topiclen > UINT16_MAX){\n\t\tmosquitto__free(local_sub);\n\t\tmosquitto__free(topics);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\tHASH_FIND(hh, db.subs, topics[0], topiclen, subhier);\n\tif(!subhier){\n\t\tsubhier = sub__add_hier_entry(NULL, &db.subs, topics[0], (uint16_t)topiclen);\n\t\tif(!subhier){\n\t\t\tmosquitto__free(local_sub);\n\t\t\tmosquitto__free(topics);\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n\trc = sub__add_context(context, sub, qos, identifier, options, subhier, topics, sharename);\n\tmosquitto__free(local_sub);\n\tmosquitto__free(topics);\n\treturn rc;\n}", "target": 1}
{"code": "void SFS_ObjectMemberAccess(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \".\");\n\tSFS_Identifier(parser);\n}", "target": 0}
{"code": "static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tfault_in_pages_readable(iov->iov_base, this_len);\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n}", "target": 1}
{"code": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\tat91_aes_init();\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\treturn rc;\n}", "target": 1}
{"code": "ins_ctrl_hat(void)\n{\n    if (map_to_exists_mode((char_u *)\"\", LANGMAP, FALSE))\n    {\n\tif (State & LANGMAP)\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    State &= ~LANGMAP;\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_LMAP;\n\t    State |= LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\t    im_set_active(FALSE);\n#endif\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\tif (im_get_status())\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    im_set_active(FALSE);\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_IM;\n\t    State &= ~LANGMAP;\n\t    im_set_active(TRUE);\n\t}\n    }\n#endif\n    set_iminsert_global();\n    showmode();\n#ifdef FEAT_GUI\n    if (gui.in_use)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n#if defined(FEAT_KEYMAP)\n    status_redraw_curbuf();\n#endif\n}", "target": 0}
{"code": "_defbackend_gen_returntext(char *buffer, size_t buflen, char **dns)\n{\n    int dnidx;\n    int sidx;\n    struct suffix_repeat {\n        char *suffix;\n        int size;\n    } candidates[] = {\n        {\"dc=\", 3}, \n        {NULL, 0}\n    };\n    PR_snprintf(buffer, buflen, \"%s (\", DEFBE_NO_SUCH_SUFFIX);\n    for (dnidx = 0; dns[dnidx]; dnidx++) ; \n    dnidx--; \n    for (sidx = 0; candidates[sidx].suffix; sidx++) {\n        if (!PL_strncasecmp(dns[dnidx], candidates[sidx].suffix, candidates[sidx].size)) {\n            while (!PL_strncasecmp(dns[--dnidx], candidates[sidx].suffix, candidates[sidx].size)) ;\n            PL_strcat(buffer, dns[++dnidx]); \n            for (++dnidx; dns[dnidx]; dnidx++) {\n                PL_strcat(buffer, \",\");\n                PL_strcat(buffer, dns[dnidx]);\n            }\n            PL_strcat(buffer, \")\");\n            return; \n        }\n    }\n    PL_strcat(buffer, dns[dnidx]);\n    PL_strcat(buffer, \")\");\n    return;\n}", "target": 0}
{"code": "int insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tif (v8086_mode(regs))\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (!(desc->type & BIT(3)))\n\t\treturn -EINVAL;\n\tswitch ((desc->l << 1) | desc->d) {\n\tcase 0: \n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: \n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: \n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "static void save_text_if_changed(const char *name, const char *new_value)\n{\n    if (!g_hash_table_lookup(g_loaded_texts, name))\n        return;\n    const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : \"\";\n    if (!old_value)\n        old_value = \"\";\n    if (strcmp(new_value, old_value) != 0)\n    {\n        struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);\n        if (dd)\n            dd_save_text(dd, name, new_value);\n        dd_close(dd);\n        problem_data_reload_from_dump_dir();\n        update_gui_state_from_problem_data( 0);\n    }\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    DelogoContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    AVFrame *out;\n    int hsub0 = desc->log2_chroma_w;\n    int vsub0 = desc->log2_chroma_h;\n    int direct = 0;\n    int plane;\n    AVRational sar;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    sar = in->sample_aspect_ratio;\n    if (!sar.num)\n        sar.num = sar.den = 1;\n    for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n        int hsub = plane == 1 || plane == 2 ? hsub0 : 0;\n        int vsub = plane == 1 || plane == 2 ? vsub0 : 0;\n        apply_delogo(out->data[plane], out->linesize[plane],\n                     in ->data[plane], in ->linesize[plane],\n                     FF_CEIL_RSHIFT(inlink->w, hsub),\n                     FF_CEIL_RSHIFT(inlink->h, vsub),\n                     sar, s->x>>hsub, s->y>>vsub,\n                     FF_CEIL_RSHIFT(s->w + (s->x & ((1<<hsub)-1)), hsub),\n                     FF_CEIL_RSHIFT(s->h + (s->y & ((1<<vsub)-1)), vsub),\n                     s->band>>FFMIN(hsub, vsub),\n                     s->show, direct);\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "static int _kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[dr];\n\t\tbreak;\n\tcase 4:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tcase 6:\n\t\t*val = vcpu->arch.dr6;\n\t\tbreak;\n\tcase 5:\n\t\tif (kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\t\treturn 1;\n\tdefault: \n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void dwc3_gadget_del_and_unmap_request(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, int status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\treq->started = false;\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t&req->request, req->direction);\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}", "target": 0}
{"code": "int mongo_env_write_socket( mongo *conn, const void *buf, int len ) {\n    const char *cbuf = buf;\n    int flags = 0;\n    while ( len ) {\n        int sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            conn->connected = 0;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n    return MONGO_OK;\n}", "target": 1}
{"code": "QList<QList<QByteArray>> CoreNetwork::splitMessage(const QString &cmd, const QString &message, std::function<QList<QByteArray>(QString &)> cmdGenerator)\n{\n    QString wrkMsg(message);\n    QList<QList<QByteArray>> msgsToSend;\n    do {\n        int splitPos = wrkMsg.size();\n        QList<QByteArray> initialSplitMsgEnc = cmdGenerator(wrkMsg);\n        int initialOverrun = userInputHandler()->lastParamOverrun(cmd, initialSplitMsgEnc);\n        if (initialOverrun) {\n            QString splitMsg(wrkMsg);\n            QTextBoundaryFinder qtbf(QTextBoundaryFinder::Word, splitMsg);\n            qtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n            QList<QByteArray> splitMsgEnc;\n            int overrun = initialOverrun;\n            while (overrun) {\n                splitPos = qtbf.toPreviousBoundary();\n                if (splitPos > 0) {\n                    splitMsg = splitMsg.left(splitPos);\n                    splitMsgEnc = cmdGenerator(splitMsg);\n                    overrun = userInputHandler()->lastParamOverrun(cmd, splitMsgEnc);\n                }\n                else {\n                    if (qtbf.type() == QTextBoundaryFinder::Word) {\n                        splitMsg = wrkMsg;\n                        splitPos = splitMsg.size();\n                        QTextBoundaryFinder graphemeQtbf(QTextBoundaryFinder::Grapheme, splitMsg);\n                        graphemeQtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n                        qtbf = graphemeQtbf;\n                    }\n                    else {\n                        qWarning() << \"Unexpected failure to split message!\";\n                        return msgsToSend;\n                    }\n                }\n            }\n            wrkMsg.remove(0, splitPos);\n            msgsToSend.append(splitMsgEnc);\n        }\n        else{\n            wrkMsg.remove(0, splitPos);\n            msgsToSend.append(initialSplitMsgEnc);\n        }\n    } while (wrkMsg.size() > 0);\n    return msgsToSend;\n}", "target": 0}
{"code": "static void bnx2x_hw_enable_status(struct bnx2x *bp)\n{\n\tu32 val;\n\tval = REG_RD(bp, CFC_REG_WEAK_ENABLE_PF);\n\tDP(BNX2X_MSG_SP, \"CFC_REG_WEAK_ENABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, PBF_REG_DISABLE_PF);\n\tDP(BNX2X_MSG_SP, \"PBF_REG_DISABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSI_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSI_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_FUNC_MASK);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_FUNC_MASK is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER is 0x%x\\n\",\n\t   val);\n}", "target": 0}
{"code": "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\tepi->nwait = -1;\n\t}\n}", "target": 0}
{"code": "ProcXkbBell(ClientPtr client)\n{\n    REQUEST(xkbBellReq);\n    DeviceIntPtr dev;\n    WindowPtr\t pWin;\n    int rc;\n    REQUEST_SIZE_MATCH(xkbBellReq);\n    if (!(client->xkbClientFlags&_XkbClientInitialized))\n\treturn BadAccess;\n    CHK_BELL_DEVICE(dev, stuff->deviceSpec, client, DixBellAccess);\n    CHK_ATOM_OR_NONE(stuff->name);\n    if ((stuff->forceSound)&&(stuff->eventOnly)) {\n\tclient->errorValue=_XkbErrCode3(0x1,stuff->forceSound,stuff->eventOnly);\n\treturn BadMatch;\n    }\n    if (stuff->percent < -100 || stuff->percent > 100) {\n\tclient->errorValue = _XkbErrCode2(0x2,stuff->percent);\n\treturn BadValue;\n    }\n    if (stuff->duration<-1) {\n\tclient->errorValue = _XkbErrCode2(0x3,stuff->duration);\n\treturn BadValue;\n    }\n    if (stuff->pitch<-1) {\n\tclient->errorValue = _XkbErrCode2(0x4,stuff->pitch);\n\treturn BadValue;\n    }\n    if (stuff->bellClass == XkbDfltXIClass) {\n\tif (dev->kbdfeed!=NULL)\n\t     stuff->bellClass= KbdFeedbackClass;\n\telse stuff->bellClass= BellFeedbackClass;\n    }\n    if (stuff->window!=None) {\n\trc = dixLookupWindow(&pWin, stuff->window, client, DixGetAttrAccess);\n\tif (rc != Success) {\n\t    client->errorValue= stuff->window;\n\t    return rc;\n\t}\n    }\n    else pWin= NULL;\n    rc = _XkbBell(client, dev, pWin, stuff->bellClass, stuff->bellID,\n                  stuff->pitch, stuff->duration, stuff->percent,\n                  stuff->forceSound, stuff->eventOnly, stuff->name);\n    if ((rc == Success) && ((stuff->deviceSpec == XkbUseCoreKbd) ||\n                            (stuff->deviceSpec == XkbUseCorePtr)))\n    {\n        DeviceIntPtr other;\n        for (other = inputInfo.devices; other; other = other->next)\n        {\n            if ((other != dev) && other->key && !other->isMaster && (other->u.master == dev))\n            {\n                rc = XaceHook(XACE_DEVICE_ACCESS, client, other, DixBellAccess);\n                if (rc == Success)\n                    _XkbBell(client, other, pWin, stuff->bellClass,\n                             stuff->bellID, stuff->pitch, stuff->duration,\n                             stuff->percent, stuff->forceSound,\n                             stuff->eventOnly, stuff->name);\n            }\n        }\n        rc = Success; \n    }\n    return rc;\n}", "target": 0}
{"code": "void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)\n{\n\tstruct snd_pcm_runtime *runtime;\n\tunsigned long flags;\n\tif (PCM_RUNTIME_CHECK(substream))\n\t\treturn;\n\truntime = substream->runtime;\n\tsnd_pcm_stream_lock_irqsave(substream, flags);\n\tif (!snd_pcm_running(substream) ||\n\t    snd_pcm_update_hw_ptr0(substream, 1) < 0)\n\t\tgoto _end;\n#ifdef CONFIG_SND_PCM_TIMER\n\tif (substream->timer_running)\n\t\tsnd_timer_interrupt(substream->timer, 1);\n#endif\n _end:\n\tsnd_pcm_stream_unlock_irqrestore(substream, flags);\n\tkill_fasync(&runtime->fasync, SIGIO, POLL_IN);\n}", "target": 1}
{"code": "  inline Eigen::IndexList<Eigen::type2index<1>, int> OneByM(int m) {\n    Eigen::IndexList<Eigen::type2index<1>, int> ret;\n    ret.set(1, m);\n    return ret;\n  }", "target": 1}
{"code": "static int do_cmd (xd3_stream *stream, const char *buf)\n{\n  int ret;\n  if ((ret = system (buf)) != 0)\n    {\n      if (WIFEXITED (ret))\n\t{\n\t  stream->msg = \"command exited non-zero\";\n\t  IF_DEBUG1 (XPR(NT \"command was: %s\\n\", buf));\n\t}\n      else\n\t{\n\t  stream->msg = \"abnormal command termination\";\n\t}\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 1}
{"code": "njs_function_capture_closure(njs_vm_t *vm, njs_function_t *function,\n    njs_function_lambda_t *lambda)\n{\n    void                *start, *end;\n    uint32_t            n;\n    njs_value_t         *value, **closure;\n    njs_native_frame_t  *frame;\n    if (lambda->nclosures == 0) {\n        return NJS_OK;\n    }\n    frame = &vm->active_frame->native;\n    while (frame->native) {\n        frame = frame->previous;\n    }\n    start = frame;\n    end = frame->free;\n    closure = njs_function_closures(function);\n    n = lambda->nclosures;\n    do {\n        n--;\n        value = njs_scope_value(vm, lambda->closures[n]);\n        if (start <= (void *) value && (void *) value < end) {\n            value = njs_scope_value_clone(vm, lambda->closures[n], value);\n            if (njs_slow_path(value == NULL)) {\n                return NJS_ERROR;\n            }\n        }\n        closure[n] = value;\n    } while (n != 0);\n    return NJS_OK;\n}", "target": 0}
{"code": "static void kvm_steal_time_set_preempted(struct kvm_vcpu *vcpu)\n{\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.st.cache;\n\tstruct kvm_steal_time __user *st;\n\tstruct kvm_memslots *slots;\n\tstatic const u8 preempted = KVM_VCPU_PREEMPTED;\n\tif (!vcpu->arch.at_instruction_boundary) {\n\t\tvcpu->stat.preemption_other++;\n\t\treturn;\n\t}\n\tvcpu->stat.preemption_reported++;\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\tif (vcpu->arch.st.preempted)\n\t\treturn;\n\tif (unlikely(current->mm != vcpu->kvm->mm))\n\t\treturn;\n\tslots = kvm_memslots(vcpu->kvm);\n\tif (unlikely(slots->generation != ghc->generation ||\n\t\t     kvm_is_error_hva(ghc->hva) || !ghc->memslot))\n\t\treturn;\n\tst = (struct kvm_steal_time __user *)ghc->hva;\n\tBUILD_BUG_ON(sizeof(st->preempted) != sizeof(preempted));\n\tif (!copy_to_user_nofault(&st->preempted, &preempted, sizeof(preempted)))\n\t\tvcpu->arch.st.preempted = KVM_VCPU_PREEMPTED;\n\tmark_page_dirty_in_slot(vcpu->kvm, ghc->memslot, gpa_to_gfn(ghc->gpa));\n}", "target": 0}
{"code": "static int cma_bind_loopback(struct rdma_id_private *id_priv)\n{\n\tstruct cma_device *cma_dev, *cur_dev;\n\tunion ib_gid gid;\n\tenum ib_port_state port_state;\n\tunsigned int p;\n\tu16 pkey;\n\tint ret;\n\tcma_dev = NULL;\n\tmutex_lock(&lock);\n\tlist_for_each_entry(cur_dev, &dev_list, list) {\n\t\tif (cma_family(id_priv) == AF_IB &&\n\t\t    !rdma_cap_ib_cm(cur_dev->device, 1))\n\t\t\tcontinue;\n\t\tif (!cma_dev)\n\t\t\tcma_dev = cur_dev;\n\t\trdma_for_each_port (cur_dev->device, p) {\n\t\t\tif (!ib_get_cached_port_state(cur_dev->device, p, &port_state) &&\n\t\t\t    port_state == IB_PORT_ACTIVE) {\n\t\t\t\tcma_dev = cur_dev;\n\t\t\t\tgoto port_found;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cma_dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tp = 1;\nport_found:\n\tret = rdma_query_gid(cma_dev->device, p, 0, &gid);\n\tif (ret)\n\t\tgoto out;\n\tret = ib_get_cached_pkey(cma_dev->device, p, 0, &pkey);\n\tif (ret)\n\t\tgoto out;\n\tid_priv->id.route.addr.dev_addr.dev_type =\n\t\t(rdma_protocol_ib(cma_dev->device, p)) ?\n\t\tARPHRD_INFINIBAND : ARPHRD_ETHER;\n\trdma_addr_set_sgid(&id_priv->id.route.addr.dev_addr, &gid);\n\tib_addr_set_pkey(&id_priv->id.route.addr.dev_addr, pkey);\n\tid_priv->id.port_num = p;\n\tcma_attach_to_dev(id_priv, cma_dev);\n\trdma_restrack_add(&id_priv->res);\n\tcma_set_loopback(cma_src_addr(id_priv));\nout:\n\tmutex_unlock(&lock);\n\treturn ret;\n}", "target": 0}
{"code": "int sock_initaddress(const char *host, const char *port,\n    struct addrinfo *hints, struct addrinfo **addrinfo, char *errbuf, int errbuflen)\n{\n\tint retval;\n\tretval = getaddrinfo(host, port == NULL ? \"0\" : port, hints, addrinfo);\n\tif (retval != 0)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tif (host != NULL && port != NULL) {\n\t\t\t\tint try_retval;\n\t\t\t\ttry_retval = getaddrinfo(host, NULL, hints,\n\t\t\t\t    addrinfo);\n\t\t\t\tif (try_retval == 0) {\n\t\t\t\t\tfreeaddrinfo(*addrinfo);\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, NULL, port);\n\t\t\t\t} else {\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, host, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tget_gai_errstring(errbuf, errbuflen, \"\",\n\t\t\t\t    retval, host, port);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_family != PF_INET) &&\n\t    ((*addrinfo)->ai_family != PF_INET6))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): socket type not supported\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_socktype == SOCK_STREAM) &&\n\t    (sock_ismcastaddr((*addrinfo)->ai_addr) == 0))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): multicast addresses are not valid when using TCP streams\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void rose_timer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, timer);\n\tstruct sock *sk = &rose->sock;\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_1:\t\n\tcase ROSE_STATE_4:\t\n\t\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\t\trose->state = ROSE_STATE_2;\n\t\trose_start_t3timer(sk);\n\t\tbreak;\n\tcase ROSE_STATE_2:\t\n\t\trose->neighbour->use--;\n\t\trose_disconnect(sk, ETIMEDOUT, -1, -1);\n\t\tbreak;\n\tcase ROSE_STATE_3:\t\n\t\tif (rose->condition & ROSE_COND_ACK_PENDING) {\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose_enquiry_response(sk);\n\t\t}\n\t\tbreak;\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "inline typename V::VectorType FBUnserializer<V>::unserializeVector() {\n  p_ += CODE_SIZE;\n  typename V::VectorType ret = V::createVector();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "static HashTable* spl_array_get_debug_info(zval *obj, int *is_temp TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(obj TSRMLS_CC);\n\tzval *tmp, *storage;\n\tint name_len;\n\tchar *zname;\n\tzend_class_entry *base;\n\t*is_temp = 0;\n\tif (!intern->std.properties) {\n\t\trebuild_object_properties(&intern->std);\n\t}\n\tif (HASH_OF(intern->array) == intern->std.properties) {\n\t\treturn intern->std.properties;\n\t} else {\n\t\tif (intern->debug_info == NULL) {\n\t\t\tALLOC_HASHTABLE(intern->debug_info);\n\t\t\tZEND_INIT_SYMTABLE_EX(intern->debug_info, zend_hash_num_elements(intern->std.properties) + 1, 0);\n\t\t}\n\t\tif (intern->debug_info->nApplyCount == 0) {\n\t\t\tzend_hash_clean(intern->debug_info);\n\t\t\tzend_hash_copy(intern->debug_info, intern->std.properties, (copy_ctor_func_t) zval_add_ref, (void *) &tmp, sizeof(zval *));\n\t\t\tstorage = intern->array;\n\t\t\tzval_add_ref(&storage);\n\t\t\tbase = (Z_OBJ_HT_P(obj) == &spl_handler_ArrayIterator) ? spl_ce_ArrayIterator : spl_ce_ArrayObject;\n\t\t\tzname = spl_gen_private_prop_name(base, \"storage\", sizeof(\"storage\")-1, &name_len TSRMLS_CC);\n\t\t\tzend_symtable_update(intern->debug_info, zname, name_len+1, &storage, sizeof(zval *), NULL);\n\t\t\tefree(zname);\n\t\t}\n\t\treturn intern->debug_info;\n\t}\n}", "target": 0}
{"code": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\ttrap = lock_rename(new_dir, old_dir);\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}", "target": 1}
{"code": "static int adpt_close(struct inode *inode, struct file *file)\n{\n\tint minor;\n\tadpt_hba* pHba;\n\tminor = iminor(inode);\n\tif (minor >= hba_count) {\n\t\treturn -ENXIO;\n\t}\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->unit == minor) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tmutex_unlock(&adpt_configuration_lock);\n\tif (pHba == NULL) {\n\t\treturn -ENXIO;\n\t}\n\tpHba->in_use = 0;\n\treturn 0;\n}", "target": 1}
{"code": "DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,\n                           UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,\n                           UINT32 FileAttributes, UINT32 SharedAccess)\n{\n\tDRIVE_FILE* file;\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\tfile = (DRIVE_FILE*)calloc(1, sizeof(DRIVE_FILE));\n\tif (!file)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn NULL;\n\t}\n\tfile->file_handle = INVALID_HANDLE_VALUE;\n\tfile->find_handle = INVALID_HANDLE_VALUE;\n\tfile->id = id;\n\tfile->basepath = base_path;\n\tfile->FileAttributes = FileAttributes;\n\tfile->DesiredAccess = DesiredAccess;\n\tfile->CreateDisposition = CreateDisposition;\n\tfile->CreateOptions = CreateOptions;\n\tfile->SharedAccess = SharedAccess;\n\tdrive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathLength));\n\tif (!drive_file_init(file))\n\t{\n\t\tDWORD lastError = GetLastError();\n\t\tdrive_file_free(file);\n\t\tSetLastError(lastError);\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 1}
{"code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n    ld->bytes_left = ld->buffer_size - words*4;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n    ld->error = 0;\n}", "target": 1}
{"code": "p2la(UINT8 *out, const UINT8 *in, int xsize, const UINT8 *palette) {\n    int x;\n    for (x = 0; x < xsize; x++, out += 4) {\n        const UINT8 *rgba = &palette[*in++ * 4];\n        out[0] = out[1] = out[2] = L(rgba) / 1000;\n        out[3] = rgba[3];\n    }\n}", "target": 0}
{"code": "bit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\treturn result;\n}", "target": 0}
{"code": "int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\treturn err;\n}", "target": 1}
{"code": "skipString(const xmlChar *cur, int end) {\n    xmlChar limit;\n    if ((cur == NULL) || (end < 0)) return(-1);\n    if ((cur[end] == '\\'') || (cur[end] == '\"')) limit = cur[end];\n    else return(end);\n    end++;\n    while (cur[end] != 0) {\n        if (cur[end] == limit)\n\t    return(end + 1);\n\tend++;\n    }\n    return(-1);\n}", "target": 0}
{"code": "static inline int domain_pfn_mapping(struct dmar_domain *domain, unsigned long iov_pfn,\n\t\t\t\t     unsigned long phys_pfn, unsigned long nr_pages,\n\t\t\t\t     int prot)\n{\n\treturn domain_mapping(domain, iov_pfn, NULL, phys_pfn, nr_pages, prot);\n}", "target": 0}
{"code": "static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static int linear_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct linear_c *lc = (struct linear_c *) ti->private;\n\treturn __blkdev_driver_ioctl(lc->dev->bdev, lc->dev->mode, cmd, arg);\n}", "target": 1}
{"code": "makeDirTree(const string &path, const StaticString &mode, uid_t owner, gid_t group) {\n\tstruct stat buf;\n\tvector<string> paths;\n\tvector<string>::reverse_iterator rit;\n\tstring current = path;\n\tmode_t modeBits;\n\tint ret;\n\tif (stat(path.c_str(), &buf) == 0) {\n\t\treturn;\n\t}\n\tmodeBits = parseModeString(mode);\n\twhile (current != \"/\" && current != \".\" && getFileType(current) == FT_NONEXISTANT) {\n\t\tpaths.push_back(current);\n\t\tcurrent = extractDirName(current);\n\t}\n\tfor (rit = paths.rbegin(); rit != paths.rend(); rit++) {\n\t\tcurrent = *rit;\n\t\tdo {\n\t\t\tret = mkdir(current.c_str(), modeBits);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EEXIST) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tint e = errno;\n\t\t\t\tthrow FileSystemException(\"Cannot create directory '\" + current + \"'\",\n\t\t\t\t\te, current);\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tret = chmod(current.c_str(), modeBits);\n\t\t} while (ret == -1 && errno == EINTR);\n\t\tif (owner != USER_NOT_GIVEN && group != GROUP_NOT_GIVEN) {\n\t\t\tif (owner == USER_NOT_GIVEN) {\n\t\t\t\towner = (uid_t) -1; \n\t\t\t}\n\t\t\tif (group == GROUP_NOT_GIVEN) {\n\t\t\t\tgroup = (gid_t) -1; \n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = chown(current.c_str(), owner, group);\n\t\t\t} while (ret == -1 && errno == EINTR);\n\t\t\tif (ret == -1) {\n\t\t\t\tchar message[1024];\n\t\t\t\tint e = errno;\n\t\t\t\tsnprintf(message, sizeof(message) - 1,\n\t\t\t\t\t\"Cannot change the directory '%s' its UID to %lld and GID to %lld\",\n\t\t\t\t\tcurrent.c_str(), (long long) owner, (long long) group);\n\t\t\t\tmessage[sizeof(message) - 1] = '\\0';\n\t\t\t\tthrow FileSystemException(message, e, path);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    OP_REQUIRES(context, out_backprop.dims() == 5,\n                errors::InvalidArgument(\"out_backprop must be 5-dimensional\"));\n    const TensorShape& output_shape = tensor_in.shape();\n    Tensor* input_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, output_shape, &input_backprop));\n    std::array<int64_t, 3> input_size{\n        {GetTensorDim(output_shape, data_format_, '2'),\n         GetTensorDim(output_shape, data_format_, '1'),\n         GetTensorDim(output_shape, data_format_, '0')}};\n    std::array<int64_t, 3> window{{GetTensorDim(ksize_, data_format_, '2'),\n                                   GetTensorDim(ksize_, data_format_, '1'),\n                                   GetTensorDim(ksize_, data_format_, '0')}};\n    std::array<int64_t, 3> stride{{GetTensorDim(stride_, data_format_, '2'),\n                                   GetTensorDim(stride_, data_format_, '1'),\n                                   GetTensorDim(stride_, data_format_, '0')}};\n    std::array<int64_t, 3> out, padding;\n    OP_REQUIRES_OK(context, Get3dOutputSize(input_size, window, stride,\n                                            padding_, &out, &padding));\n    const int64_t depth = GetTensorDim(tensor_in, data_format_, 'C');\n    const int64_t in_batch = GetTensorDim(tensor_in, data_format_, 'N');\n    TensorShape out_shape = ShapeFromFormat(data_format_, in_batch,\n                                            {{out[2], out[1], out[0]}}, depth);\n    OP_REQUIRES(\n        context, tensor_out.shape() == out_shape,\n        errors::InvalidArgument(\"Expected orig_output shape to be \", out_shape,\n                                \", but got \", tensor_out.shape()));\n    OP_REQUIRES(context, out_backprop.shape() == out_shape,\n                errors::InvalidArgument(\"Expected grad shape to be \", out_shape,\n                                        \", but got \", out_backprop.shape()));\n    LaunchMaxPooling3dGradOp<Device, T>::launch(\n        context, tensor_in, tensor_out, out_backprop, window, stride, out,\n        padding, data_format_, input_backprop);\n  }", "target": 0}
{"code": "static BOOL ntlm_av_pair_check(NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\treturn cbAvPair >= ntlm_av_pair_get_next_offset(pAvPair);\n}", "target": 1}
{"code": "static int unix_dgram_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct sockaddr_un *sunaddr = (struct sockaddr_un *)addr;\n\tstruct sock *other;\n\tunsigned int hash;\n\tint err;\n\tif (addr->sa_family != AF_UNSPEC) {\n\t\terr = unix_mkname(sunaddr, alen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\talen = err;\n\t\tif (test_bit(SOCK_PASSCRED, &sock->flags) &&\n\t\t    !unix_sk(sk)->addr && (err = unix_autobind(sock)) != 0)\n\t\t\tgoto out;\nrestart:\n\t\tother = unix_find_other(net, sunaddr, alen, sock->type, hash, &err);\n\t\tif (!other)\n\t\t\tgoto out;\n\t\tunix_state_double_lock(sk, other);\n\t\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t\tunix_state_double_unlock(sk, other);\n\t\t\tsock_put(other);\n\t\t\tgoto restart;\n\t\t}\n\t\terr = -EPERM;\n\t\tif (!unix_may_send(sk, other))\n\t\t\tgoto out_unlock;\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t} else {\n\t\tother = NULL;\n\t\tunix_state_double_lock(sk, other);\n\t}\n\tif (unix_peer(sk)) {\n\t\tstruct sock *old_peer = unix_peer(sk);\n\t\tunix_peer(sk) = other;\n\t\tunix_dgram_peer_wake_disconnect_wakeup(sk, old_peer);\n\t\tunix_state_double_unlock(sk, other);\n\t\tif (other != old_peer)\n\t\t\tunix_dgram_disconnected(sk, old_peer);\n\t\tsock_put(old_peer);\n\t} else {\n\t\tunix_peer(sk) = other;\n\t\tunix_state_double_unlock(sk, other);\n\t}\n\treturn 0;\nout_unlock:\n\tunix_state_double_unlock(sk, other);\n\tsock_put(other);\nout:\n\treturn err;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* c) override {\n    Tensor* output_tensor;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, {}, &output_tensor, attr));\n    PartialTensorShape element_shape;\n    OP_REQUIRES(\n        c, !TensorShapeUtils::IsMatrixOrHigher(c->input(1).shape()),\n        errors::InvalidArgument(\n            \"TensorListFromTensor: element_shape must be at most rank 1 but \",\n            \"has the shape of \", c->input(1).shape().DebugString()));\n    OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(1), &element_shape));\n    TensorList output_list;\n    const Tensor& t = c->input(0);\n    output_list.element_dtype = t.dtype();\n    OP_REQUIRES(c, TensorShapeUtils::IsVectorOrHigher(t.shape()),\n                errors::InvalidArgument(\n                    \"Tensor must be at least a vector, but saw shape: \",\n                    t.shape().DebugString()));\n    TensorShape output_shape(t.shape());\n    output_shape.RemoveDim(0);\n    OP_REQUIRES(c, element_shape.IsCompatibleWith(output_shape),\n                errors::InvalidArgument(\n                    \"Specified a list with shape \", element_shape.DebugString(),\n                    \" from a tensor with shape \", output_shape.DebugString()));\n    output_list.element_shape = element_shape;\n    output_list.tensors().reserve(t.shape().dim_size(0));\n    const auto copy_tensor = IsPluggableDevice(c)\n                                 ? &CopyTensorPluggableDevice<T>\n                                 : &CopyTensor<Device, T>;\n    for (int i = 0; i < t.shape().dim_size(0); ++i) {\n      Tensor tmp = t.Slice(i, i + 1);\n      TensorShape tmp_shape = tmp.shape();\n      tmp_shape.RemoveDim(0);\n      OP_REQUIRES(c, tmp.CopyFrom(tmp, tmp_shape),\n                  errors::Unknown(\"Unexpected shape error.\"));\n      Tensor aligned;\n      OP_REQUIRES_OK(c, c->allocate_temp(tmp.dtype(), tmp.shape(), &aligned));\n      copy_tensor(c, tmp, aligned);\n      output_list.tensors().push_back(aligned);\n    }\n    output_tensor->scalar<Variant>()() = std::move(output_list);\n  }", "target": 0}
{"code": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "target": 1}
{"code": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int pmd_present(pmd_t pmd)\n{\n\treturn pmd_flags(pmd) & _PAGE_PRESENT;\n}", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\tgoto error2; \n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "evtchn_port_t evtchn_from_irq(unsigned irq)\n{\n\tif (WARN(irq >= nr_irqs, \"Invalid irq %d!\\n\", irq))\n\t\treturn 0;\n\treturn info_for_irq(irq)->evtchn;\n}", "target": 1}
{"code": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\twrite_metapage(mp);\n\tIREAD_UNLOCK(ipbmap);\n\treturn (0);\n}", "target": 1}
{"code": "rt6_print(netdissect_options *ndo, register const u_char *bp, const u_char *bp2 _U_)\n{\n\tregister const struct ip6_rthdr *dp;\n\tregister const struct ip6_rthdr0 *dp0;\n\tregister const u_char *ep;\n\tint i, len;\n\tregister const struct in6_addr *addr;\n\tdp = (const struct ip6_rthdr *)bp;\n\tlen = dp->ip6r_len;\n\tep = ndo->ndo_snapend;\n\tND_TCHECK(dp->ip6r_segleft);\n\tND_PRINT((ndo, \"srcrt (len=%d\", dp->ip6r_len));\t\n\tND_PRINT((ndo, \", type=%d\", dp->ip6r_type));\n\tND_PRINT((ndo, \", segleft=%d\", dp->ip6r_segleft));\n\tswitch (dp->ip6r_type) {\n\tcase IPV6_RTHDR_TYPE_0:\n\tcase IPV6_RTHDR_TYPE_2:\t\t\t\n\t\tdp0 = (const struct ip6_rthdr0 *)dp;\n\t\tND_TCHECK(dp0->ip6r0_reserved);\n\t\tif (dp0->ip6r0_reserved || ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \", rsv=0x%0x\",\n\t\t\t    EXTRACT_32BITS(&dp0->ip6r0_reserved)));\n\t\t}\n\t\tif (len % 2 == 1)\n\t\t\tgoto trunc;\n\t\tlen >>= 1;\n\t\taddr = &dp0->ip6r0_addr[0];\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif ((const u_char *)(addr + 1) > ep)\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \", [%d]%s\", i, ip6addr_string(ndo, addr)));\n\t\t\taddr++;\n\t\t}\n\t\tND_PRINT((ndo, \") \"));\n\t\treturn((dp0->ip6r0_len + 1) << 3);\n\t\tbreak;\n\tdefault:\n\t\tgoto trunc;\n\t\tbreak;\n\t}\n trunc:\n\tND_PRINT((ndo, \"[|srcrt]\"));\n\treturn -1;\n}", "target": 1}
{"code": "int ZlibInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"ZlibInStream overrun: max itemSize exceeded\");\n  if (!underlying)\n    throw Exception(\"ZlibInStream overrun: no underlying stream\");\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n  while (end - ptr < itemSize) {\n    if (!decompress(wait))\n      return 0;\n  }\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n  return nItems;\n}", "target": 1}
{"code": "trim_subnode_array(apr_array_header_t **array,\n                   int latest_any_var,\n                   apr_pool_t *scratch_pool)\n{\n  if (*array)\n    {\n      int i, dest;\n      for (i = 0, dest = 0; i < (*array)->nelts; ++i)\n        {\n          node_t *node = APR_ARRAY_IDX(*array, i, sorted_pattern_t).node;\n          if (!trim_tree(node, latest_any_var, scratch_pool))\n            {\n              if (i != dest)\n                APR_ARRAY_IDX(*array, dest, sorted_pattern_t)\n                  = APR_ARRAY_IDX(*array, i, sorted_pattern_t);\n              ++dest;\n            }\n        }\n      if (dest)\n        {\n          (*array)->nelts = dest;\n          return FALSE;\n        }\n      *array = NULL;\n    }\n  return TRUE;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional (2)\"));\n    OP_REQUIRES(context, tensor_in.NumElements() > 0,\n                errors::InvalidArgument(\"tensor_in must not be empty (2)\"));\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    Tensor* argmax = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, out_shape, &argmax));\n    LaunchMaxPoolingWithArgmax<Device, T, Targmax>::launch(\n        context, params, tensor_in, output, argmax, propagate_nans_,\n        include_batch_in_index_);\n  }", "target": 0}
{"code": "test_appheader (xd3_stream *stream, int ignore)\n{\n  int i;\n  int ret;\n  char buf[TESTBUFSIZE];\n  char bogus[TESTBUFSIZE];\n  xoff_t ssize, tsize;\n  test_setup ();\n  if ((ret = test_make_inputs (stream, &ssize, &tsize))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"%s -q -f -e -s %s %s %s\", program_name,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_copy_to (program_name, TEST_RECON2_FILE))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"chmod 0700 %s\", TEST_RECON2_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_save_copy (TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_copy_to (TEST_SOURCE_FILE, TEST_TARGET_FILE))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) == 0)\n    {\n      return XD3_INVALID;  \n    }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  if ((ret = test_compare_files (TEST_TARGET_FILE, TEST_COPY_FILE)) != 0)\n    {\n      return ret;\n    }\n  for (i = 0; i < TESTBUFSIZE / 4; ++i)\n    {\n      bogus[2*i] = 'G';\n      bogus[2*i+1] = '/';\n    }\n  bogus[TESTBUFSIZE/2-1] = 0;\n  snprintf_func (buf, TESTBUFSIZE, \n\t\t \"%s -q -f -A=%s -e -s %s %s %s\", program_name, bogus,\n\t\t TEST_SOURCE_FILE, TEST_TARGET_FILE, TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf))) { return ret; }\n  snprintf_func (buf, TESTBUFSIZE, \"(cd /tmp && %s -q -f -d %s)\",\n\t\t TEST_RECON2_FILE,\n\t\t TEST_DELTA_FILE);\n  if ((ret = do_cmd (stream, buf)) == 0) \n    { \n      return XD3_INVALID;  \n    }\n  if (!WIFEXITED(ret))\n    {\n      return XD3_INVALID;  \n    }\n  return 0;\n}", "target": 0}
{"code": "juniper_services_print(netdissect_options *ndo,\n                       const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        struct juniper_services_header {\n            uint8_t svc_id;\n            uint8_t flags_len;\n            uint8_t svc_set_id[2];\n            uint8_t dir_iif[4];\n        };\n        const struct juniper_services_header *sh;\n        l2info.pictype = DLT_JUNIPER_SERVICES;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        sh = (const struct juniper_services_header *)p;\n        ND_TCHECK(*sh);\n        if (ndo->ndo_eflag)\n            ND_PRINT((ndo, \"service-id %u flags 0x%02x service-set-id 0x%04x iif %u: \",\n                   sh->svc_id,\n                   sh->flags_len,\n                   EXTRACT_16BITS(&sh->svc_set_id),\n                   EXTRACT_24BITS(&sh->dir_iif[1])));\n        ip_heuristic_guess (ndo, p, l2info.length);\n        return l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_services]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}", "target": 1}
{"code": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}", "target": 1}
{"code": "date_s_jisx0301(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    if (!NIL_P(opt)) argc--;\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        if (!NIL_P(opt)) argv2[argc2++] = opt;\n\tVALUE hash = date_s__jisx0301(argc2, argv2, klass);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "Http::FilterTrailersStatus Context::onRequestTrailers() {\n  if (!wasm_->onRequestTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onRequestTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}", "target": 1}
{"code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}", "target": 1}
{"code": "add_serials(struct deltas_head *deltas, ...)\n{\n\tstruct delta_head delta;\n\tva_list vl;\n\tdoc_data_init(&delta.doc_data);\n\tva_start(vl, deltas);\n\twhile ((delta.serial = va_arg(vl, unsigned long)) != END)\n\t\tck_assert_int_eq(0, deltas_head_add(deltas, &delta));\n\tva_end(vl);\n}", "target": 0}
{"code": "swap_until_sorted(struct delta_head *deltas, unsigned int i,\n    unsigned long min, unsigned long max)\n{\n\tunsigned int target_slot;\n\tstruct delta_head tmp;\n\twhile (true) {\n\t\tif (deltas[i].serial < min || max < deltas[i].serial) {\n\t\t\treturn pr_val_err(\"Deltas: Serial '%lu' is out of bounds. (min:%lu, max:%lu)\",\n\t\t\t    deltas[i].serial, min, max);\n\t\t}\n\t\ttarget_slot = deltas[i].serial - min;\n\t\tif (i == target_slot)\n\t\t\treturn 0;\n\t\tif (deltas[target_slot].serial == deltas[i].serial) {\n\t\t\treturn pr_val_err(\"Deltas: Serial '%lu' is not unique.\",\n\t\t\t    deltas[i].serial);\n\t\t}\n\t\ttmp = deltas[target_slot];\n\t\tdeltas[target_slot] = deltas[i];\n\t\tdeltas[i] = tmp;\n\t}\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_field_type_oid)\n{\n\tphp_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_TYPE_OID);\n}", "target": 0}
{"code": "sysName_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG - \"CONTIKI_TARGET_STRING);\n}", "target": 1}
{"code": "static void encode_compound_hdr(struct xdr_stream *xdr,\n\t\t\t\tstruct rpc_rqst *req,\n\t\t\t\tstruct compound_hdr *hdr)\n{\n\t__be32 *p;\n\tstruct rpc_auth *auth = req->rq_cred->cr_auth;\n\thdr->replen = RPC_REPHDRSIZE + auth->au_rslack + 3 + hdr->taglen;\n\tBUG_ON(hdr->taglen > NFS4_MAXTAGLEN);\n\tencode_string(xdr, hdr->taglen, hdr->tag);\n\tp = reserve_space(xdr, 8);\n\t*p++ = cpu_to_be32(hdr->minorversion);\n\thdr->nops_p = p;\n\t*p = cpu_to_be32(hdr->nops);\n}", "target": 0}
{"code": "void options_free() {\n    parse_global_option(CMD_FREE, NULL, NULL);\n}", "target": 1}
{"code": "static void dump_usage_categories_info(Formatter *formatter, const rgw_usage_log_entry& entry, map<string, bool> *categories)\n{\n  formatter->open_array_section(\"categories\");\n  map<string, rgw_usage_data>::const_iterator uiter;\n  for (uiter = entry.usage_map.begin(); uiter != entry.usage_map.end(); ++uiter) {\n    if (categories && !categories->empty() && !categories->count(uiter->first))\n      continue;\n    const rgw_usage_data& usage = uiter->second;\n    formatter->open_object_section(\"Entry\");\n    encode_json(\"Category\", uiter->first, formatter);\n    encode_json(\"BytesSent\", usage.bytes_sent, formatter);\n    encode_json(\"BytesReceived\", usage.bytes_received, formatter);\n    encode_json(\"Ops\", usage.ops, formatter);\n    encode_json(\"SuccessfulOps\", usage.successful_ops, formatter);\n    formatter->close_section(); \n  }\n  formatter->close_section(); \n}", "target": 0}
{"code": "static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create)\n{\n    char *path = xstrdup(p);\n    char *dp = path;\n    char *sp = NULL, *bn;\n    int oflags = O_RDONLY;\n    int dirfd = fsmOpenat(-1, \"/\", oflags);\n    int fd = dirfd; \n    while ((bn = strtok_r(dp, \"/\", &sp)) != NULL) {\n\tstruct stat sb;\n\tfd = fsmOpenat(dirfd, bn, oflags);\n\tif (fd < 0 && errno == ENOENT && create) {\n\t    mode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t    if (fsmDoMkDir(plugins, dirfd, bn, owned, mode) == 0) {\n\t\tfd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);\n\t    }\n\t}\n\tif (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {\n\t    close(fd);\n\t    errno = ENOTDIR;\n\t    fd = -1;\n\t}\n\tclose(dirfd);\n\tif (fd >= 0) {\n\t    dirfd = fd;\n\t} else {\n\t    dirfd = -1;\n\t    rpmlog(RPMLOG_ERR, _(\"failed to open dir %s of %s: %s\\n\"),\n\t\t\t\tbn, p, strerror(errno));\n\t    break;\n\t}\n\tdp = NULL;\n    }\n    free(path);\n    return dirfd;\n}", "target": 0}
{"code": "IOBasicTypes::LongFilePositionType ObjectByteWriterWithPosition::GetCurrentPosition()\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"getCurrentPosition\")).ToLocalChecked();\n    if(value->IsUndefined())\n        return true;\n    Local<Function> func = Local<Function>::Cast(value);\n\treturn TO_NUMBER(func->Call(GET_CURRENT_CONTEXT, OBJECT_FROM_PERSISTENT(mObject), 0, NULL).ToLocalChecked())->Value();\n}", "target": 1}
{"code": "gsm_xsmp_client_connect (GsmXSMPClient *client,\n                         SmsConn        conn,\n                         unsigned long *mask_ret,\n                         SmsCallbacks  *callbacks_ret)\n{\n        client->priv->conn = conn;\n        if (client->priv->protocol_timeout) {\n                g_source_remove (client->priv->protocol_timeout);\n                client->priv->protocol_timeout = 0;\n        }\n        g_debug (\"GsmXSMPClient: Initializing client %s\", client->priv->description);\n        *mask_ret = 0;\n        *mask_ret |= SmsRegisterClientProcMask;\n        callbacks_ret->register_client.callback = register_client_callback;\n        callbacks_ret->register_client.manager_data  = client;\n        *mask_ret |= SmsInteractRequestProcMask;\n        callbacks_ret->interact_request.callback = interact_request_callback;\n        callbacks_ret->interact_request.manager_data = client;\n        *mask_ret |= SmsInteractDoneProcMask;\n        callbacks_ret->interact_done.callback = interact_done_callback;\n        callbacks_ret->interact_done.manager_data = client;\n        *mask_ret |= SmsSaveYourselfRequestProcMask;\n        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;\n        callbacks_ret->save_yourself_request.manager_data = client;\n        *mask_ret |= SmsSaveYourselfP2RequestProcMask;\n        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;\n        callbacks_ret->save_yourself_phase2_request.manager_data = client;\n        *mask_ret |= SmsSaveYourselfDoneProcMask;\n        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;\n        callbacks_ret->save_yourself_done.manager_data = client;\n        *mask_ret |= SmsCloseConnectionProcMask;\n        callbacks_ret->close_connection.callback = close_connection_callback;\n        callbacks_ret->close_connection.manager_data  = client;\n        *mask_ret |= SmsSetPropertiesProcMask;\n        callbacks_ret->set_properties.callback = set_properties_callback;\n        callbacks_ret->set_properties.manager_data = client;\n        *mask_ret |= SmsDeletePropertiesProcMask;\n        callbacks_ret->delete_properties.callback = delete_properties_callback;\n        callbacks_ret->delete_properties.manager_data = client;\n        *mask_ret |= SmsGetPropertiesProcMask;\n        callbacks_ret->get_properties.callback = get_properties_callback;\n        callbacks_ret->get_properties.manager_data = client;\n}", "target": 1}
{"code": "static int pf_detect(void)\n{\n\tstruct pf_unit *pf = units;\n\tint k, unit;\n\tprintk(\"%s: %s version %s, major %d, cluster %d, nice %d\\n\",\n\t       name, name, PF_VERSION, major, cluster, nice);\n\tpar_drv = pi_register_driver(name);\n\tif (!par_drv) {\n\t\tpr_err(\"failed to register %s driver\\n\", name);\n\t\treturn -1;\n\t}\n\tk = 0;\n\tif (pf_drive_count == 0) {\n\t\tif (pi_init(pf->pi, 1, -1, -1, -1, -1, -1, pf_scratch, PI_PF,\n\t\t\t    verbose, pf->name)) {\n\t\t\tif (!pf_probe(pf) && pf->disk) {\n\t\t\t\tpf->present = 1;\n\t\t\t\tk++;\n\t\t\t} else\n\t\t\t\tpi_release(pf->pi);\n\t\t}\n\t} else\n\t\tfor (unit = 0; unit < PF_UNITS; unit++, pf++) {\n\t\t\tint *conf = *drives[unit];\n\t\t\tif (!conf[D_PRT])\n\t\t\t\tcontinue;\n\t\t\tif (pi_init(pf->pi, 0, conf[D_PRT], conf[D_MOD],\n\t\t\t\t    conf[D_UNI], conf[D_PRO], conf[D_DLY],\n\t\t\t\t    pf_scratch, PI_PF, verbose, pf->name)) {\n\t\t\t\tif (pf->disk && !pf_probe(pf)) {\n\t\t\t\t\tpf->present = 1;\n\t\t\t\t\tk++;\n\t\t\t\t} else\n\t\t\t\t\tpi_release(pf->pi);\n\t\t\t}\n\t\t}\n\tif (k)\n\t\treturn 0;\n\tprintk(\"%s: No ATAPI disk detected\\n\", name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tpf->disk->queue = NULL;\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t}\n\tpi_unregister_driver(par_drv);\n\treturn -1;\n}", "target": 0}
{"code": "GF_Err video_sample_entry_box_size(GF_Box *s)\n{\n\tGF_Box *b;\n\tu32 pos=0;\n\tGF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s;\n\tgf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s);\n\tgf_isom_check_position(s, (GF_Box *)ptr->esd, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos);\n\tif (ptr->mvc_config) {\n\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\tb = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D);\n\tif (b) gf_isom_check_position(s, b, &pos);\n\treturn GF_OK;\n}", "target": 1}
{"code": "crm_recv_remote_msg(void *session, gboolean encrypted)\n{\n    char *reply = NULL;\n    xmlNode *xml = NULL;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = cib_recv_tls(session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = cib_recv_plaintext(GPOINTER_TO_INT(session));\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n    } else {\n        xml = string2xml(reply);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", reply);\n        }\n    }\n    free(reply);\n    return xml;\n}", "target": 1}
{"code": "isAlphaNum(char ch) {\n\treturn (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}", "target": 0}
{"code": "dcinit()\n{\n\tstrsize = 1; \n\tstrmaxsize=DCSTRSIZE;\n\tdcstr=calloc(DCSTRSIZE,1);\n\tdcptr=dcstr;\n}", "target": 0}
{"code": "vgetcpu_cpu_notifier(struct notifier_block *n, unsigned long action, void *arg)\n{\n\tlong cpu = (long)arg;\n\tif (action == CPU_ONLINE || action == CPU_ONLINE_FROZEN)\n\t\tsmp_call_function_single(cpu, vgetcpu_cpu_init, NULL, 1);\n\treturn NOTIFY_DONE;\n}", "target": 0}
{"code": "ExprResolveLhs(struct xkb_context *ctx, const ExprDef *expr,\n               const char **elem_rtrn, const char **field_rtrn,\n               ExprDef **index_rtrn)\n{\n    switch (expr->expr.op) {\n    case EXPR_IDENT:\n        *elem_rtrn = NULL;\n        *field_rtrn = xkb_atom_text(ctx, expr->ident.ident);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_FIELD_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->field_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->field_ref.field);\n        *index_rtrn = NULL;\n        return true;\n    case EXPR_ARRAY_REF:\n        *elem_rtrn = xkb_atom_text(ctx, expr->array_ref.element);\n        *field_rtrn = xkb_atom_text(ctx, expr->array_ref.field);\n        *index_rtrn = expr->array_ref.entry;\n        return true;\n    default:\n        break;\n    }\n    log_wsgo(ctx, \"Unexpected operator %d in ResolveLhs\\n\", expr->expr.op);\n    return false;\n}", "target": 1}
{"code": "static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field)\n{\n    pb_field_iter_t old_field = *field;\n    pb_size_t old_tag = *(pb_size_t*)field->pSize; \n    pb_size_t new_tag = field->tag; \n    if (old_tag == 0)\n        return true; \n    if (old_tag == new_tag)\n        return true; \n    if (!pb_field_iter_find(&old_field, old_tag))\n        PB_RETURN_ERROR(stream, \"invalid union tag\");\n    pb_release_single_field(&old_field);\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n        *(void**)field->pField = NULL;\n        field->pData = NULL;\n    }\n    return true;\n}", "target": 0}
{"code": "void ZydisFormatterBufferInitTokenized(ZydisFormatterBuffer* buffer,\n    ZydisFormatterToken** first_token, void* user_buffer, ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(first_token);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n    *first_token = user_buffer;\n    (*first_token)->type = ZYDIS_TOKEN_INVALID;\n    (*first_token)->next = 0;\n    user_buffer = (ZyanU8*)user_buffer + sizeof(ZydisFormatterToken);\n    length -= sizeof(ZydisFormatterToken);\n    buffer->is_token_list              = ZYAN_TRUE;\n    buffer->capacity                   = length;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *(char*)user_buffer = '\\0';\n}", "target": 1}
{"code": "uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k)\n{\n    uint64_t hash;\n    uint8_t *out = (uint8_t*) &hash;\n    uint64_t v0 = 0x736f6d6570736575ULL;\n    uint64_t v1 = 0x646f72616e646f6dULL;\n    uint64_t v2 = 0x6c7967656e657261ULL;\n    uint64_t v3 = 0x7465646279746573ULL;\n    uint64_t k0 = U8TO64_LE(k);\n    uint64_t k1 = U8TO64_LE(k + 8);\n    uint64_t m;\n    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));\n    const int left = inlen & 7;\n    uint64_t b = ((uint64_t)inlen) << 56;\n    v3 ^= k1;\n    v2 ^= k0;\n    v1 ^= k1;\n    v0 ^= k0;\n    for (; in != end; in += 8) {\n        m = U8TO64_LE_NOCASE(in);\n        v3 ^= m;\n        SIPROUND;\n        SIPROUND;\n        v0 ^= m;\n    }\n    switch (left) {\n    case 7: b |= ((uint64_t)tolower(in[6])) << 48;\n    case 6: b |= ((uint64_t)tolower(in[5])) << 40;\n    case 5: b |= ((uint64_t)tolower(in[4])) << 32;\n    case 4: b |= ((uint64_t)tolower(in[3])) << 24;\n    case 3: b |= ((uint64_t)tolower(in[2])) << 16;\n    case 2: b |= ((uint64_t)tolower(in[1])) << 8;\n    case 1: b |= ((uint64_t)tolower(in[0])); break;\n    case 0: break;\n    }\n    v3 ^= b;\n    SIPROUND;\n    SIPROUND;\n    v0 ^= b;\n    v2 ^= 0xff;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    b = v0 ^ v1 ^ v2 ^ v3;\n    U64TO8_LE(out, b);\n    return hash;\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageJpegPtr(gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageJpegCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "mm_zfree(struct mm_master *mm, void *address)\n{\n\tmm_free(mm, address);\n}", "target": 1}
{"code": "bool SPIFFEValidator::matchSubjectAltName(X509& leaf_cert) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&leaf_cert, NID_subject_alt_name, nullptr, nullptr)));\n  ASSERT(san_names != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    if (general_name->type == GEN_URI) {\n      const std::string san = Utility::generalNameAsString(general_name);\n      for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n        if (config_san_matcher.match(san)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "soup_server_get_listener (SoupServer *server)\n{\n\tSoupServerPrivate *priv;\n\tg_return_val_if_fail (SOUP_IS_SERVER (server), NULL);\n\tpriv = SOUP_SERVER_GET_PRIVATE (server);\n\treturn priv->listen_sock;\n}", "target": 0}
{"code": "R_API int r_socket_read_block(RSocket *s, ut8 *buf, int len) {\n\tint ret = 0;\n\tfor (ret = 0; ret < len; ) {\n\t\tint r = r_socket_read (s, buf + ret, len - ret);\n\t\tif (r == -1) {\n#if HAVE_LIB_SSL\n\t\t\tif (SSL_get_error (s->sfd, r) == SSL_ERROR_WANT_READ) {\n\t\t\t\tif (r_socket_ready (s, 1, 0) == 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\treturn -1;\n\t\t}\n\t\tif (r < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tret += r;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "sread(int fd, void *buf, size_t n, int canbepipe)\n{\n\tssize_t rv;\n#ifdef FIONREAD\n\tint t = 0;\n#endif\n\tsize_t rn = n;\n\tif (fd == STDIN_FILENO)\n\t\tgoto nocheck;\n#ifdef FIONREAD\n\tif (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {\n#ifdef FD_ZERO\n\t\tssize_t cnt;\n\t\tfor (cnt = 0;; cnt++) {\n\t\t\tfd_set check;\n\t\t\tstruct timeval tout = {0, 100 * 1000};\n\t\t\tint selrv;\n\t\t\tFD_ZERO(&check);\n\t\t\tFD_SET(fd, &check);\n\t\t\tselrv = select(fd + 1, &check, NULL, NULL, &tout);\n\t\t\tif (selrv == -1) {\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (selrv == 0 && cnt >= 5) {\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n#endif\n\t\t(void)ioctl(fd, FIONREAD, &t);\n\t}\n\tif (t > 0 && (size_t)t < n) {\n\t\tn = t;\n\t\trn = n;\n\t}\n#endif\nnocheck:\n\tdo\n\t\tswitch ((rv = FINFO_READ_FUNC(fd, buf, n))) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\treturn rn - n;\n\t\tdefault:\n\t\t\tn -= rv;\n\t\t\tbuf = ((char *)buf) + rv;\n\t\t\tbreak;\n\t\t}\n\twhile (n > 0);\n\treturn rn;\n}", "target": 0}
{"code": "void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n{\n\tint i;\n\tint opts;\n\tResub m;\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushnull(J);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tjs_newarray(J);\n\t\tjs_pushstring(J, text);\n\t\tjs_setproperty(J, -2, \"input\");\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\t\tjs_setproperty(J, -2, \"index\");\n\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushnull(J);\n}", "target": 1}
{"code": "static NTSTATUS smb_set_file_dosmode(connection_struct *conn,\n\t\t\t\t     struct files_struct *fsp,\n\t\t\t\t     uint32_t dosmode)\n{\n\tstruct files_struct *dos_fsp = NULL;\n\tuint32_t current_dosmode;\n\tint ret;\n\tif (!VALID_STAT(fsp->fsp_name->st)) {\n\t\treturn NT_STATUS_OBJECT_NAME_NOT_FOUND;\n\t}\n\tdos_fsp = fsp->base_fsp != NULL ? fsp->base_fsp : fsp;\n\tif (dosmode != 0) {\n\t\tif (S_ISDIR(fsp->fsp_name->st.st_ex_mode)) {\n\t\t\tdosmode |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t} else {\n\t\t\tdosmode &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\t}\n\t}\n\tDBG_DEBUG(\"dosmode: 0x%\" PRIx32 \"\\n\", dosmode);\n\tif (dosmode == 0) {\n\t\treturn NT_STATUS_OK;\n\t}\n\tcurrent_dosmode = fdos_mode(dos_fsp);\n\tif (dosmode == current_dosmode) {\n\t\treturn NT_STATUS_OK;\n\t}\n\tDBG_DEBUG(\"file %s : setting dos mode 0x%\" PRIx32 \"\\n\",\n\t\t  fsp_str_dbg(dos_fsp), dosmode);\n\tret = file_set_dosmode(conn, dos_fsp->fsp_name, dosmode, NULL, false);\n\tif (ret != 0) {\n\t\tDBG_WARNING(\"file_set_dosmode of %s failed: %s\\n\",\n\t\t\t    fsp_str_dbg(dos_fsp), strerror(errno));\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "target": 1}
{"code": "dup_dest_constraints(const struct dest_constraint *dcs, size_t ndcs)\n{\n\tsize_t i;\n\tstruct dest_constraint *ret;\n\tif (ndcs == 0)\n\t\treturn NULL;\n\tret = xcalloc(ndcs, sizeof(*ret));\n\tfor (i = 0; i < ndcs; i++) {\n\t\tdup_dest_constraint_hop(&dcs[i].from, &ret[i].from);\n\t\tdup_dest_constraint_hop(&dcs[i].to, &ret[i].to);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void SetTransferMatrix(double x11,double x12,double x21,double x22,double x,double y)\n{\n    if ( ( fabs(x11-1.) > 0.001 ) || ( fabs(x22-1.) > 0.001 )\n         || ( fabs(x12) > 0.001 ) || ( fabs(x21) > 0.001 )\n         || ( fabs(x) > 0.001 ) || ( fabs(y) > 0.001 ) ) {\n        outpos +=\n        sprintf(outpos,\"%12.3f %12.3f %12.3f %12.3f %12.3f %12.3f cm\\n\",x11,x12,x21,x22,x,y);\n    }\n}", "target": 1}
