{"code": "bool Browser::CanCloseWithInProgressDownloads() {\n  if (cancel_download_confirmation_state_ != NOT_PROMPTED)\n    return cancel_download_confirmation_state_ != WAITING_FOR_RESPONSE;\n  int num_downloads_blocking;\n  Browser::DownloadClosePreventionType dialog_type =\n      OkToCloseWithInProgressDownloads(&num_downloads_blocking);\n  if (dialog_type == DOWNLOAD_CLOSE_OK)\n    return true;\n  cancel_download_confirmation_state_ = WAITING_FOR_RESPONSE;\n  window_->ConfirmBrowserCloseWithPendingDownloads(\n      num_downloads_blocking,\n      dialog_type,\n      false,\n      base::Bind(&Browser::InProgressDownloadResponse,\n                 weak_factory_.GetWeakPtr()));\n  return false;\n}", "target": 0}
{"code": "static int mptctl_do_reset(unsigned long arg)\n{\n\tstruct mpt_ioctl_diag_reset __user *urinfo = (void __user *) arg;\n\tstruct mpt_ioctl_diag_reset krinfo;\n\tMPT_ADAPTER\t\t*iocp;\n\tif (copy_from_user(&krinfo, urinfo, sizeof(struct mpt_ioctl_diag_reset))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_do_reset - \"\n\t\t\t\t\"Unable to copy mpt_ioctl_diag_reset struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, urinfo);\n\t\treturn -EFAULT;\n\t}\n\tif (mpt_verify_adapter(krinfo.hdr.iocnum, &iocp) < 0) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s@%d::mptctl_do_reset - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, krinfo.hdr.iocnum);\n\t\treturn -ENODEV; \n\t}\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"mptctl_do_reset called.\\n\",\n\t    iocp->name));\n\tif (mpt_HardResetHandler(iocp, CAN_SLEEP) != 0) {\n\t\tprintk (MYIOC_s_ERR_FMT \"%s@%d::mptctl_do_reset - reset failed.\\n\",\n\t\t\tiocp->name, __FILE__, __LINE__);\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\tcrypto_bignum_free(*bn);\n\t*bn = NULL;\n}", "target": 1}
{"code": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}", "target": 1}
{"code": "void AverageEvalQuantizedInt8(TfLiteContext* context, TfLiteNode* node,\n                              TfLitePoolParams* params, OpData* data,\n                              const TfLiteTensor* input, TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                        \\\n  tflite::PoolParams op_params;                                           \\\n  op_params.stride_height = params->stride_height;                        \\\n  op_params.stride_width = params->stride_width;                          \\\n  op_params.filter_height = params->filter_height;                        \\\n  op_params.filter_width = params->filter_width;                          \\\n  op_params.padding_values.height = data->padding.height;                 \\\n  op_params.padding_values.width = data->padding.width;                   \\\n  op_params.quantized_activation_min = activation_min;                    \\\n  op_params.quantized_activation_max = activation_max;                    \\\n  type::AveragePool(op_params, GetTensorShape(input),                     \\\n                    GetTensorData<int8_t>(input), GetTensorShape(output), \\\n                    GetTensorData<int8_t>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_integer_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_integer_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "NOEXPORT void cb_new_auth(void *parent, void *ptr, CRYPTO_EX_DATA *ad,\n        int idx, long argl, void *argp) {\n    (void)parent; \n    (void)ptr; \n    (void)argl; \n    s_log(LOG_DEBUG, \"Initializing application specific data for %s\",\n        (char *)argp);\n    if(!CRYPTO_set_ex_data(ad, idx, (void *)(-1)))\n        sslerror(\"CRYPTO_set_ex_data\");\n}", "target": 0}
{"code": "header_put_byte (SF_PRIVATE *psf, char x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 1)\n\t\tpsf->header [psf->headindex++] = x ;\n} ", "target": 1}
{"code": "static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_MSB,op_LSB;\n\tint ret;\n\tif (!data)\n\t\treturn 0;\n\tmemset (op, '\\0', sizeof (RAnalOp));\n\top->addr = addr;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->jump = op->fail = -1;\n\top->ptr = op->val = -1;\n\top->size = 2;\n\top_MSB = anal->big_endian? data[0]: data[1];\n\top_LSB = anal->big_endian? data[1]: data[0];\n\tret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));\n\treturn ret;\n}", "target": 1}
{"code": "int do_remount_sb(struct super_block *sb, int flags, void *data, int force)\n{\n\tint retval;\n\tint remount_ro;\n\tif (sb->s_writers.frozen != SB_UNFROZEN)\n\t\treturn -EBUSY;\n#ifdef CONFIG_BLOCK\n\tif (!(flags & MS_RDONLY) && bdev_read_only(sb->s_bdev))\n\t\treturn -EACCES;\n#endif\n\tif (flags & MS_RDONLY)\n\t\tacct_auto_close(sb);\n\tshrink_dcache_sb(sb);\n\tsync_filesystem(sb);\n\tremount_ro = (flags & MS_RDONLY) && !(sb->s_flags & MS_RDONLY);\n\tif (remount_ro) {\n\t\tif (force) {\n\t\t\tmark_files_ro(sb);\n\t\t} else {\n\t\t\tretval = sb_prepare_remount_readonly(sb);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\tif (sb->s_op->remount_fs) {\n\t\tretval = sb->s_op->remount_fs(sb, &flags, data);\n\t\tif (retval) {\n\t\t\tif (!force)\n\t\t\t\tgoto cancel_readonly;\n\t\t\tWARN(1, \"forced remount of a %s fs returned %i\\n\",\n\t\t\t     sb->s_type->name, retval);\n\t\t}\n\t}\n\tsb->s_flags = (sb->s_flags & ~MS_RMT_MASK) | (flags & MS_RMT_MASK);\n\tsmp_wmb();\n\tsb->s_readonly_remount = 0;\n\tif (remount_ro && sb->s_bdev)\n\t\tinvalidate_bdev(sb->s_bdev);\n\treturn 0;\ncancel_readonly:\n\tsb->s_readonly_remount = 0;\n\treturn retval;\n}", "target": 1}
{"code": "archive_read_format_zip_read_data_skip_seekable(struct archive_read *a)\n{\n\tstruct zip *zip;\n\tzip = (struct zip *)(a->format->data);\n\tzip->unconsumed = 0;\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static int read_file_dentry_set(struct exfat_de_iter *iter,\n\t\t\t\tstruct exfat_inode **new_node, int *skip_dentries)\n{\n\tstruct exfat_dentry *file_de, *stream_de, *dentry;\n\tstruct exfat_inode *node = NULL;\n\tint i, ret;\n\tret = exfat_de_iter_get(iter, 0, &file_de);\n\tif (ret || file_de->type != EXFAT_FILE) {\n\t\texfat_debug(\"failed to get file dentry\\n\");\n\t\treturn -EINVAL;\n\t}\n\tret = exfat_de_iter_get(iter, 1, &stream_de);\n\tif (ret || stream_de->type != EXFAT_STREAM) {\n\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =\n\t\t((stream_de->stream_flags & EXFAT_SF_CONTIGUOUS) != 0);\n\tnode->size = le64_to_cpu(stream_de->stream_size);\n\t*skip_dentries = i;\n\t*new_node = node;\n\treturn 0;\nskip_dset:\n\t*new_node = NULL;\n\texfat_free_inode(node);\n\treturn -EINVAL;\n}", "target": 1}
{"code": "    bool isPrivate() const { return is_private; }", "target": 0}
{"code": "R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAnnotation *annotation = NULL;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tannotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);\n\tfor (i = 0; i < annotation->num_element_value_pairs; i++) {\n\t\tif (offset > sz) {\n\t\t\tbreak;\n\t\t}\n\t\tevps = r_bin_java_element_pair_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (evps) {\n\t\t\toffset += evps->size;\n\t\t\tr_list_append (annotation->element_value_pairs, (void *) evps);\n\t\t}\n\t}\n\tannotation->size = offset;\n\treturn annotation;\n}", "target": 1}
{"code": "MakeFilename(char *buffer, char *orig_name, int cnt, int max_chars)\n{\n        char *filename = malloc(PATH_MAX + 1);\n        if (filename == NULL)\n            error(\"%s: malloc\", __func__);\n        if (Gflag != 0) {\n          struct tm *local_tm;\n          if ((local_tm = localtime(&Gflag_time)) == NULL) {\n                  error(\"%s: localtime\", __func__);\n          }\n          strftime(filename, PATH_MAX, orig_name, local_tm);\n        } else {\n          strncpy(filename, orig_name, PATH_MAX);\n        }\n\tif (cnt == 0 && max_chars == 0)\n\t\tstrncpy(buffer, filename, PATH_MAX + 1);\n\telse\n\t\tif (snprintf(buffer, PATH_MAX + 1, \"%s%0*d\", filename, max_chars, cnt) > PATH_MAX)\n                  error(\"too many output files or filename is too long (> %d)\", PATH_MAX);\n        free(filename);\n}", "target": 1}
{"code": "int mp_unpack_full(lua_State *L, int limit, int offset) {\n    size_t len;\n    const char *s;\n    mp_cur c;\n    int cnt; \n    int decode_all = (!limit && !offset);\n    s = luaL_checklstring(L,1,&len); \n    if (offset < 0 || limit < 0) \n        return luaL_error(L,\n            \"Invalid request to unpack with offset of %d and limit of %d.\",\n            offset, len);\n    else if (offset > len)\n        return luaL_error(L,\n            \"Start offset %d greater than input length %d.\", offset, len);\n    if (decode_all) limit = INT_MAX;\n    mp_cur_init(&c,(const unsigned char *)s+offset,len-offset);\n    for(cnt = 0; c.left > 0 && cnt < limit; cnt++) {\n        mp_decode_to_lua_type(L,&c);\n        if (c.err == MP_CUR_ERROR_EOF) {\n            return luaL_error(L,\"Missing bytes in input.\");\n        } else if (c.err == MP_CUR_ERROR_BADFMT) {\n            return luaL_error(L,\"Bad data format in input.\");\n        }\n    }\n    if (!decode_all) {\n        int offset = len - c.left;\n        luaL_checkstack(L, 1, \"in function mp_unpack_full\");\n        lua_pushinteger(L, c.left == 0 ? -1 : offset);\n        lua_insert(L, 2);\n        cnt += 1; \n    }\n    return cnt;\n}", "target": 0}
{"code": "static int crypto_rsa_common(const BYTE* input, int length, UINT32 key_length, const BYTE* modulus,\n                             const BYTE* exponent, int exponent_size, BYTE* output)\n{\n\tBN_CTX* ctx;\n\tint output_length = -1;\n\tBYTE* input_reverse;\n\tBYTE* modulus_reverse;\n\tBYTE* exponent_reverse;\n\tBIGNUM *mod, *exp, *x, *y;\n\tinput_reverse = (BYTE*)malloc(2 * key_length + exponent_size);\n\tif (!input_reverse)\n\t\treturn -1;\n\tmodulus_reverse = input_reverse + key_length;\n\texponent_reverse = modulus_reverse + key_length;\n\tmemcpy(modulus_reverse, modulus, key_length);\n\tcrypto_reverse(modulus_reverse, key_length);\n\tmemcpy(exponent_reverse, exponent, exponent_size);\n\tcrypto_reverse(exponent_reverse, exponent_size);\n\tmemcpy(input_reverse, input, length);\n\tcrypto_reverse(input_reverse, length);\n\tif (!(ctx = BN_CTX_new()))\n\t\tgoto fail_bn_ctx;\n\tif (!(mod = BN_new()))\n\t\tgoto fail_bn_mod;\n\tif (!(exp = BN_new()))\n\t\tgoto fail_bn_exp;\n\tif (!(x = BN_new()))\n\t\tgoto fail_bn_x;\n\tif (!(y = BN_new()))\n\t\tgoto fail_bn_y;\n\tBN_bin2bn(modulus_reverse, key_length, mod);\n\tBN_bin2bn(exponent_reverse, exponent_size, exp);\n\tBN_bin2bn(input_reverse, length, x);\n\tBN_mod_exp(y, x, exp, mod, ctx);\n\toutput_length = BN_bn2bin(y, output);\n\tcrypto_reverse(output, output_length);\n\tif (output_length < (int)key_length)\n\t\tmemset(output + output_length, 0, key_length - output_length);\n\tBN_free(y);\nfail_bn_y:\n\tBN_clear_free(x);\nfail_bn_x:\n\tBN_free(exp);\nfail_bn_exp:\n\tBN_free(mod);\nfail_bn_mod:\n\tBN_CTX_free(ctx);\nfail_bn_ctx:\n\tfree(input_reverse);\n\treturn output_length;\n}", "target": 1}
{"code": "ModuleExport size_t RegisterXWDImage(void)\n{\n  MagickInfo\n    *entry;\n  entry=AcquireMagickInfo(\"XWD\",\"XWD\",\"X Windows system window dump (color)\");\n#if defined(MAGICKCORE_X11_DELEGATE)\n  entry->decoder=(DecodeImageHandler *) ReadXWDImage;\n  entry->encoder=(EncodeImageHandler *) WriteXWDImage;\n#endif\n  entry->magick=(IsImageFormatHandler *) IsXWD;\n  entry->flags|=CoderDecoderSeekableStreamFlag;\n  entry->flags^=CoderAdjoinFlag;\n  (void) RegisterMagickInfo(entry);\n  return(MagickImageCoderSignature);\n}", "target": 0}
{"code": "static void __reg_combine_min_max(struct bpf_reg_state *src_reg,\n\t\t\t\t  struct bpf_reg_state *dst_reg)\n{\n\tsrc_reg->umin_value = dst_reg->umin_value = max(src_reg->umin_value,\n\t\t\t\t\t\t\tdst_reg->umin_value);\n\tsrc_reg->umax_value = dst_reg->umax_value = min(src_reg->umax_value,\n\t\t\t\t\t\t\tdst_reg->umax_value);\n\tsrc_reg->smin_value = dst_reg->smin_value = max(src_reg->smin_value,\n\t\t\t\t\t\t\tdst_reg->smin_value);\n\tsrc_reg->smax_value = dst_reg->smax_value = min(src_reg->smax_value,\n\t\t\t\t\t\t\tdst_reg->smax_value);\n\tsrc_reg->var_off = dst_reg->var_off = tnum_intersect(src_reg->var_off,\n\t\t\t\t\t\t\t     dst_reg->var_off);\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n\t__reg_deduce_bounds(src_reg);\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(src_reg);\n\t__reg_bound_offset(dst_reg);\n\t__update_reg_bounds(src_reg);\n\t__update_reg_bounds(dst_reg);\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_set_byte_offset(GF_ISOFile *file, s64 byte_offset)\n{\n\tif (!file) return GF_BAD_PARAM;\n\tfile->read_byte_offset = byte_offset;\n\treturn GF_OK;", "target": 0}
{"code": "ServerApp::help()\n{\n#if WINAPI_XWINDOWS\n#  define WINAPI_ARGS \\\n    \" [--display <display>] [--no-xinitthreads]\"\n#  define WINAPI_INFO \\\n    \"      --display <display>  connect to the X server at <display>\\n\" \\\n    \"      --no-xinitthreads    do not call XInitThreads()\\n\" \\\n    \"      --screen-change-script <path>\\n\" \\\n    \"                           full path to script to run on screen change\\n\" \\\n    \"                           first argument is the new screen name\\n\"\n#else\n#  define WINAPI_ARGS \"\"\n#  define WINAPI_INFO \"\"\n#endif\n    barrier::fs::path profile_path = argsBase().m_profileDirectory;\n    if (profile_path.empty()) {\n        profile_path = barrier::DataDirectories::profile();\n    }\n    auto usr_config_path = (profile_path / barrier::fs::u8path(USR_CONFIG_NAME)).u8string();\n    auto sys_config_path = (barrier::DataDirectories::systemconfig() /\n                            barrier::fs::u8path(SYS_CONFIG_NAME)).u8string();\n    std::ostringstream buffer;\n    buffer << \"Start the barrier server component.\\n\"\n           << \"\\n\"\n           << \"Usage: \" << args().m_exename\n           << \" [--address <address>]\"\n           << \" [--config <pathname>]\"\n           << WINAPI_ARGS << HELP_SYS_ARGS << HELP_COMMON_ARGS << \"\\n\"\n           << \"\\n\"\n           << \"Options:\\n\"\n           << \"  -a, --address <address>  listen for clients on the given address.\\n\"\n           << \"  -c, --config <pathname>  use the named configuration file instead.\\n\"\n           << HELP_COMMON_INFO_1 << WINAPI_INFO << HELP_SYS_INFO << HELP_COMMON_INFO_2 << \"\\n\"\n           << \"Default options are marked with a *\\n\"\n           << \"\\n\"\n           << \"The argument for --address is of the form: [<hostname>][:<port>].  The\\n\"\n           << \"hostname must be the address or hostname of an interface on the system.\\n\"\n           << \"Placing brackets around an IPv6 address is required when also specifying \\n\"\n           << \"a port number and optional otherwise. The default is to listen on all\\n\"\n           << \"interfaces using port number \" << kDefaultPort << \".\\n\"\n           << \"\\n\"\n           << \"If no configuration file pathname is provided then the first of the\\n\"\n           << \"following to load successfully sets the configuration:\\n\"\n           << \"  \" << usr_config_path << \"\\n\"\n           << \"  \" << sys_config_path << \"\\n\";\n    LOG((CLOG_PRINT \"%s\", buffer.str().c_str()));\n}", "target": 1}
{"code": "int rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n        if (rom->romsize > rom->datasize) {\n            d += l;\n            l = rom->romsize - rom->datasize;\n            if ((d + l) > (dest + size)) {\n                l = dest - d;\n            }\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n    return (d + l) - dest;\n}", "target": 1}
{"code": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "void APE::Properties::analyzeCurrent()\n{\n  d->file->seek(2, File::Current);\n  ByteVector descriptor = d->file->readBlock(44);\n  uint descriptorBytes = descriptor.mid(0,4).toUInt(false);\n  if ((descriptorBytes - 52) > 0)\n    d->file->seek(descriptorBytes - 52, File::Current);\n  ByteVector header = d->file->readBlock(24);\n  d->channels = header.mid(18, 2).toShort(false);\n  d->sampleRate = header.mid(20, 4).toUInt(false);\n  d->bitsPerSample = header.mid(16, 2).toShort(false);\n  uint totalFrames = header.mid(12, 4).toUInt(false);\n  uint blocksPerFrame = header.mid(4, 4).toUInt(false);\n  uint finalFrameBlocks = header.mid(8, 4).toUInt(false);\n  uint totalBlocks = totalFrames > 0 ? (totalFrames -  1) * blocksPerFrame + finalFrameBlocks : 0;\n  d->length = totalBlocks / d->sampleRate;\n  d->bitrate = d->length > 0 ? ((d->streamLength * 8L) / d->length) / 1000 : 0;\n}", "target": 1}
{"code": "struct crypto_template *crypto_lookup_template(const char *name)\n{\n\treturn try_then_request_module(__crypto_lookup_template(name), \"%s\",\n\t\t\t\t       name);\n}", "target": 1}
{"code": "  void decode(bufferlist::iterator& bl) {\n    __u8 struct_v;\n    ::decode(struct_v, bl);\n    ::decode(nonce, bl);\n    if (struct_v >= 2) {\n      ::decode(have_challenge, bl);\n      ::decode(server_challenge_plus_one, bl);\n    }\n  }", "target": 0}
{"code": "static inline void sem_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "force_removal (Device *device,\n               ForceRemovalCompleteFunc callback,\n               gpointer user_data)\n{\n  if (device->priv->device_is_mounted && device->priv->device_mount_paths->len > 0)\n    {\n      gboolean remove_dir_on_unmount;\n      if (mount_file_has_device (device->priv->device_file, NULL, &remove_dir_on_unmount) ||\n          is_device_in_fstab (device, NULL))\n        {\n          g_print (\"**** NOTE: Force unmounting device %s\\n\", device->priv->device_file);\n          force_unmount (device, callback, user_data);\n          goto pending;\n        }\n    }\n  if (device->priv->id_usage != NULL && strcmp (device->priv->id_usage, \"crypto\") == 0)\n    {\n      GList *devices;\n      GList *l;\n      devices = daemon_local_get_all_devices (device->priv->daemon);\n      for (l = devices; l != NULL; l = l->next)\n        {\n          Device *d = DEVICE (l->data);\n          if (d->priv->device_is_luks_cleartext && d->priv->luks_cleartext_slave != NULL\n              && strcmp (d->priv->luks_cleartext_slave, device->priv->object_path) == 0)\n            {\n              if (d->priv->dm_name != NULL && g_str_has_prefix (d->priv->dm_name, \"udisks-luks-uuid-\"))\n                {\n                  g_print (\"**** NOTE: Force luks teardown device %s (cleartext %s)\\n\",\n                           device->priv->device_file,\n                           d->priv->device_file);\n                  force_luks_teardown (device, d, callback, user_data);\n                  goto pending;\n                }\n            }\n        }\n    }\n  if (callback != NULL)\n    callback (device, TRUE, user_data);\n pending:\n  ;\n}", "target": 0}
{"code": "int mingw_rmdir(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\twhile ((ret = _wrmdir(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\terrno = err_win_to_posix(GetLastError());\n\t\tif (errno != EACCES)\n\t\t\tbreak;\n\t\tif (!is_dir_empty(wpathname)) {\n\t\t\terrno = ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && errno == EACCES && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Deletion of directory '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wrmdir(wpathname);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}", "target": 0}
{"code": "apr_byte_t oidc_cache_set(request_rec *r, const char *section, const char *key,\n\t\tconst char *value, apr_time_t expiry) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint encrypted = oidc_cfg_cache_encrypt(r);\n\tchar *encoded = NULL;\n\tapr_byte_t rc = FALSE;\n\tchar *msg = NULL;\n\toidc_debug(r,\n\t\t\t\"enter: %s (section=%s, len=%d, encrypt=%d, ttl(s)=%\" APR_TIME_T_FMT \", type=%s)\",\n\t\t\tkey, section, value ? (int )strlen(value) : 0, encrypted,\n\t\t\t\t\tapr_time_sec(expiry - apr_time_now()), cfg->cache->name);\n\tif (encrypted == 1) {\n\t\tkey = oidc_cache_get_hashed_key(r, cfg->crypto_passphrase, key);\n\t\tif (key == NULL)\n\t\t\tgoto out;\n\t\tif (value != NULL) {\n\t\t\tif (oidc_cache_crypto_encrypt(r, value,\n\t\t\t\t\toidc_cache_hash_passphrase(r, cfg->crypto_passphrase),\n\t\t\t\t\t&encoded) <= 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = encoded;\n\t\t}\n\t}\n\trc = cfg->cache->set(r, section, key, value, expiry);\nout:\n\tmsg = apr_psprintf(r->pool, \"%d bytes in %s cache backend for %skey %s\",\n\t\t\t(value ? (int) strlen(value) : 0),\n\t\t\t(cfg->cache->name ? cfg->cache->name : \"\"),\n\t\t\t(encrypted ? \"encrypted \" : \"\"), (key ? key : \"\"));\n\tif (rc == TRUE)\n\t\toidc_debug(r, \"successfully stored %s\", msg);\n\telse\n\t\toidc_warn(r, \"could NOT store %s\", msg);\n\treturn rc;\n}", "target": 1}
{"code": "SWFShape_setLeftFillStyle(SWFShape shape, SWFFillStyle fill)\n{\n\tShapeRecord record;\n\tint idx;\n\tif ( shape->isEnded || shape->isMorph )\n\t\treturn;\n\tif(fill == NOFILL)\n\t{\n\t\trecord = addStyleRecord(shape);\n\t\trecord.record.stateChange->leftFill = 0;\n\t\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n\t\treturn;\n\t}\n\tidx = getFillIdx(shape, fill);\n\tif(idx == 0) \n\t{\n\t\tSWFFillStyle_addDependency(fill, (SWFCharacter)shape);\n\t\tif(addFillStyle(shape, fill) < 0)\n\t\t\treturn;\t\t\n\t\tidx = getFillIdx(shape, fill);\n\t}\n\telse if (idx >= 255 && shape->useVersion == SWF_SHAPE1)\n\t{\n\t\tSWF_error(\"Too many fills for SWFShape V1.\\n\" \n\t\t\t  \"Use a higher SWFShape version\\n\");\n\t}\n\trecord = addStyleRecord(shape);\n\trecord.record.stateChange->leftFill = idx;\n\trecord.record.stateChange->flags |= SWF_SHAPE_FILLSTYLE0FLAG;\n}", "target": 0}
{"code": "MagickExport MagickBooleanType RegisterStaticModule(const char *module,\n  ExceptionInfo *exception)\n{\n  char\n    module_name[MagickPathExtent];\n  PolicyRights\n    rights;\n  const CoderInfo\n    *p;\n  size_t\n    extent;\n  ssize_t\n    i;\n  assert(module != (const char *) NULL);\n  (void) CopyMagickString(module_name,module,MagickPathExtent);\n  p=GetCoderInfo(module,exception);\n  if (p != (CoderInfo *) NULL)\n    (void) CopyMagickString(module_name,p->name,MagickPathExtent);\n  rights=ReadPolicyRights|WritePolicyRights;\n  if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",module);\n      return(MagickFalse);\n    }\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n    if (LocaleCompare(MagickModules[i].module,module_name) == 0)\n      {\n        if (MagickModules[i].registered == MagickFalse)\n          {\n            (void) (MagickModules[i].register_module)();\n            MagickModules[i].registered=MagickTrue;\n          }\n        return(MagickTrue);\n      }\n  return(MagickFalse);\n}", "target": 0}
{"code": "htmlGetText(tree_t *t)\t\t\n{\n  uchar\t\t*s,\t\t\n\t\t*s2,\t\t\n\t\t*tdata = NULL,\t\n\t\t*talloc = NULL;\t\n  size_t\tslen,\t\t\n\t\ttlen;\t\t\n  slen = 0;\n  s    = NULL;\n  while (t != NULL)\n  {\n    if (t->child)\n      tdata = talloc = htmlGetText(t->child);\n    else\n      tdata = t->data;\n    if (tdata != NULL)\n    {\n      tlen = strlen((char *)tdata);\n      if (s)\n        s2 = (uchar *)realloc(s, 1 + slen + tlen);\n      else\n        s2 = (uchar *)malloc(1 + tlen);\n      if (!s2)\n        break;\n      s = s2;\n      memcpy((char *)s + slen, (char *)tdata, tlen);\n      slen += tlen;\n      if (talloc)\n      {\n\tfree(talloc);\n\ttalloc = NULL;\n      }\n    }\n    t = t->next;\n  }\n  if (slen)\n    s[slen] = '\\0';\n  if (talloc)\n    free(talloc);\n  return (s);\n}", "target": 1}
{"code": "snmp_oid_cmp_oid(uint32_t *oid1, uint32_t *oid2)\n{\n  uint8_t i;\n  i = 0;\n  while(oid1[i] != ((uint32_t)-1) &&\n        oid2[i] != ((uint32_t)-1)) {\n    if(oid1[i] != oid2[i]) {\n      if(oid1[i] < oid2[i]) {\n        return -1;\n      }\n      return 1;\n    }\n    i++;\n  }\n  if(oid1[i] == ((uint32_t)-1) &&\n     oid2[i] != ((uint32_t)-1)) {\n    return -1;\n  }\n  if(oid1[i] != ((uint32_t)-1) &&\n     oid2[i] == ((uint32_t)-1)) {\n    return 1;\n  }\n  return 0;\n}", "target": 1}
{"code": "static InspectionBuffer *GetHttp1HeaderData(DetectEngineThreadCtx *det_ctx, const uint8_t flags,\n        const DetectEngineTransforms *transforms, Flow *f, const struct MpmListIdDataArgs *cbdata,\n        int list_id)\n{\n    SCEnter();\n    InspectionBuffer *buffer =\n            InspectionBufferMultipleForListGet(det_ctx, list_id, cbdata->local_id);\n    if (buffer == NULL)\n        return NULL;\n    if (buffer->initialized)\n        return buffer;\n    HttpHeaderThreadData *hdr_td = NULL;\n    HttpHeaderBuffer *buf =\n            HttpHeaderGetBufferSpace(det_ctx, f, flags, g_keyword_thread_id, &hdr_td);\n    if (unlikely(buf == NULL)) {\n        return NULL;\n    }\n    htp_tx_t *tx = (htp_tx_t *)cbdata->txv;\n    htp_table_t *headers;\n    if (flags & STREAM_TOSERVER) {\n        headers = tx->request_headers;\n    } else {\n        headers = tx->response_headers;\n    }\n    if (cbdata->local_id < htp_table_size(headers)) {\n        htp_header_t *h = htp_table_get_index(headers, cbdata->local_id, NULL);\n        size_t size1 = bstr_size(h->name);\n        size_t size2 = bstr_size(h->value);\n        size_t b_len = size1 + 2 + size2;\n        if (b_len > buf->size) {\n            if (HttpHeaderExpandBuffer(hdr_td, buf, b_len) != 0) {\n                return NULL;\n            }\n        }\n        memcpy(buf->buffer, bstr_ptr(h->name), bstr_size(h->name));\n        buf->buffer[size1] = ':';\n        buf->buffer[size1 + 1] = ' ';\n        memcpy(buf->buffer + size1 + 2, bstr_ptr(h->value), bstr_size(h->value));\n        buf->len = b_len;\n    } else {\n        InspectionBufferSetupMultiEmpty(buffer);\n        return NULL;\n    }\n    if (buf->len == 0) {\n        InspectionBufferSetupMultiEmpty(buffer);\n        return NULL;\n    }\n    InspectionBufferSetupMulti(buffer, transforms, buf->buffer, buf->len);\n    SCReturnPtr(buffer, \"InspectionBuffer\");\n}", "target": 1}
{"code": "void LibRaw::lch_to_rgb(double (*image2)[3])\n{\n  int indx;\n  for (indx = 0; indx < height * width; indx++)\n  {\n    image[indx][0] = CLIP(image2[indx][0] / 3.0 - image2[indx][2] / 6.0 +\n                          image2[indx][1] / 3.464101615);\n    image[indx][1] = CLIP(image2[indx][0] / 3.0 - image2[indx][2] / 6.0 -\n                          image2[indx][1] / 3.464101615);\n    image[indx][2] = CLIP(image2[indx][0] / 3.0 + image2[indx][2] / 3.0);\n  }\n}", "target": 0}
{"code": "void rose_start_t3timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t3;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "INST_HANDLER (cpse) {\t\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "static ssize_t ext4_ext_direct_IO(int rw, struct kiocb *iocb,\n\t\t\t      const struct iovec *iov, loff_t offset,\n\t\t\t      unsigned long nr_segs)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tsize_t count = iov_length(iov, nr_segs);\n\tloff_t final_size = offset + count;\n\tif (rw == WRITE && final_size <= inode->i_size) {\n\t\tiocb->private = NULL;\n\t\tEXT4_I(inode)->cur_aio_dio = NULL;\n\t\tif (!is_sync_kiocb(iocb)) {\n\t\t\tiocb->private = ext4_init_io_end(inode);\n\t\t\tif (!iocb->private)\n\t\t\t\treturn -ENOMEM;\n\t\t\tEXT4_I(inode)->cur_aio_dio = iocb->private;\n\t\t}\n\t\tret = blockdev_direct_IO(rw, iocb, inode,\n\t\t\t\t\t inode->i_sb->s_bdev, iov,\n\t\t\t\t\t offset, nr_segs,\n\t\t\t\t\t ext4_get_block_write,\n\t\t\t\t\t ext4_end_io_dio);\n\t\tif (iocb->private)\n\t\t\tEXT4_I(inode)->cur_aio_dio = NULL;\n\t\tif (ret != -EIOCBQUEUED && ret <= 0 && iocb->private) {\n\t\t\text4_free_io_end(iocb->private);\n\t\t\tiocb->private = NULL;\n\t\t} else if (ret > 0 && ext4_test_inode_state(inode,\n\t\t\t\t\t\tEXT4_STATE_DIO_UNWRITTEN)) {\n\t\t\tint err;\n\t\t\terr = ext4_convert_unwritten_extents(inode,\n\t\t\t\t\t\t\t     offset, ret);\n\t\t\tif (err < 0)\n\t\t\t\tret = err;\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t\t}\n\t\treturn ret;\n\t}\n\treturn ext4_ind_direct_IO(rw, iocb, iov, offset, nr_segs);\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n        comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n        return true;\n    }", "target": 1}
{"code": "void MoveTo(double x1,double y1) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f m\",x1,y1);\n}", "target": 1}
{"code": "static int nested_vmx_check_msr_switch(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned long count_field,\n\t\t\t\t       unsigned long addr_field)\n{\n\tint maxphyaddr;\n\tu64 count, addr;\n\tif (vmcs12_read_any(vcpu, count_field, &count) ||\n\t    vmcs12_read_any(vcpu, addr_field, &addr)) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tif (count == 0)\n\t\treturn 0;\n\tmaxphyaddr = cpuid_maxphyaddr(vcpu);\n\tif (!IS_ALIGNED(addr, 16) || addr >> maxphyaddr ||\n\t    (addr + count * sizeof(struct vmx_msr_entry) - 1) >> maxphyaddr) {\n\t\tpr_warn_ratelimited(\n\t\t\t\"nVMX: invalid MSR switch (0x%lx, %d, %llu, 0x%08llx)\",\n\t\t\taddr_field, maxphyaddr, count, addr);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int ntlm_read_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tif ((fields->BufferOffset + fields->Len) > Stream_Length(s))\n\t\t\treturn -1;\n\t\tfields->Buffer = (PBYTE) malloc(fields->Len);\n\t\tif (!fields->Buffer)\n\t\t\treturn -1;\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Read(s, fields->Buffer, fields->Len);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)\n{\n    int i, j, v;\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->intra_matrix[j]        = v;\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            v = get_bits(gb, 8);\n            j = s->idsp.idct_permutation[ff_zigzag_direct[i]];\n            s->chroma_intra_matrix[j] = v;\n        }\n    }\n    if (get_bits1(gb)) {\n        for (i = 0; i < 64; i++) {\n            get_bits(gb, 8);\n        }\n    }\n    next_start_code_studio(gb);\n}", "target": 1}
{"code": "mm_malloc(struct mm_master *mm, size_t size)\n{\n\tstruct mm_share *mms, *tmp;\n\tif (size == 0)\n\t\tfatal(\"mm_malloc: try to allocate 0 space\");\n\tif (size > SIZE_MAX - MM_MINSIZE + 1)\n\t\tfatal(\"mm_malloc: size too big\");\n\tsize = ((size + (MM_MINSIZE - 1)) / MM_MINSIZE) * MM_MINSIZE;\n\tRB_FOREACH(mms, mmtree, &mm->rb_free) {\n\t\tif (mms->size >= size)\n\t\t\tbreak;\n\t}\n\tif (mms == NULL)\n\t\treturn (NULL);\n\tmemset(mms->address, 0xd0, size);\n\ttmp = mm_make_entry(mm, &mm->rb_allocated, mms->address, size);\n\tmms->size -= size;\n\tmms->address = (char *)mms->address + size;\n\tif (mms->size == 0) {\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t}\n\treturn (tmp->address);\n}", "target": 1}
{"code": "static int l2cap_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_BOUND || sock->type != SOCK_SEQPACKET) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\tif (!l2cap_pi(sk)->psm) {\n\t\tbdaddr_t *src = &bt_sk(sk)->src;\n\t\tu16 psm;\n\t\terr = -EINVAL;\n\t\twrite_lock_bh(&l2cap_sk_list.lock);\n\t\tfor (psm = 0x1001; psm < 0x1100; psm += 2)\n\t\t\tif (!__l2cap_get_sock_by_addr(cpu_to_le16(psm), src)) {\n\t\t\t\tl2cap_pi(sk)->psm   = cpu_to_le16(psm);\n\t\t\t\tl2cap_pi(sk)->sport = cpu_to_le16(psm);\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\twrite_unlock_bh(&l2cap_sk_list.lock);\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t}\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "main (int argc, char *argv[])\n{\n  g_test_init (&argc, &argv, NULL);\n  g_test_add_func (\"/context/env\", test_context_env);\n  g_test_add_func (\"/context/env-fd\", test_context_env_fd);\n  g_test_add_func (\"/context/merge-fs\", test_context_merge_fs);\n  g_test_add_func (\"/context/validate-path-args\", test_validate_path_args);\n  g_test_add_func (\"/context/validate-path-meta\", test_validate_path_meta);\n  return g_test_run ();\n}", "target": 0}
{"code": "static void get_nb10(ut8* dbg_data, SCV_NB10_HEADER* res) {\n\tconst int nb10sz = 16;\n\tmemcpy (res, dbg_data, nb10sz);\n\tres->file_name = (ut8*) strdup ((const char*) dbg_data + nb10sz);\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  TF_LITE_ENSURE_TYPES_EQ(context, output->type, input->type);\n  TF_LITE_ENSURE_EQ(context, output->bytes, input->bytes);\n  TF_LITE_ENSURE_EQ(context, output->dims->size, input->dims->size);\n  for (int i = 0; i < output->dims->size; ++i) {\n    TF_LITE_ENSURE_EQ(context, output->dims->data[i], input->dims->data[i]);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n{\n  FILE\n    *input,\n    *output;\n  int\n    c;\n  register ssize_t\n    i;\n  if (ExpandFilenames(&argc,&argv) == MagickFalse)\n    ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n  output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n    input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n        ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n        continue;\n      }\n    for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n    (void) fclose(input);\n    (void) remove_utf8(argv[i]);\n  }\n  (void) fclose(output);\n  return(MagickTrue);\n}", "target": 1}
{"code": "int intel_execlists_submission_setup(struct intel_engine_cs *engine)\n{\n\ttasklet_init(&engine->execlists.tasklet,\n\t\t     execlists_submission_tasklet, (unsigned long)engine);\n\ttimer_setup(&engine->execlists.timer, execlists_timeslice, 0);\n\ttimer_setup(&engine->execlists.preempt, execlists_preempt, 0);\n\tlogical_ring_default_vfuncs(engine);\n\tlogical_ring_default_irqs(engine);\n\tif (engine->class == RENDER_CLASS)\n\t\trcs_submission_override(engine);\n\treturn 0;\n}", "target": 0}
{"code": "validate_event(struct pmu_hw_events *hw_events,\n\t       struct perf_event *event)\n{\n\tstruct arm_pmu *armpmu = to_arm_pmu(event->pmu);\n\tstruct hw_perf_event fake_event = event->hw;\n\tstruct pmu *leader_pmu = event->group_leader->pmu;\n\tif (is_software_event(event))\n\t\treturn 1;\n\tif (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF)\n\t\treturn 1;\n\tif (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec)\n\t\treturn 1;\n\treturn armpmu->get_event_idx(hw_events, &fake_event) >= 0;\n}", "target": 1}
{"code": "static int dp8393x_receive_filter(dp8393xState *s, const uint8_t * buf,\n                                  int size)\n{\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n    int i;\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_PRO) && (buf[0] & 1) == 0) {\n        return 0;\n    }\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_AMC) && (buf[0] & 1) == 1) {\n        return SONIC_RCR_MC;\n    }\n    if ((s->regs[SONIC_RCR] & SONIC_RCR_BRD) && !memcmp(buf, bcast, sizeof(bcast))) {\n        return SONIC_RCR_BC;\n    }\n    for (i = 0; i < 16; i++) {\n        if (s->regs[SONIC_CE] & (1 << i)) {\n             if (!memcmp(buf, s->cam[i], sizeof(s->cam[i]))) {\n                 return 0;\n             }\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "ff_layout_get_ds_info(struct inode *inode)\n{\n\tstruct pnfs_layout_hdr *layout = NFS_I(inode)->layout;\n\tif (layout == NULL)\n\t\treturn NULL;\n\treturn &FF_LAYOUT_FROM_HDR(layout)->commit_info;\n}", "target": 0}
{"code": "x509_vfy_callback_indicate_completion(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}", "target": 0}
{"code": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}", "target": 1}
{"code": "_TIFFmalloc(tmsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\treturn (malloc((size_t) s));\n}", "target": 0}
{"code": "spnego_gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t\t  gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t\t  int iov_count)\n{\n    return gss_verify_mic_iov(minor_status, context_handle, qop_state, iov,\n\t\t\t      iov_count);\n}", "target": 1}
{"code": "static void validate_set_si_mode(struct bnx2x *bp)\n{\n\tu8 func = BP_ABS_FUNC(bp);\n\tu32 val;\n\tval = MF_CFG_RD(bp, func_mf_config[func].mac_upper);\n\tif (val != 0xffff) {\n\t\tbp->mf_mode = MULTI_FUNCTION_SI;\n\t\tbp->mf_config[BP_VN(bp)] =\n\t\t\tMF_CFG_RD(bp, func_mf_config[func].config);\n\t} else\n\t\tBNX2X_DEV_INFO(\"illegal MAC address for SI\\n\");\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& handle = ctx->input(0);\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(handle.shape()),\n                errors::InvalidArgument(\"handle must be scalar\"));\n    const string& name = handle.scalar<tstring>()();\n    Tensor val;\n    auto session_state = ctx->session_state();\n    OP_REQUIRES(ctx, session_state != nullptr,\n                errors::FailedPrecondition(\n                    \"GetSessionTensor called on null session state\"));\n    OP_REQUIRES_OK(ctx, session_state->GetTensor(name, &val));\n    ctx->set_output(0, val);\n  }", "target": 0}
{"code": "nvkm_vmm_free_remove(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\trb_erase(&vma->tree, &vmm->free);\n}", "target": 0}
{"code": "int wc_SignatureGenerateHash(\n    enum wc_HashType hash_type, enum wc_SignatureType sig_type,\n    const byte* hash_data, word32 hash_len,\n    byte* sig, word32 *sig_len,\n    const void* key, word32 key_len, WC_RNG* rng)\n{\n    return wc_SignatureGenerateHash_ex(hash_type, sig_type, hash_data, hash_len,\n        sig, sig_len, key, key_len, rng, 1);\n}", "target": 0}
{"code": "define_function(foobar)\n{\n  int64_t arg = integer_argument(1);\n  switch (arg)\n  {\n    case 1:\n      return_string(\"foo\");\n      break;\n    case 2:\n      return_string(\"bar\");\n      break;\n  }\n  return_string(\"oops\")\n}", "target": 0}
{"code": "static MagickBooleanType WritePTIFImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  Image\n    *images,\n    *next,\n    *pyramid_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  PointInfo\n    resolution;\n  size_t\n    columns,\n    rows;\n  images=NewImageList();\n  for (next=image; next != (Image *) NULL; next=GetNextImageInList(next))\n  {\n    Image\n      *clone_image;\n    clone_image=CloneImage(next,0,0,MagickFalse,exception);\n    if (clone_image == (Image *) NULL)\n      break;\n    clone_image->previous=NewImageList();\n    clone_image->next=NewImageList();\n    (void) SetImageProperty(clone_image,\"tiff:subfiletype\",\"none\",exception);\n    AppendImageToList(&images,clone_image);\n    columns=next->columns;\n    rows=next->rows;\n    resolution=next->resolution;\n    while ((columns > 64) && (rows > 64))\n    {\n      columns/=2;\n      rows/=2;\n      resolution.x/=2;\n      resolution.y/=2;\n      pyramid_image=ResizeImage(next,columns,rows,image->filter,exception);\n      if (pyramid_image == (Image *) NULL)\n        break;\n      pyramid_image->resolution=resolution;\n      (void) SetImageProperty(pyramid_image,\"tiff:subfiletype\",\"REDUCEDIMAGE\",\n        exception);\n      AppendImageToList(&images,pyramid_image);\n    }\n  }\n  if (images != (Image *) NULL)\n    {\n      images=GetFirstImageInList(images);\n      write_info=CloneImageInfo(image_info);\n      write_info->adjoin=MagickTrue;\n      (void) CopyMagickString(write_info->magick,\"TIFF\",MagickPathExtent);\n      (void) CopyMagickString(images->magick,\"TIFF\",MagickPathExtent);\n      status=WriteTIFFImage(write_info,images,exception);\n      images=DestroyImageList(images);\n      write_info=DestroyImageInfo(write_info);\n    }\n  return(status);\n}", "target": 0}
{"code": "static int generate(struct crypto_rng *tfm, const u8 *src, unsigned int slen,\n\t\t    u8 *dst, unsigned int dlen)\n{\n\treturn crypto_old_rng_alg(tfm)->rng_make_random(tfm, dst, dlen);\n}", "target": 1}
{"code": "virSecuritySELinuxRestoreMemoryLabel(virSecurityManager *mgr,\n                                     virDomainDef *def,\n                                     virDomainMemoryDef *mem)\n{\n    int ret = -1;\n    virSecurityLabelDef *seclabel;\n    switch (mem->model) {\n    case VIR_DOMAIN_MEMORY_MODEL_NVDIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_VIRTIO_PMEM:\n        seclabel = virDomainDefGetSecurityLabelDef(def, SECURITY_SELINUX_NAME);\n        if (!seclabel || !seclabel->relabel)\n            return 0;\n        ret = virSecuritySELinuxRestoreFileLabel(mgr, mem->nvdimmPath, true);\n        break;\n    case VIR_DOMAIN_MEMORY_MODEL_DIMM:\n    case VIR_DOMAIN_MEMORY_MODEL_NONE:\n    case VIR_DOMAIN_MEMORY_MODEL_LAST:\n        ret = 0;\n        break;\n    }\n    return ret;\n}", "target": 0}
{"code": "static void xennet_make_txreqs(\n\tstruct xennet_gnttab_make_txreq *info,\n\tstruct page *page,\n\tunsigned int offset, unsigned int len)\n{\n\tpage += offset >> PAGE_SHIFT;\n\toffset &= ~PAGE_MASK;\n\twhile (len) {\n\t\tinfo->page = page;\n\t\tinfo->size = 0;\n\t\tgnttab_foreach_grant_in_range(page, offset, len,\n\t\t\t\t\t      xennet_make_one_txreq,\n\t\t\t\t\t      info);\n\t\tpage++;\n\t\toffset = 0;\n\t\tlen -= info->size;\n\t}\n}", "target": 0}
{"code": "static int userfaultfd_release(struct inode *inode, struct file *file)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev;\n\tstruct userfaultfd_wake_range range = { .len = 0, };\n\tunsigned long new_flags;\n\tWRITE_ONCE(ctx->released, true);\n\tif (!mmget_not_zero(mm))\n\t\tgoto wakeup;\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto skip_mm;\n\tprev = NULL;\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tcond_resched();\n\t\tBUG_ON(!!vma->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\t\tif (vma->vm_userfaultfd_ctx.ctx != ctx) {\n\t\t\tprev = vma;\n\t\t\tcontinue;\n\t\t}\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,\n\t\t\t\t new_flags, vma->anon_vma,\n\t\t\t\t vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX);\n\t\tif (prev)\n\t\t\tvma = prev;\n\t\telse\n\t\t\tprev = vma;\n\t\tvma->vm_flags = new_flags;\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t}\nskip_mm:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nwakeup:\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL, &range);\n\t__wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, &range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\twake_up_all(&ctx->event_wqh);\n\twake_up_poll(&ctx->fd_wqh, EPOLLHUP);\n\tuserfaultfd_ctx_put(ctx);\n\treturn 0;\n}", "target": 0}
{"code": "DownloadProxy* WebProcessProxy::createDownloadProxy()\n{\n#if ENABLE(NETWORK_PROCESS)\n    ASSERT(!m_context->usesNetworkProcess());\n#endif\n    if (!m_downloadProxyMap)\n        m_downloadProxyMap = adoptPtr(new DownloadProxyMap(m_messageReceiverMap));\n    return m_downloadProxyMap->createDownloadProxy(m_context.get());\n}", "target": 0}
{"code": "AudioContext* AudioContext::create(Document& document, ExceptionState& exceptionState)\n{\n    ASSERT(isMainThread());\n    if (s_hardwareContextCount >= MaxHardwareContexts) {\n        exceptionState.throwDOMException(\n            SyntaxError,\n            \"number of hardware contexts reached maximum (\" + String::number(MaxHardwareContexts) + \").\");\n        return 0;\n    }\n    AudioContext* audioContext = new AudioContext(&document);\n    audioContext->suspendIfNeeded();\n    return audioContext;\n}", "target": 0}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  size_t * D = (size_t *) dest;\n  size_t * S = (size_t *) src;\n  size_t L = len / sizeof(size_t);\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] ^= S[i];\n}", "target": 1}
{"code": "redraw_win_toolbar(win_T *wp)\n{\n    vimmenu_T\t*menu;\n    int\t\titem_idx = 0;\n    int\t\titem_count = 0;\n    int\t\tcol = 0;\n    int\t\tnext_col;\n    int\t\toff = (int)(current_ScreenLine - ScreenLines);\n    int\t\tfill_attr = syn_name2attr((char_u *)\"ToolbarLine\");\n    int\t\tbutton_attr = syn_name2attr((char_u *)\"ToolbarButton\");\n    vim_free(wp->w_winbar_items);\n    FOR_ALL_CHILD_MENUS(wp->w_winbar, menu)\n\t++item_count;\n    wp->w_winbar_items = ALLOC_CLEAR_MULT(winbar_item_T, item_count + 1);\n    for (menu = wp->w_winbar->children;\n\t\t\t  menu != NULL && col < wp->w_width; menu = menu->next)\n    {\n\tspace_to_screenline(off + col, fill_attr);\n\tif (++col >= wp->w_width)\n\t    break;\n\tif (col > 1)\n\t{\n\t    space_to_screenline(off + col, fill_attr);\n\t    if (++col >= wp->w_width)\n\t\tbreak;\n\t}\n\twp->w_winbar_items[item_idx].wb_startcol = col;\n\tspace_to_screenline(off + col, button_attr);\n\tif (++col >= wp->w_width)\n\t    break;\n\tnext_col = text_to_screenline(wp, menu->name, col);\n\twhile (col < next_col)\n\t{\n\t    ScreenAttrs[off + col] = button_attr;\n\t    ++col;\n\t}\n\twp->w_winbar_items[item_idx].wb_endcol = col;\n\twp->w_winbar_items[item_idx].wb_menu = menu;\n\t++item_idx;\n\tif (col >= wp->w_width)\n\t    break;\n\tspace_to_screenline(off + col, button_attr);\n\t++col;\n    }\n    while (col < wp->w_width)\n    {\n\tspace_to_screenline(off + col, fill_attr);\n\t++col;\n    }\n    wp->w_winbar_items[item_idx].wb_menu = NULL; \n    screen_line(wp->w_winrow, wp->w_wincol, (int)wp->w_width,\n\t\t\t\t\t\t\t  (int)wp->w_width, 0);\n}", "target": 0}
{"code": "void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n  w = r.width();\n  h = r.height();\n  b = format.bpp/8;\n  if (h == 0)\n    return;\n  buf = getBufferRW(r, &stride);\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n    }\n  } else {\n    U8 *start;\n    int w1;\n    start = buf;\n    w1 = w;\n    while (w1--) {\n      memcpy(buf, pix, b);\n      buf += b;\n    }\n    buf += (stride - w) * b;\n    h--;\n    while (h--) {\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n  commitBufferRW(r);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, MaxMinBadHintSelectsReverseIndex) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"a\" << -1));\n    runInvalidQueryFull(BSONObj(),\n                        BSONObj(),\n                        BSONObj(),\n                        0,\n                        0,\n                        fromjson(\"{a: 1}\"),\n                        fromjson(\"{a: 8}\"),\n                        fromjson(\"{a: 2}\"),\n                        false);\n}", "target": 0}
{"code": "static int adpt_i2o_systab_send(adpt_hba* pHba)\n{\n\tu32 msg[12];\n\tint ret;\n\tmsg[0] = I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6;\n\tmsg[1] = I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID;\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tmsg[4] = (0<<16) | ((pHba->unit+2) << 12); \n\tmsg[5] = 0;\t\t\t\t   \n\tmsg[6] = 0x54000000 | sys_tbl_len;\n\tmsg[7] = (u32)sys_tbl_pa;\n\tmsg[8] = 0x54000000 | 0;\n\tmsg[9] = 0;\n\tmsg[10] = 0xD4000000 | 0;\n\tmsg[11] = 0;\n\tif ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 120))) {\n\t\tprintk(KERN_INFO \"%s: Unable to set SysTab (status=%#10x).\\n\", \n\t\t\tpHba->name, ret);\n\t}\n#ifdef DEBUG\n\telse {\n\t\tPINFO(\"%s: SysTab set.\\n\", pHba->name);\n\t}\n#endif\n\treturn ret;\t\n}", "target": 1}
{"code": "bool RenderWidgetHostImpl::SurfacePropertiesMismatch(\n    const RenderWidgetSurfaceProperties& first,\n    const RenderWidgetSurfaceProperties& second) const {\n#ifdef OS_ANDROID\n  if (enable_surface_synchronization_) {\n    RenderWidgetSurfaceProperties second_reduced = second;\n    second_reduced.top_controls_height = first.top_controls_height;\n    second_reduced.top_controls_shown_ratio = first.top_controls_shown_ratio;\n    second_reduced.bottom_controls_height = first.bottom_controls_height;\n    second_reduced.bottom_controls_shown_ratio =\n        first.bottom_controls_shown_ratio;\n    second_reduced.selection = first.selection;\n    return first != second_reduced;\n  }\n#endif\n  return first != second;\n}", "target": 0}
{"code": "DECLARESepPutFunc(putRGBseparate16bittile)\n{\n\tuint16 *wr = (uint16*) r;\n\tuint16 *wg = (uint16*) g;\n\tuint16 *wb = (uint16*) b;\n\t(void) img; (void) y; (void) a;\n\twhile (h-- > 0) {\n\t\tfor (x = 0; x < w; x++)\n\t\t\t*cp++ = PACK(img->Bitdepth16To8[*wr++],\n\t\t\t    img->Bitdepth16To8[*wg++],\n\t\t\t    img->Bitdepth16To8[*wb++]);\n\t\tSKEW(wr, wg, wb, fromskew);\n\t\tcp += toskew;\n\t}\n}", "target": 0}
{"code": "void check_system_chunk(struct btrfs_trans_handle *trans, u64 type)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tstruct btrfs_space_info *info;\n\tu64 left;\n\tu64 thresh;\n\tint ret = 0;\n\tu64 num_devs;\n\tlockdep_assert_held(&fs_info->chunk_mutex);\n\tinfo = btrfs_find_space_info(fs_info, BTRFS_BLOCK_GROUP_SYSTEM);\nagain:\n\tspin_lock(&info->lock);\n\tleft = info->total_bytes - btrfs_space_info_used(info, true);\n\tspin_unlock(&info->lock);\n\tnum_devs = get_profile_num_devs(fs_info, type);\n\tthresh = btrfs_calc_metadata_size(fs_info, num_devs) +\n\t\tbtrfs_calc_insert_metadata_size(fs_info, 1);\n\tif (left < thresh && btrfs_test_opt(fs_info, ENOSPC_DEBUG)) {\n\t\tbtrfs_info(fs_info, \"left=%llu, need=%llu, flags=%llu\",\n\t\t\t   left, thresh, type);\n\t\tbtrfs_dump_space_info(fs_info, info, 0, 0);\n\t}\n\tif (left < thresh) {\n\t\tu64 flags = btrfs_system_alloc_profile(fs_info);\n\t\tu64 reserved = atomic64_read(&cur_trans->chunk_bytes_reserved);\n\t\tif (reserved > trans->chunk_bytes_reserved) {\n\t\t\tconst u64 min_needed = reserved - thresh;\n\t\t\tmutex_unlock(&fs_info->chunk_mutex);\n\t\t\twait_event(cur_trans->chunk_reserve_wait,\n\t\t\t   atomic64_read(&cur_trans->chunk_bytes_reserved) <=\n\t\t\t   min_needed);\n\t\t\tmutex_lock(&fs_info->chunk_mutex);\n\t\t\tgoto again;\n\t\t}\n\t\tret = btrfs_alloc_chunk(trans, flags);\n\t}\n\tif (!ret) {\n\t\tret = btrfs_block_rsv_add(fs_info->chunk_root,\n\t\t\t\t\t  &fs_info->chunk_block_rsv,\n\t\t\t\t\t  thresh, BTRFS_RESERVE_NO_FLUSH);\n\t\tif (!ret) {\n\t\t\tatomic64_add(thresh, &cur_trans->chunk_bytes_reserved);\n\t\t\ttrans->chunk_bytes_reserved += thresh;\n\t\t}\n\t}\n}", "target": 1}
{"code": "int setTypeAdd(robj *subject, sds value) {\n    long long llval;\n    if (subject->encoding == OBJ_ENCODING_HT) {\n        dict *ht = subject->ptr;\n        dictEntry *de = dictAddRaw(ht,value,NULL);\n        if (de) {\n            dictSetKey(ht,de,sdsdup(value));\n            dictSetVal(ht,de,NULL);\n            return 1;\n        }\n    } else if (subject->encoding == OBJ_ENCODING_INTSET) {\n        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {\n            uint8_t success = 0;\n            subject->ptr = intsetAdd(subject->ptr,llval,&success);\n            if (success) {\n                if (intsetLen(subject->ptr) > server.set_max_intset_entries)\n                    setTypeConvert(subject,OBJ_ENCODING_HT);\n                return 1;\n            }\n        } else {\n            setTypeConvert(subject,OBJ_ENCODING_HT);\n            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unknown set encoding\");\n    }\n    return 0;\n}", "target": 1}
{"code": "static TEE_Result do_alloc_keypair(struct ecc_keypair *s, uint32_t type,\n\t\t\t\t   size_t size_bits __unused)\n{\n\tif (type != TEE_TYPE_ECDSA_KEYPAIR &&\n\t    type != TEE_TYPE_ECDH_KEYPAIR)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static void process_constructors (RBinFile *bf, RList *ret, int bits) {\n\tRList *secs = sections (bf);\n\tRListIter *iter;\n\tRBinSection *sec;\n\tint i, type;\n\tr_list_foreach (secs, iter, sec) {\n\t\ttype = -1;\n\t\tif (!strcmp (sec->name, \".fini_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (!strcmp (sec->name, \".init_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_INIT;\n\t\t} else if (!strcmp (sec->name, \".preinit_array\")) {\n\t\t\ttype = R_BIN_ENTRY_TYPE_PREINIT;\n\t\t}\n\t\tif (type != -1) {\n\t\t\tut8 *buf = calloc (sec->size, 1);\n\t\t\tif (!buf) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t(void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size);\n\t\t\tif (bits == 32) {\n\t\t\t\tfor (i = 0; i < sec->size; i += 4) {\n\t\t\t\t\tut32 addr32 = r_read_le32 (buf + i);\n\t\t\t\t\tif (addr32) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < sec->size; i += 8) {\n\t\t\t\t\tut64 addr64 = r_read_le64 (buf + i);\n\t\t\t\t\tif (addr64) {\n\t\t\t\t\t\tRBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits);\n\t\t\t\t\t\tr_list_append (ret, ba);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (buf);\n\t\t}\n\t}\n\tr_list_free (secs);\n}", "target": 1}
{"code": "mark_desktop_file_executable_task_done (GObject      *source_object,\n                                        GAsyncResult *res,\n                                        gpointer      user_data)\n{\n    MarkTrustedJob *job = user_data;\n    g_object_unref (job->file);\n    if (job->done_callback)\n    {\n        job->done_callback (!job_aborted ((CommonJob *) job),\n                            job->done_callback_data);\n    }\n    finalize_common ((CommonJob *) job);\n}", "target": 0}
{"code": "ip_printts(netdissect_options *ndo,\n           register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tint hoplen;\n\tconst char *type;\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \" TS{\"));\n\thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n\tif ((length - 4) & (hoplen-1))\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tlen = 0;\n\tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n\t\tND_PRINT((ndo, \"[bad ptr %u]\", cp[2]));\n\tswitch (cp[3]&0xF) {\n\tcase IPOPT_TS_TSONLY:\n\t\tND_PRINT((ndo, \"TSONLY\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t\tND_PRINT((ndo, \"TS+ADDR\"));\n\t\tbreak;\n\tcase 2:\n\t\tND_PRINT((ndo, \"PRESPEC2.0\"));\n\t\tbreak;\n\tcase 3:\t\t\t\n\t\tND_PRINT((ndo, \"PRESPEC\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"[bad ts type %d]\", cp[3]&0xF));\n\t\tgoto done;\n\t}\n\ttype = \" \";\n\tfor (len = 4; len < length; len += hoplen) {\n\t\tif (ptr == len)\n\t\t\ttype = \" ^ \";\n\t\tND_PRINT((ndo, \"%s%d@%s\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n\t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n\t\ttype = \" \";\n\t}\ndone:\n\tND_PRINT((ndo, \"%s\", ptr == len ? \" ^ \" : \"\"));\n\tif (cp[3]>>4)\n\t\tND_PRINT((ndo, \" [%d hops not recorded]} \", cp[3]>>4));\n\telse\n\t\tND_PRINT((ndo, \"}\"));\n}", "target": 1}
{"code": "void invalidate_lstat_cache(void)\n{\n\treset_lstat_cache(&default_cache);\n}", "target": 0}
{"code": "Error ImageOverlay::parse(size_t num_images, const std::vector<uint8_t>& data)\n{\n  Error eofError(heif_error_Invalid_input,\n                 heif_suberror_Invalid_grid_data,\n                 \"Overlay image data incomplete\");\n  if (data.size() < 2 + 4 * 2) {\n    return eofError;\n  }\n  m_version = data[0];\n  m_flags = data[1];\n  if (m_version != 0) {\n    std::stringstream sstr;\n    sstr << \"Overlay image data version \" << ((int) m_version) << \" is not implemented yet\";\n    return Error(heif_error_Unsupported_feature,\n                 heif_suberror_Unsupported_data_version,\n                 sstr.str());\n  }\n  int field_len = ((m_flags & 1) ? 4 : 2);\n  int ptr = 2;\n  if (ptr + 4 * 2 + 2 * field_len + num_images * 2 * field_len > data.size()) {\n    return eofError;\n  }\n  for (int i = 0; i < 4; i++) {\n    uint16_t color = static_cast<uint16_t>(readvec(data, ptr, 2));\n    m_background_color[i] = color;\n  }\n  m_width = readvec(data, ptr, field_len);\n  m_height = readvec(data, ptr, field_len);\n  m_offsets.resize(num_images);\n  for (size_t i = 0; i < num_images; i++) {\n    m_offsets[i].x = readvec_signed(data, ptr, field_len);\n    m_offsets[i].y = readvec_signed(data, ptr, field_len);\n  }\n  return Error::Ok;\n}", "target": 1}
{"code": "  void expectTrailers(\n      std::function<void()> callback = std::function<void()>()) {\n    if (callback) {\n      EXPECT_CALL(*this, onTrailers(testing::_))\n          .WillOnce(testing::InvokeWithoutArgs(callback))\n          .RetiresOnSaturation();\n    } else {\n      EXPECT_CALL(*this, onTrailers(testing::_));\n    }\n  }", "target": 0}
{"code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\tsalsa20_ivsetup(ctx, walk.iv);\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.src.virt.addr,\n\t\t\t\t      walk.dst.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static void* socketio_CloneOption(const char* name, const void* value)\n{\n    void* result;\n    if (name != NULL)\n    {\n        result = NULL;\n        if (strcmp(name, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n            if (value == NULL)\n            {\n                LogError(\"Failed cloning option %s (value is NULL)\", name);\n            }\n            else\n            {\n                if ((result = malloc(sizeof(char) * (strlen((char*)value) + 1))) == NULL)\n                {\n                    LogError(\"Failed cloning option %s (malloc failed)\", name);\n                }\n                else\n                {\n                    strcpy((char *)result, (char *)value);\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Cannot clone option %s (not suppported)\", name);\n        }\n    }\n    else\n    {\n        result = NULL;\n    }\n    return result;\n}", "target": 1}
{"code": "static int ext4_convert_unwritten_extents_endio(handle_t *handle,\n\t\t\t\t\t      struct inode *inode,\n\t\t\t\t\t      struct ext4_ext_path *path)\n{\n\tstruct ext4_extent *ex;\n\tint depth;\n\tint err = 0;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\text_debug(\"ext4_convert_unwritten_extents_endio: inode %lu, logical\"\n\t\t\"block %llu, max_blocks %u\\n\", inode->i_ino,\n\t\t(unsigned long long)le32_to_cpu(ex->ee_block),\n\t\text4_ext_get_actual_len(ex));\n\terr = ext4_ext_get_access(handle, inode, path + depth);\n\tif (err)\n\t\tgoto out;\n\text4_ext_mark_initialized(ex);\n\text4_ext_try_to_merge(handle, inode, path, ex);\n\terr = ext4_ext_dirty(handle, inode, path + path->p_depth);\nout:\n\text4_ext_show_leaf(inode, path);\n\treturn err;\n}", "target": 1}
{"code": "spnego_gss_get_mic_iov_length(OM_uint32 *minor_status,\n\t\t\t      gss_ctx_id_t context_handle, gss_qop_t qop_req,\n\t\t\t      gss_iov_buffer_desc *iov, int iov_count)\n{\n    return gss_get_mic_iov_length(minor_status, context_handle, qop_req, iov,\n\t\t\t\t  iov_count);\n}", "target": 1}
{"code": "static int open_port(struct inode *inode, struct file *filp)\n{\n\treturn capable(CAP_SYS_RAWIO) ? 0 : -EPERM;\n}", "target": 0}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "static inline bool vm_need_virtualize_apic_accesses(struct kvm *kvm)\n{\n\treturn flexpriority_enabled && irqchip_in_kernel(kvm);\n}", "target": 0}
{"code": "void test_unlink(const char *path)\n{\n\tif (unlink(path) == 0) {\n\t\tfprintf(stderr, \"leak at unlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at unlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "void test_utimes(const char *path)\n{\n\tstruct utimbuf times;\n\ttimes.actime = 0;\n\ttimes.modtime = 0;\n\tif (utime(path, &times) == 0) {\n\t\tfprintf(stderr, \"leak at utime of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at utime of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int xennet_get_sset_count(struct net_device *dev, int string_set)\n{\n\tswitch (string_set) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(xennet_stats);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "static inline void skb_reserve(struct sk_buff *skb, int len)\n{\n\tskb->data += len;\n\tskb->tail += len;\n}", "target": 0}
{"code": "static int __d_unalias(struct inode *inode,\n\t\tstruct dentry *dentry, struct dentry *alias)\n{\n\tstruct mutex *m1 = NULL, *m2 = NULL;\n\tint ret = -ESTALE;\n\tif (alias->d_parent == dentry->d_parent)\n\t\tgoto out_unalias;\n\tif (!mutex_trylock(&dentry->d_sb->s_vfs_rename_mutex))\n\t\tgoto out_err;\n\tm1 = &dentry->d_sb->s_vfs_rename_mutex;\n\tif (!mutex_trylock(&alias->d_parent->d_inode->i_mutex))\n\t\tgoto out_err;\n\tm2 = &alias->d_parent->d_inode->i_mutex;\nout_unalias:\n\t__d_move(alias, dentry, false);\n\tret = 0;\nout_err:\n\tspin_unlock(&inode->i_lock);\n\tif (m2)\n\t\tmutex_unlock(m2);\n\tif (m1)\n\t\tmutex_unlock(m1);\n\treturn ret;\n}", "target": 0}
{"code": "TEST_CASE(\"Invalid UTF-8 text test\", \"[general]\")\n{\n    std::string s = \"a <- '\";\n    s += static_cast<char>(0xe8); \n    parser parser(s.c_str());\n    bool ret = parser;\n    REQUIRE(ret == false);\n}", "target": 0}
{"code": "  virtual ~GatherHostUsageTask() {}", "target": 0}
{"code": "std::string DecodeUnsafe(string_view encoded) {\n  std::string raw;\n  if (Decode(encoded, &raw)) {\n    return raw;\n  }\n  return ToString(encoded);\n}", "target": 1}
{"code": "void __init files_init(unsigned long mempages)\n{ \n\tunsigned long n;\n\tfilp_cachep = kmem_cache_create(\"filp\", sizeof(struct file), 0,\n\t\t\tSLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\tn = (mempages * (PAGE_SIZE / 1024)) / 10;\n\tfiles_stat.max_files = max_t(unsigned long, n, NR_FILE);\n\tfiles_defer_init();\n\tlg_lock_init(&files_lglock, \"files_lglock\");\n\tpercpu_counter_init(&nr_files, 0);\n} ", "target": 1}
{"code": "    TiffComponent* TiffIfdMakernote::doAddChild(TiffComponent::UniquePtr tiffComponent)\n    {\n        return ifd_.addChild(std::move(tiffComponent));\n    }", "target": 0}
{"code": "juniper_mfr_print(netdissect_options *ndo,\n                  const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        memset(&l2info, 0, sizeof(l2info));\n        l2info.pictype = DLT_JUNIPER_MFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie_len == 0) {\n            mfr_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        }\n        if (l2info.cookie_len == AS_PIC_COOKIE_LEN) {\n            switch(l2info.proto) {\n            case JUNIPER_LSQ_L3_PROTO_IPV4:\n                ip_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_IPV6:\n                ip6_print(ndo, p,l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_MPLS:\n                mpls_print(ndo, p, l2info.length);\n                return l2info.header_len;\n            case JUNIPER_LSQ_L3_PROTO_ISO:\n                isoclns_print(ndo, p, l2info.length, l2info.caplen);\n                return l2info.header_len;\n            default:\n                break;\n            }\n            return l2info.header_len;\n        }\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLCSAP_ISONS<<8 | LLCSAP_ISONS):\n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "check_entry_size_and_hooks(struct ipt_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static int update_alu_sanitation_state(struct bpf_insn_aux_data *aux,\n\t\t\t\t       u32 alu_state, u32 alu_limit)\n{\n\tif (aux->alu_state &&\n\t    (aux->alu_state != alu_state ||\n\t     aux->alu_limit != alu_limit))\n\t\treturn -EACCES;\n\taux->alu_state = alu_state;\n\taux->alu_limit = alu_limit;\n\treturn 0;\n}", "target": 0}
{"code": "void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\tStream_Write_UINT16(s, fields->Len); \n\tStream_Write_UINT16(s, fields->MaxLen); \n\tStream_Write_UINT32(s, fields->BufferOffset); \n}", "target": 1}
{"code": "static void vhost_zerocopy_done_signal(struct kref *kref)\n{\n\tstruct vhost_ubuf_ref *ubufs = container_of(kref, struct vhost_ubuf_ref,\n\t\t\t\t\t\t    kref);\n\twake_up(&ubufs->wait);\n}", "target": 0}
{"code": "TEST_F(OpLevelCostEstimatorTest, OpDimensionsFromInputsError) {\n  std::vector<string> paddings = {\"VALID\", \"SAME\"};\n  std::vector<string> formats = {\"NHWC\", \"NCHW\"};\n  for (const auto& p : paddings) {\n    for (const auto& f : formats) {\n      ASSERT_THAT(\n          CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 0, 2, f, p),\n          testing::StatusIs(\n              error::INVALID_ARGUMENT,\n              \"Stride must be > 0 for Height and Width, but got (2, 0)\"));\n      ASSERT_THAT(\n          CallOpDimensionsFromInputs(10, 14, 14, 3840, 3, 3, 2, 0, f, p),\n          testing::StatusIs(\n              error::INVALID_ARGUMENT,\n              \"Stride must be > 0 for Height and Width, but got (0, 2)\"));\n    }\n  }\n}", "target": 0}
{"code": "static unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = file->private_data;\n\tstruct mnt_namespace *ns = p->m.private;\n\tunsigned res = 0;\n\tpoll_wait(file, &ns->poll, wait);\n\tspin_lock(&vfsmount_lock);\n\tif (p->event != ns->event) {\n\t\tp->event = ns->event;\n\t\tres = POLLERR;\n\t}\n\tspin_unlock(&vfsmount_lock);\n\treturn res;\n}", "target": 0}
{"code": "GF_Err SFScript_Parse(GF_BifsDecoder *codec, SFScript *script_field, GF_BitStream *bs, GF_Node *n)\n{\n\tGF_Err e;\n\tu32 i, count, nbBits;\n\tchar *ptr;\n\tScriptParser parser;\n\te = GF_OK;\n\tif (gf_node_get_tag(n) != TAG_MPEG4_Script) return GF_NON_COMPLIANT_BITSTREAM;\n\tmemset(&parser, 0, sizeof(ScriptParser));\n\tparser.codec = codec;\n\tparser.script = n;\n\tparser.bs = bs;\n\tparser.length = 500;\n\tparser.string = (char *) gf_malloc(sizeof(char)* parser.length);\n\tparser.string[0] = 0;\n\tparser.identifiers = gf_list_new();\n\tparser.new_line = (char *) (codec->dec_memory_mode ? \"\\n\" : NULL);\n\tparser.indent = 0;\n\tif (gf_bs_read_int(bs, 1)) {\n\t\twhile (!gf_bs_read_int(bs, 1)) {\n\t\t\te = ParseScriptField(&parser);\n\t\t\tif (e) goto exit;\n\t\t}\n\t} else {\n\t\tnbBits = gf_bs_read_int(bs, 4);\n\t\tcount = gf_bs_read_int(bs, nbBits);\n\t\tfor (i=0; i<count; i++) {\n\t\t\te = ParseScriptField(&parser);\n\t\t\tif (e) goto exit;\n\t\t}\n\t}\n\tgf_bs_read_int(bs, 1);\n\tSFS_AddString(&parser, \"javascript:\");\n\tSFS_AddString(&parser, parser.new_line);\n\twhile (gf_bs_read_int(bs, 1)) {\n\t\tSFS_AddString(&parser, \"function \");\n\t\tSFS_Identifier(&parser);\n\t\tSFS_Arguments(&parser, GF_FALSE);\n\t\tSFS_Space(&parser);\n\t\tSFS_StatementBlock(&parser, GF_TRUE);\n\t\tSFS_Line(&parser);\n\t\tif (codec->LastError) {\n\t\t\te = codec->LastError;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tSFS_Line(&parser);\n\tif (script_field->script_text) gf_free(script_field->script_text);\n\tscript_field->script_text = (char *) gf_strdup(parser.string);\nexit:\n\twhile (gf_list_count(parser.identifiers)) {\n\t\tptr = (char *)gf_list_get(parser.identifiers, 0);\n\t\tgf_free(ptr);\n\t\tgf_list_rem(parser.identifiers, 0);\n\t}\n\tgf_list_del(parser.identifiers);\n\tif (parser.string) gf_free(parser.string);\n\treturn e;\n}", "target": 0}
{"code": "static void tcp_cwnd_reduction(struct sock *sk, const int prior_unsacked,\n\t\t\t       int fast_rexmit, int flag)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tint sndcnt = 0;\n\tint delta = tp->snd_ssthresh - tcp_packets_in_flight(tp);\n\tint newly_acked_sacked = prior_unsacked -\n\t\t\t\t (tp->packets_out - tp->sacked_out);\n\tif (newly_acked_sacked <= 0 || WARN_ON_ONCE(!tp->prior_cwnd))\n\t\treturn;\n\ttp->prr_delivered += newly_acked_sacked;\n\tif (delta < 0) {\n\t\tu64 dividend = (u64)tp->snd_ssthresh * tp->prr_delivered +\n\t\t\t       tp->prior_cwnd - 1;\n\t\tsndcnt = div_u64(dividend, tp->prior_cwnd) - tp->prr_out;\n\t} else if ((flag & FLAG_RETRANS_DATA_ACKED) &&\n\t\t   !(flag & FLAG_LOST_RETRANS)) {\n\t\tsndcnt = min_t(int, delta,\n\t\t\t       max_t(int, tp->prr_delivered - tp->prr_out,\n\t\t\t\t     newly_acked_sacked) + 1);\n\t} else {\n\t\tsndcnt = min(delta, newly_acked_sacked);\n\t}\n\tsndcnt = max(sndcnt, (fast_rexmit ? 1 : 0));\n\ttp->snd_cwnd = tcp_packets_in_flight(tp) + sndcnt;\n}", "target": 0}
{"code": "void dns_server_init(struct netif * pnetif)\n{\n\tuint8_t *ip;\n\tif (dns_server_pcb != NULL) {\n\t\tudp_remove(dns_server_pcb);\n\t\tdns_server_pcb = NULL;\n\t}\n\tdns_server_pcb = udp_new();\n\tif (dns_server_pcb == NULL) {\n\t\tprintf(\"\\n\\r Error!!!upd_new error \\n\\r\");\n\t\treturn;\n\t}\n\tudp_bind(dns_server_pcb, IP_ADDR_ANY, DNS_SERVER_PORT);\n\tudp_recv(dns_server_pcb, dnss_receive_udp_packet_handler, NULL);\n}", "target": 0}
{"code": "static void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static int newary(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tint id;\n\tint retval;\n\tstruct sem_array *sma;\n\tint size;\n\tkey_t key = params->key;\n\tint nsems = params->u.nsems;\n\tint semflg = params->flg;\n\tint i;\n\tif (!nsems)\n\t\treturn -EINVAL;\n\tif (ns->used_sems + nsems > ns->sc_semmns)\n\t\treturn -ENOSPC;\n\tsize = sizeof (*sma) + nsems * sizeof (struct sem);\n\tsma = ipc_rcu_alloc(size);\n\tif (!sma) {\n\t\treturn -ENOMEM;\n\t}\n\tmemset (sma, 0, size);\n\tsma->sem_perm.mode = (semflg & S_IRWXUGO);\n\tsma->sem_perm.key = key;\n\tsma->sem_perm.security = NULL;\n\tretval = security_sem_alloc(sma);\n\tif (retval) {\n\t\tipc_rcu_putref(sma);\n\t\treturn retval;\n\t}\n\tid = ipc_addid(&sem_ids(ns), &sma->sem_perm, ns->sc_semmni);\n\tif (id < 0) {\n\t\tsecurity_sem_free(sma);\n\t\tipc_rcu_putref(sma);\n\t\treturn id;\n\t}\n\tns->used_sems += nsems;\n\tsma->sem_base = (struct sem *) &sma[1];\n\tfor (i = 0; i < nsems; i++)\n\t\tINIT_LIST_HEAD(&sma->sem_base[i].sem_pending);\n\tsma->complex_count = 0;\n\tINIT_LIST_HEAD(&sma->sem_pending);\n\tINIT_LIST_HEAD(&sma->list_id);\n\tsma->sem_nsems = nsems;\n\tsma->sem_ctime = get_seconds();\n\tsem_unlock(sma);\n\treturn sma->sem_perm.id;\n}", "target": 1}
{"code": "delete_principal_2_svc(dprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_DELETE,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_DELETE;\n        log_unauth(\"kadm5_delete_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_delete_principal((void *)handle, arg->princ);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_delete_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static ssize_t k90_show_current_profile(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint current_profile;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tcurrent_profile = data[7];\n\tif (current_profile < 1 || current_profile > 3) {\n\t\tdev_warn(dev, \"Read invalid current profile: %02hhx.\\n\",\n\t\t\t data[7]);\n\t\treturn -EIO;\n\t}\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", current_profile);\n}", "target": 1}
{"code": "void InstanceKlass::remove_unshareable_info() {\n  if (can_be_verified_at_dumptime()) {\n    set_verified_at_dump_time();\n  }\n  Klass::remove_unshareable_info();\n  if (SystemDictionaryShared::has_class_failed_verification(this)) {\n    return;\n  }\n  _init_state = allocated;\n  { \n    assert(SafepointSynchronize::is_at_safepoint(), \"only called at safepoint\");\n    init_implementor();\n  }\n  constants()->remove_unshareable_info();\n  for (int i = 0; i < methods()->length(); i++) {\n    Method* m = methods()->at(i);\n    m->remove_unshareable_info();\n  }\n  if (array_klasses() != NULL) {\n    array_klasses()->remove_unshareable_info();\n  }\n  _source_debug_extension = NULL;\n  _dep_context = NULL;\n  _osr_nmethods_head = NULL;\n#if INCLUDE_JVMTI\n  _breakpoints = NULL;\n  _previous_versions = NULL;\n  _cached_class_file = NULL;\n  _jvmti_cached_class_field_map = NULL;\n#endif\n  _init_thread = NULL;\n  _methods_jmethod_ids = NULL;\n  _jni_ids = NULL;\n  _oop_map_cache = NULL;\n  _nest_host = NULL;\n  init_shared_package_entry();\n  _dep_context_last_cleaned = 0;\n}", "target": 0}
{"code": "static int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s32 off_min = S16_MIN, off_max = S16_MAX;\n\ts32 off = insn->off;\n\tif (curr < pos && curr + off + 1 > pos)\n\t\toff += delta;\n\telse if (curr > pos + delta && curr + off + 1 <= pos + delta)\n\t\toff -= delta;\n\tif (off < off_min || off > off_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->off = off;\n\treturn 0;\n}", "target": 0}
{"code": "bool Filter::parseTlvs(const uint8_t* buf, size_t len) {\n  size_t idx{0};\n  while (idx < len) {\n    const uint8_t tlv_type = buf[idx];\n    idx++;\n    if ((idx + 1) >= len) {\n      ENVOY_LOG(debug,\n                fmt::format(\"failed to read proxy protocol extension. No bytes for TLV length. \"\n                            \"Extension length is {}, current index is {}, current type is {}.\",\n                            len, idx, tlv_type));\n      return false;\n    }\n    const uint8_t tlv_length_upper = buf[idx];\n    const uint8_t tlv_length_lower = buf[idx + 1];\n    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;\n    idx += 2;\n    if ((idx + tlv_value_length - 1) >= len) {\n      ENVOY_LOG(\n          debug,\n          fmt::format(\"failed to read proxy protocol extension. No bytes for TLV value. \"\n                      \"Extension length is {}, current index is {}, current type is {}, current \"\n                      \"value length is {}.\",\n                      len, idx, tlv_type, tlv_length_upper));\n      return false;\n    }\n    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);\n    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);\n    if (nullptr != key_value_pair) {\n      ProtobufWkt::Value metadata_value;\n      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());\n      std::string metadata_key = key_value_pair->metadata_namespace().empty()\n                                     ? \"envoy.filters.listener.proxy_protocol\"\n                                     : key_value_pair->metadata_namespace();\n      ProtobufWkt::Struct metadata(\n          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);\n      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});\n      cb_->setDynamicMetadata(metadata_key, metadata);\n    } else {\n      ENVOY_LOG(trace,\n                \"proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata\",\n                tlv_type);\n    }\n    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {\n      ENVOY_LOG(trace, \"proxy_protocol: Storing parsed TLV of type {} to filter state.\", tlv_type);\n      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});\n    }\n    idx += tlv_value_length;\n    ASSERT(idx <= len);\n  }\n  return true;\n}", "target": 1}
{"code": "static SDL_Surface* Create_Surface_Solid(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf;\n    Sint64 size;\n    void *pixels, *ptr;\n    Sint64 pitch = width + alignment;\n    pitch += alignment;\n    pitch &= ~alignment;\n    size = height * pitch + sizeof (void *) + alignment;\n    if (size < 0 || size > SDL_MAX_SINT32) {\n        return NULL;\n    }\n    ptr = SDL_malloc((size_t)size);\n    if (ptr == NULL) {\n        return NULL;\n    }\n    pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n    ((void **)pixels)[-1] = ptr;\n    textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_INDEX8);\n    if (textbuf == NULL) {\n        SDL_free(ptr);\n        return NULL;\n    }\n    textbuf->flags &= ~SDL_PREALLOC;\n    textbuf->flags |= SDL_SIMD_ALIGNED;\n    SDL_memset(pixels, 0, height * pitch);\n    *color = 1;\n    {\n        SDL_Palette *palette = textbuf->format->palette;\n        palette->colors[0].r = 255 - fg.r;\n        palette->colors[0].g = 255 - fg.g;\n        palette->colors[0].b = 255 - fg.b;\n        palette->colors[1].r = fg.r;\n        palette->colors[1].g = fg.g;\n        palette->colors[1].b = fg.b;\n        palette->colors[1].a = fg.a;\n    }\n    SDL_SetColorKey(textbuf, SDL_TRUE, 0);\n    return textbuf;", "target": 1}
{"code": "static inline int pri2fac(const int pri)\n{\n\tunsigned fac = pri >> 3;\n\treturn (fac > 23) ? LOG_FAC_INVLD : fac;\n}", "target": 0}
{"code": "GF_Box *flxs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_AdobeFlashAccessParamsBox, GF_ISOM_BOX_TYPE_FLXS);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (const struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (const struct pgstate *)io;\n\t}\n\treturn ((const u_char *)ps <= ep? 0 : -1);\n}", "target": 1}
{"code": "bool SQClass::NewSlot(SQSharedState *ss,const SQObjectPtr &key,const SQObjectPtr &val,bool bstatic)\n{\n    SQObjectPtr temp;\n    bool belongs_to_static_table = sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE || bstatic;\n    if(_locked && !belongs_to_static_table)\n        return false; \n    if(_members->Get(key,temp) && _isfield(temp)) \n    {\n        _defaultvalues[_member_idx(temp)].val = val;\n        return true;\n    }\n\tif (_members->CountUsed() >= MEMBER_MAX_COUNT) {\n\t\treturn false;\n\t}\n    if(belongs_to_static_table) {\n        SQInteger mmidx;\n        if((sq_type(val) == OT_CLOSURE || sq_type(val) == OT_NATIVECLOSURE) &&\n            (mmidx = ss->GetMetaMethodIdxByName(key)) != -1) {\n            _metamethods[mmidx] = val;\n        }\n        else {\n            SQObjectPtr theval = val;\n            if(_base && sq_type(val) == OT_CLOSURE) {\n                theval = _closure(val)->Clone();\n                _closure(theval)->_base = _base;\n                __ObjAddRef(_base); \n            }\n            if(sq_type(temp) == OT_NULL) {\n                bool isconstructor;\n                SQVM::IsEqual(ss->_constructoridx, key, isconstructor);\n                if(isconstructor) {\n                    _constructoridx = (SQInteger)_methods.size();\n                }\n                SQClassMember m;\n                m.val = theval;\n                _members->NewSlot(key,SQObjectPtr(_make_method_idx(_methods.size())));\n                _methods.push_back(m);\n            }\n            else {\n                _methods[_member_idx(temp)].val = theval;\n            }\n        }\n        return true;\n    }\n    SQClassMember m;\n    m.val = val;\n    _members->NewSlot(key,SQObjectPtr(_make_field_idx(_defaultvalues.size())));\n    _defaultvalues.push_back(m);\n    return true;\n}", "target": 0}
{"code": "    bool replaceHostInUri( std::string& uri, const char* szHost, const char* szPort ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            return false ;\n        }\n        url->url_host = szHost ;\n        url->url_port = szPort ;\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, 1, url, params, comment) ;\n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }", "target": 1}
{"code": "  cert_chain_t::clear() {\n    _certs.clear();\n  }", "target": 0}
{"code": "sysContact_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG, https:\n}", "target": 1}
{"code": "skipString(const xmlChar *cur, int end) {\n    xmlChar limit;\n    if ((cur == NULL) || (end < 0)) return(-1);\n    if ((cur[end] == '\\'') || (cur[end] == '\"')) limit = cur[end];\n    else return(end);\n    end++;\n    while (cur[end] != 0) {\n        if (cur[end] == limit)\n\t    return(end + 1);\n\tend++;\n    }\n    return(-1);\n}", "target": 0}
{"code": "static int on_security_message(struct nvnc_client* client)\n{\n\tif (client->buffer_len - client->buffer_index < 1)\n\t\treturn 0;\n\tuint8_t type = client->msg_buffer[client->buffer_index];\n\tnvnc_log(NVNC_LOG_DEBUG, \"Client chose security type: %d\", type);\n\tif (!is_allowed_security_type(client->server, type)) {\n\t\tsecurity_handshake_failed(client, NULL, \"Illegal security type\");\n\t\treturn sizeof(type);\n\t}\n\tswitch (type) {\n\tcase RFB_SECURITY_TYPE_NONE:\n\t\tsecurity_handshake_ok(client, NULL);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_INIT;\n\t\tbreak;\n#ifdef ENABLE_TLS\n\tcase RFB_SECURITY_TYPE_VENCRYPT:\n\t\tvencrypt_send_version(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_VENCRYPT_VERSION;\n\t\tbreak;\n#endif\n#ifdef HAVE_CRYPTO\n\tcase RFB_SECURITY_TYPE_APPLE_DH:\n\t\tapple_dh_send_public_key(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_APPLE_DH_RESPONSE;\n\t\tbreak;\n\tcase RFB_SECURITY_TYPE_RSA_AES:\n\t\tclient->rsa.hash_type = CRYPTO_HASH_SHA1;\n\t\tclient->rsa.cipher_type = CRYPTO_CIPHER_AES_EAX;\n\t\tclient->rsa.challenge_len = 16;\n\t\trsa_aes_send_public_key(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_RSA_AES_PUBLIC_KEY;\n\t\tbreak;\n\tcase RFB_SECURITY_TYPE_RSA_AES256:\n\t\tclient->rsa.hash_type = CRYPTO_HASH_SHA256;\n\t\tclient->rsa.cipher_type = CRYPTO_CIPHER_AES256_EAX;\n\t\tclient->rsa.challenge_len = 32;\n\t\trsa_aes_send_public_key(client);\n\t\tclient->state = VNC_CLIENT_STATE_WAITING_FOR_RSA_AES_PUBLIC_KEY;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tsecurity_handshake_failed(client, NULL,\n\t\t\t\t\"Unsupported security type\");\n\t\tbreak;\n\t}\n\treturn sizeof(type);\n}", "target": 0}
{"code": "int rtp_packetize_xiph_config( sout_stream_id_sys_t *id, const char *fmtp,\n                               int64_t i_pts )\n{\n    if (fmtp == NULL)\n        return VLC_EGENERIC;\n    char *start = strstr(fmtp, \"configuration=\");\n    assert(start != NULL);\n    start += sizeof(\"configuration=\") - 1;\n    char *end = strchr(start, ';');\n    assert(end != NULL);\n    size_t len = end - start;\n    char b64[len + 1];\n    memcpy(b64, start, len);\n    b64[len] = '\\0';\n    int     i_max   = rtp_mtu (id) - 6; \n    uint8_t *p_orig, *p_data;\n    int i_data;\n    i_data = vlc_b64_decode_binary(&p_orig, b64);\n    if (i_data <= 9)\n    {\n        free(p_orig);\n        return VLC_EGENERIC;\n    }\n    p_data = p_orig + 9;\n    i_data -= 9;\n    int i_count = ( i_data + i_max - 1 ) / i_max;\n    for( int i = 0; i < i_count; i++ )\n    {\n        int           i_payload = __MIN( i_max, i_data );\n        block_t *out = block_Alloc( 18 + i_payload );\n        unsigned fragtype, numpkts;\n        if (i_count == 1)\n        {\n            fragtype = 0;\n            numpkts = 1;\n        }\n        else\n        {\n            numpkts = 0;\n            if (i == 0)\n                fragtype = 1;\n            else if (i == i_count - 1)\n                fragtype = 3;\n            else\n                fragtype = 2;\n        }\n        uint32_t header = ((XIPH_IDENT & 0xffffff) << 8) |\n                          (fragtype << 6) | (1 << 4) | numpkts;\n        rtp_packetize_common( id, out, 0, i_pts );\n        SetDWBE( out->p_buffer + 12, header);\n        SetWBE( out->p_buffer + 16, i_payload);\n        memcpy( &out->p_buffer[18], p_data, i_payload );\n        out->i_dts    = i_pts;\n        rtp_packetize_send( id, out );\n        p_data += i_payload;\n        i_data -= i_payload;\n    }\n    free(p_orig);\n    return VLC_SUCCESS;\n}", "target": 1}
{"code": "static void vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tif (!pi_test_and_clear_on(&vmx->pi_desc))\n\t\treturn;\n\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir);\n}", "target": 0}
{"code": "static __u8 *nci_extract_rf_params_nfcb_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcb_poll *nfcb_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcb_poll->sensb_res_len = *data++;\n\tpr_debug(\"sensb_res_len %d\\n\", nfcb_poll->sensb_res_len);\n\tmemcpy(nfcb_poll->sensb_res, data, nfcb_poll->sensb_res_len);\n\tdata += nfcb_poll->sensb_res_len;\n\treturn data;\n}", "target": 1}
{"code": "static void __exit acpi_custom_method_exit(void)\n{\n\tif (cm_dentry)\n\t\tdebugfs_remove(cm_dentry);\n }", "target": 0}
{"code": "static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct dentry *dir;\n\tstruct fscrypt_info *ci;\n\tint dir_has_key, cached_with_key;\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\tdir = dget_parent(dentry);\n\tif (!d_inode(dir)->i_sb->s_cop->is_encrypted(d_inode(dir))) {\n\t\tdput(dir);\n\t\treturn 0;\n\t}\n\tci = d_inode(dir)->i_crypt_info;\n\tif (ci && ci->ci_keyring_key &&\n\t    (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t  (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t  (1 << KEY_FLAG_DEAD))))\n\t\tci = NULL;\n\tspin_lock(&dentry->d_lock);\n\tcached_with_key = dentry->d_flags & DCACHE_ENCRYPTED_WITH_KEY;\n\tspin_unlock(&dentry->d_lock);\n\tdir_has_key = (ci != NULL);\n\tdput(dir);\n\tif ((!cached_with_key && d_is_negative(dentry)) ||\n\t\t\t(!cached_with_key && dir_has_key) ||\n\t\t\t(cached_with_key && !dir_has_key))\n\t\treturn 0;\n\treturn 1;\n}", "target": 1}
{"code": "int test(char *URL)\n{\n  int errors = 0;\n  (void)URL; \n  errors += test_weird_arguments();\n  errors += test_unsigned_short_formatting();\n  errors += test_signed_short_formatting();\n  errors += test_unsigned_int_formatting();\n  errors += test_signed_int_formatting();\n  errors += test_unsigned_long_formatting();\n  errors += test_signed_long_formatting();\n  errors += test_curl_off_t_formatting();\n  errors += test_string_formatting();\n  errors += test_float_formatting();\n  if(errors)\n    return TEST_ERR_MAJOR_BAD;\n  else\n    return 0;\n}", "target": 0}
{"code": "flac_read_loop (SF_PRIVATE *psf, unsigned len)\n{\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tpflac->pos = 0 ;\n\tpflac->len = len ;\n\tpflac->remain = len ;\n\tif (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)\n\t\tflac_buffer_copy (psf) ;\n\twhile (pflac->pos < pflac->len)\n\t{\tif (FLAC__stream_decoder_process_single (pflac->fsd) == 0)\n\t\t\tbreak ;\n\t\tif (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)\n\t\t\tbreak ;\n\t\t} ;\n\tpflac->ptr = NULL ;\n\treturn pflac->pos ;\n} ", "target": 1}
{"code": "static int isansicode(int x)\n{\n    return x == 0x1B || x == 0x0A || x == 0x0D || (x >= 0x20 && x < 0x7f);\n}", "target": 0}
{"code": "static int host_start(struct ci13xxx *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tint ret;\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\thcd = usb_create_hcd(&ci_ehci_hc_driver, ci->dev, dev_name(ci->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->phy = ci->transceiver;\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret)\n\t\tusb_put_hcd(hcd);\n\telse\n\t\tci->hcd = hcd;\n\tif (ci->platdata->flags & CI13XXX_DISABLE_STREAMING)\n\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS, USBMODE_CI_SDIS);\n\treturn ret;\n}", "target": 0}
{"code": "static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n    int ret = 0;\n\tif (im == NULL) {\n\t\treturn 1;\n\t}\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Palette image not supported by webp\");\n\t\treturn 1;\n\t}\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn 1;\n\t}\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn 1;\n\t}\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn 1;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n        ret = 1;\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\nfreeargb:\n\tgdFree(argb);\n    return ret;\n}", "target": 0}
{"code": "modify_policy_2_svc(mpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_MODIFY, NULL, NULL)) {\n        log_unauth(\"kadm5_modify_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_MODIFY;\n    } else {\n        ret.code = kadm5_modify_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_modify_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}", "target": 1}
{"code": "unknown_layer_handler(TSS2_RC rc)\n{\n    static __thread char buf[32];\n    clearbuf(buf);\n    catbuf(buf, \"0x%X\", tpm2_error_get(rc));\n    return buf;\n}", "target": 1}
{"code": "void test_access(const char *path)\n{\n\tif (access(path, O_RDONLY) >= 0) {\n\t\tfprintf(stderr, \"leak at access of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at access of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number)\n{\n  uint32_t original_out_len;\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER);\n  return out;\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui32le(const iw_byte *b)\n{\n\treturn b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24);\n}", "target": 1}
{"code": "    std::string Converter::computeExifDigest(bool)\n    {\n        return std::string(\"\");\n    }", "target": 0}
{"code": "LibRaw_byte_buffer *LibRaw_buffer_datastream::make_byte_buffer(unsigned int sz)\n{\n  if(INT64(sz)>size())\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(0);\n    if(!ret) \n      throw LIBRAW_EXCEPTION_ALLOC;\n    if(streampos + sz > streamsize)\n        sz = streamsize - streampos;\n    ret->set_buffer(buf+streampos,sz);\n    return ret;\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_check_request_header(request_rec *r)\n{\n    core_server_config *conf;\n    int strict_host_check;\n    const char *expect;\n    int access_status;\n    conf = ap_get_core_module_config(r->server->module_config);\n    strict_host_check = (conf->strict_host_check == AP_CORE_CONFIG_ON);\n    access_status = ap_update_vhost_from_headers_ex(r, strict_host_check);\n    if (strict_host_check && access_status != HTTP_OK) { \n        if (r->server == ap_server_conf) { \n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10156)\n                          \"Requested hostname '%s' did not match any ServerName/ServerAlias \"\n                          \"in the global server configuration \", r->hostname);\n        }\n        else { \n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(10157)\n                          \"Requested hostname '%s' did not match any ServerName/ServerAlias \"\n                          \"in the matching virtual host (default vhost for \"\n                          \"current connection is %s:%u)\", \n                          r->hostname, r->server->defn_name, r->server->defn_line_number);\n        }\n        r->status = access_status;\n    }\n    if (r->status != HTTP_OK) { \n        return 0;\n    }\n    if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1, 1)))\n        || ((r->proto_num == HTTP_VERSION(1, 1))\n            && !apr_table_get(r->headers_in, \"Host\"))) {\n        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00569)\n                      \"client sent HTTP/1.1 request without hostname \"\n                      \"(see RFC2616 section 14.23): %s\", r->uri);\n        r->status = HTTP_BAD_REQUEST;\n        return 0;\n    }\n    if (((expect = apr_table_get(r->headers_in, \"Expect\")) != NULL)\n        && (expect[0] != '\\0')) {\n        if (ap_cstr_casecmp(expect, \"100-continue\") == 0) {\n            r->expecting_100 = 1;\n        }\n        else {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(00570)\n                          \"client sent an unrecognized expectation value \"\n                          \"of Expect: %s\", expect);\n            r->status = HTTP_EXPECTATION_FAILED;\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input,\n                          const TfLiteTensor* axis, TfLiteTensor* output) {\n  int axis_value;\n  if (axis->type == kTfLiteInt64) {\n    axis_value = static_cast<int>(*GetTensorData<int64_t>(axis));\n  } else {\n    axis_value = *GetTensorData<int>(axis);\n  }\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n  TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1);\n  int j = 0;\n  for (int i = 0; i < NumDimensions(input); ++i) {\n    if (i != axis_value) {\n      output_dims->data[j] = SizeOfDimension(input, i);\n      ++j;\n    }\n  }\n  return context->ResizeTensor(context, output, output_dims);\n}", "target": 0}
{"code": "IW_IMPL(int) iw_get_input_density(struct iw_context *ctx,\n   double *px, double *py, int *pcode)\n{\n\t*px = 1.0;\n\t*py = 1.0;\n\t*pcode = ctx->img1.density_code;\n\tif(ctx->img1.density_code!=IW_DENSITY_UNKNOWN) {\n\t\t*px = ctx->img1.density_x;\n\t\t*py = ctx->img1.density_y;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  void SetContextState(AudioContext* audio_context,\n                       AudioContext::AudioContextState state) {\n    audio_context->SetContextState(state);\n  }", "target": 0}
{"code": "static bool extractFileTo(zip* zip, const std::string &file, std::string& to,\n                          char* buf, size_t len) {\n  auto sep = file.rfind('/');\n  if (sep != std::string::npos) {\n    auto path = to + file.substr(0, sep);\n    if (!HHVM_FN(is_dir)(path) && !HHVM_FN(mkdir)(path, 0777, true)) {\n      return false;\n    }\n    if (sep == file.length() - 1) {\n      return true;\n    }\n  }\n  to.append(file);\n  struct zip_stat zipStat;\n  if (zip_stat(zip, file.c_str(), 0, &zipStat) != 0) {\n    return false;\n  }\n  auto zipFile = zip_fopen_index(zip, zipStat.index, 0);\n  FAIL_IF_INVALID_PTR(zipFile);\n  auto outFile = fopen(to.c_str(), \"wb\");\n  if (outFile == nullptr) {\n    zip_fclose(zipFile);\n    return false;\n  }\n  for (auto n = zip_fread(zipFile, buf, len); n != 0;\n       n = zip_fread(zipFile, buf, len)) {\n    if (n < 0 || fwrite(buf, sizeof(char), n, outFile) != n) {\n      zip_fclose(zipFile);\n      fclose(outFile);\n      remove(to.c_str());\n      return false;\n    }\n  }\n  zip_fclose(zipFile);\n  if (fclose(outFile) != 0) {\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "read_file(gchar* filepath)\n{\n\tFILE * f;\n\tsize_t length;\n\tgchar *ret = NULL;\n\tf = fopen(filepath, \"rb\");\n\tif (f) {\n\t\tfseek(f, 0, SEEK_END);\n\t\tlength = (size_t)ftell(f);\n\t\tfseek(f, 0, SEEK_SET);\n\t\tret = MALLOC(length + 1);\n\t\tif (ret) {\n\t\t\tif (fread(ret, length, 1, f) != 1) {\n\t\t\t\tlog_message(LOG_INFO, \"Failed to read all of %s\", filepath);\n\t\t\t}\n\t\t\tret[length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to read Dbus file %s\", filepath);\n\t\tfclose(f);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "sshpam_cleanup(void *arg)\n{\n\t(void)arg;\n\tdebug(\"PAM: cleanup\");\n\tpam_set_item(sshpam_handle, PAM_CONV, (const void *)&null_conv);\n\tif (sshpam_cred_established) {\n\t\tpam_setcred(sshpam_handle, PAM_DELETE_CRED);\n\t\tsshpam_cred_established = 0;\n\t}\n\tif (sshpam_session_open) {\n\t\tpam_close_session(sshpam_handle, PAM_SILENT);\n\t\tsshpam_session_open = 0;\n\t}\n\tsshpam_authenticated = sshpam_new_authtok_reqd = 0;\n\tpam_end(sshpam_handle, sshpam_err);\n\tsshpam_handle = NULL;\n}", "target": 0}
{"code": "Status Tensor::BuildTensor(DataType type, const TensorShape& shape,\n                           Tensor* out_tensor) {\n  CASES_WITH_DEFAULT(\n      type, {}, return errors::InvalidArgument(\"Type not set\"),\n      return errors::InvalidArgument(\"Unexpected type: \", DataType_Name(type)));\n  *out_tensor = Tensor(type, shape);\n  return Status::OK();\n}", "target": 0}
{"code": " bool makeAllDirectories(const String& path)\n {\n    String fullPath = path;\n    if (SHCreateDirectoryEx(0, fullPath.charactersWithNullTermination(), 0) != ERROR_SUCCESS) {\n        DWORD error = GetLastError();\n        if (error != ERROR_FILE_EXISTS && error != ERROR_ALREADY_EXISTS) {\n            LOG_ERROR(\"Failed to create path %s\", path.ascii().data());\n            return false;\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "bool initialise_control(rzip_control *control)\n{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; \n\tsize_t len;\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = \".lrz\";\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\tcontrol->threads = PROCESSORS;\t\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\tif (unlikely((now_t = time(NULL)) == ((time_t)-1)))\n\t\tfatal_return((\"Failed to call time in main\\n\"), false);\n\tif (unlikely(now_t < T_ZERO)) {\n\t\tprint_output(\"Warning your time reads before the year 2011, check your system clock\\n\");\n\t\tnow_t = T_ZERO;\n\t}\n\ttdiff = (now_t - T_ZERO) / 4;\n\tnow_t = T_ZERO + tdiff;\n\tcontrol->secs = now_t;\n\tcontrol->encloops = nloops(control->secs, control->salt, control->salt + 1);\n\tif (unlikely(!get_rand(control, control->salt + 2, 6)))\n\t\treturn false;\n\teptr = getenv(\"TMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TMP\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMPDIR\");\n\tif (!eptr)\n\t\teptr = getenv(\"TEMP\");\n\tif (!eptr)\n\t\teptr = localeptr;\n\tlen = strlen(eptr);\n\tcontrol->tmpdir = malloc(len + 2);\n\tif (control->tmpdir == NULL)\n\t\tfatal_return((\"Failed to allocate for tmpdir\\n\"), false);\n\tstrcpy(control->tmpdir, eptr);\n\tif (control->tmpdir[len - 1] != '/') {\n\t\tcontrol->tmpdir[len] = '/'; \n\t\tcontrol->tmpdir[len + 1] = '\\0';\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void mq_flush_data_end_io(struct request *rq, int error)\n{\n\tstruct request_queue *q = rq->q;\n\tstruct blk_mq_hw_ctx *hctx;\n\tstruct blk_mq_ctx *ctx = rq->mq_ctx;\n\tunsigned long flags;\n\tstruct blk_flush_queue *fq = blk_get_flush_queue(q, ctx);\n\thctx = q->mq_ops->map_queue(q, ctx->cpu);\n\tspin_lock_irqsave(&fq->mq_flush_lock, flags);\n\tif (blk_flush_complete_seq(rq, fq, REQ_FSEQ_DATA, error))\n\t\tblk_mq_run_hw_queue(hctx, true);\n\tspin_unlock_irqrestore(&fq->mq_flush_lock, flags);\n}", "target": 0}
{"code": "ikev1_hash_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len _U_,\n\t\t const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\t uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_HASH)));\n\treturn NULL;\n}", "target": 0}
{"code": "void SparseFillEmptyRowsOpImpl(OpKernelContext* context,\n                               AsyncOpKernel::DoneCallback done = nullptr) {\n  if (!done) {\n    done = [] {};\n  }\n  const int kIndicesInput = 0;\n  const int kValuesInput = 1;\n  const int kDenseShapeInput = 2;\n  const int kDefaultValueInput = 3;\n  const Tensor& indices_t = context->input(kIndicesInput);\n  const Tensor& values_t = context->input(kValuesInput);\n  const Tensor& dense_shape_t = context->input(kDenseShapeInput);\n  const Tensor& default_value_t = context->input(kDefaultValueInput);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsVector(dense_shape_t.shape()),\n      errors::InvalidArgument(\"dense_shape must be a vector, saw: \",\n                              dense_shape_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()),\n                    errors::InvalidArgument(\"indices must be a matrix, saw: \",\n                                            indices_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, indices_t.dim_size(0) == values_t.dim_size(0),\n      errors::InvalidArgument(\"The length of `values` (\", values_t.dim_size(0),\n                              \") must match the first dimension of `indices` (\",\n                              indices_t.dim_size(0), \").\"),\n      done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}", "target": 0}
{"code": "static int newque(struct ipc_namespace *ns, struct ipc_params *params)\n{\n\tstruct msg_queue *msq;\n\tint id, retval;\n\tkey_t key = params->key;\n\tint msgflg = params->flg;\n\tmsq = ipc_rcu_alloc(sizeof(*msq));\n\tif (!msq)\n\t\treturn -ENOMEM;\n\tmsq->q_perm.mode = msgflg & S_IRWXUGO;\n\tmsq->q_perm.key = key;\n\tmsq->q_perm.security = NULL;\n\tretval = security_msg_queue_alloc(msq);\n\tif (retval) {\n\t\tipc_rcu_putref(msq, ipc_rcu_free);\n\t\treturn retval;\n\t}\n\tid = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);\n\tif (id < 0) {\n\t\tipc_rcu_putref(msq, msg_rcu_free);\n\t\treturn id;\n\t}\n\tmsq->q_stime = msq->q_rtime = 0;\n\tmsq->q_ctime = get_seconds();\n\tmsq->q_cbytes = msq->q_qnum = 0;\n\tmsq->q_qbytes = ns->msg_ctlmnb;\n\tmsq->q_lspid = msq->q_lrpid = 0;\n\tINIT_LIST_HEAD(&msq->q_messages);\n\tINIT_LIST_HEAD(&msq->q_receivers);\n\tINIT_LIST_HEAD(&msq->q_senders);\n\tipc_unlock_object(&msq->q_perm);\n\trcu_read_unlock();\n\treturn msq->q_perm.id;\n}", "target": 1}
{"code": "char* _multi_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 2 );\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "Status ValidateNumThreads(int32_t num_threads) {\n  if (num_threads < 0) {\n    return errors::InvalidArgument(\"`num_threads` must be >= 0\");\n  }\n  if (num_threads >= kThreadLimit) {\n    return errors::InvalidArgument(\"`num_threads` must be < \", kThreadLimit);\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "static inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n}", "target": 0}
{"code": "static int vhost_attach_cgroups(struct vhost_dev *dev)\n{\n\tstruct vhost_attach_cgroups_struct attach;\n\tattach.owner = current;\n\tvhost_work_init(&attach.work, vhost_attach_cgroups_work);\n\tvhost_work_queue(dev, &attach.work);\n\tvhost_work_flush(dev, &attach.work);\n\treturn attach.ret;\n}", "target": 0}
{"code": "static void umocktypes_free_bool_ptr(bool** value)\n{\n    if (*value != NULL)\n    {\n        my_gballoc_free(*value);\n    }\n}", "target": 0}
{"code": "rpl_dio_printopt(netdissect_options *ndo,\n                 const struct rpl_dio_genoption *opt,\n                 u_int length)\n{\n        if(length < RPL_DIO_GENOPTION_LEN) return;\n        length -= RPL_DIO_GENOPTION_LEN;\n        ND_TCHECK(opt->rpl_dio_len);\n        while((opt->rpl_dio_type == RPL_OPT_PAD0 &&\n               (const u_char *)opt < ndo->ndo_snapend) ||\n              ND_TTEST2(*opt,(opt->rpl_dio_len+2))) {\n                unsigned int optlen = opt->rpl_dio_len+2;\n                if(opt->rpl_dio_type == RPL_OPT_PAD0) {\n                        optlen = 1;\n                        ND_PRINT((ndo, \" opt:pad0\"));\n                } else {\n                        ND_PRINT((ndo, \" opt:%s len:%u \",\n                                  tok2str(rpl_subopt_values, \"subopt:%u\", opt->rpl_dio_type),\n                                  optlen));\n                        if(ndo->ndo_vflag > 2) {\n                                unsigned int paylen = opt->rpl_dio_len;\n                                if(paylen > length) paylen = length;\n                                hex_print(ndo,\n                                          \" \",\n                                          ((const uint8_t *)opt) + RPL_DIO_GENOPTION_LEN,  \n                                          paylen);\n                        }\n                }\n                opt = (const struct rpl_dio_genoption *)(((const char *)opt) + optlen);\n                length -= optlen;\n        }\n        return;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n}", "target": 1}
{"code": "R_API void r_anal_bb_free(RAnalBlock *bb) {\n\tif (!bb) {\n\t\treturn;\n\t}\n\tr_anal_cond_free (bb->cond);\n\tR_FREE (bb->fingerprint);\n\tr_anal_diff_free (bb->diff);\n\tbb->diff = NULL;\n\tR_FREE (bb->op_bytes);\n\tr_anal_switch_op_free (bb->switch_op);\n\tbb->switch_op = NULL;\n\tbb->fingerprint = NULL;\n\tbb->cond = NULL;\n\tR_FREE (bb->label);\n\tR_FREE (bb->op_pos);\n\tR_FREE (bb->parent_reg_arena);\n\tif (bb->prev) {\n\t\tif (bb->prev->jumpbb == bb) {\n\t\t\tbb->prev->jumpbb = NULL;\n\t\t}\n\t\tif (bb->prev->failbb == bb) {\n\t\t\tbb->prev->failbb = NULL;\n\t\t}\n\t\tbb->prev = NULL;\n\t}\n\tif (bb->jumpbb) {\n\t\tbb->jumpbb->prev = NULL;\n\t\tbb->jumpbb = NULL;\n\t}\n\tif (bb->failbb) {\n\t\tbb->failbb->prev = NULL;\n\t\tbb->failbb = NULL;\n\t}\n\tR_FREE (bb);\n}", "target": 1}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "Jsi_RC Jsi_ValueInsertArray(Jsi_Interp *interp, Jsi_Value *target, int key, Jsi_Value *val, int flags)\n{\n    if (target->vt != JSI_VT_OBJECT) {\n        if (interp->strict)\n            Jsi_LogWarn(\"Target is not object\");\n        return JSI_ERROR;\n    }\n    Jsi_Obj *obj = target->d.obj;\n    if (obj->isarrlist) {\n        if (key >= 0 && key < interp->maxArrayList) {\n            Jsi_ObjArraySet(interp, obj, val, key);\n            return JSI_OK;\n        }\n        return JSI_ERROR;\n    }\n    char unibuf[100];\n    Jsi_NumberItoA10(key, unibuf, sizeof(unibuf));\n    Jsi_ObjInsert(interp, obj, unibuf, val, flags);\n    return JSI_OK;\n}", "target": 1}
{"code": "void SavePackage::Cancel(bool user_action) {\n  if (!canceled()) {\n    if (user_action)\n      user_canceled_ = true;\n    else\n      disk_error_occurred_ = true;\n    Stop();\n  }\n  RecordSavePackageEvent(SAVE_PACKAGE_CANCELLED);\n}", "target": 0}
{"code": "TEST(TensorSliceWriterTest, InvalidInput) {\n  SavedSlice ss;\n  std::array<uint32_t, 1> data;\n  std::fill(data.begin(), data.end(), 1234);\n  Status s = TensorSliceWriter::SaveData(data.data(), data.size(), &ss);\n  EXPECT_EQ(s.code(), error::INVALID_ARGUMENT);\n  EXPECT_TRUE(absl::StrContains(\n      s.error_message(),\n      \"Tensor slice serialization not implemented for dtype\"));\n}", "target": 0}
{"code": "int main()\n{\n    check_file(\"heap_overflow_1.tga\");\n    check_file(\"heap_overflow_2.tga\");\n    return gdNumFailures();\n}", "target": 0}
{"code": "static MagickBooleanType ReadPSDChannelPixels(Image *image,\n  const size_t channels,const size_t row,const ssize_t type,\n  const unsigned char *pixels,ExceptionInfo *exception)\n{\n  Quantum\n    pixel;\n  register const unsigned char\n    *p;\n  register Quantum\n    *q;\n  register ssize_t\n    x;\n  size_t\n    packet_size;\n  unsigned short\n    nibble;\n  p=pixels;\n  q=GetAuthenticPixels(image,0,row,image->columns,1,exception);\n  if (q == (Quantum *) NULL)\n    return MagickFalse;\n  packet_size=GetPSDPacketSize(image);\n  for (x=0; x < (ssize_t) image->columns; x++)\n  {\n    if (packet_size == 1)\n      pixel=ScaleCharToQuantum(*p++);\n    else\n      {\n        p=PushShortPixel(MSBEndian,p,&nibble);\n        pixel=ScaleShortToQuantum(nibble);\n      }\n    if (image->depth > 1)\n      {\n        SetPSDPixel(image,channels,type,packet_size,pixel,q,exception);\n        q+=GetPixelChannels(image);\n      }\n    else\n      {\n        ssize_t\n          bit,\n          number_bits;\n        number_bits=image->columns-x;\n        if (number_bits > 8)\n          number_bits=8;\n        for (bit = 0; bit < number_bits; bit++)\n        {\n          SetPSDPixel(image,channels,type,packet_size,(((unsigned char) pixel)\n            & (0x01 << (7-bit))) != 0 ? 0 : 255,q,exception);\n          q+=GetPixelChannels(image);\n          x++;\n        }\n        if (x != image->columns)\n          x--;\n        continue;\n      }\n  }\n  return(SyncAuthenticPixels(image,exception));\n}", "target": 0}
{"code": "int decomp_get_rddata(js_string *compressed, js_string *out,\n                      unsigned int compressed_offset, int type, int rdlength) {\n    char *desc;\n    int subtype, total, len;\n    desc = decomp_get_rrdesc(type);\n    if(desc == 0) { \n        if(rdlength == 0) {\n            return JS_SUCCESS;\n            }\n        if(decomp_append_bytes(compressed,out,compressed_offset,\n                               rdlength) != JS_SUCCESS) {\n            return JS_ERROR;\n            }\n        else {\n            return JS_SUCCESS;\n            }\n        }\n    else {\n        subtype = *desc;\n        total = 0;\n        while(subtype != 0) {\n            if(subtype > 0 && subtype < 64) {\n                if(decomp_append_bytes(compressed,out,\n                   compressed_offset,subtype) != JS_SUCCESS) {\n                       return JS_ERROR;\n                       }\n                total += subtype;\n                compressed_offset += subtype;\n                }\n            else if(subtype == RRSUB_DLABEL) {\n                len = decomp_append_dlabel(compressed,out,\n                        compressed_offset);\n                if(len == JS_ERROR) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else if(subtype == RRSUB_TEXT) {\n                len = *(compressed->string + compressed_offset);\n                len += 1; \n                if(len < 0 || len > 256) {\n                    return JS_ERROR;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) !=\n                   JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else if(subtype == RRSUB_VARIABLE) {\n                len = rdlength - total;\n                if(len == 0) {\n                    break;\n                    }\n                if(decomp_append_bytes(compressed,out,\n                                       compressed_offset,len) != JS_SUCCESS) {\n                    return JS_ERROR;\n                    }\n                total += len;\n                compressed_offset += len;\n                }\n            else { \n                return JS_ERROR;\n                }\n            desc++;\n            if(subtype != RRSUB_VARIABLE)\n                subtype = *desc;\n            else\n                subtype = 0; \n            }\n        if(rdlength != total) {\n            return JS_ERROR;\n            }\n        }\n    return JS_SUCCESS;\n    }", "target": 1}
{"code": "MemoryRegion *memory_map(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram(uc, ram, size, perms);\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "ext4_xattr_create_cache(char *name)\n{\n\treturn mb_cache_create(name, HASH_BUCKET_BITS);\n}", "target": 1}
{"code": "void LightProcess::ChangeUser(const std::string &username) {\n  if (username.empty()) return;\n  for (int i = 0; i < g_procsCount; i++) {\n    Lock lock(g_procs[i].m_procMutex);\n    fprintf(g_procs[i].m_fout, \"change_user\\n%s\\n\", username.c_str());\n    fflush(g_procs[i].m_fout);\n  }\n}", "target": 1}
{"code": "}\nstatic inline bool f2fs_force_buffered_io(struct inode *inode,\n\t\t\t\tstruct kiocb *iocb, struct iov_iter *iter)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint rw = iov_iter_rw(iter);\n\tif (f2fs_post_read_required(inode))\n\t\treturn true;\n\tif (f2fs_is_multi_device(sbi))\n\t\treturn true;\n\tif (f2fs_sb_has_blkzoned(sbi))\n\t\treturn true;\n\tif (test_opt(sbi, LFS) && (rw == WRITE) &&\n\t\t\t\tblock_unaligned_IO(inode, iocb, iter))\n\t\treturn true;\n\tif (is_sbi_flag_set(F2FS_I_SB(inode), SBI_CP_DISABLED))\n\t\treturn true;", "target": 1}
{"code": "is_apple_double (const char *name)\n{\nchar *basename;\n\tgboolean ret = FALSE;\n\tbasename = g_path_get_basename (name);\n\tif (basename == NULL) {\n\t\tg_debug (\"Filename '%s' doesn't have a basename?\", name);\n\t\treturn ret;\n\t}\n\tret = g_str_has_prefix (basename, APPLE_DOUBLE_PREFIX);\n\tg_free (basename);\n\treturn ret;\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 3>::ConstTensor input,\n                  bool signed_input, int num_bits, bool range_given,\n                  Tensor* input_min_tensor, Tensor* input_max_tensor,\n                  QuantizerRoundMode round_mode, bool narrow_range,\n                  typename TTypes<T, 3>::Tensor out) {\n    QuantizeAndDequantizePerChannelImpl<CPUDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }", "target": 1}
{"code": "static void _ewk_view_on_mouse_move(void* data, Evas* eventType, Evas_Object* callback, void* eventInfo)\n{\n    Evas_Event_Mouse_Move* moveEvent = static_cast<Evas_Event_Mouse_Move*>(eventInfo);\n    Ewk_View_Smart_Data* smartData = static_cast<Ewk_View_Smart_Data*>(data);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api);\n    EINA_SAFETY_ON_NULL_RETURN(smartData->api->mouse_move);\n    smartData->api->mouse_move(smartData, moveEvent);\n}", "target": 0}
{"code": "static int clie_5_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int pipe;\n\tint j;\n\tif (serial->num_ports < 2)\n\t\treturn -1;\n\tport = serial->port[0];\n\tport->bulk_out_endpointAddress =\n\t\t\t\tserial->port[1]->bulk_out_endpointAddress;\n\tpipe = usb_sndbulkpipe(serial->dev, port->bulk_out_endpointAddress);\n\tfor (j = 0; j < ARRAY_SIZE(port->write_urbs); ++j)\n\t\tport->write_urbs[j]->pipe = pipe;\n\treturn 0;\n}", "target": 1}
{"code": "de_dotdot( char* file )\n    {\n    char* cp;\n    char* cp2;\n    int l;\n    while ( ( cp = strstr( file, \"\n\t{\n\tfor ( cp2 = cp + 2; *cp2 == '/'; ++cp2 )\n\t    continue;\n\t(void) strcpy( cp + 1, cp2 );\n\t}\n    while ( strncmp( file, \"./\", 2 ) == 0 )\n\t(void) memmove( file, file + 2, strlen( file ) - 1 );\n    while ( ( cp = strstr( file, \"/./\") ) != (char*) 0 )\n\t(void) memmove( cp, cp + 2, strlen( file ) - 1 );\n    for (;;)\n\t{\n\twhile ( strncmp( file, \"../\", 3 ) == 0 )\n\t    (void) memmove( file, file + 3, strlen( file ) - 2 );\n\tcp = strstr( file, \"/../\" );\n\tif ( cp == (char*) 0 )\n\t    break;\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\t(void) strcpy( cp2 + 1, cp + 4 );\n\t}\n    while ( ( l = strlen( file ) ) > 3 &&\n\t    strcmp( ( cp = file + l - 3 ), \"/..\" ) == 0 )\n\t{\n\tfor ( cp2 = cp - 1; cp2 >= file && *cp2 != '/'; --cp2 )\n\t    continue;\n\tif ( cp2 < file )\n\t    break;\n\t*cp2 = '\\0';\n\t}\n    }", "target": 1}
{"code": "static void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "struct cifs_ntsd *get_cifs_acl(struct cifs_sb_info *cifs_sb,\n\t\t\t\t      struct inode *inode, const char *path,\n\t\t\t\t      u32 *pacllen)\n{\n\tstruct cifs_ntsd *pntsd = NULL;\n\tstruct cifsFileInfo *open_file = NULL;\n\tif (inode)\n\t\topen_file = find_readable_file(CIFS_I(inode), true);\n\tif (!open_file)\n\t\treturn get_cifs_acl_by_path(cifs_sb, path, pacllen);\n\tpntsd = get_cifs_acl_by_fid(cifs_sb, &open_file->fid, pacllen);\n\tcifsFileInfo_put(open_file);\n\treturn pntsd;\n}", "target": 0}
{"code": "void IndexedDBDatabase::RequestComplete(ConnectionRequest* request) {\n  DCHECK_EQ(request, active_request_.get());\n  active_request_.reset();\n  if (!pending_requests_.empty())\n    ProcessRequestQueue();\n}", "target": 0}
{"code": "GF_Err dOps_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_OpusSpecificBox *ptr = (GF_OpusSpecificBox *)s;\n\tif (!s) return GF_BAD_PARAM;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs,  0);\n\tgf_bs_write_u8(bs, ptr->opcfg.OutputChannelCount);\n\tgf_bs_write_u16(bs, ptr->opcfg.PreSkip);\n\tgf_bs_write_u32(bs, ptr->opcfg.InputSampleRate);\n\tgf_bs_write_u16(bs, ptr->opcfg.OutputGain);\n\tgf_bs_write_u8(bs, ptr->opcfg.ChannelMappingFamily);\n\tif (ptr->opcfg.ChannelMappingFamily) {\n\t\tgf_bs_write_u8(bs, ptr->opcfg.StreamCount);\n\t\tgf_bs_write_u8(bs, ptr->opcfg.CoupledCount);\n\t\tgf_bs_write_data(bs, (char *) ptr->opcfg.ChannelMapping, ptr->opcfg.OutputChannelCount);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void JSArray::sortNumeric(ExecState* exec, JSValue compareFunction, CallType callType, const CallData& callData)\n{\n    ArrayStorage* storage = m_storage;\n    unsigned lengthNotIncludingUndefined = compactForSorting();\n    if (storage->m_sparseValueMap) {\n        throwOutOfMemoryError(exec);\n        return;\n    }\n    if (!lengthNotIncludingUndefined)\n        return;\n    bool allValuesAreNumbers = true;\n    size_t size = storage->m_numValuesInVector;\n    for (size_t i = 0; i < size; ++i) {\n        if (!storage->m_vector[i].isNumber()) {\n            allValuesAreNumbers = false;\n            break;\n        }\n    }\n    if (!allValuesAreNumbers)\n        return sort(exec, compareFunction, callType, callData);\n    qsort(storage->m_vector, size, sizeof(JSValue), compareNumbersForQSort);\n    checkConsistency(SortConsistencyCheck);\n}", "target": 0}
{"code": "search_make_new(const struct search_state *const state, int n, const char *const base_name) {\n\tconst size_t base_len = strlen(base_name);\n\tconst char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;\n\tstruct search_domain *dom;\n\tfor (dom = state->head; dom; dom = dom->next) {\n\t\tif (!n--) {\n\t\t\tconst u8 *const postfix = ((u8 *) dom) + sizeof(struct search_domain);\n\t\t\tconst int postfix_len = dom->len;\n\t\t\tchar *const newname = (char *) mm_malloc(base_len + need_to_append_dot + postfix_len + 1);\n\t\t\tif (!newname) return NULL;\n\t\t\tmemcpy(newname, base_name, base_len);\n\t\t\tif (need_to_append_dot) newname[base_len] = '.';\n\t\t\tmemcpy(newname + base_len + need_to_append_dot, postfix, postfix_len);\n\t\t\tnewname[base_len + need_to_append_dot + postfix_len] = 0;\n\t\t\treturn newname;\n\t\t}\n\t}\n\tEVUTIL_ASSERT(0);\n\treturn NULL; \n}", "target": 1}
{"code": "void test_chroot(const char *path)\n{\n\tif (chroot(path) == 0) {\n\t\tfprintf(stderr, \"leak at chroot of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chroot of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "  void event_cb(drachtio::RequestHandler::GlobalInfo *g, curl_socket_t s,\n                       int action, const boost::system::error_code & error,\n                       int *fdp) {\n    std::shared_ptr<RequestHandler> p = RequestHandler::getInstance() ;\n    std::map<curl_socket_t, boost::asio::ip::tcp::socket *>& socket_map = p->getSocketMap() ;\n    boost::asio::deadline_timer& timer = p->getTimer() ;\n    if(socket_map.find(s) == socket_map.end()) {\n      DR_LOG(log_error) << \"event_cb: socket already closed\";\n      return;\n    }\n    if(*fdp == action || *fdp == CURL_POLL_INOUT) {\n      CURLMcode rc;\n      if(error)\n        action = CURL_CSELECT_ERR;\n      rc = curl_multi_socket_action(g->multi, s, action, &g->still_running);\n      mcode_test(\"event_cb: curl_multi_socket_action\", rc);\n      check_multi_info(g);\n      if(g->still_running <= 0) {\n        timer.cancel();\n      }\n      if(!error && socket_map.find(s) != socket_map.end() &&\n         (*fdp == action || *fdp == CURL_POLL_INOUT)) {\n        boost::asio::ip::tcp::socket *tcp_socket = socket_map.find(s)->second;\n        if(action == CURL_POLL_IN) {\n          tcp_socket->async_read_some(boost::asio::null_buffers(),\n                                      boost::bind(&event_cb, g, s,\n                                                  action, boost::placeholders::_1, fdp));\n        }\n        if(action == CURL_POLL_OUT) {\n          tcp_socket->async_write_some(boost::asio::null_buffers(),\n                                       boost::bind(&event_cb, g, s,\n                                                   action, boost::placeholders::_1, fdp));\n        } \n      }\n    }\n  }", "target": 1}
{"code": "fr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\treturn capabilities;\n}", "target": 1}
{"code": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n#if __UNIX__\n\tint msecs = (usecs / 1000);\n\tstruct pollfd fds[1];\n\tfds[0].fd = s->fd;\n\tfds[0].events = POLLIN | POLLPRI;\n\tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;\n\treturn poll ((struct pollfd *)&fds, 1, msecs);\n#elif __WINDOWS__\n\tfd_set rfds;\n\tstruct timeval tv;\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\ttv.tv_sec = secs;\n\ttv.tv_usec = usecs;\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n#else\n\treturn true; \n#endif\n}", "target": 1}
{"code": "  bool has_dom_ui_bindings() const {\n    return BindingsPolicy::is_dom_ui_enabled(enabled_bindings_);\n  }", "target": 0}
{"code": "parse_field(netdissect_options *ndo, const char **pptr, int *len)\n{\n    const char *s;\n    if (*len <= 0 || !pptr || !*pptr)\n\treturn NULL;\n    if (*pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    s = *pptr;\n    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {\n\t(*pptr)++;\n\t(*len)--;\n    }\n    (*pptr)++;\n    (*len)--;\n    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)\n\treturn NULL;\n    return s;\n}", "target": 1}
{"code": "void ImmutableConstantOp::Compute(OpKernelContext* ctx) {\n  std::unique_ptr<MemmappedTensorAllocator> allocator(\n      new MemmappedTensorAllocator());\n  OP_REQUIRES_OK(ctx,\n                 allocator->InitializeFromRegion(region_name_, ctx->env()));\n  OP_REQUIRES(ctx, dtype_ != DT_STRING,\n              errors::Unimplemented(\"Sorry, DT_STRING is not currently \"\n                                    \"supported for ImmutableConstOp.\"));\n  ctx->set_output(0, Tensor(allocator.get(), dtype_, shape_));\n  OP_REQUIRES_OK(ctx, allocator->allocation_status());\n  allocator.release()->set_delete_on_deallocate();\n}", "target": 0}
{"code": "sysLocation_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"\");\n}", "target": 1}
{"code": "static int DefragBsdMissingFragmentIpv4Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,\n                                                     size_t xTriggerLevelBytes,\n                                                     BaseType_t xIsMessageBuffer )\n    {\n        uint8_t * pucAllocatedMemory;\n        uint8_t ucFlags;\n        if( xIsMessageBuffer == pdTRUE )\n        {\n            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;\n            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );\n        }\n        else\n        {\n            ucFlags = 0;\n            configASSERT( xBufferSizeBytes > 0 );\n        }\n        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );\n        if( xTriggerLevelBytes == ( size_t ) 0 )\n        {\n            xTriggerLevelBytes = ( size_t ) 1;\n        }\n        xBufferSizeBytes++;\n        pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); \n        if( pucAllocatedMemory != NULL )\n        {\n            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,         \n                                          pucAllocatedMemory + sizeof( StreamBuffer_t ),  \n                                          xBufferSizeBytes,\n                                          xTriggerLevelBytes,\n                                          ucFlags );\n            traceSTREAM_BUFFER_CREATE( ( ( StreamBuffer_t * ) pucAllocatedMemory ), xIsMessageBuffer );\n        }\n        else\n        {\n            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );\n        }\n        return ( StreamBufferHandle_t ) pucAllocatedMemory; \n    }", "target": 1}
{"code": "hash_link_ref(const uint8_t *link_ref, size_t length)\n{\n\tsize_t i;\n\tunsigned int hash = 0;\n\tfor (i = 0; i < length; ++i)\n\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n\treturn hash;\n}", "target": 1}
{"code": "gboolean session_info_session_is_locked(struct session_info *si)\n{\n    gboolean locked;\n    g_return_val_if_fail (si != NULL, FALSE);\n    si_dbus_read_signals(si);\n    si_dbus_read_properties(si);\n    locked = (si->session_is_locked || si->session_locked_hint);\n    if (si->verbose) {\n        syslog(LOG_DEBUG, \"(systemd-login) session is locked: %s\",\n               locked ? \"yes\" : \"no\");\n    }\n    return locked;\n}", "target": 0}
{"code": "static int process_options(int argc, char *argv[], char *operation)\n{\n  int error= 0;\n  int i= 0;\n  if ((error= handle_options(&argc, &argv, my_long_options, get_one_option)))\n    goto exit;\n  if (opt_print_defaults)\n  {\n    error= -1;\n    goto exit;\n  }\n  if (opt_basedir)\n  {\n    i= (int)strlength(opt_basedir);\n    if (opt_basedir[i-1] != FN_LIBCHAR || opt_basedir[i-1] != FN_LIBCHAR2)\n    {\n      char buff[FN_REFLEN];\n      memset(buff, 0, sizeof(buff));\n      strncpy(buff, opt_basedir, sizeof(buff) - 1);\n#ifdef __WIN__\n      strncat(buff, \"/\", sizeof(buff) - strlen(buff) - 1);\n#else\n      strncat(buff, FN_DIRSEP, sizeof(buff) - strlen(buff) - 1);\n#endif\n      buff[sizeof(buff) - 1]= 0;\n      my_free(opt_basedir);\n      opt_basedir= my_strdup(buff, MYF(MY_FAE));\n    }\n  }\n  if (!opt_no_defaults && ((error= get_default_values())))\n  {\n    error= -1;\n    goto exit;\n  }\n  strcpy(operation, \"\");\n  if ((error = check_options(argc, argv, operation)))\n  {\n    goto exit;\n  }\n  if (opt_verbose)\n  {\n    printf(\"#    basedir = %s\\n\", opt_basedir);\n    printf(\"# plugin_dir = %s\\n\", opt_plugin_dir);\n    printf(\"#    datadir = %s\\n\", opt_datadir);\n    printf(\"# plugin_ini = %s\\n\", opt_plugin_ini);\n  }\nexit:\n  return error;\n}", "target": 0}
{"code": "static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)\n{\n\tif ((ctx->clockid == CLOCK_REALTIME ||\n\t     ctx->clockid == CLOCK_REALTIME_ALARM) &&\n\t    (flags & TFD_TIMER_ABSTIME) && (flags & TFD_TIMER_CANCEL_ON_SET)) {\n\t\tif (!ctx->might_cancel) {\n\t\t\tctx->might_cancel = true;\n\t\t\tspin_lock(&cancel_lock);\n\t\t\tlist_add_rcu(&ctx->clist, &cancel_list);\n\t\t\tspin_unlock(&cancel_lock);\n\t\t}\n\t} else if (ctx->might_cancel) {\n\t\ttimerfd_remove_cancel(ctx);\n\t}\n}", "target": 1}
{"code": "mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \" Unknown Version (%d)\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));\n                return 1;\n        }\n        if (mpc->flags & MP_CAPABLE_C)\n                ND_PRINT((ndo, \" csum\"));\n        ND_PRINT((ndo, \" {0x%\" PRIx64, EXTRACT_64BITS(mpc->sender_key)));\n        if (opt_len == 20) \n                ND_PRINT((ndo, \",0x%\" PRIx64, EXTRACT_64BITS(mpc->receiver_key)));\n        ND_PRINT((ndo, \"}\"));\n        return 1;\n}", "target": 1}
{"code": "static void sanitize_string(std::string &str)\n{\n\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_START), str.end());\n\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_KV_DELIM), str.end());\n\tstr.erase(std::remove(str.begin(), str.end(), DESERIALIZE_PAIR_DELIM), str.end());\n}", "target": 0}
{"code": "vg_send_msg(VuGpu *vg, const VhostUserGpuMsg *msg, int fd)\n{\n    if (vg_sock_fd_write(vg->sock_fd, msg,\n                         VHOST_USER_GPU_HDR_SIZE + msg->size, fd) < 0) {\n        vg_sock_fd_close(vg);\n    }\n}", "target": 0}
{"code": "int AVI_read_frame(avi_t *AVI, u8 *vidbuf, int *keyframe)\n{\n\tint n;\n\tif(AVI->mode==AVI_MODE_WRITE) {\n\t\tAVI_errno = AVI_ERR_NOT_PERM;\n\t\treturn -1;\n\t}\n\tif(!AVI->video_index)         {\n\t\tAVI_errno = AVI_ERR_NO_IDX;\n\t\treturn -1;\n\t}\n\tif(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n\tn = (u32) AVI->video_index[AVI->video_pos].len;\n\t*keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\tif (vidbuf == NULL) {\n\t\tAVI->video_pos++;\n\t\treturn n;\n\t}\n\tgf_fseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\tif (avi_read(AVI->fdes,vidbuf,n) != (u32) n)\n\t{\n\t\tAVI_errno = AVI_ERR_READ;\n\t\treturn -1;\n\t}\n\tAVI->video_pos++;\n\treturn n;\n}", "target": 1}
{"code": "static int ext4_split_extent(handle_t *handle,\n\t\t\t      struct inode *inode,\n\t\t\t      struct ext4_ext_path *path,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      int split_flag,\n\t\t\t      int flags)\n{\n\text4_lblk_t ee_block;\n\tstruct ext4_extent *ex;\n\tunsigned int ee_len, depth;\n\tint err = 0;\n\tint uninitialized;\n\tint split_flag1, flags1;\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\tuninitialized = ext4_ext_is_uninitialized(ex);\n\tif (map->m_lblk + map->m_len < ee_block + ee_len) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tflags1 = flags | EXT4_GET_BLOCKS_PRE_IO;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1 |\n\t\t\t\t       EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk + map->m_len, split_flag1, flags1);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\text4_ext_drop_refs(path);\n\tpath = ext4_ext_find_extent(inode, map->m_lblk, path);\n\tif (IS_ERR(path))\n\t\treturn PTR_ERR(path);\n\tif (map->m_lblk >= ee_block) {\n\t\tsplit_flag1 = split_flag & EXT4_EXT_MAY_ZEROOUT ?\n\t\t\t      EXT4_EXT_MAY_ZEROOUT : 0;\n\t\tif (uninitialized)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT1;\n\t\tif (split_flag & EXT4_EXT_MARK_UNINIT2)\n\t\t\tsplit_flag1 |= EXT4_EXT_MARK_UNINIT2;\n\t\terr = ext4_split_extent_at(handle, inode, path,\n\t\t\t\tmap->m_lblk, split_flag1, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\text4_ext_show_leaf(inode, path);\nout:\n\treturn err ? err : map->m_len;\n}", "target": 1}
{"code": "static int decode_unit(SCPRContext *s, PixelModel *pixel, unsigned step, unsigned *rval)\n{\n    GetByteContext *gb = &s->gb;\n    RangeCoder *rc = &s->rc;\n    unsigned totfr = pixel->total_freq;\n    unsigned value, x = 0, cumfr = 0, cnt_x = 0;\n    int i, j, ret, c, cnt_c;\n    if ((ret = s->get_freq(rc, totfr, &value)) < 0)\n        return ret;\n    while (x < 16) {\n        cnt_x = pixel->lookup[x];\n        if (value >= cumfr + cnt_x)\n            cumfr += cnt_x;\n        else\n            break;\n        x++;\n    }\n    c = x * 16;\n    cnt_c = 0;\n    while (c < 256) {\n        cnt_c = pixel->freq[c];\n        if (value >= cumfr + cnt_c)\n            cumfr += cnt_c;\n        else\n            break;\n        c++;\n    }\n    if (x >= 16 || c >= 256) {\n        return AVERROR_INVALIDDATA;\n    }\n    if ((ret = s->decode(gb, rc, cumfr, cnt_c, totfr)) < 0)\n        return ret;\n    pixel->freq[c] = cnt_c + step;\n    pixel->lookup[x] = cnt_x + step;\n    totfr += step;\n    if (totfr > BOT) {\n        totfr = 0;\n        for (i = 0; i < 256; i++) {\n            unsigned nc = (pixel->freq[i] >> 1) + 1;\n            pixel->freq[i] = nc;\n            totfr += nc;\n        }\n        for (i = 0; i < 16; i++) {\n            unsigned sum = 0;\n            unsigned i16_17 = i << 4;\n            for (j = 0; j < 16; j++)\n                sum += pixel->freq[i16_17 + j];\n            pixel->lookup[i] = sum;\n        }\n    }\n    pixel->total_freq = totfr;\n    *rval = c & s->cbits;\n    return 0;\n}", "target": 0}
{"code": "aspath_loop_check (struct aspath *aspath, as_t asno)\n{\n  struct assegment *seg;\n  int count = 0;\n  if ( (aspath == NULL) || (aspath->segments == NULL) )\n    return 0;\n  seg = aspath->segments;\n  while (seg)\n    {\n      int i;\n      for (i = 0; i < seg->length; i++)\n\tif (seg->as[i] == asno)\n\t  count++;\n      seg = seg->next;\n    }\n  return count;\n}", "target": 0}
{"code": "static void test_show_object(struct object *object,\n\t\t\t     struct strbuf *path,\n\t\t\t     const char *last, void *data)\n{\n\tstruct bitmap_test_data *tdata = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0)\n\t\tdie(\"Object not in bitmap: %s\\n\", oid_to_hex(&object->oid));\n\tbitmap_set(tdata->base, bitmap_pos);\n\tdisplay_progress(tdata->prg, ++tdata->seen);\n}", "target": 1}
{"code": "static struct file *path_openat(int dfd, struct filename *pathname,\n\t\tstruct nameidata *nd, const struct open_flags *op, int flags)\n{\n\tstruct file *file;\n\tstruct path path;\n\tint opened = 0;\n\tint error;\n\tfile = get_empty_filp();\n\tif (IS_ERR(file))\n\t\treturn file;\n\tfile->f_flags = op->open_flag;\n\tif (unlikely(file->f_flags & __O_TMPFILE)) {\n\t\terror = do_tmpfile(dfd, pathname, nd, flags, op, file, &opened);\n\t\tgoto out;\n\t}\n\terror = path_init(dfd, pathname, flags, nd);\n\tif (unlikely(error))\n\t\tgoto out;\n\terror = do_last(nd, &path, file, op, &opened, pathname);\n\twhile (unlikely(error > 0)) { \n\t\tstruct path link = path;\n\t\tvoid *cookie;\n\t\tif (!(nd->flags & LOOKUP_FOLLOW)) {\n\t\t\tpath_put_conditional(&path, nd);\n\t\t\tpath_put(&nd->path);\n\t\t\terror = -ELOOP;\n\t\t\tbreak;\n\t\t}\n\t\terror = may_follow_link(&link, nd);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\tnd->flags |= LOOKUP_PARENT;\n\t\tnd->flags &= ~(LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL);\n\t\terror = follow_link(&link, nd, &cookie);\n\t\tif (unlikely(error))\n\t\t\tbreak;\n\t\terror = do_last(nd, &path, file, op, &opened, pathname);\n\t\tput_link(nd, &link, cookie);\n\t}\nout:\n\tpath_cleanup(nd);\n\tif (!(opened & FILE_OPENED)) {\n\t\tBUG_ON(!error);\n\t\tput_filp(file);\n\t}\n\tif (unlikely(error)) {\n\t\tif (error == -EOPENSTALE) {\n\t\t\tif (flags & LOOKUP_RCU)\n\t\t\t\terror = -ECHILD;\n\t\t\telse\n\t\t\t\terror = -ESTALE;\n\t\t}\n\t\tfile = ERR_PTR(error);\n\t}\n\treturn file;\n}", "target": 1}
{"code": "static NO_INLINE JsVar *jspGetNamedFieldInParents(JsVar *object, const char* name, bool returnName) {\n  JsVar * child = jspeiFindChildFromStringInParents(object, name);\n  if (!child) {\n    child = jswFindBuiltInFunction(object, name);\n  }\n  if (child && returnName) {\n    if (jsvIsName(child)) {\n      JsVar *t = jsvGetValueOfName(child);\n      jsvUnLock(child);\n      child = t;\n    }\n    JsVar *nameVar = jsvNewFromString(name);\n    JsVar *newChild = jsvCreateNewChild(object, nameVar, child);\n    jsvUnLock2(nameVar, child);\n    child = newChild;\n  }\n  if (!child) {\n    if (jsvIsFunction(object) && strcmp(name, JSPARSE_PROTOTYPE_VAR)==0) {\n      JsVar *proto = jsvNewObject();\n      jsvObjectSetChild(proto, JSPARSE_CONSTRUCTOR_VAR, object);\n      child = jsvAddNamedChild(object, proto, JSPARSE_PROTOTYPE_VAR);\n      jspEnsureIsPrototype(object, child);\n      jsvUnLock(proto);\n    } else if (strcmp(name, JSPARSE_INHERITS_VAR)==0) {\n      const char *objName = jswGetBasicObjectName(object);\n      if (objName) {\n        child = jspNewPrototype(objName);\n      }\n    }\n  }\n  return child;\n}", "target": 1}
{"code": "new_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct fixup_entry *fe;\n\tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n\tif (fe == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for a fixup\");\n\t\treturn (NULL);\n\t}\n\tfe->next = a->fixup_list;\n\ta->fixup_list = fe;\n\tfe->fixup = 0;\n\tfe->mode = 0;\n\tfe->name = strdup(pathname);\n\treturn (fe);\n}", "target": 0}
{"code": "Archive::Archive(RAROptions *InitCmd)\n{\n  Cmd=NULL; \n  DummyCmd=(InitCmd==NULL);\n  Cmd=DummyCmd ? (new RAROptions):InitCmd;\n  OpenShared=Cmd->OpenShared;\n  Format=RARFMT15;\n  Solid=false;\n  Volume=false;\n  MainComment=false;\n  Locked=false;\n  Signed=false;\n  FirstVolume=false;\n  NewNumbering=false;\n  SFXSize=0;\n  LatestTime.Reset();\n  Protected=false;\n  Encrypted=false;\n  FailedHeaderDecryption=false;\n  BrokenHeader=false;\n  LastReadBlock=0;\n  CurBlockPos=0;\n  NextBlockPos=0;\n  RecoverySize=-1;\n  RecoveryPercent=-1;\n  memset(&MainHead,0,sizeof(MainHead));\n  memset(&CryptHead,0,sizeof(CryptHead));\n  memset(&EndArcHead,0,sizeof(EndArcHead));\n  VolNumber=0;\n  VolWrite=0;\n  AddingFilesSize=0;\n  AddingHeadersSize=0;\n  *FirstVolumeName=0;\n  Splitting=false;\n  NewArchive=false;\n  SilentOpen=false;\n#ifdef USE_QOPEN\n  ProhibitQOpen=false;\n#endif\n}", "target": 0}
{"code": "static void ip6_append_data_mtu(int *mtu,\n\t\t\t\tint *maxfraglen,\n\t\t\t\tunsigned int fragheaderlen,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tstruct rt6_info *rt)\n{\n\tif (!(rt->dst.flags & DST_XFRM_TUNNEL)) {\n\t\tif (skb == NULL) {\n\t\t\t*mtu = *mtu - rt->dst.header_len;\n\t\t} else {\n\t\t\t*mtu = dst_mtu(rt->dst.path);\n\t\t}\n\t\t*maxfraglen = ((*mtu - fragheaderlen) & ~7)\n\t\t\t      + fragheaderlen - sizeof(struct frag_hdr);\n\t}\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    OP_REQUIRES(context, out_backprop.dims() == 5,\n                errors::InvalidArgument(\"out_backprop must be 5-dimensional\"));\n    const TensorShape& output_shape = tensor_in.shape();\n    Tensor* input_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, output_shape, &input_backprop));\n    std::array<int64_t, 3> input_size{\n        {GetTensorDim(output_shape, data_format_, '2'),\n         GetTensorDim(output_shape, data_format_, '1'),\n         GetTensorDim(output_shape, data_format_, '0')}};\n    std::array<int64_t, 3> window{{GetTensorDim(ksize_, data_format_, '2'),\n                                   GetTensorDim(ksize_, data_format_, '1'),\n                                   GetTensorDim(ksize_, data_format_, '0')}};\n    std::array<int64_t, 3> stride{{GetTensorDim(stride_, data_format_, '2'),\n                                   GetTensorDim(stride_, data_format_, '1'),\n                                   GetTensorDim(stride_, data_format_, '0')}};\n    std::array<int64_t, 3> out, padding;\n    OP_REQUIRES_OK(context, Get3dOutputSize(input_size, window, stride,\n                                            padding_, &out, &padding));\n    const int64_t depth = GetTensorDim(tensor_in, data_format_, 'C');\n    const int64_t in_batch = GetTensorDim(tensor_in, data_format_, 'N');\n    TensorShape out_shape = ShapeFromFormat(data_format_, in_batch,\n                                            {{out[2], out[1], out[0]}}, depth);\n    OP_REQUIRES(\n        context, tensor_out.shape() == out_shape,\n        errors::InvalidArgument(\"Expected orig_output shape to be \", out_shape,\n                                \", but got \", tensor_out.shape()));\n    OP_REQUIRES(context, out_backprop.shape() == out_shape,\n                errors::InvalidArgument(\"Expected grad shape to be \", out_shape,\n                                        \", but got \", out_backprop.shape()));\n    LaunchMaxPooling3dGradOp<Device, T>::launch(\n        context, tensor_in, tensor_out, out_backprop, window, stride, out,\n        padding, data_format_, input_backprop);\n  }", "target": 0}
{"code": "YCPBoolean as_boolean (const YCPValue& v, const char * context)\n{\n    if (v->isBoolean ())\n\treturn v->asBoolean ();\n    ycp2error (\"Expected a boolean for %s, got %s %s\",\n\t       context, v->valuetype_str(), v->toString().c_str());\n    return YCPNull ();\n}", "target": 0}
{"code": "static pyc_object *get_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "int kvm_deassign_device(struct kvm *kvm,\n\t\t\tstruct kvm_assigned_dev_kernel *assigned_dev)\n{\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tstruct pci_dev *pdev = NULL;\n\tif (!domain)\n\t\treturn 0;\n\tpdev = assigned_dev->dev;\n\tif (pdev == NULL)\n\t\treturn -ENODEV;\n\tiommu_detach_device(domain, &pdev->dev);\n\tpci_clear_dev_assigned(pdev);\n\tdev_info(&pdev->dev, \"kvm deassign device\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "MONGO_EXPORT int mongo_insert_batch( mongo *conn, const char *ns,\n                                     const bson **bsons, int count, mongo_write_concern *custom_write_concern,\n                                     int flags ) {\n    mongo_message *mm;\n    mongo_write_concern *write_concern = NULL;\n    int i;\n    char *data;\n    int overhead =  16 + 4 + strlen( ns ) + 1;\n    int size = overhead;\n    if( mongo_validate_ns( conn, ns ) != MONGO_OK )\n        return MONGO_ERROR;\n    for( i=0; i<count; i++ ) {\n        size += bson_size( bsons[i] );\n        if( mongo_bson_valid( conn, bsons[i], 1 ) != MONGO_OK )\n            return MONGO_ERROR;\n    }\n    if( ( size - overhead ) > conn->max_bson_size ) {\n        conn->err = MONGO_BSON_TOO_LARGE;\n        return MONGO_ERROR;\n    }\n    if( mongo_choose_write_concern( conn, custom_write_concern,\n                                    &write_concern ) == MONGO_ERROR ) {\n        return MONGO_ERROR;\n    }\n    mm = mongo_message_create( size , 0 , 0 , MONGO_OP_INSERT );\n    data = &mm->data;\n    if( flags & MONGO_CONTINUE_ON_ERROR )\n        data = mongo_data_append32( data, &ONE );\n    else\n        data = mongo_data_append32( data, &ZERO );\n    data = mongo_data_append( data, ns, strlen( ns ) + 1 );\n    for( i=0; i<count; i++ ) {\n        data = mongo_data_append( data, bsons[i]->data, bson_size( bsons[i] ) );\n    }\n    if( write_concern ) {\n        if( mongo_message_send( conn, mm ) == MONGO_ERROR ) {\n            return MONGO_ERROR;\n        }\n        return mongo_check_last_error( conn, ns, write_concern );\n    }\n    else {\n        return mongo_message_send( conn, mm );\n    }\n}", "target": 1}
{"code": "QPDF::resolve(int objid, int generation)\n{\n    QPDFObjGen og(objid, generation);\n    if (this->resolving.count(og))\n    {\n\tQTC::TC(\"qpdf\", \"QPDF recursion loop in resolve\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->file->getName(),\n\t\t     \"\", this->file->getLastOffset(),\n\t\t     \"loop detected resolving object \" +\n\t\t     QUtil::int_to_string(objid) + \" \" +\n\t\t     QUtil::int_to_string(generation)));\n        return new QPDF_Null;\n    }\n    ResolveRecorder rr(this, og);\n    if (! this->obj_cache.count(og))\n    {\n\tif (! this->xref_table.count(og))\n\t{\n\t    return new QPDF_Null;\n\t}\n\tQPDFXRefEntry const& entry = this->xref_table[og];\n\tswitch (entry.getType())\n\t{\n\t  case 1:\n\t    {\n\t\tqpdf_offset_t offset = entry.getOffset();\n\t\tint aobjid;\n\t\tint ageneration;\n\t\tQPDFObjectHandle oh =\n\t\t    readObjectAtOffset(true, offset, \"\", objid, generation,\n\t\t\t\t       aobjid, ageneration);\n\t    }\n\t    break;\n\t  case 2:\n\t    resolveObjectsInStream(entry.getObjStreamNumber());\n\t    break;\n\t  default:\n\t    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), \"\", 0,\n\t\t\t  \"object \" +\n\t\t\t  QUtil::int_to_string(objid) + \"/\" +\n\t\t\t  QUtil::int_to_string(generation) +\n\t\t\t  \" has unexpected xref entry type\");\n\t}\n    }\n    return this->obj_cache[og].object;\n}", "target": 0}
{"code": "unquoted_glob_pattern_p (string)\n     register char *string;\n{\n  register int c;\n  char *send;\n  int open, bsquote;\n  DECLARE_MBSTATE;\n  open = bsquote = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string != '\\0' && *string != '/')\n\t    {\n\t      bsquote = 1;\n\t      string++;\n\t      continue;\n\t    }\n\t  else if (*string == 0)\n\t    return (0);\n\tcase CTLESC:\n\t  if (*string++ == '\\0')\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return ((bsquote && posix_glob_backslash) ? 2 : 0);\n}", "target": 1}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(bufsize >= 0);\n\tJAS_DBGLOG(100, (\"mem_resize(%p, %d)\\n\", m, bufsize));\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\tJAS_DBGLOG(100, (\"mem_resize realloc failed\\n\"));\n\t\treturn -1;\n\t}\n\tJAS_DBGLOG(100, (\"mem_resize realloc succeeded\\n\"));\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "bool ExtractHardlink(CommandData *Cmd,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); \n  if (!FileExist(NameExisting))\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    uiMsg(UIERROR_NOLINKTARGET);\n    ErrHandler.SetErrorCode(RARX_CREATE);\n    return false;\n  }\n  CreatePath(NameNew,true,Cmd->DisableNames);\n#ifdef _WIN_ALL\n  bool Success=CreateHardLink(NameNew,NameExisting,NULL)!=0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#elif defined(_UNIX)\n  char NameExistingA[NM],NameNewA[NM];\n  WideToChar(NameExisting,NameExistingA,ASIZE(NameExistingA));\n  WideToChar(NameNew,NameNewA,ASIZE(NameNewA));\n  bool Success=link(NameExistingA,NameNewA)==0;\n  if (!Success)\n  {\n    uiMsg(UIERROR_HLINKCREATE,NameNew);\n    ErrHandler.SysErrMsg();\n    ErrHandler.SetErrorCode(RARX_CREATE);\n  }\n  return Success;\n#else\n  return false;\n#endif\n}", "target": 1}
{"code": "snmp_mib_cmp_oid(snmp_oid_t *oid1, snmp_oid_t *oid2)\n{\n  uint8_t i;\n  i = 0;\n  while(i < oid1->length && i < oid2->length) {\n    if(oid1->data[i] != oid2->data[i]) {\n      if(oid1->data[i] < oid2->data[i]) {\n        return -1;\n      }\n      return 1;\n    }\n    i++;\n  }\n  if(i == oid1->length &&\n     i < oid2->length) {\n    return -1;\n  }\n  if(i < oid1->length &&\n     i == oid2->length) {\n    return 1;\n  }\n  return 0;\n}", "target": 0}
{"code": "static int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)\n{\n\tchar *originurl_raw;\n\tchar *originurl;\n\tchar *query;\n\tint ret = 0;\n\tconst char *separator = \"&\";\n\tchar *querystr;\n\tquery = safe_calloc(QUERYMAXLEN);\n\tif (!query) {\n\t\tret = send_error(connection, 503);\n\t\tfree(query);\n\t\treturn ret;\n\t}\n\tquerystr = safe_calloc(QUERYMAXLEN);\n\tif (!querystr) {\n\t\tret = send_error(connection, 503);\n\t\tfree(querystr);\n\t\treturn ret;\n\t}\n\toriginurl_raw = safe_calloc(MID_BUF);\n\tif (!originurl_raw) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl_raw);\n\t\treturn ret;\n\t}\n\toriginurl = safe_calloc(CUSTOM_ENC);\n\tif (!originurl) {\n\t\tret = send_error(connection, 503);\n\t\tfree(originurl);\n\t\treturn ret;\n\t}\n\tget_query(connection, &query, separator);\n\tif (!query) {\n\t\tdebug(LOG_DEBUG, \"Unable to get query string - error 503\");\n\t\tfree(query);\n\t\treturn send_error(connection, 503);\n\t}\n\tdebug(LOG_DEBUG, \"Query string is [ %s ]\", query);\n\tsafe_asprintf(&originurl_raw, \"http:\n\tuh_urlencode(originurl, CUSTOM_ENC, originurl_raw, strlen(originurl_raw));\n\tif (strcmp(url, \"/login\") == 0) {\n\t\tclient->cpi_query = safe_strdup(originurl);\n\t\tdebug(LOG_DEBUG, \"RFC8910 request: %s\", client->cpi_query);\n\t} else {\n\t\tclient->cpi_query = \"none\";\n\t}\n\tdebug(LOG_DEBUG, \"originurl_raw: %s\", originurl_raw);\n\tdebug(LOG_DEBUG, \"originurl: %s\", originurl);\n\tquerystr=construct_querystring(connection, client, originurl, querystr);\n\tret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);\n\tfree(originurl_raw);\n\tfree(originurl);\n\tfree(query);\n\tfree(querystr);\n\treturn ret;\n}", "target": 1}
{"code": "void PDFiumEngine::FinishPaint(int progressive_index,\n                               pp::ImageData* image_data) {\n  DCHECK_GE(progressive_index, 0);\n  DCHECK_LT(static_cast<size_t>(progressive_index), progressive_paints_.size());\n  DCHECK(image_data);\n  int page_index = progressive_paints_[progressive_index].page_index;\n  pp::Rect dirty_in_screen = progressive_paints_[progressive_index].rect;\n  FPDF_BITMAP bitmap = progressive_paints_[progressive_index].bitmap;\n  int start_x, start_y, size_x, size_y;\n  GetPDFiumRect(\n      page_index, dirty_in_screen, &start_x, &start_y, &size_x, &size_y);\n  FPDF_FFLDraw(\n      form_, bitmap, pages_[page_index]->GetPage(), start_x, start_y, size_x,\n      size_y, current_rotation_, GetRenderingFlags());\n  FillPageSides(progressive_index);\n  PaintPageShadow(progressive_index, image_data);\n  DrawSelections(progressive_index, image_data);\n  FPDF_RenderPage_Close(pages_[page_index]->GetPage());\n  FPDFBitmap_Destroy(bitmap);\n  progressive_paints_.erase(progressive_paints_.begin() + progressive_index);\n  client_->DocumentPaintOccurred();\n}", "target": 0}
{"code": "static void jsiDumpInstr(Jsi_Interp *interp, jsi_Pstate *ps, Jsi_Value *_this,\n    jsi_TryList *trylist, jsi_OpCode *ip, Jsi_OpCodes *opcodes)\n{\n    int i;\n    char buf[200];\n    jsi_code_decode(interp, ip, ip - opcodes->codes, buf, sizeof(buf));\n    Jsi_Printf(interp, jsi_Stderr, \"%p: %-30.200s : THIS=%s, STACK=[\", ip, buf, jsi_evalprint(_this));\n    for (i = 0; i < interp->framePtr->Sp; ++i) {\n        Jsi_Printf(interp, jsi_Stderr, \"%s%s\", (i>0?\", \":\"\"), jsi_evalprint(_jsi_STACKIDX(i)));\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"]\");\n    if (ip->fname) {\n        const char *fn = ip->fname,  *cp = Jsi_Strrchr(fn, '/');\n        if (cp) fn = cp+1;\n        Jsi_Printf(interp, jsi_Stderr, \", %s:%d\", fn, ip->Line);\n    }\n    Jsi_Printf(interp, jsi_Stderr, \"\\n\");\n    jsi_TryList *tlt = trylist;\n    for (i = 0; tlt; tlt = tlt->next) i++;\n    if (ps->last_exception)\n        Jsi_Printf(interp, jsi_Stderr, \"TL: %d, excpt: %s\\n\", i, jsi_evalprint(ps->last_exception));\n}", "target": 1}
{"code": "void LibRaw::nikon_14bit_load_raw()\n{\n  const unsigned linelen =\n      (unsigned)(ceilf((float)(S.raw_width * 7 / 4) / 16.0)) *\n      16; \n  const unsigned pitch = S.raw_pitch ? S.raw_pitch / 2 : S.raw_width;\n  unsigned char *buf = (unsigned char *)malloc(linelen);\n  merror(buf, \"nikon_14bit_load_raw()\");\n  for (int row = 0; row < S.raw_height; row++)\n  {\n    unsigned bytesread =\n        libraw_internal_data.internal_data.input->read(buf, 1, linelen);\n    unsigned short *dest = &imgdata.rawdata.raw_image[pitch * row];\n    for (int sp = 0, dp = 0;\n         dp < pitch - 3 && sp < linelen - 6 && sp < bytesread - 6;\n         sp += 7, dp += 4)\n      unpack7bytesto4x16_nikon(buf + sp, dest + dp);\n  }\n  free(buf);\n}", "target": 0}
{"code": "bool WebContentsImpl::UpdateTitleForEntry(NavigationEntryImpl* entry,\n                                          const string16& title) {\n  string16 final_title;\n  bool explicit_set;\n  if (entry && entry->GetURL().SchemeIsFile() && title.empty()) {\n    final_title = UTF8ToUTF16(entry->GetURL().ExtractFileName());\n    explicit_set = false;  \n  } else {\n    TrimWhitespace(title, TRIM_ALL, &final_title);\n    explicit_set = true;\n  }\n  if (entry) {\n    if (final_title == entry->GetTitle())\n      return false;  \n    entry->SetTitle(final_title);\n  } else {\n    if (page_title_when_no_navigation_entry_ == final_title)\n      return false;  \n    page_title_when_no_navigation_entry_ = final_title;\n  }\n  view_->SetPageTitle(final_title);\n  std::pair<NavigationEntry*, bool> details =\n      std::make_pair(entry, explicit_set);\n  NotificationService::current()->Notify(\n      NOTIFICATION_WEB_CONTENTS_TITLE_UPDATED,\n      Source<WebContents>(this),\n      Details<std::pair<NavigationEntry*, bool> >(&details));\n  return true;\n}", "target": 0}
{"code": "int ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n    ss = source->state;\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n    ds->pending_buf = (uchf *) overlay;\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n    return Z_OK;\n#endif \n}", "target": 1}
{"code": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\treturn result;\n}", "target": 1}
{"code": "file_check_mem(struct magic_set *ms, unsigned int level)\n{\n\tsize_t len;\n\tif (level >= ms->c.len) {\n\t\tlen = (ms->c.len += 20) * sizeof(*ms->c.li);\n\t\tms->c.li = CAST(struct level_info *, (ms->c.li == NULL) ?\n\t\t    malloc(len) :\n\t\t    realloc(ms->c.li, len));\n\t\tif (ms->c.li == NULL) {\n\t\t\tfile_oomem(ms, len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tms->c.li[level].got_match = 0;\n#ifdef ENABLE_CONDITIONALS\n\tms->c.li[level].last_match = 0;\n\tms->c.li[level].last_cond = COND_NONE;\n#endif \n\treturn 0;\n}", "target": 1}
{"code": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\t\tgoto out;\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tif (un) {\n\t\tkfree(new);\n\t\tgoto success;\n\t}\n\tnew->semadj = (short *) &new[1];\n\tnew->ulp = ulp;\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}", "target": 1}
{"code": "void build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}", "target": 1}
{"code": "raw_copy_from_user(void *dst, const void __user *src, unsigned long size)\n{\n\tint ret = 0;\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic(dst, (__force void *)src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u8 *)dst, (u8 __user *)src,\n\t\t\t      ret, \"b\", \"b\", \"=q\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u16 *)dst, (u16 __user *)src,\n\t\t\t      ret, \"w\", \"w\", \"=r\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u32 *)dst, (u32 __user *)src,\n\t\t\t      ret, \"l\", \"k\", \"=r\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t      ret, \"q\", \"\", \"=r\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t       ret, \"q\", \"\", \"=r\", 10);\n\t\tif (likely(!ret))\n\t\t\t__get_user_asm_nozero(*(u16 *)(8 + (char *)dst),\n\t\t\t\t       (u16 __user *)(8 + (char __user *)src),\n\t\t\t\t       ret, \"w\", \"w\", \"=r\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin_nospec();\n\t\t__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,\n\t\t\t       ret, \"q\", \"\", \"=r\", 16);\n\t\tif (likely(!ret))\n\t\t\t__get_user_asm_nozero(*(u64 *)(8 + (char *)dst),\n\t\t\t\t       (u64 __user *)(8 + (char __user *)src),\n\t\t\t\t       ret, \"q\", \"\", \"=r\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic(dst, (__force void *)src, size);\n\t}\n}", "target": 1}
{"code": "njs_promise_perform_all_settled_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_array_t                  *array;\n    njs_value_t                  arguments[2], next;\n    njs_function_t               *on_fulfilled, *on_rejected;\n    njs_promise_capability_t     *capability;\n    njs_promise_all_context_t    *context;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    capability = pargs->capability;\n    array = args->data;\n    njs_set_undefined(&array->start[index]);\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    on_fulfilled = njs_promise_create_function(vm,\n                                            sizeof(njs_promise_all_context_t));\n    if (njs_slow_path(on_fulfilled == NULL)) {\n        return NJS_ERROR;\n    }\n    context = on_fulfilled->context;\n    context->already_called = 0;\n    context->index = (uint32_t) index;\n    context->values = pargs->args.data;\n    context->capability = capability;\n    context->remaining_elements = pargs->remaining;\n    on_rejected = njs_promise_create_function(vm, 0);\n    if (njs_slow_path(on_rejected == NULL)) {\n        return NJS_ERROR;\n    }\n    on_fulfilled->u.native = njs_promise_all_settled_element_functions;\n    on_rejected->u.native = njs_promise_all_settled_element_functions;\n    on_rejected->magic8 = 1; \n    on_fulfilled->args_count = 1;\n    on_rejected->args_count = 1;\n    on_rejected->context = context;\n    (*pargs->remaining)++;\n    njs_set_function(&arguments[0], on_fulfilled);\n    njs_set_function(&arguments[1], on_rejected);\n    ret = njs_promise_invoke_then(vm, &next, arguments, 2);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    return NJS_OK;\n}", "target": 0}
{"code": "avp_find(struct l2tp_avp *avp, const u_char *pkt, int pktlen,\n    uint16_t vendor_id, uint16_t attr_type, int fill_data)\n{\n\tint avpsz;\n\twhile (pktlen >= 6 &&\n\t    (avpsz = avp_enum(avp, pkt, pktlen, fill_data)) > 0) {\n\t\tif (avp->vendor_id != vendor_id || avp->attr_type != attr_type) {\n\t\t\tif (avpsz < 6)\n\t\t\t\treturn NULL;\n\t\t\tpkt += avpsz;\n\t\t\tpktlen -= avpsz;\n\t\t\tcontinue;\n\t\t}\n\t\treturn avp;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void LibRaw::blend_highlights()\n{\n  int clip = INT_MAX, row, col, c, i, j;\n  static const float trans[2][4][4] = {\n      {{1, 1, 1}, {1.7320508, -1.7320508, 0}, {-1, -1, 2}},\n      {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  static const float itrans[2][4][4] = {\n      {{1, 0.8660254, -0.5}, {1, -0.8660254, -0.5}, {1, 0, 1}},\n      {{1, 1, 1, 1}, {1, -1, 1, -1}, {1, 1, -1, -1}, {1, -1, -1, 1}}};\n  float cam[2][4], lab[2][4], sum[2], chratio;\n  if ((unsigned)(colors - 3) > 1)\n    return;\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 0, 2);\n  FORCC if (clip > (i = 65535 * pre_mul[c])) clip = i;\n  for (row = 0; row < height; row++)\n    for (col = 0; col < width; col++)\n    {\n      FORCC if (image[row * width + col][c] > clip) break;\n      if (c == colors)\n        continue;\n      FORCC\n      {\n        cam[0][c] = image[row * width + col][c];\n        cam[1][c] = MIN(cam[0][c], clip);\n      }\n      for (i = 0; i < 2; i++)\n      {\n        FORCC for (lab[i][c] = j = 0; j < colors; j++) lab[i][c] +=\n            trans[colors - 3][c][j] * cam[i][j];\n        for (sum[i] = 0, c = 1; c < colors; c++)\n          sum[i] += SQR(lab[i][c]);\n      }\n      chratio = sqrt(sum[1] / sum[0]);\n      for (c = 1; c < colors; c++)\n        lab[0][c] *= chratio;\n      FORCC for (cam[0][c] = j = 0; j < colors; j++) cam[0][c] +=\n          itrans[colors - 3][c][j] * lab[0][j];\n      FORCC image[row * width + col][c] = cam[0][c] / colors;\n    }\n  RUN_CALLBACK(LIBRAW_PROGRESS_HIGHLIGHTS, 1, 2);\n}", "target": 0}
{"code": "rb_reg_prepare_enc(VALUE re, VALUE str, int warn)\n{\n    rb_encoding *enc = 0;\n    int cr = str_coderange(str);\n    if (cr == ENC_CODERANGE_BROKEN) {\n        rb_raise(rb_eArgError,\n            \"invalid byte sequence in %s\",\n            rb_enc_name(rb_enc_get(str)));\n    }\n    rb_reg_check(re);\n    enc = rb_enc_get(str);\n    if (RREGEXP_PTR(re)->enc == enc) {\n    }\n    else if (cr == ENC_CODERANGE_7BIT &&\n\t    RREGEXP_PTR(re)->enc == rb_usascii_encoding()) {\n\tenc = RREGEXP_PTR(re)->enc;\n    }\n    else if (!rb_enc_asciicompat(enc)) {\n\treg_enc_error(re, str);\n    }\n    else if (rb_reg_fixed_encoding_p(re)) {\n        if ((!rb_enc_asciicompat(RREGEXP_PTR(re)->enc) ||\n\t     cr != ENC_CODERANGE_7BIT)) {\n\t    reg_enc_error(re, str);\n\t}\n\tenc = RREGEXP_PTR(re)->enc;\n    }\n    else if (warn && (RBASIC(re)->flags & REG_ENCODING_NONE) &&\n\tenc != rb_ascii8bit_encoding() &&\n\tcr != ENC_CODERANGE_7BIT) {\n\trb_warn(\"regexp match /.../n against to %s string\",\n\t\trb_enc_name(enc));\n    }\n    return enc;\n}", "target": 0}
{"code": "static int su3000_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x80, 0 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x02;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(300);\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 0;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x83;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0x51;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,\n\t\t\t\t\t&d->dev->i2c_adap);\n\tif (d->fe_adap[0].fe == NULL)\n\t\treturn -EIO;\n\tif (dvb_attach(ts2020_attach, d->fe_adap[0].fe,\n\t\t\t\t&dw2104_ts2020_config,\n\t\t\t\t&d->dev->i2c_adap)) {\n\t\tinfo(\"Attached DS3000/TS2020!\");\n\t\treturn 0;\n\t}\n\tinfo(\"Failed to attach DS3000/TS2020!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "pci_msix_table_init(struct pci_vdev *dev, int table_entries)\n{\n\tint i, table_size;\n\tassert(table_entries > 0);\n\tassert(table_entries <= MAX_MSIX_TABLE_ENTRIES);\n\ttable_size = table_entries * MSIX_TABLE_ENTRY_SIZE;\n\tdev->msix.table = calloc(1, table_size);\n\tassert(dev->msix.table != NULL);\n\tfor (i = 0; i < table_entries; i++)\n\t\tdev->msix.table[i].vector_control |= PCIM_MSIX_VCTRL_MASK;\n}", "target": 1}
{"code": "append_hex_escaped_character (GString *result,\n                              gunichar c)\n{\n  if (c <= 0xFF)\n    g_string_append_printf (result, \"\\\\x%02X\", c);\n  else if (c <= 0xFFFF)\n    g_string_append_printf (result, \"\\\\u%04X\", c);\n  else\n    g_string_append_printf (result, \"\\\\U%08X\", c);\n}", "target": 0}
{"code": "void PrepareTFPass::runOnOperation() {\n  MLIRContext *ctx = &getContext();\n  RewritePatternSet patterns(ctx);\n  RewritePatternSet phase_2_patterns(ctx);\n  auto func = getOperation();\n  if (failed(ValidateOp(func))) {\n    func.emitError() << \"tfl-prepare-tf pass failed.\";\n    signalPassFailure();\n    return;\n  }\n  if (failed(ConvertTf2XlaOps(func, ctx))) {\n    signalPassFailure();\n    return;\n  }\n  patterns.add<ConvertTFDilatedConvOp<TF::Conv2DOp>, FusedBatchNormV3Pat,\n               ConvertTFDilatedConvOp<TF::DepthwiseConv2dNativeOp>>(ctx);\n  patterns.add<RemoveIdentity>(ctx);\n  TFL::populateWithGenerated(patterns);\n  TF::ReshapeOp::getCanonicalizationPatterns(patterns, ctx);\n  (void)applyPatternsAndFoldGreedily(func, std::move(patterns));\n  if (failed(ConvertFakeQuantOps(func, ctx, use_fake_quant_num_bits_))) {\n    signalPassFailure();\n    return;\n  }\n  TFL::populateWithGenerated(phase_2_patterns);\n  if (unfold_batch_matmul_) {\n    TF::PopulateUnrollTfBatchMatMul(ctx, phase_2_patterns);\n  }\n  phase_2_patterns\n      .add<TF::ConvertTFEinsumOp, ConvertTFBroadcastTo, ConvertTFStridedSlice,\n           ConvertRfftToRfft2d, RemoveIdentity>(ctx);\n  phase_2_patterns.add<ConvertTFConv2D, ConvertTFDepthwiseConv2dNative>(\n      ctx, allow_bf16_and_f16_type_legalization_);\n  TF::ReshapeOp::getCanonicalizationPatterns(phase_2_patterns, ctx);\n  (void)applyPatternsAndFoldGreedily(func, std::move(phase_2_patterns));\n}", "target": 0}
{"code": "    bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                              bufferlist& authorizer, bufferlist& authorizer_reply,\n                              bool& isvalid, CryptoKey& session_key) override {\n      isvalid = true;\n      return true;\n    }", "target": 1}
{"code": "static bool packet_use_direct_xmit(const struct packet_sock *po)\n{\n\treturn po->xmit == packet_direct_xmit;\n}", "target": 0}
{"code": "void FrameLoader::finishedLoadingDocument(DocumentLoader* loader)\n{\n#if PLATFORM(WIN) || PLATFORM(CHROMIUM)\n    if (m_creatingInitialEmptyDocument)\n        return;\n#endif\n    const String& responseMIMEType = loader->responseMIMEType();\n#if PLATFORM(MAC)\n    m_client->finishedLoading(loader);\n    if (!ArchiveFactory::isArchiveMimeType(responseMIMEType))\n        return;\n#else\n    if (!ArchiveFactory::isArchiveMimeType(responseMIMEType)) {\n        m_client->finishedLoading(loader);\n        return;\n    }\n#endif\n    RefPtr<Archive> archive(ArchiveFactory::create(loader->mainResourceData().get(), responseMIMEType));\n    if (!archive)\n        return;\n    loader->addAllArchiveResources(archive.get());\n    ArchiveResource* mainResource = archive->mainResource();\n    loader->setParsedArchiveData(mainResource->data());\n    m_responseMIMEType = mainResource->mimeType();\n    closeURL();\n    didOpenURL(mainResource->url());\n    String userChosenEncoding = documentLoader()->overrideEncoding();\n    bool encodingIsUserChosen = !userChosenEncoding.isNull();\n    setEncoding(encodingIsUserChosen ? userChosenEncoding : mainResource->textEncoding(), encodingIsUserChosen);\n    ASSERT(m_frame->document());\n    addData(mainResource->data()->data(), mainResource->data()->size());\n}", "target": 0}
{"code": "static SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        sq_reservestack(_thread(o), nparams + 3);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}", "target": 0}
{"code": "static TEE_Result do_allocate_keypair(struct ecc_keypair *key,\n\t\t\t\t      uint32_t type __unused,\n\t\t\t\t      size_t size_bits)\n{\n\tECC_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->d = crypto_bignum_allocate(size_bits);\n\tif (!key->d)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tECC_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "fifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\tint ret;\n\tint sav_errno;\n\tif (fifo->name) {\n\t\tsav_errno = 0;\n\t\tif (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))\n\t\t\tfifo->created_fifo = true;\n\t\telse {\n\t\t\tsav_errno = errno;\n\t\t\tif (sav_errno != EEXIST)\n\t\t\t\tlog_message(LOG_INFO, \"Unable to create %snotify fifo %s\", type, fifo->name);\n\t\t}\n\t\tif (!sav_errno || sav_errno == EEXIST) {\n\t\t\tif (fifo->script)\n\t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\n\t\t\t\tif (fifo->created_fifo) {\n\t\t\t\t\tunlink(fifo->name);\n\t\t\t\t\tfifo->created_fifo = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (fifo->fd == -1) {\n\t\t\tFREE(fifo->name);\n\t\t\tfifo->name = NULL;\n\t\t}\n\t}\n}", "target": 1}
{"code": "cib_remote_auth(xmlNode *login)\n{\n    const char *user = NULL;\n    const char *pass = NULL;\n    const char *tmp = NULL;\n    crm_log_xml_info(login, \"Login: \");\n    if (login == NULL) {\n        return FALSE;\n    }\n    tmp = crm_element_name(login);\n    if (safe_str_neq(tmp, \"cib_command\")) {\n        crm_err(\"Wrong tag: %s\", tmp);\n        return FALSE;\n    }\n    tmp = crm_element_value(login, \"op\");\n    if (safe_str_neq(tmp, \"authenticate\")) {\n        crm_err(\"Wrong operation: %s\", tmp);\n        return FALSE;\n    }\n    user = crm_element_value(login, \"user\");\n    pass = crm_element_value(login, \"password\");\n    if (!user || !pass) {\n        crm_err(\"missing auth credentials\");\n        return FALSE;\n    }\n    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {\n        crm_err(\"User is not a member of the required group\");\n        return FALSE;\n    } else if (authenticate_user(user, pass) == FALSE) {\n        crm_err(\"PAM auth failed\");\n        return FALSE;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "static void bnx2x_pf_tx_q_prep(struct bnx2x *bp,\n\tstruct bnx2x_fastpath *fp, struct bnx2x_txq_setup_params *txq_init,\n\tu8 cos)\n{\n\ttxq_init->dscr_map = fp->txdata_ptr[cos]->tx_desc_mapping;\n\ttxq_init->sb_cq_index = HC_INDEX_ETH_FIRST_TX_CQ_CONS + cos;\n\ttxq_init->traffic_type = LLFC_TRAFFIC_TYPE_NW;\n\ttxq_init->fw_sb_id = fp->fw_sb_id;\n\ttxq_init->tss_leading_cl_id = bnx2x_fp(bp, 0, cl_id);\n\tif (IS_FCOE_FP(fp)) {\n\t\ttxq_init->sb_cq_index = HC_SP_INDEX_ETH_FCOE_TX_CQ_CONS;\n\t\ttxq_init->traffic_type = LLFC_TRAFFIC_TYPE_FCOE;\n\t}\n}", "target": 0}
{"code": "bool CModules::GetModInfo(CModInfo& ModInfo, const CString& sModule,\n                          CString& sRetMsg) {\n    if (!ValidateModuleName(sModule, sRetMsg)) {\n        return false;\n    }\n    CString sModPath, sTmp;\n    bool bSuccess;\n    bool bHandled = false;\n    GLOBALMODULECALL(OnGetModInfo(ModInfo, sModule, bSuccess, sRetMsg),\n                     &bHandled);\n    if (bHandled) return bSuccess;\n    if (!FindModPath(sModule, sModPath, sTmp)) {\n        sRetMsg = t_f(\"Unable to find module {1}.\")(sModule);\n        return false;\n    }\n    return GetModPathInfo(ModInfo, sModule, sModPath, sRetMsg);\n}", "target": 0}
{"code": "test_validate_path_args (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (invalid_path_args); idx++)\n    {\n      g_autoptr(FlatpakContext) context = flatpak_context_new ();\n      g_autoptr(GError) local_error = NULL;\n      const char *path = invalid_path_args[idx];\n      context_parse_args (context, &local_error, path, NULL);\n      g_assert_error (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n      g_assert (strstr (local_error->message, \"Non-graphical character\"));\n    }\n}", "target": 0}
{"code": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\tio_data->kiocb->private = NULL;\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}", "target": 1}
{"code": "static int get_task_ioprio(struct task_struct *p)\n{\n\tint ret;\n\tret = security_task_getioprio(p);\n\tif (ret)\n\t\tgoto out;\n\tret = IOPRIO_PRIO_VALUE(IOPRIO_CLASS_NONE, IOPRIO_NORM);\n\ttask_lock(p);\n\tif (p->io_context)\n\t\tret = p->io_context->ioprio;\n\ttask_unlock(p);\nout:\n\treturn ret;\n}", "target": 0}
{"code": "static Jsi_Value *jsi_treeFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_TreeEntry* hPtr = (Jsi_TreeEntry*)h;\n    void *key = Jsi_TreeKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}", "target": 1}
{"code": "rb_reg_error_desc(VALUE str, int options, const char *err)\n{\n    return rb_enc_reg_error_desc(RSTRING_PTR(str), RSTRING_LEN(str),\n\t\t\t\t rb_enc_get(str), options, err);\n}", "target": 0}
{"code": "read_and_discard_scanlines(j_decompress_ptr cinfo, JDIMENSION num_lines)\n{\n  JDIMENSION n;\n  my_master_ptr master = (my_master_ptr)cinfo->master;\n  void (*color_convert) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                         JDIMENSION input_row, JSAMPARRAY output_buf,\n                         int num_rows) = NULL;\n  void (*color_quantize) (j_decompress_ptr cinfo, JSAMPARRAY input_buf,\n                          JSAMPARRAY output_buf, int num_rows) = NULL;\n  void (*post_process_data) (j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                             JDIMENSION *in_row_group_ctr,\n                             JDIMENSION in_row_groups_avail,\n                             JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,\n                             JDIMENSION out_rows_avail) = NULL;\n  if (cinfo->cconvert && cinfo->cconvert->color_convert) {\n    color_convert = cinfo->cconvert->color_convert;\n    cinfo->cconvert->color_convert = noop_convert;\n  }\n  if (cinfo->cquantize && cinfo->cquantize->color_quantize) {\n    color_quantize = cinfo->cquantize->color_quantize;\n    cinfo->cquantize->color_quantize = noop_quantize;\n  }\n  if (master->using_merged_upsample && cinfo->post &&\n      cinfo->post->post_process_data) {\n    post_process_data = cinfo->post->post_process_data;\n    cinfo->post->post_process_data = noop_post_process;\n  }\n  for (n = 0; n < num_lines; n++)\n    jpeg_read_scanlines(cinfo, NULL, 1);\n  if (color_convert)\n    cinfo->cconvert->color_convert = color_convert;\n  if (color_quantize)\n    cinfo->cquantize->color_quantize = color_quantize;\n  if (post_process_data)\n    cinfo->post->post_process_data = post_process_data;\n}", "target": 0}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_NS_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_NS_BASE + DRAM1_NS_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len || dram_end < len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\tif ((dst < prot_start && dst > prot_start - len) || prot_start < len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t}\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\tif (addr_loaded_cnt >= CHECK_IMAGE_AREA_CNT) {\n\t\tERROR(\"BL2: max loadable non secure images reached\\n\");\n\t\tresult = IO_FAIL;\n\t}\n\taddr_loaded[addr_loaded_cnt].dest = dst;\n\taddr_loaded[addr_loaded_cnt].length = len;\n\tfor(int n=0; n<addr_loaded_cnt; n++) {\n\t\tif (((dst > addr_loaded[n].dest) &&\n\t\t     (dst <  addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    (((dst < addr_loaded[n].dest) &&\n\t\t      (dst + len)) > addr_loaded[n].dest)) {\n\t\t\tERROR(\"BL2: image is inside a previous image area.\\n\");\n\t\t\tresult = IO_FAIL;\n\t\t}\n\t}\n\taddr_loaded_cnt++;\n\treturn result;\n}", "target": 1}
{"code": "need_reloc_mappable(struct drm_i915_gem_object *obj)\n{\n\tstruct drm_i915_gem_exec_object2 *entry = obj->exec_entry;\n\treturn entry->relocation_count && !use_cpu_reloc(obj);\n}", "target": 0}
{"code": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n{\n    long i;\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n        long a = *(long *)(src1 + i);\n        long b = *(long *)(src2 + i);\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n    }\n    for (; i < w; i++)\n        dst[i] = src1[i] + src2[i];\n}", "target": 1}
{"code": "static inline void inc_slabs_node(struct kmem_cache *s, int node,\n\t\t\t\t\t\t\tint objects) {}", "target": 0}
{"code": "static void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}", "target": 0}
{"code": "DLLIMPORT int cfg_setint(cfg_t *cfg, const char *name, long int value)\n{\n\treturn cfg_setnint(cfg, name, value, 0);\n}", "target": 0}
{"code": "static int scantag(const char* in, char* buffer, int* lenp) {\n    int len;\n    for (len = 0; len < 128; len++) {\n        const char c = *in++;\n        switch (c) {\n        case '\\0':\n            return 0;\n        case '<':\n            return 0;\n        case '>':\n            buffer[len] = '\\0';\n            *lenp = len+1;\n            return 1;\n        default:\n            break;\n        }\n        buffer[len] = c;\n    }\n    return 0;\n}", "target": 0}
{"code": "double JOIN_TAB::scan_time()\n{\n  double res;\n  if (table->is_created())\n  {\n    if (table->is_filled_at_execution())\n    {\n      get_delayed_table_estimates(table, &records, &read_time,\n                                    &startup_cost);\n      found_records= records;\n      table->quick_condition_rows= records;\n    }\n    else\n    {\n      found_records= records= table->stat_records();\n      read_time= table->file->scan_time();\n    }\n    res= read_time;\n  }\n  else\n  {\n    found_records= records=table->stat_records();\n    read_time= found_records ? (double)found_records: 10.0;\n    res= read_time;\n  }\n  return res;\n}", "target": 0}
{"code": "get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof (unsigned char), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tif (!im) {\n\t\treturn NULL;\n\t}\n\tim->pixels = (unsigned char **) gdMalloc (sizeof (unsigned char *) * sy);\n\tif (!im->pixels) {\n\t\tgdFree(im);\n\t\treturn NULL;\n\t}\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; (i < sy); i++) {\n\t\tim->pixels[i] = (unsigned char *) gdCalloc (sx, sizeof (unsigned char));\n\t\tif (!im->pixels[i]) {\n\t\t\tfor (--i ; i >= 0; i--) {\n\t\t\t\tgdFree(im->pixels[i]);\n\t\t\t}\n\t\t\tgdFree(im->pixels);\n\t\t\tgdFree(im);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tfor (i = 0; (i < gdMaxColors); i++) {\n\t\tim->open[i] = 1;\n\t};\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->res_x = GD_RESOLUTION;\n\tim->res_y = GD_RESOLUTION;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "void ExtensionPrefs::InitPrefStore() {\n  ExtensionIdSet extension_ids;\n  GetExtensions(&extension_ids);\n  for (ExtensionIdSet::iterator ext_id = extension_ids.begin();\n       ext_id != extension_ids.end(); ++ext_id) {\n    ScopedExtensionPrefUpdate update(prefs_, *ext_id);\n    update.Get();\n  }\n  FixMissingPrefs(extension_ids);\n  for (ExtensionIdSet::iterator ext_id = extension_ids.begin();\n       ext_id != extension_ids.end(); ++ext_id) {\n    extension_pref_value_map_->RegisterExtension(\n        *ext_id,\n        GetInstallTime(*ext_id),\n        GetExtensionState(*ext_id) == Extension::ENABLED);\n    content_settings_store_->RegisterExtension(\n        *ext_id,\n        GetInstallTime(*ext_id),\n        GetExtensionState(*ext_id) == Extension::ENABLED);\n    const DictionaryValue* prefs = GetExtensionControlledPrefs(*ext_id, false);\n    for (DictionaryValue::key_iterator i = prefs->begin_keys();\n         i != prefs->end_keys(); ++i) {\n      Value* value;\n      if (!prefs->GetWithoutPathExpansion(*i, &value))\n        continue;\n      extension_pref_value_map_->SetExtensionPref(\n          *ext_id, *i, kExtensionPrefsScopeRegular, value->DeepCopy());\n    }\n    prefs = GetExtensionControlledPrefs(*ext_id, true);\n    for (DictionaryValue::key_iterator i = prefs->begin_keys();\n         i != prefs->end_keys(); ++i) {\n      Value* value;\n      if (!prefs->GetWithoutPathExpansion(*i, &value))\n        continue;\n      extension_pref_value_map_->SetExtensionPref(\n          *ext_id, *i, kExtensionPrefsScopeIncognitoPersistent,\n          value->DeepCopy());\n    }\n    const DictionaryValue* extension_prefs = GetExtensionPref(*ext_id);\n    DCHECK(extension_prefs);\n    ListValue* content_settings = NULL;\n    if (extension_prefs->GetList(kPrefContentSettings,\n                                 &content_settings)) {\n      content_settings_store_->SetExtensionContentSettingsFromList(\n          *ext_id, content_settings,\n          kExtensionPrefsScopeRegular);\n    }\n    if (extension_prefs->GetList(kPrefIncognitoContentSettings,\n                                 &content_settings)) {\n      content_settings_store_->SetExtensionContentSettingsFromList(\n          *ext_id, content_settings,\n          kExtensionPrefsScopeIncognitoPersistent);\n    }\n  }\n  extension_pref_value_map_->NotifyInitializationCompleted();\n}", "target": 0}
{"code": "Jsi_RC jsi_evalcode(jsi_Pstate *ps, Jsi_Func *func, Jsi_OpCodes *opcodes, \n         jsi_ScopeChain *scope, Jsi_Value *fargs,\n         Jsi_Value *_this,\n         Jsi_Value **vret)\n{\n    Jsi_Interp *interp = ps->interp;\n    if (interp->exited)\n        return JSI_ERROR;\n    Jsi_RC rc;\n    jsi_Frame frame = *interp->framePtr;\n    frame.parent = interp->framePtr;\n    interp->framePtr = &frame;\n    frame.parent->child = interp->framePtr = &frame;\n    frame.ps = ps;\n    frame.ingsc = scope;\n    frame.incsc = fargs;\n    frame.inthis = _this;\n    frame.opcodes = opcodes;\n    frame.fileName = ((func && func->script)?func->script:interp->curFile);\n    frame.funcName = interp->curFunction;\n    frame.dirName = interp->curDir;\n    if (frame.fileName && frame.fileName == frame.parent->fileName)\n        frame.logflag = frame.parent->logflag;\n    else\n        frame.logflag = 0;\n    frame.level = frame.parent->level+1;\n    frame.evalFuncPtr = func;\n    frame.arguments = NULL;\n    if (interp->curIp)\n        frame.parent->line = interp->curIp->Line;\n    frame.ip = interp->curIp;\n    interp->refCount++;\n    interp->level++;\n    Jsi_IncrRefCount(interp, fargs);\n    rc = jsi_evalcode_sub(ps, opcodes, scope, fargs, _this, *vret);\n    Jsi_DecrRefCount(interp, fargs);\n    if (interp->didReturn == 0 && !interp->exited) {\n        if ((interp->evalFlags&JSI_EVAL_RETURN)==0)\n            Jsi_ValueMakeUndef(interp, vret);\n    }\n    if (frame.arguments)\n        Jsi_DecrRefCount(interp, frame.arguments);\n    interp->didReturn = 0;\n    interp->refCount--;\n    interp->level--;\n    interp->framePtr = frame.parent;\n    interp->framePtr->child = NULL;\n    interp->curIp = frame.ip;\n    if (interp->exited)\n        rc = JSI_ERROR;\n    return rc;\n}", "target": 1}
{"code": "TfLiteStatus EvalHashtableSize(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  TfLiteTensor* output_tensor = GetOutput(context, node, kOutputTensor);\n  auto* output_data = GetTensorData<std::int64_t>(output_tensor);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  output_data[0] = lookup->Size();\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static FILE * pw_tmpfile(int lockfd)\n{\n\tFILE *fd;\n\tchar *tmpname = NULL;\n\tchar *dir = \"/etc\";\n\tif ((fd = xfmkstemp(&tmpname, dir)) == NULL) {\n\t\tulckpwdf();\n\t\terr(EXIT_FAILURE, _(\"can't open temporary file\"));\n\t}\n\tcopyfile(lockfd, fileno(fd));\n\ttmp_file = tmpname;\n\treturn fd;\n}", "target": 1}
{"code": "void read(Protocol_* iprot, const StructInfo& structInfo, void* object) {\n  DCHECK(object);\n  ProtocolReaderStructReadState<Protocol_> readState;\n  readState.readStructBegin(iprot);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    readState.fieldId = 0;\n    readState.readFieldBegin(iprot);\n    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);\n    if (fieldInfo) {\n      void* unionVal = getMember(*fieldInfo, object);\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](\n          unionVal);\n      read(iprot, *fieldInfo->typeInfo, readState, unionVal);\n      const_cast<FieldID&>(activeUnionMemberId(\n          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);\n    if (UNLIKELY(!readState.atStop())) {\n      TProtocolException::throwUnionMissingStop();\n    }\n    readState.readStructEnd(iprot);\n    return;\n  }\n  FieldID prevFieldId = 0;\n  std::int16_t index = 0;\n  for (;; ++index) {\n    auto* fieldInfo = index < structInfo.numFields\n        ? &structInfo.fieldInfos[index]\n        : &kStopMarker;\n    if (UNLIKELY(!readState.advanceToNextField(\n            iprot, prevFieldId, fieldInfo->id, fieldInfo->typeInfo->type))) {\n      for (;;) {\n        readState.afterAdvanceFailure(iprot);\n        if (readState.atStop()) {\n          readState.readStructEnd(iprot);\n          return;\n        }\n        fieldInfo = findFieldInfo(iprot, readState, structInfo);\n        if (fieldInfo) {\n          index = fieldInfo - structInfo.fieldInfos;\n          break;\n        }\n        skip(iprot, readState);\n      }\n    } else if (UNLIKELY(index >= structInfo.numFields)) {\n      readState.readStructEnd(iprot);\n      return;\n    }\n    prevFieldId = fieldInfo->id;\n    read(iprot, *fieldInfo->typeInfo, readState, getMember(*fieldInfo, object));\n    if (fieldInfo->issetOffset > 0) {\n      const_cast<bool&>(fieldIsSet(object, fieldInfo->issetOffset)) = true;\n    }\n  }\n}", "target": 1}
{"code": "void DelegatedFrameHost::ResetCompositorFrameSinkSupport() {\n  if (!support_)\n    return;\n  if (compositor_)\n    compositor_->RemoveFrameSink(frame_sink_id_);\n  support_.reset();\n}", "target": 0}
{"code": "void rfbClientCleanup(rfbClient* client) {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  int i;\n  for ( i = 0; i < 4; i++ ) {\n    if (client->zlibStreamActive[i] == TRUE ) {\n      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&\n\t  client->zlibStream[i].msg != NULL)\n\trfbClientLog(\"inflateEnd: %s\\n\", client->zlibStream[i].msg);\n    }\n  }\n  if ( client->decompStreamInited == TRUE ) {\n    if (inflateEnd (&client->decompStream) != Z_OK &&\n\tclient->decompStream.msg != NULL)\n      rfbClientLog(\"inflateEnd: %s\\n\", client->decompStream.msg );\n  }\n#endif\n  if (client->ultra_buffer)\n    free(client->ultra_buffer);\n  if (client->raw_buffer)\n    free(client->raw_buffer);\n  FreeTLS(client);\n  while (client->clientData) {\n    rfbClientData* next = client->clientData->next;\n    free(client->clientData);\n    client->clientData = next;\n  }\n  free(client->vncRec);\n  if (client->sock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->sock);\n  if (client->listenSock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->listenSock);\n  free(client->desktopName);\n  free(client->serverHost);\n  if (client->destHost)\n    free(client->destHost);\n  if (client->clientAuthSchemes)\n    free(client->clientAuthSchemes);\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslSecret)\n    free(client->saslSecret);\n#endif \n#ifdef WIN32\n  if(WSACleanup() != 0) {\n      errno=WSAGetLastError();\n      rfbClientErr(\"Could not terminate Windows Sockets: %s\\n\", strerror(errno));\n  }\n#endif\n  free(client);\n}", "target": 0}
{"code": "static void uc_invalidate_tb(struct uc_struct *uc, uint64_t start_addr, size_t len) \n{\n    tb_page_addr_t start, end;\n    start = get_page_addr_code(uc->cpu->env_ptr, start_addr) & (target_ulong)(-1);\n    end = (start + len) & (target_ulong)(-1);\n    if (start > end) {\n        return;\n    }\n    tb_invalidate_phys_range(uc, start, end);\n}", "target": 1}
{"code": "static const char *ifsection(cmd_parms *cmd, void *mconfig, const char *arg)\n{\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    int old_overrides = cmd->override;\n    char *old_path = cmd->path;\n    core_dir_config *conf;\n    const command_rec *thiscmd = cmd->cmd;\n    ap_conf_vector_t *new_if_conf = ap_create_per_dir_config(cmd->pool);\n    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);\n    const char *condition;\n    const char *expr_err;\n    if (err != NULL) {\n        return err;\n    }\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n    cmd->path = \"*If\";\n    if (!old_path) {\n        cmd->override = OR_ALL|ACCESS_CONF;\n    }\n    conf = ap_set_config_vectors(cmd->server, new_if_conf, cmd->path,\n                                 &core_module, cmd->pool);\n    if (cmd->cmd->cmd_data == COND_IF)\n        conf->condition_ifelse = AP_CONDITION_IF;\n    else if (cmd->cmd->cmd_data == COND_ELSEIF)\n        conf->condition_ifelse = AP_CONDITION_ELSEIF;\n    else if (cmd->cmd->cmd_data == COND_ELSE)\n        conf->condition_ifelse = AP_CONDITION_ELSE;\n    else\n        ap_assert(0);\n    if (conf->condition_ifelse == AP_CONDITION_ELSE) {\n        if (arg[0])\n            return \"<Else> does not take an argument\";\n    }\n    else {\n        if (!arg[0])\n            return missing_container_arg(cmd);\n        condition = ap_getword_conf(cmd->pool, &arg);\n        conf->condition = ap_expr_parse_cmd(cmd, condition, 0, &expr_err, NULL);\n        if (expr_err)\n            return apr_psprintf(cmd->pool, \"Cannot parse condition clause: %s\",\n                                expr_err);\n    }\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n    conf->d = cmd->path;\n    conf->d_is_fnmatch = 0;\n    conf->r = NULL;\n    errmsg = ap_add_if_conf(cmd->pool, (core_dir_config *)mconfig, new_if_conf);\n    if (errmsg != NULL)\n        return errmsg;\n    if (*arg != '\\0') {\n        return apr_pstrcat(cmd->pool, \"Multiple \", thiscmd->name,\n                           \"> arguments not supported.\", NULL);\n    }\n    cmd->path = old_path;\n    cmd->override = old_overrides;\n    return NULL;\n}", "target": 0}
{"code": "static void jsiSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv) {\n    SqlFunc *p = (SqlFunc*)sqlite3_user_data(context);\n    int i;\n    int rc;\n    Jsi_Interp *interp = p->interp;\n    Jsi_Value *vpargs, *itemsStatic[100], **items = itemsStatic, *ret;\n    if (argc>100)\n        items = (Jsi_Value**)Jsi_Calloc(argc, sizeof(Jsi_Value*));\n    for(i=0; i<argc; i++) {\n        items[i] = dbGetValueGet(interp, argv[i]);\n    }\n    vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, items, argc, 0));\n    Jsi_IncrRefCount(interp, vpargs);\n    ret = Jsi_ValueNew1(interp);\n    rc = Jsi_FunctionInvoke(interp, p->tocall, vpargs, &ret, NULL);\n    Jsi_DecrRefCount(interp, vpargs);\n    if (items != itemsStatic)\n        Jsi_Free(items);\n    bool b;\n    if( rc != JSI_OK) {\n        char buf[250];\n        snprintf(buf, sizeof(buf), \"error in function: %.200s\", p->zName);\n        sqlite3_result_error(context, buf, -1);\n    } else if (Jsi_ValueIsBoolean(interp, ret)) {\n        Jsi_GetBoolFromValue(interp, ret, &b);\n        sqlite3_result_int(context, b);\n    } else if (Jsi_ValueIsNumber(interp, ret)) {\n        Jsi_Number d;\n        Jsi_GetNumberFromValue(interp, ret, &d);\n        sqlite3_result_double(context, (double)d);\n    } else {\n        const char * data;\n        if (!(data = Jsi_ValueGetStringLen(interp, ret, &i))) {\n            data = Jsi_ValueToString(interp, ret, NULL);\n            i = Jsi_Strlen(data);\n        }\n        sqlite3_result_text(context, (char *)data, i, SQLITE_TRANSIENT );\n    }\n    Jsi_DecrRefCount(interp, ret);\n}", "target": 1}
{"code": "int re_yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n{\n    struct yyguts_t dummy_yyguts;\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    return yy_init_globals ( *ptr_yy_globals );", "target": 1}
{"code": "do_bid_note(struct magic_set *ms, unsigned char *nbuf, uint32_t type,\n    int swap __attribute__((__unused__)), uint32_t namesz, uint32_t descsz,\n    size_t noff, size_t doff, int *flags)\n{\n\tif (namesz == 4 && strcmp((char *)&nbuf[noff], \"GNU\") == 0 &&\n\t    type == NT_GNU_BUILD_ID && (descsz >= 4 || descsz <= 20)) {\n\t\tuint8_t desc[20];\n\t\tconst char *btype;\n\t\tuint32_t i;\n\t\t*flags |= FLAGS_DID_BUILD_ID;\n\t\tswitch (descsz) {\n\t\tcase 8:\n\t\t    btype = \"xxHash\";\n\t\t    break;\n\t\tcase 16:\n\t\t    btype = \"md5/uuid\";\n\t\t    break;\n\t\tcase 20:\n\t\t    btype = \"sha1\";\n\t\t    break;\n\t\tdefault:\n\t\t    btype = \"unknown\";\n\t\t    break;\n\t\t}\n\t\tif (file_printf(ms, \", BuildID[%s]=\", btype) == -1)\n\t\t\treturn 1;\n\t\t(void)memcpy(desc, &nbuf[doff], descsz);\n\t\tfor (i = 0; i < descsz; i++)\n\t\t    if (file_printf(ms, \"%02x\", desc[i]) == -1)\n\t\t\treturn 1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}", "target": 1}
{"code": "static int snd_ctl_elem_user_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tint change;\n\tstruct user_element *ue = kcontrol->private_data;\n\tchange = memcmp(&ucontrol->value, ue->elem_data, ue->elem_data_size) != 0;\n\tif (change)\n\t\tmemcpy(ue->elem_data, &ucontrol->value, ue->elem_data_size);\n\treturn change;\n}", "target": 1}
{"code": "static void dhcps_initialize_message(struct dhcp_msg *dhcp_message_repository)\n{\n        dhcp_message_repository->op = DHCP_MESSAGE_OP_REPLY;\n        dhcp_message_repository->htype = DHCP_MESSAGE_HTYPE;\n        dhcp_message_repository->hlen = DHCP_MESSAGE_HLEN; \n        dhcp_message_repository->hops = 0;\t\t\n        memcpy((char *)dhcp_recorded_xid, (char *) dhcp_message_repository->xid,\n\t\t\t\t\tsizeof(dhcp_message_repository->xid));\n        dhcp_message_repository->secs = 0;\n        dhcp_message_repository->flags = htons(BOOTP_BROADCAST);         \n\tmemcpy((char *)dhcp_message_repository->yiaddr,\n\t\t\t(char *)&dhcps_allocated_client_address,\n\t\t\t\tsizeof(dhcp_message_repository->yiaddr));\n\tmemset((char *)dhcp_message_repository->ciaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->ciaddr));\n        memset((char *)dhcp_message_repository->siaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->siaddr));\n        memset((char *)dhcp_message_repository->giaddr, 0,\n\t\t\t\t\tsizeof(dhcp_message_repository->giaddr));\n        memset((char *)dhcp_message_repository->sname,  0,\n\t\t\t\t\tsizeof(dhcp_message_repository->sname));\n        memset((char *)dhcp_message_repository->file,   0,\n\t\t\t\t\tsizeof(dhcp_message_repository->file));\n        memset((char *)dhcp_message_repository->options, 0,\n\t\t\t\t\tdhcp_message_total_options_lenth);\n        memcpy((char *)dhcp_message_repository->options, (char *)dhcp_magic_cookie,\n\t\t\t\t\tsizeof(dhcp_magic_cookie));\n}", "target": 1}
{"code": "int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {\n    quicklistNode *orig_tail = quicklist->tail;\n    assert(sz < UINT32_MAX); \n    if (likely(\n            _quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {\n        quicklist->tail->zl =\n            ziplistPush(quicklist->tail->zl, value, sz, ZIPLIST_TAIL);\n        quicklistNodeUpdateSz(quicklist->tail);\n    } else {\n        quicklistNode *node = quicklistCreateNode();\n        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);\n        quicklistNodeUpdateSz(node);\n        _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);\n    }\n    quicklist->count++;\n    quicklist->tail->count++;\n    return (orig_tail != quicklist->tail);\n}", "target": 0}
{"code": "str_to_archive_type (const char *str)\n{\n\tg_return_val_if_fail (str != NULL, EV_ARCHIVE_TYPE_NONE);\n\tif (g_strcmp0 (str, \"rar\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_RAR;\n\tif (g_strcmp0 (str, \"zip\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_ZIP;\n\tif (g_strcmp0 (str, \"7z\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_7Z;\n\tif (g_strcmp0 (str, \"tar\") == 0)\n\t\treturn EV_ARCHIVE_TYPE_TAR;\n\tg_warning (\"Archive type '%s' not supported\", str);\n\treturn EV_ARCHIVE_TYPE_NONE;\n}", "target": 0}
{"code": "bool HTMLMediaElement::ShouldShowControls(\n    const RecordMetricsBehavior record_metrics) const {\n  Settings* settings = GetDocument().GetSettings();\n  if (settings && !settings->GetMediaControlsEnabled()) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowDisabledSettings);\n    return false;\n  }\n  if (FastHasAttribute(kControlsAttr)) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowAttribute);\n    return true;\n  }\n  if (IsFullscreen()) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowFullscreen);\n    return true;\n  }\n  LocalFrame* frame = GetDocument().GetFrame();\n  if (frame && !GetDocument().CanExecuteScripts(kNotAboutToExecuteScript)) {\n    if (record_metrics == RecordMetricsBehavior::kDoRecord)\n      ShowControlsHistogram().Count(kMediaControlsShowNoScript);\n    return true;\n  }\n  if (record_metrics == RecordMetricsBehavior::kDoRecord)\n    ShowControlsHistogram().Count(kMediaControlsShowNotShown);\n  return false;\n}", "target": 0}
{"code": "krb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    krb5_clear_error_message(context);\n    if (pol_dn == NULL)\n        return EINVAL;\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n    ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n    }\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}", "target": 1}
{"code": "void luaD_call (lua_State *L, StkId func, int nresults) {\n  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  \n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  \n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  \n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  \n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  \n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  \n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  \n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  \n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  \n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  \n      break;\n    }\n    default: {  \n      checkstackp(L, 1, func);  \n      luaD_tryfuncTM(L, func);  \n      goto retry;  \n    }\n  }\n}", "target": 1}
{"code": "static inline u32 nla_get_u32(struct nlattr *nla)\n{\n\treturn *(u32 *) nla_data(nla);\n}", "target": 0}
{"code": "find_script_callback(char_u *fname, void *cookie)\n{\n    int sid;\n    int error = OK;\n    int *ret_sid = cookie;\n    sid = find_script_by_name(fname);\n    if (sid < 0)\n    {\n\tsid = get_new_scriptitem(&error);\n\tif (error == OK)\n\t{\n\t    scriptitem_T *si = SCRIPT_ITEM(sid);\n\t    si->sn_name = vim_strsave(fname);\n\t    si->sn_state = SN_STATE_NOT_LOADED;\n\t}\n    }\n    *ret_sid = sid;\n}", "target": 0}
{"code": "hostlist_matches_int(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = host_matches(parse_tree, pw, lhost, shost, m);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "render_pixbuf_size_prepared_cb (GdkPixbufLoader *loader,\n\t\t\t\tgint             width,\n\t\t\t\tgint             height,\n\t\t\t\tgpointer         data)\n{\n\tdouble *scale = data;\n\tint w = (width  * (*scale) + 0.5);\n\tint h = (height * (*scale) + 0.5);\n\tgdk_pixbuf_loader_set_size (loader, w, h);\n}", "target": 1}
{"code": "WebMediaPlayer::Preload HTMLMediaElement::EffectivePreloadType() const {\n  if (Autoplay() && !autoplay_policy_->IsGestureNeededForPlayback())\n    return WebMediaPlayer::kPreloadAuto;\n  WebMediaPlayer::Preload preload = PreloadType();\n  if (ignore_preload_none_ && preload == WebMediaPlayer::kPreloadNone)\n    return WebMediaPlayer::kPreloadMetaData;\n  return preload;\n}", "target": 0}
{"code": "void log_flush(LOG_MODE new_mode) {\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_MODE]);\n    if(log_mode!=LOG_MODE_CONFIGURED || new_mode!=LOG_MODE_ERROR)\n        log_mode=new_mode;\n    if(new_mode!=LOG_MODE_BUFFER) {\n        CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_LOG_BUFFER]);\n        while(head) {\n            struct LIST *tmp=head;\n            head=head->next;\n            log_raw(tmp->opt, tmp->level, tmp->stamp, tmp->id, tmp->text);\n            str_free(tmp);\n        }\n        head=tail=NULL;\n        CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_BUFFER]);\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_MODE]);\n}", "target": 1}
{"code": "CallResult<HermesValue> Runtime::interpretFunctionImpl(\n    CodeBlock *newCodeBlock) {\n  newCodeBlock->lazyCompile(*this);\n#if defined(HERMES_MEMORY_INSTRUMENTATION) || !defined(NDEBUG)\n  const inst::Inst *ip = getCurrentIP();\n  (void)ip;\n#endif\n#ifdef HERMES_MEMORY_INSTRUMENTATION\n  if (ip) {\n    const CodeBlock *codeBlock;\n    std::tie(codeBlock, ip) = getCurrentInterpreterLocation(ip);\n    if (codeBlock) {\n      pushCallStack(codeBlock, ip);\n    } else {\n      pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n    }\n  } else {\n    pushCallStack(newCodeBlock, (const Inst *)newCodeBlock->begin());\n  }\n#endif\n  InterpreterState state{newCodeBlock, 0};\n  if (HERMESVM_CRASH_TRACE &&\n      (getVMExperimentFlags() & experiments::CrashTrace)) {\n    return Interpreter::interpretFunction<false, true>(*this, state);\n  } else {\n    return Interpreter::interpretFunction<false, false>(*this, state);\n  }\n}", "target": 1}
{"code": "ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}", "target": 1}
{"code": "static size_t hash_str(const void *ptr)\n{\n    const char *str = (const char *)ptr;\n    size_t hash = 5381;\n    size_t c;\n    while((c = (size_t)*str))\n    {\n        hash = ((hash << 5) + hash) + c;\n        str++;\n    }\n    return hash;\n}", "target": 1}
{"code": "static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)\n{\n\tstruct llc_sock *llc = llc_sk(skb->sk);\n\tif (llc->cmsg_flags & LLC_CMSG_PKTINFO) {\n\t\tstruct llc_pktinfo info;\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinfo.lpi_ifindex = llc_sk(skb->sk)->dev->ifindex;\n\t\tllc_pdu_decode_dsap(skb, &info.lpi_sap);\n\t\tllc_pdu_decode_da(skb, info.lpi_mac);\n\t\tput_cmsg(msg, SOL_LLC, LLC_OPT_PKTINFO, sizeof(info), &info);\n\t}\n}", "target": 0}
{"code": "static int check_passwd(unsigned char *passwd, size_t length)\n{\n\tstruct digest *d = NULL;\n\tunsigned char *passwd1_sum;\n\tunsigned char *passwd2_sum;\n\tint ret = 0;\n\tint hash_len;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\thash_len = PBKDF2_LENGTH;\n\t} else {\n\t\td = digest_alloc(PASSWD_SUM);\n\t\tif (!d) {\n\t\t\tpr_err(\"No such digest: %s\\n\",\n\t\t\t       PASSWD_SUM ? PASSWD_SUM : \"NULL\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\thash_len = digest_length(d);\n\t}\n\tpasswd1_sum = calloc(hash_len * 2, sizeof(unsigned char));\n\tif (!passwd1_sum)\n\t\treturn -ENOMEM;\n\tpasswd2_sum = passwd1_sum + hash_len;\n\tif (is_passwd_env_enable())\n\t\tret = read_env_passwd(passwd2_sum, hash_len);\n\telse if (is_passwd_default_enable())\n\t\tret = read_default_passwd(passwd2_sum, hash_len);\n\telse\n\t\tret = -EINVAL;\n\tif (ret < 0)\n\t\tgoto err;\n\tif (IS_ENABLED(CONFIG_PASSWD_CRYPTO_PBKDF2)) {\n\t\tchar *key = passwd2_sum + PBKDF2_SALT_LEN;\n\t\tchar *salt = passwd2_sum;\n\t\tint keylen = PBKDF2_LENGTH - PBKDF2_SALT_LEN;\n\t\tret = pkcs5_pbkdf2_hmac_sha1(passwd, length, salt,\n\t\t\tPBKDF2_SALT_LEN, PBKDF2_COUNT, keylen, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, key, keylen) == 0)\n\t\t\tret = 1;\n\t} else {\n\t\tret = digest_digest(d, passwd, length, passwd1_sum);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strncmp(passwd1_sum, passwd2_sum, hash_len) == 0)\n\t\t\tret = 1;\n\t}\nerr:\n\tfree(passwd1_sum);\n\tdigest_free(d);\n\treturn ret;\n}", "target": 1}
{"code": "int main(int argc, char *argv[]) {\n  struct mschm_decompressor *chmd;\n  struct mschmd_header *chm;\n  struct mschmd_file *file, **f;\n  unsigned int numf, i;\n  setbuf(stdout, NULL);\n  setbuf(stderr, NULL);\n  user_umask = umask(0); umask(user_umask);\n  MSPACK_SYS_SELFTEST(i);\n  if (i) return 0;\n  if ((chmd = mspack_create_chm_decompressor(NULL))) {\n    for (argv++; *argv; argv++) {\n      printf(\"%s\\n\", *argv);\n      if ((chm = chmd->open(chmd, *argv))) {\n\tfor (numf=0, file=chm->files; file; file = file->next) numf++;\n\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));\n\t    }\n\t    free(outname);\n\t  }\n\t  free(f);\n\t}\n\tchmd->close(chmd, chm);\n      }\n      else {\n\tprintf(\"%s: can't open -- %s\\n\", *argv, ERROR(chmd));\n      }\n    }\n    mspack_destroy_chm_decompressor(chmd);\n  }\n  return 0;\n}", "target": 1}
{"code": "static char *utf2char(utf16_t *str, char *buffer)\n{\n  char *b = buffer;\n  while (*str != 0x00) {\n    char *chr = (char *)str;\n    *b++ = *chr;\n    str++;\n  }\n  *b = 0;\n  return buffer;\n}", "target": 1}
{"code": "static int expand_mapping_rule_ex(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  bool sanitize,\n                                  char **_filter, char ***_domains)\n{\n    int ret;\n    struct match_map_rule *r;\n    struct priority_list *p;\n    struct sss_cert_content *cert_content = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    size_t c;\n    if (_filter == NULL || _domains == NULL) {\n        return EINVAL;\n    }\n    ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content);\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to get certificate content [%d].\", ret);\n        return ret;\n    }\n    if (ctx->prio_list == NULL) {\n        if (ctx->default_mapping_rule == NULL) {\n            CM_DEBUG(ctx, \"No matching or mapping rules available.\");\n            return EINVAL;\n        }\n        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, sanitize,\n                         &filter);\n        goto done;\n    }\n    for (p = ctx->prio_list; p != NULL; p = p->next) {\n        for (r = p->rule_list; r != NULL; r = r->next) {\n            ret = do_match(ctx, r->parsed_match_rule, cert_content);\n            if (ret == 0) {\n                ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n                                 sanitize, &filter);\n                if (ret != 0) {\n                    CM_DEBUG(ctx, \"Failed to get filter\");\n                    goto done;\n                }\n                if (r->domains != NULL) {\n                    for (c = 0; r->domains[c] != NULL; c++);\n                    domains = talloc_zero_array(ctx, char *, c + 1);\n                    if (domains == NULL) {\n                        ret = ENOMEM;\n                        goto done;\n                    }\n                    for (c = 0; r->domains[c] != NULL; c++) {\n                        domains[c] = talloc_strdup(domains, r->domains[c]);\n                        if (domains[c] == NULL) {\n                            ret = ENOMEM;\n                            goto done;\n                        }\n                    }\n                }\n                ret = 0;\n                goto done;\n            }\n        }\n    }\n    ret = ENOENT;\ndone:\n    talloc_free(cert_content);\n    if (ret == 0) {\n        *_filter = filter;\n        *_domains = domains;\n    } else {\n        talloc_free(filter);\n        talloc_free(domains);\n    }\n    return ret;\n}", "target": 0}
{"code": "void Rectangle(double x,double y,double w,double h) {\n    outpos += sprintf(outpos,\"\\n %12.3f %12.3f %12.3f %12.3f re\",x,y,w,h);\n}", "target": 1}
{"code": "nfs4_proc_create(struct inode *dir, struct dentry *dentry, struct iattr *sattr,\n                 int flags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct nfs4_state *state;\n\tstruct rpc_cred *cred;\n\tint status = 0;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred)) {\n\t\tstatus = PTR_ERR(cred);\n\t\tgoto out;\n\t}\n\tstate = nfs4_do_open(dir, &path, flags, sattr, cred);\n\td_drop(dentry);\n\tif (IS_ERR(state)) {\n\t\tstatus = PTR_ERR(state);\n\t\tgoto out_putcred;\n\t}\n\td_add(dentry, igrab(state->inode));\n\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\tif (flags & O_EXCL) {\n\t\tstruct nfs_fattr fattr;\n\t\tstatus = nfs4_do_setattr(state->inode, cred, &fattr, sattr, state);\n\t\tif (status == 0)\n\t\t\tnfs_setattr_update_inode(state->inode, sattr);\n\t\tnfs_post_op_update_inode(state->inode, &fattr);\n\t}\n\tif (status == 0 && (nd->flags & LOOKUP_OPEN) != 0)\n\t\tstatus = nfs4_intent_set_file(nd, &path, state);\n\telse\n\t\tnfs4_close_sync(&path, state, flags);\nout_putcred:\n\tput_rpccred(cred);\nout:\n\treturn status;\n}", "target": 1}
{"code": "ImagingConvertInPlace(Imaging imIn, const char *mode) {\n    ImagingSectionCookie cookie;\n    ImagingShuffler convert;\n    int y;\n    if (strcmp(imIn->mode, \"L\") == 0 && strcmp(mode, \"1\") == 0) {\n        convert = l2bit;\n    } else if (strcmp(imIn->mode, \"1\") == 0 && strcmp(mode, \"L\") == 0) {\n        convert = bit2l;\n    } else {\n        return ImagingError_ModeError();\n    }\n    ImagingSectionEnter(&cookie);\n    for (y = 0; y < imIn->ysize; y++) {\n        (*convert)((UINT8 *)imIn->image[y], (UINT8 *)imIn->image[y], imIn->xsize);\n    }\n    ImagingSectionLeave(&cookie);\n    return imIn;\n}", "target": 0}
{"code": "dump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[21];\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\tif (!level)\n\t\tfclose(fp);\n}", "target": 1}
{"code": "void LinearAlgebraOp<InputScalar, OutputScalar>::AnalyzeInputs(\n    OpKernelContext* context, TensorInputs* inputs,\n    TensorShapes* input_matrix_shapes, TensorShape* batch_shape) {\n  int input_rank = -1;\n  for (int i = 0; i < NumMatrixInputs(context); ++i) {\n    const Tensor& in = context->input(i);\n    if (i == 0) {\n      input_rank = in.dims();\n      OP_REQUIRES(\n          context, input_rank >= 2,\n          errors::InvalidArgument(\"Input tensor \", i,\n                                  \" must have rank >= 2, got \", input_rank));\n      for (int dim = 0; dim < input_rank - 2; ++dim) {\n        batch_shape->AddDim(in.dim_size(dim));\n      }\n    } else {\n      OP_REQUIRES(context, input_rank == in.dims(),\n                  errors::InvalidArgument(\n                      \"All input tensors must have the same rank.\"));\n      for (int dim = 0; dim < input_rank - 2; ++dim) {\n        OP_REQUIRES(\n            context, in.dim_size(dim) == batch_shape->dim_size(dim),\n            errors::InvalidArgument(\n                \"All input tensors must have the same outer dimensions.\"));\n      }\n    }\n    const int row_dimension = input_rank - 2;\n    const int col_dimension = input_rank - 1;\n    const int64_t num_rows = in.dim_size(row_dimension);\n    const int64_t num_cols = in.dim_size(col_dimension);\n    input_matrix_shapes->emplace_back(\n        std::initializer_list<int64_t>({num_rows, num_cols}));\n    inputs->emplace_back(&in);\n    OP_REQUIRES(\n        context, in.dtype() == DataTypeToEnum<InputScalar>::v(),\n        errors::InvalidArgument(\"Invalid input dtype \", in.dtype(), \" vs \",\n                                DataTypeToEnum<InputScalar>::v()));\n  }\n  ValidateInputMatrixShapes(context, *input_matrix_shapes);\n}", "target": 0}
{"code": "static void list_slab_objects(struct kmem_cache *s, struct page *page,\n\t\t\t\t\t\t\tconst char *text)\n{\n#ifdef CONFIG_SLUB_DEBUG\n\tvoid *addr = page_address(page);\n\tvoid *p;\n\tunsigned long *map;\n\tslab_err(s, page, text, s->name);\n\tslab_lock(page);\n\tmap = get_map(s, page);\n\tfor_each_object(p, s, addr, page->objects) {\n\t\tif (!test_bit(slab_index(p, s, addr), map)) {\n\t\t\tpr_err(\"INFO: Object 0x%p @offset=%tu\\n\", p, p - addr);\n\t\t\tprint_tracking(s, p);\n\t\t}\n\t}\n\tput_map(map);\n\tslab_unlock(page);\n#endif\n}", "target": 0}
{"code": "        friend std::ostream& operator<<(std::ostream& os, const query_string& qs)\n        {\n            os << \"[ \";\n            for (size_t i = 0; i < qs.key_value_pairs_.size(); ++i)\n            {\n                if (i)\n                    os << \", \";\n                os << qs.key_value_pairs_[i];\n            }\n            os << \" ]\";\n            return os;\n        }", "target": 0}
{"code": "bool VerifySparsity(const RuntimeShape& weights_shape,\n                    const RuntimeShape& input_shape,\n                    const RuntimeShape& output_shape,\n                    const TfLiteSparsity* sparsity) {\n  const int weights_dims_count = weights_shape.DimensionsCount();\n  const int output_dims_count = output_shape.DimensionsCount();\n  const int w0_size = sparsity->dim_metadata[0].dense_size;\n  const int accum_depth = weights_shape.Dims(weights_dims_count - 1);\n  const int output_elements = output_shape.FlatSize();\n  const int input_elements = input_shape.FlatSize();\n  const int batches = FlatSizeSkipDim(output_shape, output_dims_count - 1);\n  const int output_depth = MatchingDim(weights_shape, weights_dims_count - 2,\n                                       output_shape, output_dims_count - 1);\n  const int max_batch_index = batches - 1;\n  const int max_output = max_batch_index * output_depth + w0_size;\n  const int max_batch_depth = accum_depth * max_batch_index;\n  if (output_elements < max_output) return false;\n  for (int i = 0; i < sparsity->dim_metadata[1].array_indices->size; ++i) {\n    if (input_elements <=\n        max_batch_depth + sparsity->dim_metadata[1].array_indices->data[i])\n      return false;\n  }\n  return true;\n}", "target": 0}
{"code": "int X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)\n{\n    EVP_PKEY *ktmp = NULL, *ktmp2;\n    int i, j;\n    if ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey))\n        return 1;\n    for (i = 0; i < sk_X509_num(chain); i++) {\n        ktmp = X509_get_pubkey(sk_X509_value(chain, i));\n        if (ktmp == NULL) {\n            X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,\n                    X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);\n            return 0;\n        }\n        if (!EVP_PKEY_missing_parameters(ktmp))\n            break;\n        EVP_PKEY_free(ktmp);\n        ktmp = NULL;\n    }\n    if (ktmp == NULL) {\n        X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,\n                X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);\n        return 0;\n    }\n    for (j = i - 1; j >= 0; j--) {\n        ktmp2 = X509_get_pubkey(sk_X509_value(chain, j));\n        EVP_PKEY_copy_parameters(ktmp2, ktmp);\n        EVP_PKEY_free(ktmp2);\n    }\n    if (pkey != NULL)\n        EVP_PKEY_copy_parameters(pkey, ktmp);\n    EVP_PKEY_free(ktmp);\n    return 1;\n}", "target": 0}
{"code": "getSystemTempDir() {\n\tconst char *temp_dir = getenv(\"PASSENGER_TEMP_DIR\");\n\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\ttemp_dir = getenv(\"PASSENGER_TMPDIR\");\n\t\tif (temp_dir == NULL || *temp_dir == '\\0') {\n\t\t\ttemp_dir = \"/tmp\";\n\t\t}\n\t}\n\treturn temp_dir;\n}", "target": 0}
{"code": "static int dns_resolver_cmp(const struct key *key,\n\t\t\t    const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\tkenter(\"%s,%s\", src, dsp);\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "    static size_t size() {\n      return ConstSingleton<StaticLookupTable>::get().size_;\n    }", "target": 0}
{"code": "int nfc_dep_link_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tif (!dev->ops->dep_link_down)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == false) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_down(dev);\n\tif (!rc) {\n\t\tdev->dep_link_up = false;\n\t\tdev->active_target = NULL;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t\tnfc_llcp_mac_is_down(dev);\n\t\tnfc_genl_dep_link_down_event(dev);\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "GF_Err svhd_box_size(GF_Box *s)\n{\n\tGF_SphericalVideoInfoBox *ptr = (GF_SphericalVideoInfoBox *)s;\n\tif (ptr->string)\n\t\ts->size += (u32) strlen(ptr->string);\n\ts->size += 1;\n\treturn GF_OK;\n}", "target": 0}
{"code": "void PixelBuffer::setSize(int width, int height)\n{\n  if ((width < 0) || (width > maxPixelBufferWidth))\n    throw rfb::Exception(\"Invalid PixelBuffer width of %d pixels requested\", width);\n  if ((height < 0) || (height > maxPixelBufferHeight))\n    throw rfb::Exception(\"Invalid PixelBuffer height of %d pixels requested\", height);\n  width_ = width;\n  height_ = height;\n}", "target": 0}
{"code": "static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {\n\tut8 op_byte = data[0];\n\tut64 offset = addr - java_get_method_start ();\n\tut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1;\n\tif (op_byte == 0xaa) {\n\t\tif (pos + 8 > len) {\n\t\t\treturn op->size;\n\t\t}\n\t\tint min_val = (ut32)(UINT (data, pos + 4)),\n\t\t\tmax_val = (ut32)(UINT (data, pos + 8));\n\t\tut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0;\n\t\top->switch_op = r_anal_switch_op_new (addr, min_val, default_loc);\n\t\tRAnalCaseOp *caseop = NULL;\n\t\tpos += 12;\n\t\tif (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) {\n\t\t\tfor (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) {\n\t\t\t\tif (pos + 4 >= len) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos));\n\t\t\t\tcaseop = r_anal_switch_op_add_case (op->switch_op,\n\t\t\t\t\taddr + pos, cur_case + min_val, addr + offset);\n\t\t\t\tif (caseop) {\n\t\t\t\t\tcaseop->bb_ref_to = addr+offset;\n\t\t\t\t\tcaseop->bb_ref_from = addr; \n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Invalid switch boundaries at 0x%\"PFMT64x\"\\n\", addr);\n\t\t}\n\t}\n\top->size = pos;\n\treturn op->size;\n}", "target": 1}
{"code": "merged_1v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,\n                         output_buf + *out_row_ctr);\n  (*out_row_ctr)++;\n  (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "read_pbm_integer(j_compress_ptr cinfo, FILE *infile, unsigned int maxval)\n{\n  register int ch;\n  register unsigned int val;\n  do {\n    ch = pbm_getc(infile);\n    if (ch == EOF)\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n  } while (ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r');\n  if (ch < '0' || ch > '9')\n    ERREXIT(cinfo, JERR_PPM_NONNUMERIC);\n  val = ch - '0';\n  while ((ch = pbm_getc(infile)) >= '0' && ch <= '9') {\n    val *= 10;\n    val += ch - '0';\n  }\n  if (val > maxval)\n    ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n  return val;\n}", "target": 1}
{"code": "int numa_zonelist_order_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *length,\n\t\tloff_t *ppos)\n{\n\tchar *str;\n\tint ret;\n\tif (!write)\n\t\treturn proc_dostring(table, write, buffer, length, ppos);\n\tstr = memdup_user_nul(buffer, 16);\n\tif (IS_ERR(str))\n\t\treturn PTR_ERR(str);\n\tret = __parse_numa_zonelist_order(str);\n\tkfree(str);\n\treturn ret;\n}", "target": 0}
{"code": "get_word_rgb_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "CmdExtract::CmdExtract(CommandData *Cmd)\n{\n  CmdExtract::Cmd=Cmd;\n  *ArcName=0;\n  *DestFileName=0;\n  ArcAnalyzed=false;\n  Analyze=new AnalyzeData;\n  memset(Analyze,0,sizeof(*Analyze));\n  TotalFileCount=0;\n  UpLinkExtracted=false;\n  Unp=new Unpack(&DataIO);\n#ifdef RAR_SMP\n  Unp->SetThreads(Cmd->Threads);\n#endif\n}", "target": 0}
{"code": "static int proc_dmesg_restrict(struct ctl_table *table, int write,\n\t\t\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tif (write && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\treturn proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n}", "target": 0}
{"code": "BuildSendAndCloseSoapResp(struct upnphttp * h,\n                          const char * body, int bodylen)\n{\n\tstatic const char beforebody[] =\n\t\t\"<?xml version=\\\"1.0\\\"?>\\r\\n\"\n\t\t\"<s:Envelope xmlns:s=\\\"http:\n\t\t\"s:encodingStyle=\\\"http:\n\t\t\"<s:Body>\";\n\tstatic const char afterbody[] =\n\t\t\"</s:Body>\"\n\t\t\"</s:Envelope>\\r\\n\";\n\tint r = BuildHeader_upnphttp(h, 200, \"OK\",  sizeof(beforebody) - 1\n\t                             + sizeof(afterbody) - 1 + bodylen );\n\tif(r >= 0) {\n\t\tmemcpy(h->res_buf + h->res_buflen, beforebody, sizeof(beforebody) - 1);\n\t\th->res_buflen += sizeof(beforebody) - 1;\n\t\tmemcpy(h->res_buf + h->res_buflen, body, bodylen);\n\t\th->res_buflen += bodylen;\n\t\tmemcpy(h->res_buf + h->res_buflen, afterbody, sizeof(afterbody) - 1);\n\t\th->res_buflen += sizeof(afterbody) - 1;\n\t} else {\n\t\tBuildResp2_upnphttp(h, 500, \"Internal Server Error\", NULL, 0);\n\t}\n\tSendRespAndClose_upnphttp(h);\n}", "target": 0}
{"code": "static s32 adpt_send_nop(adpt_hba*pHba,u32 m)\n{\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 5*HZ;\n\twhile(m == EMPTY_QUEUE){\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif(m != EMPTY_QUEUE){\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_ERR \"%s: Timeout waiting for message frame!\\n\",pHba->name);\n\t\t\treturn 2;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t}\n\tmsg = (u32 __iomem *)(pHba->msg_addr_virt + m);\n\twritel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);\n\twritel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);\n\twritel( 0,&msg[2]);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "static inline void TCP_ECN_queue_cwr(struct tcp_sock *tp)\n{\n\tif (tp->ecn_flags & TCP_ECN_OK)\n\t\ttp->ecn_flags |= TCP_ECN_QUEUE_CWR;\n}", "target": 0}
{"code": "spnego_gss_verify_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_buffer_t msg_buffer,\n\t\tconst gss_buffer_t token_buffer,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_verify_mic(minor_status,\n\t\t\t    context_handle,\n\t\t\t    msg_buffer,\n\t\t\t    token_buffer,\n\t\t\t    qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "spnego_gss_process_context_token(\n\t\t\t\tOM_uint32\t*minor_status,\n\t\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\t\tconst gss_buffer_t token_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_process_context_token(minor_status,\n\t\t\t\t\tcontext_handle,\n\t\t\t\t\ttoken_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size)\n{\n    auto indexObj = this->GetDictionary().GetKey(\"Index\");\n    if (indexObj == nullptr)\n    {\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}", "target": 1}
{"code": "void sqlite3SelectReset(Parse *pParse, Select *p){\n  if( ALWAYS(p) ){\n    clearSelect(pParse->db, p, 0);\n    memset(&p->iLimit, 0, sizeof(Select) - offsetof(Select,iLimit));\n    p->pEList = sqlite3ExprListAppend(pParse, 0,\n                     sqlite3ExprAlloc(pParse->db,TK_NULL,0,0));\n    p->pSrc = sqlite3DbMallocZero(pParse->db, sizeof(SrcList));\n  }\n}", "target": 0}
{"code": "getRootParserOf(XML_Parser parser, unsigned int *outLevelDiff) {\n  XML_Parser rootParser = parser;\n  unsigned int stepsTakenUpwards = 0;\n  while (rootParser->m_parentParser) {\n    rootParser = rootParser->m_parentParser;\n    stepsTakenUpwards++;\n  }\n  assert(! rootParser->m_parentParser);\n  if (outLevelDiff != NULL) {\n    *outLevelDiff = stepsTakenUpwards;\n  }\n  return rootParser;\n}", "target": 0}
{"code": "static struct nfs4_opendata *nfs4_open_recoverdata_alloc(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs4_opendata *opendata;\n\topendata = nfs4_opendata_alloc(&ctx->path, state->owner, 0, NULL);\n\tif (opendata == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\topendata->state = state;\n\tatomic_inc(&state->count);\n\treturn opendata;\n}", "target": 1}
{"code": "static int __sock_diag_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tint err;\n\tstruct sock_diag_req *req = nlmsg_data(nlh);\n\tconst struct sock_diag_handler *hndl;\n\tif (nlmsg_len(nlh) < sizeof(*req))\n\t\treturn -EINVAL;\n\tif (req->sdiag_family >= AF_MAX)\n\t\treturn -EINVAL;\n\thndl = sock_diag_lock_handler(req->sdiag_family);\n\tif (hndl == NULL)\n\t\terr = -ENOENT;\n\telse\n\t\terr = hndl->dump(skb, nlh);\n\tsock_diag_unlock_handler(hndl);\n\treturn err;\n}", "target": 0}
{"code": "static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "Status SparseReduceShapeFn(InferenceContext* c) {\n  bool keep_dims = false;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"keep_dims\", &keep_dims));\n  const Tensor* shape_tensor = c->input_tensor(2);\n  const Tensor* axes_tensor = c->input_tensor(3);\n  if (shape_tensor != nullptr && axes_tensor != nullptr) {\n    auto shape_vec = shape_tensor->flat<int64>();\n    auto axes_vec = axes_tensor->flat<int32>();\n    int64_t ndims = shape_vec.size();\n    absl::flat_hash_set<int64> axes;\n    if (ndims == 0)\n      return errors::InvalidArgument(\n          \"Number of dims in shape tensor must not be 0\");\n    for (int i = 0; i < axes_vec.size(); i++) {\n      axes.insert((axes_vec(i) + ndims) % ndims);\n    }\n    std::vector<DimensionHandle> dims;\n    if (keep_dims) {\n      dims.reserve(ndims);\n      for (int d = 0; d < ndims; ++d) {\n        if (axes.find(d) == axes.end()) {\n          dims.push_back(c->MakeDim(shape_vec(d)));\n        } else {\n          dims.push_back(c->MakeDim(1));\n        }\n      }\n    } else {\n      for (int d = 0; d < ndims; ++d) {\n        if (axes.find(d) == axes.end()) {\n          dims.push_back(c->MakeDim(shape_vec(d)));\n        }\n      }\n    }\n    c->set_output(0, c->MakeShape(dims));\n    return Status::OK();\n  }\n  return UnknownShape(c);\n}", "target": 0}
{"code": "    bool normalizeSipUri( std::string& uri, int brackets ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            return false ;\n        }\n        if( NULL == url->url_scheme && NULL == url->url_user && NULL != url->url_host ) {\n            url->url_scheme = \"sip\" ;\n            url->url_user = url->url_host ;\n            url->url_host = \"localhost\" ;   \n         }\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, brackets, url, params, comment) ;\n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }", "target": 1}
{"code": "ldbm_config_search_entry_callback(Slapi_PBlock *pb __attribute__((unused)),\n                                  Slapi_Entry *e,\n                                  Slapi_Entry *entryAfter __attribute__((unused)),\n                                  int *returncode,\n                                  char *returntext,\n                                  void *arg)\n{\n    char buf[BUFSIZ];\n    struct berval *vals[2];\n    struct berval val;\n    struct ldbminfo *li = (struct ldbminfo *)arg;\n    config_info *config;\n    int scope;\n    vals[0] = &val;\n    vals[1] = NULL;\n    returntext[0] = '\\0';\n    PR_Lock(li->li_config_mutex);\n    if (pb) {\n        slapi_pblock_get(pb, SLAPI_SEARCH_SCOPE, &scope);\n        if (scope == LDAP_SCOPE_BASE) {\n            char **attrs = NULL;\n            slapi_pblock_get(pb, SLAPI_SEARCH_ATTRS, &attrs);\n            if (attrs) {\n                for (size_t i = 0; attrs[i]; i++) {\n                    if (ldbm_config_moved_attr(attrs[i])) {\n                        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"at least one required attribute has been moved to the BDB scecific configuration entry\");\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    for (config = ldbm_config; config->config_name != NULL; config++) {\n        if (!(config->config_flags & (CONFIG_FLAG_ALWAYS_SHOW | CONFIG_FLAG_PREVIOUSLY_SET))) {\n            continue;\n        }\n        ldbm_config_get((void *)li, config, buf);\n        val.bv_val = buf;\n        val.bv_len = strlen(buf);\n        slapi_entry_attr_replace(e, config->config_name, vals);\n    }\n    PR_Unlock(li->li_config_mutex);\n    *returncode = LDAP_SUCCESS;\n    return SLAPI_DSE_CALLBACK_OK;\n}", "target": 1}
{"code": "static int sctp_sf_send_restart_abort(struct net *net, union sctp_addr *ssa,\n\t\t\t\t      struct sctp_chunk *init,\n\t\t\t\t      sctp_cmd_seq_t *commands)\n{\n\tint len;\n\tstruct sctp_packet *pkt;\n\tunion sctp_addr_param *addrparm;\n\tstruct sctp_errhdr *errhdr;\n\tstruct sctp_endpoint *ep;\n\tchar buffer[sizeof(struct sctp_errhdr)+sizeof(union sctp_addr_param)];\n\tstruct sctp_af *af = sctp_get_af_specific(ssa->v4.sin_family);\n\terrhdr = (struct sctp_errhdr *)buffer;\n\taddrparm = (union sctp_addr_param *)errhdr->variable;\n\tlen = af->to_addr_param(ssa, addrparm);\n\tlen += sizeof(sctp_errhdr_t);\n\terrhdr->cause = SCTP_ERROR_RESTART;\n\terrhdr->length = htons(len);\n\tep = sctp_sk(net->sctp.ctl_sock)->ep;\n\tpkt = sctp_abort_pkt_new(net, ep, NULL, init, errhdr, len);\n\tif (!pkt)\n\t\tgoto out;\n\tsctp_add_cmd_sf(commands, SCTP_CMD_SEND_PKT, SCTP_PACKET(pkt));\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTCTRLCHUNKS);\n\tsctp_add_cmd_sf(commands, SCTP_CMD_DISCARD_PACKET, SCTP_NULL());\nout:\n\treturn 0;\n}", "target": 0}
{"code": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n   BUG_IF(tree_root == NULL);\n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n   unfold_blk(&tree_root);\n   fprintf(stdout, \" done.\\n\\n\");\n   labels_to_offsets();\n   TAILQ_FOREACH(ue, &unfolded_tree, next) {\n      if (ue->label == 0) {\n         SAFE_REALLOC(array, i * sizeof(struct filter_op));\n         memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));\n         i++;\n      }\n   }\n   SAFE_REALLOC(array, i * sizeof(struct filter_op));\n   array[i - 1].opcode = FOP_EXIT;\n   *fop = array;\n   return (i);\n}", "target": 1}
{"code": "TEST(HeaderMapImplTest, RemoveHost) {\n  TestRequestHeaderMapImpl headers;\n  headers.setHost(\"foo\");\n  EXPECT_EQ(\"foo\", headers.get_(\"host\"));\n  EXPECT_EQ(\"foo\", headers.get_(\":authority\"));\n  EXPECT_EQ(1UL, headers.remove(\"host\"));\n  EXPECT_EQ(\"\", headers.get_(\"host\"));\n  EXPECT_EQ(\"\", headers.get_(\":authority\"));\n  EXPECT_EQ(nullptr, headers.Host());\n}", "target": 0}
{"code": "lyd_new_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}", "target": 1}
{"code": "static WCHAR* drive_file_combine_fullpath(const WCHAR* base_path, const WCHAR* path,\n                                          size_t PathLength)\n{\n\tWCHAR* fullpath;\n\tsize_t base_path_length;\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\tbase_path_length = _wcslen(base_path) * 2;\n\tfullpath = (WCHAR*)calloc(1, base_path_length + PathLength + sizeof(WCHAR));\n\tif (!fullpath)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn NULL;\n\t}\n\tCopyMemory(fullpath, base_path, base_path_length);\n\tif (path)\n\t\tCopyMemory((char*)fullpath + base_path_length, path, PathLength);\n\tdrive_file_fix_path(fullpath);\n\treturn fullpath;\n}", "target": 1}
{"code": "comics_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n\tiface->get_thumbnail = comics_document_thumbnails_get_thumbnail;\n\tiface->get_dimensions = comics_document_thumbnails_get_dimensions;\n}", "target": 1}
{"code": "bool isCPUDevice<CPUDevice>() {\n  return true;\n}", "target": 0}
{"code": "sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "vte_sequence_handler_DC (VteTerminal *terminal, GValueArray *params)\n{\n\tvte_sequence_handler_multiple(terminal, params, vte_sequence_handler_dc);\n}", "target": 0}
{"code": "Suite *cjose_jwe_suite()\n{\n    Suite *suite = suite_create(\"jwe\");\n    TCase *tc_jwe = tcase_create(\"core\");\n    tcase_set_timeout(tc_jwe, 120.0);\n    tcase_add_test(tc_jwe, test_cjose_jwe_node_jose_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_iv);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_short);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_empty);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_large);\n    tcase_add_test(tc_jwe, test_cjose_jwe_self_encrypt_self_decrypt_many);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_aes_gcm);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_rsa);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_header);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_key);\n    tcase_add_test(tc_jwe, test_cjose_jwe_encrypt_with_bad_content);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_export_compare);\n    tcase_add_test(tc_jwe, test_cjose_jwe_import_invalid_serialization);\n    tcase_add_test(tc_jwe, test_cjose_jwe_decrypt_bad_params);\n    tcase_add_test(tc_jwe, test_cjose_jwe_multiple_recipients);\n    suite_add_tcase(suite, tc_jwe);\n    return suite;\n}", "target": 0}
{"code": "isAlphaNum(char ch) {\n\treturn (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');\n}", "target": 0}
{"code": "static int bpf_adj_delta_to_imm(struct bpf_insn *insn, u32 pos, u32 delta,\n\t\t\t\tu32 curr, const bool probe_pass)\n{\n\tconst s64 imm_min = S32_MIN, imm_max = S32_MAX;\n\ts64 imm = insn->imm;\n\tif (curr < pos && curr + imm + 1 > pos)\n\t\timm += delta;\n\telse if (curr > pos + delta && curr + imm + 1 <= pos + delta)\n\t\timm -= delta;\n\tif (imm < imm_min || imm > imm_max)\n\t\treturn -ERANGE;\n\tif (!probe_pass)\n\t\tinsn->imm = imm;\n\treturn 0;\n}", "target": 0}
{"code": "void UnicodeStringTest::TestLargeAppend() {\n    if(quick) return;\n    IcuTestErrorCode status(*this, \"TestLargeAppend\");\n    int32_t len = 0xAFFFFFF;\n    UnicodeString str;\n    char16_t *buf = str.getBuffer(len);\n    uprv_memset(buf, 0x4e, len * 2);\n    str.releaseBuffer(len);\n    UnicodeString dest;\n    int64_t total = 0;\n    for (int32_t i = 0; i < 16; i++) {\n        dest.append(str);\n        total += len;\n        if (total <= INT32_MAX) {\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n        } else {\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        }\n    }\n    dest.remove();\n    total = 0;\n    for (int32_t i = 0; i < 16; i++) {\n        dest.append(str);\n        total += len;\n        if (total + len <= INT32_MAX) {\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n        } else if (total <= INT32_MAX) {\n            UnicodeString str2;\n            int32_t remain = INT32_MAX - total;\n            char16_t *buf2 = str2.getBuffer(remain);\n            if (buf2 == nullptr) {\n                return;\n            }\n            uprv_memset(buf2, 0x4e, remain * 2);\n            str2.releaseBuffer(remain);\n            dest.append(str2);\n            total += remain;\n            assertEquals(\"When a string of exactly the maximum size works\", (int64_t)INT32_MAX, total);\n            assertEquals(\"When a string of exactly the maximum size works\", INT32_MAX, dest.length());\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n            str2.truncate(1);\n            dest.append(str2);\n            total++;\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        } else {\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        }\n    }\n}", "target": 0}
{"code": "static int load_script(struct linux_binprm *bprm)\n{\n\tconst char *i_arg, *i_name;\n\tchar *cp;\n\tstruct file *file;\n\tchar interp[BINPRM_BUF_SIZE];\n\tint retval;\n\tif ((bprm->buf[0] != '#') || (bprm->buf[1] != '!'))\n\t\treturn -ENOEXEC;\n\tallow_write_access(bprm->file);\n\tfput(bprm->file);\n\tbprm->file = NULL;\n\tbprm->buf[BINPRM_BUF_SIZE - 1] = '\\0';\n\tif ((cp = strchr(bprm->buf, '\\n')) == NULL)\n\t\tcp = bprm->buf+BINPRM_BUF_SIZE-1;\n\t*cp = '\\0';\n\twhile (cp > bprm->buf) {\n\t\tcp--;\n\t\tif ((*cp == ' ') || (*cp == '\\t'))\n\t\t\t*cp = '\\0';\n\t\telse\n\t\t\tbreak;\n\t}\n\tfor (cp = bprm->buf+2; (*cp == ' ') || (*cp == '\\t'); cp++);\n\tif (*cp == '\\0') \n\t\treturn -ENOEXEC; \n\ti_name = cp;\n\ti_arg = NULL;\n\tfor ( ; *cp && (*cp != ' ') && (*cp != '\\t'); cp++)\n\t\t ;\n\twhile ((*cp == ' ') || (*cp == '\\t'))\n\t\t*cp++ = '\\0';\n\tif (*cp)\n\t\ti_arg = cp;\n\tstrcpy (interp, i_name);\n\tretval = remove_arg_zero(bprm);\n\tif (retval)\n\t\treturn retval;\n\tretval = copy_strings_kernel(1, &bprm->interp, bprm);\n\tif (retval < 0) return retval; \n\tbprm->argc++;\n\tif (i_arg) {\n\t\tretval = copy_strings_kernel(1, &i_arg, bprm);\n\t\tif (retval < 0) return retval; \n\t\tbprm->argc++;\n\t}\n\tretval = copy_strings_kernel(1, &i_name, bprm);\n\tif (retval) return retval; \n\tbprm->argc++;\n\tbprm->interp = interp;\n\tfile = open_exec(interp);\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\tbprm->file = file;\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\treturn retval;\n\treturn search_binary_handler(bprm);\n}", "target": 1}
{"code": "static int open_if_safe(int dirfd, const char *nextpath)\n{\n\tint newfd = openat(dirfd, nextpath, O_RDONLY | O_NOFOLLOW);\n\tif (newfd >= 0) \n\t\treturn newfd;\n\tif (errno == ELOOP)\n\t\treturn newfd;\n\tif (errno == EPERM || errno == EACCES) {\n\t\tnewfd = openat(dirfd, nextpath, O_PATH | O_NOFOLLOW);\n\t\tif (newfd >= 0) {\n\t\t\tint ret = check_symlink(newfd);\n\t\t\tif (ret < 0) {\n\t\t\t\tclose(newfd);\n\t\t\t\tnewfd = ret;\n\t\t\t}\n\t\t}\n\t}\n\treturn newfd;\n}", "target": 0}
{"code": "mm_destroy(struct mm_master *mm)\n{\n\tmm_freelist(mm->mmalloc, &mm->rb_free);\n\tmm_freelist(mm->mmalloc, &mm->rb_allocated);\n\tif (munmap(mm->address, mm->size) == -1)\n\t\tfatal(\"munmap(%p, %zu): %s\", mm->address, mm->size,\n\t\t    strerror(errno));\n\tif (mm->mmalloc == NULL)\n\t\tfree(mm);\n\telse\n\t\tmm_free(mm->mmalloc, mm);\n}", "target": 1}
{"code": "  template<typename T> const T GetWirelessNetworkByPath(\n      const std::vector<T>& networks, const std::string& path) const {\n    typedef typename std::vector<T>::const_iterator iter_t;\n    iter_t iter = std::find_if(networks.begin(), networks.end(),\n                               WirelessNetwork::ServicePathEq(path));\n    return (iter != networks.end()) ? *iter : NULL;\n  }", "target": 0}
{"code": "void test_symlink(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\tif (symlink(tmpname, path) == 0) {\n\t\tfprintf(stderr, \"leak at symlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at symlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (symlink(path, tmpname) == 0) {\n\t\tfprintf(stderr, \"leak at symlink (2) of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at symlink (2) of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "pthread_mutex_lock(pthread_mutex_t *mutex)\n{\n\tEnterCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "  Status check_index_ordering(const Tensor& indices) {\n    auto findices = indices.flat<int>();\n    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {\n      if (findices(i) < findices(i + 1)) {\n        continue;\n      }\n      return Status(\n          errors::InvalidArgument(\"Indices are not strictly ordered\"));\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "DefragTracker *DefragGetTrackerFromHash (Packet *p)\n{\n    DefragTracker *dt = NULL;\n    uint32_t key = DefragHashGetKey(p);\n    DefragTrackerHashRow *hb = &defragtracker_hash[key];\n    DRLOCK_LOCK(hb);\n    if (hb->head == NULL) {\n        dt = DefragTrackerGetNew(p);\n        if (dt == NULL) {\n            DRLOCK_UNLOCK(hb);\n            return NULL;\n        }\n        hb->head = dt;\n        hb->tail = dt;\n        DefragTrackerInit(dt,p);\n        DRLOCK_UNLOCK(hb);\n        return dt;\n    }\n    dt = hb->head;\n    if (dt->remove || DefragTrackerCompare(dt, p) == 0) {\n        DefragTracker *pdt = NULL; \n        while (dt) {\n            pdt = dt;\n            dt = dt->hnext;\n            if (dt == NULL) {\n                dt = pdt->hnext = DefragTrackerGetNew(p);\n                if (dt == NULL) {\n                    DRLOCK_UNLOCK(hb);\n                    return NULL;\n                }\n                hb->tail = dt;\n                dt->hprev = pdt;\n                DefragTrackerInit(dt,p);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n            if (DefragTrackerCompare(dt, p) != 0) {\n                if (dt->hnext) {\n                    dt->hnext->hprev = dt->hprev;\n                }\n                if (dt->hprev) {\n                    dt->hprev->hnext = dt->hnext;\n                }\n                if (dt == hb->tail) {\n                    hb->tail = dt->hprev;\n                }\n                dt->hnext = hb->head;\n                dt->hprev = NULL;\n                hb->head->hprev = dt;\n                hb->head = dt;\n                SCMutexLock(&dt->lock);\n                (void) DefragTrackerIncrUsecnt(dt);\n                DRLOCK_UNLOCK(hb);\n                return dt;\n            }\n        }\n    }\n    SCMutexLock(&dt->lock);\n    (void) DefragTrackerIncrUsecnt(dt);\n    DRLOCK_UNLOCK(hb);\n    return dt;\n}", "target": 1}
{"code": "void mark_files_ro(struct super_block *sb)\n{\n\tstruct file *f;\n\tlg_global_lock(&files_lglock);\n\tdo_file_list_for_each_entry(sb, f) {\n\t\tif (!file_count(f))\n\t\t\tcontinue;\n\t\tif (!(f->f_mode & FMODE_WRITE))\n\t\t\tcontinue;\n\t\tspin_lock(&f->f_lock);\n\t\tf->f_mode &= ~FMODE_WRITE;\n\t\tspin_unlock(&f->f_lock);\n\t\tif (file_check_writeable(f) != 0)\n\t\t\tcontinue;\n\t\t__mnt_drop_write(f->f_path.mnt);\n\t\tfile_release_write(f);\n\t} while_file_list_for_each_entry;\n\tlg_global_unlock(&files_lglock);\n}", "target": 1}
{"code": "    ThreadState* thread_state() const { return thread_state_; }", "target": 0}
{"code": "int HTPFileOpenWithRange(HtpState *s, HtpTxUserData *txud, const uint8_t *filename,\n        uint16_t filename_len, const uint8_t *data, uint32_t data_len, uint64_t txid,\n        bstr *rawvalue, HtpTxUserData *htud)\n{\n    SCEnter();\n    uint16_t flags;\n    DEBUG_VALIDATE_BUG_ON(s == NULL);\n    HTTPContentRange crparsed;\n    if (HTPParseAndCheckContentRange(rawvalue, &crparsed, s, htud) != 0) {\n        return HTPFileOpen(s, txud, filename, filename_len, data, data_len, txid, STREAM_TOCLIENT);\n    }\n    flags = FileFlowToFlags(s->f, STREAM_TOCLIENT);\n    FileContainer *files = &txud->files_tc;\n    if (FileOpenFileWithId(files, &htp_sbcfg, s->file_track_id++, filename, filename_len, data,\n                data_len, flags) != 0) {\n        SCReturnInt(-1);\n    } else {\n        const HTPCfgDir *cfg = &s->cfg->response;\n        FileSetInspectSizes(files->tail, cfg->inspect_window, cfg->inspect_min_size);\n    }\n    txud->tx_data.files_opened++;\n    if (FileSetRange(files, crparsed.start, crparsed.end) < 0) {\n        SCLogDebug(\"set range failed\");\n    }\n    htp_tx_t *tx = htp_list_get(s->conn->transactions, txid);\n    if (!tx) {\n        SCReturnInt(-1);\n    }\n    uint8_t *keyurl;\n    uint32_t keylen;\n    if (tx->request_hostname != NULL) {\n        keylen = bstr_len(tx->request_hostname) + filename_len;\n        keyurl = SCMalloc(keylen);\n        if (keyurl == NULL) {\n            SCReturnInt(-1);\n        }\n        memcpy(keyurl, bstr_ptr(tx->request_hostname), bstr_len(tx->request_hostname));\n        memcpy(keyurl + bstr_len(tx->request_hostname), filename, filename_len);\n    } else {\n        SCReturnInt(0);\n    }\n    DEBUG_VALIDATE_BUG_ON(htud->file_range);\n    htud->file_range = HttpRangeContainerOpenFile(keyurl, keylen, s->f, &crparsed, &htp_sbcfg,\n            filename, filename_len, flags, data, data_len);\n    SCFree(keyurl);\n    if (htud->file_range == NULL) {\n        SCReturnInt(-1);\n    }\n    SCReturnInt(0);\n}", "target": 1}
{"code": "static void adpt_sparc_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_ULTRASPARC;\n}", "target": 1}
{"code": "static int crypto_givcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"givcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<built-in>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArraySizeOfCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    int i = Jsi_ObjGetLength(interp, _this->d.obj);\n    Jsi_ValueMakeNumber(interp, ret, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "TEST(BasicFlatBufferModel, TestUnsupportedRecursion) {\n  const auto model_path =\n      \"tensorflow/lite/testdata/unsupported_recursion.bin\";\n  std::unique_ptr<tflite::FlatBufferModel> model =\n      FlatBufferModel::BuildFromFile(model_path);\n  ASSERT_NE(model, nullptr);\n  tflite::ops::builtin::BuiltinOpResolver resolver;\n  InterpreterBuilder builder(*model, resolver);\n  std::unique_ptr<Interpreter> interpreter;\n  ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n  ASSERT_NE(interpreter, nullptr);\n  ASSERT_NE(interpreter->AllocateTensors(), kTfLiteOk);\n}", "target": 0}
{"code": "static int crypto_report(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t\t struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_report_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols,\n  int stride, int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint m;\n\tint hstartcol;\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = numrows - hstartcol;\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += numcols;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\tdstptr2 = dstptr;\n\t\t\tsrcptr2 = srcptr;\n\t\t\tfor (i = 0; i < numcols; ++i) {\n\t\t\t\t*dstptr2 = *srcptr2;\n\t\t\t\t++dstptr2;\n\t\t\t\t++srcptr2;\n\t\t\t}\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += numcols;\n\t\t}\n\t}\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "static inline Quantum ScaleLongLongToQuantum(const MagickSizeType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) ((value)/MagickULLConstant(281479271743489)));\n#else\n  return((Quantum) (value/281479271743489.0));\n#endif\n}", "target": 0}
{"code": "jas_stream_t *jas_stream_memopen2(char *buf, size_t bufsize)\n{\n\tjas_stream_t *stream;\n\tjas_stream_memobj_t *obj;\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2(%p, %zu)\\n\", buf, bufsize));\n\tassert((buf && bufsize > 0) || (!buf));\n\tif (!(stream = jas_stream_create())) {\n\t\treturn 0;\n\t}\n\tstream->openmode_ = JAS_STREAM_READ | JAS_STREAM_WRITE | JAS_STREAM_BINARY;\n\tjas_stream_initbuf(stream, JAS_STREAM_FULLBUF, 0, 0);\n\tstream->ops_ = &jas_stream_memops;\n\tif (!(obj = jas_malloc(sizeof(jas_stream_memobj_t)))) {\n\t\tjas_stream_destroy(stream);\n\t\treturn 0;\n\t}\n\tstream->obj_ = (void *) obj;\n\tobj->myalloc_ = 0;\n\tobj->buf_ = 0;\n\tif (!bufsize) {\n\t\tobj->bufsize_ = 1024;\n\t\tobj->growable_ = 1;\n\t} else {\n\t\tobj->bufsize_ = bufsize;\n\t\tobj->growable_ = 0;\n\t}\n\tif (buf) {\n\t\tobj->buf_ = JAS_CAST(unsigned char *, buf);\n\t} else {\n\t\tobj->buf_ = jas_malloc(obj->bufsize_);\n\t\tobj->myalloc_ = 1;\n\t}\n\tif (!obj->buf_) {\n\t\tjas_stream_close(stream);\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(100, (\"jas_stream_memopen2 buffer buf=%p myalloc=%d\\n\",\n\t  obj->buf_, obj->myalloc_));\n\tif (bufsize > 0 && buf) {\n\t\tobj->len_ = bufsize;\n\t} else {\n\t\tobj->len_ = 0;\n\t}\n\tobj->pos_ = 0;\n\treturn stream;\n}", "target": 0}
{"code": "TfLiteStatus HardSwishPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    HardSwishParams* params = static_cast<HardSwishParams*>(node->user_data);\n    params->input_zero_point = input->params.zero_point;\n    params->output_zero_point = output->params.zero_point;\n    const float input_scale = input->params.scale;\n    const float hires_input_scale = (1.0f / 128.0f) * input_scale;\n    const float reluish_scale = 3.0f / 32768.0f;\n    const float output_scale = output->params.scale;\n    const double output_multiplier =\n        static_cast<double>(hires_input_scale / output_scale);\n    int32_t output_multiplier_fixedpoint_int32;\n    QuantizeMultiplier(output_multiplier, &output_multiplier_fixedpoint_int32,\n                       &params->output_multiplier_exponent);\n    DownScaleInt32ToInt16Multiplier(\n        output_multiplier_fixedpoint_int32,\n        &params->output_multiplier_fixedpoint_int16);\n    TF_LITE_ENSURE(context, params->output_multiplier_exponent <= 0);\n    const double reluish_multiplier =\n        static_cast<double>(hires_input_scale / reluish_scale);\n    int32_t reluish_multiplier_fixedpoint_int32;\n    QuantizeMultiplier(reluish_multiplier, &reluish_multiplier_fixedpoint_int32,\n                       &params->reluish_multiplier_exponent);\n    DownScaleInt32ToInt16Multiplier(\n        reluish_multiplier_fixedpoint_int32,\n        &params->reluish_multiplier_fixedpoint_int16);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "  void* GetData() { return embedder_data_; }", "target": 0}
{"code": "unique_ptr<IOBuf> IOBuf::create(std::size_t capacity) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  if (capacity <= kDefaultCombinedBufSize) {\n    return createCombined(capacity);\n  }\n  if (canNallocx()) {\n    auto mallocSize = goodMallocSize(capacity);\n    size_t minSize = ((capacity + 7) & ~7) + sizeof(SharedInfo);\n    if (mallocSize < minSize) {\n      auto* buf = checkedMalloc(mallocSize);\n      return takeOwnership(SIZED_FREE, buf, mallocSize, 0, 0);\n    }\n  }\n  return createSeparate(capacity);\n}", "target": 0}
{"code": "  HistogramInfo* heap_histograms() { return heap_histograms_; }", "target": 0}
{"code": "static void bnx2x_clear_func_ilt(struct bnx2x *bp, u32 func)\n{\n\tu32 i, base = FUNC_ILT_BASE(func);\n\tfor (i = base; i < base + ILT_PER_FUNC; i++)\n\t\tbnx2x_ilt_wr(bp, i, 0);\n}", "target": 0}
{"code": "NOEXPORT unsigned __stdcall daemon_thread(void *arg) {\n    (void)arg; \n    tls_alloc(NULL, NULL, \"main\"); \n    main_init();\n    SetEvent(main_initialized); \n    while(main_configure(cmdline.config_file, NULL)) {\n        if(cmdline.config_file && *cmdline.config_file=='-')\n            cmdline.config_file=NULL; \n        unbind_ports(); \n        log_flush(LOG_MODE_ERROR); \n        PostMessage(hwnd, WM_INVALID_CONFIG, 0, 0); \n        WaitForSingleObject(config_ready, INFINITE);\n    }\n    PostMessage(hwnd, WM_VALID_CONFIG, 0, 0);\n    daemon_loop();\n    main_cleanup();\n    _endthreadex(0); \n    return 0;\n}", "target": 1}
{"code": "static inline int event2keytype(int event)\n{\n\tswitch (event) {\n\tcase XFRM_MSG_DELSA:\n\t\treturn SADB_DELETE;\n\tcase XFRM_MSG_NEWSA:\n\t\treturn SADB_ADD;\n\tcase XFRM_MSG_UPDSA:\n\t\treturn SADB_UPDATE;\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn SADB_EXPIRE;\n\tdefault:\n\t\tpr_err(\"pfkey: Unknown SA event %d\\n\", event);\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static inline void tss_invalidate_io_bitmap(void)\n{\n\tPVOP_VCALL0(cpu.invalidate_io_bitmap);\n}", "target": 0}
{"code": "int sas_discover_sata(struct domain_device *dev)\n{\n\tint res;\n\tif (dev->dev_type == SAS_SATA_PM)\n\t\treturn -ENODEV;\n\tdev->sata_dev.class = sas_get_ata_command_set(dev);\n\tsas_fill_in_rphy(dev, dev->rphy);\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "  inline Eigen::IndexList<int, Eigen::type2index<1>> NByOne(int n) {\n    Eigen::IndexList<int, Eigen::type2index<1>> ret;\n    ret.set(0, n);\n    return ret;\n  }", "target": 1}
{"code": "fbStore_a1 (FbBits *bits, const CARD32 *values, int x, int width, miIndexedPtr indexed)\n{\n    int i;\n    for (i = 0; i < width; ++i) {\n        CARD32  *pixel = ((CARD32 *) bits) + ((i+x) >> 5);\n        CARD32  mask = FbStipMask((i+x) & 0x1f, 1);\n        CARD32 v = READ(values + i) & 0x80000000 ? mask : 0;\n        WRITE(pixel, (READ(pixel) & ~mask) | v);\n    }\n}", "target": 0}
{"code": "  explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "check_entry_for_referral(Slapi_PBlock *pb, Slapi_Entry *entry, char *matched, const char *callingfn) \n{\n\tint rc=0, i=0, numValues=0;\n\tSlapi_Attr *attr;\n\tSlapi_Value *val=NULL;\t\n\tstruct berval **refscopy=NULL;\n\tstruct berval **url=NULL;\n\tif ( slapi_entry_attr_find( entry, \"ref\", &attr ) )\n\t{\n\t\tgoto out;\n\t}\n\tslapi_attr_get_numvalues(attr, &numValues );\n\tif(numValues == 0) {\n\t\tgoto out;\n\t}\n\turl=(struct berval **) slapi_ch_malloc((numValues + 1) * sizeof(struct berval*));\n\tif (!url) {\n\t\tLDAPDebug( LDAP_DEBUG_ANY,\n\t\t\t\"check_entry_for_referral: Out of memory\\n\",\n\t\t\t0, 0, 0);\n\t\tgoto out;\n\t}\n\tfor (i = slapi_attr_first_value(attr, &val); i != -1;\n\t     i = slapi_attr_next_value(attr, i, &val)) {\n\t\turl[i]=(struct berval*)slapi_value_get_berval(val);\n\t}\n\turl[numValues]=NULL;\t\t\n\trefscopy = ref_adjust( pb, url, slapi_entry_get_sdn(entry), 0 ); \n\tslapi_send_ldap_result( pb, LDAP_REFERRAL, matched, NULL, 0, refscopy );\n\trc= 1;\n\tLDAPDebug( LDAP_DEBUG_TRACE,\n\t\t\"<= %s sent referral to (%s) for (%s)\\n\",\n\t\tcallingfn,\n\t\trefscopy ? refscopy[0]->bv_val : \"\",\n\t\tslapi_entry_get_dn(entry));\nout:\n\tif ( refscopy != NULL )\n\t{\n\t\tber_bvecfree( refscopy );\n\t}\n\tif( url != NULL) {\n\t\tslapi_ch_free( (void **)&url );\t\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "parse_delta(struct rpki_uri *uri, struct delta_head *parents_data,\n    struct proc_upd_args *args)\n{\n\tstruct rdr_delta_ctx ctx;\n\tstruct delta *delta;\n\tstruct doc_data *expected_data;\n\tint error;\n\texpected_data = &parents_data->doc_data;\n\tfnstack_push_uri(uri);\n\terror = hash_validate_file(\"sha256\", uri, expected_data->hash,\n\t    expected_data->hash_len);\n\tif (error)\n\t\tgoto pop_fnstack;\n\terror = delta_create(&delta);\n\tif (error)\n\t\tgoto pop_fnstack;\n\tctx.delta = delta;\n\tctx.parent = args->parent;\n\tctx.visited_uris = args->visited_uris;\n\tctx.expected_serial = parents_data->serial;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_delta, &ctx);\n\tdelta_destroy(delta);\npop_fnstack:\n\tfnstack_pop();\n\treturn error;\n}", "target": 1}
{"code": "bit_write_MC (Bit_Chain *dat, BITCODE_MC val)\n{\n  int i, j;\n  int negative = 0;\n  unsigned char byte[5];\n  BITCODE_UMC mask = 0x0000007f;\n  BITCODE_UMC value = (BITCODE_UMC)val;\n  if (val < 0)\n    {\n      negative = 1;\n      value = (BITCODE_UMC)-val;\n    }\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  if (negative)\n    byte[i] |= 0x40;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(ptr))); ptr++;\t\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(ptr))); ptr++;\t\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", *((const u_char *)ptr++))));\n\tif (length > 5) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length-5);\n\t}\n}", "target": 1}
{"code": "static int mongo_cursor_get_more( mongo_cursor *cursor ) {\n    int res;\n    if( cursor->limit > 0 && cursor->seen >= cursor->limit ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply ) {\n        cursor->err = MONGO_CURSOR_INVALID;\n        return MONGO_ERROR;\n    }\n    else if( ! cursor->reply->fields.cursorID ) {\n        cursor->err = MONGO_CURSOR_EXHAUSTED;\n        return MONGO_ERROR;\n    }\n    else {\n        char *data;\n        int sl = strlen( cursor->ns )+1;\n        int limit = 0;\n        mongo_message *mm;\n        if( cursor->limit > 0 )\n            limit = cursor->limit - cursor->seen;\n        mm = mongo_message_create( 16 \n                                   +4 \n                                   +sl\n                                   +4 \n                                   +8 \n                                   , 0, 0, MONGO_OP_GET_MORE );\n        data = &mm->data;\n        data = mongo_data_append32( data, &ZERO );\n        data = mongo_data_append( data, cursor->ns, sl );\n        data = mongo_data_append32( data, &limit );\n        mongo_data_append64( data, &cursor->reply->fields.cursorID );\n        bson_free( cursor->reply );\n        res = mongo_message_send( cursor->conn, mm );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        res = mongo_read_response( cursor->conn, &( cursor->reply ) );\n        if( res != MONGO_OK ) {\n            mongo_cursor_destroy( cursor );\n            return MONGO_ERROR;\n        }\n        cursor->current.data = NULL;\n        cursor->seen += cursor->reply->fields.num;\n        return MONGO_OK;\n    }\n}", "target": 1}
{"code": "      static double mp_normp(_cimg_math_parser& mp) {\n        const unsigned int i_end = (unsigned int)mp.opcode[2];\n        if (i_end==4) return cimg::abs(_mp_arg(3));\n        const double p = (double)mp.opcode[3];\n        double res = 0;\n        for (unsigned int i = 4; i<i_end; ++i)\n          res+=std::pow(cimg::abs(_mp_arg(i)),p);\n        res = std::pow(res,1/p);\n        return res>0?res:0.0;", "target": 0}
{"code": "MagickPrivate MagickBooleanType SyncImagePixelCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  assert(image != (Image *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,MagickTrue,exception);\n  return(cache_info == (CacheInfo *) NULL ? MagickFalse : MagickTrue);\n}", "target": 0}
{"code": "static void read_module(RBuffer *b, ut64 addr, struct minidump_module *module) {\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tr_buf_seek (b, addr, R_BUF_SET);\n\tmodule->base_of_image = r_buf_read_le64 (b);\n\tmodule->size_of_image = r_buf_read_le32 (b);\n\tmodule->check_sum = r_buf_read_le32 (b);\n\tmodule->time_date_stamp = r_buf_read_le32 (b);\n\tmodule->module_name_rva = r_buf_read_le32 (b);\n\tmodule->version_info.dw_signature = r_buf_read_le32 (b);\n\tmodule->version_info.dw_struc_version = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_product_version_ls = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags_mask = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_flags = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_os = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_type = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_subtype = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ms = r_buf_read_le32 (b);\n\tmodule->version_info.dw_file_date_ls = r_buf_read_le32 (b);\n\tmodule->cv_record.data_size = r_buf_read_le32 (b);\n\tmodule->cv_record.rva = r_buf_read_le32 (b);\n\tmodule->misc_record.data_size = r_buf_read_le32 (b);\n\tmodule->misc_record.rva = r_buf_read_le32 (b);\n\tmodule->reserved_0 = r_buf_read_le64 (b);\n\tmodule->reserved_1 = r_buf_read_le64 (b);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n}", "target": 1}
{"code": "static av_cold int xpm_decode_close(AVCodecContext *avctx)\n{\n    XPMDecContext *x = avctx->priv_data;\n    av_freep(&x->pixels);\n    av_freep(&x->buf);\n    x->buf_size = 0;\n    return 0;\n}", "target": 0}
{"code": "static int core_map_to_storage(request_rec *r)\n{\n    int access_status;\n    if ((access_status = ap_directory_walk(r))) {\n        return access_status;\n    }\n    if ((access_status = ap_file_walk(r))) {\n        return access_status;\n    }\n    return OK;\n}", "target": 0}
{"code": "static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int check_ptrace_options(unsigned long data)\n{\n\tif (data & ~(unsigned long)PTRACE_O_MASK)\n\t\treturn -EINVAL;\n\tif (unlikely(data & PTRACE_O_SUSPEND_SECCOMP)) {\n\t\tif (!IS_ENABLED(CONFIG_CHECKPOINT_RESTORE) ||\n\t\t    !IS_ENABLED(CONFIG_SECCOMP))\n\t\t\treturn -EINVAL;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (seccomp_mode(&current->seccomp) != SECCOMP_MODE_DISABLED ||\n\t\t    current->ptrace & PT_SUSPEND_SECCOMP)\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void LIRGenerator::do_NegateOp(NegateOp* x) {\n  LIRItem value(x->x(), this);\n  value.set_destroys_register();\n  value.load_item();\n  LIR_Opr reg = rlock(x);\n  LIR_Opr tmp = LIR_OprFact::illegalOpr;\n#ifdef _LP64\n  if (UseAVX > 2 && !VM_Version::supports_avx512vl()) {\n    if (x->type()->tag() == doubleTag) {\n      tmp = new_register(T_DOUBLE);\n      __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n    }\n    else if (x->type()->tag() == floatTag) {\n      tmp = new_register(T_FLOAT);\n      __ move(LIR_OprFact::floatConst(-0.0), tmp);\n    }\n  }\n#endif\n  __ negate(value.result(), reg, tmp);\n  set_result(x, round_item(reg));\n}", "target": 0}
{"code": "spnego_gss_set_sec_context_option(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t *context_handle,\n\t\tconst gss_OID desired_object,\n\t\tconst gss_buffer_t value)\n{\n\tOM_uint32 ret;\n\tret = gss_set_sec_context_option(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    value);\n\treturn (ret);\n}", "target": 1}
{"code": "struct clock_source *dce100_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "rx_cache_find(const struct rx_header *rxh, const struct ip *ip, int sport,\n\t      int32_t *opcode)\n{\n\tint i;\n\tstruct rx_cache_entry *rxent;\n\tuint32_t clip;\n\tuint32_t sip;\n\tUNALIGNED_MEMCPY(&clip, &ip->ip_dst, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&sip, &ip->ip_src, sizeof(uint32_t));\n\ti = rx_cache_hint;\n\tdo {\n\t\trxent = &rx_cache[i];\n\t\tif (rxent->callnum == EXTRACT_32BITS(&rxh->callNumber) &&\n\t\t    rxent->client.s_addr == clip &&\n\t\t    rxent->server.s_addr == sip &&\n\t\t    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&\n\t\t    rxent->dport == sport) {\n\t\t\trx_cache_hint = i;\n\t\t\t*opcode = rxent->opcode;\n\t\t\treturn(1);\n\t\t}\n\t\tif (++i >= RX_CACHE_SIZE)\n\t\t\ti = 0;\n\t} while (i != rx_cache_hint);\n\treturn(0);\n}", "target": 1}
{"code": "  RectangleRequest(const struct RectangleRequest &req)\n    : Explicit()\n  {\n    memcpy(this,&req,sizeof(struct RectangleRequest));\n    rr_pNext = NULL;\n  }", "target": 1}
{"code": "mm_create(struct mm_master *mmalloc, size_t size)\n{\n\tvoid *address;\n\tstruct mm_master *mm;\n\tif (mmalloc == NULL)\n\t\tmm = xcalloc(1, sizeof(struct mm_master));\n\telse\n\t\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\tmm->mmalloc = mmalloc;\n\taddress = mmap(NULL, size, PROT_WRITE|PROT_READ, MAP_ANON|MAP_SHARED,\n\t    -1, 0);\n\tif (address == MAP_FAILED)\n\t\tfatal(\"mmap(%zu): %s\", size, strerror(errno));\n\tmm->address = address;\n\tmm->size = size;\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\tmm_make_entry(mm, &mm->rb_free, address, size);\n\treturn (mm);\n}", "target": 1}
{"code": "inline bool operator ==(const MaskedIP& l, const MaskedIP& r) {\n  auto shift = std::max((l.v6 ? 128 : 32) - l.prefix,\n\t\t\t(r.v6 ? 128 : 32) - r.prefix);\n  ceph_assert(shift > 0);\n  return (l.addr >> shift) == (r.addr >> shift);\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<_cimg_Ttfloat> get_correlate(const CImg<t>& kernel, const bool boundary_conditions=true,\n                                      const bool is_normalized=false) const {\n      return _correlate(kernel,boundary_conditions,is_normalized,false);", "target": 0}
{"code": "local block_state deflate_fast(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    IPos hash_head;       \n    int bflush;           \n    for (;;) {\n        if (s->lookahead < MIN_LOOKAHEAD) {\n            fill_window(s);\n            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; \n        }\n        hash_head = NIL;\n        if (s->lookahead >= MIN_MATCH) {\n            INSERT_STRING(s, s->strstart, hash_head);\n        }\n        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {\n            s->match_length = longest_match (s, hash_head);\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->match_start, s->match_length);\n            _tr_tally_dist(s, s->strstart - s->match_start,\n                           s->match_length - MIN_MATCH, bflush);\n            s->lookahead -= s->match_length;\n#ifndef FASTEST\n            if (s->match_length <= s->max_insert_length &&\n                s->lookahead >= MIN_MATCH) {\n                s->match_length--; \n                do {\n                    s->strstart++;\n                    INSERT_STRING(s, s->strstart, hash_head);\n                } while (--s->match_length != 0);\n                s->strstart++;\n            } else\n#endif\n            {\n                s->strstart += s->match_length;\n                s->match_length = 0;\n                s->ins_h = s->window[s->strstart];\n                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);\n#if MIN_MATCH != 3\n                Call UPDATE_HASH() MIN_MATCH-3 more times\n#endif\n            }\n        } else {\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "__reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,\n\t\t int type, struct posix_acl *acl)\n{\n\tchar *name;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = reiserfs_posix_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = reiserfs_xattr_set_handle(th, inode, name, value, size, 0);\n\tif (error == -ENODATA) {\n\t\terror = 0;\n\t\tif (type == ACL_TYPE_ACCESS) {\n\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "inline void ImageLoader::crossSiteOrCSPViolationOccurred(\n    AtomicString imageSourceURL) {\n  m_failedLoadURL = imageSourceURL;\n}", "target": 0}
{"code": "static int r_jws_verify_sig_hmac(jws_t * jws, jwk_t * jwk) {\n  unsigned char * sig = r_jws_sign_hmac(jws, jwk);\n  int ret;\n  if (sig != NULL && 0 == o_strcmp((const char *)jws->signature_b64url, (const char *)sig)) {\n    ret = RHN_OK;\n  } else {\n    ret = RHN_ERROR_INVALID;\n  }\n  o_free(sig);\n  return ret;\n}", "target": 1}
{"code": "snmp_api_replace_oid(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  while(oid[i] != ((uint32_t)-1)) {\n    varbind->oid[i] = oid[i];\n    i++;\n  }\n  varbind->oid[i] = ((uint32_t)-1);\n}", "target": 1}
{"code": "comics_check_decompress_support\t(gchar          *mime_type,\n\t\t\t\t ComicsDocument *comics_document,\n\t\t\t\t GError         **error)\n{\n\tif (g_content_type_is_a (mime_type, \"application/x-cbr\") ||\n\t    g_content_type_is_a (mime_type, \"application/x-rar\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_RAR))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/zip\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_ZIP))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_7Z))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-tar\")) {\n\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_TAR))\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Not a comic book MIME type: %s\"),\n\t\t\t     mime_type);\n\t\t\t     return FALSE;\n\t}\n\tg_set_error_literal (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t             _(\"libarchive lacks support for this comic books \"\n\t\t\t     \"compression, please contact your distributor\"));\n\treturn FALSE;\n}", "target": 0}
{"code": "static void GTextFieldSaved(GTextField *gt) {\n    GEvent e;\n    e.type = et_controlevent;\n    e.w = gt->g.base;\n    e.u.control.subtype = et_save;\n    e.u.control.g = &gt->g;\n    if ( gt->g.handle_controlevent != NULL )\n\t(gt->g.handle_controlevent)(&gt->g,&e);\n    else\n\tGDrawPostEvent(&e);\n}", "target": 0}
{"code": "static int ecryptfs_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct file *lower_file = ecryptfs_file_to_lower(file);\n\tif (!lower_file->f_op->mmap)\n\t\treturn -ENODEV;\n\treturn generic_file_mmap(file, vma);\n}", "target": 0}
{"code": "ServerApp::openClientListener(const NetworkAddress& address)\n{\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (args().m_enableCrypto) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n        if (args().check_client_certificates) {\n            security_level = ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED;\n        }\n    }\n    ClientListener* listen = new ClientListener(\n        address,\n        new TCPSocketFactory(m_events, getSocketMultiplexer()),\n        m_events, security_level);\n    m_events->adoptHandler(\n        m_events->forClientListener().connected(), listen,\n        new TMethodEventJob<ServerApp>(\n            this, &ServerApp::handleClientConnected, listen));\n    return listen;\n}", "target": 0}
{"code": "chdlc_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p)\n{\n\tregister u_int length = h->len;\n\tregister u_int caplen = h->caplen;\n\tif (caplen < CHDLC_HDRLEN) {\n\t\tND_PRINT((ndo, \"[|chdlc]\"));\n\t\treturn (caplen);\n\t}\n        return (chdlc_print(ndo, p,length));\n}", "target": 1}
{"code": "static int kvm_ioctl_create_device(struct kvm *kvm,\n\t\t\t\t   struct kvm_create_device *cd)\n{\n\tstruct kvm_device_ops *ops = NULL;\n\tstruct kvm_device *dev;\n\tbool test = cd->flags & KVM_CREATE_DEVICE_TEST;\n\tint ret;\n\tif (cd->type >= ARRAY_SIZE(kvm_device_ops_table))\n\t\treturn -ENODEV;\n\tops = kvm_device_ops_table[cd->type];\n\tif (ops == NULL)\n\t\treturn -ENODEV;\n\tif (test)\n\t\treturn 0;\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->ops = ops;\n\tdev->kvm = kvm;\n\tmutex_lock(&kvm->lock);\n\tret = ops->create(dev, cd->type);\n\tif (ret < 0) {\n\t\tmutex_unlock(&kvm->lock);\n\t\tkfree(dev);\n\t\treturn ret;\n\t}\n\tlist_add(&dev->vm_node, &kvm->devices);\n\tmutex_unlock(&kvm->lock);\n\tif (ops->init)\n\t\tops->init(dev);\n\tkvm_get_kvm(kvm);\n\tret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);\n\tif (ret < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tmutex_lock(&kvm->lock);\n\t\tlist_del(&dev->vm_node);\n\t\tmutex_unlock(&kvm->lock);\n\t\tops->destroy(dev);\n\t\treturn ret;\n\t}\n\tcd->fd = ret;\n\treturn 0;\n}", "target": 0}
{"code": "static void unix_copy_addr(struct msghdr *msg, struct sock *sk)\n{\n\tstruct unix_sock *u = unix_sk(sk);\n\tmsg->msg_namelen = 0;\n\tif (u->addr) {\n\t\tmsg->msg_namelen = u->addr->len;\n\t\tmemcpy(msg->msg_name, u->addr->name, u->addr->len);\n\t}\n}", "target": 1}
{"code": "static int adpt_i2o_activate_hba(adpt_hba* pHba)\n{\n\tint rcode;\n\tif(pHba->initialized ) {\n\t\tif (adpt_i2o_status_get(pHba) < 0) {\n\t\t\tif((rcode = adpt_i2o_reset_hba(pHba)) != 0){\n\t\t\t\tprintk(KERN_WARNING\"%s: Could NOT reset.\\n\", pHba->name);\n\t\t\t\treturn rcode;\n\t\t\t}\n\t\t\tif (adpt_i2o_status_get(pHba) < 0) {\n\t\t\t\tprintk(KERN_INFO \"HBA not responding.\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif(pHba->status_block->iop_state == ADAPTER_STATE_FAULTED) {\n\t\t\tprintk(KERN_CRIT \"%s: hardware fault\\n\", pHba->name);\n\t\t\treturn -1;\n\t\t}\n\t\tif (pHba->status_block->iop_state == ADAPTER_STATE_READY ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_HOLD ||\n\t\t    pHba->status_block->iop_state == ADAPTER_STATE_FAILED) {\n\t\t\tadpt_i2o_reset_hba(pHba);\t\t\t\n\t\t\tif (adpt_i2o_status_get(pHba) < 0 || pHba->status_block->iop_state != ADAPTER_STATE_RESET) {\n\t\t\t\tprintk(KERN_ERR \"%s: Failed to initialize.\\n\", pHba->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif((rcode = adpt_i2o_reset_hba(pHba)) != 0){\n\t\t\tprintk(KERN_WARNING\"%s: Could NOT reset.\\n\", pHba->name);\n\t\t\treturn rcode;\n\t\t}\n\t}\n\tif (adpt_i2o_init_outbound_q(pHba) < 0) {\n\t\treturn -1;\n\t}\n\tif (adpt_i2o_hrt_get(pHba) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int iwl_process_add_sta_resp(struct iwl_priv *priv,\n\t\t\t\t    struct iwl_addsta_cmd *addsta,\n\t\t\t\t    struct iwl_rx_packet *pkt)\n{\n\tu8 sta_id = addsta->sta.sta_id;\n\tunsigned long flags;\n\tint ret = -EIO;\n\tif (pkt->hdr.flags & IWL_CMD_FAILED_MSK) {\n\t\tIWL_ERR(priv, \"Bad return from REPLY_ADD_STA (0x%08X)\\n\",\n\t\t\tpkt->hdr.flags);\n\t\treturn ret;\n\t}\n\tIWL_DEBUG_INFO(priv, \"Processing response for adding station %u\\n\",\n\t\t       sta_id);\n\tspin_lock_irqsave(&priv->shrd->sta_lock, flags);\n\tswitch (pkt->u.add_sta.status) {\n\tcase ADD_STA_SUCCESS_MSK:\n\t\tIWL_DEBUG_INFO(priv, \"REPLY_ADD_STA PASSED\\n\");\n\t\tiwl_sta_ucode_activate(priv, sta_id);\n\t\tret = 0;\n\t\tbreak;\n\tcase ADD_STA_NO_ROOM_IN_TABLE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no room in table.\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tcase ADD_STA_NO_BLOCK_ACK_RESOURCE:\n\t\tIWL_ERR(priv, \"Adding station %d failed, no block ack \"\n\t\t\t\"resource.\\n\", sta_id);\n\t\tbreak;\n\tcase ADD_STA_MODIFY_NON_EXIST_STA:\n\t\tIWL_ERR(priv, \"Attempting to modify non-existing station %d\\n\",\n\t\t\tsta_id);\n\t\tbreak;\n\tdefault:\n\t\tIWL_DEBUG_ASSOC(priv, \"Received REPLY_ADD_STA:(0x%08X)\\n\",\n\t\t\t\tpkt->u.add_sta.status);\n\t\tbreak;\n\t}\n\tIWL_DEBUG_INFO(priv, \"%s station id %u addr %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ?  \"Modified\" : \"Added\",\n\t\t       sta_id, priv->stations[sta_id].sta.sta.addr);\n\tIWL_DEBUG_INFO(priv, \"%s station according to cmd buffer %pM\\n\",\n\t\t       priv->stations[sta_id].sta.mode ==\n\t\t       STA_CONTROL_MODIFY_MSK ? \"Modified\" : \"Added\",\n\t\t       addsta->sta.addr);\n\tspin_unlock_irqrestore(&priv->shrd->sta_lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "rpcap_remoteact_getsock(const char *host, int *error, char *errbuf)\n{\n\tstruct activehosts *temp;\t\t\t\n\tstruct addrinfo hints, *addrinfo, *ai_next;\t\n\tint retval;\n\taddrinfo = NULL;\n\tmemset(&hints, 0, sizeof(struct addrinfo));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\tretval = sock_initaddress(host, NULL, &hints, &addrinfo, errbuf,\n\t    PCAP_ERRBUF_SIZE);\n\tif (retval != 0)\n\t{\n\t\t*error = 1;\n\t\treturn NULL;\n\t}\n\ttemp = activeHosts;\n\twhile (temp)\n\t{\n\t\tai_next = addrinfo;\n\t\twhile (ai_next)\n\t\t{\n\t\t\tif (sock_cmpaddr(&temp->host, (struct sockaddr_storage *) ai_next->ai_addr) == 0)\n\t\t\t{\n\t\t\t\t*error = 0;\n\t\t\t\tfreeaddrinfo(addrinfo);\n\t\t\t\treturn temp;\n\t\t\t}\n\t\t\tai_next = ai_next->ai_next;\n\t\t}\n\t\ttemp = temp->next;\n\t}\n\tif (addrinfo)\n\t\tfreeaddrinfo(addrinfo);\n\t*error = 0;\n\treturn NULL;\n}", "target": 1}
{"code": "pci_emul_dinit(struct vmctx *ctx, struct pci_vdev *dev, char *opts)\n{\n\tint error;\n\tstruct pci_emul_dummy *dummy;\n\tdummy = calloc(1, sizeof(struct pci_emul_dummy));\n\tdev->arg = dummy;\n\tpci_set_cfgdata16(dev, PCIR_DEVICE, 0x0001);\n\tpci_set_cfgdata16(dev, PCIR_VENDOR, 0x10DD);\n\tpci_set_cfgdata8(dev, PCIR_CLASS, 0x02);\n\terror = pci_emul_add_msicap(dev, PCI_EMUL_MSI_MSGS);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 0, PCIBAR_IO, DIOSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 1, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\terror = pci_emul_alloc_bar(dev, 2, PCIBAR_MEM32, DMEMSZ);\n\tassert(error == 0);\n\treturn 0;\n}", "target": 1}
{"code": "static void pcrypt_free(struct crypto_instance *inst)\n{\n\tstruct pcrypt_instance_ctx *ctx = crypto_instance_ctx(inst);\n\tcrypto_drop_aead(&ctx->spawn);\n\tkfree(inst);\n}", "target": 1}
{"code": "void Splash::setOverprintMask(Guint overprintMask, GBool additive) {\n  state->overprintMask = overprintMask;\n  state->overprintAdditive = additive;\n}", "target": 0}
{"code": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    bool off_is_neg)\n{\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\talu_state |= ptr_is_dst_reg ?\n\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\tif (retrieve_ptr_limit(ptr_reg, &alu_limit, opcode, off_is_neg))\n\t\treturn 0;\n\tif (update_alu_sanitation_state(aux, alu_state, alu_limit))\n\t\treturn -EACCES;\ndo_sim:\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg)\n\t\t*dst_reg = tmp;\n\treturn !ret ? -EFAULT : 0;\n}", "target": 0}
{"code": "comics_check_decompress_support\t(gchar          *mime_type,\n\t\t\t\t ComicsDocument *comics_document,\n\t\t\t\t GError         **error)\n{\n\tif (g_content_type_is_a (mime_type, \"application/x-cbr\") ||\n\t    g_content_type_is_a (mime_type, \"application/x-rar\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_RAR))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbz\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/zip\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_ZIP))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cb7\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-7z-compressed\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_7Z))\n\t\t\treturn TRUE;\n\t} else if (g_content_type_is_a (mime_type, \"application/x-cbt\") ||\n\t\t   g_content_type_is_a (mime_type, \"application/x-tar\")) {\n\t\tif (ev_archive_set_archive_type (comics_document->archive, EV_ARCHIVE_TYPE_TAR))\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Not a comic book MIME type: %s\"),\n\t\t\t     mime_type);\n\t\t\t     return FALSE;\n\t}\n\tg_set_error_literal (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"libarchive lacks support for this comic books \"\n\t\t\t     \"compression, please contact your distributor\"));\n\treturn FALSE;\n}", "target": 0}
{"code": "bool Archive::ReadSubData(Array<byte> *UnpData,File *DestFile,bool TestMode)\n{\n  if (BrokenHeader)\n  {\n    uiMsg(UIERROR_SUBHEADERBROKEN,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return false;\n  }\n  if (SubHead.Method>5 || SubHead.UnpVer>(Format==RARFMT50 ? VER_UNPACK5:VER_UNPACK))\n  {\n    uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n    return false;\n  }\n  if (SubHead.PackSize==0 && !SubHead.SplitAfter)\n    return true;\n  SubDataIO.Init();\n  Unpack Unpack(&SubDataIO);\n  Unpack.Init(SubHead.WinSize,false);\n  if (DestFile==NULL)\n  {\n    if (SubHead.UnpSize>0x1000000)\n    {\n      uiMsg(UIERROR_SUBHEADERUNKNOWN,FileName);\n      return false;\n    }\n    if (UnpData==NULL)\n      SubDataIO.SetTestMode(true);\n    else\n    {\n      UnpData->Alloc((size_t)SubHead.UnpSize);\n      SubDataIO.SetUnpackToMemory(&(*UnpData)[0],(uint)SubHead.UnpSize);\n    }\n  }\n  if (SubHead.Encrypted)\n    if (Cmd->Password.IsSet())\n      SubDataIO.SetEncryption(false,SubHead.CryptMethod,&Cmd->Password,\n                SubHead.SaltSet ? SubHead.Salt:NULL,SubHead.InitV,\n                SubHead.Lg2Count,SubHead.HashKey,SubHead.PswCheck);\n    else\n      return false;\n  SubDataIO.UnpHash.Init(SubHead.FileHash.Type,1);\n  SubDataIO.SetPackedSizeToRead(SubHead.PackSize);\n  SubDataIO.EnableShowProgress(false);\n  SubDataIO.SetFiles(this,DestFile);\n  SubDataIO.SetTestMode(TestMode);\n  SubDataIO.UnpVolume=SubHead.SplitAfter;\n  SubDataIO.SetSubHeader(&SubHead,NULL);\n  Unpack.SetDestSize(SubHead.UnpSize);\n  if (SubHead.Method==0)\n    CmdExtract::UnstoreFile(SubDataIO,SubHead.UnpSize);\n  else\n    Unpack.DoUnpack(SubHead.UnpVer,false);\n  if (!SubDataIO.UnpHash.Cmp(&SubHead.FileHash,SubHead.UseHashKey ? SubHead.HashKey:NULL))\n  {\n    uiMsg(UIERROR_SUBHEADERDATABROKEN,FileName,SubHead.FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    if (UnpData!=NULL)\n      UnpData->Reset();\n    return false;\n  }\n  return true;\n}", "target": 1}
{"code": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tkey_check(key);\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME_T_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tdown_write(&key->sem);\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}", "target": 1}
{"code": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\task->private = ctx;\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\tsk->sk_destruct = skcipher_sock_destruct;\n\treturn 0;\n}", "target": 1}
{"code": "int removeifnotchanged(const file_t *file, char **errorstring)\n{\n  int result;\n  struct stat st;\n  static char *filechanged = \"File contents changed during processing\";\n  static char *unknownerror = \"Unknown error\";\n  stat(file->d_name, &st);\n  if (file->device != st.st_dev ||\n      file->inode != st.st_ino ||\n      file->ctime != st.st_ctime ||\n      file->mtime != st.st_mtime ||\n      file->size != st.st_size)\n  {\n    if (errorstring != 0)\n        *errorstring = filechanged;\n    return -2;\n  }\n  else\n  {\n    result = remove(file->d_name);\n    if (result != 0 && errorstring != 0)\n    {\n      *errorstring = strerror(errno);\n      if (*errorstring == 0)\n        *errorstring = unknownerror;\n    }\n    return result;\n  }\n}", "target": 0}
{"code": "log2vis_unicode (PyObject * unicode, FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *visual = NULL;\t\n\tPyObject *result = NULL;\t\n\tint length = PyUnicode_GET_SIZE (unicode);\n\tlogical = PyUnicode_AsUTF8String (unicode);\n\tif (logical == NULL)\n\t\tgoto cleanup;\n\tvisual = log2vis_utf8 (logical, length, base_direction, clean, reordernsm);\n\tif (visual == NULL)\n\t\tgoto cleanup;\n\tresult = PyUnicode_DecodeUTF8 (PyString_AS_STRING (visual),\n\t\t\t\t       PyString_GET_SIZE (visual), \"strict\");\n      cleanup:\n\tPy_XDECREF (logical);\n\tPy_XDECREF (visual);\n\treturn result;\n}", "target": 1}
{"code": "static int ext4_end_io_nolock(ext4_io_end_t *io)\n{\n\tstruct inode *inode = io->inode;\n\tloff_t offset = io->offset;\n\tssize_t size = io->size;\n\tint ret = 0;\n\text4_debug(\"ext4_end_io_nolock: io 0x%p from inode %lu,list->next 0x%p,\"\n\t\t   \"list->prev 0x%p\\n\",\n\t           io, inode->i_ino, io->list.next, io->list.prev);\n\tif (list_empty(&io->list))\n\t\treturn ret;\n\tif (io->flag != EXT4_IO_UNWRITTEN)\n\t\treturn ret;\n\tif (offset + size <= i_size_read(inode))\n\t\tret = ext4_convert_unwritten_extents(inode, offset, size);\n\tif (ret < 0) {\n\t\tprintk(KERN_EMERG \"%s: failed to convert unwritten\"\n\t\t\t\"extents to written extents, error is %d\"\n\t\t\t\" io is still on inode %lu aio dio list\\n\",\n                       __func__, ret, inode->i_ino);\n\t\treturn ret;\n\t}\n\tio->flag = 0;\n\treturn ret;\n}", "target": 1}
{"code": "x509stack_pop(struct cert_stack *stack)\n{\n\tX509 *cert;\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo;\n\tcert = sk_X509_pop(stack->x509s);\n\tif (cert == NULL)\n\t\tpr_crit(\"Attempted to pop empty X509 stack\");\n\tX509_free(cert);\n\tmeta = SLIST_FIRST(&stack->metas);\n\tif (meta == NULL)\n\t\tpr_crit(\"Attempted to pop empty metadata stack\");\n\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\tmeta_destroy(meta);\n\trepo = SLIST_FIRST(&stack->levels);\n\tif (repo == NULL)\n\t\tpr_crit(\"Attempted to pop empty repo level stack\");\n\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n}", "target": 1}
{"code": "static void *CFRdbLoad(RedisModuleIO *io, int encver) {\n    if (encver > CF_MIN_EXPANSION_VERSION) {\n        return NULL;\n    }\n    CuckooFilter *cf = RedisModule_Calloc(1, sizeof(*cf));\n    cf->numFilters = RedisModule_LoadUnsigned(io);\n    cf->numBuckets = RedisModule_LoadUnsigned(io);\n    cf->numItems = RedisModule_LoadUnsigned(io);\n    if (encver < CF_MIN_EXPANSION_VERSION) { \n        cf->numDeletes = 0;                  \n        cf->bucketSize = CF_DEFAULT_BUCKETSIZE;\n        cf->maxIterations = CF_MAX_ITERATIONS;\n        cf->expansion = CF_DEFAULT_EXPANSION;\n    } else {\n        cf->numDeletes = RedisModule_LoadUnsigned(io);\n        cf->bucketSize = RedisModule_LoadUnsigned(io);\n        cf->maxIterations = RedisModule_LoadUnsigned(io);\n        cf->expansion = RedisModule_LoadUnsigned(io);\n    }\n    cf->filters = RedisModule_Calloc(cf->numFilters, sizeof(*cf->filters));\n    for (size_t ii = 0, exp = 1; ii < cf->numFilters; ++ii, exp *= cf->expansion) {\n        cf->filters[ii].bucketSize = cf->bucketSize;\n        if (encver < CF_MIN_EXPANSION_VERSION) {\n            cf->filters[ii].numBuckets = cf->numBuckets;\n        } else {\n            cf->filters[ii].numBuckets = RedisModule_LoadUnsigned(io);\n        }\n        size_t lenDummy = 0;\n        cf->filters[ii].data = (MyCuckooBucket *)RedisModule_LoadStringBuffer(io, &lenDummy);\n        assert(cf->filters[ii].data != NULL && lenDummy == cf->filters[ii].bucketSize *\n                                                               cf->filters[ii].numBuckets *\n                                                               sizeof(*cf->filters[ii].data));\n    }\n    return cf;\n}", "target": 1}
{"code": "SPL_METHOD(Array, valid)\n{\n\tzval *object = getThis();\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\tHashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tif (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_BOOL(zend_hash_has_more_elements_ex(aht, &intern->pos) == SUCCESS);\n\t}\n}", "target": 0}
{"code": "dissect_spoolss_uint16uni(tvbuff_t *tvb, int offset, packet_info *pinfo _U_,\n\t\t\t  proto_tree *tree, guint8 *drep _U_, char **data,\n\t\t\t  int hf_name)\n{\n\tgint len, remaining;\n\tchar *text;\n\tif (offset % 2)\n\t\toffset += 2 - (offset % 2);\n\tremaining = tvb_captured_length_remaining(tvb, offset);\n\tif (remaining <= 0) {\n\t\tif (data)\n\t\t\t*data = g_strdup(\"\");\n\t\treturn offset;\n\t}\n\ttext = tvb_get_string_enc(NULL, tvb, offset, remaining, ENC_UTF_16|ENC_LITTLE_ENDIAN);\n\tlen = (int)strlen(text);\n\tproto_tree_add_string(tree, hf_name, tvb, offset, len * 2, text);\n\tif (data)\n\t\t*data = text;\n\telse\n\t\tg_free(text);\n\treturn offset + (len + 1) * 2;\n}", "target": 1}
{"code": " */\nstatic inline zval *add_next_index_object(zval *arg, zval *tmp)\n{\n\tHashTable *symtable;\n\tif (Z_TYPE_P(arg) == IS_OBJECT) {\n\t\tsymtable = Z_OBJPROP_P(arg);\n\t} else {\n\t\tsymtable = Z_ARRVAL_P(arg);\n\t}\n\treturn zend_hash_next_index_insert(symtable, tmp);", "target": 0}
{"code": "int sldns_str2wire_nsap_buf(const char* str, uint8_t* rd, size_t* len)\n{\n\tconst char* s = str;\n\tsize_t slen;\n\tsize_t dlen = 0; \n\tif (s[0] != '0' || s[1] != 'x')\n\t\treturn LDNS_WIREPARSE_ERR_INVALID_STR;\n\ts += 2;\n\tslen = strlen(s);\n\tif(slen > LDNS_MAX_RDFLEN*2)\n\t\treturn LDNS_WIREPARSE_ERR_LABEL_OVERFLOW;\n\twhile(*s) {\n\t\tif(isspace((unsigned char)*s) || *s == '.') {\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\t\tif(!isxdigit((unsigned char)*s))\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_SYNTAX_HEX, s-str);\n\t\tif(*len < dlen/2 + 1)\n\t\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_BUFFER_TOO_SMALL,\n\t\t\t\ts-str);\n\t\tif((dlen&1)==0)\n\t\t\trd[dlen/2] = (uint8_t)sldns_hexdigit_to_int(*s++) * 16;\n\t\telse\trd[dlen/2] += sldns_hexdigit_to_int(*s++);\n\t\tdlen++;\n\t}\n\tif((dlen&1)!=0)\n\t\treturn RET_ERR(LDNS_WIREPARSE_ERR_SYNTAX_HEX, s-str);\n\t*len = dlen/2;\n\treturn LDNS_WIREPARSE_ERR_OK;\n}", "target": 0}
{"code": "_blackbox_vlogger(int32_t target,\n\t\t  struct qb_log_callsite *cs, struct timespec *timestamp, va_list ap)\n{\n\tsize_t max_size;\n\tsize_t actual_size;\n\tuint32_t fn_size;\n\tchar *chunk;\n\tchar *msg_len_pt;\n\tuint32_t msg_len;\n\tstruct qb_log_target *t = qb_log_target_get(target);\n\tif (t->instance == NULL) {\n\t\treturn;\n\t}\n\tfn_size = strlen(cs->function) + 1;\n\tactual_size = 4 * sizeof(uint32_t) + sizeof(uint8_t) + fn_size + sizeof(struct timespec);\n\tmax_size = actual_size + t->max_line_length;\n\tchunk = qb_rb_chunk_alloc(t->instance, max_size);\n\tif (chunk == NULL) {\n\t\tqb_util_perror(LOG_ERR, \"Blackbox allocation error, aborting blackbox log %s\", t->filename);\n\t\tqb_rb_close(qb_rb_lastref_and_ret(\n\t\t\t(struct qb_ringbuffer_s **) &t->instance\n\t\t));\n\t\treturn;\n\t}\n\tmemcpy(chunk, &cs->lineno, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, &cs->tags, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, &cs->priority, sizeof(uint8_t));\n\tchunk += sizeof(uint8_t);\n\tmemcpy(chunk, &fn_size, sizeof(uint32_t));\n\tchunk += sizeof(uint32_t);\n\tmemcpy(chunk, cs->function, fn_size);\n\tchunk += fn_size;\n\tmemcpy(chunk, timestamp, sizeof(struct timespec));\n\tchunk += sizeof(struct timespec);\n\tmsg_len_pt = chunk;\n\tchunk += sizeof(uint32_t);\n\tmsg_len = qb_vsnprintf_serialize(chunk, max_size, cs->format, ap);\n\tif (msg_len >= max_size) {\n\t    chunk = msg_len_pt + sizeof(uint32_t); \n\t    msg_len = qb_vsnprintf_serialize(chunk, QB_LOG_MAX_LEN,\n\t\t\"Log message too long to be stored in the blackbox.  \"\\\n\t\t\"Maximum is QB_LOG_MAX_LEN\" , ap);\n\t}\n\tactual_size += msg_len;\n\tmemcpy(msg_len_pt, &msg_len, sizeof(uint32_t));\n\t(void)qb_rb_chunk_commit(t->instance, actual_size);\n}", "target": 1}
{"code": "int mesg_make_query (u_char *qname, uint16_t qtype, uint16_t qclass,\n\t\t     uint32_t id, int rd, u_char *buf, int buflen) {\n\tchar *fn = \"mesg_make_query()\";\n\tu_char *ucp;\n\tint i, written_len;\n\tMesg_Hdr *hdr;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: (qtype: %s, id: %d): start\", fn,\n\t\t\tstring_rtype (qtype), id);\n\thdr = (Mesg_Hdr *) buf;\n\thdr->id = id;\n\thdr->opcode = OP_QUERY;\n\thdr->rcode = RC_OK;\n\thdr->rd = rd;\n\thdr->qr = hdr->aa = hdr->tc = hdr->ra = hdr->zero = 0;\n\thdr->qdcnt = ntohs (1);\n\thdr->ancnt = hdr->nscnt = hdr->arcnt = ntohs (0);\n\twritten_len = sizeof (Mesg_Hdr);\n\tucp = (u_char *) (hdr + 1);\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qname offset = %zd\", fn, ucp - buf);\n\ti = dname_copy (qname, ucp, buflen - written_len);\n\tif (i < 0)\n\t\treturn -1;\n\twritten_len += i;\n\tucp += i;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qtype/qclass offset = %zd\",\n\t\t\tfn, ucp - buf);\n\twritten_len += sizeof (uint16_t) * 2;\n\tif (written_len > buflen)\n\t\treturn -1;\n\tPUTSHORT (qtype, ucp);\n\tPUTSHORT (qclass, ucp);\n\treturn written_len;\n}", "target": 1}
{"code": "spnego_gss_wrap_size_limit(\n\tOM_uint32\t*minor_status,\n\tconst gss_ctx_id_t context_handle,\n\tint\t\tconf_req_flag,\n\tgss_qop_t\tqop_req,\n\tOM_uint32\treq_output_size,\n\tOM_uint32\t*max_input_size)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_size_limit(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tconf_req_flag,\n\t\t\t\tqop_req,\n\t\t\t\treq_output_size,\n\t\t\t\tmax_input_size);\n\treturn (ret);\n}", "target": 1}
{"code": "static HashTable *spl_array_get_gc(zval *object, zval ***gc_data, int *gc_data_count TSRMLS_DC) \n{\n\tspl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);\n\t*gc_data = &intern->array;\n\t*gc_data_count = 1;\n\treturn zend_std_get_properties(object);\n}", "target": 0}
{"code": "    }\n    template<typename t>\n    const T& max_min(t& min_val) const {\n      if (is_empty())\n        throw CImgInstanceException(_cimglist_instance\n                                    \"max_min(): Empty instance.\",\n                                    cimglist_instance);\n      const T *ptr_max = _data->_data;\n      T min_value = *ptr_max, max_value = min_value;\n      cimglist_for(*this,l) {\n        const CImg<T>& img = _data[l];\n        cimg_for(img,ptrs,T) {\n          const T val = *ptrs;\n          if (val>max_value) { max_value = val; ptr_max = ptrs; }\n          if (val<min_value) min_value = val;\n        }", "target": 0}
{"code": "static int validate_code_challenge(json_t * j_result_code, const char * code_verifier) {\n  int ret;\n  unsigned char code_verifier_hash[32] = {0}, code_verifier_hash_b64[64] = {0};\n  size_t code_verifier_hash_len = 32, code_verifier_hash_b64_len = 0;\n  gnutls_datum_t key_data;\n  if (!json_string_null_or_empty(json_object_get(j_result_code, \"code_challenge\"))) {\n    if (is_pkce_char_valid(code_verifier)) {\n      if (0 == o_strncmp(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX, json_string_value(json_object_get(j_result_code, \"code_challenge\")), o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX))) {\n        key_data.data = (unsigned char *)code_verifier;\n        key_data.size = (unsigned int)o_strlen(code_verifier);\n        if (gnutls_fingerprint(GNUTLS_DIG_SHA256, &key_data, code_verifier_hash, &code_verifier_hash_len) == GNUTLS_E_SUCCESS) {\n          if (o_base64url_encode(code_verifier_hash, code_verifier_hash_len, code_verifier_hash_b64, &code_verifier_hash_b64_len)) {\n            code_verifier_hash_b64[code_verifier_hash_b64_len] = '\\0';\n            if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\"))+o_strlen(GLEWLWYD_CODE_CHALLENGE_S256_PREFIX), (const char *)code_verifier_hash_b64)) {\n              ret = G_OK;\n            } else {\n              ret = G_ERROR_UNAUTHORIZED;\n            }\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"validate_code_challenge - Error o_base64url_encode\");\n            ret = G_ERROR;\n          }\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"validate_code_challenge - Error gnutls_fingerprint\");\n          ret = G_ERROR;\n        }\n      } else {\n        if (0 == o_strcmp(json_string_value(json_object_get(j_result_code, \"code_challenge\")), code_verifier)) {\n          ret = G_OK;\n        } else {\n          ret = G_ERROR_PARAM;\n        }\n      }\n    } else {\n      ret = G_ERROR_PARAM;\n    }\n  } else {\n    ret = G_OK;\n  }\n  return ret;\n}", "target": 1}
{"code": "int afGetFileFormat (AFfilehandle file, int *version)\n{\n\tif (!_af_filehandle_ok(file))\n\t\treturn -1;\n\tif (version != NULL)\n\t{\n\t\tif (_af_units[file->fileFormat].getversion)\n\t\t\t*version = _af_units[file->fileFormat].getversion(file);\n\t\telse\n\t\t\t*version = 0;\n\t}\n\treturn file->fileFormat;\n}", "target": 0}
{"code": "unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {\n    zl = zrealloc(zl,len);\n    ZIPLIST_BYTES(zl) = intrev32ifbe(len);\n    zl[len-1] = ZIP_END;\n    return zl;\n}", "target": 1}
{"code": "static int set_registers(rtl8150_t * dev, u16 indx, u16 size, void *data)\n{\n\treturn usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),\n\t\t\t       RTL8150_REQ_SET_REGS, RTL8150_REQT_WRITE,\n\t\t\t       indx, 0, data, size, 500);\n}", "target": 1}
{"code": "static void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n    pj_scan_get_newline(scanner);\n}", "target": 1}
{"code": "void Filter::onDownstreamEvent(Network::ConnectionEvent event) {\n  if (event == Network::ConnectionEvent::LocalClose ||\n      event == Network::ConnectionEvent::RemoteClose) {\n    downstream_closed_ = true;\n  }\n  ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),\n                 static_cast<int>(event), upstream_ == nullptr);\n  if (upstream_) {\n    Tcp::ConnectionPool::ConnectionDataPtr conn_data(upstream_->onDownstreamEvent(event));\n    if (conn_data != nullptr &&\n        conn_data->connection().state() != Network::Connection::State::Closed) {\n      config_->drainManager().add(config_->sharedConfig(), std::move(conn_data),\n                                  std::move(upstream_callbacks_), std::move(idle_timer_),\n                                  read_callbacks_->upstreamHost());\n    }\n    if (event != Network::ConnectionEvent::Connected) {\n      upstream_.reset();\n      disableIdleTimer();\n    }\n  }\n  if (generic_conn_pool_) {\n    if (event == Network::ConnectionEvent::LocalClose ||\n        event == Network::ConnectionEvent::RemoteClose) {\n      generic_conn_pool_.reset();\n    }\n  }\n}", "target": 0}
{"code": "static void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "        int          GetS32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            if ( nRes & 0x80000000 )\n                nRes |= ~0xffffffff;\n            return nRes;\n        }", "target": 1}
{"code": "int db__open(struct mosquitto__config *config)\n{\n\tstruct mosquitto__subhier *subhier;\n\tif(!config) return MOSQ_ERR_INVAL;\n\tdb.last_db_id = 0;\n\tdb.contexts_by_id = NULL;\n\tdb.contexts_by_sock = NULL;\n\tdb.contexts_for_free = NULL;\n#ifdef WITH_BRIDGE\n\tdb.bridges = NULL;\n\tdb.bridge_count = 0;\n#endif\n\tdb.clientid_index_hash = NULL;\n\tdb.subs = NULL;\n\tsubhier = sub__add_hier_entry(NULL, &db.subs, \"\", 0);\n\tif(!subhier) return MOSQ_ERR_NOMEM;\n\tsubhier = sub__add_hier_entry(NULL, &db.subs, \"$SYS\", (uint16_t)strlen(\"$SYS\"));\n\tif(!subhier) return MOSQ_ERR_NOMEM;\n\tretain__init();\n\tdb.config->security_options.unpwd = NULL;\n#ifdef WITH_PERSISTENCE\n\tif(persist__restore()) return 1;\n#endif\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "static void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINMEDIA;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &med->desc.media);\n    pj_scan_get_char(scanner);\n    pj_scan_get(scanner, &cs_token, &str);\n    med->desc.port = (unsigned short)pj_strtoul(&str);\n    if (*scanner->curptr == '/') {\n\tpj_scan_get_char(scanner);\n\tpj_scan_get(scanner, &cs_token, &str);\n\tmed->desc.port_count = pj_strtoul(&str);\n    } else {\n\tmed->desc.port_count = 0;\n    }\n    if (pj_scan_get_char(scanner) != ' ') {\n\tPJ_THROW(SYNTAX_ERROR);\n    }\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &med->desc.transport);\n    med->desc.fmt_count = 0;\n    while (*scanner->curptr == ' ') {\n\tpj_str_t fmt;\n\tpj_scan_get_char(scanner);\n\tif ((*scanner->curptr == '\\r') || (*scanner->curptr == '\\n'))\n\t\tbreak;\n\tpj_scan_get(scanner, &cs_token, &fmt);\n\tif (med->desc.fmt_count < PJMEDIA_MAX_SDP_FMT)\n\t    med->desc.fmt[med->desc.fmt_count++] = fmt;\n\telse\n\t    PJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY, \n\t\t         \"Error adding SDP media format %.*s, \"\n\t\t\t \"format is ignored\",\n\t\t\t (int)fmt.slen, fmt.ptr));\n    }\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "        int          GetU16BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 1 >= m_nLen)\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            return nRes;\n        }", "target": 1}
{"code": "MONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i ) {\n    int ds;\n    if ( i->first ) {\n        i->first = 0;\n        return ( bson_type )( *i->cur );\n    }\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_EOO:\n        return BSON_EOO; \n    case BSON_UNDEFINED:\n    case BSON_NULL:\n        ds = 0;\n        break;\n    case BSON_BOOL:\n        ds = 1;\n        break;\n    case BSON_INT:\n        ds = 4;\n        break;\n    case BSON_LONG:\n    case BSON_DOUBLE:\n    case BSON_TIMESTAMP:\n    case BSON_DATE:\n        ds = 8;\n        break;\n    case BSON_OID:\n        ds = 12;\n        break;\n    case BSON_STRING:\n    case BSON_SYMBOL:\n    case BSON_CODE:\n        ds = 4 + bson_iterator_int_raw( i );\n        break;\n    case BSON_BINDATA:\n        ds = 5 + bson_iterator_int_raw( i );\n        break;\n    case BSON_OBJECT:\n    case BSON_ARRAY:\n    case BSON_CODEWSCOPE:\n        ds = bson_iterator_int_raw( i );\n        break;\n    case BSON_DBREF:\n        ds = 4+12 + bson_iterator_int_raw( i );\n        break;\n    case BSON_REGEX: {\n        const char *s = bson_iterator_value( i );\n        const char *p = s;\n        p += strlen( p )+1;\n        p += strlen( p )+1;\n        ds = p-s;\n        break;\n    }\n    default: {\n        char msg[] = \"unknown type: 000000000000\";\n        bson_numstr( msg+14, ( unsigned )( i->cur[0] ) );\n        bson_fatal_msg( 0, msg );\n        return 0;\n    }\n    }\n    i->cur += 1 + strlen( i->cur + 1 ) + 1 + ds;\n    return ( bson_type )( *i->cur );\n}", "target": 1}
{"code": "void WasmBinaryBuilder::requireFunctionContext(const char* error) {\n  if (!currFunction) {\n    throwError(std::string(\"in a non-function context: \") + error);\n  }\n}", "target": 0}
{"code": "void AsfVideo::fileProperties() {\n  DataBuf FileIddBuf = io_->read(GUID);\n  xmpData()[\"Xmp.video.FileID\"] = GUIDTag(FileIddBuf.data()).to_string();\n  xmpData()[\"Xmp.video.FileLength\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.CreationDate\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.DataPackets\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.duration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.SendDuration\"] = readQWORDTag(io_);\n  xmpData()[\"Xmp.video.Preroll\"] = readQWORDTag(io_);\n  io_->seek(io_->tell() + DWORD + DWORD + DWORD,\n            BasicIo::beg);  \n  xmpData()[\"Xmp.video.MaxBitRate\"] = readDWORDTag(io_);\n}  ", "target": 1}
{"code": "static void HeaderMapImplGetByteSize(benchmark::State& state) {\n  HeaderMapImpl headers;\n  addDummyHeaders(headers, state.range(0));\n  uint64_t size = 0;\n  for (auto _ : state) {\n    size += headers.byteSize();\n  }\n  benchmark::DoNotOptimize(size);\n}", "target": 1}
{"code": "void AV1_RewriteESDescriptorEx(GF_MPEGVisualSampleEntryBox *av1, GF_MediaBox *mdia)\n{\n\tGF_BitRateBox *btrt = gf_isom_sample_entry_get_bitrate((GF_SampleEntryBox *)av1, GF_FALSE);\n\tif (av1->emul_esd) gf_odf_desc_del((GF_Descriptor *)av1->emul_esd);\n\tav1->emul_esd = gf_odf_desc_esd_new(2);\n\tav1->emul_esd->decoderConfig->streamType = GF_STREAM_VISUAL;\n\tav1->emul_esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;\n\tif (btrt) {\n\t\tav1->emul_esd->decoderConfig->bufferSizeDB = btrt->bufferSizeDB;\n\t\tav1->emul_esd->decoderConfig->avgBitrate = btrt->avgBitrate;\n\t\tav1->emul_esd->decoderConfig->maxBitrate = btrt->maxBitrate;\n\t}\n\tif (av1->av1_config) {\n\t\tGF_AV1Config *av1_cfg = AV1_DuplicateConfig(av1->av1_config->config);\n\t\tif (av1_cfg) {\n\t\t\tgf_odf_av1_cfg_write(av1_cfg, &av1->emul_esd->decoderConfig->decoderSpecificInfo->data, &av1->emul_esd->decoderConfig->decoderSpecificInfo->dataLength);\n\t\t\tgf_odf_av1_cfg_del(av1_cfg);\n\t\t}\n\t}\n}", "target": 1}
{"code": "count_new_keys(int n_key_data, krb5_key_data *key_data)\n{\n    int n;\n    for (n = 1; n < n_key_data; n++) {\n        if (key_data[n - 1].key_data_kvno != key_data[n].key_data_kvno)\n            return n;\n    }\n    return n_key_data;\n}", "target": 0}
{"code": "TypedValue HHVM_FUNCTION(array_reverse,\n                         ArrayArg input,\n                         bool preserve_keys ) {\n  ArrNR arrNR(input.get());\n  const Array& arr = arrNR.asArray();\n  return tvReturn(ArrayUtil::Reverse(arr, preserve_keys));\n}", "target": 0}
{"code": "Eina_Bool ewk_view_stop(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_stop(smartData->main_frame);\n}", "target": 0}
{"code": "GopherStateData::DelayAwareRead(GopherStateData *gopherState)\n{\n    const auto &conn = gopherState->serverConn;\n    if (!Comm::IsConnOpen(conn) || fd_table[conn->fd].closing()) {\n        debugs(10, 3, \"will not read from \" << conn);\n        return;\n    }\n    const auto amountToRead = gopherState->entry->bytesWanted(Range<size_t>(0, BUFSIZ));\n    if (amountToRead <= 0) {\n        AsyncCall::Pointer delayCall = asyncCall(10, 3, \"GopherStateData::DelayAwareRead\",\n                                       cbdataDialer(&GopherStateData::DelayAwareRead, gopherState));\n        gopherState->entry->mem().delayRead(delayCall);\n        return;\n    }\n    AsyncCall::Pointer readCall = commCbCall(5, 5, \"gopherReadReply\", CommIoCbPtrFun(gopherReadReply, gopherState));\n    comm_read(conn, gopherState->replybuf, amountToRead, readCall);\n}", "target": 1}
{"code": "case_map(OnigCaseFoldType* flagP, const OnigUChar** pp,\n\t const OnigUChar* end, OnigUChar* to, OnigUChar* to_end,\n\t const struct OnigEncodingTypeST* enc)\n{\n  OnigCodePoint code;\n  OnigUChar *to_start = to;\n  OnigCaseFoldType flags = *flagP;\n  while (*pp < end && to < to_end) {\n    code = *(*pp)++;\n    if (code == SHARP_s) {\n      if (flags & ONIGENC_CASE_UPCASE) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 'S';\n\tcode = (flags & ONIGENC_CASE_TITLECASE) ? 's' : 'S';\n      }\n      else if (flags & ONIGENC_CASE_FOLD) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\t*to++ = 's';\n\tcode = 's';\n      }\n    }\n    else if ((EncISO_8859_2_CtypeTable[code] & BIT_CTYPE_UPPER)\n\t     && (flags & (ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_FOLD))) {\n      flags |= ONIGENC_CASE_MODIFIED;\n      code = ENC_ISO_8859_2_TO_LOWER_CASE(code);\n    }\n    else if ((EncISO_8859_2_CtypeTable[code] & BIT_CTYPE_LOWER)\n       && (flags & ONIGENC_CASE_UPCASE)) {\n      if (code >= 0xB1 && code <= 0xBF) {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode -= 0x10;\n      }\n      else {\n\tflags |= ONIGENC_CASE_MODIFIED;\n\tcode -= 0x20;\n      }\n    }\n    *to++ = code;\n    if (flags & ONIGENC_CASE_TITLECASE)  \n      flags ^= (ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE | ONIGENC_CASE_TITLECASE);\n  }\n  *flagP = flags;\n  return (int )(to - to_start);\n}", "target": 0}
{"code": "void vlan_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n\tdev->tx_queue_len\t= 0;\n\tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}", "target": 1}
{"code": "snmp_api_set_string(snmp_varbind_t *varbind, uint32_t *oid, char *string)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OCTET_STRING;\n  varbind->value.string.string = string;\n  varbind->value.string.length = strlen(string);\n}", "target": 1}
{"code": "void RenderView::OnFindReplyAck() {\n  if (queued_find_reply_message_.get()) {\n    Send(queued_find_reply_message_.release());\n  }\n}", "target": 0}
{"code": "int NCR_IsSyncPeer(NCR_Instance inst)\n{\n  return SRC_IsSyncPeer(inst->source);\n}", "target": 0}
{"code": "int sqlite3ExpandSubquery(Parse *pParse, struct SrcList_item *pFrom){\n  Select *pSel = pFrom->pSelect;\n  Table *pTab;\n  assert( pSel );\n  pFrom->pTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));\n  if( pTab==0 ) return SQLITE_NOMEM;\n  pTab->nTabRef = 1;\n  if( pFrom->zAlias ){\n    pTab->zName = sqlite3DbStrDup(pParse->db, pFrom->zAlias);\n  }else{\n    pTab->zName = sqlite3MPrintf(pParse->db, \"subquery_%u\", pSel->selId);\n  }\n  while( pSel->pPrior ){ pSel = pSel->pPrior; }\n  sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);\n  pTab->iPKey = -1;\n  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n  pTab->tabFlags |= TF_Ephemeral;\n  return pParse->nErr ? SQLITE_ERROR : SQLITE_OK;\n}", "target": 0}
{"code": "TEST_F(SecretManagerImplTest, DeprecatedSanMatcher) {\n  envoy::extensions::transport_sockets::tls::v3::Secret secret_config;\n  const std::string yaml =\n      R\"EOF(\n      name: \"abc.com\"\n      validation_context:\n        trusted_ca: { filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\" }\n        allow_expired_certificate: true\n        match_subject_alt_names:\n          exact: \"example.foo\"\n      )EOF\";\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml), secret_config);\n  std::unique_ptr<SecretManager> secret_manager(new SecretManagerImpl(config_tracker_));\n  secret_manager->addStaticSecret(secret_config);\n  ASSERT_EQ(secret_manager->findStaticCertificateValidationContextProvider(\"undefined\"), nullptr);\n  ASSERT_NE(secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\"), nullptr);\n  Ssl::CertificateValidationContextConfigImpl cvc_config(\n      *secret_manager->findStaticCertificateValidationContextProvider(\"abc.com\")->secret(), *api_);\n  EXPECT_EQ(cvc_config.subjectAltNameMatchers().size(), 4);\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[0].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n            cvc_config.subjectAltNameMatchers()[0].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[1].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n            cvc_config.subjectAltNameMatchers()[1].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[2].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n            cvc_config.subjectAltNameMatchers()[2].san_type());\n  EXPECT_EQ(\"example.foo\", cvc_config.subjectAltNameMatchers()[3].matcher().exact());\n  EXPECT_EQ(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS,\n            cvc_config.subjectAltNameMatchers()[3].san_type());\n}", "target": 0}
{"code": "static int crypto_shash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tstruct shash_alg *salg = __crypto_shash_alg(alg);\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"shash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = salg->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "queryin(char *buf)\n{\n\tQPRS_STATE\tstate;\n\tint32\t\ti;\n\tltxtquery  *query;\n\tint32\t\tcommonlen;\n\tITEM\t   *ptr;\n\tNODE\t   *tmp;\n\tint32\t\tpos = 0;\n#ifdef BS_DEBUG\n\tchar\t\tpbuf[16384],\n\t\t\t   *cur;\n#endif\n\tstate.buf = buf;\n\tstate.state = WAITOPERAND;\n\tstate.count = 0;\n\tstate.num = 0;\n\tstate.str = NULL;\n\tstate.sumlen = 0;\n\tstate.lenop = 64;\n\tstate.curop = state.op = (char *) palloc(state.lenop);\n\t*(state.curop) = '\\0';\n\tmakepol(&state);\n\tif (!state.num)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_SYNTAX_ERROR),\n\t\t\t\t errmsg(\"syntax error\"),\n\t\t\t\t errdetail(\"Empty query.\")));\n\tcommonlen = COMPUTESIZE(state.num, state.sumlen);\n\tquery = (ltxtquery *) palloc(commonlen);\n\tSET_VARSIZE(query, commonlen);\n\tquery->size = state.num;\n\tptr = GETQUERY(query);\n\tfor (i = 0; i < state.num; i++)\n\t{\n\t\tptr[i].type = state.str->type;\n\t\tptr[i].val = state.str->val;\n\t\tptr[i].distance = state.str->distance;\n\t\tptr[i].length = state.str->length;\n\t\tptr[i].flag = state.str->flag;\n\t\ttmp = state.str->next;\n\t\tpfree(state.str);\n\t\tstate.str = tmp;\n\t}\n\tmemcpy((void *) GETOPERAND(query), (void *) state.op, state.sumlen);\n\tpfree(state.op);\n\tpos = 0;\n\tfindoprnd(ptr, &pos);\n\treturn query;\n}", "target": 1}
{"code": "static int ax25_shutdown(struct socket *sk, int how)\n{\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "static const char* get_av_pair_string(UINT16 pair)\n{\n\tswitch (pair)\n\t{\n\t\tcase MsvAvEOL:\n\t\t\treturn \"MsvAvEOL\";\n\t\tcase MsvAvNbComputerName:\n\t\t\treturn \"MsvAvNbComputerName\";\n\t\tcase MsvAvNbDomainName:\n\t\t\treturn \"MsvAvNbDomainName\";\n\t\tcase MsvAvDnsComputerName:\n\t\t\treturn \"MsvAvDnsComputerName\";\n\t\tcase MsvAvDnsDomainName:\n\t\t\treturn \"MsvAvDnsDomainName\";\n\t\tcase MsvAvDnsTreeName:\n\t\t\treturn \"MsvAvDnsTreeName\";\n\t\tcase MsvAvFlags:\n\t\t\treturn \"MsvAvFlags\";\n\t\tcase MsvAvTimestamp:\n\t\t\treturn \"MsvAvTimestamp\";\n\t\tcase MsvAvSingleHost:\n\t\t\treturn \"MsvAvSingleHost\";\n\t\tcase MsvAvTargetName:\n\t\t\treturn \"MsvAvTargetName\";\n\t\tcase MsvChannelBindings:\n\t\t\treturn \"MsvChannelBindings\";\n\t\tdefault:\n\t\t\treturn \"UNKNOWN\";\n\t}\n}", "target": 0}
{"code": "EncryptingStream::Create(const AP4_UI08* key, const AP4_UI08* iv, AP4_ByteStream* output, EncryptingStream*& stream) {\n    stream = NULL;\n    AP4_BlockCipher* block_cipher = NULL;\n    AP4_Result result = AP4_DefaultBlockCipherFactory::Instance.CreateCipher(AP4_BlockCipher::AES_128,\n                                                                             AP4_BlockCipher::ENCRYPT,\n                                                                             AP4_BlockCipher::CBC,\n                                                                             NULL,\n                                                                             key,\n                                                                             16,\n                                                                             block_cipher);\n    if (AP4_FAILED(result)) return result;\n    AP4_CbcStreamCipher* stream_cipher = new AP4_CbcStreamCipher(block_cipher);\n    stream_cipher->SetIV(iv);\n    stream = new EncryptingStream(stream_cipher, output);\n    return AP4_SUCCESS;\n}", "target": 0}
{"code": "void RenderViewTest::SendWebGestureEvent(\n    const blink::WebGestureEvent& gesture_event) {\n  SendInputEvent(gesture_event);\n}", "target": 0}
{"code": "gx_default_create_compositor(gx_device * dev, gx_device ** pcdev,\n                             const gs_composite_t * pcte,\n                             gs_gstate * pgs, gs_memory_t * memory,\n                             gx_device *cdev)\n{\n    return pcte->type->procs.create_default_compositor\n        (pcte, pcdev, dev, pgs, memory);\n}", "target": 0}
{"code": "set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->princ, NULL)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_mod_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,\n                                    arg->value);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_mod_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "      explicit JpegOutput( String const& filename ) {\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n         }\n         if( outfile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            DIP_THROW_RUNTIME( \"Error writing JPEG file.\" );\n         }\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }", "target": 1}
{"code": "static void adpt_i386_info(sysInfo_S* si)\n{\n\tswitch (boot_cpu_data.x86) {\n\tcase CPU_386:\n\t\tsi->processorType = PROC_386;\n\t\tbreak;\n\tcase CPU_486:\n\t\tsi->processorType = PROC_486;\n\t\tbreak;\n\tcase CPU_586:\n\t\tsi->processorType = PROC_PENTIUM;\n\t\tbreak;\n\tdefault:  \n\t\tsi->processorType = PROC_PENTIUM;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "static void pipe_advance(struct iov_iter *i, size_t size)\n{\n\tstruct pipe_inode_info *pipe = i->pipe;\n\tstruct pipe_buffer *buf;\n\tint idx = i->idx;\n\tsize_t off = i->iov_offset, orig_sz;\n\tif (unlikely(i->count < size))\n\t\tsize = i->count;\n\torig_sz = size;\n\tif (size) {\n\t\tif (off) \n\t\t\tsize += off - pipe->bufs[idx].offset;\n\t\twhile (1) {\n\t\t\tbuf = &pipe->bufs[idx];\n\t\t\tif (size <= buf->len)\n\t\t\t\tbreak;\n\t\t\tsize -= buf->len;\n\t\t\tidx = next_idx(idx, pipe);\n\t\t}\n\t\tbuf->len = size;\n\t\ti->idx = idx;\n\t\toff = i->iov_offset = buf->offset + size;\n\t}\n\tif (off)\n\t\tidx = next_idx(idx, pipe);\n\tif (pipe->nrbufs) {\n\t\tint unused = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\twhile (idx != unused) {\n\t\t\tpipe_buf_release(pipe, &pipe->bufs[idx]);\n\t\t\tidx = next_idx(idx, pipe);\n\t\t\tpipe->nrbufs--;\n\t\t}\n\t}\n\ti->count -= orig_sz;\n}", "target": 1}
{"code": "find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n\tback_txn *txn,\n\tint flags\n)\n{\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (uniqueid=%s) lock %d\\n\",\n\t\t    addr->uniqueid, lock, 0 );\n\t\treturn (find_entry_internal_uniqueid (pb, be, addr->uniqueid, lock, txn));\n\t}\n\telse\n\t{\n\t\tstruct backentry *entry = NULL;\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, \n\t\t\t                                lock, txn, flags);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY,\n\t\t\t                \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}\n}", "target": 1}
{"code": "mmsClient_handleFileOpenRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId, ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n        switch(tag) {\n        case 0xa0: \n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n            hasFileName = true;\n            break;\n        case 0x81: \n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n        case 0x00: \n            break;\n        default: \n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n    if (hasFileName) {\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n        if (frsm != NULL) {\n            MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n            if (obtainFileCall) {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n                obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n            }\n            FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n            if (fileHandle != NULL) {\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n                frsm->obtainRequest = obtainFileCall;\n                mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n    return;\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}", "target": 1}
{"code": " */\nstatic void re_yyensure_buffer_stack (yyscan_t yyscanner)\n{\n\tyy_size_t num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!yyg->yy_buffer_stack) {\n\t\tnum_to_alloc = 1; \n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\t\tyy_size_t grow_size = 8 ;\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)re_yyrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in re_yyensure_buffer_stack()\" );\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}", "target": 1}
{"code": "ev_archive_get_entry_pathname (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), NULL);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, NULL);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, NULL);\n\t\treturn archive_entry_pathname (archive->libar_entry);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "void Item_decimal::print(String *str, enum_query_type query_type)\n{\n  my_decimal2string(E_DEC_FATAL_ERROR, &decimal_value, 0, 0, 0, &str_value);\n  str->append(str_value);\n}", "target": 0}
{"code": "void unix_notinflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tspin_lock(&unix_gc_lock);\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\t\tBUG_ON(list_empty(&u->link));\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tuser->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}", "target": 0}
{"code": "static void free_func_state(struct bpf_func_state *state)\n{\n\tif (!state)\n\t\treturn;\n\tkfree(state->stack);\n\tkfree(state);\n}", "target": 0}
{"code": "void G711::describe()\n{\n\tif (mode() == Compress)\n\t{\n\t\tm_outChunk->f.compressionType = m_track->f.compressionType;\n\t}\n\telse\n\t{\n\t\tm_outChunk->f.byteOrder = _AF_BYTEORDER_NATIVE;\n\t\tm_outChunk->f.compressionType = AF_COMPRESSION_NONE;\n\t}\n}", "target": 0}
{"code": "inline typename V::VectorType FBUnserializer<V>::unserializeList() {\n  p_ += CODE_SIZE;\n  unserializeInt64();\n  typename V::VectorType ret = V::createVector();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "static int af9005_identify_state(struct usb_device *udev,\n\t\t\t\t struct dvb_usb_device_properties *props,\n\t\t\t\t struct dvb_usb_device_description **desc,\n\t\t\t\t int *cold)\n{\n\tint ret;\n\tu8 reply, *buf;\n\tbuf = kmalloc(FW_BULKOUT_SIZE + 2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tret = af9005_boot_packet(udev, FW_CONFIG, &reply,\n\t\t\t\t buf, FW_BULKOUT_SIZE + 2);\n\tif (ret)\n\t\tgoto err;\n\tdeb_info(\"result of FW_CONFIG in identify state %d\\n\", reply);\n\tif (reply == 0x01)\n\t\t*cold = 1;\n\telse if (reply == 0x02)\n\t\t*cold = 0;\n\telse\n\t\treturn -EIO;\n\tdeb_info(\"Identify state cold = %d\\n\", *cold);\nerr:\n\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "int nbd_client(int fd)\n{\n    return -ENOTSUP;\n}", "target": 0}
{"code": "  ~SubgraphGuard() {\n    if (status_ == kTfLiteOk) {\n      *is_subgraph_in_use_ = false;\n    }\n  }", "target": 0}
{"code": "add_header_value(VALUE hh, const char *key, int klen, const char *val, int vlen) {\n    if (sizeof(content_type) - 1 == klen && 0 == strncasecmp(key, content_type, sizeof(content_type) - 1)) {\n\trb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));\n    } else if (sizeof(content_length) - 1 == klen && 0 == strncasecmp(key, content_length, sizeof(content_length) - 1)) {\n\trb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));\n    } else {\n\tchar\t\thkey[1024];\n\tchar\t\t*k = hkey;\n\tvolatile VALUE\tsval = rb_str_new(val, vlen);\n\tstrcpy(hkey, \"HTTP_\");\n\tk = hkey + 5;\n\tif ((int)(sizeof(hkey) - 5) <= klen) {\n\t    klen = sizeof(hkey) - 6;\n\t}\n\tstrncpy(k, key, klen);\n\thkey[klen + 5] = '\\0';\n\tfor (k = hkey + 5; '\\0' != *k; k++) {\n\t    if ('-' == *k) {\n\t\t*k = '_';\n\t    } else {\n\t\t*k = toupper(*k);\n\t    }\n\t}\n\trb_hash_aset(hh, rb_str_new(hkey, klen + 5), sval);\n    }\n}", "target": 1}
{"code": "TEST_P(MultiplexedRingHashIntegrationTest,\n       CookieRoutingNoCookieWithNonzeroTtlSetAndWithAttributes) {\n  config_helper_.addConfigModifier(\n      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n              hcm) -> void {\n        auto* hash_policy = hcm.mutable_route_config()\n                                ->mutable_virtual_hosts(0)\n                                ->mutable_routes(0)\n                                ->mutable_route()\n                                ->add_hash_policy();\n        auto* cookie = hash_policy->mutable_cookie();\n        cookie->set_name(\"foo\");\n        cookie->mutable_ttl()->set_seconds(15);\n        auto* attribute_1 = cookie->mutable_attributes()->Add();\n        attribute_1->set_name(\"test1\");\n        attribute_1->set_value(\"value1\");\n        auto* attribute_2 = cookie->mutable_attributes()->Add();\n        attribute_2->set_name(\"test2\");\n        attribute_2->set_value(\"value2\");\n      });\n  std::set<std::string> set_cookies;\n  sendMultipleRequests(\n      1024,\n      Http::TestRequestHeaderMapImpl{{\":method\", \"POST\"},\n                                     {\":path\", \"/test/long/url\"},\n                                     {\":scheme\", \"http\"},\n                                     {\":authority\", \"host\"}},\n      [&](IntegrationStreamDecoder& response) {\n        EXPECT_EQ(\"200\", response.headers().getStatusValue());\n        std::string value(\n            response.headers().get(Http::Headers::get().SetCookie)[0]->value().getStringView());\n        set_cookies.insert(value);\n        EXPECT_THAT(value,\n                    MatchesRegex(\"foo=.*; Max-Age=15; test1=value1; test2=value2; HttpOnly\"));\n      });\n  EXPECT_EQ(set_cookies.size(), 1);\n}", "target": 0}
{"code": "static std::vector<std::string> AllDirectoryPrefixes(const std::string& d) {\n  std::vector<std::string> dirs;\n  const std::string patched = PatchPattern(d);\n  StringPiece dir(patched);\n  bool is_directory = d[d.size() - 1] == '/';\n#ifdef PLATFORM_WINDOWS\n  is_directory = is_directory || (d[d.size() - 1] == '\\\\');\n#endif\n  if (is_directory) {\n    dir = io::Dirname(dir);\n  }\n  while (!dir.empty()) {\n    dirs.emplace_back(dir);\n    StringPiece new_dir(io::Dirname(dir));\n    if (dir == new_dir) break;\n    dir = new_dir;\n  }\n  std::reverse(dirs.begin(), dirs.end());\n  return dirs;\n}", "target": 0}
{"code": "flatpak_run_get_cups_server_name_config (const char *path)\n{\n  g_autoptr(GFile) file = g_file_new_for_path (path);\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(GFileInputStream) input_stream = NULL;\n  g_autoptr(GDataInputStream) data_stream = NULL;\n  size_t len;\n  input_stream = g_file_read (file, NULL, &my_error);\n  if (my_error)\n    {\n      g_debug (\"CUPS configuration file '%s': %s\", path, my_error->message);\n      return NULL;\n    }\n  data_stream = g_data_input_stream_new (G_INPUT_STREAM (input_stream));\n  while (TRUE)\n    {\n      g_autofree char *line = g_data_input_stream_read_line (data_stream, &len, NULL, NULL);\n      if (line == NULL)\n        break;\n      g_strchug (line);\n      if ((*line  == '\\0') || (*line == '#'))\n        continue;\n      g_auto(GStrv) tokens = g_strsplit (line, \" \", 2);\n      if ((tokens[0] != NULL) && (tokens[1] != NULL))\n        {\n          if (strcmp (\"ServerName\", tokens[0]) == 0)\n            {\n              g_strchug (tokens[1]);\n              if (flatpak_run_cups_check_server_is_socket (tokens[1]))\n                return g_strdup (tokens[1]);\n            }\n        }\n    }\n    return NULL;\n}", "target": 0}
{"code": "static int rm_read_multi(AVFormatContext *s, AVIOContext *pb,\n                         AVStream *st, char *mime)\n{\n    int number_of_streams = avio_rb16(pb);\n    int number_of_mdpr;\n    int i, ret;\n    unsigned size2;\n    for (i = 0; i<number_of_streams; i++)\n        avio_rb16(pb);\n    number_of_mdpr = avio_rb16(pb);\n    if (number_of_mdpr != 1) {\n        avpriv_request_sample(s, \"MLTI with multiple (%d) MDPR\", number_of_mdpr);\n    }\n    for (i = 0; i < number_of_mdpr; i++) {\n        AVStream *st2;\n        if (i > 0) {\n            st2 = avformat_new_stream(s, NULL);\n            if (!st2) {\n                ret = AVERROR(ENOMEM);\n                return ret;\n            }\n            st2->id = st->id + (i<<16);\n            st2->codecpar->bit_rate = st->codecpar->bit_rate;\n            st2->start_time = st->start_time;\n            st2->duration   = st->duration;\n            st2->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st2->priv_data = ff_rm_alloc_rmstream();\n            if (!st2->priv_data)\n                return AVERROR(ENOMEM);\n        } else\n            st2 = st;\n        size2 = avio_rb32(pb);\n        ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,\n                                        size2, mime);\n        if (ret < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "jas_stream_t *jas_stream_memopen(char *buf, int bufsize)\n{\n\tchar *new_buf;\n\tsize_t new_bufsize;\n\tJAS_DBGLOG(100, (\"jas_stream_memopen(%p, %d)\\n\", buf, bufsize));\n\tif (bufsize < 0) {\n\t\tjas_deprecated(\"negative buffer size for jas_stream_memopen\");\n\t}\n\tif (buf && bufsize <= 0) {\n\t\tjas_eprintf(\"Invalid use of jas_stream_memopen detected.\\n\");\n\t\tjas_deprecated(\"A user-provided buffer for \"\n\t\t  \"jas_stream_memopen cannot be growable.\\n\");\n\t}\n\tif (bufsize <= 0) {\n\t\tnew_bufsize = 0;\n\t\tnew_buf = 0;\n\t} else {\n\t\tnew_bufsize = bufsize;\n\t\tnew_buf = buf;\n\t}\n\treturn jas_stream_memopen2(new_buf, new_bufsize);\n}", "target": 0}
{"code": "void GHASH::key_schedule(std::span<const uint8_t> key) {\n   m_H.assign(key.begin(), key.end());  \n   m_H_ad.resize(GCM_BS);\n   m_ad_len = 0;\n   m_text_len = 0;\n   uint64_t H0 = load_be<uint64_t>(m_H.data(), 0);\n   uint64_t H1 = load_be<uint64_t>(m_H.data(), 1);\n   const uint64_t R = 0xE100000000000000;\n   m_HM.resize(256);\n   for(size_t i = 0; i != 2; ++i) {\n      for(size_t j = 0; j != 64; ++j) {\n         m_HM[4 * j + 2 * i] = H0;\n         m_HM[4 * j + 2 * i + 1] = H1;\n         const uint64_t carry = R * (H1 & 1);\n         H1 = (H1 >> 1) | (H0 << 63);\n         H0 = (H0 >> 1) ^ carry;\n      }\n   }\n#if defined(BOTAN_HAS_GHASH_CLMUL_CPU)\n   if(CPUID::has_carryless_multiply()) {\n      m_H_pow.resize(8);\n      ghash_precompute_cpu(m_H.data(), m_H_pow.data());\n   }\n#endif\n}", "target": 1}
{"code": "TEST_F(ZNCTest, StatusEchoMessage) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"CAP REQ :echo-message\");\n    client.Write(\"PRIVMSG *status :blah\");\n    client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n    client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n    client.Write(\"znc delnetwork test\");\n    client.ReadUntil(\"Network deleted\");\n    auto client2 = LoginClient();\n    client2.Write(\"PRIVMSG *status :blah2\");\n    client2.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n    auto client3 = LoginClient();\n    client3.Write(\"PRIVMSG *status :blah3\");\n    client3.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n}", "target": 0}
{"code": "      BigInt multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const\n         {\n         return m_mod_order.multiply(m_mod_order.multiply(x, y), z);\n         }", "target": 0}
{"code": "void WidgetUtils::openUrlByDesktop(const QUrl &p_url)\n{\n    const auto scheme = p_url.scheme();\n    if (scheme != \"http\" && scheme != \"https\") {\n        int ret = MessageBoxHelper::questionYesNo(MessageBoxHelper::Warning,\n                                                  MainWindow::tr(\"Are you sure to open link (%1)?\").arg(p_url.toString()),\n                                                  MainWindow::tr(\"Malicious link might do harm to your device.\"),\n                                                  QString(),\n                                                  nullptr);\n        if (ret == QMessageBox::No) {\n            return;\n        }\n    }\n    QDesktopServices::openUrl(p_url);\n}", "target": 0}
{"code": "ext2_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}", "target": 1}
{"code": "WebContents* WebContents::FromRenderViewHost(const RenderViewHost* rvh) {\n  return rvh->GetDelegate()->GetAsWebContents();\n}", "target": 0}
{"code": "static int tga_readheader(FILE *fp, unsigned int *bits_per_pixel,\n                          unsigned int *width, unsigned int *height, int *flip_image)\n{\n    int palette_size;\n    unsigned char tga[TGA_HEADER_SIZE];\n    unsigned char id_len,  image_type;\n    unsigned char pixel_depth, image_desc;\n    unsigned short  cmap_len, cmap_entry_size;\n    unsigned short  image_w, image_h;\n    if (!bits_per_pixel || !width || !height || !flip_image) {\n        return 0;\n    }\n    if (fread(tga, TGA_HEADER_SIZE, 1, fp) != 1) {\n        fprintf(stderr,\n                \"\\nError: fread return a number of element different from the expected.\\n\");\n        return 0 ;\n    }\n    id_len = tga[0];\n    image_type = tga[2];\n    cmap_len = get_ushort(&tga[5]);\n    cmap_entry_size = tga[7];\n#if 0\n    x_origin = get_ushort(&tga[8]);\n    y_origin = get_ushort(&tga[10]);\n#endif\n    image_w = get_ushort(&tga[12]);\n    image_h = get_ushort(&tga[14]);\n    pixel_depth = tga[16];\n    image_desc  = tga[17];\n    *bits_per_pixel = (unsigned int)pixel_depth;\n    *width  = (unsigned int)image_w;\n    *height = (unsigned int)image_h;\n    if (id_len) {\n        unsigned char *id = (unsigned char *) malloc(id_len);\n        if (id == 0) {\n            fprintf(stderr, \"tga_readheader: memory out\\n\");\n            return 0;\n        }\n        if (!fread(id, id_len, 1, fp)) {\n            fprintf(stderr,\n                    \"\\nError: fread return a number of element different from the expected.\\n\");\n            free(id);\n            return 0 ;\n        }\n        free(id);\n    }\n    if (image_type > 8) {\n        fprintf(stderr, \"Sorry, compressed tga files are not currently supported.\\n\");\n        return 0 ;\n    }\n    *flip_image = !(image_desc & 32);\n    palette_size = cmap_len * (cmap_entry_size / 8);\n    if (palette_size > 0) {\n        fprintf(stderr, \"File contains a palette - not yet supported.\");\n        fseek(fp, palette_size, SEEK_CUR);\n    }\n    return 1;\n}", "target": 1}
{"code": "  virtual ~AuthAuthorizerChallenge() {}", "target": 0}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "void sigsegvHandler(int sig, siginfo_t *info, void *secret) {\n    UNUSED(secret);\n    UNUSED(info);\n    bugReportStart();\n    serverLog(LL_WARNING,\n        \"Redis %s crashed by signal: %d, si_code: %d\", REDIS_VERSION, sig, info->si_code);\n    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getMcontextEip(uc);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n    logStackTrace(getMcontextEip(uc), 1);\n    logRegisters(uc);\n#endif\n    printCrashReport();\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif\n    bugReportEnd(1, sig);\n}", "target": 1}
{"code": "_mibindex_add( const char *dirname, int i )\n{\n    const int old_mibindex_max = _mibindex_max;\n    DEBUGMSGTL((\"mibindex\", \"add: %s (%d)\\n\", dirname, i ));\n    if ( i == -1 )\n        i = _mibindex++;\n    if ( i >= _mibindex_max ) {\n        _mibindex_max = i + 10;\n        _mibindexes = realloc(_mibindexes,\n                              _mibindex_max * sizeof(_mibindexes[0]));\n        netsnmp_assert(_mibindexes);\n        memset(_mibindexes + old_mibindex_max, 0,\n               (_mibindex_max - old_mibindex_max) * sizeof(_mibindexes[0]));\n    }\n    _mibindexes[ i ] = strdup( dirname );\n    if ( i >= _mibindex )\n        _mibindex = i+1;\n    DEBUGMSGTL((\"mibindex\", \"add: %d/%d/%d\\n\", i, _mibindex, _mibindex_max ));\n    return i;\n}", "target": 1}
{"code": "BOOL CEAnsi::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tconst size_t nLen = wcslen(asRet);\n\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tconst BOOL bSuccess = WriteConsoleInput(hIn, pir, static_cast<DWORD>(nLen), &nWritten) && (nWritten == nLen);\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", "target": 1}
{"code": "static void axfm(RCore *core) {\n\tRVecAnalRef *refs = r_anal_xrefs_get_from (core->anal, UT64_MAX);\n\tif (refs && !RVecAnalRef_empty (refs)) {\n\t\tRVecAnalRef_sort (refs, compare_ref);\n\t\tut64 last_addr = UT64_MAX;\n\t\tRAnalRef *ref;\n\t\tR_VEC_FOREACH (refs, ref) {\n\t\t\tconst bool is_first = ref->addr != last_addr;\n\t\t\tconst char *name;\n\t\t\tif (is_first) {\n\t\t\t\tname = axtm_name (core, ref->addr);\n\t\t\t\tr_cons_printf (\"0x%\"PFMT64x\": %s\\n\", ref->addr, name? name: \"?\");\n\t\t\t}\n\t\t\tname = axtm_name (core, ref->at);\n\t\t\tr_cons_printf (\"  0x%\"PFMT64x\": %s\\n\", ref->at, name? name: \"?\");\n\t\t\tlast_addr = ref->addr;\n\t\t}\n\t}\n\tRVecAnalRef_free (refs);\n}", "target": 1}
{"code": "\tEventReturn OnPreCommand(CommandSource &source, Command *command, std::vector<Anope::string> &params) anope_override\n\t{\n\t\tif (command->name == \"nickserv/confirm\" && params.size() > 1)\n\t\t{\n\t\t\tif (Anope::ReadOnly)\n\t\t\t{\n\t\t\t\tsource.Reply(READ_ONLY_MODE);\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t\tNickAlias *na = NickAlias::Find(params[0]);\n\t\t\tResetInfo *ri = na ? reset.Get(na->nc) : NULL;\n\t\t\tif (na && ri)\n\t\t\t{\n\t\t\t\tNickCore *nc = na->nc;\n\t\t\t\tif (nc->HasExt(\"NS_SUSPENDED\"))\n\t\t\t\t{\n\t\t\t\t\tsource.Reply(NICK_X_SUSPENDED, nc->display.c_str());\n\t\t\t\t\treturn EVENT_STOP;\n\t\t\t\t}\n\t\t\t\tconst Anope::string &passcode = params[1];\n\t\t\t\tif (ri->time < Anope::CurTime - 3600)\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tsource.Reply(_(\"Your password reset request has expired.\"));\n\t\t\t\t}\n\t\t\t\telse if (passcode.equals_cs(ri->code))\n\t\t\t\t{\n\t\t\t\t\treset.Unset(nc);\n\t\t\t\t\tnc->Shrink<bool>(\"UNCONFIRMED\");\n\t\t\t\t\tLog(LOG_COMMAND, source, &commandnsresetpass) << \"to confirm RESETPASS and forcefully identify as \" << na->nick;\n\t\t\t\t\tif (source.GetUser())\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.GetUser()->Identify(na);\n\t\t\t\t\t}\n\t\t\t\t\tsource.Reply(_(\"You are now identified for your nick. Change your password now.\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\treturn EVENT_CONTINUE;\n\t\t\t\treturn EVENT_STOP;\n\t\t\t}\n\t\t}\n\t\treturn EVENT_CONTINUE;\n\t}", "target": 0}
{"code": "error::Error GLES2DecoderImpl::HandleDestroyStreamTextureCHROMIUM(\n    uint32 immediate_data_size,\n    const gles2::DestroyStreamTextureCHROMIUM& c) {\n  GLuint client_id = c.texture;\n  TextureManager::TextureInfo* info =\n      texture_manager()->GetTextureInfo(client_id);\n  if (info && info->IsStreamTexture()) {\n    if (!stream_texture_manager_)\n      return error::kInvalidArguments;\n    stream_texture_manager_->DestroyStreamTexture(info->service_id());\n    info->SetStreamTexture(false);\n    texture_manager()->SetInfoTarget(info, 0);\n  } else {\n    SetGLError(GL_INVALID_VALUE,\n               \"glDestroyStreamTextureCHROMIUM: bad texture id.\");\n  }\n  return error::kNoError;\n}", "target": 0}
{"code": "flatpak_bwrap_take_arg (FlatpakBwrap *bwrap, char *arg)\n{\n  g_ptr_array_add (bwrap->argv, arg);\n}", "target": 0}
{"code": "static void cliRefreshPrompt(void) {\n    int len;\n    if (config.eval_ldb) return;\n    if (config.hostsocket != NULL)\n        len = snprintf(config.prompt,sizeof(config.prompt),\"redis %s\",\n                       config.hostsocket);\n    else\n        len = anetFormatAddr(config.prompt, sizeof(config.prompt),\n                           config.hostip, config.hostport);\n    if (config.dbnum != 0)\n        len += snprintf(config.prompt+len,sizeof(config.prompt)-len,\"[%d]\",\n            config.dbnum);\n    snprintf(config.prompt+len,sizeof(config.prompt)-len,\"> \");\n}", "target": 1}
{"code": "int main()\n{\n    gdImagePtr im, clone;\n    int style[] = {0, 0, 0};\n    im = gdImageCreate(8, 8);\n    gdImageSetStyle(im, style, sizeof(style)/sizeof(style[0]));\n    clone = gdImageClone(im);\n    gdTestAssert(clone != NULL);\n    gdTestAssert(clone->styleLength == im->styleLength);\n    gdTestAssert(clone->stylePos == im->stylePos);\n    gdTestAssert(!memcmp(clone->style, im->style, sizeof(style)/sizeof(style[0])));\n    gdImageDestroy(clone);\n    gdImageDestroy(im);\n    return gdNumFailures();\n}", "target": 0}
{"code": "vhost_user_check_and_alloc_queue_pair(struct virtio_net *dev,\n\t\t\tstruct vhu_msg_context *ctx)\n{\n\tuint32_t vring_idx;\n\tswitch (ctx->msg.request.master) {\n\tcase VHOST_USER_SET_VRING_KICK:\n\tcase VHOST_USER_SET_VRING_CALL:\n\tcase VHOST_USER_SET_VRING_ERR:\n\t\tvring_idx = ctx->msg.payload.u64 & VHOST_USER_VRING_IDX_MASK;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_NUM:\n\tcase VHOST_USER_SET_VRING_BASE:\n\tcase VHOST_USER_GET_VRING_BASE:\n\tcase VHOST_USER_SET_VRING_ENABLE:\n\t\tvring_idx = ctx->msg.payload.state.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_VRING_ADDR:\n\t\tvring_idx = ctx->msg.payload.addr.index;\n\t\tbreak;\n\tcase VHOST_USER_SET_INFLIGHT_FD:\n\t\tvring_idx = ctx->msg.payload.inflight.num_queues - 1;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (vring_idx >= VHOST_MAX_VRING) {\n\t\tVHOST_LOG_CONFIG(ERR, \"(%s) invalid vring index: %u\\n\", dev->ifname, vring_idx);\n\t\treturn -1;\n\t}\n\tif (dev->virtqueue[vring_idx])\n\t\treturn 0;\n\treturn alloc_vring_queue(dev, vring_idx);\n}", "target": 0}
{"code": "static bool is_legal_file(const std::string &filename)\n{\n\tDBG_FS << \"Looking for '\" << filename << \"'.\\n\";\n\tif (filename.empty()) {\n\t\tLOG_FS << \"  invalid filename\\n\";\n\t\treturn false;\n\t}\n\tif (filename.find(\"..\") != std::string::npos) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (\\\"..\\\" not allowed).\\n\";\n\t\treturn false;\n\t}\n\tif (looks_like_pbl(filename)) {\n\t\tERR_FS << \"Illegal path '\" << filename << \"' (.pbl files are not allowed).\" << std::endl;\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static int update_write_order_info(rdpContext* context, wStream* s, ORDER_INFO* orderInfo,\n                                   size_t offset)\n{\n\tsize_t position;\n\tWINPR_UNUSED(context);\n\tposition = Stream_GetPosition(s);\n\tStream_SetPosition(s, offset);\n\tStream_Write_UINT8(s, orderInfo->controlFlags); \n\tif (orderInfo->controlFlags & ORDER_TYPE_CHANGE)\n\t\tStream_Write_UINT8(s, orderInfo->orderType); \n\tupdate_write_field_flags(s, orderInfo->fieldFlags, orderInfo->controlFlags,\n\t                         PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]);\n\tupdate_write_bounds(s, orderInfo);\n\tStream_SetPosition(s, position);\n\treturn 0;\n}", "target": 1}
{"code": "void Context::onDownstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onDownstreamConnectionClose_) {\n    wasm_->onDownstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "static void test_bug17512527()\n{\n  MYSQL *conn1, *conn2;\n  MYSQL_STMT *stmt1, *stmt2;\n  const char *stmt1_txt= \"SELECT NOW();\";\n  const char *stmt2_txt= \"SELECT 1;\";\n  unsigned long thread_id;\n  char query[MAX_TEST_QUERY_LENGTH];\n  int rc;\n  conn1= client_connect(0, MYSQL_PROTOCOL_DEFAULT, 1);\n  conn2= client_connect(0, MYSQL_PROTOCOL_DEFAULT, 0);\n  stmt1 = mysql_stmt_init(conn1);\n  check_stmt(stmt1);\n  rc= mysql_stmt_prepare(stmt1, stmt1_txt, strlen(stmt1_txt));\n  check_execute(stmt1, rc);\n  thread_id= mysql_thread_id(conn1);\n  sprintf(query, \"KILL %lu\", thread_id);\n  if (thread_query(query))\n    exit(1);\n  stmt2 = mysql_stmt_init(conn1);\n  check_stmt(stmt2);\n  rc= mysql_stmt_prepare(stmt2, stmt2_txt, strlen(stmt2_txt));\n  check_execute(stmt1, rc);\n  mysql_stmt_close(stmt2);\n  mysql_stmt_close(stmt1);\n  mysql_close(conn1);\n  mysql_close(conn2);\n}", "target": 0}
{"code": "static inline struct sem_array *sem_obtain_lock(struct ipc_namespace *ns, int id)\n{\n\tstruct kern_ipc_perm *ipcp;\n\tstruct sem_array *sma;\n\trcu_read_lock();\n\tipcp = ipc_obtain_object(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp)) {\n\t\tsma = ERR_CAST(ipcp);\n\t\tgoto err;\n\t}\n\tspin_lock(&ipcp->lock);\n\tif (!ipcp->deleted)\n\t\treturn container_of(ipcp, struct sem_array, sem_perm);\n\tspin_unlock(&ipcp->lock);\n\tsma = ERR_PTR(-EINVAL);\nerr:\n\trcu_read_unlock();\n\treturn sma;\n}", "target": 1}
{"code": "static long mem_seek(jas_stream_obj_t *obj, long offset, int origin)\n{\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newpos;\n\tJAS_DBGLOG(100, (\"mem_seek(%p, %ld, %d)\\n\", obj, offset, origin));\n\tswitch (origin) {\n\tcase SEEK_SET:\n\t\tnewpos = offset;\n\t\tbreak;\n\tcase SEEK_END:\n\t\tnewpos = m->len_ - offset;\n\t\tbreak;\n\tcase SEEK_CUR:\n\t\tnewpos = m->pos_ + offset;\n\t\tbreak;\n\tdefault:\n\t\tabort();\n\t\tbreak;\n\t}\n\tif (newpos < 0) {\n\t\treturn -1;\n\t}\n\tm->pos_ = newpos;\n\treturn m->pos_;\n}", "target": 1}
{"code": "static int __init setup_psi(char *str)\n{\n\treturn kstrtobool(str, &psi_enable) == 0;\n}", "target": 0}
{"code": "static void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "Status UncompressElement(const CompressedElement& compressed,\n                         std::vector<Tensor>* out) {\n  int num_components = compressed.component_metadata_size();\n  out->clear();\n  out->reserve(num_components);\n  std::vector<struct iovec> iov(num_components);\n  std::vector<tstring> tensor_proto_strs;\n  tensor_proto_strs.reserve(num_components);\n  int64 total_size = 0;\n  for (int i = 0; i < num_components; ++i) {\n    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      iov[i].iov_base = buffer->data();\n      iov[i].iov_len = buffer->size();\n    } else {\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();\n      tstring& tensor_proto_str = tensor_proto_strs.back();\n      tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes());\n      iov[i].iov_base = tensor_proto_str.mdata();\n      iov[i].iov_len = tensor_proto_str.size();\n    }\n    total_size += iov[i].iov_len;\n  }\n  const std::string& compressed_data = compressed.data();\n  size_t uncompressed_size;\n  if (!port::Snappy_GetUncompressedLength(\n          compressed_data.data(), compressed_data.size(), &uncompressed_size)) {\n    return errors::Internal(\n        \"Could not get snappy uncompressed length. Compressed data size: \",\n        compressed_data.size());\n  }\n  if (uncompressed_size != static_cast<size_t>(total_size)) {\n    return errors::Internal(\n        \"Uncompressed size mismatch. Snappy expects \", uncompressed_size,\n        \" whereas the tensor metadata suggests \", total_size);\n  }\n  if (!port::Snappy_UncompressToIOVec(compressed_data.data(),\n                                      compressed_data.size(), iov.data(),\n                                      num_components)) {\n    return errors::Internal(\"Failed to perform snappy decompression.\");\n  }\n  int tensor_proto_strs_index = 0;\n  for (int i = 0; i < num_components; ++i) {\n    if (DataTypeCanUseMemcpy(compressed.component_metadata(i).dtype())) {\n      continue;\n    }\n    TensorProto tp;\n    if (!tp.ParseFromString(tensor_proto_strs[tensor_proto_strs_index++])) {\n      return errors::Internal(\"Could not parse TensorProto\");\n    }\n    if (!out->at(i).FromProto(tp)) {\n      return errors::Internal(\"Could not parse Tensor\");\n    }\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "find_entry(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, 0 ) );\n}", "target": 1}
{"code": "rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len)\n{\n    rfbClientPtr cl;\n    rfbServerCutTextMsg sct;\n    rfbClientIteratorPtr iterator;\n    memset((char *)&sct, 0, sizeof(sct));\n    iterator = rfbGetClientIterator(rfbScreen);\n    while ((cl = rfbClientIteratorNext(iterator)) != NULL) {\n        sct.type = rfbServerCutText;\n        sct.length = Swap32IfLE(len);\n        LOCK(cl->sendMutex);\n        if (rfbWriteExact(cl, (char *)&sct,\n                       sz_rfbServerCutTextMsg) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n            UNLOCK(cl->sendMutex);\n            continue;\n        }\n        if (rfbWriteExact(cl, str, len) < 0) {\n            rfbLogPerror(\"rfbSendServerCutText: write\");\n            rfbCloseClient(cl);\n        }\n        UNLOCK(cl->sendMutex);\n        rfbStatRecordMessageSent(cl, rfbServerCutText, sz_rfbServerCutTextMsg+len, sz_rfbServerCutTextMsg+len);\n    }\n    rfbReleaseClientIterator(iterator);\n}", "target": 0}
{"code": "void RootWindowHostWin::OnPaint(HDC dc) {\n  root_window_->Draw();\n  ValidateRect(hwnd(), NULL);\n}", "target": 0}
{"code": "static int em_syscall(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tif (ctxt->mode == X86EMUL_MODE_REAL ||\n\t    ctxt->mode == X86EMUL_MODE_VM86)\n\t\treturn emulate_ud(ctxt);\n\tif (!(em_syscall_is_enabled(ctxt)))\n\t\treturn emulate_ud(ctxt);\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tif (!(efer & EFER_SCE))\n\t\treturn emulate_ud(ctxt);\n\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\tmsr_data >>= 32;\n\tcs_sel = (u16)(msr_data & 0xfffc);\n\tss_sel = (u16)(msr_data + 8);\n\tif (efer & EFER_LMA) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tctxt->regs[VCPU_REGS_RCX] = ctxt->_eip;\n\tif (efer & EFER_LMA) {\n#ifdef CONFIG_X86_64\n\t\tctxt->regs[VCPU_REGS_R11] = ctxt->eflags & ~EFLG_RF;\n\t\tops->get_msr(ctxt,\n\t\t\t     ctxt->mode == X86EMUL_MODE_PROT64 ?\n\t\t\t     MSR_LSTAR : MSR_CSTAR, &msr_data);\n\t\tctxt->_eip = msr_data;\n\t\tops->get_msr(ctxt, MSR_SYSCALL_MASK, &msr_data);\n\t\tctxt->eflags &= ~(msr_data | EFLG_RF);\n#endif\n\t} else {\n\t\tops->get_msr(ctxt, MSR_STAR, &msr_data);\n\t\tctxt->_eip = (u32)msr_data;\n\t\tctxt->eflags &= ~(EFLG_VM | EFLG_IF | EFLG_RF);\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "static HashTable *php_zip_get_gc(zval *object, zval ***gc_data, int *gc_data_count TSRMLS_DC) \n{\n\t*gc_data = NULL;\n\t*gc_data_count = 0;\n\treturn zend_std_get_properties(object TSRMLS_CC);\n}", "target": 0}
{"code": "static int __init big_key_init(void)\n{\n\treturn register_key_type(&key_type_big_key);\n}", "target": 1}
{"code": "int BUFFER_enlarge(BUFFER_HANDLE handle, size_t enlargeSize)\n{\n    int result;\n    if (handle == NULL)\n    {\n        LogError(\"Failure: handle is invalid.\");\n        result = MU_FAILURE;\n    }\n    else if (enlargeSize == 0)\n    {\n        LogError(\"Failure: enlargeSize size is 0.\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        BUFFER* b = (BUFFER*)handle;\n        unsigned char* temp = (unsigned char*)realloc(b->buffer, b->size + enlargeSize);\n        if (temp == NULL)\n        {\n            LogError(\"Failure: allocating temp buffer.\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            b->buffer = temp;\n            b->size += enlargeSize;\n            result = 0;\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "inline typename V::VariantType FBUnserializer<V>::unserializeThing() {\n  size_t code = nextCode();\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap());\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector());\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList());\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet());\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}", "target": 1}
{"code": "  HTTP_CB(on_message_begin) {\n    num_fields_ = num_values_ = 0;\n    url_.Reset();\n    return 0;\n  }", "target": 0}
{"code": "static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->id = CMD_FLUSH_QUEUE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue);\n\tcmd->u.flush_queue.channel = priv->channel;\n\tcmd->u.flush_queue.flags = 0x00;\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1}
{"code": "void CommandData::ProcessCommand()\n{\n#ifndef SFX_MODULE\n  const wchar *SingleCharCommands=L\"FUADPXETK\";\n  if (Command[0]!=0 && Command[1]!=0 && wcschr(SingleCharCommands,Command[0])!=NULL || *ArcName==0)\n    OutHelp(*Command==0 ? RARX_SUCCESS:RARX_USERERROR); \n  const wchar *ArcExt=GetExt(ArcName);\n#ifdef _UNIX\n  if (ArcExt==NULL && (!FileExist(ArcName) || IsDir(GetFileAttr(ArcName))))\n    wcsncatz(ArcName,L\".rar\",ASIZE(ArcName));\n#else\n  if (ArcExt==NULL)\n    wcsncatz(ArcName,L\".rar\",ASIZE(ArcName));\n#endif\n  if (ArcExt!=NULL && wcsnicomp(ArcExt,L\".part\",5)==0 && IsDigit(ArcExt[5]) &&\n      !FileExist(ArcName))\n  {\n    wchar Name[NM];\n    wcsncpyz(Name,ArcName,ASIZE(Name));\n    wcsncatz(Name,L\".rar\",ASIZE(Name));\n    if (FileExist(Name))\n      wcsncpyz(ArcName,Name,ASIZE(ArcName));\n  }\n  if (wcschr(L\"AFUMD\",*Command)==NULL)\n  {\n    if (GenerateArcName)\n      GenerateArchiveName(ArcName,ASIZE(ArcName),GenerateMask,false);\n    StringList ArcMasks;\n    ArcMasks.AddString(ArcName);\n    ScanTree Scan(&ArcMasks,Recurse,SaveSymLinks,SCAN_SKIPDIRS);\n    FindData FindData;\n    while (Scan.GetNext(&FindData)==SCAN_SUCCESS)\n      AddArcName(FindData.Name);\n  }\n  else\n    AddArcName(ArcName);\n#endif\n  switch(Command[0])\n  {\n    case 'P':\n    case 'X':\n    case 'E':\n    case 'T':\n    case 'I':\n      {\n        CmdExtract Extract(this);\n        Extract.DoExtract();\n      }\n      break;\n#ifndef SILENT\n    case 'V':\n    case 'L':\n      ListArchive(this);\n      break;\n    default:\n      OutHelp(RARX_USERERROR);\n#endif\n  }\n  if (!BareOutput)\n    mprintf(L\"\\n\");\n}", "target": 1}
{"code": "    inline EndpointSecurityAttributesMask mask() const\n    {\n        EndpointSecurityAttributesMask rv = ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_VALID;\n        if (is_read_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_READ_PROTECTED;\n        if (is_write_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_WRITE_PROTECTED;\n        if (is_discovery_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_DISCOVERY_PROTECTED;\n        if (is_liveliness_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_LIVELINESS_PROTECTED;\n        if (is_submessage_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_SUBMESSAGE_PROTECTED;\n        if (is_payload_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_PAYLOAD_PROTECTED;\n        if (is_key_protected) rv |= ENDPOINT_SECURITY_ATTRIBUTES_FLAG_IS_KEY_PROTECTED;\n        return rv;\n    }", "target": 1}
{"code": "get_pols_2_svc(gpols_arg *arg, struct svc_req *rqstp)\n{\n    static gpols_ret                ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gpols_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST, NULL, NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_policies\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_policies((void *)handle,\n                                       arg->exp, &ret.pols,\n                                       &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_policies\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static int websocket_send(lua_State *L) {\n    lastCFunction = __func__;\n    std::string str = checkstring(L, 1);\n    if (config.http_max_websocket_message > 0 && str.size() > (unsigned)config.http_max_websocket_message) luaL_error(L, \"Message is too large\");\n    ws_handle * ws = *(ws_handle**)lua_touserdata(L, lua_upvalueindex(1));\n    if (ws == NULL) luaL_error(L, \"attempt to use a closed file\");\n    std::lock_guard<std::mutex> lock(ws->lock);\n    if (ws->ws == NULL) return luaL_error(L, \"attempt to use a closed file\");\n    if (ws->ws->sendFrame(str.c_str(), str.size(), (int)WebSocket::FRAME_FLAG_FIN | (int)(lua_toboolean(L, 2) ? WebSocket::FRAME_BINARY : WebSocket::FRAME_TEXT)) < 1) \n        websocket_close(L);\n    return 0;\n}", "target": 1}
{"code": "static int sockfs_setattr(struct dentry *dentry, struct iattr *iattr)\n{\n\tint err = simple_setattr(dentry, iattr);\n\tif (!err && (iattr->ia_valid & ATTR_UID)) {\n\t\tstruct socket *sock = SOCKET_I(d_inode(dentry));\n\t\tsock->sk->sk_uid = iattr->ia_uid;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static int ima_lsm_rule_init(struct ima_measure_rule_entry *entry,\n\t\t\t     char *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal, args,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\treturn result;\n}", "target": 0}
{"code": "gopherTimeout(const CommTimeoutCbParams &io)\n{\n    GopherStateData *gopherState = static_cast<GopherStateData *>(io.data);\n    debugs(10, 4, io.conn << \": '\" << gopherState->entry->url() << \"'\" );\n    gopherState->fwd->fail(new ErrorState(ERR_READ_TIMEOUT, Http::scGatewayTimeout, gopherState->fwd->request, gopherState->fwd->al));\n    if (Comm::IsConnOpen(io.conn))\n        io.conn->close();\n}", "target": 1}
{"code": "static bool valid_filemode(const int filemode)\n{\n\treturn (filemode == GIT_FILEMODE_TREE\n\t\t|| filemode == GIT_FILEMODE_BLOB\n\t\t|| filemode == GIT_FILEMODE_BLOB_EXECUTABLE\n\t\t|| filemode == GIT_FILEMODE_LINK\n\t\t|| filemode == GIT_FILEMODE_COMMIT);\n}", "target": 0}
{"code": "static void mark_all_scalars_precise(struct bpf_verifier_env *env,\n\t\t\t\t     struct bpf_verifier_state *st)\n{\n\tstruct bpf_func_state *func;\n\tstruct bpf_reg_state *reg;\n\tint i, j;\n\tfor (; st; st = st->parent)\n\t\tfor (i = 0; i <= st->curframe; i++) {\n\t\t\tfunc = st->frame[i];\n\t\t\tfor (j = 0; j < BPF_REG_FP; j++) {\n\t\t\t\treg = &func->regs[j];\n\t\t\t\tif (reg->type != SCALAR_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\treg->precise = true;\n\t\t\t}\n\t\t\tfor (j = 0; j < func->allocated_stack / BPF_REG_SIZE; j++) {\n\t\t\t\tif (!is_spilled_reg(&func->stack[j]))\n\t\t\t\t\tcontinue;\n\t\t\t\treg = &func->stack[j].spilled_ptr;\n\t\t\t\tif (reg->type != SCALAR_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\treg->precise = true;\n\t\t\t}\n\t\t}\n}", "target": 0}
{"code": "static bool snd_ctl_remove_numid_conflict(struct snd_card *card,\n\t\t\t\t\t  unsigned int count)\n{\n\tstruct snd_kcontrol *kctl;\n\tif (card->last_numid >= UINT_MAX - count)\n\t\tcard->last_numid = 0;\n\tlist_for_each_entry(kctl, &card->controls, list) {\n\t\tif (kctl->id.numid < card->last_numid + 1 + count &&\n\t\t    kctl->id.numid + kctl->count > card->last_numid + 1) {\n\t\t    \tcard->last_numid = kctl->id.numid + kctl->count - 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {\n    keyReference *keys;\n    UNUSED(cmd);\n    UNUSED(argv);\n    UNUSED(argc);\n    keys = getKeysPrepareResult(result, 1);\n    keys[0].pos = 1; \n    keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;\n    return 1;\n}", "target": 1}
{"code": "static std::string PatchPattern(const std::string& pattern) {\n  const std::string fixed_prefix =\n      pattern.substr(0, pattern.find_first_of(kGlobbingChars));\n  if (io::Dirname(fixed_prefix).empty()) {\n    return io::JoinPath(\".\", pattern);\n  }\n  return pattern;\n}", "target": 0}
{"code": "static int kernel_pio(struct kvm_vcpu *vcpu, void *pd)\n{\n\tint r;\n\tif (vcpu->arch.pio.in)\n\t\tr = kvm_io_bus_read(vcpu->kvm, KVM_PIO_BUS, vcpu->arch.pio.port,\n\t\t\t\t    vcpu->arch.pio.size, pd);\n\telse\n\t\tr = kvm_io_bus_write(vcpu->kvm, KVM_PIO_BUS,\n\t\t\t\t     vcpu->arch.pio.port, vcpu->arch.pio.size,\n\t\t\t\t     pd);\n\treturn r;\n}", "target": 0}
{"code": "static int fallocate_chunk(struct inode *inode, loff_t offset, loff_t len,\n\t\t\t   int mode)\n{\n\tstruct gfs2_inode *ip = GFS2_I(inode);\n\tstruct buffer_head *dibh;\n\tint error;\n\tu64 start = offset >> PAGE_CACHE_SHIFT;\n\tunsigned int start_offset = offset & ~PAGE_CACHE_MASK;\n\tu64 end = (offset + len - 1) >> PAGE_CACHE_SHIFT;\n\tpgoff_t curr;\n\tstruct page *page;\n\tunsigned int end_offset = (offset + len) & ~PAGE_CACHE_MASK;\n\tunsigned int from, to;\n\tif (!end_offset)\n\t\tend_offset = PAGE_CACHE_SIZE;\n\terror = gfs2_meta_inode_buffer(ip, &dibh);\n\tif (unlikely(error))\n\t\tgoto out;\n\tgfs2_trans_add_bh(ip->i_gl, dibh, 1);\n\tif (gfs2_is_stuffed(ip)) {\n\t\terror = gfs2_unstuff_dinode(ip, NULL);\n\t\tif (unlikely(error))\n\t\t\tgoto out;\n\t}\n\tcurr = start;\n\toffset = start << PAGE_CACHE_SHIFT;\n\tfrom = start_offset;\n\tto = PAGE_CACHE_SIZE;\n\twhile (curr <= end) {\n\t\tpage = grab_cache_page_write_begin(inode->i_mapping, curr,\n\t\t\t\t\t\t   AOP_FLAG_NOFS);\n\t\tif (unlikely(!page)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (curr == end)\n\t\t\tto = end_offset;\n\t\terror = write_empty_blocks(page, from, to, mode);\n\t\tif (!error && offset + to > inode->i_size &&\n\t\t    !(mode & FALLOC_FL_KEEP_SIZE)) {\n\t\t\ti_size_write(inode, offset + to);\n\t\t}\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tcurr++;\n\t\toffset += PAGE_CACHE_SIZE;\n\t\tfrom = 0;\n\t}\n\tmark_inode_dirty(inode);\n\tbrelse(dibh);\nout:\n\treturn error;\n}", "target": 1}
{"code": "LUA_API void *lua_upvalueid (lua_State *L, int fidx, int n) {\n  StkId fi = index2addr(L, fidx);\n  switch (ttype(fi)) {\n    case LUA_TLCL: {  \n      return *getupvalref(L, fidx, n, NULL);\n    }\n    case LUA_TCCL: {  \n      CClosure *f = clCvalue(fi);\n      api_check(L, 1 <= n && n <= f->nupvalues, \"invalid upvalue index\");\n      return &f->upvalue[n - 1];\n    }\n    default: {\n      api_check(L, 0, \"closure expected\");\n      return NULL;\n    }\n  }\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayPopCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Value *v;\n    Jsi_Obj *obj;\n    obj = _this->d.obj;\n    int i = Jsi_ObjGetLength(interp, obj) - 1;\n    if (i < 0) {\n        Jsi_ValueMakeUndef(interp, ret);\n        return JSI_OK;\n    }\n    if (obj->arr) {\n        if ((v = obj->arr[i])) {\n            obj->arr[i] = NULL;\n            obj->arrCnt--;\n        }\n    } else {\n        v = Jsi_ValueArrayIndex(interp, _this, i);\n    }\n    if (v) {\n        Jsi_DecrRefCount(interp, *ret);\n        *ret = v;\n    }\n    Jsi_ObjSetLength(interp, obj, i);\n    return JSI_OK;\n}", "target": 1}
{"code": "parse_wcc_attr(netdissect_options *ndo,\n               const uint32_t *dp)\n{\n\tND_PRINT((ndo, \" sz %\" PRIu64, EXTRACT_64BITS(&dp[0])));\n\tND_PRINT((ndo, \" mtime %u.%06u ctime %u.%06u\",\n\t       EXTRACT_32BITS(&dp[2]), EXTRACT_32BITS(&dp[3]),\n\t       EXTRACT_32BITS(&dp[4]), EXTRACT_32BITS(&dp[5])));\n\treturn (dp + 6);\n}", "target": 0}
{"code": "static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)\n{\n    ap_mutex_init(pconf);\n    if (!saved_server_config_defines)\n        init_config_defines(pconf);\n    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,\n                              apr_pool_cleanup_null);\n    mpm_common_pre_config(pconf);\n    return OK;\n}", "target": 0}
{"code": "static void udf_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, udf_i_callback);\n}", "target": 0}
{"code": "static int kvm_vcpu_initialized(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.target >= 0;\n}", "target": 0}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             TfLiteMulParams* params, OpData* data) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInput1Tensor);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInput2Tensor);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_STATUS(CalculateActivationRangeQuantized(\n        context, params->activation, output, &data->output_activation_min,\n        &data->output_activation_max));\n    double real_multiplier = static_cast<double>(input1->params.scale) *\n                             static_cast<double>(input2->params.scale) /\n                             static_cast<double>(output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->output_multiplier,\n                       &data->output_shift);\n    data->input1_zero_point = input1->params.zero_point;\n    data->input2_zero_point = input2->params.zero_point;\n    data->output_zero_point = output->params.zero_point;\n  } else {\n    CalculateActivationRange(params->activation,\n                             &data->output_activation_min_f32,\n                             &data->output_activation_max_f32);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "bool recovery_cipher_abort(void)\n{\n    recovery_started = false;\n    if (awaiting_character) {\n        awaiting_character = false;\n        return true;\n    }\n    return false;\n}", "target": 0}
{"code": "Cleanup Ipv4Instance::forceProtocolUnsupportedForTest(bool new_val) {\n  bool old_val = force_ipv4_unsupported_for_test;\n  force_ipv4_unsupported_for_test = new_val;\n  return Cleanup([old_val]() { force_ipv4_unsupported_for_test = old_val; });\n}", "target": 0}
{"code": "static int l2cap_mode_supported(__u8 mode, __u32 feat_mask)\n{\n\tu32 local_feat_mask = l2cap_feat_mask;\n\tif (enable_ertm)\n\t\tlocal_feat_mask |= L2CAP_FEAT_ERTM;\n\tswitch (mode) {\n\tcase L2CAP_MODE_ERTM:\n\t\treturn L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;\n\tdefault:\n\t\treturn 0x00;\n\t}\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_discard_chunk(struct net *net,\n\t\t\t\t\t const struct sctp_endpoint *ep,\n\t\t\t\t\t const struct sctp_association *asoc,\n\t\t\t\t\t const sctp_subtype_t type,\n\t\t\t\t\t void *arg,\n\t\t\t\t\t sctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tif (!sctp_chunk_length_valid(chunk, sizeof(sctp_chunkhdr_t)))\n\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\tSCTP_DEBUG_PRINTK(\"Chunk %d is discarded\\n\", type.chunk);\n\treturn SCTP_DISPOSITION_DISCARD;\n}", "target": 0}
{"code": "RenderSVGResourceContainer* SVGDocumentExtensions::resourceById(const AtomicString& id) const\n{\n    if (id.isEmpty())\n        return 0;\n    return m_resources.get(id);\n}", "target": 0}
{"code": "void test_bind(const char *path)\n{\n\tint sfd;\n\tstruct sockaddr_un my_addr, peer_addr;\n\tsfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\tif (sfd < 0) {\n\t\tfprintf(stderr, \"Failed to open a socket for bind test\\n\");\n\t\texit(1);\n\t}\n\tmemset(&my_addr, 0, sizeof(struct sockaddr_un));\n\tmy_addr.sun_family = AF_UNIX;\n\tstrncpy(my_addr.sun_path, path,\n\t\t\tsizeof(my_addr.sun_path) - 1);\n\tif (bind(sfd, (struct sockaddr *) &my_addr,\n\t\t\t\tsizeof(struct sockaddr_un)) != -1) {\n\t\tfprintf(stderr, \"leak at bind of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at bind of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tclose(sfd);\n}", "target": 0}
{"code": "static bool vmci_transport_allow_dgram(struct vsock_sock *vsock, u32 peer_cid)\n{\n\tif (vsock->cached_peer != peer_cid) {\n\t\tvsock->cached_peer = peer_cid;\n\t\tif (!vmci_transport_is_trusted(vsock, peer_cid) &&\n\t\t    (vmci_context_get_priv_flags(peer_cid) &\n\t\t     VMCI_PRIVILEGE_FLAG_RESTRICTED)) {\n\t\t\tvsock->cached_peer_allow_dgram = false;\n\t\t} else {\n\t\t\tvsock->cached_peer_allow_dgram = true;\n\t\t}\n\t}\n\treturn vsock->cached_peer_allow_dgram;\n}", "target": 0}
{"code": "int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)\n{\n\tkuid_t euid;\n\tkgid_t egid;\n\tint id;\n\tint next_id = ids->next_id;\n\tif (size > IPCMNI)\n\t\tsize = IPCMNI;\n\tif (ids->in_use >= size)\n\t\treturn -ENOSPC;\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_init(&new->lock);\n\tnew->deleted = false;\n\trcu_read_lock();\n\tspin_lock(&new->lock);\n\tid = idr_alloc(&ids->ipcs_idr, new,\n\t\t       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,\n\t\t       GFP_NOWAIT);\n\tidr_preload_end();\n\tif (id < 0) {\n\t\tspin_unlock(&new->lock);\n\t\trcu_read_unlock();\n\t\treturn id;\n\t}\n\tids->in_use++;\n\tcurrent_euid_egid(&euid, &egid);\n\tnew->cuid = new->uid = euid;\n\tnew->gid = new->cgid = egid;\n\tif (next_id < 0) {\n\t\tnew->seq = ids->seq++;\n\t\tif (ids->seq > IPCID_SEQ_MAX)\n\t\t\tids->seq = 0;\n\t} else {\n\t\tnew->seq = ipcid_to_seqx(next_id);\n\t\tids->next_id = -1;\n\t}\n\tnew->id = ipc_buildid(id, new->seq);\n\treturn id;\n}", "target": 1}
{"code": "values_equal_for_ipcp_p (tree x, tree y)\n{\n  gcc_checking_assert (x != NULL_TREE && y != NULL_TREE);\n  if (x == y)\n    return true;\n  if (TREE_CODE (x) ==  ADDR_EXPR\n      && TREE_CODE (y) ==  ADDR_EXPR\n      && TREE_CODE (TREE_OPERAND (x, 0)) == CONST_DECL\n      && TREE_CODE (TREE_OPERAND (y, 0)) == CONST_DECL)\n    return operand_equal_p (DECL_INITIAL (TREE_OPERAND (x, 0)),\n\t\t\t    DECL_INITIAL (TREE_OPERAND (y, 0)), 0);\n  else\n    return operand_equal_p (x, y, 0);\n}", "target": 0}
{"code": "ev_archive_class_init (EvArchiveClass *klass)\n{\n        GObjectClass *object_class = (GObjectClass *) klass;\n        object_class->finalize = ev_archive_finalize;\n}", "target": 0}
{"code": "int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)\n{\n    av_assert0(0);\n    return AVERROR_BUG;\n}", "target": 0}
{"code": "crm_recv_remote_ready(void *session, gboolean encrypted, int timeout )\n{\n    struct pollfd fds = { 0, };\n    int sock = 0;\n    void *sock_ptr = NULL;\n    int rc = 0;\n    time_t start;\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        gnutls_session *tls_session = session;\n        sock_ptr = gnutls_transport_get_ptr(*tls_session);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        sock_ptr = session;\n    }\n    sock = GPOINTER_TO_INT(sock_ptr);\n    if (sock <= 0) {\n        return -ENOTCONN;\n    }\n    start = time(NULL);\n    errno = 0;\n    do {\n        fds.fd = sock;\n        fds.events = POLLIN;\n        if (errno == EINTR && (timeout > 0)) {\n            timeout = timeout - ((time(NULL) - start) * 1000);\n            if (timeout < 1000) {\n                timeout = 1000;\n            }\n        }\n        rc = poll(&fds, 1, timeout);\n    } while (rc < 0 && errno == EINTR);\n    return rc;\n}", "target": 0}
{"code": "static int file_exp(STANZA *s)\n{\n    BIGNUM *a = NULL, *e = NULL, *exp = NULL, *ret = NULL;\n    int st = 0;\n    if (!TEST_ptr(a = getBN(s, \"A\"))\n            || !TEST_ptr(e = getBN(s, \"E\"))\n            || !TEST_ptr(exp = getBN(s, \"Exp\"))\n            || !TEST_ptr(ret = BN_new()))\n        goto err;\n    if (!TEST_true(BN_exp(ret, a, e, ctx))\n            || !equalBN(\"A ^ E\", exp, ret))\n        goto err;\n    st = 1;\n err:\n    BN_free(a);\n    BN_free(e);\n    BN_free(exp);\n    BN_free(ret);\n    return st;\n}", "target": 0}
{"code": "COMPAT_SYSCALL_DEFINE5(waitid,\n\t\tint, which, compat_pid_t, pid,\n\t\tstruct compat_siginfo __user *, infop, int, options,\n\t\tstruct compat_rusage __user *, uru)\n{\n\tstruct rusage ru;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err && uru) {\n\t\tif (COMPAT_USE_64BIT_TIME)\n\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n\t\telse\n\t\t\terr = put_compat_rusage(&ru, uru);\n\t\tif (err)\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "static int nut_read_header(AVFormatContext *s)\n{\n    NUTContext *nut = s->priv_data;\n    AVIOContext *bc = s->pb;\n    int64_t pos;\n    int initialized_stream_count;\n    nut->avf = s;\n    pos = 0;\n    do {\n        pos = find_startcode(bc, MAIN_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"No main startcode found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n    } while (decode_main_header(nut) < 0);\n    pos = 0;\n    for (initialized_stream_count = 0; initialized_stream_count < s->nb_streams;) {\n        pos = find_startcode(bc, STREAM_STARTCODE, pos) + 1;\n        if (pos < 0 + 1) {\n            av_log(s, AV_LOG_ERROR, \"Not all stream headers found.\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if (decode_stream_header(nut) >= 0)\n            initialized_stream_count++;\n    }\n    pos = 0;\n    for (;;) {\n        uint64_t startcode = find_any_startcode(bc, pos);\n        pos = avio_tell(bc);\n        if (startcode == 0) {\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n            return AVERROR_INVALIDDATA;\n        } else if (startcode == SYNCPOINT_STARTCODE) {\n            nut->next_startcode = startcode;\n            break;\n        } else if (startcode != INFO_STARTCODE) {\n            continue;\n        }\n        decode_info_header(nut);\n    }\n    ffformatcontext(s)->data_offset = pos - 8;\n    if (bc->seekable & AVIO_SEEKABLE_NORMAL) {\n        int64_t orig_pos = avio_tell(bc);\n        find_and_decode_index(nut);\n        avio_seek(bc, orig_pos, SEEK_SET);\n    }\n    av_assert0(nut->next_startcode == SYNCPOINT_STARTCODE);\n    ff_metadata_conv_ctx(s, NULL, ff_nut_metadata_conv);\n    return 0;\n}", "target": 1}
{"code": "static Jsi_RC NumberToFixedCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_Value *pa = Jsi_ValueArrayIndex(interp, args, skip);\n    if (pa && Jsi_GetIntFromValue(interp, pa, &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMFFMT, prec, num);\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "static struct dentry *proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\tinode->i_nlink = 4;\n#ifdef CONFIG_SECURITY\n\tinode->i_nlink += 1;\n#endif\n\tdentry->d_op = &pid_dentry_operations;\n\td_add(dentry, inode);\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}", "target": 0}
{"code": "setup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n\tif (efi_enabled(EFI_OLD_MEMMAP))\n\t\treturn 0;\n\tparams->secure_boot = boot_params.secure_boot;\n\tei->efi_loader_signature = current_ei->efi_loader_signature;\n\tei->efi_systab = current_ei->efi_systab;\n\tei->efi_systab_hi = current_ei->efi_systab_hi;\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}", "target": 0}
{"code": "gopherEndHTML(GopherStateData * gopherState)\n{\n    StoreEntry *e = gopherState->entry;\n    if (!gopherState->HTML_header_added) {\n        gopherHTMLHeader(e, \"Server Return Nothing\", nullptr);\n        storeAppendPrintf(e, \"<P>The Gopher query resulted in a blank response</P>\");\n    } else if (gopherState->HTML_pre) {\n        storeAppendPrintf(e, \"</PRE>\\n\");\n    }\n    gopherHTMLFooter(e);\n}", "target": 1}
{"code": "static int sof_set_get_large_ctrl_data(struct snd_sof_dev *sdev,\n\t\t\t\t       struct sof_ipc_ctrl_data *cdata,\n\t\t\t\t       struct sof_ipc_ctrl_data_params *sparams,\n\t\t\t\t       bool send)\n{\n\tstruct sof_ipc_ctrl_data *partdata;\n\tsize_t send_bytes;\n\tsize_t offset = 0;\n\tsize_t msg_bytes;\n\tsize_t pl_size;\n\tint err;\n\tint i;\n\tpartdata = kzalloc(SOF_IPC_MSG_MAX_SIZE, GFP_KERNEL);\n\tif (!partdata)\n\t\treturn -ENOMEM;\n\tif (send)\n\t\terr = sof_get_ctrl_copy_params(cdata->type, cdata, partdata,\n\t\t\t\t\t       sparams);\n\telse\n\t\terr = sof_get_ctrl_copy_params(cdata->type, partdata, cdata,\n\t\t\t\t\t       sparams);\n\tif (err < 0)\n\t\treturn err;\n\tmsg_bytes = sparams->msg_bytes;\n\tpl_size = sparams->pl_size;\n\tmemcpy(partdata, cdata, sparams->hdr_bytes);\n\tmutex_lock(&sdev->ipc->tx_mutex);\n\tfor (i = 0; i < sparams->num_msg; i++) {\n\t\tsend_bytes = min(msg_bytes, pl_size);\n\t\tpartdata->num_elems = send_bytes;\n\t\tpartdata->rhdr.hdr.size = sparams->hdr_bytes + send_bytes;\n\t\tpartdata->msg_index = i;\n\t\tmsg_bytes -= send_bytes;\n\t\tpartdata->elems_remaining = msg_bytes;\n\t\tif (send)\n\t\t\tmemcpy(sparams->dst, sparams->src + offset, send_bytes);\n\t\terr = sof_ipc_tx_message_unlocked(sdev->ipc,\n\t\t\t\t\t\t  partdata->rhdr.hdr.cmd,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size,\n\t\t\t\t\t\t  partdata,\n\t\t\t\t\t\t  partdata->rhdr.hdr.size);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tif (!send)\n\t\t\tmemcpy(sparams->dst + offset, sparams->src, send_bytes);\n\t\toffset += pl_size;\n\t}\n\tmutex_unlock(&sdev->ipc->tx_mutex);\n\tkfree(partdata);\n\treturn err;\n}", "target": 1}
{"code": "void nfc_llcp_unregister_device(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_debug(\"No such device\\n\");\n\t\treturn;\n\t}\n\tlocal_cleanup(local);\n\tnfc_llcp_local_put(local);\n}", "target": 1}
{"code": "apr_byte_t oidc_post_preserve_javascript(request_rec *r, const char *location,\n\t\tchar **javascript, char **javascript_method) {\n\tif (oidc_cfg_dir_preserve_post(r) == 0)\n\t\treturn FALSE;\n\toidc_debug(r, \"enter\");\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tconst char *method = oidc_original_request_method(r, cfg, FALSE);\n\tif (apr_strnatcmp(method, OIDC_METHOD_FORM_POST) != 0)\n\t\treturn FALSE;\n\tapr_table_t *params = apr_table_make(r->pool, 8);\n\tif (oidc_util_read_post_params(r, params, FALSE, NULL) == FALSE) {\n\t\toidc_error(r, \"something went wrong when reading the POST parameters\");\n\t\treturn FALSE;\n\t}\n\tconst apr_array_header_t *arr = apr_table_elts(params);\n\tconst apr_table_entry_t *elts = (const apr_table_entry_t*) arr->elts;\n\tint i;\n\tchar *json = \"\";\n\tfor (i = 0; i < arr->nelts; i++) {\n\t\tjson = apr_psprintf(r->pool, \"%s'%s': '%s'%s\", json,\n\t\t\t\toidc_util_escape_string(r, elts[i].key),\n\t\t\t\toidc_util_escape_string(r, elts[i].val),\n\t\t\t\ti < arr->nelts - 1 ? \",\" : \"\");\n\t}\n\tjson = apr_psprintf(r->pool, \"{ %s }\", json);\n\tconst char *jmethod = \"preserveOnLoad\";\n\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "gopherHTMLHeader(StoreEntry * e, const char *title, const char *substring)\n{\n    storeAppendPrintf(e, \"<!DOCTYPE HTML PUBLIC \\\"-\n    storeAppendPrintf(e, \"<HTML><HEAD><TITLE>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</TITLE>\");\n    storeAppendPrintf(e, \"<STYLE type=\\\"text/css\\\"><!--BODY{background-color:#ffffff;font-family:verdana,sans-serif}--></STYLE>\\n\");\n    storeAppendPrintf(e, \"</HEAD>\\n<BODY><H1>\");\n    storeAppendPrintf(e, title, substring);\n    storeAppendPrintf(e, \"</H1>\\n\");\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::SwapBuffersCompleted(\n    const BufferPresentedCallback& ack_callback,\n    const scoped_refptr<ui::Texture>& texture_to_return) {\n  ui::Compositor* compositor = GetCompositor();\n  if (!compositor) {\n    ack_callback.Run(false, texture_to_return);\n  } else {\n    AddOnCommitCallbackAndDisableLocks(\n        base::Bind(ack_callback, false, texture_to_return));\n  }\n  DidReceiveFrameFromRenderer();\n}", "target": 0}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  if (input == nullptr) {\n    VLOG(1) << \"node = \" << node.name() << \" input = \" << node.input(0);\n    return false;\n  }\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static bool can_skip_alu_sanitation(const struct bpf_verifier_env *env,\n\t\t\t\t    const struct bpf_insn *insn)\n{\n\treturn env->allow_ptr_leaks || BPF_SRC(insn->code) == BPF_K;\n}", "target": 0}
{"code": "bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)\n{\n  bgp_notify_send (peer, \n\t\t   BGP_NOTIFY_OPEN_ERR, \n\t\t   BGP_NOTIFY_OPEN_AUTH_FAILURE); \n  return -1;\n}", "target": 1}
{"code": "int uev_init1(uev_ctx_t *ctx, int maxevents)\n{\n\tif (!ctx || maxevents < 1) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (maxevents > UEV_MAX_EVENTS)\n\t\tmaxevents = UEV_MAX_EVENTS;\n\tmemset(ctx, 0, sizeof(*ctx));\n\tctx->maxevents = maxevents;\n\treturn _init(ctx, 0);\n}", "target": 0}
{"code": "HMAC_SHA256_Update(struct HMAC_SHA256_CTX * ctx, const void *in, size_t len)\n{\n  scrypt_SHA256_Update(&ctx->ictx, in, len);\n}", "target": 1}
{"code": "shutdown_mib(void)\n{\n    unload_all_mibs();\n    if (tree_top) {\n        if (tree_top->label)\n            SNMP_FREE(tree_top->label);\n        SNMP_FREE(tree_top);\n    }\n    tree_head = NULL;\n    Mib = NULL;\n    if (_mibindexes) {\n        int i;\n        for (i = 0; i < _mibindex; ++i)\n            SNMP_FREE(_mibindexes[i]);\n        free(_mibindexes);\n        _mibindex = 0;\n        _mibindex_max = 0;\n        _mibindexes = NULL;\n    }\n    if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n        SNMP_FREE(Prefix);\n    if (Prefix)\n        Prefix = NULL;\n    SNMP_FREE(confmibs);\n    SNMP_FREE(confmibdir);\n}", "target": 1}
{"code": "static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,\n\t\t\t\t\tunsigned int optlen)\n{\n\tint val;\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tif (optlen < sizeof(int))\n\t\treturn -EINVAL;\n\tif (get_user(val, (int __user *)optval))\n\t\treturn -EFAULT;\n\tif (!sctp_is_ep_boundall(sk) && val)\n\t\treturn -EINVAL;\n\tif ((val && sp->do_auto_asconf) || (!val && !sp->do_auto_asconf))\n\t\treturn 0;\n\tspin_lock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\tif (val == 0 && sp->do_auto_asconf) {\n\t\tlist_del(&sp->auto_asconf_list);\n\t\tsp->do_auto_asconf = 0;\n\t} else if (val && !sp->do_auto_asconf) {\n\t\tlist_add_tail(&sp->auto_asconf_list,\n\t\t    &sock_net(sk)->sctp.auto_asconf_splist);\n\t\tsp->do_auto_asconf = 1;\n\t}\n\tspin_unlock_bh(&sock_net(sk)->sctp.addr_wq_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static void nf_tables_expr_destroy(const struct nft_ctx *ctx,\n\t\t\t\t   struct nft_expr *expr)\n{\n\tif (expr->ops->destroy)\n\t\texpr->ops->destroy(ctx, expr);\n\tmodule_put(expr->ops->type->owner);\n}", "target": 0}
{"code": "int regexec(Reprog *prog, const char *sp, Resub *sub, int eflags)\n{\n\tResub scratch;\n\tint i;\n\tif (!sub)\n\t\tsub = &scratch;\n\tsub->nsub = prog->nsub;\n\tfor (i = 0; i < MAXSUB; ++i)\n\t\tsub->sub[i].sp = sub->sub[i].ep = NULL;\n\treturn !match(prog->start, sp, sp, prog->flags | eflags, sub);\n}", "target": 1}
{"code": "xml_unload_external_entity(const char *URI, xmlCharEncoding enc)    {\n    return NULL;\n}", "target": 0}
{"code": "void scramble(FILE* keyFile){\n\tfor (int j = 0; j < 16; ++j)\n\t{\n\t\tchar temp = 0;\n\t\tfor (int i = 0; i < 256; ++i)\n\t\t{\n\t\t\tscrambleAsciiTables[j][i] = i;\n\t\t}\n\t\tif (keyFile != NULL){\n\t\t\tint size;\n\t\t\tchar extractedString[BUFFER_SIZE] = \"\";\n\t\t\twhile((size = fread(extractedString, 1, BUFFER_SIZE, keyFile)) > 0){\n\t\t\t\tfor (int i = 0; i < size; ++i)\n\t\t\t\t{\n\t\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][(unsigned char)(extractedString[i])];\n\t\t\t\t\tscrambleAsciiTables[j][(unsigned char)(extractedString[i])] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\trewind(keyFile);\n\t\t} else {\n\t\t\tunsigned char random256;\n\t\t\tfor (int i = 0; i < 10 * 256; ++i)\n\t\t\t{\n\t\t\t\trandom256 = generateNumber() ^ passPhrase[passIndex];\n\t\t\t\tpassIndex++;\n\t\t\t\tpassIndex %= 16384;\n\t\t\t\ttemp = scrambleAsciiTables[j][i%256];\n\t\t\t\tscrambleAsciiTables[j][i%256] = scrambleAsciiTables[j][random256];\n\t\t\t\tscrambleAsciiTables[j][random256] = temp;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "  static Handle<Value> Reinitialize(const Arguments& args) {\n    HandleScope scope;\n    http_parser_type type =\n        static_cast<http_parser_type>(args[0]->Int32Value());\n    if (type != HTTP_REQUEST && type != HTTP_RESPONSE) {\n      return ThrowException(Exception::Error(String::New(\n          \"Argument must be HTTPParser.REQUEST or HTTPParser.RESPONSE\")));\n    }\n    Parser* parser = ObjectWrap::Unwrap<Parser>(args.This());\n    parser->Init(type);\n    return Undefined();\n  }", "target": 0}
{"code": "untrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n    switch (response_id)\n    {\n        case RESPONSE_RUN:\n        {\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n        }\n        break;\n        case RESPONSE_MARK_TRUSTED:\n        {\n            file = nautilus_file_get_location (parameters->file);\n            nautilus_file_mark_desktop_file_trusted (file,\n                                                     parameters->parent_window,\n                                                     TRUE,\n                                                     NULL, NULL);\n            g_object_unref (file);\n        }\n        break;\n        default:\n        {\n        }\n        break;\n    }\n    gtk_widget_destroy (GTK_WIDGET (dialog));\n    activate_parameters_desktop_free (parameters);\n}", "target": 1}
{"code": "void PrintWebViewHelper::Print(WebKit::WebFrame* frame,\n                               const WebKit::WebNode& node) {\n  if (print_web_view_)\n    return;\n  scoped_ptr<PrepareFrameAndViewForPrint> prepare;\n  if (!InitPrintSettingsAndPrepareFrame(frame, node, &prepare)) {\n    DidFinishPrinting(FAIL_PRINT);\n    return;  \n  }\n  int expected_page_count = 0;\n  bool use_browser_overlays = true;\n  expected_page_count = prepare->GetExpectedPageCount();\n  if (expected_page_count)\n    use_browser_overlays = prepare->ShouldUseBrowserOverlays();\n  prepare.reset();\n  if (!expected_page_count) {\n    DidFinishPrinting(OK);  \n    return;\n  }\n  if (!GetPrintSettingsFromUser(frame, node, expected_page_count,\n                                use_browser_overlays)) {\n    DidFinishPrinting(OK);  \n    return;\n  }\n  if (!RenderPagesForPrint(frame, node, NULL)) {\n    LOG(ERROR) << \"RenderPagesForPrint failed\";\n    DidFinishPrinting(FAIL_PRINT);\n  }\n  ResetScriptedPrintCount();\n}", "target": 0}
{"code": "TEST_F(PlaintextRecordTest, TestSkipOversizedRecord) {\n  read_.setSkipEncryptedRecords(true);\n  addToQueue(\"170301fffb\");\n  auto longBuf = IOBuf::create(0xfffb);\n  longBuf->append(0xfffb);\n  queue_.append(std::move(longBuf));\n  EXPECT_FALSE(read_.read(queue_).hasValue());\n  EXPECT_TRUE(queue_.empty());\n}", "target": 0}
{"code": "TEST(VulnerabilityTest, CRLFInjection) {\n  Server svr;\n  svr.Post(\"/test1\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 1\", \"text/plain\");\n  });\n  svr.Delete(\"/test2\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 2\", \"text/plain\");\n  });\n  svr.Put(\"/test3\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 3\", \"text/plain\");\n  });\n  svr.Patch(\"/test4\", [](const Request &, Response &res) {\n    res.set_content(\"Hello 4\", \"text/plain\");\n  });\n  svr.set_logger([](const Request &req, const Response & ) {\n    for (const auto &x : req.headers) {\n      auto key = x.first;\n      EXPECT_STRNE(\"evil\", key.c_str());\n    }\n  });\n  auto thread = std::thread([&]() { svr.listen(HOST, PORT); });\n  auto se = detail::scope_exit([&] {\n    svr.stop();\n    thread.join();\n    ASSERT_FALSE(svr.is_running());\n  });\n  std::this_thread::sleep_for(std::chrono::seconds(1));\n  {\n    Client cli(HOST, PORT);\n    cli.Post(\"/test1\", \"A=B\",\n             \"application/x-www-form-urlencoded\\r\\nevil: hello1\");\n    cli.Delete(\"/test2\", \"A=B\", \"text/plain\\r\\nevil: hello2\");\n    cli.Put(\"/test3\", \"text\", \"text/plain\\r\\nevil: hello3\");\n    cli.Patch(\"/test4\", \"content\", \"text/plain\\r\\nevil: hello4\");\n  }\n}", "target": 0}
{"code": "}\nGF_Err jp2h_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read_ex(s, bs, jp2h_on_child_box, s->type);", "target": 0}
{"code": "static struct nlattr *reserve_sfa_size(struct sw_flow_actions **sfa,\n\t\t\t\t       int attr_len, bool log)\n{\n\tstruct sw_flow_actions *acts;\n\tint new_acts_size;\n\tsize_t req_size = NLA_ALIGN(attr_len);\n\tint next_offset = offsetof(struct sw_flow_actions, actions) +\n\t\t\t\t\t(*sfa)->actions_len;\n\tif (req_size <= (ksize(*sfa) - next_offset))\n\t\tgoto out;\n\tnew_acts_size = max(next_offset + req_size, ksize(*sfa) * 2);\n\tif (new_acts_size > MAX_ACTIONS_BUFSIZE) {\n\t\tif ((MAX_ACTIONS_BUFSIZE - next_offset) < req_size) {\n\t\t\tOVS_NLERR(log, \"Flow action size exceeds max %u\",\n\t\t\t\t  MAX_ACTIONS_BUFSIZE);\n\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t}\n\t\tnew_acts_size = MAX_ACTIONS_BUFSIZE;\n\t}\n\tacts = nla_alloc_flow_actions(new_acts_size);\n\tif (IS_ERR(acts))\n\t\treturn (void *)acts;\n\tmemcpy(acts->actions, (*sfa)->actions, (*sfa)->actions_len);\n\tacts->actions_len = (*sfa)->actions_len;\n\tacts->orig_len = (*sfa)->orig_len;\n\tkfree(*sfa);\n\t*sfa = acts;\nout:\n\t(*sfa)->actions_len += req_size;\n\treturn  (struct nlattr *) ((unsigned char *)(*sfa) + next_offset);\n}", "target": 1}
{"code": "close_msg_fds(struct VhostUserMsg *msg)\n{\n\tint i;\n\tfor (i = 0; i < msg->fd_num; i++)\n\t\tclose(msg->fds[i]);\n}", "target": 0}
{"code": "int page_name_is_good(char* page_name)\n{\n    if (!page_name)\n        return FALSE;\n    if (!isalnum(page[0]))\n        return FALSE;\n    if (strstr(page, \"..\"))\n        return FALSE;\n    return TRUE;\n}", "target": 0}
{"code": "static void setGenericValues(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n    OFCHECK(ct->getPatient().setPatientName(\"Bond^James\").good());\n    OFCHECK(ct->getPatient().setPatientID(\"007\").good());\n    OFCHECK(ct->getPatient().setPatientBirthDate(\"19771007\").good());\n    OFCHECK(ct->getStudy().setStudyDate(\"20190801\").good());\n    OFCHECK(ct->getStudy().setStudyTime(\"120000\").good());\n    OFCHECK(ct->getStudy().setStudyID(\"1\").good());\n    OFCHECK(ct->getPatientStudy().setPatientAge(\"040Y\").good());\n    OFCHECK(ct->getSeries().setSeriesDescription(\"Test Description\").good());\n    OFCHECK(ct->getSeries().setSeriesNumber(\"1\").good());\n    OFCHECK(ct->getSeries().setPatientPosition(\"HFS\").good());\n    OFCHECK(ct->getStudy().setStudyInstanceUID(\"1.2.276.0.7230010.3.1.2.8323329.14863.1565940357.864811\").good());\n    OFCHECK(ct->getFrameOfReference().setFrameOfReferenceUID(\"2.25.30853397773651184949181049330553108086\").good());\n    OFCHECK(ct->getSeries().setSeriesInstanceUID(\"1.2.276.0.7230010.3.1.3.8323329.14863.1565940357.864812\").good());\n    OFCHECK(ct->getSOPCommon().setSOPInstanceUID(\"1.2.276.0.7230010.3.1.4.8323329.14863.1565940357.864813\").good());\n    OFCHECK(ct->getIODMultiFrameFGModule().setContentTime(\"092557\").good());\n    OFCHECK(ct->getIODMultiFrameFGModule().setContentDate(\"20190816\").good());\n}", "target": 0}
{"code": "static long kvm_dev_ioctl(struct file *filp,\n\t\t\t  unsigned int ioctl, unsigned long arg)\n{\n\tlong r = -EINVAL;\n\tswitch (ioctl) {\n\tcase KVM_GET_API_VERSION:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = KVM_API_VERSION;\n\t\tbreak;\n\tcase KVM_CREATE_VM:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = kvm_dev_ioctl_create_vm();\n\t\tbreak;\n\tcase KVM_CHECK_EXTENSION:\n\t\tr = kvm_dev_ioctl_check_extension_generic(arg);\n\t\tbreak;\n\tcase KVM_GET_VCPU_MMAP_SIZE:\n\t\tr = -EINVAL;\n\t\tif (arg)\n\t\t\tgoto out;\n\t\tr = PAGE_SIZE;     \n#ifdef CONFIG_X86\n\t\tr += PAGE_SIZE;    \n#endif\n#ifdef KVM_COALESCED_MMIO_PAGE_OFFSET\n\t\tr += PAGE_SIZE;    \n#endif\n\t\tbreak;\n\tcase KVM_TRACE_ENABLE:\n\tcase KVM_TRACE_PAUSE:\n\tcase KVM_TRACE_DISABLE:\n\t\tr = -EOPNOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_arch_dev_ioctl(filp, ioctl, arg);\n\t}\nout:\n\treturn r;\n}", "target": 0}
{"code": "Item *Item_field::update_value_transformer(uchar *select_arg)\n{\n  SELECT_LEX *select= (SELECT_LEX*)select_arg;\n  DBUG_ASSERT(fixed);\n  if (field->table != select->context.table_list->table &&\n      type() != Item::TRIGGER_FIELD_ITEM)\n  {\n    List<Item> *all_fields= &select->join->all_fields;\n    Item **ref_pointer_array= select->ref_pointer_array;\n    DBUG_ASSERT(all_fields->elements <= select->ref_pointer_array_size);\n    int el= all_fields->elements;\n    Item_ref *ref;\n    ref_pointer_array[el]= (Item*)this;\n    all_fields->push_front((Item*)this);\n    ref= new Item_ref(&select->context, ref_pointer_array + el,\n                      table_name, field_name);\n    return ref;\n  }\n  return this;\n}", "target": 0}
{"code": "void UpdateDownloader::CleanLeftovers()\n{\n    std::wstring tmpdir;\n    if ( !Settings::ReadConfigValue(\"UpdateTempDir\", tmpdir) )\n        return;\n    try\n    {\n        if (tmpdir.find(GetUniqueTempDirectoryPrefix()) != 0)\n        {\n            Settings::DeleteConfigValue(\"UpdateTempDir\");\n            return;\n        }\n    }\n    catch (Win32Exception&) \n    {\n        return;\n    }\n    tmpdir.append(1, '\\0'); \n    SHFILEOPSTRUCT fos = {0};\n    fos.wFunc = FO_DELETE;\n    fos.pFrom = tmpdir.c_str();\n    fos.fFlags = FOF_NO_UI | \n                 FOF_SILENT |\n                 FOF_NOCONFIRMATION |\n                 FOF_NOERRORUI;\n    if ( SHFileOperation(&fos) == 0 )\n    {\n        Settings::DeleteConfigValue(\"UpdateTempDir\");\n    }\n}", "target": 0}
{"code": "void Item::cleanup()\n{\n  DBUG_ENTER(\"Item::cleanup\");\n  DBUG_PRINT(\"enter\", (\"this: %p\", this));\n  fixed=0;\n  marker= 0;\n  join_tab_idx= MAX_TABLES;\n  if (orig_name)\n    name= orig_name;\n  DBUG_VOID_RETURN;\n}", "target": 0}
{"code": "PixarLogSetupDecode(TIFF* tif)\n{\n\tstatic const char module[] = \"PixarLogSetupDecode\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tPixarLogState* sp = DecoderState(tif);\n\ttmsize_t tbuf_size;\n\tassert(sp != NULL);\n\ttif->tif_postdecode = _TIFFNoPostDecode;  \n\tsp->stride = (td->td_planarconfig == PLANARCONFIG_CONTIG ?\n\t    td->td_samplesperpixel : 1);\n\ttbuf_size = multiply_ms(multiply_ms(multiply_ms(sp->stride, td->td_imagewidth),\n\t\t\t\t      td->td_rowsperstrip), sizeof(uint16));\n\ttbuf_size = add_ms(tbuf_size, sizeof(uint16) * sp->stride);\n\tif (tbuf_size == 0)\n\t\treturn (0);   \n\tsp->tbuf = (uint16 *) _TIFFmalloc(tbuf_size);\n\tif (sp->tbuf == NULL)\n\t\treturn (0);\n\tsp->tbuf_size = tbuf_size;\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN)\n\t\tsp->user_datafmt = PixarLogGuessDataFmt(td);\n\tif (sp->user_datafmt == PIXARLOGDATAFMT_UNKNOWN) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module,\n\t\t\t\"PixarLog compression can't handle bits depth/data format combination (depth: %d)\", \n\t\t\ttd->td_bitspersample);\n\t\treturn (0);\n\t}\n\tif (inflateInit(&sp->stream) != Z_OK) {\n\t\tTIFFErrorExt(tif->tif_clientdata, module, \"%s\", sp->stream.msg ? sp->stream.msg : \"(null)\");\n\t\treturn (0);\n\t} else {\n\t\tsp->state |= PLSTATE_INIT;\n\t\treturn (1);\n\t}\n}", "target": 0}
{"code": "ikev2_gen_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext)\n{\n\tstruct isakmp_gen e;\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tikev2_pay_print(ndo, NPSTR(tpay), e.critical);\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 0}
{"code": "static int proc_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset,\n\t\tstruct fuse_file_info *fi)\n{\n\tif (filler(buf, \"cpuinfo\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"meminfo\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"stat\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"uptime\", NULL, 0) != 0 ||\n\t\t\t\tfiller(buf, \"diskstats\", NULL, 0) != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "static void __net_exit pfkey_net_exit(struct net *net)\n{\n\tstruct netns_pfkey *net_pfkey = net_generic(net, pfkey_net_id);\n\tpfkey_exit_proc(net);\n\tWARN_ON(!hlist_empty(&net_pfkey->table));\n}", "target": 0}
{"code": "inline void* aligned_malloc(size_t size, size_t alignment) {\n  return folly::detail::aligned_malloc(size, alignment);\n}", "target": 1}
{"code": "void AverageEvalQuantizedUint8(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<uint8_t>(input), GetTensorShape(output), \\\n                    GetTensorData<uint8_t>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "static inline bool cpu_has_vmx_ple(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING;\n}", "target": 0}
{"code": "d_lite_s_alloc_simple(VALUE klass)\n{\n    return d_simple_new_internal(klass,\n\t\t\t\t INT2FIX(0), 0,\n\t\t\t\t DEFAULT_SG,\n\t\t\t\t 0, 0, 0,\n\t\t\t\t HAVE_JD);\n}", "target": 0}
{"code": "static void init_security_types(struct nvnc* server)\n{\n#define ADD_SECURITY_TYPE(type) \\\n\tassert(server->n_security_types < MAX_SECURITY_TYPES); \\\n\tserver->security_types[server->n_security_types++] = (type);\n\tif (server->n_security_types > 0)\n\t\treturn;\n\tif (server->auth_flags & NVNC_AUTH_REQUIRE_AUTH) {\n\t\tassert(server->auth_fn);\n#ifdef ENABLE_TLS\n\t\tif (server->tls_creds) {\n\t\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_VENCRYPT);\n\t\t}\n#endif\n#ifdef HAVE_CRYPTO\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_RSA_AES256);\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_RSA_AES);\n\t\tif (!(server->auth_flags & NVNC_AUTH_REQUIRE_ENCRYPTION)) {\n\t\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_APPLE_DH);\n\t\t}\n#endif\n\t} else {\n\t\tADD_SECURITY_TYPE(RFB_SECURITY_TYPE_NONE);\n\t}\n\tif (server->n_security_types == 0) {\n\t\tnvnc_log(NVNC_LOG_PANIC, \"Failed to satisfy requested security constraints\");\n\t}\n#undef ADD_SECURITY_TYPE\n}", "target": 0}
{"code": "PHPAPI int php_lint_script(zend_file_handle *file)\n{\n\tzend_op_array *op_array;\n\tint retval = FAILURE;\n\tzend_try {\n\t\top_array = zend_compile_file(file, ZEND_INCLUDE);\n\t\tzend_destroy_file_handle(file);\n\t\tif (op_array) {\n\t\t\tdestroy_op_array(op_array);\n\t\t\tefree(op_array);\n\t\t\tretval = SUCCESS;\n\t\t}\n\t} zend_end_try();\n\tif (EG(exception)) {\n\t\tzend_exception_error(EG(exception), E_ERROR);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "void TightDecoder::FilterGradient(const rdr::U8* inbuf,\n                                  const PixelFormat& pf, PIXEL_T* outbuf,\n                                  int stride, const Rect& r)\n{\n  int x, y, c;\n  static rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  static rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    pf.rgbFromBuffer(pix, &inbuf[y*rectWidth], 1);\n    for (c = 0; c < 3; c++)\n      pix[c] += prevRow[c];\n    memcpy(thisRow, pix, sizeof(pix));\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 255) {\n          est[c] = 255;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n      }\n      pf.rgbFromBuffer(pix, &inbuf[y*rectWidth+x], 1);\n      for (c = 0; c < 3; c++)\n        pix[c] += est[c];\n      memcpy(&thisRow[x*3], pix, sizeof(pix));\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "cp949_mbc_to_code(const UChar* p, const UChar* end, OnigEncoding enc)\n{\n  return onigenc_mbn_mbc_to_code(enc, p, end);\n}", "target": 0}
{"code": "crm_parse_remote_buffer(char **msg_buf)\n{\n    char *buf = NULL;\n    char *start = NULL;\n    char *end = NULL;\n    xmlNode *xml = NULL;\n    if (*msg_buf == NULL) {\n        return NULL;\n    }\n    buf = *msg_buf;\n    *msg_buf = NULL;\n    start = buf;\n    end = strstr(start, REMOTE_MSG_TERMINATOR);\n    while (!xml && end) {\n        end[0] = '\\0';\n        end += strlen(REMOTE_MSG_TERMINATOR);\n        xml = string2xml(start);\n        if (xml == NULL) {\n            crm_err(\"Couldn't parse: '%.120s'\", start);\n        }\n        start = end;\n        end = strstr(start, REMOTE_MSG_TERMINATOR);\n    }\n    if (xml && start) {\n        *msg_buf = strdup(start);\n        free(buf);\n    } else if (!xml) {\n        *msg_buf = buf;\n    }\n    return xml;\n}", "target": 0}
{"code": "kick_delayed_job(tube t)\n{\n    int r;\n    job j;\n    size_t z;\n    j = pq_take(&t->delay);\n    if (!j) return 0;\n    z = binlog_reserve_space_update(j);\n    if (!z) return pq_give(&t->delay, j), 0; \n    j->reserved_binlog_space += z;\n    j->kick_ct++;\n    r = enqueue_job(j, 0, 1);\n    if (r == 1) return 1;\n    r = enqueue_job(j, j->delay, 0);\n    if (r == 1) return 0;\n    bury_job(j, 0);\n    return 0;\n}", "target": 0}
{"code": "void test_mknod(const char *path)\n{\n\tif (mknod(path, 0755, makedev(0, 0)) == 0) {\n\t\tfprintf(stderr, \"leak at mknod of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at mknod of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "AP_DECLARE(int) ap_some_authn_required(request_rec *r)\n{\n    int access_status;\n    switch (ap_satisfies(r)) {\n    case SATISFY_ALL:\n    case SATISFY_NOSPEC:\n        if ((access_status = ap_run_access_checker(r)) != OK) {\n            break;\n        }\n        access_status = ap_run_access_checker_ex(r);\n        if (access_status == DECLINED) {\n            return TRUE;\n        }\n        break;\n    case SATISFY_ANY:\n        if ((access_status = ap_run_access_checker(r)) == OK) {\n            break;\n        }\n        access_status = ap_run_access_checker_ex(r);\n        if (access_status == DECLINED) {\n            return TRUE;\n        }\n        break;\n    }\n    return FALSE;\n}", "target": 0}
{"code": "Adaptation::Ecap::Host::Host()\n{\n    libecap::headerTransferEncoding.assignHostId(Http::HdrType::TRANSFER_ENCODING);\n    libecap::headerReferer.assignHostId(Http::HdrType::REFERER);\n    libecap::headerContentLength.assignHostId(Http::HdrType::CONTENT_LENGTH);\n    libecap::headerVia.assignHostId(Http::HdrType::VIA);\n    libecap::protocolHttp.assignHostId(AnyP::PROTO_HTTP);\n    libecap::protocolHttps.assignHostId(AnyP::PROTO_HTTPS);\n    libecap::protocolFtp.assignHostId(AnyP::PROTO_FTP);\n    libecap::protocolGopher.assignHostId(AnyP::PROTO_GOPHER);\n    libecap::protocolWais.assignHostId(AnyP::PROTO_WAIS);\n    libecap::protocolUrn.assignHostId(AnyP::PROTO_URN);\n    libecap::protocolWhois.assignHostId(AnyP::PROTO_WHOIS);\n    protocolCacheObj.assignHostId(AnyP::PROTO_CACHE_OBJECT);\n    protocolIcp.assignHostId(AnyP::PROTO_ICP);\n#if USE_HTCP\n    protocolHtcp.assignHostId(AnyP::PROTO_HTCP);\n#endif\n    protocolIcy.assignHostId(AnyP::PROTO_ICY);\n    protocolUnknown.assignHostId(AnyP::PROTO_UNKNOWN);\n    metaBypassable.assignHostId(1);\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageXbmCtx(gdImagePtr image, char* file_name, int fg, gdIOCtx * out)\n{\n\tint x, y, c, b, sx, sy, p;\n\tchar *name, *f;\n\tsize_t i, l;\n\tname = file_name;\n\tif ((f = strrchr(name, '/')) != NULL) name = f+1;\n\tif ((f = strrchr(name, '\\\\')) != NULL) name = f+1;\n\tname = strdup(name);\n\tif ((f = strrchr(name, '.')) != NULL && !strcasecmp(f, \".XBM\")) *f = '\\0';\n\tif ((l = strlen(name)) == 0) {\n\t\tfree(name);\n\t\tname = strdup(\"image\");\n\t} else {\n\t\tfor (i=0; i<l; i++) {\n\t\t\tif (!isupper(name[i]) && !islower(name[i]) && !isdigit(name[i])) {\n\t\t\t\tname[i] = '_';\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"#define %s_width %d\\n\", name, gdImageSX(image));\n\tgdCtxPrintf(out, \"#define %s_height %d\\n\", name, gdImageSY(image));\n\tgdCtxPrintf(out, \"static unsigned char %s_bits[] = {\\n  \", name);\n\tfree(name);\n\tb = 1;\n\tp = 0;\n\tc = 0;\n\tsx = gdImageSX(image);\n\tsy = gdImageSY(image);\n\tfor (y = 0; y < sy; y++) {\n\t\tfor (x = 0; x < sx; x++) {\n\t\t\tif (gdImageGetPixel(image, x, y) == fg) {\n\t\t\t\tc |= b;\n\t\t\t}\n\t\t\tif ((b == 128) || (x == sx && y == sy)) {\n\t\t\t\tb = 1;\n\t\t\t\tif (p) {\n\t\t\t\t\tgdCtxPrintf(out, \", \");\n\t\t\t\t\tif (!(p%12)) {\n\t\t\t\t\t\tgdCtxPrintf(out, \"\\n  \");\n\t\t\t\t\t\tp = 12;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tgdCtxPrintf(out, \"0x%02X\", c);\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\tb <<= 1;\n\t\t\t}\n\t\t}\n\t}\n\tgdCtxPrintf(out, \"};\\n\");\n}", "target": 1}
{"code": "blockmix_salsa8(__m128i * Bin, __m128i * Bout, __m128i * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[8 * r - 4], 64);\n  for (i = 0; i < r; i++) {\n    blkxor(X, &Bin[i * 8], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 4], X, 64);\n    blkxor(X, &Bin[i * 8 + 4], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[(r + i) * 4], X, 64);\n  }\n}", "target": 1}
{"code": "bool DNP3_Base::ProcessData(int len, const u_char* data, bool orig)\n\t{\n\tEndpoint* endp = orig ? &orig_state : &resp_state;\n\twhile ( len )\n\t\t{\n\t\tif ( endp->in_hdr )\n\t\t\t{\n\t\t\tif ( ! AddToBuffer(endp, PSEUDO_APP_LAYER_INDEX, &data, &len) )\n\t\t\t\treturn true;\n\t\t\tif( endp->buffer[0] != 0x05 || endp->buffer[1] != 0x64 )\n\t\t\t\t{\n\t\t\t\tanalyzer->Weird(\"dnp3_header_lacks_magic\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\tif ( ! CheckCRC(PSEUDO_LINK_LAYER_LEN, endp->buffer, endp->buffer + PSEUDO_LINK_LAYER_LEN, \"header\") )\n\t\t\t\t{\n\t\t\t\tanalyzer->ProtocolViolation(\"broken_checksum\");\n\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\tanalyzer->ProtocolConfirmation();\n\t\t\tif ( (endp->buffer[PSEUDO_LENGTH_INDEX] + 3) == (char)PSEUDO_LINK_LAYER_LEN  )\n\t\t\t\t{\n\t\t\t\tClearEndpointState(orig);\n\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\tu_char ctrl = endp->buffer[PSEUDO_CONTROL_FIELD_INDEX];\n\t\t\tif ( orig != (bool)(ctrl & 0x80) )\n\t\t\t\tanalyzer->Weird(\"dnp3_unexpected_flow_direction\");\n\t\t\tendp->pkt_length = endp->buffer[PSEUDO_LENGTH_INDEX];\n\t\t\tendp->tpflags = endp->buffer[PSEUDO_TRANSPORT_INDEX];\n\t\t\tendp->in_hdr = false; \n\t\t\tif ( ++endp->pkt_cnt == 1 )\n\t\t\t\tinterp->NewData(orig, endp->buffer, endp->buffer + PSEUDO_LINK_LAYER_LEN);\n\t\t\t}\n\t\tif ( ! endp->in_hdr )\n\t\t\t{\n\t\t\tassert(endp->pkt_length);\n\t\t\tint n = PSEUDO_APP_LAYER_INDEX + (endp->pkt_length - 5) + ((endp->pkt_length - 5) / 16) * 2\n\t\t\t\t\t+ 2 * ( ((endp->pkt_length - 5) % 16 == 0) ? 0 : 1) - 1 ;\n\t\t\tif ( ! AddToBuffer(endp, n, &data, &len) )\n\t\t\t\treturn true;\n\t\t\tif ( ! ParseAppLayer(endp) )\n\t\t\t\treturn false;\n\t\t\tendp->buffer_len = 0;\n\t\t\tendp->in_hdr = true;\n\t\t\t}\n\t\t}\n\treturn true;\n\t}", "target": 1}
{"code": "static int get_query(struct MHD_Connection *connection, char **query, const char *separator)\n{\n\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j;\n\tint length = 0;\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\tif (element_counter < 0) {\n\t\t*query = safe_strdup(\"\");\n\t\treturn MHD_NO;\n\t}\n\telements = calloc(element_counter, sizeof(char *));\n\tif (elements == NULL) {\n\t\treturn MHD_NO;\n\t}\n\tcollect_query.i = 0;\n\tcollect_query.elements = elements;\n\tMHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, collect_query_string, &collect_query);\n\tfor (i = 0; i < element_counter; i++) {\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\t\tif (i > 0) \n\t\t\tlength++;\n\t}\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tfree(elements[i]);\n\t\t}\n\t\tfree(elements);\n\t\treturn 0;\n\t}\n\tquery_str = safe_calloc(QUERYMAXLEN);\n\tfor (i = 0, j = 0; i < element_counter; i++) {\n\t\tif (!elements[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\t\tstrncpy(*query + j, elements[i], length - j);\n\t\tif (i == 0) {\n\t\t\tstrcpy(query_str, \"?\");\n\t\t} else {\n\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t}\n\t\t}\n\t\tif (QUERYMAXLEN - strlen(query_str) > length - j) {\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string exceeds the maximum of %d bytes so has been truncated.\", QUERYMAXLEN/2);\n\t\t}\n\t\tfree(elements[i]);\n\t}\n\tdebug(LOG_DEBUG, \" query is [%s]\", query_str);\n\tstrncpy(*query, query_str, QUERYMAXLEN);\n\tfree(query_str);\n\tfree(elements);\n\treturn 0;\n}", "target": 1}
{"code": "nd_format_time(char *buf, size_t bufsize, const char *format,\n         const struct tm *timeptr)\n{\n\tif (timeptr != NULL) {\n\t\tif (strftime(buf, bufsize, format, timeptr) != 0)\n\t\t\treturn (buf);\n\t\telse\n\t\t\treturn (\"[nd_format_time() buffer is too small]\");\n\t} else\n\t\treturn (\"[localtime() or gmtime() couldn't convert the date and time]\");\n}", "target": 0}
{"code": "NOEXPORT int init_section(int eof, SERVICE_OPTIONS **section_ptr) {\n    char *errstr;\n#ifndef USE_WIN32\n    (*section_ptr)->option.log_stderr=new_global_options.option.log_stderr;\n#endif \n    if(*section_ptr==&new_service_options) {\n        errstr=parse_global_option(CMD_INITIALIZE, NULL, NULL);\n        if(errstr) {\n            s_log(LOG_ERR, \"Global options: %s\", errstr);\n            return 1;\n        }\n    }\n    if(*section_ptr!=&new_service_options || eof) {\n        if(*section_ptr==&new_service_options)\n            s_log(LOG_INFO, \"Initializing inetd mode configuration\");\n        else\n            s_log(LOG_INFO, \"Initializing service [%s]\",\n                (*section_ptr)->servname);\n        errstr=parse_service_option(CMD_INITIALIZE, section_ptr, NULL, NULL);\n        if(errstr) {\n            if(*section_ptr==&new_service_options)\n                s_log(LOG_ERR, \"Inetd mode: %s\", errstr);\n            else\n                s_log(LOG_ERR, \"Service [%s]: %s\",\n                    (*section_ptr)->servname, errstr);\n            return 1;\n        }\n    }\n    return 0;\n}", "target": 1}
{"code": "void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      value.clear();\n    }\n  } else {\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictFusedBatchNorm(\n    const OpContext& op_context, NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  const bool is_training = IsTraining(op_info);\n  int64_t ops = 0;\n  const auto rsqrt_cost = Eigen::internal::functor_traits<\n      Eigen::internal::scalar_rsqrt_op<float>>::Cost;\n  if (is_training) {\n    ops = dims.iz * (dims.batch * dims.ix * dims.iy * 4 + 6 + rsqrt_cost);\n  } else {\n    ops = dims.batch * dims.ix * dims.iy * dims.iz * 2;\n  }\n  node_costs->num_compute_ops = ops;\n  const int64_t size_nhwc =\n      CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  const int64_t size_c =\n      CalculateTensorSize(op_info.inputs(1), &found_unknown_shapes);\n  if (is_training) {\n    node_costs->num_input_bytes_accessed = {size_nhwc, size_c, size_c};\n    node_costs->num_output_bytes_accessed = {size_nhwc, size_c, size_c, size_c,\n                                             size_c};\n    node_costs->internal_read_bytes = size_nhwc;\n  } else {\n    node_costs->num_input_bytes_accessed = {size_nhwc, size_c, size_c, size_c,\n                                            size_c};\n    node_costs->num_output_bytes_accessed = {size_nhwc};\n  }\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "int nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols)\n{\n\tint rc;\n\tpr_debug(\"dev_name %s initiator protocols 0x%x target protocols 0x%x\\n\",\n\t\t dev_name(&dev->dev), im_protocols, tm_protocols);\n\tif (!im_protocols && !tm_protocols)\n\t\treturn -EINVAL;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->start_poll(dev, im_protocols, tm_protocols);\n\tif (!rc) {\n\t\tdev->polling = true;\n\t\tdev->rf_mode = NFC_RF_NONE;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int bson_validate_string( bson *b, const unsigned char *string,\n                                 const int length, const char check_utf8, const char check_dot,\n                                 const char check_dollar ) {\n    int position = 0;\n    int sequence_length = 1;\n    if( check_dollar && string[0] == '$' ) {\n        if( !bson_string_is_db_ref( string, length ) )\n            b->err |= BSON_FIELD_INIT_DOLLAR;\n    }\n    while ( position < length ) {\n        if ( check_dot && *( string + position ) == '.' ) {\n            b->err |= BSON_FIELD_HAS_DOT;\n        }\n        if ( check_utf8 ) {\n            sequence_length = trailingBytesForUTF8[*( string + position )] + 1;\n            if ( ( position + sequence_length ) > length ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n            if ( !isLegalUTF8( string + position, sequence_length ) ) {\n                b->err |= BSON_NOT_UTF8;\n                return BSON_ERROR;\n            }\n        }\n        position += sequence_length;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret = 0, size = 0;\n\tconst char *name = NULL;\n\tchar *value = NULL;\n\tstruct iattr newattrs;\n\tumode_t new_mode = inode->i_mode, old_mode = inode->i_mode;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &new_mode);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tret = acl ? -EINVAL : 0;\n\t\t\tgoto out;\n\t\t}\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_NOFS);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\tif (new_mode != old_mode) {\n\t\tnewattrs.ia_mode = new_mode;\n\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\tret = __ceph_setattr(inode, &newattrs);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\tret = __ceph_setxattr(inode, name, value, size, 0);\n\tif (ret) {\n\t\tif (new_mode != old_mode) {\n\t\t\tnewattrs.ia_mode = old_mode;\n\t\t\tnewattrs.ia_valid = ATTR_MODE;\n\t\t\t__ceph_setattr(inode, &newattrs);\n\t\t}\n\t\tgoto out_free;\n\t}\n\tceph_set_cached_acl(inode, type, acl);\nout_free:\n\tkfree(value);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "int HttpStreamParser::DoLoop(int result) {\n  bool can_do_more = true;\n  do {\n    switch (io_state_) {\n      case STATE_SENDING_HEADERS:\n        if (result < 0)\n          can_do_more = false;\n        else\n          result = DoSendHeaders(result);\n        break;\n      case STATE_SENDING_BODY:\n        if (result < 0)\n          can_do_more = false;\n        else\n          result = DoSendBody(result);\n        break;\n      case STATE_SEND_REQUEST_READING_BODY:\n        result = DoSendRequestReadingBody(result);\n        break;\n      case STATE_REQUEST_SENT:\n        DCHECK(result != ERR_IO_PENDING);\n        can_do_more = false;\n        break;\n      case STATE_READ_HEADERS:\n        net_log_.BeginEvent(NetLog::TYPE_HTTP_STREAM_PARSER_READ_HEADERS);\n        result = DoReadHeaders();\n        break;\n      case STATE_READ_HEADERS_COMPLETE:\n        result = DoReadHeadersComplete(result);\n        net_log_.EndEventWithNetErrorCode(\n            NetLog::TYPE_HTTP_STREAM_PARSER_READ_HEADERS, result);\n        break;\n      case STATE_BODY_PENDING:\n        DCHECK(result != ERR_IO_PENDING);\n        can_do_more = false;\n        break;\n      case STATE_READ_BODY:\n        result = DoReadBody();\n        break;\n      case STATE_READ_BODY_COMPLETE:\n        result = DoReadBodyComplete(result);\n        break;\n      case STATE_DONE:\n        DCHECK(result != ERR_IO_PENDING);\n        can_do_more = false;\n        break;\n      default:\n        NOTREACHED();\n        can_do_more = false;\n        break;\n    }\n  } while (result != ERR_IO_PENDING && can_do_more);\n  return result;\n}", "target": 0}
{"code": "char *suhosin_decrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key, char **where TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n    int o_name_len = name_len;\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n\tint l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\ndecrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n            memcpy(*where, name, o_name_len);\n            *where += o_name_len;\n            **where = '='; *where +=1;\n\t        memcpy(*where, value, value_len);\n\t        *where += value_len;\n\t\t\treturn *where;\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto decrypt_return_plain;\n\t\t}\n\t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\tvalue_len = php_url_decode(buf2, value_len);\n\td = suhosin_decrypt_string(buf2, value_len, buf, name_len, key, &l, SUHOSIN_G(cookie_checkraddr) TSRMLS_CC);\n    if (d == NULL) {\n        goto skip_cookie;\n    }\n\td_url = php_url_encode(d, l, &l);\n\tefree(d);\n    memcpy(*where, name, o_name_len);\n    *where += o_name_len;\n    **where = '=';*where += 1;\n\tmemcpy(*where, d_url, l);\n\t*where += l;\n\tefree(d_url);\nskip_cookie:\n\tif (buf != buffer) {\n\t\tefree(buf);\n\t}\n\tif (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn *where;\n}", "target": 1}
{"code": "int nfc_dev_down(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->polling || dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_down)\n\t\tdev->ops->dev_down(dev);\n\tdev->dev_up = false;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "h2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tassert(!WS_IsReserved(r2->req->ws));\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t\n\tif (req->req_body_status == NULL) {\n\t\tif (!http_GetHdr(req->http, H_Content_Length, NULL))\n\t\t\treq->req_body_status = BS_EOF;\n\t\telse\n\t\t\treq->req_body_status = BS_LENGTH;\n\t} else {\n\t\tassert (req->req_body_status == BS_NONE);\n\t\tr2->state = H2_S_CLOS_REM;\n\t\tif (http_GetContentLength(req->http) > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task->func = h2_do_req;\n\treq->task->priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); \n\t}\n\treturn (0);\n}", "target": 1}
{"code": "bool CWalletTx::AcceptWalletTransaction(CTxDB& txdb, bool fCheckInputs)\n{\n    {\n        LOCK(mempool.cs);\n        BOOST_FOREACH(CMerkleTx& tx, vtxPrev)\n        {\n            if (!tx.IsCoinBase())\n            {\n                uint256 hash = tx.GetHash();\n                if (!mempool.exists(hash) && !txdb.ContainsTx(hash))\n                    tx.AcceptToMemoryPool(txdb, fCheckInputs);\n            }\n        }\n        return AcceptToMemoryPool(txdb, fCheckInputs);\n    }\n    return false;\n}", "target": 1}
{"code": "    bool fetch(const string & url, const string & expectedETag = \"\")\n    {\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        data.clear();\n        if (requestHeaders) {\n            curl_slist_free_all(requestHeaders);\n            requestHeaders = 0;\n        }\n        if (!expectedETag.empty()) {\n            this->expectedETag = expectedETag;\n            requestHeaders = curl_slist_append(requestHeaders, (\"If-None-Match: \" + expectedETag).c_str());\n        }\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, requestHeaders);\n        if (showProgress) {\n            std::cerr << (format(\"downloading %1%... \") % url);\n            std::cerr.flush();\n            startTime = getTime();\n        }\n        CURLcode res = curl_easy_perform(curl);\n        if (showProgress)\n            std::cerr << \"\\n\";\n        checkInterrupt();\n        if (res == CURLE_WRITE_ERROR && etag == expectedETag) return false;\n        if (res != CURLE_OK)\n            throw DownloadError(format(\"unable to download %1%: %2% (%3%)\")\n                % url % curl_easy_strerror(res) % res);\n        long httpStatus = 0;\n        curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpStatus);\n        if (httpStatus == 304) return false;\n        return true;\n    }", "target": 1}
{"code": "void NumberFormatTest::Test20037_ScientificIntegerOverflow() {\n    IcuTestErrorCode status(*this, \"Test20037_ScientificIntegerOverflow\");\n    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));\n    if (U_FAILURE(status)) {\n        dataerrln(\"Unable to create NumberFormat instance.\");\n        return;\n    }\n    Formattable result;\n    nf->parse(u\"1E-2147483648\", result, status);\n    StringPiece sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should snap to zero\",\n                 u\"0\",\n                 {sp.data(), sp.length(), US_INV});\n    result = Formattable();\n    nf->parse(u\"1E-2147483647E-1\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow and should parse only the first exponent\",\n                 u\"1E-2147483647\",\n                 {sp.data(), sp.length(), US_INV});\n    result = Formattable();\n    nf->parse(u\".0003e-2147483644\", result, status);\n    sp = result.getDecimalNumber(status);\n    assertEquals(u\"Should not overflow\",\n                 u\"3E-2147483648\",\n                 {sp.data(), sp.length(), US_INV});\n}", "target": 0}
{"code": "static int createFromTiffRgba(TIFF * tif, gdImagePtr im)\n{\n\tint a;\n\tint x, y;\n\tint alphaBlendingFlag = 0;\n\tint color;\n\tint width = im->sx;\n\tint height = im->sy;\n\tuint32 *buffer;\n\tuint32 rgba;\n\talphaBlendingFlag = im->alphaBlendingFlag;\n\tgdImageAlphaBlending(im, 0);\n\tbuffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);\n\tif (!buffer) {\n\t\treturn GD_FAILURE;\n\t}\n\tTIFFReadRGBAImage(tif, width, height, buffer, 0);\n\tfor(y = 0; y < height; y++) {\n\t\tfor(x = 0; x < width; x++) {\n\t\t\trgba = buffer[(y * width + x)];\n\t\t\ta = (0xff - TIFFGetA(rgba)) / 2;\n\t\t\tcolor = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);\n\t\t\tgdImageSetPixel(im, x, height - y - 1, color);\n\t\t}\n\t}\n\tgdFree(buffer);\n\tgdImageAlphaBlending(im, alphaBlendingFlag);\n\treturn GD_SUCCESS;\n}", "target": 1}
{"code": "static char* ConcatHttpHeaders(HTTP_HEADERS_HANDLE httpHeadersHandle, size_t toAlloc, size_t headersCount)\n{\n    char *result = (char*)malloc(toAlloc * sizeof(char) + 1);\n    size_t i;\n    if (result == NULL)\n    {\n        LogError(\"unable to malloc\");\n    }\n    else\n    {\n        result[0] = '\\0';\n        for (i = 0; i < headersCount; i++)\n        {\n            char* temp;\n            if (HTTPHeaders_GetHeader(httpHeadersHandle, i, &temp) != HTTP_HEADERS_OK)\n            {\n                LogError(\"unable to HTTPHeaders_GetHeader\");\n                break;\n            }\n            else\n            {\n                (void)strcat(result, temp);\n                (void)strcat(result, \"\\r\\n\");\n                free(temp);\n            }\n        }\n        if (i < headersCount)\n        {\n            free(result);\n            result = NULL;\n        }\n        else\n        {\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "set_range(bitstr_t *bits, int low, int high, int start, int stop, int step) {\n\tDebug(DPARS|DEXT, (\"set_range(?,%d,%d,%d,%d,%d)\\n\",\n\t\t\t   low, high, start, stop, step))\n\tif (start < low || stop > high)\n\t\treturn (EOF);\n\tstart -= low;\n\tstop -= low;\n\tif (step == 1) {\n\t\tbit_nset(bits, start, stop);\n\t} else {\n\t\tfor (int i = start; i <= stop; i += step)\n\t\t\tbit_set(bits, i);\n\t}\n\treturn (OK);\n}", "target": 1}
{"code": "devzvol_readdir(struct vnode *dvp, struct uio *uiop, struct cred *cred,\n    int *eofp, caller_context_t *ct_unused, int flags_unused)\n{\n\tstruct sdev_node *sdvp = VTOSDEV(dvp);\n\tchar *ptr;\n\tsdcmn_err13((\"zv readdir of '%s' %s'\", sdvp->sdev_path,\n\t    sdvp->sdev_name));\n\tif (strcmp(sdvp->sdev_path, ZVOL_DIR) == 0) {\n\t\tstruct vnode *vp;\n\t\trw_exit(&sdvp->sdev_contents);\n\t\t(void) devname_lookup_func(sdvp, \"dsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\t(void) devname_lookup_func(sdvp, \"rdsk\", &vp, cred,\n\t\t    devzvol_create_dir, SDEV_VATTR);\n\t\tVN_RELE(vp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tif (uiop->uio_offset == 0)\n\t\tdevzvol_prunedir(sdvp);\n\tptr = sdvp->sdev_path + strlen(ZVOL_DIR);\n\tif ((strcmp(ptr, \"/dsk\") == 0) || (strcmp(ptr, \"/rdsk\") == 0)) {\n\t\trw_exit(&sdvp->sdev_contents);\n\t\tdevzvol_create_pool_dirs(dvp);\n\t\trw_enter(&sdvp->sdev_contents, RW_READER);\n\t\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n\t}\n\tptr = strchr(ptr + 1, '/') + 1;\n\trw_exit(&sdvp->sdev_contents);\n\tsdev_iter_datasets(dvp, ZFS_IOC_DATASET_LIST_NEXT, ptr);\n\trw_enter(&sdvp->sdev_contents, RW_READER);\n\treturn (devname_readdir_func(dvp, uiop, cred, eofp, 0));\n}", "target": 1}
{"code": "void out_string(conn *c, const char *str) {\n    size_t len;\n    mc_resp *resp = c->resp;\n    assert(c != NULL);\n    resp_reset(resp);\n    if (c->noreply) {\n        resp->skip = true;\n        if (settings.verbose > 1)\n            fprintf(stderr, \">%d NOREPLY %s\\n\", c->sfd, str);\n        conn_set_state(c, conn_new_cmd);\n        return;\n    }\n    if (settings.verbose > 1)\n        fprintf(stderr, \">%d %s\\n\", c->sfd, str);\n    len = strlen(str);\n    if ((len + 2) > WRITE_BUFFER_SIZE) {\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n    memcpy(resp->wbuf, str, len);\n    memcpy(resp->wbuf + len, \"\\r\\n\", 2);\n    resp_add_iov(resp, resp->wbuf, len + 2);\n    conn_set_state(c, conn_new_cmd);\n    return;\n}", "target": 1}
{"code": "snmp_ber_decode_null(unsigned char *buf, uint32_t *buff_len)\n{\n  buf++;\n  (*buff_len)--;\n  buf++;\n  (*buff_len)--;\n  return buf;\n}", "target": 1}
{"code": "static void __reg_deduce_bounds(struct bpf_reg_state *reg)\n{\n\t__reg32_deduce_bounds(reg);\n\t__reg64_deduce_bounds(reg);\n}", "target": 0}
{"code": "static struct btrfs_device *btrfs_find_device_by_path(\n\t\tstruct btrfs_fs_info *fs_info, const char *device_path)\n{\n\tint ret = 0;\n\tstruct btrfs_super_block *disk_super;\n\tu64 devid;\n\tu8 *dev_uuid;\n\tstruct block_device *bdev;\n\tstruct buffer_head *bh;\n\tstruct btrfs_device *device;\n\tret = btrfs_get_bdev_and_sb(device_path, FMODE_READ,\n\t\t\t\t    fs_info->bdev_holder, 0, &bdev, &bh);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tdisk_super = (struct btrfs_super_block *)bh->b_data;\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\tdev_uuid = disk_super->dev_item.uuid;\n\tif (btrfs_fs_incompat(fs_info, METADATA_UUID))\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->metadata_uuid);\n\telse\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, dev_uuid,\n\t\t\t\t\t   disk_super->fsid);\n\tbrelse(bh);\n\tif (!device)\n\t\tdevice = ERR_PTR(-ENOENT);\n\tblkdev_put(bdev, FMODE_READ);\n\treturn device;\n}", "target": 1}
{"code": "void LanLinkProvider::addLink(const QString& deviceId, QSslSocket* socket, NetworkPacket* receivedPacket, LanDeviceLink::ConnectionStarted connectionOrigin)\n{\n    disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n    LanDeviceLink* deviceLink;\n    QMap< QString, LanDeviceLink* >::iterator linkIterator = m_links.find(deviceId);\n    if (linkIterator != m_links.end()) {\n        deviceLink = linkIterator.value();\n        deviceLink->reset(socket, connectionOrigin);\n    } else {\n        deviceLink = new LanDeviceLink(deviceId, this, socket, connectionOrigin);\n        disconnect(socket, &QAbstractSocket::disconnected, socket, &QObject::deleteLater);\n        bool isDeviceTrusted = KdeConnectConfig::instance().trustedDevices().contains(deviceId);\n        if (!isDeviceTrusted && m_links.size() > MAX_UNPAIRED_CONNECTIONS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many unpaired devices to remember them all. Ignoring \" << deviceId;\n            socket->disconnectFromHost();\n            socket->deleteLater();\n            return;\n        }\n        connect(deviceLink, &QObject::destroyed, this, &LanLinkProvider::deviceLinkDestroyed);\n        m_links[deviceId] = deviceLink;\n        if (m_pairingHandlers.contains(deviceId)) {\n            Q_ASSERT(m_pairingHandlers.contains(deviceId));\n            m_pairingHandlers[deviceId]->setDeviceLink(deviceLink);\n        }\n    }\n    Q_EMIT onConnectionReceived(*receivedPacket, deviceLink);\n}", "target": 0}
{"code": "bool CephxAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t      bufferlist& authorizer_data, bufferlist& authorizer_reply,\n                                              EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,  uint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n  if (!authorizer_data.length()) {\n    ldout(cct, 1) << \"verify authorizer, authorizer_data.length()=0\" << dendl;\n    return false;\n  }\n  CephXServiceTicketInfo auth_ticket_info;\n  bool isvalid = cephx_verify_authorizer(cct, keys, iter, auth_ticket_info, authorizer_reply);\n  if (isvalid) {\n    caps_info = auth_ticket_info.ticket.caps;\n    entity_name = auth_ticket_info.ticket.name;\n    global_id = auth_ticket_info.ticket.global_id;\n    session_key = auth_ticket_info.session_key;\n    if (auid) *auid = auth_ticket_info.ticket.auid;\n  }\n  return isvalid;\n}", "target": 1}
{"code": "static void snd_usb_mixer_free(struct usb_mixer_interface *mixer)\n{\n\tsnd_usb_mixer_disconnect(mixer);\n\tkfree(mixer->id_elems);\n\tif (mixer->urb) {\n\t\tkfree(mixer->urb->transfer_buffer);\n\t\tusb_free_urb(mixer->urb);\n\t}\n\tusb_free_urb(mixer->rc_urb);\n\tkfree(mixer->rc_setup_packet);\n\tkfree(mixer);\n}", "target": 0}
{"code": "void FrameLoader::updateFirstPartyForCookies()\n{\n    if (m_frame->tree()->parent())\n        setFirstPartyForCookies(m_frame->tree()->parent()->document()->firstPartyForCookies());\n    else\n        setFirstPartyForCookies(m_URL);\n}", "target": 0}
{"code": "call_backend(char *uri,                 \n\t     int  argc,                 \n\t     char **argv,\t\t\n\t     char *filename)            \n{\n  const char\t*cups_serverbin;\t\n  char\t\tscheme[1024],           \n                *ptr,\t\t\t\n\t\tcmdline[65536];\t\t\n  int           retval;\n  strncpy(scheme, uri, sizeof(scheme) - 1);\n  if (strlen(uri) > 1023)\n    scheme[1023] = '\\0';\n  if ((ptr = strchr(scheme, ':')) != NULL)\n    *ptr = '\\0';\n  if ((cups_serverbin = getenv(\"CUPS_SERVERBIN\")) == NULL)\n    cups_serverbin = CUPS_SERVERBIN;\n  if (!strncasecmp(uri, \"file:\", 5) || uri[0] == '/')\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Direct output into a file not supported.\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n  else\n    snprintf(cmdline, sizeof(cmdline),\n\t     \"%s/backend/%s '%s' '%s' '%s' '%s' '%s' %s\",\n\t     cups_serverbin, scheme, argv[1], argv[2], argv[3],\n\t     (argc == 6 ? \"1\" : argv[4]),\n\t     argv[5], filename);\n  setenv(\"DEVICE_URI\", uri, 1);\n  fprintf(stderr,\n\t  \"DEBUG: beh: Executing backend command line \\\"%s\\\"...\\n\",\n\t  cmdline);\n  fprintf(stderr,\n\t  \"DEBUG: beh: Using device URI: %s\\n\",\n\t  uri);\n  retval = system(cmdline) >> 8;\n  if (retval == -1)\n    fprintf(stderr, \"ERROR: Unable to execute backend command line: %s\\n\",\n\t    strerror(errno));\n  return (retval);\n}", "target": 1}
{"code": "completion_glob_pattern (string)\n     char *string;\n{\n  register int c;\n  char *send;\n  int open;\n  DECLARE_MBSTATE;\n  open = 0;\n  send = string + strlen (string);\n  while (c = *string++)\n    {\n      switch (c)\n\t{\n\tcase '?':\n\tcase '*':\n\t  return (1);\n\tcase '[':\n\t  open++;\n\t  continue;\n\tcase ']':\n\t  if (open)\n\t    return (1);\n\t  continue;\n\tcase '+':\n\tcase '@':\n\tcase '!':\n\t  if (*string == '(')\t\n\t    return (1);\n\t  continue;\n\tcase '\\\\':\n\t  if (*string++ == 0)\n\t    return (0);\n\t}\n#ifdef HANDLE_MULTIBYTE\n      string--;\n      ADVANCE_CHAR_P (string, send - string);\n      string++;\n#else\n      ADVANCE_CHAR_P (string, send - string);\n#endif\n    }\n  return (0);\n}", "target": 1}
{"code": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\tif (size == 0)\n\t\treturn -EINVAL;\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\tif (current != task)\n\t\treturn -EACCES;\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permprofile\") == 0) {\n\t\t\terror = aa_setprocattr_changeprofile(args, !AA_ONEXEC,\n\t\t\t\t\t\t\t     AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permipc\") == 0) {\n\t\t\terror = aa_setprocattr_permipc(args);\n\t\t} else {\n\t\t\tstruct common_audit_data sa;\n\t\t\tCOMMON_AUDIT_DATA_INIT(&sa, NONE);\n\t\t\tsa.aad.op = OP_SETPROCATTR;\n\t\t\tsa.aad.info = name;\n\t\t\tsa.aad.error = -EINVAL;\n\t\t\treturn aa_audit(AUDIT_APPARMOR_DENIED, NULL, GFP_KERNEL,\n\t\t\t\t\t&sa, NULL);\n\t\t}\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t     !AA_DO_TEST);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (!error)\n\t\terror = size;\n\treturn error;\n}", "target": 1}
{"code": "compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}", "target": 1}
{"code": "usage (void)\n{\n  g_print (\"%s\\n\", _(\"Usage: exo-open [URLs...]\"));\n  g_print (\"%s\\n\", _(\"       exo-open --launch TYPE [PARAMETERs...]\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  -?, --help                          Print this help message and exit\"));\n  g_print (\"%s\\n\", _(\"  -V, --version                       Print version information and exit\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  --launch TYPE [PARAMETERs...]       Launch the preferred application of\\n\"\n                     \"                                      TYPE with the optional PARAMETERs, where\\n\"\n                     \"                                      TYPE is one of the following values.\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  --working-directory DIRECTORY       Default working directory for applications\\n\"\n                     \"                                      when using the --launch option.\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"The following TYPEs are supported for the --launch command:\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"  WebBrowser       - The preferred Web Browser.\\n\"\n                     \"  MailReader       - The preferred Mail Reader.\\n\"\n                     \"  FileManager      - The preferred File Manager.\\n\"\n                     \"  TerminalEmulator - The preferred Terminal Emulator.\"));\n  g_print (\"\\n\");\n  g_print (\"%s\\n\", _(\"If you don't specify the --launch option, exo-open will open all specified\\n\"\n                     \"URLs with their preferred URL handlers. Else, if you specify the --launch\\n\"\n                     \"option, you can select which preferred application you want to run, and\\n\"\n                     \"pass additional parameters to the application (i.e. for TerminalEmulator\\n\"\n                     \"you can pass the command line that should be run in the terminal).\"));\n  g_print (\"\\n\");\n}", "target": 0}
{"code": "    CImg<T>& RGBtoYUV() {\n      if (_spectrum!=3)\n        throw CImgInstanceException(_cimg_instance\n                                    \"RGBtoYUV(): Instance is not a RGB image.\",\n                                    cimg_instance);\n      T *p1 = data(0,0,0,0), *p2 = data(0,0,0,1), *p3 = data(0,0,0,2);\n      const ulongT whd = (ulongT)_width*_height*_depth;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(whd>=16384))\n      for (ulongT N = 0; N<whd; ++N) {\n        const Tfloat\n          R = (Tfloat)p1[N]/255,\n          G = (Tfloat)p2[N]/255,\n          B = (Tfloat)p3[N]/255,\n          Y = 0.299f*R + 0.587f*G + 0.114f*B;\n        p1[N] = (T)Y;\n        p2[N] = (T)(0.492f*(B - Y));\n        p3[N] = (T)(0.877*(R - Y));\n      }\n      return *this;", "target": 0}
{"code": "void acpi_os_set_prepare_sleep(int (*func)(u8 sleep_state,\n\t\t\t       u32 pm1a_ctrl, u32 pm1b_ctrl))\n{\n\t__acpi_os_prepare_sleep = func;\n}", "target": 0}
{"code": "static void cswitch(JF, js_Ast *ref, js_Ast *head)\n{\n\tjs_Ast *node, *clause, *def = NULL;\n\tint end;\n\tcexp(J, F, ref);\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tif (clause->type == STM_DEFAULT) {\n\t\t\tif (def)\n\t\t\t\tjsC_error(J, clause, \"more than one default label in switch\");\n\t\t\tdef = clause;\n\t\t} else {\n\t\t\tcexp(J, F, clause->a);\n\t\t\tclause->casejump = emitjump(J, F, OP_JCASE);\n\t\t}\n\t}\n\temit(J, F, OP_POP);\n\tif (def) {\n\t\tdef->casejump = emitjump(J, F, OP_JUMP);\n\t\tend = 0;\n\t} else {\n\t\tend = emitjump(J, F, OP_JUMP);\n\t}\n\tfor (node = head; node; node = node->b) {\n\t\tclause = node->a;\n\t\tlabel(J, F, clause->casejump);\n\t\tif (clause->type == STM_DEFAULT)\n\t\t\tcstmlist(J, F, clause->a);\n\t\telse\n\t\t\tcstmlist(J, F, clause->b);\n\t}\n\tif (end)\n\t\tlabel(J, F, end);\n}", "target": 0}
{"code": "static int sqfs_disk_read(__u32 block, __u32 nr_blocks, void *buf)\n{\n\tulong ret;\n\tif (!ctxt.cur_dev)\n\t\treturn -1;\n\tret = blk_dread(ctxt.cur_dev, ctxt.cur_part_info.start + block,\n\t\t\tnr_blocks, buf);\n\tif (ret != nr_blocks)\n\t\treturn -1;\n\treturn ret;\n}", "target": 0}
{"code": "l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "Envoy::Ssl::ClientValidationStatus DefaultCertValidator::verifyCertificate(\n    X509* cert, const std::vector<std::string>& verify_san_list,\n    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n        subject_alt_name_matchers) {\n  Envoy::Ssl::ClientValidationStatus validated = Envoy::Ssl::ClientValidationStatus::NotValidated;\n  if (!verify_san_list.empty()) {\n    if (!verifySubjectAltName(cert, verify_san_list)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  if (!subject_alt_name_matchers.empty()) {\n    if (!matchSubjectAltName(cert, subject_alt_name_matchers)) {\n      stats_.fail_verify_san_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  if (!verify_certificate_hash_list_.empty() || !verify_certificate_spki_list_.empty()) {\n    const bool valid_certificate_hash =\n        !verify_certificate_hash_list_.empty() &&\n        verifyCertificateHashList(cert, verify_certificate_hash_list_);\n    const bool valid_certificate_spki =\n        !verify_certificate_spki_list_.empty() &&\n        verifyCertificateSpkiList(cert, verify_certificate_spki_list_);\n    if (!valid_certificate_hash && !valid_certificate_spki) {\n      stats_.fail_verify_cert_hash_.inc();\n      return Envoy::Ssl::ClientValidationStatus::Failed;\n    }\n    validated = Envoy::Ssl::ClientValidationStatus::Validated;\n  }\n  return validated;\n}", "target": 1}
{"code": "static int sd_compat_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t\t   unsigned int cmd, unsigned long arg)\n{\n\tstruct scsi_device *sdev = scsi_disk(bdev->bd_disk)->device;\n\tif (!scsi_block_when_processing_errors(sdev))\n\t\treturn -ENODEV;\n\tif (sdev->host->hostt->compat_ioctl) {\n\t\tint ret;\n\t\tret = sdev->host->hostt->compat_ioctl(sdev, cmd, (void __user *)arg);\n\t\treturn ret;\n\t}\n\treturn -ENOIOCTLCMD; \n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageJpegPtr(gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageJpegCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "static inline unsigned long do_div_llr(const long long dividend,\n\t\t\t\t       const long divisor, long *remainder)\n{\n\tu64 result = dividend;\n\t*(remainder) = do_div(result, divisor);\n\treturn (unsigned long) result;\n}", "target": 1}
{"code": "static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,\n\t\t\t      pte_t *ptep, pte_t pte)\n{\n\tif (pte_valid_ng(pte)) {\n\t\tif (!pte_special(pte) && pte_exec(pte))\n\t\t\t__sync_icache_dcache(pte, addr);\n\t\tif (pte_dirty(pte) && pte_write(pte))\n\t\t\tpte_val(pte) &= ~PTE_RDONLY;\n\t\telse\n\t\t\tpte_val(pte) |= PTE_RDONLY;\n\t}\n\tset_pte(ptep, pte);\n}", "target": 1}
{"code": "static int getlblockinc(Jpeg2000DecoderContext *s)\n{\n    int res = 0, ret;\n    while (ret = get_bits(s, 1)) {\n        if (ret < 0)\n            return ret;\n        res++;\n    }\n    return res;\n}", "target": 0}
{"code": "gss_wrap_iov_length (minor_status,\n                     context_handle,\n                     conf_req_flag,\n                     qop_req,\n                     conf_state,\n                     iov,\n                     iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov_length) {\n\t    status = mech->gss_wrap_iov_length(\n\t\t\t\t\t      minor_status,\n\t\t\t\t\t      ctx->internal_ctx_id,\n\t\t\t\t\t      conf_req_flag,\n\t\t\t\t\t      qop_req,\n\t\t\t\t\t      conf_state,\n\t\t\t\t\t      iov,\n\t\t\t\t\t      iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "CompositeDeepScanLine::setFrameBuffer(const FrameBuffer& fr)\n{\n    _Data->_channels.resize(3);\n    _Data->_channels[0]=\"Z\";\n    _Data->_channels[1]=_Data->_zback ? \"ZBack\" : \"Z\";\n    _Data->_channels[2]=\"A\";\n    _Data->_bufferMap.resize(0);\n    for(FrameBuffer::ConstIterator q=fr.begin();q!=fr.end();q++)\n    {\n        if(q.slice().xSampling!=1 || q.slice().ySampling!=1)\n        {\n             THROW (IEX_NAMESPACE::ArgExc, \"X and/or y subsampling factors \"\n\t\t\t\t\"of \\\"\" << q.name() << \"\\\" channel in framebuffer \"\n\t\t\t\t\"are not 1\");\n        }\n        string name(q.name());\n        if(name==\"ZBack\")\n        {\n            _Data->_bufferMap.push_back(1);\n        }else if(name==\"Z\")\n        {\n            _Data->_bufferMap.push_back(0);\n        }else if(name==\"A\")\n        {\n            _Data->_bufferMap.push_back(2);\n        }else{\n            _Data->_bufferMap.push_back(static_cast<int>(_Data->_channels.size()));\n            _Data->_channels.push_back(name);\n        }\n    }\n  _Data->_outputFrameBuffer=fr;\n}", "target": 0}
{"code": "l2tp_proxy_auth_id_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));\n}", "target": 1}
{"code": "  void decode(bufferlist::iterator& bl) {\n    __u8 struct_v;\n    ::decode(struct_v, bl);\n    ::decode(server_challenge, bl);\n  }", "target": 0}
{"code": "TEST_F(ExtractorTest, TestDefaultHeaderLocation) {\n  auto headers = TestRequestHeaderMapImpl{{\"Authorization\", \"Bearer jwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 1);\n  EXPECT_EQ(tokens[0]->token(), \"jwt_token\");\n  EXPECT_TRUE(tokens[0]->isIssuerSpecified(\"issuer1\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer2\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer3\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer4\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"issuer5\"));\n  EXPECT_FALSE(tokens[0]->isIssuerSpecified(\"unknown_issuer\"));\n  tokens[0]->removeJwt(headers);\n  EXPECT_FALSE(headers.has(Http::CustomHeaders::get().Authorization));\n}", "target": 0}
{"code": "snmp_mib_add(snmp_mib_resource_t *new_resource)\n{\n  snmp_mib_resource_t *resource;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, new_resource->oid) > 0) {\n      break;\n    }\n  }\n  if(resource == NULL) {\n    list_add(snmp_mib, new_resource);\n  } else {\n    list_insert(snmp_mib, new_resource, resource);\n  }\n#if LOG_LEVEL == LOG_LEVEL_DBG\n  LOG_DBG(\"Table after insert.\\n\");\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    snmp_oid_print(resource->oid);\n  }\n#endif \n}", "target": 1}
{"code": "static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n                       Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,\n                       int width, int height, int bandpos)\n{\n    int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n    int clnpass_cnt = 0;\n    int bpass_csty_symbol           = codsty->cblk_style & JPEG2000_CBLK_BYPASS;\n    int vert_causal_ctx_csty_symbol = codsty->cblk_style & JPEG2000_CBLK_VSC;\n    av_assert0(width  <= JPEG2000_MAX_CBLKW);\n    av_assert0(height <= JPEG2000_MAX_CBLKH);\n    for (y = 0; y < height; y++)\n        memset(t1->data[y], 0, width * sizeof(**t1->data));\n    if (!cblk->length)\n        return 0;\n    for (y = 0; y < height + 2; y++)\n        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n    cblk->data[cblk->length] = 0xff;\n    cblk->data[cblk->length+1] = 0xff;\n    ff_mqc_initdec(&t1->mqc, cblk->data);\n    while (passno--) {\n        switch(pass_t) {\n        case 0:\n            decode_sigpass(t1, width, height, bpno + 1, bandpos,\n                           bpass_csty_symbol && (clnpass_cnt >= 4),\n                           vert_causal_ctx_csty_symbol);\n            break;\n        case 1:\n            decode_refpass(t1, width, height, bpno + 1);\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        case 2:\n            decode_clnpass(s, t1, width, height, bpno + 1, bandpos,\n                           codsty->cblk_style & JPEG2000_CBLK_SEGSYM,\n                           vert_causal_ctx_csty_symbol);\n            clnpass_cnt = clnpass_cnt + 1;\n            if (bpass_csty_symbol && clnpass_cnt >= 4)\n                ff_mqc_initdec(&t1->mqc, cblk->data);\n            break;\n        }\n        pass_t++;\n        if (pass_t == 3) {\n            bpno--;\n            pass_t = 0;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "static bool identifyCallsites(\n    Function *F,\n    llvh::DenseSet<CallInst *> &callSites) {\n  if (!F->isStrictMode()) {\n    return false;\n  }\n  for (auto *CU : F->getUsers()) {\n    if (auto *CI = llvh::dyn_cast<CallInst>(CU)) {\n      if (!isDirectCallee(F, CI))\n        return false;\n      callSites.insert(CI);\n    } else if (auto *CFI = llvh::dyn_cast<CreateFunctionInst>(CU)) {\n      for (auto *CL : CFI->getUsers()) {\n        auto *CI = llvh::dyn_cast<CallInst>(CL);\n        if (!CI)\n          return false;\n        if (!isDirectCallee(CFI, CI))\n          return false;\n        callSites.insert(CI);\n      }\n    } else {\n      return false;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static int dr_domain_init_resources(struct mlx5dr_domain *dmn)\n{\n\tint ret;\n\tdmn->ste_ctx = mlx5dr_ste_get_ctx(dmn->info.caps.sw_format_ver);\n\tif (!dmn->ste_ctx) {\n\t\tmlx5dr_err(dmn, \"SW Steering on this device is unsupported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tret = mlx5_core_alloc_pd(dmn->mdev, &dmn->pdn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate PD, ret: %d\", ret);\n\t\treturn ret;\n\t}\n\tdmn->uar = mlx5_get_uars_page(dmn->mdev);\n\tif (!dmn->uar) {\n\t\tmlx5dr_err(dmn, \"Couldn't allocate UAR\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_pd;\n\t}\n\tdmn->ste_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_STE);\n\tif (!dmn->ste_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto clean_uar;\n\t}\n\tdmn->action_icm_pool = mlx5dr_icm_pool_create(dmn, DR_ICM_TYPE_MODIFY_ACTION);\n\tif (!dmn->action_icm_pool) {\n\t\tmlx5dr_err(dmn, \"Couldn't get action icm memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_ste_icm_pool;\n\t}\n\tret = mlx5dr_send_ring_alloc(dmn);\n\tif (ret) {\n\t\tmlx5dr_err(dmn, \"Couldn't create send-ring\\n\");\n\t\tgoto free_action_icm_pool;\n\t}\n\treturn 0;\nfree_action_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->action_icm_pool);\nfree_ste_icm_pool:\n\tmlx5dr_icm_pool_destroy(dmn->ste_icm_pool);\nclean_uar:\n\tmlx5_put_uars_page(dmn->mdev, dmn->uar);\nclean_pd:\n\tmlx5_core_dealloc_pd(dmn->mdev, dmn->pdn);\n\treturn ret;\n}", "target": 1}
{"code": "void setScaleAndScrollAndLayout(WebKit::WebView* webView, WebPoint scroll, float scale)\n{\n    webView->setPageScaleFactor(scale, WebPoint(scroll.x, scroll.y));\n    webView->layout();\n}", "target": 0}
{"code": "v8::Handle<v8::Value> V8DOMWindow::addEventListenerMethodCustom(const v8::Arguments& args)\n{\n    String eventType = toWebCoreString(args[0]);\n    bool useCapture = args[2]->BooleanValue();\n    DOMWindow* imp = V8DOMWindow::toNative(args.Holder());\n    if (!BindingSecurity::shouldAllowAccessToFrame(imp->frame()))\n        return v8::Undefined();\n    Document* doc = imp->document();\n    if (!doc)\n        return v8::Undefined();\n    if (!imp->frame())\n        return v8::Undefined();\n    RefPtr<EventListener> listener = V8EventListenerList::getEventListener(args[1], false, ListenerFindOrCreate);\n    if (listener) {\n        imp->addEventListener(eventType, listener, useCapture);\n        createHiddenDependency(args.Holder(), args[1], eventListenerCacheIndex, args.GetIsolate());\n    }\n    return v8::Undefined();\n}", "target": 0}
{"code": "win_init_some(win_T *newp, win_T *oldp)\n{\n    newp->w_alist = oldp->w_alist;\n    ++newp->w_alist->al_refcount;\n    newp->w_arg_idx = oldp->w_arg_idx;\n    win_copy_options(oldp, newp);\n}", "target": 0}
{"code": "void CNB::DoIPHdrCSO(PVOID IpHeader, ULONG EthPayloadLength) const\n{\n    ParaNdis_CheckSumVerifyFlat(IpHeader,\n                                EthPayloadLength,\n                                pcrIpChecksum | pcrFixIPChecksum,\n                                __FUNCTION__);\n}", "target": 1}
{"code": "static bool check_reg_sane_offset(struct bpf_verifier_env *env,\n\t\t\t\t  const struct bpf_reg_state *reg,\n\t\t\t\t  enum bpf_reg_type type)\n{\n\tbool known = tnum_is_const(reg->var_off);\n\ts64 val = reg->var_off.value;\n\ts64 smin = reg->smin_value;\n\tif (known && (val >= BPF_MAX_VAR_OFF || val <= -BPF_MAX_VAR_OFF)) {\n\t\tverbose(env, \"math between %s pointer and %lld is not allowed\\n\",\n\t\t\treg_type_str[type], val);\n\t\treturn false;\n\t}\n\tif (reg->off >= BPF_MAX_VAR_OFF || reg->off <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"%s pointer offset %d is not allowed\\n\",\n\t\t\treg_type_str[type], reg->off);\n\t\treturn false;\n\t}\n\tif (smin == S64_MIN) {\n\t\tverbose(env, \"math between %s pointer and register with unbounded min value is not allowed\\n\",\n\t\t\treg_type_str[type]);\n\t\treturn false;\n\t}\n\tif (smin >= BPF_MAX_VAR_OFF || smin <= -BPF_MAX_VAR_OFF) {\n\t\tverbose(env, \"value %lld makes %s pointer be out of bounds\\n\",\n\t\t\tsmin, reg_type_str[type]);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 0}
{"code": "static int rawsock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint rc;\n\tpr_debug(\"sock=%p sk=%p len=%zu flags=%d\\n\", sock, sk, len, flags);\n\tskb = skb_recv_datagram(sk, flags, noblock, &rc);\n\tif (!skb)\n\t\treturn rc;\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\trc = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tskb_free_datagram(sk, skb);\n\treturn rc ? : copied;\n}", "target": 1}
{"code": "int writeToFile(PlatformFileHandle handle, const char* data, int length)\n{\n    if (!isHandleValid(handle))\n        return -1;\n    DWORD bytesWritten;\n    bool success = WriteFile(handle, data, length, &bytesWritten, 0);\n    if (!success)\n        return -1;\n    return static_cast<int>(bytesWritten);\n}", "target": 0}
{"code": "ClientContextImpl::newSsl(const Network::TransportSocketOptionsConstSharedPtr& options) {\n  bssl::UniquePtr<SSL> ssl_con(ContextImpl::newSsl(options));\n  const std::string server_name_indication = options && options->serverNameOverride().has_value()\n                                                 ? options->serverNameOverride().value()\n                                                 : server_name_indication_;\n  if (!server_name_indication.empty()) {\n    const int rc = SSL_set_tlsext_host_name(ssl_con.get(), server_name_indication.c_str());\n    RELEASE_ASSERT(rc, Utility::getLastCryptoError().value_or(\"\"));\n  }\n  if (options && !options->verifySubjectAltNameListOverride().empty()) {\n    SSL_set_verify(ssl_con.get(), SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, nullptr);\n  }\n  bool has_alpn_defined = !parsed_alpn_protocols_.empty();\n  if (options) {\n    has_alpn_defined |= parseAndSetAlpn(options->applicationProtocolListOverride(), *ssl_con);\n  }\n  if (options && !has_alpn_defined && !options->applicationProtocolFallback().empty()) {\n    parseAndSetAlpn(options->applicationProtocolFallback(), *ssl_con);\n  }\n  if (allow_renegotiation_) {\n    SSL_set_renegotiate_mode(ssl_con.get(), ssl_renegotiate_freely);\n  }\n  SSL_set_enforce_rsa_key_usage(ssl_con.get(), enforce_rsa_key_usage_);\n  if (max_session_keys_ > 0) {\n    if (session_keys_single_use_) {\n      absl::WriterMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n        if (SSL_SESSION_should_be_single_use(session)) {\n          session_keys_.pop_front();\n        }\n      }\n    } else {\n      absl::ReaderMutexLock l(&session_keys_mu_);\n      if (!session_keys_.empty()) {\n        SSL_SESSION* session = session_keys_.front().get();\n        SSL_set_session(ssl_con.get(), session);\n      }\n    }\n  }\n  return ssl_con;\n}", "target": 1}
{"code": "gplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUF_SIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n    PROCNAME(\"gplotAddPlot\");\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    if (!nay)\n        return ERROR_INT(\"nay not defined\", procName, 1);\n    if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)\n        return ERROR_INT(\"invalid plotstyle\", procName, 1);\n    if ((n = numaGetCount(nay)) == 0)\n        return ERROR_INT(\"no points to plot\", procName, 1);\n    if (nax && (n != numaGetCount(nax)))\n        return ERROR_INT(\"nax and nay sizes differ\", procName, 1);\n    if (n == 1 && plotstyle == GPLOT_LINES) {\n        L_INFO(\"only 1 pt; changing style to points\\n\", procName);\n        plotstyle = GPLOT_POINTS;\n    }\n    numaGetParameters(nay, &startx, &delx);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n    gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n    return 0;\n}", "target": 1}
{"code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}", "target": 1}
{"code": "static void disk_seqf_stop(struct seq_file *seqf, void *v)\n{\n\tstruct class_dev_iter *iter = seqf->private;\n\tif (iter) {\n\t\tclass_dev_iter_exit(iter);\n\t\tkfree(iter);\n\t\tseqf->private = NULL;\n\t}\n}", "target": 0}
{"code": "const int& getActiveId(const void* object, const StructInfo& info) {\n  return *reinterpret_cast<const int*>(\n      static_cast<const char*>(object) + info.unionExt->unionTypeOffset);\n}", "target": 0}
{"code": "static int ghash_update(struct shash_desc *desc,\n\t\t\t const u8 *src, unsigned int srclen)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *dst = dctx->buffer;\n\tif (!ctx->gf128)\n\t\treturn -ENOKEY;\n\tif (dctx->bytes) {\n\t\tint n = min(srclen, dctx->bytes);\n\t\tu8 *pos = dst + (GHASH_BLOCK_SIZE - dctx->bytes);\n\t\tdctx->bytes -= n;\n\t\tsrclen -= n;\n\t\twhile (n--)\n\t\t\t*pos++ ^= *src++;\n\t\tif (!dctx->bytes)\n\t\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t}\n\twhile (srclen >= GHASH_BLOCK_SIZE) {\n\t\tcrypto_xor(dst, src, GHASH_BLOCK_SIZE);\n\t\tgf128mul_4k_lle((be128 *)dst, ctx->gf128);\n\t\tsrc += GHASH_BLOCK_SIZE;\n\t\tsrclen -= GHASH_BLOCK_SIZE;\n\t}\n\tif (srclen) {\n\t\tdctx->bytes = GHASH_BLOCK_SIZE - srclen;\n\t\twhile (srclen--)\n\t\t\t*dst++ ^= *src++;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\tlist_for_each_entry(device, &fs_info->fs_devices->devices,\n\t\t\t\t    dev_list) {\n\t\t\tif (test_bit(BTRFS_DEV_STATE_IN_FS_METADATA,\n\t\t\t\t     &device->dev_state) && !device->bdev)\n\t\t\t\treturn device;\n\t\t}\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\treturn btrfs_find_device_by_path(fs_info, device_path);\n}", "target": 1}
{"code": "parse_device(dev_t *pdev, struct archive *a, char *val)\n{\n#define MAX_PACK_ARGS 3\n\tunsigned long numbers[MAX_PACK_ARGS];\n\tchar *p, *dev;\n\tint argc;\n\tpack_t *pack;\n\tdev_t result;\n\tconst char *error = NULL;\n\tmemset(pdev, 0, sizeof(*pdev));\n\tif ((dev = strchr(val, ',')) != NULL) {\n\t\t*dev++ = '\\0';\n\t\tif ((pack = pack_find(val)) == NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Unknown format `%s'\", val);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\targc = 0;\n\t\twhile ((p = la_strsep(&dev, \",\")) != NULL) {\n\t\t\tif (*p == '\\0') {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Missing number\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t\tnumbers[argc++] = (unsigned long)mtree_atol(&p);\n\t\t\tif (argc > MAX_PACK_ARGS) {\n\t\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t\t    \"Too many arguments\");\n\t\t\t\treturn ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t\tif (argc < 2) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"Not enough arguments\");\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t\tresult = (*pack)(argc, numbers, &error);\n\t\tif (error != NULL) {\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,\n\t\t\t    \"%s\", error);\n\t\t\treturn ARCHIVE_WARN;\n\t\t}\n\t} else {\n\t\tresult = (dev_t)mtree_atol(&val);\n\t}\n\t*pdev = result;\n\treturn ARCHIVE_OK;\n#undef MAX_PACK_ARGS\n}", "target": 1}
{"code": "PJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n    PJ_UNUSED_ARG(ses);\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n    if ((*hdr)->x) {\n        if (offset + sizeof (pjmedia_rtp_ext_hdr) > (unsigned)pkt_len)\n            return PJMEDIA_RTP_EINLEN;\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "TfLiteStatus ResizeOutputTensors(TfLiteContext* context, TfLiteNode* node,\n                                 const TfLiteTensor* axis,\n                                 const TfLiteTensor* input, int num_splits) {\n  int axis_value = GetTensorData<int>(axis)[0];\n  if (axis_value < 0) {\n    axis_value += NumDimensions(input);\n  }\n  TF_LITE_ENSURE(context, axis_value >= 0);\n  TF_LITE_ENSURE(context, axis_value < NumDimensions(input));\n  const int input_size = SizeOfDimension(input, axis_value);\n  TF_LITE_ENSURE(context, num_splits != 0);\n  TF_LITE_ENSURE_MSG(context, input_size % num_splits == 0,\n                     \"Not an even split\");\n  const int slice_size = input_size / num_splits;\n  for (int i = 0; i < NumOutputs(node); ++i) {\n    TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n    output_dims->data[axis_value] = slice_size;\n    TfLiteTensor* output;\n    TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, i, &output));\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_dims));\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "snmp_oid_print(uint32_t *oid)\n{\n  uint8_t i;\n  i = 0;\n  LOG_DBG(\"{\");\n  while(oid[i] != ((uint32_t)-1)) {\n    LOG_DBG_(\"%lu\", (unsigned long)oid[i]);\n    i++;\n    if(oid[i] != ((uint32_t)-1)) {\n      LOG_DBG_(\".\");\n    }\n  }\n  LOG_DBG_(\"}\\n\");\n}", "target": 1}
{"code": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\tsnprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"cipher\");\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static void handle_post_create(struct http_conn *conn,\n\t\t\t       struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tuint64_t ident;\n\tchar key[256];\n\tint err = 0;\n\tident = 1 + rand_u64() & 0xf;  \n\tre_snprintf(key, sizeof(key), \"%llu\", ident);\n\tinfo(\"POST: new pairing id %llu\\n\", ident);\n\tie = mem_zalloc(sizeof(*ie), ie_destructor);\n\tie->id = ident;\n\tstr_dup(&ie->ident, key);\n\terr = dict_add(verifyd.idents, key, ie);\n\tif (err)\n\t\tgoto out;\n\tmem_deref(ie); \n\thttp_creply(conn, 200, \"OK\",\n\t\t    \"application/json\",\n\t\t    \"{\\\"pairid\\\":\\\"%llu\\\"}\", ident);\n out:\n\tif (err) {\n\t\twarning(\"internal error (%m)\\n\" ,err);\n\t}\n}", "target": 0}
{"code": "static inline int crypto_rng_generate(struct crypto_rng *tfm,\n\t\t\t\t      const u8 *src, unsigned int slen,\n\t\t\t\t      u8 *dst, unsigned int dlen)\n{\n\treturn tfm->generate(tfm, src, slen, dst, dlen);\n}", "target": 1}
{"code": "static int allocDynamic(dynamicPtr *dp, int initialSize, void *data)\n{\n\tif(data == NULL) {\n\t\tdp->logicalSize = 0;\n\t\tdp->dataGood = FALSE;\n\t\tdp->data = gdMalloc(initialSize);\n\t} else {\n\t\tdp->logicalSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->data = data;\n\t}\n\tif(dp->data != NULL) {\n\t\tdp->realSize = initialSize;\n\t\tdp->dataGood = TRUE;\n\t\tdp->pos = 0;\n\t\treturn TRUE;\n\t} else {\n\t\tdp->realSize = 0;\n\t\treturn FALSE;\n\t}\n}", "target": 0}
{"code": "static BOOL zgfx_append(ZGFX_CONTEXT* zgfx, BYTE** ppConcatenated, size_t uncompressedSize,\n                        size_t* pUsed)\n{\n\tWINPR_ASSERT(zgfx);\n\tWINPR_ASSERT(ppConcatenated);\n\tWINPR_ASSERT(pUsed);\n\tconst size_t used = *pUsed;\n\tif (zgfx->OutputCount > UINT32_MAX - used)\n\t\treturn FALSE;\n\tif (used + zgfx->OutputCount > uncompressedSize)\n\t\treturn FALSE;\n\tBYTE* tmp = realloc(*ppConcatenated, used + zgfx->OutputCount + 64ull);\n\tif (!tmp)\n\t\treturn FALSE;\n\t*ppConcatenated = tmp;\n\tCopyMemory(&tmp[used], zgfx->OutputBuffer, zgfx->OutputCount);\n\t*pUsed = used + zgfx->OutputCount;\n\treturn TRUE;\n}", "target": 0}
{"code": "inline int ValidateTensorIndexing(const TfLiteContext* context, int index,\n                                  int max_size, const int* tensor_indices) {\n  if (index >= 0 && index < max_size) {\n    const int tensor_index = tensor_indices[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      return tensor_index;\n    }\n  }\n  return -1;\n}", "target": 0}
{"code": "coolkey_get_attribute_bytes(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE type, u8 *data, size_t *data_len, size_t max_data_len)\n{\n\tconst u8 *val;\n\tsize_t val_len;\n\tint r;\n\tr = coolkey_get_attribute(card, obj, type, &val, &val_len, NULL);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tif (val_len > max_data_len) {\n\t\tval_len = max_data_len;\n\t}\n\tmemcpy(data, val, val_len);\n\t*data_len = val_len;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "static inline bool cma_any_addr(const struct sockaddr *addr)\n{\n\treturn cma_zero_addr(addr) || cma_loopback_addr(addr);\n}", "target": 0}
{"code": "Suite *xml_load_suite(void)\n{\n\tSuite *suite;\n\tTCase *validate;\n\tvalidate = tcase_create(\"Validate\");\n\ttcase_add_test(validate, test_deltas_head_sort);\n\tsuite = suite_create(\"xml_test()\");\n\tsuite_add_tcase(suite, validate);\n\treturn suite;\n}", "target": 0}
{"code": "static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){\n  ExprList *pOrderBy = p->pOrderBy;\n  int nOrderBy = p->pOrderBy->nExpr;\n  sqlite3 *db = pParse->db;\n  KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);\n  if( pRet ){\n    int i;\n    for(i=0; i<nOrderBy; i++){\n      struct ExprList_item *pItem = &pOrderBy->a[i];\n      Expr *pTerm = pItem->pExpr;\n      CollSeq *pColl;\n      if( pTerm->flags & EP_Collate ){\n        pColl = sqlite3ExprCollSeq(pParse, pTerm);\n      }else{\n        pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);\n        if( pColl==0 ) pColl = db->pDfltColl;\n        pOrderBy->a[i].pExpr =\n          sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);\n      }\n      assert( sqlite3KeyInfoIsWriteable(pRet) );\n      pRet->aColl[i] = pColl;\n      pRet->aSortFlags[i] = pOrderBy->a[i].sortFlags;\n    }\n  }\n  return pRet;\n}", "target": 0}
{"code": "void jp2_box_dump(jp2_box_t *box, FILE *out)\n{\n\tjp2_boxinfo_t *boxinfo;\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tassert(boxinfo);\n\tfprintf(out, \"JP2 box: \");\n\tfprintf(out, \"type=%c%s%c (0x%08\"PRIxFAST32\"); length=%\"PRIuFAST32\"\\n\", '\"', boxinfo->name,\n\t  '\"', box->type, box->len);\n\tif (box->ops->dumpdata) {\n\t\t(*box->ops->dumpdata)(box, out);\n\t}\n}", "target": 1}
{"code": "static int ptrace_attach(struct task_struct *task, long request,\n\t\t\t unsigned long addr,\n\t\t\t unsigned long flags)\n{\n\tbool seize = (request == PTRACE_SEIZE);\n\tint retval;\n\tretval = -EIO;\n\tif (seize) {\n\t\tif (addr != 0)\n\t\t\tgoto out;\n\t\tif (flags & ~(unsigned long)PTRACE_O_MASK)\n\t\t\tgoto out;\n\t\tretval = check_ptrace_options(flags);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\tflags = PT_PTRACED | PT_SEIZED | (flags << PT_OPT_FLAG_SHIFT);\n\t} else {\n\t\tflags = PT_PTRACED;\n\t}\n\taudit_ptrace(task);\n\tretval = -EPERM;\n\tif (unlikely(task->flags & PF_KTHREAD))\n\t\tgoto out;\n\tif (same_thread_group(task, current))\n\t\tgoto out;\n\tretval = -ERESTARTNOINTR;\n\tif (mutex_lock_interruptible(&task->signal->cred_guard_mutex))\n\t\tgoto out;\n\ttask_lock(task);\n\tretval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);\n\ttask_unlock(task);\n\tif (retval)\n\t\tgoto unlock_creds;\n\twrite_lock_irq(&tasklist_lock);\n\tretval = -EPERM;\n\tif (unlikely(task->exit_state))\n\t\tgoto unlock_tasklist;\n\tif (task->ptrace)\n\t\tgoto unlock_tasklist;\n\ttask->ptrace = flags;\n\tptrace_link(task, current);\n\tif (!seize)\n\t\tsend_sig_info(SIGSTOP, SEND_SIG_PRIV, task);\n\tspin_lock(&task->sighand->siglock);\n\tif (task_is_stopped(task) &&\n\t    task_set_jobctl_pending(task, JOBCTL_TRAP_STOP | JOBCTL_TRAPPING))\n\t\tsignal_wake_up_state(task, __TASK_STOPPED);\n\tspin_unlock(&task->sighand->siglock);\n\tretval = 0;\nunlock_tasklist:\n\twrite_unlock_irq(&tasklist_lock);\nunlock_creds:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout:\n\tif (!retval) {\n\t\twait_on_bit(&task->jobctl, JOBCTL_TRAPPING_BIT, TASK_KILLABLE);\n\t\tproc_ptrace_connector(task, PTRACE_ATTACH);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "_SSL_check_common_name (X509 *cert, const char *host)\n{\n\tX509_NAME *name;\n\tchar *common_name = NULL;\n\tint common_name_len;\n\tint rv = -1;\n\tGInetAddress *addr;\n\tname = X509_get_subject_name (cert);\n\tif (name == NULL)\n\t\treturn -1;\n\tcommon_name_len = X509_NAME_get_text_by_NID (name, NID_commonName, NULL, 0);\n\tif (common_name_len < 0)\n\t\treturn -1;\n\tcommon_name = calloc (common_name_len + 1, 1);\n\tif (common_name == NULL)\n\t\treturn -1;\n\tX509_NAME_get_text_by_NID (name, NID_commonName, common_name, common_name_len + 1);\n\tif (common_name_len != (int)strlen(common_name))\n\t{\n\t\tg_warning (\"NUL byte in Common Name field, probably a malicious certificate.\\n\");\n\t\trv = -2;\n\t\tgoto out;\n\t}\n\tif ((addr = g_inet_address_new_from_string (host)) != NULL)\n\t{\n\t\tif (g_strcmp0 (common_name, host) == 0)\n\t\t\trv = 0;\n\t\telse\n\t\t\trv = -1;\n\t\tg_object_unref (addr);\n\t}\n\telse if (_SSL_match_hostname (common_name, host) == 0)\n\t\trv = 0;\nout:\n\tfree(common_name);\n\treturn rv;\n}", "target": 0}
{"code": "static int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (ple_gap)\n\t\tgrow_ple_window(vcpu);\n\tkvm_vcpu_on_spin(vcpu, true);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 0}
{"code": "size_t EncodedSizeOfKey(HttpSchemeMetadata, HttpSchemeMetadata::ValueType x) {\n  switch (x) {\n    case HttpSchemeMetadata::kHttp:\n      return 4;\n    case HttpSchemeMetadata::kHttps:\n      return 5;\n    default:\n      return 0;\n  }\n}", "target": 0}
{"code": "  absl::string_view failureReason() const override { return NotReadyReason; }", "target": 0}
{"code": "int mutt_b64_decode(char *out, const char *in)\n{\n  int len = 0;\n  unsigned char digit4;\n  do\n  {\n    const unsigned char digit1 = in[0];\n    if ((digit1 > 127) || (base64val(digit1) == BAD))\n      return -1;\n    const unsigned char digit2 = in[1];\n    if ((digit2 > 127) || (base64val(digit2) == BAD))\n      return -1;\n    const unsigned char digit3 = in[2];\n    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))\n      return -1;\n    digit4 = in[3];\n    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))\n      return -1;\n    in += 4;\n    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);\n    len++;\n    if (digit3 != '=')\n    {\n      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);\n      len++;\n      if (digit4 != '=')\n      {\n        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);\n        len++;\n      }\n    }\n  } while (*in && digit4 != '=');\n  return len;\n}", "target": 1}
{"code": "TfLiteIntArray* TfLiteIntArrayCreate(int size) {\n  size_t alloc_size = TfLiteIntArrayGetSizeInBytes(size);\n  if (alloc_size <= 0) return NULL;\n  TfLiteIntArray* ret = (TfLiteIntArray*)malloc(alloc_size);\n  if (!ret) return ret;\n  ret->size = size;\n  return ret;\n}", "target": 0}
{"code": "static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    cmd_parse_list(idata, s);\n    return;\n  }\n  if (!ImapCheckSubscribed)\n    return;\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  if (!list.name || list.noselect)\n    return;\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}", "target": 1}
{"code": "bool is_valid_status(const string& s) {\n  return (s == \"Enabled\" ||\n          s == \"Disabled\");\n}", "target": 0}
{"code": "OE_INLINE void _handle_oret(\n    oe_sgx_td_t* td,\n    uint16_t func,\n    uint16_t result,\n    uint64_t arg)\n{\n    oe_callsite_t* callsite = td->callsites;\n    if (!callsite)\n        return;\n    td->oret_func = func;\n    td->oret_result = result;\n    td->oret_arg = arg;\n    asm volatile(\"pushq %[rflags] \\n\\t\" \n                 \"popfq \\n\\t\"\n                 \"fldcw %[fcw] \\n\\t\"     \n                 \"ldmxcsr %[mxcsr] \\n\\t\" \n                 : [mxcsr] \"=m\"(callsite->mxcsr),\n                   [fcw] \"=m\"(callsite->fcw),\n                   [rflags] \"=m\"(callsite->rflags)\n                 :\n                 : \"cc\");\n    oe_longjmp(&callsite->jmpbuf, 1);\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tkfree(key->description);\n#ifdef KEY_DEBUGGING\n\t\tkey->magic = KEY_DEBUG_MAGIC_X;\n#endif\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::ClearDisplayedGraphics() {\n  NotifyNewContentRenderingTimeoutForTesting();\n  if (view_)\n    view_->ClearCompositorFrame();\n}", "target": 0}
{"code": "static void __sock_release(struct socket *sock, struct inode *inode)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\t\tif (inode)\n\t\t\tinode_lock(inode);\n\t\tsock->ops->release(sock);\n\t\tif (inode)\n\t\t\tinode_unlock(inode);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tpr_err(\"%s: fasync list not empty!\\n\", __func__);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}", "target": 0}
{"code": "static int nfc_genl_llc_get_params(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tstruct nfc_llcp_local *local;\n\tint rc = 0;\n\tstruct sk_buff *msg = NULL;\n\tu32 idx;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_FIRMWARE_NAME])\n\t\treturn -EINVAL;\n\tidx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\tdevice_lock(&dev->dev);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (!local) {\n\t\trc = -ENODEV;\n\t\tgoto exit;\n\t}\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\trc = nfc_genl_send_params(msg, local, info->snd_portid, info->snd_seq);\nexit:\n\tdevice_unlock(&dev->dev);\n\tnfc_put_device(dev);\n\tif (rc < 0) {\n\t\tif (msg)\n\t\t\tnlmsg_free(msg);\n\t\treturn rc;\n\t}\n\treturn genlmsg_reply(msg, info);\n}", "target": 1}
{"code": "void my_error_exit( j_common_ptr cinfo ) {\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n   longjmp( myerr->setjmp_buffer, 1 );\n}", "target": 1}
{"code": "void virtio_config_writel(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stl_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "static inline ut16 r_read_at_le16(const void *src, size_t offset) {\n\tif (!src) {\n\t\treturn UT16_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le16 (s);\n}", "target": 0}
{"code": "Status CreateTempFileBadString(Env* env, char value, uint64 size,\n                               const string suffix, string* filename) {\n  const string dir = testing::TmpDir();\n  *filename = io::JoinPath(dir, strings::StrCat(\"file_\", suffix));\n  std::unique_ptr<WritableFile> file;\n  TF_RETURN_IF_ERROR(env->NewWritableFile(*filename, &file));\n  TF_RETURN_IF_ERROR(file->Append(std::string(size, value)));\n  TF_RETURN_IF_ERROR(file->Close());\n  return Status::OK();\n}", "target": 0}
{"code": "Item_bool_func2::add_key_fields_optimize_op(JOIN *join, KEY_FIELD **key_fields,\n                                            uint *and_level,\n                                            table_map usable_tables,\n                                            SARGABLE_PARAM **sargables,\n                                            bool equal_func)\n{\n  if (is_local_field(args[0]))\n  {\n    add_key_equal_fields(join, key_fields, *and_level, this,\n                         (Item_field*) args[0]->real_item(), equal_func,\n                         args + 1, 1, usable_tables, sargables);\n  }\n  if (is_local_field(args[1]))\n  {\n    add_key_equal_fields(join, key_fields, *and_level, this, \n                         (Item_field*) args[1]->real_item(), equal_func,\n                         args, 1, usable_tables, sargables);\n  }\n}", "target": 0}
{"code": "static int php_curl_option_str(php_curl *ch, zend_long option, const char *str, const int len, zend_bool make_copy)\n{\n\tCURLcode error = CURLE_OK;\n\tif (strlen(str) != len) {\n\t\tphp_error_docref(NULL, E_WARNING, \"Curl option contains invalid characters (\\\\0)\");\n\t\treturn FAILURE;\n\t}\n#if LIBCURL_VERSION_NUM >= 0x071100\n\tif (make_copy) {\n#endif\n\t\tchar *copystr;\n\t\tcopystr = estrndup(str, len);\n\t\terror = curl_easy_setopt(ch->cp, option, copystr);\n\t\tzend_llist_add_element(&ch->to_free->str, &copystr);\n#if LIBCURL_VERSION_NUM >= 0x071100\n\t} else {\n\t\terror = curl_easy_setopt(ch->cp, option, str);\n\t}\n#endif\n\tSAVE_CURL_ERROR(ch, error)\n\treturn error == CURLE_OK ? SUCCESS : FAILURE;\n}", "target": 0}
{"code": "static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tstruct xc2028_ctrl *p    = priv_cfg;\n\tint                 rc   = 0;\n\ttuner_dbg(\"%s called\\n\", __func__);\n\tmutex_lock(&priv->lock);\n\tkfree(priv->ctrl.fname);\n\tmemcpy(&priv->ctrl, p, sizeof(priv->ctrl));\n\tif (p->fname) {\n\t\tpriv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL);\n\t\tif (priv->ctrl.fname == NULL)\n\t\t\trc = -ENOMEM;\n\t}\n\tif (!firmware_name[0] && p->fname &&\n\t    priv->fname && strcmp(p->fname, priv->fname))\n\t\tfree_firmware(priv);\n\tif (priv->ctrl.max_len < 9)\n\t\tpriv->ctrl.max_len = 13;\n\tif (priv->state == XC2028_NO_FIRMWARE) {\n\t\tif (!firmware_name[0])\n\t\t\tpriv->fname = priv->ctrl.fname;\n\t\telse\n\t\t\tpriv->fname = firmware_name;\n\t\trc = request_firmware_nowait(THIS_MODULE, 1,\n\t\t\t\t\t     priv->fname,\n\t\t\t\t\t     priv->i2c_props.adap->dev.parent,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     fe, load_firmware_cb);\n\t\tif (rc < 0) {\n\t\t\ttuner_err(\"Failed to request firmware %s\\n\",\n\t\t\t\t  priv->fname);\n\t\t\tpriv->state = XC2028_NODEV;\n\t\t} else\n\t\t\tpriv->state = XC2028_WAITING_FIRMWARE;\n\t}\n\tmutex_unlock(&priv->lock);\n\treturn rc;\n}", "target": 1}
{"code": "void SFS_Params(ScriptParser *parser)\n{\n\tu32 val;\n\tif (parser->codec->LastError) return;\n\tval = gf_bs_read_int(parser->bs, 1);\n\twhile (val) {\n\t\tSFS_Expression(parser);\n\t\tif (parser->codec->LastError) return;\n\t\tval = gf_bs_read_int(parser->bs, 1);\n\t\tif(val) SFS_AddString(parser, \",\");\n\t}\n}", "target": 0}
{"code": "static const char *cmd_xml_external_entity(cmd_parms *cmd, void *_dcfg, const char *p1)\n{\n    directory_config *dcfg = (directory_config *)_dcfg;\n    if (dcfg == NULL) return NULL;\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->xml_external_entity = 1;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->xml_external_entity = 0;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecXmlExternalEntity: %s\", p1);\n    return NULL;\n}", "target": 0}
{"code": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\tif (error < 0)\n\t\treturn error;\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\terror = git_stream_connect(t->io);\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\tt->connected = 1;\n\treturn 0;\n}", "target": 1}
{"code": "static int64_t adjust_scale(int64_t scale) {\n  if (scale < 0) {\n    scale = BCG(bc_precision);\n    if (scale < 0) scale = 0;\n  }\n  if ((uint64_t)scale > StringData::MaxSize) return StringData::MaxSize;\n  return scale;\n}", "target": 0}
{"code": "  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size =\n        prefix_size + internal::to_unsigned(spec.precision());\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    CharPtr result = prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size);\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    return result;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::uninitialized_fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::uninitialized_fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}", "target": 1}
{"code": "static unsigned int get_exif_ui32(struct iw_exif_state *e, unsigned int pos)\n{\n\tif(e->d_len<4 || pos>e->d_len-4) return 0;\n\treturn iw_get_ui32_e(&e->d[pos], e->endian);\n}", "target": 0}
{"code": "static void vmx_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exec_control;\n\tvmx->rdtscp_enabled = false;\n\tif (vmx_rdtscp_supported()) {\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\tif (exec_control & SECONDARY_EXEC_RDTSCP) {\n\t\t\tbest = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n\t\t\tif (best && (best->edx & bit(X86_FEATURE_RDTSCP)))\n\t\t\t\tvmx->rdtscp_enabled = true;\n\t\t\telse {\n\t\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\t\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\t\texec_control);\n\t\t\t}\n\t\t}\n\t}\n\tbest = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tif (vmx_invpcid_supported() &&\n\t    best && (best->ebx & bit(X86_FEATURE_INVPCID)) &&\n\t    guest_cpuid_has_pcid(vcpu)) {\n\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\texec_control |= SECONDARY_EXEC_ENABLE_INVPCID;\n\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t     exec_control);\n\t} else {\n\t\tif (cpu_has_secondary_exec_ctrls()) {\n\t\t\texec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tvmcs_write32(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t     exec_control);\n\t\t}\n\t\tif (best)\n\t\t\tbest->ebx &= ~bit(X86_FEATURE_INVPCID);\n\t}\n}", "target": 0}
{"code": "void HeaderMapImpl::subtractSize(uint64_t size) {\n  if (cached_byte_size_.has_value()) {\n    ASSERT(cached_byte_size_ >= size);\n    cached_byte_size_.value() -= size;\n  }\n}", "target": 0}
{"code": "R_API bool r_io_bank_read_at(RIO *io, const ut32 bankid, ut64 addr, ut8 *buf, int len) {\n\tr_return_val_if_fail (io, false);\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tif (!bank) {\n\t\treturn false;\n\t}\n\tRIOSubMap fake_sm = {{0}};\n\tfake_sm.itv.addr = addr;\n\tfake_sm.itv.size = len;\n\tRRBNode *node;\n\tif (R_LIKELY (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr))) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = _find_entry_submap_node (bank, &fake_sm);\n\t}\n\tmemset (buf, io->Oxff, len);\n\tRIOSubMap *sm = node ? (RIOSubMap *)node->data : NULL;\n\tbool ret = true;\n\twhile (sm && r_io_submap_overlap ((&fake_sm), sm)) {\n\t\tbank->last_used = node;\n\t\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\t\tif (!map) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!(map->perm & R_PERM_R)) {\n\t\t\tnode = r_rbnode_next (node);\n\t\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tconst ut64 buf_off = R_MAX (addr, r_io_submap_from (sm)) - addr;\n\t\tconst int read_len = R_MIN (r_io_submap_to ((&fake_sm)),\n\t\t\t\t\t     r_io_submap_to (sm)) - (addr + buf_off) + 1;\n\t\tif (map->perm & R_PERM_RELOC) {\n\t\t\tret &= map->reloc_map->read (io, map, addr + buf_off, &buf[buf_off], read_len);\n\t\t} else {\n\t\t\tconst ut64 paddr = addr + buf_off - r_io_map_from (map) + map->delta;\n\t\t\tret &= (r_io_fd_read_at (io, map->fd, paddr, &buf[buf_off], read_len) == read_len);\n\t\t}\n\t\tnode = r_rbnode_next (node);\n\t\tsm = node ? (RIOSubMap *)node->data : NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void rose_timer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, timer);\n\tstruct sock *sk = &rose->sock;\n\tbh_lock_sock(sk);\n\tswitch (rose->state) {\n\tcase ROSE_STATE_1:\t\n\tcase ROSE_STATE_4:\t\n\t\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\t\trose->state = ROSE_STATE_2;\n\t\trose_start_t3timer(sk);\n\t\tbreak;\n\tcase ROSE_STATE_2:\t\n\t\trose->neighbour->use--;\n\t\trose_disconnect(sk, ETIMEDOUT, -1, -1);\n\t\tbreak;\n\tcase ROSE_STATE_3:\t\n\t\tif (rose->condition & ROSE_COND_ACK_PENDING) {\n\t\t\trose->condition &= ~ROSE_COND_ACK_PENDING;\n\t\t\trose_enquiry_response(sk);\n\t\t}\n\t\tbreak;\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "wsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tu_int newstate = VT100_EMUL_STATE_CSI;\n\tint oargs;\n\tint rc = 0;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4':\n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > VT100_EMUL_NARGS - 1)\n\t\t\tbreak;\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';': \n\t\tedp->nargs++;\n\t\tbreak;\n\tcase '?': \n\tcase '>': \n\t\tedp->modif1 = (char)instate->inchar;\n\t\tbreak;\n\tcase '!':\n\tcase '\"':\n\tcase '$':\n\tcase '&':\n\t\tedp->modif2 = (char)instate->inchar;\n\t\tbreak;\n\tdefault: \n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > VT100_EMUL_NARGS) {\n#ifdef VT100_DEBUG\n\t\t\tprintf(\"vt100: too many arguments\\n\");\n#endif\n\t\t\tedp->nargs = VT100_EMUL_NARGS;\n\t\t}\n\t\trc = wsemul_vt100_handle_csi(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tnewstate = VT100_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\tif (COLS_LEFT != 0)\n\t\tedp->flags &= ~VTFL_LASTCHAR;\n\tedp->state = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "    size_t operator()(const ArrayOrObject data) const {\n      return data.toOpaque();\n    }", "target": 0}
{"code": "static void vgacon_scrollback_reset(int vc_num, size_t reset_size)\n{\n\tstruct vgacon_scrollback_info *scrollback = &vgacon_scrollbacks[vc_num];\n\tif (scrollback->data && reset_size > 0)\n\t\tmemset(scrollback->data, 0, reset_size);\n\tscrollback->cnt  = 0;\n\tscrollback->tail = 0;\n\tscrollback->cur  = 0;\n}", "target": 1}
{"code": "static Jsi_RC SysGetEnvCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    extern char **environ;\n    char *cp;\n    int i;\n    if (interp->isSafe)\n        return Jsi_LogError(\"no getenv in safe mode\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (v != NULL) {\n        const char *fnam = Jsi_ValueString(interp, v, NULL);\n        if (!fnam) \n            return Jsi_LogError(\"arg1: expected string 'name'\");\n        cp = getenv(fnam);\n        if (cp != NULL) {\n            Jsi_ValueMakeStringDup(interp, ret, cp);\n        }\n        return JSI_OK;\n    }\n    Jsi_Value *vres;\n    Jsi_Obj  *ores = Jsi_ObjNew(interp);\n    Jsi_Value *nnv;\n    char *val, nam[200];\n    vres = Jsi_ValueMakeObject(interp, NULL, ores);\n    for (i=0; ; i++) {\n        int n;\n        cp = environ[i];\n        if (cp == 0 || ((val = Jsi_Strchr(cp, '='))==NULL))\n            break;\n        n = val-cp+1;\n        if (n>=(int)sizeof(nam))\n            n = sizeof(nam)-1;\n        Jsi_Strncpy(nam, cp, n);\n        val = val+1;\n        nnv = Jsi_ValueMakeStringDup(interp, NULL, val);\n        Jsi_ObjInsert(interp, ores, nam, nnv, 0);\n    }\n    Jsi_ValueReplace(interp, ret, vres);\n    return JSI_OK;\n}", "target": 1}
{"code": "void ImageLoader::DecodeRequest::Trace(blink::Visitor* visitor) {\n  visitor->Trace(resolver_);\n  visitor->Trace(loader_);\n}", "target": 0}
{"code": "const char* menu_cache_item_get_file_basename( MenuCacheItem* item )\n{\n    return item->file_name;\n}", "target": 0}
{"code": "static int fuse_verify_ioctl_iov(struct iovec *iov, size_t count)\n{\n\tsize_t n;\n\tu32 max = FUSE_MAX_PAGES_PER_REQ << PAGE_SHIFT;\n\tfor (n = 0; n < count; n++) {\n\t\tif (iov->iov_len > (size_t) max)\n\t\t\treturn -ENOMEM;\n\t\tmax -= iov->iov_len;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "PredictorEncodeTile(TIFF* tif, uint8* bp0, tmsize_t cc0, uint16 s)\n{\n\tstatic const char module[] = \"PredictorEncodeTile\";\n\tTIFFPredictorState *sp = PredictorState(tif);\n        uint8 *working_copy;\n\ttmsize_t cc = cc0, rowsize;\n\tunsigned char* bp;\n        int result_code;\n\tassert(sp != NULL);\n\tassert(sp->encodepfunc != NULL);\n\tassert(sp->encodetile != NULL);\n        working_copy = (uint8*) _TIFFmalloc(cc0);\n        if( working_copy == NULL )\n        {\n            TIFFErrorExt(tif->tif_clientdata, module, \n                         \"Out of memory allocating \" TIFF_SSIZE_FORMAT \" byte temp buffer.\",\n                         cc0 );\n            return 0;\n        }\n        memcpy( working_copy, bp0, cc0 );\n        bp = working_copy;\n\trowsize = sp->rowsize;\n\tassert(rowsize > 0);\n\tif((cc0%rowsize)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"PredictorEncodeTile\",\n                     \"%s\", \"(cc0%rowsize)!=0\");\n        _TIFFfree( working_copy );\n        return 0;\n    }\n\twhile (cc > 0) {\n\t\t(*sp->encodepfunc)(tif, bp, rowsize);\n\t\tcc -= rowsize;\n\t\tbp += rowsize;\n\t}\n\tresult_code = (*sp->encodetile)(tif, working_copy, cc0, s);\n        _TIFFfree( working_copy );\n        return result_code;\n}", "target": 0}
{"code": "static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->hstep_ = hstep;\n\tcmpt->vstep_ = vstep;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\tif (jas_stream_seek(cmpt->stream_, size - 1, SEEK_SET) < 0 ||\n\t  jas_stream_putc(cmpt->stream_, 0) == EOF ||\n\t  jas_stream_seek(cmpt->stream_, 0, SEEK_SET) < 0) {\n\t\tgoto error;\n\t}\n\treturn cmpt;\nerror:\n\tif (cmpt) {\n\t\tjas_image_cmpt_destroy(cmpt);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void ntlm_write_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tStream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));\n\tStream_Write_UINT32(s, header->MessageType);\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageWBMPPtr(gdImagePtr im, int *size, int fg)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageWBMPCtx(im, fg, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\tdev = file->private_data;\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n}", "target": 1}
{"code": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n        put_bits(&pb, 3, 5); \n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n    adts->write_adts = 1;\n    return 0;\n}", "target": 1}
{"code": "static void record_recent_object(struct object *obj,\n\t\t\t\t struct strbuf *path,\n\t\t\t\t const char *last,\n\t\t\t\t void *data)\n{\n\tsha1_array_append(&recent_objects, obj->oid.hash);\n}", "target": 1}
{"code": "mm_freelist(struct mm_master *mmalloc, struct mmtree *head)\n{\n\tstruct mm_share *mms, *next;\n\tfor (mms = RB_ROOT(head); mms; mms = next) {\n\t\tnext = RB_NEXT(mmtree, head, mms);\n\t\tRB_REMOVE(mmtree, head, mms);\n\t\tif (mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mmalloc, mms);\n\t}\n}", "target": 1}
{"code": "static void srpt_handle_tsk_mgmt(struct srpt_rdma_ch *ch,\n\t\t\t\t struct srpt_recv_ioctx *recv_ioctx,\n\t\t\t\t struct srpt_send_ioctx *send_ioctx)\n{\n\tstruct srp_tsk_mgmt *srp_tsk;\n\tstruct se_cmd *cmd;\n\tstruct se_session *sess = ch->sess;\n\tuint64_t unpacked_lun;\n\tuint32_t tag = 0;\n\tint tcm_tmr;\n\tint rc;\n\tBUG_ON(!send_ioctx);\n\tsrp_tsk = recv_ioctx->ioctx.buf;\n\tcmd = &send_ioctx->cmd;\n\tpr_debug(\"recv tsk_mgmt fn %d for task_tag %lld and cmd tag %lld\"\n\t\t \" cm_id %p sess %p\\n\", srp_tsk->tsk_mgmt_func,\n\t\t srp_tsk->task_tag, srp_tsk->tag, ch->cm_id, ch->sess);\n\tsrpt_set_cmd_state(send_ioctx, SRPT_STATE_MGMT);\n\tsend_ioctx->cmd.tag = srp_tsk->tag;\n\ttcm_tmr = srp_tmr_to_tcm(srp_tsk->tsk_mgmt_func);\n\tif (tcm_tmr < 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\tTMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED;\n\t\tgoto fail;\n\t}\n\tunpacked_lun = srpt_unpack_lun((uint8_t *)&srp_tsk->lun,\n\t\t\t\t       sizeof(srp_tsk->lun));\n\tif (srp_tsk->tsk_mgmt_func == SRP_TSK_ABORT_TASK) {\n\t\trc = srpt_rx_mgmt_fn_tag(send_ioctx, srp_tsk->task_tag);\n\t\tif (rc < 0) {\n\t\t\tsend_ioctx->cmd.se_tmr_req->response =\n\t\t\t\t\tTMR_TASK_DOES_NOT_EXIST;\n\t\t\tgoto fail;\n\t\t}\n\t\ttag = srp_tsk->task_tag;\n\t}\n\trc = target_submit_tmr(&send_ioctx->cmd, sess, NULL, unpacked_lun,\n\t\t\t\tsrp_tsk, tcm_tmr, GFP_KERNEL, tag,\n\t\t\t\tTARGET_SCF_ACK_KREF);\n\tif (rc != 0) {\n\t\tsend_ioctx->cmd.se_tmr_req->response = TMR_FUNCTION_REJECTED;\n\t\tgoto fail;\n\t}\n\treturn;\nfail:\n\ttransport_send_check_condition_and_sense(cmd, 0, 0); \n}", "target": 1}
{"code": "void AICast_ScriptLoad( void ) {\n\tchar filename[MAX_QPATH];\n\tvmCvar_t mapname;\n\tfileHandle_t f;\n\tint len;\n\tlevel.scriptAI = NULL;\n\ttrap_Cvar_VariableStringBuffer( \"ai_scriptName\", filename, sizeof( filename ) );\n\tif ( strlen( filename ) > 0 ) {\n\t\ttrap_Cvar_Register( &mapname, \"ai_scriptName\", \"\", CVAR_ROM );\n\t} else {\n\t\ttrap_Cvar_Register( &mapname, \"mapname\", \"\", CVAR_SERVERINFO | CVAR_ROM );\n\t}\n\tQ_strncpyz( filename, \"maps/\", sizeof( filename ) );\n\tQ_strcat( filename, sizeof( filename ), mapname.string );\n\tif ( g_gametype.integer <= GT_COOP ) {\n\t\tQ_strcat( filename, sizeof( filename ), \".coop.ai\" );\n\t} else {\n\t\tQ_strcat( filename, sizeof( filename ), \".ai\" );\n\t}\n\tlen = trap_FS_FOpenFile( filename, &f, FS_READ );\n\tG_Printf( \"Loading: %s\\n\", filename );\n\tif ( len < 0 ) {\n\t\treturn;\n\t}\n\tlevel.scriptAI = G_Alloc( len );\n\ttrap_FS_Read( level.scriptAI, len, f );\n\ttrap_FS_FCloseFile( f );\n\treturn;\n}", "target": 1}
{"code": "static int read_probe(const AVProbeData *p)\n{\n    int cnt = 0;\n    for (int i = 0; i < p->buf_size; i++)\n        cnt += !!isansicode(p->buf[i]);\n    return (cnt * 100LL / p->buf_size) * (cnt > 400) *\n        !!av_match_ext(p->filename, tty_extensions);\n}", "target": 0}
{"code": "gopherMimeCreate(GopherStateData * gopherState)\n{\n    StoreEntry *entry = gopherState->entry;\n    const char *mime_type = nullptr;\n    const char *mime_enc = nullptr;\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n    case GOPHER_INDEX:\n    case GOPHER_HTML:\n    case GOPHER_WWW:\n    case GOPHER_CSO:\n        mime_type = \"text/html\";\n        break;\n    case GOPHER_GIF:\n    case GOPHER_IMAGE:\n    case GOPHER_PLUS_IMAGE:\n        mime_type = \"image/gif\";\n        break;\n    case GOPHER_SOUND:\n    case GOPHER_PLUS_SOUND:\n        mime_type = \"audio/basic\";\n        break;\n    case GOPHER_PLUS_MOVIE:\n        mime_type = \"video/mpeg\";\n        break;\n    case GOPHER_MACBINHEX:\n    case GOPHER_DOSBIN:\n    case GOPHER_UUENCODED:\n    case GOPHER_BIN:\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_bin;\n        break;\n    case GOPHER_FILE:\n    default:\n        mime_enc = mimeGetContentEncoding(gopherState->request);\n        mime_type = mimeGetContentType(gopherState->request);\n        if (!mime_type)\n            mime_type = def_gopher_text;\n        break;\n    }\n    assert(entry->isEmpty());\n    HttpReply *reply = new HttpReply;\n    entry->buffer();\n    reply->setHeaders(Http::scOkay, \"Gatewaying\", mime_type, -1, -1, -2);\n    if (mime_enc)\n        reply->header.putStr(Http::HdrType::CONTENT_ENCODING, mime_enc);\n    entry->replaceHttpReply(reply);\n    gopherState->reply_ = reply;\n}", "target": 1}
{"code": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = malloc(sizeof(SOCKET_IO_INSTANCE));\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    result->hostname = (char*)malloc(strlen(socket_io_config->hostname) + 1);\n                    if (result->hostname != NULL)\n                    {\n                        (void)strcpy(result->hostname, socket_io_config->hostname);\n                    }\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((int*)socket_io_config->accepted_socket);\n                }\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->target_mac_address = NULL;\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n    if((cc%(bps*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpDiff\",\n                     \"%s\", \"(cc%(bps*stride))!=0\");\n        return 0;\n    }\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[byte * wc + count] = tmp[bps * count + byte];\n\t\t\t#else\n\t\t\tcp[(bps - byte - 1) * wc + count] =\n\t\t\t\ttmp[bps * count + byte];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n\tcp = (uint8 *) cp0;\n\tcp += cc - stride - 1;\n\tfor (count = cc; count > stride; count -= stride)\n\t\tREPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)\n    return 1;\n}", "target": 0}
{"code": "static bool nfs_request_too_big(struct svc_rqst *rqstp,\n\t\t\t\tstruct svc_procedure *proc)\n{\n\tif (rqstp->rq_prog != NFS_PROGRAM)\n\t\treturn false;\n\tif (rqstp->rq_vers >= 4)\n\t\treturn false;\n\tif (proc->pc_xdrressize > 0 &&\n\t    proc->pc_xdrressize < XDR_QUADLEN(PAGE_SIZE))\n\t\treturn false;\n\treturn rqstp->rq_arg.len > PAGE_SIZE;\n}", "target": 0}
{"code": "ossl_cipher_set_key(VALUE self, VALUE key)\n{\n    EVP_CIPHER_CTX *ctx;\n    int key_len;\n    StringValue(key);\n    GetCipher(self, ctx);\n    key_len = EVP_CIPHER_CTX_key_length(ctx);\n    if (RSTRING_LEN(key) != key_len)\n\tossl_raise(rb_eArgError, \"key must be %d bytes\", key_len);\n    if (EVP_CipherInit_ex(ctx, NULL, NULL, (unsigned char *)RSTRING_PTR(key), NULL, -1) != 1)\n\tossl_raise(eCipherError, NULL);\n    rb_ivar_set(self, id_key_set, Qtrue);\n    return key;\n}", "target": 0}
{"code": "    bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t      int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t      bool& isvalid, CryptoKey& session_key) override {\n      isvalid = true;\n      return true;\n    }", "target": 1}
{"code": "static int key_notify_sa_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb;\n\tstruct sadb_msg *hdr;\n\tskb = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb, sizeof(struct sadb_msg));\n\thdr->sadb_msg_satype = pfkey_proto2satype(c->data.proto);\n\thdr->sadb_msg_type = SADB_FLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t compress(zckCtx *zck, zckComp *comp, const char *src,\n                        const size_t src_size, char **dst, size_t *dst_size,\n                        bool use_dict) {\n    VALIDATE_INT(zck);\n    ALLOCD_INT(zck, dst);\n    ALLOCD_INT(zck, src);\n    ALLOCD_INT(zck, dst_size);\n    ALLOCD_INT(zck, comp);\n    if((comp->dc_data_size > comp->dc_data_size + src_size) ||\n       (src_size > comp->dc_data_size + src_size)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading decompressed data\");\n        return false;\n    }\n    comp->dc_data = zrealloc(comp->dc_data, comp->dc_data_size + src_size);\n    if (!comp->dc_data) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return -1;\n    }\n    memcpy(comp->dc_data + comp->dc_data_size, src, src_size);\n    *dst = NULL;\n    *dst_size = 0;\n    return 0;\n}", "target": 0}
{"code": "static void *createArrayObject(const redisReadTask *task, size_t elements) {\n    redisReply *r, *parent;\n    r = createReplyObject(task->type);\n    if (r == NULL)\n        return NULL;\n    if (elements > 0) {\n        if (SIZE_MAX / sizeof(redisReply*) < elements) return NULL;  \n        r->element = hi_calloc(elements,sizeof(redisReply*));\n        if (r->element == NULL) {\n            freeReplyObject(r);\n            return NULL;\n        }\n    }\n    r->elements = elements;\n    if (task->parent) {\n        parent = task->parent->obj;\n        assert(parent->type == REDIS_REPLY_ARRAY ||\n               parent->type == REDIS_REPLY_MAP ||\n               parent->type == REDIS_REPLY_SET ||\n               parent->type == REDIS_REPLY_PUSH);\n        parent->element[task->idx] = r;\n    }\n    return r;\n}", "target": 0}
{"code": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n    free(ptr);\n    return nullptr;\n}", "target": 1}
{"code": "parsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "Pl_ASCII85Decoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCII85Decoder no-op flush\");\n\treturn;\n    }\n    unsigned long lval = 0;\n    for (int i = 0; i < 5; ++i)\n    {\n\tlval *= 85;\n\tlval += (this->inbuf[i] - 33U);\n    }\n    unsigned char outbuf[4];\n    memset(outbuf, 0, 4);\n    for (int i = 3; i >= 0; --i)\n    {\n\toutbuf[i] = lval & 0xff;\n\tlval >>= 8;\n    }\n    QTC::TC(\"libtests\", \"Pl_ASCII85Decoder partial flush\",\n\t    (this->pos == 5) ? 0 : 1);\n    getNext()->write(outbuf, this->pos - 1);\n    this->pos = 0;\n    memset(this->inbuf, 117, 5);\n}", "target": 1}
{"code": "ProcAllocColorCells(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xAllocColorCellsReq);\n    REQUEST_SIZE_MATCH(xAllocColorCellsReq);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,\n                                 client, DixAddAccess);\n    if (rc == Success) {\n        int npixels, nmasks;\n        long length;\n        Pixel *ppixels, *pmasks;\n        npixels = stuff->colors;\n        if (!npixels) {\n            client->errorValue = npixels;\n            return BadValue;\n        }\n        if (stuff->contiguous != xTrue && stuff->contiguous != xFalse) {\n            client->errorValue = stuff->contiguous;\n            return BadValue;\n        }\n        nmasks = stuff->planes;\n        length = ((long) npixels + (long) nmasks) * sizeof(Pixel);\n        ppixels = malloc(length);\n        if (!ppixels)\n            return BadAlloc;\n        pmasks = ppixels + npixels;\n        if ((rc = AllocColorCells(client->index, pcmp, npixels, nmasks,\n                                  (Bool) stuff->contiguous, ppixels, pmasks))) {\n            free(ppixels);\n            return rc;\n        }\n#ifdef PANORAMIX\n        if (noPanoramiXExtension || !pcmp->pScreen->myNum)\n#endif\n        {\n            xAllocColorCellsReply accr = {\n                .type = X_Reply,\n                .sequenceNumber = client->sequence,\n                .length = bytes_to_int32(length),\n                .nPixels = npixels,\n                .nMasks = nmasks\n            };\n            WriteReplyToClient(client, sizeof(xAllocColorCellsReply), &accr);\n            client->pSwapReplyFunc = (ReplySwapPtr) Swap32Write;\n            WriteSwappedDataToClient(client, length, ppixels);\n        }\n        free(ppixels);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "int gru_handle_user_call_os(unsigned long cb)\n{\n\tstruct gru_tlb_fault_handle *tfh;\n\tstruct gru_thread_state *gts;\n\tvoid *cbk;\n\tint ucbnum, cbrnum, ret = -EINVAL;\n\tSTAT(call_os);\n\tucbnum = get_cb_number((void *)cb);\n\tif ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n\t\treturn -EINVAL;\n\tgts = gru_find_lock_gts(cb);\n\tif (!gts)\n\t\treturn -EINVAL;\n\tgru_dbg(grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);\n\tif (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n\t\tgoto exit;\n\tgru_check_context_placement(gts);\n\tif (gts->ts_gru && gts->ts_force_cch_reload) {\n\t\tgts->ts_force_cch_reload = 0;\n\t\tgru_update_cch(gts);\n\t}\n\tret = -EAGAIN;\n\tcbrnum = thread_cbr_number(gts, ucbnum);\n\tif (gts->ts_gru) {\n\t\ttfh = get_tfh_by_index(gts->ts_gru, cbrnum);\n\t\tcbk = get_gseg_base_address_cb(gts->ts_gru->gs_gru_base_vaddr,\n\t\t\t\tgts->ts_ctxnum, ucbnum);\n\t\tret = gru_user_dropin(gts, tfh, cbk);\n\t}\nexit:\n\tgru_unlock_gts(gts);\n\treturn ret;\n}", "target": 1}
{"code": "ext4_xattr_release_block(handle_t *handle, struct inode *inode,\n\t\t\t struct buffer_head *bh)\n{\n\tstruct mb_cache_entry *ce = NULL;\n\tint error = 0;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tce = mb_cache_entry_get(ext4_mb_cache, bh->b_bdev, bh->b_blocknr);\n\tBUFFER_TRACE(bh, \"get_write_access\");\n\terror = ext4_journal_get_write_access(handle, bh);\n\tif (error)\n\t\tgoto out;\n\tlock_buffer(bh);\n\tif (BHDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tea_bdebug(bh, \"refcount now=0; freeing\");\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\tget_bh(bh);\n\t\tunlock_buffer(bh);\n\t\text4_free_blocks(handle, inode, bh, 0, 1,\n\t\t\t\t EXT4_FREE_BLOCKS_METADATA |\n\t\t\t\t EXT4_FREE_BLOCKS_FORGET);\n\t} else {\n\t\tle32_add_cpu(&BHDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tif (ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tunlock_buffer(bh);\n\t\tif (!ext4_handle_valid(handle))\n\t\t\terror = ext4_handle_dirty_xattr_block(handle, inode,\n\t\t\t\t\t\t\t      bh);\n\t\tif (IS_SYNC(inode))\n\t\t\text4_handle_sync(handle);\n\t\tdquot_free_block(inode, EXT4_C2B(EXT4_SB(inode->i_sb), 1));\n\t\tea_bdebug(bh, \"refcount now=%d; releasing\",\n\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount));\n\t}\nout:\n\text4_std_error(inode->i_sb, error);\n\treturn;\n}", "target": 1}
{"code": "find_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n    if (!is_referral_req(kdc_active_realm, request))\n        goto cleanup;\n    hostname = data2string(krb5_princ_component(kdc_context,\n                                                request->server, 1));\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(kdc_context, hostname, &realms);\n    if (retval) {\n        kdc_err(kdc_context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    if (realms == NULL || realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(kdc_context, realms);\n    free(hostname);\n    return retval;\n}", "target": 1}
{"code": "gsm_xsmp_client_connect (GsmXSMPClient *client,\n                         SmsConn        conn,\n                         unsigned long *mask_ret,\n                         SmsCallbacks  *callbacks_ret)\n{\n        client->priv->conn = conn;\n        if (client->priv->protocol_timeout) {\n                g_source_remove (client->priv->protocol_timeout);\n                client->priv->protocol_timeout = 0;\n        }\n        g_debug (\"GsmXSMPClient: Initializing client %s\", client->priv->description);\n        *mask_ret = 0;\n        *mask_ret |= SmsRegisterClientProcMask;\n        callbacks_ret->register_client.callback = register_client_callback;\n        callbacks_ret->register_client.manager_data  = client;\n        *mask_ret |= SmsInteractRequestProcMask;\n        callbacks_ret->interact_request.callback = interact_request_callback;\n        callbacks_ret->interact_request.manager_data = client;\n        *mask_ret |= SmsInteractDoneProcMask;\n        callbacks_ret->interact_done.callback = interact_done_callback;\n        callbacks_ret->interact_done.manager_data = client;\n        *mask_ret |= SmsSaveYourselfRequestProcMask;\n        callbacks_ret->save_yourself_request.callback = save_yourself_request_callback;\n        callbacks_ret->save_yourself_request.manager_data = client;\n        *mask_ret |= SmsSaveYourselfP2RequestProcMask;\n        callbacks_ret->save_yourself_phase2_request.callback = save_yourself_phase2_request_callback;\n        callbacks_ret->save_yourself_phase2_request.manager_data = client;\n        *mask_ret |= SmsSaveYourselfDoneProcMask;\n        callbacks_ret->save_yourself_done.callback = save_yourself_done_callback;\n        callbacks_ret->save_yourself_done.manager_data = client;\n        *mask_ret |= SmsCloseConnectionProcMask;\n        callbacks_ret->close_connection.callback = close_connection_callback;\n        callbacks_ret->close_connection.manager_data  = client;\n        *mask_ret |= SmsSetPropertiesProcMask;\n        callbacks_ret->set_properties.callback = set_properties_callback;\n        callbacks_ret->set_properties.manager_data = client;\n        *mask_ret |= SmsDeletePropertiesProcMask;\n        callbacks_ret->delete_properties.callback = delete_properties_callback;\n        callbacks_ret->delete_properties.manager_data = client;\n        *mask_ret |= SmsGetPropertiesProcMask;\n        callbacks_ret->get_properties.callback = get_properties_callback;\n        callbacks_ret->get_properties.manager_data = client;\n}", "target": 1}
{"code": "\tvoid testQueryCompositionMathWrite_GoogleAutofuzz113244572() {\n\t\tUriQueryListA second = { .key = \"\\x11\", .value = NULL, .next = NULL };\n\t\tUriQueryListA first = { .key = \"\\x01\", .value = \"\\x02\", .next = &second };\n\t\tconst UriBool spaceToPlus = URI_TRUE;\n\t\tconst UriBool normalizeBreaks = URI_FALSE;  \n\t\tconst int charsRequired = (3 + 1 + 3) + 1 + (3);\n\t\t{\n\t\t\tconst char * const expected = \"%01=%02\" \"&\" \"%11\";\n\t\t\tchar dest[charsRequired + 1];\n\t\t\tint charsWritten;\n\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_SUCCESS);\n\t\t\tTEST_ASSERT(! strcmp(dest, expected));\n\t\t\tTEST_ASSERT(charsWritten == strlen(expected) + 1);\n\t\t}\n\t\t{\n\t\t\tchar dest[charsRequired + 1 - 1];\n\t\t\tint charsWritten;\n\t\t\tTEST_ASSERT(uriComposeQueryExA(dest, &first, sizeof(dest),\n\t\t\t\t\t&charsWritten, spaceToPlus, normalizeBreaks)\n\t\t\t\t== URI_ERROR_OUTPUT_TOO_LARGE);\n\t\t}\n\t}", "target": 0}
{"code": "static size_t read_test_file(char **buffer, char *basename)\n{\n    char *filename;\n    FILE *fp;\n    size_t exp_size, act_size;\n    filename = gdTestFilePath2(\"tiff\", basename);\n    fp = fopen(filename, \"rb\");\n    gdTestAssert(fp != NULL);\n\tfseek(fp, 0, SEEK_END);\n\texp_size = ftell(fp);\n\tfseek(fp, 0, SEEK_SET);\n    *buffer = malloc(exp_size);\n    gdTestAssert(*buffer != NULL);\n    act_size = fread(*buffer, sizeof(**buffer), exp_size, fp);\n    gdTestAssert(act_size == exp_size);\n    fclose(fp);\n    free(filename);\n    return act_size;\n}", "target": 0}
{"code": "KCleanup::operator= ( const KCleanup &src )\n{\n    copy( src );\n    return *this;\n}", "target": 0}
{"code": "selaGetCombName(SELA    *sela,\n                l_int32  size,\n                l_int32  direction)\n{\nchar    *selname;\nchar     combname[L_BUF_SIZE];\nl_int32  i, nsels, sx, sy, found;\nSEL     *sel;\n    PROCNAME(\"selaGetCombName\");\n    if (!sela)\n        return (char *)ERROR_PTR(\"sela not defined\", procName, NULL);\n    if (direction != L_HORIZ && direction != L_VERT)\n        return (char *)ERROR_PTR(\"invalid direction\", procName, NULL);\n    if (direction == L_HORIZ)\n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dh\", size);\n    else  \n        snprintf(combname, L_BUF_SIZE, \"sel_comb_%dv\", size);\n    found = FALSE;\n    nsels = selaGetCount(sela);\n    for (i = 0; i < nsels; i++) {\n        sel = selaGetSel(sela, i);\n        selGetParameters(sel, &sy, &sx, NULL, NULL);\n        if (sy != 1 && sx != 1)  \n            continue;\n        selname = selGetName(sel);\n        if (!strcmp(selname, combname)) {\n            found = TRUE;\n            break;\n        }\n    }\n    if (found)\n        return stringNew(selname);\n    else\n        return (char *)ERROR_PTR(\"sel not found\", procName, NULL);\n}", "target": 1}
{"code": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\tsig_none = timr->it_sigev_notify == SIGEV_NONE;\n\tiv = timr->it_interval;\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += (int)kc->timer_forward(timr, now);\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}", "target": 1}
{"code": "is_word_char(unsigned char *ch)\n{\n    Lineprop ctype = get_mctype(ch);\n#ifdef USE_M17N\n    if (ctype & (PC_CTRL | PC_KANJI | PC_UNKNOWN))\n\treturn 0;\n    if (ctype & (PC_WCHAR1 | PC_WCHAR2))\n\treturn 1;\n#else\n    if (ctype == PC_CTRL)\n\treturn 0;\n#endif\n    if (IS_ALNUM(*ch))\n\treturn 1;\n    switch (*ch) {\n    case ',':\n    case '.':\n    case ':':\n    case '\\\"':\t\t\t\n    case '\\'':\n    case '$':\n    case '%':\n    case '*':\n    case '+':\n    case '-':\n    case '@':\n    case '~':\n    case '_':\n\treturn 1;\n    }\n#ifdef USE_M17N\n    if (*ch == NBSP_CODE)\n\treturn 1;\n#else\n    if (*ch == TIMES_CODE || *ch == DIVIDE_CODE || *ch == ANSP_CODE)\n\treturn 0;\n    if (*ch >= AGRAVE_CODE || *ch == NBSP_CODE)\n\treturn 1;\n#endif\n    return 0;\n}", "target": 0}
{"code": "GF_Err pcmC_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_PCMConfigBox *ptr = (GF_PCMConfigBox *) s;\n\te = gf_isom_full_box_write(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u8(bs, ptr->format_flags);\n\tgf_bs_write_u8(bs, ptr->PCM_sample_size);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void nested_vmx_failInvalid(struct kvm_vcpu *vcpu)\n{\n\tvmx_set_rflags(vcpu, (vmx_get_rflags(vcpu)\n\t\t\t& ~(X86_EFLAGS_PF | X86_EFLAGS_AF | X86_EFLAGS_ZF |\n\t\t\t    X86_EFLAGS_SF | X86_EFLAGS_OF))\n\t\t\t| X86_EFLAGS_CF);\n}", "target": 0}
{"code": "static int fuse_notify_inval_entry(struct fuse_conn *fc, unsigned int size,\n\t\t\t\t   struct fuse_copy_state *cs)\n{\n\tstruct fuse_notify_inval_entry_out outarg;\n\tint err = -ENOMEM;\n\tchar *buf;\n\tstruct qstr name;\n\tbuf = kzalloc(FUSE_NAME_MAX + 1, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto err;\n\terr = -EINVAL;\n\tif (size < sizeof(outarg))\n\t\tgoto err;\n\terr = fuse_copy_one(cs, &outarg, sizeof(outarg));\n\tif (err)\n\t\tgoto err;\n\terr = -ENAMETOOLONG;\n\tif (outarg.namelen > FUSE_NAME_MAX)\n\t\tgoto err;\n\terr = -EINVAL;\n\tif (size != sizeof(outarg) + outarg.namelen + 1)\n\t\tgoto err;\n\tname.name = buf;\n\tname.len = outarg.namelen;\n\terr = fuse_copy_one(cs, buf, outarg.namelen + 1);\n\tif (err)\n\t\tgoto err;\n\tfuse_copy_finish(cs);\n\tbuf[outarg.namelen] = 0;\n\tname.hash = full_name_hash(name.name, name.len);\n\tdown_read(&fc->killsb);\n\terr = -ENOENT;\n\tif (fc->sb)\n\t\terr = fuse_reverse_inval_entry(fc->sb, outarg.parent, &name);\n\tup_read(&fc->killsb);\n\tkfree(buf);\n\treturn err;\nerr:\n\tkfree(buf);\n\tfuse_copy_finish(cs);\n\treturn err;\n}", "target": 0}
{"code": "mm_memvalid(struct mm_master *mm, void *address, size_t size)\n{\n\tvoid *end = (char *)address + size;\n\tif (address < mm->address)\n\t\tfatal(\"mm_memvalid: address too small: %p\", address);\n\tif (end < address)\n\t\tfatal(\"mm_memvalid: end < address: %p < %p\", end, address);\n\tif (end > MM_ADDRESS_END(mm))\n\t\tfatal(\"mm_memvalid: address too large: %p\", address);\n}", "target": 1}
{"code": "static RList *r_bin_wasm_get_global_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmGlobalEntry *ptr = NULL;\n\tint buflen = bin->buf->length;\n\tif (sec->payload_data + 32 > buflen) {\n\t\treturn NULL;\n\t}\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmGlobalEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, (ut8*)&ptr->content_type, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_u8 (buf + i, buf + len, &ptr->mutability, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (len + 8 > buflen || !(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr++;\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}", "target": 1}
{"code": "void invalidFunctionWasCalled() {}", "target": 0}
{"code": "static void do_popen(FILE *fin, FILE *fout, int afdt_fd) {\n  char buf[BUFFER_SIZE];\n  char cwd[BUFFER_SIZE];\n  if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';\n  bool read_only = (buf[0] == 'r');\n  read_buf(fin, buf);\n  std::string old_cwd = Process::GetCurrentDirectory();\n  read_buf(fin, cwd);\n  if (old_cwd != cwd) {\n    if (chdir(cwd)) {\n      Logger::Warning(\"Light Process failed chdir to %s.\", cwd);\n    }\n  }\n  FILE *f = buf[0] ? ::popen(buf, read_only ? \"r\" : \"w\") : nullptr;\n  if (old_cwd != cwd && chdir(old_cwd.c_str())) {\n  }\n  if (f == nullptr) {\n    Logger::Error(\"Light process failed popen: %d (%s).\", errno,\n                  folly::errnoStr(errno).c_str());\n    fprintf(fout, \"error\\n\");\n    fflush(fout);\n  } else {\n    fprintf(fout, \"success\\n%\" PRId64 \"\\n\", (int64_t)f);\n    fflush(fout);\n    int fd = fileno(f);\n    send_fd(afdt_fd, fd);\n  }\n}", "target": 1}
{"code": "dirserv_get_bandwidth_for_router_kb(const routerinfo_t *ri)\n{\n  uint32_t bw_kb = 0;\n  long mbw_kb = 0;\n  if (ri) {\n    if (dirserv_query_measured_bw_cache_kb(ri->cache_info.identity_digest,\n                                        &mbw_kb, NULL)) {\n      bw_kb = (uint32_t)mbw_kb;\n    } else {\n      bw_kb = router_get_advertised_bandwidth(ri) / 1000;\n    }\n  }\n  return bw_kb;\n}", "target": 0}
{"code": "archive_wstring_append_from_mbs(struct archive_wstring *dest,\n    const char *p, size_t len)\n{\n\tsize_t r;\n\tint ret_val = 0;\n\tsize_t wcs_length = len;\n\tsize_t mbs_length = len;\n\tconst char *mbs = p;\n\twchar_t *wcs;\n#if HAVE_MBRTOWC\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#endif\n\tif (NULL == archive_wstring_ensure(dest, dest->length + wcs_length + 1))\n\t\treturn (-1);\n\twcs = dest->s + dest->length;\n\twhile (*mbs && mbs_length > 0) {\n\t\tif (wcs_length == 0) {\n\t\t\tdest->length = wcs - dest->s;\n\t\t\tdest->s[dest->length] = L'\\0';\n\t\t\twcs_length = mbs_length;\n\t\t\tif (NULL == archive_wstring_ensure(dest,\n\t\t\t    dest->length + wcs_length + 1))\n\t\t\t\treturn (-1);\n\t\t\twcs = dest->s + dest->length;\n\t\t}\n#if HAVE_MBRTOWC\n\t\tr = mbrtowc(wcs, mbs, wcs_length, &shift_state);\n#else\n\t\tr = mbtowc(wcs, mbs, wcs_length);\n#endif\n\t\tif (r == (size_t)-1 || r == (size_t)-2) {\n\t\t\tret_val = -1;\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t++mbs;\n\t\t\t\t--mbs_length;\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\t\tif (r == 0 || r > mbs_length)\n\t\t\tbreak;\n\t\twcs++;\n\t\twcs_length--;\n\t\tmbs += r;\n\t\tmbs_length -= r;\n\t}\n\tdest->length = wcs - dest->s;\n\tdest->s[dest->length] = L'\\0';\n\treturn (ret_val);\n}", "target": 0}
{"code": "static int stv06xx_start(struct gspca_dev *gspca_dev)\n{\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint err, packet_size;\n\tintf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface);\n\talt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt);\n\tif (!alt) {\n\t\tgspca_err(gspca_dev, \"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\terr = stv06xx_write_bridge(sd, STV_ISO_SIZE_L, packet_size);\n\tif (err < 0)\n\t\treturn err;\n\terr = sd->sensor->start(sd);\n\tif (err < 0)\n\t\tgoto out;\n\terr = stv06xx_write_bridge(sd, STV_ISO_ENABLE, 1);\nout:\n\tif (err < 0)\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Starting stream failed\\n\");\n\telse\n\t\tgspca_dbg(gspca_dev, D_STREAM, \"Started streaming\\n\");\n\treturn (err < 0) ? err : 0;\n}", "target": 0}
{"code": "DLLIMPORT const char *cfg_title(cfg_t *cfg)\n{\n\tif (cfg)\n\t\treturn cfg->title;\n\treturn NULL;\n}", "target": 0}
{"code": "  void SetUp() override {\n    auto *file = UTHENTICODE_TEST_ASSETS \"/YourPhone.exe\";\n    pe = peparse::ParsePEFromFile(file);\n    ASSERT_TRUE(pe != nullptr);\n  }", "target": 0}
{"code": "static __exit void sctp_exit(void)\n{\n\tsctp_v6_del_protocol();\n\tsctp_v4_del_protocol();\n\tunregister_pernet_subsys(&sctp_net_ops);\n\tsctp_v6_protosw_exit();\n\tsctp_v4_protosw_exit();\n\tsctp_v6_pf_exit();\n\tsctp_v4_pf_exit();\n\tsctp_sysctl_unregister();\n\tfree_pages((unsigned long)sctp_assoc_hashtable,\n\t\t   get_order(sctp_assoc_hashsize *\n\t\t\t     sizeof(struct sctp_hashbucket)));\n\tkfree(sctp_ep_hashtable);\n\tfree_pages((unsigned long)sctp_port_hashtable,\n\t\t   get_order(sctp_port_hashsize *\n\t\t\t     sizeof(struct sctp_bind_hashbucket)));\n\tpercpu_counter_destroy(&sctp_sockets_allocated);\n\trcu_barrier(); \n\tkmem_cache_destroy(sctp_chunk_cachep);\n\tkmem_cache_destroy(sctp_bucket_cachep);\n}", "target": 1}
{"code": "static int fdt_check_no_at(const void *fit, int parent)\n{\n\tconst char *name;\n\tint node;\n\tint ret;\n\tname = fdt_get_name(fit, parent, NULL);\n\tif (!name || strchr(name, '@'))\n\t\treturn -EADDRNOTAVAIL;\n\tfdt_for_each_subnode(node, fit, parent) {\n\t\tret = fdt_check_no_at(fit, node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "hb_set_union (hb_set_t       *set,\n\t      const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->union_ (*other);\n}", "target": 1}
{"code": "gplotCreate(const char  *rootname,\n            l_int32      outformat,\n            const char  *title,\n            const char  *xlabel,\n            const char  *ylabel)\n{\nchar    *newroot;\nchar     buf[L_BUF_SIZE];\nl_int32  badchar;\nGPLOT   *gplot;\n    PROCNAME(\"gplotCreate\");\n    if (!rootname)\n        return (GPLOT *)ERROR_PTR(\"rootname not defined\", procName, NULL);\n    if (outformat != GPLOT_PNG && outformat != GPLOT_PS &&\n        outformat != GPLOT_EPS && outformat != GPLOT_LATEX)\n        return (GPLOT *)ERROR_PTR(\"outformat invalid\", procName, NULL);\n    stringCheckForChars(rootname, \"`;&|><\\\"?*\", &badchar);\n    if (badchar)  \n        return (GPLOT *)ERROR_PTR(\"invalid rootname\", procName, NULL);\n    if ((gplot = (GPLOT *)LEPT_CALLOC(1, sizeof(GPLOT))) == NULL)\n        return (GPLOT *)ERROR_PTR(\"gplot not made\", procName, NULL);\n    gplot->cmddata = sarrayCreate(0);\n    gplot->datanames = sarrayCreate(0);\n    gplot->plotdata = sarrayCreate(0);\n    gplot->plottitles = sarrayCreate(0);\n    gplot->plotstyles = numaCreate(0);\n    newroot = genPathname(rootname, NULL);\n    gplot->rootname = newroot;\n    gplot->outformat = outformat;\n    snprintf(buf, L_BUF_SIZE, \"%s.cmd\", rootname);\n    gplot->cmdname = stringNew(buf);\n    if (outformat == GPLOT_PNG)\n        snprintf(buf, L_BUF_SIZE, \"%s.png\", newroot);\n    else if (outformat == GPLOT_PS)\n        snprintf(buf, L_BUF_SIZE, \"%s.ps\", newroot);\n    else if (outformat == GPLOT_EPS)\n        snprintf(buf, L_BUF_SIZE, \"%s.eps\", newroot);\n    else if (outformat == GPLOT_LATEX)\n        snprintf(buf, L_BUF_SIZE, \"%s.tex\", newroot);\n    gplot->outname = stringNew(buf);\n    if (title) gplot->title = stringNew(title);\n    if (xlabel) gplot->xlabel = stringNew(xlabel);\n    if (ylabel) gplot->ylabel = stringNew(ylabel);\n    return gplot;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayReduceSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, i;\n    Jsi_Obj *obj;\n    Jsi_Value *func, *vpargs, *ini = Jsi_ValueArrayIndex(interp, args, 1);\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *nrPtr = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0)\n        Jsi_ObjSetLength(interp, obj, 0);\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_Value *vobjs[4];\n    int n, rev = (op==2);\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>4)\n        maa = 4;\n    for (n = 0, i = (rev?obj->arrCnt-1:0); (rev?i>=0:i < (int)obj->arrCnt) && rc == JSI_OK; n++, i = (rev?i-1:i+1)) {\n        if (!obj->arr[i]) continue;\n        if (n==0 && !ini) {\n            ini = obj->arr[i];\n            continue;\n        }\n        vobjs[0] = ini;\n        vobjs[1] = obj->arr[i];\n        vobjs[2] = (maa>2?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[3] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, &nrPtr, NULL);\n        Jsi_DecrRefCount(interp, vpargs);\n        if (rc != JSI_OK)\n            break;\n        ini = nrPtr;\n    }\n    if (rc == JSI_OK && ini)\n        Jsi_ValueCopy(interp, *ret, ini); \n    Jsi_DecrRefCount(interp, nrPtr);\n    return rc;\n}", "target": 1}
{"code": "int jp2_box_put(jp2_box_t *box, jas_stream_t *out)\n{\n\tjas_stream_t *tmpstream;\n\tbool extlen;\n\tbool dataflag;\n\ttmpstream = 0;\n\tdataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));\n\tif (dataflag) {\n\t\tif (!(tmpstream = jas_stream_memopen(0, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (box->ops->putdata) {\n\t\t\tif ((*box->ops->putdata)(box, tmpstream)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tbox->len = jas_stream_tell(tmpstream) + JP2_BOX_HDRLEN(false);\n\t\tjas_stream_rewind(tmpstream);\n\t}\n\textlen = (box->len >= (((uint_fast64_t)1) << 32)) != 0;\n\tif (jp2_putuint32(out, extlen ? 1 : box->len)) {\n\t\tgoto error;\n\t}\n\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn 0;\nerror:\n\tif (tmpstream) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t}\n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "id3_skip (SF_PRIVATE * psf)\n{\tunsigned char\tbuf [10] ;\n\tmemset (buf, 0, sizeof (buf)) ;\n\tpsf_binheader_readf (psf, \"pb\", 0, buf, 10) ;\n\tif (buf [0] == 'I' && buf [1] == 'D' && buf [2] == '3')\n\t{\tint\toffset = buf [6] & 0x7f ;\n\t\toffset = (offset << 7) | (buf [7] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [8] & 0x7f) ;\n\t\toffset = (offset << 7) | (buf [9] & 0x7f) ;\n\t\tpsf_log_printf (psf, \"ID3 length : %d\\n--------------------\\n\", offset) ;\n\t\tif (offset < 0)\n\t\t\treturn 0 ;\n\t\tpsf->fileoffset += offset + 10 ;\n\t\tpsf_binheader_readf (psf, \"p\", psf->fileoffset) ;\n\t\treturn 1 ;\n\t\t} ;\n\treturn 0 ;\n} ", "target": 1}
{"code": "static unsigned int get_exif_ui16(struct iw_exif_state *e, unsigned int pos)\n{\n\tif(e->d_len<2 || pos>e->d_len-2) return 0;\n\treturn iw_get_ui16_e(&e->d[pos], e->endian);\n}", "target": 0}
{"code": "MONGO_EXPORT gridfs_offset gridfile_read( gridfile *gfile, gridfs_offset size, char *buf ) {\n    mongo_cursor *chunks;\n    bson chunk;\n    int first_chunk;\n    int last_chunk;\n    int total_chunks;\n    gridfs_offset chunksize;\n    gridfs_offset contentlength;\n    gridfs_offset bytes_left;\n    int i;\n    bson_iterator it;\n    gridfs_offset chunk_len;\n    const char *chunk_data;\n    contentlength = gridfile_get_contentlength( gfile );\n    chunksize = gridfile_get_chunksize( gfile );\n    size = ( contentlength - gfile->pos < size )\n           ? contentlength - gfile->pos\n           : size;\n    bytes_left = size;\n    first_chunk = ( gfile->pos )/chunksize;\n    last_chunk = ( gfile->pos+size-1 )/chunksize;\n    total_chunks = last_chunk - first_chunk + 1;\n    chunks = gridfile_get_chunks( gfile, first_chunk, total_chunks );\n    for ( i = 0; i < total_chunks; i++ ) {\n        mongo_cursor_next( chunks );\n        chunk = chunks->current;\n        bson_find( &it, &chunk, \"data\" );\n        chunk_len = bson_iterator_bin_len( &it );\n        chunk_data = bson_iterator_bin_data( &it );\n        if ( i == 0 ) {\n            chunk_data += ( gfile->pos )%chunksize;\n            chunk_len -= ( gfile->pos )%chunksize;\n        }\n        if ( bytes_left > chunk_len ) {\n            memcpy( buf, chunk_data, chunk_len );\n            bytes_left -= chunk_len;\n            buf += chunk_len;\n        }\n        else {\n            memcpy( buf, chunk_data, bytes_left );\n        }\n    }\n    mongo_cursor_destroy( chunks );\n    gfile->pos = gfile->pos + size;\n    return size;\n}", "target": 1}
{"code": "static int mp_get_count(struct sb_uart_state *state, struct serial_icounter_struct *icnt)\n{\n\tstruct serial_icounter_struct icount;\n\tstruct sb_uart_icount cnow;\n\tstruct sb_uart_port *port = state->port;\n\tspin_lock_irq(&port->lock);\n\tmemcpy(&cnow, &port->icount, sizeof(struct sb_uart_icount));\n\tspin_unlock_irq(&port->lock);\n\ticount.cts         = cnow.cts;\n\ticount.dsr         = cnow.dsr;\n\ticount.rng         = cnow.rng;\n\ticount.dcd         = cnow.dcd;\n\ticount.rx          = cnow.rx;\n\ticount.tx          = cnow.tx;\n\ticount.frame       = cnow.frame;\n\ticount.overrun     = cnow.overrun;\n\ticount.parity      = cnow.parity;\n\ticount.brk         = cnow.brk;\n\ticount.buf_overrun = cnow.buf_overrun;\n\treturn copy_to_user(icnt, &icount, sizeof(icount)) ? -EFAULT : 0;\n}", "target": 1}
{"code": "static inline void show_node(struct zone *zone)\n{\n\tif (IS_ENABLED(CONFIG_NUMA))\n\t\tprintk(\"Node %d \", zone_to_nid(zone));\n}", "target": 0}
{"code": "bool Item_trigger_field::fix_fields(THD *thd, Item **items)\n{\n  DBUG_ASSERT(fixed == 0);\n  if (field_idx != (uint)-1)\n  {\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n    if (table_grants)\n    {\n      table_grants->want_privilege= want_privilege;\n      if (check_grant_column(thd, table_grants, triggers->trigger_table->s->db.str,\n                             triggers->trigger_table->s->table_name.str, field_name,\n                             strlen(field_name), thd->security_ctx))\n        return TRUE;\n    }\n#endif \n    field= (row_version == OLD_ROW) ? triggers->old_field[field_idx] :\n                                      triggers->new_field[field_idx];\n    set_field(field);\n    fixed= 1;\n    return FALSE;\n  }\n  my_error(ER_BAD_FIELD_ERROR, MYF(0), field_name,\n           (row_version == NEW_ROW) ? \"NEW\" : \"OLD\");\n  return TRUE;\n}", "target": 0}
{"code": "static int sco_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sco_options opts;\n\tstruct sco_conninfo cinfo;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase SCO_OPTIONS:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\topts.mtu = sco_pi(sk)->conn->mtu;\n\t\tBT_DBG(\"mtu %d\", opts.mtu);\n\t\tlen = min_t(unsigned int, len, sizeof(opts));\n\t\tif (copy_to_user(optval, (char *)&opts, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase SCO_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = sco_pi(sk)->conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, sco_pi(sk)->conn->hcon->dev_class, 3);\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *)&cinfo, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "do_decrypt (const RIJNDAEL_context *ctx, unsigned char *bx,\n            const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t       &dec_tables);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_decrypt_block(ctx->keyschdec, bx, ax, ctx->rounds,\n\t\t\t\t     &dec_tables);\n#else\n  return do_decrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "int crypto_reportstat(struct sk_buff *in_skb, struct nlmsghdr *in_nlh,\n\t\t      struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(in_skb->sk);\n\tstruct crypto_user_alg *p = nlmsg_data(in_nlh);\n\tstruct crypto_alg *alg;\n\tstruct sk_buff *skb;\n\tstruct crypto_dump_info info;\n\tint err;\n\tif (!null_terminated(p->cru_name) || !null_terminated(p->cru_driver_name))\n\t\treturn -EINVAL;\n\talg = crypto_alg_match(p, 0);\n\tif (!alg)\n\t\treturn -ENOENT;\n\terr = -ENOMEM;\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto drop_alg;\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = in_nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = 0;\n\terr = crypto_reportstat_alg(alg, &info);\ndrop_alg:\n\tcrypto_mod_put(alg);\n\tif (err)\n\t\treturn err;\n\treturn nlmsg_unicast(net->crypto_nlsk, skb, NETLINK_CB(in_skb).portid);\n}", "target": 1}
{"code": "spnego_gss_get_mic(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_qop_t  qop_req,\n\t\tconst gss_buffer_t message_buffer,\n\t\tgss_buffer_t message_token)\n{\n\tOM_uint32 ret;\n\tret = gss_get_mic(minor_status,\n\t\t    context_handle,\n\t\t    qop_req,\n\t\t    message_buffer,\n\t\t    message_token);\n\treturn (ret);\n}", "target": 1}
{"code": "void TileManager::crop( RawTile *ttt ){\n  int tw = image->getTileWidth();\n  int th = image->getTileHeight();\n  if( loglevel >= 5 ){\n    *logfile << \"TileManager :: Edge tile: Base size: \" << tw << \"x\" << th\n\t     << \": This tile: \" << ttt->width << \"x\" << ttt->height\n\t     << endl;\n  }\n  int len = tw * th * ttt->channels * (ttt->bpc/8);\n  unsigned char* buffer = (unsigned char*) malloc( len );\n  unsigned char* src_ptr = (unsigned char*) memcpy( buffer, ttt->data, len );\n  unsigned char* dst_ptr = (unsigned char*) ttt->data;\n  len =  ttt->width * ttt->channels * (ttt->bpc/8);\n  for( unsigned int i=0; i<ttt->height; i++ ){\n    memcpy( dst_ptr, src_ptr, len );\n    dst_ptr += len;\n    src_ptr += tw * ttt->channels * (ttt->bpc/8);\n  }\n  free( buffer );\n  len = ttt->width * ttt->height * ttt->channels * (ttt->bpc/8);\n  ttt->dataLength = len;\n  ttt->padded = false;\n}", "target": 1}
{"code": "void AsfVideo::streamProperties() {\n  DataBuf streamTypedBuf = io_->read(GUID);\n  enum class streamTypeInfo { Audio = 1, Video = 2 };\n  auto stream = static_cast<streamTypeInfo>(0);\n  auto tag_stream_type = GUIDReferenceTags.find(GUIDTag(streamTypedBuf.data()));\n  if (tag_stream_type != GUIDReferenceTags.end()) {\n    if (tag_stream_type->second == \"Audio_Media\")\n      stream = streamTypeInfo::Audio;\n    else if (tag_stream_type->second == \"Video_Media\")\n      stream = streamTypeInfo::Video;\n    io_->seek(io_->tell() + GUID, BasicIo::beg);  \n    uint64_t time_offset = readQWORDTag(io_);\n    if (stream == streamTypeInfo::Video)\n      xmpData()[\"Xmp.video.TimeOffset\"] = time_offset;\n    else if (stream == streamTypeInfo::Audio)\n      xmpData()[\"Xmp.audio.TimeOffset\"] = time_offset;\n    auto specific_data_length = readDWORDTag(io_);\n    auto correction_data_length = readDWORDTag(io_);\n    io_->seek(io_->tell() + WORD  + DWORD  + specific_data_length + correction_data_length,\n              BasicIo::beg);\n  }\n}  ", "target": 1}
{"code": "header_put_be_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "static void check_file(char *basename)\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n    size = read_test_file(&buffer, basename);\n    im = gdImageCreateFromTgaPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n}", "target": 0}
{"code": "void *hashtable_get(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n    return pair->value;\n}", "target": 1}
{"code": "Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}", "target": 1}
{"code": "spnego_gss_wrap_iov(OM_uint32 *minor_status,\n\t\t    gss_ctx_id_t context_handle,\n\t\t    int conf_req_flag,\n\t\t    gss_qop_t qop_req,\n\t\t    int *conf_state,\n\t\t    gss_iov_buffer_desc *iov,\n\t\t    int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov(minor_status,\n\t\t\t   context_handle,\n\t\t\t   conf_req_flag,\n\t\t\t   qop_req,\n\t\t\t   conf_state,\n\t\t\t   iov,\n\t\t\t   iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const TensorShape& input_shape = input.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape filter_shape;\n    if (takes_shape_) {\n      const Tensor& filter_sizes = context->input(1);\n      OP_REQUIRES_OK(context, TensorShapeUtils::MakeShape(\n                                  filter_sizes.vec<int32>(), &filter_shape));\n    } else {\n      filter_shape = context->input(1).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context,\n                   ConvBackpropComputeDimensions(\n                       \"Conv3DBackpropFilterOp\", 3,\n                       input_shape, filter_shape, out_backprop_shape, stride_,\n                       padding_, data_format_, &dims));\n    Tensor* filter_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, filter_shape, &filter_backprop));\n    if (input_shape.num_elements() == 0) {\n      filter_backprop->template flat<T>().setZero();\n      return;\n    }\n    functor::CuboidConvolutionBackwardFilter<Device, T>()(\n        context->eigen_device<Device>(),\n        filter_backprop->tensor<T, 5>(),                 \n        input.tensor<T, 5>(),                            \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "static long compat_adpt_ioctl(struct file *file,\n\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct inode *inode;\n\tlong ret;\n\tinode = file_inode(file);\n\tmutex_lock(&adpt_mutex);\n\tswitch(cmd) {\n\t\tcase DPT_SIGNATURE:\n\t\tcase I2OUSRCMD:\n\t\tcase DPT_CTRLINFO:\n\t\tcase DPT_SYSINFO:\n\t\tcase DPT_BLINKLED:\n\t\tcase I2ORESETCMD:\n\t\tcase I2ORESCANCMD:\n\t\tcase (DPT_TARGET_BUSY & 0xFFFF):\n\t\tcase DPT_TARGET_BUSY:\n\t\t\tret = adpt_ioctl(inode, file, cmd, arg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret =  -ENOIOCTLCMD;\n\t}\n\tmutex_unlock(&adpt_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "R_API st64 r_buf_fread_at(RBuffer *b, ut64 addr, ut8 *buf, const char *fmt, int n) {\n\tr_return_val_if_fail (b && buf && fmt, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_fread (b, buf, fmt, n);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}", "target": 1}
{"code": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\treturn do_dentry_open(file, inode, NULL, cred);\n}", "target": 1}
{"code": "monitor_valid_hostbasedblob(u_char *data, u_int datalen, char *cuser,\n    char *chost)\n{\n\tBuffer b;\n\tchar *p;\n\tu_int len;\n\tint fail = 0;\n\tbuffer_init(&b);\n\tbuffer_append(&b, data, datalen);\n\tp = buffer_get_string(&b, &len);\n\tif ((session_id2 == NULL) ||\n\t    (len != session_id2_len) ||\n\t    (memcmp(p, session_id2, session_id2_len) != 0))\n\t\tfail++;\n\txfree(p);\n\tif (buffer_get_char(&b) != SSH2_MSG_USERAUTH_REQUEST)\n\t\tfail++;\n\tp = buffer_get_string(&b, NULL);\n\tif (strcmp(authctxt->user, p) != 0) {\n\t\tlogit(\"wrong user name passed to monitor: expected %s != %.100s\",\n\t\t    authctxt->user, p);\n\t\tfail++;\n\t}\n\txfree(p);\n\tbuffer_skip_string(&b);\t\n\tp = buffer_get_string(&b, NULL);\n\tif (strcmp(p, \"hostbased\") != 0)\n\t\tfail++;\n\txfree(p);\n\tbuffer_skip_string(&b);\t\n\tbuffer_skip_string(&b);\t\n\tp = buffer_get_string(&b, NULL);\n\tif (((len = strlen(p)) > 0) && p[len - 1] == '.')\n\t\tp[len - 1] = '\\0';\n\tif (strcmp(p, chost) != 0)\n\t\tfail++;\n\txfree(p);\n\tp = buffer_get_string(&b, NULL);\n\tif (strcmp(p, cuser) != 0)\n\t\tfail++;\n\txfree(p);\n\tif (buffer_len(&b) != 0)\n\t\tfail++;\n\tbuffer_free(&b);\n\treturn (fail == 0);\n}", "target": 0}
{"code": "TEST(Random, SecureFork) {\n  unsigned char buffer = 0;\n  folly::Random::secureRandom(&buffer, 1);\n  auto pid = fork();\n  EXPECT_NE(pid, -1);\n  if (pid) {\n    int status = 0;\n    folly::Random::secureRandom(&buffer, 1);\n    auto pid2 = wait(&status);\n    EXPECT_NE(WEXITSTATUS(status), buffer);\n    EXPECT_EQ(pid, pid2);\n  } else {\n    folly::Random::secureRandom(&buffer, 1);\n    exit(buffer); \n  }\n}", "target": 0}
{"code": "  Status BuildFeatureReaders(const OpInputList& ragged_values_list,\n                             const OpInputList& ragged_splits_list,\n                             const OpInputList& sparse_indices_list,\n                             const OpInputList& sparse_values_list,\n                             const OpInputList& dense_list, int64 batch_size,\n                             FeatureReaders* features) {\n    features->reserve(input_order_.size());\n    int next_ragged = 0;\n    int next_sparse = 0;\n    int next_dense = 0;\n    for (char c : input_order_) {\n      if (c == 'R') {\n        if (next_ragged >= ragged_values_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a ragged tensor value at index \",\n              next_ragged, \" from a list of \", ragged_values_list.size(),\n              \" values.\");\n        if (next_ragged >= ragged_splits_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a ragged tensor split at index \",\n              next_ragged, \" from a list of \", ragged_splits_list.size(),\n              \" splits.\");\n        TF_RETURN_IF_ERROR(BuildRaggedFeatureReader(\n            ragged_values_list[next_ragged], ragged_splits_list[next_ragged],\n            features));\n        next_ragged++;\n      } else if (c == 'S') {\n        if (next_sparse >= sparse_values_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a sparse tensor value at index \",\n              next_sparse, \" from a list of \", sparse_values_list.size(),\n              \" values.\");\n        if (next_sparse >= sparse_indices_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a sparse tensor index at index \",\n              next_sparse, \" from a list of \", sparse_indices_list.size(),\n              \" indices.\");\n        TF_RETURN_IF_ERROR(BuildSparseFeatureReader(\n            sparse_indices_list[next_sparse], sparse_values_list[next_sparse],\n            batch_size, features));\n        next_sparse++;\n      } else if (c == 'D') {\n        if (next_dense >= dense_list.size())\n          return errors::InvalidArgument(\n              \"input_order \\\"\", input_order_,\n              \"\\\" specifies reading a dense tensor at index \", next_dense,\n              \" from a list of \", dense_list.size(), \" tensors.\");\n        TF_RETURN_IF_ERROR(\n            BuildDenseFeatureReader(dense_list[next_dense++], features));\n      } else {\n        return errors::InvalidArgument(\"Unexpected input_order value.\");\n      }\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "R_API bool r_sys_mkdirp(const char *dir) {\n\tbool ret = true;\n\tchar slash = R_SYS_DIR[0];\n\tchar *path = strdup (dir), *ptr = path;\n\tif (!path) {\n\t\teprintf (\"r_sys_mkdirp: Unable to allocate memory\\n\");\n\t\treturn false;\n\t}\n\tif (*ptr == slash) {\n\t\tptr++;\n\t}\n#if __WINDOWS__\n\t{\n\t\tchar *p = strstr (ptr, \":\\\\\");\n\t\tif (p) {\n\t\t\tptr = p + 2;\n\t\t}\n\t}\n#endif\n\tfor (;;) {\n\t\tfor (; *ptr; ptr++) {\n\t\t\tif (*ptr == '/' || *ptr == '\\\\') {\n\t\t\t\tslash = *ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!*ptr) {\n\t\t\tbreak;\n\t\t}\n\t\t*ptr = 0;\n\t\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\t\teprintf (\"r_sys_mkdirp: fail '%s' of '%s'\\n\", path, dir);\n\t\t\tfree (path);\n\t\t\treturn false;\n\t\t}\n\t\t*ptr = slash;\n\t\tptr++;\n\t}\n\tif (!r_sys_mkdir (path) && r_sys_mkdir_failed ()) {\n\t\tret = false;\n\t}\n\tfree (path);\n\treturn ret;\n}", "target": 1}
{"code": "PHP_FUNCTION(snmp2_set)\n{\n\tphp_snmp(INTERNAL_FUNCTION_PARAM_PASSTHRU, SNMP_CMD_SET, SNMP_VERSION_2c);\n}", "target": 0}
{"code": "decode_definite_long_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL, *chunk = NULL, *string = NULL;\n    Py_ssize_t left = length;\n    Py_ssize_t consumed;\n    Py_ssize_t buffer_size = 0;  \n    Py_ssize_t buffer_length = 0;  \n    char *buffer = NULL;\n    while (left) {\n        Py_ssize_t chunk_length = 65536 - buffer_size;\n        if (left < chunk_length)\n            chunk_length = left;\n        PyObject *chunk = fp_read_object(self, chunk_length);\n        left -= chunk_length;\n        if (!chunk)\n            goto error;\n        char *bytes_buffer = PyBytes_AsString(chunk);\n        if (!bytes_buffer)\n            goto error;\n        char *source_buffer;\n        if (buffer) {\n            if (buffer_length + chunk_length > buffer_size) {\n                buffer_size = buffer_length + chunk_length;\n                char *new_buffer = PyMem_Realloc(buffer, buffer_size);\n                if (!new_buffer)\n                    goto error;\n                buffer = new_buffer;\n            }\n            memcpy(buffer + buffer_length, bytes_buffer, chunk_length);\n            buffer_length += chunk_length;\n            source_buffer = buffer;\n            chunk_length = buffer_length;\n        } else {\n            source_buffer = bytes_buffer;\n        }\n        string = PyUnicode_DecodeUTF8Stateful(source_buffer, chunk_length, NULL, &consumed);\n        if (!string)\n            goto error;\n        if (ret) {\n            PyObject *joined = PyUnicode_Concat(ret, string);\n            if (!joined)\n                goto error;\n            Py_DECREF(string);\n            string = NULL;\n            ret = joined;\n        } else {\n            ret = string;\n        }\n        Py_ssize_t unconsumed = chunk_length - consumed;\n        if (consumed != chunk_length) {\n            if (buffer) {\n                memmove(buffer, buffer + consumed, unconsumed);\n            } else {\n                buffer = PyMem_Malloc(unconsumed);\n                if (!buffer)\n                    goto error;\n                memcpy(buffer, bytes_buffer + consumed, unconsumed);\n            }\n            buffer_length = unconsumed;\n        }\n    }\n    if (ret && string_namespace_add(self, ret, length) == -1)\n        goto error;\n    return ret;\nerror:\n    Py_XDECREF(ret);\n    Py_XDECREF(chunk);\n    Py_XDECREF(string);\n    if (buffer)\n        PyMem_Free(buffer);\n    return NULL;\n}", "target": 0}
{"code": "int LibRaw::dcraw_thumb_writer(const char *fname)\n{\n  if(!fname) \n    return ENOENT;\n  FILE *tfp = fopen(fname,\"wb\");\n  if(!tfp) \n    return errno;\n  if(!T.thumb)\n    {\n      fclose(tfp);\n      return LIBRAW_OUT_OF_ORDER_CALL;\n    }\n  try {\n    switch (T.tformat)\n      {\n      case LIBRAW_THUMBNAIL_JPEG:\n        jpeg_thumb_writer (tfp,T.thumb,T.tlength);\n        break;\n      case LIBRAW_THUMBNAIL_BITMAP:\n        fprintf (tfp, \"P6\\n%d %d\\n255\\n\", T.twidth, T.theight);\n        fwrite (T.thumb, 1, T.tlength, tfp);\n        break;\n      default:\n        fclose(tfp);\n        return LIBRAW_UNSUPPORTED_THUMBNAIL;\n      }\n    fclose(tfp);\n    return 0;\n  }\n  catch ( LibRaw_exceptions err) {\n    fclose(tfp);\n    EXCEPTION_HANDLER(err);\n  }\n}", "target": 0}
{"code": "static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tint ret;\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tlong newbufsize;\n\tlong newpos;\n\tassert(buf);\n\tassert(cnt >= 0);\n\tJAS_DBGLOG(100, (\"mem_write(%p, %p, %d)\\n\", obj, buf, cnt));\n\tnewpos = m->pos_ + cnt;\n\tif (newpos > m->bufsize_ && m->growable_) {\n\t\tnewbufsize = m->bufsize_;\n\t\twhile (newbufsize < newpos) {\n\t\t\tnewbufsize <<= 1;\n\t\t\tassert(newbufsize >= 0);\n\t\t}\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %z\\n\", m->bufsize_,\n\t\t  newbufsize));\n\t\tJAS_DBGLOG(100, (\"mem_write resizing from %d to %ul\\n\", m->bufsize_,\n\t\t  JAS_CAST(unsigned long, newbufsize)));\n\t\tif (mem_resize(m, newbufsize)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tn = JAS_MIN(m->pos_, m->bufsize_) - m->len_;\n\t\tif (n > 0) {\n\t\t\tmemset(&m->buf_[m->len_], 0, n);\n\t\t\tm->len_ += n;\n\t\t}\n\t\tif (m->pos_ != m->len_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\tn = m->bufsize_ - m->pos_;\n\tret = JAS_MIN(n, cnt);\n\tif (ret > 0) {\n\t\tmemcpy(&m->buf_[m->pos_], buf, ret);\n\t\tm->pos_ += ret;\n\t}\n\tif (m->pos_ > m->len_) {\n\t\tm->len_ = m->pos_;\n\t}\n\tassert(ret == cnt);\n\treturn ret;\n}", "target": 1}
{"code": "static void freeInstParams (AFPVu *values, int fileFormat)\n{\n\tint\ti;\n\tint\tparameterCount = _af_units[fileFormat].instrumentParameterCount;\n\tfor (i=0; i<parameterCount; i++)\n\t{\n\t\tif (_af_units[fileFormat].instrumentParameters[i].type == AU_PVTYPE_PTR)\n\t\t\tif (values[i].v != NULL)\n\t\t\t\tfree(values[i].v);\n\t}\n\tfree(values);\n}", "target": 0}
{"code": "static int do_devinfo_ioctl(struct comedi_device *dev,\n\t\t\t    struct comedi_devinfo __user *arg,\n\t\t\t    struct file *file)\n{\n\tstruct comedi_devinfo devinfo;\n\tconst unsigned minor = iminor(file->f_dentry->d_inode);\n\tstruct comedi_device_file_info *dev_file_info =\n\t    comedi_get_device_file_info(minor);\n\tstruct comedi_subdevice *read_subdev =\n\t    comedi_get_read_subdevice(dev_file_info);\n\tstruct comedi_subdevice *write_subdev =\n\t    comedi_get_write_subdevice(dev_file_info);\n\tmemset(&devinfo, 0, sizeof(devinfo));\n\tdevinfo.version_code = COMEDI_VERSION_CODE;\n\tdevinfo.n_subdevs = dev->n_subdevices;\n\tmemcpy(devinfo.driver_name, dev->driver->driver_name, COMEDI_NAMELEN);\n\tmemcpy(devinfo.board_name, dev->board_name, COMEDI_NAMELEN);\n\tif (read_subdev)\n\t\tdevinfo.read_subdevice = read_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.read_subdevice = -1;\n\tif (write_subdev)\n\t\tdevinfo.write_subdevice = write_subdev - dev->subdevices;\n\telse\n\t\tdevinfo.write_subdevice = -1;\n\tif (copy_to_user(arg, &devinfo, sizeof(struct comedi_devinfo)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "TEE_Result syscall_cryp_obj_populate(unsigned long obj,\n\t\t\tstruct utee_attribute *usr_attrs,\n\t\t\tunsigned long attr_count)\n{\n\tTEE_Result res;\n\tstruct tee_ta_session *sess;\n\tstruct tee_obj *o;\n\tconst struct tee_cryp_obj_type_props *type_props;\n\tTEE_Attribute *attrs = NULL;\n\tres = tee_ta_get_current_session(&sess);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tres = tee_obj_get(to_user_ta_ctx(sess->ctx),\n\t\t\t  tee_svc_uref_to_vaddr(obj), &o);\n\tif (res != TEE_SUCCESS)\n\t\treturn res;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_PERSISTENT) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\tif ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) != 0)\n\t\treturn TEE_ERROR_BAD_PARAMETERS;\n\ttype_props = tee_svc_find_type_props(o->info.objectType);\n\tif (!type_props)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tattrs = malloc(sizeof(TEE_Attribute) * attr_count);\n\tif (!attrs)\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tres = copy_in_attrs(to_user_ta_ctx(sess->ctx), usr_attrs, attr_count,\n\t\t\t    attrs);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,\n\t\t\t\t      attrs, attr_count);\n\tif (res != TEE_SUCCESS)\n\t\tgoto out;\n\tres = tee_svc_cryp_obj_populate_type(o, type_props, attrs, attr_count);\n\tif (res == TEE_SUCCESS)\n\t\to->info.handleFlags |= TEE_HANDLE_FLAG_INITIALIZED;\nout:\n\tfree(attrs);\n\treturn res;\n}", "target": 1}
{"code": "static int l2tp_ip6_recvmsg(struct kiocb *iocb, struct sock *sk,\n\t\t\t    struct msghdr *msg, size_t len, int noblock,\n\t\t\t    int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)msg->msg_name;\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sk_buff *skb;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\tif (addr_len)\n\t\t*addr_len = sizeof(*lsa);\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_timestamp(msg, sk, skb);\n\tif (lsa) {\n\t\tlsa->l2tp_family = AF_INET6;\n\t\tlsa->l2tp_unused = 0;\n\t\tlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\n\t\tlsa->l2tp_flowinfo = 0;\n\t\tlsa->l2tp_scope_id = 0;\n\t\tlsa->l2tp_conn_id = 0;\n\t\tif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tlsa->l2tp_scope_id = IP6CB(skb)->iif;\n\t}\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\treturn err ? err : copied;\n}", "target": 0}
{"code": "get_word_gray_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  ppm_source_ptr source = (ppm_source_ptr)sinfo;\n  register JSAMPROW ptr;\n  register U_CHAR *bufferptr;\n  register JSAMPLE *rescale = source->rescale;\n  JDIMENSION col;\n  unsigned int maxval = source->maxval;\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}", "target": 1}
{"code": "void client_reset(t_client *client)\n{\n\tchar *hash;\n\tchar *msg;\n\tchar *cidinfo;\n\tdebug(LOG_DEBUG, \"Resetting client [%s]\", client->mac);\n\tclient->counters.incoming = 0;\n\tclient->counters.outgoing = 0;\n\tclient->counters.last_updated = time(NULL);\n\tclient->session_start = 0;\n\tclient->session_end = 0;\n\thash = safe_calloc(STATUS_BUF);\n\tclient->token = safe_calloc(STATUS_BUF);\n\tsafe_snprintf(client->token, STATUS_BUF, \"%04hx%04hx\", rand16(), rand16());\n\thash_str(hash, STATUS_BUF, client->token);\n\tclient->hid = safe_strdup(hash);\n\tfree(hash);\n\tclient->custom = safe_calloc(MID_BUF);\n\tclient->client_type = safe_calloc(STATUS_BUF);\n\tif (client->cid) {\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t\tclient->cid = safe_calloc(SMALL_BUF);\n\t}\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match(spec, *s)) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "static bool vtable_is_addr_vtable_start_msvc(RVTableContext *context, ut64 curAddress) {\n\tRAnalRef *xref;\n\tRListIter *xrefIter;\n\tif (!curAddress || curAddress == UT64_MAX) {\n\t\treturn false;\n\t}\n\tif (curAddress && !vtable_is_value_in_text_section (context, curAddress, NULL)) {\n\t\treturn false;\n\t}\n\tRList *xrefs = r_anal_xrefs_get (context->anal, curAddress);\n\tif (r_list_empty (xrefs)) {\n\t\tr_list_free (xrefs);\n\t\treturn false;\n\t}\n\tr_list_foreach (xrefs, xrefIter, xref) {\n\t\tif (vtable_addr_in_text_section (context, xref->addr)) {\n\t\t\tut8 buf[VTABLE_BUFF_SIZE];\n\t\t\tcontext->anal->iob.read_at (context->anal->iob.io, xref->addr, buf, sizeof(buf));\n\t\t\tRAnalOp analop = {0};\n\t\t\tr_anal_op (context->anal, &analop, xref->addr, buf, sizeof(buf), R_ANAL_OP_MASK_BASIC);\n\t\t\tif (analop.type == R_ANAL_OP_TYPE_MOV\n\t\t\t\t|| analop.type == R_ANAL_OP_TYPE_LEA) {\n\t\t\t\tr_list_free (xrefs);\n\t\t\t\tr_anal_op_fini (&analop);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_anal_op_fini (&analop);\n\t\t}\n\t}\n\tr_list_free (xrefs);\n\treturn false;\n}", "target": 1}
{"code": "njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array)\n{\n    uint32_t           i, length;\n    njs_value_t        index, value;\n    njs_object_prop_t  *prop;\n    if (njs_slow_path(!array->object.fast_array)) {\n        return NJS_OK;\n    }\n    njs_set_array(&value, array);\n    array->object.fast_array = 0;\n    length = array->length;\n    for (i = 0; i < length; i++) {\n        if (njs_is_valid(&array->start[i])) {\n            njs_uint32_to_string(&index, i);\n            prop = njs_object_property_add(vm, &value, &index, 0);\n            if (njs_slow_path(prop == NULL)) {\n                return NJS_ERROR;\n            }\n            prop->value = array->start[i];\n        }\n    }\n    njs_mp_free(vm->mem_pool, array->start);\n    array->start = NULL;\n    return NJS_OK;\n}", "target": 0}
{"code": "static u64 gen_hi_max(struct tnum var)\n{\n\treturn (var.value | var.mask) & ~0xffffffffULL;\n}", "target": 0}
{"code": "static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\tif (!(rcv->flags & IFF_UP))\n\t\tgoto tx_drop;\n\tif (dev->features & NETIF_F_NO_CSUM)\n\t\tskb->ip_summed = rcv_priv->ip_summed;\n\tlength = skb->len + ETH_HLEN;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\treturn NETDEV_TX_OK;\ntx_drop:\n\tkfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\nrx_drop:\n\tkfree_skb(skb);\n\trcv_stats->rx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "win_enter(win_T *wp, int undo_sync)\n{\n    win_enter_ext(wp, undo_sync, FALSE, FALSE, TRUE, TRUE);\n}", "target": 0}
{"code": "static int htc_config_pipe_credits(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_config_pipe_msg *cp_msg;\n\tint ret;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcp_msg = skb_put(skb, sizeof(struct htc_config_pipe_msg));\n\tcp_msg->message_id = cpu_to_be16(HTC_MSG_CONFIG_PIPE_ID);\n\tcp_msg->pipe_id = USB_WLAN_TX_PIPE;\n\tcp_msg->credits = target->credits;\n\ttarget->htc_flags |= HTC_OP_CONFIG_PIPE_CREDITS;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC credit config timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "extract_auth_val(char **q)\n{\n    unsigned char *qq = *(unsigned char **)q;\n    int quoted = 0;\n    Str val = Strnew();\n    SKIP_BLANKS(qq);\n    if (*qq == '\"') {\n\tquoted = TRUE;\n\tStrcat_char(val, *qq++);\n    }\n    while (*qq != '\\0') {\n\tif (quoted && *qq == '\"') {\n\t    Strcat_char(val, *qq++);\n\t    break;\n\t}\n\tif (!quoted) {\n\t    switch (*qq) {\n\t    case '[':\n\t    case ']':\n\t    case '(':\n\t    case ')':\n\t    case '<':\n\t    case '>':\n\t    case '@':\n\t    case ';':\n\t    case ':':\n\t    case '\\\\':\n\t    case '\"':\n\t    case '/':\n\t    case '?':\n\t    case '=':\n\t    case ' ':\n\t    case '\\t':\n\t\tqq++;\n\t    case ',':\n\t\tgoto end_token;\n\t    default:\n\t\tif (*qq <= 037 || *qq == 0177) {\n\t\t    qq++;\n\t\t    goto end_token;\n\t\t}\n\t    }\n\t}\n\telse if (quoted && *qq == '\\\\')\n\t    Strcat_char(val, *qq++);\n\tStrcat_char(val, *qq++);\n    }\n  end_token:\n    *q = (char *)qq;\n    return val;\n}", "target": 0}
{"code": "deltas_head_cleanup(struct deltas_head *list)\n{\n\tsize_t i;\n\tfor (i = 0; i < list->capacity; i++)\n\t\tdelta_head_destroy(list->array[i]);\n\tif (list->array)\n\t\tfree(list->array);\n}", "target": 1}
{"code": "static void check_file(char *basename)\n{\n    gdImagePtr im;\n    char *buffer;\n    size_t size;\n    size = read_test_file(&buffer, basename);\n    im = gdImageCreateFromTiffPtr(size, (void *) buffer);\n    gdTestAssert(im == NULL);\n    free(buffer);\n}", "target": 0}
{"code": "static void JS_FoxxAllowInstallFromRemote(\n    v8::FunctionCallbackInfo<v8::Value> const& args) {\n  TRI_V8_TRY_CATCH_BEGIN(isolate)\n  v8::HandleScope scope(isolate);\n  TRI_GET_GLOBALS();\n  ServerSecurityFeature& security =\n      v8g->_server.getFeature<ServerSecurityFeature>();\n  TRI_V8_RETURN_BOOL(security.foxxAllowInstallFromRemote());\n  TRI_V8_TRY_CATCH_END\n}", "target": 0}
{"code": "void IndexedDBDatabase::DeleteDatabase(\n    scoped_refptr<IndexedDBCallbacks> callbacks,\n    bool force_close) {\n  AppendRequest(std::make_unique<DeleteRequest>(this, callbacks));\n  if (force_close)\n    ForceClose();\n}", "target": 0}
{"code": "cmnd_matches_all(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    const bool negated = m->negated;\n    struct sudo_command *c;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(cmnd_matches_all, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (matched != UNSPEC) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static int cp2112_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tint ret;\n\tmutex_lock(&dev->lock);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_CONFIG_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tbuf[1] &= ~(1 << offset);\n\tbuf[2] = gpio_push_pull;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_CONFIG, buf,\n\t\t\t\t CP2112_GPIO_CONFIG_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0) {\n\t\thid_err(hdev, \"error setting GPIO config: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tret = 0;\nexit:\n\tmutex_unlock(&dev->lock);\n\treturn ret < 0 ? ret : -EIO;\n}", "target": 0}
{"code": "http_dissect_hdrs(struct worker *w, struct http *hp, int fd, char *p,\n    const struct http_conn *htc)\n{\n\tchar *q, *r;\n\ttxt t = htc->rxbuf;\n\tif (*p == '\\r')\n\t\tp++;\n\thp->nhd = HTTP_HDR_FIRST;\n\thp->conds = 0;\n\tr = NULL;\t\t\n\tfor (; p < t.e; p = r) {\n\t\tq = r = p;\n\t\twhile (r < t.e) {\n\t\t\tif (!vct_iscrlf(*r)) {\n\t\t\t\tr++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tq = r;\n\t\t\tassert(r < t.e);\n\t\t\tr += vct_skipcrlf(r);\n\t\t\tif (r >= t.e)\n\t\t\t\tbreak;\n\t\t\tif (!vct_issp(*r))\n\t\t\t\tbreak;\n\t\t\twhile (vct_islws(*q))\n\t\t\t\t*q++ = ' ';\n\t\t}\n\t\tif (q - p > htc->maxhdr) {\n\t\t\tVSC_C_main->losthdr++;\n\t\t\tWSL(w, SLT_LostHeader, fd, \"%.*s\",\n\t\t\t    q - p > 20 ? 20 : q - p, p);\n\t\t\treturn (413);\n\t\t}\n\t\tif (p == q)\n\t\t\tbreak;\n\t\tif ((p[0] == 'i' || p[0] == 'I') &&\n\t\t    (p[1] == 'f' || p[1] == 'F') &&\n\t\t    p[2] == '-')\n\t\t\thp->conds = 1;\n\t\twhile (q > p && vct_issp(q[-1]))\n\t\t\tq--;\n\t\t*q = '\\0';\n\t\tif (hp->nhd < hp->shd) {\n\t\t\thp->hdf[hp->nhd] = 0;\n\t\t\thp->hd[hp->nhd].b = p;\n\t\t\thp->hd[hp->nhd].e = q;\n\t\t\tWSLH(w, fd, hp, hp->nhd);\n\t\t\thp->nhd++;\n\t\t} else {\n\t\t\tVSC_C_main->losthdr++;\n\t\t\tWSL(w, SLT_LostHeader, fd, \"%.*s\",\n\t\t\t    q - p > 20 ? 20 : q - p, p);\n\t\t\treturn (413);\n\t\t}\n\t}\n\treturn (0);\n}", "target": 1}
{"code": "static Jsi_RC StringSearchCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    int sLen, bLen;\n    const char *source_str;\n    ChkString(_this, funcPtr, source_str, &sLen, &bLen);\n    char *v = _this->d.obj->d.s.str;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, skip);\n    if (Jsi_ValueIsString(interp, seq)) {\n        char *ce, *cp = Jsi_ValueString(interp, seq, NULL);\n        int n = -1;\n        if ((ce = Jsi_Strstr(source_str, cp))) {\n            n = (ce-source_str);\n        }\n        Jsi_ValueMakeNumber(interp, ret, n);\n        return JSI_OK;\n    }\n    if (!seq || seq->vt != JSI_VT_OBJECT || seq->d.obj->ot != JSI_OT_REGEXP) {\n        Jsi_ValueMakeNumber(interp, ret, -1);\n        return JSI_OK;\n    }\n    regex_t *reg = &seq->d.obj->d.robj->reg;\n    regmatch_t pos[MAX_SUBREGEX] = {};\n    int r;\n    if ((r = regexec(reg, v, MAX_SUBREGEX, pos, 0)) != 0) {\n        if (r == REG_NOMATCH) {\n            Jsi_ValueMakeNumber(interp, ret, -1.0);\n            return JSI_OK;\n        }\n        if (r >= REG_BADPAT) {\n            char buf[100];\n            regerror(r, reg, buf, sizeof(buf));\n            Jsi_LogError(\"error while matching pattern: %s\", buf);\n            return JSI_ERROR;\n        }\n    }\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)pos[0].rm_so);\n    return JSI_OK;\n}", "target": 1}
{"code": "static int rose_parse_ccitt(unsigned char *p, struct rose_facilities_struct *facilities, int len)\n{\n\tunsigned char l, n = 0;\n\tchar callsign[11];\n\tdo {\n\t\tswitch (*p & 0xC0) {\n\t\tcase 0x00:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tp   += 2;\n\t\t\tn   += 2;\n\t\t\tlen -= 2;\n\t\t\tbreak;\n\t\tcase 0x40:\n\t\t\tif (len < 3)\n\t\t\t\treturn -1;\n\t\t\tp   += 3;\n\t\t\tn   += 3;\n\t\t\tlen -= 3;\n\t\t\tbreak;\n\t\tcase 0x80:\n\t\t\tif (len < 4)\n\t\t\t\treturn -1;\n\t\t\tp   += 4;\n\t\t\tn   += 4;\n\t\t\tlen -= 4;\n\t\t\tbreak;\n\t\tcase 0xC0:\n\t\t\tif (len < 2)\n\t\t\t\treturn -1;\n\t\t\tl = p[1];\n\t\t\tif (l < 10 || l > 20)\n\t\t\t\treturn -1;\n\t\t\tif (*p == FAC_CCITT_DEST_NSAP) {\n\t\t\t\tmemcpy(&facilities->source_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12,   l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->source_call, callsign);\n\t\t\t}\n\t\t\tif (*p == FAC_CCITT_SRC_NSAP) {\n\t\t\t\tmemcpy(&facilities->dest_addr, p + 7, ROSE_ADDR_LEN);\n\t\t\t\tmemcpy(callsign, p + 12, l - 10);\n\t\t\t\tcallsign[l - 10] = '\\0';\n\t\t\t\tasc2ax(&facilities->dest_call, callsign);\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\treturn n;\n}", "target": 0}
{"code": "static void rb_inc_iter(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tif (iter->head_page == cpu_buffer->reader_page)\n\t\titer->head_page = rb_set_head_page(cpu_buffer);\n\telse\n\t\trb_inc_page(&iter->head_page);\n\titer->page_stamp = iter->read_stamp = iter->head_page->page->time_stamp;\n\titer->head = 0;\n\titer->next_event = 0;\n}", "target": 0}
{"code": "void sctp_generate_proto_unreach_event(unsigned long data)\n{\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->proto_unreach_timer,\n\t\t\t\tjiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\tsctp_do_sm(net, SCTP_EVENT_T_OTHER,\n\t\t   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),\n\t\t   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\tkey = key_ref_to_ptr(key_ref);\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error;\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\ncan_read_key:\n\tret = key_validate(key);\n\tif (ret == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tif (key->type->read) {\n\t\t\tdown_read(&key->sem);\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\t\tup_read(&key->sem);\n\t\t}\n\t}\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static struct nfc_llcp_local *nfc_llcp_remove_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local, *tmp;\n\tspin_lock(&llcp_devices_lock);\n\tlist_for_each_entry_safe(local, tmp, &llcp_devices, list)\n\t\tif (local->dev == dev) {\n\t\t\tlist_del(&local->list);\n\t\t\tspin_unlock(&llcp_devices_lock);\n\t\t\treturn local;\n\t\t}\n\tspin_unlock(&llcp_devices_lock);\n\tpr_warn(\"Shutting down device not found\\n\");\n\treturn NULL;\n}", "target": 0}
{"code": "init_device (u2fh_devs * devs, struct u2fdevice *dev)\n{\n  unsigned char resp[1024];\n  unsigned char nonce[8];\n  if (obtain_nonce(nonce) != 0)\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  size_t resplen = sizeof (resp);\n  dev->cid = CID_BROADCAST;\n  if (u2fh_sendrecv\n      (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp,\n       &resplen) == U2FH_OK)\n    {\n      U2FHID_INIT_RESP initresp;\n      if (resplen > sizeof (initresp))\n\t{\n\t  return U2FH_MEMORY_ERROR;\n\t}\n      memcpy (&initresp, resp, resplen);\n      dev->cid = initresp.cid;\n      dev->versionInterface = initresp.versionInterface;\n      dev->versionMajor = initresp.versionMajor;\n      dev->versionMinor = initresp.versionMinor;\n      dev->capFlags = initresp.capFlags;\n    }\n  else\n    {\n      return U2FH_TRANSPORT_ERROR;\n    }\n  return U2FH_OK;\n}", "target": 1}
{"code": "static int count_leading_dotdots(const char *url, const char **out)\n{\n\tint result = 0;\n\twhile (1) {\n\t\tif (starts_with_dot_dot_slash(url)) {\n\t\t\tresult++;\n\t\t\turl += strlen(\"../\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (starts_with_dot_slash(url)) {\n\t\t\turl += strlen(\"./\");\n\t\t\tcontinue;\n\t\t}\n\t\t*out = url;\n\t\treturn result;\n\t}\n}", "target": 0}
{"code": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\tusb_msg.dlc = cf->len;\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\treturn NETDEV_TX_OK;\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\treturn NETDEV_TX_OK;\n}", "target": 1}
{"code": "Status SparseCountSparseOutputShapeFn(InferenceContext *c) {\n  ShapeHandle unused;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &unused));\n  auto rank = c->Dim(c->input(0), 1);\n  auto nvals = c->UnknownDim();\n  c->set_output(0, c->Matrix(nvals, rank));  \n  c->set_output(1, c->Vector(nvals));        \n  c->set_output(2, c->Vector(rank));         \n  return Status::OK();\n}", "target": 0}
{"code": "int inet6_csk_xmit(struct sock *sk, struct sk_buff *skb, struct flowi *fl_unused)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint res;\n\tdst = inet6_csk_route_socket(sk, &fl6);\n\tif (IS_ERR(dst)) {\n\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\tsk->sk_route_caps = 0;\n\t\tkfree_skb(skb);\n\t\treturn PTR_ERR(dst);\n\t}\n\trcu_read_lock();\n\tskb_dst_set_noref(skb, dst);\n\tfl6.daddr = sk->sk_v6_daddr;\n\tres = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\trcu_read_unlock();\n\treturn res;\n}", "target": 1}
{"code": "static BOOL update_gdi_cache_bitmap_v2(rdpContext* context, CACHE_BITMAP_V2_ORDER* cacheBitmapV2)\n{\n\trdpBitmap* bitmap;\n\trdpBitmap* prevBitmap;\n\trdpCache* cache = context->cache;\n\trdpSettings* settings = context->settings;\n\tbitmap = Bitmap_Alloc(context);\n\tif (!bitmap)\n\t\treturn FALSE;\n\tif (!cacheBitmapV2->bitmapBpp)\n\t\tcacheBitmapV2->bitmapBpp = settings->ColorDepth;\n\tif ((settings->ColorDepth == 15) && (cacheBitmapV2->bitmapBpp == 16))\n\t\tcacheBitmapV2->bitmapBpp = settings->ColorDepth;\n\tBitmap_SetDimensions(bitmap, cacheBitmapV2->bitmapWidth, cacheBitmapV2->bitmapHeight);\n\tif (!bitmap->Decompress(context, bitmap, cacheBitmapV2->bitmapDataStream,\n\t                        cacheBitmapV2->bitmapWidth, cacheBitmapV2->bitmapHeight,\n\t                        cacheBitmapV2->bitmapBpp, cacheBitmapV2->bitmapLength,\n\t                        cacheBitmapV2->compressed, RDP_CODEC_ID_NONE))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\tprevBitmap = bitmap_cache_get(cache->bitmap, cacheBitmapV2->cacheId, cacheBitmapV2->cacheIndex);\n\tif (!bitmap->New(context, bitmap))\n\t{\n\t\tBitmap_Free(context, bitmap);\n\t\treturn FALSE;\n\t}\n\tBitmap_Free(context, prevBitmap);\n\treturn bitmap_cache_put(cache->bitmap, cacheBitmapV2->cacheId, cacheBitmapV2->cacheIndex,\n\t                        bitmap);\n}", "target": 0}
{"code": "TEST_F(ExprMatchTest, AndNestedWithinOrMatchesCorrectly) {\n    createMatcher(fromjson(\n        \"{$expr: {$or: [{$and: [{$eq: ['$x', 3]}, {$gt: ['$z', 5]}]}, {$lt: ['$y', 4]}]}}\"));\n    ASSERT_TRUE(matches(BSON(\"x\" << 3 << \"z\" << 7)));\n    ASSERT_TRUE(matches(BSON(\"y\" << 1)));\n    ASSERT_FALSE(matches(BSON(\"y\" << 5)));\n}", "target": 0}
{"code": "static int open_handlers(void)\n{\n\tstruct dirent **dirent_list;\n\tint num_handlers;\n\tint num_good = 0;\n\tint i;\n\tnum_handlers = scandir(handler_path, &dirent_list, is_handler, alphasort);\n\tif (num_handlers == -1)\n\t\treturn -1;\n\tfor (i = 0; i < num_handlers; i++) {\n\t\tchar *path;\n\t\tvoid *handle;\n\t\tint (*handler_init)(void);\n\t\tint ret;\n\t\tret = asprintf(&path, \"%s/%s\", handler_path, dirent_list[i]->d_name);\n\t\tif (ret == -1) {\n\t\t\ttcmu_err(\"ENOMEM\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\thandle = dlopen(path, RTLD_NOW|RTLD_LOCAL);\n\t\tif (!handle) {\n\t\t\ttcmu_err(\"Could not open handler at %s: %s\\n\", path, dlerror());\n\t\t\tfree(path);\n\t\t\tcontinue;\n\t\t}\n\t\thandler_init = dlsym(handle, \"handler_init\");\n\t\tif (!handler_init) {\n\t\t\ttcmu_err(\"dlsym failure on %s\\n\", path);\n\t\t\tfree(path);\n\t\t\tcontinue;\n\t\t}\n\t\tret = handler_init();\n\t\tfree(path);\n\t\tif (ret == 0)\n\t\t\tnum_good++;\n\t}\n\tfor (i = 0; i < num_handlers; i++)\n\t\tfree(dirent_list[i]);\n\tfree(dirent_list);\n\treturn num_good;\n}", "target": 0}
{"code": "GF_Err chnl_box_size(GF_Box *s)\n{\n\tGF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s;\n\ts->size += 1;\n\tif (ptr->layout.stream_structure & 1) {\n\t\ts->size += 1;\n\t\tif (ptr->layout.definedLayout==0) {\n\t\t\tu32 i;\n\t\t\tfor (i=0; i<ptr->layout.channels_count; i++) {\n\t\t\t\ts->size+=1;\n\t\t\t\tif (ptr->layout.layouts[i].position==126)\n\t\t\t\t\ts->size+=3;\n\t\t\t}\n\t\t} else {\n\t\t\ts->size += 8;\n\t\t}\n\t}\n\tif (ptr->layout.stream_structure & 2) {\n\t\ts->size += 1;\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "static void read_buf(FILE *fin, char *buf) {\n  if (!fgets(buf, BUFFER_SIZE, fin)) {\n    buf[0] = '\\0';\n    return;\n  }\n  buf[strlen(buf) - 1] = '\\0';\n}", "target": 1}
{"code": "int main()\n{\n    check_file(\"tiff_invalid_read_1.tiff\");\n    check_file(\"tiff_invalid_read_2.tiff\");\n    check_file(\"tiff_invalid_read_3.tiff\");\n    return gdNumFailures();\n}", "target": 0}
{"code": "void Item_direct_view_ref::update_used_tables()\n{\n  set_null_ref_table();\n  Item_direct_ref::update_used_tables();\n}", "target": 0}
{"code": "  UTF16Ref getUTF16Ref(llvh::SmallVectorImpl<char16_t> &allocator) const {\n    assert(allocator.empty() && \"Shouldn't use a non-empty allocator\");\n    return getUTF16Ref(allocator, false);\n  }", "target": 0}
{"code": "void RenderView::OnSetDOMUIProperty(const std::string& name,\n                                    const std::string& value) {\n  DCHECK(BindingsPolicy::is_dom_ui_enabled(enabled_bindings_));\n  dom_ui_bindings_.SetProperty(name, value);\n}", "target": 0}
{"code": "void LinkResolver::check_field_loader_constraints(Symbol* field, Symbol* sig,\n                                                  Klass* current_klass,\n                                                  Klass* sel_klass, TRAPS) {\n  Handle ref_loader(THREAD, current_klass->class_loader());\n  Handle sel_loader(THREAD, sel_klass->class_loader());\n  ResourceMark rm(THREAD);  \n  Symbol* failed_type_symbol =\n    SystemDictionary::check_signature_loaders(sig,\n                                              ref_loader, sel_loader,\n                                              false,\n                                              CHECK);\n  if (failed_type_symbol != NULL) {\n    stringStream ss;\n    const char* failed_type_name = failed_type_symbol->as_klass_external_name();\n    ss.print(\"loader constraint violation: when resolving field\"\n             \" \\\"%s\\\" of type %s, the class loader %s of the current class, \"\n             \"%s, and the class loader %s for the field's defining \"\n             \"type, %s, have different Class objects for type %s (%s; %s)\",\n             field->as_C_string(),\n             failed_type_name,\n             current_klass->class_loader_data()->loader_name_and_id(),\n             current_klass->external_name(),\n             sel_klass->class_loader_data()->loader_name_and_id(),\n             sel_klass->external_name(),\n             failed_type_name,\n             current_klass->class_in_module_of_loader(false, true),\n             sel_klass->class_in_module_of_loader(false, true));\n    THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n  }\n}", "target": 0}
{"code": "static bool open_match_attributes(connection_struct *conn,\n\t\t\t\t  uint32 old_dos_attr,\n\t\t\t\t  uint32 new_dos_attr,\n\t\t\t\t  mode_t existing_unx_mode,\n\t\t\t\t  mode_t new_unx_mode,\n\t\t\t\t  mode_t *returned_unx_mode)\n{\n\tuint32 noarch_old_dos_attr, noarch_new_dos_attr;\n\tnoarch_old_dos_attr = (old_dos_attr & ~FILE_ATTRIBUTE_ARCHIVE);\n\tnoarch_new_dos_attr = (new_dos_attr & ~FILE_ATTRIBUTE_ARCHIVE);\n\tif((noarch_old_dos_attr == 0 && noarch_new_dos_attr != 0) || \n\t   (noarch_old_dos_attr != 0 && ((noarch_old_dos_attr & noarch_new_dos_attr) == noarch_old_dos_attr))) {\n\t\t*returned_unx_mode = new_unx_mode;\n\t} else {\n\t\t*returned_unx_mode = (mode_t)0;\n\t}\n\tDEBUG(10,(\"open_match_attributes: old_dos_attr = 0x%x, \"\n\t\t  \"existing_unx_mode = 0%o, new_dos_attr = 0x%x \"\n\t\t  \"returned_unx_mode = 0%o\\n\",\n\t\t  (unsigned int)old_dos_attr,\n\t\t  (unsigned int)existing_unx_mode,\n\t\t  (unsigned int)new_dos_attr,\n\t\t  (unsigned int)*returned_unx_mode ));\n\tif (lp_map_system(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {\n\t\tif ((old_dos_attr & FILE_ATTRIBUTE_SYSTEM) &&\n\t\t    !(new_dos_attr & FILE_ATTRIBUTE_SYSTEM)) {\n\t\t\treturn False;\n\t\t}\n\t}\n\tif (lp_map_hidden(SNUM(conn)) || lp_store_dos_attributes(SNUM(conn))) {\n\t\tif ((old_dos_attr & FILE_ATTRIBUTE_HIDDEN) &&\n\t\t    !(new_dos_attr & FILE_ATTRIBUTE_HIDDEN)) {\n\t\t\treturn False;\n\t\t}\n\t}\n\treturn True;\n}", "target": 0}
{"code": "err_t verify_signed_hash(const struct RSA_public_key *k\n                         , u_char *s, unsigned int s_max_octets\n                         , u_char **psig\n                         , size_t hash_len\n                         , const u_char *sig_val, size_t sig_len)\n{\n    unsigned int padlen;\n    {\n\tchunk_t temp_s;\n\tMP_INT c;\n\tn_to_mpz(&c, sig_val, sig_len);\n\toswcrypto.mod_exp(&c, &c, &k->e, &k->n);\n\ttemp_s = mpz_to_n(&c, sig_len);\t\n        if(s_max_octets < sig_len) {\n            return \"2\"\"exponentiation failed; too many octets\";\n        }\n\tmemcpy(s, temp_s.ptr, sig_len);\n\tpfree(temp_s.ptr);\n\tmpz_clear(&c);\n    }\n    padlen = sig_len - 3 - hash_len;\n    DBG(DBG_CRYPT,\n\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n    s += padlen + 3;\n    (*psig) = s;\n    return NULL;\n}", "target": 1}
{"code": "static int adpt_slave_configure(struct scsi_device * device)\n{\n\tstruct Scsi_Host *host = device->host;\n\tif (host->can_queue && device->tagged_supported) {\n\t\tscsi_change_queue_depth(device,\n\t\t\t\thost->can_queue - 1);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "unsigned long _copy_from_user(void *to, const void __user *from, unsigned long n)\n{\n\tunsigned long res = n;\n\tmight_fault();\n\tif (!should_fail_usercopy() && likely(access_ok(from, n))) {\n\t\tbarrier_nospec();\n\t\tinstrument_copy_from_user_before(to, from, n);\n\t\tres = raw_copy_from_user(to, from, n);\n\t\tinstrument_copy_from_user_after(to, from, n, res);\n\t}\n\tif (unlikely(res))\n\t\tmemset(to + (n - res), 0, res);\n\treturn res;\n}", "target": 0}
{"code": "static void rpc_init_task(struct rpc_task *task, const struct rpc_task_setup *task_setup_data)\n{\n\tmemset(task, 0, sizeof(*task));\n\tatomic_set(&task->tk_count, 1);\n\ttask->tk_flags  = task_setup_data->flags;\n\ttask->tk_ops = task_setup_data->callback_ops;\n\ttask->tk_calldata = task_setup_data->callback_data;\n\tINIT_LIST_HEAD(&task->tk_task);\n\ttask->tk_garb_retry = 2;\n\ttask->tk_cred_retry = 2;\n\ttask->tk_rebind_retry = 2;\n\ttask->tk_priority = task_setup_data->priority - RPC_PRIORITY_LOW;\n\ttask->tk_owner = current->tgid;\n\ttask->tk_workqueue = task_setup_data->workqueue;\n\tif (task->tk_ops->rpc_call_prepare != NULL)\n\t\ttask->tk_action = rpc_prepare_task;\n\ttask->tk_start = ktime_get();\n\tdprintk(\"RPC:       new task initialized, procpid %u\\n\",\n\t\t\t\ttask_pid_nr(current));\n}", "target": 0}
{"code": "namespace{void nop(){}}", "target": 0}
{"code": "    const std::unordered_map<std::string, Cookie> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "static bool max_queue_pairs_gt_1(void *opaque, int version_id)\n{\n    return VIRTIO_NET(opaque)->max_queue_pairs > 1;\n}", "target": 0}
{"code": "bool PrintWebViewHelper::InitPrintSettingsAndPrepareFrame(\n    WebKit::WebFrame* frame, const WebKit::WebNode& node,\n    scoped_ptr<PrepareFrameAndViewForPrint>* prepare) {\n  if (!InitPrintSettings(frame, node))\n    return false;\n  DCHECK(!prepare->get());\n  prepare->reset(new PrepareFrameAndViewForPrint(print_pages_params_->params,\n                                                 frame, node));\n  UpdatePrintableSizeInPrintParameters(frame, node, prepare->get(),\n                                       &print_pages_params_->params);\n  Send(new PrintHostMsg_DidGetDocumentCookie(\n        routing_id(), print_pages_params_->params.document_cookie));\n  return true;\n}", "target": 0}
{"code": "name_len(netdissect_options *ndo,\n         const unsigned char *s, const unsigned char *maxbuf)\n{\n    const unsigned char *s0 = s;\n    unsigned char c;\n    if (s >= maxbuf)\n\treturn(-1);\t\n    ND_TCHECK2(*s, 1);\n    c = *s;\n    if ((c & 0xC0) == 0xC0)\n\treturn(2);\n    while (*s) {\n\tif (s >= maxbuf)\n\t    return(-1);\t\n\tND_TCHECK2(*s, 1);\n\ts += (*s) + 1;\n\tND_TCHECK2(*s, 1);\n    }\n    return(PTR_DIFF(s, s0) + 1);\ntrunc:\n    return(-1);\t\n}", "target": 0}
{"code": "static void* my_gballoc_calloc(size_t nmemb, size_t size)\n{\n    return calloc(nmemb, size);\n}", "target": 0}
{"code": "void HTMLMediaElement::SetSrc(const USVStringOrTrustedURL& stringOrURL,\n                              ExceptionState& exception_state) {\n  setAttribute(kSrcAttr, stringOrURL, exception_state);\n}", "target": 0}
{"code": "  void writeSuccess() noexcept override {}", "target": 0}
{"code": "static void test_on_link_state_changed(void* context, LINK_STATE new_link_state, LINK_STATE previous_link_state)\n{\n    (void)context;\n    test_on_link_state_changed_new_link_state = new_link_state;\n    test_on_link_state_changed_previous_link_state = previous_link_state;\n}", "target": 0}
{"code": "static int hmac_create(struct crypto_template *tmpl, struct rtattr **tb)\n{\n\tstruct shash_instance *inst;\n\tstruct crypto_alg *alg;\n\tstruct shash_alg *salg;\n\tint err;\n\tint ds;\n\tint ss;\n\terr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\n\tif (err)\n\t\treturn err;\n\tsalg = shash_attr_alg(tb[1], 0, 0);\n\tif (IS_ERR(salg))\n\t\treturn PTR_ERR(salg);\n\terr = -EINVAL;\n\tds = salg->digestsize;\n\tss = salg->statesize;\n\talg = &salg->base;\n\tif (ds > alg->cra_blocksize ||\n\t    ss < alg->cra_blocksize)\n\t\tgoto out_put_alg;\n\tinst = shash_alloc_instance(\"hmac\", alg);\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\terr = crypto_init_shash_spawn(shash_instance_ctx(inst), salg,\n\t\t\t\t      shash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\tinst->alg.base.cra_priority = alg->cra_priority;\n\tinst->alg.base.cra_blocksize = alg->cra_blocksize;\n\tinst->alg.base.cra_alignmask = alg->cra_alignmask;\n\tss = ALIGN(ss, alg->cra_alignmask + 1);\n\tinst->alg.digestsize = ds;\n\tinst->alg.statesize = ss;\n\tinst->alg.base.cra_ctxsize = sizeof(struct hmac_ctx) +\n\t\t\t\t     ALIGN(ss * 2, crypto_tfm_ctx_alignment());\n\tinst->alg.base.cra_init = hmac_init_tfm;\n\tinst->alg.base.cra_exit = hmac_exit_tfm;\n\tinst->alg.init = hmac_init;\n\tinst->alg.update = hmac_update;\n\tinst->alg.final = hmac_final;\n\tinst->alg.finup = hmac_finup;\n\tinst->alg.export = hmac_export;\n\tinst->alg.import = hmac_import;\n\tinst->alg.setkey = hmac_setkey;\n\terr = shash_register_instance(tmpl, inst);\n\tif (err) {\nout_free_inst:\n\t\tshash_free_instance(shash_crypto_instance(inst));\n\t}\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1}
{"code": "int mlx4_register_vlan(struct mlx4_dev *dev, u8 port, u16 vlan, int *index)\n{\n\tstruct mlx4_vlan_table *table = &mlx4_priv(dev)->port[port].vlan_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmutex_lock(&table->mutex);\n\tfor (i = MLX4_VLAN_REGULAR; i < MLX4_MAX_VLAN_NUM; i++) {\n\t\tif (free < 0 && (table->refs[i] == 0)) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (table->refs[i] &&\n\t\t    (vlan == (MLX4_VLAN_MASK &\n\t\t\t      be32_to_cpu(table->entries[i])))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be32(vlan | MLX4_VLAN_VALID);\n\terr = mlx4_set_port_vlan_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_warn(dev, \"Failed adding vlan: %u\\n\", vlan);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "OPJ_BOOL opj_j2k_encoding_validation (  opj_j2k_t * p_j2k,\n                                                                            opj_stream_private_t *p_stream,\n                                                                            opj_event_mgr_t * p_manager )\n{\n        OPJ_BOOL l_is_valid = OPJ_TRUE;\n        assert(p_j2k != 00);\n        assert(p_stream != 00);\n        assert(p_manager != 00);\n        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NONE);\n        l_is_valid &= (p_j2k->m_procedure_list != 00);\n        l_is_valid &= (p_j2k->m_validation_list != 00);\n        if ((p_j2k->m_cp.tcps->tccps->numresolutions <= 0) || (p_j2k->m_cp.tcps->tccps->numresolutions > 32)) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n        if ((p_j2k->m_cp.tdx) < (OPJ_UINT32) (1 << (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n        if ((p_j2k->m_cp.tdy) < (OPJ_UINT32) (1 << (p_j2k->m_cp.tcps->tccps->numresolutions - 1U))) {\n                opj_event_msg(p_manager, EVT_ERROR, \"Number of resolutions is too high in comparison to the size of tiles\\n\");\n                return OPJ_FALSE;\n        }\n        return l_is_valid;\n}", "target": 0}
{"code": "  bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) override {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "struct blk_mq_tags *blk_mq_init_tags(unsigned int total_tags,\n\t\t\t\t     unsigned int reserved_tags,\n\t\t\t\t     int node, int alloc_policy)\n{\n\tstruct blk_mq_tags *tags;\n\tif (total_tags > BLK_MQ_TAG_MAX) {\n\t\tpr_err(\"blk-mq: tag depth too large\\n\");\n\t\treturn NULL;\n\t}\n\ttags = kzalloc_node(sizeof(*tags), GFP_KERNEL, node);\n\tif (!tags)\n\t\treturn NULL;\n\tif (!zalloc_cpumask_var(&tags->cpumask, GFP_KERNEL)) {\n\t\tkfree(tags);\n\t\treturn NULL;\n\t}\n\ttags->nr_tags = total_tags;\n\ttags->nr_reserved_tags = reserved_tags;\n\treturn blk_mq_init_bitmap_tags(tags, node, alloc_policy);\n}", "target": 0}
{"code": "static bool download_and_write(SPDBDownloaderOpt *opt, const char *file) {\n\tchar *dir = r_str_newf (\"%s%s%s%s%s\",\n\t\topt->symbol_store_path, R_SYS_DIR,\n\t\topt->dbg_file, R_SYS_DIR,\n\t\topt->guid);\n\tif (!r_sys_mkdirp (dir)) {\n\t\tfree (dir);\n\t\treturn false;\n\t}\n\tchar *url = r_str_newf (\"%s/%s/%s/%s\", opt->symbol_server, opt->dbg_file, opt->guid, file);\n\tint len;\n\tchar *file_buf = r_socket_http_get (url, NULL, &len);\n\tfree (url);\n\tif (!len || R_STR_ISEMPTY (file_buf)) {\n\t\tfree (dir);\n\t\tfree (file_buf);\n\t\treturn false;\n\t}\n\tchar *path = r_str_newf (\"%s%s%s\", dir, R_SYS_DIR, opt->dbg_file);\n\tFILE *f = fopen (path, \"wb\");\n\tif (f) {\n\t\tfwrite (file_buf, sizeof (char), (size_t)len, f);\n\t\tfclose (f);\n\t}\n\tfree (dir);\n\tfree (path);\n\tfree (file_buf);\n\treturn true;\n}", "target": 0}
{"code": "bool HTMLTextAreaElement::hasCustomFocusLogic() const\n{\n    return true;\n}", "target": 0}
{"code": "uint64_t siphash(const uint8_t *in, const size_t inlen, const uint8_t *k) {\n    uint64_t hash;\n    uint8_t *out = (uint8_t*) &hash;\n    uint64_t v0 = 0x736f6d6570736575ULL;\n    uint64_t v1 = 0x646f72616e646f6dULL;\n    uint64_t v2 = 0x6c7967656e657261ULL;\n    uint64_t v3 = 0x7465646279746573ULL;\n    uint64_t k0 = U8TO64_LE(k);\n    uint64_t k1 = U8TO64_LE(k + 8);\n    uint64_t m;\n    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));\n    const int left = inlen & 7;\n    uint64_t b = ((uint64_t)inlen) << 56;\n    v3 ^= k1;\n    v2 ^= k0;\n    v1 ^= k1;\n    v0 ^= k0;\n    for (; in != end; in += 8) {\n        m = U8TO64_LE(in);\n        v3 ^= m;\n        SIPROUND;\n        SIPROUND;\n        v0 ^= m;\n    }\n    switch (left) {\n    case 7: b |= ((uint64_t)in[6]) << 48;\n    case 6: b |= ((uint64_t)in[5]) << 40;\n    case 5: b |= ((uint64_t)in[4]) << 32;\n    case 4: b |= ((uint64_t)in[3]) << 24;\n    case 3: b |= ((uint64_t)in[2]) << 16;\n    case 2: b |= ((uint64_t)in[1]) << 8;\n    case 1: b |= ((uint64_t)in[0]); break;\n    case 0: break;\n    }\n    v3 ^= b;\n    SIPROUND;\n    SIPROUND;\n    v0 ^= b;\n    v2 ^= 0xff;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    b = v0 ^ v1 ^ v2 ^ v3;\n    U64TO8_LE(out, b);\n    return hash;\n}", "target": 0}
{"code": "uint32_t virtio_config_readl(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint32_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = ldl_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR2(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t\tint ret, int err, int len)\n{\n    unsigned long ssl_err = err;\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n    SSLLogErrors(action, ret, err, len, ssock);\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}", "target": 1}
{"code": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\tassert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}", "target": 1}
{"code": "PHPAPI zend_string *php_escape_shell_cmd(char *str)\n{\n\tregister int x, y, l = (int)strlen(str);\n\tsize_t estimate = (2 * l) + 1;\n\tzend_string *cmd;\n#ifndef PHP_WIN32\n\tchar *p = NULL;\n#endif\n\tcmd = zend_string_alloc(2 * l, 0);\n\tfor (x = 0, y = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifndef PHP_WIN32\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n\t\t\t\tif (!p && (p = memchr(str + x + 1, str[x], l - x - 1))) {\n\t\t\t\t} else if (p && *p == str[x]) {\n\t\t\t\t\tp = NULL;\n\t\t\t\t} else {\n\t\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\t\t}\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t\t\tbreak;\n#else\n\t\t\tcase '%':\n\t\t\tcase '!':\n\t\t\tcase '\"':\n\t\t\tcase '\\'':\n#endif\n\t\t\tcase '#': \n\t\t\tcase '&':\n\t\t\tcase ';':\n\t\t\tcase '`':\n\t\t\tcase '|':\n\t\t\tcase '*':\n\t\t\tcase '?':\n\t\t\tcase '~':\n\t\t\tcase '<':\n\t\t\tcase '>':\n\t\t\tcase '^':\n\t\t\tcase '(':\n\t\t\tcase ')':\n\t\t\tcase '[':\n\t\t\tcase ']':\n\t\t\tcase '{':\n\t\t\tcase '}':\n\t\t\tcase '$':\n\t\t\tcase '\\\\':\n\t\t\tcase '\\x0A': \n\t\t\tcase '\\xFF':\n#ifdef PHP_WIN32\n\t\t\t\tZSTR_VAL(cmd)[y++] = '^';\n#else\n\t\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n#endif\n\t\t\tdefault:\n\t\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y] = '\\0';\n\tif ((estimate - y) > 4096) {\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}", "target": 1}
{"code": "flatpak_escape_string (const char        *s,\n                       FlatpakEscapeFlags flags)\n{\n  g_autoptr(GString) res = g_string_new (\"\");\n  gboolean did_escape = FALSE;\n  while (*s)\n    {\n      gunichar c = g_utf8_get_char_validated (s, -1);\n      if (c == (gunichar)-2 || c == (gunichar)-1)\n        {\n          append_hex_escaped_character (res, (unsigned char)*s++);\n          did_escape = TRUE;\n          continue;\n        }\n      else if (should_hex_escape (c, flags))\n        {\n          append_hex_escaped_character (res, c);\n          did_escape = TRUE;\n        }\n      else if (c == '\\\\' || (!(flags & FLATPAK_ESCAPE_DO_NOT_QUOTE) && c == '\\''))\n        {\n          g_string_append_printf (res, \"\\\\%c\", (char) c);\n          did_escape = TRUE;\n        }\n      else\n        g_string_append_unichar (res, c);\n      s = g_utf8_find_next_char (s, NULL);\n    }\n  if (did_escape && !(flags & FLATPAK_ESCAPE_DO_NOT_QUOTE))\n    {\n      g_string_prepend_c (res, '\\'');\n      g_string_append_c (res, '\\'');\n    }\n  return g_string_free (g_steal_pointer (&res), FALSE);\n}", "target": 0}
{"code": "static char* getPreferredTag(const char* gf_tag)\n{ \n\tchar* result = NULL;\n\tint grOffset = 0;\n\tgrOffset = findOffset( LOC_GRANDFATHERED ,gf_tag);\n\tif(grOffset < 0) {\n\t\treturn NULL;\n\t}\n\tif( grOffset < LOC_PREFERRED_GRANDFATHERED_LEN ){\n\t\tresult = estrdup( LOC_PREFERRED_GRANDFATHERED[grOffset] );\n\t} else {\n\t\tresult = estrdup( LOC_GRANDFATHERED[grOffset] );\n\t}\n\treturn result;\n}", "target": 1}
{"code": "Tss2_RC_Decode(TSS2_RC rc)\n{\n    static __thread char buf[TSS2_ERR_LAYER_NAME_MAX + TSS2_ERR_LAYER_ERROR_STR_MAX + 1];\n    clearbuf(buf);\n    UINT8 layer = tss2_rc_layer_number_get(rc);\n    TSS2_RC_HANDLER handler = layer_handler[layer].handler;\n    const char *lname = layer_handler[layer].name;\n    if (lname[0]) {\n        catbuf(buf, \"%s:\", lname);\n    } else {\n        catbuf(buf, \"%u:\", layer);\n    }\n    handler = !handler ? unknown_layer_handler : handler;\n    UINT16 err_bits = tpm2_error_get(rc);\n    const char *e = err_bits ? handler(err_bits) : \"success\";\n    if (e) {\n        catbuf(buf, \"%s\", e);\n    } else {\n        catbuf(buf, \"0x%X\", err_bits);\n    }\n    return buf;\n}", "target": 1}
{"code": "void test_rename(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\tif (rename(path, tmpname) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rename of %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static void test_map_big_memory(void)\n{\n    uc_engine *uc;\n    OK(uc_open(UC_ARCH_X86, UC_MODE_64, &uc));\n    uc_assert_err(UC_ERR_NOMEM,\n                  uc_mem_map(uc, 0x0, 0xfffffffffffff000, UC_PROT_ALL));\n    OK(uc_close(uc));\n}", "target": 0}
{"code": "static RzList *classes_from_symbols(RzBinFile *bf) {\n\tRzBinSymbol *sym;\n\tRzListIter *iter;\n\trz_list_foreach (bf->o->symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchar *dn = sym->dname;\n\t\t\tchar *fn = swiftField(dn, cn);\n\t\t\tif (fn) {\n\t\t\t\tRzBinField *f = rz_bin_field_new(sym->paddr, sym->vaddr, sym->size, fn, NULL, NULL, false);\n\t\t\t\trz_list_append(c->fields, f);\n\t\t\t\tfree(fn);\n\t\t\t} else {\n\t\t\t\tchar *mn = strstr(dn, \"..\");\n\t\t\t\tif (!mn) {\n\t\t\t\t\tmn = strstr(dn, cn);\n\t\t\t\t\tif (mn && mn[strlen(cn)] == '.') {\n\t\t\t\t\t\trz_list_append(c->methods, sym);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn bf->o->classes;\n}", "target": 1}
{"code": "int pico_tcp_initconn(struct pico_socket *s)\n{\n    struct pico_socket_tcp *ts = TCP_SOCK(s);\n    struct pico_frame *syn;\n    struct pico_tcp_hdr *hdr;\n    uint16_t mtu, opt_len = tcp_options_size(ts, PICO_TCP_SYN);\n    syn = s->net->alloc(s->stack, s->net, NULL, (uint16_t)(PICO_SIZE_TCPHDR + opt_len));\n    if (!syn)\n        return -1;\n    hdr = (struct pico_tcp_hdr *) syn->transport_hdr;\n    if (!ts->snd_nxt)\n        ts->snd_nxt = long_be(pico_paws());\n    ts->snd_last = ts->snd_nxt;\n    ts->cwnd = PICO_TCP_IW;\n    mtu = (uint16_t)pico_socket_get_mss(s);\n    ts->mss = (uint16_t)(mtu - PICO_SIZE_TCPHDR);\n    ts->ssthresh = (uint16_t)((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss) -  (((uint16_t)(PICO_DEFAULT_SOCKETQ / ts->mss)) >> 3u));\n    syn->sock = s;\n    hdr->seq = long_be(ts->snd_nxt);\n    hdr->len = (uint8_t)((PICO_SIZE_TCPHDR + opt_len) << 2);\n    hdr->flags = PICO_TCP_SYN;\n    tcp_set_space(ts);\n    hdr->rwnd = short_be(ts->wnd);\n    tcp_add_options(ts, syn, PICO_TCP_SYN, opt_len);\n    hdr->trans.sport = ts->sock.local_port;\n    hdr->trans.dport = ts->sock.remote_port;\n    hdr->crc = 0;\n    hdr->crc = short_be(pico_tcp_checksum(syn));\n    tcp_dbg(\"Sending SYN... (ports: %d - %d) size: %d\\n\", short_be(ts->sock.local_port), short_be(ts->sock.remote_port), syn->buffer_len);\n    ts->retrans_tmr = pico_timer_add(s->stack, PICO_TCP_SYN_TO << ts->backoff, initconn_retry, ts);\n    if (!ts->retrans_tmr) {\n        tcp_dbg(\"TCP: Failed to start initconn_retry timer\\n\");\n        PICO_FREE(syn);\n        return -1;\n    }\n    pico_enqueue(&s->stack->q_tcp.out, syn);\n    return 0;\n}", "target": 1}
{"code": "static void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\tif (is_long_mode(&vmx->vcpu)) {\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_CSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\t\tif (index >= 0 && vmx->rdtscp_enabled)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif ((index >= 0) && (vmx->vcpu.arch.efer & EFER_SCE))\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tvmx->save_nmsrs = save_nmsrs;\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(&vmx->vcpu);\n}", "target": 0}
{"code": "    void cleanup() { delete m_server; }", "target": 0}
{"code": "MONGO_EXPORT bson_bool_t mongo_cmd_authenticate( mongo *conn, const char *db, const char *user, const char *pass ) {\n    bson from_db;\n    bson cmd;\n    const char *nonce;\n    int result;\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    char hex_digest[33];\n    if( mongo_simple_int_command( conn, db, \"getnonce\", 1, &from_db ) == MONGO_OK ) {\n        bson_iterator it;\n        bson_find( &it, &from_db, \"nonce\" );\n        nonce = bson_iterator_string( &it );\n    }\n    else {\n        return MONGO_ERROR;\n    }\n    mongo_pass_digest( user, pass, hex_digest );\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )nonce, strlen( nonce ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )hex_digest, 32 );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n    bson_init( &cmd );\n    bson_append_int( &cmd, \"authenticate\", 1 );\n    bson_append_string( &cmd, \"user\", user );\n    bson_append_string( &cmd, \"nonce\", nonce );\n    bson_append_string( &cmd, \"key\", hex_digest );\n    bson_finish( &cmd );\n    bson_destroy( &from_db );\n    result = mongo_run_command( conn, db, &cmd, NULL );\n    bson_destroy( &cmd );\n    return result;\n}", "target": 1}
{"code": "GF_Err infe_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tchar *buf;\n\tu32 buf_len, i, string_len, string_start;\n\tGF_ItemInfoEntryBox *ptr = (GF_ItemInfoEntryBox *)s;\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tptr->item_ID = gf_bs_read_u16(bs);\n\tptr->item_protection_index = gf_bs_read_u16(bs);\n\tif (ptr->version == 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tptr->item_type = gf_bs_read_u32(bs);\n\t}\n\tbuf_len = (u32) (ptr->size);\n\tbuf = (char*)gf_malloc(buf_len);\n\tif (!buf) return GF_OUT_OF_MEM;\n\tif (buf_len != gf_bs_read_data(bs, buf, buf_len)) {\n\t\tgf_free(buf);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\tstring_len = 1;\n\tstring_start = 0;\n\tfor (i = 0; i < buf_len; i++) {\n\t\tif (buf[i] == 0) {\n\t\t\tif (!ptr->item_name) {\n\t\t\t\tptr->item_name = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->item_name) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->item_name, buf+string_start, string_len);\n\t\t\t} else if (!ptr->content_type) {\n\t\t\t\tptr->content_type = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_type) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_type, buf+string_start, string_len);\n\t\t\t} else {\n\t\t\t\tptr->content_encoding = (char*)gf_malloc(sizeof(char)*string_len);\n\t\t\t\tif (!ptr->content_encoding) return GF_OUT_OF_MEM;\n\t\t\t\tmemcpy(ptr->content_encoding, buf+string_start, string_len);\n\t\t\t}\n\t\t\tstring_start += string_len;\n\t\t\tstring_len = 0;\n\t\t\tif (ptr->content_encoding && ptr->version == 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tstring_len++;\n\t}\n\tgf_free(buf);\n\tif (!ptr->item_name || (!ptr->content_type && ptr->version < 2)) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isoff] Infe without name or content type !\\n\"));\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "int cg_write(const char *path, const char *buf, size_t size, off_t offset,\n\t     struct fuse_file_info *fi)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *localbuf = NULL;\n\tstruct cgfs_files *k = NULL;\n\tstruct file_info *f = (struct file_info *)fi->fh;\n\tbool r;\n\tif (f->type != LXC_TYPE_CGFILE) {\n\t\tfprintf(stderr, \"Internal error: directory cache info used in cg_write\\n\");\n\t\treturn -EIO;\n\t}\n\tif (offset)\n\t\treturn 0;\n\tif (!fc)\n\t\treturn -EIO;\n\tlocalbuf = alloca(size+1);\n\tlocalbuf[size] = '\\0';\n\tmemcpy(localbuf, buf, size);\n\tif ((k = cgfs_get_key(f->controller, f->cgroup, f->file)) == NULL) {\n\t\tsize = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\tif (!r)\n\t\tsize = -EINVAL;\nout:\n\tfree_key(k);\n\treturn size;\n}", "target": 1}
{"code": "snmp_process_data(void)\n{\n  static unsigned char packet[SNMP_MAX_PACKET_SIZE];\n  unsigned char *packet_end;\n  static uint32_t packet_len;\n  packet_end = packet + sizeof(packet) - 1;\n  packet_len = 0;\n  LOG_DBG(\"receiving UDP datagram from [\");\n  LOG_DBG_6ADDR(&UIP_IP_BUF->srcipaddr);\n  LOG_DBG_(\"]:%u\", uip_ntohs(UIP_UDP_BUF->srcport));\n  LOG_DBG_(\" Length: %u\\n\", uip_datalen());\n  if((packet_end = snmp_engine(uip_appdata, uip_datalen(), packet_end, &packet_len)) == NULL) {\n    LOG_DBG(\"Error while handling the request\\n\");\n  } else {\n    LOG_DBG(\"Sending response\\n\");\n    uip_udp_packet_sendto(snmp_udp_conn, packet_end, packet_len, &UIP_IP_BUF->srcipaddr, UIP_UDP_BUF->srcport);\n  }\n}", "target": 1}
{"code": "static void php_imagepolygon(INTERNAL_FUNCTION_PARAMETERS, int filled)\n{\n\tzval *IM, *POINTS;\n\tlong NPOINTS, COL;\n\tzval **var = NULL;\n\tgdImagePtr im;\n\tgdPointPtr points;\n\tint npoints, col, nelem, i;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rall\", &IM, &POINTS, &NPOINTS, &COL) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tnpoints = NPOINTS;\n\tcol = COL;\n\tnelem = zend_hash_num_elements(Z_ARRVAL_P(POINTS));\n\tif (nelem < 6) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must have at least 3 points in your array\");\n\t\tRETURN_FALSE;\n\t}\n\tif (npoints <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"You must give a positive number of points\");\n\t\tRETURN_FALSE;\n\t}\n\tif (nelem < npoints * 2) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Trying to use %d points in array with only %d points\", npoints, nelem/2);\n\t\tRETURN_FALSE;\n\t}\n\tpoints = (gdPointPtr) safe_emalloc(npoints, sizeof(gdPoint), 0);\n\tfor (i = 0; i < npoints; i++) {\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2), (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL((var));\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].x = Z_LVAL_PP(var);\n\t\t}\n\t\tif (zend_hash_index_find(Z_ARRVAL_P(POINTS), (i * 2) + 1, (void **) &var) == SUCCESS) {\n\t\t\tSEPARATE_ZVAL(var);\n\t\t\tconvert_to_long(*var);\n\t\t\tpoints[i].y = Z_LVAL_PP(var);\n\t\t}\n\t}\n\tif (filled) {\n\t\tgdImageFilledPolygon(im, points, npoints, col);\n\t} else {\n\t\tgdImagePolygon(im, points, npoints, col);\n\t}\n\tefree(points);\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "static void youngcollection (lua_State *L, global_State *g) {\n  GCObject **psurvival;  \n  lua_assert(g->gcstate == GCSpropagate);\n  markold(g, g->survival, g->reallyold);\n  markold(g, g->finobj, g->finobjrold);\n  atomic(L);\n  psurvival = sweepgen(L, g, &g->allgc, g->survival);\n  sweepgen(L, g, psurvival, g->reallyold);\n  g->reallyold = g->old;\n  g->old = *psurvival;  \n  g->survival = g->allgc;  \n  psurvival = sweepgen(L, g, &g->finobj, g->finobjsur);\n  sweepgen(L, g, psurvival, g->finobjrold);\n  g->finobjrold = g->finobjold;\n  g->finobjold = *psurvival;  \n  g->finobjsur = g->finobj;  \n  sweepgen(L, g, &g->tobefnz, NULL);\n  finishgencycle(L, g);\n}", "target": 1}
{"code": "    Status CmdAuthenticate::_authenticateX509(const UserName& user, const BSONObj& cmdObj) {\n        if (!getSSLManager()) {\n            return Status(ErrorCodes::ProtocolError,\n                          \"SSL support is required for the MONGODB-X509 mechanism.\");\n        }\n        if(user.getDB() != \"$external\") {\n            return Status(ErrorCodes::ProtocolError,\n                          \"X.509 authentication must always use the $external database.\");\n        }\n        ClientBasic *client = ClientBasic::getCurrent();\n        AuthorizationSession* authorizationSession = client->getAuthorizationSession();\n        std::string subjectName = client->port()->getX509SubjectName();\n        if (user.getUser() != subjectName) {\n            return Status(ErrorCodes::AuthenticationFailed,\n                          \"There is no x.509 client certificate matching the user.\");\n        }\n        else {\n            std::string srvSubjectName = getSSLManager()->getServerSubjectName();\n            std::string srvClusterId = srvSubjectName.substr(srvSubjectName.find(\",OU=\"));\n            std::string peerClusterId = subjectName.substr(subjectName.find(\",OU=\"));\n            fassert(17002, !srvClusterId.empty() && srvClusterId != srvSubjectName);\n            int clusterAuthMode = serverGlobalParams.clusterAuthMode.load(); \n            if (srvClusterId == peerClusterId) {\n                if (clusterAuthMode == ServerGlobalParams::ClusterAuthMode_undefined ||\n                    clusterAuthMode == ServerGlobalParams::ClusterAuthMode_keyFile) {\n                    return Status(ErrorCodes::AuthenticationFailed, \"The provided certificate \" \n                                  \"can only be used for cluster authentication, not client \" \n                                  \"authentication. The current configuration does not allow \" \n                                  \"x.509 cluster authentication, check the --clusterAuthMode flag\");\n                }\n                authorizationSession->grantInternalAuthorization();\n            }\n            else {\n                if (_isX509AuthDisabled) {\n                    return Status(ErrorCodes::BadValue,\n                                  _x509AuthenticationDisabledMessage);\n                }\n                Status status = authorizationSession->addAndAuthorizeUser(user);\n                if (!status.isOK()) {\n                    return status;\n                }\n            }\n            return Status::OK();\n        }\n    }", "target": 1}
{"code": "int lxc_safe_uint(const char *numstr, unsigned int *converted)\n{\n\tchar *err = NULL;\n\tunsigned long int uli;\n\twhile (isspace(*numstr))\n\t\tnumstr++;\n\tif (*numstr == '-')\n\t\treturn -EINVAL;\n\terrno = 0;\n\tuli = strtoul(numstr, &err, 0);\n\tif (errno == ERANGE && uli == ULONG_MAX)\n\t\treturn -ERANGE;\n\tif (err == numstr || *err != '\\0')\n\t\treturn -EINVAL;\n\tif (uli > UINT_MAX)\n\t\treturn -ERANGE;\n\t*converted = (unsigned int)uli;\n\treturn 0;\n}", "target": 0}
{"code": "code_to_mbclen(OnigCodePoint code, OnigEncoding enc ARG_UNUSED)\n{\n  if      ((code & 0xffffff80) == 0) return 1;\n  else if ((code & 0xfffff800) == 0) return 2;\n  else if ((code & 0xffff0000) == 0) return 3;\n  else if ((code & 0xffe00000) == 0) return 4;\n  else if ((code & 0xfc000000) == 0) return 5;\n  else if ((code & 0x80000000) == 0) return 6;\n#ifdef USE_INVALID_CODE_SCHEME\n  else if (code == INVALID_CODE_FE) return 1;\n  else if (code == INVALID_CODE_FF) return 1;\n#endif\n  else\n    return ONIGERR_TOO_BIG_WIDE_CHAR_VALUE;\n}", "target": 0}
{"code": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\treturn (attr->attrib_type);\n}", "target": 1}
{"code": "valid_ruser(const char *s)\n{\n\tsize_t i;\n\tif (*s == '-')\n\t\treturn 0;\n\tfor (i = 0; s[i] != 0; i++) {\n\t\tif (strchr(\"'`\\\";&<>|(){}\", s[i]) != NULL)\n\t\t\treturn 0;\n\t\tif (isspace((u_char)s[i]) && s[i + 1] == '-')\n\t\t\treturn 0;\n\t\tif (s[i] == '\\\\' && s[i + 1] == '\\0')\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int pagemap_open(struct inode *inode, struct file *file)\n{\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tpr_warn_once(\"Bits 55-60 of /proc/PID/pagemap entries are about \"\n\t\t\t\"to stop being page-shift some time soon. See the \"\n\t\t\t\"linux/Documentation/vm/pagemap.txt for details.\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "void mt_init(mtrand *mt, uint32_t seed) {\n  int i;\n  mt->mt_buffer_[0] = seed;\n  mt->mt_index_ = MT_LEN;\n  for (i = 1; i < MT_LEN; i++) {\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^ \n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}", "target": 1}
{"code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tmsg->msg_namelen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\treturn err;\n\t}\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0) {\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\t\tif (bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\telse\n\t\t\tmsg->msg_namelen = 0;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static inline unsigned long get_tpuser(void)\n{\n\tunsigned long reg = 0;\n\tif (has_tls_reg && !tls_emu)\n\t\t__asm__(\"mrc p15, 0, %0, c13, c0, 2\" : \"=r\" (reg));\n\treturn reg;\n}", "target": 0}
{"code": "static int check_func_proto(const struct bpf_func_proto *fn, int func_id)\n{\n\treturn check_raw_mode_ok(fn) &&\n\t       check_arg_pair_ok(fn) &&\n\t       check_btf_id_ok(fn) &&\n\t       check_refcount_ok(fn, func_id) ? 0 : -EINVAL;\n}", "target": 0}
{"code": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\tdvb_usbv2_exit(d);\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n}", "target": 1}
{"code": "void LosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE i;\n  for(i = 0;i < m_ucCount;i++) {\n    class HuffmanDecoder *dc = m_pDCDecoder[i];\n    struct Line *line = top[i];\n    struct Line *pline= prev[i];\n    UBYTE ym = m_ucMCUHeight[i];\n    class PredictorBase *mcupred = m_pPredict[i];\n    LONG *lp = line->m_pData + m_ulX[i];\n    LONG *pp = (pline)?(pline->m_pData + m_ulX[i]):(NULL);\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[i];\n      do {\n        LONG v;\n        UBYTE symbol = dc->Get(&m_Stream);\n        if (symbol == 0) {\n          v = 0;\n        } else if (symbol == 16) {\n          v = -32768;\n        } else if (symbol > 16) {\n          JPG_THROW(MALFORMED_STREAM,\"LosslessScan::ParseMCU\",\n                    \"received an out-of-bounds symbol in a lossless JPEG scan\");\n        } else {\n          LONG thre = 1L << (symbol - 1);\n          LONG diff = m_Stream.Get(symbol); \n          if (diff < thre) {\n            diff += (-1L << symbol) + 1;\n          }\n          v = diff;\n        }\n        lp[0] = pred->DecodeSample(v,lp,pp);\n      } while(--xm && (lp++,pp++,pred = pred->MoveRight(),true));\n    } while(--ym && (pp = line->m_pData + m_ulX[i],line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + m_ulX[i],mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}", "target": 0}
{"code": "static void __exit adpt_exit(void)\n{\n\tadpt_hba\t*pHba, *next;\n\tfor (pHba = hba_chain; pHba; pHba = next) {\n\t\tnext = pHba->next;\n\t\tadpt_release(pHba);\n\t}\n}", "target": 1}
{"code": "Item_func_ne::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                             uint *and_level, table_map usable_tables,\n                             SARGABLE_PARAM **sargables)\n{\n  if (!(used_tables() & OUTER_REF_TABLE_BIT))\n  {\n    if (is_local_field(args[0]) && !is_local_field(args[1]))\n      add_key_equal_fields(join, key_fields, *and_level, this,\n                           (Item_field*) (args[0]->real_item()), false,\n                           &args[1], 1, usable_tables, sargables);\n    if (is_local_field(args[1]) && !is_local_field(args[0]))\n      add_key_equal_fields(join, key_fields, *and_level, this,\n                           (Item_field*) (args[1]->real_item()), false,\n                           &args[0], 1, usable_tables, sargables);\n  }\n}", "target": 0}
{"code": "static int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\tu32 cpu_based_vm_exec_control;\n\tcpu_based_vm_exec_control = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tcpu_based_vm_exec_control &= ~CPU_BASED_VIRTUAL_INTR_PENDING;\n\tvmcs_write32(CPU_BASED_VM_EXEC_CONTROL, cpu_based_vm_exec_control);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t++vcpu->stat.irq_window_exits;\n\tif (!irqchip_in_kernel(vcpu->kvm) &&\n\t    vcpu->run->request_interrupt_window &&\n\t    !kvm_cpu_has_interrupt(vcpu)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_IRQ_WINDOW_OPEN;\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "INST_HANDLER (sbrx) {\t\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op;\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\top->cycles = 1;\t\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\n\t\t\t: \"!,!,\");\t\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t\n}", "target": 1}
{"code": "unsigned Cache::deadCapacity() const \n{\n    unsigned capacity = m_capacity - min(m_liveSize, m_capacity); \n    capacity = max(capacity, m_minDeadCapacity); \n    capacity = min(capacity, m_maxDeadCapacity); \n    return capacity;\n}", "target": 0}
{"code": "static bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64 to, const char *str) {\n\tif (to < from) {\n\t\treturn false;\n\t}\n\tRSpace *space = r_spaces_current (&a->meta_spaces);\n\tRIntervalNode *node = find_node_at (a, type, space, from);\n\tRAnalMetaItem *item = node ? node->data : R_NEW0 (RAnalMetaItem);\n\tif (!item) {\n\t\treturn false;\n\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\titem->str = str ? strdup (str) : NULL;\n\tif (str && !item->str) {\n\t\tif (!node) { \n\t\t\tfree (item);\n\t\t}\n\t\treturn false;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {\n\t\tr_interval_tree_resize (&a->meta, node, from, to);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "GF_Err gf_isom_get_fragmented_samples_info(GF_ISOFile *movie, GF_ISOTrackID trackID, u32 *nb_samples, u64 *duration)\n{\n\tu32 i=0;\n\tu32 k, l;\n\tGF_MovieFragmentBox *moof;\n\tGF_TrackFragmentBox *traf;\n\t*nb_samples = 0;\n\t*duration = 0;\n\twhile ((moof=(GF_MovieFragmentBox*)gf_list_enum(movie->TopBoxes, &i))) {\n\t\tu32 j=0;\n\t\tif (moof->type!=GF_ISOM_BOX_TYPE_MOOF) continue;\n\t\twhile ((traf=(GF_TrackFragmentBox*)gf_list_enum( moof->TrackList, &j))) {\n\t\t\tu64 def_duration, samp_dur=0;\n\t\t\tif (traf->tfhd->trackID != trackID)\n\t\t\t\tcontinue;\n\t\t\tdef_duration = 0;\n\t\t\tif (traf->tfhd->flags & GF_ISOM_TRAF_SAMPLE_DUR) def_duration = traf->tfhd->def_sample_duration;\n\t\t\telse if (traf->trex) def_duration = traf->trex->def_sample_duration;\n\t\t\tfor (k=0; k<gf_list_count(traf->TrackRuns); k++) {\n\t\t\t\tGF_TrackFragmentRunBox *trun = (GF_TrackFragmentRunBox*)gf_list_get(traf->TrackRuns, k);\n\t\t\t\t*nb_samples += trun->sample_count;\n\t\t\t\tfor (l=0; l<trun->nb_samples; l++) {\n\t\t\t\t\tGF_TrunEntry *ent = &trun->samples[l];\n\t\t\t\t\tsamp_dur = def_duration;\n\t\t\t\t\tif (trun->flags & GF_ISOM_TRUN_DURATION) samp_dur = ent->Duration;\n\t\t\t\t\tif (trun->nb_samples == trun->sample_count)\n\t\t\t\t\t\t*duration += samp_dur;\n\t\t\t\t}\n\t\t\t\tif (trun->nb_samples != trun->sample_count)\n\t\t\t\t\t*duration += samp_dur * trun->sample_count;\n\t\t\t}\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "SWTPM_NVRAM_CheckHeader(unsigned char *data, uint32_t length,\n                        uint32_t *dataoffset, uint16_t *hdrflags,\n                        uint8_t *hdrversion, bool quiet)\n{\n    blobheader *bh = (blobheader *)data;\n    if (length < sizeof(bh)) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"not enough bytes for header: %u\\n\", length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (ntohl(bh->totlen) != length) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"broken header: bh->totlen %u != %u\\n\",\n                      htonl(bh->totlen), length);\n        return TPM_BAD_PARAMETER;\n    }\n    if (bh->min_version > BLOB_HEADER_VERSION) {\n        if (!quiet)\n            logprintf(STDERR_FILENO,\n                      \"Minimum required version for the blob is %d, we \"\n                      \"only support version %d\\n\", bh->min_version,\n                      BLOB_HEADER_VERSION);\n        return TPM_BAD_VERSION;\n    }\n    *hdrversion = bh->version;\n    *dataoffset = ntohs(bh->hdrsize);\n    *hdrflags = ntohs(bh->flags);\n    return TPM_SUCCESS;\n}", "target": 1}
{"code": "generatePreview (const char inFileName[],\n\t\t float exposure,\n\t\t int previewWidth,\n\t\t int &previewHeight,\n\t\t Array2D <PreviewRgba> &previewPixels)\n{\n    RgbaInputFile in (inFileName);\n    Box2i dw = in.dataWindow();\n    float a = in.pixelAspectRatio();\n    int w = dw.max.x - dw.min.x + 1;\n    int h = dw.max.y - dw.min.y + 1;\n    Array2D <Rgba> pixels (h, w);\n    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n    float fx = (previewWidth  > 0)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\t    preview.r = gamma (pixel.r, m);\n\t    preview.g = gamma (pixel.g, m);\n\t    preview.b = gamma (pixel.b, m);\n\t    preview.a = int (IMATH_NAMESPACE::clamp (pixel.a * 255.f, 0.f, 255.f) + .5f);\n\t}\n    }\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n\tstruct nfs4_state *state = opendata->state;\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *delegation;\n\tint open_mode = opendata->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL);\n\tnfs4_stateid stateid;\n\tint ret = -EAGAIN;\n\tfor (;;) {\n\t\tif (can_open_cached(state, open_mode)) {\n\t\t\tspin_lock(&state->owner->so_lock);\n\t\t\tif (can_open_cached(state, open_mode)) {\n\t\t\t\tupdate_open_stateflags(state, open_mode);\n\t\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t\t\tgoto out_return_state;\n\t\t\t}\n\t\t\tspin_unlock(&state->owner->so_lock);\n\t\t}\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(nfsi->delegation);\n\t\tif (delegation == NULL ||\n\t\t    !can_open_delegated(delegation, open_mode)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(stateid.data, delegation->stateid.data, sizeof(stateid.data));\n\t\trcu_read_unlock();\n\t\tret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n\t\tif (ret != 0)\n\t\t\tgoto out;\n\t\tret = -EAGAIN;\n\t\tif (update_open_stateid(state, NULL, &stateid, open_mode))\n\t\t\tgoto out_return_state;\n\t}\nout:\n\treturn ERR_PTR(ret);\nout_return_state:\n\tatomic_inc(&state->count);\n\treturn state;\n}", "target": 1}
{"code": "pk_transaction_finished_emit (PkTransaction *transaction,\n\t\t\t      PkExitEnum exit_enum,\n\t\t\t      guint time_ms)\n{\n\tg_assert (!transaction->priv->emitted_finished);\n\ttransaction->priv->emitted_finished = TRUE;\n\tg_debug (\"emitting finished '%s', %i\",\n\t\t pk_exit_enum_to_string (exit_enum),\n\t\t time_ms);\n\tg_dbus_connection_emit_signal (transaction->priv->connection,\n\t\t\t\t       NULL,\n\t\t\t\t       transaction->priv->tid,\n\t\t\t\t       PK_DBUS_INTERFACE_TRANSACTION,\n\t\t\t\t       \"Finished\",\n\t\t\t\t       g_variant_new (\"(uu)\",\n\t\t\t\t\t\t      exit_enum,\n\t\t\t\t\t\t      time_ms),\n\t\t\t\t       NULL);\n\tg_signal_emit (transaction, signals[SIGNAL_FINISHED], 0);\n}", "target": 0}
{"code": "d_lite_amjd(VALUE self)\n{\n    get_d1(self);\n    return m_amjd(dat);\n}", "target": 0}
{"code": "void PrintWebViewHelper::PrintPreviewContext::InitWithNode(\n    const WebKit::WebNode& web_node) {\n  DCHECK(!web_node.isNull());\n  DCHECK(!IsRendering());\n  state_ = INITIALIZED;\n  frame_ = web_node.document().frame();\n  node_ = web_node;\n}", "target": 0}
{"code": "static int http_buf_read(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int len;\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }\n    return len;\n}", "target": 1}
{"code": "static int i8042_start(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = true;\n\tmb();\n\treturn 0;\n}", "target": 1}
{"code": "void HTMLTextAreaElement::setMaxLength(int newValue, ExceptionState& exceptionState)\n{\n    if (newValue < 0)\n        exceptionState.throwDOMException(IndexSizeError, \"The value provided (\" + String::number(newValue) + \") is not positive or 0.\");\n    else\n        setIntegralAttribute(maxlengthAttr, newValue);\n}", "target": 0}
{"code": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel, ++relnum) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  \n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  \n  else  \n    condmovestack(L,{},{});  \n  luaE_shrinkCI(L);  \n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictMaxPool(const OpContext& op_context,\n                                            NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int per_output_ops = dims.kx * dims.ky == 1 ? 1 : dims.kx * dims.ky - 1;\n  int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * per_output_ops;\n  node_costs->num_compute_ops = ops;\n  int64_t input_size = 0;\n  if (dims.ky >= dims.sy) {\n    input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  } else {  \n    const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype()));\n    input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz;\n  }\n  node_costs->num_input_bytes_accessed = {input_size};\n  const int64_t output_size =\n      CalculateOutputSize(op_info, &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "int DISOpticalFlowImpl::autoSelectCoarsestScale(int img_width)\n{\n    const int fratio = 5;\n    return std::max(0, (int)std::floor(log2((2.0f*(float)img_width) / ((float)fratio * (float)patch_size))));\n}", "target": 0}
{"code": "inline typename V::SetType FBUnserializer<V>::unserializeSet() {\n  p_ += CODE_SIZE;\n  unserializeInt64();\n  typename V::SetType ret = V::createSet();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::setAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "static struct ip_options *tcp_v4_save_options(struct sock *sk,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ip_options *opt = &(IPCB(skb)->opt);\n\tstruct ip_options *dopt = NULL;\n\tif (opt && opt->optlen) {\n\t\tint opt_size = optlength(opt);\n\t\tdopt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (dopt) {\n\t\t\tif (ip_options_echo(dopt, skb)) {\n\t\t\t\tkfree(dopt);\n\t\t\t\tdopt = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn dopt;\n}", "target": 1}
{"code": "NAN_METHOD(TxnWrap::putString) {\n    if (!info[2]->IsString())\n        return Nan::ThrowError(\"Value must be a string.\");\n    return putCommon(info, [](Nan::NAN_METHOD_ARGS_TYPE info, MDB_val &data) -> void {\n        CustomExternalStringResource::writeTo(Local<String>::Cast(info[2]), &data);\n    }, [](MDB_val &data) -> void {\n        delete[] (uint16_t*)data.mv_data;\n    });\n}", "target": 0}
{"code": "static int nfc_llcp_build_gb(struct nfc_llcp_local *local)\n{\n\tu8 *gb_cur, *version_tlv, version, version_length;\n\tu8 *lto_tlv, lto_length;\n\tu8 *wks_tlv, wks_length;\n\tu8 *miux_tlv, miux_length;\n\t__be16 wks = cpu_to_be16(local->local_wks);\n\tu8 gb_len = 0;\n\tint ret = 0;\n\tversion = LLCP_VERSION_11;\n\tversion_tlv = nfc_llcp_build_tlv(LLCP_TLV_VERSION, &version,\n\t\t\t\t\t 1, &version_length);\n\tgb_len += version_length;\n\tlto_tlv = nfc_llcp_build_tlv(LLCP_TLV_LTO, &local->lto, 1, &lto_length);\n\tgb_len += lto_length;\n\tpr_debug(\"Local wks 0x%lx\\n\", local->local_wks);\n\twks_tlv = nfc_llcp_build_tlv(LLCP_TLV_WKS, (u8 *)&wks, 2, &wks_length);\n\tgb_len += wks_length;\n\tmiux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&local->miux, 0,\n\t\t\t\t      &miux_length);\n\tgb_len += miux_length;\n\tgb_len += ARRAY_SIZE(llcp_magic);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tgb_cur = local->gb;\n\tmemcpy(gb_cur, llcp_magic, ARRAY_SIZE(llcp_magic));\n\tgb_cur += ARRAY_SIZE(llcp_magic);\n\tmemcpy(gb_cur, version_tlv, version_length);\n\tgb_cur += version_length;\n\tmemcpy(gb_cur, lto_tlv, lto_length);\n\tgb_cur += lto_length;\n\tmemcpy(gb_cur, wks_tlv, wks_length);\n\tgb_cur += wks_length;\n\tmemcpy(gb_cur, miux_tlv, miux_length);\n\tgb_cur += miux_length;\n\tlocal->gb_len = gb_len;\nout:\n\tkfree(version_tlv);\n\tkfree(lto_tlv);\n\tkfree(wks_tlv);\n\tkfree(miux_tlv);\n\treturn ret;\n}", "target": 1}
{"code": "uint32_t mt_random (mtrand *mt) {\n  uint32_t y;\n  unsigned long mag01[2];\n  mag01[0] = 0;\n  mag01[1] = MATRIX_A;\n  if (mt->mt_index_ >= MT_LEN) {\n    int kk;\n    for (kk = 0; kk < MT_LEN - MT_IA; kk++) {\n      y = (mt->mt_buffer_[kk] & UPPER_MASK) | \n\t(mt->mt_buffer_[kk + 1] & LOWER_MASK);\n      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + MT_IA] ^ \n\t(y >> 1) ^ mag01[y & 0x1UL];\n    }\n    for (;kk < MT_LEN - 1; kk++) {\n      y = (mt->mt_buffer_[kk] & UPPER_MASK) | \n\t(mt->mt_buffer_[kk + 1] & LOWER_MASK);\n      mt->mt_buffer_[kk] = mt->mt_buffer_[kk + (MT_IA - MT_LEN)] ^ \n\t(y >> 1) ^ mag01[y & 0x1UL];\n    }\n    y = (mt->mt_buffer_[MT_LEN - 1] & UPPER_MASK) | \n      (mt->mt_buffer_[0] & LOWER_MASK);\n    mt->mt_buffer_[MT_LEN - 1] = mt->mt_buffer_[MT_IA - 1] ^ \n      (y >> 1) ^ mag01[y & 0x1UL];\n    mt->mt_index_ = 0;\n  }\n  y = mt->mt_buffer_[mt->mt_index_++];\n  y ^= (y >> 11);\n  y ^= (y << 7) & 0x9d2c5680UL;\n  y ^= (y << 15) & 0xefc60000UL;\n  y ^= (y >> 18);\n  return y;\n}", "target": 1}
{"code": "int epo_copy_color(gx_device *dev, const byte *data, int data_x, int raster, gx_bitmap_id id,\\\n    int x, int y, int width, int height)\n{\n    int code = epo_handle_erase_page(dev);\n    if (code != 0)\n        return code;\n    return dev_proc(dev, copy_color)(dev, data, data_x, raster, id, x, y, width, height);\n}", "target": 0}
{"code": "__u32 secure_ipv6_id(const __be32 daddr[4])\n{\n\t__u32 hash[4];\n\tmemcpy(hash, daddr, 16);\n\tmd5_transform(hash, net_secret);\n\treturn hash[0];\n}", "target": 0}
{"code": "vq_is_ready(struct vhost_virtqueue *vq)\n{\n\treturn vq && vq->desc && vq->avail && vq->used &&\n\t       vq->kickfd != VIRTIO_UNINITIALIZED_EVENTFD &&\n\t       vq->callfd != VIRTIO_UNINITIALIZED_EVENTFD;\n}", "target": 0}
{"code": "void test_chdir(const char *path)\n{\n\tif (chdir(path) == 0) {\n\t\tfprintf(stderr, \"leak at chdir to %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "inline bool CheckForOverflow<Eigen::half>(double as_double, Eigen::half* out) {\n  return (sizeof(Eigen::half) < sizeof(double) &&\n          Eigen::half_impl::isinf(*out) && std::isfinite(as_double));\n}", "target": 0}
{"code": "pci_lintr_assert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == IDLE) {\n\t\tif (pci_lintr_permitted(dev)) {\n\t\t\tdev->lintr.state = ASSERTED;\n\t\t\tpci_irq_assert(dev);\n\t\t} else\n\t\t\tdev->lintr.state = PENDING;\n\t}\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "TEST_SUITE_CLEANUP(suite_cleanup)\n{\n    umock_c_deinit();\n    TEST_MUTEX_DESTROY(g_testByTest);\n}", "target": 0}
{"code": "TiledInputFile::rawTileData (int &dx, int &dy,\n\t\t\t     int &lx, int &ly,\n                             const char *&pixelData,\n\t\t\t     int &pixelDataSize)\n{\n    try\n    {\n        Lock lock (*_data->_streamData);\n        if (!isValidTile (dx, dy, lx, ly))\n            throw IEX_NAMESPACE::ArgExc (\"Tried to read a tile outside \"\n\t\t\t       \"the image file's data window.\");\n        TileBuffer *tileBuffer = _data->getTileBuffer (0);\n        int old_dx=dx;\n        int old_dy=dy;\n        int old_lx=lx;\n        int old_ly=ly;\n        if(isMultiPart(version()))\n        {\n            _data->_streamData->is->seekg(_data->tileOffsets(dx,dy,lx,ly));\n        }\n        readNextTileData (_data->_streamData, _data, dx, dy, lx, ly,\n\t\t\t  tileBuffer->buffer,\n                          pixelDataSize);\n        if(isMultiPart(version()))\n        {\n            if (old_dx!=dx || old_dy !=dy || old_lx!=lx || old_ly!=ly)\n            {\n                throw IEX_NAMESPACE::ArgExc (\"rawTileData read the wrong tile\");\n            }\n        }\n        else\n        {\n             if(!isValidTile (dx, dy, lx, ly) )\n             {\n                 throw IEX_NAMESPACE::IoExc (\"rawTileData read an invalid tile\");\n             }\n        }\n        pixelData = tileBuffer->buffer;\n    }\n    catch (IEX_NAMESPACE::BaseExc &e)\n    {\n        REPLACE_EXC (e, \"Error reading pixel data from image \"\n                     \"file \\\"\" << fileName() << \"\\\". \" << e.what());\n        throw;\n    }\n}", "target": 0}
{"code": "format_fractional_part_nsecs(gchar *buf, size_t buflen, guint32 nsecs, const char *decimal_point, int precision)\n{\n\tgsize decimal_point_len;\n\tgint8 num_buf[CHARS_NANOSECONDS];\n\tgint8 *num_end = &num_buf[CHARS_NANOSECONDS];\n\tgint8 *num_ptr;\n\tsize_t num_len;\n\tws_assert(precision != 0);\n\tif (buflen == 0) {\n\t\treturn;\n\t}\n\tdecimal_point_len = g_strlcpy(buf, decimal_point, buflen);\n\tif (decimal_point_len >= buflen) {\n\t\treturn;\n\t}\n\tbuf += decimal_point_len;\n\tbuflen -= decimal_point_len;\n\tswitch (precision) {\n\tcase 1:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100000000, precision);\n\t\tbreak;\n\tcase 2:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10000000, precision);\n\t\tbreak;\n\tcase 3:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 1000000, precision);\n\t\tbreak;\n\tcase 4:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100000, precision);\n\t\tbreak;\n\tcase 5:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10000, precision);\n\t\tbreak;\n\tcase 6:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 1000, precision);\n\t\tbreak;\n\tcase 7:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 100, precision);\n\t\tbreak;\n\tcase 8:\n\t\tnum_ptr = uint_to_str_back_len(num_end,\n\t\t    nsecs / 10, precision);\n\t\tbreak;\n\tcase 9:\n\t\tnum_ptr = uint_to_str_back_len(num_end, nsecs,\n\t\t    precision);\n\t\tbreak;\n\tdefault:\n\t\tws_assert_not_reached();\n\t\tbreak;\n\t}\n\tnum_len = MIN((size_t)(num_end - num_ptr), buflen - 1);\n\tif (num_len == 0) {\n\t\treturn;\n\t}\n\tmemcpy(buf, num_ptr, num_len);\n\t*(buf + num_len) = '\\0';\n}", "target": 1}
{"code": "int nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->polling) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_ENABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->enable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_ENABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\t\t\tifs = find_outbound(&sa);\n\t\t\tif (!ifs) {\n\t\t\t\tlogit(LOG_DEBUG, \"No matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"Matching socket for client %s\", inet_ntoa(sin->sin_addr));\n\t\t\ttype = strcasestr(buf, \"\\r\\nST:\");\n\t\t\tif (!type) {\n\t\t\t\tlogit(LOG_DEBUG, \"No Search Type (ST:) found in M-SEARCH *, assuming \" SSDP_ST_ALL);\n\t\t\t\ttype = SSDP_ST_ALL;\n\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttype = strchr(type, ':');\n\t\t\tif (!type)\n\t\t\t\treturn;\n\t\t\ttype++;\n\t\t\twhile (isspace(*type))\n\t\t\t\ttype++;\n\t\t\tptr = strstr(type, \"\\r\\n\");\n\t\t\tif (!ptr)\n\t\t\t\treturn;\n\t\t\t*ptr = 0;\n\t\t\tfor (i = 0; supported_types[i]; i++) {\n\t\t\t\tif (!strcmp(supported_types[i], type)) {\n\t\t\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * ST: %s from %s port %d\", type,\n\t\t\t\t\t      inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\t\t\tsend_message(ifs, type, &sa);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlogit(LOG_DEBUG, \"M-SEARCH * for unsupported ST: %s from %s\", type,\n\t\t\t      inet_ntoa(sin->sin_addr));\n\t\t}\n\t}\n}", "target": 1}
{"code": "__xfs_inode_free(\n\tstruct xfs_inode\t*ip)\n{\n\tASSERT(atomic_read(&ip->i_pincount) == 0);\n\tXFS_STATS_DEC(ip->i_mount, vn_active);\n\tcall_rcu(&VFS_I(ip)->i_rcu, xfs_inode_free_callback);\n}", "target": 0}
{"code": "static int stellaris_enet_post_load(void *opaque, int version_id)\n{\n    stellaris_enet_state *s = opaque;\n    int i;\n    if (s->next_packet >= ARRAY_SIZE(s->rx)) {\n        return -1;\n    }\n    if (s->np > ARRAY_SIZE(s->rx)) {\n        return -1;\n    }\n    for (i = 0; i < ARRAY_SIZE(s->rx); i++) {\n        if (s->rx[i].len > ARRAY_SIZE(s->rx[i].data)) {\n            return -1;\n        }\n    }\n    if (s->rx_fifo_offset > ARRAY_SIZE(s->rx[0].data) - 4) {\n        return -1;\n    }\n    if (s->tx_fifo_len > ARRAY_SIZE(s->tx_fifo)) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "bool Server::MatchViewOrStatic(const std::string& method,\n                               const std::string& url, bool* stream) {\n  if (Router::MatchView(method, url, stream)) {\n    return true;\n  }\n  if (method == methods::kGet && !doc_root_.empty()) {\n    fs::path path = doc_root_ / url;\n    fs::error_code ec;\n    if (!fs::is_directory(path, ec) && fs::exists(path, ec)) {\n      return true;\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "bool TensorSliceReader::CopySliceData(const string& name,\n                                      const TensorSlice& slice, T* data) const {\n  std::vector<std::pair<TensorSlice, string>> details;\n  const TensorSliceSet* tss;\n  {\n    mutex_lock l(mu_);\n    tss = FindTensorSlice(name, slice, &details);\n    if (!tss && !all_shards_loaded_) {\n      VLOG(1) << \"Did not find slice in preferred shard, loading all shards.\"\n              << name << \": \" << slice.DebugString();\n      LoadAllShards();\n      tss = FindTensorSlice(name, slice, &details);\n    }\n    if (!tss) {\n      return false;\n    }\n  }\n  string value;\n  for (const auto& x : details) {\n    const TensorSlice& slice_s = x.first;\n    const string& fname = x.second;\n    int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);\n    CHECK_GE(idx, 0) << \"Failed to find the index for filename \" << fname;\n    const string key = EncodeTensorNameSlice(name, slice_s);\n    if (!sss_[idx]->Get(key, &value)) {\n      VLOG(1) << \"Failed to seek to the record for tensor \" << name\n              << \", slice \" << slice_s.DebugString()\n              << \": computed key = \" << key;\n      return false;\n    }\n    SavedTensorSlices sts;\n    if (!ParseProtoUnlimited(&sts, value)) {\n      VLOG(1) << \"Failed to parse the record for tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": computed key = \" << key;\n      return false;\n    }\n    TensorShape shp_s;\n    Status s = slice_s.SliceTensorShape(tss->shape(), &shp_s);\n    if (!s.ok()) {\n      VLOG(1) << \"Failed to slice tensor \" << name << \", slice \"\n              << slice_s.DebugString() << \": \" << s;\n      return false;\n    }\n    if (checkpoint::TensorProtoDataSize<T>(sts.data().data()) !=\n        shp_s.num_elements()) {\n      VLOG(1) << \"Tensor \" << name << \", slice \" << slice_s.DebugString()\n              << \" had an unexpected amount of data: expected = \"\n              << shp_s.num_elements() << \", got = \"\n              << checkpoint::TensorProtoDataSize<T>(sts.data().data());\n      return false;\n    }\n    CopyDataFromTensorSliceToTensorSlice(\n        tss->shape(), slice_s, slice,\n        checkpoint::TensorProtoData<T>(sts.data().data()), data);\n  }\n  return true;\n}", "target": 0}
{"code": "static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set (db, \"qnx.cpu\", r_strf (\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set (db, \"qnx.fpu\", r_strf (\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set (db, \"qnx.code_index\", r_strf (\"0x%x\", lmfh->code_index), 0);\n\tsdb_set (db, \"qnx.stack_index\", r_strf (\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set (db, \"qnx.heap_index\", r_strf (\"0x%x\", lmfh->heap_index), 0);\n\tsdb_set (db, \"qnx.argv_index\", r_strf (\"0x%x\", lmfh->argv_index), 0);\n\tsdb_set (db, \"qnx.code_offset\", r_strf (\"0x%x\", lmfh->code_offset), 0);\n\tsdb_set (db, \"qnx.stack_nbytes\", r_strf (\"0x%x\", lmfh->stack_nbytes), 0);\n\tsdb_set (db, \"qnx.heap_nbytes\", r_strf (\"0x%x\", lmfh->heap_nbytes), 0);\n\tsdb_set (db, \"qnx.image_base\", r_strf (\"0x%x\", lmfh->image_base), 0);\n\treturn true;\n}", "target": 1}
{"code": "static int http_open(URLContext *h, const char *uri, int flags,\n                     AVDictionary **options)\n{\n    HTTPContext *s = h->priv_data;\n    int ret;\n    if( s->seekable == 1 )\n        h->is_streamed = 0;\n    else\n        h->is_streamed = 1;\n    s->filesize = -1;\n    s->location = av_strdup(uri);\n    if (!s->location)\n        return AVERROR(ENOMEM);\n    if (options)\n        av_dict_copy(&s->chained_options, *options, 0);\n    if (s->headers) {\n        int len = strlen(s->headers);\n        if (len < 2 || strcmp(\"\\r\\n\", s->headers + len - 2)) {\n            av_log(h, AV_LOG_WARNING,\n                   \"No trailing CRLF found in HTTP header.\\n\");\n            ret = av_reallocp(&s->headers, len + 3);\n            if (ret < 0)\n                return ret;\n            s->headers[len]     = '\\r';\n            s->headers[len + 1] = '\\n';\n            s->headers[len + 2] = '\\0';\n        }\n    }\n    if (s->listen) {\n        return http_listen(h, uri, flags, options);\n    }\n    ret = http_open_cnx(h, options);\n    if (ret < 0)\n        av_dict_free(&s->chained_options);\n    return ret;\n}", "target": 1}
{"code": "RenderWidgetHostViewBase* RenderWidgetHostImpl::GetView() const {\n  return view_.get();\n}", "target": 0}
{"code": "int __fastcall BatchSettings(TConsole * Console, TProgramParams * Params)\n{\n  int Result = RESULT_SUCCESS;\n  try\n  {\n    std::unique_ptr<TStrings> Arguments(new TStringList());\n    if (!DebugAlwaysTrue(Params->FindSwitch(L\"batchsettings\", Arguments.get())))\n    {\n      Abort();\n    }\n    else\n    {\n      if (Arguments->Count < 1)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_MASK));\n      }\n      else if (Arguments->Count < 2)\n      {\n        throw Exception(LoadStr(BATCH_SET_NO_SETTINGS));\n      }\n      else\n      {\n        TFileMasks Mask(Arguments->Strings[0]);\n        Arguments->Delete(0);\n        std::unique_ptr<TOptionsStorage> OptionsStorage(new TOptionsStorage(Arguments.get(), false));\n        int Matches = 0;\n        int Changes = 0;\n        for (int Index = 0; Index < StoredSessions->Count; Index++)\n        {\n          TSessionData * Data = StoredSessions->Sessions[Index];\n          if (!Data->IsWorkspace &&\n              Mask.Matches(Data->Name, false, false))\n          {\n            Matches++;\n            std::unique_ptr<TSessionData> OriginalData(new TSessionData(L\"\"));\n            OriginalData->CopyDataNoRecrypt(Data);\n            Data->ApplyRawSettings(OptionsStorage.get());\n            bool Changed = !OriginalData->IsSame(Data, false);\n            if (Changed)\n            {\n              Changes++;\n            }\n            UnicodeString StateStr = LoadStr(Changed ? BATCH_SET_CHANGED : BATCH_SET_NOT_CHANGED);\n            Console->PrintLine(FORMAT(L\"%s - %s\", (Data->Name, StateStr)));\n          }\n        }\n        StoredSessions->Save(false, true); \n        Console->PrintLine(FMTLOAD(BATCH_SET_SUMMARY, (Matches, Changes)));\n      }\n    }\n  }\n  catch (Exception & E)\n  {\n    Result = HandleException(Console, E);\n  }\n  Console->WaitBeforeExit();\n  return Result;\n}", "target": 1}
{"code": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}", "target": 1}
{"code": "bool Archive::Close()\n{\n#ifdef USE_ARCMEM\n  if (ArcMem.Unload())\n    return true;\n#endif\n  return File::Close();\n}", "target": 0}
{"code": "lyd_new_output_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                       void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "TEST_CASE(\"Start rule with ignore operator test\", \"[general]\")\n{\n    parser parser(R\"(\n        ~ROOT <- _\n        _ <- ' '\n    )\");\n    bool ret = parser;\n    REQUIRE(ret == false);\n}", "target": 0}
{"code": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "GF_Err gf_isom_freeze_order(GF_ISOFile *file)\n{\n\tu32 i=0;\n\tGF_Box *box;\n\tif (!file) return GF_BAD_PARAM;\n\twhile ((box=gf_list_enum(file->TopBoxes, &i))) {\n\t\tgf_isom_box_freeze_order(box);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static bool is_simm32(s64 value)\n{\n\treturn value == (s64) (s32) value;\n}", "target": 0}
{"code": "static int append_session_tasks_max(pam_handle_t *handle, sd_bus_message *m, const char *limit) {\n        uint64_t val;\n        int r;\n        if (isempty(limit) || streq(limit, \"infinity\"))\n                return 0;\n        r = safe_atou64(limit, &val);\n        if (r >= 0) {\n                r = sd_bus_message_append(m, \"(sv)\", \"TasksMax\", \"t\", val);\n                if (r < 0) {\n                        pam_syslog(handle, LOG_ERR, \"Failed to append to bus message: %s\", strerror(-r));\n                        return r;\n                }\n        } else\n                pam_syslog(handle, LOG_WARNING, \"Failed to parse systemd.limit: %s, ignoring.\", limit);\n        return 0;\n}", "target": 0}
{"code": "    CommentValue::CharsetId CommentValue::CharsetInfo::charsetIdByCode(\n        const std::string& code)\n    {\n        int i = 0;\n        for (;    charsetTable_[i].charsetId_ != lastCharsetId\n               && std::string(charsetTable_[i].code_, 8) != code; ++i) {}\n        return charsetTable_[i].charsetId_ == lastCharsetId ?\n               invalidCharsetId : charsetTable_[i].charsetId_;\n    }", "target": 0}
{"code": "CallResult<bool> isConstructor(Runtime &runtime, Callable *callable) {\n  if (!callable) {\n    return false;\n  }\n  while (BoundFunction *b = dyn_vmcast<BoundFunction>(callable)) {\n    callable = b->getTarget(runtime);\n  }\n  if (auto *func = dyn_vmcast<JSFunction>(callable)) {\n    auto *cb = func->getCodeBlock(runtime);\n    cb->lazyCompile(runtime);\n    return !func->getCodeBlock(runtime)->getHeaderFlags().isCallProhibited(\n        true);\n  }\n  if (!vmisa<NativeFunction>(callable) || vmisa<NativeConstructor>(callable)) {\n    return true;\n  }\n  if (auto *cproxy = dyn_vmcast<JSCallableProxy>(callable)) {\n    return cproxy->isConstructor(runtime);\n  }\n  return false;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart = 0, nend = 0; \n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (n == 0) {\n        goto bail;\n    }\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto bail;\n    int i;\n    for (i = istart; i <= iend; i++)\n    {\n        if (obj->arr[i])\n            Jsi_ValueCopy(interp, obj->arr[i], value);\n        else\n            obj->arr[i] = Jsi_ValueDup(interp, value);\n    }\nbail:\n    if (_this != *ret) {\n        Jsi_ValueMove(interp, *ret, _this);\n    }\n    return rc;\n}", "target": 1}
{"code": "spnego_gss_export_sec_context(\n\t\t\t    OM_uint32\t  *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t interprocess_token)\n{\n\tOM_uint32 ret;\n\tret = gss_export_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    interprocess_token);\n\treturn (ret);\n}", "target": 1}
{"code": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\tbucket = keyring_hash(name);\n\tread_lock(&keyring_name_lock);\n\tif (keyring_name_hash[bucket].next) {\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}", "target": 1}
{"code": "static int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = key->flags;\n\tkenter(\"{%d}\", key->serial);\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t\tif (key->expiry && ctx->now.tv_sec >= key->expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\tif (kflags & (1 << KEY_FLAG_NEGATIVE)) {\n\t\t\tsmp_rmb();\n\t\t\tctx->result = ERR_PTR(key->reject_error);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\nskipped:\n\treturn ctx->skipped_ret;\n}", "target": 1}
{"code": "static ssize_t aio_setup_single_vector(struct kiocb *kiocb)\n{\n\tkiocb->ki_iovec = &kiocb->ki_inline_vec;\n\tkiocb->ki_iovec->iov_base = kiocb->ki_buf;\n\tkiocb->ki_iovec->iov_len = kiocb->ki_left;\n\tkiocb->ki_nr_segs = 1;\n\tkiocb->ki_cur_seg = 0;\n\treturn 0;\n}", "target": 1}
{"code": "node_new_anychar(void)\n{\n  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);\n  return node;\n}", "target": 0}
{"code": "static int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint i_size_changed = 0;\n\ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\tif (ext4_has_inline_data(inode)) {\n\t\tret = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tput_page(page);\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\treturn ret ? ret : copied;\n}", "target": 1}
{"code": "int yr_re_match(\n    RE* re,\n    const char* target)\n{\n  return yr_re_exec(\n      re->code,\n      (uint8_t*) target,\n      strlen(target),\n      0,\n      re->flags | RE_FLAGS_SCAN,\n      NULL,\n      NULL);\n}", "target": 0}
{"code": "Status ImportNodes(ValueMapManager value_manager,\n                   const RepeatedPtrField<NodeDef>& nodes, OpBuilder& builder) {\n  Location unknown_loc = builder.getUnknownLoc();\n  MLIRContext* context = builder.getContext();\n  Type placeholder_ty = OpaqueTensorType::get(context);\n  Type control_ty = ControlType::get(context);\n  TFGraphDialect* tfgDialect =\n      cast<TFGraphDialect>(context->getLoadedDialect(\"tfg\"));\n  StringAttr device_attr = tfgDialect->getDeviceAttrIdentifier();\n  StringAttr name_attr = tfgDialect->getNameAttrIdentifier();\n  StringAttr fulltype_attr = tfgDialect->getFullTypeAttrIdentifier();\n  for (const NodeDef& node : nodes) {\n    DVLOG(1) << \"Processing node \" << node.name() << \"\\n\";\n    if (node.op().empty()) return InvalidArgument(\"empty op type\");\n    OperationState state(unknown_loc, absl::StrCat(\"tfg.\", node.op()));\n    for (const std::string& input : node.input()) {\n      if (input.empty())\n        return InvalidArgument(\"Node '\", node.name(), \"' has an empty input\");\n      state.operands.push_back(\n          value_manager.GetValueOrCreatePlaceholder(input));\n    }\n    state.types.push_back(placeholder_ty);\n    state.types.push_back(control_ty);\n    for (const auto& namedAttr : node.attr()) {\n      const std::string& name = namedAttr.first;\n      const AttrValue& tf_attr = namedAttr.second;\n      TF_ASSIGN_OR_RETURN(Attribute attr,\n                          ConvertAttributeValue(tf_attr, builder));\n      state.addAttribute(name, attr);\n    }\n    if (!node.device().empty())\n      state.addAttribute(device_attr, StringAttr::get(context, node.device()));\n    if (!node.name().empty())\n      state.addAttribute(name_attr, StringAttr::get(context, node.name()));\n    if (node.has_experimental_type()) {\n      TF_ASSIGN_OR_RETURN(tf_type::FullTypeAttr type,\n                          ConvertAttribute(node.experimental_type(), builder));\n      state.addAttribute(fulltype_attr, type);\n    }\n    Operation* op = builder.create(state);\n    StringRef node_name = node.name();\n    {\n      size_t colon_sep = node_name.find_first_of(':');\n      if (colon_sep != StringRef::npos)\n        node_name = node_name.take_front(colon_sep);\n    }\n    TF_RETURN_IF_ERROR(value_manager.DefineOperation(op, node_name));\n  }\n  for (Operation& op : *builder.getInsertionBlock()) {\n    if (op.getName().getStringRef() == \"tfg.__mlir_placeholder\") {\n      return InvalidArgument(absl::StrCat(\n          \"Couldn't import graph: placeholder left \",\n          op.getAttrOfType<StringAttr>(name_attr).getValue().str()));\n    }\n  }\n  return ::tensorflow::OkStatus();\n}", "target": 1}
{"code": "static void ip_expire(unsigned long arg)\n{\n\tstruct ipq *qp;\n\tstruct net *net;\n\tqp = container_of((struct inet_frag_queue *) arg, struct ipq, q);\n\tnet = container_of(qp->q.net, struct net, ipv4.frags);\n\tspin_lock(&qp->q.lock);\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\tipq_kill(qp);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n\t\t}\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}", "target": 1}
{"code": "static void perf_callchain_user_64(struct perf_callchain_entry *entry,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tunsigned long sp, next_sp;\n\tunsigned long next_ip;\n\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\tfor (;;) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\t\tif (next_sp - sp >= sizeof(struct signal_frame_64) &&\n\t\t    (is_sigreturn_64_address(next_ip, sp) ||\n\t\t     (level <= 1 && is_sigreturn_64_address(lr, sp))) &&\n\t\t    sane_signal_64_frame(sp)) {\n\t\t\tsigframe = (struct signal_frame_64 __user *) sp;\n\t\t\turegs = sigframe->uc.uc_mcontext.gp_regs;\n\t\t\tif (read_user_stack_64(&uregs[PT_NIP], &next_ip) ||\n\t\t\t    read_user_stack_64(&uregs[PT_LNK], &lr) ||\n\t\t\t    read_user_stack_64(&uregs[PT_R1], &sp))\n\t\t\t\treturn;\n\t\t\tlevel = 0;\n\t\t\tperf_callchain_store(entry, PERF_CONTEXT_USER);\n\t\t\tperf_callchain_store(entry, next_ip);\n\t\t\tcontinue;\n\t\t}\n\t\tif (level == 0)\n\t\t\tnext_ip = lr;\n\t\tperf_callchain_store(entry, next_ip);\n\t\t++level;\n\t\tsp = next_sp;\n\t}\n}", "target": 1}
{"code": "create_tls_session(int csock, int type  )\n{\n    int rc = 0;\n    gnutls_session *session = gnutls_malloc(sizeof(gnutls_session));\n    gnutls_init(session, type);\n#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT\n    gnutls_priority_set_direct(*session, \"NORMAL:+ANON-DH\", NULL);\n#  else\n    gnutls_set_default_priority(*session);\n    gnutls_kx_set_priority(*session, tls_kx_order);\n#  endif\n    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr) GINT_TO_POINTER(csock));\n    switch (type) {\n        case GNUTLS_SERVER:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_s);\n            break;\n        case GNUTLS_CLIENT:\n            gnutls_credentials_set(*session, GNUTLS_CRD_ANON, anon_cred_c);\n            break;\n    }\n    do {\n        rc = gnutls_handshake(*session);\n    } while (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN);\n    if (rc < 0) {\n        crm_err(\"Handshake failed: %s\", gnutls_strerror(rc));\n        gnutls_deinit(*session);\n        gnutls_free(session);\n        return NULL;\n    }\n    return session;\n}", "target": 1}
{"code": "GF_Err trak_box_size(GF_Box *s)\n{\n\tu32 pos=0;\n\tGF_TrackBox *ptr = (GF_TrackBox *)s;\n\tif (ptr->sample_encryption && ptr->sample_encryption->load_needed) {\n\t\tif (!ptr->moov || !!ptr->moov->mov || !ptr->moov->mov->movieFileMap)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tGF_Err e = senc_Parse(ptr->moov->mov->movieFileMap->bs, ptr, NULL, ptr->sample_encryption);\n\t\tif (e) return e;\n\t}\n\tgf_isom_check_position(s, (GF_Box *)ptr->Header, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Aperture, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->References, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->editBox, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->Media, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->meta, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->groups, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->udta, &pos);\n\treturn GF_OK;", "target": 0}
{"code": "static int32_t check_load_area(uintptr_t dst, uintptr_t len)\n{\n\tuint32_t legacy = dst + len <= UINT32_MAX - 1 ? 1 : 0;\n\tuintptr_t dram_start, dram_end;\n\tuintptr_t prot_start, prot_end;\n\tint32_t result = IO_SUCCESS;\n\tdram_start = legacy ? DRAM1_NS_BASE : DRAM_40BIT_BASE;\n\tdram_end = legacy ? DRAM1_NS_BASE + DRAM1_NS_SIZE :\n\t    DRAM_40BIT_BASE + DRAM_40BIT_SIZE;\n\tprot_start = legacy ? DRAM_PROTECTED_BASE : DRAM_40BIT_PROTECTED_BASE;\n\tprot_end = prot_start + DRAM_PROTECTED_SIZE;\n\tif (dst < dram_start || dst > dram_end - len || dram_end < len) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (dst >= prot_start && dst < prot_end) {\n\t\tERROR(\"BL2: dst address is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif ((dst < prot_start && dst > prot_start - len) || prot_start < len) {\n\t\tERROR(\"BL2: loaded data is on the protected area.\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\tif (addr_loaded_cnt >= CHECK_IMAGE_AREA_CNT) {\n\t\tERROR(\"BL2: max loadable non secure images reached\\n\");\n\t\tresult = IO_FAIL;\n\t\tgoto done;\n\t}\n\taddr_loaded[addr_loaded_cnt].dest = dst;\n\taddr_loaded[addr_loaded_cnt].length = len;\n\tfor(int n=0; n<addr_loaded_cnt; n++) {\n\t\tif (((dst >= addr_loaded[n].dest) &&\n\t\t     (dst <=  addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    ((dst + len >= addr_loaded[n].dest) &&\n\t\t     (dst + len <= addr_loaded[n].dest + addr_loaded[n].length)) ||\n\t\t    ((dst <= addr_loaded[n].dest) &&\n\t\t     (dst + len >= addr_loaded[n].dest + addr_loaded[n].length))) {\n\t\t\tERROR(\"BL2: next image overlap a previous image area.\\n\");\n\t\t\tresult = IO_FAIL;\n\t\t\tgoto done;\n\t\t}\n\t}\n\taddr_loaded_cnt++;\ndone:\n\tif (result == IO_FAIL) {\n\t\tERROR(\"BL2: Out of range : dst=0x%lx len=0x%lx\\n\", dst, len);\n\t}\n\treturn result;\n}", "target": 0}
{"code": "static int check_symlink(int fd)\n{\n\tstruct stat sb;\n\tint ret = fstat(fd, &sb);\n\tif (ret < 0)\n\t\treturn -ENOENT;\n\tif (S_ISLNK(sb.st_mode))\n\t\treturn -ELOOP;\n\treturn 0;\n}", "target": 0}
{"code": "static void ram_block_add(struct uc_struct *uc, RAMBlock *new_block)\n{\n    RAMBlock *block;\n    RAMBlock *last_block = NULL;\n    new_block->offset = find_ram_offset(uc, new_block->max_length);\n    if (!new_block->host) {\n        new_block->host = phys_mem_alloc(uc, new_block->max_length,\n                &new_block->mr->align);\n        if (!new_block->host) {\n            return;\n        }\n    }\n    RAMBLOCK_FOREACH(block) {\n        last_block = block;\n        if (block->max_length < new_block->max_length) {\n            break;\n        }\n    }\n    if (block) {\n        QLIST_INSERT_BEFORE(block, new_block, next);\n    } else if (last_block) {\n        QLIST_INSERT_AFTER(last_block, new_block, next);\n    } else { \n        QLIST_INSERT_HEAD(&uc->ram_list.blocks, new_block, next);\n    }\n    uc->ram_list.mru_block = NULL;\n    cpu_physical_memory_set_dirty_range(new_block->offset,\n                                        new_block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n}", "target": 1}
{"code": "unsigned WebGraphicsContext3DDefaultImpl::createRenderbuffer()\n{\n    makeContextCurrent();\n    GLuint o;\n    glGenRenderbuffersEXT(1, &o);\n    return o;\n}", "target": 0}
{"code": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\tpipe_double_lock(ipipe, opipe);\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tpipe_buf_get(ipipe, ibuf);\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\treturn ret;\n}", "target": 1}
{"code": "void recovery_character(const char *character)\n{\n    if (!awaiting_character) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");\n        layoutHome();\n        return;\n    }\n    char *pos = strchr(cipher, character[0]);\n    if (character[0] != ' ' && pos == NULL) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_SyntaxError, \"Character must be from a to z\");\n        layoutHome();\n        return;\n    }\n    static int uncyphered_word_count = 0;\n    static bool definitely_using_cipher = false;\n    static CONFIDENTIAL char coded_word[12];\n    static CONFIDENTIAL char decoded_word[12];\n    if (!mnemonic[0]) {\n        uncyphered_word_count = 0;\n        definitely_using_cipher = false;\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n    char decoded_character[2] = \" \";\n    if (character[0] != ' ') {\n        decoded_character[0] = english_alphabet[(int)(pos - cipher)];\n        strlcat(coded_word, character, sizeof(coded_word));\n        strlcat(decoded_word, decoded_character, sizeof(decoded_word));\n        if (enforce_wordlist && 4 <= strlen(coded_word)) {\n            bool maybe_not_using_cipher = attempt_auto_complete(coded_word);\n            bool maybe_using_cipher = attempt_auto_complete(decoded_word);\n            if (!maybe_not_using_cipher && maybe_using_cipher) {\n                definitely_using_cipher = true;\n            } else if (maybe_not_using_cipher && !definitely_using_cipher &&\n                       MAX_UNCYPHERED_WORDS < uncyphered_word_count++) {\n                recovery_abort();\n                fsm_sendFailure(FailureType_Failure_SyntaxError,\n                                \"Words were not entered correctly. Make sure you are using the substition cipher.\");\n                layoutHome();\n                return;\n            }\n        }\n    } else {\n        memzero(coded_word, sizeof(coded_word));\n        memzero(decoded_word, sizeof(decoded_word));\n    }\n    strlcat(mnemonic, decoded_character, MNEMONIC_BUF);\n    next_character();\n}", "target": 1}
{"code": "int zmq::stream_engine_t::decode_and_push (msg_t *msg_)\n{\n    zmq_assert (mechanism != NULL);\n    if (mechanism->decode (msg_) == -1)\n        return -1;\n    if (metadata)\n        msg_->set_metadata (metadata);\n    if (session->push_msg (msg_) == -1) {\n        if (errno == EAGAIN)\n            process_msg = &stream_engine_t::push_one_then_decode_and_push;\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static int gasp_source_id(__be32 *p)\n{\n\treturn be32_to_cpu(p[0]) >> 16;\n}", "target": 0}
{"code": "encodeJsonStructure(const void *src, const UA_DataType *type, CtxJson *ctx) {\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    status ret = writeJsonObjStart(ctx);\n    uintptr_t ptr = (uintptr_t) src;\n    u8 membersSize = type->membersSize;\n    const UA_DataType * typelists[2] = {UA_TYPES, &type[-type->typeIndex]};\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        if(m->memberName != NULL && *m->memberName != 0)\n            ret |= writeJsonKey(ctx, m->memberName);\n        if(!m->isArray) {\n            ptr += m->padding;\n            size_t memSize = mt->memSize;\n            ret |= encodeJsonJumpTable[mt->typeKind]((const void*) ptr, mt, ctx);\n            ptr += memSize;\n        } else {\n            ptr += m->padding;\n            const size_t length = *((const size_t*) ptr);\n            ptr += sizeof (size_t);\n            ret |= encodeJsonArray(ctx, *(void * const *)ptr, length, mt);\n            ptr += sizeof (void*);\n        }\n    }\n    ret |= writeJsonObjEnd(ctx);\n    ctx->depth--;\n    return ret;\n}", "target": 1}
{"code": "inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(\n    Request &req, const char *body, size_t content_length,\n    ContentProvider content_provider,\n    ContentProviderWithoutLength content_provider_without_length,\n    const std::string &content_type, Error &error) {\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_) { req.headers.emplace(\"Content-Encoding\", \"gzip\"); }\n#endif\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_ && !content_provider_without_length) {\n    detail::gzip_compressor compressor;\n    if (content_provider) {\n      auto ok = true;\n      size_t offset = 0;\n      DataSink data_sink;\n      data_sink.write = [&](const char *data, size_t data_len) -> bool {\n        if (ok) {\n          auto last = offset + data_len == content_length;\n          auto ret = compressor.compress(\n              data, data_len, last,\n              [&](const char *compressed_data, size_t compressed_data_len) {\n                req.body.append(compressed_data, compressed_data_len);\n                return true;\n              });\n          if (ret) {\n            offset += data_len;\n          } else {\n            ok = false;\n          }\n        }\n        return ok;\n      };\n      while (ok && offset < content_length) {\n        if (!content_provider(offset, content_length - offset, data_sink)) {\n          error = Error::Canceled;\n          return nullptr;\n        }\n      }\n    } else {\n      if (!compressor.compress(body, content_length, true,\n                               [&](const char *data, size_t data_len) {\n                                 req.body.append(data, data_len);\n                                 return true;\n                               })) {\n        error = Error::Compression;\n        return nullptr;\n      }\n    }\n  } else\n#endif\n  {\n    if (content_provider) {\n      req.content_length_ = content_length;\n      req.content_provider_ = std::move(content_provider);\n      req.is_chunked_content_provider_ = false;\n    } else if (content_provider_without_length) {\n      req.content_length_ = 0;\n      req.content_provider_ = detail::ContentProviderAdapter(\n          std::move(content_provider_without_length));\n      req.is_chunked_content_provider_ = true;\n      req.headers.emplace(\"Transfer-Encoding\", \"chunked\");\n    } else {\n      req.body.assign(body, content_length);\n      ;\n    }\n  }\n  auto res = detail::make_unique<Response>();\n  return send(req, *res, error) ? std::move(res) : nullptr;\n}", "target": 1}
{"code": "void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,\n                              int64_t object_store_id,\n                              scoped_refptr<IndexedDBCallbacks> callbacks) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::Clear\", \"txn.id\", transaction->id());\n  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);\n  if (!ValidateObjectStoreId(object_store_id))\n    return;\n  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,\n                                           this, object_store_id, callbacks));\n}", "target": 0}
{"code": "  void onComplete(const Status& status, ContextImpl& context) const override {\n    auto& completion_state = context.getCompletionState(this);\n    if (completion_state.is_completed_) {\n      return;\n    }\n    if (Status::Ok == status) {\n      completion_state.is_completed_ = true;\n      completeWithStatus(status, context);\n      return;\n    }\n    if (++completion_state.number_completed_children_ == verifiers_.size()) {\n      Status final_status = Status::JwtMissed;\n      for (const auto& it : verifiers_) {\n        Status child_status = context.getCompletionState(it.get()).status_;\n        if (child_status != Status::JwtMissed && child_status != Status::JwtUnknownIssuer) {\n          final_status = child_status;\n        }\n      }\n      if (is_allow_missing_or_failed_) {\n        final_status = Status::Ok;\n      } else if (is_allow_missing_ && final_status == Status::JwtMissed) {\n        final_status = Status::Ok;\n      }\n      completion_state.is_completed_ = true;\n      completeWithStatus(final_status, context);\n    }\n  }", "target": 1}
{"code": "void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}", "target": 1}
{"code": "void PPB_URLLoader_Impl::didReceiveData(WebURLLoader* loader,\n                                        const char* data,\n                                        int data_length,\n                                        int encoded_data_length) {\n  bytes_received_ += data_length;\n  UpdateStatus();\n  buffer_.insert(buffer_.end(), data, data + data_length);\n  DCHECK(request_data_.prefetch_buffer_lower_threshold <\n         request_data_.prefetch_buffer_upper_threshold);\n  if (!is_streaming_to_file_ &&\n      !is_asynchronous_load_suspended_ &&\n      (buffer_.size() >= static_cast<size_t>(\n          request_data_.prefetch_buffer_upper_threshold))) {\n    DVLOG(1) << \"Suspending async load - buffer size: \" << buffer_.size();\n    SetDefersLoading(true);\n  }\n  if (user_buffer_) {\n    RunCallback(FillUserBuffer());\n  } else {\n    DCHECK(!TrackedCallback::IsPending(pending_callback_));\n  }\n}", "target": 0}
{"code": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tunsigned int offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\t\tunsigned int len;\n\t\tswitch (**nexthdr) {\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\tlen = ipv6_optlen(exthdr);\n\t\tif (len + offset >= IPV6_MAXPLEN)\n\t\t\treturn -EINVAL;\n\t\toffset += len;\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_sizes = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    OP_REQUIRES(\n        context, out_backprop.dims() == 4,\n        errors::InvalidArgument(\"input_sizes must be 4-dimensional, got: \",\n                                out_backprop.dims()));\n    TensorShape input_shape;\n    OP_REQUIRES_OK(context,\n                   Conv2DBackpropComputeInputShape(input_sizes, filter.shape(),\n                                                   out_backprop.shape(),\n                                                   data_format_, &input_shape));\n    Tensor* in_backprop = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    if (input_shape.num_elements() == 0) {\n      return;\n    }\n    if (out_backprop.NumElements() == 0) {\n      functor::SetZeroFunctor<Device, T> set_zero;\n      set_zero(context->eigen_device<Device>(),\n               in_backprop->template flat<T>());\n      return;\n    }\n    const int stride_rows = GetTensorDim(strides_, data_format_, 'H');\n    const int stride_cols = GetTensorDim(strides_, data_format_, 'W');\n    const int dilation_rows = GetTensorDim(dilations_, data_format_, 'H');\n    const int dilation_cols = GetTensorDim(dilations_, data_format_, 'W');\n    VLOG(2) << \"Conv2DBackpropInput:\"\n            << \" input: \" << input_shape.DebugString()\n            << \" filter:\" << filter.shape().DebugString()\n            << \" out_backprop: \" << out_backprop.shape().DebugString()\n            << \" strides: [\" << stride_rows << \", \" << stride_cols << \"]\"\n            << \" dilations: [\" << dilation_rows << \", \" << dilation_cols << \"]\";\n    LaunchConv2DBackpropInputOp<Device, T> launch;\n    launch(context, use_cudnn_, cudnn_use_autotune_, out_backprop, filter,\n           dilation_rows, dilation_cols, stride_rows, stride_cols, padding_,\n           explicit_paddings_, in_backprop, data_format_);\n  }", "target": 0}
{"code": "TEST(FloatPoolingOpTest, MaxPoolWithZeroStride) {\n  EXPECT_DEATH(\n      FloatPoolingOpModel m(BuiltinOperator_MAX_POOL_2D,\n                            {TensorType_FLOAT32, {1, 2, 4, 1}},\n                            2, 2,\n                            {TensorType_FLOAT32, {}},\n                            Padding_VALID,\n                            0, 0),\n      \"Cannot allocate tensors\");\n}", "target": 0}
{"code": "RawTile OpenJPEGImage::getRegion( int ha, int va, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h ){\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, ha, va, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w * h * channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w * h * channels];\n  else throw file_error( \"OpenJPEG :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"OpenJPEG :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "static void xen_invalidate_io_bitmap(void)\n{\n\tstruct physdev_set_iobitmap iobitmap = {\n\t\t.bitmap = 0,\n\t\t.nr_ports = 0,\n\t};\n\tnative_tss_invalidate_io_bitmap();\n\tHYPERVISOR_physdev_op(PHYSDEVOP_set_iobitmap, &iobitmap);\n}", "target": 0}
{"code": "[[noreturn]] void TProtocolException::throwInvalidSkipType(TType type) {\n  throw TProtocolException(\n      TProtocolException::INVALID_DATA,\n      folly::sformat(\n          \"Encountered invalid field/element type ({}) during skipping\",\n          static_cast<uint8_t>(type)));\n}", "target": 0}
{"code": "  void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecgsiGMAPLDAP.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }", "target": 1}
{"code": "void PasswordAutofillAgent::AJAXSucceeded() {\n  OnSamePageNavigationCompleted();\n}", "target": 0}
{"code": "decode_string(CBORDecoderObject *self, uint8_t subtype)\n{\n    uint64_t length = 0;\n    bool indefinite = true;\n    PyObject *ret;\n    char length_hex[17];\n    if (decode_length(self, subtype, &length, &indefinite) == -1)\n        return NULL;\n    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {\n        sprintf(length_hex, \"%llX\", length);\n        PyErr_Format(\n                _CBOR2_CBORDecodeValueError,\n                \"excessive string size 0x%s\", length_hex);\n        return NULL;\n    }\n    if (indefinite)\n        ret = decode_indefinite_strings(self);\n    else\n        ret = decode_definite_string(self, (Py_ssize_t)length);\n    set_shareable(self, ret);\n    return ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* c) override {\n    PartialTensorShape element_shape;\n    OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(0), &element_shape));\n    OP_REQUIRES(\n        c, TensorShapeUtils::IsScalar(c->input(1).shape()),\n        errors::InvalidArgument(\n            \"The num_elements to reserve must be a tensor size 1, but got \",\n            c->input(1).shape()));\n    int32_t num_elements = c->input(1).scalar<int32>()();\n    OP_REQUIRES(c, num_elements >= 0,\n                errors::InvalidArgument(\"The num_elements to reserve must be a \"\n                                        \"non negative number, but got \",\n                                        num_elements));\n    TensorList output;\n    output.element_shape = element_shape;\n    output.element_dtype = element_dtype_;\n    output.tensors().resize(num_elements, Tensor(DT_INVALID));\n    Tensor* result;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr));\n    result->scalar<Variant>()() = std::move(output);\n  }", "target": 0}
{"code": "mem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\tif (log_op)\n\t\tfclose(log_op);\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen(log_name, \"a\");\n\tif (log_op == NULL) {\n\t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n\t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\t\tsetlinebuf(log_op);\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\tfree(log_name);\n\tterminate_banner = banner;\n}", "target": 1}
{"code": "ev_archive_read_next_header (EvArchive *archive,\n\t\t\t     GError   **error)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\treturn libarchive_read_next_header (archive, error);\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "dns_resolver_match(const struct key *key,\n\t\t   const struct key_match_data *match_data)\n{\n\tint slen, dlen, ret = 0;\n\tconst char *src = key->description, *dsp = match_data->raw_data;\n\tkenter(\"%s,%s\", src, dsp);\n\tif (!src || !dsp)\n\t\tgoto no_match;\n\tif (strcasecmp(src, dsp) == 0)\n\t\tgoto matched;\n\tslen = strlen(src);\n\tdlen = strlen(dsp);\n\tif (slen <= 0 || dlen <= 0)\n\t\tgoto no_match;\n\tif (src[slen - 1] == '.')\n\t\tslen--;\n\tif (dsp[dlen - 1] == '.')\n\t\tdlen--;\n\tif (slen != dlen || strncasecmp(src, dsp, slen) != 0)\n\t\tgoto no_match;\nmatched:\n\tret = 1;\nno_match:\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "void HeaderMapImpl::removePrefix(const LowerCaseString& prefix) {\n  headers_.remove_if([&](const HeaderEntryImpl& entry) {\n    bool to_remove = absl::StartsWith(entry.key().getStringView(), prefix.get());\n    if (to_remove) {\n      EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(entry.key().getStringView());\n      if (cb) {\n        StaticLookupResponse ref_lookup_response = cb(*this);\n        if (ref_lookup_response.entry_) {\n          *ref_lookup_response.entry_ = nullptr;\n        }\n      }\n    }\n    return to_remove;\n  });\n}", "target": 1}
{"code": "static int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}", "target": 0}
{"code": "m_hour(union DateData *x)\n{\n    if (simple_dat_p(x))\n\treturn 0;\n    else {\n\tget_c_time(x);\n#ifndef USE_PACK\n\treturn x->c.hour;\n#else\n\treturn EX_HOUR(x->c.pc);\n#endif\n    }\n}", "target": 0}
{"code": "void bio_chain(struct bio *bio, struct bio *parent)\n{\n\tBUG_ON(bio->bi_private || bio->bi_end_io);\n\tbio->bi_private = parent;\n\tbio->bi_end_io\t= bio_chain_endio;\n\tbio_inc_remaining(parent);\n}", "target": 0}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[1]) << 32) + X[0]);\n}", "target": 1}
{"code": "static int hgcm_call_preprocess_linaddr(\n\tconst struct vmmdev_hgcm_function_parameter *src_parm,\n\tvoid **bounce_buf_ret, size_t *extra)\n{\n\tvoid *buf, *bounce_buf;\n\tbool copy_in;\n\tu32 len;\n\tint ret;\n\tbuf = (void *)src_parm->u.pointer.u.linear_addr;\n\tlen = src_parm->u.pointer.size;\n\tcopy_in = src_parm->type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT;\n\tif (len > VBG_MAX_HGCM_USER_PARM)\n\t\treturn -E2BIG;\n\tbounce_buf = kvmalloc(len, GFP_KERNEL);\n\tif (!bounce_buf)\n\t\treturn -ENOMEM;\n\tif (copy_in) {\n\t\tret = copy_from_user(bounce_buf, (void __user *)buf, len);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tmemset(bounce_buf, 0, len);\n\t}\n\t*bounce_buf_ret = bounce_buf;\n\thgcm_call_add_pagelist_size(bounce_buf, len, extra);\n\treturn 0;\n}", "target": 1}
{"code": "static int is_symlink_path(pool *p, const char *path, size_t pathlen) {\n  int res, xerrno = 0;\n  struct stat st;\n  char *ptr;\n  if (pathlen == 0) {\n    return 0;\n  }\n  pr_fs_clear_cache();\n  res = pr_fsio_lstat(path, &st);\n  if (res < 0) {\n    xerrno = errno;\n    pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n      strerror(xerrno));\n    errno = xerrno;\n    return -1;\n  }\n  if (S_ISLNK(st.st_mode)) {\n    errno = EPERM;\n    return -1;\n  }\n  ptr = strrchr(path, '/');\n  if (ptr != NULL) {\n    char *new_path;\n    size_t new_pathlen;\n    pr_signals_handle();\n    new_pathlen = ptr - path;\n    if (new_pathlen == pathlen) {\n      return 0;\n    }\n    new_path = pstrndup(p, path, new_pathlen);\n    pr_log_debug(DEBUG10,\n      \"AllowChrootSymlink: path '%s' not a symlink, checking '%s'\", path,\n      new_path);\n    res = is_symlink_path(p, new_path, new_pathlen);\n    if (res < 0) {\n      return -1;\n    }\n  }\n  return 0;\n}", "target": 0}
{"code": "void ide_atapi_cmd(IDEState *s)\n{\n    uint8_t *buf;\n    buf = s->io_buffer;\n#ifdef DEBUG_IDE_ATAPI\n    {\n        int i;\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n            printf(\" %02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n#endif\n    if (s->sense_key == UNIT_ATTENTION &&\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n        ide_atapi_cmd_check_status(s);\n        return;\n    }\n    if (!s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n        s->cdrom_changed = 0;\n        s->sense_key = UNIT_ATTENTION;\n        s->asc = ASC_MEDIUM_MAY_HAVE_CHANGED;\n        return;\n    }\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n    {\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n        return;\n    }\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n        return;\n    }\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n}", "target": 0}
{"code": "GF_EXPORT\nGF_Err gf_isom_get_sidx_duration(GF_ISOFile *movie, u64 *sidx_dur, u32 *sidx_timescale)\n{\n\tu64 dur=0;\n\tu32 i;\n\tif (!movie || !movie->moov || !sidx_timescale || !sidx_dur)\n\t\treturn GF_BAD_PARAM;\n\tif (!movie->main_sidx) return GF_NOT_SUPPORTED;\n\t*sidx_timescale = movie->main_sidx->timescale;\n\tfor (i=0; i<movie->main_sidx->nb_refs; i++) {\n\t\tdur += movie->main_sidx->refs[i].subsegment_duration;\n\t}\n\t*sidx_dur = dur;\n\treturn GF_OK;", "target": 0}
{"code": "    bool load_face(Face & face, unsigned int options)\n    {\n#ifdef GRAPHITE2_TELEMETRY\n        telemetry::category _misc_cat(face.tele.misc);\n#endif\n        Face::Table silf(face, Tag::Silf, 0x00050000);\n        if (silf)   options &= ~gr_face_dumbRendering;\n        else if (!(options &  gr_face_dumbRendering))\n            return false;\n        if (!face.readGlyphs(options))\n            return false;\n        if (silf)\n        {\n            if (!face.readFeatures() || !face.readGraphite(silf))\n            {\n#if !defined GRAPHITE2_NTRACING\n                if (global_log)\n                {\n                    *global_log << json::object\n                        << \"type\" << \"fontload\"\n                        << \"failure\" << face.error()\n                        << \"context\" << face.error_context()\n                    << json::close;\n                }\n#endif\n                return false;\n            }\n            else\n                return true;\n        }\n        else\n            return options & gr_face_dumbRendering;\n    }", "target": 1}
{"code": "GIOChannel *net_connect_ip_ssl(IPADDR *ip, int port, IPADDR *my_ip, const char *cert, const char *pkey, const char *cafile, const char *capath, gboolean verify)\n{\n\tGIOChannel *handle, *ssl_handle;\n\thandle = net_connect_ip(ip, port, my_ip);\n\tif (handle == NULL)\n\t\treturn NULL;\n\tssl_handle  = irssi_ssl_get_iochannel(handle, cert, pkey, cafile, capath, verify);\n\tif (ssl_handle == NULL)\n\t\tg_io_channel_unref(handle);\n\treturn ssl_handle;\n}", "target": 1}
{"code": "disable_priv_mode ()\n{\n  int e;\n#if HAVE_DECL_SETRESUID\n  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n#else\n  if (setuid (current_user.uid) < 0)\n#endif\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n#if HAVE_DECL_SETRESGID\n  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n#else\n  if (setgid (current_user.gid) < 0)\n#endif\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}", "target": 0}
{"code": "Status OpLevelCostEstimator::PredictFusedBatchNormGrad(\n    const OpContext& op_context, NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(1).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  const auto rsqrt_cost = Eigen::internal::functor_traits<\n      Eigen::internal::scalar_rsqrt_op<float>>::Cost;\n  ops = dims.iz * (dims.batch * dims.ix * dims.iy * 11 + 5 + rsqrt_cost);\n  node_costs->num_compute_ops = ops;\n  const int64_t size_nhwc =\n      CalculateTensorSize(op_info.inputs(1), &found_unknown_shapes);\n  const int64_t size_c =\n      CalculateTensorSize(op_info.inputs(2), &found_unknown_shapes);\n  node_costs->num_input_bytes_accessed = {size_nhwc, size_nhwc, size_c, size_c};\n  node_costs->num_output_bytes_accessed = {size_nhwc, size_c, size_c};\n  node_costs->internal_read_bytes = size_nhwc;\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "void FormatConverter<T>::Populate(const T* src_data, std::vector<int> indices,\n                                  int level, int prev_idx, int* src_data_ptr,\n                                  T* dest_data) {\n  if (level == indices.size()) {\n    int orig_rank = dense_shape_.size();\n    std::vector<int> orig_idx;\n    orig_idx.resize(orig_rank);\n    int i = 0;\n    for (; i < orig_idx.size(); i++) {\n      int orig_dim = traversal_order_[i];\n      orig_idx[orig_dim] = indices[i];\n    }\n    for (; i < indices.size(); i++) {\n      const int block_idx = traversal_order_[i] - orig_rank;\n      const int orig_dim = block_map_[block_idx];\n      orig_idx[orig_dim] =\n          orig_idx[orig_dim] * block_size_[block_idx] + indices[i];\n    }\n    dest_data[GetFlattenedIndex(orig_idx, dense_shape_)] =\n        src_data[*src_data_ptr];\n    *src_data_ptr = *src_data_ptr + 1;\n    return;\n  }\n  const int metadata_idx = 2 * level;\n  const int shape_of_level = dim_metadata_[metadata_idx][0];\n  if (format_[level] == kTfLiteDimDense) {\n    for (int i = 0; i < shape_of_level; i++) {\n      indices[level] = i;\n      Populate(src_data, indices, level + 1, prev_idx * shape_of_level + i,\n               src_data_ptr, dest_data);\n    }\n  } else {\n    const auto& array_segments = dim_metadata_[metadata_idx];\n    const auto& array_indices = dim_metadata_[metadata_idx + 1];\n    for (int i = array_segments[prev_idx]; i < array_segments[prev_idx + 1];\n         i++) {\n      indices[level] = array_indices[i];\n      Populate(src_data, indices, level + 1, i, src_data_ptr, dest_data);\n    }\n  }\n}", "target": 1}
{"code": "dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,\n\t\t\t  proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n\tguint32 size;\n\tint end_offset;\n\tif (di->conformant_run)\n\t\treturn offset;\n\toffset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,\n\t\t\t\t    hf_keybuffer_size, &size);\n\tend_offset = offset + (size*2);\n\tif (end_offset < offset) {\n\t\tend_offset = tvb_reported_length_remaining(tvb, offset) + 1;\n\t}\n\twhile (offset < end_offset)\n\t\toffset = dissect_spoolss_uint16uni(\n\t\t\ttvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);\n\treturn offset;\n}", "target": 1}
{"code": "static int selinux_sb_remount(struct super_block *sb, void *mnt_opts)\n{\n\tstruct selinux_mnt_opts *opts = mnt_opts;\n\tstruct superblock_security_struct *sbsec = sb->s_security;\n\tu32 sid;\n\tint rc;\n\tif (!(sbsec->flags & SE_SBINITIALIZED))\n\t\treturn 0;\n\tif (!opts)\n\t\treturn 0;\n\tif (opts->fscontext) {\n\t\trc = parse_sid(sb, opts->fscontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, FSCONTEXT_MNT, sbsec->sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->context) {\n\t\trc = parse_sid(sb, opts->context, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, CONTEXT_MNT, sbsec->mntpoint_sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->rootcontext) {\n\t\tstruct inode_security_struct *root_isec;\n\t\troot_isec = backing_inode_security(sb->s_root);\n\t\trc = parse_sid(sb, opts->rootcontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, ROOTCONTEXT_MNT, root_isec->sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\tif (opts->defcontext) {\n\t\trc = parse_sid(sb, opts->defcontext, &sid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (bad_option(sbsec, DEFCONTEXT_MNT, sbsec->def_sid, sid))\n\t\t\tgoto out_bad_option;\n\t}\n\treturn 0;\nout_bad_option:\n\tpr_warn(\"SELinux: unable to change security options \"\n\t       \"during remount (dev %s, type=%s)\\n\", sb->s_id,\n\t       sb->s_type->name);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "SSecurityTLS::SSecurityTLS(bool _anon) : session(0), dh_params(0),\n\t\t\t\t\t\t anon_cred(0), cert_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  certfile = X509_CertFile.getData();\n  keyfile = X509_KeyFile.getData();\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}", "target": 0}
{"code": "int mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n    return MONGO_OK;\n}", "target": 1}
{"code": "Bool gf_isom_has_time_offset_table(GF_ISOFile *the_file, u32 trackNumber)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media->information->sampleTable->CompositionOffset) return GF_FALSE;\n\treturn GF_TRUE;\n}", "target": 0}
{"code": "static struct ast_sip_endpoint *ip_identify(pjsip_rx_data *rdata)\n{\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tast_sockaddr_parse(&addr_with_tp.addr, rdata->pkt_info.src_name, PARSE_PORT_FORBID);\n\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->pkt_info.src_port);\n\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n}", "target": 1}
{"code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  int batches = input->dims->data[0];\n  int height = input->dims->data[1];\n  int width = input->dims->data[2];\n  int channels_out = input->dims->data[3];\n  auto padding = params->padding;\n  int out_width, out_height;\n  TF_LITE_ENSURE(context, params->stride_height > 0);\n  TF_LITE_ENSURE(context, params->stride_width > 0);\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      params->filter_height, params->filter_width, padding, &out_height,\n      &out_width);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    if (pool_type == kAverage || pool_type == kMax) {\n      TFLITE_DCHECK_LE(std::abs(input->params.scale - output->params.scale),\n                       1.0e-6);\n      TFLITE_DCHECK_EQ(input->params.zero_point, output->params.zero_point);\n    }\n    if (pool_type == kL2) {\n      TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n    }\n  }\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = batches;\n  output_size->data[1] = out_height;\n  output_size->data[2] = out_width;\n  output_size->data[3] = channels_out;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 0}
{"code": "void HTTPServer::handleRequest(Client *cl, HTTPRequest* req) {\n\tif (!req->parse()) {\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] There was an error processing the request of type: \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tstd::cout << req->getParseError() << std::endl;\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), req->getParseError());\n\t\treturn;\n\t}\n\tstd::cout << \"[\" << cl->getClientIP() << \"] \" << req->methodIntToStr(req->getMethod()) << \" \" << req->getRequestUri() << std::endl;\n\tResourceHost* resHost = NULL;\n\tstd::string host = \"\";\n\tif (req->getVersion().compare(HTTP_VERSION_11) == 0) {\n\t\thost = req->getHeaderValue(\"Host\");\n\t\tif (host.find(\":\") == std::string::npos) {\n\t\t\thost.append(\":\" + std::to_string(listenPort));\n\t\t}\n\t\tstd::unordered_map<std::string, ResourceHost*>::const_iterator it = vhosts.find(host);\n\t\tif (it != vhosts.end())\n\t\t\tresHost = it->second;\n\t} else {\n\t\tif (hostList.size() > 0)\n\t\t\tresHost = hostList[0];\n\t}\n\tif (resHost == NULL) {\n\t\tsendStatusResponse(cl, Status(BAD_REQUEST), \"Invalid/No Host specified: \" + host);\n\t\treturn;\n\t}\n\tswitch (req->getMethod()) {\n\tcase Method(HEAD):\n\tcase Method(GET):\n\t\thandleGet(cl, req, resHost);\n\t\tbreak;\n\tcase Method(OPTIONS):\n\t\thandleOptions(cl, req);\n\t\tbreak;\n\tcase Method(TRACE):\n\t\thandleTrace(cl, req);\n\t\tbreak;\n\tdefault:\n\t\tstd::cout << \"[\" << cl->getClientIP() << \"] Could not handle or determine request of type \" << req->methodIntToStr(req->getMethod()) << std::endl;\n\t\tsendStatusResponse(cl, Status(NOT_IMPLEMENTED));\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}", "target": 0}
{"code": "static int update_header(void *obj)\n{\n\tstruct header_data *data = obj;\n\tpjsip_hdr *hdr = NULL;\n\tRAII_VAR(struct ast_datastore *, datastore,\n\t\t\t ast_sip_session_get_datastore(data->channel->session, data->header_datastore->type),\n\t\t\t ao2_cleanup);\n\tif (!datastore || !datastore->data) {\n\t\tast_log(AST_LOG_ERROR, \"No headers had been previously added to this session.\\n\");\n\t\treturn -1;\n\t}\n\thdr = find_header((struct hdr_list *) datastore->data, data->header_name,\n\t\t\t\t\t  data->header_number);\n\tif (!hdr) {\n\t\tast_log(AST_LOG_ERROR, \"There was no header named %s.\\n\", data->header_name);\n\t\treturn -1;\n\t}\n\tpj_strcpy2(&((pjsip_generic_string_hdr *) hdr)->hvalue, data->header_value);\n\treturn 0;\n}", "target": 1}
{"code": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\tgenlmsg_end(msg, hdr);\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\treturn 0;\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "cmyk_to_rgb(JSAMPLE c, JSAMPLE m, JSAMPLE y, JSAMPLE k, JSAMPLE *r, JSAMPLE *g,\n            JSAMPLE *b)\n{\n  *r = (JSAMPLE)((double)c * (double)k / 255.0 + 0.5);\n  *g = (JSAMPLE)((double)m * (double)k / 255.0 + 0.5);\n  *b = (JSAMPLE)((double)y * (double)k / 255.0 + 0.5);\n}", "target": 0}
{"code": "imapx_untagged_list (CamelIMAPXServer *is,\n                     GInputStream *input_stream,\n                     GCancellable *cancellable,\n                     GError **error)\n{\n\tCamelIMAPXListResponse *response;\n\tCamelIMAPXStore *imapx_store;\n\tconst gchar *mailbox_name;\n\tgchar separator;\n\tg_return_val_if_fail (CAMEL_IS_IMAPX_SERVER (is), FALSE);\n\tresponse = camel_imapx_list_response_new (\n\t\tCAMEL_IMAPX_INPUT_STREAM (input_stream), cancellable, error);\n\tif (response == NULL)\n\t\treturn FALSE;\n\tmailbox_name = camel_imapx_list_response_get_mailbox_name (response);\n\tseparator = camel_imapx_list_response_get_separator (response);\n\tif (camel_imapx_mailbox_is_inbox (mailbox_name))\n\t\tis->priv->inbox_separator = separator;\n\timapx_store = camel_imapx_server_ref_store (is);\n\tcamel_imapx_store_handle_list_response (imapx_store, is, response);\n\tg_clear_object (&imapx_store);\n\tg_clear_object (&response);\n\treturn TRUE;\n}", "target": 0}
{"code": "deltas_head_create(struct deltas_head **deltas)\n{\n\tstruct deltas_head *tmp;\n\ttmp = malloc(sizeof(struct deltas_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdeltas_head_init(tmp);\n\t*deltas = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "int delete_sdp_line( struct sip_msg * msg, char * s)\n{\n\tchar * start,*end;\n\tif( !s )\n\t\treturn 1;\n\tstart = s;\n\tend  = s;\n\twhile(*start != '\\n')\n\t\tstart--;\n\tstart++;\n\twhile(*end != '\\n')\n\t\tend++;\n\tend++;\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    DelogoContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    AVFrame *out;\n    int hsub0 = desc->log2_chroma_w;\n    int vsub0 = desc->log2_chroma_h;\n    int direct = 0;\n    int plane;\n    AVRational sar;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    sar = in->sample_aspect_ratio;\n    if (!sar.num)\n        sar.num = sar.den = 1;\n    for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n        int hsub = plane == 1 || plane == 2 ? hsub0 : 0;\n        int vsub = plane == 1 || plane == 2 ? vsub0 : 0;\n        apply_delogo(out->data[plane], out->linesize[plane],\n                     in ->data[plane], in ->linesize[plane],\n                     FF_CEIL_RSHIFT(inlink->w, hsub),\n                     FF_CEIL_RSHIFT(inlink->h, vsub),\n                     sar, s->x>>hsub, s->y>>vsub,\n                     FF_CEIL_RSHIFT(s->w + (s->x & ((1<<hsub)-1)), hsub),\n                     FF_CEIL_RSHIFT(s->h + (s->y & ((1<<vsub)-1)), vsub),\n                     s->band>>FFMIN(hsub, vsub),\n                     s->show, direct);\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "void sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){\n  assert( bFree==0 || (pParse->pWith==0 && pParse->pWithToFree==0) );\n  if( pWith ){\n    assert( pParse->pWith!=pWith );\n    pWith->pOuter = pParse->pWith;\n    pParse->pWith = pWith;\n    if( bFree ) pParse->pWithToFree = pWith;\n  }\n}", "target": 0}
{"code": "static void JP2WarningHandler(const char *message,void *client_data)\n{\n  ExceptionInfo\n    *exception;\n  exception=(ExceptionInfo *) client_data;\n  (void) ThrowMagickException(exception,GetMagickModule(),CoderWarning,\n    message,\"`%s'\",\"OpenJP2\");\n}", "target": 0}
{"code": "static void do_free_publickey(struct rsa_public_key *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n}", "target": 1}
{"code": "void test_creat(const char *path)\n{\n\tif (creat(path, 0755) >= 0) {\n\t\tfprintf(stderr, \"leak at creat of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at creat of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "smtp_get_interface(uschar *istring, int host_af, address_item *addr,\n  uschar **interface, uschar *msg)\n{\nconst uschar * expint;\nuschar *iface;\nint sep = 0;\nif (!istring) return TRUE;\nif (!(expint = expand_string(istring)))\n  {\n  if (f.expand_string_forcedfail) return TRUE;\n  addr->transport_return = PANIC;\n  addr->message = string_sprintf(\"failed to expand \\\"interface\\\" \"\n      \"option for %s: %s\", msg, expand_string_message);\n  return FALSE;\n  }\nwhile (isspace(*expint)) expint++;\nif (*expint == 0) return TRUE;\nwhile ((iface = string_nextinlist(&expint, &sep, big_buffer,\n          big_buffer_size)))\n  {\n  if (string_is_ip_address(iface, NULL) == 0)\n    {\n    addr->transport_return = PANIC;\n    addr->message = string_sprintf(\"\\\"%s\\\" is not a valid IP \"\n      \"address for the \\\"interface\\\" option for %s\",\n      iface, msg);\n    return FALSE;\n    }\n  if (((Ustrchr(iface, ':') == NULL)? AF_INET:AF_INET6) == host_af)\n    break;\n  }\nif (iface) *interface = string_copy(iface);\nreturn TRUE;\n}", "target": 0}
{"code": "void GfxState::shiftCTMAndClip(double tx, double ty)\n{\n    ctm[4] += tx;\n    ctm[5] += ty;\n    clipXMin += tx;\n    clipYMin += ty;\n    clipXMax += tx;\n    clipYMax += ty;\n}", "target": 0}
{"code": "NavigatorServiceWorker* NavigatorServiceWorker::from(Document& document)\n{\n    if (!document.frame() || !document.frame()->domWindow())\n        return nullptr;\n    Navigator& navigator = *document.frame()->domWindow()->navigator();\n    return &from(navigator);\n}", "target": 0}
{"code": "void LogOmniboxZeroSuggestRequest(\n    ZeroSuggestRequestsHistogramValue request_value) {\n  UMA_HISTOGRAM_ENUMERATION(\"Omnibox.ZeroSuggestRequests\", request_value,\n                            ZERO_SUGGEST_MAX_REQUEST_HISTOGRAM_VALUE);\n}", "target": 0}
{"code": "pf_remove_divert_state(struct pf_state_key *sk)\n{\n\tstruct pf_state_item\t*si;\n\tPF_ASSERT_UNLOCKED();\n\tPF_LOCK();\n\tPF_STATE_ENTER_WRITE();\n\tTAILQ_FOREACH(si, &sk->sk_states, si_entry) {\n\t\tstruct pf_state *sist = si->si_st;\n\t\tif (sk == sist->key[PF_SK_STACK] && sist->rule.ptr &&\n\t\t    (sist->rule.ptr->divert.type == PF_DIVERT_TO ||\n\t\t     sist->rule.ptr->divert.type == PF_DIVERT_REPLY)) {\n\t\t\tif (sist->key[PF_SK_STACK]->proto == IPPROTO_TCP &&\n\t\t\t    sist->key[PF_SK_WIRE] != sist->key[PF_SK_STACK]) {\n\t\t\t\tif (sist->src.state < TCPS_FIN_WAIT_2 ||\n\t\t\t\t    sist->dst.state < TCPS_FIN_WAIT_2) {\n\t\t\t\t\tpf_set_protostate(sist, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_TIME_WAIT);\n\t\t\t\t\tsist->timeout = PFTM_TCP_CLOSED;\n\t\t\t\t\tsist->expire = getuptime();\n\t\t\t\t}\n\t\t\t\tsist->state_flags |= PFSTATE_INP_UNLINKED;\n\t\t\t} else\n\t\t\t\tpf_remove_state(sist);\n\t\t\tbreak;\n\t\t}\n\t}\n\tPF_STATE_EXIT_WRITE();\n\tPF_UNLOCK();\n}", "target": 1}
{"code": "cdf_tole2(uint16_t sv)\n{\n\treturn CDF_TOLE2(sv);\n}", "target": 0}
{"code": "storagePoolGetXMLDesc(virStoragePoolPtr pool,\n                      unsigned int flags)\n{\n    virStoragePoolObj *obj;\n    virStoragePoolDef *def;\n    virStoragePoolDef *newDef;\n    virStoragePoolDef *curDef;\n    char *ret = NULL;\n    virCheckFlags(VIR_STORAGE_XML_INACTIVE, NULL);\n    if (!(obj = virStoragePoolObjFromStoragePool(pool)))\n        return NULL;\n    def = virStoragePoolObjGetDef(obj);\n    newDef = virStoragePoolObjGetNewDef(obj);\n    if (virStoragePoolGetXMLDescEnsureACL(pool->conn, def) < 0)\n        goto cleanup;\n    if ((flags & VIR_STORAGE_XML_INACTIVE) && newDef)\n        curDef = newDef;\n    else\n        curDef = def;\n    ret = virStoragePoolDefFormat(curDef);\n cleanup:\n    virStoragePoolObjEndAPI(&obj);\n    return ret;\n}", "target": 0}
{"code": "static void Sp_split_regexp(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint limit, len, k;\n\tconst char *p, *a, *b, *c, *e;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tre = js_toregexp(J, 1);\n\tlimit = js_isdefined(J, 2) ? js_tointeger(J, 2) : 1 << 30;\n\tjs_newarray(J);\n\tlen = 0;\n\te = text + strlen(text);\n\tif (e == text) {\n\t\tif (js_regexec(re->prog, text, &m, 0)) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushliteral(J, \"\");\n\t\t\tjs_setindex(J, -2, 0);\n\t\t}\n\t\treturn;\n\t}\n\tp = a = text;\n\twhile (a < e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak; \n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\t\tif (b == p) {\n\t\t\t++a;\n\t\t\tcontinue;\n\t\t}\n\t\tif (len == limit) return;\n\t\tjs_pushlstring(J, p, b - p);\n\t\tjs_setindex(J, -2, len++);\n\t\tfor (k = 1; k < m.nsub; ++k) {\n\t\t\tif (len == limit) return;\n\t\t\tjs_pushlstring(J, m.sub[k].sp, m.sub[k].ep - m.sub[k].sp);\n\t\t\tjs_setindex(J, -2, len++);\n\t\t}\n\t\ta = p = c;\n\t}\n\tif (len == limit) return;\n\tjs_pushstring(J, p);\n\tjs_setindex(J, -2, len);\n}", "target": 1}
{"code": "static void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\tif (!skb->data_len)\n\t\tgoto done;\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}", "target": 0}
{"code": "static GF_Err mp4_mux_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);\n\tif (is_remove) {\n\t\tTrackWriter *tkw = gf_filter_pid_get_udta(pid);\n\t\tif (tkw) {\n\t\t\tgf_list_del_item(ctx->tracks, tkw);\n\t\t\tif (ctx->ref_tkw == tkw) ctx->ref_tkw = gf_list_get(ctx->tracks, 0);\n\t\t\tgf_free(tkw);\n\t\t}\n\t\tif (ctx->opid && !gf_list_count(ctx->tracks)) {\n\t\t\tif (ctx->file) {\n\t\t\t\tif (!ctx->init_movie_done) {\n\t\t\t\t\tmp4_mux_done(ctx, GF_TRUE);\n\t\t\t\t}\n\t\t\t} else {\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\t\twhile (ctx->flush_size) {\n\t\t\t\t\tGF_Err e = mp4_mux_flush_fragmented(ctx);\n\t\t\t\t\tif (e) break;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\tgf_filter_pid_remove(ctx->opid);\n\t\t\tctx->opid = NULL;\n\t\t}\n\t\treturn GF_OK;\n\t}\n\treturn mp4_mux_setup_pid(filter, pid, GF_TRUE);\n}", "target": 0}
{"code": "static inline int mystrcmp(char **p, const char *sample)\n{\n    int len = strlen(sample);\n    if (strncmp(*p, sample, len) == 0) {\n        (*p) += len;\n        return 1;\n    } else\n        return 0;\n}", "target": 0}
{"code": "rdr_notification_ctx_cleanup(struct rdr_notification_ctx *ctx)\n{\n\tif (ctx->deltas.array != NULL)\n\t\tdeltas_parsed_cleanup(&ctx->deltas, __delta_head_destroy);\n}", "target": 1}
{"code": "pixBlockconv(PIX     *pix,\n             l_int32  wc,\n             l_int32  hc)\n{\nl_int32  w, h, d;\nPIX     *pixs, *pixd, *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\n    PROCNAME(\"pixBlockconv\");\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pix);\n    if ((d == 2 || d == 4 || d == 8) && pixGetColormap(pix)) {\n        L_WARNING(\"pix has colormap; removing\\n\", procName);\n        pixs = pixRemoveColormap(pix, REMOVE_CMAP_BASED_ON_SRC);\n        d = pixGetDepth(pixs);\n    } else {\n        pixs = pixClone(pix);\n    }\n    if (d != 8 && d != 32) {\n        pixDestroy(&pixs);\n        return (PIX *)ERROR_PTR(\"depth not 8 or 32 bpp\", procName, NULL);\n    }\n    if (d == 8) {\n        pixd = pixBlockconvGray(pixs, NULL, wc, hc);\n    } else { \n        pixr = pixGetRGBComponent(pixs, COLOR_RED);\n        pixrc = pixBlockconvGray(pixr, NULL, wc, hc);\n        pixDestroy(&pixr);\n        pixg = pixGetRGBComponent(pixs, COLOR_GREEN);\n        pixgc = pixBlockconvGray(pixg, NULL, wc, hc);\n        pixDestroy(&pixg);\n        pixb = pixGetRGBComponent(pixs, COLOR_BLUE);\n        pixbc = pixBlockconvGray(pixb, NULL, wc, hc);\n        pixDestroy(&pixb);\n        pixd = pixCreateRGBImage(pixrc, pixgc, pixbc);\n        pixDestroy(&pixrc);\n        pixDestroy(&pixgc);\n        pixDestroy(&pixbc);\n    }\n    pixDestroy(&pixs);\n    return pixd;\n}", "target": 1}
{"code": "daemon_linux_lvm2_lv_remove_authorized_cb (Daemon *daemon,\n                                           Device *device,\n                                           DBusGMethodInvocation *context,\n                                           const gchar *action_id,\n                                           guint num_user_data,\n                                           gpointer *user_data_elements)\n{\n  const gchar *group_uuid = user_data_elements[0];\n  const gchar *uuid = user_data_elements[1];\n  gchar *lv_name;\n  guint n;\n  gchar *argv[10];\n  lv_name = find_lvm2_lv_name_for_uuids (daemon, group_uuid, uuid);\n  if (lv_name == NULL)\n    {\n      throw_error (context, ERROR_FAILED, \"Cannot find LV with UUID `%s'\", uuid);\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"lvremove\";\n  argv[n++] = lv_name;\n  argv[n++] = \"--force\";\n  argv[n++] = NULL;\n  if (!job_new (context, \"LinuxLvm2LVRemove\", TRUE, NULL, argv, NULL, linux_lvm2_lv_remove_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  g_free (lv_name);\n}", "target": 0}
{"code": "sf_open_virtual\t(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)\n{\tSF_PRIVATE \t*psf ;\n\tif (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_read in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)\n\t{\tsf_errno = SFE_BAD_VIRTUAL_IO ;\n\t\tsnprintf (sf_parselog, sizeof (sf_parselog), \"Bad vio_write in SF_VIRTUAL_IO struct.\\n\") ;\n\t\treturn NULL ;\n\t\t} ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tpsf->virtual_io = SF_TRUE ;\n\tpsf->vio = *sfvirtual ;\n\tpsf->vio_user_data = user_data ;\n\tpsf->file.mode = mode ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "    template<typename t>\n    CImg<T>& convolve(const CImg<t>& kernel, const bool boundary_conditions=true, const bool is_normalized=false) {\n      if (is_empty() || !kernel) return *this;\n      return get_convolve(kernel,boundary_conditions,is_normalized).move_to(*this);", "target": 0}
{"code": "static int umocktypes_are_equal_FLOW_HANDLE(FLOW_HANDLE* left, FLOW_HANDLE* right)\n{\n    int result;\n    if (*left == *right)\n    {\n        result = 1;\n    }\n    else\n    {\n        result = 0;\n    }\n    return result;\n}", "target": 0}
{"code": "int CommandData::IsProcessFile(FileHeader &FileHead,bool *ExactMatch,int MatchType,\n                               wchar *MatchedArg,uint MatchedArgSize)\n{\n  if (MatchedArg!=NULL && MatchedArgSize>0)\n    *MatchedArg=0;\n  if (wcslen(FileHead.FileName)>=NM)\n    return 0;\n  bool Dir=FileHead.Dir;\n  if (ExclCheck(FileHead.FileName,Dir,false,true))\n    return 0;\n#ifndef SFX_MODULE\n  if (TimeCheck(FileHead.mtime))\n    return 0;\n  if ((FileHead.FileAttr & ExclFileAttr)!=0 || InclAttrSet && (FileHead.FileAttr & InclFileAttr)==0)\n    return 0;\n  if (!Dir && SizeCheck(FileHead.UnpSize))\n    return 0;\n#endif\n  wchar *ArgName;\n  FileArgs.Rewind();\n  for (int StringCount=1;(ArgName=FileArgs.GetString())!=NULL;StringCount++)\n    if (CmpName(ArgName,FileHead.FileName,MatchType))\n    {\n      if (ExactMatch!=NULL)\n        *ExactMatch=wcsicompc(ArgName,FileHead.FileName)==0;\n      if (MatchedArg!=NULL)\n        wcsncpyz(MatchedArg,ArgName,MatchedArgSize);\n      return StringCount;\n    }\n  return 0;\n}", "target": 1}
{"code": "bool OSD::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t       int protocol, bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t       bool& isvalid, CryptoKey& session_key)\n{\n  AuthAuthorizeHandler *authorize_handler = 0;\n  switch (peer_type) {\n  case CEPH_ENTITY_TYPE_MDS:\n  case CEPH_ENTITY_TYPE_OSD:\n  case CEPH_ENTITY_TYPE_MGR:\n    authorize_handler = authorize_handler_cluster_registry->get_handler(protocol);\n    break;\n  default:\n    authorize_handler = authorize_handler_service_registry->get_handler(protocol);\n  }\n  if (!authorize_handler) {\n    dout(0) << \"No AuthAuthorizeHandler found for protocol \" << protocol << dendl;\n    isvalid = false;\n    return true;\n  }\n  AuthCapsInfo caps_info;\n  EntityName name;\n  uint64_t global_id;\n  uint64_t auid = CEPH_AUTH_UID_DEFAULT;\n  RotatingKeyRing *keys = monc->rotating_secrets.get();\n  if (keys) {\n    isvalid = authorize_handler->verify_authorizer(\n      cct, keys,\n      authorizer_data, authorizer_reply, name, global_id, caps_info, session_key,\n      &auid);\n  } else {\n    dout(10) << __func__ << \" no rotating_keys (yet), denied\" << dendl;\n    isvalid = false;\n  }\n  if (isvalid) {\n    Session *s = static_cast<Session *>(con->get_priv());\n    if (!s) {\n      s = new Session(cct);\n      con->set_priv(s->get());\n      s->con = con;\n      dout(10) << \" new session \" << s << \" con=\" << s->con << \" addr=\" << s->con->get_peer_addr() << dendl;\n    }\n    s->entity_name = name;\n    if (caps_info.allow_all)\n      s->caps.set_allow_all();\n    s->auid = auid;\n    if (caps_info.caps.length() > 0) {\n      bufferlist::iterator p = caps_info.caps.begin();\n      string str;\n      try {\n\t::decode(str, p);\n      }\n      catch (buffer::error& e) {\n      }\n      bool success = s->caps.parse(str);\n      if (success)\n\tdout(10) << \" session \" << s << \" \" << s->entity_name << \" has caps \" << s->caps << \" '\" << str << \"'\" << dendl;\n      else\n\tdout(10) << \" session \" << s << \" \" << s->entity_name << \" failed to parse caps '\" << str << \"'\" << dendl;\n    }\n    s->put();\n  }\n  return true;\n}", "target": 1}
{"code": "void schi_box_del(GF_Box *s)\n{\n\tgf_free(s);\n}", "target": 0}
{"code": "static int get_filter(void __user *arg, struct sock_filter **p)\n{\n\tstruct sock_fprog uprog;\n\tstruct sock_filter *code = NULL;\n\tint len;\n\tif (copy_from_user(&uprog, arg, sizeof(uprog)))\n\t\treturn -EFAULT;\n\tif (!uprog.len) {\n\t\t*p = NULL;\n\t\treturn 0;\n\t}\n\tlen = uprog.len * sizeof(struct sock_filter);\n\tcode = memdup_user(uprog.filter, len);\n\tif (IS_ERR(code))\n\t\treturn PTR_ERR(code);\n\t*p = code;\n\treturn uprog.len;\n}", "target": 0}
{"code": "nfs4_atomic_open(struct inode *dir, struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct dentry *parent;\n\tstruct iattr attr;\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tstruct dentry *res;\n\tif (nd->flags & LOOKUP_CREATE) {\n\t\tattr.ia_mode = nd->intent.open.create_mode;\n\t\tattr.ia_valid = ATTR_MODE;\n\t\tif (!IS_POSIXACL(dir))\n\t\t\tattr.ia_mode &= ~current->fs->umask;\n\t} else {\n\t\tattr.ia_valid = 0;\n\t\tBUG_ON(nd->intent.open.flags & O_CREAT);\n\t}\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn (struct dentry *)cred;\n\tparent = dentry->d_parent;\n\tnfs_block_sillyrename(parent);\n\tstate = nfs4_do_open(dir, &path, nd->intent.open.flags, &attr, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tif (PTR_ERR(state) == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\t}\n\t\tnfs_unblock_sillyrename(parent);\n\t\treturn (struct dentry *)state;\n\t}\n\tres = d_add_unique(dentry, igrab(state->inode));\n\tif (res != NULL)\n\t\tpath.dentry = res;\n\tnfs_set_verifier(path.dentry, nfs_save_change_attribute(dir));\n\tnfs_unblock_sillyrename(parent);\n\tnfs4_intent_set_file(nd, &path, state);\n\treturn res;\n}", "target": 1}
{"code": "int mb2_cache_entry_create(struct mb2_cache *cache, gfp_t mask, u32 key,\n\t\t\t   sector_t block)\n{\n\tstruct mb2_cache_entry *entry, *dup;\n\tstruct hlist_bl_node *dup_node;\n\tstruct hlist_bl_head *head;\n\tentry = kmem_cache_alloc(mb2_entry_cache, mask);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(&entry->e_lru_list);\n\tatomic_set(&entry->e_refcnt, 1);\n\tentry->e_key = key;\n\tentry->e_block = block;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\tentry->e_hash_list_head = head;\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(dup, dup_node, head, e_hash_list) {\n\t\tif (dup->e_key == key && dup->e_block == block) {\n\t\t\thlist_bl_unlock(head);\n\t\t\tkmem_cache_free(mb2_entry_cache, entry);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\thlist_bl_add_head(&entry->e_hash_list, head);\n\thlist_bl_unlock(head);\n\tspin_lock(&cache->c_lru_list_lock);\n\tlist_add_tail(&entry->e_lru_list, &cache->c_lru_list);\n\tatomic_inc(&entry->e_refcnt);\n\tcache->c_entry_count++;\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static int crypto_report_acomp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_acomp racomp;\n\tstrlcpy(racomp.type, \"acomp\", sizeof(racomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_ACOMP,\n\t\t    sizeof(struct crypto_report_acomp), &racomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}", "target": 1}
{"code": "SQLWCHAR* _single_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( sizeof( SQLWCHAR ) * ( len + 1 ));\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "CURLcode Curl_auth_create_plain_message(struct Curl_easy *data,\n                                        const char *userp,\n                                        const char *passwdp,\n                                        char **outptr, size_t *outlen)\n{\n  CURLcode result;\n  char *plainauth;\n  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n  if((ulen > SIZE_T_MAX/2) || (plen > (SIZE_T_MAX/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';\n  memcpy(plainauth + ulen + 1, userp, ulen);\n  plainauth[2 * ulen + 1] = '\\0';\n  memcpy(plainauth + 2 * ulen + 2, passwdp, plen);\n  result = Curl_base64_encode(data, plainauth, plainlen, outptr, outlen);\n  free(plainauth);\n  return result;\n}", "target": 1}
{"code": "static int cqspi_setup_flash(struct cqspi_st *cqspi, struct device_node *np)\n{\n\tstruct platform_device *pdev = cqspi->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct cqspi_flash_pdata *f_pdata;\n\tstruct spi_nor *nor;\n\tstruct mtd_info *mtd;\n\tunsigned int cs;\n\tint i, ret;\n\tfor_each_available_child_of_node(dev->of_node, np) {\n\t\tif (of_property_read_u32(np, \"reg\", &cs)) {\n\t\t\tdev_err(dev, \"Couldn't determine chip select.\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tif (cs > CQSPI_MAX_CHIPSELECT) {\n\t\t\tdev_err(dev, \"Chip select %d out of range.\\n\", cs);\n\t\t\tgoto err;\n\t\t}\n\t\tf_pdata = &cqspi->f_pdata[cs];\n\t\tf_pdata->cqspi = cqspi;\n\t\tf_pdata->cs = cs;\n\t\tret = cqspi_of_get_flash_pdata(pdev, f_pdata, np);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tnor = &f_pdata->nor;\n\t\tmtd = &nor->mtd;\n\t\tmtd->priv = nor;\n\t\tnor->dev = dev;\n\t\tspi_nor_set_flash_node(nor, np);\n\t\tnor->priv = f_pdata;\n\t\tnor->read_reg = cqspi_read_reg;\n\t\tnor->write_reg = cqspi_write_reg;\n\t\tnor->read = cqspi_read;\n\t\tnor->write = cqspi_write;\n\t\tnor->erase = cqspi_erase;\n\t\tnor->prepare = cqspi_prep;\n\t\tnor->unprepare = cqspi_unprep;\n\t\tmtd->name = devm_kasprintf(dev, GFP_KERNEL, \"%s.%d\",\n\t\t\t\t\t   dev_name(dev), cs);\n\t\tif (!mtd->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tret = spi_nor_scan(nor, NULL, SPI_NOR_QUAD);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = mtd_device_register(mtd, NULL, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tf_pdata->registered = true;\n\t}\n\treturn 0;\nerr:\n\tfor (i = 0; i < CQSPI_MAX_CHIPSELECT; i++)\n\t\tif (cqspi->f_pdata[i].registered)\n\t\t\tmtd_device_unregister(&cqspi->f_pdata[i].nor.mtd);\n\treturn ret;\n}", "target": 1}
{"code": "static ssize_t ucma_write(struct file *filp, const char __user *buf,\n\t\t\t  size_t len, loff_t *pos)\n{\n\tstruct ucma_file *file = filp->private_data;\n\tstruct rdma_ucm_cmd_hdr hdr;\n\tssize_t ret;\n\tif (WARN_ON_ONCE(!ib_safe_file_access(filp)))\n\t\treturn -EACCES;\n\tif (len < sizeof(hdr))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.cmd >= ARRAY_SIZE(ucma_cmd_table))\n\t\treturn -EINVAL;\n\tif (hdr.in + sizeof(hdr) > len)\n\t\treturn -EINVAL;\n\tif (!ucma_cmd_table[hdr.cmd])\n\t\treturn -ENOSYS;\n\tret = ucma_cmd_table[hdr.cmd](file, buf + sizeof(hdr), hdr.in, hdr.out);\n\tif (!ret)\n\t\tret = len;\n\treturn ret;\n}", "target": 0}
{"code": "void DCR_CLASS dcr_parse_riff(DCRAW* p)\n{\n\tunsigned i, size, end;\n\tchar tag[4], date[64], month[64];\n\tstatic const char mon[12][4] =\n\t{ \"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\" };\n\tstruct tm t;\n\tp->order = 0x4949;\n\tdcr_fread(p->obj_, tag, 4, 1);\n\tsize = dcr_get4(p);\n\tend = dcr_ftell(p->obj_) + size;\n\tif (!memcmp(tag,\"RIFF\",4) || !memcmp(tag,\"LIST\",4)) {\n\t\tdcr_get4(p);\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end)\n\t\t\tdcr_parse_riff(p);\n\t} else if (!memcmp(tag,\"nctg\",4)) {\n\t\twhile (dcr_ftell(p->obj_)+7 < (long)end) {\n\t\t\ti = dcr_get2(p);\n\t\t\tsize = dcr_get2(p);\n\t\t\tif ((i+1) >> 1 == 10 && size == 20)\n\t\t\t\tdcr_get_timestamp(p,0);\n\t\t\telse dcr_fseek(p->obj_, size, SEEK_CUR);\n\t\t}\n\t} else if (!memcmp(tag,\"IDIT\",4) && size < 64) {\n\t\tdcr_fread(p->obj_, date, 64, 1);\n\t\tdate[size] = 0;\n\t\tmemset (&t, 0, sizeof t);\n\t\tif (sscanf (date, \"%*s %s %d %d:%d:%d %d\", month, &t.tm_mday,\n\t\t\t&t.tm_hour, &t.tm_min, &t.tm_sec, &t.tm_year) == 6) {\n\t\t\tfor (i=0; i < 12 && strcasecmp(mon[i],month); i++);\n\t\t\tt.tm_mon = i;\n\t\t\tt.tm_year -= 1900;\n\t\t\tif (mktime(&t) > 0)\n\t\t\t\tp->timestamp = mktime(&t);\n\t\t}\n\t} else\n\t\tdcr_fseek(p->obj_, size, SEEK_CUR);\n}", "target": 1}
{"code": "static void dp8393x_instance_init(Object *obj)\n{\n    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);\n    dp8393xState *s = DP8393X(obj);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_mmio(sbd, &s->prom);\n    sysbus_init_irq(sbd, &s->irq);\n}", "target": 0}
{"code": "Eina_Bool ewk_view_disable_render(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api->disable_render, false);\n    return smartData->api->disable_render(smartData);\n}", "target": 0}
{"code": "  Logger* logger() {\n    ASSERT(logger_ != NULL);\n    return logger_;\n  }", "target": 0}
{"code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 1}
{"code": "sysName_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, \"Contiki-NG - \"CONTIKI_TARGET_STRING);\n}", "target": 1}
{"code": "void beforeSleep(struct aeEventLoop *eventLoop) {\n    REDIS_NOTUSED(eventLoop);\n    listNode *ln;\n    redisClient *c;\n    if (server.vm_enabled && listLength(server.io_ready_clients)) {\n        listIter li;\n        listRewind(server.io_ready_clients,&li);\n        while((ln = listNext(&li))) {\n            c = ln->value;\n            struct redisCommand *cmd;\n            listDelNode(server.io_ready_clients,ln);\n            c->flags &= (~REDIS_IO_WAIT);\n            server.vm_blocked_clients--;\n            aeCreateFileEvent(server.el, c->fd, AE_READABLE,\n                readQueryFromClient, c);\n            cmd = lookupCommand(c->argv[0]->ptr);\n            redisAssert(cmd != NULL);\n            call(c,cmd);\n            resetClient(c);\n            if (c->querybuf && sdslen(c->querybuf) > 0)\n                processInputBuffer(c);\n        }\n    }\n    while (listLength(server.unblocked_clients)) {\n        ln = listFirst(server.unblocked_clients);\n        redisAssert(ln != NULL);\n        c = ln->value;\n        listDelNode(server.unblocked_clients,ln);\n        if (c->querybuf && sdslen(c->querybuf) > 0)\n            processInputBuffer(c);\n    }\n    flushAppendOnlyFile();\n}", "target": 1}
{"code": "GopherStateData::iconUrl(const char gtype)\n{\n    switch (gtype) {\n    case GOPHER_DIRECTORY:\n        return mimeGetIconURL(\"internal-menu\");\n    case GOPHER_HTML:\n    case GOPHER_FILE:\n        return mimeGetIconURL(\"internal-text\");\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n        return mimeGetIconURL(\"internal-index\");\n    case GOPHER_IMAGE:\n    case GOPHER_GIF:\n    case GOPHER_PLUS_IMAGE:\n        return mimeGetIconURL(\"internal-image\");\n    case GOPHER_SOUND:\n    case GOPHER_PLUS_SOUND:\n        return mimeGetIconURL(\"internal-sound\");\n    case GOPHER_PLUS_MOVIE:\n        return mimeGetIconURL(\"internal-movie\");\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        return mimeGetIconURL(\"internal-telnet\");\n    case GOPHER_BIN:\n    case GOPHER_MACBINHEX:\n    case GOPHER_DOSBIN:\n    case GOPHER_UUENCODED:\n        return mimeGetIconURL(\"internal-binary\");\n    case GOPHER_INFO:\n        return nullptr;\n    case GOPHER_WWW:\n        return mimeGetIconURL(\"internal-link\");\n    default:\n        return mimeGetIconURL(\"internal-unknown\");\n    }\n}", "target": 1}
{"code": "static struct child_process *git_connect_git(int fd[2], char *hostandport,\n\t\t\t\t\t     const char *path, const char *prog,\n\t\t\t\t\t     enum protocol_version version,\n\t\t\t\t\t     int flags)\n{\n\tstruct child_process *conn;\n\tstruct strbuf request = STRBUF_INIT;\n\tchar *target_host = getenv(\"GIT_OVERRIDE_VIRTUAL_HOST\");\n\tif (target_host)\n\t\ttarget_host = xstrdup(target_host);\n\telse\n\t\ttarget_host = xstrdup(hostandport);\n\ttransport_check_allowed(\"git\");\n\tif (strchr(target_host, '\\n') || strchr(path, '\\n'))\n\t\tdie(_(\"newline is forbidden in git:\n\tif (git_use_proxy(hostandport))\n\t\tconn = git_proxy_connect(fd, hostandport);\n\telse\n\t\tconn = git_tcp_connect(fd, hostandport, flags);\n\tstrbuf_addf(&request,\n\t\t    \"%s %s%chost=%s%c\",\n\t\t    prog, path, 0,\n\t\t    target_host, 0);\n\tif (version > 0) {\n\t\tstrbuf_addch(&request, '\\0');\n\t\tstrbuf_addf(&request, \"version=%d%c\",\n\t\t\t    version, '\\0');\n\t}\n\tpacket_write(fd[1], request.buf, request.len);\n\tfree(target_host);\n\tstrbuf_release(&request);\n\treturn conn;\n}", "target": 0}
{"code": "static VncBasicInfoList *qmp_query_server_entry(int socket,\n                                                bool websocket,\n                                                VncBasicInfoList *prev)\n{\n    VncBasicInfoList *list;\n    VncBasicInfo *info;\n    struct sockaddr_storage sa;\n    socklen_t salen = sizeof(sa);\n    char host[NI_MAXHOST];\n    char serv[NI_MAXSERV];\n    if (getsockname(socket, (struct sockaddr *)&sa, &salen) < 0 ||\n        getnameinfo((struct sockaddr *)&sa, salen,\n                    host, sizeof(host), serv, sizeof(serv),\n                    NI_NUMERICHOST | NI_NUMERICSERV) < 0) {\n        return prev;\n    }\n    info = g_new0(VncBasicInfo, 1);\n    info->host = g_strdup(host);\n    info->service = g_strdup(serv);\n    info->family = inet_netfamily(sa.ss_family);\n    info->websocket = websocket;\n    list = g_new0(VncBasicInfoList, 1);\n    list->value = info;\n    list->next = prev;\n    return list;\n}", "target": 0}
{"code": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}", "target": 1}
{"code": "int sas_smp_get_phy_events(struct sas_phy *phy)\n{\n\tint res;\n\tu8 *req;\n\tu8 *resp;\n\tstruct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);\n\tstruct domain_device *dev = sas_find_dev_by_rphy(rphy);\n\treq = alloc_smp_req(RPEL_REQ_SIZE);\n\tif (!req)\n\t\treturn -ENOMEM;\n\tresp = alloc_smp_resp(RPEL_RESP_SIZE);\n\tif (!resp) {\n\t\tkfree(req);\n\t\treturn -ENOMEM;\n\t}\n\treq[1] = SMP_REPORT_PHY_ERR_LOG;\n\treq[9] = phy->number;\n\tres = smp_execute_task(dev, req, RPEL_REQ_SIZE,\n\t\t\t            resp, RPEL_RESP_SIZE);\n\tif (!res)\n\t\tgoto out;\n\tphy->invalid_dword_count = scsi_to_u32(&resp[12]);\n\tphy->running_disparity_error_count = scsi_to_u32(&resp[16]);\n\tphy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);\n\tphy->phy_reset_problem_count = scsi_to_u32(&resp[24]);\n out:\n\tkfree(req);\n\tkfree(resp);\n\treturn res;\n}", "target": 0}
{"code": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeDebugLocation(Expression* curr, Function* func) {\n  if (sourceMap) {\n    auto& debugLocations = func->debugLocations;\n    auto iter = debugLocations.find(curr);\n    if (iter != debugLocations.end()) {\n      writeDebugLocation(iter->second);\n    }\n  }\n  if (func && !func->expressionLocations.empty()) {\n    binaryLocations.expressions[curr] =\n      BinaryLocations::Span{BinaryLocation(o.size()), 0};\n    binaryLocationTrackedExpressionsForFunc.push_back(curr);\n  }\n}", "target": 0}
{"code": "fu_plugin_config_func(void)\n{\n\tGStatBuf statbuf = {0};\n\tgboolean ret;\n\tgint rc;\n\tg_autofree gchar *conf_dir = NULL;\n\tg_autofree gchar *conf_file = NULL;\n\tg_autofree gchar *fn = NULL;\n\tg_autofree gchar *testdatadir = NULL;\n\tg_autofree gchar *value = NULL;\n\tg_autoptr(FuPlugin) plugin = fu_plugin_new(NULL);\n\tg_autoptr(GError) error = NULL;\n\ttestdatadir = g_test_build_filename(G_TEST_BUILT, \"tests\", NULL);\n\t(void)g_setenv(\"FWUPD_SYSCONFDIR\", testdatadir, TRUE);\n\tconf_dir = fu_path_from_kind(FU_PATH_KIND_SYSCONFDIR_PKG);\n\tfu_plugin_set_name(plugin, \"test\");\n\tconf_file = g_strdup_printf(\"%s.conf\", fu_plugin_get_name(plugin));\n\tfn = g_build_filename(conf_dir, conf_file, NULL);\n\tret = fu_path_mkdir_parent(fn, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_remove(fn);\n\tret = g_file_set_contents(fn, \"\", -1, &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tret = fu_plugin_set_config_value(plugin, \"Key\", \"True\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\tg_assert_true(g_file_test(fn, G_FILE_TEST_EXISTS));\n\trc = g_stat(fn, &statbuf);\n\tg_assert_cmpint(rc, ==, 0);\n\tg_assert_cmpint(statbuf.st_mode & 0777, ==, 0644);\n\tvalue = fu_plugin_get_config_value(plugin, \"Key\");\n\tg_assert_cmpstr(value, ==, \"True\");\n\tg_assert_true(fu_plugin_get_config_value_boolean(plugin, \"Key\"));\n\tret = fu_plugin_set_secure_config_value(plugin, \"Key\", \"False\", &error);\n\tg_assert_no_error(error);\n\tg_assert_true(ret);\n\trc = g_stat(fn, &statbuf);\n\tg_assert_cmpint(rc, ==, 0);\n\tg_assert_cmpint(statbuf.st_mode & 0777, ==, 0640);\n}", "target": 0}
{"code": "int blkid_probe_invert_partitions_filter(blkid_probe pr)\n{\n\treturn __blkid_probe_invert_filter(pr, BLKID_CHAIN_PARTS);\n}", "target": 0}
{"code": "static int ip_setup_cork(struct sock *sk, struct inet_cork *cork,\n\t\t\t struct ipcm_cookie *ipc, struct rtable **rtp)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_options *opt;\n\tstruct rtable *rt;\n\topt = ipc->opt;\n\tif (opt) {\n\t\tif (cork->opt == NULL) {\n\t\t\tcork->opt = kmalloc(sizeof(struct ip_options) + 40,\n\t\t\t\t\t    sk->sk_allocation);\n\t\t\tif (unlikely(cork->opt == NULL))\n\t\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tmemcpy(cork->opt, opt, sizeof(struct ip_options) + opt->optlen);\n\t\tcork->flags |= IPCORK_OPT;\n\t\tcork->addr = ipc->addr;\n\t}\n\trt = *rtp;\n\tif (unlikely(!rt))\n\t\treturn -EFAULT;\n\t*rtp = NULL;\n\tcork->fragsize = inet->pmtudisc == IP_PMTUDISC_PROBE ?\n\t\t\t rt->dst.dev->mtu : dst_mtu(rt->dst.path);\n\tcork->dst = &rt->dst;\n\tcork->length = 0;\n\tcork->tx_flags = ipc->tx_flags;\n\tcork->page = NULL;\n\tcork->off = 0;\n\treturn 0;\n}", "target": 1}
{"code": "static void *arm_coherent_dma_alloc(struct device *dev, size_t size,\n\tdma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n\tvoid *memory;\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\treturn __dma_alloc(dev, size, handle, gfp, prot, true,\n\t\t\t   __builtin_return_address(0));\n}", "target": 1}
{"code": "  void AddBatchOffsets(Tensor* indices, const Tensor& params) {\n    int64_t batch_size = 1;  \n    for (int idx = 0; idx < batch_dims_; ++idx) {\n      batch_size *= params.dim_size(idx);\n    }\n    auto indices_flat = indices->flat<Index>();\n    int64_t const index_inner_size = indices->NumElements() / batch_size;\n    int64_t const batch_offset = params.dim_size(batch_dims_);\n    for (int64_t batch_idx = 0, dest_idx = 0; batch_idx < batch_size;\n         ++batch_idx) {\n      for (int64_t idx = 0; idx < index_inner_size; ++idx) {\n        indices_flat(dest_idx++) += batch_offset * batch_idx;\n      }\n    }\n  }", "target": 1}
{"code": "static u_int mp_dss_len(const  struct mp_dss *m, int csum)\n{\n        u_int len;\n        len = 4;\n        if (m->flags & MP_DSS_A) {\n                len += (m->flags & MP_DSS_a) ? 8 : 4;\n        }\n        if (m->flags & MP_DSS_M) {\n                len += (m->flags & MP_DSS_m) ? 14 : 10;\n                if (csum)\n                        len += 2;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "static int umocktypes_copy_bool_ptr(bool** destination, const bool** source)\n{\n    int result;\n    *destination = (bool*)my_gballoc_malloc(sizeof(bool));\n    if (*destination == NULL)\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        *(*destination) = *(*source);\n        result = 0;\n    }\n    return result;\n}", "target": 0}
{"code": "static inline int ealg_tmpl_set(const struct xfrm_tmpl *t,\n\t\t\t\tconst struct xfrm_algo_desc *d)\n{\n\tunsigned int id = d->desc.sadb_alg_id;\n\tif (id >= sizeof(t->ealgos) * 8)\n\t\treturn 0;\n\treturn (t->ealgos >> id) & 1;\n}", "target": 0}
{"code": "snmp_ber_decode_integer(unsigned char *buf, uint32_t *buff_len, uint32_t *num)\n{\n  uint8_t i, len, type;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != BER_DATA_TYPE_INTEGER) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL || len > 4) {\n    return NULL;\n  }\n  if(*buff_len < len) {\n    return NULL;\n  }\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n  return buf;\n}", "target": 1}
{"code": "void hrandfieldCommand(client *c) {\n    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n    hashTypeRandomElement(hash,hashTypeLength(hash),&ele,NULL);\n    hashReplyFromListpackEntry(c, &ele);\n}", "target": 1}
{"code": "static int dns_stream_complete(DnsStream *s, int error) {\n        _cleanup_(dns_stream_unrefp) _unused_ DnsStream *ref = dns_stream_ref(s); \n        assert(s);\n#if ENABLE_DNS_OVER_TLS\n        if (s->encrypted) {\n                int r;\n                r = dnstls_stream_shutdown(s, error);\n                if (r != -EAGAIN)\n                        dns_stream_stop(s);\n        } else\n#endif\n                dns_stream_stop(s);\n        if (s->complete)\n                s->complete(s, error);\n        else \n                dns_stream_unref(s);\n        return 0;\n}", "target": 0}
{"code": "acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)\n{\n\t*cache = kmem_cache_create(name, size, 0, 0, NULL);\n\tif (*cache == NULL)\n\t\treturn AE_ERROR;\n\telse\n\t\treturn AE_OK;\n}", "target": 0}
{"code": "passGetEmphasis ()\n{\n  int more = 1;\n  passLinepos++;\n  passEmphasis = 0;\n  while (more)\n    {\n      switch (passLine.chars[passLinepos])\n\t{\n\tcase 'i':\n\t  passEmphasis |= italic;\n\t  break;\n\tcase 'b':\n\t  passEmphasis |= bold;\n\t  break;\n\tcase 'u':\n\t  passEmphasis |= underline;\n\t  break;\n\tcase 'c':\n\t  passEmphasis |= computer_braille;\n\t  break;\n\tdefault:\n\t  more = 0;\n\t  break;\n\t}\n      if (more)\n\tpassLinepos++;\n    }\n  if (!passEmphasis)\n    {\n      compileError (passNested, \"emphasis indicators expected\");\n      passLinepos--;\n      return 0;\n    }\n  return 1;\n}", "target": 0}
{"code": "MemoryRegion *memory_map_ptr(struct uc_struct *uc, hwaddr begin, size_t size, uint32_t perms, void *ptr)\n{\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n    memory_region_init_ram_ptr(uc, ram, size, ptr);\n    ram->perms = perms;\n    if (ram->addr == -1) {\n        return NULL;\n    }\n    memory_region_add_subregion(uc->system_memory, begin, ram);\n    if (uc->cpu) {\n        tlb_flush(uc->cpu);\n    }\n    return ram;\n}", "target": 1}
{"code": "void M_LoadDefaults (void)\n{\n    int\t\ti;\n    int\t\tlen;\n    FILE*\tf;\n    char\tdef[80];\n    char\tstrparm[100];\n    char*\tnewstring;\n    int\t\tparm;\n    boolean\tisstring;\n    numdefaults = sizeof(defaults)/sizeof(defaults[0]);\n    for (i=0 ; i<numdefaults ; i++)\n\t*defaults[i].location = defaults[i].defaultvalue;\n    i = M_CheckParm (\"-config\");\n    if (i && i<myargc-1)\n    {\n\tdefaultfile = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",defaultfile);\n    }\n    else\n\tdefaultfile = basedefault;\n    f = fopen (defaultfile, \"r\");\n    if (f)\n    {\n\twhile (!feof(f))\n\t{\n\t    isstring = false;\n\t    if (fscanf (f, \"%79s %[^\\n]\\n\", def, strparm) == 2)\n\t    {\n\t\tif (strparm[0] == '\"')\n\t\t{\n\t\t    isstring = true;\n\t\t    len = strlen(strparm);\n\t\t    newstring = (char *) malloc(len);\n\t\t    strparm[len-1] = 0;\n\t\t    strcpy(newstring, strparm+1);\n\t\t}\n\t\telse if (strparm[0] == '0' && strparm[1] == 'x')\n\t\t    sscanf(strparm+2, \"%x\", &parm);\n\t\telse\n\t\t    sscanf(strparm, \"%i\", &parm);\n\t\tfor (i=0 ; i<numdefaults ; i++)\n\t\t    if (!strcmp(def, defaults[i].name))\n\t\t    {\n\t\t\tif (!isstring)\n\t\t\t    *defaults[i].location = parm;\n\t\t\telse\n\t\t\t    *defaults[i].location =\n\t\t\t\t(int) newstring;\n\t\t\tbreak;\n\t\t    }\n\t    }\n\t}\n\tfclose (f);\n    }\n    for (i = 0; i < numdefaults; i++)\n    {\n        if (defaults[i].scantranslate)\n        {\n            parm = *defaults[i].location;\n            defaults[i].untranslated = parm;\n            *defaults[i].location = scantokey[parm];\n        }\n    }\n}", "target": 1}
{"code": "std::set<std::string> getMounts(Computer * computer, const std::string& comp_path) {\n    std::vector<std::string> elems = split(comp_path, \"/\\\\\");\n    std::list<std::string> pathc;\n    std::set<std::string> retval;\n    for (std::string s : elems) {\n        if (s == \"..\") { if (pathc.empty()) return retval; else pathc.pop_back(); }\n        else if (!s.empty() && !std::all_of(s.begin(), s.end(), [](const char c)->bool{return c == '.';})) {\n            s.erase(std::remove_if(s.begin(), s.end(), [](char c)->bool{return c=='\"'||c==':'||c=='<'||c=='>'||c=='?'||c=='|';}), s.end());\n            pathc.push_back(s);\n        }\n    }\n    for (const auto& m : computer->mounts)\n        if (pathc.size() + 1 == std::get<0>(m).size() && std::equal(pathc.begin(), pathc.end(), std::get<0>(m).begin()))\n            retval.insert(std::get<0>(m).back());\n    return retval;\n}", "target": 1}
{"code": "static int decode_server_caps(struct xdr_stream *xdr, struct nfs4_server_caps_res *res)\n{\n\tunsigned int savep;\n\tuint32_t attrlen, bitmap[3] = {0};\n\tint status;\n\tif ((status = decode_op_hdr(xdr, OP_GETATTR)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_bitmap(xdr, bitmap)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_length(xdr, &attrlen, &savep)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_supported(xdr, bitmap, res->attr_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_fh_expire_type(xdr, bitmap,\n\t\t\t\t\t\t &res->fh_expire_type)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_link_support(xdr, bitmap, &res->has_links)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_symlink_support(xdr, bitmap, &res->has_symlinks)) != 0)\n\t\tgoto xdr_error;\n\tif ((status = decode_attr_aclsupport(xdr, bitmap, &res->acl_bitmask)) != 0)\n\t\tgoto xdr_error;\n\tstatus = verify_attr_len(xdr, savep, attrlen);\nxdr_error:\n\tdprintk(\"%s: xdr returned %d!\\n\", __func__, -status);\n\treturn status;\n}", "target": 0}
{"code": "folly::Optional<ErrorCode> HTTP2Codec::parseHeadersDecodeFrames(\n    const folly::Optional<http2::PriorityUpdate>& priority,\n    const folly::Optional<uint32_t>& promisedStream,\n    const folly::Optional<ExAttributes>& exAttributes,\n    std::unique_ptr<HTTPMessage>& msg) {\n  Cursor headerCursor(curHeaderBlock_.front());\n  bool isReq = false;\n  if (promisedStream) {\n    isReq = true;\n  } else if (exAttributes) {\n    isReq = isRequest(curHeader_.stream);\n  } else {\n    isReq = transportDirection_ == TransportDirection::DOWNSTREAM;\n  }\n  decodeInfo_.init(isReq, parsingDownstreamTrailers_);\n  if (priority) {\n    if (curHeader_.stream == priority->streamDependency) {\n      streamError(folly::to<string>(\"Circular dependency for txn=\",\n                                    curHeader_.stream),\n                  ErrorCode::PROTOCOL_ERROR,\n                  curHeader_.type == http2::FrameType::HEADERS);\n      return ErrorCode::NO_ERROR;\n    }\n    decodeInfo_.msg->setHTTP2Priority(\n        std::make_tuple(priority->streamDependency,\n                        priority->exclusive,\n                        priority->weight));\n  }\n  headerCodec_.decodeStreaming(\n      headerCursor, curHeaderBlock_.chainLength(), this);\n  msg = std::move(decodeInfo_.msg);\n  auto g = folly::makeGuard([this] { curHeaderBlock_.move(); });\n  if (decodeInfo_.decodeError != HPACK::DecodeError::NONE) {\n    static const std::string decodeErrorMessage =\n        \"Failed decoding header block for stream=\";\n    if (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream\n                 << \" header block=\";\n      VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    } else {\n      LOG(ERROR) << decodeErrorMessage << curHeader_.stream;\n    }\n    if (msg) {\n      msg->dumpMessage(3);\n    }\n    return ErrorCode::COMPRESSION_ERROR;\n  }\n  if (decodeInfo_.parsingError != \"\") {\n    LOG(ERROR) << \"Failed parsing header list for stream=\" << curHeader_.stream\n               << \", error=\" << decodeInfo_.parsingError << \", header block=\";\n    VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), true);\n    HTTPException err(HTTPException::Direction::INGRESS,\n                      folly::to<std::string>(\"HTTP2Codec stream error: \",\n                                             \"stream=\",\n                                             curHeader_.stream,\n                                             \" status=\",\n                                             400,\n                                             \" error: \",\n                                             decodeInfo_.parsingError));\n    err.setHttpStatusCode(400);\n    callback_->onError(curHeader_.stream, err, true);\n    return ErrorCode::NO_ERROR;\n  }\n  return folly::Optional<ErrorCode>();\n}", "target": 1}
{"code": "TEST_F(HTTP2CodecTest, DuplicateBadHeaderPriority) {\n  HTTPMessage req = getGetRequest();\n  req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, false, 7));\n  upstreamCodec_.generateHeader(output_, 1, req, true );\n  EXPECT_TRUE(parse([&](IOBuf* ingress) {\n    folly::io::RWPrivateCursor c(ingress);\n    c.skip(http2::kFrameHeaderSize + http2::kConnectionPreface.length());\n    c.writeBE<uint32_t>(1);\n  }));\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n  HTTPMessage nextRequest = getGetRequest();\n  upstreamCodec_.generateHeader(output_, 1, nextRequest, true );\n  parse();\n  EXPECT_EQ(callbacks_.streamErrors, 2);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}", "target": 0}
{"code": "xfs_ioctl_setattr_xflags(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tstruct fileattr\t\t*fa)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint64_t\t\ti_flags2;\n\tif ((ip->i_df.if_nextents || ip->i_delayed_blks) &&\n\t    XFS_IS_REALTIME_INODE(ip) != (fa->fsx_xflags & FS_XFLAG_REALTIME))\n\t\treturn -EINVAL;\n\tif (fa->fsx_xflags & FS_XFLAG_REALTIME) {\n\t\tif (mp->m_sb.sb_rblocks == 0 || mp->m_sb.sb_rextsize == 0 ||\n\t\t    (ip->i_extsize % mp->m_sb.sb_rextsize))\n\t\t\treturn -EINVAL;\n\t}\n\tif ((fa->fsx_xflags & FS_XFLAG_REALTIME) && xfs_is_reflink_inode(ip))\n\t\tip->i_diflags2 &= ~XFS_DIFLAG2_REFLINK;\n\tif ((fa->fsx_xflags & FS_XFLAG_DAX) && xfs_is_reflink_inode(ip))\n\t\treturn -EINVAL;\n\ti_flags2 = xfs_flags2diflags2(ip, fa->fsx_xflags);\n\tif (i_flags2 && !xfs_has_v3inodes(mp))\n\t\treturn -EINVAL;\n\tip->i_diflags = xfs_flags2diflags(ip, fa->fsx_xflags);\n\tip->i_diflags2 = i_flags2;\n\txfs_diflags_to_iflags(ip, false);\n\txfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_CHG);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\tXFS_STATS_INC(mp, xs_ig_attrchg);\n\treturn 0;\n}", "target": 0}
{"code": "static void wait_for_child_to_die(void *ctx)\n{\n\tREQUEST *request = ctx;\n\trad_assert(request->magic == REQUEST_MAGIC);\n\tif ((request->child_state == REQUEST_QUEUED) ||\n\t    ((request->child_state == REQUEST_RUNNING) &&\n\t     (pthread_equal(request->child_pid, NO_SUCH_CHILD_PID) == 0))) {\n\t\tif (request->delay < (USEC * 60 * 5)) {\n\t\t\trequest->delay += (request->delay >> 1);\n\t\t\tradlog(L_INFO, \"WARNING: Child is hung for request %u in component %s module %s.\",\n\t\t\t       request->number, request->component, request->module);\n\t\t} else {\n\t\t\tRDEBUG2(\"Child is still stuck for request %u\",\n\t\t\t\trequest->number);\n\t\t}\n\t\ttv_add(&request->when, request->delay);\n\t\tINSERT_EVENT(wait_for_child_to_die, request);\n\t\treturn;\n\t}\n\tRDEBUG2(\"Child is finally responsive for request %u\", request->number);\n\tremove_from_request_hash(request);\n#ifdef WITH_PROXY\n\tif (request->proxy) {\n\t\twait_for_proxy_id_to_expire(request);\n\t\treturn;\n\t}\n#endif\n\tev_request_free(&request);\n}", "target": 1}
{"code": "static int install_permanent_handler(int num_cpus, uintptr_t smbase,\n\t\t\t\t\tsize_t smsize, size_t save_state_size)\n{\n\tstruct smm_loader_params smm_params = {\n\t\t.per_cpu_stack_size = CONFIG_SMM_MODULE_STACK_SIZE,\n\t\t.num_concurrent_stacks = num_cpus,\n\t\t.per_cpu_save_state_size = save_state_size,\n\t\t.num_concurrent_save_states = num_cpus,\n\t};\n\tif (mp_state.ops.adjust_smm_params != NULL)\n\t\tmp_state.ops.adjust_smm_params(&smm_params, 1);\n\tprintk(BIOS_DEBUG, \"Installing SMM handler to 0x%08lx\\n\", smbase);\n\tif (smm_load_module((void *)smbase, smsize, &smm_params))\n\t\treturn -1;\n\tadjust_smm_apic_id_map(&smm_params);\n\treturn 0;\n}", "target": 1}
{"code": "static int add_array_entry(const char* loc_name, zval* hash_arr, char* key_name TSRMLS_DC)\n{\n\tchar*   key_value \t= NULL;\n\tchar*   cur_key_name\t= NULL;\n\tchar*   token        \t= NULL;\n\tchar*   last_ptr  \t= NULL;\n\tint\tresult\t\t= 0;\n\tint \tcur_result  \t= 0;\n\tint \tcnt  \t\t= 0;\n\tif( strcmp(key_name , LOC_PRIVATE_TAG)==0 ){\n\t\tkey_value = get_private_subtags( loc_name );\n\t\tresult = 1;\n\t} else {\n\t\tkey_value = get_icu_value_internal( loc_name , key_name , &result,1 );\n\t}\n\tif( (strcmp(key_name , LOC_PRIVATE_TAG)==0) || \n\t\t( strcmp(key_name , LOC_VARIANT_TAG)==0) ){\n\t\tif( result > 0 && key_value){\n\t\t\ttoken = php_strtok_r( key_value , DELIMITER ,&last_ptr);\t\n\t\t\tif( cur_key_name ){\n\t\t\t\tefree( cur_key_name);\n\t\t\t}\n\t\t\tcur_key_name = (char*)ecalloc( 25,  25);\n\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n\t\t\tadd_assoc_string( hash_arr, cur_key_name , token ,TRUE );\n\t\t\twhile( (token = php_strtok_r(NULL , DELIMITER , &last_ptr)) && (strlen(token)>1) ){\n\t\t\t\tsprintf( cur_key_name , \"%s%d\", key_name , cnt++);\t\n\t\t\t\tadd_assoc_string( hash_arr, cur_key_name , token , TRUE );\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif( result == 1 ){\n\t\t\tadd_assoc_string( hash_arr, key_name , key_value , TRUE );\n\t\t\tcur_result = 1;\n\t\t}\n\t}\n\tif( cur_key_name ){\n\t\tefree( cur_key_name);\n\t}\n\tif( key_value){\n\t\tefree(key_value);\t\n\t}\n\treturn cur_result;\n}", "target": 1}
{"code": "BITMAP_UPDATE* update_read_bitmap_update(rdpUpdate* update, wStream* s)\n{\n\tUINT32 i;\n\tBITMAP_UPDATE* bitmapUpdate = calloc(1, sizeof(BITMAP_UPDATE));\n\tif (!bitmapUpdate)\n\t\tgoto fail;\n\tif (Stream_GetRemainingLength(s) < 2)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, bitmapUpdate->number); \n\tWLog_Print(update->log, WLOG_TRACE, \"BitmapUpdate: %\"PRIu32\"\", bitmapUpdate->number);\n\tif (bitmapUpdate->number > bitmapUpdate->count)\n\t{\n\t\tUINT16 count;\n\t\tBITMAP_DATA* newdata;\n\t\tcount = bitmapUpdate->number * 2;\n\t\tnewdata = (BITMAP_DATA*) realloc(bitmapUpdate->rectangles,\n\t\t                                 sizeof(BITMAP_DATA) * count);\n\t\tif (!newdata)\n\t\t\tgoto fail;\n\t\tbitmapUpdate->rectangles = newdata;\n\t\tZeroMemory(&bitmapUpdate->rectangles[bitmapUpdate->count],\n\t\t           sizeof(BITMAP_DATA) * (count - bitmapUpdate->count));\n\t\tbitmapUpdate->count = count;\n\t}\n\tfor (i = 0; i < bitmapUpdate->number; i++)\n\t{\n\t\tif (!update_read_bitmap_data(update, s, &bitmapUpdate->rectangles[i]))\n\t\t\tgoto fail;\n\t}\n\treturn bitmapUpdate;\nfail:\n\tfree_bitmap_update(update->context, bitmapUpdate);\n\treturn NULL;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_string_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_STRING );\n}", "target": 1}
{"code": "static int userns_install(struct nsproxy *nsproxy, void *ns)\n{\n\tstruct user_namespace *user_ns = ns;\n\tstruct cred *cred;\n\tif (user_ns == current_user_ns())\n\t\treturn -EINVAL;\n\tif (atomic_read(&current->mm->mm_users) > 1)\n\t\treturn -EINVAL;\n\tif (current->fs->users != 1)\n\t\treturn -EINVAL;\n\tif (!ns_capable(user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tcred = prepare_creds();\n\tif (!cred)\n\t\treturn -ENOMEM;\n\tput_user_ns(cred->user_ns);\n\tset_cred_user_ns(cred, get_user_ns(user_ns));\n\treturn commit_creds(cred);\n}", "target": 0}
{"code": "static void nested_release_page(struct page *page)\n{\n\tkvm_release_page_dirty(page);\n}", "target": 0}
{"code": "static BYTE get_bpp_bmf(UINT32 bpp, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bpp)\n\t{\n\t\tcase 1:\n\t\t\treturn 1;\n\t\tcase 8:\n\t\t\treturn 3;\n\t\tcase 16:\n\t\t\treturn 4;\n\t\tcase 24:\n\t\t\treturn 5;\n\t\tcase 32:\n\t\t\treturn 6;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid color depth %\" PRIu32, bpp);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "void CUser::SetClientEncoding(const CString& s) {\n    m_sClientEncoding = s;\n    for (CClient* pClient : GetAllClients()) {\n        pClient->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "snmp_ber_decode_timeticks(snmp_packet_t *snmp_packet, uint32_t *timeticks)\n{\n  return snmp_ber_decode_unsigned_integer(snmp_packet, BER_DATA_TYPE_TIMETICKS, timeticks);\n}", "target": 0}
{"code": "    bool CFontFileType1::RemovePfbMarkers()\n    {\n        bool bSuccess = true;\n        int nBlockType = 0;\n        int nBlockLen  = 0;\n        int nChar = 0;\n        unsigned char *sBuffer = NULL;\n        int nBufLen = 0;\n        while ( nBlockType != PFB_DONE )\n        {\n            while ( 0 == nBlockLen )\n            {\n                nChar = ReadU8( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n                nBlockType = ReadU8( &bSuccess );\n                if ( !bSuccess || PFB_MARKER != nChar || ( PFB_ASCII != nBlockType && PFB_BINARY != nBlockType && PFB_DONE != nBlockType ) )\n                    return false;\n                if ( PFB_DONE == nBlockType )\n                    break;\n                nBlockLen = ReadU32LE( &bSuccess );\n                if ( !bSuccess )\n                    return false;\n            }\n            if ( nBlockLen > 0 )\n            {\n                if ( !sBuffer )\n                {\n                    sBuffer = (unsigned char*)MemUtilsMalloc( nBlockLen );\n                    if ( !sBuffer )\n                        return false;\n                }\n                else\n                    sBuffer = (unsigned char*)MemUtilsRealloc( sBuffer, nBufLen + nBlockLen );\n                Read( sBuffer + nBufLen, nBlockLen );\n                nBufLen += nBlockLen;\n            }\n            nBlockLen = 0;\n        }\n        if ( m_bFreeFileData )\n            MemUtilsFree( m_sFile );\n        m_bFreeFileData = true;\n        m_sFile         = (unsigned char*)sBuffer;\n        m_sFileData     = m_sFile;\n        m_nLen          = nBufLen;\n        m_nPos          = 0;\n        return true;\n    }", "target": 1}
{"code": "has_supported_extension (const char *name,\n\t\t\t GHashTable *supported_extensions)\n{\n\tgboolean ret = FALSE;\n\tgchar *suffix;\n\tsuffix = g_strrstr (name, \".\");\n\tif (!suffix)\n\t\treturn ret;\n\tsuffix = g_ascii_strdown (suffix + 1, -1);\n\tret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));\n\tg_free (suffix);\n\treturn ret;\n}", "target": 0}
{"code": "static int netlink_realloc_groups(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tunsigned int groups;\n\tunsigned long *new_groups;\n\tint err = 0;\n\tnetlink_table_grab();\n\tgroups = nl_table[sk->sk_protocol].groups;\n\tif (!nl_table[sk->sk_protocol].registered) {\n\t\terr = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\tif (nlk->ngroups >= groups)\n\t\tgoto out_unlock;\n\tnew_groups = krealloc(nlk->groups, NLGRPSZ(groups), GFP_ATOMIC);\n\tif (new_groups == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\tmemset((char *)new_groups + NLGRPSZ(nlk->ngroups), 0,\n\t       NLGRPSZ(groups) - NLGRPSZ(nlk->ngroups));\n\tnlk->groups = new_groups;\n\tnlk->ngroups = groups;\n out_unlock:\n\tnetlink_table_ungrab();\n\treturn err;\n}", "target": 0}
{"code": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\tif (nla_len(rp) < ulen ||\n\t    xfrm_replay_state_esn_len(replay_esn) != ulen ||\n\t    replay_esn->bmp_len != up->bmp_len)\n\t\treturn -EINVAL;\n\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "static uint32_t dp8393x_crda(dp8393xState *s)\n{\n    return (s->regs[SONIC_URDA] << 16) |\n           (s->regs[SONIC_CRDA] & SONIC_DESC_ADDR);\n}", "target": 0}
{"code": "static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)\n{\n\tint i;\n\tint ret;\n\tret = xen_pcibk_read_config_word(dev, offset, value, data);\n\tif (!pci_is_enabled(dev))\n\t\treturn ret;\n\tfor (i = 0; i < PCI_ROM_RESOURCE; i++) {\n\t\tif (dev->resource[i].flags & IORESOURCE_IO)\n\t\t\t*value |= PCI_COMMAND_IO;\n\t\tif (dev->resource[i].flags & IORESOURCE_MEM)\n\t\t\t*value |= PCI_COMMAND_MEMORY;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "pci_populate_msixcap(struct msixcap *msixcap, int msgnum, int barnum,\n\t\t     uint32_t msix_tab_size)\n{\n\tassert(msix_tab_size % 4096 == 0);\n\tbzero(msixcap, sizeof(struct msixcap));\n\tmsixcap->capid = PCIY_MSIX;\n\tmsixcap->msgctrl = msgnum - 1;\n\tmsixcap->table_info = barnum & PCIM_MSIX_BIR_MASK;\n\tmsixcap->pba_info = msix_tab_size | (barnum & PCIM_MSIX_BIR_MASK);\n}", "target": 1}
{"code": "size_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)\n{\n    Error *err = NULL;\n    ssize_t ret;\n    ret = qio_channel_write(\n        vs->ioc, (const char *)data, datalen, &err);\n    VNC_DEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret);\n    return vnc_client_io_error(vs, ret, &err);\n}", "target": 0}
{"code": "call_bind_status(struct rpc_task *task)\n{\n\tint status = -EIO;\n\tif (task->tk_status >= 0) {\n\t\tdprint_status(task);\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_connect;\n\t\treturn;\n\t}\n\tswitch (task->tk_status) {\n\tcase -ENOMEM:\n\t\tdprintk(\"RPC: %5u rpcbind out of memory\\n\", task->tk_pid);\n\t\trpc_delay(task, HZ >> 2);\n\t\tgoto retry_timeout;\n\tcase -EACCES:\n\t\tdprintk(\"RPC: %5u remote rpcbind: RPC program/version \"\n\t\t\t\t\"unavailable\\n\", task->tk_pid);\n\t\tif (task->tk_msg.rpc_proc->p_proc == 0) {\n\t\t\tstatus = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t\tif (task->tk_rebind_retry == 0)\n\t\t\tbreak;\n\t\ttask->tk_rebind_retry--;\n\t\trpc_delay(task, 3*HZ);\n\t\tgoto retry_timeout;\n\tcase -ETIMEDOUT:\n\t\tdprintk(\"RPC: %5u rpcbind request timed out\\n\",\n\t\t\t\ttask->tk_pid);\n\t\tgoto retry_timeout;\n\tcase -EPFNOSUPPORT:\n\t\tdprintk(\"RPC: %5u unrecognized remote rpcbind service\\n\",\n\t\t\t\ttask->tk_pid);\n\t\tbreak;\n\tcase -EPROTONOSUPPORT:\n\t\tdprintk(\"RPC: %5u remote rpcbind version unavailable, retrying\\n\",\n\t\t\t\ttask->tk_pid);\n\t\ttask->tk_status = 0;\n\t\ttask->tk_action = call_bind;\n\t\treturn;\n\tcase -ECONNREFUSED:\t\t\n\tcase -ECONNRESET:\n\tcase -ENOTCONN:\n\tcase -EHOSTDOWN:\n\tcase -EHOSTUNREACH:\n\tcase -ENETUNREACH:\n\tcase -EPIPE:\n\t\tdprintk(\"RPC: %5u remote rpcbind unreachable: %d\\n\",\n\t\t\t\ttask->tk_pid, task->tk_status);\n\t\tif (!RPC_IS_SOFTCONN(task)) {\n\t\t\trpc_delay(task, 5*HZ);\n\t\t\tgoto retry_timeout;\n\t\t}\n\t\tstatus = task->tk_status;\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"RPC: %5u unrecognized rpcbind error (%d)\\n\",\n\t\t\t\ttask->tk_pid, -task->tk_status);\n\t}\n\trpc_exit(task, status);\n\treturn;\nretry_timeout:\n\ttask->tk_action = call_timeout;\n}", "target": 0}
{"code": "static void kvm_destroy_devices(struct kvm *kvm)\n{\n\tstruct kvm_device *dev, *tmp;\n\tlist_for_each_entry_safe(dev, tmp, &kvm->devices, vm_node) {\n\t\tlist_del(&dev->vm_node);\n\t\tdev->ops->destroy(dev);\n\t}\n}", "target": 0}
{"code": "mptctl_eventreport (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventreport __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventreport\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t numBytes, maxEvents, max;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventreport))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventreport() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventreport called.\\n\",\n\t    ioc->name));\n\tnumBytes = karg.hdr.maxDataSize - sizeof(mpt_ioctl_header);\n\tmaxEvents = numBytes/sizeof(MPT_IOCTL_EVENTS);\n\tmax = MPTCTL_EVENT_LOG_SIZE < maxEvents ? MPTCTL_EVENT_LOG_SIZE : maxEvents;\n\tif ((max < 1) || !ioc->events)\n\t\treturn -ENODATA;\n\tioc->aen_event_read_flag=0;\n\tnumBytes = max * sizeof(MPT_IOCTL_EVENTS);\n\tif (copy_to_user(uarg->eventData, ioc->events, numBytes)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventreport - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventreport struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, ioc->events);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static x3f_huffnode_t *new_node(x3f_hufftree_t *tree)\n{\n\tif (tree->free_node_index >= tree->total_node_index)\n\t\tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n  x3f_huffnode_t *t = &tree->nodes[tree->free_node_index];\n  t->branch[0] = NULL;\n  t->branch[1] = NULL;\n  t->leaf = UNDEFINED_LEAF;\n  tree->free_node_index++;\n  return t;\n}", "target": 0}
{"code": "bool allowed_new_user_problem_entry(uid_t uid, const char *name, const char *value)\n{\n    if (uid == 0)\n        return true;\n    if (strcmp(name, FILENAME_ANALYZER) != 0\n     && strcmp(name, FILENAME_TYPE) != 0\n     && strcmp(name, \"basename\") != 0)\n        return true;\n     if (strcmp(value, \"CCpp\") != 0\n      && strcmp(value, \"Kerneloops\") != 0\n      && strcmp(value, \"vmcore\") != 0\n      && strcmp(value, \"xorg\") != 0)\n        return true;\n    error_msg(\"Only root is permitted to create element '%s' containing '%s'\", name, value);\n    return false;\n}", "target": 0}
{"code": "header_read (SF_PRIVATE *psf, void *ptr, int bytes)\n{\tint count = 0 ;\n\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\treturn psf_fread (ptr, 1, bytes, psf) ;\n\tif (psf->headindex + bytes > SIGNED_SIZEOF (psf->header))\n\t{\tint most ;\n\t\tmost = SIGNED_SIZEOF (psf->header) - psf->headend ;\n\t\tpsf_fread (psf->header + psf->headend, 1, most, psf) ;\n\t\tmemcpy (ptr, psf->header + psf->headend, most) ;\n\t\tpsf->headend = psf->headindex += most ;\n\t\tpsf_fread ((char *) ptr + most, bytes - most, 1, psf) ;\n\t\treturn bytes ;\n\t\t} ;\n\tif (psf->headindex + bytes > psf->headend)\n\t{\tcount = psf_fread (psf->header + psf->headend, 1, bytes - (psf->headend - psf->headindex), psf) ;\n\t\tif (count != bytes - (int) (psf->headend - psf->headindex))\n\t\t{\tpsf_log_printf (psf, \"Error : psf_fread returned short count.\\n\") ;\n\t\t\treturn count ;\n\t\t\t} ;\n\t\tpsf->headend += count ;\n\t\t} ;\n\tmemcpy (ptr, psf->header + psf->headindex, bytes) ;\n\tpsf->headindex += bytes ;\n\treturn bytes ;\n} ", "target": 1}
{"code": "int msPostGISLayerSetTimeFilter(layerObj *lp, const char *timestring, const char *timefield)\n{\n  char **atimes, **aranges = NULL;\n  int numtimes=0,i=0,numranges=0;\n  size_t buffer_size = 512;\n  char buffer[512], bufferTmp[512];\n  buffer[0] = '\\0';\n  bufferTmp[0] = '\\0';\n  if (!lp || !timestring || !timefield)\n    return MS_FALSE;\n  if( strchr(timestring,'\\'') || strchr(timestring, '\\\\') ) {\n     msSetError(MS_MISCERR, \"Invalid time filter.\", \"msPostGISLayerSetTimeFilter()\");\n     return MS_FALSE;\n  }\n  if (strstr(timestring, \",\") == NULL &&\n      strstr(timestring, \"/\") == NULL) { \n    createPostgresTimeCompareSimple(timefield, timestring, buffer, buffer_size);\n  } else {\n    atimes = msStringSplit (timestring, ',', &numtimes);\n    if (atimes == NULL || numtimes < 1)\n      return MS_FALSE;\n    strlcat(buffer, \"(\", buffer_size);\n    for(i=0; i<numtimes; i++) {\n      if(i!=0) {\n        strlcat(buffer, \" OR \", buffer_size);\n      }\n      strlcat(buffer, \"(\", buffer_size);\n      aranges = msStringSplit(atimes[i],  '/', &numranges);\n      if(!aranges) return MS_FALSE;\n      if(numranges == 1) {\n        createPostgresTimeCompareSimple(timefield, atimes[i], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else if(numranges == 2) {\n        createPostgresTimeCompareRange(timefield, aranges[0], aranges[1], bufferTmp, buffer_size);\n        strlcat(buffer, bufferTmp, buffer_size);\n      } else {\n        return MS_FALSE;\n      }\n      msFreeCharArray(aranges, numranges);\n      strlcat(buffer, \")\", buffer_size);\n    }\n    strlcat(buffer, \")\", buffer_size);\n    msFreeCharArray(atimes, numtimes);\n  }\n  if(!*buffer) {\n    return MS_FALSE;\n  }\n  if(lp->filteritem) free(lp->filteritem);\n  lp->filteritem = msStrdup(timefield);\n  if (&lp->filter) {\n    if (lp->filter.type == MS_EXPRESSION) {\n      snprintf(bufferTmp, buffer_size, \"(%s) and %s\", lp->filter.string, buffer);\n      loadExpressionString(&lp->filter, bufferTmp);\n    } else {\n      freeExpression(&lp->filter);\n      loadExpressionString(&lp->filter, buffer);\n    }\n  }\n  return MS_TRUE;\n}", "target": 0}
{"code": "void cipso_v4_sock_delattr(struct sock *sk)\n{\n\tint hdr_delta;\n\tstruct ip_options *opt;\n\tstruct inet_sock *sk_inet;\n\tsk_inet = inet_sk(sk);\n\topt = sk_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\thdr_delta = cipso_v4_delopt(&sk_inet->opt);\n\tif (sk_inet->is_icsk && hdr_delta > 0) {\n\t\tstruct inet_connection_sock *sk_conn = inet_csk(sk);\n\t\tsk_conn->icsk_ext_hdr_len -= hdr_delta;\n\t\tsk_conn->icsk_sync_mss(sk, sk_conn->icsk_pmtu_cookie);\n\t}\n}", "target": 1}
{"code": "void Statement::GetRow(Row* row, sqlite3_stmt* stmt) {\n    int rows = sqlite3_column_count(stmt);\n    for (int i = 0; i < rows; i++) {\n        int type = sqlite3_column_type(stmt, i);\n        const char* name = sqlite3_column_name(stmt, i);\n        switch (type) {\n            case SQLITE_INTEGER: {\n                row->push_back(new Values::Integer(name, sqlite3_column_int64(stmt, i)));\n            }   break;\n            case SQLITE_FLOAT: {\n                row->push_back(new Values::Float(name, sqlite3_column_double(stmt, i)));\n            }   break;\n            case SQLITE_TEXT: {\n                const char* text = (const char*)sqlite3_column_text(stmt, i);\n                int length = sqlite3_column_bytes(stmt, i);\n                row->push_back(new Values::Text(name, length, text));\n            } break;\n            case SQLITE_BLOB: {\n                const void* blob = sqlite3_column_blob(stmt, i);\n                int length = sqlite3_column_bytes(stmt, i);\n                row->push_back(new Values::Blob(name, length, blob));\n            }   break;\n            case SQLITE_NULL: {\n                row->push_back(new Values::Null(name));\n            }   break;\n            default:\n                assert(false);\n        }\n    }\n}", "target": 0}
{"code": "M_bool M_fs_path_ishidden(const char *path, M_fs_info_t *info)\n{\n\tM_list_str_t *path_parts;\n\tsize_t        len;\n\tM_bool        ret        = M_FALSE;\n\t(void)info;\n\tif (path == NULL || *path == '\\0') {\n\t\treturn M_FALSE;\n\t}\n\tpath_parts = M_fs_path_componentize_path(path, M_FS_SYSTEM_UNIX);\n\tlen = M_list_str_len(path_parts);\n\tif (len > 0) {\n\t\tif (*M_list_str_at(path_parts, len-1) == '.') {\n\t\t\tret = M_TRUE;\n\t\t}\n\t}\n\tM_list_str_destroy(path_parts);\n\treturn ret;\n}", "target": 1}
{"code": "static void __lo_release(struct loop_device *lo)\n{\n\tint err;\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}", "target": 0}
{"code": "sort_keyuse(KEYUSE *a,KEYUSE *b)\n{\n  int res;\n  if (a->table->tablenr != b->table->tablenr)\n    return (int) (a->table->tablenr - b->table->tablenr);\n  if (a->key != b->key)\n    return (int) (a->key - b->key);\n  if (a->key == MAX_KEY && b->key == MAX_KEY && \n      a->used_tables != b->used_tables)\n    return (int) ((ulong) a->used_tables - (ulong) b->used_tables);\n  if (a->keypart != b->keypart)\n    return (int) (a->keypart - b->keypart);\n  if ((res= MY_TEST((a->used_tables & ~OUTER_REF_TABLE_BIT)) -\n       MY_TEST((b->used_tables & ~OUTER_REF_TABLE_BIT))))\n    return res;\n  return (int) ((a->optimize & KEY_OPTIMIZE_REF_OR_NULL) -\n\t\t(b->optimize & KEY_OPTIMIZE_REF_OR_NULL));\n}", "target": 0}
{"code": "static inline FILE *xfmkstemp(char **tmpname, char *dir)\n{\n\tint fd;\n\tFILE *ret;\n\tfd = xmkstemp(tmpname, dir);\n\tif (fd == -1)\n\t\treturn NULL;\n\tif (!(ret = fdopen(fd, \"w+\" UL_CLOEXECSTR))) {\n\t\tclose(fd);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void l2tp_packet_print(const struct l2tp_packet_t *pack,\n\t\t       void (*print)(const char *fmt, ...))\n{\n\tconst struct l2tp_attr_t *attr;\n\tconst struct l2tp_dict_value_t *val;\n\tif (pack->hdr.ver == 2) {\n\t\tprint(\"[L2TP tid=%u sid=%u\", ntohs(pack->hdr.tid), ntohs(pack->hdr.sid));\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t} else {\n\t\tprint(\"[L2TP cid=%u\", pack->hdr.cid);\n\t\tlog_ppp_debug(\" Ns=%u Nr=%u\", ntohs(pack->hdr.Ns), ntohs(pack->hdr.Nr));\n\t}\n\tlist_for_each_entry(attr, &pack->attrs, entry) {\n\t\tprint(\" <%s\", attr->attr->name);\n\t\tval = l2tp_dict_find_value(attr->attr, attr->val);\n\t\tif (val)\n\t\t\tprint(\" %s\", val->name);\n\t\telse if (attr->H)\n\t\t\tprint(\" (hidden, %hu bytes)\", attr->length);\n\t\telse {\n\t\t\tswitch (attr->attr->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tprint(\" %i\", attr->val.int16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_INT32:\n\t\t\t\t\tprint(\" %i\", attr->val.int32);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tprint(\" %s\", attr->val.string);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprint(\">\");\n\t}\n\tprint(\"]\\n\");\n}", "target": 1}
{"code": "snmp_ber_decode_unsigned_integer(unsigned char *buf, uint32_t *buff_len, uint8_t expected_type, uint32_t *num)\n{\n  uint8_t i, len, type;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != expected_type) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL || len > 4) {\n    return NULL;\n  }\n  if(*buff_len < len) {\n    return NULL;\n  }\n  *num = (uint32_t)(*buf++ & 0xFF);\n  (*buff_len)--;\n  for(i = 1; i < len; ++i) {\n    *num <<= 8;\n    *num |= (uint8_t)(*buf++ & 0xFF);\n    (*buff_len)--;\n  }\n  return buf;\n}", "target": 1}
{"code": "void LayerTilerChromium::invalidateEntireLayer()\n{\n    for (size_t i = 0; i < m_tiles.size(); ++i) {\n        if (m_tiles[i])\n            m_unusedTiles.append(m_tiles[i].release());\n    }\n    m_tiles.clear();\n    m_layerSize = IntSize();\n    m_layerTileSize = IntSize();\n    m_lastUpdateLayerRect = IntRect();\n}", "target": 0}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_read_from_buffer_verification_info_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->file_offset = buf_offset;\n\tse->tag = buffer[offset];\n\toffset += 1;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t}\n\tif (R_BIN_JAVA_STACKMAP_UNINIT < se->tag) {\n\t\tr_bin_java_verification_info_free (se);\n\t\treturn NULL;\n\t}\n\tse->size = offset;\n\treturn se;\n}", "target": 0}
{"code": "void input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code)\n{\n\tif (type < EV_CNT && input_max_code[type] &&\n\t    code > input_max_code[type]) {\n\t\tpr_err(\"%s: invalid code %u for type %u\\n\", __func__, code,\n\t\t       type);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\tswitch (type) {\n\tcase EV_KEY:\n\t\t__set_bit(code, dev->keybit);\n\t\tbreak;\n\tcase EV_REL:\n\t\t__set_bit(code, dev->relbit);\n\t\tbreak;\n\tcase EV_ABS:\n\t\tinput_alloc_absinfo(dev);\n\t\t__set_bit(code, dev->absbit);\n\t\tbreak;\n\tcase EV_MSC:\n\t\t__set_bit(code, dev->mscbit);\n\t\tbreak;\n\tcase EV_SW:\n\t\t__set_bit(code, dev->swbit);\n\t\tbreak;\n\tcase EV_LED:\n\t\t__set_bit(code, dev->ledbit);\n\t\tbreak;\n\tcase EV_SND:\n\t\t__set_bit(code, dev->sndbit);\n\t\tbreak;\n\tcase EV_FF:\n\t\t__set_bit(code, dev->ffbit);\n\t\tbreak;\n\tcase EV_PWR:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unknown type %u (code %u)\\n\", __func__, type, code);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\t__set_bit(type, dev->evbit);\n}", "target": 0}
{"code": "static int check_ptr_alignment(struct bpf_verifier_env *env,\n\t\t\t       const struct bpf_reg_state *reg,\n\t\t\t       int off, int size)\n{\n\tbool strict = env->strict_alignment;\n\tconst char *pointer_desc = \"\";\n\tswitch (reg->type) {\n\tcase PTR_TO_PACKET:\n\tcase PTR_TO_PACKET_META:\n\t\treturn check_pkt_ptr_alignment(env, reg, off, size, strict);\n\tcase PTR_TO_MAP_VALUE:\n\t\tpointer_desc = \"value \";\n\t\tbreak;\n\tcase PTR_TO_CTX:\n\t\tpointer_desc = \"context \";\n\t\tbreak;\n\tcase PTR_TO_STACK:\n\t\tpointer_desc = \"stack \";\n\t\tstrict = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn check_generic_ptr_alignment(env, reg, pointer_desc, off, size,\n\t\t\t\t\t   strict);\n}", "target": 0}
{"code": "void OneHotComputeImpl(const OneHotContext& op_context) {\n  int prefix_dim_size = 1;\n  for (int i = 0; i < op_context.axis; ++i) {\n    prefix_dim_size *= op_context.indices->dims->data[i];\n  }\n  if (prefix_dim_size == 0) {\n    return;\n  }\n  const int suffix_dim_size = NumElements(op_context.indices) / prefix_dim_size;\n  const int depth = *op_context.depth->data.i32;\n  const T on_value = *GetTensorData<T>(op_context.on_value);\n  const T off_value = *GetTensorData<T>(op_context.off_value);\n  T* output = GetTensorData<T>(op_context.output);\n  const TI* indices = GetTensorData<TI>(op_context.indices);\n  for (int i = 0; i < prefix_dim_size; ++i) {\n    for (int j = 0; j < depth; ++j) {\n      for (int k = 0; k < suffix_dim_size; ++k, ++output) {\n        *output = static_cast<int>(indices[i * suffix_dim_size + k]) == j\n                      ? on_value\n                      : off_value;\n      }\n    }\n  }\n}", "target": 0}
{"code": "  static void launch(OpKernelContext* context, const PoolParameters& params,\n                     const Tensor& grad_in, const Tensor& argmax,\n                     Tensor* grad_out, const bool include_batch_in_index) {\n    const DeviceBase::CpuWorkerThreads& worker_threads =\n        *(context->device()->tensorflow_cpu_worker_threads());\n    auto shard = [&grad_in, &argmax, &grad_out, include_batch_in_index](\n                     int64 start, int64 limit) {\n      const int64 batch_size =\n          GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n      const int64 output_size_per_batch = grad_out->NumElements() / batch_size;\n      const int64 input_size_per_batch = grad_in.NumElements() / batch_size;\n      {\n        auto grad_out_flat = grad_out->flat<T>();\n        auto argmax_flat = argmax.flat<int64>();\n        auto grad_in_flat = grad_in.flat<T>();\n        const int64 output_start = start * output_size_per_batch;\n        const int64 output_end = limit * output_size_per_batch;\n        EigenMatrixMap inputShard(grad_out_flat.data() + output_start, 1,\n                                  output_end - output_start);\n        inputShard.setConstant(T(0));\n        const int input_start = start * input_size_per_batch;\n        const int input_end = limit * input_size_per_batch;\n        for (int64 index = input_start; index < input_end; index++) {\n          if (index >= argmax.NumElements()) {\n            break;\n          }\n          int64 grad_out_index = argmax_flat(index);\n          if (!include_batch_in_index) {\n            const int64 cur_batch = index / input_size_per_batch;\n            grad_out_index += cur_batch * output_size_per_batch;\n          }\n          CHECK(grad_out_index >= output_start && grad_out_index < output_end)\n              << \"Invalid output gradient index: \" << grad_out_index << \", \"\n              << output_start << \", \" << output_end;\n          grad_out_flat(grad_out_index) += grad_in_flat(index);\n        }\n      }\n    };\n    const int64 batch_size = GetTensorDim(grad_out->shape(), FORMAT_NHWC, 'N');\n    const int64 shard_cost = grad_out->NumElements() / batch_size;\n    Shard(worker_threads.num_threads, worker_threads.workers, batch_size,\n          shard_cost, shard);\n  }", "target": 0}
{"code": "int mnt_optstr_get_uid(const char *optstr, const char *name, uid_t *uid)\n{\n\tchar *value = NULL;\n\tsize_t valsz = 0;\n\tchar buf[sizeof(stringify_value(UINT64_MAX))];\n\tint rc;\n\tuint64_t num;\n\tassert(optstr);\n\tassert(name);\n\tassert(uid);\n\trc = mnt_optstr_get_option(optstr, name, &value, &valsz);\n\tif (rc != 0)\n\t\tgoto fail;\n\tif (valsz > sizeof(buf) - 1) {\n\t\trc = -ERANGE;\n\t\tgoto fail;\n\t}\n\tmem2strcpy(buf, value, valsz, sizeof(buf));\n\trc = ul_strtou64(buf, &num, 10);\n\tif (rc != 0)\n\t\tgoto fail;\n\tif (num > ULONG_MAX || (uid_t) num != num) {\n\t\trc = -ERANGE;\n\t\tgoto fail;\n\t}\n\t*uid = (uid_t) num;\n\treturn 0;\nfail:\n\tDBG(UTILS, ul_debug(\"failed to convert '%s'= to number [rc=%d]\", name, rc));\n\treturn rc;\n}", "target": 0}
{"code": "theme_adium_match_with_format (const gchar **str,\n\t\t\t       const gchar *match,\n\t\t\t       gchar **format)\n{\n\tconst gchar *cur = *str;\n\tconst gchar *end;\n\tif (!theme_adium_match (&cur, match)) {\n\t\treturn FALSE;\n\t}\n\tcur++;\n\tend = strstr (cur, \"}%\");\n\tif (!end) {\n\t\treturn FALSE;\n\t}\n\t*format = g_strndup (cur , end - cur);\n\t*str = end + 1;\n\treturn TRUE;\n}", "target": 0}
{"code": "static const char *set_max_reversals(cmd_parms *cmd, void *conf_, const char *arg)\n{\n    core_dir_config *conf = conf_;\n    int val = 0;\n    if (!ap_cstr_casecmp(arg, \"none\")) {\n        val = AP_MAXRANGES_NORANGES;\n    }\n    else if (!ap_cstr_casecmp(arg, \"default\")) {\n        val = AP_MAXRANGES_DEFAULT;\n    }\n    else if (!ap_cstr_casecmp(arg, \"unlimited\")) {\n        val = AP_MAXRANGES_UNLIMITED;\n    }\n    else {\n        val = atoi(arg);\n        if (val <= 0)\n            return \"MaxRangeReversals requires 'none', 'default', 'unlimited' or \"\n            \"a positive integer\";\n    }\n    conf->max_reversals = val;\n    return NULL;\n}", "target": 0}
{"code": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\tmemset(&cai, 0, sizeof(cai));\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\tif (iaxs[callno]) {\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\treturn 1;\n}", "target": 1}
{"code": "juniper_atm2_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM2;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && \n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            return l2info.header_len;\n        }\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\n}", "target": 1}
{"code": "static inline unsigned char *skb_inner_mac_header(const struct sk_buff *skb)\n{\n\treturn skb->inner_mac_header;\n}", "target": 0}
{"code": "static void pcd_init_units(void)\n{\n\tstruct pcd_unit *cd;\n\tint unit;\n\tpcd_drive_count = 0;\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tstruct gendisk *disk = alloc_disk(1);\n\t\tif (!disk)\n\t\t\tcontinue;\n\t\tdisk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops,\n\t\t\t\t\t\t   1, BLK_MQ_F_SHOULD_MERGE);\n\t\tif (IS_ERR(disk->queue)) {\n\t\t\tput_disk(disk);\n\t\t\tdisk->queue = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tINIT_LIST_HEAD(&cd->rq_list);\n\t\tdisk->queue->queuedata = cd;\n\t\tblk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH);\n\t\tcd->disk = disk;\n\t\tcd->pi = &cd->pia;\n\t\tcd->present = 0;\n\t\tcd->last_sense = 0;\n\t\tcd->changed = 1;\n\t\tcd->drive = (*drives[unit])[D_SLV];\n\t\tif ((*drives[unit])[D_PRT])\n\t\t\tpcd_drive_count++;\n\t\tcd->name = &cd->info.name[0];\n\t\tsnprintf(cd->name, sizeof(cd->info.name), \"%s%d\", name, unit);\n\t\tcd->info.ops = &pcd_dops;\n\t\tcd->info.handle = cd;\n\t\tcd->info.speed = 0;\n\t\tcd->info.capacity = 1;\n\t\tcd->info.mask = 0;\n\t\tdisk->major = major;\n\t\tdisk->first_minor = unit;\n\t\tstrcpy(disk->disk_name, cd->name);\t\n\t\tdisk->fops = &pcd_bdops;\n\t\tdisk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE;\n\t}\n}", "target": 0}
{"code": "int crypto_scrypt(const uint8_t* password, size_t pwlen, const uint8_t* salt,\n                  size_t saltlen, uint64_t N, uint32_t r, uint32_t p,\n                  uint8_t* buf, size_t buflen) {\n  return crypto_pwhash_scryptsalsa208sha256_ll(password, pwlen, salt, saltlen,\n                                               N, r, p, buf, buflen);\n}", "target": 0}
{"code": "irc_server_set_prefix_modes_chars (struct t_irc_server *server,\n                                   const char *prefix)\n{\n    char *pos;\n    int i, length_modes, length_chars;\n    if (!server || !prefix)\n        return;\n    if (server->prefix_modes)\n    {\n        free (server->prefix_modes);\n        server->prefix_modes = NULL;\n    }\n    if (server->prefix_chars)\n    {\n        free (server->prefix_chars);\n        server->prefix_chars = NULL;\n    }\n    pos = strchr (prefix, ')');\n    if (pos)\n    {\n        server->prefix_modes = weechat_strndup (prefix + 1,\n                                                pos - prefix - 1);\n        if (server->prefix_modes)\n        {\n            pos++;\n            length_modes = strlen (server->prefix_modes);\n            length_chars = strlen (pos);\n            server->prefix_chars = malloc (length_modes + 1);\n            if (server->prefix_chars)\n            {\n                for (i = 0; i < length_modes; i++)\n                {\n                    server->prefix_chars[i] = (i < length_chars) ? pos[i] : ' ';\n                }\n                server->prefix_chars[length_modes] = '\\0';\n            }\n            else\n            {\n                free (server->prefix_modes);\n                server->prefix_modes = NULL;\n            }\n        }\n    }\n}", "target": 1}
{"code": "is_code_ctype(OnigCodePoint code, unsigned int ctype, OnigEncoding enc ARG_UNUSED)\n{\n  if (code < 256)\n    return ENC_IS_ISO_8859_6_CTYPE(code, ctype);\n  else\n    return FALSE;\n}", "target": 0}
{"code": "static void ext4_invalidatepage(struct page *page, unsigned long offset)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\tif (ext4_should_dioread_nolock(page->mapping->host))\n\t\text4_invalidatepage_free_endio(page, offset);\n\tif (offset == 0)\n\t\tClearPageChecked(page);\n\tif (journal)\n\t\tjbd2_journal_invalidatepage(journal, page, offset);\n\telse\n\t\tblock_invalidatepage(page, offset);\n}", "target": 0}
{"code": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}", "target": 1}
{"code": "int bad_format_axis(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING FLOAT_STRING SAFE_STRING \"$\",fmt);\n}", "target": 0}
{"code": "Network::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}", "target": 1}
{"code": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\t_TIFFmemcpy(tmp, cp0, cc);\n\tcp = (uint8 *) cp0;\n\tfor (count = 0; count < wc; count++) {\n\t\tuint32 byte;\n\t\tfor (byte = 0; byte < bps; byte++) {\n\t\t\t#if WORDS_BIGENDIAN\n\t\t\tcp[bps * count + byte] = tmp[byte * wc + count];\n\t\t\t#else\n\t\t\tcp[bps * count + byte] =\n\t\t\t\ttmp[(bps - byte - 1) * wc + count];\n\t\t\t#endif\n\t\t}\n\t}\n\t_TIFFfree(tmp);\n    return 1;\n}", "target": 0}
{"code": "void test_link(const char *path)\n{\n\tchar *d = strdupa(path), *tmpname;\n\td = dirname(d);\n\tsize_t len = strlen(path) + 30;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", d, (int)getpid());\n\tif (link(path, tmpname) == 0) {\n\t\tfprintf(stderr, \"leak at link of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at link of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (link(tmpname, path) == 0) {\n\t\tfprintf(stderr, \"leak at link (2) of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at link (2) of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int ScaKwdTab(GmfMshSct *msh)\n{\n   int      KwdCod, c;\n   int64_t  NexPos, EndPos, LstPos;\n   char     str[ GmfStrSiz ];\n   if(msh->typ & Asc)\n   {\n      while(fscanf(msh->hdl, \"%s\", str) != EOF)\n      {\n         if(isalpha(str[0]))\n         {\n            for(KwdCod=1; KwdCod<= GmfMaxKwd; KwdCod++)\n               if(!strcmp(str, GmfKwdFmt[ KwdCod ][0]))\n               {\n                  ScaKwdHdr(msh, KwdCod);\n                  break;\n               }\n         }\n         else if(str[0] == '#')\n            while((c = fgetc(msh->hdl)) != '\\n' && c != EOF);\n      }\n   }\n   else\n   {\n      EndPos = GetFilSiz(msh);\n      LstPos = -1;\n      do\n      {\n         ScaWrd(msh, ( char *)&KwdCod);\n         NexPos = GetPos(msh);\n         if(NexPos > EndPos)\n            longjmp(msh->err, -24);\n         if(NexPos && (NexPos <= LstPos))\n            longjmp(msh->err, -30);\n         LstPos = NexPos;\n         if( (KwdCod >= 1) && (KwdCod <= GmfMaxKwd) )\n            ScaKwdHdr(msh, KwdCod);\n         if(NexPos && !(SetFilPos(msh, NexPos)))\n            longjmp(msh->err, -25);\n      }while(NexPos && (KwdCod != GmfEnd));\n   }\n   return(1);\n}", "target": 1}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RzBinDwarfDebugInfo *info, RzBinDwarfAbbrevDecl *abbrev,\n\tRzBinDwarfCompUnitHdr *hdr, RzBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, bool big_endian) {\n\tsize_t i;\n\tconst char *comp_dir = NULL;\n\tut64 line_info_offset = UT64_MAX;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset(&die->attr_values[i], 0, sizeof(die->attr_values[i]));\n\t\tbuf = parse_attr_value(buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len, big_endian);\n\t\tRzBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tif (attribute->attr_name == DW_AT_comp_dir && (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string) && attribute->string.content) {\n\t\t\tcomp_dir = attribute->string.content;\n\t\t}\n\t\tif (attribute->attr_name == DW_AT_stmt_list) {\n\t\t\tif (attribute->kind == DW_AT_KIND_CONSTANT) {\n\t\t\t\tline_info_offset = attribute->uconstant;\n\t\t\t} else if (attribute->kind == DW_AT_KIND_REFERENCE) {\n\t\t\t\tline_info_offset = attribute->reference;\n\t\t\t}\n\t\t}\n\t\tdie->count++;\n\t}\n\tif (comp_dir && line_info_offset != UT64_MAX) {\n\t\tchar *name = strdup(comp_dir);\n\t\tif (name) {\n\t\t\tif (!ht_up_insert(info->line_info_offset_comp_dir, line_info_offset, name)) {\n\t\t\t\tfree(name);\n\t\t\t}\n\t\t}\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeIndexedHeapType(HeapType type) {\n  o << U32LEB(getTypeIndex(type));\n}", "target": 0}
{"code": "CMD_FUNC(m_authenticate)\n{\n\taClient *agent_p = NULL;\n\tif (!SASL_SERVER || !MyConnect(sptr) || BadPtr(parv[1]) || !CHECKPROTO(sptr, PROTO_SASL))\n\t\treturn 0;\n\tif (sptr->local->sasl_complete)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLALREADY), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\tif ((parv[1][0] == ':') || strchr(parv[1], ' '))\n\t{\n\t\tsendto_one(sptr, err_str(ERR_CANNOTDOCOMMAND), me.name, \"*\", \"AUTHENTICATE\", \"Invalid parameter\");\n\t\treturn 0;\n\t}\n\tif (strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(sptr, err_str(ERR_SASLTOOLONG), me.name, BadPtr(sptr->name) ? \"*\" : sptr->name);\n\t\treturn 0;\n\t}\n\tif (*sptr->local->sasl_agent)\n\t\tagent_p = find_client(sptr->local->sasl_agent, NULL);\n\tif (agent_p == NULL)\n\t{\n\t\tchar *addr = BadPtr(sptr->ip) ? \"0\" : sptr->ip;\n\t\tchar *certfp = moddata_client_get(sptr, \"certfp\");\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s H %s %s\",\n\t\t    me.name, SASL_SERVER, encode_puid(sptr), addr, addr);\n\t\tif (certfp)\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1], certfp);\n\t\telse\n\t\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s S %s\",\n\t\t\t    me.name, SASL_SERVER, encode_puid(sptr), parv[1]);\n\t}\n\telse\n\t\tsendto_server(NULL, 0, 0, \":%s SASL %s %s C %s\",\n\t\t    me.name, AGENT_SID(agent_p), encode_puid(sptr), parv[1]);\n\tsptr->local->sasl_out++;\n\treturn 0;\n}", "target": 0}
{"code": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void Document::setCookie(const String& value, ExceptionState& exception_state) {\n  if (GetSettings() && !GetSettings()->GetCookieEnabled())\n    return;\n  UseCounter::Count(*this, WebFeature::kCookieSet);\n  if (!GetSecurityOrigin()->CanAccessCookies()) {\n    if (IsSandboxed(kSandboxOrigin))\n      exception_state.ThrowSecurityError(\n          \"The document is sandboxed and lacks the 'allow-same-origin' flag.\");\n    else if (Url().ProtocolIs(\"data\"))\n      exception_state.ThrowSecurityError(\n          \"Cookies are disabled inside 'data:' URLs.\");\n    else\n      exception_state.ThrowSecurityError(\"Access is denied for this document.\");\n    return;\n  }\n  if (GetSecurityOrigin()->HasSuborigin() &&\n      !GetSecurityOrigin()->GetSuborigin()->PolicyContains(\n          Suborigin::SuboriginPolicyOptions::kUnsafeCookies))\n    return;\n  KURL cookie_url = CookieURL();\n  if (cookie_url.IsEmpty())\n    return;\n  SetCookies(this, cookie_url, value);\n}", "target": 0}
{"code": "static void smp_task_timedout(struct timer_list *t)\n{\n\tstruct sas_task_slow *slow = from_timer(slow, t, timer);\n\tstruct sas_task *task = slow->task;\n\tunsigned long flags;\n\tspin_lock_irqsave(&task->task_state_lock, flags);\n\tif (!(task->task_state_flags & SAS_TASK_STATE_DONE))\n\t\ttask->task_state_flags |= SAS_TASK_STATE_ABORTED;\n\tspin_unlock_irqrestore(&task->task_state_lock, flags);\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "u64 gf_isom_get_sample_dts(GF_ISOFile *the_file, u32 trackNumber, u32 sampleNumber)\n{\n\tu64 dts;\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return 0;\n\tif (!sampleNumber) return 0;\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tif (sampleNumber<=trak->sample_count_at_seg_start) return 0;\n\tsampleNumber -= trak->sample_count_at_seg_start;\n#endif\n\tif (stbl_GetSampleDTS(trak->Media->information->sampleTable->TimeToSample, sampleNumber, &dts) != GF_OK) return 0;\n\treturn dts;\n}", "target": 0}
{"code": "bool allow_svhandler_flash_sector_num(int sector) {\n  for (const FlashSector *s = flash_sector_map; s->use != FLASH_INVALID; s++) {\n    if (s->sector == sector) return allow_svhandler_flash_sector(s);\n  }\n  return false;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* axis = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, axis != nullptr);\n  TF_LITE_ENSURE_MSG(context, IsConstantTensor(axis),\n                     \"Non constant axis tensor not supported\");\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void FastCGITransport::onHeader(std::unique_ptr<folly::IOBuf> key_chain,\n                                std::unique_ptr<folly::IOBuf> value_chain) {\n  Cursor keyCur(key_chain.get());\n  auto key = keyCur.readFixedString(key_chain->computeChainDataLength());\n  if (strcasecmp(key.c_str(), \"HTTP_PROXY\") == 0) return;\n  Cursor valCur(value_chain.get());\n  auto value = valCur.readFixedString(value_chain->computeChainDataLength());\n  m_requestParams[key] = value;\n}", "target": 0}
{"code": "static int rr_handle_error(READ_RECORD *info, int error)\n{\n  if (info->thd->killed)\n  {\n    info->thd->send_kill_message();\n    return 1;\n  }\n  if (error == HA_ERR_END_OF_FILE)\n    error= -1;\n  else\n  {\n    if (info->print_error)\n      info->table->file->print_error(error, MYF(0));\n    if (error < 0)                            \n      error= 1;\n  }\n  return error;\n}", "target": 0}
{"code": "dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n\tSlapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err\n)\n{\n\tstruct backentry *e = NULL;\n\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n        const char *ptr;\n        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));\n        slapi_sdn_set_normdn_byref(ancestordn, ptr); \n        ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(sdn));\n        slapi_sdn_init_ndn_byref(&ancestorndn, ptr);\n        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));\n                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); \n                ptr = slapi_dn_find_parent(slapi_sdn_get_dn(ancestordn));\n                slapi_sdn_set_normdn_byref(ancestordn, ptr); \n            }\n        }\n        slapi_sdn_done(&ancestorndn);\n    }\n    LDAPDebug( LDAP_DEBUG_TRACE, \"<= dn2ancestor %p\\n\", e, 0, 0 );\n    return( e );\n}", "target": 1}
{"code": "gopher_request_parse(const HttpRequest * req, char *type_id, char *request)\n{\n    ::Parser::Tokenizer tok(req->url.path());\n    if (request)\n        *request = 0;\n    tok.skip('/'); \n    if (tok.atEnd()) {\n        *type_id = GOPHER_DIRECTORY;\n        return;\n    }\n    static const CharacterSet anyByte(\"UTF-8\",0x00, 0xFF);\n    SBuf typeId;\n    (void)tok.prefix(typeId, anyByte, 1); \n    *type_id = typeId[0];\n    if (request) {\n        SBufToCstring(request, tok.remaining().substr(0, MAX_URL-1));\n        rfc1738_unescape(request);\n    }\n}", "target": 1}
{"code": "void IOBuf::allocExtBuffer(\n    std::size_t minCapacity,\n    uint8_t** bufReturn,\n    SharedInfo** infoReturn,\n    std::size_t* capacityReturn) {\n  if (minCapacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t mallocSize = goodExtBufferSize(minCapacity);\n  auto buf = static_cast<uint8_t*>(checkedMalloc(mallocSize));\n  initExtBuffer(buf, mallocSize, infoReturn, capacityReturn);\n  (*infoReturn)->userData = reinterpret_cast<void*>(mallocSize);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(buf, mallocSize);\n  }\n  *bufReturn = buf;\n}", "target": 0}
{"code": "void js_RegExp_prototype_exec(js_State *J, js_Regexp *re, const char *text)\n{\n\tint i;\n\tint opts;\n\tResub m;\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushnull(J);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tjs_newarray(J);\n\t\tjs_pushstring(J, text);\n\t\tjs_setproperty(J, -2, \"input\");\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\t\tjs_setproperty(J, -2, \"index\");\n\t\tfor (i = 0; i < m.nsub; ++i) {\n\t\t\tjs_pushlstring(J, m.sub[i].sp, m.sub[i].ep - m.sub[i].sp);\n\t\t\tjs_setindex(J, -2, i);\n\t\t}\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushnull(J);\n}", "target": 1}
{"code": "static StkId rethook (lua_State *L, CallInfo *ci, StkId firstres, int nres) {\n  ptrdiff_t oldtop = savestack(L, L->top);  \n  int delta = 0;\n  if (isLuacode(ci)) {\n    Proto *p = clLvalue(s2v(ci->func))->p;\n    if (p->is_vararg)\n      delta = ci->u.l.nextraargs + p->numparams + 1;\n    if (L->top < ci->top)\n      L->top = ci->top;  \n  }\n  if (L->hookmask & LUA_MASKRET) {  \n    int ftransfer;\n    ci->func += delta;  \n    ftransfer = cast(unsigned short, firstres - ci->func);\n    luaD_hook(L, LUA_HOOKRET, -1, ftransfer, nres);  \n    ci->func -= delta;\n  }\n  if (isLua(ci->previous))\n    L->oldpc = ci->previous->u.l.savedpc;  \n  return restorestack(L, oldtop);\n}", "target": 1}
{"code": "bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) {\n  if (axis.getNumElements() == 0) {\n    return false;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() - 1 ==\n          *axis.getValues<int>().begin() ||\n      *axis.getValues<int>().begin() == -1) {\n    return true;\n  }\n  if (sq_op.getType().cast<ShapedType>().getRank() != axis.getNumElements()) {\n    return false;\n  }\n  auto shape = sq_op.getType().cast<ShapedType>();\n  SmallVector<int, 4> elems{axis.getValues<int>().begin(),\n                            axis.getValues<int>().end()};\n  for (int i = 0; i < shape.getRank(); ++i) {\n    if (i != elems[i]) return false;\n  }\n  return true;\n}", "target": 0}
{"code": "main (void)\n{\n  char *login;\n  int errors = 0;\n  login = getlogin ();\n  if (login == NULL)\n    puts (\"getlogin returned NULL, no further tests\");\n  else\n    {\n      char name[1024];\n      int ret;\n      printf (\"getlogin returned: `%s'\\n\", login);\n      ret = getlogin_r (name, sizeof (name));\n      if (ret == 0)\n\t{\n\t  printf (\"getlogin_r returned: `%s'\\n\", name);\n\t  if (strcmp (name, login) != 0)\n\t    {\n\t      puts (\"Error: getlogin and getlogin_r returned different names\");\n\t      ++errors;\n\t    }\n\t}\n      else\n\t{\n\t  printf (\"Error: getlogin_r returned: %d (%s)\\n\",\n\t\t  ret, strerror (ret));\n\t  ++errors;\n\t}\n    }\n  return errors != 0;\n}", "target": 0}
{"code": "\tvoid initialize(const string &path, bool owner) {\n\t\tTRACE_POINT();\n\t\tthis->path  = path;\n\t\tthis->owner = owner;\n\t\tif (owner) {\n\t\t\tswitch (getFileTypeNoFollowSymlinks(path)) {\n\t\t\tcase FT_NONEXISTANT:\n\t\t\t\tcreateDirectory(path);\n\t\t\t\tbreak;\n\t\t\tcase FT_DIRECTORY:\n\t\t\t\tverifyDirectoryPermissions(path);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow RuntimeException(\"'\" + path + \"' already exists, and is not a directory\");\n\t\t\t}\n\t\t} else if (getFileType(path) != FT_DIRECTORY) {\n\t\t\tthrow RuntimeException(\"Server instance directory '\" + path +\n\t\t\t\t\"' does not exist\");\n\t\t}\n\t}", "target": 1}
{"code": "bool use_client_socket(int fd, PgAddr *addr,\n\t\t       const char *dbname, const char *username,\n\t\t       uint64_t ckey, int oldfd, int linkfd,\n\t\t       const char *client_enc, const char *std_string,\n\t\t       const char *datestyle, const char *timezone)\n{\n\tPgSocket *client;\n\tPktBuf tmp;\n\tclient = accept_client(fd, pga_is_unix(addr));\n\tif (client == NULL)\n\t\treturn false;\n\tclient->suspended = 1;\n\tif (!set_pool(client, dbname, username))\n\t\treturn false;\n\tchange_client_state(client, CL_ACTIVE);\n\tpktbuf_static(&tmp, client->cancel_key, 8);\n\tpktbuf_put_uint64(&tmp, ckey);\n\tclient->tmp_sk_oldfd = oldfd;\n\tclient->tmp_sk_linkfd = linkfd;\n\tvarcache_set(&client->vars, \"client_encoding\", client_enc);\n\tvarcache_set(&client->vars, \"standard_conforming_strings\", std_string);\n\tvarcache_set(&client->vars, \"datestyle\", datestyle);\n\tvarcache_set(&client->vars, \"timezone\", timezone);\n\treturn true;\n}", "target": 0}
{"code": "_SSL_match_hostname (const char *cert_hostname, const char *hostname)\n{\n\tconst char *cert_domain, *domain, *next_dot;\n\tif (g_ascii_strcasecmp (cert_hostname, hostname) == 0)\n\t\treturn 0;\n\tif (cert_hostname[0] == '*')\n\t{\n\t\tcert_domain = &cert_hostname[1];\n\t\tif (cert_domain[0] == '\\0')\n\t\t\treturn -1;\n\t\tif (cert_domain[0] != '.')\n\t\t\treturn -1;\n\t\tif (cert_domain[1] == '.')\n\t\t\treturn -1;\n\t\tnext_dot = strchr (&cert_domain[1], '.');\n\t\tif (next_dot == NULL)\n\t\t\treturn -1;\n\t\tif (next_dot[1] == '.')\n\t\t\treturn -1;\n\t\tdomain = strchr (hostname, '.');\n\t\tif (domain == NULL || strlen(domain) == 1)\n\t\t\treturn -1;\n\t\tif (g_ascii_strcasecmp (cert_domain, domain) == 0)\n\t\t\treturn 0;\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "static void addDimensions(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n    IODMultiframeDimensionModule &dims = ct->getDimensions();\n    OFCHECK(dims.addDimensionIndex(\n                    DCM_StackID, \"2.25.30855560781715986879861690673941231222\", DCM_FrameContentSequence, \"STACK_DIM\")\n                .good());\n    OFCHECK(dims.addDimensionIndex(DCM_InStackPositionNumber,\n                                   \"2.25.30855560781715986879861690673941231222\",\n                                   DCM_FrameContentSequence,\n                                   \"STACK_DIM\")\n                .good());\n    OFunique_ptr<IODMultiframeDimensionModule::DimensionOrganizationItem> org(\n        new IODMultiframeDimensionModule::DimensionOrganizationItem);\n    if (org)\n    {\n        org->setDimensionOrganizationUID(\"2.25.30855560781715986879861690673941231222\");\n        dims.getDimensionOrganizationSequence().push_back(org.release());\n    }\n}", "target": 0}
{"code": "void WebGLRenderingContextBase::PushFrame() {\n  if (!marked_canvas_dirty_)\n    return;\n  marked_canvas_dirty_ = false;\n  int width = GetDrawingBuffer()->Size().Width();\n  int height = GetDrawingBuffer()->Size().Height();\n  if (!GetDrawingBuffer()) {\n    return Host()->PushFrame(nullptr, SkIRect::MakeWH(width, height));\n  }\n  std::unique_ptr<viz::SingleReleaseCallback> image_release_callback;\n  scoped_refptr<StaticBitmapImage> image =\n      GetStaticBitmapImage(&image_release_callback);\n  GetDrawingBuffer()->SwapPreviousFrameCallback(\n      std::move(image_release_callback));\n  return Host()->PushFrame(std::move(image), SkIRect::MakeWH(width, height));\n}", "target": 0}
{"code": "static void adpt_i2o_post_wait_complete(u32 context, int status)\n{\n\tstruct adpt_i2o_post_wait_data *p1 = NULL;\n\tcontext &= 0x7fff;\n\tspin_lock(&adpt_post_wait_lock);\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tif(p1->id == context) {\n\t\t\tp1->status = status;\n\t\t\tspin_unlock(&adpt_post_wait_lock);\n\t\t\twake_up_interruptible(p1->wq);\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock(&adpt_post_wait_lock);\n\tprintk(KERN_DEBUG\"dpti: Could Not find task %d in wait queue\\n\",context);\n\tprintk(KERN_DEBUG\"      Tasks in wait queue:\\n\");\n\tfor(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {\n\t\tprintk(KERN_DEBUG\"           %d\\n\",p1->id);\n\t}\n\treturn;\n}", "target": 1}
{"code": "static int smb2_resp_buf_len(struct ksmbd_work *work, unsigned short hdr2_len)\n{\n\tint free_len;\n\tfree_len = (int)(work->response_sz -\n\t\t(get_rfc1002_len(work->response_buf) + 4)) - hdr2_len;\n\treturn free_len;\n}", "target": 0}
{"code": "  StringTableEntry getStringTableEntry(uint32_t index) const override {\n    llvm_unreachable(\"Accessing string table from a lazy module\");\n  }", "target": 1}
{"code": "GF_Box *vwid_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ViewIdentifierBox, GF_ISOM_BOX_TYPE_VWID);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,\n\t\t\t\t u32 sg_table_count)\n{\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tu32 i, j, page_count = 0, sg_per_table;\n\tfor (i = 0; i < sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tkfree(sg_table);\n\treturn page_count;\n}", "target": 0}
{"code": "long kvm_arch_vcpu_ioctl(struct file *filp,\n\t\t\t unsigned int ioctl, unsigned long arg)\n{\n\tstruct kvm_vcpu *vcpu = filp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tswitch (ioctl) {\n\tcase KVM_ARM_VCPU_INIT: {\n\t\tstruct kvm_vcpu_init init;\n\t\tif (copy_from_user(&init, argp, sizeof(init)))\n\t\t\treturn -EFAULT;\n\t\treturn kvm_vcpu_set_target(vcpu, &init);\n\t}\n\tcase KVM_SET_ONE_REG:\n\tcase KVM_GET_ONE_REG: {\n\t\tstruct kvm_one_reg reg;\n\t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n\t\t\treturn -ENOEXEC;\n\t\tif (copy_from_user(&reg, argp, sizeof(reg)))\n\t\t\treturn -EFAULT;\n\t\tif (ioctl == KVM_SET_ONE_REG)\n\t\t\treturn kvm_arm_set_reg(vcpu, &reg);\n\t\telse\n\t\t\treturn kvm_arm_get_reg(vcpu, &reg);\n\t}\n\tcase KVM_GET_REG_LIST: {\n\t\tstruct kvm_reg_list __user *user_list = argp;\n\t\tstruct kvm_reg_list reg_list;\n\t\tunsigned n;\n\t\tif (unlikely(!kvm_vcpu_initialized(vcpu)))\n\t\t\treturn -ENOEXEC;\n\t\tif (copy_from_user(&reg_list, user_list, sizeof(reg_list)))\n\t\t\treturn -EFAULT;\n\t\tn = reg_list.n;\n\t\treg_list.n = kvm_arm_num_regs(vcpu);\n\t\tif (copy_to_user(user_list, &reg_list, sizeof(reg_list)))\n\t\t\treturn -EFAULT;\n\t\tif (n < reg_list.n)\n\t\t\treturn -E2BIG;\n\t\treturn kvm_arm_copy_reg_indices(vcpu, user_list->reg);\n\t}\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "static void xar_get_checksum_values(xmlTextReaderPtr reader, unsigned char ** cksum, int * hash)\n{\n    xmlChar * style = xmlTextReaderGetAttribute(reader, (const xmlChar *)\"style\");\n    const xmlChar * xmlval;\n    *hash = XAR_CKSUM_NONE;\n    if (style == NULL) {\n        cli_dbgmsg(\"cli_scaxar: xmlTextReaderGetAttribute no style attribute \"\n                   \"for checksum element\\n\");\n    } else {\n        cli_dbgmsg(\"cli_scanxar: checksum algorithm is %s.\\n\", style);        \n        if (0 == xmlStrcasecmp(style, (const xmlChar *)\"sha1\")) {\n            *hash = XAR_CKSUM_SHA1;\n        } else if (0 == xmlStrcasecmp(style, (const xmlChar *)\"md5\")) {\n            *hash = XAR_CKSUM_MD5;\n        } else {\n            cli_dbgmsg(\"cli_scanxar: checksum algorithm %s is unsupported.\\n\", style);\n            *hash = XAR_CKSUM_OTHER;\n        }\n    }\n    if (style != NULL)\n        xmlFree(style);\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        xmlval = xmlTextReaderConstValue(reader);\n        if (xmlval) {\n            *cksum = xmlStrdup(xmlval); \n            cli_dbgmsg(\"cli_scanxar: checksum value is %s.\\n\", *cksum);\n        } else {\n            *cksum = NULL;\n            cli_dbgmsg(\"cli_scanxar: xmlTextReaderConstValue() returns NULL for checksum value.\\n\");           \n        }\n    }\n    else\n        cli_dbgmsg(\"cli_scanxar: No text for XML checksum element.\\n\");\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec)\n{\n  struct mrb_context *c = fiber_check(mrb, self);\n  struct mrb_context *old_c = mrb->c;\n  enum mrb_fiber_state status;\n  mrb_value value;\n  fiber_check_cfunc(mrb, c);\n  status = c->status;\n  switch (status) {\n  case MRB_FIBER_TRANSFERRED:\n    if (resume) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"resuming transferred fiber\");\n    }\n    break;\n  case MRB_FIBER_RUNNING:\n  case MRB_FIBER_RESUMED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"double resume\");\n    break;\n  case MRB_FIBER_TERMINATED:\n    mrb_raise(mrb, E_FIBER_ERROR, \"resuming dead fiber\");\n    break;\n  default:\n    break;\n  }\n  old_c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED;\n  c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c);\n  fiber_switch_context(mrb, c);\n  if (status == MRB_FIBER_CREATED) {\n    mrb_value *b, *e;\n    if (!c->ci->proc) {\n      mrb_raise(mrb, E_FIBER_ERROR, \"double resume (current)\");\n    }\n    mrb_stack_extend(mrb, len+2); \n    b = c->stbase+1;\n    e = b + len;\n    while (b<e) {\n      *b++ = *a++;\n    }\n    if (vmexec) {\n      c->ci--;                    \n    }\n    c->cibase->n = len;\n    value = c->stbase[0] = MRB_PROC_ENV(c->cibase->proc)->stack[0];\n  }\n  else {\n    value = fiber_result(mrb, a, len);\n    if (vmexec) {\n      c->ci[1].stack[0] = value;\n    }\n  }\n  if (vmexec) {\n    c->vmexec = TRUE;\n    value = mrb_vm_exec(mrb, c->ci->proc, c->ci->pc);\n    mrb->c = old_c;\n  }\n  else {\n    MARK_CONTEXT_MODIFY(c);\n  }\n  return value;\n}", "target": 1}
{"code": "local void init_block(s)\n    deflate_state *s;\n{\n    int n; \n    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;\n    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;\n    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;\n    s->dyn_ltree[END_BLOCK].Freq = 1;\n    s->opt_len = s->static_len = 0L;\n    s->last_lit = s->matches = 0;\n}", "target": 1}
{"code": "        unsigned int GetUVarBE(int nPos, int nSize, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + nSize > m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = 0;\n            for ( int nIndex = 0; nIndex < nSize; ++nIndex )\n                nRes = (nRes << 8) + m_sFile[nPos + nIndex];\n            return nRes;\n        }", "target": 1}
{"code": "PJ_DEF(void) pj_scan_skip_line( pj_scanner *scanner )\n{\n    char *s = pj_memchr(scanner->curptr, '\\n', scanner->end - scanner->curptr);\n    if (!s) {\n\tscanner->curptr = scanner->end;\n    } else {\n\tscanner->curptr = scanner->start_line = s+1;\n\tscanner->line++;\n   }\n}", "target": 1}
{"code": "static inline bool nvme_is_write(NvmeRequest *req)\n{\n    NvmeRwCmd *rw = (NvmeRwCmd *)&req->cmd;\n    return rw->opcode == NVME_CMD_WRITE ||\n           rw->opcode == NVME_CMD_ZONE_APPEND ||\n           rw->opcode == NVME_CMD_WRITE_ZEROES;\n}", "target": 0}
{"code": "static int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qual;\n\tif (kvm_event_needs_reinjection(vcpu))\n\t\treturn -EBUSY;\n\tif (vcpu->arch.exception.pending &&\n\t\tnested_vmx_check_exception(vcpu, &exit_qual)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_inject_exception_vmexit(vcpu, exit_qual);\n\t\tvcpu->arch.exception.pending = false;\n\t\treturn 0;\n\t}\n\tif (nested_cpu_has_preemption_timer(get_vmcs12(vcpu)) &&\n\t    vmx->nested.preemption_timer_expired) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_PREEMPTION_TIMER, 0, 0);\n\t\treturn 0;\n\t}\n\tif (vcpu->arch.nmi_pending && nested_exit_on_nmi(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,\n\t\t\t\t  NMI_VECTOR | INTR_TYPE_NMI_INTR |\n\t\t\t\t  INTR_INFO_VALID_MASK, 0);\n\t\tvcpu->arch.nmi_pending = 0;\n\t\tvmx_set_nmi_mask(vcpu, true);\n\t\treturn 0;\n\t}\n\tif ((kvm_cpu_has_interrupt(vcpu) || external_intr) &&\n\t    nested_exit_on_intr(vcpu)) {\n\t\tif (vmx->nested.nested_run_pending)\n\t\t\treturn -EBUSY;\n\t\tnested_vmx_vmexit(vcpu, EXIT_REASON_EXTERNAL_INTERRUPT, 0, 0);\n\t\treturn 0;\n\t}\n\tvmx_complete_nested_posted_interrupt(vcpu);\n\treturn 0;\n}", "target": 0}
{"code": "static int oidc_cache_crypto_encrypt(request_rec *r, const char *plaintext,\n\t\tunsigned char *key, char **result) {\n\tchar *encoded = NULL, *p = NULL, *e_tag = NULL;\n\tunsigned char *ciphertext = NULL;\n\tint plaintext_len, ciphertext_len, encoded_len, e_tag_len;\n\tunsigned char tag[OIDC_CACHE_TAG_LEN];\n\tplaintext_len = strlen(plaintext) + 1;\n\tciphertext = apr_pcalloc(r->pool,\n\t\t\t(plaintext_len + EVP_CIPHER_block_size(OIDC_CACHE_CIPHER)));\n\tciphertext_len = oidc_cache_crypto_encrypt_impl(r,\n\t\t\t(unsigned char *) plaintext, plaintext_len,\n\t\t\tOIDC_CACHE_CRYPTO_GCM_AAD, sizeof(OIDC_CACHE_CRYPTO_GCM_AAD), key,\n\t\t\tOIDC_CACHE_CRYPTO_GCM_IV, sizeof(OIDC_CACHE_CRYPTO_GCM_IV),\n\t\t\tciphertext, tag, sizeof(tag));\n\tencoded_len = oidc_base64url_encode(r, &encoded, (const char *) ciphertext,\n\t\t\tciphertext_len, 1);\n\tif (encoded_len > 0) {\n\t\tp = encoded;\n\t\te_tag_len = oidc_base64url_encode(r, &e_tag, (const char *) tag,\n\t\t\t\tOIDC_CACHE_TAG_LEN, 1);\n\t\tencoded = apr_pcalloc(r->pool, encoded_len + 1 + e_tag_len + 1);\n\t\tmemcpy(encoded, p, encoded_len);\n\t\tp = encoded + encoded_len;\n\t\t*p = OIDC_CHAR_DOT;\n\t\tp++;\n\t\tmemcpy(p, e_tag, e_tag_len);\n\t\tencoded_len += e_tag_len + 1;\n\t\tencoded[encoded_len] = '\\0';\n\t\t*result = encoded;\n\t}\n\treturn encoded_len;\n}", "target": 1}
{"code": "static long process_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\nskipabs:\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "inline static jas_int_asl(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x << n;\n}", "target": 0}
{"code": "inline uint32_t mult_alpha(uint32_t a, uint32_t b)\n{\n    return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;\n}", "target": 0}
{"code": "void AdsIntegrationTest::initializeAds(const bool rate_limiting) {\n  config_helper_.addRuntimeOverride(\"envoy.restart_features.explicit_wildcard_resource\",\n                                    oldDssOrNewDss() == OldDssOrNewDss::Old ? \"false\" : \"true\");\n  config_helper_.addConfigModifier([this, &rate_limiting](\n                                       envoy::config::bootstrap::v3::Bootstrap& bootstrap) {\n    auto* ads_config = bootstrap.mutable_dynamic_resources()->mutable_ads_config();\n    if (rate_limiting) {\n      ads_config->mutable_rate_limit_settings();\n    }\n    auto* grpc_service = ads_config->add_grpc_services();\n    setGrpcService(*grpc_service, \"ads_cluster\", xds_upstream_->localAddress());\n    auto* ads_cluster = bootstrap.mutable_static_resources()->add_clusters();\n    ads_cluster->MergeFrom(bootstrap.static_resources().clusters()[0]);\n    ads_cluster->set_name(\"ads_cluster\");\n    envoy::extensions::transport_sockets::tls::v3::UpstreamTlsContext context;\n    auto* validation_context = context.mutable_common_tls_context()->mutable_validation_context();\n    validation_context->mutable_trusted_ca()->set_filename(\n        TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    validation_context->add_match_subject_alt_names()->set_suffix(\"lyft.com\");\n    if (clientType() == Grpc::ClientType::GoogleGrpc) {\n      auto* google_grpc = grpc_service->mutable_google_grpc();\n      auto* ssl_creds = google_grpc->mutable_channel_credentials()->mutable_ssl_credentials();\n      ssl_creds->mutable_root_certs()->set_filename(\n          TestEnvironment::runfilesPath(\"test/config/integration/certs/upstreamcacert.pem\"));\n    }\n    ads_cluster->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n    ads_cluster->mutable_transport_socket()->mutable_typed_config()->PackFrom(context);\n  });\n  HttpIntegrationTest::initialize();\n  if (xds_stream_ == nullptr) {\n    createXdsConnection();\n    AssertionResult result = xds_connection_->waitForNewStream(*dispatcher_, xds_stream_);\n    RELEASE_ASSERT(result, result.message());\n    xds_stream_->startGrpcStream();\n  }\n}", "target": 1}
{"code": "ospf6_print_lshdr(netdissect_options *ndo,\n                  register const struct lsa6_hdr *lshp, const u_char *dataend)\n{\n\tif ((const u_char *)(lshp + 1) > dataend)\n\t\tgoto trunc;\n\tND_TCHECK(lshp->ls_type);\n\tND_TCHECK(lshp->ls_seq);\n\tND_PRINT((ndo, \"\\n\\t  Advertising Router %s, seq 0x%08x, age %us, length %u\",\n               ipaddr_string(ndo, &lshp->ls_router),\n               EXTRACT_32BITS(&lshp->ls_seq),\n               EXTRACT_16BITS(&lshp->ls_age),\n               EXTRACT_16BITS(&lshp->ls_length)-(u_int)sizeof(struct lsa6_hdr)));\n\tospf6_print_ls_type(ndo, EXTRACT_16BITS(&lshp->ls_type), &lshp->ls_stateid);\n\treturn (0);\ntrunc:\n\treturn (1);\n}", "target": 1}
{"code": "void SslSPIFFECertValidatorIntegrationTest::addStringMatcher(\n    const envoy::type::matcher::v3::StringMatcher& matcher) {\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL);\n  san_matchers_.emplace_back();\n  *san_matchers_.back().mutable_matcher() = matcher;\n  san_matchers_.back().set_san_type(\n      envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS);\n}", "target": 0}
{"code": "int digest_generic_verify(struct digest *d, const unsigned char *md)\n{\n\tint ret;\n\tint len = digest_length(d);\n\tunsigned char *tmp;\n\ttmp = xmalloc(len);\n\tret = digest_final(d, tmp);\n\tif (ret)\n\t\tgoto end;\n\tret = memcmp(md, tmp, len);\n\tret = ret ? -EINVAL : 0;\nend:\n\tfree(tmp);\n\treturn ret;\n}", "target": 1}
{"code": "static void sycc444_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b;\n\tconst int *y, *cb, *cr;\n\tunsigned int maxw, maxh, max, i;\n\tint offset, upb;\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\tfor(i = 0U; i < max; ++i)\n\t{\n\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t++y; ++cb; ++cr; ++r; ++g; ++b;\n\t}\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\treturn;\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n}", "target": 1}
{"code": "static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t       struct msghdr *m, size_t len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint ret;\n\tint copylen;\n\tret = -EOPNOTSUPP;\n\tif (m->msg_flags&MSG_OOB)\n\t\tgoto read_error;\n\tm->msg_namelen = 0;\n\tskb = skb_recv_datagram(sk, flags, 0 , &ret);\n\tif (!skb)\n\t\tgoto read_error;\n\tcopylen = skb->len;\n\tif (len < copylen) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tcopylen = len;\n\t}\n\tret = skb_copy_datagram_iovec(skb, 0, m->msg_iov, copylen);\n\tif (ret)\n\t\tgoto out_free;\n\tret = (flags & MSG_TRUNC) ? skb->len : copylen;\nout_free:\n\tskb_free_datagram(sk, skb);\n\tcaif_check_flow_release(sk);\n\treturn ret;\nread_error:\n\treturn ret;\n}", "target": 1}
{"code": "int options_parse(CONF_TYPE type) {\n    SERVICE_OPTIONS *section;\n    options_defaults();\n    section=&new_service_options;\n    if(options_file(configuration_file, type, &section))\n        return 1;\n    if(init_section(1, &section))\n        return 1;\n    s_log(LOG_NOTICE, \"Configuration successful\");\n    return 0;\n}", "target": 1}
{"code": "static int ac_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception_e(&svm->vcpu, AC_VECTOR, 0);\n\treturn 1;\n}", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tchar *name = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\tRBinJavaAttrMetas *type_info = NULL;\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\tname = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\ttype_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((attr = type_info->allocs->new_obj (buffer, nsz, buf_offset))) {\n\t\t\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\t\t}\n\t} else {\n\t\teprintf (\"r_bin_java_read_next_attr_from_buffer: Cannot find type_info for %s\\n\", name);\n\t}\n\tfree (name);\n\treturn attr;\n}", "target": 1}
{"code": "TEST_FUNCTION_CLEANUP(test_cleanup)\n{\n    TEST_MUTEX_RELEASE(g_testByTest);\n}", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_annotation_default_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr && sz >= offset) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_ANNOTATION_DEFAULT_ATTR;\n\t\tattr->info.annotation_default_attr.default_value = r_bin_java_element_value_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\tif (attr->info.annotation_default_attr.default_value) {\n\t\t\toffset += attr->info.annotation_default_attr.default_value->size;\n\t\t}\n\t}\n\tr_bin_java_print_annotation_default_attr_summary (attr);\n\treturn attr;\n}", "target": 1}
{"code": "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n    for (i = 0; ; i++) {\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n    return NGX_OK;\n}", "target": 1}
{"code": "static int tls_construct_cke_dhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_DH\n    DH *dh_clnt = NULL;\n    const BIGNUM *pub_key;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    dh_clnt = EVP_PKEY_get0_DH(ckey);\n    if (dh_clnt == NULL || ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n        EVP_PKEY_free(ckey);\n        return 0;\n    }\n    DH_get0_key(dh_clnt, &pub_key, NULL);\n    *len = BN_num_bytes(pub_key);\n    s2n(*len, *p);\n    BN_bn2bin(pub_key, *p);\n    *len += 2;\n    EVP_PKEY_free(ckey);\n    return 1;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_DHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}", "target": 0}
{"code": "static int __init acpi_custom_method_init(void)\n{\n\tif (acpi_debugfs_dir == NULL)\n\t\treturn -ENOENT;\n\tcm_dentry = debugfs_create_file(\"custom_method\", S_IWUSR,\n\t\t\t\t\tacpi_debugfs_dir, NULL, &cm_fops);\n\tif (cm_dentry == NULL)\n\t\treturn -ENODEV;\n\treturn 0;\n}", "target": 0}
{"code": "static SDL_Surface *Create_Surface_Blended(int width, int height, SDL_Color fg, Uint32 *color)\n{\n    const int alignment = Get_Alignement() - 1;\n    SDL_Surface *textbuf = NULL;\n    Uint32 bgcolor;\n    bgcolor = (fg.r << 16) | (fg.g << 8) | fg.b;\n    *color = bgcolor | (fg.a << 24);\n    if (width != 0) {\n        Sint64 size;\n        void *pixels, *ptr;\n        Sint64 pitch = (width + alignment) * 4;\n        pitch += alignment;\n        pitch &= ~alignment;\n        size = height * pitch + sizeof (void *) + alignment;\n        if (size < 0 || size > SDL_MAX_SINT32) {\n            return NULL;\n        }\n        ptr = SDL_malloc((size_t)size);\n        if (ptr == NULL) {\n            return NULL;\n        }\n        pixels = (void *)(((uintptr_t)ptr + sizeof(void *) + alignment) & ~alignment);\n        ((void **)pixels)[-1] = ptr;\n        textbuf = SDL_CreateRGBSurfaceWithFormatFrom(pixels, width, height, 0, pitch, SDL_PIXELFORMAT_ARGB8888);\n        if (textbuf == NULL) {\n            SDL_free(ptr);\n            return NULL;\n        }\n        textbuf->flags &= ~SDL_PREALLOC;\n        textbuf->flags |= SDL_SIMD_ALIGNED;\n        SDL_memset4(pixels, bgcolor, (height * pitch) / 4);\n        if (fg.a != SDL_ALPHA_OPAQUE) {\n            SDL_SetSurfaceBlendMode(textbuf, SDL_BLENDMODE_BLEND);\n        }\n    }\n    return textbuf;", "target": 1}
{"code": "BOOL freerdp_image_copy(BYTE* pDstData, DWORD DstFormat, UINT32 nDstStep, UINT32 nXDst,\n                        UINT32 nYDst, UINT32 nWidth, UINT32 nHeight, const BYTE* pSrcData,\n                        DWORD SrcFormat, UINT32 nSrcStep, UINT32 nXSrc, UINT32 nYSrc,\n                        const gdiPalette* palette, UINT32 flags)\n{\n\tconst UINT32 dstByte = FreeRDPGetBytesPerPixel(DstFormat);\n\tconst UINT32 srcByte = FreeRDPGetBytesPerPixel(SrcFormat);\n\tif ((nHeight > INT32_MAX) || (nWidth > INT32_MAX))\n\t\treturn FALSE;\n\tif (!pDstData || !pSrcData)\n\t\treturn FALSE;\n\tif ((nWidth == 0) || (nHeight == 0))\n\t\treturn TRUE;\n\tif (nDstStep == 0)\n\t\tnDstStep = nWidth * FreeRDPGetBytesPerPixel(DstFormat);\n\tif (nSrcStep == 0)\n\t\tnSrcStep = nWidth * FreeRDPGetBytesPerPixel(SrcFormat);\n\tconst BOOL ovl = overlapping(pDstData, nXDst, nYDst, nDstStep, dstByte, pSrcData, nXSrc, nYSrc,\n\t                             nSrcStep, srcByte, nWidth, nHeight);\n\tif (ovl)\n\t\treturn freerdp_image_copy_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,\n\t\t                                  nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,\n\t\t                                  palette, flags);\n\treturn freerdp_image_copy_no_overlap(pDstData, DstFormat, nDstStep, nXDst, nYDst, nWidth,\n\t                                     nHeight, pSrcData, SrcFormat, nSrcStep, nXSrc, nYSrc,\n\t                                     palette, flags);\n}", "target": 0}
{"code": "extract_option(uschar **name, uschar **value)\n{\nuschar *n;\nuschar *v = smtp_cmd_data + Ustrlen(smtp_cmd_data) - 1;\nwhile (isspace(*v)) v--;\nv[1] = 0;\nwhile (v > smtp_cmd_data && *v != '=' && !isspace(*v))\n  {\n  if (*v == '\"') do v--; while (*v != '\"' && v > smtp_cmd_data+1);\n  v--;\n  }\nn = v;\nif (*v == '=')\n  {\n  while(isalpha(n[-1])) n--;\n  if (!isspace(n[-1])) return FALSE;\n  n[-1] = 0;\n  }\nelse\n  {\n  n++;\n  if (v == smtp_cmd_data) return FALSE;\n  }\n*v++ = 0;\n*name = n;\n*value = v;\nreturn TRUE;\n}", "target": 0}
{"code": "bgp_capability_mp_data (struct stream *s, struct capability_mp_data *mpc)\n{\n  mpc->afi = stream_getw (s);\n  mpc->reserved = stream_getc (s);\n  mpc->safi = stream_getc (s);\n}", "target": 0}
{"code": "koi8_u_mbc_case_fold(OnigCaseFoldType flag ARG_UNUSED,\n\t\t     const UChar** pp, const UChar* end ARG_UNUSED,\n\t\t     UChar* lower, OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  *lower = ENC_KOI8_U_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": "struct MACH0_(obj_t) {\n\tstruct MACH0_(mach_header) hdr;\n\tstruct MACH0_(segment_command) *segs;\n\tchar *intrp;\n\tchar *compiler;\n\tint nsegs;\n\tint segs_count;\n\tstruct r_dyld_chained_starts_in_segment **chained_starts;\n\tstruct dyld_chained_fixups_header fixups_header;\n\tut64 fixups_offset;\n\tut64 fixups_size;\n\tstruct MACH0_(section) *sects;\n\tint nsects;\n\tstruct MACH0_(nlist) *symtab;\n\tut8 *symstr;\n\tut8 *func_start; \n\tint symstrlen;\n\tint nsymtab;\n\tut32 *indirectsyms;\n\tint nindirectsyms;\n\tRBinImport **imports_by_ord;\n\tsize_t imports_by_ord_size;\n\tHtPP *imports_by_name;\n\tstruct dysymtab_command dysymtab;\n\tstruct load_command main_cmd;\n\tstruct dyld_info_command *dyld_info;\n\tstruct dylib_table_of_contents *toc;\n\tint ntoc;\n\tstruct MACH0_(dylib_module) *modtab;\n\tint nmodtab;\n\tstruct thread_command thread;\n\tut8 *signature;\n\tunion {\n\t\tstruct x86_thread_state32 x86_32;\n\t\tstruct x86_thread_state64 x86_64;\n\t\tstruct ppc_thread_state32 ppc_32;\n\t\tstruct ppc_thread_state64 ppc_64;\n\t\tstruct arm_thread_state32 arm_32;\n\t\tstruct arm_thread_state64 arm_64;\n\t} thread_state;\n\tchar (*libs)[R_BIN_MACH0_STRING_LENGTH];\n\tint nlibs;\n\tint size;\n\tut64 baddr;\n\tut64 entry;\n\tbool big_endian;\n\tconst char *file;\n\tRBuffer *b;\n\tint os;\n\tSdb *kv;\n\tint has_crypto;\n\tint has_canary;\n\tint has_retguard;\n\tint has_sanitizers;\n\tint has_blocks_ext;\n\tint dbg_info;\n\tconst char *lang;\n\tint uuidn;\n\tint func_size;\n\tbool verbose;\n\tut64 header_at;\n\tut64 symbols_off;\n\tvoid *user;\n\tut64 (*va2pa)(ut64 p, ut32 *offset, ut32 *left, RBinFile *bf);\n\tstruct symbol_t *symbols;\n\tut64 main_addr;\n\tint (*original_io_read)(RIO *io, RIODesc *fd, ut8 *buf, int count);\n\tbool rebasing_buffer;\n};", "target": 0}
{"code": "void SecurityManager::cancel_init()\n{\n    SecurityException exception;\n    if (local_participant_crypto_handle_)\n    {\n        crypto_plugin_->cryptokeyfactory()->unregister_participant(local_participant_crypto_handle_, exception);\n    }\n    if (crypto_plugin_ != nullptr)\n    {\n        delete crypto_plugin_;\n        crypto_plugin_ = nullptr;\n    }\n    if (access_plugin_ != nullptr)\n    {\n        delete access_plugin_;\n        access_plugin_ = nullptr;\n    }\n    delete authentication_plugin_;\n    authentication_plugin_ = nullptr;\n    disable_security_manager();\n}", "target": 1}
{"code": "void ParamTraits<string16>::Log(const param_type& p, std::string* l) {\n  l->append(UTF16ToUTF8(p));\n}", "target": 0}
{"code": "process(register int code, unsigned char** fill)\n{\n    int incode;\n    static unsigned char firstchar;\n    if (code == clear) {\n\tcodesize = datasize + 1;\n\tcodemask = (1 << codesize) - 1;\n\tavail = clear + 2;\n\toldcode = -1;\n\treturn 1;\n    }\n    if (oldcode == -1) {\n        if (code >= clear) {\n            fprintf(stderr, \"bad input: code=%d is larger than clear=%d\\n\",code, clear);\n            return 0;\n        }\n\t*(*fill)++ = suffix[code];\n\tfirstchar = oldcode = code;\n\treturn 1;\n    }\n    if (code > avail) {\n\tfprintf(stderr, \"code %d too large for %d\\n\", code, avail);\n\treturn 0; \n    }\n    incode = code;\n    if (code == avail) {      \n\t*stackp++ = firstchar;\n\tcode = oldcode;\n    }\n    while (code > clear) {\n\t*stackp++ = suffix[code];\n\tcode = prefix[code];\n    }\n    *stackp++ = firstchar = suffix[code];\n    prefix[avail] = oldcode;\n    suffix[avail] = firstchar;\n    avail++;\n    if (((avail & codemask) == 0) && (avail < 4096)) {\n\tcodesize++;\n\tcodemask += avail;\n    }\n    oldcode = incode;\n    do {\n\t*(*fill)++ = *--stackp;\n    } while (stackp > stack);\n    return 1;\n}", "target": 0}
{"code": "void CScreencopyPortal::queueNextShareFrame(CScreencopyPortal::SSession* pSession) {\n    const auto PSTREAM = m_pPipewire->streamFromSession(pSession);\n    if (PSTREAM && !PSTREAM->streamState)\n        return;\n    const auto FRAMETOOKMS           = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::system_clock::now() - pSession->sharingData.begunFrame).count() / 1000.0;\n    const auto MSTILNEXTREFRESH      = 1000.0 / (pSession->sharingData.framerate) - FRAMETOOKMS;\n    pSession->sharingData.begunFrame = std::chrono::system_clock::now();\n    Debug::log(TRACE, \"[screencopy] set fps {}, frame took {:.2f}ms, ms till next refresh {:.2f}, estimated actual fps: {:.2f}\", pSession->sharingData.framerate, FRAMETOOKMS,\n               MSTILNEXTREFRESH, std::clamp(1000.0 / FRAMETOOKMS, 1.0, (double)pSession->sharingData.framerate));\n    g_pPortalManager->addTimer({std::clamp(MSTILNEXTREFRESH - 1.0 , 6.0, 1000.0), [pSession]() { g_pPortalManager->m_sPortals.screencopy->startFrameCopy(pSession); }});\n}", "target": 1}
{"code": "CHUNK_REMAINING_CAPACITY(const chunk_t *chunk)\n{\n  return (chunk->mem + chunk->memlen) - (chunk->data + chunk->datalen);\n}", "target": 0}
{"code": "void LanLinkProvider::udpBroadcastReceived()\n{\n    while (m_udpSocket.hasPendingDatagrams()) {\n        QByteArray datagram;\n        datagram.resize(m_udpSocket.pendingDatagramSize());\n        QHostAddress sender;\n        m_udpSocket.readDatagram(datagram.data(), datagram.size(), &sender);\n        if (sender.isLoopback() && !m_testMode)\n            continue;\n        NetworkPacket* receivedPacket = new NetworkPacket(QLatin1String(\"\"));\n        bool success = NetworkPacket::unserialize(datagram, receivedPacket);\n        if (!success) {\n            qCDebug(KDECONNECT_CORE) << \"Could not unserialize UDP packet\";\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->type() != PACKET_TYPE_IDENTITY) {\n            qCDebug(KDECONNECT_CORE) << \"Received a UDP packet of wrong type\" << receivedPacket->type();\n            delete receivedPacket;\n            continue;\n        }\n        if (receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) == KdeConnectConfig::instance().deviceId()) {\n            delete receivedPacket;\n            continue;\n        }\n        int tcpPort = receivedPacket->get<int>(QStringLiteral(\"tcpPort\"));\n        if (m_receivedIdentityPackets.size() > MAX_REMEMBERED_IDENTITY_PACKETS) {\n            qCWarning(KDECONNECT_CORE) << \"Too many remembered identities, ignoring\" << receivedPacket->get<QString>(QStringLiteral(\"deviceId\")) << \"received via UDP\";\n            delete receivedPacket;\n            continue;\n        }\n        QSslSocket* socket = new QSslSocket(this);\n        socket->setProxy(QNetworkProxy::NoProxy);\n        m_receivedIdentityPackets[socket].np = receivedPacket;\n        m_receivedIdentityPackets[socket].sender = sender;\n        connect(socket, &QAbstractSocket::connected, this, &LanLinkProvider::tcpSocketConnected);\n#if QT_VERSION < QT_VERSION_CHECK(5,15,0)\n        connect(socket, QOverload<QAbstractSocket::SocketError>::of(&QAbstractSocket::error), this, &LanLinkProvider::connectError);\n#else\n        connect(socket, &QAbstractSocket::errorOccurred, this, &LanLinkProvider::connectError);\n#endif\n        socket->connectToHost(sender, tcpPort);\n    }\n}", "target": 0}
{"code": "static int cxusb_ctrl_msg(struct dvb_usb_device *d,\n\t\t\t  u8 cmd, u8 *wbuf, int wlen, u8 *rbuf, int rlen)\n{\n\tstruct cxusb_state *st = d->priv;\n\tint ret, wo;\n\tif (1 + wlen > MAX_XFER_SIZE) {\n\t\twarn(\"i2c wr: len=%d is too big!\\n\", wlen);\n\t\treturn -EOPNOTSUPP;\n\t}\n\two = (rbuf == NULL || rlen == 0); \n\tmutex_lock(&d->data_mutex);\n\tst->data[0] = cmd;\n\tmemcpy(&st->data[1], wbuf, wlen);\n\tif (wo)\n\t\tret = dvb_usb_generic_write(d, st->data, 1 + wlen);\n\telse\n\t\tret = dvb_usb_generic_rw(d, st->data, 1 + wlen,\n\t\t\t\t\t rbuf, rlen, 0);\n\tmutex_unlock(&d->data_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n{\n    if (!PKCS7_type_is_data(p7)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p7->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    return ASN1_item_unpack(p7->d.data, ASN1_ITEM_rptr(PKCS12_SAFEBAGS));\n}", "target": 0}
{"code": "setv4key_principal_2_svc(setv4key_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setv4key_principal((void *)handle, arg->princ,\n                                            arg->keyblock);\n    } else {\n        log_unauth(\"kadm5_setv4key_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setv4key_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static struct dst_entry *inet6_csk_route_socket(struct sock *sk,\n\t\t\t\t\t\tstruct flowi6 *fl6)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = sk->sk_protocol;\n\tfl6->daddr = sk->sk_v6_daddr;\n\tfl6->saddr = np->saddr;\n\tfl6->flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6->flowlabel);\n\tfl6->flowi6_oif = sk->sk_bound_dev_if;\n\tfl6->flowi6_mark = sk->sk_mark;\n\tfl6->fl6_sport = inet->inet_sport;\n\tfl6->fl6_dport = inet->inet_dport;\n\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(fl6));\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tdst = __inet6_csk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\t\tif (!IS_ERR(dst))\n\t\t\t__inet6_csk_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "void kvm_arch_flush_shadow_memslot(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tkvm_arch_flush_shadow_all(kvm);\n}", "target": 0}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = S[i];\n}", "target": 1}
{"code": "static void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  \n\t\tbreak;\n\tcase TUN_TAP_DEV:\n\t\tdev->netdev_ops = &tap_netdev_ops;\n\t\tether_setup(dev);\n\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\trandom_ether_addr(dev->dev_addr);\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  \n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static inline void sem_getref(struct sem_array *sma)\n{\n\tspin_lock(&(sma)->sem_perm.lock);\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "process_pointer_pdu(STREAM s)\n{\n\tuint16 message_type;\n\tuint16 x, y;\n\tin_uint16_le(s, message_type);\n\tin_uint8s(s, 2);\t\n\tswitch (message_type)\n\t{\n\t\tcase RDP_POINTER_MOVE:\n\t\t\tin_uint16_le(s, x);\n\t\t\tin_uint16_le(s, y);\n\t\t\tif (s_check(s))\n\t\t\t\tui_move_pointer(x, y);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_COLOR:\n\t\t\tprocess_colour_pointer_pdu(s);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_CACHED:\n\t\t\tprocess_cached_pointer_pdu(s);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_SYSTEM:\n\t\t\tprocess_system_pointer_pdu(s);\n\t\t\tbreak;\n\t\tcase RDP_POINTER_NEW:\n\t\t\tprocess_new_pointer_pdu(s);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tunimpl(\"Pointer message 0x%x\\n\", message_type);\n\t}\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    auto value = ctx->input(0);\n    OP_REQUIRES(ctx, value.dims() >= 1,\n                errors::InvalidArgument(\"value should be at least rank 1.\"));\n    OP_REQUIRES(\n        ctx, value.dim_size(0) > loc_,\n        errors::InvalidArgument(\"0th dimension of value = \", value.dim_size(0),\n                                \" must be greater than loc_ = \", loc_));\n    auto update = ctx->input(1);\n    OP_REQUIRES(\n        ctx, value.dims() == update.dims(),\n        errors::InvalidArgument(\"value and update shape doesn't match: \",\n                                value.shape().DebugString(), \" vs. \",\n                                update.shape().DebugString()));\n    for (int i = 1; i < value.dims(); ++i) {\n      OP_REQUIRES(\n          ctx, value.dim_size(i) == update.dim_size(i),\n          errors::InvalidArgument(\"value and update shape doesn't match \",\n                                  value.shape().DebugString(), \" vs. \",\n                                  update.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, 1 == update.dim_size(0),\n                errors::InvalidArgument(\"update shape doesn't match: \",\n                                        update.shape().DebugString()));\n    Tensor output = value;  \n    const auto& d = ctx->eigen_device<Device>();\n    OP_REQUIRES_OK(\n        ctx, ::tensorflow::functor::DoParallelConcat(d, update, loc_, &output));\n    ctx->set_output(0, output);\n  }", "target": 0}
{"code": "static void mrled(u8 * RESTRICT in, u8 * RESTRICT out, s32 outlen) {\n    s32 op = 0, ip = 0;\n    s32 c, pc = -1;\n    s32 t[256] = { 0 };\n    s32 run = 0;\n    for (s32 i = 0; i < 32; ++i) {\n        c = in[ip++];\n        for (s32 j = 0; j < 8; ++j) t[i * 8 + j] = (c >> j) & 1;\n    }\n    while (op < outlen) {\n        c = in[ip++];\n        if (t[c]) {\n            for (run = 0; (pc = in[ip++]) == 255; run += 255)\n                ;\n            run += pc + 1;\n            for (; run > 0 && op < outlen; --run) out[op++] = c;\n        } else\n            out[op++] = c;\n    }\n}", "target": 1}
{"code": "tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "TfLiteStatus ReshapeOutput(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  int num_input_elements = NumElements(input);\n  TfLiteIntArray* output_shape = output->dims;\n  if (NumInputs(node) == 1 &&  \n      output_shape->size == 1 && output_shape->data[0] == 0) {\n    output_shape->size = 0;\n  }\n  int num_output_elements = 1;\n  int stretch_dim = -1;\n  for (int i = 0; i < output_shape->size; ++i) {\n    int value = output_shape->data[i];\n    if (value == -1) {\n      TF_LITE_ENSURE_EQ(context, stretch_dim, -1);\n      stretch_dim = i;\n    } else {\n      num_output_elements *= value;\n    }\n  }\n  if (stretch_dim != -1) {\n    output_shape->data[stretch_dim] = num_input_elements / num_output_elements;\n    num_output_elements *= output_shape->data[stretch_dim];\n  }\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE_EQ(context, num_input_elements, num_output_elements);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "  TfLiteStatus status() const { return status_; }", "target": 0}
{"code": "mark_op_resolved (FlatpakTransactionOperation *op,\n                  const char                  *commit,\n                  GFile                       *sideload_path,\n                  GBytes                      *metadata,\n                  GBytes                      *old_metadata)\n{\n  g_debug (\"marking op %s:%s resolved to %s\", kind_to_str (op->kind), flatpak_decomposed_get_ref (op->ref), commit ? commit : \"-\");\n  g_assert (op != NULL);\n  g_assert (commit != NULL);\n  op->resolved = TRUE;\n  if (op->resolved_commit != commit)\n    {\n      g_free (op->resolved_commit); \n      op->resolved_commit = g_strdup (commit);\n    }\n  if (sideload_path)\n    op->resolved_sideload_path = g_object_ref (sideload_path);\n  if (metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_metadata = g_bytes_ref (metadata);\n          op->resolved_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n  if (old_metadata)\n    {\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      if (g_key_file_load_from_bytes (metakey, old_metadata, G_KEY_FILE_NONE, NULL))\n        {\n          op->resolved_old_metadata = g_bytes_ref (old_metadata);\n          op->resolved_old_metakey = g_steal_pointer (&metakey);\n        }\n      else\n        g_message (\"Warning: Failed to parse old metadata for %s\\n\", flatpak_decomposed_get_ref (op->ref));\n    }\n}", "target": 1}
{"code": "void luaV_concat (lua_State *L, int total) {\n  if (total == 1)\n    return;  \n  do {\n    StkId top = L->top;\n    int n = 2;  \n    if (!(ttisstring(s2v(top - 2)) || cvt2str(s2v(top - 2))) ||\n        !tostring(L, s2v(top - 1)))\n      luaT_tryconcatTM(L);\n    else if (isemptystr(s2v(top - 1)))  \n      cast_void(tostring(L, s2v(top - 2)));  \n    else if (isemptystr(s2v(top - 2))) {  \n      setobjs2s(L, top - 2, top - 1);  \n    }\n    else {\n      size_t tl = vslen(s2v(top - 1));\n      TString *ts;\n      for (n = 1; n < total && tostring(L, s2v(top - n - 1)); n++) {\n        size_t l = vslen(s2v(top - n - 1));\n        if (l_unlikely(l >= (MAX_SIZE/sizeof(char)) - tl))\n          luaG_runerror(L, \"string length overflow\");\n        tl += l;\n      }\n      if (tl <= LUAI_MAXSHORTLEN) {  \n        char buff[LUAI_MAXSHORTLEN];\n        copy2buff(top, n, buff);  \n        ts = luaS_newlstr(L, buff, tl);\n      }\n      else {  \n        ts = luaS_createlngstrobj(L, tl);\n        copy2buff(top, n, getstr(ts));\n      }\n      setsvalue2s(L, top - n, ts);  \n    }\n    total -= n-1;  \n    L->top -= n-1;  \n  } while (total > 1);  \n}", "target": 1}
{"code": "int fscrypt_get_encryption_info(struct inode *inode)\n{\n\tstruct fscrypt_info *ci = inode->i_crypt_info;\n\tif (!ci ||\n\t\t(ci->ci_keyring_key &&\n\t\t (ci->ci_keyring_key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t\t\t       (1 << KEY_FLAG_REVOKED) |\n\t\t\t\t\t       (1 << KEY_FLAG_DEAD)))))\n\t\treturn fscrypt_get_crypt_info(inode);\n\treturn 0;\n}", "target": 1}
{"code": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    int v, i;\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n        if (length > 256 || !(s->state & PNG_PLTE))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length; i++) {\n            v = bytestream2_get_byte(&s->gb);\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n        }\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n            return AVERROR_INVALIDDATA;\n        for (i = 0; i < length / 2; i++) {\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n            if (s->bit_depth > 8)\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n            else\n                s->transparent_color_be[i] = v;\n        }\n    } else {\n        return AVERROR_INVALIDDATA;\n    }\n    bytestream2_skip(&s->gb, 4); \n    s->has_trns = 1;\n    return 0;\n}", "target": 1}
{"code": "\t__releases(rcu_bh)\n{\n\trcu_read_unlock_bh();\n}", "target": 0}
{"code": "rtadv_read (struct thread *thread)\n{\n  int sock;\n  int len;\n  u_char buf[RTADV_MSG_SIZE];\n  struct sockaddr_in6 from;\n  ifindex_t ifindex = 0;\n  int hoplimit = -1;\n  struct zebra_vrf *zvrf = THREAD_ARG (thread);\n  sock = THREAD_FD (thread);\n  zvrf->rtadv.ra_read = NULL;\n  rtadv_event (zvrf, RTADV_READ, sock);\n  len = rtadv_recv_packet (sock, buf, BUFSIZ, &from, &ifindex, &hoplimit);\n  if (len < 0) \n    {\n      zlog_warn (\"router solicitation recv failed: %s.\", safe_strerror (errno));\n      return len;\n    }\n  rtadv_process_packet (buf, (unsigned)len, ifindex, hoplimit, zvrf->vrf_id);\n  return 0;\n}", "target": 1}
{"code": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\tif (!ctx.match_data.cmp)\n\t\treturn ERR_PTR(-ENOKEY);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tkey = keyring_search_aux(keyring, &ctx);\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}", "target": 1}
{"code": "static void unbound_resolver_callback(void *data, int err, struct ub_result *ub_result)\n{\n\tstruct ast_dns_query *query = data;\n\tif (!ub_result) {\n\t\tast_debug(3, \"Badly formatted DNS query '%s'\\n\", ast_dns_query_get_name(query));\n\t\tast_dns_resolver_set_result(query, 0, 0, ns_r_formerr, ast_dns_query_get_name(query), \"\", 0);\n\t\tast_dns_resolver_completed(query);\n\t\tao2_ref(query, -1);\n\t\treturn;\n\t}\n\tif (!ast_dns_resolver_set_result(query, ub_result->secure, ub_result->bogus, ub_result->rcode,\n\t\tS_OR(ub_result->canonname, ast_dns_query_get_name(query)), ub_result->answer_packet, ub_result->answer_len)) {\n\t\tint i;\n\t\tchar *result_data;\n\t\tfor (i = 0; (result_data = ub_result->data[i]); i++) {\n\t\t\tif (ast_dns_resolver_add_record(query, ub_result->qtype, ub_result->qclass, ub_result->ttl,\n\t\t\t\tresult_data, ub_result->len[i])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tast_dns_resolver_completed(query);\n\tao2_ref(query, -1);\n\tub_resolve_free(ub_result);\n}", "target": 0}
{"code": "fixExec2Error(int action,\n             u_char * var_val,\n             u_char var_val_type,\n             size_t var_val_len,\n             u_char * statP, oid * name, size_t name_len)\n{\n    netsnmp_old_extend *exten = NULL;\n    unsigned int idx;\n    idx = name[name_len-1] -1;\n    exten = &compatability_entries[ idx ];\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    switch (action) {\n    case MODE_SET_RESERVE1:\n        if (var_val_type != ASN_INTEGER) {\n            snmp_log(LOG_ERR, \"Wrong type != int\\n\");\n            return SNMP_ERR_WRONGTYPE;\n        }\n        idx = *((long *) var_val);\n        if (idx != 1) {\n            snmp_log(LOG_ERR, \"Wrong value != 1\\n\");\n            return SNMP_ERR_WRONGVALUE;\n        }\n        if (!exten || !exten->efix_entry) {\n            snmp_log(LOG_ERR, \"No command to run\\n\");\n            return SNMP_ERR_GENERR;\n        }\n        return SNMP_ERR_NOERROR;\n    case MODE_SET_COMMIT:\n        netsnmp_cache_check_and_reload( exten->efix_entry->cache );\n    }\n#endif \n    return SNMP_ERR_NOERROR;\n}", "target": 1}
{"code": "ecryptfs_decode_from_filename(unsigned char *dst, size_t *dst_size,\n\t\t\t      const unsigned char *src, size_t src_size)\n{\n\tu8 current_bit_offset = 0;\n\tsize_t src_byte_offset = 0;\n\tsize_t dst_byte_offset = 0;\n\tif (dst == NULL) {\n\t\t(*dst_size) = ecryptfs_max_decoded_size(src_size);\n\t\tgoto out;\n\t}\n\twhile (src_byte_offset < src_size) {\n\t\tunsigned char src_byte =\n\t\t\t\tfilename_rev_map[(int)src[src_byte_offset]];\n\t\tswitch (current_bit_offset) {\n\t\tcase 0:\n\t\t\tdst[dst_byte_offset] = (src_byte << 2);\n\t\t\tcurrent_bit_offset = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 4);\n\t\t\tdst[dst_byte_offset] = ((src_byte & 0xF)\n\t\t\t\t\t\t << 4);\n\t\t\tcurrent_bit_offset = 4;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdst[dst_byte_offset++] |= (src_byte >> 2);\n\t\t\tdst[dst_byte_offset] = (src_byte << 6);\n\t\t\tcurrent_bit_offset = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdst[dst_byte_offset++] |= (src_byte);\n\t\t\tdst[dst_byte_offset] = 0;\n\t\t\tcurrent_bit_offset = 0;\n\t\t\tbreak;\n\t\t}\n\t\tsrc_byte_offset++;\n\t}\n\t(*dst_size) = dst_byte_offset;\nout:\n\treturn;\n}", "target": 1}
{"code": "static int kvm_create_dirty_bitmap(struct kvm_memory_slot *memslot)\n{\n\tunsigned long dirty_bytes = 2 * kvm_dirty_bitmap_bytes(memslot);\n\tmemslot->dirty_bitmap = kvm_kvzalloc(dirty_bytes);\n\tif (!memslot->dirty_bitmap)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 0}
{"code": "fp_read_object(CBORDecoderObject *self, const Py_ssize_t size)\n{\n    PyObject *ret = NULL;\n    PyObject *obj, *size_obj;\n    size_obj = PyLong_FromSsize_t(size);\n    if (size_obj) {\n        obj = PyObject_CallFunctionObjArgs(self->read, size_obj, NULL);\n        Py_DECREF(size_obj);\n        if (obj) {\n            assert(PyBytes_CheckExact(obj));\n            if (PyBytes_GET_SIZE(obj) == (Py_ssize_t) size) {\n                ret = obj;\n            } else {\n                Py_DECREF(obj);\n                PyErr_Format(\n                    _CBOR2_CBORDecodeEOF,\n                    \"premature end of stream (expected to read %zd bytes, \"\n                    \"got %zd instead)\", size, PyBytes_GET_SIZE(obj));\n            }\n        }\n    }\n    return ret;\n}", "target": 0}
{"code": "l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}", "target": 1}
{"code": "vrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tdump_data_vrrp(file);\n\tfclose(file);\n}", "target": 1}
{"code": "void LibRaw::sinar_4shot_load_raw()\n{\n  ushort *pixel;\n  unsigned shot, row, col, r, c;\n  if (raw_image)\n  {\n    shot = LIM(shot_select, 1, 4) - 1;\n    fseek(ifp, data_offset + shot * 4, SEEK_SET);\n    fseek(ifp, get4(), SEEK_SET);\n    unpacked_load_raw();\n    return;\n  }\n  if (!image)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  pixel = (ushort *)calloc(raw_width, sizeof *pixel);\n  merror(pixel, \"sinar_4shot_load_raw()\");\n  try\n  {\n    for (shot = 0; shot < 4; shot++)\n    {\n      checkCancel();\n      fseek(ifp, data_offset + shot * 4, SEEK_SET);\n      fseek(ifp, get4(), SEEK_SET);\n      for (row = 0; row < raw_height; row++)\n      {\n        read_shorts(pixel, raw_width);\n        if ((r = row - top_margin - (shot >> 1 & 1)) >= height)\n          continue;\n        for (col = 0; col < raw_width; col++)\n        {\n          if ((c = col - left_margin - (shot & 1)) >= width)\n            continue;\n          image[r * width + c][(row & 1) * 3 ^ (~col & 1)] = pixel[col];\n        }\n      }\n    }\n  }\n  catch (...)\n  {\n    free(pixel);\n    throw;\n  }\n  free(pixel);\n  mix_green = 1;\n}", "target": 0}
{"code": "ClearServer2Client(rfbClient* client, int messageType)\n{\n  client->supportedMessages.server2client[((messageType & 0xFF)/8)] &= (!(1<<(messageType % 8)));\n}", "target": 0}
{"code": "_public_ int sd_bus_enqueue_for_read(sd_bus *bus, sd_bus_message *m) {\n        int r;\n        assert_return(bus, -EINVAL);\n        assert_return(bus = bus_resolve(bus), -ENOPKG);\n        assert_return(m, -EINVAL);\n        assert_return(m->sealed, -EINVAL);\n        assert_return(!bus_pid_changed(bus), -ECHILD);\n        if (!BUS_IS_OPEN(bus->state))\n                return -ENOTCONN;\n        r = bus_rqueue_make_room(bus);\n        if (r < 0)\n                return r;\n        bus->rqueue[bus->rqueue_size++] = bus_message_ref_queued(m, bus);\n        return 0;\n}", "target": 0}
{"code": "left_is_superset(DTCollation *left, DTCollation *right)\n{\n  if (left->collation->state & MY_CS_UNICODE &&\n      (left->derivation < right->derivation ||\n       (left->derivation == right->derivation &&\n        (!(right->collation->state & MY_CS_UNICODE) ||\n         (left->collation->state & MY_CS_UNICODE_SUPPLEMENT &&\n          !(right->collation->state & MY_CS_UNICODE_SUPPLEMENT) &&\n          left->collation->mbmaxlen > right->collation->mbmaxlen &&\n          left->collation->mbminlen == right->collation->mbminlen)))))\n    return TRUE;\n  if (right->repertoire == MY_REPERTOIRE_ASCII &&\n      (left->derivation < right->derivation ||\n       (left->derivation == right->derivation &&\n        !(left->repertoire == MY_REPERTOIRE_ASCII))))\n    return TRUE;\n  return FALSE;\n}", "target": 0}
{"code": "void ConnPoolImplBase::closeIdleConnectionsForDrainingPool() {\n  Common::AutoDebugRecursionChecker assert_not_in(recursion_checker_);\n  std::list<ActiveClient*> to_close;\n  for (auto& client : ready_clients_) {\n    if (client->numActiveStreams() == 0) {\n      to_close.push_back(client.get());\n    }\n  }\n  if (pending_streams_.empty()) {\n    for (auto& client : connecting_clients_) {\n      to_close.push_back(client.get());\n    }\n  }\n  for (auto& entry : to_close) {\n    ENVOY_LOG_EVENT(debug, \"closing_idle_client\", \"closing idle client {} for cluster {}\",\n                    entry->id(), host_->cluster().name());\n    entry->close();\n  }\n}", "target": 0}
{"code": "char *redisProtocolToLuaType(lua_State *lua, char* reply) {\n    if (!lua_checkstack(lua, 5)) {\n        serverPanic(\"lua stack limit reach when parsing redis.call reply\");\n    }\n    char *p = reply;\n    switch(*p) {\n    case ':': p = redisProtocolToLuaType_Int(lua,reply); break;\n    case '$': p = redisProtocolToLuaType_Bulk(lua,reply); break;\n    case '+': p = redisProtocolToLuaType_Status(lua,reply); break;\n    case '-': p = redisProtocolToLuaType_Error(lua,reply); break;\n    case '*': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '%': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '~': p = redisProtocolToLuaType_Aggregate(lua,reply,*p); break;\n    case '_': p = redisProtocolToLuaType_Null(lua,reply); break;\n    case '#': p = redisProtocolToLuaType_Bool(lua,reply,p[1]); break;\n    case ',': p = redisProtocolToLuaType_Double(lua,reply); break;\n    }\n    return p;\n}", "target": 0}
{"code": "int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,\n                            size_t size)\n{\n    GetBitContext gb;\n    AC3HeaderInfo *hdr;\n    int err;\n    if (!*phdr)\n        *phdr = av_mallocz(sizeof(AC3HeaderInfo));\n    if (!*phdr)\n        return AVERROR(ENOMEM);\n    hdr = *phdr;\n    init_get_bits8(&gb, buf, size);\n    err = ff_ac3_parse_header(&gb, hdr);\n    if (err < 0)\n        return AVERROR_INVALIDDATA;\n    return get_bits_count(&gb);\n}", "target": 1}
{"code": "static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)\n{\n    pb_type_t type;\n    pb_decoder_t func;\n    type = iter->pos->type;\n    func = PB_DECODERS[PB_LTYPE(type)];\n    switch (PB_HTYPE(type))\n    {\n        case PB_HTYPE_REQUIRED:\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_OPTIONAL:\n            if (iter->pSize != iter->pData)\n                *(bool*)iter->pSize = true;\n            return func(stream, iter->pos, iter->pData);\n        case PB_HTYPE_REPEATED:\n            if (wire_type == PB_WT_STRING\n                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)\n            {\n                bool status = true;\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                pb_istream_t substream;\n                if (!pb_make_string_substream(stream, &substream))\n                    return false;\n                while (substream.bytes_left > 0 && *size < iter->pos->array_size)\n                {\n                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                    if (!func(&substream, iter->pos, pItem))\n                    {\n                        status = false;\n                        break;\n                    }\n                    (*size)++;\n                }\n                if (substream.bytes_left != 0)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                if (!pb_close_string_substream(stream, &substream))\n                    return false;\n                return status;\n            }\n            else\n            {\n                pb_size_t *size = (pb_size_t*)iter->pSize;\n                char *pItem = (char*)iter->pData + iter->pos->data_size * (*size);\n                if ((*size)++ >= iter->pos->array_size)\n                    PB_RETURN_ERROR(stream, \"array overflow\");\n                return func(stream, iter->pos, pItem);\n            }\n        case PB_HTYPE_ONEOF:\n            *(pb_size_t*)iter->pSize = iter->pos->tag;\n            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)\n            {\n                memset(iter->pData, 0, iter->pos->data_size);\n                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);\n            }\n            return func(stream, iter->pos, iter->pData);\n        default:\n            PB_RETURN_ERROR(stream, \"invalid field type\");\n    }\n}", "target": 1}
{"code": "static void fio_worker_cleanup(void) {\n  if (fio_data->is_worker)\n    FIO_LOG_INFO(\"(%d) detected exit signal.\", (int)getpid());\n  else\n    FIO_LOG_INFO(\"Server Detected exit signal.\");\n  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol) {\n      fio_defer_push_task(deferred_on_shutdown, (void *)fd2uuid(i), NULL);\n    }\n  }\n  fio_defer_push_task(fio_cycle_unwind, NULL, NULL);\n  fio_defer_perform();\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol || fd_data(i).open) {\n      fio_force_close(fd2uuid(i));\n    }\n  }\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_ON_FINISH);\n  fio_defer_perform();\n  if (!fio_data->is_worker) {\n    fio_cluster_signal_children();\n    while (wait(NULL) != -1)\n      ;\n  }\n  fio_defer_perform();\n  fio_signal_handler_reset();\n  if (fio_data->parent == getpid()) {\n    FIO_LOG_INFO(\"   ---  Shutdown Complete  ---\\n\");\n  } else {\n    FIO_LOG_INFO(\"(%d) cleanup complete.\", (int)getpid());\n  }\n}", "target": 1}
{"code": "static inline int nlmsg_parse(struct nlmsghdr *nlh, int hdrlen,\n\t\t\t      struct nlattr *tb[], int maxtype,\n\t\t\t      const struct nla_policy *policy)\n{\n\tif (nlh->nlmsg_len < nlmsg_msg_size(hdrlen))\n\t\treturn -EINVAL;\n\treturn nla_parse(tb, maxtype, nlmsg_attrdata(nlh, hdrlen),\n\t\t\t nlmsg_attrlen(nlh, hdrlen), policy);\n}", "target": 0}
{"code": "got_headers (SoupMessage *req, SoupClientContext *client)\n{\n\tSoupServer *server = client->server;\n\tSoupServerPrivate *priv = SOUP_SERVER_GET_PRIVATE (server);\n\tSoupURI *uri;\n\tSoupDate *date;\n\tchar *date_string;\n\tSoupAuthDomain *domain;\n\tGSList *iter;\n\tgboolean rejected = FALSE;\n\tchar *auth_user;\n\tif (!priv->raw_paths) {\n\t\tchar *decoded_path;\n\t\turi = soup_message_get_uri (req);\n\t\tdecoded_path = soup_uri_decode (uri->path);\n\t\tif (strstr (decoded_path, \"/../\") ||\n\t\t    g_str_has_suffix (decoded_path, \"/..\")) {\n\t\t\tg_free (decoded_path);\n\t\t\tsoup_message_set_status (req, SOUP_STATUS_BAD_REQUEST);\n\t\t\treturn;\n\t\t}\n\t\tsoup_uri_set_path (uri, decoded_path);\n\t\tg_free (decoded_path);\n\t}\n\tdate = soup_date_new_from_now (0);\n\tdate_string = soup_date_to_string (date, SOUP_DATE_HTTP);\n\tsoup_message_headers_replace (req->response_headers, \"Date\",\n\t\t\t\t      date_string);\n\tg_free (date_string);\n\tsoup_date_free (date);\n\tfor (iter = priv->auth_domains; iter; iter = iter->next) {\n\t\tdomain = iter->data;\n\t\tif (soup_auth_domain_covers (domain, req)) {\n\t\t\tauth_user = soup_auth_domain_accepts (domain, req);\n\t\t\tif (auth_user) {\n\t\t\t\tclient->auth_domain = g_object_ref (domain);\n\t\t\t\tclient->auth_user = auth_user;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trejected = TRUE;\n\t\t}\n\t}\n\tif (!rejected)\n\t\treturn;\n\tfor (iter = priv->auth_domains; iter; iter = iter->next) {\n\t\tdomain = iter->data;\n\t\tif (soup_auth_domain_covers (domain, req))\n\t\t\tsoup_auth_domain_challenge (domain, req);\n\t}\n}", "target": 0}
{"code": "static int ivr_probe(AVProbeData *p)\n{\n    if (memcmp(p->buf, \".R1M\\x0\\x1\\x1\", 7) &&\n        memcmp(p->buf, \".REC\", 4))\n        return 0;\n    return AVPROBE_SCORE_MAX;\n}", "target": 0}
{"code": "static int bson_append_estart( bson *b, int type, const char *name, const int dataSize ) {\n    const int len = strlen( name ) + 1;\n    if ( b->finished ) {\n        b->err |= BSON_ALREADY_FINISHED;\n        return BSON_ERROR;\n    }\n    if ( bson_ensure_space( b, 1 + len + dataSize ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n    if( bson_check_field_name( b, ( const char * )name, len - 1 ) == BSON_ERROR ) {\n        bson_builder_error( b );\n        return BSON_ERROR;\n    }\n    bson_append_byte( b, ( char )type );\n    bson_append( b, name, len );\n    return BSON_OK;\n}", "target": 1}
{"code": "bool OmniboxViewWin::IsSelectAll() {\n  CHARRANGE selection;\n  GetSel(selection);\n  return IsSelectAllForRange(selection);\n}", "target": 0}
{"code": "cmndlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *list, const char *runchroot,\n    struct cmnd_info *info)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = cmnd_matches(parse_tree, m, runchroot, info);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static bool find_andx_cmd_ofs(uint8_t *buf, size_t *pofs)\n{\n\tuint8_t cmd;\n\tsize_t ofs;\n\tcmd = CVAL(buf, smb_com);\n\tSMB_ASSERT(is_andx_req(cmd));\n\tofs = smb_vwv0;\n\twhile (CVAL(buf, ofs) != 0xff) {\n\t\tif (!is_andx_req(CVAL(buf, ofs))) {\n\t\t\treturn false;\n\t\t}\n\t\tofs = SVAL(buf, ofs+2) + 4 + 1;\n\t\tSMB_ASSERT(ofs+4 < talloc_get_size(buf));\n\t}\n\t*pofs = ofs;\n\treturn true;\n}", "target": 0}
{"code": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}", "target": 1}
{"code": "int nfs4_do_close(struct path *path, struct nfs4_state *state, int wait)\n{\n\tstruct nfs_server *server = NFS_SERVER(state->inode);\n\tstruct nfs4_closedata *calldata;\n\tstruct nfs4_state_owner *sp = state->owner;\n\tstruct rpc_task *task;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_CLOSE],\n\t\t.rpc_cred = state->owner->so_cred,\n\t};\n\tstruct rpc_task_setup task_setup_data = {\n\t\t.rpc_client = server->client,\n\t\t.rpc_message = &msg,\n\t\t.callback_ops = &nfs4_close_ops,\n\t\t.workqueue = nfsiod_workqueue,\n\t\t.flags = RPC_TASK_ASYNC,\n\t};\n\tint status = -ENOMEM;\n\tcalldata = kmalloc(sizeof(*calldata), GFP_KERNEL);\n\tif (calldata == NULL)\n\t\tgoto out;\n\tcalldata->inode = state->inode;\n\tcalldata->state = state;\n\tcalldata->arg.fh = NFS_FH(state->inode);\n\tcalldata->arg.stateid = &state->open_stateid;\n\tcalldata->arg.seqid = nfs_alloc_seqid(&state->owner->so_seqid);\n\tif (calldata->arg.seqid == NULL)\n\t\tgoto out_free_calldata;\n\tcalldata->arg.open_flags = 0;\n\tcalldata->arg.bitmask = server->attr_bitmask;\n\tcalldata->res.fattr = &calldata->fattr;\n\tcalldata->res.seqid = calldata->arg.seqid;\n\tcalldata->res.server = server;\n\tcalldata->path.mnt = mntget(path->mnt);\n\tcalldata->path.dentry = dget(path->dentry);\n\tmsg.rpc_argp = &calldata->arg,\n\tmsg.rpc_resp = &calldata->res,\n\ttask_setup_data.callback_data = calldata;\n\ttask = rpc_run_task(&task_setup_data);\n\tif (IS_ERR(task))\n\t\treturn PTR_ERR(task);\n\tstatus = 0;\n\tif (wait)\n\t\tstatus = rpc_wait_for_completion_task(task);\n\trpc_put_task(task);\n\treturn status;\nout_free_calldata:\n\tkfree(calldata);\nout:\n\tnfs4_put_open_state(state);\n\tnfs4_put_state_owner(sp);\n\treturn status;\n}", "target": 1}
{"code": "static ssize_t drop_sync(QIOChannel *ioc, size_t size)\n{\n    ssize_t ret = 0;\n    char small[1024];\n    char *buffer;\n    buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size));\n    while (size > 0) {\n        ssize_t count = read_sync(ioc, buffer, MIN(65536, size));\n        if (count <= 0) {\n            goto cleanup;\n        }\n        assert(count <= size);\n        size -= count;\n        ret += count;\n    }\n cleanup:\n    if (buffer != small) {\n        g_free(buffer);\n    }\n    return ret;\n}", "target": 1}
{"code": "mm_xmalloc(struct mm_master *mm, size_t size)\n{\n\tvoid *address;\n\taddress = mm_malloc(mm, size);\n\tif (address == NULL)\n\t\tfatal(\"%s: mm_malloc(%zu)\", __func__, size);\n\tmemset(address, 0, size);\n\treturn (address);\n}", "target": 1}
{"code": "void nego_process_negotiation_request(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->RequestedProtocols);\n\tWLog_DBG(TAG, \"RDP_NEG_REQ: RequestedProtocol: 0x%08\" PRIX32 \"\", nego->RequestedProtocols);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "  void encode(bufferlist& bl) const {\n    __u8 struct_v = 1;\n    ::encode(struct_v, bl);\n    ::encode(server_challenge, bl);\n  }", "target": 0}
{"code": "rdr_notification_ctx_init(struct rdr_notification_ctx *ctx)\n{\n\tdeltas_parsed_init(&ctx->deltas);\n\treturn 0;\n}", "target": 1}
{"code": "ev_archive_get_entry_size (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, -1);\n\t\treturn archive_entry_size (archive->libar_entry);\n\t}\n\treturn -1;\n}", "target": 0}
{"code": "bool CSSStyleSheet::isLoading()\n{\n    unsigned len = length();\n    for (unsigned i = 0; i < len; ++i) {\n        StyleBase* rule = item(i);\n        if (rule->isImportRule() && static_cast<CSSImportRule*>(rule)->isLoading())\n            return true;\n    }\n    return false;\n}", "target": 0}
{"code": "mesh_state_cleanup(struct mesh_state* mstate)\n{\n\tstruct mesh_area* mesh;\n\tint i;\n\tif(!mstate)\n\t\treturn;\n\tmesh = mstate->s.env->mesh;\n\tif(mstate->s.serve_expired_data && mstate->s.serve_expired_data->timer) {\n\t\tcomm_timer_delete(mstate->s.serve_expired_data->timer);\n\t\tmstate->s.serve_expired_data->timer = NULL;\n\t}\n\tif(!mstate->replies_sent) {\n\t\tstruct mesh_reply* rep = mstate->reply_list;\n\t\tstruct mesh_cb* cb;\n\t\tmstate->reply_list = NULL;\n\t\tfor(; rep; rep=rep->next) {\n\t\t\tinfra_wait_limit_dec(mesh->env->infra_cache,\n\t\t\t\t&rep->query_reply, mesh->env->cfg);\n\t\t\tcomm_point_drop_reply(&rep->query_reply);\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t}\n\t\twhile((cb = mstate->cb_list)!=NULL) {\n\t\t\tmstate->cb_list = cb->next;\n\t\t\tfptr_ok(fptr_whitelist_mesh_cb(cb->cb));\n\t\t\t(*cb->cb)(cb->cb_arg, LDNS_RCODE_SERVFAIL, NULL,\n\t\t\t\tsec_status_unchecked, NULL, 0);\n\t\t\tlog_assert(mesh->num_reply_addrs > 0);\n\t\t\tmesh->num_reply_addrs--;\n\t\t}\n\t}\n\tfor(i=0; i<mesh->mods.num; i++) {\n\t\tfptr_ok(fptr_whitelist_mod_clear(mesh->mods.mod[i]->clear));\n\t\t(*mesh->mods.mod[i]->clear)(&mstate->s, i);\n\t\tmstate->s.minfo[i] = NULL;\n\t\tmstate->s.ext_state[i] = module_finished;\n\t}\n\talloc_reg_release(mstate->s.env->alloc, mstate->s.region);\n}", "target": 0}
{"code": "struct clock_source *dce112_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "gss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "void handle_debug_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n        const MessagesMap_t *entry = message_map_entry(DEBUG_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, DEBUG_MSG);\n    }\n}", "target": 1}
{"code": "static char *get_cert_prompt(TALLOC_CTX *mem_ctx,\n                             struct cert_auth_info *cert_info)\n{\n    int ret;\n    struct sss_certmap_ctx *ctx = NULL;\n    unsigned char *der = NULL;\n    size_t der_size;\n    char *prompt = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    ret = sss_certmap_init(mem_ctx, NULL, NULL, &ctx);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_init failed.\\n\");\n        return NULL;\n    }\n    ret = sss_certmap_add_rule(ctx, 10, \"KRB5:<ISSUER>.*\",\n                               \"LDAP:{subject_dn!nss}\", NULL);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_add_rule failed.\\n\");\n        goto done;\n    }\n    der = sss_base64_decode(mem_ctx, sss_cai_get_cert(cert_info), &der_size);\n    if (der == NULL) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_base64_decode failed.\\n\");\n        goto done;\n    }\n    ret = sss_certmap_get_search_filter(ctx, der, der_size, &filter, &domains);\n    if (ret != 0) {\n        DEBUG(SSSDBG_OP_FAILURE, \"sss_certmap_get_search_filter failed.\\n\");\n        goto done;\n    }\n    prompt = talloc_asprintf(mem_ctx, \"%s\\n%s\", sss_cai_get_label(cert_info),\n                                                filter);\n    if (prompt == NULL) {\n        DEBUG(SSSDBG_OP_FAILURE, \"talloc_strdup failed.\\n\");\n    }\ndone:\n    sss_certmap_free_filter_and_domains(filter, domains);\n    sss_certmap_free_ctx(ctx);\n    talloc_free(der);\n    return prompt;\n}", "target": 1}
{"code": "static uint8_t search_next_ip(void)\n{       \n\tuint8_t range_count, offset_count;\n\tuint8_t start, end;\n\tuint8_t max_count;\n\tif(dhcps_addr_pool_set){\n#if LWIP_VERSION_MAJOR >= 2\n\t\tstart = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_start));\n\t\tend = (uint8_t)ip4_addr4(ip_2_ip4(&dhcps_addr_pool_end));\n#else\n\t\tstart = (uint8_t)ip4_addr4(&dhcps_addr_pool_start);\n\t\tend = (uint8_t)ip4_addr4(&dhcps_addr_pool_end);\n#endif\n\t}else{\n\t\tstart = 0;\n\t\tend = 255;\n\t}\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tfor (range_count = 0; range_count < (max_count = 8); range_count++) {\n\t\tfor (offset_count = 0;offset_count < 32; offset_count++) {\n\t\t\tif ((((ip_table.ip_range[range_count] >> offset_count) & 0x01) == 0) \n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) >= start)\n\t\t\t\t&&(((range_count * 32) + (offset_count + 1)) <= end)) {\n\t\t\t\txSemaphoreGive(dhcps_ip_table_semaphore); \n\t\t\t\treturn ((range_count * 32) + (offset_count + 1));\n\t\t\t}\n\t\t}\n\t}\n\txSemaphoreGive(dhcps_ip_table_semaphore); \n\treturn 0;\n}", "target": 0}
{"code": "nfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tstruct kvec *tail = rqstp->rq_arg.tail;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\tif ((void *)p > head->iov_base + head->iov_len)\n\t\treturn 0;\n\tif (args->count != args->len)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "std::string TarFileReader::extract(const string &_path) {\n  if (_path.empty()) THROW(\"path cannot be empty\");\n  if (!hasMore()) THROW(\"No more tar files\");\n  string path = _path;\n  if (SystemUtilities::isDirectory(path)) path += \"/\" + getFilename();\n  LOG_DEBUG(5, \"Extracting: \" << path);\n  return extract(*SystemUtilities::oopen(path));\n}", "target": 1}
{"code": "crm_recv_remote_raw(void *session, gboolean encrypted, size_t max_recv, size_t *recv_len, int *disconnected)\n{\n    char *reply = NULL;\n    if (recv_len) {\n        *recv_len = 0;\n    }\n    if (disconnected) {\n        *disconnected = 0;\n    }\n    if (encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        reply = crm_recv_tls(session, max_recv, recv_len, disconnected);\n#else\n        CRM_ASSERT(encrypted == FALSE);\n#endif\n    } else {\n        reply = crm_recv_plaintext(GPOINTER_TO_INT(session), max_recv, recv_len, disconnected);\n    }\n    if (reply == NULL || strlen(reply) == 0) {\n        crm_trace(\"Empty reply\");\n    }\n    return reply;\n}", "target": 0}
{"code": "_client_list_free_node(t_client *client)\n{\n\tchar *msg;\n\tchar *cidinfo;\n\tif (client->cid) {\n\t\tif (strlen(client->cid) > 0) {\n\t\t\tmsg = safe_calloc(SMALL_BUF);\n\t\t\tcidinfo = safe_calloc(MID_BUF);\n\t\t\tsafe_snprintf(cidinfo, MID_BUF, \"cid=\\\"%s\\\"\", client->cid);\n\t\t\twrite_client_info(msg, SMALL_BUF, \"rmcid\", client->cid, cidinfo);\n\t\t\tfree(msg);\n\t\t\tfree(cidinfo);\n\t\t}\n\t}\n\tfree(client->token);\n\tfree(client->hid);\n\tfree(client->custom);\n\tfree(client->client_type);\n\tfree(client->cid);\n\tif (strcmp(client->cpi_query, \"\") == 0) {\n\t\tfree(client->cpi_query);\n\t}\n\tfree(client);\n}", "target": 0}
{"code": "static void add_send_options(GDHCPClient *dhcp_client,\n\t\t\t\tstruct dhcp_packet *packet)\n{\n\tg_hash_table_foreach(dhcp_client->send_value_hash,\n\t\t\t\tadd_binary_option, packet);\n}", "target": 0}
{"code": "monitor_sync(struct monitor *pmonitor)\n{\n\tif (options.compression) {\n\t\tmm_share_sync(&pmonitor->m_zlib, &pmonitor->m_zback);\n\t}\n}", "target": 1}
{"code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\tif (!net_eq(current->nsproxy->net_ns, sock_net(sk)))\n\t\treturn -EINVAL;\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\t*sockp = sock;\n\treturn err;\n}", "target": 0}
{"code": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}", "target": 1}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "static inline void PrefetchPixelCacheNexusPixels(const NexusInfo *nexus_info,\n  const MapMode mode)\n{\n  if (mode == ReadMode)\n    {\n      MagickCachePrefetch((unsigned char *) nexus_info->pixels,0,1);\n      return;\n    }\n  MagickCachePrefetch((unsigned char *) nexus_info->pixels,1,1);\n}", "target": 0}
{"code": "const FieldID& activeUnionMemberId(const void* object, ptrdiff_t offset) {\n  return *reinterpret_cast<const FieldID*>(\n      offset + static_cast<const char*>(object));\n}", "target": 1}
{"code": "int nfc_fw_download(struct nfc_dev *dev, const char *firmware_name)\n{\n\tint rc = 0;\n\tpr_debug(\"%s do firmware %s\\n\", dev_name(&dev->dev), firmware_name);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dev_up) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->fw_download) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tdev->fw_download_in_progress = true;\n\trc = dev->ops->fw_download(dev, firmware_name);\n\tif (rc)\n\t\tdev->fw_download_in_progress = false;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static int sgi_timer_set(struct k_itimer *timr, int flags,\n\tstruct itimerspec * new_setting,\n\tstruct itimerspec * old_setting)\n{\n\tunsigned long when, period, irqflags;\n\tint err = 0;\n\tcnodeid_t nodeid;\n\tstruct mmtimer *base;\n\tstruct rb_node *n;\n\tif (old_setting)\n\t\tsgi_timer_get(timr, old_setting);\n\tsgi_timer_del(timr);\n\twhen = timespec_to_ns(new_setting->it_value);\n\tperiod = timespec_to_ns(new_setting->it_interval);\n\tif (when == 0)\n\t\treturn 0;\n\tbase = kmalloc(sizeof(struct mmtimer), GFP_KERNEL);\n\tif (base == NULL)\n\t\treturn -ENOMEM;\n\tif (flags & TIMER_ABSTIME) {\n\t\tstruct timespec n;\n\t\tunsigned long now;\n\t\tgetnstimeofday(&n);\n\t\tnow = timespec_to_ns(n);\n\t\tif (when > now)\n\t\t\twhen -= now;\n\t\telse\n\t\t\twhen = 0;\n\t}\n\twhen = (when + sgi_clock_period - 1) / sgi_clock_period + rtc_time();\n\tperiod = (period + sgi_clock_period - 1)  / sgi_clock_period;\n\tpreempt_disable();\n\tnodeid =  cpu_to_node(smp_processor_id());\n\tspin_lock_irqsave(&timers[nodeid].lock, irqflags);\n\tbase->timer = timr;\n\tbase->cpu = smp_processor_id();\n\ttimr->it.mmtimer.clock = TIMER_SET;\n\ttimr->it.mmtimer.node = nodeid;\n\ttimr->it.mmtimer.incr = period;\n\ttimr->it.mmtimer.expires = when;\n\tn = timers[nodeid].next;\n\tmmtimer_add_list(base);\n\tif (timers[nodeid].next == n) {\n\t\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\t\tpreempt_enable();\n\t\treturn err;\n\t}\n\tif (n)\n\t\tmmtimer_disable_int(cnodeid_to_nasid(nodeid), COMPARATOR);\n\tmmtimer_set_next_timer(nodeid);\n\tspin_unlock_irqrestore(&timers[nodeid].lock, irqflags);\n\tpreempt_enable();\n\treturn err;\n}", "target": 1}
{"code": "BigInt EC_Group::multiply_mod_order(const BigInt& x, const BigInt& y, const BigInt& z) const\n   {\n   return data().multiply_mod_order(x, y, z);\n   }", "target": 0}
{"code": "messageFindArgument(const message *m, const char *variable)\n{\n\tint i;\n\tsize_t len;\n\tassert(m != NULL);\n\tassert(variable != NULL);\n\tlen = strlen(variable);\n\tfor(i = 0; i < m->numberOfArguments; i++) {\n\t\tconst char *ptr;\n\t\tptr = messageGetArgument(m, i);\n\t\tif((ptr == NULL) || (*ptr == '\\0'))\n\t\t\tcontinue;\n#ifdef\tCL_DEBUG\n\t\tcli_dbgmsg(\"messageFindArgument: compare %lu bytes of %s with %s\\n\",\n\t\t\t(unsigned long)len, variable, ptr);\n#endif\n\t\tif(strncasecmp(ptr, variable, len) == 0) {\n\t\t\tptr = &ptr[len];\n\t\t\twhile(isspace(*ptr))\n\t\t\t\tptr++;\n\t\t\tif(*ptr != '=') {\n\t\t\t\tcli_dbgmsg(\"messageFindArgument: no '=' sign found in MIME header '%s' (%s)\\n\", variable, messageGetArgument(m, i));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif((*++ptr == '\"') && (strchr(&ptr[1], '\"') != NULL)) {\n\t\t\t\tchar *ret = cli_strdup(++ptr);\n\t\t\t\tchar *p;\n\t\t\t\tif(ret == NULL)\n\t\t\t\t\treturn NULL;\n\t\t\t\tif((p = strchr(ret, '\"')) != NULL) {\n\t\t\t\t\tret[strlen(ret) - 1] = '\\0';\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn cli_strdup(ptr);\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)\n{\n\tstruct scsi_cmnd *cmd, *n;\n\tlist_for_each_entry_safe(cmd, n, error_q, eh_entry) {\n\t\tif (cmd->device->sdev_target == my_cmd->device->sdev_target &&\n\t\t    cmd->device->lun == my_cmd->device->lun)\n\t\t\tsas_eh_defer_cmd(cmd);\n\t}\n}", "target": 1}
{"code": "static BOOL rdp_redirection_read_base64_wchar(UINT32 flag, wStream* s, UINT32* pLength,\n                                              BYTE** pData)\n{\n\tBOOL rc = FALSE;\n\tchar buffer[64] = { 0 };\n\tconst BYTE* ptr = NULL;\n\tif (!rdp_redirection_get_data(s, pLength, &ptr))\n\t\treturn FALSE;\n\tconst WCHAR* wchar = (const WCHAR*)ptr;\n\tsize_t utf8_len = 0;\n\tchar* utf8 = ConvertWCharNToUtf8Alloc(wchar, *pLength, &utf8_len);\n\tif (!utf8)\n\t\tgoto fail;\n\tredirection_free_data(pData, NULL);\n\tutf8_len = strnlen(utf8, utf8_len);\n\t*pData = calloc(utf8_len, sizeof(BYTE));\n\tif (!*pData)\n\t\tgoto fail;\n\tsize_t rlen = utf8_len;\n\tsize_t wpos = 0;\n\tchar* tok = strtok(utf8, \"\\r\\n\");\n\twhile (tok)\n\t{\n\t\tconst size_t len = strnlen(tok, rlen);\n\t\trlen -= len;\n\t\tsize_t bplen = 0;\n\t\tBYTE* bptr = NULL;\n\t\tcrypto_base64_decode(tok, len, &bptr, &bplen);\n\t\tif (!bptr)\n\t\t\tgoto fail;\n\t\tmemcpy(&(*pData)[wpos], bptr, bplen);\n\t\twpos += bplen;\n\t\tfree(bptr);\n\t\ttok = strtok(NULL, \"\\r\\n\");\n\t}\n\t*pLength = wpos;\n\tWLog_DBG(TAG, \"%s:\", rdp_redirection_flags_to_string(flag, buffer, sizeof(buffer)));\n\trc = TRUE;\nfail:\n\tif (!rc)\n\t\tWLog_ERR(TAG, \"failed to read base64 data\");\n\tfree(utf8);\n\treturn rc;\n}", "target": 1}
{"code": "selReadStream(FILE  *fp)\n{\nchar    *selname;\nchar     linebuf[L_BUF_SIZE];\nl_int32  sy, sx, cy, cx, i, j, version, ignore;\nSEL     *sel;\n    PROCNAME(\"selReadStream\");\n    if (!fp)\n        return (SEL *)ERROR_PTR(\"stream not defined\", procName, NULL);\n    if (fscanf(fp, \"  Sel Version %d\\n\", &version) != 1)\n        return (SEL *)ERROR_PTR(\"not a sel file\", procName, NULL);\n    if (version != SEL_VERSION_NUMBER)\n        return (SEL *)ERROR_PTR(\"invalid sel version\", procName, NULL);\n    if (fgets(linebuf, L_BUF_SIZE, fp) == NULL)\n        return (SEL *)ERROR_PTR(\"error reading into linebuf\", procName, NULL);\n    selname = stringNew(linebuf);\n    sscanf(linebuf, \"  ------  %s  ------\", selname);\n    if (fscanf(fp, \"  sy = %d, sx = %d, cy = %d, cx = %d\\n\",\n            &sy, &sx, &cy, &cx) != 4) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"dimensions not read\", procName, NULL);\n    }\n    if ((sel = selCreate(sy, sx, selname)) == NULL) {\n        LEPT_FREE(selname);\n        return (SEL *)ERROR_PTR(\"sel not made\", procName, NULL);\n    }\n    selSetOrigin(sel, cy, cx);\n    for (i = 0; i < sy; i++) {\n        ignore = fscanf(fp, \"    \");\n        for (j = 0; j < sx; j++)\n            ignore = fscanf(fp, \"%1d\", &sel->data[i][j]);\n        ignore = fscanf(fp, \"\\n\");\n    }\n    ignore = fscanf(fp, \"\\n\");\n    LEPT_FREE(selname);\n    return sel;\n}", "target": 1}
{"code": "  CrxImage() : memmgr(0){}", "target": 0}
{"code": "Client::connect()\n{\n    if (m_stream != NULL) {\n        return;\n    }\n    if (m_suspended) {\n        m_connectOnResume = true;\n        return;\n    }\n    auto security_level = ConnectionSecurityLevel::PLAINTEXT;\n    if (m_useSecureNetwork) {\n        security_level = ConnectionSecurityLevel::ENCRYPTED;\n    }\n    try {\n        m_serverAddress.resolve();\n        if (m_serverAddress.getAddress() != NULL) {\n          LOG((CLOG_NOTE \"connecting to '%s': %s:%i\",\n          m_serverAddress.getHostname().c_str(),\n          ARCH->addrToString(m_serverAddress.getAddress()).c_str(),\n          m_serverAddress.getPort()));\n        }\n        IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()),\n                                                      security_level);\n        m_socket = dynamic_cast<TCPSocket*>(socket);\n        m_stream = socket;\n        m_stream = new PacketStreamFilter(m_events, m_stream, true);\n        LOG((CLOG_DEBUG1 \"connecting to server\"));\n        setupConnecting();\n        setupTimer();\n        socket->connect(m_serverAddress);\n    }\n    catch (XBase& e) {\n        cleanupTimer();\n        cleanupConnecting();\n        cleanupStream();\n        LOG((CLOG_DEBUG1 \"connection failed\"));\n        sendConnectionFailedEvent(e.what());\n        return;\n    }\n}", "target": 1}
{"code": "execlists_unwind_incomplete_requests(struct intel_engine_execlists *execlists)\n{\n\tstruct intel_engine_cs *engine =\n\t\tcontainer_of(execlists, typeof(*engine), execlists);\n\treturn __unwind_incomplete_requests(engine);\n}", "target": 0}
{"code": "static inline int perf_intr_is_nmi(struct pt_regs *regs)\n{\n\treturn !regs->softe;\n}", "target": 0}
{"code": "  void clear_scheduled_exception() {\n    thread_local_top_.scheduled_exception_ = heap_.the_hole_value();\n  }", "target": 0}
{"code": "heap_available()\n{\n    long avail = 0;\n    void *probes[max_malloc_probes];\n    uint n;\n    for (n = 0; n < max_malloc_probes; n++) {\n        if ((probes[n] = malloc(malloc_probe_size)) == 0)\n            break;\n        if_debug2('a', \"[a]heap_available probe[%d]=0x%lx\\n\",\n                  n, (ulong) probes[n]);\n        avail += malloc_probe_size;\n    }\n    while (n)\n        free(probes[--n]);\n    return avail;\n}", "target": 0}
{"code": "void CommandData::ParseArg(wchar *Arg)\n{\n  if (IsSwitch(*Arg) && !NoMoreSwitches)\n    if (Arg[1]=='-' && Arg[2]==0)\n      NoMoreSwitches=true;\n    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpy(Command,Arg,ASIZE(Command));\n      *Command=toupperw(*Command);\n      if (*Command!='I' && *Command!='S')\n        wcsupper(Command);\n    }\n    else\n      if (*ArcName==0)\n        wcsncpyz(ArcName,Arg,ASIZE(ArcName));\n      else\n      {\n        size_t Length=wcslen(Arg);\n        wchar EndChar=Length==0 ? 0:Arg[Length-1];\n        bool EndSeparator=IsDriveDiv(EndChar) || IsPathDiv(EndChar);\n        wchar CmdChar=toupperw(*Command);\n        bool Add=wcschr(L\"AFUM\",CmdChar)!=NULL;\n        bool Extract=CmdChar=='X' || CmdChar=='E';\n        if (EndSeparator && !Add)\n          wcsncpyz(ExtrPath,Arg,ASIZE(ExtrPath));\n        else\n          if ((Add || CmdChar=='T') && (*Arg!='@' || ListMode==RCLM_REJECT_LISTS))\n            FileArgs.AddString(Arg);\n          else\n          {\n            FindData FileData;\n            bool Found=FindFile::FastFind(Arg,&FileData);\n            if ((!Found || ListMode==RCLM_ACCEPT_LISTS) && \n                ListMode!=RCLM_REJECT_LISTS && *Arg=='@' && !IsWildcard(Arg))\n            {\n              FileLists=true;\n              ReadTextFile(Arg+1,&FileArgs,false,true,FilelistCharset,true,true,true);\n            }\n            else\n              if (Found && FileData.IsDir && Extract && *ExtrPath==0)\n              {\n                wcsncpyz(ExtrPath,Arg,ASIZE(ExtrPath));\n                AddEndSlash(ExtrPath,ASIZE(ExtrPath));\n              }\n              else\n                FileArgs.AddString(Arg);\n          }\n      }\n}", "target": 1}
{"code": "bool EditorClientBlackBerry::shouldApplyStyle(StylePropertySet*, Range*)\n{\n    notImplemented();\n    return true;\n}", "target": 0}
{"code": "header_put_le_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\t} ;\n} ", "target": 1}
{"code": "static char* get_private_subtags(const char* loc_name)\n{\n\tchar* \tresult =NULL;\n\tint \tsingletonPos = 0;\n\tint \tlen =0; \n\tconst char* \tmod_loc_name =NULL;\n\tif( loc_name && (len = strlen(loc_name)>0 ) ){\n\t\tmod_loc_name = loc_name ; \n\t\tlen   = strlen(mod_loc_name);\n\t\twhile( (singletonPos = getSingletonPos(mod_loc_name))!= -1){\n\t\t\tif( singletonPos!=-1){ \n\t\t\t\tif( (*(mod_loc_name+singletonPos)=='x') || (*(mod_loc_name+singletonPos)=='X') ){\t\t\n\t\t\t\t\tif( singletonPos + 2 ==  len){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tresult = estrndup(mod_loc_name + singletonPos+2  , (len -( singletonPos +2) ) );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif( singletonPos + 1 >=  len){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmod_loc_name = mod_loc_name + singletonPos +1;\n\t\t\t\t\t\tlen = strlen(mod_loc_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n\treturn result;\n}", "target": 1}
{"code": "static inline void jmp_rel(struct x86_emulate_ctxt *ctxt, int rel)\n{\n\tassign_eip_near(ctxt, ctxt->_eip + rel);\n}", "target": 1}
{"code": "main (int argc, char **argv)\n{\n\tEvArchive *ar;\n\tEvArchiveType ar_type;\n\tGError *error = NULL;\n\tgboolean printed_header = FALSE;\n\tif (argc != 3) {\n\t\tusage (argv[0]);\n\t\treturn 1;\n\t}\n\tar_type = str_to_archive_type (argv[1]);\n\tif (ar_type == EV_ARCHIVE_TYPE_NONE)\n\t\treturn 1;\n\tar = ev_archive_new ();\n\tif (!ev_archive_set_archive_type (ar, ar_type)) {\n\t\tg_warning (\"Failed to set archive type\");\n\t\tgoto out;\n\t}\n\tif (!ev_archive_open_filename (ar, argv[2], &error)) {\n\t\tg_warning (\"Failed to open '%s': %s\",\n\t\t\t   argv[2], error->message);\n\t\tg_error_free (error);\n\t\tgoto out;\n\t}\n\twhile (1) {\n\t\tconst char *name;\n\t\tgboolean is_encrypted;\n\t\tgint64 size;\n\t\tif (!ev_archive_read_next_header (ar, &error)) {\n\t\t\tif (error != NULL) {\n\t\t\t\tg_warning (\"Fatal error handling archive: %s\", error->message);\n\t\t\t\tg_clear_error (&error);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tname = ev_archive_get_entry_pathname (ar);\n\t\tis_encrypted = ev_archive_get_entry_is_encrypted (ar);\n\t\tsize = ev_archive_get_entry_size (ar);\n\t\tif (!printed_header) {\n\t\t\tg_print (\"P\\tSIZE\\tNAME\\n\");\n\t\t\tprinted_header = TRUE;\n\t\t}\n\t\tg_print (\"%c\\t%\"G_GINT64_FORMAT\"\\t%s\\n\",\n\t\t\t is_encrypted ? 'P' : ' ',\n\t\t\t size, name);\n\t}\n\tev_archive_reset (ar);\n\tg_clear_object (&ar);\n\treturn 0;\nout:\n\tg_clear_object (&ar);\n\treturn 1;\n}", "target": 0}
{"code": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\tif (!commit_transaction)\n\t\treturn;\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}", "target": 1}
{"code": "static mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n    if ( !id )\n        id = rand();\n    mm->head.len = len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n    return mm;\n}", "target": 1}
{"code": "static inline uint16_t ok_inflater_can_write_total(const ok_inflater *inflater) {\n    return inflater->buffer_start_pos - inflater->buffer_end_pos - 1;\n}", "target": 0}
{"code": "static void coroutine_fn v9fs_attach(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsState *s = pdu->s;\n    int32_t fid, afid, n_uname;\n    V9fsString uname, aname;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsQID qid;\n    ssize_t err;\n    v9fs_string_init(&uname);\n    v9fs_string_init(&aname);\n    err = pdu_unmarshal(pdu, offset, \"ddssd\", &fid,\n                        &afid, &uname, &aname, &n_uname);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_attach(pdu->tag, pdu->id, fid, afid, uname.data, aname.data);\n    fidp = alloc_fid(s, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    fidp->uid = n_uname;\n    err = v9fs_co_name_to_path(pdu, NULL, \"/\", &fidp->path);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err = fid_to_qid(pdu, fidp, &qid);\n    if (err < 0) {\n        err = -EINVAL;\n        clunk_fid(s, fid);\n        goto out;\n    }\n    if (!s->migration_blocker) {\n        error_setg(&s->migration_blocker,\n                   \"Migration is disabled when VirtFS export path '%s' is mounted in the guest using mount_tag '%s'\",\n                   s->ctx.fs_root ? s->ctx.fs_root : \"NULL\", s->tag);\n        err = migrate_add_blocker(s->migration_blocker, NULL);\n        if (err < 0) {\n            error_free(s->migration_blocker);\n            s->migration_blocker = NULL;\n            clunk_fid(s, fid);\n            goto out;\n        }\n        s->root_fid = fid;\n    }\n    err = pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        clunk_fid(s, fid);\n        goto out;\n    }\n    err += offset;\n    memcpy(&s->root_qid, &qid, sizeof(qid));\n    trace_v9fs_attach_return(pdu->tag, pdu->id,\n                             qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&uname);\n    v9fs_string_free(&aname);\n}", "target": 0}
{"code": "static int fetch_setup_walk(git_revwalk **out, git_repository *repo)\n{\n\tgit_revwalk *walk = NULL;\n\tgit_strarray refs;\n\tunsigned int i;\n\tgit_reference *ref;\n\tint error;\n\tif ((error = git_reference_list(&refs, repo)) < 0)\n\t\treturn error;\n\tif ((error = git_revwalk_new(&walk, repo)) < 0)\n\t\treturn error;\n\tgit_revwalk_sorting(walk, GIT_SORT_TIME);\n\tfor (i = 0; i < refs.count; ++i) {\n\t\tif (!git__prefixcmp(refs.strings[i], GIT_REFS_TAGS_DIR))\n\t\t\tcontinue;\n\t\tif ((error = git_reference_lookup(&ref, repo, refs.strings[i])) < 0)\n\t\t\tgoto on_error;\n\t\tif (git_reference_type(ref) == GIT_REF_SYMBOLIC)\n\t\t\tcontinue;\n\t\tif ((error = git_revwalk_push(walk, git_reference_target(ref))) < 0)\n\t\t\tgoto on_error;\n\t\tgit_reference_free(ref);\n\t}\n\tgit_strarray_free(&refs);\n\t*out = walk;\n\treturn 0;\non_error:\n\tgit_revwalk_free(walk);\n\tgit_reference_free(ref);\n\tgit_strarray_free(&refs);\n\treturn error;\n}", "target": 0}
{"code": "static MagickBooleanType ReadPSDChannelRLE(Image *image,const PSDInfo *psd_info,\n  const ssize_t type,MagickOffsetType *sizes,ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n  size_t\n    length,\n    row_size;\n  ssize_t\n    count,\n    y;\n  unsigned char\n    *compact_pixels,\n    *pixels;\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n       \"      layer data is RLE compressed\");\n  row_size=GetPSDRowSize(image);\n  pixels=(unsigned char *) AcquireQuantumMemory(row_size,sizeof(*pixels));\n  if (pixels == (unsigned char *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  length=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n    if ((MagickOffsetType) length < sizes[y])\n      length=(size_t) sizes[y];\n  if (length > row_size + 256) \n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"InvalidLength\",\n        image->filename);\n    }\n  compact_pixels=(unsigned char *) AcquireQuantumMemory(length,sizeof(*pixels));\n  if (compact_pixels == (unsigned char *) NULL)\n    {\n      pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n      ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n        image->filename);\n    }\n  (void) ResetMagickMemory(compact_pixels,0,length*sizeof(*compact_pixels));\n  status=MagickTrue;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    status=MagickFalse;\n    count=ReadBlob(image,(size_t) sizes[y],compact_pixels);\n    if (count != (ssize_t) sizes[y])\n      break;\n    count=DecodePSDPixels((size_t) sizes[y],compact_pixels,\n      (ssize_t) (image->depth == 1 ? 123456 : image->depth),row_size,pixels);\n    if (count != (ssize_t) row_size)\n      break;\n    status=ReadPSDChannelPixels(image,psd_info->channels,y,type,pixels,\n      exception);\n    if (status == MagickFalse)\n      break;\n  }\n  compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);\n  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n  return(status);\n}", "target": 1}
{"code": "flatpak_validate_path_characters (const char *path,\n                                  GError    **error)\n{\n  while (*path)\n    {\n      gunichar c = g_utf8_get_char_validated (path, -1);\n      if (c == (gunichar)-1 || c == (gunichar)-2)\n        {\n          g_autofree char *escaped_char = escape_character ((unsigned char)*path);\n          g_autofree char *escaped = flatpak_escape_string (path, FLATPAK_ESCAPE_DEFAULT);\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                       \"Non-UTF8 byte %s in path %s\", escaped_char, escaped);\n          return FALSE;\n        }\n      else if (!is_char_safe (c))\n        {\n          g_autofree char *escaped_char = escape_character (c);\n          g_autofree char *escaped = flatpak_escape_string (path, FLATPAK_ESCAPE_DEFAULT);\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA,\n                       \"Non-graphical character %s in path %s\", escaped_char, escaped);\n          return FALSE;\n        }\n      path = g_utf8_find_next_char (path, NULL);\n    }\n  return TRUE;\n}", "target": 0}
{"code": "bool CSPSource::isSchemeOnly() const\n{\n    return m_host.isEmpty();\n}", "target": 0}
{"code": "resolve_superior_type_check(struct lys_type *type)\n{\n    uint32_t i;\n    if (type->base == LY_TYPE_DER) {\n        return EXIT_FAILURE;\n    } else if (type->base == LY_TYPE_UNION) {\n        for (i = 0; i < type->info.uni.count; ++i) {\n            if (resolve_superior_type_check(&type->info.uni.types[i])) {\n                return EXIT_FAILURE;\n            }\n        }\n    } else if (type->base == LY_TYPE_LEAFREF) {\n        while (!type->info.lref.path) {\n            assert(type->der);\n            type = &type->der->type;\n        }\n    }\n    return EXIT_SUCCESS;\n}", "target": 0}
{"code": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n\t\t}", "target": 1}
{"code": "static inline struct old_rng_alg *crypto_old_rng_alg(struct crypto_rng *tfm)\n{\n\treturn &crypto_rng_tfm(tfm)->__crt_alg->cra_rng;\n}", "target": 1}
{"code": "static bool read_phdr(ELFOBJ *bin, bool linux_kernel_hack) {\n\tbool phdr_found = false;\n\tint i;\n#if R_BIN_ELF64\n\tconst bool is_elf64 = true;\n#else\n\tconst bool is_elf64 = false;\n#endif\n\tut64 phnum = Elf_(r_bin_elf_get_phnum) (bin);\n\tfor (i = 0; i < phnum; i++) {\n\t\tut8 phdr[sizeof (Elf_(Phdr))] = {0};\n\t\tint j = 0;\n\t\tconst size_t rsize = bin->ehdr.e_phoff + i * sizeof (Elf_(Phdr));\n\t\tint len = r_buf_read_at (bin->b, rsize, phdr, sizeof (Elf_(Phdr)));\n\t\tif (len < 1) {\n\t\t\tR_LOG_ERROR (\"read (phdr)\");\n\t\t\tR_FREE (bin->phdr);\n\t\t\treturn false;\n\t\t}\n\t\tbin->phdr[i].p_type = READ32 (phdr, j);\n\t\tif (bin->phdr[i].p_type == PT_PHDR) {\n\t\t\tphdr_found = true;\n\t\t}\n\t\tif (is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_offset = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_vaddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_paddr = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_filesz = R_BIN_ELF_READWORD (phdr, j);\n\t\tbin->phdr[i].p_memsz = R_BIN_ELF_READWORD (phdr, j);\n\t\tif (!is_elf64) {\n\t\t\tbin->phdr[i].p_flags = READ32 (phdr, j);\n\t\t}\n\t\tbin->phdr[i].p_align = R_BIN_ELF_READWORD (phdr, j);\n\t}\n\tif (linux_kernel_hack && phdr_found) {\n\t\tut64 load_addr = Elf_(r_bin_elf_get_baddr) (bin);\n\t\tbin->ehdr.e_phoff = Elf_(r_bin_elf_v2p) (bin, load_addr + bin->ehdr.e_phoff);\n\t\treturn read_phdr (bin, false);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void RequestContext::StartBackendSpanAndSetTraceContext() {\n  backend_span_.reset(CreateSpan(cloud_trace_.get(), \"Backend\"));\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}", "target": 1}
{"code": "        CFontFileBase(char *sFile, int nLen, bool bFreeFileData)\n        {\n            m_sFileData = m_sFile = (unsigned char *)sFile;\n            m_nLen = nLen;\n            m_bFreeFileData = bFreeFileData;\n            m_nPos = 0;\n        }", "target": 1}
{"code": "  void Compute(OpKernelContext* c) override {\n    const TensorList* input_list = nullptr;\n    OP_REQUIRES_OK(c, GetInputList(c, 0, &input_list));\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(c->input(1).shape()),\n                errors::InvalidArgument(\"size must be a scalar\"));\n    int32_t size = c->input(1).scalar<int32>()();\n    OP_REQUIRES(\n        c, size >= 0,\n        errors::InvalidArgument(\n            \"TensorListSlice expects size to be non-negative. Got: \", size));\n    std::unique_ptr<Tensor> maybe_result =\n        c->forward_input(0, 0, DT_VARIANT, TensorShape{},\n                         c->input_memory_type(0), AllocatorAttributes());\n    if (maybe_result != nullptr) {\n      TensorList* out = maybe_result->scalar<Variant>()().get<TensorList>();\n      if (out->RefCountIsOne()) {\n        out->tensors().resize(size, Tensor(DT_INVALID));\n        c->set_output(0, *maybe_result);\n        return;\n      }\n    }\n    Tensor* result;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape{}, &result, attr));\n    TensorList output_list;\n    output_list.element_shape = input_list->element_shape;\n    output_list.element_dtype = input_list->element_dtype;\n    output_list.max_num_elements = input_list->max_num_elements;\n    if (size > input_list->tensors().size()) {\n      output_list.tensors().insert(output_list.tensors().begin(),\n                                   input_list->tensors().begin(),\n                                   input_list->tensors().end());\n      output_list.tensors().resize(size, Tensor(DT_INVALID));\n    } else {\n      output_list.tensors().insert(output_list.tensors().begin(),\n                                   input_list->tensors().begin(),\n                                   input_list->tensors().begin() + size);\n    }\n    result->scalar<Variant>()() = std::move(output_list);\n  }", "target": 0}
{"code": "gimp_channel_new_from_buffer (GimpImage     *image,\n                              GeglBuffer    *buffer,\n                              const gchar   *name,\n                              const GimpRGB *color)\n{\n  GimpChannel *channel;\n  GeglBuffer  *dest;\n  g_return_val_if_fail (GIMP_IS_IMAGE (image), NULL);\n  g_return_val_if_fail (GEGL_IS_BUFFER (buffer), NULL);\n  channel = gimp_channel_new (image,\n                              gegl_buffer_get_width  (buffer),\n                              gegl_buffer_get_height (buffer),\n                              name, color);\n  dest = gimp_drawable_get_buffer (GIMP_DRAWABLE (channel));\n  gimp_gegl_buffer_copy (buffer, NULL, GEGL_ABYSS_NONE, dest, NULL);\n  return channel;\n}", "target": 0}
{"code": "static size_t write_cb(void *contents, size_t size, size_t nmemb, void *data)\n{\n    size_t realsize = 0;\n    connection_t *conn = NULL;\n    char *ptr = NULL;\n    conn = data;\n    ogs_assert(conn);\n    realsize = size * nmemb;\n    ptr = ogs_realloc(conn->memory, conn->size + realsize + 1);\n    if(!ptr) {\n        ogs_fatal(\"not enough memory (realloc returned NULL)\");\n        ogs_assert_if_reached();\n        return 0;\n    }\n    conn->memory = ptr;\n    memcpy(&(conn->memory[conn->size]), contents, realsize);\n    conn->size += realsize;\n    conn->memory[conn->size] = 0;\n    return realsize;\n}", "target": 1}
{"code": "static int decode_font(ASS_Track *track)\n{\n    unsigned char *p;\n    unsigned char *q;\n    size_t i;\n    size_t size;                   \n    size_t dsize;                  \n    unsigned char *buf = 0;\n    ass_msg(track->library, MSGL_V, \"Font: %d bytes encoded data\",\n            track->parser_priv->fontdata_used);\n    size = track->parser_priv->fontdata_used;\n    if (size % 4 == 1) {\n        ass_msg(track->library, MSGL_ERR, \"Bad encoded data size\");\n        goto error_decode_font;\n    }\n    buf = malloc(size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (!buf)\n        goto error_decode_font;\n    q = buf;\n    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;\n         i < size / 4; i++, p += 4) {\n        q = decode_chars(p, q, 4);\n    }\n    if (size % 4 == 2) {\n        q = decode_chars(p, q, 2);\n    } else if (size % 4 == 3) {\n        q = decode_chars(p, q, 3);\n    }\n    dsize = q - buf;\n    assert(dsize == size / 4 * 3 + FFMAX(size % 4 - 1, 0));\n    if (track->library->extract_fonts) {\n        ass_add_font(track->library, track->parser_priv->fontname,\n                     (char *) buf, dsize);\n    }\nerror_decode_font:\n    free(buf);\n    reset_embedded_font_parsing(track->parser_priv);\n    return 0;\n}", "target": 1}
{"code": "static int rb_check_list(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t struct list_head *list)\n{\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->prev) != list->prev))\n\t\treturn 1;\n\tif (RB_WARN_ON(cpu_buffer, rb_list_head(list->next) != list->next))\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "static struct dentry *aio_mount(struct file_system_type *fs_type,\n\t\t\t\tint flags, const char *dev_name, void *data)\n{\n\tstatic const struct dentry_operations ops = {\n\t\t.d_dname\t= simple_dname,\n\t};\n\treturn mount_pseudo(fs_type, \"aio:\", NULL, &ops, AIO_RING_MAGIC);\n}", "target": 1}
{"code": "static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n\t\treturn -EINVAL;\n\tif (up->replay_window > up->bmp_len * sizeof(__u32) * 8)\n\t\treturn -EINVAL;\n\treturn 0;\n}", "target": 0}
{"code": "void SSH2_update_kex_myproposal(PTInstVar pvar)\n{\n\tstatic char buf[512]; \n\tint index;\n\tint i;\n\tif (pvar->socket != INVALID_SOCKET) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint pos = strlen(myproposal[PROPOSAL_KEX_ALGS]) - strlen(\",ext-info-c\");\n\t\t\tif (strcmp(myproposal[PROPOSAL_KEX_ALGS] + pos, \",ext-info-c\") == 0) {\n\t\t\t\tmyproposal[PROPOSAL_KEX_ALGS][pos] = '\\0';\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tbuf[0] = '\\0';\n\tfor (i = 0 ; pvar->settings.KexOrder[i] != 0 ; i++) {\n\t\tindex = pvar->settings.KexOrder[i] - '0';\n\t\tif (index == KEX_DH_NONE) \n\t\t\tbreak;\n\t\tstrncat_s(buf, sizeof(buf), get_kex_algorithm_name(index), _TRUNCATE);\n\t\tstrncat_s(buf, sizeof(buf), \",\", _TRUNCATE);\n\t}\n\tstrncat_s(buf, sizeof(buf), \"ext-info-c\", _TRUNCATE);\n\tmyproposal[PROPOSAL_KEX_ALGS] = buf; \n}", "target": 1}
{"code": "int ff_combine_frame(ParseContext *pc, int next, const uint8_t **buf, int *buf_size)\n{\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1], (*buf)[2], (*buf)[3]);\n    }\n    for(; pc->overread>0; pc->overread--){\n        pc->buffer[pc->index++]= pc->buffer[pc->overread_index++];\n    }\n    if(!*buf_size && next == END_NOT_FOUND){\n        next= 0;\n    }\n    pc->last_index= pc->index;\n    if(next == END_NOT_FOUND){\n        void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, (*buf_size) + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n            return AVERROR(ENOMEM);\n        pc->buffer = new_buffer;\n        memcpy(&pc->buffer[pc->index], *buf, *buf_size);\n        pc->index += *buf_size;\n        return -1;\n    }\n    *buf_size=\n    pc->overread_index= pc->index + next;\n    if(pc->index){\n        void* new_buffer = av_fast_realloc(pc->buffer, &pc->buffer_size, next + pc->index + FF_INPUT_BUFFER_PADDING_SIZE);\n        if(!new_buffer)\n            return AVERROR(ENOMEM);\n        pc->buffer = new_buffer;\n        if (next > -FF_INPUT_BUFFER_PADDING_SIZE)\n            memcpy(&pc->buffer[pc->index], *buf,\n                   next + FF_INPUT_BUFFER_PADDING_SIZE);\n        pc->index = 0;\n        *buf= pc->buffer;\n    }\n    for(;next < 0; next++){\n        pc->state = (pc->state<<8) | pc->buffer[pc->last_index + next];\n        pc->state64 = (pc->state64<<8) | pc->buffer[pc->last_index + next];\n        pc->overread++;\n    }\n    if(pc->overread){\n        av_dlog(NULL, \"overread %d, state:%X next:%d index:%d o_index:%d\\n\",\n                pc->overread, pc->state, next, pc->index, pc->overread_index);\n        av_dlog(NULL, \"%X %X %X %X\\n\", (*buf)[0], (*buf)[1],(*buf)[2],(*buf)[3]);\n    }\n    return 0;\n}", "target": 1}
{"code": "char *reds_get_video_codec_fullname(RedVideoCodec *codec)\n{\n    int i;\n    const char *encoder_name = NULL;\n    const char *codec_name = get_index_name(video_codec_names, codec->type);\n    spice_assert(codec_name);\n    for (i = 0; i < G_N_ELEMENTS(video_encoder_procs); i++) {\n        if (video_encoder_procs[i] == codec->create) {\n            encoder_name = get_index_name(video_encoder_names, i);\n            break;\n        }\n    }\n    spice_assert(encoder_name);\n    return g_strdup_printf(\"%s:%s\", encoder_name, codec_name);\n}", "target": 0}
{"code": "void test_open(const char *path)\n{\n\tint fd = open(path, O_RDONLY);\n\tif (fd >= 0) {\n\t\tfprintf(stderr, \"leak at open of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at open of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int restrictedFile(const char *filename)\n{\n\tif (!live_dangerously && !strncasecmp(filename, \"/\", 1) &&\n\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "xfs_iget_check_free_state(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\tflags)\n{\n\tif (flags & XFS_IGET_CREATE) {\n\t\tif (VFS_I(ip)->i_mode != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx not marked free! (mode 0x%x)\",\n\t\t\t\tip->i_ino, VFS_I(ip)->i_mode);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\tif (ip->i_d.di_nblocks != 0) {\n\t\t\txfs_warn(ip->i_mount,\n\"Corruption detected! Free inode 0x%llx has blocks allocated!\",\n\t\t\t\tip->i_ino);\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (VFS_I(ip)->i_mode == 0)\n\t\treturn -ENOENT;\n\treturn 0;\n}", "target": 0}
{"code": "processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}", "target": 1}
{"code": "static ssize_t o2nm_node_local_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\ttmp = !!tmp; \n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\treturn count;\n}", "target": 1}
{"code": "file_transfer_t *imcb_file_send_start(struct im_connection *ic, char *handle, char *file_name, size_t file_size)\n{\n\tbee_t *bee = ic->bee;\n\tbee_user_t *bu = bee_user_by_handle(bee, ic, handle);\n\tif (bee->ui->ft_in_start) {\n\t\treturn bee->ui->ft_in_start(bee, bu, file_name, file_size);\n\t} else {\n\t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "void NetworkScreen::OnHelpLinkActivated() {\n  ClearErrors();\n  if (!help_app_.get())\n    help_app_.reset(new HelpAppLauncher(view()->GetNativeWindow()));\n  help_app_->ShowHelpTopic(HelpAppLauncher::HELP_CONNECTIVITY);\n}", "target": 0}
{"code": "    virtual void visit(const messages::result_message::prepared::cql& m) override {\n        _response.write_int(0x0004);\n        _response.write_short_bytes(m.get_id());\n        _response.write(m.metadata(), _version);\n        if (_version > 1) {\n            _response.write(*m.result_metadata());\n        }\n    }", "target": 0}
{"code": "ExprCreateFloat(void)\n{\n    EXPR_CREATE(ExprFloat, expr, EXPR_VALUE, EXPR_TYPE_FLOAT);\n    return expr;\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageGifCtx(im, out);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "static const uint8_t *get_signature(const uint8_t *asn1_sig, int *len)\n{\n    int offset = 0;\n    const uint8_t *ptr = NULL;\n    if (asn1_next_obj(asn1_sig, &offset, ASN1_SEQUENCE) < 0 || \n            asn1_skip_obj(asn1_sig, &offset, ASN1_SEQUENCE))\n        goto end_get_sig;\n    if (asn1_sig[offset++] != ASN1_OCTET_STRING)\n        goto end_get_sig;\n    *len = get_asn1_length(asn1_sig, &offset);\n    ptr = &asn1_sig[offset];          \nend_get_sig:\n    return ptr;\n}", "target": 1}
{"code": "static void run(int argc, const char *const argv[],\n        const char *name, void (*init)(const char * const argv[]))\n{\n    int rv;\n    bool user_config;\n    const char *argv_out[argc+4], *new_argv[argc+4];\n    int argc_out;\n    char conf_file[OGS_MAX_FILEPATH_LEN];\n    user_config = false;\n    for (argc_out = 0; argc_out < argc; argc_out++) {\n        if (strcmp(\"-c\", argv[argc_out]) == 0) {\n            user_config = true; \n        }\n        argv_out[argc_out] = argv[argc_out];\n    }\n    argv_out[argc_out] = NULL;\n    if (!user_config) {\n        ogs_snprintf(conf_file, sizeof conf_file, \"%s%s\",\n            MESON_BUILD_ROOT OGS_DIR_SEPARATOR_S\n            \"configs\" OGS_DIR_SEPARATOR_S, name);\n        argv_out[argc_out++] = \"-c\";\n        argv_out[argc_out++] = conf_file;\n        argv_out[argc_out] = NULL;\n    }\n    argv_out[0] = MESON_BUILD_ROOT OGS_DIR_SEPARATOR_S \n            \"src\" OGS_DIR_SEPARATOR_S \"open5gs-main\";\n    rv = abts_main(argc_out, argv_out, new_argv);\n    ogs_assert(rv == OGS_OK);\n    (*init)(new_argv);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& sizes = context->input(1);\n    OP_REQUIRES(\n        context,\n        (TensorShapeUtils::IsVector(sizes.shape()) ||\n         TensorShapeUtils::IsScalar(sizes.shape())),\n        errors::InvalidArgument(\"sizes input must be 1-D, not \",\n                                sizes.shape().DebugString()));\n    OP_REQUIRES(\n        context, sizes.NumElements() < TensorShape::MaxDimensions(),\n        errors::InvalidArgument(\"too many dimensions: must be < \",\n                                TensorShape::MaxDimensions(), \", but received \",\n                                sizes.NumElements()));\n    TensorShape shape;\n    int64_t product = 1;\n    int unknown_index = -1;\n    bool sizes_has_zero_dim;\n    switch (sizes.dtype()) {\n      case DT_INT32:\n        OP_REQUIRES_OK(context,\n                       ValidateSizes<int32>(sizes, &product, &unknown_index,\n                                            &shape, &sizes_has_zero_dim));\n        break;\n      case DT_INT64:\n        OP_REQUIRES_OK(context,\n                       ValidateSizes<int64_t>(sizes, &product, &unknown_index,\n                                              &shape, &sizes_has_zero_dim));\n        break;\n      default:\n        context->CtxFailure(errors::InvalidArgument(\n            \"desired shape must be a DT_INT32 or DT_INT64 vector, not a \",\n            DataTypeString(sizes.dtype())));\n        return;\n    }\n    if (unknown_index != -1) {\n      int64_t input_num_elements = 1;\n      bool input_has_zero_dim = false;\n      for (int dim = 0; dim < input.dims(); dim++) {\n        if (input.dim_size(dim) > 0 || !sizes_has_zero_dim) {\n          input_num_elements *= input.dim_size(dim);\n        } else {\n          input_has_zero_dim = true;\n        }\n      }\n      const int64_t missing = input_num_elements / product;\n      if (!input_has_zero_dim) {\n        OP_REQUIRES(\n            context, product * missing == input_num_elements,\n            errors::InvalidArgument(\n                \"Input to reshape is a tensor with \", input_num_elements,\n                \" values, but the requested shape requires a multiple of \",\n                product));\n      }\n      shape.set_dim(unknown_index, missing);\n    }\n    OP_REQUIRES(context, shape.num_elements() == input.NumElements(),\n                errors::InvalidArgument(\"Input to reshape is a tensor with \",\n                                        input.NumElements(),\n                                        \" values, but the requested shape has \",\n                                        shape.num_elements()));\n    Tensor output(input.dtype());\n    CHECK(output.CopyFrom(input, shape));\n    context->set_output(0, output);\n  }", "target": 0}
{"code": "void ImplPolygon::ImplSplit( sal_uInt16 nPos, sal_uInt16 nSpace, ImplPolygon const * pInitPoly )\n{\n    if (mnPoints + nSpace > USHRT_MAX)\n        return;\n    const sal_uInt16    nNewSize = mnPoints + nSpace;\n    const std::size_t   nSpaceSize = static_cast<std::size_t>(nSpace) * sizeof(Point);\n    if( nPos >= mnPoints )\n    {\n        nPos = mnPoints;\n        ImplSetSize( nNewSize );\n        if( pInitPoly )\n        {\n            memcpy( mpPointAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n            if( pInitPoly->mpFlagAry )\n                memcpy( mpFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n        }\n    }\n    else\n    {\n        const sal_uInt16    nSecPos = nPos + nSpace;\n        const sal_uInt16    nRest = mnPoints - nPos;\n        Point* pNewAry = reinterpret_cast<Point*>(new char[ static_cast<std::size_t>(nNewSize) * sizeof(Point) ]);\n        memcpy( pNewAry, mpPointAry, nPos * sizeof( Point ) );\n        if( pInitPoly )\n            memcpy( pNewAry + nPos, pInitPoly->mpPointAry, nSpaceSize );\n        else\n            memset( pNewAry + nPos, 0, nSpaceSize );\n        memcpy( pNewAry + nSecPos, mpPointAry + nPos, nRest * sizeof( Point ) );\n        delete[] reinterpret_cast<char*>(mpPointAry);\n        if( mpFlagAry )\n        {\n            PolyFlags* pNewFlagAry = new PolyFlags[ nNewSize ];\n            memcpy( pNewFlagAry, mpFlagAry, nPos );\n            if( pInitPoly && pInitPoly->mpFlagAry )\n                memcpy( pNewFlagAry + nPos, pInitPoly->mpFlagAry, nSpace );\n            else\n                memset( pNewFlagAry + nPos, 0, nSpace );\n            memcpy( pNewFlagAry + nSecPos, mpFlagAry + nPos, nRest );\n            delete[] mpFlagAry;\n            mpFlagAry = pNewFlagAry;\n        }\n        mpPointAry = pNewAry;\n        mnPoints   = nNewSize;\n    }\n}", "target": 1}
{"code": "bool __fastcall TSiteRawDialog::Execute(TSessionData * Data)\n{\n  std::unique_ptr<TSessionData> FactoryDefaults(new TSessionData(L\"\"));\n  std::unique_ptr<TSessionData> RawData(new TSessionData(L\"\"));\n  RawData->Assign(Data);\n  if (RawData->FSProtocol != fsSFTPonly)\n  {\n    RawData->FSProtocol = FactoryDefaults->FSProtocol;\n  }\n  RawData->HostName = FactoryDefaults->HostName;\n  RawData->PortNumber = FactoryDefaults->PortNumber;\n  RawData->UserName = FactoryDefaults->UserName;\n  RawData->Password = FactoryDefaults->Password;\n  RawData->Ftps = FactoryDefaults->Ftps;\n  std::unique_ptr<TStrings> Options(RawData->SaveToOptions(FactoryDefaults.get(), false, false));\n  SettingsMemo->Lines = Options.get();\n  bool Result = TCustomDialog::Execute();\n  if (Result)\n  {\n    std::unique_ptr<TSessionData> BackupData(new TSessionData(L\"\"));\n    BackupData->Assign(Data);\n    Data->DefaultSettings();\n    Data->FSProtocol = BackupData->FSProtocol;\n    Data->HostName = BackupData->HostName;\n    Data->PortNumber = BackupData->PortNumber;\n    Data->UserName = BackupData->UserName;\n    Data->Password = BackupData->Password;\n    Data->Ftps = BackupData->Ftps;\n    Data->ApplyRawSettings(SettingsMemo->Lines);\n  }\n  return Result;\n}", "target": 1}
{"code": "void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  if (MinCapacity > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  size_t NewCapacity = 2 * capacity() + 1; \n  NewCapacity =\n      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n    memcpy(NewElts, this->BeginX, size() * TSize);\n  } else {\n    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);\n  }\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}", "target": 1}
{"code": "static inline void init_keys(at91_aes_key_size_t *key_size,\n\t\t\t     unsigned int *cipher_key,\n\t\t\t     unsigned int *cmac_key,\n\t\t\t     unsigned int *iv)\n{\n#if defined(CONFIG_AES_KEY_SIZE_128)\n\t*key_size = AT91_AES_KEY_SIZE_128;\n#elif defined(CONFIG_AES_KEY_SIZE_192)\n\t*key_size = AT91_AES_KEY_SIZE_192;\n#elif defined(CONFIG_AES_KEY_SIZE_256)\n\t*key_size = AT91_AES_KEY_SIZE_256;\n#else\n#error \"bad AES key size\"\n#endif\n\tiv[0]\t\t= CONFIG_AES_IV_WORD0;\n\tiv[1]\t\t= CONFIG_AES_IV_WORD1;\n\tiv[2]\t\t= CONFIG_AES_IV_WORD2;\n\tiv[3]\t\t= CONFIG_AES_IV_WORD3;\n\tcipher_key[0]\t= CONFIG_AES_CIPHER_KEY_WORD0;\n\tcmac_key[0]\t= CONFIG_AES_CMAC_KEY_WORD0;\n\tcipher_key[1]\t= CONFIG_AES_CIPHER_KEY_WORD1;\n\tcmac_key[1]\t= CONFIG_AES_CMAC_KEY_WORD1;\n\tcipher_key[2]\t= CONFIG_AES_CIPHER_KEY_WORD2;\n\tcmac_key[2]\t= CONFIG_AES_CMAC_KEY_WORD2;\n\tcipher_key[3]\t= CONFIG_AES_CIPHER_KEY_WORD3;\n\tcmac_key[3]\t= CONFIG_AES_CMAC_KEY_WORD3;\n#if defined(CONFIG_AES_KEY_SIZE_192) || defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[4]\t= CONFIG_AES_CIPHER_KEY_WORD4;\n\tcmac_key[4]\t= CONFIG_AES_CMAC_KEY_WORD4;\n\tcipher_key[5]\t= CONFIG_AES_CIPHER_KEY_WORD5;\n\tcmac_key[5]\t= CONFIG_AES_CMAC_KEY_WORD5;\n#endif\n#if defined(CONFIG_AES_KEY_SIZE_256)\n\tcipher_key[6]\t= CONFIG_AES_CIPHER_KEY_WORD6;\n\tcmac_key[6]\t= CONFIG_AES_CMAC_KEY_WORD6;\n\tcipher_key[7]\t= CONFIG_AES_CIPHER_KEY_WORD7;\n\tcmac_key[7]\t= CONFIG_AES_CMAC_KEY_WORD7;\n#endif\n}", "target": 1}
{"code": "static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint opts;\n\tResub m;\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\tjs_pushboolean(J, 0);\n}", "target": 1}
{"code": "l2tp_bearer_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_TYPE_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}", "target": 1}
{"code": "get_number(int *numptr, int low, const char *names[], int ch, FILE *file,\n    const char *terms) {\n\tchar temp[MAX_TEMPSTR], *pc;\n\tint len, i;\n\tpc = temp;\n\tlen = 0;\n\twhile (isdigit((unsigned char)ch)) {\n\t\tif (++len >= MAX_TEMPSTR)\n\t\t\tgoto bad;\n\t\t*pc++ = ch;\n\t\tch = get_char(file);\n\t}\n\t*pc = '\\0';\n\tif (len != 0) {\n\t\tif (!strchr(terms, ch))\n\t\t\tgoto bad;\n\t\t*numptr = atoi(temp);\n\t\treturn (ch);\n\t}\n\tif (names) {\n\t\twhile (isalpha((unsigned char)ch)) {\n\t\t\tif (++len >= MAX_TEMPSTR)\n\t\t\t\tgoto bad;\n\t\t\t*pc++ = ch;\n\t\t\tch = get_char(file);\n\t\t}\n\t\t*pc = '\\0';\n\t\tif (len != 0 && strchr(terms, ch)) {\n\t\t\tfor (i = 0;  names[i] != NULL;  i++) {\n\t\t\t\tDebug(DPARS|DEXT,\n\t\t\t\t\t(\"get_num, compare(%s,%s)\\n\", names[i],\n\t\t\t\t\ttemp))\n\t\t\t\tif (!strcasecmp(names[i], temp)) {\n\t\t\t\t\t*numptr = i+low;\n\t\t\t\t\treturn (ch);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nbad:\n\tunget_char(ch, file);\n\treturn (EOF);\n}", "target": 1}
{"code": "snmp_api_set_time_ticks(snmp_varbind_t *varbind, uint32_t *oid, uint32_t integer)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = SNMP_DATA_TYPE_TIME_TICKS;\n  varbind->value.integer = integer;\n}", "target": 1}
{"code": "int hashtable_set(hashtable_t *hashtable,\n                  const char *key, size_t serial,\n                  json_t *value)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t hash, index;\n    if(hashtable->size >= num_buckets(hashtable))\n        if(hashtable_do_rehash(hashtable))\n            return -1;\n    hash = hash_str(key);\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(pair)\n    {\n        json_decref(pair->value);\n        pair->value = value;\n    }\n    else\n    {\n        pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);\n        if(!pair)\n            return -1;\n        pair->hash = hash;\n        pair->serial = serial;\n        strcpy(pair->key, key);\n        pair->value = value;\n        list_init(&pair->list);\n        insert_to_bucket(hashtable, bucket, &pair->list);\n        hashtable->size++;\n    }\n    return 0;\n}", "target": 1}
{"code": "inline bool SegmentReader::amplifiedRead(WordCount virtualAmount) {\n  return readLimiter->canRead(virtualAmount, arena);\n}", "target": 0}
{"code": "ptr_str_array_compare (const gchar **a,\n                       const gchar **b)\n{\n  return g_strcmp0 (*a, *b);\n}", "target": 0}
{"code": "static int _nfs4_do_open_reclaim(struct nfs_open_context *ctx, struct nfs4_state *state)\n{\n\tstruct nfs_delegation *delegation;\n\tstruct nfs4_opendata *opendata;\n\tint delegation_type = 0;\n\tint status;\n\topendata = nfs4_open_recoverdata_alloc(ctx, state);\n\tif (IS_ERR(opendata))\n\t\treturn PTR_ERR(opendata);\n\topendata->o_arg.claim = NFS4_OPEN_CLAIM_PREVIOUS;\n\topendata->o_arg.fh = NFS_FH(state->inode);\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(state->inode)->delegation);\n\tif (delegation != NULL && test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) != 0)\n\t\tdelegation_type = delegation->type;\n\trcu_read_unlock();\n\topendata->o_arg.u.delegation_type = delegation_type;\n\tstatus = nfs4_open_recover(opendata, state);\n\tnfs4_opendata_put(opendata);\n\treturn status;\n}", "target": 1}
{"code": "int drm_mode_dirtyfb_ioctl(struct drm_device *dev,\n\t\t\t   void *data, struct drm_file *file_priv)\n{\n\tstruct drm_clip_rect __user *clips_ptr;\n\tstruct drm_clip_rect *clips = NULL;\n\tstruct drm_mode_fb_dirty_cmd *r = data;\n\tstruct drm_mode_object *obj;\n\tstruct drm_framebuffer *fb;\n\tunsigned flags;\n\tint num_clips;\n\tint ret = 0;\n\tif (!drm_core_check_feature(dev, DRIVER_MODESET))\n\t\treturn -EINVAL;\n\tmutex_lock(&dev->mode_config.mutex);\n\tobj = drm_mode_object_find(dev, r->fb_id, DRM_MODE_OBJECT_FB);\n\tif (!obj) {\n\t\tDRM_ERROR(\"invalid framebuffer id\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tfb = obj_to_fb(obj);\n\tnum_clips = r->num_clips;\n\tclips_ptr = (struct drm_clip_rect *)(unsigned long)r->clips_ptr;\n\tif (!num_clips != !clips_ptr) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tflags = DRM_MODE_FB_DIRTY_FLAGS & r->flags;\n\tif (flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && (num_clips % 2)) {\n\t\tret = -EINVAL;\n\t\tgoto out_err1;\n\t}\n\tif (num_clips && clips_ptr) {\n\t\tif (num_clips < 0 || num_clips > DRM_MODE_FB_DIRTY_MAX_CLIPS) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tclips = kzalloc(num_clips * sizeof(*clips), GFP_KERNEL);\n\t\tif (!clips) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_err1;\n\t\t}\n\t\tret = copy_from_user(clips, clips_ptr,\n\t\t\t\t     num_clips * sizeof(*clips));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out_err2;\n\t\t}\n\t}\n\tif (fb->funcs->dirty) {\n\t\tret = fb->funcs->dirty(fb, file_priv, flags, r->color,\n\t\t\t\t       clips, num_clips);\n\t} else {\n\t\tret = -ENOSYS;\n\t\tgoto out_err2;\n\t}\nout_err2:\n\tkfree(clips);\nout_err1:\n\tmutex_unlock(&dev->mode_config.mutex);\n\treturn ret;\n}", "target": 0}
{"code": "void nfs4_close_sync(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 1);\n}", "target": 1}
{"code": "AtomicString SrcSchemeToURL(TestURLScheme scheme) {\n  switch (scheme) {\n    case TestURLScheme::kHttp:\n      return \"http:\n    case TestURLScheme::kHttps:\n      return \"https:\n    case TestURLScheme::kFtp:\n      return \"ftp:\n    case TestURLScheme::kFile:\n      return \"file:\n    case TestURLScheme::kData:\n      return \"data:video/mp4;base64,XXXXXXX\";\n    case TestURLScheme::kBlob:\n      return \"blob:http:\n    default:\n      NOTREACHED();\n  }\n  return g_empty_atom;\n}", "target": 0}
{"code": "GF_EXPORT\nvoid gf_isom_reset_sample_count(GF_ISOFile *movie)\n{\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie) return;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox*)gf_list_get(movie->moov->trackList, i);\n\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n\t\ttrak->sample_count_at_seg_start = 0;\n\t}\n\tmovie->NextMoofNumber = 0;\n#endif", "target": 0}
{"code": "disconnect_ice_connection (IceConn ice_conn)\n{\n        IceSetShutdownNegotiation (ice_conn, FALSE);\n        IceCloseConnection (ice_conn);\n}", "target": 0}
{"code": "void is888Tests()\n{\n    printf(\"Simple format detection:\\n\\n\");\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 0, 8, 16);\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 24, 16, 8);\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 24, 8, 0);\n    do888Test(false, 32, 16, false, true, 15, 31, 15, 0, 8, 16);\n    do888Test(false, 32, 8, false, true, 3, 7, 3, 0, 8, 16);\n    do888Test(false, 16, 16, false, true, 15, 31, 15, 0, 5, 11);\n    do888Test(false, 8, 8, false, true, 3, 7, 3, 0, 2, 5);\n    do888Test(false, 8, 8, false, false, 0, 0, 0, 0, 0, 0);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 0, 8, 18);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 0, 11, 24);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 4, 16, 24);\n    printf(\"\\n\");\n}", "target": 0}
{"code": "void mobi_buffer_move(MOBIBuffer *buf, const int offset, const size_t len) {\n    size_t aoffset = (size_t) abs(offset);\n    unsigned char *source = buf->data + buf->offset;\n    if (offset >= 0) {\n        if (buf->offset + aoffset + len > buf->maxlen) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source += aoffset;\n    } else {\n        if (buf->offset < aoffset) {\n            debug_print(\"%s\", \"End of buffer\\n\");\n            buf->error = MOBI_BUFFER_END;\n            return;\n        }\n        source -= aoffset;\n    }\n    memmove(buf->data + buf->offset, source, len);\n    buf->offset += len;\n}", "target": 1}
{"code": "int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tint err;\n\tu32 tsk_portid = cb->args[0];\n\tu32 last_publ = cb->args[1];\n\tu32 done = cb->args[2];\n\tstruct net *net = sock_net(skb->sk);\n\tstruct tipc_sock *tsk;\n\tif (!tsk_portid) {\n\t\tstruct nlattr **attrs;\n\t\tstruct nlattr *sock[TIPC_NLA_SOCK_MAX + 1];\n\t\terr = tipc_nlmsg_parse(cb->nlh, &attrs);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!attrs[TIPC_NLA_SOCK])\n\t\t\treturn -EINVAL;\n\t\terr = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX,\n\t\t\t\t       attrs[TIPC_NLA_SOCK],\n\t\t\t\t       tipc_nl_sock_policy);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (!sock[TIPC_NLA_SOCK_REF])\n\t\t\treturn -EINVAL;\n\t\ttsk_portid = nla_get_u32(sock[TIPC_NLA_SOCK_REF]);\n\t}\n\tif (done)\n\t\treturn 0;\n\ttsk = tipc_sk_lookup(net, tsk_portid);\n\tif (!tsk)\n\t\treturn -EINVAL;\n\tlock_sock(&tsk->sk);\n\terr = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);\n\tif (!err)\n\t\tdone = 1;\n\trelease_sock(&tsk->sk);\n\tsock_put(&tsk->sk);\n\tcb->args[0] = tsk_portid;\n\tcb->args[1] = last_publ;\n\tcb->args[2] = done;\n\treturn skb->len;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  auto* params = reinterpret_cast<TfLiteL2NormParams*>(node->builtin_data);\n  L2NormalizationParams* data =\n      static_cast<L2NormalizationParams*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE(context, NumDimensions(input) <= 4);\n  TF_LITE_ENSURE(context, output->type == kTfLiteFloat32 ||\n                              output->type == kTfLiteUInt8 ||\n                              output->type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (output->type == kTfLiteUInt8 || output->type == kTfLiteInt8) {\n    data->input_zero_point = input->params.zero_point;\n  } else if (output->type == kTfLiteFloat32) {\n    data->input_zero_point = 0;\n  }\n  TF_LITE_ENSURE_EQ(context, params->activation, kTfLiteActNone);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  \n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  \n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  \n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else\n      return NULL;  \n  }\n  if (pos)\n    *pos = base + (n - 1);\n  return name;\n}", "target": 1}
{"code": "static void Sp_match(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint len;\n\tconst char *a, *b, *c, *e;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\tre = js_toregexp(J, -1);\n\tif (!(re->flags & JS_REGEXP_G)) {\n\t\tjs_RegExp_prototype_exec(J, re, text);\n\t\treturn;\n\t}\n\tre->last = 0;\n\tjs_newarray(J);\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\t\ta = c;\n\t\tif (c - b == 0)\n\t\t\t++a;\n\t}\n\tif (len == 0) {\n\t\tjs_pop(J, 1);\n\t\tjs_pushnull(J);\n\t}\n}", "target": 1}
{"code": "new_unencoding_writer(struct Curl_easy *data,\n                      const struct content_encoding *handler,\n                      struct contenc_writer *downstream)\n{\n  size_t sz = offsetof(struct contenc_writer, params) + handler->paramsize;\n  struct contenc_writer *writer = (struct contenc_writer *)calloc(1, sz);\n  if(writer) {\n    writer->handler = handler;\n    writer->downstream = downstream;\n    if(handler->init_writer(data, writer)) {\n      free(writer);\n      writer = NULL;\n    }\n  }\n  return writer;\n}", "target": 0}
{"code": "le64addr_string(netdissect_options *ndo, const u_char *ep)\n{\n\tconst unsigned int len = 8;\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tchar buf[BUFSIZE];\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\tcp = buf;\n\tfor (i = len; i > 0 ; --i) {\n\t\t*cp++ = hex[*(ep + i - 1) >> 4];\n\t\t*cp++ = hex[*(ep + i - 1) & 0xf];\n\t\t*cp++ = ':';\n\t}\n\tcp --;\n\t*cp = '\\0';\n\ttp->e_name = strdup(buf);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"le64addr_string: strdup(buf)\");\n\treturn (tp->e_name);\n}", "target": 1}
{"code": "xmlValidCtxtPtr xmlNewValidCtxt(void) {\n    xmlValidCtxtPtr ret;\n    if ((ret = xmlMalloc(sizeof (xmlValidCtxt))) == NULL) {\n\txmlVErrMemory(NULL, \"malloc failed\");\n\treturn (NULL);\n    }\n    (void) memset(ret, 0, sizeof (xmlValidCtxt));\n    return (ret);\n}", "target": 0}
{"code": "void HTMLMediaElement::AudioTracksTimerFired(TimerBase*) {\n  Vector<WebMediaPlayer::TrackId> enabled_track_ids;\n  for (unsigned i = 0; i < audioTracks().length(); ++i) {\n    AudioTrack* track = audioTracks().AnonymousIndexedGetter(i);\n    if (track->enabled())\n      enabled_track_ids.push_back(track->id());\n  }\n  GetWebMediaPlayer()->EnabledAudioTracksChanged(enabled_track_ids);\n}", "target": 0}
{"code": "static CURLUcode hostname_check(struct Curl_URL *u, char *hostname)\n{\n  size_t len;\n  size_t hlen = strlen(hostname);\n  if(hostname[0] == '[') {\n    const char *l = \"0123456789abcdefABCDEF:.\";\n    if(hlen < 4) \n      return CURLUE_BAD_IPV6;\n    hostname++;\n    hlen -= 2;\n    if(hostname[hlen] != ']')\n      return CURLUE_BAD_IPV6;\n    len = strspn(hostname, l);\n    if(hlen != len) {\n      hlen = len;\n      if(hostname[len] == '%') {\n        char zoneid[16];\n        int i = 0;\n        char *h = &hostname[len + 1];\n        if(!strncmp(h, \"25\", 2) && h[2] && (h[2] != ']'))\n          h += 2;\n        while(*h && (*h != ']') && (i < 15))\n          zoneid[i++] = *h++;\n        if(!i || (']' != *h))\n          return CURLUE_MALFORMED_INPUT;\n        zoneid[i] = 0;\n        u->zoneid = strdup(zoneid);\n        if(!u->zoneid)\n          return CURLUE_OUT_OF_MEMORY;\n        hostname[len] = ']'; \n        hostname[len + 1] = 0; \n      }\n      else\n        return CURLUE_BAD_IPV6;\n    }\n#ifdef ENABLE_IPV6\n    {\n      char dest[16]; \n      char norm[MAX_IPADR_LEN];\n      hostname[hlen] = 0; \n      if(1 != Curl_inet_pton(AF_INET6, hostname, dest))\n        return CURLUE_BAD_IPV6;\n      if(Curl_inet_ntop(AF_INET6, dest, norm, sizeof(norm)) &&\n         (strlen(norm) < hlen)) {\n        strcpy(hostname, norm);\n        hlen = strlen(norm);\n        hostname[hlen + 1] = 0;\n      }\n      hostname[hlen] = ']'; \n    }\n#endif\n  }\n  else {\n    len = strcspn(hostname, \" \\r\\n\\t/:#?!@\");\n    if(hlen != len)\n      return CURLUE_BAD_HOSTNAME;\n  }\n  if(!hostname[0])\n    return CURLUE_NO_HOST;\n  return CURLUE_OK;\n}", "target": 0}
{"code": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "void streamGetEdgeID(stream *s, int first, int skip_tombstones, streamID *edge_id)\n{\n    streamIterator si;\n    int64_t numfields;\n    streamIteratorStart(&si,s,NULL,NULL,!first);\n    si.skip_tombstones = skip_tombstones;\n    int found = streamIteratorGetID(&si,edge_id,&numfields);\n    if (!found) {\n        streamID min_id = {0, 0}, max_id = {UINT64_MAX, UINT64_MAX};\n        *edge_id = first ? max_id : min_id;\n    }\n}", "target": 1}
{"code": "unsigned long OPENSSL_LH_get_down_load(const OPENSSL_LHASH *lh)\n{\n    return lh->down_load;\n}", "target": 0}
{"code": "static void do_change_user(FILE *fin, FILE *fout) {\n  char uname[BUFFER_SIZE];\n  read_buf(fin, uname);\n  if (strlen(uname) > 0) {\n    struct passwd *pw = getpwnam(uname);\n    if (pw) {\n      if (pw->pw_gid) {\n        setgid(pw->pw_gid);\n      }\n      if (pw->pw_uid) {\n        setuid(pw->pw_uid);\n      }\n    }\n  }\n}", "target": 1}
{"code": "fbFetch_r8g8b8 (const FbBits *bits, int x, int width, CARD32 *buffer, miIndexedPtr indexed)\n{\n    const CARD8 *pixel = (const CARD8 *)bits + 3*x;\n    const CARD8 *end = pixel + 3*width;\n    while (pixel < end) {\n        CARD32 b = Fetch24(pixel) | 0xff000000;\n        pixel += 3;\n        WRITE(buffer++, b);\n    }\n}", "target": 0}
{"code": "MONGO_EXPORT void *bson_malloc( int size ) {\n    void *p;\n    p = bson_malloc_func( size );\n    bson_fatal_msg( !!p, \"malloc() failed\" );\n    return p;\n}", "target": 1}
{"code": "    const char* Image::typeName(uint16_t tag) const\n    {\n        const char* result = nullptr;\n        switch (tag ) {\n            case Exiv2::unsignedByte     : result = \"BYTE\"      ; break;\n            case Exiv2::asciiString      : result = \"ASCII\"     ; break;\n            case Exiv2::unsignedShort    : result = \"SHORT\"     ; break;\n            case Exiv2::unsignedLong     : result = \"LONG\"      ; break;\n            case Exiv2::unsignedRational : result = \"RATIONAL\"  ; break;\n            case Exiv2::signedByte       : result = \"SBYTE\"     ; break;\n            case Exiv2::undefined        : result = \"UNDEFINED\" ; break;\n            case Exiv2::signedShort      : result = \"SSHORT\"    ; break;\n            case Exiv2::signedLong       : result = \"SLONG\"     ; break;\n            case Exiv2::signedRational   : result = \"SRATIONAL\" ; break;\n            case Exiv2::tiffFloat        : result = \"FLOAT\"     ; break;\n            case Exiv2::tiffDouble       : result = \"DOUBLE\"    ; break;\n            case Exiv2::tiffIfd          : result = \"IFD\"       ; break;\n            default                      : result = \"unknown\"   ; break;\n        }\n        return result;\n    }", "target": 0}
{"code": "void poly_frommsg(poly *r, const uint8_t msg[KYBER_INDCPA_MSGBYTES])\n{\n  unsigned int i,j;\n  int16_t mask;\n#if (KYBER_INDCPA_MSGBYTES != KYBER_N/8)\n#error \"KYBER_INDCPA_MSGBYTES must be equal to KYBER_N/8 bytes!\"\n#endif\n  for(i=0;i<KYBER_N/8;i++) {\n    for(j=0;j<8;j++) {\n      mask = -(int16_t)((msg[i] >> j)&1);\n      r->coeffs[8*i+j] = mask & ((KYBER_Q+1)/2);\n    }\n  }\n}", "target": 1}
{"code": "static SQLRETURN qt_string_SQLSetConnectAttr(SQLHDBC handle, SQLINTEGER attr, const QString &val)\n{\n    auto encoded = toSQLTCHAR(val);\n    return SQLSetConnectAttr(handle, attr,\n                             encoded.data(),\n                             SQLINTEGER(encoded.size() * sizeof(SQLTCHAR))); \n}", "target": 0}
{"code": "  explicit ReverseSequenceOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"batch_dim\", &batch_dim_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seq_dim\", &seq_dim_));\n    OP_REQUIRES(context, batch_dim_ >= 0,\n                errors::InvalidArgument(\"Invalid batch_dim \", batch_dim_));\n    OP_REQUIRES(context, seq_dim_ >= 0,\n                errors::InvalidArgument(\"Invalid seq_dim \", seq_dim_));\n  }", "target": 0}
{"code": "static void cil_reset_perm(struct cil_perm *perm)\n{\n\tcil_reset_classperms_list(perm->classperms);\n}", "target": 1}
{"code": "int nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx, u8 mode)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s target_idx=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->active_target->idx != target_idx) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\tif (dev->ops->check_presence)\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\tdev->ops->deactivate_target(dev, dev->active_target, mode);\n\tdev->active_target = NULL;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static void accumulate_steal_time(struct kvm_vcpu *vcpu)\n{\n\tu64 delta;\n\tif (!(vcpu->arch.st.msr_val & KVM_MSR_ENABLED))\n\t\treturn;\n\tdelta = current->sched_info.run_delay - vcpu->arch.st.last_steal;\n\tvcpu->arch.st.last_steal = current->sched_info.run_delay;\n\tvcpu->arch.st.accum_steal = delta;\n}", "target": 0}
{"code": "void CxImage::Startup(uint32_t imagetype)\n{\n\tpDib = pSelection = pAlpha = NULL;\n\tppLayers = ppFrames = NULL;\n\tmemset(&head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&info,0,sizeof(CXIMAGEINFO));\n    info.dwType = imagetype;\n\tinfo.fQuality = 90.0f;\n\tinfo.nAlphaMax = 255;\n\tinfo.nBkgndIndex = -1;\n\tinfo.bEnabled = true;\n\tinfo.nJpegScale = 1;\n\tSetXDPI(CXIMAGE_DEFAULT_DPI);\n\tSetYDPI(CXIMAGE_DEFAULT_DPI);\n\tint16_t test = 1;\n\tinfo.bLittleEndianHost = (*((char *) &test) == 1);\n}", "target": 1}
{"code": "void CreateWindowForRequest(const FrameLoadRequest& request,\n                            LocalFrame& opener_frame,\n                            NavigationPolicy policy) {\n  DCHECK(request.GetResourceRequest().RequestorOrigin() ||\n         (opener_frame.GetDocument() &&\n          opener_frame.GetDocument()->Url().IsEmpty()));\n  if (opener_frame.GetDocument()->PageDismissalEventBeingDispatched() !=\n      Document::kNoDismissal)\n    return;\n  if (opener_frame.GetDocument() &&\n      opener_frame.GetDocument()->IsSandboxed(kSandboxPopups))\n    return;\n  if (policy == kNavigationPolicyCurrentTab)\n    policy = kNavigationPolicyNewForegroundTab;\n  WebWindowFeatures features;\n  features.noopener = request.GetShouldSetOpener() == kNeverSetOpener;\n  bool created;\n  Frame* new_frame =\n      CreateWindowHelper(opener_frame, opener_frame, opener_frame, request,\n                         features, policy, created);\n  if (!new_frame)\n    return;\n  if (request.GetShouldSendReferrer() == kMaybeSendReferrer) {\n    if (new_frame->IsLocalFrame())\n      ToLocalFrame(new_frame)->GetDocument()->SetReferrerPolicy(\n          opener_frame.GetDocument()->GetReferrerPolicy());\n  }\n  FrameLoadRequest new_request(0, request.GetResourceRequest());\n  new_request.SetForm(request.Form());\n  if (new_frame->IsLocalFrame())\n    ToLocalFrame(new_frame)->Loader().Load(new_request);\n}", "target": 0}
{"code": "void uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n{\n\tstruct rdma_umap_priv *priv, *next_priv;\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\twhile (1) {\n\t\tstruct mm_struct *mm = NULL;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\twhile (!list_empty(&ufile->umaps)) {\n\t\t\tint ret;\n\t\t\tpriv = list_first_entry(&ufile->umaps,\n\t\t\t\t\t\tstruct rdma_umap_priv, list);\n\t\t\tmm = priv->vma->vm_mm;\n\t\t\tret = mmget_not_zero(mm);\n\t\t\tif (!ret) {\n\t\t\t\tlist_del_init(&priv->list);\n\t\t\t\tmm = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tif (!mm)\n\t\t\treturn;\n\t\tdown_write(&mm->mmap_sem);\n\t\tif (!mmget_still_valid(mm))\n\t\t\tgoto skip_mm;\n\t\tmutex_lock(&ufile->umap_lock);\n\t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n\t\t\t\t\t  list) {\n\t\t\tstruct vm_area_struct *vma = priv->vma;\n\t\t\tif (vma->vm_mm != mm)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&priv->list);\n\t\t\tzap_vma_ptes(vma, vma->vm_start,\n\t\t\t\t     vma->vm_end - vma->vm_start);\n\t\t\tvma->vm_flags &= ~(VM_SHARED | VM_MAYSHARE);\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\tskip_mm:\n\t\tup_write(&mm->mmap_sem);\n\t\tmmput(mm);\n\t}\n}", "target": 0}
{"code": "uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val;\n    k->get_config(vdev, vdev->config);\n    if (addr > (vdev->config_len - sizeof(val)))\n        return (uint32_t)-1;\n    val = lduw_p(vdev->config + addr);\n    return val;\n}", "target": 1}
{"code": "parse_memory(VALUE klass, VALUE data, VALUE encoding)\n{\n  htmlParserCtxtPtr ctxt;\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n  ctxt = htmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                    (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n  if (RTEST(encoding)) {\n    xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler(StringValueCStr(encoding));\n    if (enc != NULL) {\n      xmlSwitchToEncoding(ctxt, enc);\n      if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n        rb_raise(rb_eRuntimeError, \"Unsupported encoding %s\",\n                 StringValueCStr(encoding));\n      }\n    }\n  }\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}", "target": 1}
{"code": "lib_contains_symbol(const char *path, const char *s)\n{\n\tstruct nlist nl[2];\n\tint ret = -1, r;\n\tmemset(nl, 0, sizeof(nl));\n\tnl[0].n_name = xstrdup(s);\n\tnl[1].n_name = NULL;\n\tif ((r = nlist(path, nl)) == -1) {\n\t\terror_f(\"nlist failed for %s\", path);\n\t\tgoto out;\n\t}\n\tif (r != 0 || nl[0].n_value == 0 || nl[0].n_type == 0) {\n\t\terror_f(\"library %s does not contain symbol %s\", path, s);\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\tfree(nl[0].n_name);\n\treturn ret;\n}", "target": 0}
{"code": "static int f2fs_set_data_page_dirty(struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\ttrace_f2fs_set_page_dirty(page, DATA);\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\tif (f2fs_is_atomic_file(inode) && !f2fs_is_commit_atomic_write(inode)) {\n\t\tif (!IS_ATOMIC_WRITTEN_PAGE(page)) {\n\t\t\tf2fs_register_inmem_page(inode, page);\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (!PageDirty(page)) {\n\t\t__set_page_dirty_nobuffers(page);\n\t\tf2fs_update_dirty_page(inode, page);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void *safe_calloc(size_t size) {\n  void *addr;\n  if (!size)\n  {\n    ERR(\"Invalid allocation size.\\n\");\n    exit(EXIT_FAILURE);\n  }\n  if (!(addr = calloc(1, size)))\n  {\n      ERR(\"Failed to allocate requested number of bytes, out of memory?\\n\");\n      exit(EXIT_FAILURE);\n  }\n  return addr;\n}", "target": 0}
{"code": "TfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.zero_point,\n                      std::numeric_limits<int8_t>::min());\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n    data->input_zero_point = input->params.zero_point;\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "dup_dest_constraints(const struct dest_constraint *dcs, size_t ndcs)\n{\n\tsize_t i;\n\tstruct dest_constraint *ret;\n\tif (ndcs == 0)\n\t\treturn NULL;\n\tret = xcalloc(ndcs, sizeof(*ret));\n\tfor (i = 0; i < ndcs; i++) {\n\t\tdup_dest_constraint_hop(&dcs[i].from, &ret[i].from);\n\t\tdup_dest_constraint_hop(&dcs[i].to, &ret[i].to);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "static void bdrv_cloop_init(void)\n{\n    bdrv_register(&bdrv_cloop);\n}", "target": 0}
{"code": "static inline Quantum ScaleLongLongToQuantum(const MagickSizeType value)\n{\n  return((Quantum) (value));\n}", "target": 0}
{"code": "static const char *virtualhost_section(cmd_parms *cmd, void *dummy,\n                                       const char *arg)\n{\n    server_rec *main_server = cmd->server, *s;\n    const char *errmsg;\n    const char *endp = ap_strrchr_c(arg, '>');\n    apr_pool_t *p = cmd->pool;\n    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);\n    if (err != NULL) {\n        return err;\n    }\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    arg = apr_pstrndup(cmd->temp_pool, arg, endp - arg);\n    if (!arg[0]) {\n        return missing_container_arg(cmd);\n    }\n    if (main_server->is_virtual) {\n        return \"<VirtualHost> doesn't nest!\";\n    }\n    errmsg = ap_init_virtual_host(p, arg, main_server, &s);\n    if (errmsg) {\n        return errmsg;\n    }\n    s->next = main_server->next;\n    main_server->next = s;\n    s->defn_name = cmd->directive->filename;\n    s->defn_line_number = cmd->directive->line_num;\n    cmd->server = s;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd,\n                            s->lookup_defaults);\n    cmd->server = main_server;\n    return errmsg;\n}", "target": 0}
{"code": "void Document::FinishedParsing() {\n  DCHECK(!GetScriptableDocumentParser() || !parser_->IsParsing());\n  DCHECK(!GetScriptableDocumentParser() || ready_state_ != kLoading);\n  SetParsingState(kInDOMContentLoaded);\n  DocumentParserTiming::From(*this).MarkParserStop();\n  if (!document_timing_.DomContentLoadedEventStart())\n    document_timing_.MarkDomContentLoadedEventStart();\n  DispatchEvent(Event::CreateBubble(EventTypeNames::DOMContentLoaded));\n  if (!document_timing_.DomContentLoadedEventEnd())\n    document_timing_.MarkDomContentLoadedEventEnd();\n  SetParsingState(kFinishedParsing);\n  Microtask::PerformCheckpoint(V8PerIsolateData::MainThreadIsolate());\n  ScriptableDocumentParser* parser = GetScriptableDocumentParser();\n  well_formed_ = parser && parser->WellFormed();\n  if (LocalFrame* frame = GetFrame()) {\n    const bool main_resource_was_already_requested =\n        frame->Loader().StateMachine()->CommittedFirstRealDocumentLoad();\n    if (main_resource_was_already_requested)\n      UpdateStyleAndLayoutTree();\n    BeginLifecycleUpdatesIfRenderingReady();\n    frame->Loader().FinishedParsing();\n    TRACE_EVENT_INSTANT1(\"devtools.timeline\", \"MarkDOMContent\",\n                         TRACE_EVENT_SCOPE_THREAD, \"data\",\n                         InspectorMarkLoadEvent::Data(frame));\n    probe::domContentLoadedEventFired(frame);\n    frame->GetIdlenessDetector()->DomContentLoadedEventFired();\n  }\n  element_data_cache_clear_timer_.StartOneShot(10, BLINK_FROM_HERE);\n  fetcher_->ClearPreloads(ResourceFetcher::kClearSpeculativeMarkupPreloads);\n  if (!frame_ || frame_->GetSettings()->GetSavePreviousDocumentResources() ==\n                     SavePreviousDocumentResources::kUntilOnDOMContentLoaded) {\n    fetcher_->ClearResourcesFromPreviousFetcher();\n  }\n  if (IsPrefetchOnly())\n    WebPrerenderingSupport::Current()->PrefetchFinished();\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    OP_REQUIRES(context, grad_in.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected grad shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", grad_in.shape()));\n    OP_REQUIRES(context, argmax.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected argmax shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", argmax.shape()));\n    TensorShape out_shape({params.tensor_in_batch, params.tensor_in_rows,\n                           params.tensor_in_cols, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    if (out_shape.num_elements() == 0) return;  \n    LaunchMaxPoolingGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "static int irda_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\tstruct msghdr *msg, size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct irda_sock *self;\n\tstruct sk_buff *skb;\n\tint err = -EPIPE;\n\tIRDA_DEBUG(4, \"%s(), len=%zd\\n\", __func__, len);\n\tif (msg->msg_flags & ~(MSG_DONTWAIT | MSG_EOR | MSG_CMSG_COMPAT |\n\t\t\t       MSG_NOSIGNAL))\n\t\treturn -EINVAL;\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto out_err;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tself = irda_sk(sk);\n\tif (wait_event_interruptible(*(sk->sk_sleep),\n\t    (self->tx_flow != FLOW_STOP  ||  sk->sk_state != TCP_ESTABLISHED)))\n\t\treturn -ERESTARTSYS;\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\treturn -ENOTCONN;\n\tif (len > self->max_data_size) {\n\t\tIRDA_DEBUG(2, \"%s(), Chopping frame from %zd to %d bytes!\\n\",\n\t\t\t   __func__, len, self->max_data_size);\n\t\tlen = self->max_data_size;\n\t}\n\tskb = sock_alloc_send_skb(sk, len + self->max_header_size + 16,\n\t\t\t\t  msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\tgoto out_err;\n\tskb_reserve(skb, self->max_header_size + 16);\n\tskb_reset_transport_header(skb);\n\tskb_put(skb, len);\n\terr = memcpy_fromiovec(skb_transport_header(skb), msg->msg_iov, len);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out_err;\n\t}\n\terr = irttp_data_request(self->tsap, skb);\n\tif (err) {\n\t\tIRDA_DEBUG(0, \"%s(), err=%d\\n\", __func__, err);\n\t\tgoto out_err;\n\t}\n\treturn len;\n out_err:\n\treturn sk_stream_error(sk, msg->msg_flags, err);\n}", "target": 0}
{"code": "static const char *tls_dns_name(const GENERAL_NAME * gn)\n{\n\tconst char *dnsname;\n\tif (ASN1_STRING_type(gn->d.ia5) != V_ASN1_IA5STRING) {\n\t\tg_warning(\"Invalid ASN1 value type in subjectAltName\");\n\t\treturn NULL;\n\t}\n\tdnsname = (char *) ASN1_STRING_data(gn->d.ia5);\n\tif (has_internal_nul(dnsname, ASN1_STRING_length(gn->d.ia5))) {\n\t\tg_warning(\"Internal NUL in subjectAltName\");\n\t\treturn NULL;\n\t}\n\treturn dnsname;\n}", "target": 0}
{"code": "recv_fd (const int sock)\n{\n  struct msghdr msg = {0};\n  union\n    {\n      struct cmsghdr hdr;\n      char buf[CMSG_SPACE(sizeof(int))];\n    } cmsgbuf = {0};\n  struct cmsghdr *cmsg;\n  struct iovec vec;\n  ssize_t n;\n  char ch = '\\0';\n  int fd = -1;\n  vec.iov_base = &ch;\n  vec.iov_len = 1;\n  msg.msg_iov = &vec;\n  msg.msg_iovlen = 1;\n  msg.msg_control = &cmsgbuf.buf;\n  msg.msg_controllen = sizeof (cmsgbuf.buf);\n  while ((n = recvmsg (sock, &msg, 0)) == -1 && errno == EINTR);\n  if (n != 1 || ch != 'A')\n    return -1;\n  cmsg = CMSG_FIRSTHDR (&msg);\n  if (cmsg == NULL)\n    return -1;\n  if (cmsg->cmsg_type != SCM_RIGHTS)\n    return -1;\n  memcpy (&fd, CMSG_DATA (cmsg), sizeof (fd));\n  if (fd < 0)\n    return -1;\n  return fd;\n}", "target": 0}
{"code": "void bnx2x_setup_cnic_irq_info(struct bnx2x *bp)\n{\n\tstruct cnic_eth_dev *cp = &bp->cnic_eth_dev;\n\tif (bp->flags & USING_MSIX_FLAG) {\n\t\tcp->drv_state |= CNIC_DRV_STATE_USING_MSIX;\n\t\tcp->irq_arr[0].irq_flags |= CNIC_IRQ_FL_MSIX;\n\t\tcp->irq_arr[0].vector = bp->msix_table[1].vector;\n\t} else {\n\t\tcp->drv_state &= ~CNIC_DRV_STATE_USING_MSIX;\n\t\tcp->irq_arr[0].irq_flags &= ~CNIC_IRQ_FL_MSIX;\n\t}\n\tif (!CHIP_IS_E1x(bp))\n\t\tcp->irq_arr[0].status_blk = (void *)bp->cnic_sb.e2_sb;\n\telse\n\t\tcp->irq_arr[0].status_blk = (void *)bp->cnic_sb.e1x_sb;\n\tcp->irq_arr[0].status_blk_num =  bnx2x_cnic_fw_sb_id(bp);\n\tcp->irq_arr[0].status_blk_num2 = bnx2x_cnic_igu_sb_id(bp);\n\tcp->irq_arr[1].status_blk = bp->def_status_blk;\n\tcp->irq_arr[1].status_blk_num = DEF_SB_ID;\n\tcp->irq_arr[1].status_blk_num2 = DEF_SB_IGU_ID;\n\tcp->num_irq = 2;\n}", "target": 0}
{"code": "  static TfLiteRegistration DynamicCopyOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      TfLiteTensor* output0 = GetOutput(context, node, 0);\n      SetTensorToDynamic(output0);\n      const TfLiteTensor* input = GetInput(context, node, 0);\n      TfLiteTensor* output1 = GetOutput(context, node, 1);\n      TF_LITE_ENSURE_STATUS(context->ResizeTensor(\n          context, output1, TfLiteIntArrayCopy(input->dims)));\n      return kTfLiteOk;\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "    PreviewProperties LoaderExifJpeg::getProperties() const\n    {\n        PreviewProperties prop = Loader::getProperties();\n        prop.mimeType_ = \"image/jpeg\";\n        prop.extension_ = \".jpg\";\n#ifdef EXV_UNICODE_PATH\n        prop.wextension_ = EXV_WIDEN(\".jpg\");\n#endif\n        return prop;\n    }", "target": 0}
{"code": "checked_xcalloc (size_t num, size_t size)\n{\n    alloc_limit_assert (\"checked_xcalloc\", (num *size));\n    return xcalloc (num, size);\n}", "target": 1}
{"code": "static inline bool spectre_v2_in_eibrs_mode(enum spectre_v2_mitigation mode)\n{\n\treturn mode == SPECTRE_V2_EIBRS ||\n\t       mode == SPECTRE_V2_EIBRS_RETPOLINE ||\n\t       mode == SPECTRE_V2_EIBRS_LFENCE;\n}", "target": 0}
{"code": "static void kvm_vcpu_ioctl_x86_get_xcrs(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_xcrs *guest_xcrs)\n{\n\tif (!cpu_has_xsave) {\n\t\tguest_xcrs->nr_xcrs = 0;\n\t\treturn;\n\t}\n\tguest_xcrs->nr_xcrs = 1;\n\tguest_xcrs->flags = 0;\n\tguest_xcrs->xcrs[0].xcr = XCR_XFEATURE_ENABLED_MASK;\n\tguest_xcrs->xcrs[0].value = vcpu->arch.xcr0;\n}", "target": 0}
{"code": "void infra_wait_limit_dec(struct infra_cache* infra, struct comm_reply* rep,\n\tstruct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 1);\n\tif(entry) {\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\tif(d->mesh_wait > 0)\n\t\t\td->mesh_wait--;\n\t\tlock_rw_unlock(&entry->lock);\n\t}\n}", "target": 0}
{"code": "static int sctp_v6_xmit(struct sk_buff *skb, struct sctp_transport *transport)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 fl6;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tfl6.daddr = transport->ipaddr.v6.sin6_addr;\n\tfl6.saddr = transport->saddr.v6.sin6_addr;\n\tfl6.flowlabel = np->flow_label;\n\tIP6_ECN_flow_xmit(sk, fl6.flowlabel);\n\tif (ipv6_addr_type(&fl6.saddr) & IPV6_ADDR_LINKLOCAL)\n\t\tfl6.flowi6_oif = transport->saddr.v6.sin6_scope_id;\n\telse\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\tif (np->opt && np->opt->srcrt) {\n\t\tstruct rt0_hdr *rt0 = (struct rt0_hdr *) np->opt->srcrt;\n\t\tfl6.daddr = *rt0->addr;\n\t}\n\tpr_debug(\"%s: skb:%p, len:%d, src:%pI6 dst:%pI6\\n\", __func__, skb,\n\t\t skb->len, &fl6.saddr, &fl6.daddr);\n\tSCTP_INC_STATS(sock_net(sk), SCTP_MIB_OUTSCTPPACKS);\n\tif (!(transport->param_flags & SPP_PMTUD_ENABLE))\n\t\tskb->local_df = 1;\n\treturn ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n}", "target": 1}
{"code": "inline TfLiteStatus GetMutableInputSafe(const TfLiteContext* context,\n                                        const TfLiteNode* node, int index,\n                                        const TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->inputs->size,\n                                          node->inputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "pci_get_vdev_info(int slot)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct pci_vdev *dev = NULL;\n\tbi = pci_businfo[0];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[slot];\n\tif (si != NULL)\n\t\tdev = si->si_funcs[0].fi_devi;\n\telse\n\t\tfprintf(stderr, \"slot=%d is empty!\\n\", slot);\n\treturn dev;\n}", "target": 1}
{"code": "static int em_grp45(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tswitch (ctxt->modrm_reg) {\n\tcase 2:  {\n\t\tlong int old_eip;\n\t\told_eip = ctxt->_eip;\n\t\tctxt->_eip = ctxt->src.val;\n\t\tctxt->src.val = old_eip;\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\tcase 4: \n\t\tctxt->_eip = ctxt->src.val;\n\t\tbreak;\n\tcase 5: \n\t\trc = em_jmp_far(ctxt);\n\t\tbreak;\n\tcase 6:\t\n\t\trc = em_push(ctxt);\n\t\tbreak;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "safe_add (int a, int b)\n{\n  if (a > INT_MAX/2 || b > INT_MAX/2)\n    return a > b ? a : b;\n  else\n    return a + b;\n}", "target": 0}
{"code": "void aio_complete(struct kiocb *iocb, long res, long res2)\n{\n\tstruct kioctx\t*ctx = iocb->ki_ctx;\n\tstruct aio_ring\t*ring;\n\tstruct io_event\t*ev_page, *event;\n\tunsigned tail, pos, head;\n\tunsigned long\tflags;\n\tif (is_sync_kiocb(iocb)) {\n\t\tiocb->ki_user_data = res;\n\t\tsmp_wmb();\n\t\tiocb->ki_ctx = ERR_PTR(-EXDEV);\n\t\twake_up_process(iocb->ki_obj.tsk);\n\t\treturn;\n\t}\n\tif (iocb->ki_list.next) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&ctx->ctx_lock, flags);\n\t\tlist_del(&iocb->ki_list);\n\t\tspin_unlock_irqrestore(&ctx->ctx_lock, flags);\n\t}\n\tspin_lock_irqsave(&ctx->completion_lock, flags);\n\ttail = ctx->tail;\n\tpos = tail + AIO_EVENTS_OFFSET;\n\tif (++tail >= ctx->nr_events)\n\t\ttail = 0;\n\tev_page = kmap_atomic(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tevent = ev_page + pos % AIO_EVENTS_PER_PAGE;\n\tevent->obj = (u64)(unsigned long)iocb->ki_obj.user;\n\tevent->data = iocb->ki_user_data;\n\tevent->res = res;\n\tevent->res2 = res2;\n\tkunmap_atomic(ev_page);\n\tflush_dcache_page(ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE]);\n\tpr_debug(\"%p[%u]: %p: %p %Lx %lx %lx\\n\",\n\t\t ctx, tail, iocb, iocb->ki_obj.user, iocb->ki_user_data,\n\t\t res, res2);\n\tsmp_wmb();\t\n\tctx->tail = tail;\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\tring->tail = tail;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\tctx->completed_events++;\n\tif (ctx->completed_events > 1)\n\t\trefill_reqs_available(ctx, head, tail);\n\tspin_unlock_irqrestore(&ctx->completion_lock, flags);\n\tpr_debug(\"added to ring %p at [%u]\\n\", iocb, tail);\n\tif (iocb->ki_eventfd != NULL)\n\t\teventfd_signal(iocb->ki_eventfd, 1);\n\tkiocb_free(iocb);\n\tsmp_mb();\n\tif (waitqueue_active(&ctx->wait))\n\t\twake_up(&ctx->wait);\n\tpercpu_ref_put(&ctx->reqs);\n}", "target": 0}
{"code": "static pj_status_t decode_uint_attr(pj_pool_t *pool, \n                                    const pj_uint8_t *buf, \n                                    const pj_stun_msg_hdr *msghdr, \n                                    void **p_attr)\n{\n    pj_stun_uint_attr *attr;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_uint_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->value = GETVAL32H(buf, 4);\n    if (attr->hdr.length != 4)\n        return PJNATH_ESTUNINATTRLEN;\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "test_all_FFs_set_handler(void **state)\n{\n    (void) state;\n    Tss2_RC_SetHandler(0xFF, \"garbage\", custom_err_handler);\n    Tss2_RC_SetHandler(0xFF, NULL, NULL);\n}", "target": 0}
{"code": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}", "target": 1}
{"code": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !inode_capable(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "GF_Err gf_isom_last_error(GF_ISOFile *the_file)\n{\n\tif (!the_file) return MP4_API_IO_Err;\n\treturn the_file->LastError;\n}", "target": 0}
{"code": "Function *ESTreeIRGen::genGeneratorFunction(\n    Identifier originalName,\n    Variable *lazyClosureAlias,\n    ESTree::FunctionLikeNode *functionNode) {\n  assert(functionNode && \"Function AST cannot be null\");\n  auto *outerFn = Builder.createGeneratorFunction(\n      originalName,\n      Function::DefinitionKind::ES5Function,\n      ESTree::isStrict(functionNode->strictness),\n       nullptr);\n  auto *innerFn = genES5Function(\n      genAnonymousLabelName(originalName.isValid() ? originalName.str() : \"\"),\n      lazyClosureAlias,\n      functionNode,\n      true);\n  {\n    FunctionContext outerFnContext{this, outerFn, functionNode->getSemInfo()};\n    emitFunctionPrologue(\n        functionNode,\n        Builder.createBasicBlock(outerFn),\n        InitES5CaptureState::Yes,\n        DoEmitParameters::No);\n    auto *gen = Builder.createCreateGeneratorInst(innerFn);\n    if (!hasSimpleParams(functionNode)) {\n      Value *next = Builder.createLoadPropertyInst(gen, \"next\");\n      Builder.createCallInst(next, gen, {});\n    }\n    emitFunctionEpilogue(gen);\n  }\n  return outerFn;\n}", "target": 1}
{"code": "void PacketReader::getLabelFromContent(const vector<uint8_t>& content, uint16_t& frompos, string& ret, int recurs) \n{\n  if(recurs > 100) \n    throw MOADNSException(\"Loop\");\n  int pos = frompos;\n  for(;;) {\n    unsigned char labellen=content.at(frompos++);\n    if(!labellen) {\n      if(ret.empty())\n              ret.append(1,'.');\n      break;\n    }\n    else if((labellen & 0xc0) == 0xc0) {\n      uint16_t offset=256*(labellen & ~0xc0) + (unsigned int)content.at(frompos++) - sizeof(dnsheader);\n      if(offset >= pos)\n        throw MOADNSException(\"forward reference during label decompression\");\n      return getLabelFromContent(content, offset, ret, ++recurs);\n    }\n    else if(labellen > 63) \n      throw MOADNSException(\"Overly long label during label decompression (\"+lexical_cast<string>((unsigned int)labellen)+\")\");\n    else {\n      for(string::size_type n = 0 ; n < labellen; ++n, frompos++) {\n        if(content.at(frompos)=='.' || content.at(frompos)=='\\\\') {\n          ret.append(1, '\\\\');\n          ret.append(1, content[frompos]);\n        }\n        else if(content.at(frompos)==' ') {\n          ret+=\"\\\\032\";\n        }\n        else \n          ret.append(1, content[frompos]);\n      }\n      ret.append(1,'.');\n    }\n    if (ret.length() > 1024)\n      throw MOADNSException(\"Total name too long\");\n  }\n}", "target": 1}
{"code": "void GfxImageColorMap::getGrayLine(unsigned char *in, unsigned char *out, int length)\n{\n    int i, j;\n    unsigned char *inp, *tmp_line;\n    if ((colorSpace2 && !colorSpace2->useGetGrayLine()) || (!colorSpace2 && !colorSpace->useGetGrayLine())) {\n        GfxGray gray;\n        inp = in;\n        for (i = 0; i < length; i++) {\n            getGray(inp, &gray);\n            out[i] = colToByte(gray);\n            inp += nComps;\n        }\n        return;\n    }\n    switch (colorSpace->getMode()) {\n    case csIndexed:\n    case csSeparation:\n        tmp_line = (unsigned char *)gmallocn(length, nComps2);\n        for (i = 0; i < length; i++) {\n            for (j = 0; j < nComps2; j++) {\n                unsigned char c = in[i];\n                if (byte_lookup)\n                    c = byte_lookup[c * nComps2 + j];\n                tmp_line[i * nComps2 + j] = c;\n            }\n        }\n        colorSpace2->getGrayLine(tmp_line, out, length);\n        gfree(tmp_line);\n        break;\n    default:\n        if (byte_lookup) {\n            inp = in;\n            for (j = 0; j < length; j++)\n                for (i = 0; i < nComps; i++) {\n                    *inp = byte_lookup[*inp * nComps + i];\n                    inp++;\n                }\n        }\n        colorSpace->getGrayLine(in, out, length);\n        break;\n    }\n}", "target": 0}
{"code": "void CheckAuthTest::TestValidToken(const std::string &auth_token,\n                                   const std::string &user_info) {\n  EXPECT_CALL(*raw_request_, FindHeader(\"x-goog-iap-jwt-assertion\", _))\n      .WillOnce(Invoke([](const std::string &, std::string *token) {\n        *token = \"\";\n        return false;\n      }));\n  EXPECT_CALL(*raw_request_, FindHeader(kAuthHeader, _))\n      .WillOnce(Invoke([auth_token](const std::string &, std::string *token) {\n        *token = std::string(kBearer) + auth_token;\n        return true;\n      }));\n  EXPECT_CALL(*raw_request_, SetAuthToken(auth_token)).Times(1);\n  EXPECT_CALL(*raw_env_, DoRunHTTPRequest(_))\n      .Times(2)\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1OpenIdUrl);\n        std::string body(kOpenIdContent);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }))\n      .WillOnce(Invoke([](HTTPRequest *req) {\n        EXPECT_EQ(req->url(), kIssuer1PubkeyUrl);\n        std::string body(kPubkey);\n        std::map<std::string, std::string> empty;\n        req->OnComplete(Status::OK, std::move(empty), std::move(body));\n      }));\n  std::cout << \"need be replaced: \" << user_info << std::endl;\n  EXPECT_CALL(*raw_request_,\n              AddHeaderToBackend(kEndpointApiUserInfo, user_info))\n      .WillOnce(Return(utils::Status::OK));\n  CheckAuth(context_, [](Status status) { ASSERT_TRUE(status.ok()); });\n}", "target": 1}
{"code": "static void rd_release_device_space(struct rd_dev *rd_dev)\n{\n\tu32 i, j, page_count = 0, sg_per_table;\n\tstruct rd_dev_sg_table *sg_table;\n\tstruct page *pg;\n\tstruct scatterlist *sg;\n\tif (!rd_dev->sg_table_array || !rd_dev->sg_table_count)\n\t\treturn;\n\tsg_table = rd_dev->sg_table_array;\n\tfor (i = 0; i < rd_dev->sg_table_count; i++) {\n\t\tsg = sg_table[i].sg_table;\n\t\tsg_per_table = sg_table[i].rd_sg_count;\n\t\tfor (j = 0; j < sg_per_table; j++) {\n\t\t\tpg = sg_page(&sg[j]);\n\t\t\tif (pg) {\n\t\t\t\t__free_page(pg);\n\t\t\t\tpage_count++;\n\t\t\t}\n\t\t}\n\t\tkfree(sg);\n\t}\n\tpr_debug(\"CORE_RD[%u] - Released device space for Ramdisk\"\n\t\t\" Device ID: %u, pages %u in %u tables total bytes %lu\\n\",\n\t\trd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,\n\t\trd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);\n\tkfree(sg_table);\n\trd_dev->sg_table_array = NULL;\n\trd_dev->sg_table_count = 0;\n}", "target": 1}
{"code": "log_close_all(void)\n{\nif (mainlogfd >= 0)\n  { (void)close(mainlogfd); mainlogfd = -1; }\nif (rejectlogfd >= 0)\n  { (void)close(rejectlogfd); rejectlogfd = -1; }\ncloselog();\nsyslog_open = FALSE;\n}", "target": 0}
{"code": "gopherSendRequest(int, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *)data;\n    MemBuf mb;\n    mb.init();\n    if (gopherState->type_id == GOPHER_CSO) {\n        const char *t = strchr(gopherState->request, '?');\n        if (t)\n            ++t;        \n        else\n            t = \"\";\n        mb.appendf(\"query %s\\r\\nquit\", t);\n    } else {\n        if (gopherState->type_id == GOPHER_INDEX) {\n            if (char *t = strchr(gopherState->request, '?'))\n                *t = '\\t';\n        }\n        mb.append(gopherState->request, strlen(gopherState->request));\n    }\n    mb.append(\"\\r\\n\", 2);\n    debugs(10, 5, gopherState->serverConn);\n    AsyncCall::Pointer call = commCbCall(5,5, \"gopherSendComplete\",\n                                         CommIoCbPtrFun(gopherSendComplete, gopherState));\n    Comm::Write(gopherState->serverConn, &mb, call);\n    if (!gopherState->entry->makePublic())\n        gopherState->entry->makePrivate(true);\n}", "target": 1}
{"code": "int dsOpen(void) {\n    struct stat sb;\n    int retval;\n    char *path = server.diskstore_path;\n    if ((retval = stat(path,&sb) == -1) && errno != ENOENT) {\n        redisLog(REDIS_WARNING, \"Error opening disk store at %s: %s\",\n                path, strerror(errno));\n        return REDIS_ERR;\n    }\n    if (retval == 0 && S_ISDIR(sb.st_mode)) return REDIS_OK;\n    if (retval == 0 && !S_ISDIR(sb.st_mode)) {\n        redisLog(REDIS_WARNING,\"Disk store at %s is not a directory\", path);\n        return REDIS_ERR;\n    }\n    if (mkdir(path) == -1) {\n        redisLog(REDIS_WARNING,\"Disk store init failed creating dir %s: %s\",\n            path, strerror(errno));\n        return REDIS_ERR;\n    }\n    return REDIS_OK;\n}", "target": 1}
{"code": "cmnd_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member *m, const char *runchroot, struct cmnd_info *info)\n{\n    struct alias *a;\n    struct sudo_command *c;\n    int rc, matched = UNSPEC;\n    debug_decl(cmnd_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\tcase COMMAND:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "GF_Err xtra_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_XtraBox *ptr = (GF_XtraBox *)s;\n\twhile (ptr->size) {\n\t\tGF_XtraTag *tag;\n\t\tu32 prop_type = 0;\n\t\tchar *data=NULL, *data2=NULL;\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 8)\n\t\ts32 tag_size = gf_bs_read_u32(bs);\n\t\tu32 name_size = gf_bs_read_u32(bs);\n\t\tif (tag_size < 8) return GF_ISOM_INVALID_FILE;\n\t\ttag_size -= 8;\n\t\tif ((tag_size>ptr->size) || (name_size>ptr->size)) {\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, 10)\n\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, name_size)\n\t\tdata = gf_malloc(sizeof(char) * (name_size+1));\n\t\tgf_bs_read_data(bs, data, name_size);\n\t\tdata[name_size] = 0;\n\t\ttag_size-=name_size;\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+2));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;\n\t\tgf_list_add(ptr->tags, tag);\n\t\tif (tag_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[isom] invalid tag size in Xtra !\\n\"));\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 1}
{"code": "void rose_start_t2timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t2;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "ts_date_hmsfrac_print(netdissect_options *ndo, long sec, long usec,\n\t\t      enum date_flag date_flag, enum time_flag time_flag)\n{\n\ttime_t Time = sec;\n\tstruct tm *tm;\n\tchar timestr[32];\n\tif ((unsigned)sec & 0x80000000) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (time_flag == LOCAL_TIME)\n\t\ttm = localtime(&Time);\n\telse\n\t\ttm = gmtime(&Time);\n\tif (!tm) {\n\t\tND_PRINT(\"[Error converting time]\");\n\t\treturn;\n\t}\n\tif (date_flag == WITH_DATE)\n\t\tstrftime(timestr, sizeof(timestr), \"%Y-%m-%d %H:%M:%S\", tm);\n\telse\n\t\tstrftime(timestr, sizeof(timestr), \"%H:%M:%S\", tm);\n\tND_PRINT(\"%s\", timestr);\n\tts_frac_print(ndo, usec);\n}", "target": 1}
{"code": "FNAME(prefetch_gpte)(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t     u64 *spte, pt_element_t gpte, bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\tunsigned pte_access;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\tif (FNAME(prefetch_invalid_gpte)(vcpu, sp, spte, gpte))\n\t\treturn false;\n\tpgprintk(\"%s: gpte %llx spte %p\\n\", __func__, (u64)gpte, spte);\n\tgfn = gpte_to_gfn(gpte);\n\tpte_access = sp->role.access & FNAME(gpte_access)(gpte);\n\tFNAME(protect_clean_gpte)(vcpu->arch.mmu, &pte_access, gpte);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn,\n\t\t\tno_dirty_log && (pte_access & ACC_WRITE_MASK));\n\tif (!slot)\n\t\treturn false;\n\tpfn = gfn_to_pfn_memslot_atomic(slot, gfn);\n\tif (is_error_pfn(pfn))\n\t\treturn false;\n\tmmu_set_spte(vcpu, slot, spte, pte_access, gfn, pfn, NULL);\n\tkvm_release_pfn_clean(pfn);\n\treturn true;\n}", "target": 0}
{"code": "cpStripToTile(uint8* out, uint8* in,\n    uint32 rows, uint32 cols, int outskew, int inskew)\n{\n\twhile (rows-- > 0) {\n\t\tuint32 j = cols;\n\t\twhile (j-- > 0)\n\t\t\t*out++ = *in++;\n\t\tout += outskew;\n\t\tin += inskew;\n\t}\n}", "target": 1}
{"code": "void CLASS parse_kodak_ifd (int base)\n{\n  unsigned entries, tag, type, len, save;\n  int i, c, wbi=-2, wbtemp=6500;\n  float mul[3]={1,1,1}, num;\n  static const int wbtag[] = { 64037,64040,64039,64041,-1,-1,64042 };\n  entries = get2();\n  if (entries > 1024) return;\n  while (entries--) {\n    tiff_get (base, &tag, &type, &len, &save);\n    if (tag == 1020) wbi = getint(type);\n    if (tag == 1021 && len == 72) {\t\t\n      fseek (ifp, 40, SEEK_CUR);\n      FORC3 cam_mul[c] = 2048.0 / get2();\n      wbi = -2;\n    }\n    if (tag == 2118) wbtemp = getint(type);\n    if (tag == 2120 + wbi && wbi >= 0)\n      FORC3 cam_mul[c] = 2048.0 / getreal(type);\n    if (tag == 2130 + wbi)\n      FORC3 mul[c] = getreal(type);\n    if (tag == 2140 + wbi && wbi >= 0)\n      FORC3 {\n\tfor (num=i=0; i < 4; i++)\n\t  num += getreal(type) * pow (wbtemp/100.0, i);\n\tcam_mul[c] = 2048 / (num * mul[c]);\n      }\n    if (tag == 2317) linear_table (len);\n    if (tag == 6020) iso_speed = getint(type);\n    if (tag == 64013) wbi = fgetc(ifp);\n    if ((unsigned) wbi < 7 && tag == wbtag[wbi])\n      FORC3 cam_mul[c] = get4();\n    if (tag == 64019) width = getint(type);\n    if (tag == 64020) height = (getint(type)+1) & -2;\n    fseek (ifp, save, SEEK_SET);\n  }\n}", "target": 0}
{"code": "pci_emul_add_capability(struct pci_vdev *dev, u_char *capdata, int caplen)\n{\n\tint i, capoff, reallen;\n\tuint16_t sts;\n\tassert(caplen > 0);\n\treallen = roundup2(caplen, 4);\t\t\n\tsts = pci_get_cfgdata16(dev, PCIR_STATUS);\n\tif ((sts & PCIM_STATUS_CAPPRESENT) == 0)\n\t\tcapoff = CAP_START_OFFSET;\n\telse\n\t\tcapoff = dev->capend + 1;\n\tif (capoff + reallen > PCI_REGMAX + 1)\n\t\treturn -1;\n\tif ((sts & PCIM_STATUS_CAPPRESENT) == 0) {\n\t\tpci_set_cfgdata8(dev, PCIR_CAP_PTR, capoff);\n\t\tpci_set_cfgdata16(dev, PCIR_STATUS, sts|PCIM_STATUS_CAPPRESENT);\n\t} else\n\t\tpci_set_cfgdata8(dev, dev->prevcap + 1, capoff);\n\tfor (i = 0; i < caplen; i++)\n\t\tpci_set_cfgdata8(dev, capoff + i, capdata[i]);\n\tpci_set_cfgdata8(dev, capoff + 1, 0);\n\tdev->prevcap = capoff;\n\tdev->capend = capoff + reallen - 1;\n\treturn 0;\n}", "target": 1}
{"code": "static inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;\n}", "target": 0}
{"code": "static void flush_cmd(void)\n{\n    scanned = readnbd = (size_t) 0U;\n}", "target": 0}
{"code": "static void nvme_zone_reset_cancel(BlockAIOCB *aiocb)\n{\n    NvmeZoneResetAIOCB *iocb = container_of(aiocb, NvmeZoneResetAIOCB, common);\n    NvmeRequest *req = iocb->req;\n    NvmeNamespace *ns = req->ns;\n    iocb->idx = ns->num_zones;\n    iocb->ret = -ECANCELED;\n    if (iocb->aiocb) {\n        blk_aio_cancel_async(iocb->aiocb);\n        iocb->aiocb = NULL;\n    }\n}", "target": 0}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        return CalculateOutputIndexValueRowID(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        return CalculateOutputIndexRowSplit(\n            row_partition_tensor, parent_output_index, output_index_multiplier,\n            output_size, result);\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_constant_value_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_CONST_VALUE_ATTR;\n\t\tattr->info.constant_value_attr.constantvalue_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    INDEX_TYPE first_dimension;\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    OP_REQUIRES(context, first_partition_tensor.NumElements() > 0,\n                errors::InvalidArgument(\"Invalid first partition input. Tensor \"\n                                        \"requires at least one element.\"));\n    OP_REQUIRES_OK(context, GetFirstDimensionSize(context, &first_dimension));\n    vector<INDEX_TYPE> output_size;\n    OP_REQUIRES_OK(context,\n                   CalculateOutputSize(first_dimension, context, &output_size));\n    vector<INDEX_TYPE> multiplier;\n    multiplier.resize(ragged_rank_ + 1);\n    multiplier[multiplier.size() - 1] = 1;\n    for (int i = multiplier.size() - 2; i >= 0; --i) {\n      multiplier[i] = multiplier[i + 1] * output_size[i + 1];\n    }\n    TensorShape output_shape;\n    OP_REQUIRES_OK(context,\n                   TensorShapeUtils::MakeShape(output_size, &output_shape));\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, output_shape, &output_tensor));\n    const INDEX_TYPE full_size = multiplier[0] * output_size[0];\n    if (full_size > 0) {\n      vector<INDEX_TYPE> output_index, new_output_index;\n      int nvals = context->input(kValueInputIndex).shape().dim_size(0);\n      output_index.reserve(nvals);\n      new_output_index.reserve(nvals);\n      CalculateFirstParentOutputIndex(first_dimension, multiplier[0],\n                                      output_size[0], &output_index);\n      for (int i = 1; i <= ragged_rank_; ++i) {\n        OP_REQUIRES_OK(context, CalculateOutputIndex(\n                                    context, i - 1, output_index, multiplier[i],\n                                    output_size[i], &new_output_index));\n        output_index.swap(new_output_index);\n        new_output_index.clear();\n      }\n      SetOutput(context, ragged_rank_, output_index, output_tensor);\n    }\n  }", "target": 0}
{"code": "static void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}", "target": 1}
{"code": "CMS_ContentInfo *CMS_sign_receipt(CMS_SignerInfo *si,\n                                  X509 *signcert, EVP_PKEY *pkey,\n                                  STACK_OF(X509) *certs, unsigned int flags)\n{\n    CMS_SignerInfo *rct_si;\n    CMS_ContentInfo *cms = NULL;\n    ASN1_OCTET_STRING **pos, *os;\n    BIO *rct_cont = NULL;\n    int r = 0;\n    flags &= ~(CMS_STREAM | CMS_TEXT);\n    flags |= CMS_PARTIAL | CMS_BINARY | CMS_DETACHED;\n    if (!pkey || !signcert) {\n        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_NO_KEY_OR_CERT);\n        return NULL;\n    }\n    cms = CMS_sign(NULL, NULL, certs, NULL, flags);\n    if (!cms)\n        goto err;\n    if (!CMS_set1_eContentType(cms, OBJ_nid2obj(NID_id_smime_ct_receipt)))\n        goto err;\n    rct_si = CMS_add1_signer(cms, signcert, pkey, NULL, flags);\n    if (!rct_si) {\n        CMSerr(CMS_F_CMS_SIGN_RECEIPT, CMS_R_ADD_SIGNER_ERROR);\n        goto err;\n    }\n    os = cms_encode_Receipt(si);\n    if (!os)\n        goto err;\n    rct_cont = BIO_new_mem_buf(os->data, os->length);\n    if (!rct_cont)\n        goto err;\n    if (!cms_msgSigDigest_add1(rct_si, si))\n        goto err;\n    if (!CMS_final(cms, rct_cont, NULL, flags))\n        goto err;\n    pos = CMS_get0_content(cms);\n    *pos = os;\n    r = 1;\n err:\n    if (rct_cont)\n        BIO_free(rct_cont);\n    if (r)\n        return cms;\n    CMS_ContentInfo_free(cms);\n    return NULL;\n}", "target": 0}
{"code": "void HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });\n  max_request_headers_kb_ = 96;\n  Http::TestHeaderMapImpl big_headers{\n      {\":method\", \"GET\"}, {\":path\", \"/test/long/url\"}, {\":scheme\", \"http\"}, {\":authority\", \"host\"}};\n  for (int i = 0; i < 20000; i++) {\n    big_headers.addCopy(std::to_string(i), std::string(0, 'a'));\n  }\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto response =\n      sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0, 0, time);\n  EXPECT_TRUE(response->complete());\n  EXPECT_EQ(\"200\", response->headers().Status()->value().getStringView());\n}", "target": 0}
{"code": "static struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\t\tsel >>= 3;\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}", "target": 1}
{"code": "dup_list_from_ptrarray (GPtrArray *p)\n{\n  GList *ret;\n  guint n;\n  ret = NULL;\n  for (n = 0; n < p->len; n++)\n    ret = g_list_prepend (ret, g_strdup (((gchar **) p->pdata)[n]));\n  return ret;\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoVertexAttrib1f(GLuint index, GLfloat v0) {\n  VertexAttribManager::VertexAttribInfo* info =\n      vertex_attrib_manager_->GetVertexAttribInfo(index);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glVertexAttrib1f: index out of range\");\n    return;\n  }\n  VertexAttribManager::VertexAttribInfo::Vec4 value;\n  value.v[0] = v0;\n  value.v[1] = 0.0f;\n  value.v[2] = 0.0f;\n  value.v[3] = 1.0f;\n  info->set_value(value);\n  glVertexAttrib1f(index, v0);\n}", "target": 0}
{"code": "int __hnbad(const char *dotted)\n{\n\tunsigned char c, n, *cp;\n\tunsigned char buf[NS_MAXCDNAME];\n\tcp = (unsigned char *)dotted;\n\twhile ((c = *cp++))\n\t\tif (c < 0x21 || c > 0x7E)\n\t\t\treturn (1);\n\tif (ns_name_pton(dotted, buf, sizeof(buf)) < 0)\n\t\treturn (2);\n\tif (buf[0] > 0 && buf[1] == '-')\n\t\treturn (3);\n\tcp = buf;\n\twhile ((n = *cp++)) {\n\t\tif (n > 63)\n\t\t\treturn (4);\n\t\twhile (n--) {\n\t\t\tc = *cp++;\n\t\t\tif (c < '-' ||\n\t\t\t    (c > '-' && c < '0') ||\n\t\t\t    (c > '9' && c < 'A') ||\n\t\t\t    (c > 'Z' && c < '_') ||\n\t\t\t    (c > '_' && c < 'a') ||\n\t\t\t    c > 'z')\n\t\t\t\treturn (5);\n\t\t}\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "QPDF::read_xref(qpdf_offset_t xref_offset)\n{\n    std::map<int, int> free_table;\n    std::set<qpdf_offset_t> visited;\n    while (xref_offset)\n    {\n        visited.insert(xref_offset);\n        char buf[7];\n        memset(buf, 0, sizeof(buf));\n\tthis->m->file->seek(xref_offset, SEEK_SET);\n\tthis->m->file->read(buf, sizeof(buf) - 1);\n        if ((strncmp(buf, \"xref\", 4) == 0) &&\n            QUtil::is_space(buf[4]))\n\t{\n            QTC::TC(\"qpdf\", \"QPDF xref space\",\n                    ((buf[4] == '\\n') ? 0 :\n                     (buf[4] == '\\r') ? 1 :\n                     (buf[4] == ' ') ? 2 : 9999));\n            int skip = 4;\n            while (QUtil::is_space(buf[skip]))\n            {\n                ++skip;\n            }\n            xref_offset = read_xrefTable(xref_offset + skip);\n\t}\n\telse\n\t{\n\t    xref_offset = read_xrefStream(xref_offset);\n\t}\n        if (visited.count(xref_offset) != 0)\n        {\n            xref_offset = 0;\n        }\n    }\n    if (! this->m->trailer.isInitialized())\n    {\n        throw QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n                      \"unable to find trailer while reading xref\");\n    }\n    int size = this->m->trailer.getKey(\"/Size\").getIntValue();\n    int max_obj = 0;\n    if (! this->m->xref_table.empty())\n    {\n\tmax_obj = (*(this->m->xref_table.rbegin())).first.getObj();\n    }\n    if (! this->m->deleted_objects.empty())\n    {\n\tmax_obj = std::max(max_obj, *(this->m->deleted_objects.rbegin()));\n    }\n    if (size != max_obj + 1)\n    {\n\tQTC::TC(\"qpdf\", \"QPDF xref size mismatch\");\n\twarn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), \"\", 0,\n\t\t     std::string(\"reported number of objects (\") +\n\t\t     QUtil::int_to_string(size) +\n\t\t     \") inconsistent with actual number of objects (\" +\n\t\t     QUtil::int_to_string(max_obj + 1) + \")\"));\n    }\n    this->m->deleted_objects.clear();\n}", "target": 0}
{"code": "vm_fault_t gru_fault(struct vm_fault *vmf)\n{\n\tstruct vm_area_struct *vma = vmf->vma;\n\tstruct gru_thread_state *gts;\n\tunsigned long paddr, vaddr;\n\tunsigned long expires;\n\tvaddr = vmf->address;\n\tgru_dbg(grudev, \"vma %p, vaddr 0x%lx (0x%lx)\\n\",\n\t\tvma, vaddr, GSEG_BASE(vaddr));\n\tSTAT(nopfn);\n\tgts = gru_find_thread_state(vma, TSID(vaddr, vma));\n\tif (!gts)\n\t\treturn VM_FAULT_SIGBUS;\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\tgru_check_context_placement(gts);\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();\n\t\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(GRU_ASSIGN_DELAY);  \n\t\t\texpires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;\n\t\t\tif (time_before(expires, jiffies))\n\t\t\t\tgru_steal_context(gts);\n\t\t\tgoto again;\n\t\t}\n\t\tgru_load_context(gts);\n\t\tpaddr = gseg_physical_address(gts->ts_gru, gts->ts_ctxnum);\n\t\tremap_pfn_range(vma, vaddr & ~(GRU_GSEG_PAGESIZE - 1),\n\t\t\t\tpaddr >> PAGE_SHIFT, GRU_GSEG_PAGESIZE,\n\t\t\t\tvma->vm_page_prot);\n\t}\n\tpreempt_enable();\n\tmutex_unlock(&gts->ts_ctxlock);\n\treturn VM_FAULT_NOPAGE;\n}", "target": 1}
{"code": "static void lwp_write(FILE *fout, const std::string &buf) {\n  size_t len = buf.length();\n  fwrite(&len, sizeof(len), 1, fout);\n  fwrite(buf.c_str(), sizeof(buf[0]), len, fout);\n  fflush(fout);\n}", "target": 0}
{"code": "    uint32_t TiffEntryBase::doSizeImage() const\n    {\n        return 0;\n    } ", "target": 0}
{"code": "static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)\n{\n\tunsigned long val;\n\tvoid *ptr = NULL;\n\tif (!atomic_pool) {\n\t\tWARN(1, \"coherent pool not initialised!\\n\");\n\t\treturn NULL;\n\t}\n\tval = gen_pool_alloc(atomic_pool, size);\n\tif (val) {\n\t\tphys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);\n\t\t*ret_page = phys_to_page(phys);\n\t\tptr = (void *)val;\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(ptr, 0, size);\n\t}\n\treturn ptr;\n}", "target": 1}
{"code": "  void ClearSchemes() {\n    schemes_.clear();\n  }", "target": 0}
{"code": "static inline int udp4_csum_init(struct sk_buff *skb, struct udphdr *uh,\n\t\t\t\t int proto)\n{\n\tint err;\n\tUDP_SKB_CB(skb)->partial_cov = 0;\n\tUDP_SKB_CB(skb)->cscov = skb->len;\n\tif (proto == IPPROTO_UDPLITE) {\n\t\terr = udplite_checksum_init(skb, uh);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn skb_checksum_init_zero_check(skb, proto, uh->check,\n\t\t\t\t\t    inet_compute_pseudo);\n}", "target": 0}
{"code": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\tp->replacement_session_keyring = NULL;\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\tnew->user_ns = new->user->user_ns;\n#ifdef CONFIG_KEYS\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}", "target": 0}
{"code": "http_rxchunk(struct http *hp)\n{\n\tchar *q;\n\tint l, i;\n\tl = hp->prxbuf;\n\tdo\n\t\t(void)http_rxchar(hp, 1, 0);\n\twhile (hp->rxbuf[hp->prxbuf - 1] != '\\n');\n\tvtc_dump(hp->vl, 4, \"len\", hp->rxbuf + l, -1);\n\ti = strtoul(hp->rxbuf + l, &q, 16);\n\tbprintf(hp->chunklen, \"%d\", i);\n\tif ((q == hp->rxbuf + l) ||\n\t\t(*q != '\\0' && !vct_islws(*q))) {\n\t\tvtc_log(hp->vl, hp->fatal, \"chunked fail %02x @ %d\",\n\t\t    *q, q - (hp->rxbuf + l));\n\t}\n\tassert(q != hp->rxbuf + l);\n\tassert(*q == '\\0' || vct_islws(*q));\n\thp->prxbuf = l;\n\tif (i > 0) {\n\t\t(void)http_rxchar(hp, i, 0);\n\t\tvtc_dump(hp->vl, 4, \"chunk\",\n\t\t    hp->rxbuf + l, i);\n\t}\n\tl = hp->prxbuf;\n\t(void)http_rxchar(hp, 2, 0);\n\tif(!vct_iscrlf(hp->rxbuf[l]))\n\t\tvtc_log(hp->vl, hp->fatal,\n\t\t    \"Wrong chunk tail[0] = %02x\",\n\t\t    hp->rxbuf[l] & 0xff);\n\tif(!vct_iscrlf(hp->rxbuf[l + 1]))\n\t\tvtc_log(hp->vl, hp->fatal,\n\t\t    \"Wrong chunk tail[1] = %02x\",\n\t\t    hp->rxbuf[l + 1] & 0xff);\n\thp->prxbuf = l;\n\thp->rxbuf[l] = '\\0';\n\treturn (i);\n}", "target": 1}
{"code": "expand_command(struct eventlog *evlog, char **newbuf)\n{\n    size_t len, bufsize = strlen(evlog->command) + 1;\n    char *cp, *buf;\n    int ac;\n    debug_decl(expand_command, SUDO_DEBUG_UTIL);\n    if (evlog->argv == NULL || evlog->argv[0] == NULL || evlog->argv[1] == NULL) {\n\t*newbuf = NULL;\n\tdebug_return_str(evlog->command);\n    }\n    for (ac = 1; evlog->argv[ac] != NULL; ac++)\n\tbufsize += strlen(evlog->argv[ac]) + 1;\n    if ((buf = malloc(bufsize)) == NULL)\n\tsudo_fatalx(U_(\"%s: %s\"), __func__, U_(\"unable to allocate memory\"));\n    cp = buf;\n    len = strlcpy(cp, evlog->command, bufsize);\n    if (len >= bufsize)\n\tsudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n    cp += len;\n    bufsize -= len;\n    for (ac = 1; evlog->argv[ac] != NULL; ac++) {\n\tif (bufsize < 2)\n\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\t*cp++ = ' ';\n\tbufsize--;\n\tlen = strlcpy(cp, evlog->argv[ac], bufsize);\n\tif (len >= bufsize)\n\t    sudo_fatalx(U_(\"internal error, %s overflow\"), __func__);\n\tcp += len;\n\tbufsize -= len;\n    }\n    *newbuf = buf;\n    debug_return_str(buf);\n}", "target": 0}
{"code": "static void vnc_refresh(DisplayChangeListener *dcl)\n{\n    VncDisplay *vd = container_of(dcl, VncDisplay, dcl);\n    VncState *vs, *vn;\n    int has_dirty, rects = 0;\n    if (QTAILQ_EMPTY(&vd->clients)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_MAX);\n        return;\n    }\n    graphic_hw_update(vd->dcl.con);\n    if (vnc_trylock_display(vd)) {\n        update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n        return;\n    }\n    has_dirty = vnc_refresh_server_surface(vd);\n    vnc_unlock_display(vd);\n    QTAILQ_FOREACH_SAFE(vs, &vd->clients, next, vn) {\n        rects += vnc_update_client(vs, has_dirty, false);\n    }\n    if (has_dirty && rects) {\n        vd->dcl.update_interval /= 2;\n        if (vd->dcl.update_interval < VNC_REFRESH_INTERVAL_BASE) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_BASE;\n        }\n    } else {\n        vd->dcl.update_interval += VNC_REFRESH_INTERVAL_INC;\n        if (vd->dcl.update_interval > VNC_REFRESH_INTERVAL_MAX) {\n            vd->dcl.update_interval = VNC_REFRESH_INTERVAL_MAX;\n        }\n    }\n}", "target": 0}
{"code": "add_key_equal_fields(JOIN *join, KEY_FIELD **key_fields, uint and_level,\n                     Item_bool_func *cond, Item *field_item,\n                     bool eq_func, Item **val,\n                     uint num_values, table_map usable_tables,\n                     SARGABLE_PARAM **sargables, uint row_col_no= 0)\n{\n  Field *field= ((Item_field *) (field_item->real_item()))->field;\n  add_key_field(join, key_fields, and_level, cond, field,\n                eq_func, val, num_values, usable_tables, sargables,\n                row_col_no);\n  Item_equal *item_equal= field_item->get_item_equal();\n  if (item_equal)\n  { \n    Item_equal_fields_iterator it(*item_equal);\n    while (it++)\n    {\n      Field *equal_field= it.get_curr_field();\n      if (!field->eq(equal_field))\n      {\n        add_key_field(join, key_fields, and_level, cond, equal_field,\n                      eq_func, val, num_values, usable_tables,\n                      sargables, row_col_no);\n      }\n    }\n  }\n}", "target": 0}
{"code": "static int ntlm_read_ntlm_v2_client_challenge(wStream* s, NTLMv2_CLIENT_CHALLENGE* challenge)\n{\n\tsize_t size;\n\tif (Stream_GetRemainingLength(s) < 28)\n\t\treturn -1;\n\tStream_Read_UINT8(s, challenge->RespType);\n\tStream_Read_UINT8(s, challenge->HiRespType);\n\tStream_Read_UINT16(s, challenge->Reserved1);\n\tStream_Read_UINT32(s, challenge->Reserved2);\n\tStream_Read(s, challenge->Timestamp, 8);\n\tStream_Read(s, challenge->ClientChallenge, 8);\n\tStream_Read_UINT32(s, challenge->Reserved3);\n\tsize = Stream_Length(s) - Stream_GetPosition(s);\n\tif (size > UINT32_MAX)\n\t\treturn -1;\n\tchallenge->cbAvPairs = size;\n\tchallenge->AvPairs = (NTLM_AV_PAIR*)malloc(challenge->cbAvPairs);\n\tif (!challenge->AvPairs)\n\t\treturn -1;\n\tStream_Read(s, challenge->AvPairs, size);\n\treturn 1;\n}", "target": 0}
{"code": "static void vgacon_scrollback_update(struct vc_data *c, int t, int count)\n{\n\tvoid *p;\n\tif (!vgacon_scrollback_cur->data || !vgacon_scrollback_cur->size ||\n\t    c->vc_num != fg_console)\n\t\treturn;\n\tp = (void *) (c->vc_origin + t * c->vc_size_row);\n\twhile (count--) {\n\t\tif ((vgacon_scrollback_cur->tail + c->vc_size_row) >\n\t\t    vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\t\tscr_memcpyw(vgacon_scrollback_cur->data +\n\t\t\t    vgacon_scrollback_cur->tail,\n\t\t\t    p, c->vc_size_row);\n\t\tvgacon_scrollback_cur->cnt++;\n\t\tp += c->vc_size_row;\n\t\tvgacon_scrollback_cur->tail += c->vc_size_row;\n\t\tif (vgacon_scrollback_cur->tail >= vgacon_scrollback_cur->size)\n\t\t\tvgacon_scrollback_cur->tail = 0;\n\t\tif (vgacon_scrollback_cur->cnt > vgacon_scrollback_cur->rows)\n\t\t\tvgacon_scrollback_cur->cnt = vgacon_scrollback_cur->rows;\n\t\tvgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;\n\t}\n}", "target": 1}
{"code": "int perf_config(config_fn_t fn, void *data)\n{\n\tint ret = 0, found = 0;\n\tchar *repo_config = NULL;\n\tconst char *home = NULL;\n\tif (config_exclusive_filename)\n\t\treturn perf_config_from_file(fn, config_exclusive_filename, data);\n\tif (perf_config_system() && !access(perf_etc_perfconfig(), R_OK)) {\n\t\tret += perf_config_from_file(fn, perf_etc_perfconfig(),\n\t\t\t\t\t    data);\n\t\tfound += 1;\n\t}\n\thome = getenv(\"HOME\");\n\tif (perf_config_global() && home) {\n\t\tchar *user_config = strdup(mkpath(\"%s/.perfconfig\", home));\n\t\tif (!access(user_config, R_OK)) {\n\t\t\tret += perf_config_from_file(fn, user_config, data);\n\t\t\tfound += 1;\n\t\t}\n\t\tfree(user_config);\n\t}\n\trepo_config = perf_pathdup(\"config\");\n\tif (!access(repo_config, R_OK)) {\n\t\tret += perf_config_from_file(fn, repo_config, data);\n\t\tfound += 1;\n\t}\n\tfree(repo_config);\n\tif (found == 0)\n\t\treturn -1;\n\treturn ret;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_result_seek)\n{\n\tzval *result;\n\tzend_long row;\n\tpgsql_result_handle *pg_result;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"rl\", &result, &row) == FAILURE) {\n\t\treturn;\n\t}\n\tZEND_FETCH_RESOURCE(pg_result, pgsql_result_handle *, result, -1, \"PostgreSQL result\", le_result);\n\tif (row < 0 || row >= PQntuples(pg_result->result)) {\n\t\tRETURN_FALSE;\n\t}\n\tpg_result->row = (int)row;\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "struct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)\n{\n\tint err;\n\tstruct nfs_client *clp = nfs_alloc_client(cl_init);\n\tif (IS_ERR(clp))\n\t\treturn clp;\n\terr = nfs_get_cb_ident_idr(clp, cl_init->minorversion);\n\tif (err)\n\t\tgoto error;\n\tif (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\tspin_lock_init(&clp->cl_lock);\n\tINIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);\n\tINIT_LIST_HEAD(&clp->cl_ds_clients);\n\trpc_init_wait_queue(&clp->cl_rpcwaitq, \"NFS client\");\n\tclp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;\n\tclp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];\n\tclp->cl_mig_gen = 1;\n#if IS_ENABLED(CONFIG_NFS_V4_1)\n\tinit_waitqueue_head(&clp->cl_lock_waitq);\n#endif\n\tINIT_LIST_HEAD(&clp->pending_cb_stateids);\n\treturn clp;\nerror:\n\tnfs_free_client(clp);\n\treturn ERR_PTR(err);\n}", "target": 1}
{"code": "static bool cma_match_net_dev(const struct rdma_cm_id *id,\n\t\t\t      const struct net_device *net_dev,\n\t\t\t      const struct cma_req_info *req)\n{\n\tconst struct rdma_addr *addr = &id->route.addr;\n\tif (!net_dev)\n\t\treturn (!id->port_num || id->port_num == req->port) &&\n\t\t       (addr->src_addr.ss_family == AF_IB);\n\tif (!cma_is_req_ipv6_ll(req))\n\t\treturn true;\n\tif (net_eq(dev_net(net_dev), addr->dev_addr.net) &&\n\t    (!!addr->dev_addr.bound_dev_if ==\n\t     (addr->dev_addr.bound_dev_if == net_dev->ifindex)))\n\t\treturn true;\n\telse\n\t\treturn false;\n}", "target": 0}
{"code": "void test_rmdir(const char *path)\n{\n\tsize_t len = strlen(path) + 30;\n\tchar *tmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", path, (int)getpid());\n\tif (rmdir(path) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rmdir of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (rmdir(tmpname) == 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at rmdir of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static u32 gasp_version(__be32 *p)\n{\n\treturn be32_to_cpu(p[1]) & 0xffffff;\n}", "target": 0}
{"code": "   Clears flags on messages */\nPHP_FUNCTION(imap_clearflag_full)\n{\n\tzval *streamind;\n\tzend_string *sequence, *flag;\n\tzend_long flags = 0;\n\tpils *imap_le_struct;\n\tint argc = ZEND_NUM_ARGS();\n\tif (zend_parse_parameters(argc, \"rSS|l\", &streamind, &sequence, &flag, &flags) ==FAILURE) {\n\t\treturn;\n\t}\n\tif ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), \"imap\", le_imap)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tmail_clearflag_full(imap_le_struct->imap_stream, ZSTR_VAL(sequence), ZSTR_VAL(flag), (argc == 4 ? flags : NIL));\n\tRETURN_TRUE;", "target": 0}
{"code": "static inline struct htx_blk *htx_add_header(struct htx *htx, const struct ist name,\n\t\t\t\t\t     const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_HDR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "extract_one_file(EpubDocument* epub_document,GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n    gboolean result = TRUE;\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n    if ( directory != NULL )\n        directory++;\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n    outfile = g_file_new_for_path(gfilepath->str);\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outfile) ;\n    g_object_unref(outstream) ;\nout:\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}", "target": 1}
{"code": "int DynamicMetadataMapIterator::luaPairsIterator(lua_State* state) {\n  if (current_ == parent_.streamInfo().dynamicMetadata().filter_metadata().end()) {\n    parent_.iterator_.reset();\n    return 0;\n  }\n  lua_pushstring(state, current_->first.c_str());\n  Filters::Common::Lua::MetadataMapHelper::createTable(state, current_->second.fields());\n  current_++;\n  return 2;\n}", "target": 0}
{"code": "add_serials(struct deltas_head *deltas, ...)\n{\n\tstruct delta_head delta;\n\tva_list vl;\n\tdoc_data_init(&delta.doc_data);\n\tva_start(vl, deltas);\n\twhile ((delta.serial = va_arg(vl, unsigned long)) != END)\n\t\tck_assert_int_eq(0, deltas_head_add(deltas, &delta));\n\tva_end(vl);\n}", "target": 0}
{"code": "int main(int argc, char **argv)\n{\n    gdImagePtr im;\n    FILE *fp = gdTestFileOpen(\"tga/bug00247a.tga\");\n    im = gdImageCreateFromTga(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}", "target": 0}
{"code": "TfLiteStatus PrepareSimple(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  const TfLiteTensor* axis = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, axis != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, axis->type, kTfLiteInt32);\n  if (input->type == kTfLiteInt8) {\n    OpData* data = static_cast<OpData*>(node->user_data);\n    const TfLiteTensor* output = GetOutput(context, node, 0);\n    const double real_multiplier = static_cast<double>(input->params.scale) /\n                                   static_cast<double>(output->params.scale);\n    QuantizeMultiplier(real_multiplier, &data->multiplier, &data->shift);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "rpl_print(netdissect_options *ndo,\n          const struct icmp6_hdr *hdr,\n          const u_char *bp, u_int length)\n{\n        int secured = hdr->icmp6_code & 0x80;\n        int basecode= hdr->icmp6_code & 0x7f;\n        if(secured) {\n                ND_PRINT((ndo, \", (SEC) [worktodo]\"));\n                return;\n        } else {\n                ND_PRINT((ndo, \", (CLR)\"));\n        }\n        switch(basecode) {\n        case ND_RPL_DAG_IS:\n                ND_PRINT((ndo, \"DODAG Information Solicitation\"));\n                if(ndo->ndo_vflag) {\n                }\n                break;\n        case ND_RPL_DAG_IO:\n                ND_PRINT((ndo, \"DODAG Information Object\"));\n                if(ndo->ndo_vflag) {\n                        rpl_dio_print(ndo, bp, length);\n                }\n                break;\n        case ND_RPL_DAO:\n                ND_PRINT((ndo, \"Destination Advertisement Object\"));\n                if(ndo->ndo_vflag) {\n                        rpl_dao_print(ndo, bp, length);\n                }\n                break;\n        case ND_RPL_DAO_ACK:\n                ND_PRINT((ndo, \"Destination Advertisement Object Ack\"));\n                if(ndo->ndo_vflag) {\n                        rpl_daoack_print(ndo, bp, length);\n                }\n                break;\n        default:\n                ND_PRINT((ndo, \"RPL message, unknown code %u\",hdr->icmp6_code));\n                break;\n        }\n\treturn;\n#if 0\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n#endif\n}", "target": 1}
{"code": "ext2_xattr_cache_find(struct inode *inode, struct ext2_xattr_header *header)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tif (!header->h_hash)\n\t\treturn NULL;  \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext2_xattr_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\text2_error(inode->i_sb, \"ext2_xattr_cache_find\",\n\t\t\t\t\"inode %ld: block %ld read error\",\n\t\t\t\tinode->i_ino, (unsigned long) ce->e_block);\n\t\t} else {\n\t\t\tlock_buffer(bh);\n\t\t\tif (le32_to_cpu(HDR(bh)->h_refcount) >\n\t\t\t\t   EXT2_XATTR_REFCOUNT_MAX) {\n\t\t\t\tea_idebug(inode, \"block %ld refcount %d>%d\",\n\t\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t\t  le32_to_cpu(HDR(bh)->h_refcount),\n\t\t\t\t\t  EXT2_XATTR_REFCOUNT_MAX);\n\t\t\t} else if (!ext2_xattr_cmp(header, HDR(bh))) {\n\t\t\t\tea_bdebug(bh, \"b_count=%d\",\n\t\t\t\t\t  atomic_read(&(bh->b_count)));\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\t\treturn bh;\n\t\t\t}\n\t\t\tunlock_buffer(bh);\n\t\t\tbrelse(bh);\n\t\t}\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void nfs4_open_confirm_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (!data->rpc_done)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "check(str, sub, should)\nchar *str;\nmy_regmatch_t sub;\nchar *should;\n{\n\tregister int len;\n\tregister int shlen;\n\tregister char *p;\n\tstatic char grump[500];\n\tregister char *at = NULL;\n\tif (should != NULL && strcmp(should, \"-\") == 0)\n\t\tshould = NULL;\n\tif (should != NULL && should[0] == '@') {\n\t\tat = should + 1;\n\t\tshould = (char*) \"\";\n\t}\n\tif (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_eo == -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_so < 0) ||\n\t\t\t\t(sub.rm_eo != -1 && sub.rm_eo < 0) ) {\n\t\tsprintf(grump, \"start %ld end %ld\", (long)sub.rm_so,\n\t\t\t\t\t\t\t(long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\tif (sub.rm_so == -1 && should == NULL)\n\t\treturn(NULL);\n\tif (sub.rm_so == -1)\n\t\treturn((char*) \"did not match\");\n\tif ((int) sub.rm_eo > (int) strlen(str)) {\n\t\tsprintf(grump, \"start %ld end %ld, past end of string\",\n\t\t\t\t\t(long)sub.rm_so, (long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\tlen = (int)(sub.rm_eo - sub.rm_so);\n\tshlen = (int)strlen(should);\n\tp = str + sub.rm_so;\n\tif (should == NULL) {\n\t\tsprintf(grump, \"matched `%.*s'\", len, p);\n\t\treturn(grump);\n\t}\n\tif (len != shlen || strncmp(p, should, (size_t)shlen) != 0) {\n\t\tsprintf(grump, \"matched `%.*s' instead\", len, p);\n\t\treturn(grump);\n\t}\n\tif (shlen > 0)\n\t\treturn(NULL);\n\tif (at == NULL)\n\t\treturn(NULL);\n\tshlen = strlen(at);\n\tif (shlen == 0)\n\t\tshlen = 1;\t\n\tif (strncmp(p, at, shlen) != 0) {\n\t\tsprintf(grump, \"matched null at `%.20s'\", p);\n\t\treturn(grump);\n\t}\n\treturn(NULL);\n}", "target": 1}
{"code": "void CSecurityTLS::shutdown(bool needbye)\n{\n  if (session && needbye)\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS)\n      vlog.error(\"gnutls_bye failed\");\n  if (anon_cred) {\n    gnutls_anon_free_client_credentials(anon_cred);\n    anon_cred = 0;\n  }\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n    gnutls_global_deinit();\n  }\n}", "target": 1}
{"code": "GF_Err gf_isom_avc_config_update(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex, GF_AVCConfig *cfg)\n{\n\treturn gf_isom_avc_config_update_ex(the_file, trackNumber, DescriptionIndex, cfg, 0, GF_FALSE);\n}", "target": 0}
{"code": "ZEND_API int zend_ts_hash_num_elements(TsHashTable *ht)\n{\n\tint retval;\n\tbegin_read(ht);\n\tretval = zend_hash_num_elements(TS_HASH(ht));\n\tend_read(ht);\n\treturn retval;\n}", "target": 0}
{"code": "void ntlm_write_message_fields_buffer(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->Len > 0)\n\t{\n\t\tStream_SetPosition(s, fields->BufferOffset);\n\t\tStream_Write(s, fields->Buffer, fields->Len);\n\t}\n}", "target": 1}
{"code": "t1mac_output_ascii(char *s, int len)\n{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}", "target": 1}
{"code": "f_indent(typval_T *argvars, typval_T *rettv)\n{\n    linenr_T\tlnum;\n    if (in_vim9script() && check_for_lnum_arg(argvars, 0) == FAIL)\n\treturn;\n    lnum = tv_get_lnum(argvars);\n    if (lnum >= 1 && lnum <= curbuf->b_ml.ml_line_count)\n\trettv->vval.v_number = get_indent_lnum(lnum);\n    else\n    {\n\tif (in_vim9script())\n\t    semsg(_(e_invalid_line_number_nr), lnum);\n\trettv->vval.v_number = -1;\n    }\n}", "target": 0}
{"code": "void CleanWriters(GF_List *writers)\n{\n\twhile (gf_list_count(writers)) {\n\t\tTrackWriter *writer = (TrackWriter*)gf_list_get(writers, 0);\n\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stco);\n\t\tgf_list_del_item(writer->stbl->child_boxes, writer->stsc);\n\t\tgf_isom_box_del(writer->stco);\n\t\tgf_isom_box_del((GF_Box *)writer->stsc);\n\t\tgf_free(writer);\n\t\tgf_list_rem(writers, 0);\n\t}\n}", "target": 0}
{"code": "int Jsi_ObjArraySizer(Jsi_Interp *interp, Jsi_Obj *obj, uint len)\n{\n    int nsiz = len + 1, mod = ALLOC_MOD_SIZE;\n    assert(obj->isarrlist);\n    if (mod>1)\n        nsiz = nsiz + ((mod-1) - (nsiz + mod - 1)%mod);\n    if (nsiz > MAX_ARRAY_LIST) {\n        Jsi_LogError(\"array size too large\");\n        return 0;\n    }\n    if (len >= obj->arrMaxSize) {\n        int oldsz = (nsiz-obj->arrMaxSize);\n        obj->arr = (Jsi_Value**)Jsi_Realloc(obj->arr, nsiz*sizeof(Jsi_Value*));\n        memset(obj->arr+obj->arrMaxSize, 0, oldsz*sizeof(Jsi_Value*));\n        obj->arrMaxSize = nsiz;\n    }\n    if (len>obj->arrCnt)\n        obj->arrCnt = len;\n    return nsiz;\n}", "target": 1}
{"code": "BGD_DECLARE(gdImagePtr) gdImageCreateFromTgaCtx(gdIOCtx* ctx)\n{\n\tint bitmap_caret = 0;\n\toTga *tga = NULL;\n\tvolatile gdImagePtr image = NULL;\n\tint x = 0;\n\tint y = 0;\n\ttga = (oTga *) gdMalloc(sizeof(oTga));\n\tif (!tga) {\n\t\treturn NULL;\n\t}\n\ttga->bitmap = NULL;\n\ttga->ident = NULL;\n\tif (read_header_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\tif (read_image_tga(ctx, tga) < 0) {\n\t\tfree_tga(tga);\n\t\treturn NULL;\n\t}\n\timage = gdImageCreateTrueColor((int)tga->width, (int)tga->height );\n\tif (image == 0) {\n\t\tfree_tga( tga );\n\t\treturn NULL;\n\t}\n\tif (tga->alphabits) {\n\t\tgdImageAlphaBlending(image, 0);\n\t\tgdImageSaveAlpha(image, 1);\n\t}\n\tfor (y = 0; y < tga->height; y++) {\n\t\tregister int *tpix = image->tpixels[y];\n\t\tfor ( x = 0; x < tga->width; x++, tpix++) {\n\t\t\tif (tga->bits == TGA_BPP_24) {\n\t\t\t\t*tpix = gdTrueColor(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret]);\n\t\t\t\tbitmap_caret += 3;\n\t\t\t} else if (tga->bits == TGA_BPP_32 || tga->alphabits) {\n\t\t\t\tregister int a = tga->bitmap[bitmap_caret + 3];\n\t\t\t\t*tpix = gdTrueColorAlpha(tga->bitmap[bitmap_caret + 2], tga->bitmap[bitmap_caret + 1], tga->bitmap[bitmap_caret], gdAlphaMax - (a >> 1));\n\t\t\t\tbitmap_caret += 4;\n\t\t\t}\n\t\t}\n\t}\n\tif (tga->flipv && tga->fliph) {\n\t\tgdImageFlipBoth(image);\n\t} else if (tga->flipv) {\n\t\tgdImageFlipVertical(image);\n\t} else if (tga->fliph) {\n\t\tgdImageFlipHorizontal(image);\n\t}\n\tfree_tga(tga);\n\treturn image;\n}", "target": 1}
{"code": "std::wstring CreateUniqueTempDirectory()\n{\n    wchar_t tmpdir[MAX_PATH+1];\n    if ( GetTempPath(MAX_PATH+1, tmpdir) == 0 )\n        throw Win32Exception(\"Cannot create temporary directory\");\n    for ( ;; )\n    {\n        std::wstring dir(tmpdir);\n        dir += L\"Update-\";\n        UUID uuid;\n        UuidCreate(&uuid);\n        RPC_WSTR uuidStr;\n        RPC_STATUS status = UuidToString(&uuid, &uuidStr);\n        dir += reinterpret_cast<wchar_t*>(uuidStr);\n        RpcStringFree(&uuidStr);\n        if ( CreateDirectory(dir.c_str(), NULL) )\n            return dir;\n        else if ( GetLastError() != ERROR_ALREADY_EXISTS )\n            throw Win32Exception(\"Cannot create temporary directory\");\n    }\n}", "target": 1}
{"code": "static int adpt_device_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tu32 msg[4];\n\tu32 rcode;\n\tint old_state;\n\tstruct adpt_device* d = cmd->device->hostdata;\n\tpHba = (void*) cmd->device->host->hostdata[0];\n\tprintk(KERN_INFO\"%s: Trying to reset device\\n\",pHba->name);\n\tif (!d) {\n\t\tprintk(KERN_INFO\"%s: Reset Device: Device Not found\\n\",pHba->name);\n\t\treturn FAILED;\n\t}\n\tmemset(msg, 0, sizeof(msg));\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = (I2O_DEVICE_RESET<<24|HOST_TID<<12|d->tid);\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\told_state = d->state;\n\td->state |= DPTI_DEV_RESET;\n\trcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);\n\td->state = old_state;\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tif(rcode == -EOPNOTSUPP ){\n\t\t\tprintk(KERN_INFO\"%s: Device reset not supported\\n\",pHba->name);\n\t\t\treturn FAILED;\n\t\t}\n\t\tprintk(KERN_INFO\"%s: Device reset failed\\n\",pHba->name);\n\t\treturn FAILED;\n\t} else {\n\t\tprintk(KERN_INFO\"%s: Device reset successful\\n\",pHba->name);\n\t\treturn SUCCESS;\n\t}\n}", "target": 1}
{"code": "void big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\tkey_payload_reserve(key, 0);\n\tif (key_is_instantiated(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}", "target": 1}
{"code": "bgp_capability_receive (struct peer *peer, bgp_size_t size)\n{\n  u_char *pnt;\n  int ret;\n  pnt = stream_pnt (peer->ibuf);\n  if (BGP_DEBUG (normal, NORMAL))\n    zlog_debug (\"%s rcv CAPABILITY\", peer->host);\n  if (! CHECK_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV))\n    {\n      plog_err (peer->log, \"%s [Error] BGP dynamic capability is not enabled\",\n\t\tpeer->host);\n      bgp_notify_send (peer,\n\t\t       BGP_NOTIFY_HEADER_ERR,\n\t\t       BGP_NOTIFY_HEADER_BAD_MESTYPE);\n      return;\n    }\n  if (peer->status != Established)\n    {\n      plog_err (peer->log,\n\t\t\"%s [Error] Dynamic capability packet received under status %s\", peer->host, LOOKUP (bgp_status_msg, peer->status));\n      bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);\n      return;\n    }\n  ret = bgp_capability_msg_parse (peer, pnt, size);\n}", "target": 1}
{"code": "int ossl_dsa_check_pub_key_partial(const DSA *dsa, const BIGNUM *pub_key, int *ret)\n{\n    if (!dsa_precheck_params(dsa, ret))\n        return 0;\n    return ossl_ffc_validate_public_key_partial(&dsa->params, pub_key, ret)\n           && *ret == 0;\n}", "target": 0}
{"code": "static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)\n{\n\tstruct block_device *bdev;\n\tchar b[BDEVNAME_SIZE];\n\tbdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);\n\tif (IS_ERR(bdev))\n\t\tgoto fail;\n\treturn bdev;\nfail:\n\text3_msg(sb, \"error: failed to open journal device %s: %ld\",\n\t\t__bdevname(dev, b), PTR_ERR(bdev));\n\treturn NULL;\n}", "target": 1}
{"code": "scrypt_SHA256_Update(struct SHA256_CTX * ctx, const void *in, size_t len)\n{\n  uint32_t bitlen[2];\n  uint32_t r;\n  const unsigned char *src = (unsigned char *) in;\n  r = (ctx->count[1] >> 3) & 0x3f;\n  bitlen[1] = ((uint32_t)len) << 3;\n  bitlen[0] = (uint32_t)(len >> 29);\n  if ((ctx->count[1] += bitlen[1]) < bitlen[1])\n    ctx->count[0]++;\n  ctx->count[0] += bitlen[0];\n  if (len < 64 - r) {\n    memcpy(&ctx->buf[r], src, len);\n    return;\n  }\n  memcpy(&ctx->buf[r], src, 64 - r);\n  SHA256_Transform(ctx->state, ctx->buf);\n  src += 64 - r;\n  len -= 64 - r;\n  while (len >= 64) {\n    SHA256_Transform(ctx->state, src);\n    src += 64;\n    len -= 64;\n  }\n  memcpy(ctx->buf, src, len);\n}", "target": 1}
{"code": "static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,\n\t\t\t\t\t\tint id)\n{\n\tstruct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);\n\tif (IS_ERR(ipcp))\n\t\treturn ERR_CAST(ipcp);\n\treturn container_of(ipcp, struct sem_array, sem_perm);\n}", "target": 1}
{"code": "utf16le_mbc_to_code(const UChar* p, const UChar* end)\n{\n  OnigCodePoint code;\n  UChar c0 = *p;\n  UChar c1 = *(p+1);\n  if (UTF16_IS_SURROGATE_FIRST(c1)) {\n    if (end - p < 4) return 0;\n    code = ((((c1 - 0xd8) << 2) + ((c0  & 0xc0) >> 6) + 1) << 16)\n         + ((((c0 & 0x3f) << 2) + (p[3] - 0xdc)) << 8)\n         + p[2];\n  }\n  else {\n    code = c1 * 256 + p[0];\n  }\n  return code;\n}", "target": 0}
{"code": "static const tls12_hash_info *tls12_get_hash_info(unsigned char hash_alg)\n\t{\n\tif (hash_alg == 0)\n\t\treturn NULL;\n\tif (hash_alg > sizeof(tls12_md_info)/sizeof(tls12_md_info[0]))\n\t\treturn NULL;\n\treturn tls12_md_info + hash_alg - 1;\n\t}", "target": 0}
{"code": "SanMatcherPtr createStringSanMatcher(\n    envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher const& matcher) {\n  static_assert(envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::SanType_MAX ==\n                4);\n  switch (matcher.san_type()) {\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_DNS, matcher.matcher())};\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_EMAIL, matcher.matcher())};\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_URI, matcher.matcher())};\n  case envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS:\n    return SanMatcherPtr{std::make_unique<StringSanMatcher>(GEN_IPADD, matcher.matcher())};\n  default:\n    NOT_REACHED_GCOVR_EXCL_LINE;\n  }\n}", "target": 0}
{"code": "static Jsi_RC ObjListifyCallback(Jsi_Tree *tree, Jsi_TreeEntry *hPtr, void *data)\n{\n    Jsi_Interp *interp = tree->opts.interp;\n    Jsi_Obj *obj = (Jsi_Obj*)data;\n    int n;\n    if (!hPtr->f.bits.dontenum) {\n        char *ep = NULL, *cp = (char*)Jsi_TreeKeyGet(hPtr);\n        if (!cp || !isdigit(*cp))\n            return JSI_OK;\n        n = (int)strtol(cp, &ep, 0);\n        if (n<0 || n >= interp->maxArrayList)\n            return JSI_OK;\n        hPtr->f.bits.isarrlist = 1;\n        if (Jsi_ObjArraySizer(interp, obj, n) <= 0) \n            return Jsi_LogError(\"too long\");\n        obj->arr[n] = (Jsi_Value*)Jsi_TreeValueGet(hPtr);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "struct resource_pool *dcn10_create_resource_pool(\n\t\tconst struct dc_init_data *init_data,\n\t\tstruct dc *dc)\n{\n\tstruct dcn10_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dcn10_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(init_data->num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "userlist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(userlist_matches, SUDOERS_DEBUG_MATCH);\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tif ((matched = user_matches(parse_tree, pw, m)) != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static int ipv4ll_recv_arp_packet(GDHCPClient *dhcp_client)\n{\n\tint bytes;\n\tstruct ether_arp arp;\n\tuint32_t ip_requested;\n\tint source_conflict;\n\tint target_conflict;\n\tguint timeout_ms;\n\tmemset(&arp, 0, sizeof(arp));\n\tbytes = read(dhcp_client->listener_sockfd, &arp, sizeof(arp));\n\tif (bytes < 0)\n\t\treturn bytes;\n\tif (arp.arp_op != htons(ARPOP_REPLY) &&\n\t\t\tarp.arp_op != htons(ARPOP_REQUEST))\n\t\treturn -EINVAL;\n\tif (memcmp(arp.arp_sha, dhcp_client->mac_address, ETH_ALEN) == 0)\n\t\treturn 0;\n\tip_requested = htonl(dhcp_client->requested_ip);\n\tsource_conflict = !memcmp(arp.arp_spa, &ip_requested,\n\t\t\t\t\t\tsizeof(ip_requested));\n\ttarget_conflict = !memcmp(arp.arp_tpa, &ip_requested,\n\t\t\t\tsizeof(ip_requested));\n\tif (!source_conflict && !target_conflict)\n\t\treturn 0;\n\tdhcp_client->conflicts++;\n\tdebug(dhcp_client, \"IPV4LL conflict detected\");\n\tif (dhcp_client->state == IPV4LL_MONITOR) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\tdhcp_client->state = IPV4LL_DEFEND;\n\t\tdebug(dhcp_client, \"DEFEND mode conflicts : %d\",\n\t\t\tdhcp_client->conflicts);\n\t\tsend_announce_packet(dhcp_client);\n\t\treturn 0;\n\t}\n\tif (dhcp_client->state == IPV4LL_DEFEND) {\n\t\tif (!source_conflict)\n\t\t\treturn 0;\n\t\telse if (dhcp_client->ipv4ll_lost_cb)\n\t\t\tdhcp_client->ipv4ll_lost_cb(dhcp_client,\n\t\t\t\t\t\tdhcp_client->ipv4ll_lost_data);\n\t}\n\tipv4ll_stop(dhcp_client);\n\tif (dhcp_client->conflicts < MAX_CONFLICTS)\n\t\ttimeout_ms = __connman_util_random_delay_ms(PROBE_WAIT);\n\telse\n\t\ttimeout_ms = RATE_LIMIT_INTERVAL * 1000;\n\tdhcp_client->retry_times++;\n\tdhcp_client->timeout =\n\t\tg_timeout_add_full(G_PRIORITY_HIGH,\n\t\t\t\ttimeout_ms,\n\t\t\t\tsend_probe_packet,\n\t\t\t\tdhcp_client,\n\t\t\t\tNULL);\n\treturn 0;\n}", "target": 0}
{"code": "    ExprMatchTest() : _expCtx(new ExpressionContextForTest()) {}", "target": 0}
{"code": "string PacketReader::getLabel(unsigned int recurs)\n{\n  string ret;\n  ret.reserve(40);\n  getLabelFromContent(d_content, d_pos, ret, recurs++);\n  return ret;\n}", "target": 1}
{"code": "int inet6_sk_rebuild_header(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct dst_entry *dst;\n\tdst = __sk_dst_check(sk, np->dst_cookie);\n\tif (!dst) {\n\t\tstruct inet_sock *inet = inet_sk(sk);\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = sk->sk_protocol;\n\t\tfl6.daddr = sk->sk_v6_daddr;\n\t\tfl6.saddr = np->saddr;\n\t\tfl6.flowlabel = np->flow_label;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = sk->sk_mark;\n\t\tfl6.fl6_dport = inet->inet_dport;\n\t\tfl6.fl6_sport = inet->inet_sport;\n\t\tsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst)) {\n\t\t\tsk->sk_route_caps = 0;\n\t\t\tsk->sk_err_soft = -PTR_ERR(dst);\n\t\t\treturn PTR_ERR(dst);\n\t\t}\n\t\t__ip6_dst_store(sk, dst, NULL, NULL);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int ip_identify_match_check(void *obj, void *arg, int flags)\n{\n\tstruct ip_identify_match *identify = obj;\n\tstruct ast_sockaddr_with_tp *addr_with_tp = arg;\n\tstruct ast_sockaddr address = addr_with_tp->addr;\n\tint sense;\n\tsense = ast_apply_ha(identify->matches, &address);\n\tif (sense != AST_SENSE_ALLOW) {\n\t\tast_debug(3, \"Address %s matches identify '%s'\\n\",\n\t\t\t\tast_sockaddr_stringify(&address),\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\tif (ast_strlen_zero(identify->transport) || !strcasecmp(identify->transport, addr_with_tp->tp)) {\n\t\t\tast_debug(3, \"Transport %s matches identify '%s'\\n\",\n\t\t\t\taddr_with_tp->tp,\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\t\treturn CMP_MATCH;\n\t\t} else {\n\t\t\tast_debug(3, \"Transport %s match not matched identify '%s'\\n\",\n\t\t\t\taddr_with_tp->tp,\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tast_debug(3, \"Address %s does not match identify '%s'\\n\",\n\t\t\t\tast_sockaddr_stringify(&address),\n\t\t\t\tast_sorcery_object_get_id(identify));\n\t\treturn 0;\n\t}\n}", "target": 1}
{"code": "mes_lookup (struct message *meslist, int max, int index)\n{\n  if ((index >= 0) && (index < max) && (meslist[index].key == index))\n    return meslist[index].str;\n  {\n    int i;\n    for (i = 0; i < max; i++, meslist++)\n      {\n\tif (meslist->key == index)\n\t  {\n\t    zlog_warn(\"message index %d [%s] found in position %d (max is %d)\",\n\t\t      index, meslist->str, i, max);\n\t    return meslist->str;\n\t  }\n      }\n  }\n  zlog_err(\"message index %d not found (max is %d)\", index, max);\n  return NULL;\n}", "target": 1}
{"code": "no_peephole(codegen_scope *s)\n{\n  return no_optimize(s) || s->lastlabel == s->pc || s->pc == 0 || s->pc == s->lastpc;\n}", "target": 0}
{"code": "static int __init big_key_crypto_init(void)\n{\n\tint ret = -EINVAL;\n\tbig_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);\n\tif (IS_ERR(big_key_rng)) {\n\t\tbig_key_rng = NULL;\n\t\treturn -EFAULT;\n\t}\n\tret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));\n\tif (ret)\n\t\tgoto error;\n\tbig_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,\n\t\t\t\t\t\t 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_skcipher)) {\n\t\tbig_key_skcipher = NULL;\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tcrypto_free_rng(big_key_rng);\n\tbig_key_rng = NULL;\n\treturn ret;\n}", "target": 1}
{"code": "static inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\tget_futex_key_refs(&q->key);\n\thb = hash_futex(&q->key);\n\tq->lock_ptr = &hb->lock;\n\tspin_lock(&hb->lock);\n\treturn hb;\n}", "target": 1}
{"code": "static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\tBUG_ON(client != handle->client);\n\tvalid_handle = ion_handle_validate(client, handle);\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\treturn;\n\t}\n\tion_handle_put_nolock(handle);\n}", "target": 0}
{"code": "TensorBuffer* FromProtoField<ResourceHandle>(Allocator* a,\n                                             const TensorProto& in, int64_t n) {\n  CHECK_GT(n, 0);\n  Buffer<ResourceHandle>* buf = new Buffer<ResourceHandle>(a, n);\n  ResourceHandle* data = buf->template base<ResourceHandle>();\n  if (data == nullptr) {\n    buf->Unref();\n    return nullptr;\n  }\n  const int64_t in_n = ProtoHelper<ResourceHandle>::NumElements(in);\n  if (in_n <= 0) {\n    std::fill_n(data, n, ResourceHandle());\n  } else {\n    const int64_t real_n = n < in_n ? n : in_n;\n    for (int64_t i = 0; i < real_n; ++i) {\n      Status s = ResourceHandle::BuildResourceHandle(in.resource_handle_val(i),\n                                                     &data[i]);\n      if (!s.ok()) {\n        LOG(ERROR) << \"Could not decode resource handle from proto \\\"\"\n                   << in.resource_handle_val(i).ShortDebugString()\n                   << \"\\\", returned status: \" << s.ToString();\n        buf->Unref();\n        return nullptr;\n      }\n    }\n    for (int64_t i = in_n; i < n; ++i) {\n      data[i] = ResourceHandle();\n    }\n  }\n  return buf;\n}", "target": 0}
{"code": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_realloc called with %x,%zu\\n\", ptr, size));\n\tresult = realloc(ptr, size);\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\n\treturn result;\n}", "target": 1}
{"code": "static void __evtchn_fifo_handle_events(unsigned cpu, bool drop)\n{\n\tstruct evtchn_fifo_control_block *control_block;\n\tunsigned long ready;\n\tunsigned q;\n\tcontrol_block = per_cpu(cpu_control_block, cpu);\n\tready = xchg(&control_block->ready, 0);\n\twhile (ready) {\n\t\tq = find_first_bit(&ready, EVTCHN_FIFO_MAX_QUEUES);\n\t\tconsume_one_event(cpu, control_block, q, &ready, drop);\n\t\tready |= xchg(&control_block->ready, 0);\n\t}\n}", "target": 1}
{"code": "void hexdump(msg_info msg_info, const char *mem, unsigned int len)\n{\n    unsigned int i, j;\n    char str[10 + HEXDUMP_COLS * 4 + 2];\n    int c = 0; \n    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)\n    {\n        if(i % HEXDUMP_COLS == 0)\n            c += sprintf(&str[c], \"0x%06x: \", i);\n        if(i < len)\n            c += sprintf(&str[c], \"%02x \", 0xFF & mem[i]);\n        else \n            c+= sprintf(&str[c], \"   \");\n        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1)) {\n            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++) {\n                if(j >= len) \n                    str[c++] = ' ';\n                else if(isprint(mem[j])) \n                    str[c++] = 0xFF & mem[j];\n                else \n                    str[c++] = '.';\n            }\n            str[c++] = '\\n';\n            str[c++] = 0;\n            print_message(msg_info, str);\n            c = 0;\n        }\n    }\n}", "target": 1}
{"code": "Status SpectrogramShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 2, &input));\n  int32_t window_size;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"window_size\", &window_size));\n  if (window_size <= 1) {\n    return errors::InvalidArgument(\"window size must be > 1, got \",\n                                   window_size);\n  }\n  int32_t stride;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"stride\", &stride));\n  if (stride <= 0) {\n    return errors::InvalidArgument(\"stride must be strictly positive, got \",\n                                   stride);\n  }\n  DimensionHandle input_length = c->Dim(input, 0);\n  DimensionHandle input_channels = c->Dim(input, 1);\n  DimensionHandle output_length;\n  if (!c->ValueKnown(input_length)) {\n    output_length = c->UnknownDim();\n  } else {\n    const int64_t input_length_value = c->Value(input_length);\n    const int64_t length_minus_window = (input_length_value - window_size);\n    int64_t output_length_value;\n    if (length_minus_window < 0) {\n      output_length_value = 0;\n    } else {\n      output_length_value = 1 + (length_minus_window / stride);\n    }\n    output_length = c->MakeDim(output_length_value);\n  }\n  DimensionHandle output_channels =\n      c->MakeDim(1 + NextPowerOfTwo(window_size) / 2);\n  c->set_output(0,\n                c->MakeShape({input_channels, output_length, output_channels}));\n  return OkStatus();\n}", "target": 0}
{"code": "DLLIMPORT int cfg_rmnsec(cfg_t *cfg, const char *name, unsigned int index)\n{\n\treturn cfg_opt_rmnsec(cfg_getopt(cfg, name), index);\n}", "target": 0}
{"code": "static bool add_ref_to_table_cond(THD *thd, JOIN_TAB *join_tab)\n{\n  DBUG_ENTER(\"add_ref_to_table_cond\");\n  if (!join_tab->ref.key_parts)\n    DBUG_RETURN(FALSE);\n  Item_cond_and *cond= new (thd->mem_root) Item_cond_and(thd);\n  TABLE *table=join_tab->table;\n  int error= 0;\n  if (!cond)\n    DBUG_RETURN(TRUE);\n  for (uint i=0 ; i < join_tab->ref.key_parts ; i++)\n  {\n    Field *field=table->field[table->key_info[join_tab->ref.key].key_part[i].\n\t\t\t      fieldnr-1];\n    Item *value=join_tab->ref.items[i];\n    cond->add(new (thd->mem_root)\n              Item_func_equal(thd, new (thd->mem_root) Item_field(thd, field),\n                              value),\n              thd->mem_root);\n  }\n  if (thd->is_fatal_error)\n    DBUG_RETURN(TRUE);\n  if (!cond->fixed)\n  {\n    Item *tmp_item= (Item*) cond;\n    cond->fix_fields(thd, &tmp_item);\n    DBUG_ASSERT(cond == tmp_item);\n  }\n  if (join_tab->select)\n  {\n    Item *UNINIT_VAR(cond_copy);\n    if (join_tab->select->pre_idx_push_select_cond)\n      cond_copy= cond->copy_andor_structure(thd);\n    if (join_tab->select->cond)\n      error=(int) cond->add(join_tab->select->cond, thd->mem_root);\n    join_tab->select->cond= cond;\n    if (join_tab->select->pre_idx_push_select_cond)\n    {\n      Item *new_cond= and_conds(thd, cond_copy,\n                                join_tab->select->pre_idx_push_select_cond);\n      if (!new_cond->fixed && new_cond->fix_fields(thd, &new_cond))\n        error= 1;\n      join_tab->pre_idx_push_select_cond=\n        join_tab->select->pre_idx_push_select_cond= new_cond;\n    }\n    join_tab->set_select_cond(cond, __LINE__);\n  }\n  else if ((join_tab->select= make_select(join_tab->table, 0, 0, cond,\n                                          (SORT_INFO*) 0, 0, &error)))\n    join_tab->set_select_cond(cond, __LINE__);\n  DBUG_RETURN(error ? TRUE : FALSE);\n}", "target": 0}
{"code": "int sub__add(struct mosquitto *context, const char *sub, uint8_t qos, uint32_t identifier, int options)\n{\n\tint rc = 0;\n\tstruct mosquitto__subhier *subhier;\n\tconst char *sharename = NULL;\n\tchar *local_sub;\n\tchar **topics;\n\tsize_t topiclen;\n\tassert(sub);\n\trc = sub__topic_tokenise(sub, &local_sub, &topics, &sharename);\n\tif(rc) return rc;\n\ttopiclen = strlen(topics[0]);\n\tif(topiclen > UINT16_MAX){\n\t\tmosquitto__free(local_sub);\n\t\tmosquitto__free(topics);\n\t\treturn MOSQ_ERR_INVAL;\n\t}\n\tHASH_FIND(hh, db.subs, topics[0], topiclen, subhier);\n\tif(!subhier){\n\t\tsubhier = sub__add_hier_entry(NULL, &db.subs, topics[0], (uint16_t)topiclen);\n\t\tif(!subhier){\n\t\t\tmosquitto__free(local_sub);\n\t\t\tmosquitto__free(topics);\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t}\n\trc = sub__add_context(context, sub, qos, identifier, options, subhier, topics, sharename);\n\tmosquitto__free(local_sub);\n\tmosquitto__free(topics);\n\treturn rc;\n}", "target": 1}
{"code": "  explicit QuantizeAndDequantizeOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"signed_input\", &signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"num_bits\", &num_bits_));\n    OP_REQUIRES(ctx, num_bits_ > 0 && num_bits_ < (signed_input_ ? 62 : 63),\n                errors::InvalidArgument(\"num_bits is out of range: \", num_bits_,\n                                        \" with signed_input_ \", signed_input_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"range_given\", &range_given_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_min\", &input_min_));\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"input_max\", &input_max_));\n    if (range_given_) {\n      OP_REQUIRES(\n          ctx, input_min_ <= input_max_,\n          errors::InvalidArgument(\"Invalid range: input_min \", input_min_,\n                                  \" > input_max \", input_max_));\n    }\n  }", "target": 1}
{"code": "void set_pmd_migration_entry(struct page_vma_mapped_walk *pvmw,\n\t\tstruct page *page)\n{\n\tstruct vm_area_struct *vma = pvmw->vma;\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long address = pvmw->address;\n\tpmd_t pmdval;\n\tswp_entry_t entry;\n\tpmd_t pmdswp;\n\tif (!(pvmw->pmd && !pvmw->pte))\n\t\treturn;\n\tmmu_notifier_invalidate_range_start(mm, address,\n\t\t\taddress + HPAGE_PMD_SIZE);\n\tflush_cache_range(vma, address, address + HPAGE_PMD_SIZE);\n\tpmdval = *pvmw->pmd;\n\tpmdp_invalidate(vma, address, pvmw->pmd);\n\tif (pmd_dirty(pmdval))\n\t\tset_page_dirty(page);\n\tentry = make_migration_entry(page, pmd_write(pmdval));\n\tpmdswp = swp_entry_to_pmd(entry);\n\tif (pmd_soft_dirty(pmdval))\n\t\tpmdswp = pmd_swp_mksoft_dirty(pmdswp);\n\tset_pmd_at(mm, address, pvmw->pmd, pmdswp);\n\tpage_remove_rmap(page, true);\n\tput_page(page);\n\tmmu_notifier_invalidate_range_end(mm, address,\n\t\t\taddress + HPAGE_PMD_SIZE);\n}", "target": 0}
{"code": "void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {\n\tbloc = *offset;\n\tsend(huff->loc[ch], NULL, fout);\n\t*offset = bloc;\n}", "target": 1}
{"code": "GF_Err paen_box_size(GF_Box *s)\n{\n\treturn GF_OK;\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    BoxBlurContext *s = ctx->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int plane;\n    int cw = FF_CEIL_RSHIFT(inlink->w, s->hsub), ch = FF_CEIL_RSHIFT(in->height, s->vsub);\n    int w[4] = { inlink->w, cw, cw, inlink->w };\n    int h[4] = { in->height, ch, ch, in->height };\n    out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n    if (!out) {\n        av_frame_free(&in);\n        return AVERROR(ENOMEM);\n    }\n    av_frame_copy_props(out, in);\n    for (plane = 0; in->data[plane] && plane < 4; plane++)\n        hblur(out->data[plane], out->linesize[plane],\n              in ->data[plane], in ->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n    for (plane = 0; in->data[plane] && plane < 4; plane++)\n        vblur(out->data[plane], out->linesize[plane],\n              out->data[plane], out->linesize[plane],\n              w[plane], h[plane], s->radius[plane], s->power[plane],\n              s->temp);\n    av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "static int bson_string_is_db_ref( const unsigned char *string, const int length ) {\n    int result = 0;\n    if( length >= 4 ) {\n        if( string[1] == 'r' && string[2] == 'e' && string[3] == 'f' )\n            result = 1;\n    }\n    else if( length >= 3 ) {\n        if( string[1] == 'i' && string[2] == 'd' )\n            result = 1;\n        else if( string[1] == 'd' && string[2] == 'b' )\n            result = 1;\n    }\n    return result;\n}", "target": 1}
{"code": "int ib_update_cm_av(struct ib_cm_id *id, const u8 *smac, const u8 *alt_smac)\n{\n\tstruct cm_id_private *cm_id_priv;\n\tcm_id_priv = container_of(id, struct cm_id_private, id);\n\tif (smac != NULL)\n\t\tmemcpy(cm_id_priv->av.smac, smac, sizeof(cm_id_priv->av.smac));\n\tif (alt_smac != NULL)\n\t\tmemcpy(cm_id_priv->alt_av.smac, alt_smac,\n\t\t       sizeof(cm_id_priv->alt_av.smac));\n\treturn 0;\n}", "target": 1}
{"code": "int JOIN::optimize()\n{\n  int res= 0;\n  create_explain_query_if_not_exists(thd->lex, thd->mem_root);\n  join_optimization_state init_state= optimization_state;\n  if (select_lex->pushdown_select)\n  {\n    if (!(select_options & SELECT_DESCRIBE))\n    {\n      res= select_lex->pushdown_select->init();\n    }\n    with_two_phase_optimization= false;\n  }\n  else if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)\n    res= optimize_stage2();\n  else\n  {\n    if (optimization_state != JOIN::NOT_OPTIMIZED)\n      return FALSE;\n    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;\n    res= optimize_inner();\n  }\n  if (!with_two_phase_optimization ||\n      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)\n  {\n    if (!res && have_query_plan != QEP_DELETED)\n      res= build_explain();\n    optimization_state= JOIN::OPTIMIZATION_DONE;\n  }\n  return res;\n}", "target": 0}
{"code": "bool SecureSocket::verify_cert_fingerprint(const barrier::fs::path& fingerprint_db_path)\n{\n    barrier::FingerprintData fingerprint_sha1, fingerprint_sha256;\n    try {\n        auto* cert = SSL_get_peer_certificate(m_ssl->m_ssl);\n        fingerprint_sha1 = barrier::get_ssl_cert_fingerprint(cert,\n                                                             barrier::FingerprintType::SHA1);\n        fingerprint_sha256 = barrier::get_ssl_cert_fingerprint(cert,\n                                                               barrier::FingerprintType::SHA256);\n    } catch (const std::exception& e) {\n        LOG((CLOG_ERR \"%s\", e.what()));\n        return false;\n    }\n    LOG((CLOG_NOTE \"server fingerprint (SHA1): %s (SHA256): %s\",\n         barrier::format_ssl_fingerprint(fingerprint_sha1.data).c_str(),\n         barrier::format_ssl_fingerprint(fingerprint_sha256.data).c_str()));\n    LOG((CLOG_NOTE \"fingerprint_db_path: %s\", fingerprint_db_path.u8string().c_str()));\n    barrier::FingerprintDatabase db;\n    db.read(fingerprint_db_path);\n    if (!db.fingerprints().empty()) {\n        LOG((CLOG_NOTE \"Read %d fingerprints from: %s\", db.fingerprints().size(),\n             fingerprint_db_path.u8string().c_str()));\n    } else {\n        LOG((CLOG_NOTE \"Could not read fingerprints from: %s\",\n             fingerprint_db_path.u8string().c_str()));\n    }\n    if (db.is_trusted(fingerprint_sha256)) {\n        LOG((CLOG_NOTE \"Fingerprint matches trusted fingerprint\"));\n        return true;\n    } else {\n        LOG((CLOG_NOTE \"Fingerprint does not match trusted fingerprint\"));\n        return false;\n    }\n}", "target": 1}
{"code": "static void dp8393x_register_types(void)\n{\n    type_register_static(&dp8393x_info);\n}", "target": 0}
{"code": "bits_at(const OnigCodePoint *c, const int n)\n{\n  return bits_of(c[n / 3], n % 3);\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::SetNeedsFlush() {\n  if (view_)\n    view_->OnSetNeedsFlushInput();\n}", "target": 0}
{"code": "static int fsmOpenat(int dirfd, const char *path, int flags)\n{\n    struct stat lsb, sb;\n    int sflags = flags | O_NOFOLLOW;\n    int fd = openat(dirfd, path, sflags);\n    if (fd < 0 && errno == ELOOP && flags != sflags) {\n\tint ffd = openat(dirfd, path, flags);\n\tif (ffd >= 0 && fstatat(dirfd, path, &lsb, AT_SYMLINK_NOFOLLOW) == 0) {\n\t    if (fstat(ffd, &sb) == 0) {\n\t\tif (lsb.st_uid == 0 || lsb.st_uid == sb.st_uid) {\n\t\t    fd = ffd;\n\t\t} else {\n\t\t    close(ffd);\n\t\t}\n\t    }\n\t}\n    }\n    return fd;\n}", "target": 0}
{"code": "tsetcap(int cap, int flags)\n{\n    if (tccan(cap) && !isset(SINGLELINEZLE) &&\n        !(termflags & (TERM_NOUP|TERM_BAD|TERM_UNKNOWN))) {\n\tswitch (flags & TSC_OUTPUT_MASK) {\n\tcase TSC_RAW:\n\t    tputs(tcstr[cap], 1, putraw);\n\t    break;\n\tcase 0:\n\tdefault:\n\t    tputs(tcstr[cap], 1, putshout);\n\t    break;\n\tcase TSC_PROMPT:\n\t    if (!bv->dontcount) {\n\t\taddbufspc(1);\n\t\t*bv->bp++ = Inpar;\n\t    }\n\t    tputs(tcstr[cap], 1, putstr);\n\t    if (!bv->dontcount) {\n\t\tint glitch = 0;\n\t\tif (cap == TCSTANDOUTBEG || cap == TCSTANDOUTEND)\n\t\t    glitch = tgetnum(\"sg\");\n\t\telse if (cap == TCUNDERLINEBEG || cap == TCUNDERLINEEND)\n\t\t    glitch = tgetnum(\"ug\");\n\t\tif(glitch < 0)\n\t\t    glitch = 0;\n\t\taddbufspc(glitch + 1);\n\t\twhile(glitch--)\n\t\t    *bv->bp++ = Nularg;\n\t\t*bv->bp++ = Outpar;\n\t    }\n\t    break;\n\t}\n\tif (flags & TSC_DIRTY) {\n\t    flags &= ~TSC_DIRTY;\n\t    if (txtisset(TXTBOLDFACE) && cap != TCBOLDFACEBEG)\n\t\ttsetcap(TCBOLDFACEBEG, flags);\n\t    if (txtisset(TXTSTANDOUT))\n\t\ttsetcap(TCSTANDOUTBEG, flags);\n\t    if (txtisset(TXTUNDERLINE))\n\t\ttsetcap(TCUNDERLINEBEG, flags);\n\t    if (txtisset(TXTFGCOLOUR))\n\t\tset_colour_attribute(txtattrmask, COL_SEQ_FG, TSC_PROMPT);\n\t    if (txtisset(TXTBGCOLOUR))\n\t\tset_colour_attribute(txtattrmask, COL_SEQ_BG, TSC_PROMPT);\n\t}\n    }\n}", "target": 0}
{"code": "ptaReadStream(FILE  *fp)\n{\nchar       typestr[128];\nl_int32    i, n, ix, iy, type, version;\nl_float32  x, y;\nPTA       *pta;\n    PROCNAME(\"ptaReadStream\");\n    if (!fp)\n        return (PTA *)ERROR_PTR(\"stream not defined\", procName, NULL);\n    if (fscanf(fp, \"\\n Pta Version %d\\n\", &version) != 1)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (version != PTA_VERSION_NUMBER)\n        return (PTA *)ERROR_PTR(\"invalid pta version\", procName, NULL);\n    if (fscanf(fp, \" Number of pts = %d; format = %s\\n\", &n, typestr) != 2)\n        return (PTA *)ERROR_PTR(\"not a pta file\", procName, NULL);\n    if (!strcmp(typestr, \"float\"))\n        type = 0;\n    else  \n        type = 1;\n    if ((pta = ptaCreate(n)) == NULL)\n        return (PTA *)ERROR_PTR(\"pta not made\", procName, NULL);\n    for (i = 0; i < n; i++) {\n        if (type == 0) {  \n            if (fscanf(fp, \"   (%f, %f)\\n\", &x, &y) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading floats\", procName, NULL);\n            }\n            ptaAddPt(pta, x, y);\n        } else {   \n            if (fscanf(fp, \"   (%d, %d)\\n\", &ix, &iy) != 2) {\n                ptaDestroy(&pta);\n                return (PTA *)ERROR_PTR(\"error reading ints\", procName, NULL);\n            }\n            ptaAddPt(pta, ix, iy);\n        }\n    }\n    return pta;\n}", "target": 1}
{"code": "bool Scanner::fill(size_t need)\n{\n    if (eof) return false;\n    pop_finished_files();\n    DASSERT(bot <= tok && tok <= lim);\n    size_t free = static_cast<size_t>(tok - bot);\n    size_t copy = static_cast<size_t>(lim - tok);\n    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n        free = BSIZE - copy;\n    }\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n    return true;\n}", "target": 1}
{"code": "content::ColorChooser* Browser::OpenColorChooser(\n      WebContents* web_contents,\n      SkColor initial_color,\n      const std::vector<content::ColorSuggestion>& suggestions) {\n  return chrome::ShowColorChooser(web_contents, initial_color);\n}", "target": 0}
{"code": "static void adpt_release(adpt_hba *pHba)\n{\n\tstruct Scsi_Host *shost = pHba->host;\n\tscsi_remove_host(shost);\n\tadpt_i2o_delete_hba(pHba);\n\tscsi_host_put(shost);\n}", "target": 1}
{"code": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\tstrlcpy(rcomp.type, \"compression\", sizeof(rcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)\n{\n    ASSERT(!(n < 4));\n    auto predecessor = n.minus({ 1 });\n    auto d = predecessor;\n    size_t r = 0;\n    {\n        auto div_result = d.divided_by(2);\n        while (div_result.remainder == 0) {\n            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        return n == 2;\n    }\n    for (auto a : tests) {\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {\n                skip_this_witness = true;\n                break;\n            }\n        }\n        if (skip_this_witness)\n            continue;\n        return false; \n    }\n    return true; \n}", "target": 1}
{"code": "    bool PamBackend::start(const QString &user) {\n        bool result;\n        QString service = QStringLiteral(\"sddm\");\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n        return result;\n    }", "target": 1}
{"code": "check_1_6_dummy(kadm5_principal_ent_t entry, long mask,\n                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)\n{\n    int i;\n    char *password = *passptr;\n    if (!(mask & KADM5_ATTRIBUTES) ||\n        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))\n        return;\n    for (i = 0; (unsigned char) password[i] == i + 1; i++);\n    if (password[i] != '\\0' || i != 255)\n        return;\n    *passptr = NULL;\n}", "target": 1}
{"code": "static void update_cr8_intercept(struct kvm_vcpu *vcpu)\n{\n\tint max_irr, tpr;\n\tif (!kvm_x86_ops->update_cr8_intercept)\n\t\treturn;\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\tif (!vcpu->arch.apic->vapic_addr)\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\telse\n\t\tmax_irr = -1;\n\tif (max_irr != -1)\n\t\tmax_irr >>= 4;\n\ttpr = kvm_lapic_get_cr8(vcpu);\n\tkvm_x86_ops->update_cr8_intercept(vcpu, tpr, max_irr);\n}", "target": 0}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tint bitmap_pos;\n\tbitmap_pos = bitmap_position(object->oid.hash);\n\tif (bitmap_pos < 0) {\n\t\tchar *name = path_name(path, last);\n\t\tbitmap_pos = ext_index_add_object(object, name);\n\t\tfree(name);\n\t}\n\tbitmap_set(base, bitmap_pos);\n}", "target": 1}
{"code": "TfLiteStatus ReluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  ReluOpData* data = static_cast<ReluOpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  if (input->type == kTfLiteInt8) {\n    CalculateReluOpData<int8_t>(input, output, data);\n  } else if (input->type == kTfLiteUInt8) {\n    CalculateReluOpData<uint8_t>(input, output, data);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "rrdp_process_deltas(struct update_notification *parent,\n    unsigned long cur_serial, struct visited_uris *visited_uris,\n    bool log_operation)\n{\n\tstruct proc_upd_args args;\n\targs.parent = parent;\n\targs.visited_uris = visited_uris;\n\targs.log_operation = log_operation;\n\treturn deltas_head_for_each(parent->deltas_list,\n\t    parent->global_data.serial, cur_serial, process_delta, &args);\n}", "target": 1}
{"code": "void ConnectDialogEdit::accept() {\n\tvalidate();\n\tif (bOk) {\n\t\tQString server = qleServer->text().simplified();\n\t\tconst int schemaPos = server.indexOf(QLatin1String(\":\n\t\tif (schemaPos != -1) {\n\t\t\tserver.remove(0, schemaPos + 3);\n\t\t}\n\t\tconst int pathPos = server.indexOf(QLatin1Char('/'));\n\t\tif (pathPos != -1) {\n\t\t\tserver.resize(pathPos);\n\t\t}\n\t\tqleServer->setText(server);\n\t\tif (qleName->text().simplified().isEmpty() || !bCustomLabel) {\n\t\t\tqleName->setText(server);\n\t\t}\n\t\tQDialog::accept();\n\t}\n}", "target": 0}
{"code": "pdf_t *pdf_new(const char *name)\n{\n    const char *n;\n    pdf_t      *pdf;\n    pdf = calloc(1, sizeof(pdf_t));\n    if (name)\n    {\n        if ((n = strrchr(name, '/')))\n          ++n;\n        else\n          n = name;\n        pdf->name = malloc(strlen(n) + 1);\n        strcpy(pdf->name, n);\n    }\n    else \n    {\n        pdf->name = malloc(strlen(\"Unknown\") + 1);\n        strcpy(pdf->name, \"Unknown\");\n    }\n    return pdf;\n}", "target": 1}
{"code": "Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,\n        SDL_PixelFormat * dst)\n{\n    Uint8 *map;\n    int i;\n    int bpp;\n    SDL_Palette *pal = src->palette;\n    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);\n    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < pal->ncolors; ++i) {\n        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);\n        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);\n        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);\n        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);\n        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);\n    }\n    return (map);\n}", "target": 1}
{"code": "QString KNSResource::longDescription()\n{\n    QString ret = m_entry.summary();\n    if (m_entry.shortSummary().isEmpty()) {\n        const int newLine = ret.indexOf(QLatin1Char('\\n'));\n        if (newLine<0)\n            ret.clear();\n        else\n            ret = ret.mid(newLine+1).trimmed();\n    }\n    ret.remove(QLatin1Char('\\r'));\n    ret.replace(QStringLiteral(\"[li]\"), QStringLiteral(\"\\n* \"));\n    ret.remove(QRegularExpression(QStringLiteral(\"\\\\[\\\\/?[a-z]*\\\\]\")));\n    static const QRegularExpression urlRegExp(QStringLiteral(\"(^|\\\\s)([-a-zA-Z0-9@:%_\\\\+.~#?&\n    ret.replace(urlRegExp, QStringLiteral(\"<a href=\\\"\\\\2\\\">\\\\2</a>\"));\n    return ret;\n}", "target": 1}
{"code": "void luaT_getvarargs (lua_State *L, CallInfo *ci, StkId where, int wanted) {\n  int i;\n  int nextra = ci->u.l.nextraargs;\n  if (wanted < 0) {\n    wanted = nextra;  \n    checkstackp(L, nextra, where);  \n    L->top = where + nextra;  \n  }\n  for (i = 0; i < wanted && i < nextra; i++)\n    setobjs2s(L, where + i, ci->func - nextra + i);\n  for (; i < wanted; i++)   \n    setnilvalue(s2v(where + i));\n}", "target": 1}
{"code": "static void mark_verifier_state_clean(struct bpf_verifier_env *env)\n{\n\tenv->scratched_regs = 0U;\n\tenv->scratched_stack_slots = 0ULL;\n}", "target": 0}
{"code": "void InterstitialPage::Focus() {\n  render_view_host_->view()->Focus();\n}", "target": 0}
{"code": "bool DefaultCertValidator::matchSubjectAltName(\n    X509* cert,\n    const std::vector<Matchers::StringMatcherImpl<envoy::type::matcher::v3::StringMatcher>>&\n        subject_alt_name_matchers) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return false;\n  }\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    const std::string san = Utility::generalNameAsString(general_name);\n    for (auto& config_san_matcher : subject_alt_name_matchers) {\n      if (general_name->type == GEN_DNS &&\n                  config_san_matcher.matcher().match_pattern_case() ==\n                      envoy::type::matcher::v3::StringMatcher::MatchPatternCase::kExact\n              ? Utility::dnsNameMatch(config_san_matcher.matcher().exact(), absl::string_view(san))\n              : config_san_matcher.match(san)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "void Curl_attach_connnection(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  DEBUGASSERT(!data->conn);\n  DEBUGASSERT(conn);\n  data->conn = conn;\n  Curl_llist_insert_next(&conn->easyq, conn->easyq.tail, data,\n                         &data->conn_queue);\n  if(conn->handler->attach)\n    conn->handler->attach(data, conn);\n  Curl_ssl_associate_conn(data, conn);\n}", "target": 0}
{"code": "imapx_unset_folder_flagged_flag (CamelFolderSummary *summary,\n\t\t\t\t GPtrArray *changed_uids,\n\t\t\t\t gboolean except_deleted_messages)\n{\n\tCamelMessageInfo *info;\n\tgboolean changed = FALSE;\n\tgint ii;\n\tg_return_if_fail (CAMEL_IS_FOLDER_SUMMARY (summary));\n\tg_return_if_fail (changed_uids != NULL);\n\tfor (ii = 0; ii < changed_uids->len; ii++) {\n\t\tinfo = camel_folder_summary_get (summary, changed_uids->pdata[ii]);\n\t\tif (info) {\n\t\t\tCamelMessageInfoBase *mi = (CamelMessageInfoBase *) info;\n\t\t\tif ((mi->flags & CAMEL_MESSAGE_FOLDER_FLAGGED) != 0 &&\n\t\t\t   (!except_deleted_messages || (mi->flags & CAMEL_MESSAGE_DELETED) == 0)) {\n\t\t\t\tmi->flags &= ~CAMEL_MESSAGE_FOLDER_FLAGGED;\n\t\t\t\tmi->dirty = TRUE;\n\t\t\t\tchanged = TRUE;\n\t\t\t}\n\t\t\tcamel_message_info_unref (info);\n\t\t}\n\t}\n\tif (changed) {\n\t\tcamel_folder_summary_touch (summary);\n\t\tcamel_folder_summary_save_to_db (summary, NULL);\n\t}\n}", "target": 0}
{"code": "pq_buffer_has_data(void)\n{\n\treturn (PqRecvPointer < PqRecvLength);\n}", "target": 0}
{"code": "static TEE_Result do_alloc_publickey(struct ecc_public_key *s, uint32_t type,\n\t\t\t\t     size_t size_bits __unused)\n{\n\tif (type != TEE_TYPE_ECDSA_PUBLIC_KEY &&\n\t    type != TEE_TYPE_ECDH_PUBLIC_KEY)\n\t\treturn TEE_ERROR_NOT_IMPLEMENTED;\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "void FrameLoader::begin(const KURL& url, bool dispatch, SecurityOrigin* origin)\n{\n    RefPtr<SecurityOrigin> forcedSecurityOrigin = origin;\n    RefPtr<Document> document;\n    if (!m_isDisplayingInitialEmptyDocument && m_client->shouldUsePluginDocument(m_responseMIMEType))\n        document = PluginDocument::create(m_frame);\n    else if (!m_client->hasHTMLView())\n        document = PlaceholderDocument::create(m_frame);\n    else\n        document = DOMImplementation::createDocument(m_responseMIMEType, m_frame, m_frame->inViewSourceMode());\n    bool resetScripting = !(m_isDisplayingInitialEmptyDocument && m_frame->document()->securityOrigin()->isSecureTransitionTo(url));\n    clear(resetScripting, resetScripting);\n    if (resetScripting)\n        m_frame->script()->updatePlatformScriptObjects();\n    m_needsClear = true;\n    m_isComplete = false;\n    m_didCallImplicitClose = false;\n    m_isLoadingMainResource = true;\n    m_isDisplayingInitialEmptyDocument = m_creatingInitialEmptyDocument;\n    KURL ref(url);\n    ref.setUser(String());\n    ref.setPass(String());\n    ref.removeFragmentIdentifier();\n    m_outgoingReferrer = ref.string();\n    m_URL = url;\n    document->setURL(m_URL);\n    m_frame->setDocument(document);\n    if (m_decoder)\n        document->setDecoder(m_decoder.get());\n    if (forcedSecurityOrigin)\n        document->setSecurityOrigin(forcedSecurityOrigin.get());\n    m_frame->domWindow()->setURL(document->url());\n    m_frame->domWindow()->setSecurityOrigin(document->securityOrigin());\n    if (dispatch)\n        dispatchWindowObjectAvailable();\n    updateFirstPartyForCookies();\n    Settings* settings = document->settings();\n    document->docLoader()->setAutoLoadImages(settings && settings->loadsImagesAutomatically());\n    if (m_documentLoader) {\n        String dnsPrefetchControl = m_documentLoader->response().httpHeaderField(\"X-DNS-Prefetch-Control\");\n        if (!dnsPrefetchControl.isEmpty())\n            document->parseDNSPrefetchControlHeader(dnsPrefetchControl);\n    }\n    history()->restoreDocumentState();\n    document->implicitOpen();\n    if (m_frame->view() && m_client->hasHTMLView())\n        m_frame->view()->setContentsSize(IntSize());\n}", "target": 0}
{"code": "static void dhcps_send_ack(struct pbuf *packet_buffer)\n{\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\t      \t\t\tDHCP_MESSAGE_TYPE_ACK));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t   &dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}", "target": 1}
{"code": "_pdfioFileConsume(pdfio_file_t *pdf,\t\n                  size_t       bytes)\t\n{\n  PDFIO_DEBUG(\"_pdfioFileConsume(pdf=%p, bytes=%u)\\n\", pdf, (unsigned)bytes);\n  if ((size_t)(pdf->bufend - pdf->bufptr) > bytes)\n    pdf->bufptr += bytes;\n  else if (_pdfioFileSeek(pdf, (off_t)bytes, SEEK_CUR) < 0)\n    return (false);\n  PDFIO_DEBUG(\"_pdfioFileConsume: pos=%ld\\n\", (long)(pdf->bufpos + pdf->bufptr - pdf->buffer));\n  return (true);\n}", "target": 0}
{"code": "http_error_t::make_body (int n, const str &si, const str &aux)\n{\n  strbuf b;\n  str ldesc;\n  const str sdesc = http_status.get_desc (n, &ldesc);\n  b << \"<html>\\n\"\n    << \" <head>\\n\"\n    << \"  <title>\" << n << \" \" << sdesc << \"</title>\\n\"\n    << \" </head>\\n\"\n    << \" <body>\\n\"\n    << \" <h1>Error \" << n << \" \" << sdesc << \"</h1><br><br>\\n\"\n    ;\n  if (n == HTTP_NOT_FOUND && aux) {\n    b << \"The file <tt>\" << aux \n      << \"</tt> was not found on this server.<br><br>\\n\\n\";\n  }\n  b << \"  <hr>\\n\"\n    << \"  <i>\" << si << \"</i>\\n\"\n    << \" <br>\\n\"\n    << \" </body>\\n\"\n    << \"</html>\\n\"\n    ;\n  return b;\n}", "target": 1}
{"code": "R_API int r_io_bank_write_to_submap_at(RIO *io, const ut32 bankid, ut64 addr, const ut8 *buf, int len) {\n\tRIOBank *bank = r_io_bank_get (io, bankid);\n\tr_return_val_if_fail (io && bank, -1);\n\tif (!len) {\n\t\treturn 0;\n\t}\n\tRRBNode *node;\n\tif (bank->last_used && r_io_submap_contain (((RIOSubMap *)bank->last_used->data), addr)) {\n\t\tnode = bank->last_used;\n\t} else {\n\t\tnode = r_crbtree_find_node (bank->submaps, &addr, _find_sm_by_vaddr_cb, NULL);\n\t\tif (!node) {\n\t\t\treturn 0;\n\t\t}\n\t\tbank->last_used = node;\n\t}\n\tRIOSubMap *sm = (RIOSubMap *)node->data;\n\tif (!r_io_submap_contain (sm, addr)) {\n\t\treturn 0;\n\t}\n\tRIOMap *map = r_io_map_get_by_ref (io, &sm->mapref);\n\tif (!map || !(map->perm & R_PERM_W)) {\n\t\treturn -1;\n\t}\n\tconst int write_len = R_MIN (len, r_io_submap_to (sm) - addr + 1);\n\tconst ut64 paddr = addr - r_io_map_from (map) + map->delta;\n\treturn r_io_fd_write_at (io, map->fd, paddr, buf, write_len);\n}", "target": 0}
{"code": "static inline void pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tbuf->ops->get(pipe, buf);\n}", "target": 1}
{"code": "atm_if_print(netdissect_options *ndo,\n             const struct pcap_pkthdr *h, const u_char *p)\n{\n\tu_int caplen = h->caplen;\n\tu_int length = h->len;\n\tuint32_t llchdr;\n\tu_int hdrlen = 0;\n\tif (caplen < 1 || length < 1) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n        if (*p == LLC_UI) {\n            if (ndo->ndo_eflag)\n                ND_PRINT((ndo, \"CNLPID \"));\n            isoclns_print(ndo, p + 1, length - 1, caplen - 1);\n            return hdrlen;\n        }\n\tif (caplen < 3 || length < 3) {\n\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\treturn (caplen);\n\t}\n\tllchdr = EXTRACT_24BITS(p);\n\tif (llchdr != LLC_UI_HDR(LLCSAP_SNAP) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&\n\t    llchdr != LLC_UI_HDR(LLCSAP_IP)) {\n\t\tif (caplen < 20 || length < 20) {\n\t\t\tND_PRINT((ndo, \"%s\", tstr));\n\t\t\treturn (caplen);\n\t\t}\n\t\tif (ndo->ndo_eflag)\n\t\t\tND_PRINT((ndo, \"%08x%08x %08x%08x \",\n\t\t\t       EXTRACT_32BITS(p),\n\t\t\t       EXTRACT_32BITS(p+4),\n\t\t\t       EXTRACT_32BITS(p+8),\n\t\t\t       EXTRACT_32BITS(p+12)));\n\t\tp += 20;\n\t\tlength -= 20;\n\t\tcaplen -= 20;\n\t\thdrlen += 20;\n\t}\n\thdrlen += atm_llc_print(ndo, p, length, caplen);\n\treturn (hdrlen);\n}", "target": 1}
{"code": "char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length)\n{\n    char *buffer=NULL;\n    int   n=0;\n    FILEXFER_ALLOWED_OR_CLOSE_AND_RETURN(\"\", cl, NULL);\n    if(length == SIZE_MAX || length > INT_MAX) {\n\trfbErr(\"rfbProcessFileTransferReadBuffer: too big file transfer length requested: %u\", (unsigned int)length);\n\trfbCloseClient(cl);\n\treturn NULL;\n    }\n    if (length>0) {\n        buffer=malloc((size_t)length+1);\n        if (buffer!=NULL) {\n            if ((n = rfbReadExact(cl, (char *)buffer, length)) <= 0) {\n                if (n != 0)\n                    rfbLogPerror(\"rfbProcessFileTransferReadBuffer: read\");\n                rfbCloseClient(cl);\n                if (buffer!=NULL) free(buffer);\n                return NULL;\n            }\n            buffer[length]=0;\n        }\n    }\n    return buffer;\n}", "target": 0}
{"code": "translate_hex_string(char *s, char *saved_orphan)\n{\n  int c1 = *saved_orphan;\n  char *start = s;\n  char *t = s;\n  for (; *s; s++) {\n    if (isspace(*s))\n      continue;\n    if (c1) {\n      *t++ = (hexval(c1) << 4) + hexval(*s);\n      c1 = 0;\n    } else\n      c1 = *s;\n  }\n  *saved_orphan = c1;\n  return t - start;\n}", "target": 1}
{"code": "static int __init adpt_init(void)\n{\n\tint\t\terror;\n\tadpt_hba\t*pHba, *next;\n\tprintk(\"Loading Adaptec I2O RAID: Version \" DPT_I2O_VERSION \"\\n\");\n\terror = adpt_detect(&driver_template);\n\tif (error < 0)\n\t\treturn error;\n\tif (hba_chain == NULL)\n\t\treturn -ENODEV;\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\terror = scsi_add_host(pHba->host, &pHba->pDev->dev);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tscsi_scan_host(pHba->host);\n\t}\n\treturn 0;\nfail:\n\tfor (pHba = hba_chain; pHba; pHba = next) {\n\t\tnext = pHba->next;\n\t\tscsi_remove_host(pHba->host);\n\t}\n\treturn error;\n}", "target": 1}
{"code": "  ErrorSslSocket(absl::string_view error) : error_(error) {}", "target": 0}
{"code": "  const uint8_t *getBytecode(uint32_t) const override {\n    llvm_unreachable(\"Accessing bytecode from a lazy module\");\n  }", "target": 1}
{"code": "void sw_crypto_acipher_free_rsa_public_key(struct rsa_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->e);\n}", "target": 1}
{"code": "ServerSecurityFeature::ServerSecurityFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "int Item::save_time_in_field(Field *field)\n{\n  MYSQL_TIME ltime;\n  if (get_time(&ltime))\n    return set_field_to_null_with_conversions(field, 0);\n  field->set_notnull();\n  return field->store_time_dec(&ltime, decimals);\n}", "target": 0}
{"code": "static int umocktypes_copy_FLOW_HANDLE(FLOW_HANDLE* destination, const FLOW_HANDLE* source)\n{\n    int result = 0;\n    *(destination) = *(source);\n    return result;\n}", "target": 0}
{"code": "static void rekey_seq_generator(struct work_struct *work)\n{\n\tstruct keydata *keyptr = &ip_keydata[1 ^ (ip_cnt & 1)];\n\tget_random_bytes(keyptr->secret, sizeof(keyptr->secret));\n\tkeyptr->count = (ip_cnt & COUNT_MASK) << HASH_BITS;\n\tsmp_wmb();\n\tip_cnt++;\n\tschedule_delayed_work(&rekey_work,\n\t\t\t      round_jiffies_relative(REKEY_INTERVAL));\n}", "target": 1}
{"code": "njs_json_parse_iterator(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_value_t *object)\n{\n    njs_int_t             ret;\n    njs_value_t           *key, wrapper;\n    njs_object_t          *obj;\n    njs_json_state_t      *state;\n    njs_object_prop_t     *prop;\n    njs_property_query_t  pq;\n    obj = njs_json_wrap_value(vm, &wrapper, object);\n    if (njs_slow_path(obj == NULL)) {\n        return NJS_ERROR;\n    }\n    state = njs_json_push_parse_state(vm, parse, &wrapper);\n    if (njs_slow_path(state == NULL)) {\n        return NJS_ERROR;\n    }\n    for ( ;; ) {\n        if (state->index < state->keys->length) {\n            njs_property_query_init(&pq, NJS_PROPERTY_QUERY_SET, 0);\n            key = &state->keys->start[state->index];\n            ret = njs_property_query(vm, &pq, &state->value, key);\n            if (njs_slow_path(ret != NJS_OK)) {\n                if (ret == NJS_DECLINED) {\n                    state->index++;\n                    continue;\n                }\n                return NJS_ERROR;\n            }\n            prop = pq.lhq.value;\n            if (prop->type == NJS_WHITEOUT) {\n                state->index++;\n                continue;\n            }\n            state->prop = prop;\n            if (prop->type == NJS_PROPERTY && njs_is_object(&prop->value)) {\n                state = njs_json_push_parse_state(vm, parse, &prop->value);\n                if (state == NULL) {\n                    return NJS_ERROR;\n                }\n                continue;\n            }\n            if (prop->type == NJS_PROPERTY_REF\n                && njs_is_object(prop->value.data.u.value))\n            {\n                state = njs_json_push_parse_state(vm, parse,\n                                                  prop->value.data.u.value);\n                if (state == NULL) {\n                    return NJS_ERROR;\n                }\n                continue;\n            }\n        } else {\n            state = njs_json_pop_parse_state(vm, parse);\n            if (state == NULL) {\n                vm->retval = parse->retval;\n                return NJS_OK;\n            }\n        }\n        ret = njs_json_parse_iterator_call(vm, parse, state);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n}", "target": 1}
{"code": "void dev_load(struct net *net, const char *name)\n{\n\tstruct net_device *dev;\n\trcu_read_lock();\n\tdev = dev_get_by_name_rcu(net, name);\n\trcu_read_unlock();\n\tif (!dev && capable(CAP_NET_ADMIN))\n\t\trequest_module(\"%s\", name);\n}", "target": 1}
{"code": "static void vgacon_scrolldelta(struct vc_data *c, int lines)\n{\n\tint start, end, count, soff;\n\tif (!lines) {\n\t\tvgacon_restore_screen(c);\n\t\treturn;\n\t}\n\tif (!vgacon_scrollback_cur->data)\n\t\treturn;\n\tif (!vgacon_scrollback_cur->save) {\n\t\tvgacon_cursor(c, CM_ERASE);\n\t\tvgacon_save_screen(c);\n\t\tc->vc_origin = (unsigned long)c->vc_screenbuf;\n\t\tvgacon_scrollback_cur->save = 1;\n\t}\n\tvgacon_scrollback_cur->restore = 0;\n\tstart = vgacon_scrollback_cur->cur + lines;\n\tend = start + abs(lines);\n\tif (start < 0)\n\t\tstart = 0;\n\tif (start > vgacon_scrollback_cur->cnt)\n\t\tstart = vgacon_scrollback_cur->cnt;\n\tif (end < 0)\n\t\tend = 0;\n\tif (end > vgacon_scrollback_cur->cnt)\n\t\tend = vgacon_scrollback_cur->cnt;\n\tvgacon_scrollback_cur->cur = start;\n\tcount = end - start;\n\tsoff = vgacon_scrollback_cur->tail -\n\t\t((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);\n\tsoff -= count * c->vc_size_row;\n\tif (soff < 0)\n\t\tsoff += vgacon_scrollback_cur->size;\n\tcount = vgacon_scrollback_cur->cnt - start;\n\tif (count > c->vc_rows)\n\t\tcount = c->vc_rows;\n\tif (count) {\n\t\tint copysize;\n\t\tint diff = c->vc_rows - count;\n\t\tvoid *d = (void *) c->vc_visible_origin;\n\t\tvoid *s = (void *) c->vc_screenbuf;\n\t\tcount *= c->vc_size_row;\n\t\tcopysize = min(count, vgacon_scrollback_cur->size - soff);\n\t\tscr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);\n\t\td += copysize;\n\t\tcount -= copysize;\n\t\tif (count) {\n\t\t\tscr_memcpyw(d, vgacon_scrollback_cur->data, count);\n\t\t\td += count;\n\t\t}\n\t\tif (diff)\n\t\t\tscr_memcpyw(d, s, diff * c->vc_size_row);\n\t} else\n\t\tvgacon_cursor(c, CM_MOVE);\n}", "target": 1}
{"code": "gdImagePtr gdImageCreate (int sx, int sy)\n{\n\tint i;\n\tgdImagePtr im;\n\tif (overflow2(sx, sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sy)) {\n\t\treturn NULL;\n\t}\n\tif (overflow2(sizeof(unsigned char *), sx)) {\n\t\treturn NULL;\n\t}\n\tim = (gdImage *) gdCalloc(1, sizeof(gdImage));\n\tim->pixels = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n\tim->polyInts = 0;\n\tim->polyAllocated = 0;\n\tim->brush = 0;\n\tim->tile = 0;\n\tim->style = 0;\n\tfor (i = 0; i < sy; i++) {\n\t\tim->pixels[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t\tim->AA_opacity[i] = (unsigned char *) gdCalloc(sx, sizeof(unsigned char));\n\t}\n\tim->sx = sx;\n\tim->sy = sy;\n\tim->colorsTotal = 0;\n\tim->transparent = (-1);\n\tim->interlace = 0;\n\tim->thick = 1;\n\tim->AA = 0;\n\tim->AA_polygon = 0;\n\tfor (i = 0; i < gdMaxColors; i++) {\n\t\tim->open[i] = 1;\n\t\tim->red[i] = 0;\n\t\tim->green[i] = 0;\n\t\tim->blue[i] = 0;\n\t}\n\tim->trueColor = 0;\n\tim->tpixels = 0;\n\tim->cx1 = 0;\n\tim->cy1 = 0;\n\tim->cx2 = im->sx - 1;\n\tim->cy2 = im->sy - 1;\n\tim->interpolation = NULL;\n\tim->interpolation_id = GD_BILINEAR_FIXED;\n\treturn im;\n}", "target": 0}
{"code": "static int evtchn_fifo_percpu_deinit(unsigned int cpu)\n{\n\t__evtchn_fifo_handle_events(cpu, true);\n\treturn 0;\n}", "target": 1}
{"code": "  void SetInput(const std::vector<float>& data) {\n    QuantizeAndPopulate<uint8_t>(input_, data);\n  }", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  const int input_channels = input->dims->data[3];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = output_channels;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 0}
{"code": "bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\treturn ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid) &&\n\t\tkgid_has_mapping(ns, inode->i_gid);\n}", "target": 0}
{"code": "\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)\n{\n\tu8 *buf = NULL;\n\tint err;\n\tif (!seed && slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tget_random_bytes(buf, slen);\n\t\tseed = buf;\n\t}\n\terr = tfm->seed(tfm, seed, slen);\n\tkfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "tpaddr_print_ip(netdissect_options *ndo,\n\t        const struct arp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (PROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong len>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, TPA(ap))));\n}", "target": 0}
{"code": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\tword.ptr = value->ptr - 1; \n\te = value->ptr + value->len;\n\twhile (++word.ptr < e) {\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\tif (unlikely(n == word.ptr)) \n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl + c;\n\t\t}\n\t\tword.len = n - word.ptr;\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\treturn !not_first;\n fail:\n\treturn -1;\n}", "target": 1}
{"code": "usm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n    if (old_ref) {\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n    }\n}                               ", "target": 1}
{"code": "dump_dest_constraint_hop(const struct dest_constraint_hop *dch)\n{\n\tu_int i;\n\tchar *fp;\n\tdebug_f(\"user %s hostname %s is_ca %d nkeys %u\",\n\t    dch->user == NULL ? \"(null)\" : dch->user,\n\t    dch->hostname == NULL ? \"(null)\" : dch->hostname,\n\t    dch->is_ca, dch->nkeys);\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tfp = NULL;\n\t\tif (dch->keys[i] != NULL &&\n\t\t    (fp = sshkey_fingerprint(dch->keys[i],\n\t\t    SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL)\n\t\t\tfatal_f(\"fingerprint failed\");\n\t\tdebug_f(\"key %u/%u: %s%s%s key_is_ca %d\", i, dch->nkeys,\n\t\t    dch->keys[i] == NULL ? \"\" : sshkey_ssh_name(dch->keys[i]),\n\t\t    dch->keys[i] == NULL ? \"\" : \" \",\n\t\t    dch->keys[i] == NULL ? \"none\" : fp,\n\t\t    dch->key_is_ca[i]);\n\t\tfree(fp);\n\t}\n}", "target": 0}
{"code": "rt6_print(netdissect_options *ndo, register const u_char *bp, const u_char *bp2 _U_)\n{\n\tregister const struct ip6_rthdr *dp;\n\tregister const struct ip6_rthdr0 *dp0;\n\tregister const u_char *ep;\n\tint i, len;\n\tregister const struct in6_addr *addr;\n\tdp = (const struct ip6_rthdr *)bp;\n\tlen = dp->ip6r_len;\n\tep = ndo->ndo_snapend;\n\tND_TCHECK(dp->ip6r_segleft);\n\tND_PRINT((ndo, \"srcrt (len=%d\", dp->ip6r_len));\t\n\tND_PRINT((ndo, \", type=%d\", dp->ip6r_type));\n\tND_PRINT((ndo, \", segleft=%d\", dp->ip6r_segleft));\n\tswitch (dp->ip6r_type) {\n\tcase IPV6_RTHDR_TYPE_0:\n\tcase IPV6_RTHDR_TYPE_2:\t\t\t\n\t\tdp0 = (const struct ip6_rthdr0 *)dp;\n\t\tND_TCHECK(dp0->ip6r0_reserved);\n\t\tif (dp0->ip6r0_reserved || ndo->ndo_vflag) {\n\t\t\tND_PRINT((ndo, \", rsv=0x%0x\",\n\t\t\t    EXTRACT_32BITS(&dp0->ip6r0_reserved)));\n\t\t}\n\t\tif (len % 2 == 1)\n\t\t\tgoto trunc;\n\t\tlen >>= 1;\n\t\taddr = &dp0->ip6r0_addr[0];\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif ((const u_char *)(addr + 1) > ep)\n\t\t\t\tgoto trunc;\n\t\t\tND_PRINT((ndo, \", [%d]%s\", i, ip6addr_string(ndo, addr)));\n\t\t\taddr++;\n\t\t}\n\t\tND_PRINT((ndo, \") \"));\n\t\treturn((dp0->ip6r0_len + 1) << 3);\n\t\tbreak;\n\tdefault:\n\t\tgoto trunc;\n\t\tbreak;\n\t}\n trunc:\n\tND_PRINT((ndo, \"[|srcrt]\"));\n\treturn -1;\n}", "target": 1}
{"code": "uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg,\n                                          char *buffer) {\n  uint16_t offset = 4 + (5 * 32);\n  int16_t len = msg->data_length - offset;\n  if (msg->has_data_length && len > 0) {\n    memcpy(buffer, msg->data_initial_chunk.bytes + offset, len);\n    return len < 256 ? (uint8_t)len : 0;\n  }\n  return 0;\n}", "target": 1}
{"code": "void __init proc_root_init(void)\n{\n\tstruct vfsmount *mnt;\n\tint err;\n\tproc_init_inodecache();\n\terr = register_filesystem(&proc_fs_type);\n\tif (err)\n\t\treturn;\n\tmnt = kern_mount_data(&proc_fs_type, &init_pid_ns);\n\tif (IS_ERR(mnt)) {\n\t\tunregister_filesystem(&proc_fs_type);\n\t\treturn;\n\t}\n\tinit_pid_ns.proc_mnt = mnt;\n\tproc_symlink(\"mounts\", NULL, \"self/mounts\");\n\tproc_net_init();\n#ifdef CONFIG_SYSVIPC\n\tproc_mkdir(\"sysvipc\", NULL);\n#endif\n\tproc_mkdir(\"fs\", NULL);\n\tproc_mkdir(\"driver\", NULL);\n\tproc_mkdir(\"fs/nfsd\", NULL); \n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\n\tproc_mkdir(\"openprom\", NULL);\n#endif\n\tproc_tty_init();\n#ifdef CONFIG_PROC_DEVICETREE\n\tproc_device_tree_init();\n#endif\n\tproc_mkdir(\"bus\", NULL);\n\tproc_sys_init();\n}", "target": 1}
{"code": "static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){\n    long i;\n#if !HAVE_FAST_UNALIGNED\n    if((long)src2 & (sizeof(long)-1)){\n        for(i=0; i+7<w; i+=8){\n            dst[i+0] = src1[i+0]-src2[i+0];\n            dst[i+1] = src1[i+1]-src2[i+1];\n            dst[i+2] = src1[i+2]-src2[i+2];\n            dst[i+3] = src1[i+3]-src2[i+3];\n            dst[i+4] = src1[i+4]-src2[i+4];\n            dst[i+5] = src1[i+5]-src2[i+5];\n            dst[i+6] = src1[i+6]-src2[i+6];\n            dst[i+7] = src1[i+7]-src2[i+7];\n        }\n    }else\n#endif\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src1+i);\n        long b = *(long*)(src2+i);\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] = src1[i+0]-src2[i+0];\n}", "target": 1}
{"code": "char *LibRaw_bigfile_datastream::gets(char *str, int sz)\n{\n  if(sz<1) return NULL;\n  LR_BF_CHK();\n  return fgets(str, sz, f);\n}", "target": 0}
{"code": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tint l2 = 22 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = mkdir_p(dest, 0755);\n\t\tif (ret < 0) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}", "target": 1}
{"code": "void test_openat(const char *path)\n{\n\tchar *d = strdupa(path), *f, *tmpname;\n\tint fd, fd2;\n\tf = basename(d);\n\td = dirname(d);\n\tfd = open(d, O_RDONLY);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Error in openat test: could not open parent dir\\n\");\n\t\tfprintf(stderr, \"(this is expected on the second run)\\n\");\n\t\treturn;\n\t}\n\tfd2 = openat(fd, f, O_RDONLY);\n\tif (fd2 >= 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at openat of %s\\n\", f);\n\t\texit(1);\n\t}\n\tsize_t len = strlen(path) + strlen(\"/cgroup.procs\") + 1;\n\ttmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/cgroup.procs\", f);\n\tfd2 = openat(fd, tmpname, O_RDONLY);\n\tif (fd2 >= 0 || errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at openat of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n\tclose(fd);\n}", "target": 0}
{"code": "ip_printroute(netdissect_options *ndo,\n              register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tif (length < 3) {\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\t\treturn;\n\t}\n\tif ((length + 1) & 3)\n\t\tND_PRINT((ndo, \" [bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tif (ptr < 3 || ((ptr + 1) & 3) || ptr > length + 1)\n\t\tND_PRINT((ndo, \" [bad ptr %u]\", cp[2]));\n\tfor (len = 3; len < length; len += 4) {\n\t\tND_PRINT((ndo, \" %s\", ipaddr_string(ndo, &cp[len])));\n\t\tif (ptr > len)\n\t\t\tND_PRINT((ndo, \",\"));\n\t}\n}", "target": 1}
{"code": "void BlockCodec::runPull()\n{\n\tAFframecount framesToRead = m_outChunk->frameCount;\n\tAFframecount framesRead = 0;\n\tassert(framesToRead % m_framesPerPacket == 0);\n\tint blockCount = framesToRead / m_framesPerPacket;\n\tssize_t bytesRead = read(m_inChunk->buffer, m_bytesPerPacket * blockCount);\n\tint blocksRead = bytesRead >= 0 ? bytesRead / m_bytesPerPacket : 0;\n\tfor (int i=0; i<blocksRead; i++)\n\t{\n\t\tdecodeBlock(static_cast<const uint8_t *>(m_inChunk->buffer) + i * m_bytesPerPacket,\n\t\t\tstatic_cast<int16_t *>(m_outChunk->buffer) + i * m_framesPerPacket * m_track->f.channelCount);\n\t\tframesRead += m_framesPerPacket;\n\t}\n\tm_track->nextfframe += framesRead;\n\tassert(tell() == m_track->fpos_next_frame);\n\tif (framesRead < framesToRead)\n\t\treportReadError(framesRead, framesToRead);\n\tm_outChunk->frameCount = framesRead;\n}", "target": 1}
{"code": "static void sas_probe_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_PROBE, &port->disc.pending);\n\tlist_for_each_entry(dev, &port->disco_list, disco_list_node) {\n\t\tspin_lock_irq(&port->dev_list_lock);\n\t\tlist_add_tail(&dev->dev_list_node, &port->dev_list);\n\t\tspin_unlock_irq(&port->dev_list_lock);\n\t}\n\tsas_probe_sata(port);\n\tlist_for_each_entry_safe(dev, n, &port->disco_list, disco_list_node) {\n\t\tint err;\n\t\terr = sas_rphy_add(dev->rphy);\n\t\tif (err)\n\t\t\tsas_fail_probe(dev, __func__, err);\n\t\telse\n\t\t\tlist_del_init(&dev->disco_list_node);\n\t}\n}", "target": 1}
{"code": "static void ConvertLoopSequence(ModSample &smp, STPLoopList &loopList)\n{\n\tif(!smp.HasSampleData() || loopList.size() < 2) return;\n\tModSample newSmp = smp;\n\tnewSmp.nLength = 0;\n\tnewSmp.pSample = nullptr;\n\tsize_t numLoops = loopList.size();\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\t\tif((newSmp.nLength + info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopLength > MAX_SAMPLE_LENGTH) ||\n\t\t   (info.loopStart + info.loopLength > smp.nLength))\n\t\t{\n\t\t\tnumLoops = i;\n\t\t\tbreak;\n\t\t}\n\t\tnewSmp.nLength += info.loopLength;\n\t}\n\tif(!newSmp.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\tSmpLength start = 0;\n\tfor(size_t i = 0; i < numLoops; i++)\n\t{\n\t\tSTPLoopInfo &info = loopList[i];\n\t\tmemcpy(newSmp.pSample8 + start, smp.pSample8 + info.loopStart, info.loopLength);\n\t\tinfo.loopStart = start;\n\t\tif(i > 0 && i <= mpt::size(newSmp.cues))\n\t\t{\n\t\t\tnewSmp.cues[i - 1] = start;\n\t\t}\n\t\tstart += info.loopLength;\n\t}\n\tsmp.FreeSample();\n\tsmp = newSmp;\n\tsmp.nLoopStart = 0;\n\tsmp.nLoopEnd = smp.nLength;\n\tsmp.uFlags.set(CHN_LOOP);\n}", "target": 1}
{"code": "RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server,\n                                 GeneralRequest* request, GeneralResponse* response)\n    : RestVocbaseBaseHandler(server, request, response),\n      _validFor(60 * 60 * 24 * 30) {}", "target": 1}
{"code": "void options_apply() { \n    unsigned num=0;\n    SERVICE_OPTIONS *section;\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n    memcpy(&global_options, &new_global_options, sizeof(GLOBAL_OPTIONS));\n    memset(&new_global_options, 0, sizeof(GLOBAL_OPTIONS));\n    for(section=new_service_options.next; section; section=section->next)\n        section->section_number=num++;\n    memcpy(&service_options, &new_service_options, sizeof(SERVICE_OPTIONS));\n    memset(&new_service_options, 0, sizeof(SERVICE_OPTIONS));\n    number_of_sections=num;\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}", "target": 0}
{"code": "static void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen)\n{\n  struct host_query *hquery = (struct host_query*)arg;\n  int addinfostatus = ARES_SUCCESS;\n  hquery->timeouts += timeouts;\n  hquery->remaining--;\n  if (status == ARES_SUCCESS)\n    {\n      addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n    }\n  else if (status == ARES_EDESTRUCTION)\n    {\n      end_hquery(hquery, status);\n      return;\n    }\n  if (!hquery->remaining)\n    {\n      if (addinfostatus != ARES_SUCCESS)\n        {\n          end_hquery(hquery, addinfostatus);\n        }\n      else if (hquery->ai->nodes)\n        {\n          end_hquery(hquery, ARES_SUCCESS);\n        }\n      else if (status == ARES_ENOTFOUND)\n        {\n          next_lookup(hquery, status);\n        }\n      else\n        {\n          end_hquery(hquery, status);\n        }\n    }\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    AVFilterContext *ctx = inlink->dst;\n    LutContext *s = ctx->priv;\n    AVFilterLink *outlink = ctx->outputs[0];\n    AVFrame *out;\n    uint8_t *inrow, *outrow, *inrow0, *outrow0;\n    int i, j, plane, direct = 0;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    if (s->is_rgb) {\n        inrow0  = in ->data[0];\n        outrow0 = out->data[0];\n        for (i = 0; i < in->height; i ++) {\n            int w = inlink->w;\n            const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;\n            inrow  = inrow0;\n            outrow = outrow0;\n            for (j = 0; j < w; j++) {\n                switch (s->step) {\n                case 4:  outrow[3] = tab[3][inrow[3]]; \n                case 3:  outrow[2] = tab[2][inrow[2]]; \n                case 2:  outrow[1] = tab[1][inrow[1]]; \n                default: outrow[0] = tab[0][inrow[0]];\n                }\n                outrow += s->step;\n                inrow  += s->step;\n            }\n            inrow0  += in ->linesize[0];\n            outrow0 += out->linesize[0];\n        }\n    } else {\n        for (plane = 0; plane < 4 && in->data[plane]; plane++) {\n            int vsub = plane == 1 || plane == 2 ? s->vsub : 0;\n            int hsub = plane == 1 || plane == 2 ? s->hsub : 0;\n            int h = FF_CEIL_RSHIFT(inlink->h, vsub);\n            int w = FF_CEIL_RSHIFT(inlink->w, hsub);\n            inrow  = in ->data[plane];\n            outrow = out->data[plane];\n            for (i = 0; i < h; i++) {\n                const uint8_t *tab = s->lut[plane];\n                for (j = 0; j < w; j++)\n                    outrow[j] = tab[inrow[j]];\n                inrow  += in ->linesize[plane];\n                outrow += out->linesize[plane];\n            }\n        }\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "void* WebGraphicsContext3DDefaultImpl::mapBufferSubDataCHROMIUM(unsigned target, int offset, int size, unsigned access)\n{\n    return 0;\n}", "target": 0}
{"code": "static void mdbEvalSetColumnJSON(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    if (field->isnull) {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    const char *zBlob = \"\";\n    int bytes = 0;\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_STRING:\n            zBlob = field->buffer.vstring;\n        default:\n        {\n            if( !zBlob ) {\n                Jsi_DSAppend(dStr, \"null\", NULL);\n                return;\n            }\n            Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n            return;\n        }\n    }\n}", "target": 1}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev, RBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tif (!buf || !buf_end || buf > buf_end) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (RBinDwarfDie));\n\t}\n\tfor (i = 0; i < abbrev->count && i < die->capacity; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\tconst ut8 *nbuf = parse_attr_value (buf, buf_end - buf,\n\t\t\t&abbrev->defs[i],\n\t\t\t&die->attr_values[i],\n\t\t\thdr, debug_str, debug_str_len);\n\t\tif (nbuf) {\n\t\t\tbuf = nbuf;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tbool is_string = (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string);\n\t\tbool is_valid_string_form = is_string && attribute->string.content;\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "dane_query_status_t dane_query_status(dane_query_t q)\n{\n\treturn q->status;\n}", "target": 0}
{"code": "TfLiteStatus CalculateArithmeticOpData(TfLiteContext* context, TfLiteNode* node,\n                                       OpData* data) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    static constexpr int kInputIntegerBits = 4;\n    const double input_real_multiplier =\n        static_cast<double>(input->params.scale) *\n        static_cast<double>(1 << (31 - kInputIntegerBits));\n    const double q = std::frexp(input_real_multiplier, &data->input_left_shift);\n    data->input_multiplier = static_cast<int32_t>(TfLiteRound(q * (1ll << 31)));\n    data->input_range_radius =\n        CalculateInputRadius(kInputIntegerBits, data->input_left_shift, 31);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void FoFiTrueType::cvtEncoding(char **encoding,\n\t\t\t       FoFiOutputFunc outputFunc,\n\t\t\t       void *outputStream) {\n  const char *name;\n  GooString *buf;\n  int i;\n  (*outputFunc)(outputStream, \"/Encoding 256 array\\n\", 20);\n  if (encoding) {\n    for (i = 0; i < 256; ++i) {\n      if (!(name = encoding[i])) {\n\tname = \".notdef\";\n      }\n      buf = GooString::format(\"dup {0:d} /\", i);\n      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n      delete buf;\n      (*outputFunc)(outputStream, name, strlen(name));\n      (*outputFunc)(outputStream, \" put\\n\", 5);\n    }\n  } else {\n    for (i = 0; i < 256; ++i) {\n      buf = GooString::format(\"dup {0:d} /c{1:02x} put\\n\", i, i);\n      (*outputFunc)(outputStream, buf->getCString(), buf->getLength());\n      delete buf;\n    }\n  }\n  (*outputFunc)(outputStream, \"readonly def\\n\", 13);\n}", "target": 0}
{"code": "static void ifb_setup(struct net_device *dev)\n{\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}", "target": 1}
{"code": "int DefaultCertValidator::doVerifyCertChain(\n    X509_STORE_CTX* store_ctx, Ssl::SslExtendedSocketInfo* ssl_extended_info, X509& leaf_cert,\n    const Network::TransportSocketOptions* transport_socket_options) {\n  if (verify_trusted_ca_) {\n    int ret = X509_verify_cert(store_ctx);\n    if (ssl_extended_info) {\n      ssl_extended_info->setCertificateValidationStatus(\n          ret == 1 ? Envoy::Ssl::ClientValidationStatus::Validated\n                   : Envoy::Ssl::ClientValidationStatus::Failed);\n    }\n    if (ret <= 0) {\n      stats_.fail_verify_error_.inc();\n      ENVOY_LOG(debug, \"{}\", Utility::getX509VerificationErrorInfo(store_ctx));\n      return allow_untrusted_certificate_ ? 1 : ret;\n    }\n  }\n  Envoy::Ssl::ClientValidationStatus validated =\n      verifyCertificate(&leaf_cert,\n                        transport_socket_options != nullptr\n                            ? transport_socket_options->verifySubjectAltNameListOverride()\n                            : std::vector<std::string>{},\n                        subject_alt_name_matchers_);\n  if (ssl_extended_info) {\n    if (ssl_extended_info->certificateValidationStatus() ==\n        Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    } else if (validated != Envoy::Ssl::ClientValidationStatus::NotValidated) {\n      ssl_extended_info->setCertificateValidationStatus(validated);\n    }\n  }\n  int validation_status = verify_trusted_ca_\n                              ? validated != Envoy::Ssl::ClientValidationStatus::Failed\n                              : validated == Envoy::Ssl::ClientValidationStatus::Validated;\n  return allow_untrusted_certificate_ ? 1 : validation_status;\n}", "target": 1}
{"code": "static void process_blob(struct rev_info *revs,\n\t\t\t struct blob *blob,\n\t\t\t show_object_fn show,\n\t\t\t struct strbuf *path,\n\t\t\t const char *name,\n\t\t\t void *cb_data)\n{\n\tstruct object *obj = &blob->object;\n\tif (!revs->blob_objects)\n\t\treturn;\n\tif (!obj)\n\t\tdie(\"bad blob object\");\n\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\treturn;\n\tobj->flags |= SEEN;\n\tshow(obj, path, name, cb_data);\n}", "target": 1}
{"code": "bool MemoryManager::validate_user_read(const Process& process, VirtualAddress vaddr) const\n{\n    auto* region = region_from_vaddr(process, vaddr);\n    return region && region->is_readable();\n}", "target": 1}
{"code": "static uint8_t avrcp_handle_abort_continuing(struct avrcp *session,\n\t\t\t\t\t\tstruct avrcp_header *pdu,\n\t\t\t\t\t\tuint8_t transaction)\n{\n\tuint16_t len = ntohs(pdu->params_len);\n\tstruct pending_pdu *pending;\n\tif (len != 1 || session->pending_pdu == NULL)\n\t\tgoto err;\n\tpending = session->pending_pdu;\n\tif (pending->pdu_id != pdu->params[0])\n\t\tgoto err;\n\tsession_abort_pending_pdu(session);\n\tpdu->params_len = 0;\n\treturn AVC_CTYPE_ACCEPTED;\nerr:\n\tpdu->params_len = htons(1);\n\tpdu->params[0] = AVRCP_STATUS_INVALID_PARAM;\n\treturn AVC_CTYPE_REJECTED;\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicy::GrantReadRawCookies(int renderer_id) {\n  AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(renderer_id);\n  if (state == security_state_.end())\n    return;\n  state->second->GrantReadRawCookies();\n}", "target": 0}
{"code": "static unsigned char *oidc_cache_hash_passphrase(request_rec *r,\n\t\tconst char *passphrase) {\n\tunsigned char *key = NULL;\n\tunsigned int key_len = 0;\n\toidc_jose_error_t err;\n\tif (oidc_jose_hash_bytes(r->pool, OIDC_JOSE_ALG_SHA256,\n\t\t\t(const unsigned char *) passphrase, strlen(passphrase), &key,\n\t\t\t&key_len, &err) == FALSE) {\n\t\toidc_error(r, \"oidc_jose_hash_bytes returned an error: %s\", err.text);\n\t\treturn NULL;\n\t}\n\treturn key;\n}", "target": 1}
{"code": "parse_notification_delta(xmlTextReaderPtr reader,\n    struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head *tmp;\n\tunsigned long serial;\n\tint error;\n\terror = delta_head_create(&tmp);\n\tif (error)\n\t\treturn error;\n\terror = parse_long(reader, RRDP_ATTR_SERIAL, &serial);\n\tif (error)\n\t\tgoto delta_destroy;\n\ttmp->serial = serial;\n\terror = parse_doc_data(reader, true, true, &tmp->doc_data);\n\tif (error)\n\t\tgoto delta_destroy;\n\terror = deltas_parsed_add(&ctx->deltas, &tmp);\n\tif (error)\n\t\tgoto delta_destroy;\n\treturn 0;\ndelta_destroy:\n\tdelta_head_destroy(tmp);\n\treturn error;\n}", "target": 1}
{"code": "struct clock_source *dce80_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "int socketio_setoption(CONCRETE_IO_HANDLE socket_io, const char* optionName, const void* value)\n{\n    int result;\n    if (socket_io == NULL ||\n        optionName == NULL ||\n        value == NULL)\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        SOCKET_IO_INSTANCE* socket_io_instance = (SOCKET_IO_INSTANCE*)socket_io;\n        if (strcmp(optionName, \"tcp_keepalive\") == 0)\n        {\n            result = setsockopt(socket_io_instance->socket, SOL_SOCKET, SO_KEEPALIVE, value, sizeof(int));\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, \"tcp_keepalive_time\") == 0)\n        {\n#ifdef __APPLE__\n            result = setsockopt(socket_io_instance->socket, IPPROTO_TCP, TCP_KEEPALIVE, value, sizeof(int));\n#else\n            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPIDLE, value, sizeof(int));\n#endif\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, \"tcp_keepalive_interval\") == 0)\n        {\n            result = setsockopt(socket_io_instance->socket, SOL_TCP, TCP_KEEPINTVL, value, sizeof(int));\n            if (result == -1) result = errno;\n        }\n        else if (strcmp(optionName, OPTION_NET_INT_MAC_ADDRESS) == 0)\n        {\n#ifdef __APPLE__\n            LogError(\"option not supported.\");\n            result = MU_FAILURE;\n#else\n            if (strlen(value) == 0)\n            {\n                LogError(\"option value must be a valid mac address\");\n                result = MU_FAILURE;\n            }\n            else if ((socket_io_instance->target_mac_address = (char*)malloc(sizeof(char) * (strlen(value) + 1))) == NULL)\n            {\n                LogError(\"failed setting net_interface_mac_address option (malloc failed)\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(socket_io_instance->target_mac_address, value);\n                strtoup(socket_io_instance->target_mac_address);\n                result = 0;\n            }\n#endif\n        }\n        else if (strcmp(optionName, OPTION_ADDRESS_TYPE) == 0)\n        {\n            result = socketio_setaddresstype_option(socket_io_instance, (const char*)value);\n        }\n        else\n        {\n            result = MU_FAILURE;\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_element( bson *b, const char *name_or_null, const bson_iterator *elem ) {\n    bson_iterator next = *elem;\n    int size;\n    bson_iterator_next( &next );\n    size = next.cur - elem->cur;\n    if ( name_or_null == NULL ) {\n        if( bson_ensure_space( b, size ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append( b, elem->cur, size );\n    }\n    else {\n        int data_size = size - 2 - strlen( bson_iterator_key( elem ) );\n        bson_append_estart( b, elem->cur[0], name_or_null, data_size );\n        bson_append( b, bson_iterator_value( elem ), data_size );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "write(Protocol_* iprot, const StructInfo& structInfo, const void* object) {\n  DCHECK(object);\n  size_t written = iprot->writeStructBegin(structInfo.name);\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    const FieldInfo* end = structInfo.fieldInfos + structInfo.numFields;\n    const auto& unionId =\n        activeUnionMemberId(object, structInfo.unionExt->unionTypeOffset);\n    const FieldInfo* found = std::lower_bound(\n        structInfo.fieldInfos,\n        end,\n        unionId,\n        [](const FieldInfo& lhs, FieldID rhs) { return lhs.id < rhs; });\n    if (found < end && found->id == unionId) {\n      const OptionalThriftValue value = getValue(*found->typeInfo, object);\n      if (value.hasValue()) {\n        written += writeField(iprot, *found, value.value());\n      } else if (found->typeInfo->type == protocol::TType::T_STRUCT) {\n        written += iprot->writeFieldBegin(\n            found->name, found->typeInfo->type, found->id);\n        written += iprot->writeStructBegin(found->name);\n        written += iprot->writeStructEnd();\n        written += iprot->writeFieldStop();\n        written += iprot->writeFieldEnd();\n      }\n    }\n  } else {\n    for (std::int16_t index = 0; index < structInfo.numFields; index++) {\n      const auto& fieldInfo = structInfo.fieldInfos[index];\n      if (fieldInfo.isUnqualified || fieldInfo.issetOffset == 0 ||\n          fieldIsSet(object, fieldInfo.issetOffset)) {\n        const OptionalThriftValue value =\n            getValue(*fieldInfo.typeInfo, getMember(fieldInfo, object));\n        if (value.hasValue()) {\n          written += writeField(iprot, fieldInfo, value.value());\n        }\n      }\n    }\n  }\n  written += iprot->writeFieldStop();\n  written += iprot->writeStructEnd();\n  return written;\n}", "target": 1}
{"code": "string_copylc(uschar *s)\n{\nuschar *ss = store_get(Ustrlen(s) + 1);\nuschar *p = ss;\nwhile (*s != 0) *p++ = tolower(*s++);\n*p = 0;\nreturn ss;\n}", "target": 0}
{"code": "static int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\tpr_debug(\"\\n\");\n#endif\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; \n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\tparams->resp_avail(params->v);\n\treturn 0;\n}", "target": 1}
{"code": "do_encrypt (const RIJNDAEL_context *ctx,\n            unsigned char *bx, const unsigned char *ax)\n{\n#ifdef USE_AMD64_ASM\n  return _gcry_aes_amd64_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds,\n\t\t\t\t       encT);\n#elif defined(USE_ARM_ASM)\n  return _gcry_aes_arm_encrypt_block(ctx->keyschenc, bx, ax, ctx->rounds, encT);\n#else\n  return do_encrypt_fn (ctx, bx, ax);\n#endif \n}", "target": 1}
{"code": "queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)\n{\n\tspin_unlock(&hb->lock);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "trim_subnode_array(apr_array_header_t **array,\n                   int latest_any_var,\n                   apr_pool_t *scratch_pool)\n{\n  if (*array)\n    {\n      int i, dest;\n      for (i = 0, dest = 0; i < (*array)->nelts; ++i)\n        {\n          node_t *node = APR_ARRAY_IDX(*array, i, sorted_pattern_t).node;\n          if (!trim_tree(node, latest_any_var, scratch_pool))\n            {\n              if (i != dest)\n                APR_ARRAY_IDX(*array, dest, sorted_pattern_t)\n                  = APR_ARRAY_IDX(*array, i, sorted_pattern_t);\n              ++dest;\n            }\n        }\n      if (dest)\n        {\n          (*array)->nelts = dest;\n          return FALSE;\n        }\n      *array = NULL;\n    }\n  return TRUE;\n}", "target": 0}
{"code": "void AverageEvalQuantizedInt16(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  CalculateActivationRangeQuantized(context, params->activation, output,\n                                    &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<int16_t>(input), GetTensorShape(output), \\\n                    GetTensorData<int16_t>(output))\n  TF_LITE_AVERAGE_POOL(reference_integer_ops);\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "init_ctx_cont(OM_uint32 *minor_status, gss_ctx_id_t *ctx, gss_buffer_t buf,\n\t      gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 ret, tmpmin, acc_negState;\n\tunsigned char *ptr;\n\tspnego_gss_ctx_id_t sc;\n\tgss_OID supportedMech = GSS_C_NO_OID;\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\t*negState = REJECT;\n\t*tokflag = ERROR_TOKEN_SEND;\n\tptr = buf->value;\n\tret = get_negTokenResp(minor_status, ptr, buf->length,\n\t\t\t       &acc_negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (acc_negState == REJECT) {\n\t\t*minor_status = ERR_SPNEGO_NEGOTIATION_FAILED;\n\t\tmap_errcode(minor_status);\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (!sc->nego_done) {\n\t\tret = init_ctx_nego(minor_status, sc,\n\t\t\t\t    acc_negState,\n\t\t\t\t    supportedMech, responseToken,\n\t\t\t\t    mechListMIC,\n\t\t\t\t    negState, tokflag);\n\t} else if ((!sc->mech_complete && *responseToken == GSS_C_NO_BUFFER) ||\n\t\t   (sc->mech_complete && *responseToken != GSS_C_NO_BUFFER)) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t} else if (!sc->mech_complete ||\n\t\t   (sc->mic_reqd &&\n\t\t    (sc->ctx_flags & GSS_C_INTEG_FLAG))) {\n\t\t*negState = ACCEPT_INCOMPLETE;\n\t\t*tokflag = CONT_TOKEN_SEND;\n\t\tret = GSS_S_CONTINUE_NEEDED;\n\t} else {\n\t\t*negState = ACCEPT_COMPLETE;\n\t\t*tokflag = NO_TOKEN_SEND;\n\t\tret = GSS_S_COMPLETE;\n\t}\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID)\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\treturn ret;\n}", "target": 0}
{"code": "void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}", "target": 1}
{"code": "static inline pmd_t pmd_read_atomic(pmd_t *pmdp)\n{\n\treturn *pmdp;\n}", "target": 0}
{"code": "win_free_lsize(win_T *wp)\n{\n    if (wp != NULL)\n\tVIM_CLEAR(wp->w_lines);\n}", "target": 0}
{"code": "Item_cond_and::add_key_fields(JOIN *join, KEY_FIELD **key_fields,\n                              uint *and_level, table_map usable_tables,\n                              SARGABLE_PARAM **sargables)\n{\n  List_iterator_fast<Item> li(*argument_list());\n  KEY_FIELD *org_key_fields= *key_fields;\n  Item *item;\n  while ((item=li++))\n    item->add_key_fields(join, key_fields, and_level, usable_tables,\n                         sargables);\n  for (; org_key_fields != *key_fields ; org_key_fields++)\n    org_key_fields->level= *and_level;\n}", "target": 0}
{"code": "        bool erase() const { return erase_; }", "target": 0}
{"code": "static void on_bytes_received(void* context, const unsigned char* buffer, size_t size)\n{\n    unsigned char* new_received_bytes;\n    HTTP_HANDLE_DATA* http_instance = (HTTP_HANDLE_DATA*)context;\n    if (http_instance != NULL)\n    {\n        if (buffer == NULL)\n        {\n            http_instance->is_io_error = 1;\n            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, http_instance->received_bytes_count + size);\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }\n            else\n            {\n                http_instance->received_bytes = new_received_bytes;\n                if (memcpy(http_instance->received_bytes + http_instance->received_bytes_count, buffer, size) == NULL)\n                {\n                    http_instance->is_io_error = 1;\n                    LogError(\"Error copping received data to the HTTP bufffer\");\n                }\n                else\n                {\n                    http_instance->received_bytes_count += size;\n                }\n            }\n        }\n    }\n}", "target": 1}
{"code": "dotraplinkage void notrace do_int3(struct pt_regs *regs, long error_code)\n{\n#ifdef CONFIG_DYNAMIC_FTRACE\n\tif (unlikely(atomic_read(&modifying_ftrace_code)) &&\n\t    ftrace_int3_handler(regs))\n\t\treturn;\n#endif\n\tif (poke_int3_handler(regs))\n\t\treturn;\n\tist_enter(regs);\n\tRCU_LOCKDEP_WARN(!rcu_is_watching(), \"entry code didn't wake RCU\");\n#ifdef CONFIG_KGDB_LOW_LEVEL_TRAP\n\tif (kgdb_ll_trap(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n#endif \n#ifdef CONFIG_KPROBES\n\tif (kprobe_int3_handler(regs))\n\t\tgoto exit;\n#endif\n\tif (notify_die(DIE_INT3, \"int3\", regs, error_code, X86_TRAP_BP,\n\t\t\tSIGTRAP) == NOTIFY_STOP)\n\t\tgoto exit;\n\tdebug_stack_usage_inc();\n\tcond_local_irq_enable(regs);\n\tdo_trap(X86_TRAP_BP, SIGTRAP, \"int3\", regs, error_code, NULL);\n\tcond_local_irq_disable(regs);\n\tdebug_stack_usage_dec();\nexit:\n\tist_exit(regs);\n}", "target": 1}
{"code": "        int          GetU8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];\n        }", "target": 1}
{"code": "addMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type, \n                         size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex, \n                         size_t dimensionSize) {\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    status ret;\n    if(dimensionIndex == (dimensionSize - 1)) {\n        ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index),\n                              arrayDimensions[dimensionIndex], type);\n        (*index) += arrayDimensions[dimensionIndex];\n        return ret;\n    }\n    ret = writeJsonArrStart(ctx);\n    for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) {\n        ret |= writeJsonCommaIfNeeded(ctx);\n        ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions,\n                                        dimensionIndex + 1, dimensionSize);\n        ctx->commaNeeded[ctx->depth] = true;\n        if(ret != UA_STATUSCODE_GOOD)\n            return ret;\n    }\n    ret |= writeJsonArrEnd(ctx);\n    return ret;\n}", "target": 1}
{"code": "RestStatus RestAuthHandler::execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { \n    return RestStatus::DONE;\n  }\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n  _username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(_username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      std::string jwt = generateJwt(_username, password);\n      resultBuilder.add(\"jwt\", VPackValue(jwt));\n    }\n    _isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}", "target": 1}
{"code": "static bool nested_exit_on_nmi(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_NMI_EXITING;\n}", "target": 0}
{"code": "static std::string GetBaseFilename(const std::string &filepath) {\n  auto idx = filepath.find_last_of(\"/\\\\\");\n  if (idx != std::string::npos)\n    return filepath.substr(idx + 1);\n  return filepath;\n}", "target": 1}
{"code": "raptor_libxml_resolveEntity(void* user_data, \n                            const xmlChar *publicId, const xmlChar *systemId) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_resolveEntity(sax2->xc, publicId, systemId);\n}", "target": 1}
{"code": "static inline void nft_reg_store64(u32 *dreg, u64 val)\n{\n\tput_unaligned(val, (u64 *)dreg);\n}", "target": 1}
{"code": "deltas_head_sort(struct deltas_head *deltas, unsigned long max_serial)\n{\n\tunsigned long min_serial;\n\tstruct delta_head *cursor;\n\tarray_index i;\n\tint error;\n\tif (max_serial + 1 < deltas->len)\n\t\treturn pr_val_err(\"Deltas: Too many deltas (%zu) for serial %lu. (Negative serials not implemented.)\",\n\t\t    deltas->len, max_serial);\n\tmin_serial = max_serial + 1 - deltas->len;\n\tARRAYLIST_FOREACH(deltas, cursor, i) {\n\t\terror = swap_until_sorted(deltas->array, i, min_serial,\n\t\t    max_serial);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "GlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face, bool(face_options & gr_face_dumbRendering))),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),\n  _num_attrs(_glyphs ? _glyph_loader->num_attrs() : 0),\n  _upem(_glyphs ? _glyph_loader->units_per_em() : 0)\n{\n    if ((face_options & gr_face_preloadGlyphs) && _glyph_loader && _glyphs)\n    {\n        int numsubs = 0;\n        GlyphFace * const glyphs = new GlyphFace [_num_glyphs];\n        if (!glyphs)\n            return;\n        _glyphs[0] = _glyph_loader->read_glyph(0, glyphs[0], &numsubs);\n        const GlyphFace * loaded = _glyphs[0];\n        for (uint16 gid = 1; loaded && gid != _num_glyphs; ++gid)\n            _glyphs[gid] = loaded = _glyph_loader->read_glyph(gid, glyphs[gid], &numsubs);\n        if (!loaded)\n        {\n            _glyphs[0] = 0;\n            delete [] glyphs;\n        }\n        else if (numsubs > 0 && _boxes)\n        {\n            GlyphBox * boxes = (GlyphBox *)gralloc<char>(_num_glyphs * sizeof(GlyphBox) + numsubs * 8 * sizeof(float));\n            GlyphBox * currbox = boxes;\n            for (uint16 gid = 0; currbox && gid != _num_glyphs; ++gid)\n            {\n                _boxes[gid] = currbox;\n                currbox = _glyph_loader->read_box(gid, currbox, *_glyphs[gid]);\n            }\n            if (!currbox)\n            {\n                free(boxes);\n                _boxes[0] = 0;\n            }\n        }\n        delete _glyph_loader;\n        _glyph_loader = 0;\n    }\n    if (_glyphs && glyph(0) == 0)\n    {\n        free(_glyphs);\n        _glyphs = 0;\n        if (_boxes)\n        {\n            free(_boxes);\n            _boxes = 0;\n        }\n        _num_glyphs = _num_attrs = _upem = 0;\n    }\n}", "target": 1}
{"code": "static int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *line_state_p)\n{\n\tint rc;\n\tu8 *status_buf;\n\t__u16 status;\n\tdev_info(&port->serial->dev->dev, \"sending SIO Poll request\\n\");\n\tstatus_buf = kmalloc(KLSI_STATUSBUF_LEN, GFP_KERNEL);\n\tif (!status_buf)\n\t\treturn -ENOMEM;\n\tstatus_buf[0] = 0xff;\n\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, \n\t\t\t     0, \n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\tkfree(status_buf);\n\treturn rc;\n}", "target": 1}
{"code": "static int llcp_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct nfc_llcp_sock *llcp_sock = nfc_llcp_sock(sk);\n\tstruct nfc_llcp_local *local;\n\tstruct nfc_dev *dev;\n\tstruct sockaddr_nfc_llcp llcp_addr;\n\tint len, ret = 0;\n\tif (!addr || addr->sa_family != AF_NFC)\n\t\treturn -EINVAL;\n\tpr_debug(\"sk %p addr %p family %d\\n\", sk, addr, addr->sa_family);\n\tmemset(&llcp_addr, 0, sizeof(llcp_addr));\n\tlen = min_t(unsigned int, sizeof(llcp_addr), alen);\n\tmemcpy(&llcp_addr, addr, len);\n\tif (llcp_addr.dsap != 0)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != LLCP_CLOSED) {\n\t\tret = -EBADFD;\n\t\tgoto error;\n\t}\n\tdev = nfc_get_device(llcp_addr.dev_idx);\n\tif (dev == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto error;\n\t}\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\tllcp_sock->service_name_len = min_t(unsigned int,\n\t\t\t\t\t    llcp_addr.service_name_len,\n\t\t\t\t\t    NFC_LLCP_MAX_SERVICE_NAME);\n\tllcp_sock->service_name = kmemdup(llcp_addr.service_name,\n\t\t\t\t\t  llcp_sock->service_name_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tllcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);\n\tif (llcp_sock->ssap == LLCP_SAP_MAX) {\n\t\tret = -EADDRINUSE;\n\t\tgoto put_dev;\n\t}\n\tllcp_sock->reserved_ssap = llcp_sock->ssap;\n\tnfc_llcp_sock_link(&local->sockets, sk);\n\tpr_debug(\"Socket bound to SAP %d\\n\", llcp_sock->ssap);\n\tsk->sk_state = LLCP_BOUND;\nput_dev:\n\tnfc_put_device(dev);\nerror:\n\trelease_sock(sk);\n\treturn ret;\n}", "target": 0}
{"code": "void Ogg::XiphComment::parse(const ByteVector &data)\n{\n  int pos = 0;\n  int vendorLength = data.mid(0, 4).toUInt(false);\n  pos += 4;\n  d->vendorID = String(data.mid(pos, vendorLength), String::UTF8);\n  pos += vendorLength;\n  int commentFields = data.mid(pos, 4).toUInt(false);\n  pos += 4;\n  for(int i = 0; i < commentFields; i++) {\n    int commentLength = data.mid(pos, 4).toUInt(false);\n    pos += 4;\n    String comment = String(data.mid(pos, commentLength), String::UTF8);\n    pos += commentLength;\n    int commentSeparatorPosition = comment.find(\"=\");\n    String key = comment.substr(0, commentSeparatorPosition);\n    String value = comment.substr(commentSeparatorPosition + 1);\n    addField(key, value, false);\n  }\n}", "target": 1}
{"code": "GF_Err pasp_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_PixelAspectRatioBox *ptr = (GF_PixelAspectRatioBox *)s;\n\tGF_Err e = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->hSpacing);\n\tgf_bs_write_u32(bs, ptr->vSpacing);\n\treturn GF_OK;\n}", "target": 0}
{"code": "check_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    iterate_rc4(O_data, key_bytes, key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;\n}", "target": 1}
{"code": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}", "target": 1}
{"code": "static bool is_valid_guid(const char *guid) {\n\tif (!guid) {\n\t\treturn false;\n\t}\n\tsize_t i;\n\tfor (i = 0; guid[i]; i++) {\n\t\tif (!isxdigit (guid[i])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn i >= 33; \n}", "target": 0}
{"code": "void snd_msndmidi_input_read(void *mpuv)\n{\n\tunsigned long flags;\n\tstruct snd_msndmidi *mpu = mpuv;\n\tvoid *pwMIDQData = mpu->dev->mappedbase + MIDQ_DATA_BUFF;\n\tspin_lock_irqsave(&mpu->input_lock, flags);\n\twhile (readw(mpu->dev->MIDQ + JQS_wTail) !=\n\t       readw(mpu->dev->MIDQ + JQS_wHead)) {\n\t\tu16 wTmp, val;\n\t\tval = readw(pwMIDQData + 2 * readw(mpu->dev->MIDQ + JQS_wHead));\n\t\t\tif (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,\n\t\t\t\t     &mpu->mode))\n\t\t\t\tsnd_rawmidi_receive(mpu->substream_input,\n\t\t\t\t\t\t    (unsigned char *)&val, 1);\n\t\twTmp = readw(mpu->dev->MIDQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(mpu->dev->MIDQ + JQS_wSize))\n\t\t\twritew(0,  mpu->dev->MIDQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp,  mpu->dev->MIDQ + JQS_wHead);\n\t}\n\tspin_unlock_irqrestore(&mpu->input_lock, flags);\n}", "target": 1}
{"code": "const wchar_t *LibRaw_file_datastream::wfname()\n{\n  return wfilename.size() > 0 ? wfilename.c_str() : NULL;\n}", "target": 0}
{"code": "free_link_refs(struct link_ref **references)\n{\n\tsize_t i;\n\tfor (i = 0; i < REF_TABLE_SIZE; ++i) {\n\t\tstruct link_ref *r = references[i];\n\t\tstruct link_ref *next;\n\t\twhile (r) {\n\t\t\tnext = r->next;\n\t\t\tbufrelease(r->label);\n\t\t\tbufrelease(r->link);\n\t\t\tbufrelease(r->title);\n\t\t\tfree(r);\n\t\t\tr = next;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void svg_parse_preserveaspectratio(SVG_PreserveAspectRatio *par, char *attribute_content, GF_Err *out_e)\n{\n\tchar *content = attribute_content;\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"defer\")) {\n\t\tpar->defer = 1;\n\t\tcontent += 4;\n\t} else {\n\t\tcontent = attribute_content;\n\t}\n\twhile (*content == ' ') content++;\n\tif (strstr(content, \"none\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_NONE;\n\t\tcontent+=4;\n\t} else if (strstr(content, \"xMinYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMin\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMIN;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMid\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMID;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMinYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMINYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMidYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMIDYMAX;\n\t\tcontent+=8;\n\t} else if (strstr(content, \"xMaxYMax\")) {\n\t\tpar->align = SVG_PRESERVEASPECTRATIO_XMAXYMAX;\n\t\tcontent+=8;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\twhile (*content == ' ') content++;\n\tif (*content == 0) return;\n\tif (strstr(content, \"meet\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_MEET;\n\t} else if (strstr(content, \"slice\")) {\n\t\tpar->meetOrSlice = SVG_MEETORSLICE_SLICE;\n\t} else {\n\t\t*out_e = GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}", "target": 1}
{"code": "static int sched_read_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr,\n\t\t\t   unsigned int usize)\n{\n\tint ret;\n\tif (!access_ok(VERIFY_WRITE, uattr, usize))\n\t\treturn -EFAULT;\n\tif (usize < sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tattr->size = usize;\n\t}\n\tret = copy_to_user(uattr, attr, usize);\n\tif (ret)\n\t\treturn -EFAULT;\nout:\n\treturn ret;\nerr_size:\n\tret = -E2BIG;\n\tgoto out;\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_buffer_size( const bson *b ) {\n    return (b->cur - b->data + 1);\n}", "target": 1}
{"code": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n        assert(f);\n        assert(ret);\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n        path_simplify(p);\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n                delete_trailing_chars(p, \"/\");\n                p = skip_leading_chars(p, \"/\");\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 1}
{"code": "ppmd_read(void *p)\n{\n  struct archive_read *a = ((IByteIn*)p)->a;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n  Byte b;\n  if (!rar_br_read_ahead(a, br, 8))\n  {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                      \"Truncated RAR file data\");\n    rar->valid = 0;\n    return 0;\n  }\n  b = rar_br_bits(br, 8);\n  rar_br_consume(br, 8);\n  return b;\n}", "target": 0}
{"code": "static void lwp_read_int32(FILE *fin, int32_t &d) {\n  fread(&d, sizeof(d), 1, fin);\n}", "target": 0}
{"code": "int processCommand(redisClient *c) {\n    struct redisCommand *cmd;\n    if (!strcasecmp(c->argv[0]->ptr,\"quit\")) {\n        addReply(c,shared.ok);\n        c->flags |= REDIS_CLOSE_AFTER_REPLY;\n        return REDIS_ERR;\n    }\n    cmd = lookupCommand(c->argv[0]->ptr);\n    if (!cmd) {\n        addReplyErrorFormat(c,\"unknown command '%s'\",\n            (char*)c->argv[0]->ptr);\n        return REDIS_OK;\n    } else if ((cmd->arity > 0 && cmd->arity != c->argc) ||\n               (c->argc < -cmd->arity)) {\n        addReplyErrorFormat(c,\"wrong number of arguments for '%s' command\",\n            cmd->name);\n        return REDIS_OK;\n    }\n    if (server.requirepass && !c->authenticated && cmd->proc != authCommand) {\n        addReplyError(c,\"operation not permitted\");\n        return REDIS_OK;\n    }\n    if (server.maxmemory) freeMemoryIfNeeded();\n    if (server.maxmemory && (cmd->flags & REDIS_CMD_DENYOOM) &&\n        zmalloc_used_memory() > server.maxmemory)\n    {\n        addReplyError(c,\"command not allowed when used memory > 'maxmemory'\");\n        return REDIS_OK;\n    }\n    if ((dictSize(c->pubsub_channels) > 0 || listLength(c->pubsub_patterns) > 0)\n        &&\n        cmd->proc != subscribeCommand && cmd->proc != unsubscribeCommand &&\n        cmd->proc != psubscribeCommand && cmd->proc != punsubscribeCommand) {\n        addReplyError(c,\"only (P)SUBSCRIBE / (P)UNSUBSCRIBE / QUIT allowed in this context\");\n        return REDIS_OK;\n    }\n    if (server.masterhost && server.replstate != REDIS_REPL_CONNECTED &&\n        server.repl_serve_stale_data == 0 &&\n        cmd->proc != infoCommand && cmd->proc != slaveofCommand)\n    {\n        addReplyError(c,\n            \"link with MASTER is down and slave-serve-stale-data is set to no\");\n        return REDIS_OK;\n    }\n    if (server.loading && cmd->proc != infoCommand) {\n        addReply(c, shared.loadingerr);\n        return REDIS_OK;\n    }\n    if (c->flags & REDIS_MULTI &&\n        cmd->proc != execCommand && cmd->proc != discardCommand &&\n        cmd->proc != multiCommand && cmd->proc != watchCommand)\n    {\n        queueMultiCommand(c,cmd);\n        addReply(c,shared.queued);\n    } else {\n        if (server.vm_enabled && server.vm_max_threads > 0 &&\n            blockClientOnSwappedKeys(c,cmd)) return REDIS_ERR;\n        call(c,cmd);\n    }\n    return REDIS_OK;\n}", "target": 1}
{"code": "static void apply_server_config(request_rec *r)\n{\n    apr_socket_t *csd;\n    csd = ap_get_conn_socket(r->connection);\n    apr_socket_timeout_set(csd, r->server->timeout);\n    r->per_dir_config = r->server->lookup_defaults;\n}", "target": 0}
{"code": "static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n    beyond = pData + stride * height;\n    pix = pData;\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            return OPJ_FALSE;\n        }\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n            }\n        } else {\n            c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n            if (c == 0x00) { \n                x = 0;\n                ++y;\n                pix = pData + y * stride + x;\n            } else if (c == 0x01) { \n                break;\n            } else if (c == 0x02) { \n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                x += (OPJ_UINT32)c;\n                c = getc(IN);\n                if (c == EOF) {\n                    return OPJ_FALSE;\n                }\n                y += (OPJ_UINT32)c;\n                pix = pData + y * stride + x;\n            } else { \n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                    }\n                    c1 = (OPJ_UINT8)c1_int;\n                    *pix = c1;\n                }\n                if ((OPJ_UINT32)c & 1U) { \n                    c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n        }\n    }\n    return OPJ_TRUE;\n}", "target": 1}
{"code": "cmsBool  CMSEXPORT cmsAppendNamedColor(cmsNAMEDCOLORLIST* NamedColorList,\n                                       const char* Name,\n                                       cmsUInt16Number PCS[3], cmsUInt16Number Colorant[cmsMAXCHANNELS])\n{\n    cmsUInt32Number i;\n    if (NamedColorList == NULL) return FALSE;\n    if (NamedColorList ->nColors + 1 > NamedColorList ->Allocated) {\n        if (!GrowNamedColorList(NamedColorList)) return FALSE;\n    }\n    for (i=0; i < NamedColorList ->ColorantCount; i++)\n        NamedColorList ->List[NamedColorList ->nColors].DeviceColorant[i] = Colorant == NULL? 0 : Colorant[i];\n    for (i=0; i < 3; i++)\n        NamedColorList ->List[NamedColorList ->nColors].PCS[i] = PCS == NULL ? 0 : PCS[i];\n    if (Name != NULL) {\n        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,\n                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name));\n        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;\n    }\n    else\n        NamedColorList ->List[NamedColorList ->nColors].Name[0] = 0;\n    NamedColorList ->nColors++;\n    return TRUE;\n}", "target": 1}
{"code": "    std::string& attrf(int ncid, int varId, const char * attrName, std::string& alloc)\n    {\n        alloc = \"\";\n        size_t len = 0;\n        nc_inq_attlen(ncid, varId, attrName, &len);\n        if(len < 1)\n        {\n            return alloc;\n        }\n        char attr_vals[NC_MAX_NAME + 1];\n        memset(attr_vals, 0, NC_MAX_NAME + 1);\n        if(nc_get_att_text(ncid, varId, attrName, attr_vals) != NC_NOERR)\n        {\n            return alloc;\n        }\n        alloc = std::string(attr_vals);\n        return alloc;\n    }", "target": 1}
{"code": "  void createDebugInfo() override {\n    llvm_unreachable(\"Accessing debug info from a lazy module\");\n  }", "target": 1}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(nullptr);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "static int build_open_gop_key_points(AVStream *st)\n{\n    int k;\n    int sample_id = 0;\n    uint32_t cra_index;\n    MOVStreamContext *sc = st->priv_data;\n    if (st->codecpar->codec_id != AV_CODEC_ID_HEVC || !sc->sync_group_count)\n        return 0;\n    sc->sample_offsets_count = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        sc->sample_offsets_count += sc->ctts_data[i].count;\n    av_freep(&sc->sample_offsets);\n    sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));\n    if (!sc->sample_offsets)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->ctts_count; i++)\n        for (int j = 0; j < sc->ctts_data[i].count; j++)\n             sc->sample_offsets[k++] = sc->ctts_data[i].duration;\n    cra_index = get_sgpd_sync_index(sc, HEVC_NAL_CRA_NUT); \n    if (!cra_index)\n        return 0;\n    sc->open_key_samples_count = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++)\n        if (sc->sync_group[i].index == cra_index)\n            sc->open_key_samples_count += sc->sync_group[i].count;\n    av_freep(&sc->open_key_samples);\n    sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));\n    if (!sc->open_key_samples)\n        return AVERROR(ENOMEM);\n    k = 0;\n    for (uint32_t i = 0; i < sc->sync_group_count; i++) {\n        const MOVSbgp *sg = &sc->sync_group[i];\n        if (sg->index == cra_index)\n            for (uint32_t j = 0; j < sg->count; j++)\n                sc->open_key_samples[k++] = sample_id;\n        sample_id += sg->count;\n    }\n    sc->min_sample_duration = UINT_MAX;\n    for (uint32_t i = 0; i < sc->stts_count; i++)\n        sc->min_sample_duration = FFMIN(sc->min_sample_duration, sc->stts_data[i].duration);\n    return 0;\n}", "target": 1}
{"code": "nfsd4_encode_layoutget(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_layoutget *lgp)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[lgp->lg_layout_type];\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, nfserr);\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 36 + sizeof(stateid_opaque_t));\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(1);\t\n\t*p++ = cpu_to_be32(lgp->lg_sid.si_generation);\n\tp = xdr_encode_opaque_fixed(p, &lgp->lg_sid.si_opaque,\n\t\t\t\t    sizeof(stateid_opaque_t));\n\t*p++ = cpu_to_be32(1);\t\n\tp = xdr_encode_hyper(p, lgp->lg_seg.offset);\n\tp = xdr_encode_hyper(p, lgp->lg_seg.length);\n\t*p++ = cpu_to_be32(lgp->lg_seg.iomode);\n\t*p++ = cpu_to_be32(lgp->lg_layout_type);\n\tnfserr = ops->encode_layoutget(xdr, lgp);\nout:\n\tkfree(lgp->lg_content);\n\treturn nfserr;\n}", "target": 1}
{"code": "TfLiteStatus PreluPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  PreluParams* params = static_cast<PreluParams*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  const TfLiteTensor* alpha = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, alpha != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  return CalculatePreluParams(input, alpha, output, params);\n}", "target": 0}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             const TfLiteConvParams* params, int width,\n                             int height, int filter_width, int filter_height,\n                             int out_width, int out_height,\n                             const TfLiteType data_type, OpData* data) {\n  bool has_bias = node->inputs->size == 3;\n  TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  auto padding = params->padding;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width,\n      params->dilation_height_factor, params->dilation_width_factor, height,\n      width, filter_height, filter_width, padding, &out_height, &out_width);\n  if (data_type != kTfLiteFloat32) {\n    const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n    TF_LITE_ENSURE(context, input != nullptr);\n    const TfLiteTensor* filter = GetInput(context, node, kFilterTensor);\n    TF_LITE_ENSURE(context, filter != nullptr);\n    const TfLiteTensor* bias =\n        GetOptionalInputTensor(context, node, kBiasTensor);\n    TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n    TF_LITE_ENSURE(context, output != nullptr);\n    int output_channels = filter->dims->data[kConvQuantizedDimension];\n    TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams(\n        context, input, filter, bias, output, params->activation,\n        &data->output_multiplier, &data->output_shift,\n        &data->output_activation_min, &data->output_activation_max,\n        data->per_channel_output_multiplier,\n        reinterpret_cast<int*>(data->per_channel_output_shift),\n        output_channels));\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));\n    buttonBox->button(QDialogButtonBox::Cancel)->setFocus();\n  }", "target": 1}
{"code": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!IsSupportedType(input->type)) {\n    TF_LITE_KERNEL_LOG(context, \"Input data type %s (%d) is not supported.\",\n                       TfLiteTypeGetName(input->type), input->type);\n    return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void reset_active(struct i915_request *rq,\n\t\t\t struct intel_engine_cs *engine)\n{\n\tstruct intel_context * const ce = rq->hw_context;\n\tu32 head;\n\tGEM_TRACE(\"%s(%s): { rq=%llx:%lld }\\n\",\n\t\t  __func__, engine->name, rq->fence.context, rq->fence.seqno);\n\tif (i915_request_completed(rq))\n\t\thead = rq->tail;\n\telse\n\t\thead = active_request(ce->timeline, rq)->head;\n\tce->ring->head = intel_ring_wrap(ce->ring, head);\n\tintel_ring_update_space(ce->ring);\n\trestore_default_state(ce, engine);\n\t__execlists_update_reg_state(ce, engine);\n\tce->lrc_desc |= CTX_DESC_FORCE_RESTORE;\n}", "target": 0}
{"code": "int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;\n\t\t}\n\t\tif (dev->ops->check_presence)\n\t\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\trc = dev->ops->im_transceive(dev, dev->active_target, skb, cb,\n\t\t\t\t\t     cb_context);\n\t\tif (!rc && dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t} else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) {\n\t\trc = dev->ops->tm_send(dev, skb);\n\t} else {\n\t\trc = -ENOTCONN;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n    if (!pdu)\n        return NULL;\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n    if (pdu->securityStateRef &&\n        pdu->command == SNMP_MSG_TRAP2) {\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,\n                (struct usmStateReference **) &newpdu->securityStateRef );\n        if (ret)\n        {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&\n        sptr->pdu_clone != NULL) {\n        (*sptr->pdu_clone) (pdu, newpdu);\n    }\n    return newpdu;\n}", "target": 1}
{"code": "static int cg_rmdir(const char *path)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tfprintf(stderr, \"rmdir: verifying access to %s:%s (req path %s)\\n\",\n\t\t\tcontroller, cgdir, path);\n\tif (!fc_may_access(fc, controller, cgdir, NULL, O_WRONLY)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, cgroup, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!cgfs_remove(controller, cgroup)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t   __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[12];\n\tstruct keydata *keyptr = get_keyptr();\n\tmemcpy(hash, saddr, 16);\n\thash[4] = ((__force u16)sport << 16) + (__force u16)dport;\n\tmemcpy(&hash[5], keyptr->secret, sizeof(__u32) * 7);\n\tseq = twothirdsMD4Transform((const __u32 *)daddr, hash) & HASH_MASK;\n\tseq += keyptr->count;\n\tseq += ktime_to_ns(ktime_get_real());\n\treturn seq;\n}", "target": 1}
{"code": "PackLinuxElf32::elf_find_dynamic(unsigned int key) const\n{\n    Elf32_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) {\n        unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val));\n        if (t) {\n            return t + file_image;\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "daemon_AuthUserPwd(char *username, char *password, char *errbuf)\n{\n#ifdef _WIN32\n\tHANDLE Token;\n\tif (LogonUser(username, \".\", password, LOGON32_LOGON_NETWORK, LOGON32_PROVIDER_DEFAULT, &Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"LogonUser() failed\");\n\t\treturn -1;\n\t}\n\tif (ImpersonateLoggedOnUser(Token) == 0)\n\t{\n\t\tpcap_fmt_errmsg_for_win32_err(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    GetLastError(), \"ImpersonateLoggedOnUser() failed\");\n\t\tCloseHandle(Token);\n\t\treturn -1;\n\t}\n\tCloseHandle(Token);\n\treturn 0;\n#else\n\tstruct passwd *user;\n\tchar *user_password;\n#ifdef HAVE_GETSPNAM\n\tstruct spwd *usersp;\n#endif\n\tif ((user = getpwnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n#ifdef HAVE_GETSPNAM\n\tif ((usersp = getspnam(username)) == NULL)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tuser_password = usersp->sp_pwdp;\n#else\n\tuser_password = user->pw_passwd;\n#endif\n\tif (strcmp(user_password, (char *) crypt(password, user_password)) != 0)\n\t{\n\t\tpcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, \"Authentication failed: user name or password incorrect\");\n\t\treturn -1;\n\t}\n\tif (setuid(user->pw_uid))\n\t{\n\t\tpcap_fmt_errmsg_for_errno(errbuf, PCAP_ERRBUF_SIZE,\n\t\t    errno, \"setuid\");\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}", "target": 1}
{"code": "static ssize_t mem_write(struct file * file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tint copied;\n\tchar *page;\n\tstruct task_struct *task = get_proc_task(file->f_path.dentry->d_inode);\n\tunsigned long dst = *ppos;\n\tcopied = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (!MAY_PTRACE(task) || !ptrace_may_attach(task))\n\t\tgoto out;\n\tcopied = -ENOMEM;\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\tcopied = 0;\n\twhile (count > 0) {\n\t\tint this_len, retval;\n\t\tthis_len = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tif (copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tretval = access_process_vm(task, dst, page, this_len, 1);\n\t\tif (!retval) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tcopied += retval;\n\t\tbuf += retval;\n\t\tdst += retval;\n\t\tcount -= retval;\t\t\t\n\t}\n\t*ppos = dst;\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn copied;\n}", "target": 0}
{"code": "SkBitmap Clipboard::ReadImage(Buffer buffer) const {\n  ScopedGObject<GdkPixbuf>::Type pixbuf(\n      gtk_clipboard_wait_for_image(clipboard_));\n  if (!pixbuf.get())\n    return SkBitmap();\n  gfx::CanvasSkia canvas(gdk_pixbuf_get_width(pixbuf.get()),\n                         gdk_pixbuf_get_height(pixbuf.get()),\n                         false);\n  {\n    skia::ScopedPlatformPaint scoped_platform_paint(canvas.sk_canvas());\n    cairo_t* context = scoped_platform_paint.GetPlatformSurface();\n    gdk_cairo_set_source_pixbuf(context, pixbuf.get(), 0.0, 0.0);\n    cairo_paint(context);\n  }\n  return canvas.ExtractBitmap();\n}", "target": 0}
{"code": "static int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)\n{\n\treturn __verify_planes_array(vb, pb);\n}", "target": 0}
{"code": "static void* my_gballoc_malloc(size_t size)\n{\n    return malloc(size);\n}", "target": 0}
{"code": "static Status ValidateFunctionNotRecursive(const FunctionDef& function) {\n  const auto& function_name = function.signature().name();\n  for (const auto& node : function.node_def()) {\n    if (node.op() == function_name) {\n      return errors::FailedPrecondition(\n          \"Function \", function_name,\n          \" is self recursive and TensorFlow does not support this scenario.\");\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "R_API char *r_cons_hud_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_ansi_strip (o);\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}", "target": 0}
{"code": "    size_t SonyMnHeader::size() const\n    {\n        return sizeOfSignature();\n    }", "target": 0}
{"code": "static int attach_link(LINK_HANDLE link, ON_ENDPOINT_FRAME_RECEIVED* on_frame_received)\n{\n    umock_c_reset_all_calls();\n    STRICT_EXPECTED_CALL(session_begin(TEST_SESSION_HANDLE));\n    STRICT_EXPECTED_CALL(session_start_link_endpoint(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG, IGNORED_PTR_ARG, IGNORED_PTR_ARG, link))\n        .CaptureArgumentValue_frame_received_callback(on_frame_received);\n    return link_attach(link, test_on_transfer_received, test_on_link_state_changed, test_on_link_flow_on, NULL);\n}", "target": 0}
{"code": "static long vbg_misc_device_ioctl(struct file *filp, unsigned int req,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct vbg_session *session = filp->private_data;\n\tsize_t returned_size, size;\n\tstruct vbg_ioctl_hdr hdr;\n\tbool is_vmmdev_req;\n\tint ret = 0;\n\tvoid *buf;\n\tif (copy_from_user(&hdr, (void *)arg, sizeof(hdr)))\n\t\treturn -EFAULT;\n\tif (hdr.version != VBG_IOCTL_HDR_VERSION)\n\t\treturn -EINVAL;\n\tif (hdr.size_in < sizeof(hdr) ||\n\t    (hdr.size_out && hdr.size_out < sizeof(hdr)))\n\t\treturn -EINVAL;\n\tsize = max(hdr.size_in, hdr.size_out);\n\tif (_IOC_SIZE(req) && _IOC_SIZE(req) != size)\n\t\treturn -EINVAL;\n\tif (size > SZ_16M)\n\t\treturn -E2BIG;\n\tis_vmmdev_req = (req & ~IOCSIZE_MASK) == VBG_IOCTL_VMMDEV_REQUEST(0) ||\n\t\t\t req == VBG_IOCTL_VMMDEV_REQUEST_BIG;\n\tif (is_vmmdev_req)\n\t\tbuf = vbg_req_alloc(size, VBG_IOCTL_HDR_TYPE_DEFAULT);\n\telse\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(buf, (void *)arg, hdr.size_in)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (hdr.size_in < size)\n\t\tmemset(buf + hdr.size_in, 0, size -  hdr.size_in);\n\tret = vbg_core_ioctl(session, req, buf);\n\tif (ret)\n\t\tgoto out;\n\treturned_size = ((struct vbg_ioctl_hdr *)buf)->size_out;\n\tif (returned_size > size) {\n\t\tvbg_debug(\"%s: too much output data %zu > %zu\\n\",\n\t\t\t  __func__, returned_size, size);\n\t\treturned_size = size;\n\t}\n\tif (copy_to_user((void *)arg, buf, returned_size) != 0)\n\t\tret = -EFAULT;\nout:\n\tif (is_vmmdev_req)\n\t\tvbg_req_free(buf, size);\n\telse\n\t\tkfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "static inline uint32_t mp_clz_mpi(mp_int_t x) {\n    MP_STATIC_ASSERT(sizeof(mp_int_t) == sizeof(long long)\n        || sizeof(mp_int_t) == sizeof(long));\n    if (sizeof(mp_int_t) == sizeof(long)) {\n        return mp_clzl(x);\n    } else {\n        return mp_clzll(x);\n    }\n}", "target": 0}
{"code": "snmp_ber_decode_length(unsigned char *buff, uint32_t *buff_len, uint8_t *length)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n  *length = *buff++;\n  (*buff_len)--;\n  return buff;\n}", "target": 1}
{"code": "static void free_states(struct bpf_verifier_env *env)\n{\n\tstruct bpf_verifier_state_list *sl, *sln;\n\tint i;\n\tsl = env->free_list;\n\twhile (sl) {\n\t\tsln = sl->next;\n\t\tfree_verifier_state(&sl->state, false);\n\t\tkfree(sl);\n\t\tsl = sln;\n\t}\n\tenv->free_list = NULL;\n\tif (!env->explored_states)\n\t\treturn;\n\tfor (i = 0; i < state_htab_size(env); i++) {\n\t\tsl = env->explored_states[i];\n\t\twhile (sl) {\n\t\t\tsln = sl->next;\n\t\t\tfree_verifier_state(&sl->state, false);\n\t\t\tkfree(sl);\n\t\t\tsl = sln;\n\t\t}\n\t\tenv->explored_states[i] = NULL;\n\t}\n}", "target": 0}
{"code": "cib_recv_plaintext(int sock)\n{\n    char *buf = NULL;\n    ssize_t rc = 0;\n    ssize_t len = 0;\n    ssize_t chunk_size = 512;\n    buf = calloc(1, chunk_size);\n    while (1) {\n        errno = 0;\n        rc = read(sock, buf + len, chunk_size);\n        crm_trace(\"Got %d more bytes. errno=%d\", (int)rc, errno);\n        if (errno == EINTR || errno == EAGAIN) {\n            crm_trace(\"Retry: %d\", (int)rc);\n            if (rc > 0) {\n                len += rc;\n                buf = realloc(buf, len + chunk_size);\n                CRM_ASSERT(buf != NULL);\n            }\n        } else if (rc < 0) {\n            crm_perror(LOG_ERR, \"Error receiving message: %d\", (int)rc);\n            goto bail;\n        } else if (rc == chunk_size) {\n            len += rc;\n            chunk_size *= 2;\n            buf = realloc(buf, len + chunk_size);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else if (buf[len + rc - 1] != 0) {\n            crm_trace(\"Last char is %d '%c'\", buf[len + rc - 1], buf[len + rc - 1]);\n            crm_trace(\"Retry with %d more bytes\", (int)chunk_size);\n            len += rc;\n            buf = realloc(buf, len + chunk_size);\n            CRM_ASSERT(buf != NULL);\n        } else {\n            return buf;\n        }\n    }\n  bail:\n    free(buf);\n    return NULL;\n}", "target": 1}
{"code": "STATIC void\nS_put_code_point(pTHX_ SV *sv, UV c)\n{\n    PERL_ARGS_ASSERT_PUT_CODE_POINT;\n    if (c > 255) {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x{%04\" UVXf \"}\", c);\n    }\n    else if (isPRINT(c)) {\n\tconst char string = (char) c;\n\tif (isBACKSLASHED_PUNCT(c) || c == '{' || c == '}')\n\t    sv_catpvs(sv, \"\\\\\");\n\tsv_catpvn(sv, &string, 1);\n    }\n    else if (isMNEMONIC_CNTRL(c)) {\n        Perl_sv_catpvf(aTHX_ sv, \"%s\", cntrl_to_mnemonic((U8) c));\n    }\n    else {\n        Perl_sv_catpvf(aTHX_ sv, \"\\\\x%02X\", (U8) c);\n    }", "target": 0}
{"code": "static pj_status_t pjsip_auth_verify( const pjsip_authorization_hdr *hdr,\n\t\t\t\t      const pj_str_t *method,\n\t\t\t\t      const pjsip_cred_info *cred_info )\n{\n    if (pj_stricmp(&hdr->scheme, &pjsip_DIGEST_STR) == 0) {\n\tchar digest_buf[PJSIP_MD5STRLEN];\n\tpj_str_t digest;\n\tconst pjsip_digest_credential *dig = &hdr->credential.digest;\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->username, &cred_info->username) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tPJ_ASSERT_RETURN(pj_strcmp(&dig->realm, &cred_info->realm) == 0,\n\t\t\t PJ_EINVALIDOP);\n\tdigest.ptr = digest_buf;\n\tdigest.slen = PJSIP_MD5STRLEN;\n\tpjsip_auth_create_digest(&digest, \n\t\t\t\t &hdr->credential.digest.nonce,\n\t\t\t\t &hdr->credential.digest.nc, \n\t\t\t\t &hdr->credential.digest.cnonce,\n\t\t\t\t &hdr->credential.digest.qop,\n\t\t\t\t &hdr->credential.digest.uri,\n\t\t\t\t &cred_info->realm,\n\t\t\t\t cred_info, \n\t\t\t\t method );\n\treturn (pj_stricmp(&digest, &hdr->credential.digest.response) == 0) ?\n\t       PJ_SUCCESS : PJSIP_EAUTHINVALIDDIGEST;\n    } else {\n\tpj_assert(!\"Unsupported authentication scheme\");\n\treturn PJSIP_EINVALIDAUTHSCHEME;\n    }\n}", "target": 1}
{"code": "void ipc_rcu_getref(void *ptr)\n{\n\tcontainer_of(ptr, struct ipc_rcu_hdr, data)->refcount++;\n}", "target": 1}
{"code": "static char *get_object(\n    FILE         *fp,\n    int           obj_id,\n    const xref_t *xref,\n    size_t       *size,\n    int          *is_stream)\n{\n    static const int    blk_sz = 256;\n    int                 i, total_sz, read_sz, n_blks, search, stream;\n    size_t              obj_sz;\n    char               *c, *data;\n    long                start;\n    const xref_entry_t *entry;\n    if (size)\n      *size = 0;\n    if (is_stream)\n      *is_stream = 0;\n    start = ftell(fp);\n    entry = NULL;\n    for (i=0; i<xref->n_entries; i++)\n      if (xref->entries[i].obj_id == obj_id)\n      {\n          entry = &xref->entries[i];\n          break;\n      }\n    if (!entry)\n      return NULL;\n    fseek(fp, entry->offset, SEEK_SET);\n    obj_sz = 0;    \n    total_sz = 0;  \n    n_blks = 1;\n    data = malloc(blk_sz * n_blks);\n    memset(data, 0, blk_sz * n_blks);\n    stream = 0;\n    while ((read_sz = fread(data+total_sz, 1, blk_sz-1, fp)) && !ferror(fp))\n    {\n        total_sz += read_sz;\n        *(data + total_sz) = '\\0';\n        if (total_sz + blk_sz >= (blk_sz * n_blks))\n          data = realloc(data, blk_sz * (++n_blks));\n        search = total_sz - read_sz;\n        if (search < 0)\n          search = 0;\n        if ((c = strstr(data + search, \"endobj\")))\n        {\n            *(c + strlen(\"endobj\") + 1) = '\\0';\n            obj_sz = (void *)strstr(data + search, \"endobj\") - (void *)data;\n            obj_sz += strlen(\"endobj\") + 1;\n            break;\n        }\n        else if (strstr(data, \"stream\"))\n          stream = 1;\n    }\n    clearerr(fp);\n    fseek(fp, start, SEEK_SET);\n    if (size)\n      *size = obj_sz;\n    if (is_stream)\n      *is_stream = stream;\n    return data;\n}", "target": 1}
{"code": "x509stack_push(struct cert_stack *stack, struct rpki_uri *uri, X509 *x509,\n    enum rpki_policy policy, enum cert_type type)\n{\n\tstruct metadata_node *meta;\n\tstruct repo_level_node *repo, *head_repo;\n\tstruct defer_node *defer_separator;\n\tunsigned int work_repo_level;\n\tint ok;\n\tint error;\n\trepo = malloc(sizeof(struct repo_level_node));\n\tif (repo == NULL)\n\t\treturn pr_enomem();\n\trepo->level = 0;\n\twork_repo_level = working_repo_peek_level();\n\thead_repo = SLIST_FIRST(&stack->levels);\n\tif (head_repo != NULL && work_repo_level > head_repo->level)\n\t\trepo->level = work_repo_level;\n\tSLIST_INSERT_HEAD(&stack->levels, repo, next);\n\tmeta = malloc(sizeof(struct metadata_node));\n\tif (meta == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end3;\n\t}\n\tmeta->uri = uri;\n\turi_refget(uri);\n\tserial_numbers_init(&meta->serials);\n\tsubjects_init(&meta->subjects);\n\tmeta->resources = resources_create(false);\n\tif (meta->resources == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end4;\n\t}\n\tresources_set_policy(meta->resources, policy);\n\terror = certificate_get_resources(x509, meta->resources, type);\n\tif (error)\n\t\tgoto end5;\n\tif (type == TA && resources_empty(meta->resources)) {\n\t\terror = pr_val_err(\"Trust Anchor certificate does not define any number resources.\");\n\t\tgoto end5;\n\t}\n\tdefer_separator = malloc(sizeof(struct defer_node));\n\tif (defer_separator == NULL) {\n\t\terror = pr_enomem();\n\t\tgoto end5;\n\t}\n\tdefer_separator->type = DNT_SEPARATOR;\n\tok = sk_X509_push(stack->x509s, x509);\n\tif (ok <= 0) {\n\t\terror = val_crypto_err(\n\t\t    \"Could not add certificate to trusted stack: %d\", ok);\n\t\tgoto end5;\n\t}\n\tSLIST_INSERT_HEAD(&stack->defers, defer_separator, next);\n\tSLIST_INSERT_HEAD(&stack->metas, meta, next);\n\treturn 0;\nend5:\tresources_destroy(meta->resources);\nend4:\tsubjects_cleanup(&meta->subjects, subject_cleanup);\n\tserial_numbers_cleanup(&meta->serials, serial_cleanup);\n\turi_refput(meta->uri);\n\tfree(meta);\nend3:\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\tfree(repo);\n\treturn error;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_advance_n( pj_scanner *scanner,\n\t\t\t\t unsigned N, pj_bool_t skip_ws)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    scanner->curptr += N;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "GF_Err stsz_box_size(GF_Box *s)\n{\n\tu32 i, fieldSize, size;\n\tGF_SampleSizeBox *ptr = (GF_SampleSizeBox *)s;\n\tptr->size += 8;\n\tif (!ptr->sampleCount) return GF_OK;\n\tif (ptr->type == GF_ISOM_BOX_TYPE_STSZ) {\n\t\tif (ptr->sampleSize) return GF_OK;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tif (!ptr->sizes) return GF_ISOM_INVALID_FILE;\n\tfieldSize = 4;\n\tsize = ptr->sizes[0];\n\tfor (i=0; i < ptr->sampleCount; i++) {\n\t\tif (ptr->sizes[i] <= 0xF) {\n\t\t}\n\t\telse if (ptr->sizes[i] <= 0xFF) {\n\t\t\tfieldSize = 8;\n\t\t}\n\t\telse if (ptr->sizes[i] <= 0xFFFF) {\n\t\t\tfieldSize = 16;\n\t\t}\n\t\telse {\n\t\t\tfieldSize = 32;\n\t\t}\n\t\tif (size != ptr->sizes[i]) size = 0;\n\t}\n\tif (size) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->sampleSize = size;\n\t\tgf_free(ptr->sizes);\n\t\tptr->sizes = NULL;\n\t\treturn GF_OK;\n\t}\n\tif (fieldSize == 32) {\n\t\tptr->type = GF_ISOM_BOX_TYPE_STSZ;\n\t\tptr->size += (4 * ptr->sampleCount);\n\t\treturn GF_OK;\n\t}\n\tptr->type = GF_ISOM_BOX_TYPE_STZ2;\n\tptr->sampleSize = fieldSize;\n\tif (fieldSize == 4) {\n\t\tptr->size += (ptr->sampleCount + 1) / 2;\n\t} else {\n\t\tptr->size += (ptr->sampleCount) * (fieldSize/8);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "PHYSICALPATH_FUNC(mod_alias_physical_handler) {\n\tplugin_data *p = p_d;\n\tint uri_len, basedir_len;\n\tchar *uri_ptr;\n\tsize_t k;\n\tif (buffer_is_empty(con->physical.path)) return HANDLER_GO_ON;\n\tmod_alias_patch_connection(srv, con, p);\n\tbasedir_len = buffer_string_length(con->physical.basedir);\n\tif ('/' == con->physical.basedir->ptr[basedir_len-1]) --basedir_len;\n\turi_len = buffer_string_length(con->physical.path) - basedir_len;\n\turi_ptr = con->physical.path->ptr + basedir_len;\n\tfor (k = 0; k < p->conf.alias->used; k++) {\n\t\tdata_string *ds = (data_string *)p->conf.alias->data[k];\n\t\tint alias_len = buffer_string_length(ds->key);\n\t\tif (alias_len > uri_len) continue;\n\t\tif (buffer_is_empty(ds->key)) continue;\n\t\tif (0 == (con->conf.force_lowercase_filenames ?\n\t\t\t\t\tstrncasecmp(uri_ptr, ds->key->ptr, alias_len) :\n\t\t\t\t\tstrncmp(uri_ptr, ds->key->ptr, alias_len))) {\n\t\t\tif (uri_ptr[alias_len] == '.') {\n\t\t\t\tchar *s = uri_ptr + alias_len + 1;\n\t\t\t\tif (*s == '.') ++s;\n\t\t\t\tif (*s == '/' || *s == '\\0') {\n\t\t\t\t\tsize_t vlen = buffer_string_length(ds->value);\n\t\t\t\t\tif (0 != alias_len && ds->key->ptr[alias_len-1] != '/'\n\t\t\t\t\t    && 0 != vlen && ds->value->ptr[vlen-1] == '/') {\n\t\t\t\t\t\tcon->http_status = 403;\n\t\t\t\t\t\treturn HANDLER_FINISHED;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer_copy_buffer(con->physical.basedir, ds->value);\n\t\t\tbuffer_copy_buffer(srv->tmp_buf, ds->value);\n\t\t\tbuffer_append_string(srv->tmp_buf, uri_ptr + alias_len);\n\t\t\tbuffer_copy_buffer(con->physical.path, srv->tmp_buf);\n\t\t\treturn HANDLER_GO_ON;\n\t\t}\n\t}\n\treturn HANDLER_GO_ON;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif(im->trueColor) {\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif(!pim) {\n\t\t\treturn;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\tGIFEncode(\n\t    out, tim->sx, tim->sy, interlace, 0, tim->transparent, BitsPerPixel,\n\t    tim->red, tim->green, tim->blue, tim);\n\tif(pim) {\n\t\tgdImageDestroy(\tpim);\n\t}\n}", "target": 1}
{"code": "const aura::Window* Shell::GetContainer(const aura::Window* root_window,\n                                        int container_id) {\n  return root_window->GetChildById(container_id);\n}", "target": 0}
{"code": "static GF_Err swf_svg_add_iso_sample(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_FilterPacket *pck;\n\tu8 *pck_data;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tif (!data || !length) return GF_BAD_PARAM;\n\tif (ctx->seek_state==2) {\n\t\tDouble ts = (Double) timestamp;\n\t\tts/=1000;\n\t\tif (ts<ctx->start_range) return GF_OK;\n\t\tctx->seek_state = 0;\n\t}\n\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\tif (pck) {\n\t\tmemcpy(pck_data, data, length);\n\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale*timestamp/1000) );\n\t\tgf_filter_pck_set_sap(pck, isRap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_FALSE);\n\t\tgf_filter_pck_send(pck);\n\t}\n\tif (txtin_check_blocking(ctx))\n\t\tctx->is_suspended = GF_TRUE;\n\treturn GF_OK;", "target": 0}
{"code": "add_link_ref(\n\tstruct link_ref **references,\n\tconst uint8_t *name, size_t name_size)\n{\n\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));\n\tif (!ref)\n\t\treturn NULL;\n\tref->id = hash_link_ref(name, name_size);\n\tref->next = references[ref->id % REF_TABLE_SIZE];\n\treferences[ref->id % REF_TABLE_SIZE] = ref;\n\treturn ref;\n}", "target": 1}
{"code": "static __u8 *sp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 107 && rdesc[104] == 0x26 && rdesc[105] == 0x80 &&\n\t\t\trdesc[106] == 0x03) {\n\t\thid_info(hdev, \"fixing up Sunplus Wireless Desktop report descriptor\\n\");\n\t\trdesc[105] = rdesc[110] = 0x03;\n\t\trdesc[106] = rdesc[111] = 0x21;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "GF_Err url_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_DataEntryURLBox *ptr = (GF_DataEntryURLBox *)s;\n\tif (ptr->size) {\n\t\tptr->location = (char*)gf_malloc((u32) ptr->size);\n\t\tif (! ptr->location) return GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, ptr->location, (u32)ptr->size);\n\t\tif (ptr->location[ptr->size-1]) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[iso file] url box location is not 0-terminated\\n\" ));\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t}\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static FORCEINLINE NEDMALLOCNOALIASATTR NEDMALLOCPTRATTR void *CallMalloc(void *RESTRICT mspace, size_t size, size_t alignment, unsigned flags) THROWSPEC\n{\n\tvoid *RESTRICT ret=0;\n#if USE_MAGIC_HEADERS\n\tsize_t _alignment=alignment;\n\tsize_t *_ret=0;\n\tsize+=alignment+3*sizeof(size_t);\n\t_alignment=0;\n#endif\n#if USE_ALLOCATOR==0\n\tret=(flags & M2_ZERO_MEMORY) ? syscalloc(1, size) : sysmalloc(size);\t\n#elif USE_ALLOCATOR==1\n\tret=mspace_malloc2((mstate) mspace, size, alignment, flags);\n#ifndef ENABLE_FAST_HEAP_DETECTION\n\tif(ret)\n\t{\n\t\tmchunkptr p=mem2chunk(ret);\n\t\tsize_t truesize=chunksize(p) - overhead_for(p);\n\t\tif(!leastusedaddress || (void *)((mstate) mspace)->least_addr<leastusedaddress) leastusedaddress=(void *)((mstate) mspace)->least_addr;\n\t\tif(!largestusedblock || truesize>largestusedblock) largestusedblock=(truesize+mparams.page_size) & ~(mparams.page_size-1);\n\t}\n#endif\n#endif\n\tif(!ret) return 0;\n#if DEBUG\n\tif(flags & M2_ZERO_MEMORY)\n\t{\n\t\tconst char *RESTRICT n;\n\t\tfor(n=(const char *)ret; n<(const char *)ret+size; n++)\n\t\t{\n\t\t\tassert(!*n);\n\t\t}\n\t}\n#endif\n#if USE_MAGIC_HEADERS\n\t_ret=(size_t *) ret;\n\tret=(void *)(_ret+3);\n\tif(alignment) ret=(void *)(((size_t) ret+alignment-1)&~(alignment-1));\n\tfor(; _ret<(size_t *)ret-2; _ret++) *_ret=*(size_t *)\"NEDMALOC\";\n\t_ret[0]=(size_t) mspace;\n\t_ret[1]=size-3*sizeof(size_t);\n#endif\n\treturn ret;\n}", "target": 1}
{"code": "ProcStoreNamedColor(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xStoreNamedColorReq);\n    REQUEST_FIXED_SIZE(xStoreNamedColorReq, stuff->nbytes);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->cmap, RT_COLORMAP,\n                                 client, DixWriteAccess);\n    if (rc == Success) {\n        xColorItem def;\n        if (OsLookupColor(pcmp->pScreen->myNum, (char *) &stuff[1],\n                          stuff->nbytes, &def.red, &def.green, &def.blue)) {\n            def.flags = stuff->flags;\n            def.pixel = stuff->pixel;\n            return StoreColors(pcmp, 1, &def, client);\n        }\n        return BadName;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "void PrintWebViewHelper::PrintPreviewContext::Failed(bool report_error) {\n  DCHECK(state_ == INITIALIZED || state_ == RENDERING);\n  state_ = INITIALIZED;\n  if (report_error) {\n    DCHECK_NE(PREVIEW_ERROR_NONE, error_);\n    UMA_HISTOGRAM_ENUMERATION(\"PrintPreview.RendererError\", error_,\n                              PREVIEW_ERROR_LAST_ENUM);\n  }\n  ClearContext();\n}", "target": 0}
{"code": "next_state_val(CClassNode* cc, OnigCodePoint *vs, OnigCodePoint v,\n\t       int* vs_israw, int v_israw,\n\t       enum CCVALTYPE intype, enum CCVALTYPE* type,\n\t       enum CCSTATE* state, ScanEnv* env)\n{\n  int r;\n  switch (*state) {\n  case CCS_VALUE:\n    if (*type == CCV_SB) {\n      if (*vs > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n      BITSET_SET_BIT(cc->bs, (int )(*vs));\n    }\n    else if (*type == CCV_CODE_POINT) {\n      r = add_code_range(&(cc->mbuf), env, *vs, *vs);\n      if (r < 0) return r;\n    }\n    break;\n  case CCS_RANGE:\n    if (intype == *type) {\n      if (intype == CCV_SB) {\n        if (*vs > 0xff || v > 0xff)\n          return ONIGERR_INVALID_CODE_POINT_VALUE;\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )v);\n      }\n      else {\n        r = add_code_range(&(cc->mbuf), env, *vs, v);\n        if (r < 0) return r;\n      }\n    }\n    else {\n#if 0\n      if (intype == CCV_CODE_POINT && *type == CCV_SB) {\n#endif\n        if (*vs > v) {\n          if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC))\n            goto ccs_range_end;\n          else\n            return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS;\n        }\n        bitset_set_range(cc->bs, (int )*vs, (int )(v < 0xff ? v : 0xff));\n        r = add_code_range(&(cc->mbuf), env, (OnigCodePoint )*vs, v);\n        if (r < 0) return r;\n#if 0\n      }\n      else\n        return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE;\n#endif\n    }\n  ccs_range_end:\n    *state = CCS_COMPLETE;\n    break;\n  case CCS_COMPLETE:\n  case CCS_START:\n    *state = CCS_VALUE;\n    break;\n  default:\n    break;\n  }\n  *vs_israw = v_israw;\n  *vs       = v;\n  *type     = intype;\n  return 0;\n}", "target": 0}
{"code": "same_url_p(ParsedURL *pu1, ParsedURL *pu2)\n{\n    return (pu1->scheme == pu2->scheme && pu1->port == pu2->port &&\n\t    (pu1->host ? pu2->host ? !strcasecmp(pu1->host, pu2->host) : 0 : 1)\n\t    && (pu1->file ? pu2->\n\t\tfile ? !strcmp(pu1->file, pu2->file) : 0 : 1));\n}", "target": 0}
{"code": "my_decimal *Item_param::val_decimal(my_decimal *dec)\n{\n  switch (state) {\n  case DECIMAL_VALUE:\n    return &decimal_value;\n  case REAL_VALUE:\n    double2my_decimal(E_DEC_FATAL_ERROR, value.real, dec);\n    return dec;\n  case INT_VALUE:\n    int2my_decimal(E_DEC_FATAL_ERROR, value.integer, unsigned_flag, dec);\n    return dec;\n  case STRING_VALUE:\n  case LONG_DATA_VALUE:\n    string2my_decimal(E_DEC_FATAL_ERROR, &str_value, dec);\n    return dec;\n  case TIME_VALUE:\n  {\n    longlong i= (longlong) TIME_to_ulonglong(&value.time);\n    int2my_decimal(E_DEC_FATAL_ERROR, i, 0, dec);\n    return dec;\n  }\n  case NULL_VALUE:\n    return 0; \n  default:\n    DBUG_ASSERT(0);\n  }\n  return 0;\n}", "target": 0}
{"code": "void DetectHttpRequestHeaderRegister(void)\n{\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].name = \"http.request_header\";\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].desc =\n            \"sticky buffer to match on only one HTTP header name and value\";\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].url = \"/rules/http-keywords.html#request_header\";\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].Setup = DetectHTTPRequestHeaderSetup;\n    sigmatch_table[DETECT_HTTP_REQUEST_HEADER].flags |=\n            SIGMATCH_NOOPT | SIGMATCH_INFO_STICKY_BUFFER;\n    DetectAppLayerMpmRegister2(\"http_request_header\", SIG_FLAG_TOSERVER, 2,\n            PrefilterMpmHttp2HeaderRegister, NULL, ALPROTO_HTTP2, HTTP2StateOpen);\n    DetectAppLayerInspectEngineRegister2(\"http_request_header\", ALPROTO_HTTP2, SIG_FLAG_TOSERVER,\n            HTTP2StateOpen, DetectEngineInspectHttp2Header, NULL);\n    DetectAppLayerMpmRegister2(\"http_request_header\", SIG_FLAG_TOSERVER, 2,\n            PrefilterMpmHttp1HeaderRegister, NULL, ALPROTO_HTTP1, 0);\n    DetectAppLayerInspectEngineRegister2(\"http_request_header\", ALPROTO_HTTP1, SIG_FLAG_TOSERVER,\n            HTP_REQUEST_HEADERS, DetectEngineInspectHttp1Header, NULL);\n    DetectBufferTypeSetDescriptionByName(\"http_request_header\", \"HTTP header name and value\");\n    g_http_request_header_buffer_id = DetectBufferTypeGetByName(\"http_request_header\");\n    DetectBufferTypeSupportsMultiInstance(\"http_request_header\");\n    g_request_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_request_header\",\n            HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);\n}", "target": 0}
{"code": "void ChildProcessSecurityPolicy::GrantInspectElement(int renderer_id) {\n  AutoLock lock(lock_);\n  SecurityStateMap::iterator state = security_state_.find(renderer_id);\n  if (state == security_state_.end())\n    return;\n  state->second->GrantScheme(chrome::kChromeUIScheme);\n}", "target": 0}
{"code": "update_notification_create(struct update_notification **file)\n{\n\tstruct update_notification *tmp;\n\tstruct deltas_head *list;\n\tint error;\n\ttmp = malloc(sizeof(struct update_notification));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tlist = NULL;\n\terror = deltas_head_create(&list);\n\tif (error) {\n\t\tfree(tmp);\n\t\treturn error;\n\t}\n\ttmp->deltas_list = list;\n\ttmp->uri = NULL;\n\tglobal_data_init(&tmp->global_data);\n\tdoc_data_init(&tmp->snapshot);\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "remote_auth_timeout_cb(gpointer data)\n{\n    cib_client_t *client = data;\n    client->remote_auth_timeout = 0;\n    if (client->remote_auth == TRUE) {\n        return FALSE;\n    }\n    mainloop_del_fd(client->remote);\n    crm_err(\"Remote client authentication timed out\");\n    return FALSE;\n}", "target": 0}
{"code": "GC_INNER void * GC_generic_malloc_ignore_off_page(size_t lb, int k)\n{\n    void *result;\n    size_t lg;\n    size_t lb_rounded;\n    word n_blocks;\n    GC_bool init;\n    DCL_LOCK_STATE;\n    if (SMALL_OBJ(lb))\n        return(GC_generic_malloc((word)lb, k));\n    lg = ROUNDED_UP_GRANULES(lb);\n    lb_rounded = GRANULES_TO_BYTES(lg);\n    if (lb_rounded < lb)\n        return((*GC_get_oom_fn())(lb));\n    n_blocks = OBJ_SZ_TO_BLOCKS(lb_rounded);\n    init = GC_obj_kinds[k].ok_init;\n    if (EXPECT(GC_have_errors, FALSE))\n      GC_print_all_errors();\n    GC_INVOKE_FINALIZERS();\n    LOCK();\n    result = (ptr_t)GC_alloc_large(ADD_SLOP(lb), k, IGNORE_OFF_PAGE);\n    if (0 != result) {\n        if (GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        } else {\n#           ifdef THREADS\n                ((word *)result)[0] = 0;\n                ((word *)result)[1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-1] = 0;\n                ((word *)result)[GRANULES_TO_WORDS(lg)-2] = 0;\n#           endif\n        }\n    }\n    GC_bytes_allocd += lb_rounded;\n    if (0 == result) {\n        GC_oom_func oom_fn = GC_oom_fn;\n        UNLOCK();\n        return((*oom_fn)(lb));\n    } else {\n        UNLOCK();\n        if (init && !GC_debugging_started) {\n            BZERO(result, n_blocks * HBLKSIZE);\n        }\n        return(result);\n    }\n}", "target": 0}
{"code": "void RenderView::OnShouldClose() {\n  bool should_close = webview()->dispatchBeforeUnloadEvent();\n  Send(new ViewHostMsg_ShouldClose_ACK(routing_id_, should_close));\n}", "target": 0}
{"code": "test_validate_path_characters (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (paths); idx++)\n    {\n      PathValidityData *data = &paths[idx];\n      gboolean ret = FALSE;\n      ret = flatpak_validate_path_characters (data->path, NULL);\n      g_assert_cmpint (ret, ==, data->ret);\n    }\n}", "target": 0}
{"code": "static UINT parallel_process_irp_create(PARALLEL_DEVICE* parallel, IRP* irp)\n{\n\tchar* path = NULL;\n\tint status;\n\tUINT32 PathLength;\n\tStream_Seek(irp->input, 28);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tstatus = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)Stream_Pointer(irp->input), PathLength / 2,\n\t                            &path, 0, NULL, NULL);\n\tif (status < 1)\n\t\tif (!(path = (char*)calloc(1, 1)))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\t\treturn CHANNEL_RC_NO_MEMORY;\n\t\t}\n\tparallel->id = irp->devman->id_sequence++;\n\tparallel->file = open(parallel->path, O_RDWR);\n\tif (parallel->file < 0)\n\t{\n\t\tirp->IoStatus = STATUS_ACCESS_DENIED;\n\t\tparallel->id = 0;\n\t}\n\telse\n\t{\n\t\tif (fcntl(parallel->file, F_SETFL, O_NONBLOCK) == -1)\n\t\t{\n\t\t}\n\t}\n\tStream_Write_UINT32(irp->output, parallel->id);\n\tStream_Write_UINT8(irp->output, 0);\n\tfree(path);\n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "gss_unwrap_aead (minor_status,\n                 context_handle,\n\t\t input_message_buffer,\n\t\t input_assoc_buffer,\n\t\t output_payload_buffer,\n                 conf_state,\n                 qop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\toutput_payload_buffer;\nint \t\t\t*conf_state;\ngss_qop_t\t\t*qop_state;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_unwrap_aead_args(minor_status, context_handle,\n\t\t\t\t  input_message_buffer, input_assoc_buffer,\n\t\t\t\t  output_payload_buffer,\n\t\t\t\t  conf_state, qop_state);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n    return gssint_unwrap_aead(mech, minor_status, ctx,\n\t\t\t      input_message_buffer, input_assoc_buffer,\n\t\t\t      output_payload_buffer, conf_state, qop_state);\n}", "target": 0}
{"code": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n  char *pt = dest;\n  const char *s = src;\n  *pt++ = '\"';\n  dlen -= 2;\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      if (dlen < 2)\n        break;\n      dlen -= 2;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}", "target": 0}
{"code": "int main(void) {\n    if (siphash_test() == 0) {\n        printf(\"SipHash test: OK\\n\");\n        return 0;\n    } else {\n        printf(\"SipHash test: FAILED\\n\");\n        return 1;\n    }\n}", "target": 0}
{"code": "static int __key_instantiate_and_link(struct key *key,\n\t\t\t\t      struct key_preparsed_payload *prep,\n\t\t\t\t      struct key *keyring,\n\t\t\t\t      struct key *authkey,\n\t\t\t\t      struct assoc_array_edit **_edit)\n{\n\tint ret, awaken;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tmutex_lock(&key_construction_mutex);\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\tret = key->type->instantiate(key, prep);\n\t\tif (ret == 0) {\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\t\t\t\t__key_link(key, _edit);\n\t\t\t}\n\t\t\tif (authkey)\n\t\t\t\tkey_revoke(authkey);\n\t\t\tif (prep->expiry != TIME_T_MAX) {\n\t\t\t\tkey->expiry = prep->expiry;\n\t\t\t\tkey_schedule_gc(prep->expiry + key_gc_delay);\n\t\t\t}\n\t\t}\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret;\n}", "target": 1}
{"code": "utf32be_mbc_to_code(const UChar* p, const UChar* end ARG_UNUSED)\n{\n  if (end - p < 4) return 0;\n  return (OnigCodePoint )(((p[0] * 256 + p[1]) * 256 + p[2]) * 256 + p[3]);\n}", "target": 0}
{"code": "_dbus_lookup_session_address_launchd (DBusString *address, DBusError  *error)\n{\n  dbus_bool_t valid_socket;\n  DBusString socket_path;\n  if (_dbus_check_setuid ())\n    {\n      dbus_set_error_const (error, DBUS_ERROR_NOT_SUPPORTED,\n                            \"Unable to find launchd socket when setuid\");\n      return FALSE;\n    }\n  if (!_dbus_string_init (&socket_path))\n    {\n      _DBUS_SET_OOM (error);\n      return FALSE;\n    }\n  valid_socket = _dbus_lookup_launchd_socket (&socket_path, \"DBUS_LAUNCHD_SESSION_BUS_SOCKET\", error);\n  if (dbus_error_is_set(error))\n    {\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  if (!valid_socket)\n    {\n      dbus_set_error(error, \"no socket path\",\n                \"launchd did not provide a socket path, \"\n                \"verify that org.freedesktop.dbus-session.plist is loaded!\");\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  if (!_dbus_string_append (address, \"unix:path=\"))\n    {\n      _DBUS_SET_OOM (error);\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  if (!_dbus_string_copy (&socket_path, 0, address,\n                          _dbus_string_get_length (address)))\n    {\n      _DBUS_SET_OOM (error);\n      _dbus_string_free(&socket_path);\n      return FALSE;\n    }\n  _dbus_string_free(&socket_path);\n  return TRUE;\n}", "target": 0}
{"code": "static int kill_something_info(int sig, struct siginfo *info, pid_t pid)\n{\n\tint ret;\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\tif (pid == INT_MIN)\n\t\treturn -ESRCH;\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\treturn ret;\n}", "target": 0}
{"code": "static int set_msr_mce(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tu64 mcg_cap = vcpu->arch.mcg_cap;\n\tunsigned bank_num = mcg_cap & 0xff;\n\tswitch (msr) {\n\tcase MSR_IA32_MCG_STATUS:\n\t\tvcpu->arch.mcg_status = data;\n\t\tbreak;\n\tcase MSR_IA32_MCG_CTL:\n\t\tif (!(mcg_cap & MCG_CTL_P))\n\t\t\treturn 1;\n\t\tif (data != 0 && data != ~(u64)0)\n\t\t\treturn -1;\n\t\tvcpu->arch.mcg_ctl = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr >= MSR_IA32_MC0_CTL &&\n\t\t    msr < MSR_IA32_MC0_CTL + 4 * bank_num) {\n\t\t\tu32 offset = msr - MSR_IA32_MC0_CTL;\n\t\t\tif ((offset & 0x3) == 0 &&\n\t\t\t    data != 0 && (data | (1 << 10)) != ~(u64)0)\n\t\t\t\treturn -1;\n\t\t\tvcpu->arch.mce_banks[offset] = data;\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static bool isFloat(FormatCode code) { return code >= kFloat && code <= kDouble; }", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    OP_REQUIRES(context, tensor_in.dims() == 4,\n                errors::InvalidArgument(\"tensor_in must be 4-dimensional (2)\"));\n    OP_REQUIRES(context, tensor_in.NumElements() > 0,\n                errors::InvalidArgument(\"tensor_in must not be empty (2)\"));\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    Tensor* argmax = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, out_shape, &argmax));\n    LaunchMaxPoolingWithArgmax<Device, T, Targmax>::launch(\n        context, params, tensor_in, output, argmax, propagate_nans_,\n        include_batch_in_index_);\n  }", "target": 0}
{"code": "static void get_sem_elements(struct sem_data *p)\n{\n\tsize_t i;\n\tif (!p || !p->sem_nsems || p->sem_perm.id < 0)\n\t\treturn;\n\tp->elements = xcalloc(p->sem_nsems, sizeof(struct sem_elem));\n\tfor (i = 0; i < p->sem_nsems; i++) {\n\t\tstruct sem_elem *e = &p->elements[i];\n\t\tunion semun arg = { .val = 0 };\n\t\te->semval = semctl(p->sem_perm.id, i, GETVAL, arg);\n\t\tif (e->semval < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETVAL)\");\n\t\te->ncount = semctl(p->sem_perm.id, i, GETNCNT, arg);\n\t\tif (e->ncount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETNCNT)\");\n\t\te->zcount = semctl(p->sem_perm.id, i, GETZCNT, arg);\n\t\tif (e->zcount < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETZCNT)\");\n\t\te->pid = semctl(p->sem_perm.id, i, GETPID, arg);\n\t\tif (e->pid < 0)\n\t\t\terr(EXIT_FAILURE, _(\"%s failed\"), \"semctl(GETPID)\");\n\t}\n}", "target": 1}
{"code": "void PDPClient::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "PHP_FUNCTION(radius_get_vendor_attr)\n{\n\tint res;\n\tconst void *data;\n\tint len;\n\tu_int32_t vendor;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &data, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tres = rad_get_vendor_attr(&vendor, &data, (size_t *) &len);\n\tif (res == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tarray_init(return_value);\n\t\tadd_assoc_long(return_value, \"attr\", res);\n\t\tadd_assoc_long(return_value, \"vendor\", vendor);\n\t\tadd_assoc_stringl(return_value, \"data\", (char *) data, len, 1);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "void end_read_record(READ_RECORD *info)\n{\n  free_cache(info);\n  if (info->table)\n  {\n    if (info->table->db_stat) \n      (void) info->table->file->extra(HA_EXTRA_NO_CACHE);\n    if (info->read_record != rr_quick) \n      (void) info->table->file->ha_index_or_rnd_end();\n    info->table=0;\n  }\n}", "target": 0}
{"code": "PHP_NAMED_FUNCTION(zif_locale_set_default)\n{\n\tchar* locale_name = NULL;\n\tint   len=0;\t\n\tif(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  \"s\",\n\t\t&locale_name ,&len ) == FAILURE)\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t \t\"locale_set_default: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tif(len == 0) {\n\t\tlocale_name =  (char *)uloc_getDefault() ;\n\t\tlen = strlen(locale_name);\n\t}\n\tzend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);\t\n\tRETURN_TRUE;\n}", "target": 1}
{"code": "void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}", "target": 0}
{"code": "GtkTreeModel *bluetooth_client_get_model (BluetoothClient *client)\n{\n\tBluetoothClientPrivate *priv;\n\tGtkTreeModel *model;\n\tg_return_val_if_fail (BLUETOOTH_IS_CLIENT (client), NULL);\n\tpriv = BLUETOOTH_CLIENT_GET_PRIVATE(client);\n\tmodel = GTK_TREE_MODEL (g_object_ref(priv->store));\n\treturn model;\n}", "target": 0}
{"code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}", "target": 0}
{"code": "R_API char *r_socket_http_get(const char *url, int *code, int *rlen) {\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (curl_env && *curl_env) {\n\t\tchar *encoded_url = r_str_escape (url);\n\t\tchar *res = r_sys_cmd_strf (\"curl '%s'\", encoded_url);\n\t\tfree (encoded_url);\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = strlen (res);\n\t\t\t}\n\t\t}\n\t\tfree (curl_env);\n\t\treturn res;\n\t}\n\tfree (curl_env);\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https:\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\thost = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: *", "target": 1}
{"code": "static int fill_autodev(const struct lxc_rootfs *rootfs)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\tINFO(\"Creating initial consoles under container /dev\");\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\tif (!dir_exists(path))  \n\t\treturn 0;\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}", "target": 1}
{"code": "void deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  }\n  else\n  {\n    to_keep = duplicate;\n    to_delete = *existing;\n    *existing = duplicate;\n  }\n  if (!ISFLAG(flags, F_HIDEPROGRESS)) fprintf(stderr, \"\\r%40s\\r\", \" \");\n  if (loginfo)\n    log_begin_set(loginfo);\n  printf(\"   [+] %s\\n\", to_keep->d_name);\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n  if (matchconfirmed)\n  {\n    if (remove(to_delete->d_name) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file!\\n\");\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }\n  else\n  {\n    printf(\"   [!] %s\\n\", to_delete->d_name);\n    printf(\" -- unable to confirm match; file not deleted!\\n\");\n    if (loginfo)\n      log_file_remaining(loginfo, to_delete->d_name);\n  }\n  if (loginfo)\n    log_end_set(loginfo);\n  printf(\"\\n\");\n}", "target": 1}
{"code": "bool Tensor::FromProto(Allocator* a, const TensorProto& proto) {\n  CHECK_NOTNULL(a);\n  TensorBuffer* p = nullptr;\n  if (!TensorShape::IsValid(proto.tensor_shape())) return false;\n  if (proto.dtype() == DT_INVALID) return false;\n  TensorShape shape(proto.tensor_shape());\n  const int64_t N = shape.num_elements();\n  if (N > 0 && proto.dtype()) {\n    bool dtype_error = false;\n    if (!proto.tensor_content().empty()) {\n      const auto& content = proto.tensor_content();\n      CASES_WITH_DEFAULT(proto.dtype(), p = Helper<T>::Decode(a, content, N),\n                         dtype_error = true, dtype_error = true);\n    } else {\n      CASES_WITH_DEFAULT(proto.dtype(), p = FromProtoField<T>(a, proto, N),\n                         dtype_error = true, dtype_error = true);\n    }\n    if (dtype_error || p == nullptr) return false;\n  } else {\n    bool dtype_error = false;\n    CASES_WITH_DEFAULT(proto.dtype(), break, dtype_error = true,\n                       dtype_error = true);\n    if (dtype_error) return false;\n  }\n  shape_ = shape;\n  set_dtype(proto.dtype());\n  UnrefIfNonNull(buf_);\n  buf_ = p;\n  if (MemoryLoggingEnabled() && buf_ != nullptr && buf_->data() != nullptr) {\n    LogMemory::RecordTensorAllocation(\"Unknown (from Proto)\",\n                                      LogMemory::UNKNOWN_STEP_ID, *this);\n  }\n  return true;\n}", "target": 0}
{"code": "gx_default_get_alpha_bits(gx_device * dev, graphics_object_type type)\n{\n    return (type == go_text ? dev->color_info.anti_alias.text_bits :\n            dev->color_info.anti_alias.graphics_bits);\n}", "target": 0}
{"code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu64 mode = (*(u64 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\t\tif (!system_supports_32bit_el0())\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\t\tif (!vcpu_el1_is_32bit(vcpu))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tif (vcpu_el1_is_32bit(vcpu))\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}", "target": 0}
{"code": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\tif (WARN_ON(!info))\n\t\treturn;\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\tif (!list_empty(&info->eoi_list))\n\t\tlateeoi_list_del(info);\n\tlist_del(&info->list);\n\tset_info_for_irq(irq, NULL);\n\tWARN_ON(info->refcnt > 0);\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\tkfree(info);\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\tirq_free_desc(irq);\n}", "target": 0}
{"code": "static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n\t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n\t\trdesc[11] = rdesc[16] = 0xff;\n\t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "static WERROR dnsserver_complex_operate_zone(struct dnsserver_state *dsstate,\n\t\t\t\t\tTALLOC_CTX *mem_ctx,\n\t\t\t\t\tstruct dnsserver_zone *z,\n\t\t\t\t\tconst char *operation,\n\t\t\t\t\tconst unsigned int client_version,\n\t\t\t\t\tenum DNS_RPC_TYPEID typeid_in,\n\t\t\t\t\tunion DNSSRV_RPC_UNION *rin,\n\t\t\t\t\tenum DNS_RPC_TYPEID *typeid_out,\n\t\t\t\t\tunion DNSSRV_RPC_UNION *rout)\n{\n\tif (strcasecmp(operation, \"QueryDwordProperty\") == 0) {\n\t\tif (typeid_in == DNSSRV_TYPEID_LPSTR) {\n\t\t\treturn dnsserver_query_zone(dsstate, mem_ctx, z,\n\t\t\t\t\t\trin->String,\n\t\t\t\t\t\tclient_version,\n\t\t\t\t\t\ttypeid_out,\n\t\t\t\t\t\trout);\n\t\t}\n\t}\n\tDEBUG(0,(\"dnsserver: Invalid zone operation %s\", operation));\n\treturn WERR_DNS_ERROR_INVALID_PROPERTY;\n}", "target": 0}
{"code": "void groupGenerate(const std::string &rule, std::vector<Proxy> &nodelist, string_array &filtered_nodelist, bool add_direct, extra_settings &ext)\n{\n    std::string real_rule;\n    if(startsWith(rule, \"[]\") && add_direct)\n    {\n        filtered_nodelist.emplace_back(rule.substr(2));\n    }\n#ifndef NO_JS_RUNTIME\n    else if(startsWith(rule, \"script:\"))\n    {\n        script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx){\n            std::string script = fileGet(rule.substr(7), true);\n            try\n            {\n                ctx.eval(script);\n                auto filter = (std::function<std::string(const std::vector<Proxy>&)>) ctx.eval(\"filter\");\n                std::string result_list = filter(nodelist);\n                filtered_nodelist = split(regTrim(result_list), \"\\n\");\n            }\n            catch (qjs::exception)\n            {\n                script_print_stack(ctx);\n            }\n        }, global.scriptCleanContext);\n    }\n#endif \n    else\n    {\n        for(Proxy &x : nodelist)\n        {\n            if(applyMatcher(rule, real_rule, x) && (real_rule.empty() || regFind(x.Remark, real_rule)) && std::find(filtered_nodelist.begin(), filtered_nodelist.end(), x.Remark) == filtered_nodelist.end())\n                filtered_nodelist.emplace_back(x.Remark);\n        }\n    }\n}", "target": 1}
{"code": "void SetColor(double c, double m, double y, double k,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f K\",c,m,y,k);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f k\",c,m,y,k);\n    }\n}", "target": 1}
{"code": "bittok2str_internal(register const struct tok *lp, register const char *fmt,\n\t   register u_int v, const char *sep)\n{\n        static char buf[256]; \n        int buflen=0;\n        register u_int rotbit; \n        register u_int tokval;\n        const char * sepstr = \"\";\n\twhile (lp != NULL && lp->s != NULL) {\n            tokval=lp->v;   \n            rotbit=1;\n            while (rotbit != 0) {\n\t\tif (tokval == (v&rotbit)) {\n                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, \"%s%s\",\n                                     sepstr, lp->s);\n                    sepstr = sep;\n                    break;\n                }\n                rotbit=rotbit<<1; \n            }\n            lp++;\n\t}\n        if (buflen == 0)\n            (void)snprintf(buf, sizeof(buf), fmt == NULL ? \"#%08x\" : fmt, v);\n        return (buf);\n}", "target": 1}
{"code": "ev_archive_open_filename (EvArchive   *archive,\n\t\t\t  const char  *path,\n\t\t\t  GError     **error)\n{\n\tint r;\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\tg_return_val_if_fail (path != NULL, FALSE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tr = archive_read_open_filename (archive->libar, path, BUFFER_SIZE);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t\t     \"Error opening archive: %s\", archive_error_string (archive->libar));\n\t\t\treturn FALSE;\n\t\t}\n\t\treturn TRUE;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "static inline bool IsGlobbingPattern(const std::string& pattern) {\n  return (pattern.find_first_of(kGlobbingChars) != std::string::npos);\n}", "target": 0}
{"code": "lexer_check_arrow_param (parser_context_t *context_p) \n{\n  JERRY_ASSERT (context_p->token.flags & LEXER_NO_SKIP_SPACES);\n  if (context_p->source_p >= context_p->source_end_p)\n  {\n    return false;\n  }\n  if (context_p->source_p[0] == LIT_CHAR_COMMA)\n  {\n    return true;\n  }\n  if (context_p->source_p[0] != LIT_CHAR_EQUALS)\n  {\n    return false;\n  }\n  return (context_p->source_p + 1 >= context_p->source_end_p || context_p->source_p[1] != LIT_CHAR_EQUALS);\n} ", "target": 0}
{"code": "Status ValidatePaddingValues(absl::Span<const int64_t> input_dimensions,\n                             absl::Span<const int64_t> window_dimensions,\n                             absl::Span<const int64_t> window_strides) {\n  bool ok = input_dimensions.size() == window_dimensions.size() &&\n            input_dimensions.size() == window_strides.size();\n  if (!ok) {\n    return InvalidArgument(\n        \"Want input dimensions size %u = window dimensions size %u = window \"\n        \"strides size %u\",\n        input_dimensions.size(), window_dimensions.size(),\n        window_strides.size());\n  }\n  for (size_t i = 0; i < input_dimensions.size(); ++i) {\n    if (window_dimensions[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive size %d\", i,\n                             window_dimensions[i]);\n    }\n    if (window_strides[i] <= 0) {\n      return InvalidArgument(\"Window dimension %u has non-positive stride %d\",\n                             i, window_strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "add_prefix_matches(lookup_state_t *state,\n                   const svn_stringbuf_t *segment,\n                   apr_array_header_t *prefixes)\n{\n  int i = svn_sort__bsearch_lower_bound(prefixes, segment->data,\n                                        compare_node_path_segment);\n  if (i < prefixes->nelts)\n    add_if_prefix_matches(state,\n                          &APR_ARRAY_IDX(prefixes, i, sorted_pattern_t),\n                          segment);\n  if (i > 0)\n    {\n      sorted_pattern_t *pattern;\n      for (pattern = &APR_ARRAY_IDX(prefixes, i - 1, sorted_pattern_t);\n           pattern;\n           pattern = pattern->next)\n        {\n          add_if_prefix_matches(state, pattern, segment);\n        }\n    }\n}", "target": 0}
{"code": "void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) {\n  global_State *g = G(L);\n  lua_assert(isblack(o) && iswhite(v) && !isdead(g, v) && !isdead(g, o));\n  if (keepinvariant(g)) {  \n    reallymarkobject(g, v);  \n    if (isold(o)) {\n      lua_assert(!isold(v));  \n      setage(v, G_OLD0);  \n    }\n  }\n  else {  \n    lua_assert(issweepphase(g));\n    makewhite(g, o);  \n  }\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command, \n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out, \n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR, \n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "static void unix_dgram_peer_wake_disconnect(struct sock *sk,\n\t\t\t\t\t    struct sock *other)\n{\n\tstruct unix_sock *u, *u_other;\n\tu = unix_sk(sk);\n\tu_other = unix_sk(other);\n\tspin_lock(&u_other->peer_wait.lock);\n\tif (u->peer_wake.private == other) {\n\t\t__remove_wait_queue(&u_other->peer_wait, &u->peer_wake);\n\t\tu->peer_wake.private = NULL;\n\t}\n\tspin_unlock(&u_other->peer_wait.lock);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, DottedFieldCovering) {\n    addIndex(BSON(\"a.b\" << 1));\n    runQuerySortProj(fromjson(\"{'a.b': 5}\"), BSONObj(), fromjson(\"{_id: 0, 'a.b': 1}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, 'a.b': 1}, node: \"\n        \"{cscan: {dir: 1, filter: {'a.b': 5}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, 'a.b': 1}, node: {ixscan: {filter: null, pattern: {'a.b': 1},\"\n        \"bounds: {'a.b': [[5,5,true,true]]}}}}}\");\n}", "target": 0}
{"code": "  void readEOF() noexcept override {}", "target": 0}
{"code": "static void usage(void)\n{\n  PRINT_VERSION;\n  puts(\"Copyright (c) 2011, Oracle and/or its affiliates. \"\n       \"All rights reserved.\\n\");\n  puts(\"Enable or disable plugins.\");\n  printf(\"\\nUsage: %s [options] <plugin> ENABLE|DISABLE\\n\\nOptions:\\n\",\n     my_progname);\n  my_print_help(my_long_options);\n  puts(\"\\n\");\n}", "target": 1}
{"code": "static int wcd9335_codec_find_amic_input(struct snd_soc_component *comp,\n\t\t\t\t\t int adc_mux_n)\n{\n\tint mux_sel, reg, mreg;\n\tif (adc_mux_n < 0 || adc_mux_n > WCD9335_MAX_VALID_ADC_MUX ||\n\t    adc_mux_n == WCD9335_INVALID_ADC_MUX)\n\t\treturn 0;\n\tif (adc_mux_n < 4) {\n\t\treg = WCD9335_CDC_TX_INP_MUX_ADC_MUX0_CFG1 + 2 * adc_mux_n;\n\t\tmreg = WCD9335_CDC_TX_INP_MUX_ADC_MUX0_CFG0 + 2 * adc_mux_n;\n\t\tmux_sel = snd_soc_component_read32(comp, reg) & 0x3;\n\t} else {\n\t\treg = WCD9335_CDC_TX_INP_MUX_ADC_MUX4_CFG0 + adc_mux_n - 4;\n\t\tmreg = reg;\n\t\tmux_sel = snd_soc_component_read32(comp, reg) >> 6;\n\t}\n\tif (mux_sel != WCD9335_CDC_TX_INP_MUX_SEL_AMIC)\n\t\treturn 0;\n\treturn snd_soc_component_read32(comp, mreg) & 0x07;\n}", "target": 0}
{"code": "infra_create(struct config_file* cfg)\n{\n\tstruct infra_cache* infra = (struct infra_cache*)calloc(1, \n\t\tsizeof(struct infra_cache));\n\tsize_t maxmem = cfg->infra_cache_numhosts * (sizeof(struct infra_key)+\n\t\tsizeof(struct infra_data)+INFRA_BYTES_NAME);\n\tif(!infra) {\n\t\treturn NULL;\n\t}\n\tinfra->hosts = slabhash_create(cfg->infra_cache_slabs,\n\t\tINFRA_HOST_STARTSIZE, maxmem, &infra_sizefunc, &infra_compfunc,\n\t\t&infra_delkeyfunc, &infra_deldatafunc, NULL);\n\tif(!infra->hosts) {\n\t\tfree(infra);\n\t\treturn NULL;\n\t}\n\tinfra->host_ttl = cfg->host_ttl;\n\tinfra->infra_keep_probing = cfg->infra_keep_probing;\n\tinfra_dp_ratelimit = cfg->ratelimit;\n\tinfra->domain_rates = slabhash_create(cfg->ratelimit_slabs,\n\t\tINFRA_HOST_STARTSIZE, cfg->ratelimit_size,\n\t\t&rate_sizefunc, &rate_compfunc, &rate_delkeyfunc,\n\t\t&rate_deldatafunc, NULL);\n\tif(!infra->domain_rates) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tif(!setup_domain_limits(infra, cfg)) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tif(!setup_wait_limits(infra, cfg)) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\tinfra_ip_ratelimit = cfg->ip_ratelimit;\n\tinfra->client_ip_rates = slabhash_create(cfg->ip_ratelimit_slabs,\n\t    INFRA_HOST_STARTSIZE, cfg->ip_ratelimit_size, &ip_rate_sizefunc,\n\t    &ip_rate_compfunc, &ip_rate_delkeyfunc, &ip_rate_deldatafunc, NULL);\n\tif(!infra->client_ip_rates) {\n\t\tinfra_delete(infra);\n\t\treturn NULL;\n\t}\n\treturn infra;\n}", "target": 0}
{"code": "static void ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = iocb->private;\n\tstruct workqueue_struct *wq;\n\tif (!io_end || !size)\n\t\treturn;\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p\"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %llu\\n\",\n \t\t  iocb->private, io_end->inode->i_ino, iocb, offset,\n\t\t  size);\n\tif (io_end->flag != EXT4_IO_UNWRITTEN){\n\t\text4_free_io_end(io_end);\n\t\tiocb->private = NULL;\n\t\treturn;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\twq = EXT4_SB(io_end->inode->i_sb)->dio_unwritten_wq;\n\tqueue_work(wq, &io_end->work);\n\tlist_add_tail(&io_end->list,\n\t\t &EXT4_I(io_end->inode)->i_completed_io_list);\n\tiocb->private = NULL;\n}", "target": 1}
{"code": "xfs_da3_fixhashpath(\n\tstruct xfs_da_state\t*state,\n\tstruct xfs_da_state_path *path)\n{\n\tstruct xfs_da_state_blk\t*blk;\n\tstruct xfs_da_intnode\t*node;\n\tstruct xfs_da_node_entry *btree;\n\txfs_dahash_t\t\tlasthash=0;\n\tint\t\t\tlevel;\n\tint\t\t\tcount;\n\tstruct xfs_inode\t*dp = state->args->dp;\n\ttrace_xfs_da_fixhashpath(state->args);\n\tlevel = path->active-1;\n\tblk = &path->blk[ level ];\n\tswitch (blk->magic) {\n\tcase XFS_ATTR_LEAF_MAGIC:\n\t\tlasthash = xfs_attr_leaf_lasthash(blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DIR2_LEAFN_MAGIC:\n\t\tlasthash = xfs_dir2_leafn_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\tcase XFS_DA_NODE_MAGIC:\n\t\tlasthash = xfs_da3_node_lasthash(dp, blk->bp, &count);\n\t\tif (count == 0)\n\t\t\treturn;\n\t\tbreak;\n\t}\n\tfor (blk--, level--; level >= 0; blk--, level--) {\n\t\tstruct xfs_da3_icnode_hdr nodehdr;\n\t\tnode = blk->bp->b_addr;\n\t\tdp->d_ops->node_hdr_from_disk(&nodehdr, node);\n\t\tbtree = dp->d_ops->node_tree_p(node);\n\t\tif (be32_to_cpu(btree->hashval) == lasthash)\n\t\t\tbreak;\n\t\tblk->hashval = lasthash;\n\t\tbtree[blk->index].hashval = cpu_to_be32(lasthash);\n\t\txfs_trans_log_buf(state->args->trans, blk->bp,\n\t\t\t\t  XFS_DA_LOGRANGE(node, &btree[blk->index],\n\t\t\t\t\t\t  sizeof(*btree)));\n\t\tlasthash = be32_to_cpu(btree[nodehdr.count - 1].hashval);\n\t}\n}", "target": 1}
{"code": "static int EscChar(const char *src, char *dst, int dstlen, const char *specchars, char escchar)\n{\n   const char *p;\n   char *q, *end = dst+dstlen-1;\n   for (p = src, q = dst; *p && q < end; ) {\n      if (strchr(specchars, *p)) {\n         *q++ = escchar;\n         if (q < end)\n            *q++ = *p++;\n      } else\n         *q++ = *p++;\n   }\n   *q = '\\0';\n   if (*p != 0)\n      return -1;\n   return q-dst;\n}", "target": 1}
{"code": "_pyfribidi_log2vis (PyObject * self, PyObject * args, PyObject * kw)\n{\n\tPyObject *logical = NULL;\t\n\tFriBidiParType base = FRIBIDI_TYPE_RTL;\t\n\tconst char *encoding = \"utf-8\";\t\n\tint clean = 0; \n\tint reordernsm = 1; \n\tstatic char *kwargs[] =\n\t        { \"logical\", \"base_direction\", \"encoding\", \"clean\", \"reordernsm\", NULL };\n        if (!PyArg_ParseTupleAndKeywords (args, kw, \"O|isii\", kwargs,\n\t\t\t\t\t  &logical, &base, &encoding, &clean, &reordernsm))\n\t\treturn NULL;\n\tif (!(base == FRIBIDI_TYPE_RTL ||\n\t      base == FRIBIDI_TYPE_LTR || base == FRIBIDI_TYPE_ON))\n\t\treturn PyErr_Format (PyExc_ValueError,\n\t\t\t\t     \"invalid value %d: use either RTL, LTR or ON\",\n\t\t\t\t     base);\n\tif (PyUnicode_Check (logical))\n\t        return log2vis_unicode (logical, base, clean, reordernsm);\n\telse if (PyString_Check (logical))\n\t        return log2vis_encoded_string (logical, encoding, base, clean, reordernsm);\n\telse\n\t\treturn PyErr_Format (PyExc_TypeError,\n\t\t\t\t     \"expected unicode or str, not %s\",\n\t\t\t\t     logical->ob_type->tp_name);\n}", "target": 1}
{"code": "\tUnbufferedAsioTlsStream(UnbufferedAsioTlsStreamParams& init)\n\t\t: AsioTcpTlsStream(init.IoContext, init.SslContext), m_VerifyOK(true), m_Hostname(init.Hostname)\n\t{\n\t}", "target": 1}
{"code": "irc_nick_realloc_prefixes (struct t_irc_server *server,\n                           int old_length, int new_length)\n{\n    struct t_irc_channel *ptr_channel;\n    struct t_irc_nick *ptr_nick;\n    char *new_prefixes;\n    for (ptr_channel = server->channels; ptr_channel;\n         ptr_channel = ptr_channel->next_channel)\n    {\n        for (ptr_nick = ptr_channel->nicks; ptr_nick;\n             ptr_nick = ptr_nick->next_nick)\n        {\n            if (ptr_nick->prefixes)\n            {\n                new_prefixes = realloc (ptr_nick->prefixes, new_length + 1);\n                if (new_prefixes)\n                {\n                    ptr_nick->prefixes = new_prefixes;\n                    if (new_length > old_length)\n                    {\n                        memset (ptr_nick->prefixes + old_length,\n                                ' ',\n                                new_length - old_length);\n                    }\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n            else\n            {\n                ptr_nick->prefixes = malloc (new_length + 1);\n                if (ptr_nick->prefixes)\n                {\n                    memset (ptr_nick->prefixes, ' ', new_length);\n                    ptr_nick->prefixes[new_length] = '\\0';\n                }\n            }\n        }\n    }\n}", "target": 0}
{"code": "ikev1_attr_print(netdissect_options *ndo, const u_char *p, const u_char *ep)\n{\n\tint totlen;\n\tuint32_t t;\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tt = p[2];\n\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}", "target": 1}
{"code": "static void lent_destructor(void *arg)\n{\n\tstruct lookup_entry *lent = arg;\n\tmem_deref(lent->host);\n}", "target": 0}
{"code": "bool ArcMemory::Seek(int64 Offset,int Method)\n{\n  if (!Loaded)\n    return false;\n  if (Method==SEEK_SET)\n    SeekPos=Min(Offset,ArcData.Size());\n  else\n    if (Method==SEEK_CUR || Method==SEEK_END)\n    {\n      if (Method==SEEK_END)\n        SeekPos=ArcData.Size();\n      SeekPos+=(uint64)Offset;\n      if (SeekPos>ArcData.Size())\n        SeekPos=Offset<0 ? 0 : ArcData.Size();\n    }\n  return true;\n}", "target": 0}
{"code": "int stringmatchlen(const char *pattern, int patternLen,\n        const char *string, int stringLen, int nocase) {\n    int skipLongerMatches = 0;\n    return stringmatchlen_impl(pattern,patternLen,string,stringLen,nocase,&skipLongerMatches,0);\n}", "target": 0}
{"code": "    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n        bool bASCII = false;\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }", "target": 1}
{"code": "static int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(dentry->d_inode);\n\tint result = -ENOENT;\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}", "target": 0}
{"code": "void kvm_release_pfn_clean(kvm_pfn_t pfn)\n{\n\tif (!is_error_noslot_pfn(pfn) && !kvm_is_reserved_pfn(pfn))\n\t\tput_page(pfn_to_page(pfn));\n}", "target": 0}
{"code": "  virtual ~EmbeddedWorkerBrowserTest() {}", "target": 0}
{"code": "int luaD_pretailcall (lua_State *L, CallInfo *ci, StkId func,\n                                    int narg1, int delta) {\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \n      return precallC(L, func, LUA_MULTRET, clCvalue(s2v(func))->f);\n    case LUA_VLCF:  \n      return precallC(L, func, LUA_MULTRET, fvalue(s2v(func)));\n    case LUA_VLCL: {  \n      Proto *p = clLvalue(s2v(func))->p;\n      int fsize = p->maxstacksize;  \n      int nfixparams = p->numparams;\n      int i;\n      ci->func -= delta;  \n      for (i = 0; i < narg1; i++)  \n        setobjs2s(L, ci->func + i, func + i);\n      checkstackGC(L, fsize);\n      func = ci->func;  \n      for (; narg1 <= nfixparams; narg1++)\n        setnilvalue(s2v(func + narg1));  \n      ci->top = func + 1 + fsize;  \n      lua_assert(ci->top <= L->stack_last);\n      ci->u.l.savedpc = p->code;  \n      ci->callstatus |= CIST_TAIL;\n      L->top = func + narg1;  \n      return -1;\n    }\n    default: {  \n      func = luaD_tryfuncTM(L, func);  \n      narg1++;\n      goto retry;  \n    }\n  }\n}", "target": 1}
{"code": "dirvote_get_vote(const char *fp, int flags)\n{\n  int by_id = flags & DGV_BY_ID;\n  const int include_pending = flags & DGV_INCLUDE_PENDING;\n  const int include_previous = flags & DGV_INCLUDE_PREVIOUS;\n  if (!pending_vote_list && !previous_vote_list)\n    return NULL;\n  if (fp == NULL) {\n    authority_cert_t *c = get_my_v3_authority_cert();\n    if (c) {\n      fp = c->cache_info.identity_digest;\n      by_id = 1;\n    } else\n      return NULL;\n  }\n  if (by_id) {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(get_voter(pv->vote)->identity_digest, fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  } else {\n    if (pending_vote_list && include_pending) {\n      SMARTLIST_FOREACH(pending_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n    if (previous_vote_list && include_previous) {\n      SMARTLIST_FOREACH(previous_vote_list, pending_vote_t *, pv,\n        if (fast_memeq(pv->vote->digests.d[DIGEST_SHA1], fp, DIGEST_LEN))\n          return pv->vote_body);\n    }\n  }\n  return NULL;\n}", "target": 0}
{"code": "void main_cleanup() {\n#ifdef USE_OS_THREADS\n    CLI *c;\n    unsigned i, threads;\n    THREAD_ID *thread_list;\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_THREAD_LIST]);\n    threads=0;\n    for(c=thread_head; c; c=c->thread_next) \n        threads++;\n    thread_list=str_alloc((threads+1)*sizeof(THREAD_ID));\n    i=0;\n    for(c=thread_head; c; c=c->thread_next) { \n        thread_list[i++]=c->thread_id;\n        s_log(LOG_DEBUG, \"Terminating a thread for [%s]\", c->opt->servname);\n    }\n    if(cron_thread_id) { \n        thread_list[threads++]=cron_thread_id;\n        s_log(LOG_DEBUG, \"Terminating the cron thread\");\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_THREAD_LIST]);\n    if(threads) {\n        s_log(LOG_NOTICE, \"Terminating %u service thread(s)\", threads);\n        writesocket(terminate_pipe[1], \"\", 1);\n        for(i=0; i<threads; ++i) { \n#ifdef USE_PTHREAD\n            if(pthread_join(thread_list[i], NULL))\n                s_log(LOG_ERR, \"pthread_join() failed\");\n#endif\n#ifdef USE_WIN32\n            if(WaitForSingleObject(thread_list[i], INFINITE)==WAIT_FAILED)\n                ioerror(\"WaitForSingleObject\");\n            if(!CloseHandle(thread_list[i]))\n                ioerror(\"CloseHandle\");\n#endif\n        }\n        s_log(LOG_NOTICE, \"Service threads terminated\");\n    }\n    str_free(thread_list);\n#endif \n    unbind_ports();\n    s_poll_free(fds);\n    fds=NULL;\n#if 0\n    str_stats(); \n#endif\n    log_flush(LOG_MODE_ERROR);\n    log_close(SINK_SYSLOG|SINK_OUTFILE);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    OP_REQUIRES(context,\n                batch == out_backprop.dim_size(0) &&\n                    out_rows == out_backprop.dim_size(1) &&\n                    out_cols == out_backprop.dim_size(2) &&\n                    depth == out_backprop.dim_size(3),\n                errors::InvalidArgument(\"out_backprop has incompatible size.\"));\n    Tensor* in_backprop = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &in_backprop));\n    if (input.shape().num_elements() == 0) {\n      return;\n    }\n    functor::DilationBackpropInput<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,\n        stride_cols, rate_rows, rate_cols, pad_top, pad_left,\n        in_backprop->tensor<T, 4>());\n  }", "target": 0}
{"code": "NavigationControllerImpl& WebContentsImpl::GetControllerForRenderManager() {\n  return GetController();\n}", "target": 0}
{"code": "Pl_Count::write(unsigned char* buf, size_t len)\n{\n    if (len)\n    {\n\tthis->m->count += QIntC::to_offset(len);\n\tgetNext()->write(buf, len);\n\tthis->m->last_char = buf[len - 1];\n    }\n}", "target": 1}
{"code": "xfs_inode_ag_iterator(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\t(*execute)(struct xfs_inode *ip, int flags,\n\t\t\t\t\t   void *args),\n\tint\t\t\tflags,\n\tvoid\t\t\t*args)\n{\n\treturn xfs_inode_ag_iterator_flags(mp, execute, flags, args, 0);\n}", "target": 0}
{"code": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}", "target": 1}
{"code": "deltas_head_for_each(struct deltas_head *deltas, unsigned long max_serial,\n    unsigned long from_serial, delta_head_cb cb, void *arg)\n{\n\tsize_t index;\n\tsize_t from;\n\tint error;\n\tif (deltas->capacity == 0) {\n\t\tpr_val_warn(\"There's no delta list to process.\");\n\t\treturn -ENOENT;\n\t}\n\tpr_val_debug(\"Getting RRDP deltas from serial %lu to %lu.\", from_serial,\n\t    max_serial);\n\tfrom = deltas->capacity - (max_serial - from_serial);\n\tfor (index = from; index < deltas->capacity; index++) {\n\t\terror = cb(deltas->array[index], arg);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n{\n\tM_list_str_t *parts;\n\tconst char   *part;\n\tchar         *out;\n\tsize_t        len;\n\tsize_t        i;\n\tsize_t        count;\n\tif (path == NULL) {\n\t\treturn NULL;\n\t}\n\tlen = M_list_str_len(path);\n\tif (len == 0) {\n\t\treturn NULL;\n\t}\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\tparts = M_list_str_duplicate(path);\n\tfor (i=len-1; i>0; i--) {\n\t\tpart = M_list_str_at(parts, i);\n\t\tif (part == NULL || *part == '\\0') {\n\t\t\tM_list_str_remove_at(parts, i);\n\t\t}\n\t}\n\tlen = M_list_str_len(parts);\n\tpart = M_list_str_at(parts, 0);\n\tif (len == 1 && (part == NULL || *part == '\\0')) {\n\t\tM_list_str_destroy(parts);\n\t\tif (sys_type == M_FS_SYSTEM_WINDOWS) {\n\t\t\treturn M_strdup(\"\\\\\\\\\");\n\t\t}\n\t\treturn M_strdup(\"/\");\n\t}\n\tif (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {\n\t\tpart  = M_list_str_at(parts, 0);\n\t\tcount = (len == 1) ? 2 : 1;\n\t\tif (part != NULL && *part == '\\0') {\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tM_list_str_insert_at(parts, \"\", 0);\n\t\t\t}\n\t\t} else if (M_fs_path_isabs(part, sys_type) && len == 1) {\n\t\t\tM_list_str_insert_at(parts, \"\", 1);\n\t\t}\n\t}\n\tout = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));\n\tM_list_str_destroy(parts);\n\treturn out;\n}", "target": 1}
{"code": "String BuildElementErrorMessage(const String& error) {\n  DEFINE_STATIC_LOCAL(const String, element_error_prefix,\n                      (\"MEDIA_ELEMENT_ERROR: \"));\n  StringBuilder builder;\n  builder.Append(element_error_prefix);\n  builder.Append(error);\n  return builder.ToString();\n}", "target": 0}
{"code": "ElectronNavigationThrottle::WillStartRequest() {\n  auto* handle = navigation_handle();\n  auto* contents = handle->GetWebContents();\n  if (!contents) {\n    NOTREACHED();\n    return PROCEED;\n  }\n  v8::Isolate* isolate = v8::Isolate::GetCurrent();\n  v8::HandleScope scope(isolate);\n  auto api_contents = electron::api::WebContents::From(isolate, contents);\n  if (api_contents.IsEmpty()) {\n    return PROCEED;\n  }\n  if (handle->IsRendererInitiated() && handle->IsInMainFrame() &&\n      api_contents->EmitNavigationEvent(\"will-navigate\", handle)) {\n    return CANCEL;\n  }\n  return PROCEED;\n}", "target": 0}
{"code": "static struct port_buffer *get_inbuf(struct port *port)\n{\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tif (port->inbuf)\n\t\treturn port->inbuf;\n\tbuf = virtqueue_get_buf(port->in_vq, &len);\n\tif (buf) {\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\tport->stats.bytes_received += len;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "is_contained_by (asection *section, Elf_Internal_Phdr *segment,\n\t\t bfd_vma paddr, bfd_vma vaddr, unsigned int opb,\n\t\t const struct elf_backend_data *bed)\n{\n  bfd_vma seg_addr = !bed->want_p_paddr_set_to_zero ? paddr : vaddr;\n  bfd_vma addr = !bed->want_p_paddr_set_to_zero ? section->lma : section->vma;\n  bfd_vma octet;\n  if (_bfd_mul_overflow (addr, opb, &octet))\n    return false;\n  return (octet >= seg_addr\n\t  && segment_size (segment) >= section_size (section, segment)\n\t  && (octet - seg_addr\n\t      <= segment_size (segment) - section_size (section, segment)));\n}", "target": 0}
{"code": "vrrp_print_stats(void)\n{\n\tFILE *file;\n\tfile = fopen (stats_file, \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tstats_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\tlist l = vrrp_data->vrrp;\n\telement e;\n\tvrrp_t *vrrp;\n\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\t\tfprintf(file, \"VRRP Instance: %s\\n\", vrrp->iname);\n\t\tfprintf(file, \"  Advertisements:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->advert_rcvd);\n\t\tfprintf(file, \"    Sent: %d\\n\", vrrp->stats->advert_sent);\n\t\tfprintf(file, \"  Became master: %d\\n\", vrrp->stats->become_master);\n\t\tfprintf(file, \"  Released master: %d\\n\",\n\t\t\tvrrp->stats->release_master);\n\t\tfprintf(file, \"  Packet Errors:\\n\");\n\t\tfprintf(file, \"    Length: %\" PRIu64 \"\\n\", vrrp->stats->packet_len_err);\n\t\tfprintf(file, \"    TTL: %\" PRIu64 \"\\n\", vrrp->stats->ip_ttl_err);\n\t\tfprintf(file, \"    Invalid Type: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->invalid_type_rcvd);\n\t\tfprintf(file, \"    Advertisement Interval: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->advert_interval_err);\n\t\tfprintf(file, \"    Address List: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->addr_list_err);\n\t\tfprintf(file, \"  Authentication Errors:\\n\");\n\t\tfprintf(file, \"    Invalid Type: %d\\n\",\n\t\t\tvrrp->stats->invalid_authtype);\n#ifdef _WITH_VRRP_AUTH_\n\t\tfprintf(file, \"    Type Mismatch: %d\\n\",\n\t\t\tvrrp->stats->authtype_mismatch);\n\t\tfprintf(file, \"    Failure: %d\\n\",\n\t\t\tvrrp->stats->auth_failure);\n#endif\n\t\tfprintf(file, \"  Priority Zero:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_rcvd);\n\t\tfprintf(file, \"    Sent: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_sent);\n\t}\n\tfclose(file);\n}", "target": 1}
{"code": "int rose_parse_facilities(unsigned char *p, unsigned packet_len,\n\tstruct rose_facilities_struct *facilities)\n{\n\tint facilities_len, len;\n\tfacilities_len = *p++;\n\tif (facilities_len == 0 || (unsigned)facilities_len > packet_len)\n\t\treturn 0;\n\twhile (facilities_len >= 3 && *p == 0x00) {\n\t\tfacilities_len--;\n\t\tp++;\n\t\tswitch (*p) {\n\t\tcase FAC_NATIONAL:\t\t\n\t\t\tlen = rose_parse_national(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\t\tcase FAC_CCITT:\t\t\n\t\t\tlen = rose_parse_ccitt(p + 1, facilities, facilities_len - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_DEBUG \"ROSE: rose_parse_facilities - unknown facilities family %02X\\n\", *p);\n\t\t\tlen = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (len < 0)\n\t\t\treturn 0;\n\t\tif (WARN_ON(len >= facilities_len))\n\t\t\treturn 0;\n\t\tfacilities_len -= len + 1;\n\t\tp += len + 1;\n\t}\n\treturn facilities_len == 0;\n}", "target": 0}
{"code": "parserep(netdissect_options *ndo,\n         register const struct sunrpc_msg *rp, register u_int length)\n{\n\tregister const uint32_t *dp;\n\tu_int len;\n\tenum sunrpc_accept_stat astat;\n\tdp = ((const uint32_t *)&rp->rm_reply) + 1;\n\tND_TCHECK(dp[1]);\n\tlen = EXTRACT_32BITS(&dp[1]);\n\tif (len >= length)\n\t\treturn (NULL);\n\tdp += (len + (2*sizeof(uint32_t) + 3)) / sizeof(uint32_t);\n\tND_TCHECK2(dp[0], 0);\n\tastat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);\n\tif (astat != SUNRPC_SUCCESS) {\n\t\tND_PRINT((ndo, \" %s\", tok2str(sunrpc_str, \"ar_stat %d\", astat)));\n\t\tnfserr = 1;\t\t\n\t\treturn (NULL);\n\t}\n\tND_TCHECK2(*dp, sizeof(astat));\n\treturn ((const uint32_t *) (sizeof(astat) + ((const char *)dp)));\ntrunc:\n\treturn (0);\n}", "target": 1}
{"code": "fbFetchPixel_b8g8r8 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD8   *pixel = ((CARD8 *) bits) + (offset*3);\n#if IMAGE_BYTE_ORDER == MSBFirst\n    return (0xff000000 |\n\t    (READ(pixel + 2) << 16) |\n\t    (READ(pixel + 1) << 8) |\n\t    (READ(pixel + 0)));\n#else\n    return (0xff000000 |\n\t    (READ(pixel + 0) << 16) |\n\t    (READ(pixel + 1) << 8) |\n\t    (READ(pixel + 2)));\n#endif\n}", "target": 0}
{"code": "    **/\n    T cubic_cut_atXYZ(const float fx, const float fy, const float fz, const int c, const T& out_value) const {\n      return cimg::type<T>::cut(cubic_atXYZ(fx,fy,fz,c,out_value));", "target": 0}
{"code": "void RenderView::OnDownloadFavIcon(int id,\n                                   const GURL& image_url,\n                                   int image_size) {\n  bool data_image_failed = false;\n  if (image_url.SchemeIs(\"data\")) {\n    SkBitmap data_image = ImageFromDataUrl(image_url);\n    data_image_failed = data_image.empty();\n    if (!data_image_failed) {\n      Send(new ViewHostMsg_DidDownloadFavIcon(routing_id_, id, image_url, false,\n                                              data_image));\n    }\n  }\n  if (data_image_failed ||\n      !DownloadImage(id, image_url, image_size)) {\n    Send(new ViewHostMsg_DidDownloadFavIcon(routing_id_, id, image_url, true,\n                                            SkBitmap()));\n  }\n}", "target": 0}
{"code": "bool MemoryManager::validate_user_write(const Process& process, VirtualAddress vaddr) const\n{\n    auto* region = region_from_vaddr(process, vaddr);\n    return region && region->is_writable();\n}", "target": 1}
{"code": "k5_asn1_full_decode(const krb5_data *code, const struct atype_info *a,\n                    void **retrep)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    taginfo t;\n    *retrep = NULL;\n    ret = get_tag((uint8_t *)code->data, code->length, &t, &contents,\n                  &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (!check_atype_tag(a, &t))\n        return ASN1_BAD_ID;\n    return decode_atype_to_ptr(&t, contents, clen, a, retrep);\n}", "target": 1}
{"code": "StatusOr<unsigned> GraphDefImporter::ArgNumType(const NamedAttrList &attrs,\n                                                const OpDef::ArgDef &arg_def,\n                                                SmallVectorImpl<Type> &types) {\n  if (!arg_def.type_list_attr().empty()) {\n    if (auto v = attrs.get(arg_def.type_list_attr()).dyn_cast<ArrayAttr>()) {\n      for (Attribute attr : v) {\n        if (auto dtype = attr.dyn_cast<TypeAttr>()) {\n          types.push_back(UnrankedTensorType::get(dtype.getValue()));\n        } else {\n          return InvalidArgument(\"Expected '\", arg_def.type_list_attr(),\n                                 \"' to be a list of types\");\n        }\n      }\n      return v.size();\n    }\n    return NotFound(\"Type attr not found: \", arg_def.type_list_attr());\n  }\n  unsigned num = 1;\n  if (!arg_def.number_attr().empty()) {\n    if (auto v = attrs.get(arg_def.number_attr()).dyn_cast<IntegerAttr>()) {\n      num = v.getValue().getZExtValue();\n    } else {\n      return NotFound(\"Type attr not found: \", arg_def.number_attr());\n    }\n  }\n  Type dtype;\n  if (arg_def.type() != DataType::DT_INVALID) {\n    TF_RETURN_IF_ERROR(ConvertDataType(arg_def.type(), b_, &dtype));\n  } else if (arg_def.type_attr().empty()) {\n    return InvalidArgument(\"Arg '\", arg_def.name(),\n                           \"' has invalid type and no type attribute\");\n  } else {\n    if (auto v = attrs.get(arg_def.type_attr()).dyn_cast<TypeAttr>()) {\n      dtype = v.getValue();\n    } else {\n      return NotFound(\"Type attr not found: \", arg_def.type_attr());\n    }\n  }\n  types.append(num, UnrankedTensorType::get(dtype));\n  return num;\n}", "target": 1}
{"code": "struct btrfs_device *btrfs_find_device(struct btrfs_fs_devices *fs_devices,\n\t\t\t\t       u64 devid, u8 *uuid, u8 *fsid)\n{\n\tstruct btrfs_device *device;\n\twhile (fs_devices) {\n\t\tif (!fsid ||\n\t\t    !memcmp(fs_devices->metadata_uuid, fsid, BTRFS_FSID_SIZE)) {\n\t\t\tdevice = find_device(fs_devices, devid, uuid);\n\t\t\tif (device)\n\t\t\t\treturn device;\n\t\t}\n\t\tfs_devices = fs_devices->seed;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}", "target": 1}
{"code": "static inline bool is_noncanonical_address(u64 la)\n{\n#ifdef CONFIG_X86_64\n\treturn get_canonical(la) != la;\n#else\n\treturn false;\n#endif\n}", "target": 0}
{"code": "static ssize_t module_xz_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0xfd, '7', 'z', 'X', 'Z', 0 };\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tsize_t new_size = 0;\n\tssize_t retval;\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not an xz compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\txz_buf.in_size = size;\n\txz_buf.in = buf;\n\txz_buf.in_pos = 0;\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\t\tnew_size += xz_buf.out_pos;\n\t} while (xz_buf.out_pos == PAGE_SIZE && xz_ret == XZ_OK);\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", xz_ret);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\tretval = new_size;\n out:\n\txz_dec_end(xz_dec);\n\treturn retval;\n}", "target": 1}
{"code": "int db_update(char* name, char* value)\n{\n\tchar* sql;\n\tint r = 0;\n\tif (crypt_key) {\n\t\tvalue = note_encrypt(value,crypt_key);\n\t\tr = asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='true' WHERE name='%s'\", value, name);\n\t\tfree(value);\n\t\tif (r < 0)\n\t\t\treturn 1;\n\t}else{\n\t\tif (asprintf(&sql, \"UPDATE nodau set text='%s' , encrypted='false' WHERE name='%s'\", value, name) < 0)\n\t\t\treturn 1;\n\t}\n\tr = sqlite3_exec(db_data.db, sql, NULL, 0, &db_data.error_msg);\n\tfree(sql);\n\treturn r;\n}", "target": 1}
{"code": "TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* hash;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &hash));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input));\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n  TF_LITE_ENSURE(context, SizeOfDimension(input, 0) >= 1);\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &weight));\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;\n  }\n  return context->ResizeTensor(context, output, outputSize);\n}", "target": 0}
{"code": "  TfLiteRegistration CancelOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      cancellation_data_.is_cancelled = true;\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "soup_server_new (const char *optname1, ...)\n{\n\tSoupServer *server;\n\tva_list ap;\n\tva_start (ap, optname1);\n\tserver = (SoupServer *)g_object_new_valist (SOUP_TYPE_SERVER,\n\t\t\t\t\t\t    optname1, ap);\n\tva_end (ap);\n\treturn server;\n}", "target": 0}
{"code": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n    emit newLogPeer(temp);\n}", "target": 1}
{"code": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n\tstruct netdev_desc *desc;\n\tint i;\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 1:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 3:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 4:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 5:\n\t\tnetif_stop_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 6:\n\t\tnetif_wake_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 7:\n\t\tprintk\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n\t\t     np->old_rx);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 8:\n\t\tprintk(\"TX ring:\\n\");\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tdesc = &np->tx_ring[i];\n\t\t\tprintk\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n\t\t\t     i,\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n\t\t\t     (u32)le64_to_cpu(desc->status),\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n\t\t\tprintk (\"\\n\");\n\t\t}\n\t\tprintk (\"\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static inline bool unconditional(const struct ipt_ip *ip)\n{\n\tstatic const struct ipt_ip uncond;\n\treturn memcmp(ip, &uncond, sizeof(uncond)) == 0;\n#undef FWINV\n}", "target": 1}
{"code": "static Jsi_RC SysTimesCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_RC rc = JSI_OK;\n    int i, n=1, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Value *func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueIsBoolean(interp, func)) {\n        bool bv;\n        if (argc != 1)\n            return Jsi_LogError(\"bool must be only arg\");\n        Jsi_GetBoolFromValue(interp, func, &bv);\n        double now = jsi_GetTimestamp();\n        if (bv)\n            interp->timesStart = now;\n        else {\n            char buf[100];\n            snprintf(buf, sizeof(buf), \" (times = %.6f sec)\\n\", (now-interp->timesStart));\n            Jsi_Puts(interp, jsi_Stderr, buf, -1);\n        }\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_Wide diff, start, end;\n    if (!Jsi_ValueIsFunction(interp, func))\n        return Jsi_LogError(\"arg1: expected function|bool\");\n    if (argc > 1 && Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, 1), &n) != JSI_OK)\n        return JSI_ERROR;\n    if (n<=0) \n        return Jsi_LogError(\"count not > 0: %d\", n);\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    start = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    for (i=0; i<n && rc == JSI_OK; i++) {\n        rc = Jsi_FunctionInvoke(interp, func, NULL, ret, NULL);\n    }\n    gettimeofday(&tv, NULL);\n    end = (Jsi_Wide) tv.tv_sec * 1000000 + tv.tv_usec;\n    diff = (end - start);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)diff);\n    return rc;\n}", "target": 1}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "int sas_discover_end_dev(struct domain_device *dev)\n{\n\tint res;\n\tres = sas_notify_lldd_dev_found(dev);\n\tif (res)\n\t\treturn res;\n\tsas_discover_event(dev->port, DISCE_PROBE);\n\treturn 0;\n}", "target": 1}
{"code": "static int do_i2c_crc(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t      char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tint\tcount;\n\tuchar\tbyte;\n\tulong\tcrc;\n\tulong\terr;\n\tint ret = 0;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc < 4)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n#endif\n\tcount = hextoul(argv[3], NULL);\n\tprintf (\"CRC32 for %08lx ... %08lx ==> \", addr, addr + count - 1);\n\tcrc = 0;\n\terr = 0;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, &byte, 1);\n#else\n\t\tret = i2c_read(chip, addr, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\terr++;\n\t\tcrc = crc32(crc, &byte, 1);\n\t\taddr++;\n\t}\n\tif (err > 0)\n\t\ti2c_report_err(ret, I2C_ERR_READ);\n\telse\n\t\tprintf (\"%08lx\\n\", crc);\n\treturn 0;\n}", "target": 1}
{"code": "lyd_new_output(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new(parent, snode, 0);\n}", "target": 1}
{"code": "mrb_singleton_class_ptr(mrb_state *mrb, mrb_value v)\n{\n  struct RBasic *obj;\n  switch (mrb_type(v)) {\n  case MRB_TT_FALSE:\n    if (mrb_nil_p(v))\n      return mrb->nil_class;\n    return mrb->false_class;\n  case MRB_TT_TRUE:\n    return mrb->true_class;\n  case MRB_TT_CPTR:\n  case MRB_TT_SYMBOL:\n  case MRB_TT_INTEGER:\n#ifndef MRB_NO_FLOAT\n  case MRB_TT_FLOAT:\n#endif\n    return NULL;\n  default:\n    break;\n  }\n  obj = mrb_basic_ptr(v);\n  if (obj->c == NULL) return NULL;\n  prepare_singleton_class(mrb, obj);\n  return obj->c;\n}", "target": 0}
{"code": "const char* ExpressionRandom::getOpName() const {\n    return \"$rand\";\n}", "target": 0}
{"code": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}", "target": 1}
{"code": "__global__ void UnsortedSegmentCustomKernel(const Index input_outer_dim_size,\n                                            const Index inner_dim_size,\n                                            const Index output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const Index input_total_size = input_outer_dim_size * inner_dim_size;\n  const Index output_total_size = output_outer_dim_size * inner_dim_size;\n  for (int input_index : GpuGridRangeX(input_total_size)) {\n    const Index input_segment_index = input_index / inner_dim_size;\n    const Index segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 || output_segment_index >= output_total_size) {\n      continue;\n    }\n    const Index output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}", "target": 1}
{"code": "    void Xmpdatum::setValue(const Value* pValue)\n    {\n        p_->value_.reset();\n        if (pValue) p_->value_ = pValue->clone();\n    }", "target": 0}
{"code": "device_linux_md_stop_authorized_cb (Daemon *daemon,\n                                    Device *device,\n                                    DBusGMethodInvocation *context,\n                                    const gchar *action_id,\n                                    guint num_user_data,\n                                    gpointer *user_data_elements)\n{\n  int n;\n  char *argv[10];\n  GError *error;\n  n = 0;\n  argv[n++] = \"mdadm\";\n  argv[n++] = \"--stop\";\n  argv[n++] = device->priv->device_file;\n  argv[n++] = NULL;\n  error = NULL;\n  if (!job_new (context, \"LinuxMdStop\", TRUE, device, argv, NULL, linux_md_stop_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}", "target": 0}
{"code": "fbCombineConjointInReverseC (CARD32 *dest, CARD32 *src, CARD32 *mask, int width)\n{\n    fbCombineConjointGeneralC (dest, src, mask, width, CombineBIn);\n}", "target": 0}
{"code": "void HBCISel::generateHBCResolveEnvironment(\n    HBCResolveEnvironment *Inst,\n    BasicBlock *next) {\n  VariableScope *instScope = Inst->getScope();\n  Optional<int32_t> instScopeDepth = scopeAnalysis_.getScopeDepth(instScope);\n  Optional<int32_t> curScopeDepth =\n      scopeAnalysis_.getScopeDepth(F_->getFunctionScope());\n  if (!instScopeDepth || !curScopeDepth) {\n    emitUnreachableIfDebug();\n    return;\n  }\n  assert(\n      curScopeDepth && curScopeDepth.getValue() >= instScopeDepth.getValue() &&\n      \"Cannot access variables in inner scopes\");\n  int32_t delta = curScopeDepth.getValue() - instScopeDepth.getValue();\n  assert(delta > 0 && \"HBCResolveEnvironment for current scope\");\n  if (std::numeric_limits<uint8_t>::max() < delta) {\n    F_->getContext().getSourceErrorManager().error(\n        Inst->getLocation(), \"Variable environment is out-of-reach\");\n  }\n  BCFGen_->emitGetEnvironment(encodeValue(Inst), delta - 1);\n}", "target": 0}
{"code": "std::string addEmoji(const Proxy &node, const RegexMatchConfigs &emoji_array, extra_settings &ext)\n{\n    std::string real_rule, ret;\n    for(const RegexMatchConfig &x : emoji_array)\n    {\n        if(!x.Script.empty())\n        {\n            std::string result;\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto getEmoji = (std::function<std::string(const Proxy&)>) ctx.eval(\"getEmoji\");\n                    ret = getEmoji(node);\n                    if(!ret.empty())\n                        result = ret + \" \" + node.Remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            if(!result.empty())\n                return result;\n            continue;\n        }\n        if(x.Replace.empty())\n            continue;\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size() && regFind(node.Remark, real_rule))\n            return x.Replace + \" \" + node.Remark;\n    }\n    return node.Remark;\n}", "target": 1}
{"code": "mm_skey_query(void *ctx, char **name, char **infotxt,\n   u_int *numprompts, char ***prompts, u_int **echo_on)\n{\n\tBuffer m;\n\tint len;\n\tu_int success;\n\tchar *p, *challenge;\n\tdebug3(\"%s: entering\", __func__);\n\tbuffer_init(&m);\n\tmm_request_send(pmonitor->m_recvfd, MONITOR_REQ_SKEYQUERY, &m);\n\tmm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_SKEYQUERY,\n\t    &m);\n\tsuccess = buffer_get_int(&m);\n\tif (success == 0) {\n\t\tdebug3(\"%s: no challenge\", __func__);\n\t\tbuffer_free(&m);\n\t\treturn (-1);\n\t}\n\tchallenge  = buffer_get_string(&m, NULL);\n\tbuffer_free(&m);\n\tdebug3(\"%s: received challenge: %s\", __func__, challenge);\n\tmm_chall_setup(name, infotxt, numprompts, prompts, echo_on);\n\tlen = strlen(challenge) + strlen(SKEY_PROMPT) + 1;\n\tp = xmalloc(len);\n\tstrlcpy(p, challenge, len);\n\tstrlcat(p, SKEY_PROMPT, len);\n\t(*prompts)[0] = p;\n\txfree(challenge);\n\treturn (0);\n}", "target": 0}
{"code": "static struct phy *serdes_simple_xlate(struct device *dev,\n\t\t\t\t       struct of_phandle_args *args)\n{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\tport = args->args[0];\n\tidx = args->args[1];\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\tmacro->port = port;\n\t\treturn ctrl->phys[i];\n\t}\n\treturn ERR_PTR(-ENODEV);\n}", "target": 1}
{"code": "static void naldmx_switch_timestamps(GF_NALUDmxCtx *ctx, GF_FilterPacket *pck)\n{\n\tif (!ctx->notime) {\n\t\tu64 ts = gf_filter_pck_get_cts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tctx->prev_cts = ctx->cts;\n\t\t\tctx->cts = ts;\n\t\t}\n\t\tts = gf_filter_pck_get_dts(pck);\n\t\tif (ts != GF_FILTER_NO_TS) {\n\t\t\tif (ctx->full_au_source) {\n\t\t\t\tctx->prev_dts = ctx->dts;\n\t\t\t\tctx->dts = ts;\n\t\t\t} else {\n\t\t\t\tGF_FilterClockType ck_type = gf_filter_pid_get_clock_info(ctx->ipid, NULL, NULL);\n\t\t\t\tif (ck_type==GF_FILTER_CLOCK_PCR_DISC)\n\t\t\t\t\tctx->dts = ts;\n\t\t\t\telse if (ctx->dts<ts)\n\t\t\t\t\tctx->dts=ts;\n\t\t\t\tif (!ctx->prev_dts) ctx->prev_dts = ts;\n\t\t\t\telse if (ctx->prev_dts != ts) {\n\t\t\t\t\tu64 diff = ts;\n\t\t\t\t\tdiff -= ctx->prev_dts;\n\t\t\t\t\tif (!ctx->cur_fps.den)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\telse if (ctx->cur_fps.den > diff)\n\t\t\t\t\t\tctx->cur_fps.den = (u32) diff;\n\t\t\t\t\tctx->prev_dts = ts;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tctx->pck_duration = gf_filter_pck_get_duration(pck);\n\t\tif (ctx->src_pck) gf_filter_pck_unref(ctx->src_pck);\n\t\tctx->src_pck = pck;\n\t\tgf_filter_pck_ref_props(&ctx->src_pck);\n\t\tgf_filter_pck_get_framing(pck, &ctx->input_is_au_start, NULL);\n\t}\n}", "target": 0}
{"code": "void SecurityManager::resend_handshake_message_token(\n        const GUID_t& remote_participant_key) const\n{\n    auto sentry = is_security_manager_initialized();\n    if (!sentry)\n    {\n        return;\n    }\n    shared_lock<shared_mutex> _(mutex_);\n    auto dp_it = discovered_participants_.find(remote_participant_key);\n    if (dp_it != discovered_participants_.end())\n    {\n        SecurityManager::DiscoveredParticipantInfo::AuthUniquePtr remote_participant_info = dp_it->second->get_auth();\n        if (remote_participant_info)\n        {\n            if (remote_participant_info->change_sequence_number_ != SequenceNumber_t::unknown())\n            {\n                CacheChange_t* p_change = participant_stateless_message_writer_history_->remove_change_and_reuse(\n                    remote_participant_info->change_sequence_number_);\n                remote_participant_info->change_sequence_number_ = SequenceNumber_t::unknown();\n                if (p_change != nullptr)\n                {\n                    EPROSIMA_LOG_INFO(SECURITY, \"Authentication handshake resent to participant \" <<\n                            remote_participant_key);\n                    if (participant_stateless_message_writer_history_->add_change(p_change))\n                    {\n                        remote_participant_info->change_sequence_number_ = p_change->sequenceNumber;\n                    }\n                }\n            }\n            dp_it->second->set_auth(remote_participant_info);\n        }\n    }\n}", "target": 1}
{"code": "void make_random_permutation(int start) {\n        int i, j;\n        permutation[0] = start;\t\n        for (i = 1; i < ARRAY_SIZE; i++) {\n                j = random() * (double)(i + 1) / RAND_MAX; \n                if (j != i) { \n                  permutation[i] = permutation[j];\n                }\n                permutation[j] = start + i;\n        }\n}", "target": 0}
{"code": "  Status DoCompute(OpKernelContext* ctx) {\n    tensorflow::ResourceTagger tag(kTFDataResourceTag,\n                                   ctx->op_kernel().type_string());\n    tstring filename;\n    TF_RETURN_IF_ERROR(\n        ParseScalarArgument<tstring>(ctx, \"filename\", &filename));\n    tstring compression_type;\n    TF_RETURN_IF_ERROR(ParseScalarArgument<tstring>(ctx, \"compression_type\",\n                                                    &compression_type));\n    std::unique_ptr<WritableFile> file;\n    TF_RETURN_IF_ERROR(ctx->env()->NewWritableFile(filename, &file));\n    auto writer = absl::make_unique<io::RecordWriter>(\n        file.get(),\n        io::RecordWriterOptions::CreateRecordWriterOptions(compression_type));\n    DatasetBase* dataset;\n    TF_RETURN_IF_ERROR(GetDatasetFromVariantTensor(ctx->input(0), &dataset));\n    IteratorContext::Params params(ctx);\n    FunctionHandleCache function_handle_cache(params.flr);\n    params.function_handle_cache = &function_handle_cache;\n    ResourceMgr resource_mgr;\n    params.resource_mgr = &resource_mgr;\n    CancellationManager cancellation_manager(ctx->cancellation_manager());\n    params.cancellation_manager = &cancellation_manager;\n    IteratorContext iter_ctx(std::move(params));\n    DatasetBase* finalized_dataset;\n    TF_RETURN_IF_ERROR(FinalizeDataset(ctx, dataset, &finalized_dataset));\n    std::unique_ptr<IteratorBase> iterator;\n    TF_RETURN_IF_ERROR(finalized_dataset->MakeIterator(\n        &iter_ctx, nullptr, \"ToTFRecordOpIterator\", &iterator));\n    std::vector<Tensor> components;\n    components.reserve(finalized_dataset->output_dtypes().size());\n    bool end_of_sequence;\n    do {\n      TF_RETURN_IF_ERROR(\n          iterator->GetNext(&iter_ctx, &components, &end_of_sequence));\n      if (!end_of_sequence) {\n        TF_RETURN_IF_ERROR(\n            writer->WriteRecord(components[0].scalar<tstring>()()));\n      }\n      components.clear();\n    } while (!end_of_sequence);\n    return Status::OK();\n  }", "target": 1}
{"code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n\tif (nb_bits>=32) return 0;\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts64 neg = (s64) val - (0x00000001UL << nb_bits);\n\t\treturn ((Fixed)neg) / lsr->res_factor;\n\t} else {\n\t\treturn ((Fixed)val) / lsr->res_factor;\n\t}\n#endif\n}", "target": 0}
{"code": "static FormatCode getFormatCode(const _AudioFormat &format)\n{\n\tif (format.sampleFormat == AF_SAMPFMT_FLOAT)\n\t\treturn kFloat;\n\tif (format.sampleFormat == AF_SAMPFMT_DOUBLE)\n\t\treturn kDouble;\n\tif (format.isInteger())\n\t{\n\t\tswitch (format.bytesPerSample(false))\n\t\t{\n\t\t\tcase 1: return kInt8;\n\t\t\tcase 2: return kInt16;\n\t\t\tcase 3: return kInt24;\n\t\t\tcase 4: return kInt32;\n\t\t}\n\t}\n\tassert(false);\n\treturn kUndefined;\n}", "target": 0}
{"code": "void CoreUserInputHandler::handleMsg(const BufferInfo &bufferInfo, const QString &msg)\n{\n    Q_UNUSED(bufferInfo);\n    if (!msg.contains(' '))\n        return;\n    QString target = msg.section(' ', 0, 0);\n    QByteArray encMsg = userEncode(target, msg.section(' ', 1));\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(target), encMsg, network()->cipher(target));\n#else\n    putPrivmsg(serverEncode(target), encMsg);\n#endif\n}", "target": 1}
{"code": "CertificateValidationContextConfigImpl::CertificateValidationContextConfigImpl(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config,\n    Api::Api& api)\n    : ca_cert_(Config::DataSource::read(config.trusted_ca(), true, api)),\n      ca_cert_path_(Config::DataSource::getPath(config.trusted_ca())\n                        .value_or(ca_cert_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      certificate_revocation_list_(Config::DataSource::read(config.crl(), true, api)),\n      certificate_revocation_list_path_(\n          Config::DataSource::getPath(config.crl())\n              .value_or(certificate_revocation_list_.empty() ? EMPTY_STRING : INLINE_STRING)),\n      subject_alt_name_matchers_(config.match_subject_alt_names().begin(),\n                                 config.match_subject_alt_names().end()),\n      verify_certificate_hash_list_(config.verify_certificate_hash().begin(),\n                                    config.verify_certificate_hash().end()),\n      verify_certificate_spki_list_(config.verify_certificate_spki().begin(),\n                                    config.verify_certificate_spki().end()),\n      allow_expired_certificate_(config.allow_expired_certificate()),\n      trust_chain_verification_(config.trust_chain_verification()),\n      custom_validator_config_(\n          config.has_custom_validator_config()\n              ? absl::make_optional<envoy::config::core::v3::TypedExtensionConfig>(\n                    config.custom_validator_config())\n              : absl::nullopt),\n      api_(api), only_verify_leaf_cert_crl_(config.only_verify_leaf_cert_crl()) {\n  if (ca_cert_.empty() && custom_validator_config_ == absl::nullopt) {\n    if (!certificate_revocation_list_.empty()) {\n      throw EnvoyException(fmt::format(\"Failed to load CRL from {} without trusted CA\",\n                                       certificateRevocationListPath()));\n    }\n    if (!subject_alt_name_matchers_.empty()) {\n      throw EnvoyException(\"SAN-based verification of peer certificates without \"\n                           \"trusted CA is insecure and not allowed\");\n    }\n    if (allow_expired_certificate_) {\n      throw EnvoyException(\"Certificate validity period is always ignored without trusted CA\");\n    }\n  }\n}", "target": 1}
{"code": "static void rb_wake_up_waiters(struct irq_work *work)\n{\n\tstruct rb_irq_work *rbwork = container_of(work, struct rb_irq_work, work);\n\twake_up_all(&rbwork->waiters);\n\tif (rbwork->wakeup_full) {\n\t\trbwork->wakeup_full = false;\n\t\twake_up_all(&rbwork->full_waiters);\n\t}\n}", "target": 0}
{"code": "static bool shm_may_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\treturn (shp->shm_nattch == 0) &&\n\t       (ns->shm_rmid_forced ||\n\t\t(shp->shm_perm.mode & SHM_DEST));\n}", "target": 0}
{"code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\tline += PKT_LEN_SIZE;\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}", "target": 0}
{"code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\treturn 0;\n}", "target": 0}
{"code": "static void spl_array_it_get_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC) \n{\n\tspl_array_it       *iterator = (spl_array_it *)iter;\n\tspl_array_object   *object   = iterator->object;\n\tHashTable          *aht      = spl_array_get_hash_table(object, 0 TSRMLS_CC);\n\tif (object->ar_flags & SPL_ARRAY_OVERLOADED_KEY) {\n\t\tzend_user_it_get_current_key(iter, key TSRMLS_CC);\n\t} else {\n\t\tif (spl_array_object_verify_pos_ex(object, aht, \"ArrayIterator::current(): \" TSRMLS_CC) == FAILURE) {\n\t\t\tZVAL_NULL(key);\n\t\t} else {\n\t\t\tzend_hash_get_current_key_zval_ex(aht, key, &object->pos);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)\n{\n#if BITS_PER_LONG == 32\n\treturn (u32)(unsigned long)reply;\n#else\n\tulong flags = 0;\n\tu32 nr, i;\n\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tnr = ARRAY_SIZE(pHba->ioctl_reply_context);\n\tfor (i = 0; i < nr; i++) {\n\t\tif (pHba->ioctl_reply_context[i] == NULL) {\n\t\t\tpHba->ioctl_reply_context[i] = reply;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\tif (i >= nr) {\n\t\tprintk(KERN_WARNING\"%s: Too many outstanding \"\n\t\t\t\t\"ioctl commands\\n\", pHba->name);\n\t\treturn (u32)-1;\n\t}\n\treturn i;\n#endif\n}", "target": 1}
{"code": "_dbus_fd_set_close_on_exec (intptr_t fd)\n{\n  int val;\n  val = fcntl (fd, F_GETFD, 0);\n  if (val < 0)\n    return;\n  val |= FD_CLOEXEC;\n  fcntl (fd, F_SETFD, val);\n}", "target": 0}
{"code": "bool SrvAnsiImpl::ReportString(LPCWSTR asRet)\n{\n\tif (!asRet || !*asRet)\n\t\treturn FALSE;\n\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);\n\tbool bSuccess = WriteConsoleInput(hIn, pir, nLen, &nWritten) && (nWritten == nLen);\n\tif (pir != ir)\n\t\tfree(pir);\n\treturn bSuccess;\n}", "target": 1}
{"code": "bool ResourceHandle::ParseFromString(const string& s) {\n  ResourceHandleProto proto;\n  const bool status = proto.ParseFromString(s);\n  if (status) FromProto(proto);\n  return status;\n}", "target": 1}
{"code": "int sock_initaddress(const char *host, const char *port,\n    struct addrinfo *hints, struct addrinfo **addrinfo, char *errbuf, int errbuflen)\n{\n\tint retval;\n\tretval = getaddrinfo(host, port == NULL ? \"0\" : port, hints, addrinfo);\n\tif (retval != 0)\n\t{\n\t\tif (errbuf)\n\t\t{\n\t\t\tif (host != NULL && port != NULL) {\n\t\t\t\tint try_retval;\n\t\t\t\ttry_retval = getaddrinfo(host, NULL, hints,\n\t\t\t\t    addrinfo);\n\t\t\t\tif (try_retval == 0) {\n\t\t\t\t\tfreeaddrinfo(*addrinfo);\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, NULL, port);\n\t\t\t\t} else {\n\t\t\t\t\tget_gai_errstring(errbuf, errbuflen,\n\t\t\t\t\t    \"\", retval, host, NULL);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tget_gai_errstring(errbuf, errbuflen, \"\",\n\t\t\t\t    retval, host, port);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_family != PF_INET) &&\n\t    ((*addrinfo)->ai_family != PF_INET6))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): socket type not supported\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\tif (((*addrinfo)->ai_socktype == SOCK_STREAM) &&\n\t    (sock_ismcastaddr((*addrinfo)->ai_addr) == 0))\n\t{\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"getaddrinfo(): multicast addresses are not valid when using TCP streams\");\n\t\tfreeaddrinfo(*addrinfo);\n\t\t*addrinfo = NULL;\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "get_case_fold_codes_by_str(OnigCaseFoldType flag,\n\t\t\t\t       const OnigUChar* p, const OnigUChar* end,\n\t\t\t\t       OnigCaseFoldCodeItem items[],\n\t\t\t\t       OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_get_case_fold_codes_by_str_with_map(\n\t     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 1,\n\t     flag, p, end, items);\n}", "target": 0}
{"code": "void UncompressElementOp::Compute(OpKernelContext* ctx) {\n  Tensor tensor = ctx->input(0);\n  const Variant& variant = tensor.scalar<Variant>()();\n  const CompressedElement* compressed = variant.get<CompressedElement>();\n  OP_REQUIRES(\n      ctx, compressed != nullptr,\n      errors::InvalidArgument(\n          \"Input does not contain a compressed element. Instead got tensor \",\n          tensor.DebugString()));\n  std::vector<Tensor> components;\n  OP_REQUIRES_OK(ctx, UncompressElement(*compressed, &components));\n  OP_REQUIRES(ctx, components.size() == output_types_.size(),\n              errors::FailedPrecondition(\"Expected \", output_types_.size(),\n                                         \" outputs from uncompress, but got \",\n                                         components.size()));\n  for (int i = 0; i < components.size(); ++i) {\n    OP_REQUIRES(\n        ctx, components[i].dtype() == output_types_[i],\n        errors::FailedPrecondition(\"Expected a tensor of type \",\n                                   DataTypeString(output_types_[i]),\n                                   \" but got a tensor of type \",\n                                   DataTypeString(components[i].dtype())));\n    ctx->set_output(i, components[i]);\n  }\n}", "target": 0}
{"code": "void native_tss_update_io_bitmap(void)\n{\n\tstruct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw);\n\tstruct thread_struct *t = &current->thread;\n\tu16 *base = &tss->x86_tss.io_bitmap_base;\n\tif (!test_thread_flag(TIF_IO_BITMAP)) {\n\t\ttss_invalidate_io_bitmap(tss);\n\t\treturn;\n\t}\n\tif (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) {\n\t\t*base = IO_BITMAP_OFFSET_VALID_ALL;\n\t} else {\n\t\tstruct io_bitmap *iobm = t->io_bitmap;\n\t\tif (tss->io_bitmap.prev_sequence != iobm->sequence)\n\t\t\ttss_copy_io_bitmap(tss, iobm);\n\t\t*base = IO_BITMAP_OFFSET_VALID_MAP;\n\t}\n\trefresh_tss_limit();\n}", "target": 1}
{"code": "lyd_new_output_leaf(struct lyd_node *parent, const struct lys_module *module, const char *name, const char *val_str)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 1);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_LEAFLIST | LYS_LEAF, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new_leaf(parent, snode, val_str, 0, 0);\n}", "target": 1}
{"code": "void NavigationControllerImpl::LoadIfNecessary() {\n  if (!needs_reload_)\n    return;\n  if (pending_entry_) {\n    NavigateToPendingEntry(ReloadType::NONE, nullptr );\n  } else if (last_committed_entry_index_ != -1) {\n    pending_entry_ = entries_[last_committed_entry_index_].get();\n    pending_entry_index_ = last_committed_entry_index_;\n    NavigateToPendingEntry(ReloadType::NONE, nullptr );\n  } else {\n    needs_reload_ = false;\n  }\n}", "target": 0}
{"code": "void EventPluginsManager::loadPlugin(const QString &pluginId)\n{\n    QPluginLoader loader(\"plasmacalendarplugins/\" + pluginId);\n    if (!loader.load()) {\n        qWarning() << \"Could not create Plasma Calendar Plugin: \" << pluginId;\n        qWarning() << loader.errorString();\n        return;\n    }\n    QObject *obj = loader.instance();\n    if (obj) {\n        CalendarEvents::CalendarEventsPlugin *eventsPlugin = qobject_cast<CalendarEvents::CalendarEventsPlugin *>(obj);\n        if (eventsPlugin) {\n            qDebug() << \"Loading Calendar plugin\" << eventsPlugin;\n            eventsPlugin->setProperty(\"pluginId\", pluginId);\n            d->plugins << eventsPlugin;\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::dataReady, this, &EventPluginsManager::dataReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventModified, this, &EventPluginsManager::eventModified);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::eventRemoved, this, &EventPluginsManager::eventRemoved);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::alternateCalendarDateReady, this, &EventPluginsManager::alternateCalendarDateReady);\n            connect(eventsPlugin, &CalendarEvents::CalendarEventsPlugin::subLabelReady, this, &EventPluginsManager::subLabelReady);\n        } else {\n            loader.unload();\n        }\n    } else {\n        loader.unload();\n    }\n}", "target": 1}
{"code": "int check_name(char *name, int size)\n{\n\tchar *start = name;\n\tif(name[0] == '.') {\n\t\tif(name[1] == '.')\n\t\t\tname++;\n\t\tif(name[1] == '/' || name[1] == '\\0')\n\t\t\treturn FALSE;\n\t}\n\twhile(name[0] != '/' && name[0] != '\\0')\n\t\tname ++;\n\tif(name[0] == '/')\n\t\treturn FALSE;\n\tif((name - start) != size)\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "static s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)\n{\n\tstruct Scsi_Host *host;\n\thost = scsi_host_alloc(sht, sizeof(adpt_hba*));\n\tif (host == NULL) {\n\t\tprintk(\"%s: scsi_host_alloc returned NULL\\n\", pHba->name);\n\t\treturn -1;\n\t}\n\thost->hostdata[0] = (unsigned long)pHba;\n\tpHba->host = host;\n\thost->irq = pHba->pDev->irq;\n\thost->io_port = 0;\n\thost->n_io_port = 0;\n\thost->max_id = 16;\n\thost->max_lun = 256;\n\thost->max_channel = pHba->top_scsi_channel + 1;\n\thost->cmd_per_lun = 1;\n\thost->unique_id = (u32)sys_tbl_pa + pHba->unit;\n\thost->sg_tablesize = pHba->sg_tablesize;\n\thost->can_queue = pHba->post_fifo_size;\n\treturn 0;\n}", "target": 1}
{"code": "main(int argc, char* argv[])\n{\n    (void) argc;\n    (void) argv;\n    const struct CMUnitTest tests[] = {\n            cmocka_unit_test(test_layers),\n            cmocka_unit_test(test_tpm_format_0_version2_0_error),\n            cmocka_unit_test(test_tpm_format_0_version2_0_warn),\n            cmocka_unit_test(test_tpm2_format_0_unknown),\n            cmocka_unit_test(test_tpm_format_1_unk_handle),\n            cmocka_unit_test(test_tpm_format_1_unk_parameter),\n            cmocka_unit_test(test_tpm_format_1_unk_session),\n            cmocka_unit_test(test_tpm_format_1_5_handle),\n            cmocka_unit_test(test_tpm2_format_1_unknown),\n            cmocka_unit_test(test_tpm2_format_1_success),\n            cmocka_unit_test(test_custom_handler),\n            cmocka_unit_test(test_zero_length_name),\n            cmocka_unit_test(test_over_length_name),\n            cmocka_unit_test(test_null_name),\n            cmocka_unit_test(test_sys),\n            cmocka_unit_test(test_esys),\n            cmocka_unit_test(test_mu),\n            cmocka_unit_test(test_tcti),\n            cmocka_unit_test(test_info_fmt0),\n            cmocka_unit_test(test_info_fmt1_parameter),\n            cmocka_unit_test(test_info_fmt1_handle),\n            cmocka_unit_test(test_info_fmt1_session),\n            cmocka_unit_test(test_info_null),\n            cmocka_unit_test(test_info_str_fmt1),\n            cmocka_unit_test(test_info_str_fmt1_ff),\n            cmocka_unit_test(test_info_str_fmt0_err),\n            cmocka_unit_test(test_info_str_fmt0_warn),\n            cmocka_unit_test(test_info_str_fmt0_ff),\n            cmocka_unit_test(test_info_str_null),\n            cmocka_unit_test(test_all_FFs),\n            cmocka_unit_test(test_all_FFs_set_handler)\n    };\n    return cmocka_run_group_tests(tests, NULL, NULL);\n}", "target": 0}
{"code": "static int getSingletonPos(const char* str)\n{\n\tint result =-1;\n\tint i=0;\n\tint len = 0;\n\tif( str && ((len=strlen(str))>0) ){\n\t\tfor( i=0; i<len ; i++){\n\t\t\tif( isIDSeparator(*(str+i)) ){\n\t\t\t\tif( i==1){\n\t\t\t\t\tresult =0;\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tif( isIDSeparator(*(str+i+2)) ){\n\t\t\t\t\t\tresult = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "  QUInt16() {}", "target": 1}
{"code": "smb_send_rqst(struct TCP_Server_Info *server, struct smb_rqst *rqst)\n{\n\tint rc;\n\tstruct kvec *iov = rqst->rq_iov;\n\tint n_vec = rqst->rq_nvec;\n\tunsigned int smb_buf_length = get_rfc1002_length(iov[0].iov_base);\n\tunsigned int i;\n\tsize_t total_len = 0, sent;\n\tstruct socket *ssocket = server->ssocket;\n\tint val = 1;\n\tif (ssocket == NULL)\n\t\treturn -ENOTSOCK;\n\tcFYI(1, \"Sending smb: smb_len=%u\", smb_buf_length);\n\tdump_smb(iov[0].iov_base, iov[0].iov_len);\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\trc = smb_send_kvec(server, iov, n_vec, &sent);\n\tif (rc < 0)\n\t\tgoto uncork;\n\ttotal_len += sent;\n\tfor (i = 0; i < rqst->rq_npages; i++) {\n\t\tstruct kvec p_iov;\n\t\tcifs_rqst_page_to_kvec(rqst, i, &p_iov);\n\t\trc = smb_send_kvec(server, &p_iov, 1, &sent);\n\t\tkunmap(rqst->rq_pages[i]);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\ttotal_len += sent;\n\t}\nuncork:\n\tval = 0;\n\tkernel_setsockopt(ssocket, SOL_TCP, TCP_CORK,\n\t\t\t\t(char *)&val, sizeof(val));\n\tif ((total_len > 0) && (total_len != smb_buf_length + 4)) {\n\t\tcFYI(1, \"partial send (wanted=%u sent=%zu): terminating \"\n\t\t\t\"session\", smb_buf_length + 4, total_len);\n\t\tserver->tcpStatus = CifsNeedReconnect;\n\t}\n\tif (rc < 0 && rc != -EINTR)\n\t\tcERROR(1, \"Error %d sending data on socket to server\", rc);\n\telse\n\t\trc = 0;\n\treturn rc;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, NonPrefixRegexOrCovering) {\n    addIndex(BSON(\"a\" << 1));\n    runQuerySortProj(\n        fromjson(\"{$or: [{a: /0/}, {a: /1/}]}\"), BSONObj(), fromjson(\"{_id: 0, a: 1}\"));\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{cscan: {dir: 1, filter: {$or: [{a: /0/}, {a: /1/}]}}}}}\");\n    assertSolutionExists(\n        \"{proj: {spec: {_id: 0, a: 1}, node: \"\n        \"{ixscan: {filter: {$or: [{a: /0/}, {a: /1/}]}, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "char *curl_easy_escape(CURL *handle, const char *string, int inlength)\n{\n  size_t alloc = (inlength?(size_t)inlength:strlen(string))+1;\n  char *ns;\n  char *testing_ptr = NULL;\n  unsigned char in; \n  size_t newlen = alloc;\n  int strindex=0;\n  size_t length;\n  CURLcode res;\n  ns = malloc(alloc);\n  if(!ns)\n    return NULL;\n  length = alloc-1;\n  while(length--) {\n    in = *string;\n    if(Curl_isunreserved(in))\n      ns[strindex++]=in;\n    else {\n      newlen += 2; \n      if(newlen > alloc) {\n        alloc *= 2;\n        testing_ptr = realloc(ns, alloc);\n        if(!testing_ptr) {\n          free( ns );\n          return NULL;\n        }\n        else {\n          ns = testing_ptr;\n        }\n      }\n      res = Curl_convert_to_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n      snprintf(&ns[strindex], 4, \"%%%02X\", in);\n      strindex+=3;\n    }\n    string++;\n  }\n  ns[strindex]=0; \n  return ns;\n}", "target": 1}
{"code": "      JpegInput( String filename ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); \n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               if( infile_ == nullptr ) {\n                  filename_ = FileAddExtension( filename_, \"jpeg\" ); \n                  infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               }\n            }\n         }\n         if( infile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            DIP_THROW_RUNTIME( \"Error reading JPEG file.\" );\n         }\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }", "target": 1}
{"code": "dump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen(file_name, \"a\");\n\tFREE(file_name);\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\tdump_thread_data(master, fp);\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}", "target": 1}
{"code": "String StringUtil::Implode(const Variant& items, const String& delim,\n                           const bool checkIsContainer ) {\n  if (checkIsContainer && !isContainer(items)) {\n    throw_param_is_not_container();\n  }\n  int size = getContainerSize(items);\n  if (size == 0) return empty_string();\n  req::vector<String> sitems;\n  sitems.reserve(size);\n  int len = 0;\n  int lenDelim = delim.size();\n  for (ArrayIter iter(items); iter; ++iter) {\n    sitems.emplace_back(iter.second().toString());\n    len += sitems.back().size() + lenDelim;\n  }\n  len -= lenDelim; \n  assert(sitems.size() == size);\n  String s = String(len, ReserveString);\n  char *buffer = s.mutableData();\n  const char *sdelim = delim.data();\n  char *p = buffer;\n  String &init_str = sitems[0];\n  int init_len = init_str.size();\n  memcpy(p, init_str.data(), init_len);\n  p += init_len;\n  for (int i = 1; i < size; i++) {\n    String &item = sitems[i];\n    memcpy(p, sdelim, lenDelim);\n    p += lenDelim;\n    int lenItem = item.size();\n    memcpy(p, item.data(), lenItem);\n    p += lenItem;\n  }\n  assert(p - buffer == len);\n  s.setSize(len);\n  return s;\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred)\n{\n\tstruct nfs4_exception exception = { };\n\tstruct nfs4_state *res;\n\tint status;\n\tdo {\n\t\tstatus = _nfs4_do_open(dir, path, flags, sattr, cred, &res);\n\t\tif (status == 0)\n\t\t\tbreak;\n\t\tif (status == -NFS4ERR_BAD_SEQID) {\n\t\t\tprintk(KERN_WARNING \"NFS: v4 server %s \"\n\t\t\t\t\t\" returned a bad sequence-id error!\\n\",\n\t\t\t\t\tNFS_SERVER(dir)->nfs_client->cl_hostname);\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -NFS4ERR_BAD_STATEID) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (status == -EAGAIN) {\n\t\t\texception.retry = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tres = ERR_PTR(nfs4_handle_exception(NFS_SERVER(dir),\n\t\t\t\t\tstatus, &exception));\n\t} while (exception.retry);\n\treturn res;\n}", "target": 1}
{"code": "start_output_ppm (j_decompress_ptr cinfo, djpeg_dest_ptr dinfo)\n{\n  ppm_dest_ptr dest = (ppm_dest_ptr) dinfo;\n  switch (cinfo->out_color_space) {\n  case JCS_GRAYSCALE:\n    fprintf(dest->pub.output_file, \"P5\\n%ld %ld\\n%d\\n\",\n            (long) cinfo->output_width, (long) cinfo->output_height,\n            PPM_MAXVAL);\n    break;\n  case JCS_RGB:\n  case JCS_EXT_RGB:\n  case JCS_EXT_RGBX:\n  case JCS_EXT_BGR:\n  case JCS_EXT_BGRX:\n  case JCS_EXT_XBGR:\n  case JCS_EXT_XRGB:\n  case JCS_EXT_RGBA:\n  case JCS_EXT_BGRA:\n  case JCS_EXT_ABGR:\n  case JCS_EXT_ARGB:\n  case JCS_CMYK:\n    fprintf(dest->pub.output_file, \"P6\\n%ld %ld\\n%d\\n\",\n            (long) cinfo->output_width, (long) cinfo->output_height,\n            PPM_MAXVAL);\n    break;\n  default:\n    ERREXIT(cinfo, JERR_PPM_COLORSPACE);\n  }\n}", "target": 0}
{"code": "spnego_gss_delete_sec_context(\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t *context_handle,\n\t\t\t    gss_buffer_t output_token)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tspnego_gss_ctx_id_t *ctx =\n\t\t    (spnego_gss_ctx_id_t *)context_handle;\n\t*minor_status = 0;\n\tif (context_handle == NULL)\n\t\treturn (GSS_S_FAILURE);\n\tif (*ctx == NULL)\n\t\treturn (GSS_S_COMPLETE);\n\tif ((*ctx)->magic_num == SPNEGO_MAGIC_ID) {\n\t\t(void) gss_delete_sec_context(minor_status,\n\t\t\t\t    &(*ctx)->ctx_handle,\n\t\t\t\t    output_token);\n\t\t(void) release_spnego_ctx(ctx);\n\t} else {\n\t\tret = gss_delete_sec_context(minor_status,\n\t\t\t\t    context_handle,\n\t\t\t\t    output_token);\n\t}\n\treturn (ret);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& rhs = context->input(1);\n    context->forward_ref_input_to_ref_output(0, 0);\n    OP_REQUIRES(\n        context, rhs.IsInitialized(),\n        errors::Internal(\"Right hand side of AssignOp is not initialized\"));\n    AllocatorAttributes attr;\n    if (!relax_constraints_) {\n      attr.set_gpu_compatible(true);\n      attr.set_nic_compatible(true);\n    }\n    {\n      mutex_lock l(*context->input_ref_mutex(0));\n      const Tensor& old_lhs = context->mutable_input(0,  true);\n      const bool same_shape = old_lhs.shape().IsSameSize(rhs.shape());\n      if (validate_shape_) {\n        OP_REQUIRES(context, same_shape,\n                    errors::InvalidArgument(\n                        \"Assign requires shapes of both tensors to match. \"\n                        \"lhs shape= \",\n                        old_lhs.shape().DebugString(),\n                        \" rhs shape= \", rhs.shape().DebugString()));\n      }\n      if (old_lhs.IsInitialized() &&\n          old_lhs.shape().num_elements() == rhs.shape().num_elements()) {\n        Tensor reshaped_old_lhs;\n        if (same_shape) {\n          reshaped_old_lhs = old_lhs;\n        } else {\n          CHECK(reshaped_old_lhs.CopyFrom(old_lhs, rhs.shape()));\n          context->replace_ref_input(0, reshaped_old_lhs,\n                                      true);\n        }\n        if (use_exclusive_lock_) {\n          Copy(context, &reshaped_old_lhs, rhs);\n          return;\n        }\n      } else {\n        std::unique_ptr<Tensor> input_alias = context->forward_input(\n            1, OpKernelContext::Params::kNoReservation ,\n            rhs.dtype(), rhs.shape(), DEVICE_MEMORY, attr);\n        if (input_alias != nullptr) {\n          context->replace_ref_input(0, *input_alias,  true);\n          return;\n        }\n        Tensor copy_tensor;\n        OP_REQUIRES_OK(context,\n                       context->allocate_temp(old_lhs.dtype(), rhs.shape(),\n                                              &copy_tensor, attr));\n        context->clear_recorded_memory();\n        context->replace_ref_input(0, copy_tensor,  true);\n        if (use_exclusive_lock_) {\n          Copy(context, &copy_tensor, rhs);\n          return;\n        }\n      }\n    }\n    Tensor old_unlocked_lhs = context->mutable_input(0,  false);\n    Copy(context, &old_unlocked_lhs, rhs);\n  }", "target": 0}
{"code": "dup_dest_constraint_hop(const struct dest_constraint_hop *dch,\n    struct dest_constraint_hop *out)\n{\n\tu_int i;\n\tint r;\n\tout->user = dch->user == NULL ? NULL : xstrdup(dch->user);\n\tout->hostname = dch->hostname == NULL ? NULL : xstrdup(dch->hostname);\n\tout->is_ca = dch->is_ca;\n\tout->nkeys = dch->nkeys;\n\tout->keys = out->nkeys == 0 ? NULL :\n\t    xcalloc(out->nkeys, sizeof(*out->keys));\n\tout->key_is_ca = out->nkeys == 0 ? NULL :\n\t    xcalloc(out->nkeys, sizeof(*out->key_is_ca));\n\tfor (i = 0; i < dch->nkeys; i++) {\n\t\tif (dch->keys[i] != NULL &&\n\t\t    (r = sshkey_from_private(dch->keys[i],\n\t\t    &(out->keys[i]))) != 0)\n\t\t\tfatal_fr(r, \"copy key\");\n\t\tout->key_is_ca[i] = dch->key_is_ca[i];\n\t}\n}", "target": 0}
{"code": "register_disks_device (Device *device)\n{\n  DBusConnection *connection;\n  GError *error = NULL;\n  device->priv->system_bus_connection = dbus_g_bus_get (DBUS_BUS_SYSTEM, &error);\n  if (device->priv->system_bus_connection == NULL)\n    {\n      if (error != NULL)\n        {\n          g_critical (\"error getting system bus: %s\", error->message);\n          g_error_free (error);\n        }\n      goto error;\n    }\n  connection = dbus_g_connection_get_connection (device->priv->system_bus_connection);\n  device->priv->object_path = compute_object_path (device->priv->native_path);\n  if (dbus_g_connection_lookup_g_object (device->priv->system_bus_connection, device->priv->object_path) != NULL)\n    {\n      g_error (\"**** HACK: Wanting to register object at path `%s' but there is already an \"\n               \"object there. This is an internal error in the daemon. Aborting.\\n\", device->priv->object_path);\n    }\n  dbus_g_connection_register_g_object (device->priv->system_bus_connection,\n                                       device->priv->object_path,\n                                       G_OBJECT (device));\n  return TRUE;\n error:\n  return FALSE;\n}", "target": 0}
{"code": "static int propagate_one(struct mount *m)\n{\n\tstruct mount *child;\n\tint type;\n\tif (IS_MNT_NEW(m))\n\t\treturn 0;\n\tif (!is_subdir(mp->m_dentry, m->mnt.mnt_root))\n\t\treturn 0;\n\tif (peers(m, last_dest)) {\n\t\ttype = CL_MAKE_SHARED;\n\t} else {\n\t\tstruct mount *n, *p;\n\t\tbool done;\n\t\tfor (n = m; ; n = p) {\n\t\t\tp = n->mnt_master;\n\t\t\tif (p == dest_master || IS_MNT_MARKED(p))\n\t\t\t\tbreak;\n\t\t}\n\t\tdo {\n\t\t\tstruct mount *parent = last_source->mnt_parent;\n\t\t\tif (last_source == first_source)\n\t\t\t\tbreak;\n\t\t\tdone = parent->mnt_master == p;\n\t\t\tif (done && peers(n, parent))\n\t\t\t\tbreak;\n\t\t\tlast_source = last_source->mnt_master;\n\t\t} while (!done);\n\t\ttype = CL_SLAVE;\n\t\tif (IS_MNT_SHARED(m))\n\t\t\ttype |= CL_MAKE_SHARED;\n\t}\n\tif (m->mnt_ns->user_ns != user_ns)\n\t\ttype |= CL_UNPRIVILEGED;\n\tchild = copy_tree(last_source, last_source->mnt.mnt_root, type);\n\tif (IS_ERR(child))\n\t\treturn PTR_ERR(child);\n\tchild->mnt.mnt_flags &= ~MNT_LOCKED;\n\tmnt_set_mountpoint(m, mp, child);\n\tlast_dest = m;\n\tlast_source = child;\n\tif (m->mnt_master != dest_master) {\n\t\tread_seqlock_excl(&mount_lock);\n\t\tSET_MNT_MARK(m->mnt_master);\n\t\tread_sequnlock_excl(&mount_lock);\n\t}\n\thlist_add_head(&child->mnt_hash, list);\n\treturn count_mounts(m->mnt_ns, child);\n}", "target": 0}
{"code": "  bool AllocatesOpaqueHandle() const override { return true; }", "target": 0}
{"code": "int anetUnixServer(char *err, char *path, mode_t perm, int backlog)\n{\n    int s;\n    struct sockaddr_un sa;\n    if (strlen(path) > sizeof(sa.sun_path)-1) {\n        anetSetError(err,\"unix socket path too long (%zu), must be under %zu\", strlen(path), sizeof(sa.sun_path));\n        return ANET_ERR;\n    }\n    if ((s = anetCreateSocket(err,AF_LOCAL)) == ANET_ERR)\n        return ANET_ERR;\n    memset(&sa,0,sizeof(sa));\n    sa.sun_family = AF_LOCAL;\n    redis_strlcpy(sa.sun_path,path,sizeof(sa.sun_path));\n    if (anetListen(err,s,(struct sockaddr*)&sa,sizeof(sa),backlog) == ANET_ERR)\n        return ANET_ERR;\n    if (perm)\n        chmod(sa.sun_path, perm);\n    return s;\n}", "target": 1}
{"code": "static void nvme_select_iocs_ns(NvmeCtrl *n, NvmeNamespace *ns)\n{\n    uint32_t cc = ldl_le_p(&n->bar.cc);\n    ns->iocs = nvme_cse_iocs_none;\n    switch (ns->csi) {\n    case NVME_CSI_NVM:\n        if (NVME_CC_CSS(cc) != NVME_CC_CSS_ADMIN_ONLY) {\n            ns->iocs = nvme_cse_iocs_nvm;\n        }\n        break;\n    case NVME_CSI_ZONED:\n        if (NVME_CC_CSS(cc) == NVME_CC_CSS_CSI) {\n            ns->iocs = nvme_cse_iocs_zoned;\n        } else if (NVME_CC_CSS(cc) == NVME_CC_CSS_NVM) {\n            ns->iocs = nvme_cse_iocs_nvm;\n        }\n        break;\n    }\n}", "target": 0}
{"code": "static void do_bad_area(unsigned long addr, unsigned int esr, struct pt_regs *regs)\n{\n\tstruct task_struct *tsk = current;\n\tstruct mm_struct *mm = tsk->active_mm;\n\tif (user_mode(regs))\n\t\t__do_user_fault(tsk, addr, esr, SIGSEGV, SEGV_MAPERR, regs);\n\telse\n\t\t__do_kernel_fault(mm, addr, esr, regs);\n}", "target": 0}
{"code": "static size_t GetImageChannels(const Image *image)\n{\n  register ssize_t\n    i;\n  size_t\n    channels;\n  channels=0;\n  for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n  {\n    PixelChannel channel = GetPixelChannelChannel(image,i);\n    PixelTrait traits = GetPixelChannelTraits(image,channel);\n    if (traits == UndefinedPixelTrait)\n      continue;\n    if ((traits & UpdatePixelTrait) == 0)\n      continue;\n    channels++;\n  }\n  return((size_t) (channels == 0 ? 1 : channels));\n}", "target": 0}
{"code": "get_char(_pdfio_token_t *tb)\t\t\n{\n  ssize_t\tbytes;\t\t\t\n  if (tb->bufptr >= tb->bufend)\n  {\n    if (tb->bufend > tb->buffer)\n    {\n      PDFIO_DEBUG(\"get_char: Consuming %d bytes.\\n\", (int)(tb->bufend - tb->buffer));\n      (tb->consume_cb)(tb->cb_data, (size_t)(tb->bufend - tb->buffer));\n    }\n    if ((bytes = (tb->peek_cb)(tb->cb_data, tb->buffer, sizeof(tb->buffer))) <= 0)\n    {\n      tb->bufptr = tb->bufend = tb->buffer;\n      return (EOF);\n    }\n    tb->bufptr = tb->buffer;\n    tb->bufend = tb->buffer + bytes;\n#if 0\n#ifdef DEBUG\n    unsigned char *ptr;\t\t\t\n    PDFIO_DEBUG(\"get_char: Read '\");\n    for (ptr = tb->buffer; ptr < tb->bufend; ptr ++)\n    {\n      if (*ptr < ' ' || *ptr == 0x7f)\n        PDFIO_DEBUG(\"\\\\%03o\", *ptr);\n      else\n        PDFIO_DEBUG(\"%c\", *ptr);\n    }\n    PDFIO_DEBUG(\"'\\n\");\n#endif \n#endif \n  }\n  return (*(tb->bufptr)++);\n}", "target": 0}
{"code": "  const hbc::DebugOffsets *getDebugOffsets(uint32_t) const override {\n    llvm_unreachable(\"Accessing debug offsets from a lazy module\");\n  }", "target": 1}
{"code": "privsep_preauth(Authctxt *authctxt)\n{\n\tint status, r;\n\tpid_t pid;\n\tstruct ssh_sandbox *box = NULL;\n\tpmonitor = monitor_init();\n\tpmonitor->m_pkex = &active_state->kex;\n\tif (use_privsep == PRIVSEP_ON)\n\t\tbox = ssh_sandbox_init();\n\tpid = fork();\n\tif (pid == -1) {\n\t\tfatal(\"fork of unprivileged child failed\");\n\t} else if (pid != 0) {\n\t\tdebug2(\"Network child is on pid %ld\", (long)pid);\n\t\tpmonitor->m_pid = pid;\n\t\tif (have_agent) {\n\t\t\tr = ssh_get_authentication_socket(&auth_sock);\n\t\t\tif (r != 0) {\n\t\t\t\terror(\"Could not get agent socket: %s\",\n\t\t\t\t    ssh_err(r));\n\t\t\t\thave_agent = 0;\n\t\t\t}\n\t\t}\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_preauth(box, pid);\n\t\tmonitor_child_preauth(authctxt, pmonitor);\n\t\tmonitor_sync(pmonitor);\n\t\twhile (waitpid(pid, &status, 0) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tpmonitor->m_pid = -1;\n\t\t\tfatal(\"%s: waitpid: %s\", __func__, strerror(errno));\n\t\t}\n\t\tprivsep_is_preauth = 0;\n\t\tpmonitor->m_pid = -1;\n\t\tif (WIFEXITED(status)) {\n\t\t\tif (WEXITSTATUS(status) != 0)\n\t\t\t\tfatal(\"%s: preauth child exited with status %d\",\n\t\t\t\t    __func__, WEXITSTATUS(status));\n\t\t} else if (WIFSIGNALED(status))\n\t\t\tfatal(\"%s: preauth child terminated by signal %d\",\n\t\t\t    __func__, WTERMSIG(status));\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_parent_finish(box);\n\t\treturn 1;\n\t} else {\n\t\tclose(pmonitor->m_sendfd);\n\t\tclose(pmonitor->m_log_recvfd);\n\t\tset_log_handler(mm_log_handler, pmonitor);\n\t\tprivsep_preauth_child();\n\t\tsetproctitle(\"%s\", \"[net]\");\n\t\tif (box != NULL)\n\t\t\tssh_sandbox_child(box);\n\t\treturn 0;\n\t}\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 curpos, offset = 0;\n\tRBinJavaLineNumberAttribute *lnattr;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;\n\tattr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.line_number_table_attr.line_number_table = r_list_newf (free);\n\tut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;\n\tRList *linenum_list = attr->info.line_number_table_attr.line_number_table;\n\tif (linenum_len > sz) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < linenum_len; i++) {\n\t\tcurpos = buf_offset + offset;\n\t\tlnattr = R_NEW0 (RBinJavaLineNumberAttribute);\n\t\tif (!lnattr) {\n\t\t\tbreak;\n\t\t}\n\t\tlnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tlnattr->file_offset = curpos;\n\t\tlnattr->size = 4;\n\t\tr_list_append (linenum_list, lnattr);\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}", "target": 1}
{"code": "void color_cmyk_to_rgb(opj_image_t *image)\n{\n\tfloat C, M, Y, K;\n\tfloat sC, sM, sY, sK;\n\tunsigned int w, h, max, i;\n\tw = image->comps[0].w;\n\th = image->comps[0].h;\n\tif(image->numcomps < 4) return;\n\tmax = w * h;\n\tsC = 1.0F / (float)((1 << image->comps[0].prec) - 1);\n\tsM = 1.0F / (float)((1 << image->comps[1].prec) - 1);\n\tsY = 1.0F / (float)((1 << image->comps[2].prec) - 1);\n\tsK = 1.0F / (float)((1 << image->comps[3].prec) - 1);\n\tfor(i = 0; i < max; ++i)\n\t{\n\t\tC = (float)(image->comps[0].data[i]) * sC;\n\t\tM = (float)(image->comps[1].data[i]) * sM;\n\t\tY = (float)(image->comps[2].data[i]) * sY;\n\t\tK = (float)(image->comps[3].data[i]) * sK;\n\t\tC = 1.0F - C;\n\t\tM = 1.0F - M;\n\t\tY = 1.0F - Y;\n\t\tK = 1.0F - K;\n\t\timage->comps[0].data[i] = (int)(255.0F * C * K); \n\t\timage->comps[1].data[i] = (int)(255.0F * M * K); \n\t\timage->comps[2].data[i] = (int)(255.0F * Y * K); \n\t}\n\tfree(image->comps[3].data); image->comps[3].data = NULL;\n\timage->comps[0].prec = 8;\n\timage->comps[1].prec = 8;\n\timage->comps[2].prec = 8;\n\timage->numcomps -= 1;\n\timage->color_space = OPJ_CLRSPC_SRGB;\n\tfor (i = 3; i < image->numcomps; ++i) {\n\t\tmemcpy(&(image->comps[i]), &(image->comps[i+1]), sizeof(image->comps[i]));\n\t}\n}", "target": 1}
{"code": "static __u8 *mr_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 30 && rdesc[29] == 0x05 && rdesc[30] == 0x09) {\n\t\thid_info(hdev, \"fixing up button/consumer in HID report descriptor\\n\");\n\t\trdesc[30] = 0x0c;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "integerify(void * B, size_t r)\n{\n  uint32_t * X = (uint32_t *)((uintptr_t)(B) + (2 * r - 1) * 64);\n  return (((uint64_t)(X[13]) << 32) + X[0]);\n}", "target": 1}
{"code": "get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)\n{\n    static gprincs_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gprincs_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->exp;\n    if (prime_arg == NULL)\n        prime_arg = \"*\";\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_LIST,\n                                                       NULL,\n                                                       NULL)) {\n        ret.code = KADM5_AUTH_LIST;\n        log_unauth(\"kadm5_get_principals\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code  = kadm5_get_principals((void *)handle,\n                                         arg->exp, &ret.princs,\n                                         &ret.count);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_principals\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "DEFINE_TEST(test_write_disk_fixup)\n{\n\tstruct archive *ad;\n\tstruct archive_entry *ae;\n\tint r;\n\tif (!canSymlink()) {\n\t\tskipping(\"Symlinks not supported\");\n\t\treturn;\n\t}\n\tassert((ad = archive_write_disk_new()) != NULL);\n\tassertMakeFile(\"victim\", 0600, \"a\");\n        assert((ae = archive_entry_new()) != NULL);\n        archive_entry_copy_pathname(ae, \"dir\");\n        archive_entry_set_mode(ae, AE_IFDIR | 0606);\n\tassertEqualIntA(ad, 0, archive_write_header(ad, ae));\n\tassertEqualIntA(ad, 0, archive_write_finish_entry(ad));\n        archive_entry_free(ae);\n\tassert((ae = archive_entry_new()) != NULL);\n\tarchive_entry_copy_pathname(ae, \"dir\");\n\tarchive_entry_set_mode(ae, AE_IFLNK | 0777);\n\tarchive_entry_set_size(ae, 0);\n\tarchive_entry_copy_symlink(ae, \"victim\");\n\tassertEqualIntA(ad, 0, r = archive_write_header(ad, ae));\n\tif (r >= ARCHIVE_WARN)\n\t\tassertEqualIntA(ad, 0, archive_write_finish_entry(ad));\n\tarchive_entry_free(ae);\n\tassertEqualInt(ARCHIVE_OK, archive_write_free(ad));\n\tassertIsSymlink(\"dir\", \"victim\", 0);\n\tassertFileMode(\"victim\", 0600);\n}", "target": 0}
{"code": "mptctl_readtest (unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_readtest() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;\n#else\n\tkarg.chip_type = ioc->pcidev->device;\n#endif\n\tstrncpy (karg.name, ioc->name, MPT_MAX_NAME);\n\tkarg.name[MPT_MAX_NAME-1]='\\0';\n\tstrncpy (karg.product, ioc->prod_name, MPT_PRODUCT_LENGTH);\n\tkarg.product[MPT_PRODUCT_LENGTH-1]='\\0';\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to write out mpt_ioctl_test struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct resource_pool *dce100_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc  *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "Variant HHVM_FUNCTION(imageaffinematrixget,\n                      int64_t type,\n                      const Variant& options ) {\n  Array ret = Array::Create();\n  double affine[6];\n  int res = GD_FALSE, i;\n  switch((gdAffineStandardMatrix)type) {\n    case GD_AFFINE_TRANSLATE:\n    case GD_AFFINE_SCALE: {\n      double x, y;\n      Array aoptions = options.toArray();\n      if (aoptions.empty()) {\n        raise_warning(\"imageaffinematrixget(): Array expected as options\");\n        return false;\n      }\n      if (aoptions.exists(s_x)) {\n        x = aoptions[s_x].toDouble();\n      } else {\n        raise_warning(\"imageaffinematrixget(): Missing x position\");\n        return false;\n      }\n      if (aoptions.exists(s_y)) {\n        y = aoptions[s_y].toDouble();\n      } else {\n        raise_warning(\"imageaffinematrixget(): Missing x position\");\n        return false;\n      }\n      if (type == GD_AFFINE_TRANSLATE) {\n        res = gdAffineTranslate(affine, x, y);\n      } else {\n        res = gdAffineScale(affine, x, y);\n      }\n      break;\n    }\n    case GD_AFFINE_ROTATE:\n    case GD_AFFINE_SHEAR_HORIZONTAL:\n    case GD_AFFINE_SHEAR_VERTICAL: {\n      double angle;\n      double doptions = options.toDouble();\n      if (!doptions) {\n        raise_warning(\"imageaffinematrixget(): Number is expected as option\");\n        return false;\n      }\n      angle = doptions;\n      if (type == GD_AFFINE_SHEAR_HORIZONTAL) {\n        res = gdAffineShearHorizontal(affine, angle);\n      } else if (type == GD_AFFINE_SHEAR_VERTICAL) {\n        res = gdAffineShearVertical(affine, angle);\n      } else {\n        res = gdAffineRotate(affine, angle);\n      }\n      break;\n    }\n    default:\n      raise_warning(\"imageaffinematrixget():Invalid type for \"\n                    \"element %\" PRId64, type);\n      return false;\n  }\n  if (res == GD_FALSE) {\n    return false;\n  } else {\n    for (i = 0; i < 6; i++) {\n      ret.set(String(i, CopyString), affine[i]);\n    }\n  }\n  return ret;\n}", "target": 0}
{"code": "TightDecoder::FilterGradient24(const rdr::U8 *inbuf,\n                               const PixelFormat& pf, PIXEL_T* outbuf,\n                               int stride, const Rect& r)\n{\n  int x, y, c;\n  rdr::U8 prevRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 thisRow[TIGHT_MAX_WIDTH*3];\n  rdr::U8 pix[3]; \n  int est[3]; \n  memset(prevRow, 0, sizeof(prevRow));\n  int rectHeight = r.height();\n  int rectWidth = r.width();\n  for (y = 0; y < rectHeight; y++) {\n    for (c = 0; c < 3; c++) {\n      pix[c] = inbuf[y*rectWidth*3+c] + prevRow[c];\n      thisRow[c] = pix[c];\n    }\n    pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride], pix, 1);\n    for (x = 1; x < rectWidth; x++) {\n      for (c = 0; c < 3; c++) {\n        est[c] = prevRow[x*3+c] + pix[c] - prevRow[(x-1)*3+c];\n        if (est[c] > 0xff) {\n          est[c] = 0xff;\n        } else if (est[c] < 0) {\n          est[c] = 0;\n        }\n        pix[c] = inbuf[(y*rectWidth+x)*3+c] + est[c];\n        thisRow[x*3+c] = pix[c];\n      }\n      pf.bufferFromRGB((rdr::U8*)&outbuf[y*stride+x], pix, 1);\n    }\n    memcpy(prevRow, thisRow, sizeof(prevRow));\n  }\n}", "target": 1}
{"code": "__attribute__((__always_inline__)) static inline void create_v4_hdr(\n    struct iphdr* iph,\n    __u8 tos,\n    __u32 saddr,\n    __u32 daddr,\n    __u16 pkt_bytes,\n    __u8 proto) {\n  __u64 csum = 0;\n  iph->version = 4;\n  iph->ihl = 5;\n  iph->frag_off = 0;\n  iph->protocol = proto;\n  iph->check = 0;\n#ifdef COPY_INNER_PACKET_TOS\n  iph->tos = tos;\n#else\n  iph->tos = DEFAULT_TOS;\n#endif\n  iph->tot_len = bpf_htons(pkt_bytes + sizeof(struct iphdr));\n  iph->id = 0;\n  iph->daddr = daddr;\n  iph->saddr = saddr;\n  iph->ttl = DEFAULT_TTL;\n  ipv4_csum_inline(iph, &csum);\n  iph->check = csum;\n}", "target": 0}
{"code": "static int sgi_clock_get(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tnsec = rtc_time() * sgi_clock_period\n\t\t\t+ sgi_clock_offset.tv_nsec;\n\ttp->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tp->tv_nsec)\n\t\t\t+ sgi_clock_offset.tv_sec;\n\treturn 0;\n};", "target": 1}
{"code": "inline bool RARPPM_CONTEXT::decodeSymbol2(ModelPPM *Model)\n{\n  int count, HiCnt, i=NumStats-Model->NumMasked;\n  RARPPM_SEE2_CONTEXT* psee2c=makeEscFreq2(Model,i);\n  RARPPM_STATE* ps[256], ** pps=ps, * p=U.Stats-1;\n  HiCnt=0;\n  do \n  {\n    do \n    { \n      p++; \n    } while (Model->CharMask[p->Symbol] == Model->EscCount);\n    HiCnt += p->Freq;\n    if (pps>=ps+ASIZE(ps))\n      return false;\n    *pps++ = p;\n  } while ( --i );\n  Model->Coder.SubRange.scale += HiCnt;\n  count=Model->Coder.GetCurrentCount();\n  if (count>=(int)Model->Coder.SubRange.scale)\n    return(false);\n  p=*(pps=ps);\n  if (count < HiCnt) \n  {\n    HiCnt=0;\n    while ((HiCnt += p->Freq) <= count) \n    {\n      pps++;\n      if (pps>=ps+ASIZE(ps)) \n        return false;\n      p=*pps;\n    }\n    Model->Coder.SubRange.LowCount = (Model->Coder.SubRange.HighCount=HiCnt)-p->Freq;\n    psee2c->update();\n    update2(Model,p);\n  }\n  else\n  {\n    Model->Coder.SubRange.LowCount=HiCnt;\n    Model->Coder.SubRange.HighCount=Model->Coder.SubRange.scale;\n    i=NumStats-Model->NumMasked;\n    pps--;\n    do \n    { \n      pps++;\n      if (pps>=ps+ASIZE(ps)) \n        return false;\n      Model->CharMask[(*pps)->Symbol]=Model->EscCount; \n    } while ( --i );\n    psee2c->Summ += Model->Coder.SubRange.scale;\n    Model->NumMasked = NumStats;\n  }\n  return true;\n}", "target": 1}
{"code": "int LibRaw::parseLeicaLensName(unsigned len)\n{\n#define plln ilm.Lens\n  if (!len)\n  {\n    strcpy(plln, \"N/A\");\n    return 0;\n  }\n  stmread(plln, len, ifp);\n  if ((plln[0] == ' ') || !strncasecmp(plln, \"not \", 4) ||\n      !strncmp(plln, \"---\", 3) || !strncmp(plln, \"***\", 3))\n  {\n    strcpy(plln, \"N/A\");\n    return 0;\n  }\n  else\n    return 1;\n#undef plln\n}", "target": 0}
{"code": "  void writeErr(size_t, const AsyncSocketException& ex) noexcept override {\n    LOG(ERROR) << \"write error: \" << ex.what();\n    EXPECT_NE(\n        ex.getType(),\n        AsyncSocketException::AsyncSocketExceptionType::SSL_ERROR);\n  }", "target": 0}
{"code": "static void credential_write_item(FILE *fp, const char *key, const char *value)\n{\n\tif (!value)\n\t\treturn;\n\tif (strchr(value, '\\n'))\n\t\tdie(\"credential value for %s contains newline\", key);\n\tfprintf(fp, \"%s=%s\\n\", key, value);\n}", "target": 0}
{"code": "GF_Err schm_box_size(GF_Box *s)\n{\n\tGF_SchemeTypeBox *ptr = (GF_SchemeTypeBox *) s;\n\tif (!s) return GF_BAD_PARAM;\n\tptr->size += 8;\n\tif (ptr->flags & 0x000001) ptr->size += 1 + (ptr->URI ? strlen(ptr->URI) : 0);\n\treturn GF_OK;\n}", "target": 0}
{"code": "static RList *r_bin_wasm_get_element_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmElementEntry *ptr = NULL;\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmElementEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->num_elem, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tut32 j = 0;\n\t\twhile (i < len && j < ptr->num_elem\t) {\n\t\t\tut32 e;\n\t\t\tif (!(consume_u32 (buf + i, buf + len, &e, &i))) {\n\t\t\t\tfree (ptr);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tr_list_append (ret, ptr);\n\t\tr += 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "int user_match(const struct key *key, const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}", "target": 1}
{"code": "void smp_enc_cmpl(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {\n uint8_t enc_enable = p_data->status;\n  SMP_TRACE_DEBUG(\"%s\", __func__);\n  tSMP_INT_DATA smp_int_data;\n  smp_int_data.status = enc_enable ? SMP_SUCCESS : SMP_ENC_FAIL;\n  smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &smp_int_data);\n}", "target": 0}
{"code": "is_apple_double (const char *name)\n{\n\tchar *basename;\n\tgboolean ret = FALSE;\n\tbasename = g_path_get_basename (name);\n\tif (basename == NULL) {\n\t\tg_debug (\"Filename '%s' doesn't have a basename?\", name);\n\t\treturn ret;\n\t}\n\tret = g_str_has_prefix (basename, APPLE_DOUBLE_PREFIX);\n\tg_free (basename);\n\treturn ret;\n}", "target": 0}
{"code": "    GopherStateData(FwdState *aFwd) :\n        entry(aFwd->entry),\n        conversion(NORMAL),\n        HTML_header_added(0),\n        HTML_pre(0),\n        type_id(GOPHER_FILE ),\n        overflowed(false),\n        cso_recno(0),\n        len(0),\n        buf(nullptr),\n        fwd(aFwd)\n    {\n        *request = 0;\n        buf = (char *)memAllocate(MEM_4K_BUF);\n        entry->lock(\"gopherState\");\n        *replybuf = 0;\n    }", "target": 1}
{"code": "on_response(void *data, krb5_error_code retval, otp_response response)\n{\n    struct request_state rs = *(struct request_state *)data;\n    free(data);\n    if (retval == 0 && response != otp_response_success)\n        retval = KRB5_PREAUTH_FAILED;\n    if (retval == 0)\n        rs.enc_tkt_reply->flags |= TKT_FLG_PRE_AUTH;\n    rs.respond(rs.arg, retval, NULL, NULL, NULL);\n}", "target": 0}
{"code": "int rpc_type_of_NPPVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPPVpluginNameString:\n  case NPPVpluginDescriptionString:\n  case NPPVformValue: \n  case NPPVpluginNativeAccessibleAtkPlugId:\n\ttype = RPC_TYPE_STRING;\n\tbreak;\n  case NPPVpluginWindowSize:\n  case NPPVpluginTimerInterval:\n\ttype = RPC_TYPE_INT32;\n\tbreak;\n  case NPPVpluginNeedsXEmbed:\n  case NPPVpluginWindowBool:\n  case NPPVpluginTransparentBool:\n  case NPPVjavascriptPushCallerBool:\n  case NPPVpluginKeepLibraryInMemory:\n  case NPPVpluginUrlRequestsDisplayedBool:\n  case NPPVpluginWantsAllNetworkStreams:\n  case NPPVpluginCancelSrcStream:\n  case NPPVSupportsAdvancedKeyHandling:\n\ttype = RPC_TYPE_BOOLEAN;\n\tbreak;\n  case NPPVpluginScriptableNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}", "target": 0}
{"code": "void InputMethodBase::OnFocus() {\n  DCHECK(!system_toplevel_window_focused_);\n  system_toplevel_window_focused_ = true;\n}", "target": 0}
{"code": "decode_bytestring(CBORDecoderObject *self, uint8_t subtype)\n{\n    uint64_t length = 0;\n    bool indefinite = true;\n    PyObject *ret;\n    char length_hex[17];\n    if (decode_length(self, subtype, &length, &indefinite) == -1)\n        return NULL;\n    if (length > (uint64_t)PY_SSIZE_T_MAX - (uint64_t)PyBytesObject_SIZE) {\n        sprintf(length_hex, \"%llX\", length);\n        PyErr_Format(\n                _CBOR2_CBORDecodeValueError,\n                \"excessive bytestring size 0x%s\", length_hex);\n        return NULL;\n    }\n    if (indefinite)\n        ret = decode_indefinite_bytestrings(self);\n    else\n        ret = decode_definite_bytestring(self, (Py_ssize_t)length);\n    set_shareable(self, ret);\n    return ret;\n}", "target": 1}
{"code": "bool ValidateInput(const Tensor& updates) {\n  const auto updates_flat = updates.flat<T>();\n  const T zero(0);\n  for (int i = 0; i < updates.NumElements(); i++) {\n    if (updates_flat(i) == zero) return false;\n  }\n  return true;\n}", "target": 0}
{"code": "sanitize_speculative_path(struct bpf_verifier_env *env,\n\t\t\t  const struct bpf_insn *insn,\n\t\t\t  u32 next_idx, u32 curr_idx)\n{\n\tstruct bpf_verifier_state *branch;\n\tstruct bpf_reg_state *regs;\n\tbranch = push_stack(env, next_idx, curr_idx, true);\n\tif (branch && insn) {\n\t\tregs = branch->frame[branch->curframe]->regs;\n\t\tif (BPF_SRC(insn->code) == BPF_K) {\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t} else if (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tmark_reg_unknown(env, regs, insn->src_reg);\n\t\t}\n\t}\n\treturn branch;\n}", "target": 0}
{"code": "  void setInVmContextCreatedForTesting() { in_vm_context_created_ = true; }", "target": 0}
{"code": "int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *c2, void *arg2, int jobnr, int threadnr), void *arg, int *ret, int count)\n{\n    int i;\n    for (i = 0; i < count; i++) {\n        int r = func(c, arg, i, 0);\n        if (ret)\n            ret[i] = r;\n    }\n    return 0;\n}", "target": 0}
{"code": "mysql_list_processes(MYSQL *mysql)\n{\n  MYSQL_DATA *fields;\n  uint field_count;\n  uchar *pos;\n  DBUG_ENTER(\"mysql_list_processes\");\n  LINT_INIT(fields);\n  if (simple_command(mysql,COM_PROCESS_INFO,0,0,0))\n    DBUG_RETURN(0);\n  free_old_query(mysql);\n  pos=(uchar*) mysql->net.read_pos;\n  field_count=(uint) net_field_length(&pos);\n  if (!(fields = (*mysql->methods->read_rows)(mysql,(MYSQL_FIELD*) 0,\n\t\t\t\t\t      protocol_41(mysql) ? 7 : 5)))\n    DBUG_RETURN(NULL);\n  if (!(mysql->fields=unpack_fields(mysql, fields,&mysql->field_alloc,field_count,0,\n\t\t\t\t    mysql->server_capabilities)))\n    DBUG_RETURN(0);\n  mysql->status=MYSQL_STATUS_GET_RESULT;\n  mysql->field_count=field_count;\n  DBUG_RETURN(mysql_store_result(mysql));\n}", "target": 0}
{"code": "void dhcps_deinit(void)\n{\n\tif (dhcps_pcb != NULL) {\n\t\tudp_remove(dhcps_pcb);\n\t\tdhcps_pcb = NULL;\t\n\t}\n\tif (dhcps_ip_table_semaphore != NULL) {\t\n\t\tvSemaphoreDelete(dhcps_ip_table_semaphore);\n\t\tdhcps_ip_table_semaphore = NULL;\n\t}\t\t\n}", "target": 1}
{"code": "int main(int argc, char *argv[]) {\n  try {\n    for (int i = 1; i < argc; i++) {\n      string arg = argv[i];\n      if (arg == \"--extract\" && i < argc - 1) {\n        TarFileReader reader(argv[++i]);\n        while (reader.hasMore())\n          cout << reader.extract() << endl;\n      } else THROWS(\"Invalid arg '\" << arg << \"'\");\n    }\n    return 0;\n  } catch (const Exception &e) {cerr << e.getMessage();}\n  return 1;\n}", "target": 0}
{"code": "NO_INLINE JsVar *jspeFactorDelete() {\n  JSP_ASSERT_MATCH(LEX_R_DELETE);\n  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n      if (jsvHasChildren(parent)) {\n        if (jsvIsArray(parent)) {\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }\n    }\n    result = jsvNewFromBool(ok);\n  }\n  jsvUnLock2(a, parent);\n  return result;\n}", "target": 1}
{"code": "static int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tstruct inode *inode = nd->inode;\n\tif (!nd->root.mnt)\n\t\tset_root_rcu(nd);\n\twhile (1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\t\t\tinode = parent->d_inode;\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tnd->path.dentry = parent;\n\t\t\tnd->seq = seq;\n\t\t\tif (unlikely(!path_connected(&nd->path)))\n\t\t\t\treturn -ENOENT;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n\t\t\tstruct mount *mparent = mnt->mnt_parent;\n\t\t\tstruct dentry *mountpoint = mnt->mnt_mountpoint;\n\t\t\tstruct inode *inode2 = mountpoint->d_inode;\n\t\t\tunsigned seq = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tif (&mparent->mnt == nd->path.mnt)\n\t\t\t\tbreak;\n\t\t\tnd->path.dentry = mountpoint;\n\t\t\tnd->path.mnt = &mparent->mnt;\n\t\t\tinode = inode2;\n\t\t\tnd->seq = seq;\n\t\t}\n\t}\n\twhile (unlikely(d_mountpoint(nd->path.dentry))) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\treturn -ECHILD;\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tinode = nd->path.dentry->d_inode;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\tnd->inode = inode;\n\treturn 0;\n}", "target": 0}
{"code": "  double sessionTimeout() const { return _sessionTimeout; }", "target": 0}
{"code": "static inline struct page *try_get_compound_head(struct page *page, int refs)\n{\n\tstruct page *head = compound_head(page);\n\tif (WARN_ON_ONCE(page_ref_count(head) < 0))\n\t\treturn NULL;\n\tif (unlikely(!page_cache_add_speculative(head, refs)))\n\t\treturn NULL;\n\treturn head;\n}", "target": 0}
{"code": "static void free_kvm_area(void)\n{\n\tint cpu;\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}", "target": 0}
{"code": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\treturn data;\n}", "target": 1}
{"code": "  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    if (output.size() == 0) {\n      return;\n    }\n    GPUDevice d = ctx->template eigen_device<GPUDevice>();\n    GpuLaunchConfig config = GetGpuLaunchConfig(output.size(), d);\n    TF_CHECK_OK(GpuLaunchKernel(\n        SetToValue<T>, config.block_count, config.thread_per_block, 0,\n        d.stream(), output.size(), output.data(), InitialValueF()()));\n    if (data_size == 0 || segment_ids_shape.num_elements() == 0) {\n      return;\n    }\n    const Index input_outer_dim_size = segment_ids.dimension(0);\n    const Index input_inner_dim_size = data_size / input_outer_dim_size;\n    config = GetGpuLaunchConfig(data_size, d);\n    TF_CHECK_OK(\n        GpuLaunchKernel(UnsortedSegmentCustomKernel<T, Index, ReductionF>,\n                        config.block_count, config.thread_per_block, 0,\n                        d.stream(), input_outer_dim_size, input_inner_dim_size,\n                        num_segments, segment_ids.data(), data, output.data()));\n  }", "target": 1}
{"code": "static void set_ntacl_dacl(struct user_namespace *user_ns,\n\t\t\t   struct smb_acl *pndacl,\n\t\t\t   struct smb_acl *nt_dacl,\n\t\t\t   const struct smb_sid *pownersid,\n\t\t\t   const struct smb_sid *pgrpsid,\n\t\t\t   struct smb_fattr *fattr)\n{\n\tstruct smb_ace *ntace, *pndace;\n\tint nt_num_aces = le32_to_cpu(nt_dacl->num_aces), num_aces = 0;\n\tunsigned short size = 0;\n\tint i;\n\tpndace = (struct smb_ace *)((char *)pndacl + sizeof(struct smb_acl));\n\tif (nt_num_aces) {\n\t\tntace = (struct smb_ace *)((char *)nt_dacl + sizeof(struct smb_acl));\n\t\tfor (i = 0; i < nt_num_aces; i++) {\n\t\t\tmemcpy((char *)pndace + size, ntace, le16_to_cpu(ntace->size));\n\t\t\tsize += le16_to_cpu(ntace->size);\n\t\t\tntace = (struct smb_ace *)((char *)ntace + le16_to_cpu(ntace->size));\n\t\t\tnum_aces++;\n\t\t}\n\t}\n\tset_posix_acl_entries_dacl(user_ns, pndace, fattr,\n\t\t\t\t   &num_aces, &size, nt_num_aces);\n\tpndacl->num_aces = cpu_to_le32(num_aces);\n\tpndacl->size = cpu_to_le16(le16_to_cpu(pndacl->size) + size);\n}", "target": 1}
{"code": "static int cma_bind_loopback(struct rdma_id_private *id_priv)\n{\n\tstruct cma_device *cma_dev, *cur_dev;\n\tunion ib_gid gid;\n\tenum ib_port_state port_state;\n\tunsigned int p;\n\tu16 pkey;\n\tint ret;\n\tcma_dev = NULL;\n\tmutex_lock(&lock);\n\tlist_for_each_entry(cur_dev, &dev_list, list) {\n\t\tif (cma_family(id_priv) == AF_IB &&\n\t\t    !rdma_cap_ib_cm(cur_dev->device, 1))\n\t\t\tcontinue;\n\t\tif (!cma_dev)\n\t\t\tcma_dev = cur_dev;\n\t\trdma_for_each_port (cur_dev->device, p) {\n\t\t\tif (!ib_get_cached_port_state(cur_dev->device, p, &port_state) &&\n\t\t\t    port_state == IB_PORT_ACTIVE) {\n\t\t\t\tcma_dev = cur_dev;\n\t\t\t\tgoto port_found;\n\t\t\t}\n\t\t}\n\t}\n\tif (!cma_dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tp = 1;\nport_found:\n\tret = rdma_query_gid(cma_dev->device, p, 0, &gid);\n\tif (ret)\n\t\tgoto out;\n\tret = ib_get_cached_pkey(cma_dev->device, p, 0, &pkey);\n\tif (ret)\n\t\tgoto out;\n\tid_priv->id.route.addr.dev_addr.dev_type =\n\t\t(rdma_protocol_ib(cma_dev->device, p)) ?\n\t\tARPHRD_INFINIBAND : ARPHRD_ETHER;\n\trdma_addr_set_sgid(&id_priv->id.route.addr.dev_addr, &gid);\n\tib_addr_set_pkey(&id_priv->id.route.addr.dev_addr, pkey);\n\tid_priv->id.port_num = p;\n\tcma_attach_to_dev(id_priv, cma_dev);\n\trdma_restrack_add(&id_priv->res);\n\tcma_set_loopback(cma_src_addr(id_priv));\nout:\n\tmutex_unlock(&lock);\n\treturn ret;\n}", "target": 0}
{"code": "acc_ctx_hints(OM_uint32 *minor_status,\n\t      gss_ctx_id_t *ctx,\n\t      spnego_gss_cred_id_t spcred,\n\t      gss_buffer_t *mechListMIC,\n\t      OM_uint32 *negState,\n\t      send_token_flag *return_token)\n{\n\tOM_uint32 tmpmin, ret;\n\tgss_OID_set supported_mechSet;\n\tspnego_gss_ctx_id_t sc = NULL;\n\t*mechListMIC = GSS_C_NO_BUFFER;\n\tsupported_mechSet = GSS_C_NO_OID_SET;\n\t*return_token = NO_TOKEN_SEND;\n\t*negState = REJECT;\n\t*minor_status = 0;\n\tif (*ctx != GSS_C_NO_CONTEXT)\n\t    return GSS_S_DEFECTIVE_TOKEN;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = INIT_TOKEN_SEND;\n\tsc->firstpass = 1;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\tret = GSS_S_COMPLETE;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\tgss_release_oid_set(&tmpmin, &supported_mechSet);\n\treturn ret;\n}", "target": 1}
{"code": "static void fuse_delete_context_key(void)\n{\n    pthread_mutex_lock(&fuse_context_lock);\n    fuse_context_ref--;\n    if (!fuse_context_ref) {\n        free(pthread_getspecific(fuse_context_key));\n        pthread_key_delete(fuse_context_key);\n    }\n    pthread_mutex_unlock(&fuse_context_lock);\n}", "target": 0}
{"code": "DWORD OmniboxViewWin::EditDropTarget::OnDragOver(IDataObject* data_object,\n                                                 DWORD key_state,\n                                                 POINT cursor_position,\n                                                 DWORD effect) {\n  if (drag_has_url_)\n    return CopyOrLinkDropEffect(effect);\n  if (drag_has_string_) {\n    UpdateDropHighlightPosition(cursor_position);\n    if (edit_->drop_highlight_position() == -1 && edit_->in_drag())\n      return DROPEFFECT_NONE;\n    if (edit_->in_drag()) {\n      DCHECK((effect & DROPEFFECT_COPY) && (effect & DROPEFFECT_MOVE));\n      return (key_state & MK_CONTROL) ? DROPEFFECT_COPY : DROPEFFECT_MOVE;\n    }\n    return CopyOrLinkDropEffect(effect);\n  }\n  return DROPEFFECT_NONE;\n}", "target": 0}
{"code": "static Jsi_RC WebSocketVersionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    const char *verStr = NULL;\n    verStr = lws_get_library_version();\n    if (verStr) {\n        char buf[100], *cp;\n        snprintf(buf, sizeof(buf), \"%s\", verStr);\n        cp = Jsi_Strchr(buf, ' ');\n        if (cp) *cp = 0;\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(context, input_shape.dims() == 5,\n                errors::InvalidArgument(\"input tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, filter_shape.dims() == 5,\n        errors::InvalidArgument(\"filter_sizes tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dims() == 5,\n        errors::InvalidArgument(\"out_backprop tensor must have 5 dimensions\"));\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "void RenderWidgetHostImpl::SetView(RenderWidgetHostViewBase* view) {\n  if (view)\n    view_ = view->GetWeakPtr();\n  else\n    view_.reset();\n  if (view_ && renderer_initialized_) {\n    Send(new ViewMsg_SetSurfaceIdNamespace(routing_id_,\n                                           view_->GetSurfaceIdNamespace()));\n  }\n  synthetic_gesture_controller_.reset();\n}", "target": 0}
{"code": "  static bool TryParse(const char* inp, int length,\n                       TypedValue* buf, Variant& out,\n                       JSONContainerType container_type, bool is_tsimplejson) {\n    SimpleParser parser(inp, length, buf, container_type, is_tsimplejson);\n    bool ok = parser.parseValue();\n    parser.skipSpace();\n    if (!ok || parser.p != inp + length) {\n      tvDecRefRange(buf, parser.top);\n      return false;\n    }\n    out = Variant::attach(*--parser.top);\n    return true;\n  }", "target": 1}
{"code": "void handle_irq_for_port(evtchn_port_t port, struct evtchn_loop_ctrl *ctrl)\n{\n\tint irq;\n\tstruct irq_info *info;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq == -1)\n\t\treturn;\n\tif (!ctrl->defer_eoi && !(++ctrl->count & 0xff)) {\n\t\tktime_t kt = ktime_get();\n\t\tif (!ctrl->timeout) {\n\t\t\tkt = ktime_add_ms(kt,\n\t\t\t\t\t  jiffies_to_msecs(event_loop_timeout));\n\t\t\tctrl->timeout = kt;\n\t\t} else if (kt > ctrl->timeout) {\n\t\t\tctrl->defer_eoi = true;\n\t\t}\n\t}\n\tinfo = info_for_irq(irq);\n\tif (ctrl->defer_eoi) {\n\t\tinfo->eoi_cpu = smp_processor_id();\n\t\tinfo->irq_epoch = __this_cpu_read(irq_epoch);\n\t\tinfo->eoi_time = get_jiffies_64() + event_eoi_delay;\n\t}\n\tgeneric_handle_irq(irq);\n}", "target": 0}
{"code": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\tif (!asoc)\n\t\treturn -EINVAL;\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\t*sockp = sock;\n\treturn err;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayShiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Value *v;\n    Jsi_Obj *obj = _this->d.obj;\n    Jsi_ObjListifyArray(interp, obj);\n    uint n = Jsi_ObjGetLength(interp, obj);\n    assert(n <= obj->arrCnt);\n    if (n<=0) {\n        Jsi_ValueMakeUndef(interp, ret);\n    } else {\n        n--;\n        v = obj->arr[0];\n        memmove(obj->arr, obj->arr+1, n*sizeof(Jsi_Value*));\n        obj->arr[n] = NULL;\n        Jsi_ValueDup2(interp, ret, v);\n        Jsi_DecrRefCount(interp, v);\n        Jsi_ObjSetLength(interp, obj, n);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "__switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\tload_sp0(tss, next);\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\tload_TLS(next, cpu);\n\tarch_end_context_switch(next_p);\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\tswitch_fpu_finish(next_p, fpu);\n\tprev->usersp = this_cpu_read(old_rsp);\n\tthis_cpu_write(old_rsp, next->usersp);\n\tthis_cpu_write(current_task, next_p);\n\ttask_thread_info(prev_p)->saved_preempt_count = this_cpu_read(__preempt_count);\n\tthis_cpu_write(__preempt_count, task_thread_info(next_p)->saved_preempt_count);\n\tthis_cpu_write(kernel_stack,\n\t\t  (unsigned long)task_stack_page(next_p) +\n\t\t  THREAD_SIZE - KERNEL_STACK_OFFSET);\n\tif (unlikely(task_thread_info(next_p)->flags & _TIF_WORK_CTXSW_NEXT ||\n\t\t     task_thread_info(prev_p)->flags & _TIF_WORK_CTXSW_PREV))\n\t\t__switch_to_xtra(prev_p, next_p, tss);\n\treturn prev_p;\n}", "target": 1}
{"code": "GF_Box *stri_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubTrackInformationBox, GF_ISOM_BOX_TYPE_STRI);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static Jsi_RC SysVerConvertCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    Jsi_Value *flag = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!val) goto bail;\n    if (Jsi_ValueIsNumber(interp, val)) {\n        char buf[200];\n        Jsi_Number n;\n        if (Jsi_GetNumberFromValue(interp, val, &n) != JSI_OK)\n            goto bail;\n        jsi_VersionNormalize(n, buf, sizeof(buf));\n        int trunc = 0;\n        if (flag && (Jsi_GetIntFromValue(interp, flag, &trunc) != JSI_OK\n            || trunc<0 || trunc>2))\n            return Jsi_LogError(\"arg2: bad trunc: expected int between 0 and 2\");\n        if (trunc) {\n            int len = Jsi_Strlen(buf)-1;\n            while (trunc>0 && len>1) {\n                if (buf[len] == '0' && buf[len-1] == '.')\n                    buf[len-1] = 0;\n                len -= 2;\n                trunc--;\n            }\n        }\n        Jsi_ValueMakeStringDup(interp, ret, buf);\n        return JSI_OK;\n    }\n    if (Jsi_ValueIsString(interp, val)) {\n        Jsi_Number n;\n        if (jsi_GetVerFromVal(interp, val, &n, 0) == JSI_OK) {\n            Jsi_ValueMakeNumber(interp, ret, n);\n            return JSI_OK;\n        }\n    }\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return JSI_OK;\n}", "target": 1}
{"code": "string handleGet(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n  if (uri.compare(\"/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    body = getLogin();\n  } else if (uri.compare(\"/cal\") == 0 && uid != -1) {\n    cout << \"cal page\" << endl;\n    string username = userNameById(uid);\n    body = getHeader(username);\n    body += getEmptyCalendar();\n    body += getFooter();\n  } else if (uri.compare(\"/getEvents\") == 0 && uid != -1) {\n    body = getEventsJson(uid);\n    resHeaders[\"Content-Type\"] = \"application/json; charset=UTF-8\";\n  } else {\n    cout << \"error page\" << endl;\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}", "target": 1}
{"code": "static void sco_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\tBT_DBG(\"parent %p\", parent);\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tsco_sock_close(sk);\n\t\tsco_sock_kill(sk);\n\t}\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}", "target": 0}
{"code": "comics_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n\t\t\t\t\t   EvRenderContext      *rc,\n\t\t\t\t\t   gint                 *width,\n\t\t\t\t\t   gint                 *height)\n{\n\tgdouble page_width, page_height;\n\tcomics_document_get_page_size (EV_DOCUMENT (document), rc->page,\n\t\t\t\t       &page_width, &page_height);\n\tif (rc->rotation == 90 || rc->rotation == 270) {\n\t\t*width = (gint) (page_height * rc->scale);\n\t\t*height = (gint) (page_width * rc->scale);\n\t} else {\n\t\t*width = (gint) (page_width * rc->scale);\n\t\t*height = (gint) (page_height * rc->scale);\n\t}\n}", "target": 1}
{"code": "prologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "static int tcp_v6_send_synack(const struct sock *sk, struct dst_entry *dst,\n\t\t\t      struct flowi *fl,\n\t\t\t      struct request_sock *req,\n\t\t\t      struct tcp_fastopen_cookie *foc,\n\t\t\t      bool attach_req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct flowi6 *fl6 = &fl->u.ip6;\n\tstruct sk_buff *skb;\n\tint err = -ENOMEM;\n\tif (!dst && (dst = inet6_csk_route_req(sk, fl6, req,\n\t\t\t\t\t       IPPROTO_TCP)) == NULL)\n\t\tgoto done;\n\tskb = tcp_make_synack(sk, dst, req, foc, attach_req);\n\tif (skb) {\n\t\t__tcp_v6_send_check(skb, &ireq->ir_v6_loc_addr,\n\t\t\t\t    &ireq->ir_v6_rmt_addr);\n\t\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\t\tif (np->repflow && ireq->pktopts)\n\t\t\tfl6->flowlabel = ip6_flowlabel(ipv6_hdr(ireq->pktopts));\n\t\terr = ip6_xmit(sk, skb, fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\ndone:\n\treturn err;\n}", "target": 1}
{"code": "static bool rb_is_reader_page(struct buffer_page *page)\n{\n\tstruct list_head *list = page->list.prev;\n\treturn rb_list_head(list->next) != &page->list;\n}", "target": 0}
{"code": "static void __attribute__((destructor)) fio_lib_destroy(void) {\n  uint8_t add_eol = fio_is_master();\n  fio_data->active = 0;\n  fio_on_fork();\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_AT_EXIT);\n  fio_state_callback_clear_all();\n  fio_defer_perform();\n  fio_poll_close();\n  fio_timer_clear_all();\n  fio_free(fio_data);\n  fio_mem_destroy();\n  FIO_LOG_DEBUG(\"(%d) facil.io resources released, exit complete.\",\n                (int)getpid());\n  if (add_eol)\n    fprintf(stderr, \"\\n\"); \n}", "target": 1}
{"code": "void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)\n{\n\tunsigned long flags;\n\tunsigned long resolution = 0;\n\tstruct snd_timer_instance *ti, *ts;\n\tif (timer->card && timer->card->shutdown)\n\t\treturn;\n\tif (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n\t\treturn;\n\tif (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n\t\t       event > SNDRV_TIMER_EVENT_MRESUME))\n\t\treturn;\n\tspin_lock_irqsave(&timer->lock, flags);\n\tif (event == SNDRV_TIMER_EVENT_MSTART ||\n\t    event == SNDRV_TIMER_EVENT_MCONTINUE ||\n\t    event == SNDRV_TIMER_EVENT_MRESUME) {\n\t\tif (timer->hw.c_resolution)\n\t\t\tresolution = timer->hw.c_resolution(timer);\n\t\telse\n\t\t\tresolution = timer->hw.resolution;\n\t}\n\tlist_for_each_entry(ti, &timer->active_list_head, active_list) {\n\t\tif (ti->ccallback)\n\t\t\tti->ccallback(ti, event, tstamp, resolution);\n\t\tlist_for_each_entry(ts, &ti->slave_active_head, active_list)\n\t\t\tif (ts->ccallback)\n\t\t\t\tts->ccallback(ts, event, tstamp, resolution);\n\t}\n\tspin_unlock_irqrestore(&timer->lock, flags);\n}", "target": 0}
{"code": "void ContainerNode::cloneChildNodes(ContainerNode *clone)\n{\n    TrackExceptionState exceptionState;\n    for (Node* n = firstChild(); n && !exceptionState.hadException(); n = n->nextSibling())\n        clone->appendChild(n->cloneNode(true), exceptionState);\n}", "target": 0}
{"code": "void handle_get_plugin_schema_resp(nng_aio *aio, neu_resp_check_schema_t *resp)\n{\n    if (resp->exist) {\n        char * schema_path = NULL;\n        size_t len         = 0;\n        char * buf         = NULL;\n        if (0 > neu_asprintf(&schema_path, \"%s/schema/%s.json\", g_plugin_dir,\n                             resp->schema)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n        if (NULL == buf) {\n            free(schema_path);\n            if (0 > neu_asprintf(&schema_path, \"%s/custom/schema/%s.json\",\n                                 g_plugin_dir, resp->schema)) {\n                NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                    neu_http_response(aio, error_code.error, result_error);\n                });\n                return;\n            }\n            buf = file_string_read(&len, schema_path);\n        }\n        if (NULL == buf) {\n            free(schema_path);\n            if (0 > neu_asprintf(&schema_path, \"%s/system/schema/%s.json\",\n                                 g_plugin_dir, resp->schema)) {\n                NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                    neu_http_response(aio, error_code.error, result_error);\n                });\n                return;\n            }\n            buf = file_string_read(&len, schema_path);\n        }\n        if (NULL == buf) {\n            nlog_info(\"open %s error: %d\", schema_path, errno);\n            neu_http_not_found(aio, \"{\\\"status\\\": \\\"error\\\"}\");\n            free(schema_path);\n            return;\n        }\n        neu_http_ok(aio, buf);\n        free(buf);\n        free(schema_path);\n    } else {\n        NEU_JSON_RESPONSE_ERROR(NEU_ERR_PLUGIN_NOT_FOUND, {\n            neu_http_response(aio, error_code.error, result_error);\n        });\n    }\n}", "target": 0}
{"code": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\ttrap = lock_rename(new_dir, old_dir);\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}", "target": 1}
{"code": "  UsageAndQuotaDispatcherTask(\n      QuotaManager* manager,\n      const std::string& host,\n      StorageType type)\n      : QuotaTask(manager),\n        host_(host),\n        type_(type),\n        quota_(-1),\n        global_usage_(-1),\n        global_unlimited_usage_(-1),\n        host_usage_(-1),\n        quota_status_(kQuotaStatusUnknown),\n        waiting_callbacks_(1),\n        callback_factory_(ALLOW_THIS_IN_INITIALIZER_LIST(this)) {}", "target": 0}
{"code": "static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)\n{\n\tstruct snd_msnd *chip = dev_id;\n\tvoid *pwDSPQData = chip->mappedbase + DSPQ_DATA_BUFF;\n\twhile (readw(chip->DSPQ + JQS_wTail) != readw(chip->DSPQ + JQS_wHead)) {\n\t\tu16 wTmp;\n\t\tsnd_msnd_eval_dsp_msg(chip,\n\t\t\treadw(pwDSPQData + 2 * readw(chip->DSPQ + JQS_wHead)));\n\t\twTmp = readw(chip->DSPQ + JQS_wHead) + 1;\n\t\tif (wTmp > readw(chip->DSPQ + JQS_wSize))\n\t\t\twritew(0, chip->DSPQ + JQS_wHead);\n\t\telse\n\t\t\twritew(wTmp, chip->DSPQ + JQS_wHead);\n\t}\n\tinb(chip->io + HP_RXL);\n\treturn IRQ_HANDLED;\n}", "target": 1}
{"code": "pixBlockconvGrayUnnormalized(PIX     *pixs,\n                             l_int32  wc,\n                             l_int32  hc)\n{\nl_int32    i, j, w, h, d, wpla, wpld, jmax;\nl_uint32  *linemina, *linemaxa, *lined, *dataa, *datad;\nPIX       *pixsb, *pixacc, *pixd;\n    PROCNAME(\"pixBlockconvGrayUnnormalized\");\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        wc = L_MIN(wc, (w - 1) / 2);\n        hc = L_MIN(hc, (h - 1) / 2);\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pixs);\n    if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL)\n        return (PIX *)ERROR_PTR(\"pixsb not made\", procName, NULL);\n    pixacc = pixBlockconvAccum(pixsb);\n    pixDestroy(&pixsb);\n    if (!pixacc)\n        return (PIX *)ERROR_PTR(\"pixacc not made\", procName, NULL);\n    if ((pixd = pixCreate(w, h, 32)) == NULL) {\n        pixDestroy(&pixacc);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    wpla = pixGetWpl(pixacc);\n    wpld = pixGetWpl(pixd);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixacc);\n    for (i = 0; i < h; i++) {\n        lined = datad + i * wpld;\n        linemina = dataa + i * wpla;\n        linemaxa = dataa + (i + 2 * hc + 1) * wpla;\n        for (j = 0; j < w; j++) {\n            jmax = j + 2 * wc + 1;\n            lined[j] = linemaxa[jmax] - linemaxa[j] -\n                       linemina[jmax] + linemina[j];\n        }\n    }\n    pixDestroy(&pixacc);\n    return pixd;\n}", "target": 1}
{"code": "int main(void)\n{\n\tint fd;\n\tunsigned int i;\n\tunsigned int start = 0;\n\tunsigned int _gap = ~0;\n\tunsigned int gap = _gap / 8;\n\tstruct qcedev_cipher_op_req req = { 0 };\n\tchar *data;\n\tfd = open(dev, O_RDWR);\n\tif (fd < 0) {\n\t\tprintf(\"Failed to open %s with errno %s\\n\", dev,\n\t\t       strerror(errno));\n\t\treturn EXIT_FAILURE;\n\t}\n\tthread_func(start, start + gap, fd);\n\tsleep(1000000);\n\treturn EXIT_FAILURE;\n}", "target": 0}
{"code": "static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\treturn usb_serial_generic_open(tty, port);\n}", "target": 1}
{"code": "void CharToWideMap(const char *Src,wchar *Dest,size_t DestSize,bool &Success)\n{\n  Success=false;\n  bool MarkAdded=false;\n  uint SrcPos=0,DestPos=0;\n  while (DestPos<DestSize)\n  {\n    if (Src[SrcPos]==0)\n    {\n      Success=true;\n      break;\n    }\n    mbstate_t ps;\n    memset(&ps,0,sizeof(ps));\n    if (mbrtowc(Dest+DestPos,Src+SrcPos,MB_CUR_MAX,&ps)==-1)\n    {\n      if (byte(Src[SrcPos])>=0x80)\n      {\n        if (!MarkAdded)\n        {\n          Dest[DestPos++]=MappedStringMark;\n          MarkAdded=true;\n          if (DestPos>=DestSize)\n            break;\n        }\n        Dest[DestPos++]=byte(Src[SrcPos++])+MapAreaStart;\n      }\n      else\n        break;\n    }\n    else\n    {\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Src+SrcPos,MB_CUR_MAX,&ps);\n      SrcPos+=Max(Length,1);\n      DestPos++;\n    }\n  }\n  Dest[Min(DestPos,DestSize-1)]=0;\n}", "target": 1}
{"code": "void PeerListWidget::updatePeer(const QString &ip, BitTorrent::TorrentHandle *const torrent, const BitTorrent::PeerInfo &peer)\n{\n    QStandardItem *item = m_peerItems.value(ip);\n    int row = item->row();\n    if (m_resolveCountries) {\n        const QIcon ico = GuiIconProvider::instance()->getFlagIcon(peer.country());\n        if (!ico.isNull()) {\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), ico, Qt::DecorationRole);\n            const QString countryName = Net::GeoIPManager::CountryName(peer.country());\n            m_listModel->setData(m_listModel->index(row, PeerListDelegate::COUNTRY), countryName, Qt::ToolTipRole);\n            m_missingFlags.remove(ip);\n        }\n    }\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CONNECTION), peer.connectionType());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PORT), peer.address().port);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flags());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::FLAGS), peer.flagsDescription(), Qt::ToolTipRole);\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::CLIENT), peer.client());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::PROGRESS), peer.progress());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWN_SPEED), peer.payloadDownSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::UP_SPEED), peer.payloadUpSpeed());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_DOWN), peer.totalDownload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::TOT_UP), peer.totalUpload());\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::RELEVANCE), peer.relevance());\n    QStringList downloadingFiles(torrent->info().filesForPiece(peer.downloadingPieceIndex()));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\";\")));\n    m_listModel->setData(m_listModel->index(row, PeerListDelegate::DOWNLOADING_PIECE), downloadingFiles.join(QLatin1String(\"\\n\")), Qt::ToolTipRole);\n}", "target": 1}
{"code": "static int x25_create(struct net *net, struct socket *sock, int protocol,\n\t\t      int kern)\n{\n\tstruct sock *sk;\n\tstruct x25_sock *x25;\n\tint rc = -EAFNOSUPPORT;\n\tif (!net_eq(net, &init_net))\n\t\tgoto out;\n\trc = -ESOCKTNOSUPPORT;\n\tif (sock->type != SOCK_SEQPACKET)\n\t\tgoto out;\n\trc = -EINVAL;\n\tif (protocol)\n\t\tgoto out;\n\trc = -ENOMEM;\n\tif ((sk = x25_alloc_socket(net, kern)) == NULL)\n\t\tgoto out;\n\tx25 = x25_sk(sk);\n\tsock_init_data(sock, sk);\n\tx25_init_timers(sk);\n\tsock->ops    = &x25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tsk->sk_backlog_rcv = x25_backlog_rcv;\n\tx25->t21   = sysctl_x25_call_request_timeout;\n\tx25->t22   = sysctl_x25_reset_request_timeout;\n\tx25->t23   = sysctl_x25_clear_request_timeout;\n\tx25->t2    = sysctl_x25_ack_holdback_timeout;\n\tx25->state = X25_STATE_0;\n\tx25->cudmatchlength = 0;\n\tset_bit(X25_ACCPT_APPRV_FLAG, &x25->flags);\t\n\tx25->facilities.winsize_in  = X25_DEFAULT_WINDOW_SIZE;\n\tx25->facilities.winsize_out = X25_DEFAULT_WINDOW_SIZE;\n\tx25->facilities.pacsize_in  = X25_DEFAULT_PACKET_SIZE;\n\tx25->facilities.pacsize_out = X25_DEFAULT_PACKET_SIZE;\n\tx25->facilities.throughput  = 0;\t\n\tx25->facilities.reverse     = X25_DEFAULT_REVERSE;\n\tx25->dte_facilities.calling_len = 0;\n\tx25->dte_facilities.called_len = 0;\n\tmemset(x25->dte_facilities.called_ae, '\\0',\n\t\t\tsizeof(x25->dte_facilities.called_ae));\n\tmemset(x25->dte_facilities.calling_ae, '\\0',\n\t\t\tsizeof(x25->dte_facilities.calling_ae));\n\trc = 0;\nout:\n\treturn rc;\n}", "target": 0}
{"code": "static void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->n);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->qp);\n\tcrypto_bignum_free(key->dp);\n\tcrypto_bignum_free(key->dq);\n}", "target": 1}
{"code": "static void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINORIGIN;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.user);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.id = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.version = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &ses->origin.addr);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}\n\t}\n\tif (!node) {\n\t\t*ch = 0;\n\t\treturn;\n\t}\n\t*ch = node->symbol;\n\t*offset = bloc;\n}", "target": 1}
{"code": "int main()\n{\n    gdImagePtr im1, im2;\n    FILE *fp;\n    int size;\n    fp = gdTestFileOpen2(\"webp\", \"bug_double_free.jpg\");\n    gdTestAssert(fp != NULL);\n    im1 = gdImageCreateFromJpeg(fp);\n    gdTestAssert(im1 != NULL);\n    fclose(fp);\n    im2 = gdImageWebpPtr(im1, &size);\n    gdTestAssert(im2 == NULL);\n    gdImageDestroy(im1);\n    return gdNumFailures();\n}", "target": 0}
{"code": "void Logger::addMessage(const QString &message, const Log::MsgType &type)\n{\n    QWriteLocker locker(&lock);\n    Log::Msg temp = { msgCounter++, QDateTime::currentMSecsSinceEpoch(), type, message };\n    m_messages.push_back(temp);\n    if (m_messages.size() >= MAX_LOG_MESSAGES)\n        m_messages.pop_front();\n    emit newLogMessage(temp);\n}", "target": 1}
{"code": "int _yr_re_is_word_char(\n    uint8_t* input,\n    int character_size)\n{\n  int result = ((isalnum(*input) || (*input) == '_'));\n  if (character_size == 2)\n    result = result && (*(input + 1) == 0);\n  return result;\n}", "target": 0}
{"code": "static int match_func(struct libmnt_fs *fs,\n\t\t      void *data __attribute__ ((__unused__)))\n{\n\tint rc = flags & FL_INVERT ? 1 : 0;\n\tconst char *m;\n\tvoid *md;\n\tm = get_match(COL_FSTYPE);\n\tif (m && !mnt_fs_match_fstype(fs, m))\n\t\treturn rc;\n\tm = get_match(COL_OPTIONS);\n\tif (m && !mnt_fs_match_options(fs, m))\n\t\treturn rc;\n\tmd = get_match_data(COL_MAJMIN);\n\tif (md && mnt_fs_get_devno(fs) != *((dev_t *) md))\n\t\treturn rc;\n\tm = get_match(COL_TARGET);\n\tif (m && !mnt_fs_match_target(fs, m, cache))\n\t\treturn rc;\n\tm = get_match(COL_SOURCE);\n\tif (m && !mnt_fs_match_source(fs, m, cache))\n\t\treturn rc;\n\tif ((flags & FL_DF) && !(flags & FL_ALL)) {\n\t\tconst char *type = mnt_fs_get_fstype(fs);\n\t\tif (type && strstr(type, \"tmpfs\"))\t\n\t\t\treturn !rc;\n\t\tif (mnt_fs_is_pseudofs(fs))\n\t\t\treturn rc;\n\t}\n\tif ((flags & FL_REAL) && mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\tif ((flags & FL_PSEUDO) && !mnt_fs_is_pseudofs(fs))\n\t    return rc;\n\tif ((flags & FL_SHADOWED)) {\n\t\tstruct libmnt_table *tb = NULL;\n\t\tmnt_fs_get_table(fs, &tb);\n\t\tif (tb && mnt_table_over_fs(tb, fs, NULL) != 0)\n\t\t\treturn rc;\n\t}\n\tif ((flags & FL_DELETED) && !mnt_fs_is_deleted(fs))\n\t\treturn rc;\n\treturn !rc;\n}", "target": 1}
{"code": "static void pptp_ctx_switch(struct triton_context_t *ctx, void *arg)\n{\n\tif (arg) {\n\t\tstruct ap_session *s = arg;\n\t\tnet = s->net;\n\t} else\n\t\tnet = def_net;\n\tlog_switch(ctx, arg);\n}", "target": 0}
{"code": "bool WindowsServiceControl::install( const QString& filePath, const QString& displayName  )\n{\n\tm_serviceHandle = CreateService(\n\t\t\t\tm_serviceManager,\t\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( m_name ),\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( displayName ),\n\t\t\t\tSERVICE_ALL_ACCESS,\t\n\t\t\t\tSERVICE_WIN32_OWN_PROCESS,\n\t\t\t\tSERVICE_AUTO_START,\t\n\t\t\t\tSERVICE_ERROR_NORMAL,\t\n\t\t\t\tWindowsCoreFunctions::toConstWCharArray( filePath ),\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tL\"Tcpip\\0RpcSs\\0\\0\",\t\t\n\t\t\t\tnullptr,\t\t\t\n\t\t\t\tnullptr );\t\t\t\n\tif( m_serviceHandle == nullptr )\n\t{\n\t\tconst auto error = GetLastError();\n\t\tif( error == ERROR_SERVICE_EXISTS )\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" is already installed.\" ).arg( m_name ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvCritical() << qUtf8Printable( tr( \"The service \\\"%1\\\" could not be installed.\" ).arg( m_name ) );\n\t\t}\n\t\treturn false;\n\t}\n\tSC_ACTION serviceActions;\n\tserviceActions.Delay = 10000;\n\tserviceActions.Type = SC_ACTION_RESTART;\n\tSERVICE_FAILURE_ACTIONS serviceFailureActions;\n\tserviceFailureActions.dwResetPeriod = 0;\n\tserviceFailureActions.lpRebootMsg = nullptr;\n\tserviceFailureActions.lpCommand = nullptr;\n\tserviceFailureActions.lpsaActions = &serviceActions;\n\tserviceFailureActions.cActions = 1;\n\tChangeServiceConfig2( m_serviceHandle, SERVICE_CONFIG_FAILURE_ACTIONS, &serviceFailureActions );\n\tvInfo() << qUtf8Printable( tr( \"The service \\\"%1\\\" has been installed successfully.\" ).arg( m_name ) );\n\treturn true;\n}", "target": 1}
{"code": "static int rmqueue_bulk(struct zone *zone, unsigned int order,\n\t\t\tunsigned long count, struct list_head *list,\n\t\t\tint migratetype)\n{\n\tint i, alloced = 0;\n\tspin_lock(&zone->lock);\n\tfor (i = 0; i < count; ++i) {\n\t\tstruct page *page = __rmqueue(zone, order, migratetype);\n\t\tif (unlikely(page == NULL))\n\t\t\tbreak;\n\t\tif (unlikely(check_pcp_refill(page)))\n\t\t\tcontinue;\n\t\tlist_add_tail(&page->lru, list);\n\t\talloced++;\n\t\tif (is_migrate_cma(get_pcppage_migratetype(page)))\n\t\t\t__mod_zone_page_state(zone, NR_FREE_CMA_PAGES,\n\t\t\t\t\t      -(1 << order));\n\t}\n\t__mod_zone_page_state(zone, NR_FREE_PAGES, -(i << order));\n\tspin_unlock(&zone->lock);\n\treturn alloced;\n}", "target": 0}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    OP_REQUIRES_OK_ASYNC(c,\n                         FillCollectiveParams(col_params, REDUCTION_COLLECTIVE,\n                                               c->input(1),\n                                               c->input(2),\n                                               c->input(3)),\n                         done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV2 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &headers() const override\n    {\n        return headers_;\n    }", "target": 1}
{"code": "int nfc_stop_poll(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->polling) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tdev->ops->stop_poll(dev);\n\tdev->polling = false;\n\tdev->rf_mode = NFC_RF_NONE;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n    return crc;\n}", "target": 1}
{"code": "static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n}", "target": 0}
{"code": "xps_parse_digits(char *s, int *digit)\n{\n    *digit = 0;\n    while (*s >= '0' && *s <= '9')\n    {\n        *digit = *digit * 10 + (*s - '0');\n        s ++;\n    }\n    return s;\n}", "target": 0}
{"code": "static inline bool siphash_key_is_zero(const siphash_key_t *key)\n{\n\treturn !(key->key[0] | key->key[1]);\n}", "target": 0}
{"code": "static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,\n\t\tsector_t capacity, int geom[])\n{\n\tint heads=-1;\n\tint sectors=-1;\n\tint cylinders=-1;\n\tif (capacity < 0x2000 ) {\t\n\t\theads = 18;\n\t\tsectors = 2;\n\t} \n\telse if (capacity < 0x20000) {\n\t\theads = 64;\n\t\tsectors = 32;\n\t}\n\telse if (capacity < 0x40000) {\n\t\theads = 65;\n\t\tsectors = 63;\n\t}\n\telse if (capacity < 0x80000) {\n\t\theads = 128;\n\t\tsectors = 63;\n\t}\n\telse {\n\t\theads = 255;\n\t\tsectors = 63;\n\t}\n\tcylinders = sector_div(capacity, heads * sectors);\n\tif(sdev->type == 5) {  \n\t\theads = 252;\n\t\tsectors = 63;\n\t\tcylinders = 1111;\n\t}\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\tPDEBUG(\"adpt_bios_param: exit\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "void test_truncate(const char *path)\n{\n\tif (truncate(path, 0) == 0) {\n\t\tfprintf(stderr, \"leak at truncate of %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)\n{\n\tstruct super_block *sb;\n\tint err;\n\tint rc;\n\tif (!ext4_handle_valid(handle)) {\n\t\text4_put_nojournal(handle);\n\t\treturn 0;\n\t}\n\tif (!handle->h_transaction) {\n\t\terr = jbd2_journal_stop(handle);\n\t\treturn handle->h_err ? handle->h_err : err;\n\t}\n\tsb = handle->h_transaction->t_journal->j_private;\n\terr = handle->h_err;\n\trc = jbd2_journal_stop(handle);\n\tif (!err)\n\t\terr = rc;\n\tif (err)\n\t\t__ext4_std_error(sb, where, line, err);\n\treturn err;\n}", "target": 1}
{"code": "static Array HHVM_METHOD(Memcache, getextendedstats,\n                         const String&  ,\n                         int  , int  ) {\n  auto data = Native::data<MemcacheData>(this_);\n  memcached_return_t ret;\n  memcached_stat_st *stats;\n  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n  int server_count = memcached_server_count(&data->m_memcache);\n  Array return_val;\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n    stat = stats + server_id;\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n  free(stats);\n  return return_val;\n}", "target": 1}
{"code": "escape(unsigned char ch, char *buf)\n{\n    const int len = ch < 0100 ? (ch < 010 ? 3 : 4) : 5;\n    switch (len) {\n    case 5:\n\tbuf[4] = (ch & 7) + '0';\n\tch >>= 3;\n\tFALLTHROUGH;\n    case 4:\n\tbuf[3] = (ch & 7) + '0';\n\tch >>= 3;\n\tFALLTHROUGH;\n    case 3:\n\tbuf[2] = (ch & 7) + '0';\n\tbuf[1] = '0';\n\tbuf[0] = '#';\n\tbreak;\n    }\n    buf[len] = '\\0';\n    return len;\n}", "target": 0}
{"code": "get_principal_2_svc(gprinc_arg *arg, struct svc_req *rqstp)\n{\n    static gprinc_ret               ret;\n    char                            *prime_arg, *funcname;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gprinc_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    funcname = \"kadm5_get_principal\";\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(funcname, prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_principal(handle, arg->princ, &ret.rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static int __init fm10k_init_module(void)\n{\n\tpr_info(\"%s - version %s\\n\", fm10k_driver_string, fm10k_driver_version);\n\tpr_info(\"%s\\n\", fm10k_copyright);\n\tfm10k_workqueue = alloc_workqueue(\"%s\", WQ_MEM_RECLAIM, 0,\n\t\t\t\t\t  fm10k_driver_name);\n\tif (!fm10k_workqueue)\n\t\treturn -ENOMEM;\n\tfm10k_dbg_init();\n\treturn fm10k_register_pci_driver();\n}", "target": 0}
{"code": "static void http1_on_data_first_time(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  ssize_t i;\n  i = fio_read(uuid, p->buf + p->buf_len, HTTP_MAX_HEADER_LENGTH - p->buf_len);\n  if (i <= 0)\n    return;\n  p->buf_len += i;\n  p->p.protocol.on_data = http1_on_data;\n  if (i >= 24 && !memcmp(p->buf, \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\", 24)) {\n    FIO_LOG_WARNING(\"client claimed unsupported HTTP/2 prior knowledge.\");\n    fio_close(uuid);\n    return;\n  }\n  http1_consume_data(uuid, p);\n}", "target": 1}
{"code": "  StatusOr<std::vector<int64_t>> GetKernelSize(XlaOpKernelContext* ctx) {\n    if (ctx->num_inputs() == 1) {\n      return ksize_;\n    }\n    const TensorShape ksize_shape = ctx->InputShape(1);\n    if (!TensorShapeUtils::IsVector(ksize_shape)) {\n      return errors::InvalidArgument(\"ksize must be a vector, not shape \",\n                                     ksize_shape.DebugString());\n    }\n    if (ksize_shape.num_elements() != num_dims()) {\n      return errors::InvalidArgument(\n          \"Sliding window ksize field must \"\n          \"specify \",\n          num_dims(), \" dimensions\");\n    }\n    std::vector<int64_t> ksize;\n    auto status = ctx->ConstantInputAsIntVector(1, &ksize);\n    if (!status.ok()) {\n      return status;\n    }\n    return ksize;\n  }", "target": 1}
{"code": "static void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}", "target": 0}
{"code": "gss_context_time (minor_status,\n                  context_handle,\n                  time_rec)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nOM_uint32 *\t\ttime_rec;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (time_rec == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_context_time) {\n\t    status = mech->gss_context_time(\n\t\t\t\t\t    minor_status,\n\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t    time_rec);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "static Jsi_RC NumberToStringCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[500];\n    int radix = 10, skip = 0, argc = Jsi_ValueGetLength(interp, args);\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    if (argc>skip && (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &radix) != JSI_OK\n        || radix<2))\n        return JSI_ERROR;\n    if (argc==skip)\n        return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    switch (radix) {\n        case 16: snprintf(buf, sizeof(buf), \"%\" PRIx64, (Jsi_Wide)num); break;\n        case 8: snprintf(buf, sizeof(buf), \"%\" PRIo64, (Jsi_Wide)num); break;\n        case 10: snprintf(buf, sizeof(buf), \"%\" PRId64, (Jsi_Wide)num); break;\n        default: return jsi_ObjectToStringCmd(interp, args, _this, ret, funcPtr);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "static inline int ip_ufo_append_data(struct sock *sk,\n\t\t\tstruct sk_buff_head *queue,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\t       int odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int maxfraglen, unsigned int flags)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\tif ((skb = skb_peek_tail(queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reserve(skb, hh_len);\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\t\tskb_reset_network_header(skb);\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\t__skb_queue_tail(queue, skb);\n\t}\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}", "target": 1}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n    Tensor group_assignment = c->input(2);\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment, REDUCTION_COLLECTIVE,\n                             resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();\n    col_params->final_op = final_op_.get();\n    VLOG(1) << \"CollectiveReduceV3 group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "bool WddxPacket::recursiveAddVar(const String& varName,\n                                 const Variant& varVariant,\n                                 bool hasVarTag) {\n  bool isArray = varVariant.isArray();\n  bool isObject = varVariant.isObject();\n  if (isArray || isObject) {\n    if (hasVarTag) {\n      m_packetString += \"<var name='\";\n      m_packetString += varName.data();\n      m_packetString += \"'>\";\n    }\n    Array varAsArray;\n    Object varAsObject = varVariant.toObject();\n    if (isArray) varAsArray = varVariant.toArray();\n    if (isObject) varAsArray = varAsObject.toArray();\n    int length = varAsArray.length();\n    if (length > 0) {\n      ArrayIter it = ArrayIter(varAsArray);\n      if (it.first().isString()) isObject = true;\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n      } else {\n        m_packetString += \"<array length='\";\n        m_packetString += std::to_string(length);\n        m_packetString += \"'>\";\n      }\n      for (ArrayIter it(varAsArray); it; ++it) {\n        Variant key = it.first();\n        Variant value = it.second();\n        recursiveAddVar(key.toString(), value, isObject);\n      }\n      if (isObject) {\n        m_packetString += \"</struct>\";\n      }\n      else {\n        m_packetString += \"</array>\";\n      }\n    }\n    else {\n      if (isObject) {\n        m_packetString += \"<struct>\";\n        if (!isArray) {\n          m_packetString += \"<var name='php_class_name'><string>\";\n          m_packetString += varAsObject->o_getClassName().c_str();\n          m_packetString += \"</string></var>\";\n        }\n        m_packetString += \"</struct>\";\n      }\n    }\n    if (hasVarTag) {\n      m_packetString += \"</var>\";\n    }\n    return true;\n  }\n  std::string varType = getDataTypeString(varVariant.getType()).data();\n  if (!getWddxEncoded(varType, \"\", varName, false).empty()) {\n    std::string varValue = varVariant.toString().data();\n    if (varType.compare(\"boolean\") == 0) {\n      varValue = varVariant.toBoolean() ? \"true\" : \"false\";\n    }\n    m_packetString += getWddxEncoded(varType, varValue, varName, hasVarTag);\n    return true;\n  }\n  return false;\n}", "target": 1}
{"code": "double AccessibilityUIElement::clickPointY()\n{\n    return 0.0f;\n}", "target": 0}
{"code": "DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n   BigInt i(msg, msg_len, q.bits());\n   while(i >= q)\n      i -= q;\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n   BigInt s = inverse_mod(k, q);\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n   s = m_mod_q.multiply(s, mul_add(m_x, r, i));\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r/s during DSA signature\");\n   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());\n   }", "target": 1}
{"code": "static void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\tread_lock(&evtchn_rwlock);\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\t\txen_evtchn_handle_events(cpu);\n\t\tBUG_ON(!irqs_disabled());\n\t\tvirt_rmb(); \n\t} while (vcpu_info->evtchn_upcall_pending);\n\tread_unlock(&evtchn_rwlock);\n}", "target": 0}
{"code": "int fz_colorspace_is_gray(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && cs->type == FZ_COLORSPACE_GRAY;\n}", "target": 0}
{"code": "void test_checkout_nasty__dotgit_alternate_data_stream(void)\n{\n\ttest_checkout_fails(\"refs/heads/dotgit_alternate_data_stream\", \".git/dummy-file\");\n\ttest_checkout_fails(\"refs/heads/dotgit_alternate_data_stream\", \".git::$INDEX_ALLOCATION/dummy-file\");\n}", "target": 0}
{"code": "int luaG_traceexec (lua_State *L, const Instruction *pc) {\n  CallInfo *ci = L->ci;\n  lu_byte mask = L->hookmask;\n  int counthook;\n  if (!(mask & (LUA_MASKLINE | LUA_MASKCOUNT))) {  \n    ci->u.l.trap = 0;  \n    return 0;  \n  }\n  pc++;  \n  ci->u.l.savedpc = pc;  \n  counthook = (--L->hookcount == 0 && (mask & LUA_MASKCOUNT));\n  if (counthook)\n    resethookcount(L);  \n  else if (!(mask & LUA_MASKLINE))\n    return 1;  \n  if (ci->callstatus & CIST_HOOKYIELD) {  \n    ci->callstatus &= ~CIST_HOOKYIELD;  \n    return 1;  \n  }\n  if (!isIT(*(ci->u.l.savedpc - 1)))\n    L->top = ci->top;  \n  if (counthook)\n    luaD_hook(L, LUA_HOOKCOUNT, -1, 0, 0);  \n  if (mask & LUA_MASKLINE) {\n    const Proto *p = ci_func(ci)->p;\n    int npci = pcRel(pc, p);\n    if (npci == 0 ||  \n        pc <= L->oldpc ||  \n        changedline(p, pcRel(L->oldpc, p), npci)) {  \n      int newline = luaG_getfuncline(p, npci);\n      luaD_hook(L, LUA_HOOKLINE, newline, 0, 0);  \n    }\n    L->oldpc = pc;  \n  }\n  if (L->status == LUA_YIELD) {  \n    if (counthook)\n      L->hookcount = 1;  \n    ci->u.l.savedpc--;  \n    ci->callstatus |= CIST_HOOKYIELD;  \n    luaD_throw(L, LUA_YIELD);\n  }\n  return 1;  \n}", "target": 1}
{"code": "date_strftime_internal(int argc, VALUE *argv, VALUE self,\n\t\t       const char *default_fmt,\n\t\t       void (*func)(VALUE, struct tmx *))\n{\n    VALUE vfmt;\n    const char *fmt;\n    long len;\n    char buffer[SMALLBUF], *buf = buffer;\n    struct tmx tmx;\n    VALUE str;\n    rb_scan_args(argc, argv, \"01\", &vfmt);\n    if (argc < 1)\n\tvfmt = rb_usascii_str_new2(default_fmt);\n    else {\n\tStringValue(vfmt);\n\tif (!rb_enc_str_asciicompat_p(vfmt)) {\n\t    rb_raise(rb_eArgError,\n\t\t     \"format should have ASCII compatible encoding\");\n\t}\n    }\n    fmt = RSTRING_PTR(vfmt);\n    len = RSTRING_LEN(vfmt);\n    (*func)(self, &tmx);\n    if (memchr(fmt, '\\0', len)) {\n\tconst char *p = fmt, *pe = fmt + len;\n\tstr = rb_str_new(0, 0);\n\twhile (p < pe) {\n\t    len = date_strftime_alloc(&buf, p, &tmx);\n\t    rb_str_cat(str, buf, len);\n\t    p += strlen(p);\n\t    if (buf != buffer) {\n\t\txfree(buf);\n\t\tbuf = buffer;\n\t    }\n\t    for (fmt = p; p < pe && !*p; ++p);\n\t    if (p > fmt) rb_str_cat(str, fmt, p - fmt);\n\t}\n\trb_enc_copy(str, vfmt);\n\treturn str;\n    }\n    else\n\tlen = date_strftime_alloc(&buf, fmt, &tmx);\n    str = rb_str_new(buf, len);\n    if (buf != buffer) xfree(buf);\n    rb_enc_copy(str, vfmt);\n    return str;\n}", "target": 0}
{"code": "static void listdir(unsigned int depth, int f, void * const tls_fd,\n                    const char *name)\n{\n    PureFileInfo *dir;\n    char *names;\n    PureFileInfo *s;\n    PureFileInfo *r;\n    int d;\n    if (depth >= max_ls_depth || matches >= max_ls_files) {\n        return;\n    }\n    if ((dir = sreaddir(&names)) == NULL) {\n        addreply(226, MSG_CANT_READ_FILE, name);\n        return;\n    }\n    s = dir;\n    while (s->name_offset != (size_t) -1) {\n        d = 0;\n        if (FI_NAME(s)[0] != '.') {\n            d = listfile(s, NULL);\n        } else if (opt_a) {\n            if (FI_NAME(s)[1] == 0 ||\n                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {\n                listfile(s, NULL);\n            } else {\n                d = listfile(s, NULL);\n            }\n        }\n        if (!d) {\n            s->name_offset = (size_t) -1;\n        }\n        s++;\n    }\n    outputfiles(f, tls_fd);\n    r = dir;\n    while (opt_R && r != s) {\n        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {\n            char *alloca_subdir;\n            const size_t sizeof_subdir = PATH_MAX + 1U;\n            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {\n                goto toomany;\n            }\n            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",\n                                 name, FI_NAME(r)), sizeof_subdir)) {\n                goto nolist;\n            }\n            wrstr(f, tls_fd, \"\\r\\n\\r\\n\");\n            wrstr(f, tls_fd, alloca_subdir);\n            wrstr(f, tls_fd, \":\\r\\n\\r\\n\");\n            listdir(depth + 1U, f, tls_fd, alloca_subdir);\n            nolist:\n            ALLOCA_FREE(alloca_subdir);\n            if (matches >= max_ls_files) {\n                goto toomany;\n            }\n            if (chdir(\"..\")) {    \n                if (chdir(wd) || chdir(name)) {    \n                    die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                }\n            }\n        }\n        r++;\n    }\n    toomany:\n    free(names);\n    free(dir);\n    names = NULL;\n}", "target": 1}
{"code": "LUA_API void lua_sethook (lua_State *L, lua_Hook func, int mask, int count) {\n  if (func == NULL || mask == 0) {  \n    mask = 0;\n    func = NULL;\n  }\n  if (isLua(L->ci))\n    L->oldpc = L->ci->u.l.savedpc;\n  L->hook = func;\n  L->basehookcount = count;\n  resethookcount(L);\n  L->hookmask = cast_byte(mask);\n  if (mask)\n    settraps(L->ci);  \n}", "target": 1}
{"code": "static const char *adpt_info(struct Scsi_Host *host)\n{\n\tadpt_hba* pHba;\n\tpHba = (adpt_hba *) host->hostdata[0];\n\treturn (char *) (pHba->detail);\n}", "target": 1}
{"code": "static int adpt_show_info(struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct adpt_device* d;\n\tint id;\n\tint chan;\n\tadpt_hba* pHba;\n\tint unit;\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->host == host) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tmutex_unlock(&adpt_configuration_lock);\n\tif (pHba == NULL) {\n\t\treturn 0;\n\t}\n\thost = pHba->host;\n\tseq_printf(m, \"Adaptec I2O RAID Driver Version: %s\\n\\n\", DPT_I2O_VERSION);\n\tseq_printf(m, \"%s\\n\", pHba->detail);\n\tseq_printf(m, \"SCSI Host=scsi%d  Control Node=/dev/%s  irq=%d\\n\", \n\t\t\tpHba->host->host_no, pHba->name, host->irq);\n\tseq_printf(m, \"\\tpost fifo size  = %d\\n\\treply fifo size = %d\\n\\tsg table size   = %d\\n\\n\",\n\t\t\thost->can_queue, (int) pHba->reply_fifo_size , host->sg_tablesize);\n\tseq_puts(m, \"Devices:\\n\");\n\tfor(chan = 0; chan < MAX_CHANNEL; chan++) {\n\t\tfor(id = 0; id < MAX_ID; id++) {\n\t\t\td = pHba->channel[chan].device[id];\n\t\t\twhile(d) {\n\t\t\t\tseq_printf(m,\"\\t%-24.24s\", d->pScsi_dev->vendor);\n\t\t\t\tseq_printf(m,\" Rev: %-8.8s\\n\", d->pScsi_dev->rev);\n\t\t\t\tunit = d->pI2o_dev->lct_data.tid;\n\t\t\t\tseq_printf(m, \"\\tTID=%d, (Channel=%d, Target=%d, Lun=%llu)  (%s)\\n\\n\",\n\t\t\t\t\t       unit, (int)d->scsi_channel, (int)d->scsi_id, d->scsi_lun,\n\t\t\t\t\t       scsi_device_online(d->pScsi_dev)? \"online\":\"offline\"); \n\t\t\t\td = d->next_lun;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int encode_open_downgrade(struct xdr_stream *xdr, const struct nfs_closeargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(4+NFS4_STATEID_SIZE+4);\n\tWRITE32(OP_OPEN_DOWNGRADE);\n\tWRITEMEM(arg->stateid->data, NFS4_STATEID_SIZE);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\treturn 0;\n}", "target": 1}
{"code": "    explicit DialogHandler(v8::Handle<v8::Value> dialogArguments, ScriptState* scriptState)\n        : m_scriptState(scriptState)\n        , m_dialogArguments(dialogArguments)\n    {\n    }", "target": 0}
{"code": "ev_archive_get_entry_is_encrypted (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, -1);\n\t\treturn archive_entry_is_encrypted (archive->libar_entry);\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "videobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count++;\n}", "target": 1}
{"code": "spnego_gss_context_time(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tOM_uint32\t*time_rec)\n{\n\tOM_uint32 ret;\n\tret = gss_context_time(minor_status,\n\t\t\t    context_handle,\n\t\t\t    time_rec);\n\treturn (ret);\n}", "target": 1}
{"code": "static uint8_t nvme_sq_empty(NvmeSQueue *sq)\n{\n    return sq->head == sq->tail;\n}", "target": 0}
{"code": "flatpak_filesystem_key_in_home (const char *filesystem)\n{\n  if (strcmp (filesystem, \"home\") == 0)\n    return TRUE;\n  if (g_strv_contains (flatpak_context_special_filesystems, filesystem) ||\n      g_str_has_prefix (filesystem, \"/\"))\n    return FALSE;\n  if (g_str_has_prefix (filesystem, \"xdg-run\"))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "Jsi_RC Jsi_RegExpMatch(Jsi_Interp *interp, Jsi_Value *pattern, const char *v, int *rc, Jsi_DString *dStr)\n{\n    Jsi_Regex *re;\n    int regexec_flags = 0;\n    if (rc)\n        *rc = 0;\n    if (pattern == NULL || pattern->vt != JSI_VT_OBJECT || pattern->d.obj->ot != JSI_OT_REGEXP) \n        return Jsi_LogError(\"expected pattern\");\n    re = pattern->d.obj->d.robj;\n    regex_t *reg = &re->reg;\n    regmatch_t pos = {};\n    if (dStr)\n        Jsi_DSInit(dStr);\n    int r  = regexec(reg, v, 1, &pos, regexec_flags);\n    if (r >= REG_BADPAT) {\n        char buf[100];\n        regerror(r, reg, buf, sizeof(buf));\n        return Jsi_LogError(\"error while matching pattern: %s\", buf);\n    }\n    if (r != REG_NOMATCH) {\n        if (rc) *rc = 1;\n        if (dStr && pos.rm_so >= 0 && pos.rm_eo >= 0 &&  pos.rm_eo >= pos.rm_so)\n            Jsi_DSAppendLen(dStr, v + pos.rm_so, pos.rm_eo - pos.rm_so);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "std::shared_ptr<EC_Group_Data> EC_Group::BER_decode_EC_group(const uint8_t bits[], size_t len,\n                                                             EC_Group_Source source)\n   {\n   BER_Decoder ber(bits, len);\n   BER_Object obj = ber.get_next_object();\n   if(obj.type() == NULL_TAG)\n      {\n      throw Decoding_Error(\"Cannot handle ImplicitCA ECC parameters\");\n      }\n   else if(obj.type() == OBJECT_ID)\n      {\n      OID dom_par_oid;\n      BER_Decoder(bits, len).decode(dom_par_oid);\n      return ec_group_data().lookup(dom_par_oid);\n      }\n   else if(obj.type() == SEQUENCE)\n      {\n      BigInt p, a, b, order, cofactor;\n      std::vector<uint8_t> base_pt;\n      std::vector<uint8_t> seed;\n      BER_Decoder(bits, len)\n         .start_cons(SEQUENCE)\n           .decode_and_check<size_t>(1, \"Unknown ECC param version code\")\n           .start_cons(SEQUENCE)\n            .decode_and_check(OID(\"1.2.840.10045.1.1\"),\n                              \"Only prime ECC fields supported\")\n             .decode(p)\n           .end_cons()\n           .start_cons(SEQUENCE)\n             .decode_octet_string_bigint(a)\n             .decode_octet_string_bigint(b)\n             .decode_optional_string(seed, BIT_STRING, BIT_STRING)\n           .end_cons()\n           .decode(base_pt, OCTET_STRING)\n           .decode(order)\n           .decode(cofactor)\n         .end_cons()\n         .verify_end();\n      if(p.bits() < 64 || p.is_negative() || !is_bailie_psw_probable_prime(p))\n         throw Decoding_Error(\"Invalid ECC p parameter\");\n      if(a.is_negative() || a >= p)\n         throw Decoding_Error(\"Invalid ECC a parameter\");\n      if(b <= 0 || b >= p)\n         throw Decoding_Error(\"Invalid ECC b parameter\");\n      if(order <= 0 || !is_bailie_psw_probable_prime(order))\n         throw Decoding_Error(\"Invalid ECC order parameter\");\n      if(cofactor <= 0 || cofactor >= 16)\n         throw Decoding_Error(\"Invalid ECC cofactor parameter\");\n      std::pair<BigInt, BigInt> base_xy = Botan::OS2ECP(base_pt.data(), base_pt.size(), p, a, b);\n      return ec_group_data().lookup_or_create(p, a, b, base_xy.first, base_xy.second,\n                                              order, cofactor, OID(), source);\n      }\n   else\n      {\n      throw Decoding_Error(\"Unexpected tag while decoding ECC domain params\");\n      }\n   }", "target": 1}
{"code": "static int do_new_mount(struct path *path, const char *fstype, int flags,\n\t\t\tint mnt_flags, const char *name, void *data)\n{\n\tstruct file_system_type *type;\n\tstruct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;\n\tstruct vfsmount *mnt;\n\tint err;\n\tif (!fstype)\n\t\treturn -EINVAL;\n\ttype = get_fs_type(fstype);\n\tif (!type)\n\t\treturn -ENODEV;\n\tif (user_ns != &init_user_ns) {\n\t\tif (!(type->fs_flags & FS_USERNS_MOUNT)) {\n\t\t\tput_filesystem(type);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tif (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {\n\t\t\tflags |= MS_NODEV;\n\t\t\tmnt_flags |= MNT_NODEV;\n\t\t}\n\t}\n\tmnt = vfs_kern_mount(type, flags, name, data);\n\tif (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&\n\t    !mnt->mnt_sb->s_subtype)\n\t\tmnt = fs_set_subtype(mnt, fstype);\n\tput_filesystem(type);\n\tif (IS_ERR(mnt))\n\t\treturn PTR_ERR(mnt);\n\terr = do_add_mount(real_mount(mnt), path, mnt_flags);\n\tif (err)\n\t\tmntput(mnt);\n\treturn err;\n}", "target": 1}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "libarchive_read_next_header (EvArchive *archive,\n\t\t\t     GError   **error)\n{\n\twhile (1) {\n\t\tint r;\n\t\tr = archive_read_next_header (archive->libar, &archive->libar_entry);\n\t\tif (r != ARCHIVE_OK) {\n\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t\t\t     \"Error reading archive: %s\", archive_error_string (archive->libar));\n\t\t\treturn FALSE;\n\t\t}\n\t\tif (archive_entry_filetype (archive->libar_entry) != AE_IFREG) {\n\t\t\tg_debug (\"Skipping '%s' as it's not a regular file\",\n\t\t\t\t archive_entry_pathname (archive->libar_entry));\n\t\t\tcontinue;\n\t\t}\n\t\tg_debug (\"At header for file '%s'\", archive_entry_pathname (archive->libar_entry));\n\t\tbreak;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "void usbredirparser_send_control_packet(struct usbredirparser *parser,\n    uint64_t id,\n    struct usb_redir_control_packet_header *control_header,\n    uint8_t *data, int data_len)\n{\n    usbredirparser_queue(parser, usb_redir_control_packet, id, control_header,\n                         data, data_len);\n}", "target": 0}
{"code": "static void zep_print_ts(netdissect_options *ndo, const u_char *p)\n{\n\tint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tfloat ff;\n\ti = GET_BE_U_4(p);\n\tuf = GET_BE_U_4(p + 4);\n\tff = (float) uf;\n\tif (ff < 0.0)           \n\t\tff += FMAXINT;\n\tff = (float) (ff / FMAXINT); \n\tf = (uint32_t) (ff * 1000000000.0);  \n\tND_PRINT(\"%u.%09d\", i, f);\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tstruct tm *tm;\n\t\tchar time_buf[128];\n\t\ttm = localtime(&seconds);\n\t\tstrftime(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\", tm);\n\t\tND_PRINT(\" (%s)\", time_buf);\n\t}\n}", "target": 1}
{"code": "int main()\n{\n    gdImagePtr src, dst;\n    int size;\n    src = gdImageCreateTrueColor(1, 10);\n    gdTestAssert(src != NULL);\n    src->sx = 0; \n    dst = gdImageJpegPtr(src, &size, 0);\n    gdTestAssert(dst == NULL);\n    gdImageDestroy(src);\n    return gdNumFailures();\n}", "target": 0}
{"code": "bool SQLiteDatabase::ExecuteCommand(const String& sql) {\n  return SQLiteStatement(*this, sql).ExecuteCommand();\n}", "target": 0}
{"code": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int fd_getgeo(struct block_device *bdev, struct hd_geometry *geo)\n{\n\tint drive = (long)bdev->bd_disk->private_data;\n\tint type = ITYPE(drive_state[drive].fd_device);\n\tstruct floppy_struct *g;\n\tint ret;\n\tret = get_floppy_geometry(drive, type, &g);\n\tif (ret)\n\t\treturn ret;\n\tgeo->heads = g->head;\n\tgeo->sectors = g->sect;\n\tgeo->cylinders = g->track;\n\treturn 0;\n}", "target": 0}
{"code": "static bool torture_winbind_struct_netbios_name(struct torture_context *torture)\n{\n\tstruct winbindd_response rep;\n\tconst char *expected;\n\tZERO_STRUCT(rep);\n\ttorture_comment(torture, \"Running WINBINDD_NETBIOS_NAME (struct based)\\n\");\n\tDO_STRUCT_REQ_REP(WINBINDD_NETBIOS_NAME, NULL, &rep);\n\texpected = torture_setting_string(torture,\n\t\t\t\t\t  \"winbindd_netbios_name\",\n\t\t\t\t\t  lpcfg_netbios_name(torture->lp_ctx));\n\texpected = strupper_talloc(torture, expected);\n\ttorture_assert_str_equal(torture,\n\t\t\t\t rep.data.netbios_name, expected,\n\t\t\t\t \"winbindd's netbios name doesn't match\");\n\treturn true;\n}", "target": 0}
{"code": "gss_process_context_token (minor_status,\n                           context_handle,\n                           token_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    if (token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n    if (GSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_process_context_token) {\n\t    status = mech->gss_process_context_token(\n\t\t\t\t\t\t    minor_status,\n\t\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t\t    token_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "lyd_new_yangdata(const struct lys_module *module, const char *name_template, const char *name)\n{\n    const struct lys_node *schema = NULL, *snode;\n    if (!module || !name_template || !name) {\n        LOGARG;\n        return NULL;\n    }\n    schema = lyp_get_yang_data_template(module, name_template, strlen(name_template));\n    if (!schema) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find yang-data template \\\"%s\\\".\", name_template);\n        return NULL;\n    }\n    if (lys_getnext_data(module, schema, name, strlen(name), LYS_CONTAINER, &snode) || !snode) {\n        LOGERR(module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a container child of \\\"%s:%s\\\".\",\n               name, module->name, schema->name);\n        return NULL;\n    }\n    return _lyd_new(NULL, snode, 0);\n}", "target": 1}
{"code": "static void on_underlying_io_bytes_received(void *context, const unsigned char *buffer, size_t size)\n{\n    if (context != NULL)\n    {\n        TLS_IO_INSTANCE *tls_io_instance = (TLS_IO_INSTANCE *)context;\n        unsigned char *new_socket_io_read_bytes = (unsigned char *)realloc(tls_io_instance->socket_io_read_bytes, tls_io_instance->socket_io_read_byte_count + size);\n        if (new_socket_io_read_bytes == NULL)\n        {\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else\n        {\n            tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;\n            (void)memcpy(tls_io_instance->socket_io_read_bytes + tls_io_instance->socket_io_read_byte_count, buffer, size);\n            tls_io_instance->socket_io_read_byte_count += size;\n        }\n    }\n    else\n    {\n        LogError(\"NULL value passed in context\");\n    }\n}", "target": 1}
{"code": "create_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->ctx_handle = GSS_C_NO_CONTEXT;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\tcheck_spnego_options(spnego_ctx);\n\treturn (spnego_ctx);\n}", "target": 1}
{"code": "static inline void flush(Encoder *encoder)\n{\n    if (encoder->io_available_bits > 0 && encoder->io_available_bits != 32) {\n        encode(encoder, 0, encoder->io_available_bits);\n    }\n    encode_32(encoder, 0);\n    encode(encoder, 0, 1);\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int kLeftShift = 8;\n    int32_t input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(\n        static_cast<double>(input1->params.scale), &input1_multiplier,\n        &input1_shift);\n    int32_t input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(\n        static_cast<double>(input2->params.scale), &input2_multiplier,\n        &input2_shift);\n    data->params.left_shift = kLeftShift;\n    data->params.input1_offset = input1_offset;\n    data->params.input1_multiplier = input1_multiplier;\n    data->params.input1_shift = input1_shift;\n    data->params.input2_offset = input2_offset;\n    data->params.input2_multiplier = input2_multiplier;\n    data->params.input2_shift = input2_shift;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_field_type_oid)\n{\n\tphp_pgsql_get_field_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_FIELD_TYPE_OID);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& filter = context->input(1);\n    const TensorShape& filter_shape = filter.shape();\n    const Tensor& out_backprop = context->input(2);\n    const TensorShape& out_backprop_shape = out_backprop.shape();\n    TensorShape input_shape;\n    if (takes_shape_) {\n      const Tensor& input_sizes = context->input(0);\n      OP_REQUIRES_OK(context, tensor::MakeShape(input_sizes, &input_shape));\n    } else {\n      input_shape = context->input(0).shape();\n    }\n    OP_REQUIRES(\n        context, input_shape.dim_size(4) == filter_shape.dim_size(3),\n        errors::InvalidArgument(\"input and filter_sizes must have the same \"\n                                \"number of channels. Got \",\n                                input_shape.dim_size(4), \" for input and \",\n                                filter_shape.dim_size(3), \" for filter_sizes\"));\n    OP_REQUIRES(\n        context, out_backprop_shape.dim_size(4) == filter_shape.dim_size(4),\n        errors::InvalidArgument(\"out_backprop and filter_sizes must have the \"\n                                \"same number of channels. Got \",\n                                out_backprop_shape.dim_size(4),\n                                \" for out_backprop and \",\n                                filter_shape.dim_size(4), \" for filter_sizes\"));\n    ConvBackpropDimensions dims;\n    OP_REQUIRES_OK(context, ConvBackpropComputeDimensions(\n                                \"Conv3DBackpropInputOp\", 3,\n                                input_shape, filter_shape, out_backprop_shape,\n                                stride_, padding_, data_format_, &dims));\n    Tensor* in_backprop;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    functor::CuboidConvolutionBackwardInput<Device, T>()(\n        context->eigen_device<Device>(),\n        in_backprop->tensor<T, 5>(),                     \n        filter.tensor<T, 5>(),                           \n        out_backprop.tensor<T, 5>(),                     \n        static_cast<int>(dims.spatial_dims[0].stride),   \n        static_cast<int>(dims.spatial_dims[1].stride),   \n        static_cast<int>(dims.spatial_dims[2].stride));  \n  }", "target": 0}
{"code": "static void vm_unlock_anon_vma(struct anon_vma *anon_vma)\n{\n\tif (test_bit(0, (unsigned long *) &anon_vma->root->rb_root.rb_node)) {\n\t\tif (!__test_and_clear_bit(0, (unsigned long *)\n\t\t\t\t\t  &anon_vma->root->rb_root.rb_node))\n\t\t\tBUG();\n\t\tanon_vma_unlock_write(anon_vma);\n\t}\n}", "target": 0}
{"code": "void *mempool_getbuffer(MemoryPoolHandle handle, size_t expected_buffer_size) {\n  int rc;\n  int bufs_to_allocate;\n  int bufs_that_can_be_allocated = 0;\n  struct memory_pool_element *pool_item = NULL;\n  struct mempool *pool = (struct mempool *)handle;\n  char *log_msg_fmt =\n      \"mempool(%p): mempool_getbuffer called for invalid \"\n      \"expected_buffer_size(%zu), current pool manages only \"\n      \"mempool_item_size(%zu)\";\n  char log_msg[300];\n  if (pool == NULL) {\n    return NULL;\n  }\n  if (pool->mempool_item_size != expected_buffer_size) {\n    if (pool->log_callback_func) {\n      snprintf(log_msg, sizeof(log_msg), log_msg_fmt, (void *)pool,\n               expected_buffer_size, pool->mempool_item_size);\n      pool->log_callback_func(MEMPOOL_LOG_FATAL, log_msg);\n      return NULL;\n    }\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_lock(&pool->lock);\n  }\n  if (pool->free_bufs_in_pool == 0) {\n    bufs_to_allocate = pool->expandable_size / pool->mempool_item_size;\n    bufs_that_can_be_allocated = pool_can_expand_by(pool);\n    if (bufs_that_can_be_allocated > 0) {\n      bufs_to_allocate = ((bufs_to_allocate > bufs_that_can_be_allocated)\n                              ? bufs_that_can_be_allocated\n                              : bufs_to_allocate);\n      rc = freelist_allocate(pool, bufs_to_allocate);\n      if (rc != 0) {\n        if ((pool->flags & ENABLE_LOCKING) != 0) {\n          pthread_mutex_unlock(&pool->lock);\n        }\n        return NULL;\n      }\n    } else {\n      if ((pool->flags & ENABLE_LOCKING) != 0) {\n        pthread_mutex_unlock(&pool->lock);\n      }\n      return NULL;\n    }\n  }\n  if (pool->free_list != NULL) {\n    pool_item = pool->free_list;\n    pool->free_list = pool_item->next;\n    pool_item->next = (struct memory_pool_element *)NULL;\n    pool->free_bufs_in_pool--;\n  }\n  if (pool_item) {\n    pool->number_of_bufs_shared++;\n  }\n  if ((pool->flags & ENABLE_LOCKING) != 0) {\n    pthread_mutex_unlock(&pool->lock);\n  }\n  return (void *)pool_item;\n}", "target": 0}
{"code": "LogicalSize NGColumnLayoutAlgorithm::CalculateColumnSize(\n    const LogicalSize& content_box_size) {\n  LogicalSize column_size = content_box_size;\n  DCHECK_GE(column_size.inline_size, LayoutUnit());\n  column_size.inline_size =\n      ResolveUsedColumnInlineSize(column_size.inline_size, Style());\n  if (NeedsColumnBalancing(column_size.block_size, Style())) {\n    int used_count =\n        ResolveUsedColumnCount(content_box_size.inline_size, Style());\n    column_size.block_size =\n        CalculateBalancedColumnBlockSize(column_size, used_count);\n  }\n  return column_size;\n}", "target": 0}
{"code": "bool SPIFFEValidator::matchSubjectAltName(X509& leaf_cert) {\n  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(\n      X509_get_ext_d2i(&leaf_cert, NID_subject_alt_name, nullptr, nullptr)));\n  ASSERT(san_names != nullptr,\n         \"san_names should have at least one name after SPIFFE cert validation\");\n  for (const GENERAL_NAME* general_name : san_names.get()) {\n    if (general_name->type == GEN_URI) {\n      const std::string san = Utility::generalNameAsString(general_name);\n      for (const auto& config_san_matcher : subject_alt_name_matchers_) {\n        if (config_san_matcher.match(san)) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "sudo_auth_begin_session(const struct sudoers_context *ctx, struct passwd *pw,\n    char **user_env[])\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_begin_session, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->begin_session && !IS_DISABLED(auth)) {\n\t    int status = (auth->begin_session)(ctx, pw, user_env, auth);\n\t    if (status != AUTH_SUCCESS) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}", "target": 1}
{"code": "STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7encdata(PKCS7 *p7, const char *pass,\n                                                  int passlen)\n{\n    if (!PKCS7_type_is_encrypted(p7))\n        return NULL;\n    if (p7->d.encrypted == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    return PKCS12_item_decrypt_d2i_ex(p7->d.encrypted->enc_data->algorithm,\n                                   ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                                   pass, passlen,\n                                   p7->d.encrypted->enc_data->enc_data, 1,\n                                   p7->ctx.libctx, p7->ctx.propq);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    OP_REQUIRES(context, input.dims() == 1 || input.dims() == 2,\n                errors::InvalidArgument(\n                    \"input must be a vector or 2D tensor, but got shape \",\n                    input.shape().DebugString()));\n    if (input.dims() == 1) {\n      OP_REQUIRES(context,\n                  input.NumElements() == 2 || input.NumElements() == 4 ||\n                      input.NumElements() == 5,\n                  errors::InvalidArgument(\n                      \"1D input must be of size 2, 4 or 5, but got shape \",\n                      input.shape().DebugString()));\n    } else if (input.dims() == 2) {\n      OP_REQUIRES(context, input.dim_size(0) == 2 || input.dim_size(0) == 4,\n                  errors::InvalidArgument(\"First dimension of 2D input must be \"\n                                          \"of size 2 or 4, but got shape \",\n                                          input.shape().DebugString()));\n      OP_REQUIRES(\n          context, input.dim_size(1) == 2,\n          errors::InvalidArgument(\n              \"Second dimension of 2D input must be of size 2, but got shape \",\n              input.shape().DebugString()));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n    Eigen::DSizes<Eigen::DenseIndex, 8> dst_idx;\n    string src_format_str = src_format_;\n    string dst_format_str = dst_format_;\n    if (input.dim_size(0) == 2) {\n      auto keep_only_spatial_dimensions = [](string* format_str) -> void {\n        auto new_end = std::remove_if(\n            format_str->begin(), format_str->end(),\n            [](const char dim) { return dim != 'H' && dim != 'W'; });\n        format_str->erase(new_end, format_str->end());\n      };\n      keep_only_spatial_dimensions(&src_format_str);\n      keep_only_spatial_dimensions(&dst_format_str);\n      OP_REQUIRES(context,\n                  src_format_str.size() == 2 && dst_format_str.size() == 2,\n                  errors::InvalidArgument(\n                      \"Format specifier must contain H and W for 2D case\"));\n    }\n    ComputeDstIndex(src_format_str, dst_format_str, input.dims(), &dst_idx);\n    functor::DataFormatVecPermute<Device, T>()(context->eigen_device<Device>(),\n                                               input.flat<T>(),\n                                               output->flat<T>(), dst_idx);\n  }", "target": 0}
{"code": "static inline int may_ptrace_stop(void)\n{\n\tif (!likely(current->ptrace))\n\t\treturn 0;\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_source_code_file_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (!sz) {\n\t\treturn NULL;\n\t}\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SOURCE_FILE_ATTR;\n\tattr->info.source_file_attr.sourcefile_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "int RECORD_LAYER_data_present(const RECORD_LAYER *rl)\n{\n    if (rl->rstate == SSL_ST_READ_BODY)\n        return 1;\n    if (RECORD_LAYER_processed_read_pending(rl))\n        return 1;\n    return 0;\n}", "target": 0}
{"code": "snmp_mib_find_next(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(snmp_oid_cmp_oid(resource->oid, oid) > 0) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "static void ssl_reset_sock_state(pj_ssl_sock_t *ssock)\n{\n    ossl_sock_t *ossock = (ossl_sock_t *)ssock;\n    if (ossock->ossl_ssl) {\n\tSSL_set_ex_data(ossock->ossl_ssl, sslsock_idx, NULL);\n    }\n    if (ossock->ossl_ssl && SSL_in_init(ossock->ossl_ssl) == 0) {\n\tint ret = SSL_shutdown(ossock->ossl_ssl);\n\tif (ret == 0) {\n\t    flush_circ_buf_output(ssock, &ssock->shutdown_op_key, 0, 0);\n\t}\n    }\n    pj_lock_acquire(ssock->write_mutex);\n    ssock->ssl_state = SSL_STATE_NULL;\n    pj_lock_release(ssock->write_mutex);\n    ssl_close_sockets(ssock);\n    ERR_clear_error();\n}", "target": 0}
{"code": "static char *oidc_cache_get_hashed_key(request_rec *r, const char *passphrase,\n\t\tconst char *key) {\n\tchar *input = apr_psprintf(r->pool, \"%s:%s\", passphrase, key);\n\tchar *output = NULL;\n\tif (oidc_util_hash_string_and_base64url_encode(r, OIDC_JOSE_ALG_SHA256,\n\t\t\tinput, &output) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"oidc_util_hash_string_and_base64url_encode returned an error\");\n\t\treturn NULL;\n\t}\n\treturn output;\n}", "target": 1}
{"code": "static void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 intr_info = vmx_get_intr_info(vcpu);\n\tunsigned int vector = intr_info & INTR_INFO_VECTOR_MASK;\n\tgate_desc *desc = (gate_desc *)host_idt_base + vector;\n\tif (KVM_BUG(!is_external_intr(intr_info), vcpu->kvm,\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\thandle_interrupt_nmi_irqoff(vcpu, gate_offset(desc));\n\tvcpu->arch.at_instruction_boundary = true;\n}", "target": 0}
{"code": "bool CMerkleTx::AcceptToMemoryPool(CTxDB &txdb, bool fCheckInputs) {\n    return(CTransaction::AcceptToMemoryPool(txdb, fCheckInputs));\n}", "target": 1}
{"code": "int dns_add_rr_nested_end(struct dns_rr_nested *rr_nested, dns_type_t rtype)\n{\n\tif (rr_nested == NULL || rr_nested->rr_start == NULL) {\n\t\treturn -1;\n\t}\n\tint len = rr_nested->context.ptr - rr_nested->rr_start;\n\tunsigned char *ptr = rr_nested->rr_len_ptr;\n\tif (ptr == NULL || _dns_left_len(&rr_nested->context) < 2) {\n\t\treturn -1;\n\t}\n\tif (len <= 14) {\n\t\trr_nested->context.ptr = rr_nested->rr_start;\n\t\treturn 0;\n\t}\n\t_dns_write_short(&ptr, len - rr_nested->rr_head_len);\n\treturn _dns_rr_add_end(rr_nested->context.packet, rr_nested->type, rtype, len);\n}", "target": 0}
{"code": "header_put_be_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "static int handle_invept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 vmx_instruction_info, types;\n\tunsigned long type;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand;\n\tif (!(vmx->nested.nested_vmx_secondary_ctls_high &\n\t      SECONDARY_EXEC_ENABLE_EPT) ||\n\t    !(vmx->nested.nested_vmx_ept_caps & VMX_EPT_INVEPT_BIT)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tif (!nested_vmx_check_permission(vcpu))\n\t\treturn 1;\n\tif (!kvm_read_cr0_bits(vcpu, X86_CR0_PE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\ttypes = (vmx->nested.nested_vmx_ept_caps >> VMX_EPT_EXTENT_SHIFT) & 6;\n\tif (!(types & (1UL << type))) {\n\t\tnested_vmx_failValid(vcpu,\n\t\t\t\tVMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n\t\treturn 1;\n\t}\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\tvmx_instruction_info, false, &gva))\n\t\treturn 1;\n\tif (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &operand,\n\t\t\t\tsizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\tswitch (type) {\n\tcase VMX_EPT_EXTENT_GLOBAL:\n\t\tkvm_mmu_sync_roots(vcpu);\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\tnested_vmx_succeed(vcpu);\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t\tbreak;\n\t}\n\tskip_emulated_instruction(vcpu);\n\treturn 1;\n}", "target": 0}
{"code": "static void put_crypt_info(struct fscrypt_info *ci)\n{\n\tif (!ci)\n\t\treturn;\n\tkey_put(ci->ci_keyring_key);\n\tcrypto_free_skcipher(ci->ci_ctfm);\n\tkmem_cache_free(fscrypt_info_cachep, ci);\n}", "target": 1}
{"code": "static int __init xfrm6_tunnel_spi_init(void)\n{\n\txfrm6_tunnel_spi_kmem = kmem_cache_create(\"xfrm6_tunnel_spi\",\n\t\t\t\t\t\t  sizeof(struct xfrm6_tunnel_spi),\n\t\t\t\t\t\t  0, SLAB_HWCACHE_ALIGN,\n\t\t\t\t\t\t  NULL);\n\tif (!xfrm6_tunnel_spi_kmem)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "static void mark_curve(fixed sx, fixed sy, fixed c1x, fixed c1y, fixed c2x, fixed c2y, fixed ex, fixed ey, fixed base_y, fixed height, int *table, int *index, int depth)\n{\n    fixed ax = (sx + c1x)>>1;\n    fixed ay = (sy + c1y)>>1;\n    fixed bx = (c1x + c2x)>>1;\n    fixed by = (c1y + c2y)>>1;\n    fixed cx = (c2x + ex)>>1;\n    fixed cy = (c2y + ey)>>1;\n    fixed dx = (ax + bx)>>1;\n    fixed dy = (ay + by)>>1;\n    fixed fx = (bx + cx)>>1;\n    fixed fy = (by + cy)>>1;\n    fixed gx = (dx + fx)>>1;\n    fixed gy = (dy + fy)>>1;\n    assert(depth >= 0);\n    if (depth == 0)\n        mark_line(sx, sy, ex, ey, base_y, height, table, index);\n    else {\n        depth--;\n        mark_curve(sx, sy, ax, ay, dx, dy, gx, gy, base_y, height, table, index, depth);\n        mark_curve(gx, gy, fx, fy, cx, cy, ex, ey, base_y, height, table, index, depth);\n    }\n}", "target": 0}
{"code": "static int ext4_set_bh_endio(struct buffer_head *bh, struct inode *inode)\n{\n\text4_io_end_t *io_end;\n\tstruct page *page = bh->b_page;\n\tloff_t offset = (sector_t)page->index << PAGE_CACHE_SHIFT;\n\tsize_t size = bh->b_size;\nretry:\n\tio_end = ext4_init_io_end(inode, GFP_ATOMIC);\n\tif (!io_end) {\n\t\tif (printk_ratelimit())\n\t\t\tprintk(KERN_WARNING \"%s: allocation fail\\n\", __func__);\n\t\tschedule();\n\t\tgoto retry;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\tio_end->page = page;\n\tget_page(io_end->page);\n\tbh->b_private = io_end;\n\tbh->b_end_io = ext4_end_io_buffer_write;\n\treturn 0;\n}", "target": 0}
{"code": "const AtomicString& BaseAudioContext::InterfaceName() const {\n  return event_target_names::kAudioContext;\n}", "target": 0}
{"code": "void CConfig::Write(CFile& File, unsigned int iIndentation) {\n    CString sIndentation = CString(iIndentation, '\\t');\n    for (const auto& it : m_ConfigEntries) {\n        for (const CString& sValue : it.second) {\n            File.Write(sIndentation + it.first + \" = \" + sValue + \"\\n\");\n        }\n    }\n    for (const auto& it : m_SubConfigs) {\n        for (const auto& it2 : it.second) {\n            File.Write(\"\\n\");\n            File.Write(sIndentation + \"<\" + it.first + \" \" + it2.first + \">\\n\");\n            it2.second.m_pSubConfig->Write(File, iIndentation + 1);\n            File.Write(sIndentation + \"</\" + it.first + \">\\n\");\n        }\n    }\n}", "target": 1}
{"code": "int button_open(Button *b) {\n        char *p, name[256];\n        int r;\n        assert(b);\n        b->fd = safe_close(b->fd);\n        p = strjoina(\"/dev/input/\", b->name);\n        b->fd = open(p, O_RDWR|O_CLOEXEC|O_NOCTTY|O_NONBLOCK);\n        if (b->fd < 0)\n                return log_warning_errno(errno, \"Failed to open %s: %m\", p);\n        r = button_suitable(b);\n        if (r < 0)\n                return log_warning_errno(r, \"Failed to determine whether input device is relevant to us: %m\");\n        if (r == 0)\n                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n        (void) button_set_mask(b);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n        return 0;\nfail:\n        b->fd = safe_close(b->fd);\n        return r;\n}", "target": 1}
{"code": "int mutt_seqset_iterator_next(struct SeqsetIterator *iter, unsigned int *next)\n{\n  if (!iter || !next)\n    return -1;\n  if (iter->in_range)\n  {\n    if ((iter->down && (iter->range_cur == (iter->range_end - 1))) ||\n        (!iter->down && (iter->range_cur == (iter->range_end + 1))))\n    {\n      iter->in_range = 0;\n    }\n  }\n  if (!iter->in_range)\n  {\n    iter->substr_cur = iter->substr_end;\n    if (iter->substr_cur == iter->eostr)\n      return 1;\n    while (!*(iter->substr_cur))\n      iter->substr_cur++;\n    iter->substr_end = strchr(iter->substr_cur, ',');\n    if (!iter->substr_end)\n      iter->substr_end = iter->eostr;\n    else\n      *(iter->substr_end) = '\\0';\n    char *range_sep = strchr(iter->substr_cur, ':');\n    if (range_sep)\n      *range_sep++ = '\\0';\n    if (mutt_str_atoui(iter->substr_cur, &iter->range_cur) != 0)\n      return -1;\n    if (range_sep)\n    {\n      if (mutt_str_atoui(range_sep, &iter->range_end) != 0)\n        return -1;\n    }\n    else\n      iter->range_end = iter->range_cur;\n    iter->down = (iter->range_end < iter->range_cur);\n    iter->in_range = 1;\n  }\n  *next = iter->range_cur;\n  if (iter->down)\n    iter->range_cur--;\n  else\n    iter->range_cur++;\n  return 0;\n}", "target": 1}
{"code": "unsigned paravirt_patch_jmp(void *insnbuf, const void *target,\n\t\t\t    unsigned long addr, unsigned len)\n{\n\tstruct branch *b = insnbuf;\n\tunsigned long delta = (unsigned long)target - (addr+5);\n\tif (len < 5)\n\t\treturn len;\t\n\tb->opcode = 0xe9;\t\n\tb->delta = delta;\n\treturn 5;\n}", "target": 1}
{"code": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stb_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "netsnmp_mibindex_load( void )\n{\n    DIR *dir;\n    struct dirent *file;\n    FILE *fp;\n    char tmpbuf[ 300];\n    char tmpbuf2[300];\n    int  i;\n    char *cp;\n    snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes\",\n              get_persistent_directory());\n    tmpbuf[sizeof(tmpbuf)-1] = 0;\n    dir = opendir( tmpbuf );\n    if ( dir == NULL ) {\n        DEBUGMSGTL((\"mibindex\", \"load: (new)\\n\"));\n        mkdirhier( tmpbuf, NETSNMP_AGENT_DIRECTORY_MODE, 0);\n        return;\n    }\n    while ((file = readdir( dir ))) {\n        if ( !isdigit((unsigned char)(file->d_name[0])))\n            continue;\n        i = atoi( file->d_name );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n              get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        fp = fopen( tmpbuf, \"r\" );\n        if (!fp)\n            continue;\n        cp = fgets( tmpbuf2, sizeof(tmpbuf2), fp );\n        fclose( fp );\n        if ( !cp ) {\n            DEBUGMSGTL((\"mibindex\", \"Empty MIB index (%d)\\n\", i));\n            continue;\n        }\n        if ( strncmp( tmpbuf2, \"DIR \", 4 ) != 0 ) {\n            DEBUGMSGTL((\"mibindex\", \"Malformed MIB index (%d)\\n\", i));\n            continue;\n        }\n        tmpbuf2[strlen(tmpbuf2)-1] = 0;\n        DEBUGMSGTL((\"mibindex\", \"load: (%d) %s\\n\", i, tmpbuf2));\n        (void)_mibindex_add( tmpbuf2+4, i );  \n    }\n    closedir( dir );\n}", "target": 1}
{"code": "static int handle_invvpid(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}", "target": 0}
{"code": "static void handle_irq_for_port(evtchn_port_t port)\n{\n\tint irq;\n\tirq = get_evtchn_to_irq(port);\n\tif (irq != -1)\n\t\tgeneric_handle_irq(irq);\n}", "target": 1}
{"code": "bool IsIdentityConsumingSwitch(const MutableGraphView& graph,\n                               const NodeDef& node) {\n  if ((IsIdentity(node) || IsIdentityNSingleInput(node)) &&\n      node.input_size() > 0) {\n    TensorId tensor_id = ParseTensorName(node.input(0));\n    if (IsTensorIdControlling(tensor_id)) {\n      return false;\n    }\n    NodeDef* input_node = graph.GetNode(tensor_id.node());\n    if (input_node == nullptr) {\n      return false;\n    }\n    return IsSwitch(*input_node);\n  }\n  return false;\n}", "target": 0}
{"code": "  Status Init(DataType input_type, const string& fill = \"\", int width = -1,\n              int precision = -1, bool scientific = false,\n              bool shortest = false) {\n    TF_CHECK_OK(NodeDefBuilder(\"op\", \"AsString\")\n                    .Input(FakeInput(input_type))\n                    .Attr(\"fill\", fill)\n                    .Attr(\"precision\", precision)\n                    .Attr(\"scientific\", scientific)\n                    .Attr(\"shortest\", shortest)\n                    .Attr(\"width\", width)\n                    .Finalize(node_def()));\n    return InitOp();\n  }", "target": 0}
{"code": "    void StackMsg::appendLine( char *szLine, bool complete ) {\n        if( complete ) {\n            m_os.flush() ;\n            m_sipMessage = m_os.str() ;\n            m_sipMessage.resize( m_sipMessage.length() - 1) ;\n            boost::replace_all(m_sipMessage, \"\\n\", DR_CRLF);\n        }\n        else if( 0 == strcmp(szLine, \"\\n\") ) {\n            m_os << endl ;\n        }\n        else {\n            int i = 0 ;\n            while( ' ' == szLine[i] && '\\0' != szLine[i]) i++ ;\n            m_os << ( szLine + i ) ;\n        }\n    }", "target": 1}
{"code": "_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  char *last_elem, *wp;\n  last_elem = wp = result;\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n  *wp = '\\0';\n  return result;\n}", "target": 1}
{"code": "static void unqueue_me_pi(struct futex_q *q)\n{\n\tWARN_ON(plist_node_empty(&q->list));\n\tplist_del(&q->list, &q->list.plist);\n\tBUG_ON(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = NULL;\n\tspin_unlock(q->lock_ptr);\n\tdrop_futex_key_refs(&q->key);\n}", "target": 1}
{"code": "static int em_fxsave(struct x86_emulate_ctxt *ctxt)\n{\n\tstruct fxregs_state fx_state;\n\tsize_t size;\n\tint rc;\n\trc = check_fxsr(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->ops->get_fpu(ctxt);\n\trc = asm_safe(\"fxsave %[fx]\", , [fx] \"+m\"(fx_state));\n\tctxt->ops->put_fpu(ctxt);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tif (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)\n\t\tsize = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);\n\telse\n\t\tsize = offsetof(struct fxregs_state, xmm_space[0]);\n\treturn segmented_write(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n   libettercap_init();\n   ef_globals_alloc();\n   select_text_interface();\n   libettercap_ui_init();\n   fprintf(stdout, \"\\n\" EC_COLOR_BOLD \"%s %s\" EC_COLOR_END \" copyright %s %s\\n\\n\", \n                      PROGRAM, EC_VERSION, EC_COPYRIGHT, EC_AUTHORS);\n   EF_GBL->lineno = 1;\n   parse_options(argc, argv);\n   if (EF_GBL_OPTIONS->source_file) {\n      yyin = fopen(EF_GBL_OPTIONS->source_file, \"r\");\n      if (yyin == NULL)\n         FATAL_ERROR(\"Input file not found !\");\n   } else {\n      FATAL_ERROR(\"No source file.\");\n   }\n   setbuf(yyin, NULL);\n   setbuf(stdout, NULL);\n   setbuf(stderr, NULL);\n   load_tables();\n   load_constants();\n   fprintf(stdout, \"\\n Parsing source file \\'%s\\' \", EF_GBL_OPTIONS->source_file);\n   fflush(stdout);\n   ef_debug(1, \"\\n\");\n   if (yyparse() == 0)\n      fprintf(stdout, \" done.\\n\\n\");\n   else\n      fprintf(stdout, \"\\n\\nThe script contains errors...\\n\\n\");\n   if (write_output() != E_SUCCESS)\n      FATAL_ERROR(\"Cannot write output file (%s)\", EF_GBL_OPTIONS->output_file);\n   ef_globals_free();\n   return 0;\n}", "target": 1}
{"code": "Status GraphConstructor::MakeEdge(Node* src, int output_index, Node* dst,\n                                  int input_index) {\n  if (output_index >= src->num_outputs()) {\n    return errors::InvalidArgument(\n        \"Output \", output_index, \" of node \", src->name(),\n        \" does not exist. Node only has \", src->num_outputs(), \" outputs.\");\n  }\n  if (input_index >= dst->num_inputs()) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(),\n        \" does not exist. Node only has \", dst->num_inputs(), \" inputs.\");\n  }\n  DataType src_out = src->output_type(output_index);\n  DataType dst_in = dst->input_type(input_index);\n  if (!TypesCompatible(dst_in, src_out)) {\n    return errors::InvalidArgument(\n        \"Input \", input_index, \" of node \", dst->name(), \" was passed \",\n        DataTypeString(src_out), \" from \", src->name(), \":\", output_index,\n        \" incompatible with expected \", DataTypeString(dst_in), \".\");\n  }\n  g_->AddEdge(src, output_index, dst, input_index);\n  return Status::OK();\n}", "target": 0}
{"code": "static inline int memcmp_P(const void *a1, const void *b1, size_t len) {\n    const uint8_t* a = (const uint8_t*)(a1);\n    uint8_t* b = (uint8_t*)(b1);\n    for (size_t i=0; i<len; i++) {\n        uint8_t d = pgm_read_byte(a) - pgm_read_byte(b);\n        if (d) return d;\n        a++;\n        b++;\n    }\n    return 0;\n}", "target": 0}
{"code": "LibRaw_byte_buffer *LibRaw_abstract_datastream::make_byte_buffer(unsigned int sz)\n{\n  if(INT64(sz)>size())\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(sz);\n    if(!ret) \n      throw LIBRAW_EXCEPTION_ALLOC;\n    read(ret->get_buffer(),sz,1);\n    return ret;\n}", "target": 0}
{"code": "TEST_F(QuicUnencryptedServerTransportTest, DuplicateOneRttWriteCipher) {\n  setupClientReadCodec();\n  recvClientHello();\n  recvClientFinished();\n  loopForWrites();\n  try {\n    recvClientHello();\n    recvClientFinished();\n    FAIL();\n  } catch (const std::runtime_error& ex) {\n    EXPECT_THAT(ex.what(), HasSubstr(\"Crypto error\"));\n  }\n  EXPECT_TRUE(server->isClosed());\n}", "target": 0}
{"code": "wb_id(netdissect_options *ndo,\n      const struct pkt_id *id, u_int len)\n{\n\tint i;\n\tconst char *cp;\n\tconst struct id_off *io;\n\tchar c;\n\tint nid;\n\tND_PRINT((ndo, \" wb-id:\"));\n\tif (len < sizeof(*id) || !ND_TTEST(*id))\n\t\treturn (-1);\n\tlen -= sizeof(*id);\n\tND_PRINT((ndo, \" %u/%s:%u (max %u/%s:%u) \",\n\t       EXTRACT_32BITS(&id->pi_ps.slot),\n\t       ipaddr_string(ndo, &id->pi_ps.page.p_sid),\n\t       EXTRACT_32BITS(&id->pi_ps.page.p_uid),\n\t       EXTRACT_32BITS(&id->pi_mslot),\n\t       ipaddr_string(ndo, &id->pi_mpage.p_sid),\n\t       EXTRACT_32BITS(&id->pi_mpage.p_uid)));\n\tnid = EXTRACT_16BITS(&id->pi_ps.nid);\n\tlen -= sizeof(*io) * nid;\n\tio = (struct id_off *)(id + 1);\n\tcp = (char *)(io + nid);\n\tif (!ND_TTEST2(cp, len)) {\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t\tfn_print(ndo, (u_char *)cp, (u_char *)cp + len);\n\t\tND_PRINT((ndo, \"\\\"\"));\n\t}\n\tc = '<';\n\tfor (i = 0; i < nid && ND_TTEST(*io); ++io, ++i) {\n\t\tND_PRINT((ndo, \"%c%s:%u\",\n\t\t    c, ipaddr_string(ndo, &io->id), EXTRACT_32BITS(&io->off)));\n\t\tc = ',';\n\t}\n\tif (i >= nid) {\n\t\tND_PRINT((ndo, \">\"));\n\t\treturn (0);\n\t}\n\treturn (-1);\n}", "target": 1}
{"code": "struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned int flags,\n\t\t\t\t    int *peeked, int *off, int *err)\n{\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tint error = sock_error(sk);\n\tif (error)\n\t\tgoto no_packet;\n\ttimeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);\n\tdo {\n\t\tunsigned long cpu_flags;\n\t\tstruct sk_buff_head *queue = &sk->sk_receive_queue;\n\t\tspin_lock_irqsave(&queue->lock, cpu_flags);\n\t\tskb_queue_walk(queue, skb) {\n\t\t\t*peeked = skb->peeked;\n\t\t\tif (flags & MSG_PEEK) {\n\t\t\t\tif (*off >= skb->len) {\n\t\t\t\t\t*off -= skb->len;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tskb->peeked = 1;\n\t\t\t\tatomic_inc(&skb->users);\n\t\t\t} else\n\t\t\t\t__skb_unlink(skb, queue);\n\t\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\t\treturn skb;\n\t\t}\n\t\tspin_unlock_irqrestore(&queue->lock, cpu_flags);\n\t\terror = -EAGAIN;\n\t\tif (!timeo)\n\t\t\tgoto no_packet;\n\t} while (!wait_for_packet(sk, err, &timeo));\n\treturn NULL;\nno_packet:\n\t*err = error;\n\treturn NULL;\n}", "target": 1}
{"code": "__delta_head_destroy(struct delta_head **delta_head)\n{\n\tdelta_head_destroy(*delta_head);\n}", "target": 1}
{"code": "CString CZNC::FixupEncoding(const CString& sEncoding) const {\n    if (sEncoding.empty() && m_uiForceEncoding) {\n        return \"UTF-8\";\n    }\n    return sEncoding;\n}", "target": 1}
{"code": "xsltSort(xsltTransformContextPtr ctxt,\n\txmlNodePtr node ATTRIBUTE_UNUSED, xmlNodePtr inst,\n\txsltStylePreCompPtr comp) {\n    if (comp == NULL) {\n\txsltTransformError(ctxt, NULL, inst,\n\t     \"xsl:sort : compilation failed\\n\");\n\treturn;\n    }\n    xsltTransformError(ctxt, NULL, inst,\n\t \"xsl:sort : improper use this should not be reached\\n\");\n}", "target": 0}
{"code": "Cleanup Ipv6Instance::forceProtocolUnsupportedForTest(bool new_val) {\n  bool old_val = force_ipv6_unsupported_for_test;\n  force_ipv6_unsupported_for_test = new_val;\n  return Cleanup([old_val]() { force_ipv6_unsupported_for_test = old_val; });\n}", "target": 0}
{"code": "static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct in6_addr *final_p, final;\n\tstruct flowi6 fl6;\n\tint err = -1;\n\tstruct dst_entry *dst;\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_proto = IPPROTO_DCCP;\n\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\tfl6.saddr = ireq->ir_v6_loc_addr;\n\tfl6.flowlabel = 0;\n\tfl6.flowi6_oif = ireq->ir_iif;\n\tfl6.fl6_dport = ireq->ir_rmt_port;\n\tfl6.fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\tif (IS_ERR(dst)) {\n\t\terr = PTR_ERR(dst);\n\t\tdst = NULL;\n\t\tgoto done;\n\t}\n\tskb = dccp_make_response(sk, dst, req);\n\tif (skb != NULL) {\n\t\tstruct dccp_hdr *dh = dccp_hdr(skb);\n\t\tdh->dccph_checksum = dccp_v6_csum_finish(skb,\n\t\t\t\t\t\t\t &ireq->ir_v6_loc_addr,\n\t\t\t\t\t\t\t &ireq->ir_v6_rmt_addr);\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\terr = ip6_xmit(sk, skb, &fl6, np->opt, np->tclass);\n\t\terr = net_xmit_eval(err);\n\t}\ndone:\n\tdst_release(dst);\n\treturn err;\n}", "target": 1}
{"code": "void gdImageCopyMerge (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int w, int h, int pct)\n{\n\tint c, dc;\n\tint x, y;\n\tint tox, toy;\n\tint ncR, ncG, ncB;\n\ttoy = dstY;\n\tfor (y = srcY; y < (srcY + h); y++) {\n\t\ttox = dstX;\n\t\tfor (x = srcX; x < (srcX + w); x++) {\n\t\t\tint nc;\n\t\t\tc = gdImageGetPixel(src, x, y);\n\t\t\tif (gdImageGetTransparent(src) == c) {\n\t\t\t\ttox++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (dst == src) {\n\t\t\t\tnc = c;\n\t\t\t} else {\n\t\t\t\tdc = gdImageGetPixel(dst, tox, toy);\n \t\t\t\tncR = (int)(gdImageRed (src, c) * (pct / 100.0) + gdImageRed (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncG = (int)(gdImageGreen (src, c) * (pct / 100.0) + gdImageGreen (dst, dc) * ((100 - pct) / 100.0));\n \t\t\t\tncB = (int)(gdImageBlue (src, c) * (pct / 100.0) + gdImageBlue (dst, dc) * ((100 - pct) / 100.0));\n\t\t\t\tnc = gdImageColorResolve (dst, ncR, ncG, ncB);\n\t\t\t}\n\t\t\tgdImageSetPixel (dst, tox, toy, nc);\n\t\t\ttox++;\n\t\t}\n\t\ttoy++;\n\t}\n}", "target": 1}
{"code": "flatpak_bwrap_envp_to_args (FlatpakBwrap *bwrap)\n{\n  gsize i;\n  for (i = 0; bwrap->envp[i] != NULL; i++)\n    {\n      char *key_val = bwrap->envp[i];\n      char *eq = strchr (key_val, '=');\n      if (eq)\n        {\n          flatpak_bwrap_add_arg (bwrap, \"--setenv\");\n          flatpak_bwrap_take_arg (bwrap, g_strndup (key_val, eq - key_val));\n          flatpak_bwrap_add_arg (bwrap, eq + 1);\n        }\n      else\n        {\n          g_warn_if_reached ();\n        }\n    }\n  g_strfreev (g_steal_pointer (&bwrap->envp));\n  bwrap->envp = g_strdupv (flatpak_bwrap_empty_env);\n}", "target": 0}
{"code": "static ssize_t o2nm_node_num_store(struct config_item *item, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tint ret = 0;\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; \n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_NUM,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}", "target": 1}
{"code": "static void snd_timer_proc_read(struct snd_info_entry *entry,\n\t\t\t\tstruct snd_info_buffer *buffer)\n{\n\tstruct snd_timer *timer;\n\tstruct snd_timer_instance *ti;\n\tmutex_lock(&register_mutex);\n\tlist_for_each_entry(timer, &snd_timer_list, device_list) {\n\t\tif (timer->card && timer->card->shutdown)\n\t\t\tcontinue;\n\t\tswitch (timer->tmr_class) {\n\t\tcase SNDRV_TIMER_CLASS_GLOBAL:\n\t\t\tsnd_iprintf(buffer, \"G%i: \", timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_CARD:\n\t\t\tsnd_iprintf(buffer, \"C%i-%i: \",\n\t\t\t\t    timer->card->number, timer->tmr_device);\n\t\t\tbreak;\n\t\tcase SNDRV_TIMER_CLASS_PCM:\n\t\t\tsnd_iprintf(buffer, \"P%i-%i-%i: \", timer->card->number,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsnd_iprintf(buffer, \"?%i-%i-%i-%i: \", timer->tmr_class,\n\t\t\t\t    timer->card ? timer->card->number : -1,\n\t\t\t\t    timer->tmr_device, timer->tmr_subdevice);\n\t\t}\n\t\tsnd_iprintf(buffer, \"%s :\", timer->name);\n\t\tif (timer->hw.resolution)\n\t\t\tsnd_iprintf(buffer, \" %lu.%03luus (%lu ticks)\",\n\t\t\t\t    timer->hw.resolution / 1000,\n\t\t\t\t    timer->hw.resolution % 1000,\n\t\t\t\t    timer->hw.ticks);\n\t\tif (timer->hw.flags & SNDRV_TIMER_HW_SLAVE)\n\t\t\tsnd_iprintf(buffer, \" SLAVE\");\n\t\tsnd_iprintf(buffer, \"\\n\");\n\t\tlist_for_each_entry(ti, &timer->open_list_head, open_list)\n\t\t\tsnd_iprintf(buffer, \"  Client %s : %s\\n\",\n\t\t\t\t    ti->owner ? ti->owner : \"unknown\",\n\t\t\t\t    ti->flags & (SNDRV_TIMER_IFLG_START |\n\t\t\t\t\t\t SNDRV_TIMER_IFLG_RUNNING)\n\t\t\t\t    ? \"running\" : \"stopped\");\n\t}\n\tmutex_unlock(&register_mutex);\n}", "target": 0}
{"code": "static void process_event_record(MYSQL_THD thd, LEX_CSTRING event_name,\n                                 const char *data, size_t data_length)\n{\n  const char *record_str = (const char *)THDVAR(thd, event_record_def);\n  LEX_CSTRING record_begin = get_token(&record_str);\n  LEX_CSTRING record_end = get_token(&record_str);\n  if (record_str == NULL)\n  {\n    return;\n  }\n  if (record_end.length == 0)\n  {\n    const char *buffer= THDVAR(thd, event_record);\n    add_event(thd, buffer, event_name, data, data_length);\n    my_free((void *)(buffer));\n    if (!my_charset_latin1.coll->strnncoll(&my_charset_latin1,\n                                           (const uchar *)record_begin.str,\n                                           record_begin.length,\n                                           (const uchar *)event_name.str,\n                                           event_name.length, FALSE))\n    {\n      THDVAR(thd, event_record_def)= 0;\n    }\n  }\n  else\n  {\n    const char *buffer;\n    if (my_charset_latin1.coll->strnncoll(&my_charset_latin1,\n                                          (const uchar *)record_begin.str,\n                                          record_begin.length,\n                                          (const uchar *)event_name.str,\n                                          event_name.length, FALSE))\n    {\n      return;\n    }\n    buffer= THDVAR(thd, event_record);\n    my_free((void *)(buffer));\n    THDVAR(thd, event_record)= 0;\n    add_event(thd, \"\", event_name, data, data_length);\n    record_str = (const char *)THDVAR(thd, event_record_def);\n    memmove((char *)record_str, (void *)record_end.str, record_end.length + 1);\n  }\n}", "target": 0}
{"code": "UrlQuery::UrlQuery(const std::string& encoded_str) {\n  if (!encoded_str.empty()) {\n    for (std::size_t i = 0; i != std::string::npos;) {\n      std::size_t j = encoded_str.find_first_of('&', i);\n      std::string kv;\n      if (j == std::string::npos) {\n        kv = encoded_str.substr(i);\n        i = std::string::npos;\n      } else {\n        kv = encoded_str.substr(i, j - i);\n        i = j + 1;\n      }\n      string_view key;\n      string_view value;\n      if (SplitKV(kv, '=', false, &key, &value)) {\n        parameters_.push_back({ DecodeUnsafe(key), DecodeUnsafe(value) });\n      }\n    }\n  }\n}", "target": 1}
{"code": "gx_default_include_color_space(gx_device *pdev, gs_color_space *cspace,\n        const byte *res_name, int name_length)\n{\n    return 0;\n}", "target": 0}
{"code": "int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  char **_filter, char ***_domains)\n{\n    int ret;\n    struct match_map_rule *r;\n    struct priority_list *p;\n    struct sss_cert_content *cert_content = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    size_t c;\n    if (_filter == NULL || _domains == NULL) {\n        return EINVAL;\n    }\n    ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content);\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to get certificate content [%d].\", ret);\n        return ret;\n    }\n    if (ctx->prio_list == NULL) {\n        if (ctx->default_mapping_rule == NULL) {\n            CM_DEBUG(ctx, \"No matching or mapping rules available.\");\n            return EINVAL;\n        }\n        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, &filter);\n        goto done;\n    }\n    for (p = ctx->prio_list; p != NULL; p = p->next) {\n        for (r = p->rule_list; r != NULL; r = r->next) {\n            ret = do_match(ctx, r->parsed_match_rule, cert_content);\n            if (ret == 0) {\n                ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n                                 &filter);\n                if (ret != 0) {\n                    CM_DEBUG(ctx, \"Failed to get filter\");\n                    goto done;\n                }\n                if (r->domains != NULL) {\n                    for (c = 0; r->domains[c] != NULL; c++);\n                    domains = talloc_zero_array(ctx, char *, c + 1);\n                    if (domains == NULL) {\n                        ret = ENOMEM;\n                        goto done;\n                    }\n                    for (c = 0; r->domains[c] != NULL; c++) {\n                        domains[c] = talloc_strdup(domains, r->domains[c]);\n                        if (domains[c] == NULL) {\n                            ret = ENOMEM;\n                            goto done;\n                        }\n                    }\n                }\n                ret = 0;\n                goto done;\n            }\n        }\n    }\n    ret = ENOENT;\ndone:\n    talloc_free(cert_content);\n    if (ret == 0) {\n        *_filter = filter;\n        *_domains = domains;\n    } else {\n        talloc_free(filter);\n        talloc_free(domains);\n    }\n    return ret;\n}", "target": 1}
{"code": "goto_tabpage_tp(\n    tabpage_T\t*tp,\n    int\t\ttrigger_enter_autocmds,\n    int\t\ttrigger_leave_autocmds)\n{\n    set_keep_msg(NULL, 0);\n    if (tp != curtab && leave_tabpage(tp->tp_curwin->w_buffer,\n\t\t\t\t\ttrigger_leave_autocmds) == OK)\n    {\n\tif (valid_tabpage(tp))\n\t    enter_tabpage(tp, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n\telse\n\t    enter_tabpage(curtab, curbuf, trigger_enter_autocmds,\n\t\t    trigger_leave_autocmds);\n    }\n}", "target": 0}
{"code": "static int check_client_redirect_uri_valid(struct _oidc_config * config,\n                                           const char * client_id,\n                                           const char * redirect_uri,\n                                           const char * ip_source) {\n  json_t * j_client = config->glewlwyd_config->glewlwyd_plugin_callback_get_client(config->glewlwyd_config, client_id);\n  int uri_found = 0, ret;\n  if (check_result_value(j_client, G_OK) && json_object_get(json_object_get(j_client, \"client\"), \"enabled\") == json_true()) {\n    if (!o_strnullempty(redirect_uri)) {\n      if (json_array_has_string(json_object_get(json_object_get(j_client, \"client\"), \"redirect_uri\"), redirect_uri)) {\n        uri_found = 1;\n      } else {\n        uri_found = 0;\n      }\n    } else {\n      uri_found = 1;\n    }\n    if (!uri_found) {\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_client_redirect_uri_valid - oidc - Error, redirect_uri '%s' is invalid for the client '%s', origin: %s\", redirect_uri, client_id, ip_source);\n      ret = G_ERROR_UNAUTHORIZED;\n    } else {\n      ret = G_OK;\n    }\n  } else {\n    ret = G_ERROR_UNAUTHORIZED;\n  }\n  json_decref(j_client);\n  return ret;\n}", "target": 1}
{"code": "bool RenderViewImpl::isPointerLocked() {\n  return mouse_lock_dispatcher_->IsMouseLockedTo(\n      webwidget_mouse_lock_target_.get());\n }", "target": 0}
{"code": "static OPJ_BOOL opj_tcd_code_block_enc_allocate_data(opj_tcd_cblk_enc_t *\n        p_code_block)\n{\n    OPJ_UINT32 l_data_size;\n    l_data_size = 2 + (OPJ_UINT32)((p_code_block->x1 - p_code_block->x0) *\n                                   (p_code_block->y1 - p_code_block->y0) * (OPJ_INT32)sizeof(OPJ_UINT32));\n    if (l_data_size > p_code_block->data_size) {\n        if (p_code_block->data) {\n            opj_free(p_code_block->data - 1);\n        }\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(l_data_size + 1);\n        if (! p_code_block->data) {\n            p_code_block->data_size = 0U;\n            return OPJ_FALSE;\n        }\n        p_code_block->data_size = l_data_size;\n        p_code_block->data[0] = 0;\n        p_code_block->data += 1; \n    }\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "get_authname(int type)\n{\n\tstatic char buf[1024];\n\tswitch (type) {\n\tcase SSH_CMSG_AUTH_PASSWORD:\n\t\treturn \"password\";\n\tcase SSH_CMSG_AUTH_RSA:\n\t\treturn \"rsa\";\n\tcase SSH_CMSG_AUTH_RHOSTS_RSA:\n\t\treturn \"rhosts-rsa\";\n\tcase SSH_CMSG_AUTH_RHOSTS:\n\t\treturn \"rhosts\";\n\tcase SSH_CMSG_AUTH_TIS:\n\tcase SSH_CMSG_AUTH_TIS_RESPONSE:\n\t\treturn \"challenge-response\";\n#if defined(KRB4) || defined(KRB5)\n\tcase SSH_CMSG_AUTH_KERBEROS:\n\t\treturn \"kerberos\";\n#endif\n\t}\n\tsnprintf(buf, sizeof buf, \"bad-auth-msg-%d\", type);\n\treturn buf;\n}", "target": 0}
{"code": "bool AudioContext::isAudioThread() const\n{\n    return currentThread() == m_audioThread;\n}", "target": 0}
{"code": "static int irda_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tstruct irda_sock *self;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\tif (net != &init_net)\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:     \n\tcase SOCK_SEQPACKET:  \n\tcase SOCK_DGRAM:      \n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_IRDA, GFP_KERNEL, &irda_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tself = irda_sk(sk);\n\tpr_debug(\"%s() : self is %p\\n\", __func__, self);\n\tinit_waitqueue_head(&self->query_wait);\n\tswitch (sock->type) {\n\tcase SOCK_STREAM:\n\t\tsock->ops = &irda_stream_ops;\n\t\tself->max_sdu_size_rx = TTP_SAR_DISABLE;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tsock->ops = &irda_seqpacket_ops;\n\t\tself->max_sdu_size_rx = TTP_SAR_UNBOUND;\n\t\tbreak;\n\tcase SOCK_DGRAM:\n\t\tswitch (protocol) {\n#ifdef CONFIG_IRDA_ULTRA\n\t\tcase IRDAPROTO_ULTRA:\n\t\t\tsock->ops = &irda_ultra_ops;\n\t\t\tself->max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER;\n\t\t\tself->max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER;\n\t\t\tbreak;\n#endif \n\t\tcase IRDAPROTO_UNITDATA:\n\t\t\tsock->ops = &irda_dgram_ops;\n\t\t\tself->max_sdu_size_rx = TTP_SAR_UNBOUND;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsk_free(sk);\n\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tsk_free(sk);\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsock_init_data(sock, sk);\t\n\tsk->sk_family = PF_IRDA;\n\tsk->sk_protocol = protocol;\n\tself->ckey = irlmp_register_client(0, NULL, NULL, NULL);\n\tself->mask.word = 0xffff;\n\tself->rx_flow = self->tx_flow = FLOW_START;\n\tself->nslots = DISCOVERY_DEFAULT_SLOTS;\n\tself->daddr = DEV_ADDR_ANY;\t\n\tself->saddr = 0x0;\t\t\n\treturn 0;\n}", "target": 0}
{"code": "sds *ldbReplParseCommand(int *argcp) {\n    sds *argv = NULL;\n    int argc = 0;\n    if (sdslen(ldb.cbuf) == 0) return NULL;\n    sds copy = sdsdup(ldb.cbuf);\n    char *p = copy;\n    p = strchr(p,'*'); if (!p) goto protoerr;\n    char *plen = p+1; \n    p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n    *p = '\\0'; p += 2;\n    *argcp = atoi(plen);\n    if (*argcp <= 0 || *argcp > 1024) goto protoerr;\n    argv = zmalloc(sizeof(sds)*(*argcp));\n    argc = 0;\n    while(argc < *argcp) {\n        if (*p != '$') goto protoerr;\n        plen = p+1; \n        p = strstr(p,\"\\r\\n\"); if (!p) goto protoerr;\n        *p = '\\0'; p += 2;\n        int slen = atoi(plen); \n        if (slen <= 0 || slen > 1024) goto protoerr;\n        argv[argc++] = sdsnewlen(p,slen);\n        p += slen; \n        if (p[0] != '\\r' || p[1] != '\\n') goto protoerr;\n        p += 2; \n    }\n    sdsfree(copy);\n    return argv;\nprotoerr:\n    sdsfreesplitres(argv,argc);\n    sdsfree(copy);\n    return NULL;\n}", "target": 1}
{"code": "snmp_api_set_oid(snmp_varbind_t *varbind, uint32_t *oid, uint32_t *ret_oid)\n{\n  snmp_api_replace_oid(varbind, oid);\n  varbind->value_type = BER_DATA_TYPE_OID;\n  varbind->value.oid = ret_oid;\n}", "target": 1}
{"code": "EXPORTED int http_allow_noauth_get(struct transaction_t *txn)\n{\n    switch (txn->meth) {\n    case METH_GET:\n    case METH_HEAD:\n        return 0;\n    default:\n        return 1;\n    }\n}", "target": 0}
{"code": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlSchemaPtr schema;\n  xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  VALUE rb_schema;\n  VALUE errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n   schema = xmlSchemaParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\tif (KVM_BUG_ON(!lapic_in_kernel(vcpu), vcpu->kvm))\n\t\treturn -EINVAL;\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}", "target": 0}
{"code": "void *UntrustedCacheMalloc::GetBuffer() {\n  void **buffers = nullptr;\n  void *buffer;\n  bool is_pool_empty;\n  {\n    LockGuard spin_lock(&lock_);\n    is_pool_empty = buffer_pool_.empty();\n    if (is_pool_empty) {\n      buffers =\n          primitives::AllocateUntrustedBuffers(kPoolIncrement, kPoolEntrySize);\n      for (int i = 0; i < kPoolIncrement; i++) {\n        if (!buffers[i] ||\n            !TrustedPrimitives::IsOutsideEnclave(buffers[i], kPoolEntrySize)) {\n          abort();\n        }\n        buffer_pool_.push(buffers[i]);\n      }\n    }\n    buffer = buffer_pool_.top();\n    buffer_pool_.pop();\n    busy_buffers_.insert(buffer);\n  }\n  if (is_pool_empty) {\n    Free(buffers);\n  }\n  return buffer;\n}", "target": 1}
{"code": "int count_mounts(struct mnt_namespace *ns, struct mount *mnt)\n{\n\tunsigned int max = READ_ONCE(sysctl_mount_max);\n\tunsigned int mounts = 0, old, pending, sum;\n\tstruct mount *p;\n\tfor (p = mnt; p; p = next_mnt(p, mnt))\n\t\tmounts++;\n\told = ns->mounts;\n\tpending = ns->pending_mounts;\n\tsum = old + pending;\n\tif ((old > sum) ||\n\t    (pending > sum) ||\n\t    (max < sum) ||\n\t    (mounts > (max - sum)))\n\t\treturn -ENOSPC;\n\tns->pending_mounts = pending + mounts;\n\treturn 0;\n}", "target": 0}
{"code": "ext4_xattr_cache_find(struct inode *inode, struct ext4_xattr_header *header,\n\t\t      struct mb_cache_entry **pce)\n{\n\t__u32 hash = le32_to_cpu(header->h_hash);\n\tstruct mb_cache_entry *ce;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tif (!header->h_hash)\n\t\treturn NULL;  \n\tea_idebug(inode, \"looking for cached blocks [%x]\", (int)hash);\nagain:\n\tce = mb_cache_entry_find_first(ext4_mb_cache, inode->i_sb->s_bdev,\n\t\t\t\t       hash);\n\twhile (ce) {\n\t\tstruct buffer_head *bh;\n\t\tif (IS_ERR(ce)) {\n\t\t\tif (PTR_ERR(ce) == -EAGAIN)\n\t\t\t\tgoto again;\n\t\t\tbreak;\n\t\t}\n\t\tbh = sb_bread(inode->i_sb, ce->e_block);\n\t\tif (!bh) {\n\t\t\tEXT4_ERROR_INODE(inode, \"block %lu read error\",\n\t\t\t\t\t (unsigned long) ce->e_block);\n\t\t} else if (le32_to_cpu(BHDR(bh)->h_refcount) >=\n\t\t\t\tEXT4_XATTR_REFCOUNT_MAX) {\n\t\t\tea_idebug(inode, \"block %lu refcount %d>=%d\",\n\t\t\t\t  (unsigned long) ce->e_block,\n\t\t\t\t  le32_to_cpu(BHDR(bh)->h_refcount),\n\t\t\t\t\t  EXT4_XATTR_REFCOUNT_MAX);\n\t\t} else if (ext4_xattr_cmp(header, BHDR(bh)) == 0) {\n\t\t\t*pce = ce;\n\t\t\treturn bh;\n\t\t}\n\t\tbrelse(bh);\n\t\tce = mb_cache_entry_find_next(ce, inode->i_sb->s_bdev, hash);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static void expire_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);\n\tif (likely((s64)(rq_clock(rq_of(cfs_rq)) - cfs_rq->runtime_expires) < 0))\n\t\treturn;\n\tif (cfs_rq->runtime_remaining < 0)\n\t\treturn;\n\tif (cfs_rq->expires_seq == cfs_b->expires_seq) {\n\t\tcfs_rq->runtime_expires += TICK_NSEC;\n\t} else {\n\t\tcfs_rq->runtime_remaining = 0;\n\t}\n}", "target": 1}
{"code": "static int mbochs_probe(struct mdev_device *mdev)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mdev_get_type_group_id(mdev)];\n\tstruct device *dev = mdev_dev(mdev);\n\tstruct mdev_state *mdev_state;\n\tint ret = -ENOMEM;\n\tif (type->mbytes + mbochs_used_mbytes > max_mbytes)\n\t\treturn -ENOMEM;\n\tmdev_state = kzalloc(sizeof(struct mdev_state), GFP_KERNEL);\n\tif (mdev_state == NULL)\n\t\treturn -ENOMEM;\n\tvfio_init_group_dev(&mdev_state->vdev, &mdev->dev, &mbochs_dev_ops);\n\tmdev_state->vconfig = kzalloc(MBOCHS_CONFIG_SPACE_SIZE, GFP_KERNEL);\n\tif (mdev_state->vconfig == NULL)\n\t\tgoto err_mem;\n\tmdev_state->memsize = type->mbytes * 1024 * 1024;\n\tmdev_state->pagecount = mdev_state->memsize >> PAGE_SHIFT;\n\tmdev_state->pages = kcalloc(mdev_state->pagecount,\n\t\t\t\t    sizeof(struct page *),\n\t\t\t\t    GFP_KERNEL);\n\tif (!mdev_state->pages)\n\t\tgoto err_mem;\n\tdev_info(dev, \"%s: %s, %d MB, %ld pages\\n\", __func__,\n\t\t type->name, type->mbytes, mdev_state->pagecount);\n\tmutex_init(&mdev_state->ops_lock);\n\tmdev_state->mdev = mdev;\n\tINIT_LIST_HEAD(&mdev_state->dmabufs);\n\tmdev_state->next_id = 1;\n\tmdev_state->type = type;\n\tmdev_state->edid_regs.max_xres = type->max_x;\n\tmdev_state->edid_regs.max_yres = type->max_y;\n\tmdev_state->edid_regs.edid_offset = MBOCHS_EDID_BLOB_OFFSET;\n\tmdev_state->edid_regs.edid_max_size = sizeof(mdev_state->edid_blob);\n\tmbochs_create_config_space(mdev_state);\n\tmbochs_reset(mdev_state);\n\tmbochs_used_mbytes += type->mbytes;\n\tret = vfio_register_group_dev(&mdev_state->vdev);\n\tif (ret)\n\t\tgoto err_mem;\n\tdev_set_drvdata(&mdev->dev, mdev_state);\n\treturn 0;\nerr_mem:\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n\treturn ret;\n}", "target": 1}
{"code": "static uint jsi_SizeOfArray(Jsi_Interp *interp, Jsi_Obj *obj) {\n    if (!obj || !obj->arr)\n        return 0;\n    return obj->arrCnt;\n}", "target": 0}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, (xmlHashDeallocator) xmlFreeID);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}", "target": 0}
{"code": "spnego_gss_inquire_context(\n\t\t\tOM_uint32\t*minor_status,\n\t\t\tconst gss_ctx_id_t context_handle,\n\t\t\tgss_name_t\t*src_name,\n\t\t\tgss_name_t\t*targ_name,\n\t\t\tOM_uint32\t*lifetime_rec,\n\t\t\tgss_OID\t\t*mech_type,\n\t\t\tOM_uint32\t*ctx_flags,\n\t\t\tint\t\t*locally_initiated,\n\t\t\tint\t\t*opened)\n{\n\tOM_uint32 ret = GSS_S_COMPLETE;\n\tret = gss_inquire_context(minor_status,\n\t\t\t\tcontext_handle,\n\t\t\t\tsrc_name,\n\t\t\t\ttarg_name,\n\t\t\t\tlifetime_rec,\n\t\t\t\tmech_type,\n\t\t\t\tctx_flags,\n\t\t\t\tlocally_initiated,\n\t\t\t\topened);\n\treturn (ret);\n}", "target": 1}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document, \n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"xreader-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp, \n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 1}
{"code": "batchCopyElem(batch_obj_t *pDest, batch_obj_t *pSrc) {\n\tmemcpy(pDest, pSrc, sizeof(batch_obj_t));\n}", "target": 1}
{"code": "static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, u32 features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tunsigned int mss;\n\tunsigned int unfrag_ip6hlen, unfrag_len;\n\tstruct frag_hdr *fptr;\n\tu8 *mac_start, *prevhdr;\n\tu8 nexthdr;\n\tu8 frag_hdr_sz = sizeof(struct frag_hdr);\n\tint offset;\n\t__wsum csum;\n\tmss = skb_shinfo(skb)->gso_size;\n\tif (unlikely(skb->len <= mss))\n\t\tgoto out;\n\tif (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) {\n\t\tint type = skb_shinfo(skb)->gso_type;\n\t\tif (unlikely(type & ~(SKB_GSO_UDP | SKB_GSO_DODGY) ||\n\t\t\t     !(type & (SKB_GSO_UDP))))\n\t\t\tgoto out;\n\t\tskb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss);\n\t\tsegs = NULL;\n\t\tgoto out;\n\t}\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +\n\t\t     unfrag_ip6hlen;\n\tmac_start = skb_mac_header(skb);\n\tmemmove(mac_start-frag_hdr_sz, mac_start, unfrag_len);\n\tskb->mac_header -= frag_hdr_sz;\n\tskb->network_header -= frag_hdr_sz;\n\tfptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen);\n\tfptr->nexthdr = nexthdr;\n\tfptr->reserved = 0;\n\tipv6_select_ident(fptr);\n\tsegs = skb_segment(skb, features);\nout:\n\treturn segs;\n}", "target": 1}
{"code": "bool InstanceKlass::remove_osr_nmethod(nmethod* n) {\n  MutexLockerEx ml(OsrList_lock, Mutex::_no_safepoint_check_flag);\n  assert(n->is_osr_method(), \"wrong kind of nmethod\");\n  nmethod* last = NULL;\n  nmethod* cur  = osr_nmethods_head();\n  int max_level = CompLevel_none;  \n  Method* m = n->method();\n  bool found = false;\n  while(cur != NULL && cur != n) {\n    if (TieredCompilation && m == cur->method()) {\n      max_level = MAX2(max_level, cur->comp_level());\n    }\n    last = cur;\n    cur = cur->osr_link();\n  }\n  nmethod* next = NULL;\n  if (cur == n) {\n    found = true;\n    next = cur->osr_link();\n    if (last == NULL) {\n      set_osr_nmethods_head(next);\n    } else {\n      last->set_osr_link(next);\n    }\n  }\n  n->set_osr_link(NULL);\n  if (TieredCompilation) {\n    cur = next;\n    while (cur != NULL) {\n      if (m == cur->method()) {\n        max_level = MAX2(max_level, cur->comp_level());\n      }\n      cur = cur->osr_link();\n    }\n    m->set_highest_osr_comp_level(max_level);\n  }\n  return found;\n}", "target": 0}
{"code": "xfs_attr_shortform_addname(xfs_da_args_t *args)\n{\n\tint newsize, forkoff, retval;\n\ttrace_xfs_attr_sf_addname(args);\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);\n\tif (!forkoff)\n\t\treturn -ENOSPC;\n\txfs_attr_shortform_add(args, forkoff);\n\treturn 0;\n}", "target": 1}
{"code": "static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)\n{\n\tswitch (mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tif (l2cap_mode_supported(mode, remote_feat_mask))\n\t\t\treturn mode;\n\tdefault:\n\t\treturn L2CAP_MODE_BASIC;\n\t}\n}", "target": 0}
{"code": "usage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}", "target": 1}
{"code": "static int cma_accept_iw(struct rdma_id_private *id_priv,\n\t\t  struct rdma_conn_param *conn_param)\n{\n\tstruct iw_cm_conn_param iw_param;\n\tint ret;\n\tif (!conn_param)\n\t\treturn -EINVAL;\n\tret = cma_modify_qp_rtr(id_priv, conn_param);\n\tif (ret)\n\t\treturn ret;\n\tiw_param.ord = conn_param->initiator_depth;\n\tiw_param.ird = conn_param->responder_resources;\n\tiw_param.private_data = conn_param->private_data;\n\tiw_param.private_data_len = conn_param->private_data_len;\n\tif (id_priv->id.qp)\n\t\tiw_param.qpn = id_priv->qp_num;\n\telse\n\t\tiw_param.qpn = conn_param->qp_num;\n\treturn iw_cm_accept(id_priv->cm_id.iw, &iw_param);\n}", "target": 0}
{"code": "  virtual void DisconnectFromWirelessNetwork(const WirelessNetwork* network) {\n    DCHECK(network);\n    if (!EnsureCrosLoaded() || !network)\n      return;\n    if (DisconnectFromNetwork(network->service_path().c_str())) {\n      if (network->type() == TYPE_WIFI) {\n        WifiNetwork* wifi = GetWirelessNetworkByPath(\n            wifi_networks_, network->service_path());\n        if (wifi) {\n          wifi->set_connected(false);\n          wifi_ = NULL;\n        }\n      } else if (network->type() == TYPE_CELLULAR) {\n        CellularNetwork* cellular = GetWirelessNetworkByPath(\n            cellular_networks_, network->service_path());\n        if (cellular) {\n          cellular->set_connected(false);\n          cellular_ = NULL;\n        }\n      }\n      NotifyNetworkManagerChanged();\n    }\n  }", "target": 0}
{"code": "static int jsR_hasproperty(js_State *J, js_Object *obj, const char *name)\n{\n\tjs_Property *ref;\n\tint k;\n\tif (obj->type == JS_CARRAY) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.a.length);\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (obj->type == JS_CSTRING) {\n\t\tif (!strcmp(name, \"length\")) {\n\t\t\tjs_pushnumber(J, obj->u.s.length);\n\t\t\treturn 1;\n\t\t}\n\t\tif (js_isarrayindex(J, name, &k)) {\n\t\t\tif (k >= 0 && k < obj->u.s.length) {\n\t\t\t\tjs_pushrune(J, js_runeat(J, obj->u.s.string, k));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\telse if (obj->type == JS_CREGEXP) {\n\t\tif (!strcmp(name, \"source\")) {\n\t\t\tjs_pushliteral(J, obj->u.r.source);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"global\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_G);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"ignoreCase\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_I);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"multiline\")) {\n\t\t\tjs_pushboolean(J, obj->u.r.flags & JS_REGEXP_M);\n\t\t\treturn 1;\n\t\t}\n\t\tif (!strcmp(name, \"lastIndex\")) {\n\t\t\tjs_pushnumber(J, obj->u.r.last);\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if (obj->type == JS_CUSERDATA) {\n\t\tif (obj->u.user.has && obj->u.user.has(J, obj->u.user.data, name))\n\t\t\treturn 1;\n\t}\n\tref = jsV_getproperty(J, obj, name);\n\tif (ref) {\n\t\tif (ref->getter) {\n\t\t\tjs_pushobject(J, ref->getter);\n\t\t\tjs_pushobject(J, obj);\n\t\t\tjs_call(J, 0);\n\t\t} else {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(\"kadm5_modify_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_modify_principal((void *)handle, &arg->rec,\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static int crypto_aead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"aead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t aead->geniv ?: \"<built-in>\");\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static int do_i2c_read(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc != 5)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\tdevaddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n\tlength = hextoul(argv[3], NULL);\n\tmemaddr = (u_char *)hextoul(argv[4], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (!ret)\n\t\tret = dm_i2c_read(dev, devaddr, memaddr, length);\n#else\n\tret = i2c_read(chip, devaddr, alen, memaddr, length);\n#endif\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_READ);\n\treturn 0;\n}", "target": 1}
{"code": "  bool IsSupported(const NodeDef* node) const override {\n    if (!node || node->input_size() < 2) {\n      return false;\n    }\n    return IsAnyMul(*node) && node->input(0) == node->input(1);\n  }", "target": 0}
{"code": "void jfs_evict_inode(struct inode *inode)\n{\n\tstruct jfs_inode_info *ji = JFS_IP(inode);\n\tjfs_info(\"In jfs_evict_inode, inode = 0x%p\", inode);\n\tif (!inode->i_nlink && !is_bad_inode(inode)) {\n\t\tdquot_initialize(inode);\n\t\tif (JFS_IP(inode)->fileset == FILESYSTEM_I) {\n\t\t\ttruncate_inode_pages_final(&inode->i_data);\n\t\t\tif (test_cflag(COMMIT_Freewmap, inode))\n\t\t\t\tjfs_free_zero_link(inode);\n\t\t\tif (JFS_SBI(inode->i_sb)->ipimap)\n\t\t\t\tdiFree(inode);\n\t\t\tdquot_free_inode(inode);\n\t\t}\n\t} else {\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\t}\n\tclear_inode(inode);\n\tdquot_drop(inode);\n\tBUG_ON(!list_empty(&ji->anon_inode_list));\n\tspin_lock_irq(&ji->ag_lock);\n\tif (ji->active_ag != -1) {\n\t\tstruct bmap *bmap = JFS_SBI(inode->i_sb)->bmap;\n\t\tatomic_dec(&bmap->db_active[ji->active_ag]);\n\t\tji->active_ag = -1;\n\t}\n\tspin_unlock_irq(&ji->ag_lock);\n}", "target": 1}
{"code": "static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_l2tpip *addr = (struct sockaddr_l2tpip *) uaddr;\n\tstruct net *net = sock_net(sk);\n\tint ret;\n\tint chk_addr_ret;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_l2tpip))\n\t\treturn -EINVAL;\n\tif (addr->l2tp_family != AF_INET)\n\t\treturn -EINVAL;\n\tret = -EADDRINUSE;\n\tread_lock_bh(&l2tp_ip_lock);\n\tif (__l2tp_ip_bind_lookup(net, addr->l2tp_addr.s_addr,\n\t\t\t\t  sk->sk_bound_dev_if, addr->l2tp_conn_id))\n\t\tgoto out_in_use;\n\tread_unlock_bh(&l2tp_ip_lock);\n\tlock_sock(sk);\n\tif (sk->sk_state != TCP_CLOSE || addr_len < sizeof(struct sockaddr_l2tpip))\n\t\tgoto out;\n\tchk_addr_ret = inet_addr_type(net, addr->l2tp_addr.s_addr);\n\tret = -EADDRNOTAVAIL;\n\tif (addr->l2tp_addr.s_addr && chk_addr_ret != RTN_LOCAL &&\n\t    chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST)\n\t\tgoto out;\n\tif (addr->l2tp_addr.s_addr)\n\t\tinet->inet_rcv_saddr = inet->inet_saddr = addr->l2tp_addr.s_addr;\n\tif (chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST)\n\t\tinet->inet_saddr = 0;  \n\tsk_dst_reset(sk);\n\tl2tp_ip_sk(sk)->conn_id = addr->l2tp_conn_id;\n\twrite_lock_bh(&l2tp_ip_lock);\n\tsk_add_bind_node(sk, &l2tp_ip_bind_table);\n\tsk_del_node_init(sk);\n\twrite_unlock_bh(&l2tp_ip_lock);\n\tret = 0;\n\tsock_reset_flag(sk, SOCK_ZAPPED);\nout:\n\trelease_sock(sk);\n\treturn ret;\nout_in_use:\n\tread_unlock_bh(&l2tp_ip_lock);\n\treturn ret;\n}", "target": 1}
{"code": "void testPartialDataHandling(const T& val, size_t bytesToPassTheCheck) {\n  auto buf = Serializer::template serialize<folly::IOBufQueue>(val).move();\n  buf->coalesce();\n  EXPECT_NO_THROW(Serializer::template deserialize<T>(buf.get()));\n  buf->trimEnd(buf->length() - bytesToPassTheCheck);\n  EXPECT_THROW(\n      Serializer::template deserialize<T>(buf.get()), std::out_of_range);\n  buf->trimEnd(1);\n  EXPECT_THROW(\n      Serializer::template deserialize<T>(buf.get()),\n      apache::thrift::protocol::TProtocolException);\n}", "target": 0}
{"code": "static void __sco_chan_add(struct sco_conn *conn, struct sock *sk,\n\t\t\t   struct sock *parent)\n{\n\tBT_DBG(\"conn %p\", conn);\n\tsco_pi(sk)->conn = conn;\n\tconn->sk = sk;\n\tINIT_DELAYED_WORK(&conn->timeout_work, sco_sock_timeout);\n\tif (parent)\n\t\tbt_accept_enqueue(parent, sk, true);\n}", "target": 0}
{"code": "void * pvPortMalloc( size_t xWantedSize )\n{\n    BlockLink_t * pxBlock, * pxPreviousBlock, * pxNewBlockLink;\n    static BaseType_t xHeapHasBeenInitialised = pdFALSE;\n    void * pvReturn = NULL;\n    vTaskSuspendAll();\n    {\n        if( xHeapHasBeenInitialised == pdFALSE )\n        {\n            prvHeapInit();\n            xHeapHasBeenInitialised = pdTRUE;\n        }\n        if( xWantedSize > 0 )\n        {\n            xWantedSize += heapSTRUCT_SIZE;\n            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )\n            {\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n            }\n        }\n        if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )\n        {\n            pxPreviousBlock = &xStart;\n            pxBlock = xStart.pxNextFreeBlock;\n            while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )\n            {\n                pxPreviousBlock = pxBlock;\n                pxBlock = pxBlock->pxNextFreeBlock;\n            }\n            if( pxBlock != &xEnd )\n            {\n                pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );\n                pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;\n                if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )\n                {\n                    pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );\n                    pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;\n                    pxBlock->xBlockSize = xWantedSize;\n                    prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );\n                }\n                xFreeBytesRemaining -= pxBlock->xBlockSize;\n            }\n        }\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    return pvReturn;\n}", "target": 1}
{"code": "static int http1_on_error(http1_parser_s *parser) {\n  FIO_LOG_DEBUG(\"HTTP parser error at HTTP/1.1 buffer position %zu/%zu\",\n                parser->state.next - parser2http(parser)->buf,\n                parser2http(parser)->buf_len);\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}", "target": 1}
{"code": "DocumentLoader* FrameLoader::activeDocumentLoader() const\n{\n    if (m_state == FrameStateProvisional)\n        return m_provisionalDocumentLoader.get();\n    return m_documentLoader.get();\n}", "target": 0}
{"code": "int nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol)\n{\n\tint rc;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s target_idx=%u protocol=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, protocol);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->active_target) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_idx);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->activate_target(dev, target, protocol);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t\tif (dev->ops->check_presence && !dev->shutting_down)\n\t\t\tmod_timer(&dev->check_pres_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "header_put_be_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "njs_promise_perform_race_handler(njs_vm_t *vm, njs_iterator_args_t *args,\n    njs_value_t *value, int64_t index)\n{\n    njs_int_t                    ret;\n    njs_value_t                  arguments[2], next;\n    njs_promise_capability_t     *capability;\n    njs_promise_iterator_args_t  *pargs;\n    if (!njs_is_valid(value)) {\n        value = njs_value_arg(&njs_value_undefined);\n    }\n    pargs = (njs_promise_iterator_args_t *) args;\n    ret = njs_function_call(vm, pargs->function, pargs->constructor, value,\n                            1, &next);\n    if (njs_slow_path(ret == NJS_ERROR)) {\n        return ret;\n    }\n    capability = pargs->capability;\n    arguments[0] = capability->resolve;\n    arguments[1] = capability->reject;\n    (void) njs_promise_invoke_then(vm, &next, arguments, 2);\n    return NJS_OK;\n}", "target": 0}
{"code": "void options_defaults() {\n    SERVICE_OPTIONS *service;\n    memset(&new_global_options, 0, sizeof(GLOBAL_OPTIONS));\n    memset(&new_service_options, 0, sizeof(SERVICE_OPTIONS));\n    new_service_options.next=NULL;\n    parse_global_option(CMD_SET_DEFAULTS, NULL, NULL);\n    service=&new_service_options;\n    parse_service_option(CMD_SET_DEFAULTS, &service, NULL, NULL);\n}", "target": 1}
{"code": "void nghttp2_option_set_max_continuations(nghttp2_option *option, size_t val) {\n  option->opt_set_mask |= NGHTTP2_OPT_MAX_CONTINUATIONS;\n  option->max_continuations = val;\n}", "target": 0}
{"code": "  void encode(bufferlist& bl) const {\n    __u8 struct_v = 1;\n    ::encode(struct_v, bl);\n    ::encode(nonce, bl);\n  }", "target": 1}
{"code": "int OmniboxViewWin::OnPerformDrop(const views::DropTargetEvent& event) {\n  return OnPerformDropImpl(event, false);\n}", "target": 0}
{"code": "pid_t LightProcess::proc_open(const char *cmd, const std::vector<int> &created,\n                              const std::vector<int> &desired,\n                              const char *cwd,\n                              const std::vector<std::string> &env) {\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  always_assert(Available());\n  always_assert(created.size() == desired.size());\n  if (fprintf(g_procs[id].m_fout, \"proc_open\\n%s\\n%s\\n\", cmd, cwd) <= 0) {\n    Logger::Error(\"Failed to send command proc_open\");\n    return -1;\n  }\n  fprintf(g_procs[id].m_fout, \"%d\\n\", (int)env.size());\n  for (unsigned int i = 0; i < env.size(); i++) {\n    fprintf(g_procs[id].m_fout, \"%s\\n\", env[i].c_str());\n  }\n  fprintf(g_procs[id].m_fout, \"%d\\n\", (int)created.size());\n  for (unsigned int i = 0; i < desired.size(); i++) {\n    fprintf(g_procs[id].m_fout, \"%d\\n\", desired[i]);\n  }\n  fflush(g_procs[id].m_fout);\n  bool error_send = false;\n  int save_errno = 0;\n  for (unsigned int i = 0; i < created.size(); i++) {\n    if (!send_fd(g_procs[id].m_afdt_fd, created[i])) {\n      error_send = true;\n      save_errno = errno;\n      break;\n    }\n  }\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (strncmp(buf, \"error\", 5) == 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n    if (error_send) {\n      errno = save_errno;\n    }\n    return -1;\n  }\n  int64_t pid = -1;\n  sscanf(buf, \"%\" PRId64, &pid);\n  assert(pid);\n  return (pid_t)pid;\n}", "target": 1}
{"code": "COMPAT_SYSCALL_DEFINE3(set_mempolicy, int, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tDECLARE_BITMAP(bm, MAX_NUMNODES);\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask) {\n\t\terr = compat_get_bitmap(bm, nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, bm, alloc_size);\n\t}\n\tif (err)\n\t\treturn -EFAULT;\n\treturn sys_set_mempolicy(mode, nm, nr_bits+1);\n}", "target": 1}
{"code": "int seccomp_restrict_realtime(void) {\n        static const int permitted_policies[] = {\n                SCHED_OTHER,\n                SCHED_BATCH,\n                SCHED_IDLE,\n        };\n        int r, max_policy = 0;\n        uint32_t arch;\n        unsigned i;\n        for (i = 0; i < ELEMENTSOF(permitted_policies); i++)\n                if (permitted_policies[i] > max_policy)\n                        max_policy = permitted_policies[i];\n        SECCOMP_FOREACH_LOCAL_ARCH(arch) {\n                _cleanup_(seccomp_releasep) scmp_filter_ctx seccomp = NULL;\n                int p;\n                log_debug(\"Operating on architecture: %s\", seccomp_arch_to_string(arch));\n                r = seccomp_init_for_arch(&seccomp, arch, SCMP_ACT_ALLOW);\n                if (r < 0)\n                        return r;\n                for (p = 0; p < max_policy; p++) {\n                        bool good = false;\n                        for (i = 0; i < ELEMENTSOF(permitted_policies); i++)\n                                if (permitted_policies[i] == p) {\n                                        good = true;\n                                        break;\n                                }\n                        if (good)\n                                continue;\n                        r = seccomp_rule_add_exact(\n                                        seccomp,\n                                        SCMP_ACT_ERRNO(EPERM),\n                                        SCMP_SYS(sched_setscheduler),\n                                        1,\n                                        SCMP_A1(SCMP_CMP_EQ, p));\n                        if (r < 0) {\n                                log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                                continue;\n                        }\n                }\n                r = seccomp_rule_add_exact(\n                                seccomp,\n                                SCMP_ACT_ERRNO(EPERM),\n                                SCMP_SYS(sched_setscheduler),\n                                1,\n                                SCMP_A1(SCMP_CMP_GT, max_policy));\n                if (r < 0) {\n                        log_debug_errno(r, \"Failed to add scheduler rule for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n                        continue;\n                }\n                r = seccomp_load(seccomp);\n                if (IN_SET(r, -EPERM, -EACCES))\n                        return r;\n                if (r < 0)\n                        log_debug_errno(r, \"Failed to install realtime protection rules for architecture %s, skipping: %m\", seccomp_arch_to_string(arch));\n        }\n        return 0;\n}", "target": 0}
{"code": "static void hid_input_field(struct hid_device *hid, struct hid_field *field,\n\t\t\t    __u8 *data, int interrupt)\n{\n\tunsigned n;\n\tunsigned count = field->report_count;\n\tunsigned offset = field->report_offset;\n\tunsigned size = field->report_size;\n\t__s32 min = field->logical_minimum;\n\t__s32 max = field->logical_maximum;\n\t__s32 *value;\n\tvalue = kmalloc(sizeof(__s32) * count, GFP_ATOMIC);\n\tif (!value)\n\t\treturn;\n\tfor (n = 0; n < count; n++) {\n\t\tvalue[n] = min < 0 ?\n\t\t\tsnto32(hid_field_extract(hid, data, offset + n * size,\n\t\t\t       size), size) :\n\t\t\thid_field_extract(hid, data, offset + n * size, size);\n\t\tif (!(field->flags & HID_MAIN_ITEM_VARIABLE) &&\n\t\t    value[n] >= min && value[n] <= max &&\n\t\t    value[n] - min < field->maxusage &&\n\t\t    field->usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)\n\t\t\tgoto exit;\n\t}\n\tfor (n = 0; n < count; n++) {\n\t\tif (HID_MAIN_ITEM_VARIABLE & field->flags) {\n\t\t\thid_process_event(hid, field, &field->usage[n], value[n], interrupt);\n\t\t\tcontinue;\n\t\t}\n\t\tif (field->value[n] >= min && field->value[n] <= max\n\t\t\t&& field->value[n] - min < field->maxusage\n\t\t\t&& field->usage[field->value[n] - min].hid\n\t\t\t&& search(value, field->value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);\n\t\tif (value[n] >= min && value[n] <= max\n\t\t\t&& value[n] - min < field->maxusage\n\t\t\t&& field->usage[value[n] - min].hid\n\t\t\t&& search(field->value, value[n], count))\n\t\t\t\thid_process_event(hid, field, &field->usage[value[n] - min], 1, interrupt);\n\t}\n\tmemcpy(field->value, value, count * sizeof(__s32));\nexit:\n\tkfree(value);\n}", "target": 0}
{"code": "pci_emul_add_msixcap(struct pci_vdev *dev, int msgnum, int barnum)\n{\n\tuint32_t tab_size;\n\tstruct msixcap msixcap;\n\tassert(msgnum >= 1 && msgnum <= MAX_MSIX_TABLE_ENTRIES);\n\tassert(barnum >= 0 && barnum <= PCIR_MAX_BAR_0);\n\ttab_size = msgnum * MSIX_TABLE_ENTRY_SIZE;\n\ttab_size = roundup2(tab_size, 4096);\n\tdev->msix.table_bar = barnum;\n\tdev->msix.pba_bar   = barnum;\n\tdev->msix.table_offset = 0;\n\tdev->msix.table_count = msgnum;\n\tdev->msix.pba_offset = tab_size;\n\tdev->msix.pba_size = PBA_SIZE(msgnum);\n\tpci_msix_table_init(dev, msgnum);\n\tpci_populate_msixcap(&msixcap, msgnum, barnum, tab_size);\n\tpci_emul_alloc_bar(dev, barnum, PCIBAR_MEM32,\n\t\t\t\ttab_size + dev->msix.pba_size);\n\treturn (pci_emul_add_capability(dev, (u_char *)&msixcap,\n\t\t\t\t\tsizeof(msixcap)));\n}", "target": 1}
{"code": "void test_base64_decode(void)\n{\n  char buffer[16];\n  int len = mutt_b64_decode(buffer, encoded);\n  if (!TEST_CHECK(len == sizeof(clear) - 1))\n  {\n    TEST_MSG(\"Expected: %zu\", sizeof(clear) - 1);\n    TEST_MSG(\"Actual  : %zu\", len);\n  }\n  buffer[len] = '\\0';\n  if (!TEST_CHECK(strcmp(buffer, clear) == 0))\n  {\n    TEST_MSG(\"Expected: %s\", clear);\n    TEST_MSG(\"Actual  : %s\", buffer);\n  }\n}", "target": 1}
{"code": "bool ArcMemory::Read(void *Data,size_t Size,size_t &Result)\n{\n  if (!Loaded)\n    return false;\n  Result=(size_t)Min(Size,ArcData.Size()-SeekPos);\n  memcpy(Data,&ArcData[(size_t)SeekPos],Result);\n  SeekPos+=Result;\n  return true;\n}", "target": 0}
{"code": "local unsigned long crc32_big(crc, buf, len)\n    unsigned long crc;\n    const unsigned char FAR *buf;\n    unsigned len;\n{\n    register z_crc_t c;\n    register const z_crc_t FAR *buf4;\n    c = ZSWAP32((z_crc_t)crc);\n    c = ~c;\n    while (len && ((ptrdiff_t)buf & 3)) {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n        len--;\n    }\n    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;\n    buf4--;\n    while (len >= 32) {\n        DOBIG32;\n        len -= 32;\n    }\n    while (len >= 4) {\n        DOBIG4;\n        len -= 4;\n    }\n    buf4++;\n    buf = (const unsigned char FAR *)buf4;\n    if (len) do {\n        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);\n    } while (--len);\n    c = ~c;\n    return (unsigned long)(ZSWAP32(c));\n}", "target": 1}
{"code": "mbc_case_fold(OnigCaseFoldType flag,\n\t      const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower,\n\t      OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  if (*p == SHARP_s && (flag & INTERNAL_ONIGENC_CASE_FOLD_MULTI_CHAR) != 0) {\n    *lower++ = 's';\n    *lower   = 's';\n    (*pp)++;\n    return 2;\n  }\n  *lower = ENC_CP1254_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": "static int unload_module(void)\n{\n\tast_cli_unregister_multiple(cli_identify, ARRAY_LEN(cli_identify));\n\tast_sip_unregister_cli_formatter(cli_formatter);\n\tast_sip_unregister_endpoint_formatter(&endpoint_identify_formatter);\n\tast_sip_unregister_endpoint_identifier(&header_identifier);\n\tast_sip_unregister_endpoint_identifier(&request_identifier);\n\tast_sip_unregister_endpoint_identifier(&ip_identifier);\n\tast_sip_unregister_endpoint_identifier(&transport_identifier);\n\treturn 0;\n}", "target": 1}
{"code": "  StringSanMatcher(int general_name_type, envoy::type::matcher::v3::StringMatcher matcher)\n      : general_name_type_(general_name_type), matcher_(matcher) {}", "target": 0}
{"code": "bounded_iostream::bounded_iostream(Sirikata::DecoderWriter *w,\n                                   const std::function<void(Sirikata::DecoderWriter*, size_t)> &size_callback,\n                                   const Sirikata::JpegAllocator<uint8_t> &alloc) \n    : parent(w), err(Sirikata::JpegError::nil()) {\n    this->size_callback = size_callback;\n    buffer_position = 0;\n    byte_position = 0;\n    byte_bound = 0x7FFFFFFF;\n    num_bytes_attempted_to_write = 0;\n    set_bound(0);\n}", "target": 0}
{"code": "static int br_mdb_dump(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net_device *dev;\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlmsghdr *nlh = NULL;\n\tint idx = 0, s_idx;\n\ts_idx = cb->args[0];\n\trcu_read_lock();\n\tcb->seq = net->dev_base_seq + br_mdb_rehash_seq;\n\tfor_each_netdev_rcu(net, dev) {\n\t\tif (dev->priv_flags & IFF_EBRIDGE) {\n\t\t\tstruct br_port_msg *bpm;\n\t\t\tif (idx < s_idx)\n\t\t\t\tgoto skip;\n\t\t\tnlh = nlmsg_put(skb, NETLINK_CB(cb->skb).portid,\n\t\t\t\t\tcb->nlh->nlmsg_seq, RTM_GETMDB,\n\t\t\t\t\tsizeof(*bpm), NLM_F_MULTI);\n\t\t\tif (nlh == NULL)\n\t\t\t\tbreak;\n\t\t\tbpm = nlmsg_data(nlh);\n\t\t\tmemset(bpm, 0, sizeof(*bpm));\n\t\t\tbpm->ifindex = dev->ifindex;\n\t\t\tif (br_mdb_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tif (br_rports_fill_info(skb, cb, dev) < 0)\n\t\t\t\tgoto out;\n\t\t\tcb->args[1] = 0;\n\t\t\tnlmsg_end(skb, nlh);\n\t\tskip:\n\t\t\tidx++;\n\t\t}\n\t}\nout:\n\tif (nlh)\n\t\tnlmsg_end(skb, nlh);\n\trcu_read_unlock();\n\tcb->args[0] = idx;\n\treturn skb->len;\n}", "target": 0}
{"code": "static bool r_bin_mdmp_init_directory(struct r_bin_mdmp_obj *obj) {\n\tint i;\n\tut8 *directory_base;\n\tstruct minidump_directory *entry;\n\tdirectory_base = obj->b->buf + obj->hdr->stream_directory_rva;\n\tsdb_num_set (obj->kv, \"mdmp_directory.offset\",\n\t\t\tobj->hdr->stream_directory_rva, 0);\n\tsdb_set (obj->kv, \"mdmp_directory.format\", \"[4]E? \"\n\t\t\t\"(mdmp_stream_type)StreamType \"\n\t\t\t\"(mdmp_location_descriptor)Location\", 0);\n\tfor (i = 0; i < (int)obj->hdr->number_of_streams; i++) {\n\t\tentry = (struct minidump_directory *)(directory_base + (i * sizeof (struct minidump_directory)));\n\t\tr_bin_mdmp_init_directory_entry (obj, entry);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void xen_irq_lateeoi_worker(struct work_struct *work)\n{\n\tstruct lateeoi_work *eoi;\n\tstruct irq_info *info;\n\tu64 now = get_jiffies_64();\n\tunsigned long flags;\n\teoi = container_of(to_delayed_work(work), struct lateeoi_work, delayed);\n\tread_lock_irqsave(&evtchn_rwlock, flags);\n\twhile (true) {\n\t\tspin_lock(&eoi->eoi_list_lock);\n\t\tinfo = list_first_entry_or_null(&eoi->eoi_list, struct irq_info,\n\t\t\t\t\t\teoi_list);\n\t\tif (info == NULL || now < info->eoi_time) {\n\t\t\tspin_unlock(&eoi->eoi_list_lock);\n\t\t\tbreak;\n\t\t}\n\t\tlist_del_init(&info->eoi_list);\n\t\tspin_unlock(&eoi->eoi_list_lock);\n\t\tinfo->eoi_time = 0;\n\t\txen_irq_lateeoi_locked(info);\n\t}\n\tif (info)\n\t\tmod_delayed_work_on(info->eoi_cpu, system_wq,\n\t\t\t\t    &eoi->delayed, info->eoi_time - now);\n\tread_unlock_irqrestore(&evtchn_rwlock, flags);\n}", "target": 0}
{"code": "GF_Err ainf_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_AssetInformationBox *ptr = (GF_AssetInformationBox *) s;\n\tISOM_DECREASE_SIZE(s, 4)\n\tptr->profile_version = gf_bs_read_u32(bs);\n\treturn gf_isom_read_null_terminated_string(s, bs, s->size, &ptr->APID);\n}", "target": 0}
{"code": "static int l2cap_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_l2 la;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tmemset(&la, 0, sizeof(la));\n\tlen = min_t(unsigned int, sizeof(la), alen);\n\tmemcpy(&la, addr, len);\n\tif (la.l2_cid)\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && !la.l2_psm) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tswitch (l2cap_pi(sk)->mode) {\n\tcase L2CAP_MODE_BASIC:\n\t\tbreak;\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\tif (enable_ertm)\n\t\t\tbreak;\n\tdefault:\n\t\terr = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\tswitch (sk->sk_state) {\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\t\tgoto wait;\n\tcase BT_CONNECTED:\n\t\tgoto done;\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\t\tbreak;\n\tdefault:\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tbacpy(&bt_sk(sk)->dst, &la.l2_bdaddr);\n\tl2cap_pi(sk)->psm = la.l2_psm;\n\terr = l2cap_do_connect(sk);\n\tif (err)\n\t\tgoto done;\nwait:\n\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "hstoreArrayToPairs(ArrayType *a, int *npairs)\n{\n\tDatum\t   *key_datums;\n\tbool\t   *key_nulls;\n\tint\t\t\tkey_count;\n\tPairs\t   *key_pairs;\n\tint\t\t\tbufsiz;\n\tint\t\t\ti,\n\t\t\t\tj;\n\tdeconstruct_array(a,\n\t\t\t\t\t  TEXTOID, -1, false, 'i',\n\t\t\t\t\t  &key_datums, &key_nulls, &key_count);\n\tif (key_count == 0)\n\t{\n\t\t*npairs = 0;\n\t\treturn NULL;\n\t}\n\tif (key_count > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t key_count, (int) (MaxAllocSize / sizeof(Pairs)))));\n\tkey_pairs = palloc(sizeof(Pairs) * key_count);\n\tfor (i = 0, j = 0; i < key_count; i++)\n\t{\n\t\tif (!key_nulls[i])\n\t\t{\n\t\t\tkey_pairs[j].key = VARDATA(key_datums[i]);\n\t\t\tkey_pairs[j].keylen = VARSIZE(key_datums[i]) - VARHDRSZ;\n\t\t\tkey_pairs[j].val = NULL;\n\t\t\tkey_pairs[j].vallen = 0;\n\t\t\tkey_pairs[j].needfree = 0;\n\t\t\tkey_pairs[j].isnull = 1;\n\t\t\tj++;\n\t\t}\n\t}\n\t*npairs = hstoreUniquePairs(key_pairs, j, &bufsiz);\n\treturn key_pairs;\n}", "target": 0}
{"code": "void ImapModelOpenConnectionTest::testPreauthWithStartTlsWanted()\n{\n    cleanup(); init(true); \n    cEmpty();\n    cServer(\"* PREAUTH hi there\\r\\n\");\n    QCOMPARE(failedSpy->size(), 1);\n    QVERIFY(completedSpy->isEmpty());\n    QVERIFY(authSpy->isEmpty());\n    QVERIFY(startTlsUpgradeSpy->isEmpty());\n}", "target": 0}
{"code": "int sock_present2network(const char *address, struct sockaddr_storage *sockaddr, int addr_family, char *errbuf, int errbuflen)\n{\n\tstruct addrinfo *addrinfo;\n\tstruct addrinfo hints;\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = addr_family;\n\tif (sock_initaddress(address, \"22222\" , &hints, &addrinfo, errbuf, errbuflen) == -1)\n\t\treturn 0;\n\tif (addrinfo->ai_family == PF_INET)\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in));\n\telse\n\t\tmemcpy(sockaddr, addrinfo->ai_addr, sizeof(struct sockaddr_in6));\n\tif (addrinfo->ai_next != NULL)\n\t{\n\t\tfreeaddrinfo(addrinfo);\n\t\tif (errbuf)\n\t\t\tsnprintf(errbuf, errbuflen, \"More than one socket requested; using the first one returned\");\n\t\treturn -2;\n\t}\n\tfreeaddrinfo(addrinfo);\n\treturn -1;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[1];\n  const int input_width = input->dims->data[2];\n  int output_height = input_height / block_size;\n  int output_width = input_width / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height * block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width * block_size);\n  TfLiteIntArray* output_size = TfLiteIntArrayCreate(4);\n  output_size->data[0] = input->dims->data[0];\n  output_size->data[1] = output_height;\n  output_size->data[2] = output_width;\n  output_size->data[3] = input->dims->data[3] * block_size * block_size;\n  return context->ResizeTensor(context, output, output_size);\n}", "target": 0}
{"code": "bool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\tif (url_len < 1)\n\t\treturn false;\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\tif (port_len) {\n\t\tchar *slash;\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\treturn true;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& boxes = context->input(0);\n    const Tensor& scores = context->input(1);\n    const Tensor& max_output_size = context->input(2);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(max_output_size.shape()),\n        errors::InvalidArgument(\"max_output_size must be 0-D, got shape \",\n                                max_output_size.shape().DebugString()));\n    const Tensor& iou_threshold = context->input(3);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(iou_threshold.shape()),\n                errors::InvalidArgument(\"iou_threshold must be 0-D, got shape \",\n                                        iou_threshold.shape().DebugString()));\n    const T iou_threshold_val = iou_threshold.scalar<T>()();\n    OP_REQUIRES(context,\n                iou_threshold_val >= static_cast<T>(0.0) &&\n                    iou_threshold_val <= static_cast<T>(1.0),\n                errors::InvalidArgument(\"iou_threshold must be in [0, 1]\"));\n    const Tensor& score_threshold = context->input(4);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(score_threshold.shape()),\n        errors::InvalidArgument(\"score_threshold must be 0-D, got shape \",\n                                score_threshold.shape().DebugString()));\n    const T score_threshold_val = score_threshold.scalar<T>()();\n    int num_boxes = 0;\n    ParseAndCheckBoxSizes(context, boxes, &num_boxes);\n    CheckScoreSizes(context, num_boxes, scores);\n    if (!context->status().ok()) {\n      return;\n    }\n    auto similarity_fn = CreateIOUSimilarityFn<T>(boxes);\n    int num_valid_outputs;\n    bool return_scores_tensor_ = false;\n    const T dummy_soft_nms_sigma = static_cast<T>(0.0);\n    DoNonMaxSuppressionOp<T>(\n        context, scores, num_boxes, max_output_size, iou_threshold_val,\n        score_threshold_val, dummy_soft_nms_sigma, similarity_fn,\n        return_scores_tensor_, pad_to_max_output_size_, &num_valid_outputs);\n    if (!context->status().ok()) {\n      return;\n    }\n    Tensor* num_outputs_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                1, tensorflow::TensorShape{}, &num_outputs_t));\n    num_outputs_t->scalar<int32>().setConstant(num_valid_outputs);\n  }", "target": 0}
{"code": "MATCHER_P(HeaderMapEqualIgnoreOrder, expected, \"\") {\n  const bool equal = TestUtility::headerMapEqualIgnoreOrder(*arg, *expected);\n  if (!equal) {\n    *result_listener << \"\\n\"\n                     << TestUtility::addLeftAndRightPadding(\"Expected header map:\") << \"\\n\"\n                     << *expected\n                     << TestUtility::addLeftAndRightPadding(\"is not equal to actual header map:\")\n                     << \"\\n\"\n                     << *arg << TestUtility::addLeftAndRightPadding(\"\") \n                     << \"\\n\";\n  }\n  return equal;\n}", "target": 0}
{"code": "void InferenceContext::PreInputInit(\n    const OpDef& op_def, const std::vector<const Tensor*>& input_tensors,\n    const std::vector<ShapeHandle>& input_tensors_as_shapes) {\n  const auto ret = full_type::SpecializeType(attrs_, op_def);\n  DCHECK(ret.status().ok()) << \"while instantiating types: \" << ret.status();\n  ret_types_ = ret.ValueOrDie();\n  input_tensors_ = input_tensors;\n  input_tensors_as_shapes_ = input_tensors_as_shapes;\n  construction_status_ =\n      NameRangesForNode(attrs_, op_def, &input_name_map_, &output_name_map_);\n  if (!construction_status_.ok()) return;\n  int num_outputs = 0;\n  for (const auto& e : output_name_map_) {\n    num_outputs = std::max(num_outputs, e.second.second);\n  }\n  outputs_.assign(num_outputs, nullptr);\n  output_handle_shapes_and_types_.resize(num_outputs);\n}", "target": 1}
{"code": "blkxor(void * dest, void * src, size_t len)\n{\n  __m128i * D = (__m128i *) dest;\n  __m128i * S = (__m128i *) src;\n  size_t L = len / 16;\n  size_t i;\n  for (i = 0; i < L; i++)\n    D[i] = _mm_xor_si128(D[i], S[i]);\n}", "target": 1}
{"code": "section_size (asection *section, Elf_Internal_Phdr *segment)\n{\n  if ((section->flags & SEC_HAS_CONTENTS) != 0\n      || (section->flags & SEC_THREAD_LOCAL) == 0\n      || segment->p_type == PT_TLS)\n    return section->size;\n  return 0;\n}", "target": 0}
{"code": "\tclass BadDistanceErr : public Err {public: BadDistanceErr() : Err(INVALID_DATA_FORMAT, \"Inflator: error in bit distance\") {}};", "target": 0}
{"code": "TfLiteStatus EvalGatherNd(TfLiteContext* context,\n                          const TfLiteEvalTensor* params,\n                          const TfLiteEvalTensor* indices,\n                          TfLiteEvalTensor* output) {\n  switch (params->type) {\n    case kTfLiteFloat32:\n      return GatherNd<float, IndicesT>(params, indices, output);\n      break;\n    case kTfLiteInt8:\n      return GatherNd<int8_t, IndicesT>(params, indices, output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context,\n                         \"Params type '%s' are not supported by gather_nd.\",\n                         TfLiteTypeGetName(params->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "exit_ext2_xattr(void)\n{\n\tmb_cache_destroy(ext2_xattr_cache);\n}", "target": 1}
{"code": "std::vector<std::string> Utility::getSubjectAltNames(X509& cert, int type) {\n  std::vector<std::string> subject_alt_names;\n  bssl::UniquePtr<GENERAL_NAMES> san_names(\n      static_cast<GENERAL_NAMES*>(X509_get_ext_d2i(&cert, NID_subject_alt_name, nullptr, nullptr)));\n  if (san_names == nullptr) {\n    return subject_alt_names;\n  }\n  for (const GENERAL_NAME* san : san_names.get()) {\n    if (san->type == type) {\n      subject_alt_names.push_back(generalNameAsString(san));\n    }\n  }\n  return subject_alt_names;\n}", "target": 1}
{"code": "TEST_P(ProxyFilterIntegrationTest, UpstreamTlsWithTooLongSni) {\n  upstream_tls_ = true;\n  initializeWithArgs(1024, 1024, \"x-host\");\n  std::string too_long_sni(300, 'a');\n  ASSERT_EQ(too_long_sni.size(), 300); \n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  const Http::TestRequestHeaderMapImpl request_headers{{\":method\", \"POST\"},\n                                                       {\":path\", \"/test/long/url\"},\n                                                       {\":scheme\", \"http\"},\n                                                       {\":authority\", \"localhost\"},\n                                                       {\"x-host\", too_long_sni}};\n  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  ASSERT_TRUE(response->waitForEndStream());\n  EXPECT_EQ(\"503\", response->headers().getStatusValue());\n}", "target": 0}
{"code": "static tjhandle _tjInitDecompress(tjinstance *this)\n{\n\tstatic unsigned char buffer[1];\n\tthis->dinfo.err=jpeg_std_error(&this->jerr.pub);\n\tthis->jerr.pub.error_exit=my_error_exit;\n\tthis->jerr.pub.output_message=my_output_message;\n\tthis->jerr.emit_message=this->jerr.pub.emit_message;\n\tthis->jerr.pub.emit_message=my_emit_message;\n\tif(setjmp(this->jerr.setjmp_buffer))\n\t{\n\t\tif(this) free(this);\n\t\treturn NULL;\n\t}\n\tjpeg_create_decompress(&this->dinfo);\n\tjpeg_mem_src_tj(&this->dinfo, buffer, 1);\n\tthis->init|=DECOMPRESS;\n\treturn (tjhandle)this;\n}", "target": 0}
{"code": "void sctp_generate_t3_rtx_event(unsigned long peer)\n{\n\tint error;\n\tstruct sctp_transport *transport = (struct sctp_transport *) peer;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->T3_rtx_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_T3_RTX),\n\t\t\t   asoc->state,\n\t\t\t   asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "AnyP::UriScheme::defaultPort() const\n{\n    switch (theScheme_) {\n    case AnyP::PROTO_HTTP:\n        return 80;\n    case AnyP::PROTO_HTTPS:\n        return 443;\n    case AnyP::PROTO_FTP:\n        return 21;\n    case AnyP::PROTO_COAP:\n    case AnyP::PROTO_COAPS:\n        return 5683;\n    case AnyP::PROTO_GOPHER:\n        return 70;\n    case AnyP::PROTO_WAIS:\n        return 210;\n    case AnyP::PROTO_CACHE_OBJECT:\n        return CACHE_HTTP_PORT;\n    case AnyP::PROTO_WHOIS:\n        return 43;\n    default:\n        return 0;\n    }\n}", "target": 1}
{"code": "comics_document_init (ComicsDocument *comics_document)\n{\n\tcomics_document->archive = NULL;\n\tcomics_document->page_names = NULL;\n\tcomics_document->extract_command = NULL;\n}", "target": 1}
{"code": "static int __init init_ext2_fs(void)\n{\n\tint err = init_ext2_xattr();\n\tif (err)\n\t\treturn err;\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n        err = register_filesystem(&ext2_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\texit_ext2_xattr();\n\treturn err;\n}", "target": 1}
{"code": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\treturn 0;\n}", "target": 1}
{"code": "static void __mcheck_cpu_clear_vendor(struct cpuinfo_x86 *c)\n{\n\tswitch (c->x86_vendor) {\n\tcase X86_VENDOR_INTEL:\n\t\tmce_intel_feature_clear(c);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "v8::Handle<v8::Value> V8ThrowException::throwTypeError(v8::Isolate* isolate, const String& message)\n{\n    v8::Handle<v8::Value> exception = V8ThrowException::createTypeError(isolate, message);\n    return V8ThrowException::throwException(exception, isolate);\n}", "target": 0}
{"code": "service_info *FindServiceControlURLPath(\n\tservice_table *table, const char *controlURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table && parse_uri(controlURLPath,\n\t\t\t     strlen(controlURLPath),\n\t\t\t     &parsed_url_in) == HTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->controlURL) {\n\t\t\t\tif (parse_uri(finger->controlURL,\n\t\t\t\t\t    strlen(finger->controlURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "void common_timer_get(struct k_itimer *timr, struct itimerspec64 *cur_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tktime_t now, remaining, iv;\n\tstruct timespec64 ts64;\n\tbool sig_none;\n\tsig_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tiv = timr->it_interval;\n\tif (iv) {\n\t\tcur_setting->it_interval = ktime_to_timespec64(iv);\n\t} else if (!timr->it_active) {\n\t\tif (!sig_none)\n\t\t\treturn;\n\t}\n\tkc->clock_get(timr->it_clock, &ts64);\n\tnow = timespec64_to_ktime(ts64);\n\tif (iv && (timr->it_requeue_pending & REQUEUE_PENDING || sig_none))\n\t\ttimr->it_overrun += kc->timer_forward(timr, now);\n\tremaining = kc->timer_remaining(timr, now);\n\tif (remaining <= 0) {\n\t\tif (!sig_none)\n\t\t\tcur_setting->it_value.tv_nsec = 1;\n\t} else {\n\t\tcur_setting->it_value = ktime_to_timespec64(remaining);\n\t}\n}", "target": 1}
{"code": "static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],\n                                         w + (s->w - s->in_w),\n                                         h + (s->h - s->in_h));\n    int plane;\n    if (!frame)\n        return NULL;\n    frame->width  = w;\n    frame->height = h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int hsub = s->draw.hsub[plane];\n        int vsub = s->draw.vsub[plane];\n        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +\n                              (s->y >> vsub) * frame->linesize[plane];\n    }\n    return frame;\n}", "target": 1}
{"code": "static noinline_for_stack void scrub_workers_put(struct btrfs_fs_info *fs_info)\n{\n\tif (--fs_info->scrub_workers_refcnt == 0) {\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_wr_completion_workers);\n\t\tbtrfs_destroy_workqueue(fs_info->scrub_parity_workers);\n\t}\n\tWARN_ON(fs_info->scrub_workers_refcnt < 0);\n}", "target": 0}
{"code": "static int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint offs, int count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif(copy_from_user(&((char *) &ins)[offs], addr + offs, sizeof(ins) - offs))\n\t\treturn -EFAULT;\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\treturn store_instr(ins.channel, &ins);\n}", "target": 1}
{"code": "static int sco_sock_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t int addr_len)\n{\n\tstruct sockaddr_sco *sa = (struct sockaddr_sco *) addr;\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->sco_bdaddr);\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\tif (addr_len < sizeof(struct sockaddr_sco))\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tbacpy(&sco_pi(sk)->src, &sa->sco_bdaddr);\n\tsk->sk_state = BT_BOUND;\ndone:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "xmlAddRef(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n    xmlAttrPtr attr) {\n    xmlRefPtr ret;\n    xmlRefTablePtr table;\n    xmlListPtr ref_list;\n    if (doc == NULL) {\n        return(NULL);\n    }\n    if (value == NULL) {\n        return(NULL);\n    }\n    if (attr == NULL) {\n        return(NULL);\n    }\n    table = (xmlRefTablePtr) doc->refs;\n    if (table == NULL) {\n        doc->refs = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n            \"xmlAddRef: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n        return(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->name = NULL;\n\tret->attr = attr;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (NULL == (ref_list = xmlHashLookup(table, value))) {\n        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare))) {\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list creation failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n        if (xmlHashAddEntry(table, value, ref_list) < 0) {\n            xmlListDelete(ref_list);\n\t    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n\t    goto failed;\n        }\n    }\n    if (xmlListAppend(ref_list, ret) != 0) {\n\txmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n\t\t    \"xmlAddRef: Reference list insertion failed!\\n\",\n\t\t    NULL);\n        goto failed;\n    }\n    return(ret);\nfailed:\n    if (ret != NULL) {\n        if (ret->value != NULL)\n\t    xmlFree((char *)ret->value);\n        if (ret->name != NULL)\n\t    xmlFree((char *)ret->name);\n        xmlFree(ret);\n    }\n    return(NULL);\n}", "target": 1}
{"code": "GetSamplingFrequencyIndex(unsigned int sampling_frequency)\n{\n    switch (sampling_frequency) {\n        case 96000: return 0;\n        case 88200: return 1;\n        case 64000: return 2;\n        case 48000: return 3;\n        case 44100: return 4;\n        case 32000: return 5;\n        case 24000: return 6;\n        case 22050: return 7;\n        case 16000: return 8;\n        case 12000: return 9;\n        case 11025: return 10;\n        case 8000:  return 11;\n        case 7350:  return 12;\n        default:    return 0;\n    }\n}", "target": 0}
{"code": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n  req.body.assign(body, content_length);\n  return send_(std::move(req));\n}", "target": 1}
{"code": "static inline key_ref_t __key_update(key_ref_t key_ref,\n\t\t\t\t     struct key_preparsed_payload *prep)\n{\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\tgoto error;\n\tret = -EEXIST;\n\tif (!key->type->update)\n\t\tgoto error;\n\tdown_write(&key->sem);\n\tret = key->type->update(key, prep);\n\tif (ret == 0)\n\t\tclear_bit(KEY_FLAG_NEGATIVE, &key->flags);\n\tup_write(&key->sem);\n\tif (ret < 0)\n\t\tgoto error;\nout:\n\treturn key_ref;\nerror:\n\tkey_put(key);\n\tkey_ref = ERR_PTR(ret);\n\tgoto out;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    OP_REQUIRES(context,\n                batch == out_backprop.dim_size(0) &&\n                    out_rows == out_backprop.dim_size(1) &&\n                    out_cols == out_backprop.dim_size(2) &&\n                    depth == out_backprop.dim_size(3),\n                errors::InvalidArgument(\"out_backprop has incompatible size.\"));\n    Tensor* filter_backprop = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(0, filter.shape(), &filter_backprop));\n    if (filter.shape().num_elements() == 0) {\n      return;\n    }\n    functor::DilationBackpropFilter<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), out_backprop.tensor<T, 4>(), stride_rows,\n        stride_cols, rate_rows, rate_cols, pad_top, pad_left,\n        filter_backprop->tensor<T, 3>());\n  }", "target": 0}
{"code": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tif (!dst)\n\t\tgoto out;\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\nout:\n\treturn dst;\n}", "target": 1}
{"code": "lys_getnext_data(const struct lys_module *mod, const struct lys_node *parent, const char *name, int nam_len,\n                 LYS_NODE type, const struct lys_node **ret)\n{\n    const struct lys_node *node;\n    assert((mod || parent) && name);\n    assert(!(type & (LYS_AUGMENT | LYS_USES | LYS_GROUPING | LYS_CHOICE | LYS_CASE | LYS_INPUT | LYS_OUTPUT)));\n    if (!mod) {\n        mod = lys_node_module(parent);\n    }\n    node = NULL;\n    while ((node = lys_getnext(node, parent, mod, 0))) {\n        if (!type || (node->nodetype & type)) {\n            if (lys_node_module(node) != lys_main_module(mod)) {\n                continue;\n            }\n            if (!strncmp(node->name, name, nam_len) && !node->name[nam_len]) {\n                if (ret) {\n                    *ret = node;\n                }\n                return EXIT_SUCCESS;\n            }\n        }\n    }\n    return EXIT_FAILURE;\n}", "target": 1}
{"code": "static int umocktypes_are_equal_bool_ptr(bool** left, bool** right)\n{\n    int result;\n    if (*left == *right)\n    {\n        result = 1;\n    }\n    else\n    {\n        if (*(*left) == *(*right))\n        {\n            result = 1;\n        }\n        else\n        {\n            result = 0;\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "static lbool must_quote(char c)\n{\n\treturn (c == '\\n'); \n}", "target": 0}
{"code": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n    return sRet + \"/\";\n}", "target": 1}
{"code": "MOBI_RET mobi_find_attrvalue(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end, const MOBIFiletype type, const char *needle) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    size_t needle_length = strlen(needle);\n    if (needle_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", needle_length);\n        return MOBI_PARAM_ERR;\n    }\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    unsigned char tag_open;\n    unsigned char tag_close;\n    if (type == T_CSS) {\n        tag_open = '{';\n        tag_close = '}';\n    } else {\n        tag_open = '<';\n        tag_close = '>';\n    }\n    unsigned char last_border = tag_close;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end && memcmp(data, needle, needle_length) == 0) {\n            if (last_border != tag_open) {\n                data += needle_length;\n                continue;\n            }\n            while (data >= data_start && !isspace(*data) && *data != tag_open && *data != '=' && *data != '(') {\n                data--;\n            }\n            result->is_url = (*data == '(');\n            result->start = ++data;\n            int i = 0;\n            while (data <= data_end && !isspace(*data) && *data != tag_close && *data != ')' && i < MOBI_ATTRVALUE_MAXSIZE) {\n                result->value[i++] = (char) *data++;\n            }\n            if (*(data - 1) == '/' && *data == '>') {\n                --data; --i;\n            }\n            result->end = data;\n            result->value[i] = '\\0';\n            return MOBI_SUCCESS;\n        }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_host)\n{\n\tphp_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_HOST);\n}", "target": 0}
{"code": "ConnectClientToUnixSock(const char *sockFile)\n{\n#ifdef WIN32\n  rfbClientErr(\"Windows doesn't support UNIX sockets\\n\");\n  return -1;\n#else\n  int sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  if(strlen(sockFile) + 1 > sizeof(addr.sun_path)) {\n      rfbClientErr(\"ConnectToUnixSock: socket file name too long\\n\");\n      return -1;\n  }\n  strcpy(addr.sun_path, sockFile);\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock < 0) {\n    rfbClientErr(\"ConnectToUnixSock: socket (%s)\\n\",strerror(errno));\n    return -1;\n  }\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0) {\n    rfbClientErr(\"ConnectToUnixSock: connect\\n\");\n    close(sock);\n    return -1;\n  }\n  return sock;\n#endif\n}", "target": 0}
{"code": "is_create_with_attrs(struct nfsd4_open *open)\n{\n\treturn open->op_create == NFS4_OPEN_CREATE\n\t\t&& (open->op_createmode == NFS4_CREATE_UNCHECKED\n\t\t    || open->op_createmode == NFS4_CREATE_GUARDED\n\t\t    || open->op_createmode == NFS4_CREATE_EXCLUSIVE4_1);\n}", "target": 0}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tsize_t new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "static int ghash_final(struct shash_desc *desc, u8 *dst)\n{\n\tstruct ghash_desc_ctx *dctx = shash_desc_ctx(desc);\n\tstruct ghash_ctx *ctx = crypto_shash_ctx(desc->tfm);\n\tu8 *buf = dctx->buffer;\n\tif (!ctx->gf128)\n\t\treturn -ENOKEY;\n\tghash_flush(ctx, dctx);\n\tmemcpy(dst, buf, GHASH_BLOCK_SIZE);\n\treturn 0;\n}", "target": 0}
{"code": "WebKit::WebView* RenderView::webview() const {\n  return static_cast<WebKit::WebView*>(webwidget());\n}", "target": 0}
{"code": "static int activate(AVFilterContext *ctx)\n{\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    AudioFWTDNContext *s = ctx->priv;\n    AVFrame *in = NULL;\n    int ret, status;\n    int64_t pts;\n    FF_FILTER_FORWARD_STATUS_BACK(outlink, inlink);\n    ret = ff_inlink_consume_samples(inlink, s->nb_samples, s->nb_samples, &in);\n    if (ret < 0)\n        return ret;\n    if (ret > 0)\n        return filter_frame(inlink, in);\n    if (ff_inlink_acknowledge_status(inlink, &status, &pts)) {\n        if (status == AVERROR_EOF) {\n            while (s->padd_samples != 0) {\n                ret = filter_frame(inlink, NULL);\n                if (ret < 0)\n                    return ret;\n            }\n            ff_outlink_set_status(outlink, status, pts);\n            return ret;\n        }\n    }\n    FF_FILTER_FORWARD_WANTED(outlink, inlink);\n    return FFERROR_NOT_READY;\n}", "target": 1}
{"code": "nvkm_vmm_node_remove(struct nvkm_vmm *vmm, struct nvkm_vma *vma)\n{\n\trb_erase(&vma->tree, &vmm->root);\n}", "target": 0}
{"code": "void mutt_socket_empty(struct Connection *conn)\n{\n  if (!conn)\n    return;\n  char buf[1024];\n  int bytes;\n  while ((bytes = mutt_socket_poll(conn, 0)) > 0)\n  {\n    mutt_socket_read(conn, buf, MIN(bytes, sizeof(buf)));\n  }\n}", "target": 0}
{"code": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\tkenter(\"%p{%u}\", user, uid);\n\tif (user->uid_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\tif (!user->uid_keyring) {\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "set_num_722(unsigned char *p, uint16_t value)\n{\n\tarchive_be16enc(p, value);\n}", "target": 0}
{"code": "struct dst_entry *inet_csk_route_req(struct sock *sk,\n\t\t\t\t     const struct request_sock *req)\n{\n\tstruct rtable *rt;\n\tconst struct inet_request_sock *ireq = inet_rsk(req);\n\tstruct ip_options *opt = inet_rsk(req)->opt;\n\tstruct net *net = sock_net(sk);\n\tstruct flowi4 fl4;\n\tflowi4_init_output(&fl4, sk->sk_bound_dev_if, sk->sk_mark,\n\t\t\t   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,\n\t\t\t   sk->sk_protocol, inet_sk_flowi_flags(sk),\n\t\t\t   (opt && opt->srr) ? opt->faddr : ireq->rmt_addr,\n\t\t\t   ireq->loc_addr, ireq->rmt_port, inet_sk(sk)->inet_sport);\n\tsecurity_req_classify_flow(req, flowi4_to_flowi(&fl4));\n\trt = ip_route_output_flow(net, &fl4, sk);\n\tif (IS_ERR(rt))\n\t\tgoto no_route;\n\tif (opt && opt->is_strictroute && rt->rt_dst != rt->rt_gateway)\n\t\tgoto route_err;\n\treturn &rt->dst;\nroute_err:\n\tip_rt_put(rt);\nno_route:\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);\n\treturn NULL;\n}", "target": 1}
{"code": "static int req_ssl_var_lookup(lua_State *L)\n{\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    const char *s = luaL_checkstring(L, 2);\n    const char *res = ap_lua_ssl_val(r->pool, r->server, r->connection, r, \n                                     (char *)s);\n    lua_pushstring(L, res);\n    return 1;\n}", "target": 0}
{"code": "blkcpy(void * dest, void * src, size_t len)\n{\n  memcpy(dest, src, len);\n}", "target": 1}
{"code": "static void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\tkenter(\"%p\", dest_keyring);\n\tif (dest_keyring) {\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}", "target": 1}
{"code": "compat_mptfwxfer_ioctl(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_fw_xfer32 kfw32;\n\tstruct mpt_fw_xfer kfw;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\tif (copy_from_user(&kfw32, (char __user *)arg, sizeof(kfw32)))\n\t\treturn -EFAULT;\n\tiocnumX = kfw32.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mptfwxfer_ioctl @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mptfwxfer_ioctl() called\\n\",\n\t    iocp->name));\n\tkfw.iocnum = iocnum;\n\tkfw.fwlen = kfw32.fwlen;\n\tkfw.bufp = compat_ptr(kfw32.bufp);\n\tret = mptctl_do_fw_download(kfw.iocnum, kfw.bufp, kfw.fwlen);\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "static __be16 cma_port(const struct sockaddr *addr)\n{\n\tstruct sockaddr_ib *sib;\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\treturn ((struct sockaddr_in *) addr)->sin_port;\n\tcase AF_INET6:\n\t\treturn ((struct sockaddr_in6 *) addr)->sin6_port;\n\tcase AF_IB:\n\t\tsib = (struct sockaddr_ib *) addr;\n\t\treturn htons((u16) (be64_to_cpu(sib->sib_sid) &\n\t\t\t\t    be64_to_cpu(sib->sib_sid_mask)));\n\tdefault:\n\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "    bool cmpPreviewProperties(\n        const PreviewProperties& lhs,\n        const PreviewProperties& rhs\n    )\n    {\n        uint32_t l = lhs.width_ * lhs.height_;\n        uint32_t r = rhs.width_ * rhs.height_;\n        return l < r;\n    }", "target": 0}
{"code": "static void mdbEvalSetColumn(MyDbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    char nbuf[200];\n    MysqlPrep *prep = p->prep;\n    SqlFieldResults *field = prep->fieldResult+iCol;\n    Jsi_Interp *interp = p->jdb->interp;\n    if (field->isnull)\n        return;\n    switch(field->jsiTypeMap) {\n        case JSI_OPTION_STRING: {\n            int bytes = field->len;\n            const char *zBlob = field->buffer.vstring;\n            if( !zBlob ) {\n                const char *nv = p->jdb->optPtr->nullvalue;\n                Jsi_DSAppend(dStr, nv?nv:\"null\", NULL);\n                return;\n            }\n            Jsi_DSAppendLen(dStr, zBlob, bytes);\n            return;\n        }\n        case JSI_OPTION_BOOL: {\n            snprintf(nbuf, sizeof(nbuf), \"%s\", field->buffer.vchar?\"true\":\"false\");\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_INT64: {\n            snprintf(nbuf, sizeof(nbuf), \"%lld\", field->buffer.vlonglong);\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_TIME_D:\n        case JSI_OPTION_TIME_W: {\n            Jsi_Number jtime = mdbMyTimeToJS(&field->buffer.timestamp);\n            Jsi_NumberToString(interp, jtime, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        case JSI_OPTION_DOUBLE: {\n            Jsi_NumberToString(interp, field->buffer.vdouble, nbuf, sizeof(nbuf));\n            Jsi_DSAppend(dStr, nbuf, NULL);\n            return;\n        }\n        default:\n            Jsi_LogWarn(\"unknown type: %d\", field->jsiTypeMap);\n    }\n}", "target": 1}
{"code": "void __skb_tstamp_tx(struct sk_buff *orig_skb,\n\t\t     struct skb_shared_hwtstamps *hwtstamps,\n\t\t     struct sock *sk, int tstype)\n{\n\tstruct sk_buff *skb;\n\tbool tsonly;\n\tif (!sk)\n\t\treturn;\n\ttsonly = sk->sk_tsflags & SOF_TIMESTAMPING_OPT_TSONLY;\n\tif (!skb_may_tx_timestamp(sk, tsonly))\n\t\treturn;\n\tif (tsonly) {\n#ifdef CONFIG_INET\n\t\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS) &&\n\t\t    sk->sk_protocol == IPPROTO_TCP &&\n\t\t    sk->sk_type == SOCK_STREAM)\n\t\t\tskb = tcp_get_timestamping_opt_stats(sk);\n\t\telse\n#endif\n\t\t\tskb = alloc_skb(0, GFP_ATOMIC);\n\t} else {\n\t\tskb = skb_clone(orig_skb, GFP_ATOMIC);\n\t}\n\tif (!skb)\n\t\treturn;\n\tif (tsonly) {\n\t\tskb_shinfo(skb)->tx_flags = skb_shinfo(orig_skb)->tx_flags;\n\t\tskb_shinfo(skb)->tskey = skb_shinfo(orig_skb)->tskey;\n\t}\n\tif (hwtstamps)\n\t\t*skb_hwtstamps(skb) = *hwtstamps;\n\telse\n\t\tskb->tstamp = ktime_get_real();\n\t__skb_complete_tx_timestamp(skb, sk, tstype);", "target": 1}
{"code": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t\treturn 0;\n\t}\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t}\n\tif (retval_ptr)\n\t\tzval_ptr_dtor(&retval_ptr);\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 0}
{"code": "end_write(JOIN *join, JOIN_TAB *join_tab __attribute__((unused)),\n\t  bool end_of_records)\n{\n  TABLE *const table= join_tab->table;\n  DBUG_ENTER(\"end_write\");\n  if (!end_of_records)\n  {\n    copy_fields(join_tab->tmp_table_param);\n    if (copy_funcs(join_tab->tmp_table_param->items_to_copy, join->thd))\n      DBUG_RETURN(NESTED_LOOP_ERROR);           \n    if (likely(!join_tab->having || join_tab->having->val_int()))\n    {\n      int error;\n      join->found_records++;\n      if ((error= table->file->ha_write_tmp_row(table->record[0])))\n      {\n        if (likely(!table->file->is_fatal_error(error, HA_CHECK_DUP)))\n\t  goto end;                             \n        bool is_duplicate;\n\tif (create_internal_tmp_table_from_heap(join->thd, table, \n                                                join_tab->tmp_table_param->start_recinfo,\n                                                &join_tab->tmp_table_param->recinfo,\n                                                error, 1, &is_duplicate))\n\t  DBUG_RETURN(NESTED_LOOP_ERROR);        \n        if (is_duplicate)\n          goto end;\n\ttable->s->uniques=0;\t\t\t\n      }\n      if (++join_tab->send_records >=\n            join_tab->tmp_table_param->end_write_records &&\n\t  join->do_send_rows)\n      {\n\tif (!(join->select_options & OPTION_FOUND_ROWS))\n\t  DBUG_RETURN(NESTED_LOOP_QUERY_LIMIT);\n\tjoin->do_send_rows=0;\n\tjoin->unit->select_limit_cnt = HA_POS_ERROR;\n      }\n    }\n  }\nend:\n  if (unlikely(join->thd->check_killed()))\n  {\n    DBUG_RETURN(NESTED_LOOP_KILLED);             \n  }\n  DBUG_RETURN(NESTED_LOOP_OK);\n}", "target": 0}
{"code": "zisofs_rewind_boot_file(struct archive_write *a)\n{\n\tstruct iso9660 *iso9660 = a->format_data;\n\tif (iso9660->el_torito.boot->file->zisofs.header_size != 0) {\n\t\tarchive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n\t\t    \"We cannot extract the zisofs imaged boot file;\"\n\t\t    \" this may not boot in being zisofs imaged\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\treturn (ARCHIVE_OK);\n}", "target": 0}
{"code": "static int snd_hrtimer_stop(struct snd_timer *t)\n{\n\tstruct snd_hrtimer *stime = t->private_data;\n\tatomic_set(&stime->running, 0);\n\thrtimer_try_to_cancel(&stime->hrt);\n\treturn 0;\n}", "target": 0}
{"code": "      \\param[out] colors At return, contains the list of 3d object colors.\n      \\return List of 3d object vertices.\n    **/\n    template<typename tf, typename tc>", "target": 0}
{"code": "GF_Box *prft_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_ProducerReferenceTimeBox, GF_ISOM_BOX_TYPE_PRFT);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "static long cec_adap_g_log_addrs(struct cec_adapter *adap,\n\t\t\t\t struct cec_log_addrs __user *parg)\n{\n\tstruct cec_log_addrs log_addrs;\n\tmutex_lock(&adap->lock);\n\tlog_addrs = adap->log_addrs;\n\tif (!adap->is_configured)\n\t\tmemset(log_addrs.log_addr, CEC_LOG_ADDR_INVALID,\n\t\t       sizeof(log_addrs.log_addr));\n\tmutex_unlock(&adap->lock);\n\tif (copy_to_user(parg, &log_addrs, sizeof(log_addrs)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 1}
{"code": "void QuotaManager::DidGetDatabaseLRUOrigin(const GURL& origin) {\n  if (origins_in_use_.find(origin) != origins_in_use_.end() ||\n      access_notified_origins_.find(origin) != access_notified_origins_.end())\n    lru_origin_callback_->Run(GURL());\n  else\n    lru_origin_callback_->Run(origin);\n  access_notified_origins_.clear();\n  lru_origin_callback_.reset();\n}", "target": 0}
{"code": "static inline bool StateSynSentValidateTimestamp(TcpSession *ssn, Packet *p)\n{\n    if (PKT_IS_TOSERVER(p) || !(TCP_HAS_TS(p))) {\n        return true;\n    }\n    TcpStream *receiver_stream = &ssn->client;\n    uint32_t ts_echo = TCP_GET_TSECR(p);\n    if ((receiver_stream->flags & STREAMTCP_STREAM_FLAG_TIMESTAMP) != 0) {\n        if (receiver_stream->last_ts != 0 && ts_echo != 0 &&\n            ts_echo != receiver_stream->last_ts)\n        {\n            SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,\n                    ts_echo, receiver_stream->last_ts);\n            return false;\n        }\n    } else {\n        if (receiver_stream->last_ts == 0 && ts_echo != 0) {\n            SCLogDebug(\"ssn %p: BAD TSECR echo %u recv %u\", ssn,\n                    ts_echo, receiver_stream->last_ts);\n            return false;\n        }\n    }\n    return true;\n}", "target": 0}
{"code": "TfLiteStatus EvalHashtableFind(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  int resource_id = input_resource_id_tensor->data.i32[0];\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* default_value_tensor =\n      GetInput(context, node, kDefaultValueTensor);\n  TfLiteTensor* output_tensor = GetOutput(context, node, 0);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      lookup->CheckKeyAndValueTypes(context, key_tensor, output_tensor));\n  auto result =\n      lookup->Lookup(context, key_tensor, output_tensor, default_value_tensor);\n  return result;\n}", "target": 1}
{"code": "int vm_sockets_get_local_cid(void)\n{\n\treturn transport->get_local_cid();\n}", "target": 0}
{"code": "TfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  data->input_zero_point = input->params.zero_point;\n  return CalculateArithmeticOpData(context, node, data);\n}", "target": 0}
{"code": "bool SignedData::verify_signature() const {\n  STACK_OF(X509) *certs = nullptr;\n  switch (OBJ_obj2nid(p7_->type)) {\n    case NID_pkcs7_signed: {\n      certs = p7_->d.sign->cert;\n      break;\n    }\n    case NID_pkcs7_signedAndEnveloped: {\n      certs = p7_->d.signed_and_enveloped->cert;\n      break;\n    }\n  }\n  if (certs == nullptr) {\n    return false;\n  }\n  auto *signers_stack_ptr = PKCS7_get0_signers(p7_, nullptr, 0);\n  if (signers_stack_ptr == nullptr) {\n    return false;\n  }\n  auto signers_stack = impl::STACK_OF_X509_ptr(signers_stack_ptr, impl::SK_X509_free);\n  for (auto i = 0; i < sk_X509_num(signers_stack.get()); ++i) {\n    auto *signer = sk_X509_value(signers_stack.get(), i);\n    auto xku_flags = X509_get_extended_key_usage(signer);\n    if (!(xku_flags & XKU_CODE_SIGN)) {\n      return false;\n    }\n  }\n  std::uint8_t *indirect_data_buf = nullptr;\n  auto buf_size = impl::i2d_Authenticode_SpcIndirectDataContent(indirect_data_, &indirect_data_buf);\n  if (buf_size < 0 || indirect_data_buf == nullptr) {\n    return false;\n  }\n  auto indirect_data_ptr =\n      impl::OpenSSL_ptr(reinterpret_cast<char *>(indirect_data_buf), impl::OpenSSL_free);\n  const auto *signed_data_seq = reinterpret_cast<std::uint8_t *>(indirect_data_ptr.get());\n  long length = 0;\n  int tag = 0, tag_class = 0;\n  ASN1_get_object(&signed_data_seq, &length, &tag, &tag_class, buf_size);\n  if (tag != V_ASN1_SEQUENCE) {\n    return false;\n  }\n  auto *signed_data_ptr = BIO_new_mem_buf(signed_data_seq, length);\n  if (signed_data_ptr == nullptr) {\n    return false;\n  }\n  impl::BIO_ptr signed_data(signed_data_ptr, BIO_free);\n  auto status = PKCS7_verify(p7_, certs, nullptr, signed_data.get(), nullptr, PKCS7_NOVERIFY);\n  return status == 1;\n}", "target": 0}
{"code": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    return;\n  }\n  if (!MRB_PROC_CFUNC_P(b) && b->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)b->body.irep);\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n}", "target": 0}
{"code": "static int serdes_probe(struct platform_device *pdev)\n{\n\tstruct phy_provider *provider;\n\tstruct serdes_ctrl *ctrl;\n\tunsigned int i;\n\tint ret;\n\tctrl = devm_kzalloc(&pdev->dev, sizeof(*ctrl), GFP_KERNEL);\n\tif (!ctrl)\n\t\treturn -ENOMEM;\n\tctrl->dev = &pdev->dev;\n\tctrl->regs = syscon_node_to_regmap(pdev->dev.parent->of_node);\n\tif (IS_ERR(ctrl->regs))\n\t\treturn PTR_ERR(ctrl->regs);\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tret = serdes_phy_create(ctrl, i, &ctrl->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdev_set_drvdata(&pdev->dev, ctrl);\n\tprovider = devm_of_phy_provider_register(ctrl->dev,\n\t\t\t\t\t\t serdes_simple_xlate);\n\treturn PTR_ERR_OR_ZERO(provider);\n}", "target": 1}
{"code": "comics_regex_quote (const gchar *unquoted_string)\n{\n\tconst gchar *p;\n\tGString *dest;\n\tdest = g_string_new (\"'\");\n\tp = unquoted_string;\n\twhile (*p) {\n\t\tswitch (*p) {\n\t\t\tcase ('*'):\n\t\t\tcase ('?'):\n\t\t\tcase ('['):\n\t\t\t\tg_string_append (dest, \"[\");\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tg_string_append (dest, \"]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\\\'):\n\t\t\t\tg_string_append (dest, \"[\\\\\\\\]\");\n\t\t\t\tbreak;\n\t\t\tcase ('\\''):\n\t\t\t\tg_string_append (dest, \"'\\\\''\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tg_string_append_c (dest, *p);\n\t\t\t\tbreak;\n\t\t}\n\t\t++p;\n\t}\n\tg_string_append_c (dest, '\\'');\n\treturn g_string_free (dest, FALSE);\n}", "target": 1}
{"code": "static bool tipc_crypto_key_rcv(struct tipc_crypto *rx, struct tipc_msg *hdr)\n{\n\tstruct tipc_crypto *tx = tipc_net(rx->net)->crypto_tx;\n\tstruct tipc_aead_key *skey = NULL;\n\tu16 key_gen = msg_key_gen(hdr);\n\tu16 size = msg_data_sz(hdr);\n\tu8 *data = msg_data(hdr);\n\tspin_lock(&rx->lock);\n\tif (unlikely(rx->skey || (key_gen == rx->key_gen && rx->key.keys))) {\n\t\tpr_err(\"%s: key existed <%p>, gen %d vs %d\\n\", rx->name,\n\t\t       rx->skey, key_gen, rx->key_gen);\n\t\tgoto exit;\n\t}\n\tskey = kmalloc(size, GFP_ATOMIC);\n\tif (unlikely(!skey)) {\n\t\tpr_err(\"%s: unable to allocate memory for skey\\n\", rx->name);\n\t\tgoto exit;\n\t}\n\tskey->keylen = ntohl(*((__be32 *)(data + TIPC_AEAD_ALG_NAME)));\n\tmemcpy(skey->alg_name, data, TIPC_AEAD_ALG_NAME);\n\tmemcpy(skey->key, data + TIPC_AEAD_ALG_NAME + sizeof(__be32),\n\t       skey->keylen);\n\tif (unlikely(size != tipc_aead_key_size(skey))) {\n\t\tkfree(skey);\n\t\tskey = NULL;\n\t\tgoto exit;\n\t}\n\trx->key_gen = key_gen;\n\trx->skey_mode = msg_key_mode(hdr);\n\trx->skey = skey;\n\trx->nokey = 0;\n\tmb(); \nexit:\n\tspin_unlock(&rx->lock);\n\tif (likely(skey && queue_delayed_work(tx->wq, &rx->work, 0)))\n\t\treturn true;\n\treturn false;\n}", "target": 1}
{"code": "header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->headend)\n\t\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;\n\t\t\tpsf->headindex = position ;\n\t\t\tbreak ;\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->headindex + position < 0)\n\t\t\t\tbreak ;\n\t\t\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (psf->headindex + position <= psf->headend)\n\t\t\t{\tpsf->headindex += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\t\t\tif (psf->headindex + position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t\n\t\t\t\tpsf->headindex = psf->headend ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\tbreak ;\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;\n\t\t\tbreak ;\n\t\t} ;\n\treturn ;\n} ", "target": 1}
{"code": "valid_hostname(const char *s)\n{\n\tsize_t i;\n\tif (*s == '-')\n\t\treturn 0;\n\tfor (i = 0; s[i] != 0; i++) {\n\t\tif (strchr(\"'`\\\"$\\\\;&<>|(){}\", s[i]) != NULL ||\n\t\t    isspace((u_char)s[i]) || iscntrl((u_char)s[i]))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static void lwp_write_int32(FILE *fout, int32_t d) {\n  fwrite(&d, sizeof(d), 1, fout);\n  fflush(fout);\n}", "target": 0}
{"code": "sraSpanInsertAfter(sraSpan *newspan, sraSpan *after) {\n  newspan->_next = after->_next;\n  newspan->_prev = after;\n  after->_next->_prev = newspan;\n  after->_next = newspan;\n}", "target": 1}
{"code": "inline bool ClientImpl::write_request(Stream &strm, Request &req,\n                                      bool close_connection, Error &error) {\n  if (close_connection) {\n    if (!req.has_header(\"Connection\")) {\n      req.headers.emplace(\"Connection\", \"close\");\n    }\n  }\n  if (!req.has_header(\"Host\")) {\n    if (is_ssl()) {\n      if (port_ == 443) {\n        req.headers.emplace(\"Host\", host_);\n      } else {\n        req.headers.emplace(\"Host\", host_and_port_);\n      }\n    } else {\n      if (port_ == 80) {\n        req.headers.emplace(\"Host\", host_);\n      } else {\n        req.headers.emplace(\"Host\", host_and_port_);\n      }\n    }\n  }\n  if (!req.has_header(\"Accept\")) { req.headers.emplace(\"Accept\", \"*", "target": 1}
{"code": "iasecc_chv_verify(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd, unsigned char *scbs,\n\t\t  int *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tunsigned char scb = scbs[IASECC_ACLS_CHV_VERIFY];\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Verify CHV PIN(ref:%i,len:%i,scb:%X)\", pin_cmd->pin_reference, pin_cmd->pin1.len,\n\t       scb);\n\tif (scb & IASECC_SCB_METHOD_SM) {\n\t\trv = iasecc_sm_pin_verify(card, scb & IASECC_SCB_METHOD_MASK_REF, pin_cmd, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\trv = iso_ops->pin_cmd(card, pin_cmd, tries_left);\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "void EditorClientBlackBerry::learnWord(const WTF::String&)\n{\n    notImplemented();\n}", "target": 0}
{"code": "static int do_prlimit(struct task_struct *tsk, unsigned int resource,\n\t\t      struct rlimit *new_rlim, struct rlimit *old_rlim)\n{\n\tstruct rlimit *rlim;\n\tint retval = 0;\n\tif (resource >= RLIM_NLIMITS)\n\t\treturn -EINVAL;\n\tresource = array_index_nospec(resource, RLIM_NLIMITS);\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_cur > new_rlim->rlim_max)\n\t\t\treturn -EINVAL;\n\t\tif (resource == RLIMIT_NOFILE &&\n\t\t\t\tnew_rlim->rlim_max > sysctl_nr_open)\n\t\t\treturn -EPERM;\n\t}\n\trlim = tsk->signal->rlim + resource;\n\ttask_lock(tsk->group_leader);\n\tif (new_rlim) {\n\t\tif (new_rlim->rlim_max > rlim->rlim_max &&\n\t\t\t\t!capable(CAP_SYS_RESOURCE))\n\t\t\tretval = -EPERM;\n\t\tif (!retval)\n\t\t\tretval = security_task_setrlimit(tsk, resource, new_rlim);\n\t}\n\tif (!retval) {\n\t\tif (old_rlim)\n\t\t\t*old_rlim = *rlim;\n\t\tif (new_rlim)\n\t\t\t*rlim = *new_rlim;\n\t}\n\ttask_unlock(tsk->group_leader);\n\tif (!retval && new_rlim && resource == RLIMIT_CPU &&\n\t    new_rlim->rlim_cur != RLIM_INFINITY &&\n\t    IS_ENABLED(CONFIG_POSIX_TIMERS)) {\n\t\tupdate_rlimit_cpu(tsk->group_leader, new_rlim->rlim_cur);\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "AP_DECLARE(void) ap_set_last_modified(request_rec *r)\n{\n    if (!r->assbackwards) {\n        apr_time_t mod_time = ap_rationalize_mtime(r, r->mtime);\n        char *datestr = apr_palloc(r->pool, APR_RFC822_DATE_LEN);\n        apr_rfc822_date(datestr, mod_time);\n        apr_table_setn(r->headers_out, \"Last-Modified\", datestr);\n    }\n}", "target": 0}
{"code": "generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name,\n        service_name;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if (! (ret.code = check_handle((void *)handle))) {\n        ret.api_version = handle->api_version;\n    }\n    free_server_handle(handle);\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (ret.code != 0)\n        errmsg = krb5_get_error_message(NULL, ret.code);\n    clen = client_name.length;\n    trunc_name(&clen, &cdots);\n    slen = service_name.length;\n    trunc_name(&slen, &sdots);\n    krb5_klog_syslog(LOG_NOTICE, _(\"Request: kadm5_init, %.*s%s, %s, \"\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    return(&ret);\n}", "target": 1}
{"code": "eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n    WebKitWebFrame *frame;\n    JSGlobalContextRef context;\n    JSObjectRef globalobject;\n    JSStringRef var_name;\n    JSStringRef js_script;\n    JSValueRef js_result;\n    JSStringRef js_result_string;\n    size_t js_result_size;\n    js_init();\n    frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));\n    context = webkit_web_frame_get_global_context(frame);\n    globalobject = JSContextGetGlobalObject(context);\n    var_name = JSStringCreateWithUTF8CString(\"Uzbl\");\n    JSObjectSetProperty(context, globalobject, var_name,\n                        JSObjectMake(context, uzbl.js.classref, NULL),\n                        kJSClassAttributeNone, NULL);\n    js_script = JSStringCreateWithUTF8CString(script);\n    js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n    if (js_result && !JSValueIsUndefined(context, js_result)) {\n        js_result_string = JSValueToStringCopy(context, js_result, NULL);\n        js_result_size = JSStringGetMaximumUTF8CStringSize(js_result_string);\n        if (js_result_size) {\n            char js_result_utf8[js_result_size];\n            JSStringGetUTF8CString(js_result_string, js_result_utf8, js_result_size);\n            g_string_assign(result, js_result_utf8);\n        }\n        JSStringRelease(js_result_string);\n    }\n    JSObjectDeleteProperty(context, globalobject, var_name, NULL);\n    JSStringRelease(var_name);\n    JSStringRelease(js_script);\n}", "target": 1}
{"code": "pci_set_cfgdata32(struct pci_vdev *dev, int offset, uint32_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\t*(uint32_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "static int sd_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tswitch (gspca_dev->pixfmt.width) {\n\tcase 160:\n\t\tmin_packet_size = 200;\n\t\tbreak;\n\tcase 176:\n\t\tmin_packet_size = 266;\n\t\tbreak;\n\tdefault:\n\t\tmin_packet_size = 400;\n\t\tbreak;\n\t}\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tpr_err(\"set alt 1 err %d\\n\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "static int do_replace(struct net *net, const void __user *user,\n\t\t      unsigned int len)\n{\n\tint ret, countersize;\n\tstruct ebt_table_info *newinfo;\n\tstruct ebt_replace tmp;\n\tif (copy_from_user(&tmp, user, sizeof(tmp)) != 0)\n\t\treturn -EFAULT;\n\tif (len != sizeof(tmp) + tmp.entries_size) {\n\t\tBUGPRINT(\"Wrong len argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.entries_size == 0) {\n\t\tBUGPRINT(\"Entries_size never zero\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /\n\t\t\tNR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\tif (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))\n\t\treturn -ENOMEM;\n\ttmp.name[sizeof(tmp.name) - 1] = 0;\n\tcountersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;\n\tnewinfo = vmalloc(sizeof(*newinfo) + countersize);\n\tif (!newinfo)\n\t\treturn -ENOMEM;\n\tif (countersize)\n\t\tmemset(newinfo->counters, 0, countersize);\n\tnewinfo->entries = vmalloc(tmp.entries_size);\n\tif (!newinfo->entries) {\n\t\tret = -ENOMEM;\n\t\tgoto free_newinfo;\n\t}\n\tif (copy_from_user(\n\t   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {\n\t\tBUGPRINT(\"Couldn't copy entries from userspace\\n\");\n\t\tret = -EFAULT;\n\t\tgoto free_entries;\n\t}\n\tret = do_replace_finish(net, &tmp, newinfo);\n\tif (ret == 0)\n\t\treturn ret;\nfree_entries:\n\tvfree(newinfo->entries);\nfree_newinfo:\n\tvfree(newinfo);\n\treturn ret;\n}", "target": 0}
{"code": "devzvol_create(struct vnode *dvp, char *nm, struct vattr *vap, vcexcl_t excl,\n    int mode, struct vnode **vpp, struct cred *cred, int flag,\n    caller_context_t *ct, vsecattr_t *vsecp)\n{\n\tint error;\n\tstruct vnode *vp;\n\t*vpp = NULL;\n\terror = devzvol_lookup(dvp, nm, &vp, NULL, 0, NULL, cred, ct, NULL,\n\t    NULL);\n\tif (error == 0) {\n\t\tif (excl == EXCL)\n\t\t\terror = EEXIST;\n\t\telse if (vp->v_type == VDIR && (mode & VWRITE))\n\t\t\terror = EISDIR;\n\t\telse\n\t\t\terror = VOP_ACCESS(vp, mode, 0, cred, ct);\n\t\tif (error) {\n\t\t\tVN_RELE(vp);\n\t\t} else\n\t\t\t*vpp = vp;\n\t} else if (error == ENOENT) {\n\t\terror = EROFS;\n\t}\n\treturn (error);\n}", "target": 0}
{"code": "static ssize_t attr_show_buffers(struct device *cd,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct v4l2_loopback_device *dev = v4l2loopback_cd2dev(cd);\n\treturn sprintf(buf, \"%d\\n\", dev->used_buffers);\n}", "target": 0}
{"code": "_XimEncodeSavedStatusValue(\n    Xic\t\t\t  ic,\n    XIMResourceList\t  res,\n    XPointer\t\t  value)\n{\n    int\t\t\t  list_ret;\n    XFontStruct\t\t**struct_list;\n    char\t\t**name_list;\n    char\t\t *tmp;\n    int\t\t\t  len;\n    register int\t  i;\n    if (res->xrm_name == XrmStringToQuark(XNFontSet)) {\n\tif (!value)\n\t    return False;\n\tXfree(ic->private.proto.status_font);\n\tlist_ret = XFontsOfFontSet((XFontSet)value,\n\t\t\t\t\t\t&struct_list, &name_list);\n\tfor(i = 0, len = 0; i < list_ret; i++) {\n\t    len += (strlen(name_list[i]) + sizeof(char));\n\t}\n\tif(!(tmp = Xmalloc(len + 1))) {\n\t    ic->private.proto.status_font = NULL;\n\t    return False;\n\t}\n\ttmp[0] = '\\0';\n\tfor(i = 0; i < list_ret; i++) {\n\t    strcat(tmp, name_list[i]);\n\t    strcat(tmp, \",\");\n\t}\n\ttmp[len - 1] = 0;\n\tic->private.proto.status_font        = tmp;\n\tic->private.proto.status_font_length = len - 1;\n    }\n    return True;\n}", "target": 0}
{"code": "static int save_dev(blkid_dev dev, FILE *file)\n{\n\tstruct list_head *p;\n\tif (!dev || dev->bid_name[0] != '/')\n\t\treturn 0;\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\treturn 0;\n}", "target": 1}
{"code": "smtp_log_to_file(smtp_t *smtp)\n{\n\tFILE *fp = fopen(\"/tmp/smtp-alert.log\", \"a\");\n\ttime_t now;\n\tstruct tm tm;\n\tchar time_buf[25];\n\tint time_buf_len;\n\ttime(&now);\n\tlocaltime_r(&now, &tm);\n\ttime_buf_len = strftime(time_buf, sizeof time_buf, \"%a %b %e %X %Y\", &tm);\n\tfprintf(fp, \"%s: %s -> %s\\n\"\n\t\t    \"%*sSubject: %s\\n\"\n\t\t    \"%*sBody:    %s\\n\\n\",\n\t\t    time_buf, global_data->email_from, smtp->email_to,\n\t\t    time_buf_len - 7, \"\", smtp->subject,\n\t\t    time_buf_len - 7, \"\", smtp->body);\n\tfclose(fp);\n\tfree_smtp_all(smtp);\n}", "target": 1}
{"code": "static void nfs_set_open_stateid(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tnfs_set_open_stateid_locked(state, stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n}", "target": 1}
{"code": "const char *string_of_NPPVariable(int variable)\n{\n  const char *str;\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPPVpluginNameString);\n\t_(NPPVpluginDescriptionString);\n\t_(NPPVpluginWindowBool);\n\t_(NPPVpluginTransparentBool);\n\t_(NPPVjavaClass);\n\t_(NPPVpluginWindowSize);\n\t_(NPPVpluginTimerInterval);\n\t_(NPPVpluginScriptableInstance);\n\t_(NPPVpluginScriptableIID);\n\t_(NPPVjavascriptPushCallerBool);\n\t_(NPPVpluginKeepLibraryInMemory);\n\t_(NPPVpluginNeedsXEmbed);\n\t_(NPPVpluginScriptableNPObject);\n\t_(NPPVformValue);\n\t_(NPPVpluginUrlRequestsDisplayedBool);\n\t_(NPPVpluginWantsAllNetworkStreams);\n\t_(NPPVpluginNativeAccessibleAtkPlugId);\n\t_(NPPVpluginCancelSrcStream);\n\t_(NPPVSupportsAdvancedKeyHandling);\n#undef _\n  default:\n\tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPPVpluginScriptableInstance);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n  return str;\n}", "target": 0}
{"code": "static int r_cmd_java_call(void *user, const char *input) {\n\tRCore *core = (RCore *) user;\n\tint res = false;\n\tut32 i = 0;\n\tif (strncmp (input, \"java\", 4)) {\n\t\treturn false;\n\t}\n\tif (input[4] != ' ') {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\tfor (; i < END_CMDS; i++) {\n\t\tIFDBG r_cons_printf (\"Checking cmd: %s %d\\n\", JAVA_CMDS[i].name,\n\t\t\tstrncmp (input+5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len));\n\t\tif (!strncmp (input + 5, JAVA_CMDS[i].name, JAVA_CMDS[i].name_len)) {\n\t\t\tconst char *cmd = input + 5 + JAVA_CMDS[i].name_len;\n\t\t\tif (*cmd && *cmd == ' ') {\n\t\t\t\tcmd++;\n\t\t\t}\n\t\t\tres =  JAVA_CMDS[i].handler (core, cmd);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!res) {\n\t\treturn r_cmd_java_handle_help (core, input);\n\t}\n\treturn true;\n}", "target": 1}
{"code": "TfLiteStatus GetTemporarySafe(const TfLiteContext* context,\n                              const TfLiteNode* node, int index,\n                              TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->temporaries->size,\n                                 node->temporaries->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "inline FIO_FUNC ssize_t fio_sendfile(intptr_t uuid, intptr_t source_fd,\n                                     off_t offset, size_t length) {\n  return fio_write2(uuid, .data.fd = source_fd, .length = length, .is_fd = 1,\n                    .offset = offset);\n}", "target": 1}
{"code": "static void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t index = size > 0? (size - 1) % s: 0;\n\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\tindex = 0;\n\t\t}\n\t\tut64 mask = bitmask_by_width[index];\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\t\tif (shift > 0 && shift < 64) {\n\t\t\tr_strbuf_appendf (sb, \"%d,SWAP,0x%\"PFMT64x\",&,<<,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tshift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);\n\t\t} else {\n\t\t\tint dimsize = size % 64;\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",&,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tmask, REG64 (n), regc, VEC64_MASK (shift, dimsize), REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}", "target": 1}
{"code": "    void resetTriggered() { m_triggered = false; }", "target": 0}
{"code": "main_get_appheader (xd3_stream *stream, main_file *ifile,\n\t\t    main_file *output, main_file *sfile)\n{\n  uint8_t *apphead;\n  usize_t appheadsz;\n  int ret;\n  if (! option_use_appheader) { return; }\n  ret = xd3_get_appheader (stream, & apphead, & appheadsz);\n  if (ret != 0) { return; }\n  if (appheadsz > 0)\n    {\n      char *start = (char*)apphead;\n      char *slash;\n      int   place = 0;\n      char *parsed[4];\n      memset (parsed, 0, sizeof (parsed));\n      while ((slash = strchr (start, '/')) != NULL)\n\t{\n\t  *slash = 0;\n\t  parsed[place++] = start;\n\t  start = slash + 1;\n\t}\n      parsed[place++] = start;\n      if (place == 2 || place == 4)\n\t{\n\t  main_get_appheader_params (output, parsed, 1, \"output\", ifile);\n\t}\n      if (place == 4)\n\t{\n\t  main_get_appheader_params (sfile, parsed+2, 0, \"source\", ifile);\n\t}\n    }\n  option_use_appheader = 0;\n  return;\n}", "target": 1}
{"code": "mrb_ary_shift_m(mrb_state *mrb, mrb_value self)\n{\n  struct RArray *a = mrb_ary_ptr(self);\n  mrb_int len = ARY_LEN(a);\n  mrb_int n;\n  mrb_value val;\n  if (mrb_get_args(mrb, \"|i\", &n) == 0) {\n    return mrb_ary_shift(mrb, self);\n  };\n  ary_modify_check(mrb, a);\n  if (len == 0 || n == 0) return mrb_ary_new(mrb);\n  if (n < 0) mrb_raise(mrb, E_ARGUMENT_ERROR, \"negative array shift\");\n  if (n > len) n = len;\n  val = mrb_ary_new_from_values(mrb, n, ARY_PTR(a));\n  if (ARY_SHARED_P(a)) {\n  L_SHIFT:\n    a->as.heap.ptr+=n;\n    a->as.heap.len-=n;\n    return val;\n  }\n  if (len > ARY_SHIFT_SHARED_MIN) {\n    ary_make_shared(mrb, a);\n    goto L_SHIFT;\n  }\n  else if (len == n) {\n    ARY_SET_LEN(a, 0);\n  }\n  else {\n    mrb_value *ptr = ARY_PTR(a);\n    mrb_int size = len-n;\n    while (size--) {\n      *ptr = *(ptr+n);\n      ++ptr;\n    }\n    ARY_SET_LEN(a, len-n);\n  }\n  return val;\n}", "target": 1}
{"code": "  QInt16() {}", "target": 1}
{"code": "static inline int mpeg4_get_dc_length(int level, int n)\n{\n    if (n < 4)\n        return uni_DCtab_lum_len[level + 256];\n    else\n        return uni_DCtab_chrom_len[level + 256];\n}", "target": 0}
{"code": "static int attach_recursive_mnt(struct mount *source_mnt,\n\t\t\tstruct mount *dest_mnt,\n\t\t\tstruct mountpoint *dest_mp,\n\t\t\tstruct path *parent_path)\n{\n\tHLIST_HEAD(tree_list);\n\tstruct mnt_namespace *ns = dest_mnt->mnt_ns;\n\tstruct mount *child, *p;\n\tstruct hlist_node *n;\n\tint err;\n\tif (!parent_path) {\n\t\terr = count_mounts(ns, source_mnt);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tif (IS_MNT_SHARED(dest_mnt)) {\n\t\terr = invent_group_ids(source_mnt, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = propagate_mnt(dest_mnt, dest_mp, source_mnt, &tree_list);\n\t\tlock_mount_hash();\n\t\tif (err)\n\t\t\tgoto out_cleanup_ids;\n\t\tfor (p = source_mnt; p; p = next_mnt(p, source_mnt))\n\t\t\tset_mnt_shared(p);\n\t} else {\n\t\tlock_mount_hash();\n\t}\n\tif (parent_path) {\n\t\tdetach_mnt(source_mnt, parent_path);\n\t\tattach_mnt(source_mnt, dest_mnt, dest_mp);\n\t\ttouch_mnt_namespace(source_mnt->mnt_ns);\n\t} else {\n\t\tmnt_set_mountpoint(dest_mnt, dest_mp, source_mnt);\n\t\tcommit_tree(source_mnt, NULL);\n\t}\n\thlist_for_each_entry_safe(child, n, &tree_list, mnt_hash) {\n\t\tstruct mount *q;\n\t\thlist_del_init(&child->mnt_hash);\n\t\tq = __lookup_mnt_last(&child->mnt_parent->mnt,\n\t\t\t\t      child->mnt_mountpoint);\n\t\tcommit_tree(child, q);\n\t}\n\tunlock_mount_hash();\n\treturn 0;\n out_cleanup_ids:\n\twhile (!hlist_empty(&tree_list)) {\n\t\tchild = hlist_entry(tree_list.first, struct mount, mnt_hash);\n\t\tchild->mnt_parent->mnt_ns->pending_mounts = 0;\n\t\tumount_tree(child, UMOUNT_SYNC);\n\t}\n\tunlock_mount_hash();\n\tcleanup_group_ids(source_mnt, NULL);\n out:\n\tns->pending_mounts = 0;\n\treturn err;\n}", "target": 0}
{"code": "do_macro(uschar *p)\n{\nint length;\nint nest = 0;\nargstr **pp;\nmacrodef *md = misc_malloc(sizeof(macrodef));\nmd->name = misc_readitem(p, NULL, &length, NULL, 0);\nmd->namelength = Ustrlen(md->name);\np += length;\nif (length == 0)\n  {\n  error(14);\n  return;\n  }\nmd->lines = md->args = NULL;\nmd->next = macrolist;\nmacrolist = md;\npp = &(md->args);\nwhile (*p != 0)\n  {\n  argstr *as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_readitem(p, NULL, &length, NULL, 0);\n  p += length;\n  }\npp = &(md->lines);\nfor (;;)\n  {\n  argstr *as;\n  uschar *line = read_nextline();\n  if (line == NULL) { error(13, \".endmacro\"); return; }\n  if (Ustrncmp(line, \".macro \", 7) == 0) nest++;\n  else if (Ustrncmp(line, \".endmacro\", 9) == 0)\n    {\n    if (isspace(line[9]) || line[9] == '\\n')\n    if (--nest < 0) break;\n    }\n  as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_copystring(line, Ustrlen(line));\n  }\nif (md->lines == NULL)\n  {\n  md->lines = misc_malloc(sizeof(argstr));\n  md->lines->next = NULL;\n  md->lines->string = misc_copystring(US\". Dummy line\\n\", 13);\n  }\n}", "target": 1}
{"code": "static int spk_ttyio_ldisc_open(struct tty_struct *tty)\n{\n\tstruct spk_ldisc_data *ldisc_data;\n\tif (!tty->ops->write)\n\t\treturn -EOPNOTSUPP;\n\tspeakup_tty = tty;\n\tldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);\n\tif (!ldisc_data)\n\t\treturn -ENOMEM;\n\tinit_completion(&ldisc_data->completion);\n\tldisc_data->buf_free = true;\n\tspeakup_tty->disc_data = ldisc_data;\n\treturn 0;\n}", "target": 1}
{"code": "static void sctp_generate_timeout_event(struct sctp_association *asoc,\n\t\t\t\t\tsctp_event_timeout_t timeout_type)\n{\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint error = 0;\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy: timer %d\\n\", __func__,\n\t\t\t timeout_type);\n\t\tif (!mod_timer(&asoc->timers[timeout_type], jiffies + (HZ/20)))\n\t\t\tsctp_association_hold(asoc);\n\t\tgoto out_unlock;\n\t}\n\tif (asoc->base.dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(timeout_type),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   (void *)timeout_type, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_association_put(asoc);\n}", "target": 1}
{"code": "static unsigned long kvm_get_tsc_khz(void)\n{\n\tstruct pvclock_vcpu_time_info *src;\n\tsrc = &per_cpu(hv_clock, 0);\n\treturn pvclock_tsc_khz(src);\n}", "target": 0}
{"code": "storageDriverAutostartCallback(virStoragePoolObj *obj,\n                               const void *opaque G_GNUC_UNUSED)\n{\n    virStoragePoolDef *def = virStoragePoolObjGetDef(obj);\n    virStorageBackend *backend;\n    bool started = false;\n    if (!(backend = virStorageBackendForType(def->type)))\n        return;\n    if (virStoragePoolObjIsAutostart(obj) &&\n        !virStoragePoolObjIsActive(obj)) {\n        virStoragePoolObjSetStarting(obj, true);\n        if (backend->startPool &&\n            backend->startPool(obj) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to autostart storage pool '%s': %s\"),\n                           def->name, virGetLastErrorMessage());\n            goto cleanup;\n        }\n        started = true;\n    }\n    if (started) {\n        g_autofree char *stateFile = NULL;\n        stateFile = virFileBuildPath(driver->stateDir, def->name, \".xml\");\n        if (!stateFile ||\n            virStoragePoolSaveState(stateFile, def) < 0 ||\n            storagePoolRefreshImpl(backend, obj, stateFile) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to autostart storage pool '%s': %s\"),\n                           def->name, virGetLastErrorMessage());\n        } else {\n            virStoragePoolObjSetActive(obj, true);\n        }\n    }\n cleanup:\n    if (virStoragePoolObjIsStarting(obj)) {\n        if (!virStoragePoolObjIsActive(obj))\n            virStoragePoolUpdateInactive(obj);\n        virStoragePoolObjSetStarting(obj, false);\n    }\n}", "target": 0}
{"code": "void test_path_dotgit__dotgit_modules_symlink(void)\n{\n\tcl_assert_equal_b(true, git_path_isvalid(NULL, \".gitmodules\", 0, GIT_PATH_REJECT_DOT_GIT_HFS|GIT_PATH_REJECT_DOT_GIT_NTFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_HFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_NTFS));\n\tcl_assert_equal_b(false, git_path_isvalid(NULL, \".gitmodules . .::$DATA\", S_IFLNK, GIT_PATH_REJECT_DOT_GIT_NTFS));\n}", "target": 0}
{"code": "ZEND_API int zend_declare_property(zend_class_entry *ce, const char *name, int name_length, zval *property, int access_type TSRMLS_DC) \n{\n\treturn zend_declare_property_ex(ce, name, name_length, property, access_type, NULL, 0 TSRMLS_CC);\n}", "target": 0}
{"code": "static void mbochs_remove(struct mdev_device *mdev)\n{\n\tstruct mdev_state *mdev_state = dev_get_drvdata(&mdev->dev);\n\tmbochs_used_mbytes -= mdev_state->type->mbytes;\n\tvfio_unregister_group_dev(&mdev_state->vdev);\n\tkfree(mdev_state->pages);\n\tkfree(mdev_state->vconfig);\n\tkfree(mdev_state);\n}", "target": 1}
{"code": "static void ok_jpg_idct_16x16(const int16_t *input, uint8_t *output) {\n    int temp[8 * 16];\n    ok_jpg_idct_1d_col_16(input, temp);\n    ok_jpg_idct_1d_row_16(16, temp, output);\n}", "target": 0}
{"code": "Curves16Data* CurvesAlloc(cmsContext ContextID, int nCurves, int nElements, cmsToneCurve** G)\n{\n    int i, j;\n    Curves16Data* c16;\n    c16 = _cmsMallocZero(ContextID, sizeof(Curves16Data));\n    if (c16 == NULL) return NULL;\n    c16 ->nCurves = nCurves;\n    c16 ->nElements = nElements;\n    c16 ->Curves = _cmsCalloc(ContextID, nCurves, sizeof(cmsUInt16Number*));\n    if (c16 ->Curves == NULL) return NULL;\n    for (i=0; i < nCurves; i++) {\n        c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));\n        if (c16->Curves[i] == NULL) {\n            for (j=0; j < i; j++) {\n                _cmsFree(ContextID, c16->Curves[j]);\n            }\n            _cmsFree(ContextID, c16->Curves);\n            _cmsFree(ContextID, c16);\n            return NULL;\n        }\n        if (nElements == 256) {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], FROM_8_TO_16(j));\n            }\n        }\n        else {\n            for (j=0; j < nElements; j++) {\n                c16 ->Curves[i][j] = cmsEvalToneCurve16(G[i], (cmsUInt16Number) j);\n            }\n        }\n    }\n    return c16;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& grad_in = context->input(1);\n    const Tensor& argmax = context->input(2);\n    PoolParameters params{context,\n                          ksize_,\n                          stride_,\n                          padding_,\n                          {},\n                          FORMAT_NHWC,\n                          tensor_in.shape()};\n    if (!context->status().ok()) {\n      return;\n    }\n    OP_REQUIRES(\n        context, grad_in.shape() == tensor_in.shape(),\n        errors::InvalidArgument(\"Expected grad shape to be \", tensor_in.shape(),\n                                \", but got \", grad_in.shape()));\n    OP_REQUIRES(context, argmax.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected argmax shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", argmax.shape()));\n    TensorShape out_shape({params.tensor_in_batch, params.out_height,\n                           params.out_width, params.depth});\n    Tensor* grad_out = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {0}, 0, out_shape, &grad_out));\n    LaunchMaxPoolingGradGradWithArgmax<Device, T>::launch(\n        context, params, grad_in, argmax, grad_out, include_batch_in_index_);\n  }", "target": 0}
{"code": "void UpstreamRequest::onPerTryTimeout() {\n  if (per_try_idle_timeout_) {\n    per_try_idle_timeout_.reset();\n  }\n  if (!parent_.downstreamResponseStarted()) {\n    ENVOY_STREAM_LOG(debug, \"upstream per try timeout\", *parent_.callbacks());\n    stream_info_.setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamRequestTimeout);\n    parent_.onPerTryTimeout(*this);\n  } else {\n    ENVOY_STREAM_LOG(debug,\n                     \"ignored upstream per try timeout due to already started downstream response\",\n                     *parent_.callbacks());\n  }\n}", "target": 0}
{"code": "static bool reg_type_may_be_null(enum bpf_reg_type type)\n{\n\treturn type == PTR_TO_MAP_VALUE_OR_NULL ||\n\t       type == PTR_TO_SOCKET_OR_NULL ||\n\t       type == PTR_TO_SOCK_COMMON_OR_NULL ||\n\t       type == PTR_TO_TCP_SOCK_OR_NULL;\n}", "target": 0}
{"code": "static inline struct blk_align_bitmap *get_bm(struct blk_mq_hw_ctx *hctx,\n\t\t\t\t\t      struct blk_mq_ctx *ctx)\n{\n\treturn &hctx->ctx_map.map[ctx->index_hw / hctx->ctx_map.bits_per_word];\n}", "target": 0}
{"code": "sf_flac_write_callback (const FLAC__StreamDecoder * UNUSED (decoder), const FLAC__Frame *frame, const int32_t * const buffer [], void *client_data)\n{\tSF_PRIVATE *psf = (SF_PRIVATE*) client_data ;\n\tFLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;\n\tpflac->frame = frame ;\n\tpflac->bufferpos = 0 ;\n\tpflac->bufferbackup = SF_FALSE ;\n\tpflac->wbuffer = buffer ;\n\tflac_buffer_copy (psf) ;\n\treturn FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE ;\n} ", "target": 1}
{"code": "void ewk_view_scrollbars_visible_get(Evas_Object* ewkView, bool* visible)\n{\n    DBG(\"%s, o=%p\", __func__, ewkView);\n    *visible = false;\n    evas_object_smart_callback_call(ewkView, \"scrollbars,visible,get\", visible);\n}", "target": 0}
{"code": "cib_send_plaintext(int sock, xmlNode * msg)\n{\n    char *xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        int rc = 0;\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        len++;                  \n        crm_trace(\"Message on socket %d: size=%d\", sock, len);\n  retry:\n        rc = write(sock, unsent, len);\n        if (rc < 0) {\n            switch (errno) {\n                case EINTR:\n                case EAGAIN:\n                    crm_trace(\"Retry\");\n                    goto retry;\n                default:\n                    crm_perror(LOG_ERR, \"Could only write %d of the remaining %d bytes\", rc, len);\n                    break;\n            }\n        } else if (rc < len) {\n            crm_trace(\"Only sent %d of %d remaining bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n            goto retry;\n        } else {\n            crm_trace(\"Sent %d bytes: %.100s\", rc, xml_text);\n        }\n    }\n    free(xml_text);\n    return NULL;\n}", "target": 1}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringView data = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "apr_byte_t oidc_cache_get(request_rec *r, const char *section, const char *key,\n\t\tchar **value) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tint encrypted = oidc_cfg_cache_encrypt(r);\n\tapr_byte_t rc = TRUE;\n\tchar *msg = NULL;\n\toidc_debug(r, \"enter: %s (section=%s, decrypt=%d, type=%s)\", key, section,\n\t\t\tencrypted, cfg->cache->name);\n\tif (encrypted == 1)\n\t\tkey = oidc_cache_get_hashed_key(r, cfg->crypto_passphrase, key);\n\tconst char *cache_value = NULL;\n\tif (cfg->cache->get(r, section, key, &cache_value) == FALSE) {\n\t\trc = FALSE;\n\t\tgoto out;\n\t}\n\tif (cache_value == NULL)\n\t\tgoto out;\n\tif (encrypted == 0) {\n\t\t*value = apr_pstrdup(r->pool, cache_value);\n\t\tgoto out;\n\t}\n\trc = (oidc_cache_crypto_decrypt(r, cache_value,\n\t\t\toidc_cache_hash_passphrase(r, cfg->crypto_passphrase),\n\t\t\t(unsigned char **) value) > 0);\nout:\n\tmsg = apr_psprintf(r->pool, \"from %s cache backend for %skey %s\",\n\t\t\tcfg->cache->name, encrypted ? \"encrypted \" : \"\", key);\n\tif (rc == TRUE)\n\t\tif (*value != NULL)\n\t\t\toidc_debug(r, \"cache hit: return %d bytes %s\",\n\t\t\t\t\t*value ? (int )strlen(*value) : 0, msg);\n\t\telse\n\t\t\toidc_debug(r, \"cache miss %s\", msg);\n\telse\n\t\toidc_warn(r, \"error retrieving value %s\", msg);\n\treturn rc;\n}", "target": 1}
{"code": "set_bm_backward_skip(UChar* s, UChar* end, OnigEncoding enc ARG_UNUSED,\n\t\t     int** skip)\n{\n  int i, len;\n  if (IS_NULL(*skip)) {\n    *skip = (int* )xmalloc(sizeof(int) * ONIG_CHAR_TABLE_SIZE);\n    if (IS_NULL(*skip)) return ONIGERR_MEMORY;\n  }\n  len = (int )(end - s);\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++)\n    (*skip)[i] = len;\n  for (i = len - 1; i > 0; i--)\n    (*skip)[s[i]] = i;\n  return 0;\n}", "target": 0}
{"code": "static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}", "target": 1}
{"code": "void * CAPSTONE_API cs_winkernel_malloc(size_t size)\n{\n\tNT_ASSERT(size);\n#pragma prefast(suppress : 30030)\t\t\n\tCS_WINKERNEL_MEMBLOCK *block = (CS_WINKERNEL_MEMBLOCK *)ExAllocatePoolWithTag(\n\t\t\tNonPagedPool, size + sizeof(CS_WINKERNEL_MEMBLOCK), CS_WINKERNEL_POOL_TAG);\n\tif (!block) {\n\t\treturn NULL;\n\t}\n\tblock->size = size;\n\treturn block->data;\n}", "target": 1}
{"code": "static bool tls_desc_okay(const struct user_desc *info)\n{\n\tif (LDT_empty(info))\n\t\treturn true;\n\tif (!info->seg_32bit)\n\t\treturn false;\n\treturn true;\n}", "target": 0}
{"code": "__be32 ipv6_select_ident(struct net *net,\n\t\t\t const struct in6_addr *daddr,\n\t\t\t const struct in6_addr *saddr)\n{\n\tstatic u32 ip6_idents_hashrnd __read_mostly;\n\tu32 id;\n\tnet_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_idents_hashrnd, daddr, saddr);\n\treturn htonl(id);\n}", "target": 1}
{"code": "UnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n  srcChars += srcStart;\n  if(srcLength < 0) {\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}", "target": 1}
{"code": "  void libraw_recycle(libraw_data_t *lr)\n  {\n    if (!lr)\n      return;\n    LibRaw *ip = (LibRaw *)lr->parent_class;\n    ip->recycle();\n  }", "target": 0}
{"code": "static MagickBooleanType WriteINLINEImage(const ImageInfo *image_info,\n  Image *image,ExceptionInfo *exception)\n{\n  char\n    *base64,\n    message[MagickPathExtent];\n  const MagickInfo\n    *magick_info;\n  Image\n    *write_image;\n  ImageInfo\n    *write_info;\n  MagickBooleanType\n    status;\n  size_t\n    blob_length,\n    encode_length;\n  unsigned char\n    *blob;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  write_info=CloneImageInfo(image_info);\n  (void) SetImageInfo(write_info,1,exception);\n  if (LocaleCompare(write_info->magick,\"INLINE\") == 0)\n    (void) CopyMagickString(write_info->magick,image->magick,MagickPathExtent);\n  magick_info=GetMagickInfo(write_info->magick,exception);\n  if ((magick_info == (const MagickInfo *) NULL) ||\n      (GetMagickMimeType(magick_info) == (const char *) NULL))\n    ThrowWriterException(CorruptImageError,\"ImageTypeNotSupported\");\n  (void) CopyMagickString(image->filename,write_info->filename,\n    MagickPathExtent);\n  blob_length=2048;\n  write_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (write_image == (Image *) NULL)\n    {\n      write_info=DestroyImageInfo(write_info);\n      return(MagickTrue);\n    }\n  blob=(unsigned char *) ImageToBlob(write_info,write_image,&blob_length,\n    exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (blob == (unsigned char *) NULL)\n    return(MagickFalse);\n  encode_length=0;\n  base64=Base64Encode(blob,blob_length,&encode_length);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  if (base64 == (char *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      base64=DestroyString(base64);\n      return(status);\n    }\n  (void) FormatLocaleString(message,MagickPathExtent,\"data:%s;base64,\",\n    GetMagickMimeType(magick_info));\n  (void) WriteBlobString(image,message);\n  (void) WriteBlobString(image,base64);\n  base64=DestroyString(base64);\n  return(MagickTrue);\n}", "target": 1}
{"code": "int main(int argc, char *argv[] ) {\n\tint i, fails_count=0;\n\tCU_pSuite cryptoUtilsTestSuite, parserTestSuite;\n\tCU_pSuite *suites[] = {\n\t\t&cryptoUtilsTestSuite,\n\t\t&parserTestSuite,\n\t\tNULL\n\t};\n\tif (argc>1) {\n\t\tif (argv[1][0] == '-') {\n\t\t\tif (strcmp(argv[1], \"-verbose\") == 0) {\n\t\t\t\tverbose = 1;\n\t\t\t} else {\n\t\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tprintf (\"Usage:\\n %s [-verbose] to enable extensive logging\\n\", argv[0]);\n\t\t\treturn 1;\n\t\t}\n\t}\n#ifdef HAVE_LIBXML2\n\txmlInitParser();\n#endif\n\tif (CUE_SUCCESS != CU_initialize_registry()) {\n\t\treturn CU_get_error();\n\t}\n\tcryptoUtilsTestSuite = CU_add_suite(\"Bzrtp Crypto Utils\", NULL, NULL);\n\tCU_add_test(cryptoUtilsTestSuite, \"zrtpKDF\", test_zrtpKDF);\n\tCU_add_test(cryptoUtilsTestSuite, \"CRC32\", test_CRC32);\n\tCU_add_test(cryptoUtilsTestSuite, \"algo agreement\", test_algoAgreement);\n\tCU_add_test(cryptoUtilsTestSuite, \"context algo setter and getter\", test_algoSetterGetter);\n\tCU_add_test(cryptoUtilsTestSuite, \"adding mandatory crypto algorithms if needed\", test_addMandatoryCryptoTypesIfNeeded);\n\tparserTestSuite = CU_add_suite(\"Bzrtp ZRTP Packet Parser\", NULL, NULL);\n\tCU_add_test(parserTestSuite, \"Parse\", test_parser);\n\tCU_add_test(parserTestSuite, \"Parse hvi check fail\", test_parser_hvi);\n\tCU_add_test(parserTestSuite, \"Parse Exchange\", test_parserComplete);\n\tCU_add_test(parserTestSuite, \"State machine\", test_stateMachine);\n\tfor(i=0; suites[i]; i++){\n\t\tCU_basic_run_suite(*suites[i]);\n\t\tfails_count += CU_get_number_of_tests_failed();\n\t}\n\tCU_cleanup_registry();\n#ifdef HAVE_LIBXML2\n\txmlCleanupParser();\n#endif\n\treturn (fails_count == 0 ? 0 : 1);\n}", "target": 0}
{"code": "str_lower_case_match(OnigEncoding enc, int case_fold_flag,\n                     const UChar* t, const UChar* tend,\n                     const UChar* p, const UChar* end)\n{\n  int lowlen;\n  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  while (t < tend) {\n    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);\n    q = lowbuf;\n    while (lowlen > 0) {\n      if (t >= tend)    return 0;\n      if (*t++ != *q++) return 0;\n      lowlen--;\n    }\n  }\n  return 1;\n}", "target": 0}
{"code": "void SFS_CompoundExpression(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (! gf_bs_read_int(parser->bs, 1)) return;\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \",\");\n\tSFS_CompoundExpression(parser);\n}", "target": 0}
{"code": "TEST(SpecializeType, ForEachRejectsMalformedInput) {\n  OpDef op;\n  FullTypeDef* t = op.add_output_arg()->mutable_experimental_full_type();\n  t->set_type_id(TFT_FOR_EACH);\n  t->add_args()->set_type_id(TFT_PRODUCT);\n  NodeDef ndef;\n  AttrSlice attrs(ndef);\n  FullTypeDef ft;\n  EXPECT_FALSE(SpecializeType(attrs, op, ft).ok());\n}", "target": 0}
{"code": "void vers_select_conds_t::print(String *str, enum_query_type query_type) const\n{\n  switch (orig_type) {\n  case SYSTEM_TIME_UNSPECIFIED:\n    break;\n  case SYSTEM_TIME_AS_OF:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME AS OF \"));\n    break;\n  case SYSTEM_TIME_FROM_TO:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME FROM \"));\n    end.print(str, query_type, STRING_WITH_LEN(\" TO \"));\n    break;\n  case SYSTEM_TIME_BETWEEN:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME BETWEEN \"));\n    end.print(str, query_type, STRING_WITH_LEN(\" AND \"));\n    break;\n  case SYSTEM_TIME_BEFORE:\n    start.print(str, query_type, STRING_WITH_LEN(\" FOR SYSTEM_TIME BEFORE \"));\n    break;\n  case SYSTEM_TIME_HISTORY:\n    break;\n  case SYSTEM_TIME_ALL:\n    str->append(\" FOR SYSTEM_TIME ALL\");\n    break;\n  }\n}", "target": 0}
{"code": "static int ec2m_field_sanity(void)\n{\n    int ret = 0;\n    BN_CTX *ctx = BN_CTX_new();\n    BIGNUM *p, *a, *b;\n    EC_GROUP *group1 = NULL, *group2 = NULL, *group3 = NULL;\n    TEST_info(\"Testing GF2m hardening\\n\");\n    BN_CTX_start(ctx);\n    p = BN_CTX_get(ctx);\n    a = BN_CTX_get(ctx);\n    if (!TEST_ptr(b = BN_CTX_get(ctx))\n        || !TEST_true(BN_one(a))\n        || !TEST_true(BN_one(b)))\n        goto out;\n    if (!TEST_true(BN_set_word(p, 0xf2)))\n        goto out;\n    if (!TEST_ptr_null(group1 = EC_GROUP_new_curve_GF2m(p, a, b, ctx)))\n        TEST_error(\"Zero constant term accepted in GF2m polynomial\");\n    if (!TEST_true(BN_set_word(p, 0xf3)))\n        goto out;\n    if (!TEST_ptr_null(group2 = EC_GROUP_new_curve_GF2m(p, a, b, ctx)))\n        TEST_error(\"Hexanomial accepted as GF2m polynomial\");\n    if (!TEST_true(BN_set_word(p, 0x71))\n        || !TEST_true(BN_set_bit(p, OPENSSL_ECC_MAX_FIELD_BITS + 1)))\n        goto out;\n    if (!TEST_ptr_null(group3 = EC_GROUP_new_curve_GF2m(p, a, b, ctx)))\n        TEST_error(\"GF2m polynomial degree > %d accepted\",\n                   OPENSSL_ECC_MAX_FIELD_BITS);\n    ret = group1 == NULL && group2 == NULL && group3 == NULL;\n out:\n    EC_GROUP_free(group1);\n    EC_GROUP_free(group2);\n    EC_GROUP_free(group3);\n    BN_CTX_end(ctx);\n    BN_CTX_free(ctx);\n    return ret;\n}", "target": 0}
{"code": "static void process_COM (const uchar * Data, int length)\n{\n    int ch;\n    char Comment[MAX_COMMENT_SIZE+1];\n    int nch;\n    int a;\n    nch = 0;\n    if (length > MAX_COMMENT_SIZE) length = MAX_COMMENT_SIZE; \n    for (a=2;a<length;a++){\n        ch = Data[a];\n        if (ch == '\\r' && Data[a+1] == '\\n') continue; \n        if (ch >= 32 || ch == '\\n' || ch == '\\t'){\n            Comment[nch++] = (char)ch;\n        }else{\n            Comment[nch++] = '?';\n        }\n    }\n    Comment[nch] = '\\0'; \n    if (ShowTags){\n        printf(\"COM marker comment: %s\\n\",Comment);\n    }\n    strcpy(ImageInfo.Comments,Comment);\n}", "target": 1}
{"code": "void NotificationService::RemoveObserver(NotificationObserver* observer,\n                                          NotificationType type,\n                                          const NotificationSource& source) {\n   DCHECK(type.value < NotificationType::NOTIFICATION_TYPE_COUNT);\n  CHECK(HasKey(observers_[type.value], source));\n   NotificationObserverList* observer_list =\n       observers_[type.value][source.map_key()];\n  if (observer_list) {\n    observer_list->RemoveObserver(observer);\n#ifndef NDEBUG\n    --observer_counts_[type.value];\n#endif\n  }\n}", "target": 0}
{"code": "ext2_xattr_put_super(struct super_block *sb)\n{\n}", "target": 1}
{"code": "ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch(type) {\n\t\tcase ACL_TYPE_ACCESS:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\t\tif (acl) {\n\t\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\t\tif (error < 0)\n\t\t\t\t\treturn error;\n\t\t\t\telse {\n\t\t\t\t\tinode->i_ctime = CURRENT_TIME_SEC;\n\t\t\t\t\tmark_inode_dirty(inode);\n\t\t\t\t\tif (error == 0)\n\t\t\t\t\t\tacl = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACL_TYPE_DEFAULT:\n\t\t\tname_index = EXT2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\t\treturn acl ? -EACCES : 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n \tif (acl) {\n\t\tvalue = ext2_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = ext2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "int main()\n{\n    gdImagePtr im;\n    FILE *fp;\n    fp = gdTestFileOpen2(\"gd2\", \"bug00354a.gd2\");\n    gdTestAssert(fp != NULL);\n    im = gdImageCreateFromGd2(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    fp = gdTestFileOpen2(\"gd2\", \"bug00354b.gd2\");\n    gdTestAssert(fp != NULL);\n    im = gdImageCreateFromGd2(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}", "target": 0}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "pci_lintr_request(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint bestpin, bestcount, pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tbestpin = 0;\n\tbestcount = si->si_intpins[0].ii_count;\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tif (si->si_intpins[pin].ii_count < bestcount) {\n\t\t\tbestpin = pin;\n\t\t\tbestcount = si->si_intpins[pin].ii_count;\n\t\t}\n\t}\n\tsi->si_intpins[bestpin].ii_count++;\n\tdev->lintr.pin = bestpin + 1;\n\tpci_set_cfgdata8(dev, PCIR_INTPIN, bestpin + 1);\n}", "target": 1}
{"code": "static int _sqlite_rollback_txn(void *db, const sasl_utils_t *utils)\n{\n    return _sqlite_exec(db, \"ROLLBACK TRANSACTION\", NULL, 0, NULL, utils);\n}", "target": 0}
{"code": "void kvm_arch_mmu_notifier_invalidate_page(struct kvm *kvm,\n\t\t\t\t\t   unsigned long address)\n{\n\tif (address == gfn_to_hva(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT))\n\t\tkvm_make_all_cpus_request(kvm, KVM_REQ_APIC_PAGE_RELOAD);\n}", "target": 0}
{"code": "void CLua::init_libraries()\n{\n    lua_stack_cleaner clean(state());\n    lua_pushcfunction(_state, lua_loadstring);\n    lua_setglobal(_state, \"loadstring\");\n    lua_pushnil(_state);\n    lua_setglobal(_state, \"load\");\n    cluaopen_kills(_state);\n    cluaopen_you(_state);\n    cluaopen_item(_state);\n    cluaopen_food(_state);\n    cluaopen_crawl(_state);\n    cluaopen_file(_state);\n    cluaopen_moninf(_state);\n    cluaopen_options(_state);\n    cluaopen_travel(_state);\n    cluaopen_view(_state);\n    cluaopen_spells(_state);\n    cluaopen_globals(_state);\n    execfile(\"dlua/macro.lua\", true, true);\n    execstring(\"chk_startgame = { }\", \"base\");\n    lua_register(_state, \"loadfile\", _clua_loadfile);\n    lua_register(_state, \"dofile\", _clua_dofile);\n    lua_register(_state, \"crawl_require\", _clua_require);\n    execfile(\"dlua/util.lua\", true, true);\n    execfile(\"dlua/iter.lua\", true, true);\n    execfile(\"dlua/tags.lua\", true, true);\n    execfile(\"dlua/init.lua\", true, true);\n    if (managed_vm)\n    {\n        lua_register(_state, \"pcall\", _clua_guarded_pcall);\n        execfile(\"dlua/userbase.lua\", true, true);\n        execfile(\"dlua/persist.lua\", true, true);\n    }\n}", "target": 0}
{"code": "boost::optional<SaplingOutgoingPlaintext> SaplingOutgoingPlaintext::decrypt(\n    const SaplingOutCiphertext &ciphertext,\n    const uint256& ovk,\n    const uint256& cv,\n    const uint256& cm,\n    const uint256& epk\n)\n{\n    auto pt = AttemptSaplingOutDecryption(ciphertext, ovk, cv, cm, epk);\n    if (!pt) {\n        return boost::none;\n    }\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n    SaplingOutgoingPlaintext ret;\n    ss >> ret;\n    assert(ss.size() == 0);\n    return ret;\n}", "target": 1}
{"code": "static int t220_frontend_attach(struct dvb_usb_adapter *d)\n{\n\tu8 obuf[3] = { 0xe, 0x87, 0 };\n\tu8 ibuf[] = { 0 };\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x86;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 0;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tmsleep(50);\n\tobuf[0] = 0xe;\n\tobuf[1] = 0x80;\n\tobuf[2] = 1;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x0e transfer failed.\");\n\tobuf[0] = 0x51;\n\tif (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)\n\t\terr(\"command 0x51 transfer failed.\");\n\td->fe_adap[0].fe = dvb_attach(cxd2820r_attach, &cxd2820r_config,\n\t\t\t\t\t&d->dev->i2c_adap, NULL);\n\tif (d->fe_adap[0].fe != NULL) {\n\t\tif (dvb_attach(tda18271_attach, d->fe_adap[0].fe, 0x60,\n\t\t\t\t\t&d->dev->i2c_adap, &tda18271_config)) {\n\t\t\tinfo(\"Attached TDA18271HD/CXD2820R!\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tinfo(\"Failed to attach TDA18271HD/CXD2820R!\");\n\treturn -EIO;\n}", "target": 1}
{"code": "void json_object_seed(size_t seed) {\n    uint32_t new_seed = (uint32_t)seed;\n    if (hashtable_seed == 0) {\n        if (__atomic_test_and_set(&seed_initialized, __ATOMIC_RELAXED) == 0) {\n            if (new_seed == 0)\n                new_seed = generate_seed();\n            __atomic_store_n(&hashtable_seed, new_seed, __ATOMIC_ACQ_REL);\n        } else {\n            do {\n#ifdef HAVE_SCHED_YIELD\n                sched_yield();\n#endif\n            } while(__atomic_load_n(&hashtable_seed, __ATOMIC_ACQUIRE) == 0);\n        }\n    }\n}", "target": 0}
{"code": "qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t\tconst char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & QEDI_LOG_NOTICE))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_notice(\"[%s]:[%s:%d]:%d: %pV\",\n\t\t\t  dev_name(&qedi->pdev->dev), nfunc, line,\n\t\t\t  qedi->host_no, &vaf);\n\telse\n\t\tpr_notice(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "TfLiteStatus Gather(const TfLiteGatherParams& params, const TfLiteTensor* input,\n                    const TfLiteTensor* positions, TfLiteTensor* output) {\n  tflite::GatherParams op_params;\n  op_params.axis = params.axis;\n  op_params.batch_dims = params.batch_dims;\n  optimized_ops::Gather(op_params, GetTensorShape(input),\n                        GetTensorData<InputT>(input), GetTensorShape(positions),\n                        GetTensorData<PositionsT>(positions),\n                        GetTensorShape(output), GetTensorData<InputT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "format_nstime_as_iso8601(gchar *buf, size_t buflen, const nstime_t *ns,\n    char *decimal_point, gboolean local, int precision)\n{\n\tstruct tm tm, *tmp;\n\tgchar *ptr;\n\tsize_t buf_remaining;\n\tint num_chars;\n\tif (local)\n\t\ttmp = ws_localtime_r(&ns->secs, &tm);\n\telse\n\t\ttmp = ws_gmtime_r(&ns->secs, &tm);\n\tif (tmp == NULL) {\n\t\tsnprintf(buf, buflen, \"Not representable\");\n\t\treturn;\n\t}\n\tptr = buf;\n\tbuf_remaining = buflen;\n\tnum_chars = snprintf(ptr, buf_remaining,\n\t    \"%04d-%02d-%02d %02d:%02d:%02d\",\n\t    tmp->tm_year + 1900,\n\t    tmp->tm_mon + 1,\n\t    tmp->tm_mday,\n\t    tmp->tm_hour,\n\t    tmp->tm_min,\n\t    tmp->tm_sec);\n\tif (num_chars < 0) {\n\t\tsnprintf(buf, buflen, \"snprintf() failed\");\n\t\treturn;\n\t}\n\tif ((unsigned int)num_chars >= buf_remaining) {\n\t\treturn;\n\t}\n\tptr += num_chars;\n\tbuf_remaining -= num_chars;\n\tif (precision == 0) {\n\t\treturn;\n\t}\n\tformat_fractional_part_nsecs(ptr, buf_remaining, (guint32)ns->nsecs, decimal_point, precision);\n}", "target": 1}
{"code": "static char *handle_new_problem(GVariant *problem_info, uid_t caller_uid, char **error)\n{\n    problem_data_t *pd = problem_data_new();\n    GVariantIter *iter;\n    g_variant_get(problem_info, \"a{ss}\", &iter);\n    gchar *key, *value;\n    while (g_variant_iter_loop(iter, \"{ss}\", &key, &value))\n    {\n        problem_data_add_text_editable(pd, key, value);\n    }\n    if (caller_uid != 0 || problem_data_get_content_or_NULL(pd, FILENAME_UID) == NULL)\n    {   \n        log_info(\"Adding UID %d to problem data\", caller_uid);\n        char buf[sizeof(uid_t) * 3 + 2];\n        snprintf(buf, sizeof(buf), \"%d\", caller_uid);\n        problem_data_add_text_noteditable(pd, FILENAME_UID, buf);\n    }\n    problem_data_add_basics(pd);\n    char *problem_id = problem_data_save(pd);\n    if (problem_id)\n        notify_new_path(problem_id);\n    else if (error)\n        *error = xasprintf(\"Cannot create a new problem\");\n    problem_data_free(pd);\n    return problem_id;\n}", "target": 1}
{"code": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\t*ie_ptr = ie;\n\treturn 0;\n}", "target": 0}
{"code": "nfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp++;\t\t\t\t\n\targs->offset = ntohl(*p++);\t\n\tp++;\t\t\t\t\n\tlen = args->len = ntohl(*p++);\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}", "target": 0}
{"code": "static void LodePNGIText_init(LodePNGInfo* info)\n{\n  info->itext_num = 0;\n  info->itext_keys = NULL;\n  info->itext_langtags = NULL;\n  info->itext_transkeys = NULL;\n  info->itext_strings = NULL;\n}", "target": 0}
{"code": "void EditorClientBlackBerry::didWriteSelectionToPasteboard()\n{\n    notImplemented();\n}", "target": 0}
{"code": "pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len;\n\tuint16_t idx;\n\tsc = vsc;\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\twhile (vq_has_descs(vq)) {\n\t\tvq_getchain(vq, &idx, &iov, 1, NULL);\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\t\tassert(len > 0);\n\t\tvq_relchain(vq, idx, (uint32_t)len);\n\t}\n\tvq_endchains(vq, 1);\t\n}", "target": 1}
{"code": "void FormatConverter<T>::InitSparseToDenseConverter(\n    std::vector<int> shape, std::vector<int> traversal_order,\n    std::vector<TfLiteDimensionType> format, std::vector<int> dense_size,\n    std::vector<std::vector<int>> segments,\n    std::vector<std::vector<int>> indices, std::vector<int> block_map) {\n  dense_shape_ = std::move(shape);\n  traversal_order_ = std::move(traversal_order);\n  block_map_ = std::move(block_map);\n  format_ = std::move(format);\n  dense_size_ = 1;\n  for (int i = 0; i < dense_shape_.size(); i++) {\n    dense_size_ *= dense_shape_[i];\n  }\n  dim_metadata_.resize(2 * format_.size());\n  for (int i = 0; i < format_.size(); i++) {\n    if (format_[i] == kTfLiteDimDense) {\n      dim_metadata_[2 * i] = {dense_size[i]};\n    } else {\n      dim_metadata_[2 * i] = std::move(segments[i]);\n      dim_metadata_[2 * i + 1] = std::move(indices[i]);\n    }\n  }\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const auto& input = context->input(0);\n    auto flat_in = input.flat<tstring>();\n    int fixed_length;\n    const auto& length_input = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(length_input.shape()),\n                errors::InvalidArgument(\"k must be scalar, got shape \",\n                                        length_input.shape().DebugString()));\n    fixed_length = length_input.scalar<int32>()();\n    OP_REQUIRES(\n        context, fixed_length % sizeof(T) == 0,\n        errors::InvalidArgument(\n            \"fixed_length (\", fixed_length,\n            \") must be a multiple of the size of out_type (\", sizeof(T), \")\"));\n    OP_REQUIRES(context, fixed_length > 0,\n                errors::InvalidArgument(\"fixed_length (\", fixed_length,\n                                        \") must be greater than zero.\"));\n    int width = fixed_length / sizeof(T);\n    TensorShape out_shape = input.shape();\n    out_shape.AddDim(width);\n    Tensor* output_tensor = nullptr;\n    OP_REQUIRES_OK(\n        context, context->allocate_output(\"output\", out_shape, &output_tensor));\n    if (flat_in.size() == 0) {  \n      return;\n    }\n    auto out = output_tensor->flat_inner_dims<T>();\n    T* out_data = out.data();\n    memset(out_data, 0, fixed_length * flat_in.size());\n    if (!convert_data_endianness_ || sizeof(T) == 1) {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const T* in_data = reinterpret_cast<const T*>(flat_in(i).data());\n        if (flat_in(i).size() > fixed_length) {\n          memcpy(out_data, in_data, fixed_length);\n        } else {\n          memcpy(out_data, in_data, flat_in(i).size());\n        }\n        out_data += fixed_length;\n      }\n    } else {\n      for (int64 i = 0; i < flat_in.size(); ++i) {\n        const char* in_data_bytes =\n            reinterpret_cast<const char*>(flat_in(i).data());\n        char* out_data_bytes = reinterpret_cast<char*>(out_data);\n        const char* p_in = in_data_bytes;\n        char* p_out = out_data_bytes;\n        for (; p_in < in_data_bytes + fixed_length;\n             p_in += sizeof(T), p_out += sizeof(T)) {\n          std::reverse_copy(p_in, p_in + sizeof(T), p_out);\n        }\n        out_data += fixed_length;\n      }\n    }\n  }", "target": 1}
{"code": "static OPJ_BOOL opj_j2k_write_sod(opj_j2k_t *p_j2k,\n                                  opj_tcd_t * p_tile_coder,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 * p_data_written,\n                                  OPJ_UINT32 p_total_data_size,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    opj_codestream_info_t *l_cstr_info = 00;\n    OPJ_UINT32 l_remaining_data;\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    OPJ_UNUSED(p_stream);\n    if (p_total_data_size < 4) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOD marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_write_bytes(p_data, J2K_MS_SOD,\n                    2);                                 \n    p_data += 2;\n    l_remaining_data =  p_total_data_size - 4;\n    p_tile_coder->tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;\n    p_tile_coder->cur_tp_num =\n        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;\n#ifdef USE_JPWL\n    assert(0 && \"TODO\");\n#endif \n    if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {\n        p_tile_coder->tcd_image->tiles->packno = 0;\n        if (l_cstr_info) {\n            l_cstr_info->packno = 0;\n        }\n    }\n    *p_data_written = 0;\n    if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data,\n                              p_data_written, l_remaining_data, l_cstr_info,\n                              p_manager)) {\n        opj_event_msg(p_manager, EVT_ERROR, \"Cannot encode tile\\n\");\n        return OPJ_FALSE;\n    }\n    *p_data_written += 2;\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "static const char *adpt_i2o_get_class_name(int class)\n{\n\tint idx = 16;\n\tstatic char *i2o_class_name[] = {\n\t\t\"Executive\",\n\t\t\"Device Driver Module\",\n\t\t\"Block Device\",\n\t\t\"Tape Device\",\n\t\t\"LAN Interface\",\n\t\t\"WAN Interface\",\n\t\t\"Fibre Channel Port\",\n\t\t\"Fibre Channel Device\",\n\t\t\"SCSI Device\",\n\t\t\"ATE Port\",\n\t\t\"ATE Device\",\n\t\t\"Floppy Controller\",\n\t\t\"Floppy Device\",\n\t\t\"Secondary Bus Port\",\n\t\t\"Peer Transport Agent\",\n\t\t\"Peer Transport\",\n\t\t\"Unknown\"\n\t};\n\tswitch(class&0xFFF) {\n\tcase I2O_CLASS_EXECUTIVE:\n\t\tidx = 0; break;\n\tcase I2O_CLASS_DDM:\n\t\tidx = 1; break;\n\tcase I2O_CLASS_RANDOM_BLOCK_STORAGE:\n\t\tidx = 2; break;\n\tcase I2O_CLASS_SEQUENTIAL_STORAGE:\n\t\tidx = 3; break;\n\tcase I2O_CLASS_LAN:\n\t\tidx = 4; break;\n\tcase I2O_CLASS_WAN:\n\t\tidx = 5; break;\n\tcase I2O_CLASS_FIBRE_CHANNEL_PORT:\n\t\tidx = 6; break;\n\tcase I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL:\n\t\tidx = 7; break;\n\tcase I2O_CLASS_SCSI_PERIPHERAL:\n\t\tidx = 8; break;\n\tcase I2O_CLASS_ATE_PORT:\n\t\tidx = 9; break;\n\tcase I2O_CLASS_ATE_PERIPHERAL:\n\t\tidx = 10; break;\n\tcase I2O_CLASS_FLOPPY_CONTROLLER:\n\t\tidx = 11; break;\n\tcase I2O_CLASS_FLOPPY_DEVICE:\n\t\tidx = 12; break;\n\tcase I2O_CLASS_BUS_ADAPTER_PORT:\n\t\tidx = 13; break;\n\tcase I2O_CLASS_PEER_TRANSPORT_AGENT:\n\t\tidx = 14; break;\n\tcase I2O_CLASS_PEER_TRANSPORT:\n\t\tidx = 15; break;\n\t}\n\treturn i2o_class_name[idx];\n}", "target": 1}
{"code": "build_ycc_rgb_table(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  int i;\n  JLONG x;\n  SHIFT_TEMPS\n  upsample->Cr_r_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cb_b_tab = (int *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(int));\n  upsample->Cr_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  upsample->Cb_g_tab = (JLONG *)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                (MAXJSAMPLE + 1) * sizeof(JLONG));\n  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {\n    upsample->Cr_r_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.40200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cb_b_tab[i] = (int)\n                    RIGHT_SHIFT(FIX(1.77200) * x + ONE_HALF, SCALEBITS);\n    upsample->Cr_g_tab[i] = (-FIX(0.71414)) * x;\n    upsample->Cb_g_tab[i] = (-FIX(0.34414)) * x + ONE_HALF;\n  }\n}", "target": 1}
{"code": "date_s_rfc3339(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    if (!NIL_P(opt)) argc--;\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01T00:00:00+00:00\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        if (!NIL_P(opt)) argv2[argc2++] = opt;\n\tVALUE hash = date_s__rfc3339(argc2, argv2, klass);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "scrypt_SHA256_Final(unsigned char digest[32], struct SHA256_CTX * ctx)\n{\n  SHA256_Pad(ctx);\n  be32enc_vect(digest, ctx->state, 32);\n  memset((void *)ctx, 0, sizeof(*ctx));\n}", "target": 1}
{"code": "    void setPrivate(bool p) { is_private = p; }", "target": 0}
{"code": "int BN_is_one(const BIGNUM *a)\n{\n    return BN_abs_is_word(a, 1) && !a->neg;\n}", "target": 0}
{"code": "static int acurite_leak_detector_decode(r_device* decoder, uint8_t* bb)\n{\n    int parity = parity_bytes(&bb[2], 4);\n    if (parity) {\n        decoder_log_bitrow(decoder, 1, __func__, bb, 7 * 8, \"bad parity\");\n        return DECODE_FAIL_MIC;\n    }\n    char const* channel_str = acurite_getChannel(bb[0]);\n    if (*channel_str == 'E') {\n        decoder_logf(decoder, 1, __func__, \"Acurite TXR sensor : bad channel Ch %s\", channel_str);\n        return DECODE_FAIL_SANITY;\n    }\n    int sensor_id = ((bb[0] & 0x3f) << 8) | bb[1];\n    int battery_low = (bb[2] & 0x40) == 0;\n    int is_wet = (bb[3] & 0x10) >> 4;\n    data_t* data;\n    data = data_make(\n            \"model\",                \"\",             DATA_STRING, \"Acurite-Leak\",\n            \"id\",                   \"\",             DATA_INT,    sensor_id,\n            \"channel\",              NULL,           DATA_STRING, channel_str,\n            \"battery_ok\",           \"Battery\",      DATA_INT,    !battery_low,\n            \"leak_detected\",        \"Leak\",         DATA_INT,    is_wet,\n            \"mic\",                  \"Integrity\",    DATA_STRING, \"CHECKSUM\",\n            NULL);\n    decoder_output_data(decoder, data);\n    return 1;\n}", "target": 0}
{"code": "TfLiteStatus EvalHashtableImport(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputResourceIdTensor);\n  const int resource_id = input_resource_id_tensor->data.i32[0];\n  const TfLiteTensor* key_tensor = GetInput(context, node, kKeyTensor);\n  const TfLiteTensor* value_tensor = GetInput(context, node, kValueTensor);\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  auto* lookup = resource::GetHashtableResource(&resources, resource_id);\n  TF_LITE_ENSURE(context, lookup != nullptr);\n  TF_LITE_ENSURE_STATUS(\n      lookup->CheckKeyAndValueTypes(context, key_tensor, value_tensor));\n  auto result = lookup->Import(context, key_tensor, value_tensor);\n  return result;\n}", "target": 1}
{"code": "static void Sp_search(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tResub m;\n\ttext = checkstring(J, 0);\n\tif (js_isregexp(J, 1))\n\t\tjs_copy(J, 1);\n\telse if (js_isundefined(J, 1))\n\t\tjs_newregexp(J, \"\", 0);\n\telse\n\t\tjs_newregexp(J, js_tostring(J, 1), 0);\n\tre = js_toregexp(J, -1);\n\tif (!js_regexec(re->prog, text, &m, 0))\n\t\tjs_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));\n\telse\n\t\tjs_pushnumber(J, -1);\n}", "target": 1}
{"code": "test_string_escape (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (escapes); idx++)\n    {\n      EscapeData *data = &escapes[idx];\n      g_autofree char *ret = NULL;\n      ret = flatpak_escape_string (data->in, data->flags);\n      g_assert_cmpstr (ret, ==, data->out);\n    }\n}", "target": 0}
{"code": "file_push_buffer(struct magic_set *ms)\n{\n\tfile_pushbuf_t *pb;\n\tif (ms->event_flags & EVENT_HAD_ERR)\n\t\treturn NULL;\n\tif ((pb = (CAST(file_pushbuf_t *, malloc(sizeof(*pb))))) == NULL)\n\t\treturn NULL;\n\tpb->buf = ms->o.buf;\n\tpb->offset = ms->offset;\n\tms->o.buf = NULL;\n\tms->offset = 0;\n\treturn pb;\n}", "target": 0}
{"code": "  void MakeDataset(OpKernelContext* ctx, DatasetBase** output) override {\n    const Tensor* indices;\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices));\n    const Tensor* values;\n    OP_REQUIRES_OK(ctx, ctx->input(\"values\", &values));\n    const Tensor* dense_shape;\n    OP_REQUIRES_OK(ctx, ctx->input(\"dense_shape\", &dense_shape));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsMatrix(indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    indices->shape().DebugString()));\n    const auto num_indices = indices->NumElements();\n    const auto num_values = values->NumElements();\n    if (num_indices == 0 || num_values == 0) {\n      OP_REQUIRES(ctx, num_indices == num_values,\n                  errors::InvalidArgument(\n                      \"If indices or values are empty, the other one must also \"\n                      \"be. Got indices of shape \",\n                      indices->shape().DebugString(), \" and values of shape \",\n                      values->shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    indices->shape().DebugString()));\n    OP_REQUIRES(ctx, TensorShapeUtils::IsVector(dense_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    dense_shape->shape().DebugString()));\n    int64_t previous_batch_index = -1;\n    for (int64_t i = 0; i < indices->dim_size(0); ++i) {\n      int64_t next_batch_index = indices->matrix<int64_t>()(i, 0);\n      OP_REQUIRES(\n          ctx, next_batch_index >= previous_batch_index,\n          errors::Unimplemented(\"The SparseTensor must be ordered in the batch \"\n                                \"dimension; handling arbitrarily ordered input \"\n                                \"is not currently supported.\"));\n      previous_batch_index = next_batch_index;\n    }\n    gtl::InlinedVector<int64_t, 8> std_order(dense_shape->NumElements(), 0);\n    sparse::SparseTensor tensor;\n    OP_REQUIRES_OK(\n        ctx, sparse::SparseTensor::Create(\n                 *indices, *values, TensorShape(dense_shape->vec<int64_t>()),\n                 std_order, &tensor));\n    *output = new Dataset<T>(ctx, std::move(tensor));\n  }", "target": 1}
{"code": "static GF_AV1Config* AV1_DuplicateConfig(GF_AV1Config const * const cfg) {\n\tu32 i = 0;\n\tGF_AV1Config *out = gf_malloc(sizeof(GF_AV1Config));\n\tout->marker = cfg->marker;\n\tout->version = cfg->version;\n\tout->seq_profile = cfg->seq_profile;\n\tout->seq_level_idx_0 = cfg->seq_level_idx_0;\n\tout->seq_tier_0 = cfg->seq_tier_0;\n\tout->high_bitdepth = cfg->high_bitdepth;\n\tout->twelve_bit = cfg->twelve_bit;\n\tout->monochrome = cfg->monochrome;\n\tout->chroma_subsampling_x = cfg->chroma_subsampling_x;\n\tout->chroma_subsampling_y = cfg->chroma_subsampling_y;\n\tout->chroma_sample_position = cfg->chroma_sample_position;\n\tout->initial_presentation_delay_present = cfg->initial_presentation_delay_present;\n\tout->initial_presentation_delay_minus_one = cfg->initial_presentation_delay_minus_one;\n\tout->obu_array = gf_list_new();\n\tfor (i = 0; i<gf_list_count(cfg->obu_array); ++i) {\n\t\tGF_AV1_OBUArrayEntry *dst = gf_malloc(sizeof(GF_AV1_OBUArrayEntry)), *src = gf_list_get(cfg->obu_array, i);\n\t\tdst->obu_length = src->obu_length;\n\t\tdst->obu_type = src->obu_type;\n\t\tdst->obu = gf_malloc((size_t)dst->obu_length);\n\t\tmemcpy(dst->obu, src->obu, (size_t)src->obu_length);\n\t\tgf_list_add(out->obu_array, dst);\n\t}\n\treturn out;\n}", "target": 1}
{"code": "int propagate_mnt(struct mount *dest_mnt, struct mountpoint *dest_mp,\n\t\t    struct mount *source_mnt, struct hlist_head *tree_list)\n{\n\tstruct mount *m, *n;\n\tint ret = 0;\n\tuser_ns = current->nsproxy->mnt_ns->user_ns;\n\tlast_dest = dest_mnt;\n\tfirst_source = source_mnt;\n\tlast_source = source_mnt;\n\tmp = dest_mp;\n\tlist = tree_list;\n\tdest_master = dest_mnt->mnt_master;\n\tfor (n = next_peer(dest_mnt); n != dest_mnt; n = next_peer(n)) {\n\t\tret = propagate_one(n);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tfor (m = next_group(dest_mnt, dest_mnt); m;\n\t\t\tm = next_group(m, dest_mnt)) {\n\t\tn = m;\n\t\tdo {\n\t\t\tret = propagate_one(n);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tn = next_peer(n);\n\t\t} while (n != m);\n\t}\nout:\n\tread_seqlock_excl(&mount_lock);\n\thlist_for_each_entry(n, tree_list, mnt_hash) {\n\t\tm = n->mnt_parent;\n\t\tif (m->mnt_master != dest_mnt->mnt_master)\n\t\t\tCLEAR_MNT_MARK(m->mnt_master);\n\t}\n\tread_sequnlock_excl(&mount_lock);\n\treturn ret;\n}", "target": 0}
{"code": "TEST_F(HermesRuntimeTest, SpreadHostObjectWithOwnProperties) {\n  class HostObjectWithPropertyNames : public HostObject {\n    std::vector<PropNameID> getPropertyNames(Runtime &rt) override {\n      return PropNameID::names(rt, \"prop1\", \"1\", \"2\", \"prop2\", \"3\");\n    }\n    Value get(Runtime &runtime, const PropNameID &name) override {\n      return Value();\n    }\n  };\n  Object ho = Object::createFromHostObject(\n      *rt, std::make_shared<HostObjectWithPropertyNames>());\n  rt->global().setProperty(*rt, \"ho\", ho);\n  auto res = eval(R\"###(\nvar spreaded = {...ho};\nvar props = Object.getOwnPropertyNames(spreaded);\nprops.toString();\n)###\")\n                 .getString(*rt)\n                 .utf8(*rt);\n  EXPECT_EQ(res, \"1,2,3,prop1,prop2\");\n}", "target": 0}
{"code": "int kvm_arch_vcpu_ioctl_translate(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_translation *tr)\n{\n\tunsigned long vaddr = tr->linear_address;\n\tgpa_t gpa;\n\tint idx;\n\tidx = srcu_read_lock(&vcpu->kvm->srcu);\n\tgpa = kvm_mmu_gva_to_gpa_system(vcpu, vaddr, NULL);\n\tsrcu_read_unlock(&vcpu->kvm->srcu, idx);\n\ttr->physical_address = gpa;\n\ttr->valid = gpa != UNMAPPED_GVA;\n\ttr->writeable = 1;\n\ttr->usermode = 0;\n\treturn 0;\n}", "target": 0}
{"code": "size_t mobi_get_attribute_value(char *value, const unsigned char *data, const size_t size, const char *attribute, bool only_quoted) {\n    if (!data) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return SIZE_MAX;\n    }\n    size_t length = size;\n    size_t attr_length = strlen(attribute);\n    if (attr_length > MOBI_ATTRNAME_MAXSIZE) {\n        debug_print(\"Attribute too long: %zu\\n\", attr_length);\n        return SIZE_MAX;\n    }\n    char attr[MOBI_ATTRNAME_MAXSIZE + 2];\n    strcpy(attr, attribute);\n    strcat(attr, \"=\");\n    attr_length++;\n    if (size < attr_length) {\n        return SIZE_MAX;\n    }\n    unsigned char last_border = '\\0';\n    do {\n        if (*data == '<' || *data == '>') {\n            last_border = *data;\n        }\n        if (length > attr_length + 1 && memcmp(data, attr, attr_length) == 0) {\n            size_t offset = size - length;\n            if (last_border == '>') {\n                data += attr_length;\n                length -= attr_length - 1;\n                continue;\n            }\n            if (offset > 0) {\n                if (data[-1] != '<' && !isspace(data[-1])) {\n                    data += attr_length;\n                    length -= attr_length - 1;\n                    continue;\n                }\n            }\n            data += attr_length;\n            length -= attr_length;\n            unsigned char separator;\n            if (*data != '\\'' && *data != '\"') {\n                if (only_quoted) {\n                    continue;\n                }\n                separator = ' ';\n            } else {\n                separator = *data;\n                data++;\n                length--;\n            }\n            size_t j;\n            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            if (*(data - 1) == '/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            return size - length - j;\n        }\n        data++;\n    } while (--length);\n    value[0] = '\\0';\n    return SIZE_MAX;\n}", "target": 1}
{"code": "void* CxImage::Create(uint32_t dwWidth, uint32_t dwHeight, uint32_t wBpp, uint32_t imagetype)\n{\n\tif (!Destroy())\n\t\treturn NULL;\n\tif ((dwWidth == 0) || (dwHeight == 0)){\n\t\tstrcpy(info.szLastError,\"CxImage::Create : width and height must be greater than zero\");\n\t\treturn NULL;\n\t}\n    if\t\t(wBpp <= 1)\twBpp = 1;\n    else if (wBpp <= 4)\twBpp = 4;\n    else if (wBpp <= 8)\twBpp = 8;\n    else\t\t\t\twBpp = 24;\n\tif ((((float)dwWidth*(float)dwHeight*(float)wBpp)/8.0f) > (float)CXIMAGE_MAX_MEMORY)\n\t{\n\t\tstrcpy(info.szLastError,\"CXIMAGE_MAX_MEMORY exceeded\");\n\t\treturn NULL;\n\t}\n    switch (wBpp){\n        case 1:\n            head.biClrUsed = 2;\tbreak;\n        case 4:\n            head.biClrUsed = 16; break;\n        case 8:\n            head.biClrUsed = 256; break;\n        default:\n            head.biClrUsed = 0;\n    }\n    info.dwEffWidth = ((((wBpp * dwWidth) + 31) / 32) * 4);\n    info.dwType = imagetype;\n\thead.biSize = sizeof(BITMAPINFOHEADER); \n    head.biWidth = dwWidth;\t\t\n    head.biHeight = dwHeight;\t\n    head.biPlanes = 1;\t\t\t\n    head.biBitCount = (uint16_t)wBpp;\t\t\n    head.biCompression = BI_RGB;    \n    head.biSizeImage = info.dwEffWidth * dwHeight;\n\tpDib = malloc(GetSize()); \n    if (!pDib){\n\t\tstrcpy(info.szLastError,\"CxImage::Create can't allocate memory\");\n\t\treturn NULL;\n\t}\n    pDibLimit = (void*)((uint8_t*)pDib + GetSize());\n\tRGBQUAD* pal=GetPalette();\n\tif (pal) memset(pal,0,GetPaletteSize());\n#if CXIMAGE_SUPPORT_SELECTION\n\tif (pSelection) SelectionDelete();\n#endif \n#if CXIMAGE_SUPPORT_ALPHA\n\tif (pAlpha) AlphaDelete();\n#endif \n    BITMAPINFOHEADER*  lpbi;\n\tlpbi = (BITMAPINFOHEADER*)(pDib);\n    *lpbi = head;\n\tinfo.pImage=GetBits();\n    return pDib; \n}", "target": 0}
{"code": "sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}", "target": 1}
{"code": "static int get_bitmap_file(struct mddev *mddev, void __user * arg)\n{\n\tmdu_bitmap_file_t *file = NULL; \n\tchar *ptr;\n\tint err;\n\tfile = kmalloc(sizeof(*file), GFP_NOIO);\n\tif (!file)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tspin_lock(&mddev->lock);\n\tif (!mddev->bitmap_info.file)\n\t\tfile->pathname[0] = '\\0';\n\telse if ((ptr = file_path(mddev->bitmap_info.file,\n\t\t\t       file->pathname, sizeof(file->pathname))),\n\t\t IS_ERR(ptr))\n\t\terr = PTR_ERR(ptr);\n\telse\n\t\tmemmove(file->pathname, ptr,\n\t\t\tsizeof(file->pathname)-(ptr-file->pathname));\n\tspin_unlock(&mddev->lock);\n\tif (err == 0 &&\n\t    copy_to_user(arg, file, sizeof(*file)))\n\t\terr = -EFAULT;\n\tkfree(file);\n\treturn err;\n}", "target": 1}
{"code": "decode_definite_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL;\n    char *buf;\n    buf = PyMem_Malloc(length);\n    if (!buf)\n        return PyErr_NoMemory();\n    if (fp_read(self, buf, length) == 0)\n        ret = PyUnicode_DecodeUTF8(\n                buf, length, PyBytes_AS_STRING(self->str_errors));\n    PyMem_Free(buf);\n    if (!ret)\n        return NULL;\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 1}
{"code": "GF_Err dfla_box_read(GF_Box *s,GF_BitStream *bs)\n{\n\tGF_FLACConfigBox *ptr = (GF_FLACConfigBox *) s;\n\tptr->dataSize = (u32) ptr->size;\n\tptr->size=0;\n\tptr->data = gf_malloc(ptr->dataSize);\n\tgf_bs_read_data(bs, ptr->data, ptr->dataSize);\n\treturn GF_OK;\n}", "target": 0}
{"code": "void WasmBinaryBuilder::read() {\n  if (DWARF) {\n    if (!hasDWARFSections()) {\n      DWARF = false;\n    }\n  }\n  readHeader();\n  readSourceMapHeader();\n  while (more()) {\n    uint8_t sectionCode = getInt8();\n    uint32_t payloadLen = getU32LEB();\n    if (uint64_t(pos) + uint64_t(payloadLen) > input.size()) {\n      throwError(\"Section extends beyond end of input\");\n    }\n    auto oldPos = pos;\n    if (sectionCode != BinaryConsts::Section::User &&\n        sectionCode != BinaryConsts::Section::Code) {\n      if (!seenSections.insert(BinaryConsts::Section(sectionCode)).second) {\n        throwError(\"section seen more than once: \" +\n                   std::to_string(sectionCode));\n      }\n    }\n    switch (sectionCode) {\n      case BinaryConsts::Section::Start:\n        readStart();\n        break;\n      case BinaryConsts::Section::Memory:\n        readMemory();\n        break;\n      case BinaryConsts::Section::Type:\n        readTypes();\n        break;\n      case BinaryConsts::Section::Import:\n        readImports();\n        break;\n      case BinaryConsts::Section::Function:\n        readFunctionSignatures();\n        break;\n      case BinaryConsts::Section::Code:\n        if (DWARF) {\n          codeSectionLocation = pos;\n        }\n        readFunctions();\n        break;\n      case BinaryConsts::Section::Export:\n        readExports();\n        break;\n      case BinaryConsts::Section::Element:\n        readElementSegments();\n        break;\n      case BinaryConsts::Section::Global:\n        readGlobals();\n        break;\n      case BinaryConsts::Section::Data:\n        readDataSegments();\n        break;\n      case BinaryConsts::Section::DataCount:\n        readDataCount();\n        break;\n      case BinaryConsts::Section::Table:\n        readTableDeclarations();\n        break;\n      case BinaryConsts::Section::Tag:\n        readTags();\n        break;\n      default: {\n        readUserSection(payloadLen);\n        if (pos > oldPos + payloadLen) {\n          throwError(\"bad user section size, started at \" +\n                     std::to_string(oldPos) + \" plus payload \" +\n                     std::to_string(payloadLen) +\n                     \" not being equal to new position \" + std::to_string(pos));\n        }\n        pos = oldPos + payloadLen;\n      }\n    }\n    if (pos != oldPos + payloadLen) {\n      throwError(\"bad section size, started at \" + std::to_string(oldPos) +\n                 \" plus payload \" + std::to_string(payloadLen) +\n                 \" not being equal to new position \" + std::to_string(pos));\n    }\n  }\n  validateBinary();\n  processNames();\n}", "target": 0}
{"code": "bool bt_att_cancel(struct bt_att *att, unsigned int id)\n{\n\tconst struct queue_entry *entry;\n\tstruct att_send_op *op;\n\tif (!att || !id)\n\t\treturn false;\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\t\tif (bt_att_chan_cancel(chan, id))\n\t\t\treturn true;\n\t}\n\tif (att->in_disc)\n\t\treturn bt_att_disc_cancel(att, id);\n\top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\tif (!op)\n\t\treturn false;\ndone:\n\tdestroy_att_send_op(op);\n\twakeup_writer(att);\n\treturn true;\n}", "target": 0}
{"code": "static int handle_pte_fault(struct mm_struct *mm,\n\t\t     struct vm_area_struct *vma, unsigned long address,\n\t\t     pte_t *pte, pmd_t *pmd, unsigned int flags)\n{\n\tpte_t entry;\n\tspinlock_t *ptl;\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n\t\t\t\t\t\t\tpmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\tif (pte_protnone(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);\n\tif (unlikely(!pte_same(*pte, entry)))\n\t\tgoto unlock;\n\tif (flags & FAULT_FLAG_WRITE) {\n\t\tif (!pte_write(entry))\n\t\t\treturn do_wp_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, ptl, entry);\n\t\tentry = pte_mkdirty(entry);\n\t}\n\tentry = pte_mkyoung(entry);\n\tif (ptep_set_access_flags(vma, address, pte, entry, flags & FAULT_FLAG_WRITE)) {\n\t\tupdate_mmu_cache(vma, address, pte);\n\t} else {\n\t\tif (flags & FAULT_FLAG_WRITE)\n\t\t\tflush_tlb_fix_spurious_fault(vma, address);\n\t}\nunlock:\n\tpte_unmap_unlock(pte, ptl);\n\treturn 0;\n}", "target": 1}
{"code": "static s32 adpt_rescan(adpt_hba* pHba)\n{\n\ts32 rcode;\n\tulong flags = 0;\n\tif(pHba->host)\n\t\tspin_lock_irqsave(pHba->host->host_lock, flags);\n\tif ((rcode=adpt_i2o_lct_get(pHba)) < 0)\n\t\tgoto out;\n\tif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0)\n\t\tgoto out;\n\trcode = 0;\nout:\tif(pHba->host)\n\t\tspin_unlock_irqrestore(pHba->host->host_lock, flags);\n\treturn rcode;\n}", "target": 1}
{"code": "static void l2tp_eth_dev_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n}", "target": 1}
{"code": "bool SVGAnimateElement::calculateFromAndToValues(const String& fromString, const String& toString)\n{\n    SVGElement* targetElement = this->targetElement();\n    if (!targetElement)\n        return false;\n    determinePropertyValueTypes(fromString, toString);\n    ensureAnimator()->calculateFromAndToValues(m_fromType, m_toType, fromString, toString);\n    ASSERT(m_animatedPropertyType == m_animator->type());\n    return true;\n}", "target": 0}
{"code": "void nfc_unregister_device(struct nfc_dev *dev)\n{\n\tint rc;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\trc = nfc_genl_device_removed(dev);\n\tif (rc)\n\t\tpr_debug(\"The userspace won't be notified that the device %s \"\n\t\t\t \"was removed\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (dev->rfkill) {\n\t\trfkill_unregister(dev->rfkill);\n\t\trfkill_destroy(dev->rfkill);\n\t}\n\tdevice_unlock(&dev->dev);\n\tif (dev->ops->check_presence) {\n\t\tdevice_lock(&dev->dev);\n\t\tdev->shutting_down = true;\n\t\tdevice_unlock(&dev->dev);\n\t\tdel_timer_sync(&dev->check_pres_timer);\n\t\tcancel_work_sync(&dev->check_pres_work);\n\t}\n\tnfc_llcp_unregister_device(dev);\n\tmutex_lock(&nfc_devlist_mutex);\n\tnfc_devlist_generation++;\n\tdevice_del(&dev->dev);\n\tmutex_unlock(&nfc_devlist_mutex);\n}", "target": 1}
{"code": "gopherCachable(const HttpRequest * req)\n{\n    int cachable = 1;\n    char type_id;\n    gopher_request_parse(req,\n                         &type_id,\n                         nullptr);\n    switch (type_id) {\n    case GOPHER_INDEX:\n    case GOPHER_CSO:\n    case GOPHER_TELNET:\n    case GOPHER_3270:\n        cachable = 0;\n        break;\n    default:\n        cachable = 1;\n    }\n    return cachable;\n}", "target": 1}
{"code": "void put_filp(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tsecurity_file_free(file);\n\t\tfile_sb_list_del(file);\n\t\tfile_free(file);\n\t}\n}", "target": 1}
{"code": "ev_archive_set_archive_type (EvArchive *archive,\n\t\t\t     EvArchiveType archive_type)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type == EV_ARCHIVE_TYPE_NONE, FALSE);\n\tswitch (archive_type) {\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tlibarchive_set_archive_type (archive, archive_type);\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\top = pwcs;\n\twhile (*s && len > 0) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n\t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n\t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n\t\t} else {\n\t\t\t*op++ = *s++;\n\t\t\tlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}", "target": 1}
{"code": "xmlIsStreaming(xmlValidCtxtPtr ctxt) {\n    xmlParserCtxtPtr pctxt;\n    if (ctxt == NULL)\n        return(0);\n    if ((ctxt->finishDtd != XML_CTXT_FINISH_DTD_0) &&\n        (ctxt->finishDtd != XML_CTXT_FINISH_DTD_1))\n        return(0);\n    pctxt = ctxt->userData;\n    return(pctxt->parseMode == XML_PARSE_READER);\n}", "target": 0}
{"code": "push_tag(struct readbuffer *obuf, char *cmdname, int cmd)\n{\n    obuf->tag_stack[obuf->tag_sp] = New(struct cmdtable);\n    obuf->tag_stack[obuf->tag_sp]->cmdname = allocStr(cmdname, -1);\n    obuf->tag_stack[obuf->tag_sp]->cmd = cmd;\n    obuf->tag_sp++;\n    if (obuf->tag_sp >= TAG_STACK_SIZE || obuf->flag & (RB_SPECIAL & ~RB_NOBR))\n\tappend_tags(obuf);\n}", "target": 0}
{"code": "GF_Box *subs_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_SubSampleInformationBox, GF_ISOM_BOX_TYPE_SUBS);\n\ttmp->Samples = gf_list_new();\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread)\n{\n  ssize_t i;\n  ssize_t si;\n  struct Curl_easy *data = conn->data;\n  struct SMTP *smtp = data->req.protop;\n  char *scratch = data->state.scratch;\n  char *newscratch = NULL;\n  char *oldscratch = NULL;\n  size_t eob_sent;\n  if(!scratch || data->set.crlf) {\n    oldscratch = scratch;\n    scratch = newscratch = malloc(2 * data->set.buffer_size);\n    if(!newscratch) {\n      failf(data, \"Failed to alloc scratch buffer!\");\n      return CURLE_OUT_OF_MEMORY;\n    }\n  }\n  eob_sent = smtp->eob;\n  for(i = 0, si = 0; i < nread; i++) {\n    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {\n      smtp->eob++;\n      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)\n        smtp->trailing_crlf = TRUE;\n      else\n        smtp->trailing_crlf = FALSE;\n    }\n    else if(smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n      si += smtp->eob - eob_sent;\n      if(SMTP_EOB[0] == data->req.upload_fromhere[i])\n        smtp->eob = 1;\n      else\n        smtp->eob = 0;\n      eob_sent = 0;\n      smtp->trailing_crlf = FALSE;\n    }\n    if(SMTP_EOB_FIND_LEN == smtp->eob) {\n      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],\n             SMTP_EOB_REPL_LEN - eob_sent);\n      si += SMTP_EOB_REPL_LEN - eob_sent;\n      smtp->eob = 0;\n      eob_sent = 0;\n    }\n    else if(!smtp->eob)\n      scratch[si++] = data->req.upload_fromhere[i];\n  }\n  if(smtp->eob - eob_sent) {\n    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);\n    si += smtp->eob - eob_sent;\n  }\n  if(si != nread) {\n    data->req.upload_fromhere = scratch;\n    data->state.scratch = scratch;\n    free(oldscratch);\n    data->req.upload_present = si;\n  }\n  else\n    free(newscratch);\n  return CURLE_OK;\n}", "target": 1}
{"code": "bool WasmBinaryBuilder::maybeVisitRefCast(Expression*& out, uint32_t code) {\n  if (code == BinaryConsts::RefCast) {\n    auto* rtt = popNonVoidExpression();\n    auto* ref = popNonVoidExpression();\n    out = Builder(wasm).makeRefCast(ref, rtt);\n    return true;\n  } else if (code == BinaryConsts::RefCastStatic) {\n    auto intendedType = getIndexedHeapType();\n    auto* ref = popNonVoidExpression();\n    out = Builder(wasm).makeRefCast(ref, intendedType);\n    return true;\n  }\n  return false;\n}", "target": 0}
{"code": "static void *my_malloc(size_t size)\n{\n    malloc_called += 1;\n    return malloc(size);\n}", "target": 1}
{"code": "static int db_dict_iter_lookup_key_values(struct db_dict_value_iter *iter)\n{\n\tstruct db_dict_iter_key *key;\n\tstring_t *path;\n\tconst char *error;\n\tint ret;\n\tarray_sort(&iter->keys, db_dict_iter_key_cmp);\n\tpath = t_str_new(128);\n\tstr_append(path, DICT_PATH_SHARED);\n\tarray_foreach_modifiable(&iter->keys, key) {\n\t\tif (!key->used)\n\t\t\tcontinue;\n\t\tstr_truncate(path, strlen(DICT_PATH_SHARED));\n\t\tret = var_expand(path, key->key->key, iter->var_expand_table, &error);\n\t\tif (ret <= 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to expand key %s: %s\", key->key->key, error);\n\t\t\treturn -1;\n\t\t}\n\t\tret = dict_lookup(iter->conn->dict, iter->pool,\n\t\t\t\t  str_c(path), &key->value, &error);\n\t\tif (ret > 0) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\t       \"Lookup: %s = %s\", str_c(path),\n\t\t\t\t\t       key->value);\n\t\t} else if (ret < 0) {\n\t\t\tauth_request_log_error(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Failed to lookup key %s: %s\", str_c(path), error);\n\t\t\treturn -1;\n\t\t} else if (key->key->default_value != NULL) {\n\t\t\tauth_request_log_debug(iter->auth_request, AUTH_SUBSYS_DB,\n\t\t\t\t\"Lookup: %s not found, using default value %s\",\n\t\t\t\tstr_c(path), key->key->default_value);\n\t\t\tkey->value = key->key->default_value;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static void __net_init sctp_ctrlsock_exit(struct net *net)\n{\n\tinet_ctl_sock_destroy(net->sctp.ctl_sock);\n}", "target": 0}
{"code": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    return pure_memcmp(s1, s2, strlen(s1) + 1U);\n}", "target": 1}
{"code": "gfx::Rect OverlayWindowViews::GetVideoBounds() {\n  return video_bounds_;\n}", "target": 0}
{"code": "static int smb311_decode_neg_context(struct smb2_negotiate_rsp *rsp,\n\t\t\t\t     struct TCP_Server_Info *server,\n\t\t\t\t     unsigned int len_of_smb)\n{\n\tstruct smb2_neg_context *pctx;\n\tunsigned int offset = le32_to_cpu(rsp->NegotiateContextOffset);\n\tunsigned int ctxt_cnt = le16_to_cpu(rsp->NegotiateContextCount);\n\tunsigned int len_of_ctxts, i;\n\tint rc = 0;\n\tcifs_dbg(FYI, \"decoding %d negotiate contexts\\n\", ctxt_cnt);\n\tif (len_of_smb <= offset) {\n\t\tcifs_dbg(VFS, \"Invalid response: negotiate context offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\tlen_of_ctxts = len_of_smb - offset;\n\tfor (i = 0; i < ctxt_cnt; i++) {\n\t\tint clen;\n\t\tif (len_of_ctxts == 0)\n\t\t\tbreak;\n\t\tif (len_of_ctxts < sizeof(struct smb2_neg_context))\n\t\t\tbreak;\n\t\tpctx = (struct smb2_neg_context *)(offset + (char *)rsp);\n\t\tclen = le16_to_cpu(pctx->DataLength);\n\t\tif (clen > len_of_ctxts)\n\t\t\tbreak;\n\t\tif (pctx->ContextType == SMB2_PREAUTH_INTEGRITY_CAPABILITIES)\n\t\t\tdecode_preauth_context(\n\t\t\t\t(struct smb2_preauth_neg_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_ENCRYPTION_CAPABILITIES)\n\t\t\trc = decode_encrypt_ctx(server,\n\t\t\t\t(struct smb2_encryption_neg_context *)pctx);\n\t\telse if (pctx->ContextType == SMB2_POSIX_EXTENSIONS_AVAILABLE)\n\t\t\tserver->posix_ext_supported = true;\n\t\telse\n\t\t\tcifs_dbg(VFS, \"unknown negcontext of type %d ignored\\n\",\n\t\t\t\tle16_to_cpu(pctx->ContextType));\n\t\tif (rc)\n\t\t\tbreak;\n\t\tclen = (clen + 7) & ~0x7;\n\t\toffset += clen + sizeof(struct smb2_neg_context);\n\t\tlen_of_ctxts -= clen;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "static void coroutine_fn virtfs_reset(V9fsPDU *pdu)\n{\n    V9fsState *s = pdu->s;\n    V9fsFidState *fidp = NULL;\n    while (s->fid_list) {\n        fidp = s->fid_list;\n        s->fid_list = fidp->next;\n        if (fidp->ref) {\n            fidp->clunked = 1;\n        } else {\n            free_fid(pdu, fidp);\n        }\n    }\n    if (fidp) {\n        error_report(\"9pfs:%s: One or more uncluncked fids \"\n                     \"found during reset\", __func__);\n    }\n}", "target": 0}
{"code": "list_session(char *log_dir, regex_t *re, const char *user, const char *tty)\n{\n    char idbuf[7], *idstr, *cp;\n    struct eventlog *evlog = NULL;\n    const char *timestr;\n    int ret = -1;\n    debug_decl(list_session, SUDO_DEBUG_UTIL);\n    if ((evlog = iolog_parse_loginfo(-1, log_dir)) == NULL)\n\tgoto done;\n    if (evlog->command == NULL || evlog->submituser == NULL ||\n\t    evlog->runuser == NULL) {\n\tgoto done;\n    }\n    if (!STAILQ_EMPTY(&search_expr) && !match_expr(&search_expr, evlog, true))\n\tgoto done;\n    cp = log_dir + strlen(session_dir) + 1;\n    if (IS_IDLOG(cp)) {\n\tidbuf[0] = cp[0];\n\tidbuf[1] = cp[1];\n\tidbuf[2] = cp[3];\n\tidbuf[3] = cp[4];\n\tidbuf[4] = cp[6];\n\tidbuf[5] = cp[7];\n\tidbuf[6] = '\\0';\n\tidstr = idbuf;\n    } else {\n\tidstr = cp;\n    }\n    timestr = get_timestr(evlog->submit_time.tv_sec, 1);\n    printf(\"%s : %s : \", timestr ? timestr : \"invalid date\", evlog->submituser);\n    if (evlog->submithost != NULL)\n\tprintf(\"HOST=%s ; \", evlog->submithost);\n    if (evlog->ttyname != NULL)\n\tprintf(\"TTY=%s ; \", evlog->ttyname);\n    if (evlog->runchroot != NULL)\n\tprintf(\"CHROOT=%s ; \", evlog->runchroot);\n    if (evlog->runcwd != NULL || evlog->cwd != NULL)\n\tprintf(\"CWD=%s ; \", evlog->runcwd ? evlog->runcwd : evlog->cwd);\n    printf(\"USER=%s ; \", evlog->runuser);\n    if (evlog->rungroup != NULL)\n\tprintf(\"GROUP=%s ; \", evlog->rungroup);\n    printf(\"TSID=%s ; COMMAND=%s\\n\", idstr, evlog->command);\n    ret = 0;\ndone:\n    eventlog_free(evlog);\n    debug_return_int(ret);\n}", "target": 1}
{"code": "sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int matched = 0;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\tstrlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n    epass = (char *) crypt(pass, pw_epasswd);\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)\n\t    matched = !strncmp(pw_epasswd, epass, DESLEN);\n\telse\n\t    matched = !strcmp(pw_epasswd, epass);\n    }\n    explicit_bzero(des_pass, sizeof(des_pass));\n    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n}", "target": 1}
{"code": "bool DSClientEvent::event()\n{\n    bool restart = false;\n    ParticipantProxyData* part_proxy_data;\n    eprosima::shared_lock<eprosima::shared_mutex> lock(mp_PDP->mp_builtin->getDiscoveryMutex());\n    for (auto server: mp_PDP->remote_server_attributes())\n    {\n        std::unique_lock<std::recursive_mutex> pdp_lock(*mp_PDP->getMutex());\n        part_proxy_data = mp_PDP->get_participant_proxy_data(server.guidPrefix);\n        if (nullptr != part_proxy_data)\n        {\n            if (!mp_EDP->areRemoteEndpointsMatched(part_proxy_data))\n            {\n                mp_EDP->assignRemoteEndpoints(*(part_proxy_data));\n            }\n        }\n        else\n        {\n            restart = true;\n        }\n    }\n    if (restart)\n    {\n        mp_PDP->_serverPing = true;\n        mp_PDP->announceParticipantState(false);\n        EPROSIMA_LOG_INFO(CLIENT_PDP_THREAD,\n                \"Client \" << mp_PDP->getRTPSParticipant()->getGuid() << \" PDP announcement\");\n    }\n    return restart;\n}", "target": 1}
{"code": "size_t CxMemFile::Read(void *buffer, size_t size, size_t count)\n{\n\tif (buffer==NULL) return 0;\n\tif (m_pBuffer==NULL) return 0;\n\tif (m_Position >= (int32_t)m_Size){\n\t\tm_bEOF = true;\n\t\treturn 0;\n\t}\n\tint32_t nCount = (int32_t)(count*size);\n\tif (nCount == 0) return 0;\n\tint32_t nRead;\n\tif (m_Position + nCount > (int32_t)m_Size){\n\t\tm_bEOF = true;\n\t\tnRead = (m_Size - m_Position);\n\t} else\n\t\tnRead = nCount;\n\tmemcpy(buffer, m_pBuffer + m_Position, nRead);\n\tm_Position += nRead;\n\treturn (size_t)(nRead/size);\n}", "target": 1}
{"code": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n    return allowed_new_user_problem_entry(client_uid, key, value);\n}", "target": 0}
{"code": "static PHP_NAMED_FUNCTION(zif_zip_entry_read)\n{\n\tzval * zip_entry;\n\tzend_long len = 0;\n\tzip_read_rsrc * zr_rsrc;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"r|l\", &zip_entry, &len) == FAILURE) {\n\t\treturn;\n\t}\n\tif ((zr_rsrc = (zip_read_rsrc *)zend_fetch_resource(Z_RES_P(zip_entry), le_zip_entry_name, le_zip_entry)) == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tif (len <= 0) {\n\t\tlen = 1024;\n\t}\n\tif (zr_rsrc->zf) {\n\t\tbuffer = zend_string_alloc(len, 0);\n\t\tn = zip_fread(zr_rsrc->zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\t\tif (n > 0) {\n\t\t\tZSTR_VAL(buffer)[n] = '\\0';\n\t\t\tZSTR_LEN(buffer) = n;\n\t\t\tRETURN_NEW_STR(buffer);\n\t\t} else {\n\t\t\tzend_string_free(buffer);\n\t\t\tRETURN_EMPTY_STRING()\n\t\t}\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}", "target": 1}
{"code": "static int asf_read_marker(AVFormatContext *s, int64_t size)\n{\n    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n    avio_rl64(pb);            \n    avio_rl64(pb);            \n    count = avio_rl32(pb);    \n    avio_rl16(pb);            \n    name_len = avio_rl16(pb); \n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); \n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n        avio_rl64(pb);             \n        pres_time = avio_rl64(pb); \n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             \n        avio_rl32(pb);             \n        avio_rl32(pb);             \n        name_len = avio_rl32(pb);  \n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)\n            avio_skip(pb, name_len - ret);\n        avpriv_new_chapter(s, i, (AVRational) { 1, 10000000 }, pres_time,\n                           AV_NOPTS_VALUE, name);\n    }\n    return 0;\n}", "target": 1}
{"code": "int migrate_task_to(struct task_struct *p, int target_cpu)\n{\n\tstruct migration_arg arg = { p, target_cpu };\n\tint curr_cpu = task_cpu(p);\n\tif (curr_cpu == target_cpu)\n\t\treturn 0;\n\tif (!cpumask_test_cpu(target_cpu, tsk_cpus_allowed(p)))\n\t\treturn -EINVAL;\n\ttrace_sched_move_numa(p, curr_cpu, target_cpu);\n\treturn stop_one_cpu(curr_cpu, migration_cpu_stop, &arg);\n}", "target": 0}
{"code": "void Item_cache_row::set_null()\n{\n  Item_cache::set_null();\n  if (!values)\n    return;\n  for (uint i= 0; i < item_count; i++)\n    values[i]->set_null();\n};", "target": 0}
{"code": "set_lenIV(char *line)\n{\n  char *p = strstr(line, \"/lenIV \");\n  if (p && (isdigit(p[7]) || p[7] == '+' || p[7] == '-')) {\n    lenIV = atoi(p + 7);\n  }\n}", "target": 1}
{"code": "static int adpt_close(struct inode *inode, struct file *file)\n{\n\tint minor;\n\tadpt_hba* pHba;\n\tminor = iminor(inode);\n\tif (minor >= hba_count) {\n\t\treturn -ENXIO;\n\t}\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->unit == minor) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tmutex_unlock(&adpt_configuration_lock);\n\tif (pHba == NULL) {\n\t\treturn -ENXIO;\n\t}\n\tpHba->in_use = 0;\n\treturn 0;\n}", "target": 1}
{"code": "ieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx->skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)tx->skb->data;\n\tstruct ps_data *ps;\n\tif (tx->sdata->vif.type == NL80211_IFTYPE_AP ||\n\t    tx->sdata->vif.type == NL80211_IFTYPE_AP_VLAN) {\n\t\tif (!tx->sdata->bss)\n\t\t\treturn TX_CONTINUE;\n\t\tps = &tx->sdata->bss->ps;\n\t} else if (ieee80211_vif_is_mesh(&tx->sdata->vif)) {\n\t\tps = &tx->sdata->u.mesh.ps;\n\t} else {\n\t\treturn TX_CONTINUE;\n\t}\n\tif (ieee80211_has_order(hdr->frame_control))\n\t\treturn TX_CONTINUE;\n\tif (tx->local->hw.flags & IEEE80211_HW_QUEUE_CONTROL)\n\t\tinfo->hw_queue = tx->sdata->vif.cab_queue;\n\tif (!atomic_read(&ps->num_sta_ps))\n\t\treturn TX_CONTINUE;\n\tinfo->flags |= IEEE80211_TX_CTL_SEND_AFTER_DTIM;\n\tif (!(tx->local->hw.flags & IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING))\n\t\treturn TX_CONTINUE;\n\tif (tx->local->total_ps_buffered >= TOTAL_MAX_TX_BUFFER)\n\t\tpurge_old_ps_buffers(tx->local);\n\tif (skb_queue_len(&ps->bc_buf) >= AP_MAX_BC_BUFFER) {\n\t\tps_dbg(tx->sdata,\n\t\t       \"BC TX buffer full - dropping the oldest frame\\n\");\n\t\tdev_kfree_skb(skb_dequeue(&ps->bc_buf));\n\t} else\n\t\ttx->local->total_ps_buffered++;\n\tskb_queue_tail(&ps->bc_buf, tx->skb);\n\treturn TX_QUEUED;\n}", "target": 0}
{"code": "int snd_ctl_create(struct snd_card *card)\n{\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = snd_ctl_dev_free,\n\t\t.dev_register =\tsnd_ctl_dev_register,\n\t\t.dev_disconnect = snd_ctl_dev_disconnect,\n\t};\n\tif (snd_BUG_ON(!card))\n\t\treturn -ENXIO;\n\treturn snd_device_new(card, SNDRV_DEV_CONTROL, card, &ops);\n}", "target": 0}
{"code": "static int pppoe_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t  struct msghdr *m, size_t total_len, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint error = 0;\n\tif (sk->sk_state & PPPOX_BOUND) {\n\t\terror = -EIO;\n\t\tgoto end;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &error);\n\tif (error < 0)\n\t\tgoto end;\n\tm->msg_namelen = 0;\n\tif (skb) {\n\t\ttotal_len = min_t(size_t, total_len, skb->len);\n\t\terror = skb_copy_datagram_iovec(skb, 0, m->msg_iov, total_len);\n\t\tif (error == 0) {\n\t\t\tconsume_skb(skb);\n\t\t\treturn total_len;\n\t\t}\n\t}\n\tkfree_skb(skb);\nend:\n\treturn error;\n}", "target": 1}
{"code": "int main() {\n  int selftest;\n  MSPACK_SYS_SELFTEST(selftest);\n  TEST(selftest == MSPACK_ERR_OK);\n  kwajd_open_test_01();\n  printf(\"ALL %d TESTS PASSED.\\n\", test_count);\n  return 0;\n}", "target": 0}
{"code": "static int zipfileRollback(sqlite3_vtab *pVtab){\n  return zipfileCommit(pVtab);\n}", "target": 0}
{"code": "std::shared_ptr<SQLiteDBInstance> getTestDBC() {\n  auto dbc = SQLiteDBManager::getUnique();\n  char* err = nullptr;\n  std::vector<std::string> queries = {\n      \"CREATE TABLE test_table (username varchar(30) primary key, age int)\",\n      \"INSERT INTO test_table VALUES (\\\"mike\\\", 23)\",\n      \"INSERT INTO test_table VALUES (\\\"matt\\\", 24)\"};\n  for (auto q : queries) {\n    sqlite3_exec(dbc->db(), q.c_str(), nullptr, nullptr, &err);\n    if (err != nullptr) {\n      throw std::domain_error(std::string(\"Cannot create testing DBC's db: \") +\n                              err);\n    }\n  }\n  return dbc;\n}", "target": 1}
{"code": "DLLEXPORT int DLLCALL tjDecodeYUV(tjhandle handle, const unsigned char *srcBuf,\n\tint pad, int subsamp, unsigned char *dstBuf, int width, int pitch,\n\tint height, int pixelFormat, int flags)\n{\n\tconst unsigned char *srcPlanes[3];\n\tint pw0, ph0, strides[3], retval=-1;\n\ttjinstance *this=(tjinstance *)handle;\n\tif(!this) _throwg(\"tjDecodeYUV(): Invalid handle\");\n\tthis->isInstanceError=FALSE;\n\tif(srcBuf==NULL || pad<0 || !isPow2(pad) || subsamp<0 || subsamp>=NUMSUBOPT\n\t\t|| width<=0 || height<=0)\n\t\t_throw(\"tjDecodeYUV(): Invalid argument\");\n\tpw0=tjPlaneWidth(0, width, subsamp);\n\tph0=tjPlaneHeight(0, height, subsamp);\n\tsrcPlanes[0]=srcBuf;\n\tstrides[0]=PAD(pw0, pad);\n\tif(subsamp==TJSAMP_GRAY)\n\t{\n\t\tstrides[1]=strides[2]=0;\n\t\tsrcPlanes[1]=srcPlanes[2]=NULL;\n\t}\n\telse\n\t{\n\t\tint pw1=tjPlaneWidth(1, width, subsamp);\n\t\tint ph1=tjPlaneHeight(1, height, subsamp);\n\t\tstrides[1]=strides[2]=PAD(pw1, pad);\n\t\tsrcPlanes[1]=srcPlanes[0]+strides[0]*ph0;\n\t\tsrcPlanes[2]=srcPlanes[1]+strides[1]*ph1;\n\t}\n\treturn tjDecodeYUVPlanes(handle, srcPlanes, strides, subsamp, dstBuf, width,\n\t\tpitch, height, pixelFormat, flags);\n\tbailout:\n\treturn retval;\n}", "target": 0}
{"code": "  void SetUp() override {\n    auto *file = UTHENTICODE_TEST_ASSETS \"/A_SSLippery_Slope.exe\";\n    pe = peparse::ParsePEFromFile(file);\n    ASSERT_TRUE(pe != nullptr);\n  }", "target": 0}
{"code": "RootWindow* RootWindow::GetRootWindow() {\n  return this;\n}", "target": 0}
{"code": "static void remove_full(struct kmem_cache *s, struct kmem_cache_node *n, struct page *page)\n{\n\tif (!(s->flags & SLAB_STORE_USER))\n\t\treturn;\n\tlockdep_assert_held(&n->list_lock);\n\tlist_del(&page->slab_list);\n}", "target": 0}
{"code": "void Curl_ssl_detach_conn(struct Curl_easy *data,\n                          struct connectdata *conn)\n{\n  if(Curl_ssl->disassociate_connection) {\n    Curl_ssl->disassociate_connection(data, FIRSTSOCKET);\n    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n      Curl_ssl->disassociate_connection(data, SECONDARYSOCKET);\n  }\n}", "target": 0}
{"code": "init_ext2_xattr(void)\n{\n\text2_xattr_cache = mb_cache_create(\"ext2_xattr\", 6);\n\tif (!ext2_xattr_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}", "target": 1}
{"code": "static void copy_password_acl_validation_control(\n\tstruct ldb_request *req,\n\tstruct ldb_reply *ares)\n{\n\tstruct ldb_control *pav_ctrl = NULL;\n\tstruct dsdb_control_password_acl_validation *pav = NULL;\n\tpav_ctrl = ldb_request_get_control(\n\t\tdiscard_const(req),\n\t\tDSDB_CONTROL_PASSWORD_ACL_VALIDATION_OID);\n\tif (pav_ctrl == NULL) {\n\t\treturn;\n\t}\n\tpav = talloc_get_type_abort(\n\t\tpav_ctrl->data,\n\t\tstruct dsdb_control_password_acl_validation);\n\tif (pav == NULL) {\n\t\treturn;\n\t}\n\tldb_reply_add_control(\n\t\tares,\n\t\tDSDB_CONTROL_PASSWORD_ACL_VALIDATION_OID,\n\t\tfalse,\n\t\tpav);\n}", "target": 0}
{"code": "static int wc_ecc_gen_k(WC_RNG* rng, int size, mp_int* k, mp_int* order)\n{\n    int err;\n#ifdef WOLFSSL_SMALL_STACK\n    byte* buf;\n#else\n    byte  buf[ECC_MAXSIZE_GEN];\n#endif\n#ifdef WOLFSSL_SMALL_STACK\n    buf = (byte*)XMALLOC(ECC_MAXSIZE_GEN, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n    if (buf == NULL)\n        return MEMORY_E;\n#endif\n    size += 8;\n    err = wc_RNG_GenerateBlock(rng, buf, size);\n    if (err == 0)\n        err = mp_read_unsigned_bin(k, (byte*)buf, size);\n    if (err == MP_OKAY) {\n        if (mp_iszero(k) == MP_YES)\n          err = MP_ZERO_E;\n    }\n    if (err == MP_OKAY) {\n        if (mp_cmp(k, order) != MP_LT) {\n            err = mp_mod(k, order, k);\n        }\n    }\n    ForceZero(buf, ECC_MAXSIZE);\n#ifdef WOLFSSL_SMALL_STACK\n    XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n    return err;\n}", "target": 1}
{"code": "SIZED_STRING* sized_string_dup(\n    SIZED_STRING* s)\n{\n  SIZED_STRING* result = (SIZED_STRING*) yr_malloc(\n      sizeof(SIZED_STRING) + s->length);\n  if (result == NULL)\n    return NULL;\n  result->length = s->length;\n  result->flags = s->flags;\n  strncpy(result->c_string, s->c_string, s->length + 1);\n  return result;\n}", "target": 0}
{"code": "static ssize_t read_mem(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t read, sz;\n\tvoid *ptr;\n\tif (p != *ppos)\n\t\treturn 0;\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\tread = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (sz > 0) {\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\t\tsz = size_inside_page(p, count);\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n\t\t\treturn -EPERM;\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr)\n\t\t\treturn -EFAULT;\n\t\tremaining = copy_to_user(buf, ptr, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\t*ppos += read;\n\treturn read;\n}", "target": 1}
{"code": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}", "target": 1}
{"code": "wsemul_sun_output_control(struct wsemul_sun_emuldata *edp,\n    struct wsemul_inputstate *instate)\n{\n\tint oargs;\n\tint rc;\n\tswitch (instate->inchar) {\n\tcase '0': case '1': case '2': case '3': case '4': \n\tcase '5': case '6': case '7': case '8': case '9':\n\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\tcase ';':\t\t\n\t\tedp->nargs++;\n\t\tbreak;\n\tdefault:\t\t\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\tedp->nargs = oargs;\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void ResetPixelList(PixelList *pixel_list)\n{\n  int\n    level;\n  register SkipNode\n    *root;\n  register SkipList\n    *p;\n  p=(&pixel_list->skip_list);\n  root=p->nodes+65536UL;\n  p->level=0;\n  for (level=0; level < 9; level++)\n    root->next[level]=65536UL;\n  pixel_list->seed=pixel_list->signature++;\n}", "target": 0}
{"code": "  static Address js_entry_sp(ThreadLocalTop* thread) {\n    return thread->js_entry_sp_;\n  }", "target": 0}
{"code": "static void ext4_invalidatepage_free_endio(struct page *page, unsigned long offset)\n{\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tif (!page_has_buffers(page))\n\t\treturn;\n\thead = bh = page_buffers(page);\n\tdo {\n\t\tif (offset <= curr_off && test_clear_buffer_uninit(bh)\n\t\t\t\t\t&& bh->b_private) {\n\t\t\text4_free_io_end(bh->b_private);\n\t\t\tbh->b_private = NULL;\n\t\t\tbh->b_end_io = NULL;\n\t\t}\n\t\tcurr_off = curr_off + bh->b_size;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}", "target": 0}
{"code": "static struct sk_buff **sit_gro_receive(struct sk_buff **head,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tif (NAPI_GRO_CB(skb)->encap_mark) {\n\t\tNAPI_GRO_CB(skb)->flush = 1;\n\t\treturn NULL;\n\t}\n\tNAPI_GRO_CB(skb)->encap_mark = 1;\n\treturn ipv6_gro_receive(head, skb);\n}", "target": 0}
{"code": "createenv(const struct rule *rule)\n{\n\tstruct env *env;\n\tu_int i;\n\tenv = malloc(sizeof(*env));\n\tif (!env)\n\t\terr(1, NULL);\n\tRB_INIT(&env->root);\n\tenv->count = 0;\n\tif (rule->options & KEEPENV) {\n\t\textern char **environ;\n\t\tfor (i = 0; environ[i] != NULL; i++) {\n\t\t\tstruct envnode *node;\n\t\t\tconst char *e, *eq;\n\t\t\tsize_t len;\n\t\t\tchar keybuf[1024];\n\t\t\te = environ[i];\n\t\t\tif ((eq = strchr(e, '=')) == NULL || eq == e)\n\t\t\t\tcontinue;\n\t\t\tlen = eq - e;\n\t\t\tif (len > sizeof(keybuf) - 1)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(keybuf, e, len);\n\t\t\tkeybuf[len] = '\\0';\n\t\t\tnode = createnode(keybuf, eq + 1);\n\t\t\tif (RB_INSERT(envtree, &env->root, node)) {\n\t\t\t\tfreenode(node);\n\t\t\t} else {\n\t\t\t\tenv->count++;\n\t\t\t}\n\t\t}\n\t}\n\treturn env;\n}", "target": 1}
{"code": "be32enc_vect(unsigned char *dst, const uint32_t *src, size_t len)\n{\n  size_t i;\n  uint32_t *d;\n  for (i = 0; i < len / 4; i++) {\n    d = (uint32_t *) (dst + i * 4);\n    *d = folly::Endian::big32(src[i]);\n  }\n}", "target": 1}
{"code": "static noinline int btrfs_mksubvol(struct path *parent,\n\t\t\t\t   char *name, int namelen,\n\t\t\t\t   struct btrfs_root *snap_src,\n\t\t\t\t   u64 *async_transid, bool readonly,\n\t\t\t\t   struct btrfs_qgroup_inherit **inherit)\n{\n\tstruct inode *dir  = parent->dentry->d_inode;\n\tstruct dentry *dentry;\n\tint error;\n\tmutex_lock_nested(&dir->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, parent->dentry, namelen);\n\terror = PTR_ERR(dentry);\n\tif (IS_ERR(dentry))\n\t\tgoto out_unlock;\n\terror = -EEXIST;\n\tif (dentry->d_inode)\n\t\tgoto out_dput;\n\terror = btrfs_may_create(dir, dentry);\n\tif (error)\n\t\tgoto out_dput;\n\terror = btrfs_check_dir_item_collision(BTRFS_I(dir)->root,\n\t\t\t\t\t       dir->i_ino, name,\n\t\t\t\t\t       namelen);\n\tif (error)\n\t\tgoto out_dput;\n\tdown_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\n\tif (btrfs_root_refs(&BTRFS_I(dir)->root->root_item) == 0)\n\t\tgoto out_up_read;\n\tif (snap_src) {\n\t\terror = create_snapshot(snap_src, dentry, name, namelen,\n\t\t\t\t\tasync_transid, readonly, inherit);\n\t} else {\n\t\terror = create_subvol(BTRFS_I(dir)->root, dentry,\n\t\t\t\t      name, namelen, async_transid, inherit);\n\t}\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\nout_up_read:\n\tup_read(&BTRFS_I(dir)->root->fs_info->subvol_sem);\nout_dput:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->i_mutex);\n\treturn error;\n}", "target": 0}
{"code": "yy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)\n{\n  int res = 0;\n  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;\n  if (0 <= yylocp->first_line)\n    {\n      res += YYFPRINTF (yyo, \"%d\", yylocp->first_line);\n      if (0 <= yylocp->first_column)\n        res += YYFPRINTF (yyo, \".%d\", yylocp->first_column);\n    }\n  if (0 <= yylocp->last_line)\n    {\n      if (yylocp->first_line < yylocp->last_line)\n        {\n          res += YYFPRINTF (yyo, \"-%d\", yylocp->last_line);\n          if (0 <= end_col)\n            res += YYFPRINTF (yyo, \".%d\", end_col);\n        }\n      else if (0 <= end_col && yylocp->first_column < end_col)\n        res += YYFPRINTF (yyo, \"-%d\", end_col);\n    }\n  return res;\n }", "target": 1}
{"code": "pixBlockconvGray(PIX     *pixs,\n                 PIX     *pixacc,\n                 l_int32  wc,\n                 l_int32  hc)\n{\nl_int32    w, h, d, wpl, wpla;\nl_uint32  *datad, *dataa;\nPIX       *pixd, *pixt;\n    PROCNAME(\"pixBlockconvGray\");\n    if (!pixs)\n        return (PIX *)ERROR_PTR(\"pixs not defined\", procName, NULL);\n    pixGetDimensions(pixs, &w, &h, &d);\n    if (d != 8)\n        return (PIX *)ERROR_PTR(\"pixs not 8 bpp\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    if (wc == 0 && hc == 0)   \n        return pixCopy(NULL, pixs);\n    if (w < 2 * wc + 1 || h < 2 * hc + 1) {\n        L_WARNING(\"kernel too large; returning a copy\\n\", procName);\n        L_INFO(\"w = %d, wc = %d, h = %d, hc = %d\\n\", procName, w, wc, h, hc);\n        return pixCopy(NULL, pixs);\n    }\n    if (pixacc) {\n        if (pixGetDepth(pixacc) == 32) {\n            pixt = pixClone(pixacc);\n        } else {\n            L_WARNING(\"pixacc not 32 bpp; making new one\\n\", procName);\n            if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n                return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n        }\n    } else {\n        if ((pixt = pixBlockconvAccum(pixs)) == NULL)\n            return (PIX *)ERROR_PTR(\"pixt not made\", procName, NULL);\n    }\n    if ((pixd = pixCreateTemplate(pixs)) == NULL) {\n        pixDestroy(&pixt);\n        return (PIX *)ERROR_PTR(\"pixd not made\", procName, NULL);\n    }\n    pixSetPadBits(pixt, 0);\n    wpl = pixGetWpl(pixd);\n    wpla = pixGetWpl(pixt);\n    datad = pixGetData(pixd);\n    dataa = pixGetData(pixt);\n    blockconvLow(datad, w, h, wpl, dataa, wpla, wc, hc);\n    pixDestroy(&pixt);\n    return pixd;\n}", "target": 1}
{"code": "static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir,\n\t\t\t      struct dentry *dentry, struct path *lowerpath,\n\t\t\t      struct kstat *stat, struct iattr *attr,\n\t\t\t      const char *link)\n{\n\tstruct inode *wdir = workdir->d_inode;\n\tstruct inode *udir = upperdir->d_inode;\n\tstruct dentry *newdentry = NULL;\n\tstruct dentry *upper = NULL;\n\tumode_t mode = stat->mode;\n\tint err;\n\tnewdentry = ovl_lookup_temp(workdir, dentry);\n\terr = PTR_ERR(newdentry);\n\tif (IS_ERR(newdentry))\n\t\tgoto out;\n\tupper = lookup_one_len(dentry->d_name.name, upperdir,\n\t\t\t       dentry->d_name.len);\n\terr = PTR_ERR(upper);\n\tif (IS_ERR(upper))\n\t\tgoto out1;\n\tstat->mode &= S_IFMT;\n\terr = ovl_create_real(wdir, newdentry, stat, link, NULL, true);\n\tstat->mode = mode;\n\tif (err)\n\t\tgoto out2;\n\tif (S_ISREG(stat->mode)) {\n\t\tstruct path upperpath;\n\t\tovl_path_upper(dentry, &upperpath);\n\t\tBUG_ON(upperpath.dentry != NULL);\n\t\tupperpath.dentry = newdentry;\n\t\terr = ovl_copy_up_data(lowerpath, &upperpath, stat->size);\n\t\tif (err)\n\t\t\tgoto out_cleanup;\n\t}\n\terr = ovl_copy_xattr(lowerpath->dentry, newdentry);\n\tif (err)\n\t\tgoto out_cleanup;\n\tmutex_lock(&newdentry->d_inode->i_mutex);\n\terr = ovl_set_attr(newdentry, stat);\n\tif (!err && attr)\n\t\terr = notify_change(newdentry, attr, NULL);\n\tmutex_unlock(&newdentry->d_inode->i_mutex);\n\tif (err)\n\t\tgoto out_cleanup;\n\terr = ovl_do_rename(wdir, newdentry, udir, upper, 0);\n\tif (err)\n\t\tgoto out_cleanup;\n\tovl_dentry_update(dentry, newdentry);\n\tnewdentry = NULL;\n\tif (!S_ISDIR(stat->mode))\n\t\tovl_dentry_set_opaque(dentry, true);\nout2:\n\tdput(upper);\nout1:\n\tdput(newdentry);\nout:\n\treturn err;\nout_cleanup:\n\tovl_cleanup(wdir, newdentry);\n\tgoto out;\n}", "target": 1}
{"code": "static void prefetch_enc(void)\n{\n  prefetch_table((const void *)encT, sizeof(encT));\n}", "target": 1}
{"code": "void WifiPacket::handle_prism(const u_char *pc, size_t len)\n{\n    prism2_pkthdr hdr;\n    hdr.host_time \t= EXTRACT_LE_32BITS(pc+32);\n    hdr.mac_time \t= EXTRACT_LE_32BITS(pc+44);\n    hdr.channel \t= EXTRACT_LE_32BITS(pc+56);\n    hdr.rssi \t\t= EXTRACT_LE_32BITS(pc+68);\n    hdr.sq \t\t= EXTRACT_LE_32BITS(pc+80);\n    hdr.signal  \t= EXTRACT_LE_32BITS(pc+92);\n    hdr.noise   \t= EXTRACT_LE_32BITS(pc+104);\n    hdr.rate\t\t= EXTRACT_LE_32BITS(pc+116)/2;\n    hdr.istx\t\t= EXTRACT_LE_32BITS(pc+128);\n    cbs->HandlePrism( *this, &hdr, pc + 144, len - 144);\n    handle_80211(pc+144,len-144);\n}", "target": 1}
{"code": "int install_user_keyrings(void)\n{\n\tstruct user_struct *user;\n\tconst struct cred *cred;\n\tstruct key *uid_keyring, *session_keyring;\n\tkey_perm_t user_keyring_perm;\n\tchar buf[20];\n\tint ret;\n\tuid_t uid;\n\tuser_keyring_perm = (KEY_POS_ALL & ~KEY_POS_SETATTR) | KEY_USR_ALL;\n\tcred = current_cred();\n\tuser = cred->user;\n\tuid = from_kuid(cred->user_ns, user->uid);\n\tkenter(\"%p{%u}\", user, uid);\n\tif (user->uid_keyring && user->session_keyring) {\n\t\tkleave(\" = 0 [exist]\");\n\t\treturn 0;\n\t}\n\tmutex_lock(&key_user_keyring_mutex);\n\tret = 0;\n\tif (!user->uid_keyring) {\n\t\tsprintf(buf, \"_uid.%u\", uid);\n\t\tuid_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(uid_keyring)) {\n\t\t\tuid_keyring = keyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t\t    cred, user_keyring_perm,\n\t\t\t\t\t\t    KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t\t    NULL, NULL);\n\t\t\tif (IS_ERR(uid_keyring)) {\n\t\t\t\tret = PTR_ERR(uid_keyring);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsprintf(buf, \"_uid_ses.%u\", uid);\n\t\tsession_keyring = find_keyring_by_name(buf, true);\n\t\tif (IS_ERR(session_keyring)) {\n\t\t\tsession_keyring =\n\t\t\t\tkeyring_alloc(buf, user->uid, INVALID_GID,\n\t\t\t\t\t      cred, user_keyring_perm,\n\t\t\t\t\t      KEY_ALLOC_IN_QUOTA,\n\t\t\t\t\t      NULL, NULL);\n\t\t\tif (IS_ERR(session_keyring)) {\n\t\t\t\tret = PTR_ERR(session_keyring);\n\t\t\t\tgoto error_release;\n\t\t\t}\n\t\t\tret = key_link(session_keyring, uid_keyring);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_release_both;\n\t\t}\n\t\tuser->uid_keyring = uid_keyring;\n\t\tuser->session_keyring = session_keyring;\n\t}\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = 0\");\n\treturn 0;\nerror_release_both:\n\tkey_put(session_keyring);\nerror_release:\n\tkey_put(uid_keyring);\nerror:\n\tmutex_unlock(&key_user_keyring_mutex);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}", "target": 1}
{"code": "  void connectSuccess() noexcept override {\n    ssl_->writeChain(nullptr, IOBuf::copyBuffer(\"hi\"));\n    auto ssl = const_cast<SSL*>(ssl_->getSSL());\n    SSL_shutdown(ssl);\n    auto fd = ssl_->detachNetworkSocket();\n    tcp_.reset(new AsyncSocket(evb_, fd), AsyncSocket::Destructor());\n    evb_->runAfterDelay(\n        [this]() {\n          perLoopReads_.setSocket(tcp_.get());\n          tcp_->setReadCB(&perLoopReads_);\n          evb_->runAfterDelay([this]() { tcp_->closeNow(); }, 10);\n        },\n        100);\n  }", "target": 0}
{"code": "struct r_bin_dyldcache_obj_t* r_bin_dyldcache_from_bytes_new(const ut8* buf, ut64 size) {\n\tstruct r_bin_dyldcache_obj_t *bin;\n\tif (!(bin = malloc (sizeof (struct r_bin_dyldcache_obj_t)))) {\n\t\treturn NULL;\n\t}\n\tmemset (bin, 0, sizeof (struct r_bin_dyldcache_obj_t));\n\tif (!buf) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->b = r_buf_new();\n\tif (!r_buf_set_bytes (bin->b, buf, size)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tif (!r_bin_dyldcache_init (bin)) {\n\t\treturn r_bin_dyldcache_free (bin);\n\t}\n\tbin->size = size;\n\treturn bin;\n}", "target": 1}
{"code": "  void setSocket(AsyncSocket* s) {\n    s_ = s;\n  }", "target": 0}
{"code": "mrb_remove_method(mrb_state *mrb, struct RClass *c, mrb_sym mid)\n{\n  mt_tbl *h;\n  MRB_CLASS_ORIGIN(c);\n  h = c->mt;\n  if (h && mt_del(mrb, h, mid)) return;\n  mrb_name_error(mrb, mid, \"method '%n' not defined in %C\", mid, c);\n}", "target": 1}
{"code": "TEST(AsyncSSLSocketTest, EarlyCloseNotify) {\n  WriteOnEofReadCallback readCallback(nullptr);\n  HandshakeCallback handshakeCallback(&readCallback);\n  SSLServerAcceptCallback acceptCallback(&handshakeCallback);\n  TestSSLServer server(&acceptCallback);\n  EventBase eventBase;\n  CloseNotifyConnector cnc(&eventBase, server.getAddress());\n  eventBase.loop();\n}", "target": 0}
{"code": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n\thook_del_nick_can_register(check_registration_keywords);\n\thook_del_user_can_register(check_registration_keywords);\n\tdel_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table);\n}", "target": 0}
{"code": "_zip_cdir_new(int nentry, struct zip_error *error)\n{\n    struct zip_cdir *cd;\n    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\treturn NULL;\n    }\n    if ( nentry > ((size_t)-1)/sizeof(*(cd->entry)) || (cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*(size_t)nentry))\n\t== NULL) {\n\t_zip_error_set(error, ZIP_ER_MEMORY, 0);\n\tfree(cd);\n\treturn NULL;\n    }\n    cd->nentry = nentry;\n    cd->size = cd->offset = 0;\n    cd->comment = NULL;\n    cd->comment_len = 0;\n    return cd;\n}", "target": 0}
{"code": "static void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\topl3_set_instr(dev, voice, info->pgm_num);\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}", "target": 1}
{"code": "const char *GetClipboardText(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return glfwGetClipboardString(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script_string(\"navigator.clipboard.readText() \\\n        .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\\n        .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"\n    );\n    return NULL;\n#endif\n    return NULL;\n}", "target": 1}
{"code": "static int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\tBT_DBG(\"sk %p\", sk);\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tlock_sock(sk);\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsec.level = rfcomm_pi(sk)->sec_level;\n\t\tsec.key_size = 0;\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "TEST(RegexMatchExpression, MatchesNull) {\n    RegexMatchExpression regex(\"a\", \"b\", \"\");\n    ASSERT(!regex.matchesBSON(BSONObj(), NULL));\n    ASSERT(!regex.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n}", "target": 0}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tresult = Unmaybe(object->Delete(context_handle, key->CopyInto()));\n\t\t}", "target": 1}
{"code": "GF_Err gf_isom_reset_tables(GF_ISOFile *movie, Bool reset_sample_count)\n{\n#ifndef\tGPAC_DISABLE_ISOM_FRAGMENTS\n\tu32 i;\n\tif (!movie || !movie->moov || !movie->moov->mvex) return GF_BAD_PARAM;\n\tfor (i=0; i<gf_list_count(movie->moov->trackList); i++) {\n\t\tGF_TrackBox *trak = (GF_TrackBox *)gf_list_get(movie->moov->trackList, i);\n\t\tu32 dur;\n\t\tu64 dts;\n\t\tGF_SampleTableBox *stbl = trak->Media->information->sampleTable;\n\t\ttrak->sample_count_at_seg_start += stbl->SampleSize->sampleCount;\n\t\tif (trak->sample_count_at_seg_start) {\n\t\t\tGF_Err e;\n\t\t\te = stbl_GetSampleDTS_and_Duration(stbl->TimeToSample, stbl->SampleSize->sampleCount, &dts, &dur);\n\t\t\tif (e == GF_OK) {\n\t\t\t\ttrak->dts_at_seg_start += dts + dur;\n\t\t\t}\n\t\t}\n\t\tgf_isom_recreate_tables(trak);\n#if 0\n\t\tj = stbl->nb_stbl_boxes;\n\t\twhile ((a = (GF_Box *)gf_list_enum(stbl->child_boxes, &j))) {\n\t\t\tgf_isom_box_del_parent(&stbl->child_boxes, a);\n\t\t\tj--;\n\t\t}\n#endif\n\t\tif (reset_sample_count) {\n\t\t\ttrak->Media->information->sampleTable->SampleSize->sampleCount = 0;\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t\ttrak->sample_count_at_seg_start = 0;\n\t\t\ttrak->dts_at_seg_start = 0;\n\t\t\ttrak->first_traf_merged = GF_FALSE;\n#endif\n\t\t}\n\t}\n\tif (reset_sample_count) {\n\t\tmovie->NextMoofNumber = 0;\n\t}\n#endif\n\treturn GF_OK;\n}", "target": 0}
{"code": "PROCESS_THREAD(snmp_process, ev, data)\n{\n  PROCESS_BEGIN();\n  snmp_udp_conn = udp_new(NULL, 0, NULL);\n  udp_bind(snmp_udp_conn, SNMP_SERVER_PORT);\n  LOG_DBG(\"Listening on port %u\\n\", uip_ntohs(snmp_udp_conn->lport));\n  while(1) {\n    PROCESS_YIELD();\n    if(ev == tcpip_event) {\n      if(uip_newdata()) {\n        snmp_process_data();\n      }\n    }\n  } \n  PROCESS_END();\n}", "target": 1}
{"code": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\treturn ret;\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "GF_Err moof_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\treturn gf_isom_box_array_read(s, bs, moof_on_child_box);\n}", "target": 0}
{"code": "int CLua::execstring(const char *s, const char *context, int nresults)\n{\n    int err = 0;\n    if ((err = loadstring(s, context)))\n        return err;\n    lua_State *ls = state();\n    lua_call_throttle strangler(this);\n    err = lua_pcall(ls, 0, nresults, 0);\n    set_error(err, ls);\n    return err;\n}", "target": 0}
{"code": "ResponsePtr Server::ServeStatic(RequestPtr request) {\n  assert(request->method() == methods::kGet);\n  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n  fs::path path = doc_root_ / request->url().path();\n  try {\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n    auto response = std::make_shared<Response>(Status::kOK);\n    std::string extension = path.extension().string();\n    response->SetContentType(media_types::FromExtension(extension), \"\");\n    response->SetBody(body, true);\n    return response;\n  } catch (const Error& error) {\n    LOG_ERRO(\"File error: %s\", error.message().c_str());\n    return {};\n  }\n}", "target": 1}
{"code": "static bool ieee80211_validate_radiotap_len(struct sk_buff *skb)\n{\n\tstruct ieee80211_radiotap_header *rthdr =\n\t\t(struct ieee80211_radiotap_header *)skb->data;\n\tif (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header)))\n\t\treturn false; \n\tif (unlikely(rthdr->it_version))\n\t\treturn false; \n\tif (unlikely(skb->len < ieee80211_get_radiotap_len(skb->data)))\n\t\treturn false; \n\treturn true;\n}", "target": 0}
{"code": "static int midi_setup_sysex_roland_reset(struct _mdi *mdi) {\n    MIDI_EVENT_DEBUG(__FUNCTION__,0,0);\n    _WM_CheckEventMemoryPool(mdi);\n    mdi->events[mdi->event_count].do_event = *_WM_do_sysex_roland_reset;\n    mdi->events[mdi->event_count].event_data.channel = 0;\n    mdi->events[mdi->event_count].event_data.data.value = 0;\n    mdi->events[mdi->event_count].samples_to_next = 0;\n    mdi->event_count++;\n    return (0);\n}", "target": 0}
{"code": "  static void  Ins_MDRP( INS_ARG )\n  {\n    Int         point;\n    TT_F26Dot6  distance,\n                org_dist;\n    point = (Int)args[0];\n    if ( BOUNDS( args[0], CUR.zp1.n_points ) )\n    {\n      return;\n    }\n    org_dist = CUR_Func_dualproj( CUR.zp1.org_x[point] -\n                                    CUR.zp0.org_x[CUR.GS.rp0],\n                                  CUR.zp1.org_y[point] -\n                                    CUR.zp0.org_y[CUR.GS.rp0] );\n    if ( ABS(org_dist) < CUR.GS.single_width_cutin )\n    {\n      if ( org_dist >= 0 )\n        org_dist = CUR.GS.single_width_value;\n      else\n        org_dist = -CUR.GS.single_width_value;\n    }\n    if ( (CUR.opcode & 4) != 0 )\n      distance = CUR_Func_round( org_dist,\n                                 CUR.metrics.compensations[CUR.opcode & 3] );\n    else\n      distance = Round_None( EXEC_ARGS\n                             org_dist,\n                             CUR.metrics.compensations[CUR.opcode & 3]  );\n    if ( (CUR.opcode & 8) != 0 )\n    {\n      if ( org_dist >= 0 )\n      {\n        if ( distance < CUR.GS.minimum_distance )\n          distance = CUR.GS.minimum_distance;\n      }\n      else\n      {\n        if ( distance > -CUR.GS.minimum_distance )\n          distance = -CUR.GS.minimum_distance;\n      }\n    }\n    org_dist = CUR_Func_project( CUR.zp1.cur_x[point] -\n                                   CUR.zp0.cur_x[CUR.GS.rp0],\n                                 CUR.zp1.cur_y[point] -\n                                   CUR.zp0.cur_y[CUR.GS.rp0] );\n    CUR_Func_move( &CUR.zp1, point, distance - org_dist );\n    CUR.GS.rp1 = CUR.GS.rp0;\n    CUR.GS.rp2 = point;\n    if ( (CUR.opcode & 16) != 0 )\n      CUR.GS.rp0 = point;\n  }", "target": 0}
{"code": "bool UnbufferedAsioTlsStream::IsVerifyOK() const\n{\n\treturn m_VerifyOK;\n}", "target": 1}
{"code": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\treturn mount_entry_on_generic(mntent, path);\n}", "target": 1}
{"code": "RAMBlock *qemu_ram_alloc_from_ptr(struct uc_struct *uc, ram_addr_t size, void *host,\n                                   MemoryRegion *mr)\n{\n    RAMBlock *new_block;\n    ram_addr_t max_size = size;\n    size = HOST_PAGE_ALIGN(uc, size);\n    max_size = HOST_PAGE_ALIGN(uc, max_size);\n    new_block = g_malloc0(sizeof(*new_block));\n    if (new_block == NULL)\n        return NULL;\n    new_block->mr = mr;\n    new_block->used_length = size;\n    new_block->max_length = max_size;\n    assert(max_size >= size);\n    new_block->page_size = uc->qemu_real_host_page_size;\n    new_block->host = host;\n    if (host) {\n        new_block->flags |= RAM_PREALLOC;\n    }\n    uc->invalid_addr = UC_ERR_OK;\n    ram_block_add(mr->uc, new_block);\n    if (uc->invalid_error != UC_ERR_OK) {\n        g_free(new_block);\n        return NULL;\n    }\n    return new_block;\n}", "target": 0}
{"code": "inline int TensorProtoDataSize<qint32>(const TensorProto& t) {\n  return t.int_val_size();\n}", "target": 0}
{"code": "int acpi_register_debugger(struct module *owner,\n\t\t\t   const struct acpi_debugger_ops *ops)\n{\n\tint ret = 0;\n\tmutex_lock(&acpi_debugger.lock);\n\tif (acpi_debugger.ops) {\n\t\tret = -EBUSY;\n\t\tgoto err_lock;\n\t}\n\tacpi_debugger.owner = owner;\n\tacpi_debugger.ops = ops;\nerr_lock:\n\tmutex_unlock(&acpi_debugger.lock);\n\treturn ret;\n}", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_ReviewIPPacket(PVOID buffer, ULONG size, LPCSTR caller)\n{\n    tTcpIpPacketParsingResult res = QualifyIpPacket((IPHeader *) buffer, size);\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 1}
{"code": "DLLIMPORT unsigned int cfg_opt_size(cfg_opt_t *opt)\n{\n\tif (opt)\n\t\treturn opt->nvalues;\n\treturn 0;\n}", "target": 0}
{"code": "spnego_gss_import_sec_context(\n\tOM_uint32\t\t*minor_status,\n\tconst gss_buffer_t\tinterprocess_token,\n\tgss_ctx_id_t\t\t*context_handle)\n{\n\tOM_uint32 ret;\n\tret = gss_import_sec_context(minor_status,\n\t\t\t\t    interprocess_token,\n\t\t\t\t    context_handle);\n\treturn (ret);\n}", "target": 1}
{"code": "int ptrace_setxregs(struct task_struct *child, void __user *uregs)\n{\n\tstruct thread_info *ti = task_thread_info(child);\n\tstruct pt_regs *regs = task_pt_regs(child);\n\telf_xtregs_t *xtregs = uregs;\n\tint ret = 0;\n\tif (!access_ok(VERIFY_READ, uregs, sizeof(elf_xtregs_t)))\n\t\treturn -EFAULT;\n#if XTENSA_HAVE_COPROCESSORS\n\tcoprocessor_flush_all(ti);\n\tcoprocessor_release_all(ti);\n\tret |= __copy_from_user(&ti->xtregs_cp, &xtregs->cp0, \n\t\t\t\tsizeof(xtregs_coprocessor_t));\n#endif\n\tret |= __copy_from_user(&regs->xtregs_opt, &xtregs->opt,\n\t\t\t\tsizeof(xtregs->opt));\n\tret |= __copy_from_user(&ti->xtregs_user, &xtregs->user,\n\t\t\t\tsizeof(xtregs->user));\n\treturn ret ? -EFAULT : 0;\n}", "target": 0}
{"code": "static int sco_send_frame(struct sock *sk, struct msghdr *msg, int len)\n{\n\tstruct sco_conn *conn = sco_pi(sk)->conn;\n\tstruct sk_buff *skb;\n\tint err;\n\tif (len > conn->mtu)\n\t\treturn -EINVAL;\n\tBT_DBG(\"sk %p len %d\", sk, len);\n\tskb = bt_skb_send_alloc(sk, len, msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\tif (memcpy_from_msg(skb_put(skb, len), msg, len)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\thci_send_sco(conn->hcon, skb);\n\treturn len;\n}", "target": 1}
{"code": "void ntlm_print_negotiate_flags(UINT32 flags)\n{\n\tint i;\n\tconst char* str;\n\tWLog_INFO(TAG, \"negotiateFlags \\\"0x%08\"PRIX32\"\\\"\", flags);\n\tfor (i = 31; i >= 0; i--)\n\t{\n\t\tif ((flags >> i) & 1)\n\t\t{\n\t\t\tstr = NTLM_NEGOTIATE_STRINGS[(31 - i)];\n\t\t\tWLog_INFO(TAG, \"\\t%s (%d),\", str, (31 - i));\n\t\t}\n\t}\n}", "target": 1}
{"code": "void* CxImage::GetDIBLimit() const\n{\n    return pDibLimit;\n}", "target": 0}
{"code": "static unsigned int UTFCharLength(uint8 lead)\n{\n  if (lead < 0x80)\n    return 1;\n  else if ((lead >> 5) == 0x6)\n    return 2;\n  else if ((lead >> 4) == 0xe)\n    return 3;\n  else if ((lead >> 3) == 0x1e)\n    return 4;\n  else\n    return 0;\n}", "target": 0}
{"code": "static void on_underlying_io_bytes_received(void* context, const unsigned char* buffer, size_t size)\n{\n    if (context != NULL)\n    {\n        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)context;\n        unsigned char* new_socket_io_read_bytes = (unsigned char*)realloc(tls_io_instance->socket_io_read_bytes, tls_io_instance->socket_io_read_byte_count + size);\n        if (new_socket_io_read_bytes == NULL)\n        {\n            LogError(\"Failed allocating memory for received bytes\");\n            tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;\n            indicate_error(tls_io_instance);\n        }\n        else\n        {\n            tls_io_instance->socket_io_read_bytes = new_socket_io_read_bytes;\n            (void)memcpy(tls_io_instance->socket_io_read_bytes + tls_io_instance->socket_io_read_byte_count, buffer, size);\n            tls_io_instance->socket_io_read_byte_count += size;\n        }\n    }\n    else\n    {\n        LogInfo(\"Supplied context is NULL on bytes_received\");\n    }\n}", "target": 1}
{"code": "update_bar_address(struct vmctx *ctx, struct pci_vdev *dev, uint64_t addr,\n\tint idx, int type, bool ignore_reg_unreg)\n{\n\tbool decode = false;\n\tuint64_t orig_addr = dev->bar[idx].addr;\n\tif (!ignore_reg_unreg) {\n\t\tif (dev->bar[idx].type == PCIBAR_IO)\n\t\t\tdecode = porten(dev);\n\t\telse\n\t\t\tdecode = memen(dev);\n\t}\n\tif (decode)\n\t\tunregister_bar(dev, idx);\n\tswitch (type) {\n\tcase PCIBAR_IO:\n\tcase PCIBAR_MEM32:\n\t\tdev->bar[idx].addr = addr;\n\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}", "target": 1}
{"code": "void ModuleSQL::init()\n{\n\tif (mysql_library_init(0, NULL, NULL))\n\t\tthrow ModuleException(\"Unable to initialise the MySQL library!\");\n\tDispatcher = new DispatcherThread(this);\n\tServerInstance->Threads->Start(Dispatcher);\n\tImplementation eventlist[] = { I_OnRehash, I_OnUnloadModule };\n\tServerInstance->Modules->Attach(eventlist, this, sizeof(eventlist)/sizeof(Implementation));\n\tOnRehash(NULL);\n}", "target": 0}
{"code": "int scsi_verify_blk_ioctl(struct block_device *bd, unsigned int cmd)\n{\n\tif (bd && bd == bd->bd_contains)\n\t\treturn 0;\n\tswitch (cmd) {\n\tcase SCSI_IOCTL_GET_IDLUN:\n\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\tcase SCSI_IOCTL_GET_PCI:\n\tcase SCSI_IOCTL_PROBE_HOST:\n\tcase SG_GET_VERSION_NUM:\n\tcase SG_SET_TIMEOUT:\n\tcase SG_GET_TIMEOUT:\n\tcase SG_GET_RESERVED_SIZE:\n\tcase SG_SET_RESERVED_SIZE:\n\tcase SG_EMULATED_HOST:\n\t\treturn 0;\n\tcase CDROM_GET_CAPABILITY:\n\t\treturn -ENOIOCTLCMD;\n\tdefault:\n\t\tbreak;\n\t}\n\tprintk_ratelimited(KERN_WARNING\n\t\t\t   \"%s: sending ioctl %x to a partition!\\n\", current->comm, cmd);\n\treturn capable(CAP_SYS_RAWIO) ? 0 : -ENOIOCTLCMD;\n}", "target": 0}
{"code": "static void recovery_abort(void) {\n    if (!dry_run) {\n        storage_reset();\n    }\n    recovery_started = false;\n    awaiting_character = false;\n    memzero(mnemonic, sizeof(mnemonic));\n    memzero(cipher, sizeof(cipher));\n}", "target": 0}
{"code": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\tport->exists = false;\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n}", "target": 1}
{"code": "static int do_hidp_sock_ioctl(struct socket *sock, unsigned int cmd, void __user *argp)\n{\n\tstruct hidp_connadd_req ca;\n\tstruct hidp_conndel_req cd;\n\tstruct hidp_connlist_req cl;\n\tstruct hidp_conninfo ci;\n\tstruct socket *csock;\n\tstruct socket *isock;\n\tint err;\n\tBT_DBG(\"cmd %x arg %p\", cmd, argp);\n\tswitch (cmd) {\n\tcase HIDPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tcsock = sockfd_lookup(ca.ctrl_sock, &err);\n\t\tif (!csock)\n\t\t\treturn err;\n\t\tisock = sockfd_lookup(ca.intr_sock, &err);\n\t\tif (!isock) {\n\t\t\tsockfd_put(csock);\n\t\t\treturn err;\n\t\t}\n\t\tca.name[sizeof(ca.name)-1] = 0;\n\t\terr = hidp_connection_add(&ca, csock, isock);\n\t\tif (!err && copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\terr = -EFAULT;\n\t\tsockfd_put(csock);\n\t\tsockfd_put(isock);\n\t\treturn err;\n\tcase HIDPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn hidp_connection_del(&cd);\n\tcase HIDPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = hidp_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase HIDPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = hidp_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}", "target": 0}
{"code": "bool PrintWebViewHelper::PrintPreviewContext::CreatePreviewDocument(\n    PrepareFrameAndViewForPrint* prepared_frame,\n    const std::vector<int>& pages) {\n  DCHECK_EQ(INITIALIZED, state_);\n  state_ = RENDERING;\n  prep_frame_view_.reset(prepared_frame);\n  prep_frame_view_->StartPrinting();\n  total_page_count_ = prep_frame_view_->GetExpectedPageCount();\n  if (total_page_count_ == 0) {\n    LOG(ERROR) << \"CreatePreviewDocument got 0 page count\";\n    set_error(PREVIEW_ERROR_ZERO_PAGES);\n    return false;\n  }\n  metafile_.reset(new PdfMetafileSkia);\n  if (!metafile_->Init()) {\n    set_error(PREVIEW_ERROR_METAFILE_INIT_FAILED);\n    LOG(ERROR) << \"PdfMetafileSkia Init failed\";\n    return false;\n  }\n  current_page_index_ = 0;\n  pages_to_render_ = pages;\n  std::sort(pages_to_render_.begin(), pages_to_render_.end());\n  pages_to_render_.resize(\n      std::unique(pages_to_render_.begin(), pages_to_render_.end()) -\n      pages_to_render_.begin());\n  pages_to_render_.resize(std::lower_bound(pages_to_render_.begin(),\n                                           pages_to_render_.end(),\n                                           total_page_count_) -\n                          pages_to_render_.begin());\n  print_ready_metafile_page_count_ = pages_to_render_.size();\n  if (pages_to_render_.empty()) {\n    print_ready_metafile_page_count_ = total_page_count_;\n    for (int i = 0; i < total_page_count_; ++i)\n      pages_to_render_.push_back(i);\n  } else if (generate_draft_pages_) {\n    int pages_index = 0;\n    for (int i = 0; i < total_page_count_; ++i) {\n      if (pages_index < print_ready_metafile_page_count_ &&\n          i == pages_to_render_[pages_index]) {\n        pages_index++;\n        continue;\n      }\n      pages_to_render_.push_back(i);\n    }\n  }\n  document_render_time_ = base::TimeDelta();\n  begin_time_ = base::TimeTicks::Now();\n  return true;\n}", "target": 0}
{"code": "  TfLiteRegistration CopyOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n      TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n      TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n      return context->ResizeTensor(context, tensor1, newSize);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      CallReporting* call_reporting =\n          static_cast<CallReporting*>(node->builtin_data);\n      const TfLiteTensor* a0 = GetInput(context, node, 0);\n      TfLiteTensor* a1 = GetOutput(context, node, 0);\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        a1->data.f[i] = a0->data.f[i];\n      }\n      call_reporting->Record();\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "static int __tail_onwire_len(int front_len, int middle_len, int data_len,\n\t\t\t     bool secure)\n{\n\tBUG_ON(front_len < 0 || front_len > CEPH_MSG_MAX_FRONT_LEN ||\n\t       middle_len < 0 || middle_len > CEPH_MSG_MAX_MIDDLE_LEN ||\n\t       data_len < 0 || data_len > CEPH_MSG_MAX_DATA_LEN);\n\tif (!front_len && !middle_len && !data_len)\n\t\treturn 0;\n\tif (!secure)\n\t\treturn front_len + middle_len + data_len +\n\t\t       CEPH_EPILOGUE_PLAIN_LEN;\n\treturn padded_len(front_len) + padded_len(middle_len) +\n\t       padded_len(data_len) + CEPH_EPILOGUE_SECURE_LEN;\n}", "target": 0}
{"code": "void RenderWidgetHostViewAura::UpdateExternalTexture() {\n  if (accelerated_compositing_state_changed_)\n    accelerated_compositing_state_changed_ = false;\n  bool is_compositing_active = host_->is_accelerated_compositing_active();\n  if (is_compositing_active && current_surface_.get()) {\n    window_->layer()->SetExternalTexture(current_surface_.get());\n    current_frame_size_ = ConvertSizeToDIP(\n        current_surface_->device_scale_factor(), current_surface_->size());\n    CheckResizeLock();\n    software_frame_manager_->DiscardCurrentFrame();\n  } else if (is_compositing_active &&\n             software_frame_manager_->HasCurrentFrame()) {\n    cc::TextureMailbox mailbox;\n    scoped_ptr<cc::SingleReleaseCallback> callback;\n    software_frame_manager_->GetCurrentFrameMailbox(&mailbox, &callback);\n    window_->layer()->SetTextureMailbox(mailbox,\n                                        callback.Pass(),\n                                        last_swapped_surface_scale_factor_);\n    current_frame_size_ = ConvertSizeToDIP(last_swapped_surface_scale_factor_,\n                                           mailbox.shared_memory_size());\n    CheckResizeLock();\n  } else {\n    window_->layer()->SetShowPaintedContent();\n    resize_lock_.reset();\n    host_->WasResized();\n    software_frame_manager_->DiscardCurrentFrame();\n  }\n}", "target": 0}
{"code": "static int sanitize_val_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\treturn update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DoUniform1i(GLint fake_location, GLint v0) {\n  GLenum type = 0;\n  GLsizei count = 1;\n  GLint real_location = -1;\n  if (!PrepForSetUniformByLocation(\n      fake_location, \"glUniform1iv\", &real_location, &type, &count)) {\n    return;\n  }\n  current_program_->SetSamplers(fake_location, 1, &v0);\n  glUniform1i(real_location, v0);\n}", "target": 0}
{"code": "kg_seal(minor_status, context_handle, conf_req_flag, qop_req,\n        input_message_buffer, conf_state, output_message_buffer, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    int conf_req_flag;\n    gss_qop_t qop_req;\n    gss_buffer_t input_message_buffer;\n    int *conf_state;\n    gss_buffer_t output_message_buffer;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_error_code code;\n    krb5_context context;\n    output_message_buffer->length = 0;\n    output_message_buffer->value = NULL;\n    if (qop_req != 0) {\n        *minor_status = (OM_uint32) G_UNKNOWN_QOP;\n        return GSS_S_FAILURE;\n    }\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    context = ctx->k5_context;\n    switch (ctx->proto)\n    {\n    case 0:\n        code = make_seal_token_v1(context, ctx->enc, ctx->seq,\n                                  &ctx->seq_send, ctx->initiate,\n                                  input_message_buffer, output_message_buffer,\n                                  ctx->signalg, ctx->cksum_size, ctx->sealalg,\n                                  conf_req_flag, toktype, ctx->mech_used);\n        break;\n    case 1:\n        code = gss_krb5int_make_seal_token_v3(context, ctx,\n                                              input_message_buffer,\n                                              output_message_buffer,\n                                              conf_req_flag, toktype);\n        break;\n    default:\n        code = G_UNKNOWN_QOP;   \n        break;\n    }\n    if (code) {\n        *minor_status = code;\n        save_error_info(*minor_status, context);\n        return(GSS_S_FAILURE);\n    }\n    if (conf_state)\n        *conf_state = conf_req_flag;\n    *minor_status = 0;\n    return(GSS_S_COMPLETE);\n}", "target": 1}
{"code": "static int ras_getdatastd(jas_stream_t *in, ras_hdr_t *hdr, ras_cmap_t *cmap,\n  jas_image_t *image)\n{\n\tint pad;\n\tint nz;\n\tint z;\n\tint c;\n\tint y;\n\tint x;\n\tint v;\n\tint i;\n\tjas_matrix_t *data[3];\n\tcmap = 0;\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tdata[i] = jas_matrix_create(1, jas_image_width(image));\n\t\tassert(data[i]);\n\t}\n\tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tnz = 0;\n\t\tz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\twhile (nz < hdr->depth) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tz = (z << 8) | c;\n\t\t\t\tnz += 8;\n\t\t\t}\n\t\t\tv = (z >> (nz - hdr->depth)) & RAS_ONES(hdr->depth);\n\t\t\tz &= RAS_ONES(nz - hdr->depth);\n\t\t\tnz -= hdr->depth;\n\t\t\tif (jas_image_numcmpts(image) == 3) {\n\t\t\t\tjas_matrix_setv(data[0], x, (RAS_GETRED(v)));\n\t\t\t\tjas_matrix_setv(data[1], x, (RAS_GETGREEN(v)));\n\t\t\t\tjas_matrix_setv(data[2], x, (RAS_GETBLUE(v)));\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(data[0], x, (v));\n\t\t\t}\n\t\t}\n\t\tif (pad) {\n\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,\n\t\t\t  data[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "atol10(const char *p, size_t char_cnt)\n{\n\tuint64_t l;\n\tint digit;\n\tif (char_cnt == 0)\n\t\treturn (0);\n\tl = 0;\n\tdigit = *p - '0';\n\twhile (digit >= 0 && digit < 10  && char_cnt-- > 0) {\n\t\tl = (l * 10) + digit;\n\t\tdigit = *++p - '0';\n\t}\n\treturn (l);\n}", "target": 0}
{"code": "Ztring& Ztring::Date_From_Seconds_1970_Local (const int32u Value)\n{\n    time_t Time=(time_t)Value;\n    #if _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE\n    struct tm Gmt_Temp;\n    struct tm *Gmt=localtime_r(&Time, &Gmt_Temp);\n    #elif defined(_MSC_VER)\n    struct tm Gmt_Temp;\n    errno_t localtime_s_Result=localtime_s(&Gmt_Temp , &Time);\n    struct tm* Gmt=localtime_s_Result?NULL:&Gmt_Temp;\n    #else\n    struct tm *Gmt=localtime(&Time);\n    #endif\n    Ztring DateT;\n    Ztring Date;\n    if (Gmt)\n    {\n    Date+=Ztring::ToZtring((Gmt->tm_year+1900));\n    Date+=__T(\"-\");\n    DateT.From_Number(Gmt->tm_mon+1); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mon+1);}\n    Date+=DateT;\n    Date+=__T(\"-\");\n    DateT.From_Number(Gmt->tm_mday); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_mday);}\n    Date+=DateT;\n    Date+=__T(\" \");\n    DateT.From_Number(Gmt->tm_hour); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_hour);}\n    Date+=DateT;\n    Date+=__T(\":\");\n    DateT=Ztring::ToZtring(Gmt->tm_min); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_min);}\n    Date+=DateT;\n    Date+=__T(\":\");\n    DateT.From_Number(Gmt->tm_sec); if (DateT.size()<2){DateT=Ztring(__T(\"0\"))+Ztring::ToZtring(Gmt->tm_sec);}\n    Date+=DateT;\n    assign (Date.c_str());\n    }\n    return *this;\n}", "target": 0}
{"code": "static int em_bt(struct x86_emulate_ctxt *ctxt)\n{\n\tctxt->dst.type = OP_NONE;\n\tctxt->src.val &= (ctxt->dst.bytes << 3) - 1;\n\temulate_2op_SrcV_nobyte(ctxt, \"bt\");\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": "  explicit DataFormatVecPermuteOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    string src_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"src_format\", &src_format));\n    OP_REQUIRES(context, src_format.size() == 4 || src_format.size() == 5,\n                errors::InvalidArgument(\n                    \"Source format must be of length 4 or 5, received \"\n                    \"src_format = \",\n                    src_format));\n    string dst_format;\n    OP_REQUIRES_OK(context, context->GetAttr(\"dst_format\", &dst_format));\n    OP_REQUIRES(context, dst_format.size() == 4 || dst_format.size() == 5,\n                errors::InvalidArgument(\"Destination format must be of length \"\n                                        \"4 or 5, received dst_format = \",\n                                        dst_format));\n    OP_REQUIRES(\n        context, IsValidPermutation(src_format, dst_format),\n        errors::InvalidArgument(\n            \"Destination and source format must determine a permutation, got \",\n            src_format, \" and \", dst_format));\n    src_format_ = src_format;\n    dst_format_ = dst_format;\n  }", "target": 0}
{"code": "    ThreadId thread_id() const { return thread_id_; }", "target": 0}
{"code": "  void connectErr(const AsyncSocketException& ex) noexcept override {\n    FAIL() << ex.what();\n  }", "target": 0}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = offset;\n\treturn attr;\n}", "target": 1}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tbool allow = [&]() {\n\t\t\t\tif (!inherit) {\n\t\t\t\t\tif (key_inner->IsName()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealNamedProperty(context_handle, key_inner.As<Name>()));\n\t\t\t\t\t} else if (key_inner->IsNumber()) {\n\t\t\t\t\t\treturn Unmaybe(object->HasRealIndexedProperty(context_handle, HandleCast<uint32_t>(key_inner)));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}();\n\t\t\tLocal<Value> value = allow ?\n\t\t\t\tUnmaybe(object->Get(context_handle, key_inner)) :\n\t\t\t\tUndefined(Isolate::GetCurrent()).As<Value>();\n\t\t\tret = TransferOut(value, options);\n\t\t}", "target": 1}
{"code": "ORDER *simple_remove_const(ORDER *order, COND *where)\n{\n  if (!order || !where)\n    return order;\n  ORDER *first= NULL, *prev= NULL;\n  for (; order; order= order->next)\n  {\n    DBUG_ASSERT(!order->item[0]->with_sum_func()); \n    if (!const_expression_in_where(where, order->item[0]))\n    {\n      if (!first)\n        first= order;\n      if (prev)\n        prev->next= order;\n      prev= order;\n    }\n  }\n  if (prev)\n    prev->next= NULL;\n  return first;\n}", "target": 0}
{"code": "externalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: \n    default:\n      break;\n    }\n  }\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}", "target": 1}
{"code": "static int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EAGAIN;\n\ttrace_f2fs_readpage(page, DATA);\n\tif (f2fs_has_inline_data(inode))\n\t\tret = f2fs_read_inline_data(inode, page);\n\tif (ret == -EAGAIN)\n\t\tret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);\n\treturn ret;\n}", "target": 1}
{"code": "void sas_unregister_dev(struct asd_sas_port *port, struct domain_device *dev)\n{\n\tif (!test_bit(SAS_DEV_DESTROY, &dev->state) &&\n\t    !list_empty(&dev->disco_list_node)) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_rphy_free(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t\treturn;\n\t}\n\tif (!test_and_set_bit(SAS_DEV_DESTROY, &dev->state)) {\n\t\tsas_rphy_unlink(dev->rphy);\n\t\tlist_move_tail(&dev->disco_list_node, &port->destroy_list);\n\t\tsas_discover_event(dev->port, DISCE_DESTRUCT);\n\t}\n}", "target": 1}
{"code": "static void nodeDestruct(struct SaveNode* node)\n{\n    if (node->v == &node->sorted)\n    {\n        tr_free(node->sorted.val.l.vals);\n    }\n}", "target": 1}
{"code": "  QInt32() {}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NaturalSortAndHint) {\n    addIndex(BSON(\"x\" << 1));\n    runQuerySortHint(fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << -1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << 1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    runQuerySortHint(\n        fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << -1), BSON(\"$natural\" << -1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(\n        fromjson(\"{x: {$exists: true}}\"), BSON(\"$natural\" << 1), BSON(\"$natural\" << 1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << -1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << 1), BSONObj());\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << -1), BSON(\"$natural\" << -1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: -1}}\");\n    runQuerySortHint(BSONObj(), BSON(\"$natural\" << 1), BSON(\"$natural\" << 1));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n}", "target": 0}
{"code": "deltas_head_add(struct deltas_head *deltas, unsigned long max_serial,\n    unsigned long serial, char *uri, unsigned char *hash, size_t hash_len)\n{\n\tstruct delta_head *elem;\n\tsize_t position;\n\tint error;\n\tposition = deltas->capacity - 1 - (max_serial - serial);\n\tif (position < 0 || position > deltas->capacity - 1)\n\t\treturn -EINVAL;\n\tif (deltas->array[position] != NULL)\n\t\treturn -EEXIST;\n\telem = NULL;\n\terror = delta_head_create(&elem);\n\tif (error)\n\t\treturn error;\n\telem->serial = serial;\n\telem->doc_data.uri = strdup(uri);\n\tif (elem->doc_data.uri == NULL) {\n\t\tfree(elem);\n\t\treturn pr_enomem();\n\t}\n\telem->doc_data.hash_len = hash_len;\n\telem->doc_data.hash = malloc(hash_len);\n\tif (elem->doc_data.hash == NULL) {\n\t\tfree(elem->doc_data.uri);\n\t\tfree(elem);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(elem->doc_data.hash, hash, hash_len);\n\tdeltas->array[position] = elem;\n\tdeltas->len++;\n\treturn 0;\n}", "target": 1}
{"code": "TEST(ModMatchExpression, MatchesArrayValue) {\n    ModMatchExpression mod(\"a\", 5, 2);\n    ASSERT(mod.matchesBSON(BSON(\"a\" << BSON_ARRAY(5 << 12LL)), NULL));\n    ASSERT(!mod.matchesBSON(BSON(\"a\" << BSON_ARRAY(6 << 8)), NULL));\n}", "target": 0}
{"code": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_sched_clock_irq(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers();\n\tthis_cpu_add(net_rand_state.s1, rol32(jiffies, 24) + user_tick);\n}", "target": 0}
{"code": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* data =\n      reinterpret_cast<TfLiteAudioMicrofrontendParams*>(node->user_data);\n  FrontendReset(data->state);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  if (data->out_float) {\n    GenerateFeatures<float>(data, input, output);\n  } else {\n    GenerateFeatures<int32>(data, input, output);\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "void crypto_bignum_free(struct bignum *a)\n{\n\tif (a)\n\t\tpanic();\n}", "target": 1}
{"code": "static zend_bool add_post_var(zval *arr, post_var_data_t *var, zend_bool eof TSRMLS_DC)\n{\n\tchar *ksep, *vsep, *val;\n\tsize_t klen, vlen;\n\tunsigned int new_vlen;\n\tif (var->ptr >= var->end) {\n\t\treturn 0;\n\t}\n\tvsep = memchr(var->ptr, '&', var->end - var->ptr);\n\tif (!vsep) {\n\t\tif (!eof) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvsep = var->end;\n\t\t}\n\t}\n\tksep = memchr(var->ptr, '=', vsep - var->ptr);\n\tif (ksep) {\n\t\t*ksep = '\\0';\n\t\tklen = ksep - var->ptr;\n\t\tvlen = vsep - ++ksep;\n\t} else {\n\t\tksep = \"\";\n\t\tklen = vsep - var->ptr;\n\t\tvlen = 0;\n\t}\n\tphp_url_decode(var->ptr, klen);\n\tval = estrndup(ksep, vlen);\n\tif (vlen) {\n\t\tvlen = php_url_decode(val, vlen);\n\t}\n\tif (sapi_module.input_filter(PARSE_POST, var->ptr, &val, vlen, &new_vlen TSRMLS_CC)) {\n\t\tphp_register_variable_safe(var->ptr, val, new_vlen, arr TSRMLS_CC);\n\t}\n\tefree(val);\n\tvar->ptr = vsep + (vsep != var->end);\n\treturn 1;\n}", "target": 1}
{"code": "void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\tfree(name);\n}", "target": 1}
{"code": "void Item_hex_string::print(String *str, enum_query_type query_type)\n{\n  str->append(\"X'\");\n  str->append_hex(str_value.ptr(), str_value.length());\n  str->append(\"'\");\n}", "target": 0}
{"code": "    void assignRemoteEndpoints(\n            const ParticipantProxyData& ) override\n    {\n    }", "target": 1}
{"code": "static __u8 *pl_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 60 && rdesc[39] == 0x2a && rdesc[40] == 0xf5 &&\n\t\t\trdesc[41] == 0x00 && rdesc[59] == 0x26 &&\n\t\t\trdesc[60] == 0xf9 && rdesc[61] == 0x00) {\n\t\thid_info(hdev, \"fixing up Petalynx Maxter Remote report descriptor\\n\");\n\t\trdesc[60] = 0xfa;\n\t\trdesc[40] = 0xfa;\n\t}\n\treturn rdesc;\n}", "target": 1}
{"code": "GF_Err pcrb_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu32 i;\n\tGF_PcrInfoBox *ptr = (GF_PcrInfoBox*) s;\n\te = gf_isom_box_write_header(s, bs);\n\tif (e) return e;\n\tgf_bs_write_u32(bs, ptr->subsegment_count);\n\tfor (i=0; i<ptr->subsegment_count; i++ ) {\n\t\tu32 data1 = (u32) (ptr->pcr_values[i] >> 10);\n\t\tu16 data2 = (u16) (ptr->pcr_values[i] << 6);\n\t\tgf_bs_write_u32(bs, data1);\n\t\tgf_bs_write_u16(bs, data2);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void CmdExtract::ExtractArchiveInit(Archive &Arc)\n{\n  DataIO.AdjustTotalArcSize(&Arc);\n  FileCount=0;\n  MatchedArgs=0;\n#ifndef SFX_MODULE\n  FirstFile=true;\n#endif\n  GlobalPassword=Cmd->Password.IsSet() || uiIsGlobalPasswordSet();\n  DataIO.UnpVolume=false;\n  PrevProcessed=false;\n  AllMatchesExact=true;\n  AnySolidDataUnpackedWell=false;\n  ArcAnalyzed=false;\n  StartTime.SetCurrentTime();\n  LastCheckedSymlink.clear();\n}", "target": 0}
{"code": "PJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_assert(pj_cis_match(spec,0)==0);\n    if (!pj_cis_match(spec, *s)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    do {\n\t++s;\n    } while (pj_cis_match(spec, *s));\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}", "target": 1}
{"code": "static inline bool key_is_positive(const struct key *key)\n{\n\treturn key_read_state(key) == KEY_IS_POSITIVE;\n}", "target": 0}
{"code": "\t\tvoid PdfTranslator::setSource ( const std::string & source )\n\t\t{\n\t\t\tint dbg(0);\n\t\t\tstd::cerr<< ++dbg <<std::endl;\n\t\t\tif ( checkIsPDF ( source ) )\n\t\t\t{\n\t\t\t\tmultiSource.push_back ( source );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tifstream in ( source.c_str(), ifstream::in );\n\t\t\t\tif ( !in.good() )\n\t\t\t\t\tthrow runtime_error ( \"setSource() failed to open input file\" );\n\t\t\t\tchar *filenameBuffer = new char[1000];\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tin.getline ( filenameBuffer, 1000 );\n\t\t\t\t\tstd::string ts ( filenameBuffer, in.gcount() );\n\t\t\t\t\tif ( ts.size() > 4 ) \n\t\t\t\t\t{\n\t\t\t\t\t\tmultiSource.push_back ( ts );\n\t\t\t\t\t\tstd::cerr << \"Appending \"<< ts <<\" to source\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile ( !in.eof() );\n\t\t\t\tin.close();\n\t\t\t\tdelete [] filenameBuffer;\n\t\t\t}\n\t\t\tstd::cerr<< ++dbg <<std::endl;\n\t\t\tfor ( std::vector<std::string>::const_iterator ms = multiSource.begin(); ms != multiSource.end(); ++ms )\n\t\t\t{\n\t\t\t\tif ( ms == multiSource.begin() )\n\t\t\t\t{\n\t\t\t\t\ttry{\n\t\t\t\t\t\tsourceDoc = new PdfMemDocument ( ( *ms ).c_str() );\n\t\t\t\t\t}\n\t\t\t\t\tcatch(PdfError& e)\n\t\t\t\t\t{\n                        std::cerr << \"Unable to create Document: \" << PdfError::ErrorMessage( e.GetError() ) << std::endl;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tPdfMemDocument mdoc ( ( *ms ).c_str() );\n\t\t\t\t\tsourceDoc->InsertPages ( mdoc, 0, mdoc.GetPageCount() );\n\t\t\t\t}\n\t\t\t}\n\t\t\tpcount = sourceDoc->GetPageCount();\n\t\t\tif ( pcount > 0 ) \n\t\t\t{\n\t\t\t\tPoDoFo::PdfRect rect ( sourceDoc->GetPage ( 0 )->GetMediaBox() );\n\t\t\t\tsourceWidth =  rect.GetWidth() - rect.GetLeft();\n\t\t\t\tsourceHeight =  rect.GetHeight() - rect.GetBottom() ;\n\t\t\t}\n\t\t}", "target": 1}
{"code": "fbFetchPixel_b1g2r1 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32  pixel = Fetch4(bits, offset);\n    CARD32  r,g,b;\n    b = ((pixel & 0x8) * 0xff) >> 3;\n    g = ((pixel & 0x6) * 0x55) << 7;\n    r = ((pixel & 0x1) * 0xff) << 16;\n    return 0xff000000|r|g|b;\n}", "target": 0}
{"code": "int qeth_snmp_command(struct qeth_card *card, char __user *udata)\n{\n\tstruct qeth_cmd_buffer *iob;\n\tstruct qeth_ipa_cmd *cmd;\n\tstruct qeth_snmp_ureq *ureq;\n\tint req_len;\n\tstruct qeth_arp_query_info qinfo = {0, };\n\tint rc = 0;\n\tQETH_CARD_TEXT(card, 3, \"snmpcmd\");\n\tif (card->info.guestlan)\n\t\treturn -EOPNOTSUPP;\n\tif ((!qeth_adp_supported(card, IPA_SETADP_SET_SNMP_CONTROL)) &&\n\t    (!card->options.layer2)) {\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (copy_from_user(&req_len, udata + sizeof(int), sizeof(int)))\n\t\treturn -EFAULT;\n\tureq = memdup_user(udata, req_len + sizeof(struct qeth_snmp_ureq_hdr));\n\tif (IS_ERR(ureq)) {\n\t\tQETH_CARD_TEXT(card, 2, \"snmpnome\");\n\t\treturn PTR_ERR(ureq);\n\t}\n\tqinfo.udata_len = ureq->hdr.data_len;\n\tqinfo.udata = kzalloc(qinfo.udata_len, GFP_KERNEL);\n\tif (!qinfo.udata) {\n\t\tkfree(ureq);\n\t\treturn -ENOMEM;\n\t}\n\tqinfo.udata_offset = sizeof(struct qeth_snmp_ureq_hdr);\n\tiob = qeth_get_adapter_cmd(card, IPA_SETADP_SET_SNMP_CONTROL,\n\t\t\t\t   QETH_SNMP_SETADP_CMDLENGTH + req_len);\n\tcmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);\n\tmemcpy(&cmd->data.setadapterparms.data.snmp, &ureq->cmd, req_len);\n\trc = qeth_send_ipa_snmp_cmd(card, iob, QETH_SETADP_BASE_LEN + req_len,\n\t\t\t\t    qeth_snmp_command_cb, (void *)&qinfo);\n\tif (rc)\n\t\tQETH_DBF_MESSAGE(2, \"SNMP command failed on %s: (0x%x)\\n\",\n\t\t\t   QETH_CARD_IFNAME(card), rc);\n\telse {\n\t\tif (copy_to_user(udata, qinfo.udata, qinfo.udata_len))\n\t\t\trc = -EFAULT;\n\t}\n\tkfree(ureq);\n\tkfree(qinfo.udata);\n\treturn rc;\n}", "target": 1}
{"code": "static const char *valid_domain_label(const char *label)\n{\n\tunsigned char ch;\n\tunsigned pos = 0;\n\tfor (;;) {\n\t\tch = *label;\n\t\tif ((ch|0x20) < 'a' || (ch|0x20) > 'z') {\n\t\t\tif (ch < '0' || ch > '9') {\n\t\t\t\tif (ch == '\\0' || ch == '.')\n\t\t\t\t\treturn label;\n\t\t\t\tif (ch != '-' && ch != '_')\n\t\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tlabel++;\n\t\tpos++;\n\t}\n}", "target": 0}
{"code": "urlInitialize(void)\n{\n    debugs(23, 5, \"urlInitialize: Initializing...\");\n    assert(strcmp(AnyP::ProtocolType_str[AnyP::PROTO_MAX], \"MAX\") == 0);\n    assert(0 == matchDomainName(\"foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"y.x.foo.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"x.foo.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\"foo.com\", \"x.foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \".foo.com\"));\n    assert(0 < matchDomainName(\"zzz.com\", \"foo.com\"));\n    assert(0 > matchDomainName(\"aaa.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"FOO.com\", \"foo.COM\"));\n    assert(0 < matchDomainName(\"bfoo.com\", \"afoo.com\"));\n    assert(0 > matchDomainName(\"afoo.com\", \"bfoo.com\"));\n    assert(0 < matchDomainName(\"x-foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\"y.x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\".x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 == matchDomainName(\"*.foo.com\", \"x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".foo.com\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"*.foo.com\", \"foo.com\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"foo.com\", \"\"));\n    assert(0 != matchDomainName(\"foo.com\", \"\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"foo.com\", \"\", mdnRejectSubsubDomains));\n}", "target": 0}
{"code": "static inline void native_tss_invalidate_io_bitmap(void)\n{\n\tthis_cpu_write(cpu_tss_rw.x86_tss.io_bitmap_base,\n\t\t       IO_BITMAP_OFFSET_INVALID);\n}", "target": 0}
{"code": "monitor_apply_keystate(struct monitor *pmonitor)\n{\n\tstruct ssh *ssh = active_state;\t\n\tstruct kex *kex;\n\tint r;\n\tdebug3(\"%s: packet_set_state\", __func__);\n\tif ((r = ssh_packet_set_state(ssh, child_state)) != 0)\n                fatal(\"%s: packet_set_state: %s\", __func__, ssh_err(r));\n\tsshbuf_free(child_state);\n\tchild_state = NULL;\n\tif ((kex = ssh->kex) != NULL) {\n#ifdef WITH_OPENSSL\n\t\tkex->kex[KEX_DH_GRP1_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA1] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP14_SHA256] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP16_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GRP18_SHA512] = kexdh_server;\n\t\tkex->kex[KEX_DH_GEX_SHA1] = kexgex_server;\n\t\tkex->kex[KEX_DH_GEX_SHA256] = kexgex_server;\n\t\tkex->kex[KEX_ECDH_SHA2] = kexecdh_server;\n#endif\n\t\tkex->kex[KEX_C25519_SHA256] = kexc25519_server;\n\t\tkex->load_host_public_key=&get_hostkey_public_by_type;\n\t\tkex->load_host_private_key=&get_hostkey_private_by_type;\n\t\tkex->host_key_index=&get_hostkey_index;\n\t\tkex->sign = sshd_hostkey_sign;\n\t}\n\tif (options.compression) {\n\t\tssh_packet_set_compress_hooks(ssh, pmonitor->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n}", "target": 1}
{"code": "static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)\n{\n\tint i;\n\tunsigned char max_level = 0;\n\tint unix_sock_count = 0;\n\tif (too_many_unix_fds(current))\n\t\treturn -ETOOMANYREFS;\n\tfor (i = scm->fp->count - 1; i >= 0; i--) {\n\t\tstruct sock *sk = unix_get_socket(scm->fp->fp[i]);\n\t\tif (sk) {\n\t\t\tunix_sock_count++;\n\t\t\tmax_level = max(max_level,\n\t\t\t\t\tunix_sk(sk)->recursion_level);\n\t\t}\n\t}\n\tif (unlikely(max_level > MAX_RECURSION_LEVEL))\n\t\treturn -ETOOMANYREFS;\n\tUNIXCB(skb).fp = scm_fp_dup(scm->fp);\n\tif (!UNIXCB(skb).fp)\n\t\treturn -ENOMEM;\n\tfor (i = scm->fp->count - 1; i >= 0; i--)\n\t\tunix_inflight(scm->fp->user, scm->fp->fp[i]);\n\treturn max_level;\n}", "target": 0}
{"code": "static void fuse_lib_init(void *data, struct fuse_conn_info *conn)\n{\n    struct fuse *f = (struct fuse *) data;\n    struct fuse_context_i *c = fuse_get_context_internal();\n    memset(c, 0, sizeof(*c));\n    c->ctx.fuse = f;\n    fuse_fs_init(f->fs, conn);\n}", "target": 0}
{"code": "static bool map_info2_flags_to_sbuf(const SMB_STRUCT_STAT *psbuf,\n\t\t\t\tconst uint32_t smb_fflags,\n\t\t\t\tconst uint32_t smb_fmask,\n\t\t\t\tint *stat_fflags)\n{\n\tuint32_t max_fmask = 0;\n\tint i;\n\t*stat_fflags = psbuf->st_ex_flags;\n\tfor (i = 0; i < ARRAY_SIZE(info2_flags_map); ++i) {\n\t    max_fmask |= info2_flags_map[i].smb_fflag;\n\t    if (smb_fmask & info2_flags_map[i].smb_fflag) {\n\t\t    if (smb_fflags & info2_flags_map[i].smb_fflag) {\n\t\t\t    *stat_fflags |= info2_flags_map[i].stat_fflag;\n\t\t    } else {\n\t\t\t    *stat_fflags &= ~info2_flags_map[i].stat_fflag;\n\t\t    }\n\t    }\n\t}\n\tif ((smb_fmask & max_fmask) != smb_fmask) {\n\t\treturn False;\n\t}\n\treturn True;\n}", "target": 0}
{"code": "cmsUInt8Number Word2Byte(cmsUInt16Number w)\n{\n    return (cmsUInt8Number) floor((cmsFloat64Number) w / 257.0 + 0.5);\n}", "target": 0}
{"code": "otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)\n{\n    otError error = OT_ERROR_NO_BUFS;\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);\n    RemoveJoiner(aEui64, 0); \n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (joiner->mValid)\n        {\n            continue;\n        }\n        if (aEui64 != NULL)\n        {\n            joiner->mEui64 = *aEui64;\n            joiner->mAny   = false;\n        }\n        else\n        {\n            joiner->mAny = true;\n        }\n        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));\n        joiner->mValid          = true;\n        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);\n        UpdateJoinerExpirationTimer();\n        SendCommissionerSet();\n        otLogInfoMeshCoP(\"Added Joiner (%s, %s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\", aPskd);\n        ExitNow(error = OT_ERROR_NONE);\n    }\nexit:\n    return error;\n}", "target": 1}
{"code": "compat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}", "target": 1}
{"code": "int tcp_filter(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct tcphdr *th = (struct tcphdr *)skb->data;\n\tunsigned int eaten = skb->len;\n\tint err;\n\terr = sk_filter_trim_cap(sk, skb, th->doff * 4);\n\tif (!err) {\n\t\teaten -= skb->len;\n\t\tTCP_SKB_CB(skb)->end_seq -= eaten;\n\t}\n\treturn err;\n}", "target": 0}
{"code": "pthread_mutex_unlock(pthread_mutex_t *mutex)\n{\n\tLeaveCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "static int vgacon_switch(struct vc_data *c)\n{\n\tint x = c->vc_cols * VGA_FONTWIDTH;\n\tint y = c->vc_rows * c->vc_font.height;\n\tint rows = screen_info.orig_video_lines * vga_default_font_height/\n\t\tc->vc_font.height;\n\tvga_video_num_columns = c->vc_cols;\n\tvga_video_num_lines = c->vc_rows;\n\tif (!vga_is_gfx) {\n\t\tscr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,\n\t\t\t    c->vc_screenbuf_size > vga_vram_size ?\n\t\t\t\tvga_vram_size : c->vc_screenbuf_size);\n\t\tif ((vgacon_xres != x || vgacon_yres != y) &&\n\t\t    (!(vga_video_num_columns % 2) &&\n\t\t     vga_video_num_columns <= screen_info.orig_video_cols &&\n\t\t     vga_video_num_lines <= rows))\n\t\t\tvgacon_doresize(c, c->vc_cols, c->vc_rows);\n\t}\n\tvgacon_scrollback_switch(c->vc_num);\n\treturn 0;\t\t\n}", "target": 1}
{"code": "static int adpt_hba_reset(adpt_hba* pHba)\n{\n\tint rcode;\n\tpHba->state |= DPTI_STATE_RESET;\n\tif ((rcode=adpt_i2o_activate_hba(pHba)) < 0) {\n\t\tprintk(KERN_ERR \"%s: Could not activate\\n\", pHba->name);\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tif ((rcode=adpt_i2o_build_sys_table()) < 0) {\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tPDEBUG(\"%s: in HOLD state\\n\",pHba->name);\n\tif ((rcode=adpt_i2o_online_hba(pHba)) < 0) {\n\t\tadpt_i2o_delete_hba(pHba);\t\n\t\treturn rcode;\n\t}\n\tPDEBUG(\"%s: in OPERATIONAL state\\n\",pHba->name);\n\tif ((rcode=adpt_i2o_lct_get(pHba)) < 0){\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tif ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){\n\t\tadpt_i2o_delete_hba(pHba);\n\t\treturn rcode;\n\t}\n\tpHba->state &= ~DPTI_STATE_RESET;\n\tscsi_host_complete_all_commands(pHba->host, DID_RESET);\n\treturn 0;\t\n}", "target": 1}
{"code": "static int ntlm_decode_oem_str(struct wire_field_hdr *str_hdr,\n                               struct ntlm_buffer *buffer,\n                               size_t payload_offs, char **_str)\n{\n    uint16_t str_len;\n    uint32_t str_offs;\n    char *str = NULL;\n    str_len = le16toh(str_hdr->len);\n    if (str_len == 0) goto done;\n    str_offs = le32toh(str_hdr->offset);\n    if ((str_offs < payload_offs) ||\n        (str_offs > buffer->length) ||\n        (UINT32_MAX - str_offs < str_len) ||\n        (str_offs + str_len > buffer->length)) {\n        return ERR_DECODE;\n    }\n    str = strndup((const char *)&buffer->data[str_offs], str_len);\n    if (!str) return ENOMEM;\ndone:\n    *_str = str;\n    return 0;\n}", "target": 0}
{"code": "static int translate_desc(struct vhost_dev *dev, u64 addr, u32 len,\n\t\t\t  struct iovec iov[], int iov_size)\n{\n\tconst struct vhost_memory_region *reg;\n\tstruct vhost_memory *mem;\n\tstruct iovec *_iov;\n\tu64 s = 0;\n\tint ret = 0;\n\trcu_read_lock();\n\tmem = rcu_dereference(dev->memory);\n\twhile ((u64)len > s) {\n\t\tu64 size;\n\t\tif (unlikely(ret >= iov_size)) {\n\t\t\tret = -ENOBUFS;\n\t\t\tbreak;\n\t\t}\n\t\treg = find_region(mem, addr, len);\n\t\tif (unlikely(!reg)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t_iov = iov + ret;\n\t\tsize = reg->memory_size - addr + reg->guest_phys_addr;\n\t\t_iov->iov_len = min((u64)len, size);\n\t\t_iov->iov_base = (void __user *)(unsigned long)\n\t\t\t(reg->userspace_addr + addr - reg->guest_phys_addr);\n\t\ts += size;\n\t\taddr += size;\n\t\t++ret;\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 1}
{"code": "int CF_LoadEncodedChunk(const CuckooFilter *cf, long long pos, const char *data, size_t datalen) {\n    if (datalen == 0) {\n        return REDISMODULE_ERR;\n    }\n    long long offset = pos - datalen - 1;\n    long long currentSize;\n    int filterIx = 0;\n    SubCF *filter = NULL;\n    for (; filterIx < cf->numFilters; ++filterIx) {\n        filter = cf->filters + filterIx;\n        currentSize = filter->bucketSize * filter->numBuckets;\n        if (offset < currentSize) {\n            break;\n        }\n        offset -= currentSize;\n    }\n    memcpy(filter->data + offset, data, datalen);\n    return REDISMODULE_OK;\n}", "target": 1}
{"code": "void RenderView::InsertCSS(const std::wstring& frame_xpath,\n                           const std::string& css,\n                           const std::string& id) {\n  WebFrame* web_frame = GetChildFrame(frame_xpath);\n  if (!web_frame)\n    return;\n  web_frame->insertStyleText(WebString::fromUTF8(css), WebString::fromUTF8(id));\n}", "target": 0}
{"code": "static const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[100];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, 100, \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, 100, \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, 100, \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, 100, \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, 100, \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, 100, \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, 100, \"UNDEFINED\");\n    }\n    return buf;\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size);\n        name = buffer.data() + sizeof(local_file_header_signature) + fields_size;\n        extra_data = name + name_length;\n        compressed_data = extra_data + extra_data_length;\n        return true;\n    }", "target": 1}
{"code": "int hashtable_init(hashtable_t *hashtable)\n{\n    size_t i;\n    hashtable->size = 0;\n    hashtable->num_buckets = 0;  \n    hashtable->buckets = jsonp_malloc(num_buckets(hashtable) * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    list_init(&hashtable->list);\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    return 0;\n}", "target": 1}
{"code": "static bool IsValidPermutation(const std::string& src, const std::string& dst) {\n  if (src.size() != dst.size()) {\n    return false;\n  }\n  std::map<char, bool> characters;\n  for (const auto c : src) {\n    if (characters[c]) {\n      return false;\n    }\n    characters[c] = true;\n  }\n  for (const auto c : dst) {\n    if (!characters[c]) {\n      return false;\n    }\n    characters[c] = false;\n  }\n  return true;\n}", "target": 0}
{"code": "static int base64decode_block(unsigned char *target, const char *data, size_t data_size)\n{\n\tint w1,w2,w3,w4;\n\tint i;\n\tsize_t n;\n\tif (!data || (data_size <= 0)) {\n\t\treturn 0;\n\t}\n\tn = 0;\n\ti = 0;\n\twhile (n < data_size-3) {\n\t\tw1 = base64_table[(int)data[n]];\n\t\tw2 = base64_table[(int)data[n+1]];\n\t\tw3 = base64_table[(int)data[n+2]];\n\t\tw4 = base64_table[(int)data[n+3]];\n\t\tif (w2 >= 0) {\n\t\t\ttarget[i++] = (char)((w1*4 + (w2 >> 4)) & 255);\n\t\t}\n\t\tif (w3 >= 0) {\n\t\t\ttarget[i++] = (char)((w2*16 + (w3 >> 2)) & 255);\n\t\t}\n\t\tif (w4 >= 0) {\n\t\t\ttarget[i++] = (char)((w3*64 + w4) & 255);\n\t\t}\n\t\tn+=4;\n\t}\n\treturn i;\n}", "target": 1}
{"code": "utf32le_mbc_case_fold(OnigCaseFoldType flag,\n\t\t      const UChar** pp, const UChar* end, UChar* fold)\n{\n  const UChar* p = *pp;\n  if (ONIGENC_IS_ASCII_CODE(*p) && *(p+1) == 0 && *(p+2) == 0 && *(p+3) == 0) {\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n    if ((flag & ONIGENC_CASE_FOLD_TURKISH_AZERI) != 0) {\n      if (*p == 0x49) {\n        *fold++ = 0x31;\n        *fold++ = 0x01;\n      }\n    }\n    else {\n#endif\n      *fold++ = ONIGENC_ASCII_CODE_TO_LOWER_CASE(*p);\n      *fold++ = 0;\n#ifdef USE_UNICODE_CASE_FOLD_TURKISH_AZERI\n    }\n#endif\n    *fold++ = 0;\n    *fold   = 0;\n    *pp += 4;\n    return 4;\n  }\n  else\n    return onigenc_unicode_mbc_case_fold(ONIG_ENCODING_UTF32_LE, flag, pp, end,\n                                         fold);\n}", "target": 0}
{"code": "void ip_send_reply(struct sock *sk, struct sk_buff *skb, struct ip_reply_arg *arg,\n\t\t   unsigned int len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct {\n\t\tstruct ip_options\topt;\n\t\tchar\t\t\tdata[40];\n\t} replyopts;\n\tstruct ipcm_cookie ipc;\n\t__be32 daddr;\n\tstruct rtable *rt = skb_rtable(skb);\n\tif (ip_options_echo(&replyopts.opt, skb))\n\t\treturn;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (replyopts.opt.optlen) {\n\t\tipc.opt = &replyopts.opt;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = replyopts.opt.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4;\n\t\tflowi4_init_output(&fl4, arg->bound_dev_if, 0,\n\t\t\t\t   RT_TOS(ip_hdr(skb)->tos),\n\t\t\t\t   RT_SCOPE_UNIVERSE, sk->sk_protocol,\n\t\t\t\t   ip_reply_arg_flowi_flags(arg),\n\t\t\t\t   daddr, rt->rt_spec_dst,\n\t\t\t\t   tcp_hdr(skb)->source, tcp_hdr(skb)->dest);\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(sock_net(sk), &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\treturn;\n\t}\n\tbh_lock_sock(sk);\n\tinet->tos = ip_hdr(skb)->tos;\n\tsk->sk_priority = skb->priority;\n\tsk->sk_protocol = ip_hdr(skb)->protocol;\n\tsk->sk_bound_dev_if = arg->bound_dev_if;\n\tip_append_data(sk, ip_reply_glue_bits, arg->iov->iov_base, len, 0,\n\t\t       &ipc, &rt, MSG_DONTWAIT);\n\tif ((skb = skb_peek(&sk->sk_write_queue)) != NULL) {\n\t\tif (arg->csumoffset >= 0)\n\t\t\t*((__sum16 *)skb_transport_header(skb) +\n\t\t\t  arg->csumoffset) = csum_fold(csum_add(skb->csum,\n\t\t\t\t\t\t\t\targ->csum));\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tip_push_pending_frames(sk);\n\t}\n\tbh_unlock_sock(sk);\n\tip_rt_put(rt);\n}", "target": 1}
{"code": "PHP_FUNCTION(mb_regex_encoding)\n{\n\tsize_t argc = ZEND_NUM_ARGS();\n\tchar *encoding;\n\tint encoding_len;\n\tOnigEncoding mbctype;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &encoding, &encoding_len) == FAILURE) {\n\t\treturn;\n\t}\n\tif (argc == 0) {\n\t\tconst char *retval = _php_mb_regex_mbctype2name(MBREX(current_mbctype));\n\t\tif (retval == NULL) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tRETURN_STRING((char *)retval, 1);\n\t} else if (argc == 1) {\n\t\tmbctype = _php_mb_regex_name2mbctype(encoding);\n\t\tif (mbctype == ONIG_ENCODING_UNDEF) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown encoding \\\"%s\\\"\", encoding);\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tMBREX(current_mbctype) = mbctype;\n\t\tRETURN_TRUE;\n\t}\n}", "target": 0}
{"code": "static int mailimf_group_parse(const char * message, size_t length,\n\t\t\t       size_t * indx,\n\t\t\t       struct mailimf_group ** result)\n{\n  size_t cur_token;\n  char * display_name;\n  struct mailimf_mailbox_list * mailbox_list;\n  struct mailimf_group * group;\n  int r;\n  int res;\n  clist * list;\n  cur_token = * indx;\n  mailbox_list = NULL;\n  r = mailimf_display_name_parse(message, length, &cur_token, &display_name);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto err;\n  }\n  r = mailimf_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_display_name;\n  }\n  r = mailimf_mailbox_list_parse(message, length, &cur_token, &mailbox_list);\n  switch (r) {\n  case MAILIMF_NO_ERROR:\n    break;\n  case MAILIMF_ERROR_PARSE:\n    r = mailimf_cfws_parse(message, length, &cur_token);\n    if ((r != MAILIMF_NO_ERROR) && (r != MAILIMF_ERROR_PARSE)) {\n      res = r;\n      goto free_display_name;\n    }\n    list = clist_new();\n    if (list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      goto free_display_name;\n    }\n    mailbox_list = mailimf_mailbox_list_new(list);\n    if (mailbox_list == NULL) {\n      res = MAILIMF_ERROR_MEMORY;\n      clist_free(list);\n      goto free_display_name;\n    }\n    break;\n  default:\n    res = r;\n    goto free_display_name;\n  }\n  r = mailimf_semi_colon_parse(message, length, &cur_token);\n  if (r != MAILIMF_NO_ERROR) {\n    res = r;\n    goto free_mailbox_list;\n  }\n  group = mailimf_group_new(display_name, mailbox_list);\n  if (group == NULL) {\n    res = MAILIMF_ERROR_MEMORY;\n    goto free_mailbox_list;\n  }\n  * indx = cur_token;\n  * result = group;\n  return MAILIMF_NO_ERROR;\n free_mailbox_list:\n  if (mailbox_list != NULL) {\n    mailimf_mailbox_list_free(mailbox_list);\n  }\n free_display_name:\n  mailimf_display_name_free(display_name);\n err:\n  return res;\n}", "target": 0}
{"code": "int IMA::decodeBlockQT(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tadpcmState state;\n\t\tint predictor = (encoded[0] << 8) | (encoded[1] & 0x80);\n\t\tif (predictor & 0x8000)\n\t\t\tpredictor -= 0x10000;\n\t\tstate.previousValue = clamp(predictor, MIN_INT16, MAX_INT16);\n\t\tstate.index = encoded[1] & 0x7f;\n\t\tencoded += 2;\n\t\tfor (int n=0; n<m_framesPerPacket; n+=2)\n\t\t{\n\t\t\tuint8_t e = *encoded;\n\t\t\tdecoded[n*channelCount + c] = decodeSample(state, e & 0xf);\n\t\t\tdecoded[(n+1)*channelCount + c] = decodeSample(state, e >> 4);\n\t\t\tencoded++;\n\t\t}\n\t}\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}", "target": 1}
{"code": "TEST_P(RedirectIntegrationTest, InternalRedirectHandledByDirectResponse) {\n  useAccessLog(\"%RESPONSE_FLAGS% %RESPONSE_CODE% %RESPONSE_CODE_DETAILS% %RESP(test-header)%\");\n  config_helper_.addConfigModifier(\n      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&\n             hcm) { hcm.set_via(\"via_value\"); });\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  default_request_headers_.setHost(\"handle.internal.redirect\");\n  IntegrationStreamDecoderPtr response =\n      codec_client_->makeHeaderOnlyRequest(default_request_headers_);\n  waitForNextUpstreamRequest();\n  redirect_response_.setLocation(\"http:\n  upstream_request_->encodeHeaders(redirect_response_, true);\n  ASSERT_TRUE(response->waitForEndStream());\n  ASSERT_TRUE(response->complete());\n  EXPECT_EQ(\"204\", response->headers().getStatusValue());\n  EXPECT_EQ(1, test_server_->counter(\"cluster.cluster_0.upstream_internal_redirect_succeeded_total\")\n                   ->value());\n  EXPECT_EQ(0, test_server_->counter(\"http.config_test.downstream_rq_3xx\")->value());\n  EXPECT_EQ(1, test_server_->counter(\"http.config_test.downstream_rq_2xx\")->value());\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 0),\n              HasSubstr(\"302 internal_redirect test-header-value\\n\"));\n  EXPECT_THAT(waitForAccessLog(access_log_name_, 1), HasSubstr(\"204 direct_response -\\n\"));\n}", "target": 0}
{"code": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && !ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));\n\t\tio = (struct id_off *)(ps + 1);\n\t\tfor (ie = io + ps->nid; io < ie && !ND_TTEST(*io); ++io) {\n\t\t\tND_PRINT((ndo, \"%c%s:%u\", c, ipaddr_string(ndo, &io->id),\n\t\t\t    EXTRACT_32BITS(&io->off)));\n\t\t\tc = ',';\n\t\t}\n\t\tND_PRINT((ndo, \">\"));\n\t\tps = (struct pgstate *)io;\n\t}\n\treturn ((u_char *)ps <= ep? 0 : -1);\n}", "target": 1}
{"code": "static bool io_wq_for_each_worker(struct io_wqe *wqe,\n\t\t\t\t  bool (*func)(struct io_worker *, void *),\n\t\t\t\t  void *data)\n{\n\tstruct io_worker *worker;\n\tbool ret = false;\n\tlist_for_each_entry_rcu(worker, &wqe->all_list, all_list) {\n\t\tif (io_worker_get(worker)) {\n\t\t\tif (worker->task)\n\t\t\t\tret = func(worker, data);\n\t\t\tio_worker_release(worker);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source)\n{\n  lodepng_info_cleanup(dest);\n  *dest = *source;\n  lodepng_color_mode_init(&dest->color);\n  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));\n#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS\n  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));\n  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));\n  LodePNGUnknownChunks_init(dest);\n  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));\n#endif \n  return 0;\n}", "target": 0}
{"code": "xfs_attr_rmtval_get(\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_bmbt_irec\tmap[ATTR_RMTVALUE_MAPSIZE];\n\tstruct xfs_mount\t*mp = args->dp->i_mount;\n\tstruct xfs_buf\t\t*bp;\n\txfs_dablk_t\t\tlblkno = args->rmtblkno;\n\t__uint8_t\t\t*dst = args->value;\n\tint\t\t\tvaluelen = args->valuelen;\n\tint\t\t\tnmap;\n\tint\t\t\terror;\n\tint\t\t\tblkcnt = args->rmtblkcnt;\n\tint\t\t\ti;\n\tint\t\t\toffset = 0;\n\ttrace_xfs_attr_rmtval_get(args);\n\tASSERT(!(args->flags & ATTR_KERNOVAL));\n\twhile (valuelen > 0) {\n\t\tnmap = ATTR_RMTVALUE_MAPSIZE;\n\t\terror = xfs_bmapi_read(args->dp, (xfs_fileoff_t)lblkno,\n\t\t\t\t       blkcnt, map, &nmap,\n\t\t\t\t       XFS_BMAPI_ATTRFORK);\n\t\tif (error)\n\t\t\treturn error;\n\t\tASSERT(nmap >= 1);\n\t\tfor (i = 0; (i < nmap) && (valuelen > 0); i++) {\n\t\t\txfs_daddr_t\tdblkno;\n\t\t\tint\t\tdblkcnt;\n\t\t\tASSERT((map[i].br_startblock != DELAYSTARTBLOCK) &&\n\t\t\t       (map[i].br_startblock != HOLESTARTBLOCK));\n\t\t\tdblkno = XFS_FSB_TO_DADDR(mp, map[i].br_startblock);\n\t\t\tdblkcnt = XFS_FSB_TO_BB(mp, map[i].br_blockcount);\n\t\t\terror = xfs_trans_read_buf(mp, NULL, mp->m_ddev_targp,\n\t\t\t\t\t\t   dblkno, dblkcnt, 0, &bp,\n\t\t\t\t\t\t   &xfs_attr3_rmt_buf_ops);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\terror = xfs_attr_rmtval_copyout(mp, bp, args->dp->i_ino,\n\t\t\t\t\t\t\t&offset, &valuelen,\n\t\t\t\t\t\t\t&dst);\n\t\t\txfs_buf_relse(bp);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tlblkno += map[i].br_blockcount;\n\t\t\tblkcnt -= map[i].br_blockcount;\n\t\t}\n\t}\n\tASSERT(valuelen == 0);\n\treturn 0;\n}", "target": 1}
{"code": "ECDSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                    RandomNumberGenerator& rng)\n   {\n   BigInt m(msg, msg_len, m_group.get_order_bits());\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   const BigInt k = generate_rfc6979_nonce(m_x, m_group.get_order(), m, m_rfc6979_hash);\n#else\n   const BigInt k = m_group.random_scalar(rng);\n#endif\n   const BigInt k_inv = m_group.inverse_mod_order(k);\n   const BigInt r = m_group.mod_order(\n      m_group.blinded_base_point_multiply_x(k, rng, m_ws));\n   const BigInt xrm = m_group.mod_order(m_group.multiply_mod_order(m_x, r) + m);\n   const BigInt s = m_group.multiply_mod_order(k_inv, xrm);\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"During ECDSA signature generated zero r/s\");\n   return BigInt::encode_fixed_length_int_pair(r, s, m_group.get_order_bytes());\n   }", "target": 1}
{"code": "int bad_format_print(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING FLOAT_STRING SAFE_STRING \"%s\" SAFE_STRING \"$\",fmt);\n}", "target": 0}
{"code": "void lremCommand(client *c) {\n    robj *subject, *obj;\n    obj = c->argv[3];\n    long toremove;\n    long removed = 0;\n    if (sdslen(obj->ptr) > LIST_MAX_ITEM_SIZE) {\n        addReplyError(c, \"Element too large\");\n        return;\n    }\n    if ((getLongFromObjectOrReply(c, c->argv[2], &toremove, NULL) != C_OK))\n        return;\n    subject = lookupKeyWriteOrReply(c,c->argv[1],shared.czero);\n    if (subject == NULL || checkType(c,subject,OBJ_LIST)) return;\n    listTypeIterator *li;\n    if (toremove < 0) {\n        toremove = -toremove;\n        li = listTypeInitIterator(subject,-1,LIST_HEAD);\n    } else {\n        li = listTypeInitIterator(subject,0,LIST_TAIL);\n    }\n    listTypeEntry entry;\n    while (listTypeNext(li,&entry)) {\n        if (listTypeEqual(&entry,obj)) {\n            listTypeDelete(li, &entry);\n            server.dirty++;\n            removed++;\n            if (toremove && removed == toremove) break;\n        }\n    }\n    listTypeReleaseIterator(li);\n    if (removed) {\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,\"lrem\",c->argv[1],c->db->id);\n    }\n    if (listTypeLength(subject) == 0) {\n        dbDelete(c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_GENERIC,\"del\",c->argv[1],c->db->id);\n    }\n    addReplyLongLong(c,removed);\n}", "target": 0}
{"code": "gss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n    prf_out->length = 0;\n    prf_out->value = NULL;\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn status;\n    }\n    return GSS_S_BAD_MECH;\n}", "target": 0}
{"code": "static int sysfs_slab_add(struct kmem_cache *s)\n{\n\tint err;\n\tconst char *name;\n\tstruct kset *kset = cache_kset(s);\n\tint unmergeable = slab_unmergeable(s);\n\tINIT_WORK(&s->kobj_remove_work, sysfs_slab_remove_workfn);\n\tif (!kset) {\n\t\tkobject_init(&s->kobj, &slab_ktype);\n\t\treturn 0;\n\t}\n\tif (!unmergeable && disable_higher_order_debug &&\n\t\t\t(slub_debug & DEBUG_METADATA_FLAGS))\n\t\tunmergeable = 1;\n\tif (unmergeable) {\n\t\tsysfs_remove_link(&slab_kset->kobj, s->name);\n\t\tname = s->name;\n\t} else {\n\t\tname = create_unique_id(s);\n\t}\n\ts->kobj.kset = kset;\n\terr = kobject_init_and_add(&s->kobj, &slab_ktype, NULL, \"%s\", name);\n\tif (err)\n\t\tgoto out;\n\terr = sysfs_create_group(&s->kobj, &slab_attr_group);\n\tif (err)\n\t\tgoto out_del_kobj;\n#ifdef CONFIG_MEMCG\n\tif (is_root_cache(s) && memcg_sysfs_enabled) {\n\t\ts->memcg_kset = kset_create_and_add(\"cgroup\", NULL, &s->kobj);\n\t\tif (!s->memcg_kset) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_del_kobj;\n\t\t}\n\t}\n#endif\n\tkobject_uevent(&s->kobj, KOBJ_ADD);\n\tif (!unmergeable) {\n\t\tsysfs_slab_alias(s, s->name);\n\t}\nout:\n\tif (!unmergeable)\n\t\tkfree(name);\n\treturn err;\nout_del_kobj:\n\tkobject_del(&s->kobj);\n\tgoto out;", "target": 0}
{"code": "static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        sampler->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n  return true;\n}", "target": 1}
{"code": "char *ReadInput(char *filename)\n{\n    FILE *finput;\n    long filesize, num;\n    char *buffer;\n    if ( ( finput = fopen(filename,\"r\") ) == 0 ) {\n        fprintf(stderr,\"%s: Cannot open file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    if ( ( fseek(finput,0,SEEK_END) != 0 )\n      || ( ( filesize = ftell(finput) ) < 0 )\n      || ( fseek(finput,0,SEEK_SET) != 0 ) ) {\n        fprintf(stderr,\"%s: File error in file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    if ( ( buffer = malloc((filesize+1)*sizeof(char)) ) == 0 ) {\n        fprintf(stderr,\"%s: Error allocating %ld bytes of memory\",axohelp,filesize+1);\n        exit(-1);\n    }\n    num = fread( buffer, 1, filesize, finput );\n    if ( ferror(finput) ) {\n        fprintf(stderr,\"%s: Error reading file %s\\n\",axohelp,filename);\n        exit(-1);\n    }\n    buffer[num] = 0;\n    fclose(finput);\n    return(buffer);\n}", "target": 1}
{"code": "static void packet_dev_mclist_delete(struct net_device *dev,\n\t\t\t\t     struct packet_mclist **mlp)\n{\n\tstruct packet_mclist *ml;\n\twhile ((ml = *mlp) != NULL) {\n\t\tif (ml->ifindex == dev->ifindex) {\n\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\t\t*mlp = ml->next;\n\t\t\tkfree(ml);\n\t\t} else\n\t\t\tmlp = &ml->next;\n\t}\n}", "target": 0}
{"code": "gss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n        return(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "static inline bool sched_clock_stable(void)\n{\n\treturn true;\n}", "target": 0}
{"code": "unsigned char *ziplistMerge(unsigned char **first, unsigned char **second) {\n    if (first == NULL || *first == NULL || second == NULL || *second == NULL)\n        return NULL;\n    if (*first == *second)\n        return NULL;\n    size_t first_bytes = intrev32ifbe(ZIPLIST_BYTES(*first));\n    size_t first_len = intrev16ifbe(ZIPLIST_LENGTH(*first));\n    size_t second_bytes = intrev32ifbe(ZIPLIST_BYTES(*second));\n    size_t second_len = intrev16ifbe(ZIPLIST_LENGTH(*second));\n    int append;\n    unsigned char *source, *target;\n    size_t target_bytes, source_bytes;\n    if (first_len >= second_len) {\n        target = *first;\n        target_bytes = first_bytes;\n        source = *second;\n        source_bytes = second_bytes;\n        append = 1;\n    } else {\n        target = *second;\n        target_bytes = second_bytes;\n        source = *first;\n        source_bytes = first_bytes;\n        append = 0;\n    }\n    size_t zlbytes = first_bytes + second_bytes -\n                     ZIPLIST_HEADER_SIZE - ZIPLIST_END_SIZE;\n    size_t zllength = first_len + second_len;\n    zllength = zllength < UINT16_MAX ? zllength : UINT16_MAX;\n    assert(zlbytes < UINT32_MAX);\n    size_t first_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*first));\n    size_t second_offset = intrev32ifbe(ZIPLIST_TAIL_OFFSET(*second));\n    target = zrealloc(target, zlbytes);\n    if (append) {\n        memcpy(target + target_bytes - ZIPLIST_END_SIZE,\n               source + ZIPLIST_HEADER_SIZE,\n               source_bytes - ZIPLIST_HEADER_SIZE);\n    } else {\n        memmove(target + source_bytes - ZIPLIST_END_SIZE,\n                target + ZIPLIST_HEADER_SIZE,\n                target_bytes - ZIPLIST_HEADER_SIZE);\n        memcpy(target, source, source_bytes - ZIPLIST_END_SIZE);\n    }\n    ZIPLIST_BYTES(target) = intrev32ifbe(zlbytes);\n    ZIPLIST_LENGTH(target) = intrev16ifbe(zllength);\n    ZIPLIST_TAIL_OFFSET(target) = intrev32ifbe(\n                                   (first_bytes - ZIPLIST_END_SIZE) +\n                                   (second_offset - ZIPLIST_HEADER_SIZE));\n    target = __ziplistCascadeUpdate(target, target+first_offset);\n    if (append) {\n        zfree(*second);\n        *second = NULL;\n        *first = target;\n    } else {\n        zfree(*first);\n        *first = NULL;\n        *second = target;\n    }\n    return target;\n}", "target": 0}
{"code": "gss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov_length == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,\n\t\t\t\t\t  qop_req, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}", "target": 0}
{"code": "static int fbcon_set_font(struct vc_data *vc, struct console_font *font,\n\t\t\t  unsigned int flags)\n{\n\tstruct fb_info *info = fbcon_info_from_console(vc->vc_num);\n\tunsigned charcount = font->charcount;\n\tint w = font->width;\n\tint h = font->height;\n\tint size;\n\tint i, csum;\n\tu8 *new_data, *data = font->data;\n\tint pitch = PITCH(font->width);\n\tif (charcount != 256 && charcount != 512)\n\t\treturn -EINVAL;\n\tif (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) ||\n\t    h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres))\n\t\treturn -EINVAL;\n\tif (!(info->pixmap.blit_x & (1 << (font->width - 1))) ||\n\t    !(info->pixmap.blit_y & (1 << (font->height - 1))))\n\t\treturn -EINVAL;\n\tif (fbcon_invalid_charcount(info, charcount))\n\t\treturn -EINVAL;\n\tsize = CALC_FONTSZ(h, pitch, charcount);\n\tnew_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int));\n\tnew_data += FONT_EXTRA_WORDS * sizeof(int);\n\tFNTSIZE(new_data) = size;\n\tREFCOUNT(new_data) = 0;\t\n\tfor (i=0; i< charcount; i++) {\n\t\tmemcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch);\n\t}\n\tcsum = crc32(0, new_data, size);\n\tFNTSUM(new_data) = csum;\n\tfor (i = first_fb_vc; i <= last_fb_vc; i++) {\n\t\tstruct vc_data *tmp = vc_cons[i].d;\n\t\tif (fb_display[i].userfont &&\n\t\t    fb_display[i].fontdata &&\n\t\t    FNTSUM(fb_display[i].fontdata) == csum &&\n\t\t    FNTSIZE(fb_display[i].fontdata) == size &&\n\t\t    tmp->vc_font.width == w &&\n\t\t    !memcmp(fb_display[i].fontdata, new_data, size)) {\n\t\t\tkfree(new_data - FONT_EXTRA_WORDS * sizeof(int));\n\t\t\tnew_data = (u8 *)fb_display[i].fontdata;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1);\n}", "target": 1}
{"code": "void SFS_ArrayDeref(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \"[\");\n\tSFS_CompoundExpression(parser);\n\tSFS_AddString(parser, \"]\");\n}", "target": 0}
{"code": "  FramebufferManager::FramebufferInfo* GetFramebufferInfoForTarget(\n      GLenum target) {\n    FramebufferManager::FramebufferInfo* info = NULL;\n    switch (target) {\n      case GL_FRAMEBUFFER:\n      case GL_DRAW_FRAMEBUFFER:\n        info = bound_draw_framebuffer_;\n        break;\n      case GL_READ_FRAMEBUFFER:\n        info = bound_read_framebuffer_;\n        break;\n      default:\n        NOTREACHED();\n        break;\n    }\n    return info;\n  }", "target": 0}
{"code": "gopherHTMLFooter(StoreEntry * e)\n{\n    storeAppendPrintf(e, \"<HR noshade size=\\\"1px\\\">\\n\");\n    storeAppendPrintf(e, \"<ADDRESS>\\n\");\n    storeAppendPrintf(e, \"Generated %s by %s (%s)\\n\",\n                      Time::FormatRfc1123(squid_curtime),\n                      getMyHostname(),\n                      visible_appname_string);\n    storeAppendPrintf(e, \"</ADDRESS></BODY></HTML>\\n\");\n}", "target": 1}
{"code": "int IMA::decodeBlockWAVE(const uint8_t *encoded, int16_t *decoded)\n{\n\tint channelCount = m_track->f.channelCount;\n\tfor (int c=0; c<channelCount; c++)\n\t{\n\t\tm_adpcmState[c].previousValue = (encoded[1]<<8) | encoded[0];\n\t\tif (encoded[1] & 0x80)\n\t\t\tm_adpcmState[c].previousValue -= 0x10000;\n\t\tm_adpcmState[c].index = encoded[2];\n\t\t*decoded++ = m_adpcmState[c].previousValue;\n\t\tencoded += 4;\n\t}\n\tfor (int n=0; n<m_framesPerPacket - 1; n += 8)\n\t{\n\t\tfor (int c=0; c<channelCount; c++)\n\t\t{\n\t\t\tint16_t *output = decoded + c;\n\t\t\tfor (int s=0; s<4; s++)\n\t\t\t{\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded & 0xf);\n\t\t\t\toutput += channelCount;\n\t\t\t\t*output = decodeSample(m_adpcmState[c], *encoded >> 4);\n\t\t\t\toutput += channelCount;\n\t\t\t\tencoded++;\n\t\t\t}\n\t\t}\n\t\tdecoded += channelCount * 8;\n\t}\n\treturn m_framesPerPacket * channelCount * sizeof (int16_t);\n}", "target": 1}
{"code": "av_cold int ff_vc2enc_init_transforms(VC2TransformContext *s, int p_width, int p_height)\n{\n    s->vc2_subband_dwt[VC2_TRANSFORM_9_7]    = vc2_subband_dwt_97;\n    s->vc2_subband_dwt[VC2_TRANSFORM_5_3]    = vc2_subband_dwt_53;\n    s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));\n    if (!s->buffer)\n        return 1;\n    return 0;\n}", "target": 1}
{"code": "  Status CheckInputs(Tensor group_size_t, Tensor group_key_t) {\n    if (group_size_t.dims() > 0) {\n      return errors::Internal(\n          \"Unexpected dimensions on input group_size. \"\n          \"It shoulbe a scalar, got tensor with shape \",\n          group_size_t.shape().DebugString());\n    }\n    if (group_key_t.dims() > 0) {\n      return errors::Internal(\"Unexpected dimensions on input group_key, got \",\n                              group_key_t.shape().DebugString());\n    }\n    auto group_size = group_size_t.unaligned_flat<int32>()(0);\n    if (group_size <= 0) {\n      return errors::InvalidArgument(\n          \"group_size must be positive integer but got \", group_size);\n    }\n    return Status::OK();\n  }", "target": 1}
{"code": "mwifiex_cmd_append_vsie_tlv(struct mwifiex_private *priv,\n\t\t\t    u16 vsie_mask, u8 **buffer)\n{\n\tint id, ret_len = 0;\n\tstruct mwifiex_ie_types_vendor_param_set *vs_param_set;\n\tif (!buffer)\n\t\treturn 0;\n\tif (!(*buffer))\n\t\treturn 0;\n\tfor (id = 0; id < MWIFIEX_MAX_VSIE_NUM; id++) {\n\t\tif (priv->vs_ie[id].mask & vsie_mask) {\n\t\t\tvs_param_set =\n\t\t\t\t(struct mwifiex_ie_types_vendor_param_set *)\n\t\t\t\t*buffer;\n\t\t\tvs_param_set->header.type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_PASSTHROUGH);\n\t\t\tvs_param_set->header.len =\n\t\t\t\tcpu_to_le16((((u16) priv->vs_ie[id].ie[1])\n\t\t\t\t& 0x00FF) + 2);\n\t\t\tif (le16_to_cpu(vs_param_set->header.len) >\n\t\t\t\tMWIFIEX_MAX_VSIE_LEN) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"Invalid param length!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(vs_param_set->ie, priv->vs_ie[id].ie,\n\t\t\t       le16_to_cpu(vs_param_set->header.len));\n\t\t\t*buffer += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t\tret_len += le16_to_cpu(vs_param_set->header.len) +\n\t\t\t\t   sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\t}\n\treturn ret_len;\n}", "target": 0}
{"code": "__ext4_set_acl(handle_t *handle, struct inode *inode, int type,\n\t     struct posix_acl *acl)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ext4_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\terror = ext4_xattr_set_handle(handle, inode, name_index, \"\",\n\t\t\t\t      value, size, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "void receive_tcppacket(connection_t *c, const char *buffer, int len) {\n\tvpn_packet_t outpkt;\n\tif(len > sizeof outpkt.data)\n\t\treturn;\n\toutpkt.len = len;\n\tif(c->options & OPTION_TCPONLY)\n\t\toutpkt.priority = 0;\n\telse\n\t\toutpkt.priority = -1;\n\tmemcpy(outpkt.data, buffer, len);\n\treceive_packet(c->node, &outpkt);\n}", "target": 0}
{"code": "iakerb_gss_import_sec_context(OM_uint32 *minor_status,\n                              gss_buffer_t interprocess_token,\n                              gss_ctx_id_t *context_handle)\n{\n    OM_uint32 maj, tmpmin;\n    krb5_error_code code;\n    gss_ctx_id_t gssc;\n    krb5_gss_ctx_id_t kctx;\n    iakerb_ctx_id_t ctx;\n    maj = krb5_gss_import_sec_context(minor_status, interprocess_token, &gssc);\n    if (maj != GSS_S_COMPLETE)\n        return maj;\n    kctx = (krb5_gss_ctx_id_t)gssc;\n    if (!kctx->established) {\n        krb5_gss_delete_sec_context(&tmpmin, &gssc, GSS_C_NO_BUFFER);\n        return GSS_S_FAILURE;\n    }\n    code = iakerb_alloc_context(&ctx, kctx->initiate);\n    if (code != 0) {\n        krb5_gss_delete_sec_context(&tmpmin, &gssc, GSS_C_NO_BUFFER);\n        *minor_status = code;\n        return GSS_S_FAILURE;\n    }\n    ctx->gssc = gssc;\n    ctx->established = 1;\n    *context_handle = (gss_ctx_id_t)ctx;\n    return GSS_S_COMPLETE;\n}", "target": 0}
{"code": "[[noreturn]] void TProtocolException::throwTruncatedData() {\n  throw TProtocolException(\n      TProtocolException::INVALID_DATA,\n      \"Not enough bytes to read the entire message, the data appears to be \"\n      \"truncated\");\n}", "target": 0}
{"code": "static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result = 0;\n\tif (!priv->comm_is_ok)\n\t\treturn -EIO;\n\tusb_clear_halt(serial->dev, 0x81);\n\tusb_clear_halt(serial->dev, 0x02);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->bytes_in = 0;\n\tpriv->bytes_out = 0;\n\tpriv->cmd_count = 0;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tcypress_send(port);\n\tif (tty)\n\t\tcypress_set_termios(tty, port, &priv->tmp_termios);\n\tif (!port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"%s - interrupt_in_urb is empty!\\n\",\n\t\t\t__func__);\n\t\treturn -1;\n\t}\n\tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n\t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n\t\tport->interrupt_in_urb->transfer_buffer,\n\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv->read_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\treturn result;\n} ", "target": 1}
{"code": "static void bson_append( bson *b, const void *data, int len ) {\n    memcpy( b->cur , data , len );\n    b->cur += len;\n}", "target": 1}
{"code": "ring_buffer_read_finish(struct ring_buffer_iter *iter)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer = iter->cpu_buffer;\n\tunsigned long flags;\n\traw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);\n\trb_check_pages(cpu_buffer);\n\traw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);\n\tatomic_dec(&cpu_buffer->record_disabled);\n\tatomic_dec(&cpu_buffer->buffer->resize_disabled);\n\tkfree(iter);\n}", "target": 0}
{"code": "snmp_oid_copy(uint32_t *dst, uint32_t *src)\n{\n  uint8_t i;\n  i = 0;\n  while(src[i] != ((uint32_t)-1)) {\n    dst[i] = src[i];\n    i++;\n  }\n  dst[i] = src[i];\n}", "target": 1}
{"code": "\t\tvoid CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep)\n\t\t{\n\t\t\tstd::string idx = request::findValue(&req, \"idx\");\n\t\t\tif (idx == \"\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstd::vector<std::vector<std::string> > result;\n\t\t\tresult = m_sql.safe_queryBlob(\"SELECT Image FROM Floorplans WHERE ID=%s\", idx.c_str());\n\t\t\tif (result.empty())\n\t\t\t\treturn;\n\t\t\treply::set_content(&rep, result[0][0].begin(), result[0][0].end());\n\t\t\tstd::string oname = \"floorplan\";\n\t\t\tif (result[0][0].size() > 10)\n\t\t\t{\n\t\t\t\tif (result[0][0][0] == 'P')\n\t\t\t\t\toname += \".png\";\n\t\t\t\telse if (result[0][0][0] == -1)\n\t\t\t\t\toname += \".jpg\";\n\t\t\t\telse if (result[0][0][0] == 'B')\n\t\t\t\t\toname += \".bmp\";\n\t\t\t\telse if (result[0][0][0] == 'G')\n\t\t\t\t\toname += \".gif\";\n\t\t\t}\n\t\t\treply::add_header_attachment(&rep, oname);\n\t\t}", "target": 1}
{"code": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t\n\toptions += 3;\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}", "target": 1}
{"code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\tkey_ref = lookup_user_key(id, 0, KEY_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\tret = key_update(key_ref, payload, plen);\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "X509_NAME_oneline_ex(X509_NAME * a,\n                     char *buf,\n                     unsigned int *size,\n                     unsigned long flag)\n{\n    BIO *out = NULL;\n    out = BIO_new(BIO_s_mem ());\n    if (X509_NAME_print_ex(out, a, 0, flag) > 0) {\n        if (buf != NULL && (*size) >  (unsigned int) BIO_number_written(out)) {\n            memset(buf, 0, *size);\n            BIO_read(out, buf, (int) BIO_number_written(out));\n        }\n        else {\n            *size = BIO_number_written(out);\n        }\n    }\n    BIO_free(out);\n    return (buf);\n}", "target": 1}
{"code": "static void process_request(struct connection *conn) {\n    num_requests++;\n    if (!parse_request(conn)) {\n        default_reply(conn, 400, \"Bad Request\",\n            \"You sent a request that the server couldn't understand.\");\n    }\n    else if (is_https_redirect(conn)) {\n        redirect_https(conn);\n    }\n    else if (auth_key != NULL &&\n            (conn->authorization == NULL ||\n             strcmp(conn->authorization, auth_key)))\n    {\n        default_reply(conn, 401, \"Unauthorized\",\n            \"Access denied due to invalid credentials.\");\n    }\n    else if (strcmp(conn->method, \"GET\") == 0) {\n        process_get(conn);\n    }\n    else if (strcmp(conn->method, \"HEAD\") == 0) {\n        process_get(conn);\n        conn->header_only = 1;\n    }\n    else {\n        default_reply(conn, 501, \"Not Implemented\",\n                      \"The method you specified is not implemented.\");\n    }\n    conn->state = SEND_HEADER;\n    free(conn->request);\n    conn->request = NULL; \n}", "target": 1}
{"code": "IW_IMPL(int) iw_get_i32le(const iw_byte *b)\n{\n\treturn (iw_int32)(iw_uint32)(b[0] | (b[1]<<8) | (b[2]<<16) | (b[3]<<24));\n}", "target": 1}
{"code": "setkey_principal3_2_svc(setkey3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal_3((void *)handle, arg->princ,\n                                            arg->keepold,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "_dbus_credentials_add_from_current_process (DBusCredentials *credentials)\n{\n  _dbus_assert (sizeof (pid_t) <= sizeof (dbus_pid_t));\n  _dbus_assert (sizeof (uid_t) <= sizeof (dbus_uid_t));\n  _dbus_assert (sizeof (gid_t) <= sizeof (dbus_gid_t));\n  if (!_dbus_credentials_add_unix_pid(credentials, _dbus_getpid()))\n    return FALSE;\n  if (!_dbus_credentials_add_unix_uid(credentials, _dbus_geteuid()))\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "int safe_mount(const char *src, const char *dest, const char *fstype,\n\t\tunsigned long flags, const void *data, const char *rootfs)\n{\n\tint srcfd = -1, destfd, ret, saved_errno;\n\tchar srcbuf[50], destbuf[50]; \n\tconst char *mntsrc = src;\n\tif (!rootfs)\n\t\trootfs = \"\";\n\tif (flags & MS_BIND && src && src[0] != '/') {\n\t\tINFO(\"this is a relative bind mount\");\n\t\tsrcfd = open_without_symlink(src, NULL);\n\t\tif (srcfd < 0)\n\t\t\treturn srcfd;\n\t\tret = snprintf(srcbuf, 50, \"/proc/self/fd/%d\", srcfd);\n\t\tif (ret < 0 || ret > 50) {\n\t\t\tclose(srcfd);\n\t\t\tERROR(\"Out of memory\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmntsrc = srcbuf;\n\t}\n\tdestfd = open_without_symlink(dest, rootfs);\n\tif (destfd < 0) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\treturn destfd;\n\t}\n\tret = snprintf(destbuf, 50, \"/proc/self/fd/%d\", destfd);\n\tif (ret < 0 || ret > 50) {\n\t\tif (srcfd != -1)\n\t\t\tclose(srcfd);\n\t\tclose(destfd);\n\t\tERROR(\"Out of memory\");\n\t\treturn -EINVAL;\n\t}\n\tret = mount(mntsrc, destbuf, fstype, flags, data);\n\tsaved_errno = errno;\n\tif (srcfd != -1)\n\t\tclose(srcfd);\n\tclose(destfd);\n\tif (ret < 0) {\n\t\terrno = saved_errno;\n\t\tSYSERROR(\"Failed to mount %s onto %s\", src, dest);\n\t\treturn ret;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "parseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "    Curl()\n    {\n        requestHeaders = 0;\n        curl = curl_easy_init();\n        if (!curl) throw Error(\"unable to initialize curl\");\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        curl_easy_setopt(curl, CURLOPT_CAINFO, getEnv(\"SSL_CERT_FILE\", \"/etc/ssl/certs/ca-certificates.crt\").c_str());\n        curl_easy_setopt(curl, CURLOPT_USERAGENT, (\"Nix/\" + nixVersion).c_str());\n        curl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, headerCallback);\n        curl_easy_setopt(curl, CURLOPT_HEADERDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, progressCallback_);\n        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, (void *) &curl);\n        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 0);\n        showProgress = isatty(STDERR_FILENO);\n    }", "target": 1}
{"code": "void usbredirparser_send_get_configuration(struct usbredirparser *parser,\n    uint64_t id)\n{\n    usbredirparser_queue(parser, usb_redir_get_configuration, id,\n                         NULL, NULL, 0);\n}", "target": 0}
{"code": "static void coroutine_fn v9fs_symlink(void *opaque)\n{\n    V9fsPDU *pdu = opaque;\n    V9fsString name;\n    V9fsString symname;\n    V9fsFidState *dfidp;\n    V9fsQID qid;\n    struct stat stbuf;\n    int32_t dfid;\n    int err = 0;\n    gid_t gid;\n    size_t offset = 7;\n    v9fs_string_init(&name);\n    v9fs_string_init(&symname);\n    err = pdu_unmarshal(pdu, offset, \"dssd\", &dfid, &name, &symname, &gid);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    trace_v9fs_symlink(pdu->tag, pdu->id, dfid, name.data, symname.data, gid);\n    if (name_is_illegal(name.data)) {\n        err = -ENOENT;\n        goto out_nofid;\n    }\n    if (!strcmp(\".\", name.data) || !strcmp(\"..\", name.data)) {\n        err = -EEXIST;\n        goto out_nofid;\n    }\n    dfidp = get_fid(pdu, dfid);\n    if (dfidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    err = v9fs_co_symlink(pdu, dfidp, &name, symname.data, gid, &stbuf);\n    if (err < 0) {\n        goto out;\n    }\n    err = stat_to_qid(pdu, &stbuf, &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err =  pdu_marshal(pdu, offset, \"Q\", &qid);\n    if (err < 0) {\n        goto out;\n    }\n    err += offset;\n    trace_v9fs_symlink_return(pdu->tag, pdu->id,\n                              qid.type, qid.version, qid.path);\nout:\n    put_fid(pdu, dfidp);\nout_nofid:\n    pdu_complete(pdu, err);\n    v9fs_string_free(&name);\n    v9fs_string_free(&symname);\n}", "target": 0}
{"code": "FastCGIServer::FastCGIServer(const std::string &address,\n                             int port,\n                             int workers,\n                             bool useFileSocket)\n  : Server(address, port),\n    m_worker(&m_eventBaseManager),\n    m_dispatcher(workers, workers,\n                 RuntimeOption::ServerThreadDropCacheTimeoutSeconds,\n                 RuntimeOption::ServerThreadDropStack,\n                 this,\n                 RuntimeOption::ServerThreadJobLIFOSwitchThreshold,\n                 RuntimeOption::ServerThreadJobMaxQueuingMilliSeconds,\n                 RequestPriority::k_numPriorities) {\n  folly::SocketAddress sock_addr;\n  if (useFileSocket) {\n    sock_addr.setFromPath(address);\n  } else if (address.empty()) {\n    sock_addr.setFromLocalPort(port);\n  } else {\n    sock_addr.setFromHostPort(address, port);\n  }\n  m_socketConfig.bindAddress = sock_addr;\n  m_socketConfig.acceptBacklog = RuntimeOption::ServerBacklog;\n  std::chrono::seconds timeout;\n  if (RuntimeOption::ConnectionTimeoutSeconds >= 0) {\n    timeout = std::chrono::seconds(RuntimeOption::ConnectionTimeoutSeconds);\n  } else {\n    timeout = std::chrono::seconds(120);\n  }\n  m_socketConfig.connectionIdleTimeout = timeout;\n}", "target": 1}
{"code": "defbackend_bind( Slapi_PBlock *pb )\n{\n    int\t\t\trc;\n    ber_tag_t\t\tmethod;\n    struct berval\t*cred;\n    LDAPDebug( LDAP_DEBUG_TRACE, \"defbackend_bind\\n\", 0, 0, 0 );\n    slapi_pblock_get( pb, SLAPI_BIND_METHOD, &method );\n    slapi_pblock_get( pb, SLAPI_BIND_CREDENTIALS, &cred );\n    if ( method == LDAP_AUTH_SIMPLE && cred->bv_len == 0 ) {\n\tslapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsAnonymousBinds);\n\trc = SLAPI_BIND_ANONYMOUS;\n    } else {\n\tsend_nobackend_ldap_result( pb );\n\trc = SLAPI_BIND_FAIL;\n    }\n    return( rc );\n}", "target": 1}
{"code": "_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}", "target": 1}
{"code": "static int openssl_static_locks_install(void)\n{\n    int result;\n    if (openssl_locks != NULL)\n    {\n        LogInfo(\"Locks already initialized\");\n        result = MU_FAILURE;\n    }\n    else\n    {\n        openssl_locks = malloc(CRYPTO_num_locks() * sizeof(LOCK_HANDLE));\n        if (openssl_locks == NULL)\n        {\n            LogError(\"Failed to allocate locks\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            int i;\n            for (i = 0; i < CRYPTO_num_locks(); i++)\n            {\n                openssl_locks[i] = Lock_Init();\n                if (openssl_locks[i] == NULL)\n                {\n                    LogError(\"Failed to allocate lock %d\", i);\n                    break;\n                }\n            }\n            if (i != CRYPTO_num_locks())\n            {\n                int j;\n                for (j = 0; j < i; j++)\n                {\n                    Lock_Deinit(openssl_locks[j]);\n                }\n                result = MU_FAILURE;\n            }\n            else\n            {\n                CRYPTO_set_locking_callback(openssl_static_locks_lock_unlock_cb);\n                result = 0;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "void freeClient(redisClient *c) {\n    listNode *ln;\n    sdsfree(c->querybuf);\n    c->querybuf = NULL;\n    if (c->flags & REDIS_BLOCKED)\n        unblockClientWaitingData(c);\n    unwatchAllKeys(c);\n    listRelease(c->watched_keys);\n    pubsubUnsubscribeAllChannels(c,0);\n    pubsubUnsubscribeAllPatterns(c,0);\n    dictRelease(c->pubsub_channels);\n    listRelease(c->pubsub_patterns);\n    aeDeleteFileEvent(server.el,c->fd,AE_READABLE);\n    aeDeleteFileEvent(server.el,c->fd,AE_WRITABLE);\n    listRelease(c->reply);\n    freeClientArgv(c);\n    close(c->fd);\n    ln = listSearchKey(server.clients,c);\n    redisAssert(ln != NULL);\n    listDelNode(server.clients,ln);\n    if (c->flags & REDIS_IO_WAIT) {\n        redisAssert(server.vm_enabled);\n        if (listLength(c->io_keys) == 0) {\n            ln = listSearchKey(server.io_ready_clients,c);\n            redisAssert(ln != NULL);\n            listDelNode(server.io_ready_clients,ln);\n        } else {\n            while (listLength(c->io_keys)) {\n                ln = listFirst(c->io_keys);\n                dontWaitForSwappedKey(c,ln->value);\n            }\n        }\n        server.vm_blocked_clients--;\n    }\n    listRelease(c->io_keys);\n    if (c->flags & REDIS_SLAVE) {\n        if (c->replstate == REDIS_REPL_SEND_BULK && c->repldbfd != -1)\n            close(c->repldbfd);\n        list *l = (c->flags & REDIS_MONITOR) ? server.monitors : server.slaves;\n        ln = listSearchKey(l,c);\n        redisAssert(ln != NULL);\n        listDelNode(l,ln);\n    }\n    if (c->flags & REDIS_MASTER) {\n        server.master = NULL;\n        server.replstate = REDIS_REPL_CONNECT;\n        while (listLength(server.slaves)) {\n            ln = listFirst(server.slaves);\n            freeClient((redisClient*)ln->value);\n        }\n    }\n    zfree(c->argv);\n    freeClientMultiState(c);\n    zfree(c);\n}", "target": 1}
{"code": "int ip_options_get(struct net *net, struct ip_options **optp,\n\t\t   unsigned char *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen)\n\t\tmemcpy(opt->__data, data, optlen);\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}", "target": 1}
{"code": "static void handle_put_accept(struct http_conn *conn,\n\t\t\t      const struct http_msg *msg,\n\t\t\t      struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"accept: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"accept: saving content(%zu): %b\\n\",\n\t\t  clen, mbuf_buf(mb), mbuf_get_left(mb));\n\tmbuf_strdup(mb, &ie->content.accept, clen);\n\thttp_reply(conn, 200, \"OK\", NULL);\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,\n\t\t    gfp_t gfp, struct dma_attrs *attrs)\n{\n\tpgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);\n\tvoid *memory;\n\tif (dma_alloc_from_coherent(dev, size, handle, &memory))\n\t\treturn memory;\n\treturn __dma_alloc(dev, size, handle, gfp, prot, false,\n\t\t\t   __builtin_return_address(0));\n}", "target": 1}
{"code": "static long adpt_unlocked_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tstruct inode *inode;\n\tlong ret;\n\tinode = file_inode(file);\n\tmutex_lock(&adpt_mutex);\n\tret = adpt_ioctl(inode, file, cmd, arg);\n\tmutex_unlock(&adpt_mutex);\n\treturn ret;\n}", "target": 1}
{"code": "static inline int pfkey_mode_to_xfrm(int mode)\n{\n\tswitch(mode) {\n\tcase IPSEC_MODE_ANY:\t\n\tcase IPSEC_MODE_TRANSPORT:\n\t\treturn XFRM_MODE_TRANSPORT;\n\tcase IPSEC_MODE_TUNNEL:\n\t\treturn XFRM_MODE_TUNNEL;\n\tcase IPSEC_MODE_BEET:\n\t\treturn XFRM_MODE_BEET;\n\tdefault:\n\t\treturn -1;\n\t}\n}", "target": 0}
{"code": "static void ossl_disassociate_connection(struct Curl_easy *data,\n                                         int sockindex)\n{\n  struct connectdata *conn = data->conn;\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  struct ssl_backend_data *backend = connssl->backend;\n  if(!backend->handle)\n    return;\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    bool isproxy = FALSE;\n    bool incache;\n    void *old_ssl_sessionid = NULL;\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      isproxy = SSL_get_ex_data(backend->handle, proxy_idx) ? TRUE : FALSE;\n      SSL_set_ex_data(backend->handle, data_idx, NULL);\n      SSL_set_ex_data(backend->handle, connectdata_idx, NULL);\n      SSL_set_ex_data(backend->handle, sockindex_idx, NULL);\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n    }\n    Curl_ssl_sessionid_lock(data);\n    incache = !(Curl_ssl_getsessionid(data, conn, isproxy,\n                                      &old_ssl_sessionid, NULL, sockindex));\n    if(incache)\n      Curl_ssl_delsessionid(data, old_ssl_sessionid);\n    Curl_ssl_sessionid_unlock(data);\n  }\n}", "target": 0}
{"code": "key_set(const char *key) {\n    int\t\tlen = (int)strlen(key);\n    int64_t\th = calc_hash(key, &len);\n    Slot\t*bucket = get_bucketp(h);\n    Slot\ts;\n    if (NULL != (s = (Slot)AGOO_MALLOC(sizeof(struct _slot)))) {\n\ts->hash = h;\n\ts->klen = len;\n\ts->key = key;\n\ts->next = *bucket;\n\t*bucket = s;\n    }\n}", "target": 1}
{"code": "static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\tint i;\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tfor (i = off; i < off + cnt - 1; i++)\n\t\tnew_data[i].seen = true;\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}", "target": 0}
{"code": "static void cfg_resp_handler(int err, const struct http_msg *msg,\n\t\t\t     struct mbuf *mb, struct json_object *jobj,\n\t\t\t     void *arg)\n{\n\tchar *json_str = NULL;\n\tstruct zapi_ice_server *servers;\n\tsize_t nservers = 0;\n\tsize_t i;\n\tre_printf(\"config ready! err=%d\\n\");\n\tif (err == ECONNABORTED)\n\t\tgoto out;\n\tif (!err && jobj) {\n\t\terr = jzon_encode(&json_str, jobj);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\tre_printf(\"CONFIG: %s\\n\", json_str);\n\tconfig_update(g_config, err, json_str, str_len(json_str));\n\tmem_deref(json_str);\n\tservers = config_get_iceservers(g_config, &nservers);\n\tre_printf(\"Probing: %d servers\\n\", nservers);\n\tfor (i = 0; i < nservers; ++i) {\n\t\tstruct zapi_ice_server *turn = &servers[i];\n\t\tstruct stun_uri uri;\n\t\terr = stun_uri_decode(&uri, turn->url);\n\t\tif (err)\n\t\t\terr = turn_dns_lookup(turn, &uri);\n\t\telse {\n\t\t\tstart_netprobe(&uri.addr, uri.proto, uri.secure,\n\t\t\t\t       turn->username, turn->credential);\n\t\t}\n\t}\n out:\n\tif (err)\n\t\terror(\"config request failed: %m\\n\", err);\n}", "target": 0}
{"code": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        value += (1 << zeroes) - 1;\n    }\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n    *write_to = value;\n    return 0;\n}", "target": 1}
{"code": "R_API int r_socket_read(RSocket *s, unsigned char *buf, int len) {\n\tif (!s) {\n\t\treturn -1;\n\t}\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\tif (s->bio) {\n\t\t\treturn BIO_read (s->bio, buf, len);\n\t\t}\n\t\treturn SSL_read (s->sfd, buf, len);\n\t}\n#endif\n#if __WINDOWS__\nrep:\n\t{\n\tint ret = recv (s->fd, (void *)buf, len, 0);\n\tif (ret == -1) {\n\t\tgoto rep;\n\t}\n\treturn ret;\n\t}\n#else\n\tint r = recv (s->fd, buf, len, 0);\n\tD { eprintf (\"READ \"); int i; for (i = 0; i<len; i++) { eprintf (\"%02x \", buf[i]); } eprintf (\"\\n\"); }\n\treturn r;\n#endif\n}", "target": 1}
{"code": "int main(int argc, char *argv[])\n{\n\tchar *procspath;\n\tsize_t len;\n\tif (geteuid() != 0) {\n\t\tfprintf(stderr, \"Run me as root\\n\");\n\t\texit(1);\n\t}\n\tif (argc != 2)  {\n\t\tfprintf(stderr, \"Usage: %s [lxcfs_test_cgroup_path]\\n\", argv[0]);\n\t\texit(1);\n\t}\n\tlen = strlen(argv[1]) + strlen(\"/cgroup.procs\") + 1;\n\tprocspath = alloca(len);\n\tsnprintf(procspath, len, \"%s/cgroup.procs\", argv[1]);\n\ttest_open(argv[1]);\n\ttest_open(procspath);\n\ttest_stat(argv[1]);\n\ttest_stat(procspath);\n\ttest_access(argv[1]);\n\ttest_access(procspath);\n\ttest_bind(argv[1]);\n\ttest_bind(procspath);\n\ttest_bindmount(argv[1]);\n\ttest_bindmount(procspath);\n\ttest_truncate(argv[1]);\n\ttest_truncate(procspath);\n\ttest_chdir(argv[1]);\n\ttest_chdir(procspath);\n\ttest_rename(argv[1]);\n\ttest_rename(procspath);\n\ttest_mkdir(argv[1]);\n\ttest_mkdir(procspath);\n\ttest_rmdir(argv[1]);\n\ttest_rmdir(procspath);\n\ttest_creat(argv[1]);\n\ttest_creat(procspath);\n\ttest_link(argv[1]);\n\ttest_link(procspath);\n\ttest_unlink(argv[1]);\n\ttest_unlink(procspath);\n\ttest_symlink(argv[1]);\n\ttest_symlink(procspath);\n\ttest_readlink(argv[1]);\n\ttest_readlink(procspath);\n\ttest_chmod(argv[1]);\n\ttest_chmod(procspath);\n\ttest_chown(argv[1]);\n\ttest_chown(procspath);\n\ttest_lchown(argv[1]);\n\ttest_lchown(procspath);\n\ttest_mknod(argv[1]);\n\ttest_mknod(procspath);\n\ttest_chroot(argv[1]);\n\ttest_chroot(procspath);\n\ttest_xattrs(argv[1]);\n\ttest_xattrs(procspath);\n\ttest_utimes(argv[1]);\n\ttest_utimes(procspath);\n\ttest_openat(argv[1]);\n\tprintf(\"All tests passed\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "static int jpeg_size(unsigned char* data, unsigned int data_size,\n                     int *width, int *height)\n{\n    int i = 0;\n    if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&\n            data[i+2] == 0xFF && data[i+3] == 0xE0) {\n        i += 4;\n        if(i + 6 < data_size &&\n                data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&\n                data[i+5] == 'F' && data[i+6] == 0x00) {\n            unsigned short block_length = data[i] * 256 + data[i+1];\n            while(i<data_size) {\n                i+=block_length;\n                if((i + 1) >= data_size)\n                    return -1;\n                if(data[i] != 0xFF)\n                    return -1;\n                if(data[i+1] == 0xC0) {\n                    *height = data[i+5]*256 + data[i+6];\n                    *width = data[i+7]*256 + data[i+8];\n                    return 0;\n                }\n                i+=2;\n                block_length = data[i] * 256 + data[i+1];\n            }\n        }\n    }\n    return -1;\n}", "target": 1}
{"code": "bool isKeyInvalid(const String &key) {\n  return key.find('\\0') != -1;\n}", "target": 0}
{"code": "static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tstruct urb *urb;\n\tu32 val32;\n\tint ret;\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tusb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt,\n\t\t\t priv->int_buf, USB_INTR_CONTENT_LENGTH,\n\t\t\t rtl8xxxu_int_complete, priv, 1);\n\tusb_anchor_urb(urb, &priv->int_anchor);\n\tret = usb_submit_urb(urb, GFP_KERNEL);\n\tif (ret) {\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_urb(urb);\n\t\tgoto error;\n\t}\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HIMR);\n\tval32 |= USB_HIMR_CPWM;\n\trtl8xxxu_write32(priv, REG_USB_HIMR, val32);\nerror:\n\treturn ret;\n}", "target": 0}
{"code": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "public char * shell_quoten(constant char *s, size_t slen)\n{\n\tconstant char *p;\n\tchar *np;\n\tchar *newstr;\n\tsize_t len;\n\tconstant char *esc = get_meta_escape();\n\tsize_t esclen = strlen(esc);\n\tlbool use_quotes = FALSE;\n\tlbool have_quotes = FALSE;\n\tlen = 1; \n\tfor (p = s;  p < s + slen;  p++)\n\t{\n\t\tlen++;\n\t\tif (*p == openquote || *p == closequote)\n\t\t\thave_quotes = TRUE;\n\t\tif (metachar(*p))\n\t\t{\n\t\t\tif (esclen == 0)\n\t\t\t{\n\t\t\t\tuse_quotes = TRUE;\n\t\t\t} else\n\t\t\t{\n\t\t\t\tlen += esclen;\n\t\t\t}\n\t\t}\n\t}\n\tif (use_quotes)\n\t{\n\t\tif (have_quotes)\n\t\t\treturn (NULL);\n\t\tlen = slen + 3;\n\t}\n\tnewstr = np = (char *) ecalloc(len, sizeof(char));\n\tif (use_quotes)\n\t{\n\t\tSNPRINTF4(newstr, len, \"%c%.*s%c\", openquote, (int) slen, s, closequote);\n\t} else\n\t{\n\t\tconstant char *es = s + slen;\n\t\twhile (s < es)\n\t\t{\n\t\t\tif (metachar(*s))\n\t\t\t{\n\t\t\t\tstrcpy(np, esc);\n\t\t\t\tnp += esclen;\n\t\t\t}\n\t\t\t*np++ = *s++;\n\t\t}\n\t\t*np = '\\0';\n\t}\n\treturn (newstr);\n}", "target": 1}
{"code": "acpi_os_install_interrupt_handler(u32 gsi, acpi_osd_handler handler,\n\t\t\t\t  void *context)\n{\n\tunsigned int irq;\n\tacpi_irq_stats_init();\n\tif (gsi != acpi_gbl_FADT.sci_interrupt)\n\t\treturn AE_BAD_PARAMETER;\n\tif (acpi_irq_handler)\n\t\treturn AE_ALREADY_ACQUIRED;\n\tif (acpi_gsi_to_irq(gsi, &irq) < 0) {\n\t\tprintk(KERN_ERR PREFIX \"SCI (ACPI GSI %d) not registered\\n\",\n\t\t       gsi);\n\t\treturn AE_OK;\n\t}\n\tacpi_irq_handler = handler;\n\tacpi_irq_context = context;\n\tif (request_irq(irq, acpi_irq, IRQF_SHARED, \"acpi\", acpi_irq)) {\n\t\tprintk(KERN_ERR PREFIX \"SCI (IRQ%d) allocation failed\\n\", irq);\n\t\tacpi_irq_handler = NULL;\n\t\treturn AE_NOT_ACQUIRED;\n\t}\n\tacpi_sci_irq = irq;\n\treturn AE_OK;\n}", "target": 0}
{"code": "MagickExport MagickBooleanType HeapOverflowSanityCheck(const size_t count,\n  const size_t quantum)\n{\n  size_t\n    size;\n  size=count*quantum;\n  if ((count == 0) || (quantum != (size/count)))\n    {\n      errno=ENOMEM;\n      return(MagickTrue);\n    }\n  return(MagickFalse);\n}", "target": 0}
{"code": "static void snd_timer_user_tinterrupt(struct snd_timer_instance *timeri,\n\t\t\t\t      unsigned long resolution,\n\t\t\t\t      unsigned long ticks)\n{\n\tstruct snd_timer_user *tu = timeri->callback_data;\n\tstruct snd_timer_tread *r, r1;\n\tstruct timespec tstamp;\n\tint prev, append = 0;\n\tmemset(&tstamp, 0, sizeof(tstamp));\n\tspin_lock(&tu->qlock);\n\tif ((tu->filter & ((1 << SNDRV_TIMER_EVENT_RESOLUTION) |\n\t\t\t   (1 << SNDRV_TIMER_EVENT_TICK))) == 0) {\n\t\tspin_unlock(&tu->qlock);\n\t\treturn;\n\t}\n\tif (tu->last_resolution != resolution || ticks > 0) {\n\t\tif (timer_tstamp_monotonic)\n\t\t\tktime_get_ts(&tstamp);\n\t\telse\n\t\t\tgetnstimeofday(&tstamp);\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_RESOLUTION)) &&\n\t    tu->last_resolution != resolution) {\n\t\tmemset(&r1, 0, sizeof(r1));\n\t\tr1.event = SNDRV_TIMER_EVENT_RESOLUTION;\n\t\tr1.tstamp = tstamp;\n\t\tr1.val = resolution;\n\t\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\t\ttu->last_resolution = resolution;\n\t\tappend++;\n\t}\n\tif ((tu->filter & (1 << SNDRV_TIMER_EVENT_TICK)) == 0)\n\t\tgoto __wake;\n\tif (ticks == 0)\n\t\tgoto __wake;\n\tif (tu->qused > 0) {\n\t\tprev = tu->qtail == 0 ? tu->queue_size - 1 : tu->qtail - 1;\n\t\tr = &tu->tqueue[prev];\n\t\tif (r->event == SNDRV_TIMER_EVENT_TICK) {\n\t\t\tr->tstamp = tstamp;\n\t\t\tr->val += ticks;\n\t\t\tappend++;\n\t\t\tgoto __wake;\n\t\t}\n\t}\n\tr1.event = SNDRV_TIMER_EVENT_TICK;\n\tr1.tstamp = tstamp;\n\tr1.val = ticks;\n\tsnd_timer_user_append_to_tqueue(tu, &r1);\n\tappend++;\n      __wake:\n\tspin_unlock(&tu->qlock);\n\tif (append == 0)\n\t\treturn;\n\tkill_fasync(&tu->fasync, SIGIO, POLL_IN);\n\twake_up(&tu->qchange_sleep);\n}", "target": 0}
{"code": "kg_unseal_iov(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int *conf_state,\n              gss_qop_t *qop_state,\n              gss_iov_buffer_desc *iov,\n              int iov_count,\n              int toktype)\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 code;\n    ctx = (krb5_gss_ctx_id_rec *)context_handle;\n    if (!ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return GSS_S_NO_CONTEXT;\n    }\n    if (kg_locate_iov(iov, iov_count, GSS_IOV_BUFFER_TYPE_STREAM) != NULL) {\n        code = kg_unseal_stream_iov(minor_status, ctx, conf_state, qop_state,\n                                    iov, iov_count, toktype);\n    } else {\n        code = kg_unseal_iov_token(minor_status, ctx, conf_state, qop_state,\n                                   iov, iov_count, toktype);\n    }\n    return code;\n}", "target": 1}
{"code": "static void umocktypes_free_FLOW_HANDLE(FLOW_HANDLE* value)\n{\n    (void)value;\n}", "target": 0}
{"code": "bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey)\n{\n    {\n        LOCK2(cs_main, cs_wallet);\n        printf(\"CommitTransaction:\\n%s\", wtxNew.ToString().c_str());\n        {\n            CWalletDB* pwalletdb = fFileBacked ? new CWalletDB(strWalletFile,\"r\") : NULL;\n            reservekey.KeepKey();\n            AddToWallet(wtxNew);\n            set<CWalletTx*> setCoins;\n            BOOST_FOREACH(const CTxIn& txin, wtxNew.vin)\n            {\n                CWalletTx &coin = mapWallet[txin.prevout.hash];\n                coin.BindWallet(this);\n                coin.MarkSpent(txin.prevout.n);\n                coin.WriteToDisk();\n                NotifyTransactionChanged(this, coin.GetHash(), CT_UPDATED);\n            }\n            if (fFileBacked)\n                delete pwalletdb;\n        }\n        mapRequestCount[wtxNew.GetHash()] = 0;\n        if (!wtxNew.AcceptToMemoryPool())\n        {\n            printf(\"CommitTransaction() : Error: Transaction not valid\");\n            return false;\n        }\n        wtxNew.RelayWalletTransaction();\n    }\n    return true;\n}", "target": 1}
{"code": "static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,\n\t\t\tstruct file *file, unsigned int cmd, unsigned long arg)\n{\n\tint unit, err = -EFAULT;\n\tstruct ppp *ppp;\n\tstruct channel *chan;\n\tstruct ppp_net *pn;\n\tint __user *p = (int __user *)arg;\n\tmutex_lock(&ppp_mutex);\n\tswitch (cmd) {\n\tcase PPPIOCNEWUNIT:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\tppp = ppp_create_interface(net, unit, file, &err);\n\t\tif (!ppp)\n\t\t\tbreak;\n\t\tfile->private_data = &ppp->file;\n\t\terr = -EFAULT;\n\t\tif (put_user(ppp->file.index, p))\n\t\t\tbreak;\n\t\terr = 0;\n\t\tbreak;\n\tcase PPPIOCATTACH:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = -ENXIO;\n\t\tpn = ppp_pernet(net);\n\t\tmutex_lock(&pn->all_ppp_mutex);\n\t\tppp = ppp_find_unit(pn, unit);\n\t\tif (ppp) {\n\t\t\tatomic_inc(&ppp->file.refcnt);\n\t\t\tfile->private_data = &ppp->file;\n\t\t\terr = 0;\n\t\t}\n\t\tmutex_unlock(&pn->all_ppp_mutex);\n\t\tbreak;\n\tcase PPPIOCATTCHAN:\n\t\tif (get_user(unit, p))\n\t\t\tbreak;\n\t\terr = -ENXIO;\n\t\tpn = ppp_pernet(net);\n\t\tspin_lock_bh(&pn->all_channels_lock);\n\t\tchan = ppp_find_channel(pn, unit);\n\t\tif (chan) {\n\t\t\tatomic_inc(&chan->file.refcnt);\n\t\t\tfile->private_data = &chan->file;\n\t\t\terr = 0;\n\t\t}\n\t\tspin_unlock_bh(&pn->all_channels_lock);\n\t\tbreak;\n\tdefault:\n\t\terr = -ENOTTY;\n\t}\n\tmutex_unlock(&ppp_mutex);\n\treturn err;\n}", "target": 0}
{"code": "format_DEC_TTL(const struct ofpact_cnt_ids *a,\n               const struct ofpact_format_params *fp)\n{\n    size_t i;\n    ds_put_format(fp->s, \"%sdec_ttl%s\", colors.paren, colors.end);\n    if (a->ofpact.raw == NXAST_RAW_DEC_TTL_CNT_IDS) {\n        ds_put_format(fp->s, \"%s(%s\", colors.paren, colors.end);\n        for (i = 0; i < a->n_controllers; i++) {\n            if (i) {\n                ds_put_cstr(fp->s, \",\");\n            }\n            ds_put_format(fp->s, \"%\"PRIu16, a->cnt_ids[i]);\n        }\n        ds_put_format(fp->s, \"%s)%s\", colors.paren, colors.end);\n    }\n}", "target": 0}
{"code": "static void addrconf_ip6_tnl_config(struct net_device *dev)\n{\n\tstruct inet6_dev *idev;\n\tASSERT_RTNL();\n\tidev = addrconf_add_dev(dev);\n\tif (IS_ERR(idev)) {\n\t\tpr_debug(\"init ip6-ip6: add_dev failed\\n\");\n\t\treturn;\n\t}\n\tip6_tnl_add_linklocal(idev);\n}", "target": 0}
{"code": "putstr(int d)\n{\n    addbufspc(1);\n    pputc(d);\n    return 0;\n}", "target": 0}
{"code": "pci_emul_cmdsts_write(struct pci_vdev *dev, int coff, uint32_t new, int bytes)\n{\n\tint i, rshift;\n\tuint32_t cmd, cmd2, changed, old, readonly;\n\tcmd = pci_get_cfgdata16(dev, PCIR_COMMAND);\t\n\trshift = (coff & 0x3) * 8;\n\treadonly = 0xFFFFF880 >> rshift;\n\told = CFGREAD(dev, coff, bytes);\n\tnew &= ~readonly;\n\tnew |= (old & readonly);\n\tCFGWRITE(dev, coff, new, bytes);\t\t\n\tcmd2 = pci_get_cfgdata16(dev, PCIR_COMMAND);\t\n\tchanged = cmd ^ cmd2;\n\tfor (i = 0; i <= PCI_BARMAX; i++) {\n\t\tswitch (dev->bar[i].type) {\n\t\tcase PCIBAR_NONE:\n\t\tcase PCIBAR_MEMHI64:\n\t\t\tbreak;\n\t\tcase PCIBAR_IO:\n\t\t\tif (changed & PCIM_CMD_PORTEN) {\n\t\t\t\tif (porten(dev))\n\t\t\t\t\tregister_bar(dev, i);\n\t\t\t\telse\n\t\t\t\t\tunregister_bar(dev, i);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCIBAR_MEM32:\n\t\tcase PCIBAR_MEM64:\n\t\t\tif (changed & PCIM_CMD_MEMEN) {\n\t\t\t\tif (memen(dev))\n\t\t\t\t\tregister_bar(dev, i);\n\t\t\t\telse\n\t\t\t\t\tunregister_bar(dev, i);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(0);\n\t\t}\n\t}\n\tpci_lintr_update(dev);\n}", "target": 1}
{"code": "static void mpls_dev_sysctl_unregister(struct net_device *dev,\n\t\t\t\t       struct mpls_dev *mdev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tif (!mdev->sysctl)\n\t\treturn;\n\ttable = mdev->sysctl->ctl_table_arg;\n\tunregister_net_sysctl_table(mdev->sysctl);\n\tkfree(table);\n\tmpls_netconf_notify_devconf(net, RTM_DELNETCONF, 0, mdev);\n}", "target": 0}
{"code": "ppmd_read(void* p) {\n\tstruct archive_read *a = ((IByteIn*)p)->a;\n\tstruct zip *zip = (struct zip*) a->format->data;\n\tconst uint8_t* data = __archive_read_ahead(a, 1, NULL);\n\t__archive_read_consume(a, 1);\n\t++zip->zipx_ppmd_read_compressed;\n\treturn data[0];\n}", "target": 0}
{"code": "sctp_chunk_length_valid(struct sctp_chunk *chunk,\n\t\t\t   __u16 required_length)\n{\n\t__u16 chunk_length = ntohs(chunk->chunk_hdr->length);\n\tif (unlikely(chunk->pdiscard))\n\t\treturn 0;\n\tif (unlikely(chunk_length < required_length))\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "static void sanitize_dead_code(struct bpf_verifier_env *env)\n{\n\tstruct bpf_insn_aux_data *aux_data = env->insn_aux_data;\n\tstruct bpf_insn nop = BPF_MOV64_REG(BPF_REG_0, BPF_REG_0);\n\tstruct bpf_insn *insn = env->prog->insnsi;\n\tconst int insn_cnt = env->prog->len;\n\tint i;\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (aux_data[i].seen)\n\t\t\tcontinue;\n\t\tmemcpy(insn + i, &nop, sizeof(nop));\n\t}\n}", "target": 0}
{"code": "void test_chown(const char *path)\n{\n\tif (chown(path, 0, 0) == 0) {\n\t\tfprintf(stderr, \"leak at chown of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chown of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "inline uint char_val(char X)\n{\n  return (uint) (X >= '0' && X <= '9' ? X-'0' :\n\t\t X >= 'A' && X <= 'Z' ? X-'A'+10 :\n\t\t X-'a'+10);\n}", "target": 0}
{"code": "LookupModMask(struct xkb_context *ctx, const void *priv, xkb_atom_t field,\n              enum expr_value_type type, xkb_mod_mask_t *val_rtrn)\n{\n    const char *str;\n    xkb_mod_index_t ndx;\n    const LookupModMaskPriv *arg = priv;\n    const struct xkb_mod_set *mods = arg->mods;\n    enum mod_type mod_type = arg->mod_type;\n    if (type != EXPR_TYPE_INT)\n        return false;\n    str = xkb_atom_text(ctx, field);\n    if (!str)\n        return false;\n    if (istreq(str, \"all\")) {\n        *val_rtrn  = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    if (istreq(str, \"none\")) {\n        *val_rtrn = 0;\n        return true;\n    }\n    ndx = XkbModNameToIndex(mods, field, mod_type);\n    if (ndx == XKB_MOD_INVALID)\n        return false;\n    *val_rtrn = (1u << ndx);\n    return true;\n}", "target": 0}
{"code": "uint WavInFile::getSampleRate() const\n{\n    return header.format.sample_rate;\n}", "target": 0}
{"code": "bool jas_image_cmpt_domains_same(jas_image_t *image)\n{\n\tint cmptno;\n\tjas_image_cmpt_t *cmpt;\n\tjas_image_cmpt_t *cmpt0;\n\tcmpt0 = image->cmpts_[0];\n\tfor (cmptno = 1; cmptno < image->numcmpts_; ++cmptno) {\n\t\tcmpt = image->cmpts_[cmptno];\n\t\tif (cmpt->tlx_ != cmpt0->tlx_ || cmpt->tly_ != cmpt0->tly_ ||\n\t\t  cmpt->hstep_ != cmpt0->hstep_ || cmpt->vstep_ != cmpt0->vstep_ ||\n\t\t  cmpt->width_ != cmpt0->width_ || cmpt->height_ != cmpt0->height_) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "hb_set_clear (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->clear ();\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArraySliceCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n   if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart;\n    Jsi_Obj *nobj, *obj;\n    Jsi_Value *start = Jsi_ValueArrayIndex(interp, args, 0),\n        *end = Jsi_ValueArrayIndex(interp, args, 1);\n    if (!start) {\n        goto bail;\n    }\n    obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n    if (Jsi_GetNumberFromValue(interp,start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto done;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (n == 0) {\ndone:\n        Jsi_ValueMakeArrayObject(interp, ret, Jsi_ObjNewType(interp, JSI_OT_ARRAY));\n        return JSI_OK;\n    }\n    Jsi_Number nend;\n    iend = n-1;\n    if (end && Jsi_GetNumberFromValue(interp,end, &nend) == JSI_OK) {\n        iend = (int) nend;\n        if (iend >= n)\n            iend = n;\n        if (iend < 0)\n            iend = (n+iend);\n        if (iend<0)\n            goto bail;\n    }\n    nsiz = iend-istart+1;\n    if (nsiz<=0)\n        goto done;\n    Jsi_ObjListifyArray(interp, obj);\n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz) <= 0) {\n        rc = Jsi_LogError(\"index too large: %d\", nsiz);\n        goto bail;\n    }\n    int i, m;\n    for (m = 0, i = istart; i <= iend; i++, m++)\n    {\n        if (!obj->arr[i]) continue;\n        nobj->arr[m] = NULL;\n        Jsi_ValueDup2(interp, nobj->arr+m, obj->arr[i]);\n    }\n    Jsi_ObjSetLength(interp, nobj, nsiz);\n    Jsi_ValueMakeArrayObject(interp, ret, nobj);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeNull(interp, ret);\n    return rc;\n}", "target": 1}
{"code": "SPL_METHOD(SplFileObject, fgets)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} ", "target": 0}
{"code": "static int atusb_get_and_show_build(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tchar build[ATUSB_BUILD_SIZE + 1];\n\tint ret;\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuild, ATUSB_BUILD_SIZE, 1000);\n\tif (ret >= 0) {\n\t\tbuild[ret] = 0;\n\t\tdev_info(&usb_dev->dev, \"Firmware: build %s\\n\", build);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "bool DevToolsDownloadManagerDelegate::ShouldOpenDownload(\n    content::DownloadItem* item,\n    const content::DownloadOpenDelayedCallback& callback) {\n  DevToolsDownloadManagerHelper* download_helper =\n      DevToolsDownloadManagerHelper::FromWebContents(item->GetWebContents());\n  if (download_helper)\n    return true;\n  if (proxy_download_delegate_)\n    return proxy_download_delegate_->ShouldOpenDownload(item, callback);\n  return false;\n}", "target": 0}
{"code": "DwaCompressor::uncompress\n    (const char *inPtr,\n     int inSize,\n     int minY,\n     const char *&outPtr)\n{\n    return uncompress (inPtr,\n                       inSize,\n                       IMATH_NAMESPACE::Box2i (IMATH_NAMESPACE::V2i (_min[0], minY),\n                       IMATH_NAMESPACE::V2i (_max[0], minY + numScanLines() - 1)),\n                       outPtr);\n}", "target": 0}
{"code": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}", "target": 1}
{"code": "    bool Image::isShortType(uint16_t type) {\n         return type == Exiv2::unsignedShort\n             || type == Exiv2::signedShort\n             ;\n    }", "target": 0}
{"code": "SWFShape_addGradientFillStyle(SWFShape shape, SWFGradient gradient, byte flags)\n{\n\tSWFFillStyle fill = newSWFGradientFillStyle(gradient, flags);\n\tif(addFillStyle(shape, fill) < 0)\n\t{\n\t\tdestroySWFFillStyle(fill);\n\t\treturn NULL;\n\t}\n\treturn fill;\t\t\n}", "target": 0}
{"code": "wchar* ConvertPath(const wchar *SrcPath,wchar *DestPath,size_t DestSize)\n{\n  const wchar *DestPtr=SrcPath;\n  for (const wchar *s=DestPtr;*s!=0;s++)\n    if (IsPathDiv(s[0]) && s[1]=='.' && s[2]=='.' && IsPathDiv(s[3]))\n      DestPtr=s+4;\n  while (*DestPtr!=0)\n  {\n    const wchar *s=DestPtr;\n    if (s[0]!=0 && IsDriveDiv(s[1]))\n      s+=2;\n    if (s[0]=='\\\\' && s[1]=='\\\\')\n    {\n      const wchar *Slash=wcschr(s+2,'\\\\');\n      if (Slash!=NULL && (Slash=wcschr(Slash+1,'\\\\'))!=NULL)\n        s=Slash+1;\n    }\n    for (const wchar *t=s;*t!=0;t++)\n      if (IsPathDiv(*t))\n        s=t+1;\n      else\n        if (*t!='.')\n          break;\n    if (s==DestPtr)\n      break;\n    DestPtr=s;\n  }\n  if (DestPtr[0]=='.' && DestPtr[1]=='.' && DestPtr[2]==0)\n    DestPtr+=2;\n  if (DestPath!=NULL)\n  {\n    wchar TmpStr[NM];\n    wcsncpyz(TmpStr,DestPtr,ASIZE(TmpStr));\n    wcsncpyz(DestPath,TmpStr,DestSize);\n  }\n  return (wchar *)DestPtr;\n}", "target": 1}
{"code": "static void read_version(struct pbap_data *pbap, GObexApparam *apparam)\n{\n\tconst guint8 *data;\n\tuint8_t value[16];\n\tgsize len;\n\tif (!(pbap->supported_features & FOLDER_VERSION_FEATURE))\n\t\treturn;\n\tif (!g_obex_apparam_get_bytes(apparam, PRIMARY_COUNTER_TAG, &data,\n\t\t\t\t\t\t\t\t&len)) {\n\t\tlen = sizeof(value);\n\t\tmemset(value, 0, len);\n\t\tdata = value;\n\t}\n\tif (memcmp(pbap->primary, data, len)) {\n\t\tmemcpy(pbap->primary, data, len);\n\t\tg_dbus_emit_property_changed(conn,\n\t\t\t\t\tobc_session_get_path(pbap->session),\n\t\t\t\t\tPBAP_INTERFACE, \"PrimaryCounter\");\n\t}\n\tif (!g_obex_apparam_get_bytes(apparam, SECONDARY_COUNTER_TAG, &data,\n\t\t\t\t\t\t\t\t&len)) {\n\t\tlen = sizeof(value);\n\t\tmemset(value, 0, len);\n\t\tdata = value;\n\t}\n\tif (memcmp(pbap->secondary, data, len)) {\n\t\tmemcpy(pbap->secondary, data, len);\n\t\tg_dbus_emit_property_changed(conn,\n\t\t\t\t\tobc_session_get_path(pbap->session),\n\t\t\t\t\tPBAP_INTERFACE, \"SecondaryCounter\");\n\t}\n}", "target": 1}
{"code": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;\n\tpsf->fileoffset = psf_ftell (psf) ;\n\tif (! close_desc)\n\t\tpsf->file.do_not_close_descriptor = SF_TRUE ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "void infra_wait_limit_inc(struct infra_cache* infra, struct comm_reply* rep,\n\ttime_t timenow, struct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 1);\n\tif(entry) {\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\td->mesh_wait++;\n\t\tlock_rw_unlock(&entry->lock);\n\t\treturn;\n\t}\n\tinfra_ip_create_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, timenow, 1);\n}", "target": 0}
{"code": "gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}", "target": 0}
{"code": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}", "target": 1}
{"code": "header_put_marker (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "static void smp_task_done(struct sas_task *task)\n{\n\tif (!del_timer(&task->slow_task->timer))\n\t\treturn;\n\tcomplete(&task->slow_task->completion);\n}", "target": 1}
{"code": "static int send_header(void *data, const char *key, const char *val)\n{\n    ap_fputstrs(((hdr_ptr*)data)->f, ((hdr_ptr*)data)->bb,\n                key, \": \", val, CRLF, NULL);\n    return 1;\n}", "target": 0}
{"code": "SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {\n  auto& self = instance();\n  WriteLock lock(self.create_mutex_);\n  if (self.db_ == nullptr) {\n    openOptimized(self.db_);\n    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));\n    attachVirtualTables(self.connection_);\n  }\n  if (primary) {\n    return self.connection_;\n  }\n  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);\n  if (!instance->isPrimary()) {\n    attachVirtualTables(instance);\n  }\n  return instance;\n}", "target": 0}
{"code": "int fscrypt_process_policy(struct inode *inode,\n\t\t\t\tconst struct fscrypt_policy *policy)\n{\n\tif (!inode_owner_or_capable(inode))\n\t\treturn -EACCES;\n\tif (policy->version != 0)\n\t\treturn -EINVAL;\n\tif (!inode_has_encryption_context(inode)) {\n\t\tif (!inode->i_sb->s_cop->empty_dir)\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (!inode->i_sb->s_cop->empty_dir(inode))\n\t\t\treturn -ENOTEMPTY;\n\t\treturn create_encryption_context_from_policy(inode, policy);\n\t}\n\tif (is_encryption_context_consistent_with_policy(inode, policy))\n\t\treturn 0;\n\tprintk(KERN_WARNING \"%s: Policy inconsistent with encryption context\\n\",\n\t       __func__);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "bool ReadDictionaryValue(const Message* m, PickleIterator* iter,\n                         DictionaryValue* value, int recursion) {\n  int size;\n  if (!ReadParam(m, iter, &size))\n    return false;\n  for (int i = 0; i < size; ++i) {\n    std::string key;\n    Value* subval;\n    if (!ReadParam(m, iter, &key) ||\n        !ReadValue(m, iter, &subval, recursion + 1))\n      return false;\n    value->SetWithoutPathExpansion(key, subval);\n  }\n  return true;\n}", "target": 0}
{"code": "deinit_pci(struct vmctx *ctx)\n{\n\tstruct pci_vdev_ops *ops;\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tstruct funcinfo *fi;\n\tint bus, slot, func;\n\tsize_t lowmem;\n\tstruct mem_range mr;\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI ECFG\";\n\tmr.base = PCI_EMUL_ECFG_BASE;\n\tmr.size = PCI_EMUL_ECFG_SIZE;\n\tunregister_mem(&mr);\n\tlowmem = vm_get_lowmem_size(ctx);\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI hole (32-bit)\";\n\tmr.base = lowmem;\n\tmr.size = (4ULL * 1024 * 1024 * 1024) - lowmem;\n\tunregister_mem_fallback(&mr);\n\tbzero(&mr, sizeof(struct mem_range));\n\tmr.name = \"PCI hole (64-bit)\";\n\tmr.base = PCI_EMUL_MEMBASE64;\n\tmr.size = PCI_EMUL_MEMLIMIT64 - PCI_EMUL_MEMBASE64;\n\tunregister_mem_fallback(&mr);\n\tfor (bus = 0; bus < MAXBUSES; bus++) {\n\t\tbi = pci_businfo[bus];\n\t\tif (bi == NULL)\n\t\t\tcontinue;\n\t\tfor (slot = 0; slot < MAXSLOTS; slot++) {\n\t\t\tsi = &bi->slotinfo[slot];\n\t\t\tfor (func = 0; func < MAXFUNCS; func++) {\n\t\t\t\tfi = &si->si_funcs[func];\n\t\t\t\tif (fi->fi_name == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tops = pci_emul_finddev(fi->fi_name);\n\t\t\t\tassert(ops != NULL);\n\t\t\t\tpr_notice(\"pci deinit %s\\n\", fi->fi_name);\n\t\t\t\tpci_emul_deinit(ctx, ops, bus, slot,\n\t\t\t\t    func, fi);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "unsigned long get_pfnblock_flags_mask(struct page *page, unsigned long pfn,\n\t\t\t\t\tunsigned long end_bitidx,\n\t\t\t\t\tunsigned long mask)\n{\n\treturn __get_pfnblock_flags_mask(page, pfn, end_bitidx, mask);\n}", "target": 0}
{"code": "static int _process_tokenize(mcp_parser_t *pr, const size_t max) {\n    const char *s = pr->request;\n    int len = pr->reqlen - 2;\n    if (len > PARSER_MAXLEN) {\n        len = PARSER_MAXLEN;\n    }\n    const char *end = s + len;\n    int curtoken = 0;\n    int state = 0;\n    while (s != end) {\n        switch (state) {\n            case 0:\n                if (*s != ' ') {\n                    pr->tokens[curtoken] = s - pr->request;\n                    if (++curtoken == max) {\n                        s++;\n                        state = 2;\n                        break;\n                    }\n                    state = 1;\n                }\n                s++;\n                break;\n            case 1:\n                if (*s != ' ') {\n                    s++;\n                } else {\n                    state = 0;\n                }\n                break;\n            case 2:\n                if (*s == ' ') {\n                    goto endloop;\n                }\n                s++;\n                break;\n        }\n    }\nendloop:\n    pr->tokens[curtoken] = s - pr->request;\n    pr->ntokens = curtoken;\n    P_DEBUG(\"%s: cur_tokens: %d\\n\", __func__, curtoken);\n    return 0;\n}", "target": 1}
{"code": "  void readErr(const AsyncSocketException& ex) noexcept override {\n    LOG(ERROR) << ex.what();\n  }", "target": 0}
{"code": "mainloop_destroy_trigger(crm_trigger_t * source)\n{\n    source->trigger = FALSE;\n    if (source->id > 0) {\n        g_source_remove(source->id);\n        source->id = 0;\n    }\n    return TRUE;\n}", "target": 0}
{"code": "int main_configure(char *arg1, char *arg2) {\n    int cmdline_status;\n    cmdline_status=options_cmdline(arg1, arg2);\n    if(cmdline_status) \n        return cmdline_status;\n    options_apply();\n    str_canary_init(); \n    log_open(SINK_SYSLOG);\n    if(bind_ports())\n        return 1;\n#ifdef HAVE_CHROOT\n    if(change_root())\n        return 1;\n#endif \n    if(drop_privileges(1))\n        return 1;\n    if(log_open(SINK_OUTFILE))\n        return 1;\n#ifndef USE_FORK\n    num_clients=0; \n#endif\n    log_flush(LOG_MODE_CONFIGURED);\n    return 0;\n}", "target": 1}
{"code": "void RenderView::didUpdateInspectorSetting(const WebString& key,\n                                           const WebString& value) {\n  Send(new ViewHostMsg_UpdateInspectorSetting(routing_id_,\n                                              key.utf8(),\n                                              value.utf8()));\n}", "target": 0}
{"code": "  add_authorized_client(const std::string &name, std::string &&cert) {\n    client_t &client = client_root;\n    named_cert_t named_cert;\n    named_cert.name = name;\n    named_cert.cert = std::move(cert);\n    named_cert.uuid = uuid_util::uuid_t::generate().string();\n    client.named_devices.emplace_back(named_cert);\n    if (!config::sunshine.flags[config::flag::FRESH_STATE]) {\n      save_state();\n    }\n  }", "target": 0}
{"code": "static void php_mcrypt_module_dtor(zend_rsrc_list_entry *rsrc TSRMLS_DC) \n{\n\tphp_mcrypt *pm = (php_mcrypt *) rsrc->ptr;\n\tif (pm) {\t\n\t\tmcrypt_generic_deinit(pm->td);\n\t\tmcrypt_module_close(pm->td);\n\t\tefree(pm);\n\t\tpm = NULL;\n\t}", "target": 1}
{"code": "ScopedDefaultGLContext::ScopedDefaultGLContext(GLES2DecoderImpl* decoder)\n    : decoder_(decoder) {\n  decoder_->default_context_->MakeCurrent();\n}", "target": 0}
{"code": "static int adis_update_scan_mode_burst(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tunsigned int burst_length;\n\tu8 *tx;\n\tburst_length = (indio_dev->num_channels - 1) * sizeof(u16);\n\tburst_length += adis->burst->extra_len;\n\tadis->xfer = kcalloc(2, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kzalloc(burst_length + sizeof(u16), GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\ttx = adis->buffer + burst_length;\n\ttx[0] = ADIS_READ_REG(adis->burst->reg_cmd);\n\ttx[1] = 0;\n\tadis->xfer[0].tx_buf = tx;\n\tadis->xfer[0].bits_per_word = 8;\n\tadis->xfer[0].len = 2;\n\tadis->xfer[1].rx_buf = adis->buffer;\n\tadis->xfer[1].bits_per_word = 8;\n\tadis->xfer[1].len = burst_length;\n\tspi_message_init(&adis->msg);\n\tspi_message_add_tail(&adis->xfer[0], &adis->msg);\n\tspi_message_add_tail(&adis->xfer[1], &adis->msg);\n\treturn 0;\n}", "target": 1}
{"code": "static int ttusbdecfe_dvbs_diseqc_send_master_cmd(struct dvb_frontend* fe, struct dvb_diseqc_master_cmd *cmd)\n{\n\tstruct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n\tu8 b[] = { 0x00, 0xff, 0x00, 0x00,\n\t\t   0x00, 0x00, 0x00, 0x00,\n\t\t   0x00, 0x00 };\n\tif (cmd->msg_len > sizeof(b) - 4)\n\t\treturn -EINVAL;\n\tmemcpy(&b[4], cmd->msg, cmd->msg_len);\n\tstate->config->send_command(fe, 0x72,\n\t\t\t\t    sizeof(b) - (6 - cmd->msg_len), b,\n\t\t\t\t    NULL, NULL);\n\treturn 0;\n}", "target": 0}
{"code": "static gboolean has_internal_nul(const char* str, int len) {\n\twhile (len > 0 && str[len-1] == 0)\n\t\tlen--;\n\treturn strlen(str) != len;\n}", "target": 0}
{"code": "void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n    header = get_header(fp);\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n    free(header);\n}", "target": 1}
{"code": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n\t       sizeof(ualg->cru_driver_name));\n\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n\t       CRYPTO_MAX_ALG_NAME);\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static int __get_data_block(struct inode *inode, sector_t iblock,\n\t\t\tstruct buffer_head *bh, int create, int flag,\n\t\t\tpgoff_t *next_pgofs)\n{\n\tstruct f2fs_map_blocks map;\n\tint err;\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\tmap.m_next_pgofs = next_pgofs;\n\terr = f2fs_map_blocks(inode, &map, create, flag);\n\tif (!err) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\tbh->b_state = (bh->b_state & ~F2FS_MAP_FLAGS) | map.m_flags;\n\t\tbh->b_size = map.m_len << inode->i_blkbits;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tmsg->msg_namelen = 0;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0)\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}", "target": 1}
{"code": "void addReply(redisClient *c, robj *obj) {\n    if (_installWriteEvent(c) != REDIS_OK) return;\n    redisAssert(!server.vm_enabled || obj->storage == REDIS_VM_MEMORY);\n    if (obj->encoding == REDIS_ENCODING_RAW) {\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n    } else {\n        obj = getDecodedObject(obj);\n        if (_addReplyToBuffer(c,obj->ptr,sdslen(obj->ptr)) != REDIS_OK)\n            _addReplyObjectToList(c,obj);\n        decrRefCount(obj);\n    }\n}", "target": 1}
{"code": "static LINK_HANDLE create_link(role link_role)\n{\n    umock_c_reset_all_calls();\n    STRICT_EXPECTED_CALL(gballoc_calloc(IGNORED_NUM_ARG, IGNORED_NUM_ARG));\n    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));\n    STRICT_EXPECTED_CALL(amqpvalue_clone(IGNORED_PTR_ARG));\n    STRICT_EXPECTED_CALL(tickcounter_create());\n    STRICT_EXPECTED_CALL(singlylinkedlist_create());\n    STRICT_EXPECTED_CALL(gballoc_malloc(IGNORED_NUM_ARG));\n    STRICT_EXPECTED_CALL(session_create_link_endpoint(TEST_SESSION_HANDLE, TEST_LINK_NAME_1));\n    STRICT_EXPECTED_CALL(session_set_link_endpoint_callback(TEST_LINK_ENDPOINT, IGNORED_PTR_ARG, IGNORED_PTR_ARG));\n    return link_create(TEST_SESSION_HANDLE, TEST_LINK_NAME_1, link_role, TEST_LINK_SOURCE, TEST_LINK_TARGET);\n}", "target": 0}
{"code": "static int onChdir(rpmfi fi, void *data)\n{\n    struct diriter_s *di = data;\n    if (di->dirfd >= 0) {\n\tclose(di->dirfd);\n\tdi->dirfd = -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "static int handle_vmon(struct kvm_vcpu *vcpu)\n{\n\tint ret;\n\tgpa_t vmptr;\n\tstruct page *page;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED\n\t\t| FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX;\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_VMXE)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\tif (vmx->nested.vmxon) {\n\t\tnested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif ((vmx->msr_ia32_feature_control & VMXON_NEEDED_FEATURES)\n\t\t\t!= VMXON_NEEDED_FEATURES) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\tif (nested_vmx_get_vmptr(vcpu, &vmptr))\n\t\treturn 1;\n\tif (!PAGE_ALIGNED(vmptr) || (vmptr >> cpuid_maxphyaddr(vcpu))) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tpage = kvm_vcpu_gpa_to_page(vcpu, vmptr);\n\tif (is_error_page(page)) {\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tif (*(u32 *)kmap(page) != VMCS12_REVISION) {\n\t\tkunmap(page);\n\t\tkvm_release_page_clean(page);\n\t\tnested_vmx_failInvalid(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\tkunmap(page);\n\tkvm_release_page_clean(page);\n\tvmx->nested.vmxon_ptr = vmptr;\n\tret = enter_vmx_operation(vcpu);\n\tif (ret)\n\t\treturn ret;\n\tnested_vmx_succeed(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}", "target": 0}
{"code": "void HTMLSelectElement::dispatchFocusEvent(Element* oldFocusedElement, FocusDirection direction)\n{\n    if (usesMenuList())\n        saveLastSelection();\n    HTMLFormControlElementWithState::dispatchFocusEvent(oldFocusedElement, direction);\n}", "target": 0}
{"code": "update_job_run (updateJobPtr job)\n{\n\tif (*(job->request->source) == '|') {\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n\t\tupdate_exec_cmd (job);\n\t\treturn;\n\t}\n\tif (strstr (job->request->source, \":\n\t\tnetwork_process_request (job);\n\t\treturn;\n\t}\n\t{\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized file URI: %s\", job->request->source);\n\t\tupdate_load_file (job);\n\t\treturn;\n\t}\n}", "target": 1}
{"code": "int VP8LHuffmanTablesAllocate(int size, HuffmanTables* huffman_tables) {\n  HuffmanTablesSegment* const root = &huffman_tables->root;\n  huffman_tables->curr_segment = root;\n  root->start = (HuffmanCode*)WebPSafeMalloc(size, sizeof(*root->start));\n  if (root->start == NULL) return 0;\n  root->curr_table = root->start;\n  root->next = NULL;\n  root->size = size;\n  return 1;\n}", "target": 0}
{"code": "JSON_read(int fd)\n{\n    uint32_t hsize, nsize;\n    char *str;\n    cJSON *json = NULL;\n    int rc;\n    if (Nread(fd, (char*) &nsize, sizeof(nsize), Ptcp) >= 0) {\n\thsize = ntohl(nsize);\n\tstr = (char *) calloc(sizeof(char), hsize+1);\t\n\tif (str != NULL) {\n\t    rc = Nread(fd, str, hsize, Ptcp);\n\t    if (rc >= 0) {\n\t\tif (rc == hsize) {\n\t\t    json = cJSON_Parse(str);\n\t\t}\n\t\telse {\n\t\t    printf(\"WARNING:  Size of data read does not correspond to offered length\\n\");\n\t\t}\n\t    }\n\t}\n\tfree(str);\n    }\n    return json;\n}", "target": 1}
{"code": "sd_markdown_new(\n\tunsigned int extensions,\n\tsize_t max_nesting,\n\tconst struct sd_callbacks *callbacks,\n\tvoid *opaque)\n{\n\tstruct sd_markdown *md = NULL;\n\tassert(max_nesting > 0 && callbacks);\n\tmd = malloc(sizeof(struct sd_markdown));\n\tif (!md)\n\t\treturn NULL;\n\tmemcpy(&md->cb, callbacks, sizeof(struct sd_callbacks));\n\tredcarpet_stack_init(&md->work_bufs[BUFFER_BLOCK], 4);\n\tredcarpet_stack_init(&md->work_bufs[BUFFER_SPAN], 8);\n\tmemset(md->active_char, 0x0, 256);\n\tif (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) {\n\t\tmd->active_char['*'] = MD_CHAR_EMPHASIS;\n\t\tmd->active_char['_'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & MKDEXT_STRIKETHROUGH)\n\t\t\tmd->active_char['~'] = MD_CHAR_EMPHASIS;\n\t\tif (extensions & MKDEXT_HIGHLIGHT)\n\t\t\tmd->active_char['='] = MD_CHAR_EMPHASIS;\n\t}\n\tif (md->cb.codespan)\n\t\tmd->active_char['`'] = MD_CHAR_CODESPAN;\n\tif (md->cb.linebreak)\n\t\tmd->active_char['\\n'] = MD_CHAR_LINEBREAK;\n\tif (md->cb.image || md->cb.link)\n\t\tmd->active_char['['] = MD_CHAR_LINK;\n\tmd->active_char['<'] = MD_CHAR_LANGLE;\n\tmd->active_char['\\\\'] = MD_CHAR_ESCAPE;\n\tmd->active_char['&'] = MD_CHAR_ENTITITY;\n\tif (extensions & MKDEXT_AUTOLINK) {\n\t\tmd->active_char[':'] = MD_CHAR_AUTOLINK_URL;\n\t\tmd->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;\n\t\tmd->active_char['w'] = MD_CHAR_AUTOLINK_WWW;\n\t}\n\tif (extensions & MKDEXT_SUPERSCRIPT)\n\t\tmd->active_char['^'] = MD_CHAR_SUPERSCRIPT;\n\tif (extensions & MKDEXT_QUOTE)\n\t\tmd->active_char['\"'] = MD_CHAR_QUOTE;\n\tmd->ext_flags = extensions;\n\tmd->opaque = opaque;\n\tmd->max_nesting = max_nesting;\n\tmd->in_link_body = 0;\n\treturn md;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE(context, input->type == kTfLiteUInt8 ||\n                              input->type == kTfLiteInt8 ||\n                              input->type == kTfLiteInt16);\n  TF_LITE_ENSURE(\n      context, output->type == kTfLiteFloat32 || output->type == kTfLiteInt32);\n  if (output->type == kTfLiteInt32) {\n    const double effective_output_scale =\n        static_cast<double>(input->params.scale) /\n        static_cast<double>(output->params.scale);\n    QuantizeMultiplier(effective_output_scale, &data->output_multiplier,\n                       &data->output_shift);\n  }\n  data->quantization_params.zero_point = input->params.zero_point;\n  data->quantization_params.scale = static_cast<double>(input->params.scale);\n  data->output_zero_point = output->params.zero_point;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void cmov_int16(int16_t *r, int16_t v, uint16_t b)\n{\n  b = -b;\n  *r ^= b & ((*r) ^ v);\n}", "target": 0}
{"code": "   int64 usage() const { return usage_; }", "target": 0}
{"code": "    uint32_t TiffIfdMakernote::doSizeImage() const\n    {\n        return ifd_.sizeImage();\n    } ", "target": 0}
{"code": "CACHE_BITMAP_V2_ORDER* copy_cache_bitmap_v2_order(rdpContext* context,\n                                                  const CACHE_BITMAP_V2_ORDER* order)\n{\n\tCACHE_BITMAP_V2_ORDER* dst = calloc(1, sizeof(CACHE_BITMAP_V2_ORDER));\n\tif (!dst || !order)\n\t\tgoto fail;\n\t*dst = *order;\n\tif (order->bitmapLength > 0)\n\t{\n\t\tdst->bitmapDataStream = malloc(order->bitmapLength);\n\t\tif (!dst->bitmapDataStream)\n\t\t\tgoto fail;\n\t\tmemcpy(dst->bitmapDataStream, order->bitmapDataStream, order->bitmapLength);\n\t}\n\treturn dst;\nfail:\n\tfree_cache_bitmap_v2_order(context, dst);\n\treturn NULL;\n}", "target": 0}
{"code": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "host_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member *m)\n{\n    struct alias *a;\n    int matched = UNSPEC;\n    debug_decl(host_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name, lhost, shost,\n\t\tdef_netgroup_tuple ? pw->pw_name : NULL))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NTWKADDR:\n\t    if (addr_matches(m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, HOSTALIAS);\n\t    if (a != NULL) {\n\t\tconst int rc = hostlist_matches_int(parse_tree, pw, lhost,\n\t\t    shost, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (hostname_matches(shost, lhost, m->name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    sudo_debug_printf(SUDO_DEBUG_DEBUG,\n\t\"host %s (%s) matches sudoers host %s%s: %s\", lhost, shost,\n\tm->negated ? \"!\" : \"\", m->name ? m->name : \"ALL\",\n\tmatched == true ? \"true\" : \"false\");\n    debug_return_int(matched);\n}", "target": 1}
{"code": "static ext4_io_end_t *ext4_init_io_end (struct inode *inode)\n{\n\text4_io_end_t *io = NULL;\n\tio = kmalloc(sizeof(*io), GFP_NOFS);\n\tif (io) {\n\t\tigrab(inode);\n\t\tio->inode = inode;\n\t\tio->flag = 0;\n\t\tio->offset = 0;\n\t\tio->size = 0;\n\t\tio->error = 0;\n\t\tINIT_WORK(&io->work, ext4_end_io_work);\n\t\tINIT_LIST_HEAD(&io->list);\n\t}\n\treturn io;\n}", "target": 1}
{"code": "static void f_parser (lua_State *L, void *ud) {\n  int i;\n  Proto *tf;\n  Closure *cl;\n  struct SParser *p = cast(struct SParser *, ud);\n  int c = luaZ_lookahead(p->z);\n  luaC_checkGC(L);\n  tf = ((c == LUA_SIGNATURE[0]) ? luaU_undump : luaY_parser)(L, p->z,\n                                                             &p->buff, p->name);\n  cl = luaF_newLclosure(L, tf->nups, hvalue(gt(L)));\n  cl->l.p = tf;\n  for (i = 0; i < tf->nups; i++)  \n    cl->l.upvals[i] = luaF_newupval(L);\n  setclvalue(L, L->top, cl);\n  incr_top(L);\n}", "target": 1}
{"code": "SessionStorageNamespace* WebContentsImpl::GetSessionStorageNamespace(\n    SiteInstance* instance) {\n  return controller_.GetSessionStorageNamespace(instance);\n}", "target": 0}
{"code": "void DetectHttpResponseHeaderRegister(void)\n{\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].name = \"http.response_header\";\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].desc =\n            \"sticky buffer to match on only one HTTP header name and value\";\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].url = \"/rules/http2-keywords.html#response_header\";\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].Setup = DetectHTTPResponseHeaderSetup;\n    sigmatch_table[DETECT_HTTP_RESPONSE_HEADER].flags |=\n            SIGMATCH_NOOPT | SIGMATCH_INFO_STICKY_BUFFER;\n    DetectAppLayerMpmRegister2(\"http_response_header\", SIG_FLAG_TOCLIENT, 2,\n            PrefilterMpmHttp2HeaderRegister, NULL, ALPROTO_HTTP2, HTTP2StateOpen);\n    DetectAppLayerInspectEngineRegister2(\"http_response_header\", ALPROTO_HTTP2, SIG_FLAG_TOCLIENT,\n            HTTP2StateOpen, DetectEngineInspectHttp2Header, NULL);\n    DetectAppLayerMpmRegister2(\"http_response_header\", SIG_FLAG_TOCLIENT, 2,\n            PrefilterMpmHttp1HeaderRegister, NULL, ALPROTO_HTTP1, 0);\n    DetectAppLayerInspectEngineRegister2(\"http_response_header\", ALPROTO_HTTP1, SIG_FLAG_TOCLIENT,\n            HTP_RESPONSE_HEADERS, DetectEngineInspectHttp1Header, NULL);\n    DetectBufferTypeSetDescriptionByName(\"http_response_header\", \"HTTP header name and value\");\n    g_http_response_header_buffer_id = DetectBufferTypeGetByName(\"http_response_header\");\n    DetectBufferTypeSupportsMultiInstance(\"http_response_header\");\n    g_response_header_thread_id = DetectRegisterThreadCtxGlobalFuncs(\"http_response_header\",\n            HttpMultiBufHeaderThreadDataInit, NULL, HttpMultiBufHeaderThreadDataFree);\n}", "target": 0}
{"code": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n\tint retval;\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}", "target": 1}
{"code": "void processInputBuffer(client *c) {\n    server.current_client = c;\n    while(sdslen(c->querybuf)) {\n        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;\n        if (c->flags & CLIENT_BLOCKED) break;\n        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;\n        if (!c->reqtype) {\n            if (c->querybuf[0] == '*') {\n                c->reqtype = PROTO_REQ_MULTIBULK;\n            } else {\n                c->reqtype = PROTO_REQ_INLINE;\n            }\n        }\n        if (c->reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;\n        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break;\n        } else {\n            serverPanic(\"Unknown request type\");\n        }\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            if (processCommand(c) == C_OK)\n                resetClient(c);\n            if (server.current_client == NULL) break;\n        }\n    }\n    server.current_client = NULL;\n}", "target": 1}
{"code": "agoo_http_init() {\n    const char\t**kp = header_keys;\n    memset(&key_cache, 0, sizeof(struct _cache));\n    for (; NULL != *kp; kp++) {\n\tkey_set(*kp);\n    }\n}", "target": 1}
{"code": "static void perf_event_interrupt(struct pt_regs *regs)\n{\n\tint i;\n\tstruct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n\tstruct perf_event *event;\n\tunsigned long val;\n\tint found = 0;\n\tint nmi;\n\tif (cpuhw->n_limited)\n\t\tfreeze_limited_counters(cpuhw, mfspr(SPRN_PMC5),\n\t\t\t\t\tmfspr(SPRN_PMC6));\n\tperf_read_regs(regs);\n\tnmi = perf_intr_is_nmi(regs);\n\tif (nmi)\n\t\tnmi_enter();\n\telse\n\t\tirq_enter();\n\tfor (i = 0; i < cpuhw->n_events; ++i) {\n\t\tevent = cpuhw->event[i];\n\t\tif (!event->hw.idx || is_limited_pmc(event->hw.idx))\n\t\t\tcontinue;\n\t\tval = read_pmc(event->hw.idx);\n\t\tif ((int)val < 0) {\n\t\t\tfound = 1;\n\t\t\trecord_and_restart(event, val, regs, nmi);\n\t\t}\n\t}\n\tif (!found) {\n\t\tfor (i = 0; i < ppmu->n_counter; ++i) {\n\t\t\tif (is_limited_pmc(i + 1))\n\t\t\t\tcontinue;\n\t\t\tval = read_pmc(i + 1);\n\t\t\tif ((int)val < 0)\n\t\t\t\twrite_pmc(i + 1, 0);\n\t\t}\n\t}\n\twrite_mmcr0(cpuhw, cpuhw->mmcr[0]);\n\tif (nmi)\n\t\tnmi_exit();\n\telse\n\t\tirq_exit();\n}", "target": 1}
{"code": "static int rtnl_bridge_setlink(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct ifinfomsg *ifm;\n\tstruct net_device *dev;\n\tstruct nlattr *br_spec, *attr = NULL;\n\tint rem, err = -EOPNOTSUPP;\n\tu16 flags = 0;\n\tbool have_flags = false;\n\tif (nlmsg_len(nlh) < sizeof(*ifm))\n\t\treturn -EINVAL;\n\tifm = nlmsg_data(nlh);\n\tif (ifm->ifi_family != AF_BRIDGE)\n\t\treturn -EPFNOSUPPORT;\n\tdev = __dev_get_by_index(net, ifm->ifi_index);\n\tif (!dev) {\n\t\tpr_info(\"PF_BRIDGE: RTM_SETLINK with unknown ifindex\\n\");\n\t\treturn -ENODEV;\n\t}\n\tbr_spec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\n\tif (br_spec) {\n\t\tnla_for_each_nested(attr, br_spec, rem) {\n\t\t\tif (nla_type(attr) == IFLA_BRIDGE_FLAGS) {\n\t\t\t\tif (nla_len(attr) < sizeof(flags))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\thave_flags = true;\n\t\t\t\tflags = nla_get_u16(attr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!flags || (flags & BRIDGE_FLAGS_MASTER)) {\n\t\tstruct net_device *br_dev = netdev_master_upper_dev_get(dev);\n\t\tif (!br_dev || !br_dev->netdev_ops->ndo_bridge_setlink) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\terr = br_dev->netdev_ops->ndo_bridge_setlink(dev, nlh, flags);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tflags &= ~BRIDGE_FLAGS_MASTER;\n\t}\n\tif ((flags & BRIDGE_FLAGS_SELF)) {\n\t\tif (!dev->netdev_ops->ndo_bridge_setlink)\n\t\t\terr = -EOPNOTSUPP;\n\t\telse\n\t\t\terr = dev->netdev_ops->ndo_bridge_setlink(dev, nlh,\n\t\t\t\t\t\t\t\t  flags);\n\t\tif (!err) {\n\t\t\tflags &= ~BRIDGE_FLAGS_SELF;\n\t\t\terr = rtnl_bridge_notify(dev);\n\t\t}\n\t}\n\tif (have_flags)\n\t\tmemcpy(nla_data(attr), &flags, sizeof(flags));\nout:\n\treturn err;\n}", "target": 0}
{"code": "mm_free(struct mm_master *mm, void *address)\n{\n\tstruct mm_share *mms, *prev, tmp;\n\ttmp.address = address;\n\tmms = RB_FIND(mmtree, &mm->rb_allocated, &tmp);\n\tif (mms == NULL)\n\t\tfatal(\"mm_free(%p): can not find %p\", mm, address);\n\tmemset(mms->address, 0xd0, mms->size);\n\tRB_REMOVE(mmtree, &mm->rb_allocated, mms);\n\tif (RB_INSERT(mmtree, &mm->rb_free, mms) != NULL)\n\t\tfatal(\"mm_free(%p): double address %p\", mm, address);\n\tprev = mms;\n\tif (RB_LEFT(prev, next)) {\n\t\tprev = RB_LEFT(prev, next);\n\t\twhile (RB_RIGHT(prev, next))\n\t\t\tprev = RB_RIGHT(prev, next);\n\t} else {\n\t\tif (RB_PARENT(prev, next) &&\n\t\t    (prev == RB_RIGHT(RB_PARENT(prev, next), next)))\n\t\t\tprev = RB_PARENT(prev, next);\n\t\telse {\n\t\t\twhile (RB_PARENT(prev, next) &&\n\t\t\t    (prev == RB_LEFT(RB_PARENT(prev, next), next)))\n\t\t\t\tprev = RB_PARENT(prev, next);\n\t\t\tprev = RB_PARENT(prev, next);\n\t\t}\n\t}\n\tif (prev != NULL && MM_ADDRESS_END(prev) > address)\n\t\tfatal(\"mm_free: memory corruption: %p(%zu) > %p\",\n\t\t    prev->address, prev->size, address);\n\tif (prev != NULL && MM_ADDRESS_END(prev) == address) {\n\t\tprev->size += mms->size;\n\t\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\t\tif (mm->mmalloc == NULL)\n\t\t\tfree(mms);\n\t\telse\n\t\t\tmm_free(mm->mmalloc, mms);\n\t} else\n\t\tprev = mms;\n\tif (prev == NULL)\n\t\treturn;\n\tmms = RB_NEXT(mmtree, &mm->rb_free, prev);\n\tif (mms == NULL)\n\t\treturn;\n\tif (MM_ADDRESS_END(prev) > mms->address)\n\t\tfatal(\"mm_free: memory corruption: %p < %p(%zu)\",\n\t\t    mms->address, prev->address, prev->size);\n\tif (MM_ADDRESS_END(prev) != mms->address)\n\t\treturn;\n\tprev->size += mms->size;\n\tRB_REMOVE(mmtree, &mm->rb_free, mms);\n\tif (mm->mmalloc == NULL)\n\t\tfree(mms);\n\telse\n\t\tmm_free(mm->mmalloc, mms);\n}", "target": 1}
{"code": "    Value::UniquePtr Xmpdatum::getValue() const\n    {\n        return p_->value_.get() == 0 ? nullptr : p_->value_->clone();\n    }", "target": 0}
{"code": "hermesInternalIsLazy(void *, Runtime &runtime, NativeArgs args) {\n  auto callable = args.dyncastArg<Callable>(0);\n  if (!callable) {\n    return HermesValue::encodeBoolValue(false);\n  }\n  auto codeBlock = getLeafCodeBlock(callable, runtime);\n  if (!codeBlock) {\n    return HermesValue::encodeBoolValue(false);\n  }\n  RuntimeModule *runtimeModule = codeBlock->getRuntimeModule();\n  return HermesValue::encodeBoolValue(\n      runtimeModule && runtimeModule->getBytecode()->isLazy());\n}", "target": 0}
{"code": "void unbind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    s_poll_init(fds, 1);\n    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_SECTIONS]);\n    opt=service_options.next;\n    service_options.next=NULL;\n    service_free(&service_options);\n    while(opt) {\n        unsigned i;\n        s_log(LOG_DEBUG, \"Unbinding service [%s]\", opt->servname);\n        for(i=0; i<opt->local_addr.num; ++i)\n            unbind_port(opt, i);\n        if(opt->exec_name && opt->connect_addr.names) {\n            opt->option.retry=0;\n        }\n        if(opt->ctx)\n            SSL_CTX_flush_sessions(opt->ctx,\n                (long)time(NULL)+opt->session_timeout+1);\n        s_log(LOG_DEBUG, \"Service [%s] closed\", opt->servname);\n        {\n            SERVICE_OPTIONS *garbage=opt;\n            opt=opt->next;\n            garbage->next=NULL;\n            service_free(garbage);\n        }\n    }\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);\n}", "target": 1}
{"code": "static int br_parse_ip_options(struct sk_buff *skb)\n{\n\tstruct ip_options *opt;\n\tstruct iphdr *iph;\n\tstruct net_device *dev = skb->dev;\n\tu32 len;\n\tiph = ip_hdr(skb);\n\topt = &(IPCB(skb)->opt);\n\tif (iph->ihl < 5 || iph->version != 4)\n\t\tgoto inhdr_error;\n\tif (!pskb_may_pull(skb, iph->ihl*4))\n\t\tgoto inhdr_error;\n\tiph = ip_hdr(skb);\n\tif (unlikely(ip_fast_csum((u8 *)iph, iph->ihl)))\n\t\tgoto inhdr_error;\n\tlen = ntohs(iph->tot_len);\n\tif (skb->len < len) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INTRUNCATEDPKTS);\n\t\tgoto drop;\n\t} else if (len < (iph->ihl*4))\n\t\tgoto inhdr_error;\n\tif (pskb_trim_rcsum(skb, len)) {\n\t\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INDISCARDS);\n\t\tgoto drop;\n\t}\n\tif (iph->ihl == 5) {\n\t\tmemset(IPCB(skb), 0, sizeof(struct inet_skb_parm));\n\t\treturn 0;\n\t}\n\topt->optlen = iph->ihl*4 - sizeof(struct iphdr);\n\tif (ip_options_compile(dev_net(dev), opt, skb))\n\t\tgoto inhdr_error;\n\tif (unlikely(opt->srr)) {\n\t\tstruct in_device *in_dev = __in_dev_get_rcu(dev);\n\t\tif (in_dev && !IN_DEV_SOURCE_ROUTE(in_dev))\n\t\t\tgoto drop;\n\t\tif (ip_options_rcv_srr(skb))\n\t\t\tgoto drop;\n\t}\n\treturn 0;\ninhdr_error:\n\tIP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);\ndrop:\n\treturn -1;\n}", "target": 1}
{"code": "PermissionRequestType PermissionUtil::GetRequestType(ContentSettingsType type) {\n  switch (type) {\n    case CONTENT_SETTINGS_TYPE_GEOLOCATION:\n      return PermissionRequestType::PERMISSION_GEOLOCATION;\n    case CONTENT_SETTINGS_TYPE_NOTIFICATIONS:\n      return PermissionRequestType::PERMISSION_NOTIFICATIONS;\n    case CONTENT_SETTINGS_TYPE_MIDI_SYSEX:\n      return PermissionRequestType::PERMISSION_MIDI_SYSEX;\n    case CONTENT_SETTINGS_TYPE_PUSH_MESSAGING:\n      return PermissionRequestType::PERMISSION_PUSH_MESSAGING;\n    case CONTENT_SETTINGS_TYPE_PROTECTED_MEDIA_IDENTIFIER:\n      return PermissionRequestType::PERMISSION_PROTECTED_MEDIA_IDENTIFIER;\n    case CONTENT_SETTINGS_TYPE_PLUGINS:\n      return PermissionRequestType::PERMISSION_FLASH;\n    default:\n      NOTREACHED();\n      return PermissionRequestType::UNKNOWN;\n  }\n}", "target": 0}
{"code": "static int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\tint delta = (state.delta * adaptationTable[code]) >> 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\treturn static_cast<int16_t>(linearSample);\n}", "target": 1}
{"code": "int touch_file(const char *path, bool parents, usec_t stamp, uid_t uid, gid_t gid, mode_t mode) {\n        _cleanup_close_ int fd;\n        int r;\n        assert(path);\n        if (parents)\n                mkdir_parents(path, 0755);\n        fd = open(path, O_WRONLY|O_CREAT|O_CLOEXEC|O_NOCTTY,\n                        (mode == 0 || mode == MODE_INVALID) ? 0644 : mode);\n        if (fd < 0)\n                return -errno;\n        if (mode != MODE_INVALID) {\n                r = fchmod(fd, mode);\n                if (r < 0)\n                        return -errno;\n        }\n        if (uid != UID_INVALID || gid != GID_INVALID) {\n                r = fchown(fd, uid, gid);\n                if (r < 0)\n                        return -errno;\n        }\n        if (stamp != USEC_INFINITY) {\n                struct timespec ts[2];\n                timespec_store(&ts[0], stamp);\n                ts[1] = ts[0];\n                r = futimens(fd, ts);\n        } else\n                r = futimens(fd, NULL);\n        if (r < 0)\n                return -errno;\n        return 0;\n}", "target": 0}
{"code": "static pj_status_t decode_errcode_attr(pj_pool_t *pool, \n                                       const pj_uint8_t *buf,\n                                       const pj_stun_msg_hdr *msghdr, \n                                       void **p_attr)\n{\n    pj_stun_errcode_attr *attr;\n    pj_str_t value;\n    PJ_UNUSED_ARG(msghdr);\n    attr = PJ_POOL_ZALLOC_T(pool, pj_stun_errcode_attr);\n    GETATTRHDR(buf, &attr->hdr);\n    attr->err_code = buf[6] * 100 + buf[7];\n    value.ptr = ((char*)buf + ATTR_HDR_LEN + 4);\n    value.slen = attr->hdr.length - 4;\n    if (value.slen < 0)\n        value.slen = 0;\n    pj_strdup(pool, &attr->reason, &value);\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}", "target": 1}
{"code": "certstack_destroy(struct cert_stack *stack)\n{\n\tunsigned int stack_size;\n\tstruct metadata_node *meta;\n\tstruct defer_node *post;\n\tstruct repo_level_node *level;\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->defers)) {\n\t\tpost = SLIST_FIRST(&stack->defers);\n\t\tSLIST_REMOVE_HEAD(&stack->defers, next);\n\t\tdefer_destroy(post);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u deferred certificates.\", stack_size);\n\tpr_val_debug(\"Deleting %d stacked x509s.\", sk_X509_num(stack->x509s));\n\tsk_X509_pop_free(stack->x509s, X509_free);\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->metas)) {\n\t\tmeta = SLIST_FIRST(&stack->metas);\n\t\tSLIST_REMOVE_HEAD(&stack->metas, next);\n\t\tmeta_destroy(meta);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u metadatas.\", stack_size);\n\tstack_size = 0;\n\twhile (!SLIST_EMPTY(&stack->levels)) {\n\t\tlevel = SLIST_FIRST(&stack->levels);\n\t\tSLIST_REMOVE_HEAD(&stack->levels, next);\n\t\tfree(level);\n\t\tstack_size++;\n\t}\n\tpr_val_debug(\"Deleted %u stacked levels.\", stack_size);\n\tfree(stack);\n}", "target": 1}
{"code": "static void atomic2gen (lua_State *L, global_State *g) {\n  g->gcstate = GCSswpallgc;\n  sweep2old(L, &g->allgc);\n  g->reallyold = g->old = g->survival = g->allgc;\n  sweep2old(L, &g->finobj);\n  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;\n  sweep2old(L, &g->tobefnz);\n  g->gckind = KGC_GEN;\n  g->lastatomic = 0;\n  g->GCestimate = gettotalbytes(g);  \n  finishgencycle(L, g);\n}", "target": 0}
{"code": "l2tp_q931_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tprint_16bits_val(ndo, (const uint16_t *)dat);\n\tND_PRINT((ndo, \", %02x\", dat[2]));\n\tif (length > 3) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, dat+3, length-3);\n\t}\n}", "target": 1}
{"code": "static Jsi_RC DebugInfoCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash) {\n        Jsi_ValueMakeArrayObject(interp, ret, NULL);\n        return JSI_OK;\n    }\n    int argc = Jsi_ValueGetLength(interp, args);\n    if (argc == 0)\n        return Jsi_HashKeysDump(interp, interp->breakpointHash, ret, 0);\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    int num;\n    char nbuf[100];\n    if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n        return Jsi_LogError(\"bad number\");\n    snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n    Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n    if (!hPtr) \n        return Jsi_LogError(\"unknown breakpoint\");\n    jsi_BreakPoint* bp = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr);\n    if (!bp) return JSI_ERROR;\n    Jsi_DString dStr = {};\n    if (bp->func)\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"func\\\", func:\\\"%s\\\", hits:%d, enabled:%s, temporary:%s}\",\n         bp->id, bp->func, bp->hits, bp->enabled?\"true\":\"false\", bp->temp?\"true\":\"false\");\n    else\n        Jsi_DSPrintf(&dStr, \"{id:%d, type:\\\"line\\\", file:\\\"%s\\\", line:%d, hits:%d, enabled:%s}\",\n            bp->id, bp->file?bp->file:\"\", bp->line, bp->hits, bp->enabled?\"true\":\"false\");\n    Jsi_RC rc = Jsi_JSONParse(interp, Jsi_DSValue(&dStr), ret, 0);\n    Jsi_DSFree(&dStr);\n    return rc;\n}", "target": 1}
{"code": "static int64_t http_seek_internal(URLContext *h, int64_t off, int whence, int force_reconnect)\n{\n    HTTPContext *s = h->priv_data;\n    URLContext *old_hd = s->hd;\n    int64_t old_off = s->off;\n    uint8_t old_buf[BUFFER_SIZE];\n    int old_buf_size, ret;\n    AVDictionary *options = NULL;\n    if (whence == AVSEEK_SIZE)\n        return s->filesize;\n    else if (!force_reconnect &&\n             ((whence == SEEK_CUR && off == 0) ||\n              (whence == SEEK_SET && off == s->off)))\n        return s->off;\n    else if ((s->filesize == -1 && whence == SEEK_END))\n        return AVERROR(ENOSYS);\n    if (whence == SEEK_CUR)\n        off += s->off;\n    else if (whence == SEEK_END)\n        off += s->filesize;\n    else if (whence != SEEK_SET)\n        return AVERROR(EINVAL);\n    if (off < 0)\n        return AVERROR(EINVAL);\n    s->off = off;\n    if (s->off && h->is_streamed)\n        return AVERROR(ENOSYS);\n    old_buf_size = s->buf_end - s->buf_ptr;\n    memcpy(old_buf, s->buf_ptr, old_buf_size);\n    s->hd = NULL;\n    if ((ret = http_open_cnx(h, &options)) < 0) {\n        av_dict_free(&options);\n        memcpy(s->buffer, old_buf, old_buf_size);\n        s->buf_ptr = s->buffer;\n        s->buf_end = s->buffer + old_buf_size;\n        s->hd      = old_hd;\n        s->off     = old_off;\n        return ret;\n    }\n    av_dict_free(&options);\n    ffurl_close(old_hd);\n    return off;\n}", "target": 1}
{"code": "static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_rng rrng;\n\tsnprintf(rrng.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"rng\");\n\trrng.seedsize = alg->cra_rng.seedsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_RNG,\n\t\t    sizeof(struct crypto_report_rng), &rrng))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "Network::TransportSocketPtr ServerSslSocketFactory::createDownstreamTransportSocket() const {\n  Envoy::Ssl::ServerContextSharedPtr ssl_ctx;\n  {\n    absl::ReaderMutexLock l(&ssl_ctx_mu_);\n    ssl_ctx = ssl_ctx_;\n  }\n  if (ssl_ctx) {\n    return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Server, nullptr,\n                                       config_->createHandshaker());\n  } else {\n    ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n    stats_.downstream_context_secrets_not_ready_.inc();\n    return std::make_unique<NotReadySslSocket>();\n  }\n}", "target": 1}
{"code": "  void resizeTable(HeaderTable& table, uint32_t newCapacity, uint32_t newMax) {\n    table.setCapacity(newCapacity);\n    EXPECT_LE(table.size(), newMax);\n  }", "target": 0}
{"code": "struct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= type->match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tkey_ref = search_process_keyrings(&ctx);\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tconstruct_get_dest_keyring(&dest_keyring);\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tkey_put(dest_keyring);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}", "target": 1}
{"code": "monitor_init(void)\n{\n\tstruct ssh *ssh = active_state;\t\t\t\n\tstruct monitor *mon;\n\tmon = xcalloc(1, sizeof(*mon));\n\tmonitor_openfds(mon, 1);\n\tif (options.compression) {\n\t\tmon->m_zback = mm_create(NULL, MM_MEMSIZE);\n\t\tmon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);\n\t\tssh_packet_set_compress_hooks(ssh, mon->m_zlib,\n\t\t    (ssh_packet_comp_alloc_func *)mm_zalloc,\n\t\t    (ssh_packet_comp_free_func *)mm_zfree);\n\t}\n\treturn mon;\n}", "target": 1}
{"code": "static void sctp_skb_set_owner_r_frag(struct sk_buff *skb, struct sock *sk)\n{\n\tstruct sk_buff *frag;\n\tif (!skb->data_len)\n\t\tgoto done;\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_skb_set_owner_r_frag(frag, sk);\ndone:\n\tsctp_skb_set_owner_r(skb, sk);\n}", "target": 0}
{"code": "build_principal_va(krb5_context context, krb5_principal princ,\n                   unsigned int rlen, const char *realm, va_list ap)\n{\n    krb5_error_code retval = 0;\n    char *r = NULL;\n    krb5_data *data = NULL;\n    krb5_int32 count = 0;\n    krb5_int32 size = 2;  \n    char *component = NULL;\n    data = malloc(size * sizeof(krb5_data));\n    if (!data) { retval = ENOMEM; }\n    if (!retval) {\n        r = strdup(realm);\n        if (!r) { retval = ENOMEM; }\n    }\n    while (!retval && (component = va_arg(ap, char *))) {\n        if (count == size) {\n            krb5_data *new_data = NULL;\n            size *= 2;\n            new_data = realloc(data, size * sizeof(krb5_data));\n            if (new_data) {\n                data = new_data;\n            } else {\n                retval = ENOMEM;\n            }\n        }\n        if (!retval) {\n            data[count].length = strlen(component);\n            data[count].data = strdup(component);\n            if (!data[count].data) { retval = ENOMEM; }\n            count++;\n        }\n    }\n    if (!retval) {\n        princ->type = KRB5_NT_UNKNOWN;\n        princ->magic = KV5M_PRINCIPAL;\n        princ->realm = make_data(r, rlen);\n        princ->data = data;\n        princ->length = count;\n        r = NULL;    \n        data = NULL; \n    }\n    if (data) {\n        while (--count >= 0) {\n            free(data[count].data);\n        }\n        free(data);\n    }\n    free(r);\n    return retval;\n}", "target": 1}
{"code": "void OmniboxViewWin::BuildContextMenu() {\n  if (context_menu_contents_.get())\n    return;\n  context_menu_contents_.reset(new ui::SimpleMenuModel(this));\n  if (popup_window_mode_) {\n    context_menu_contents_->AddItemWithStringId(IDC_COPY, IDS_COPY);\n  } else {\n    context_menu_contents_->AddItemWithStringId(IDS_UNDO, IDS_UNDO);\n    context_menu_contents_->AddSeparator();\n    context_menu_contents_->AddItemWithStringId(IDC_CUT, IDS_CUT);\n    context_menu_contents_->AddItemWithStringId(IDC_COPY, IDS_COPY);\n    context_menu_contents_->AddItemWithStringId(IDC_PASTE, IDS_PASTE);\n    context_menu_contents_->AddItemWithStringId(IDS_PASTE_AND_GO,\n                                                IDS_PASTE_AND_GO);\n    context_menu_contents_->AddSeparator();\n    context_menu_contents_->AddItemWithStringId(IDS_SELECT_ALL, IDS_SELECT_ALL);\n    context_menu_contents_->AddSeparator();\n    context_menu_contents_->AddItemWithStringId(IDS_EDIT_SEARCH_ENGINES,\n                                                IDS_EDIT_SEARCH_ENGINES);\n  }\n  context_menu_.reset(new views::Menu2(context_menu_contents_.get()));\n}", "target": 0}
{"code": "  friend H AbslHashValue(H h, const TensorKey& k) {\n    const uint8* d = static_cast<uint8*>(k.data());\n    size_t s = k.AllocatedBytes();\n    std::vector<uint8> vec;\n    vec.reserve(s);\n    for (int i = 0; i < s; i++) {\n      vec.push_back(d[i]);\n    }\n    return H::combine(std::move(h), s);\n  }", "target": 1}
{"code": "  static void operator delete(void *, MEM_ROOT*) {}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, OrWithExactAndInexact3) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"b\" << 1));\n    runQuery(\n        fromjson(\"{$or: [{a: {$in: [/z/, /x/]}}, {a: 'w'},\"\n                 \"{b: {$exists: false}}, {b: {$in: ['p']}}]}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\"{cscan: {dir: 1}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: {or: {nodes: [\"\n        \"{ixscan: {filter: {$or:[{a:{$in:[/z/, /x/]}}, {a:'w'}]}, \"\n        \"pattern: {a: 1}}}, \"\n        \"{fetch: {filter: {$or:[{b:{$exists:false}}, {b:{$eq:'p'}}]},\"\n        \"node: {ixscan: {filter: null, pattern: {b: 1}}}}}]}}}}\");\n}", "target": 0}
{"code": "static void print_primaries(WriterContext *w, enum AVColorPrimaries color_primaries)\n{\n    const char *val = av_color_primaries_name(color_primaries);\n    if (!val || color_primaries == AVCOL_PRI_UNSPECIFIED) {\n        print_str_opt(\"color_primaries\", \"unknown\");\n    } else {\n        print_str(\"color_primaries\", val);\n    }\n}", "target": 0}
{"code": "    TimeValue::TimeValue(int hour, int minute,\n                         int second, int tzHour,\n                         int tzMinute)\n        : Value(date)\n    {\n        time_.hour = hour;\n        time_.minute = minute;\n        time_.second = second;\n        time_.tzHour = tzHour;\n        time_.tzMinute = tzMinute;\n    }", "target": 0}
{"code": "void SFS_ObjectMemberAccess(ScriptParser *parser)\n{\n\tif (parser->codec->LastError) return;\n\tSFS_Expression(parser);\n\tif (parser->codec->LastError) return;\n\tSFS_AddString(parser, \".\");\n\tSFS_Identifier(parser);\n}", "target": 0}
{"code": "static int bnx2x_vlan_rx_add_vid(struct net_device *dev, __be16 proto, u16 vid)\n{\n\tstruct bnx2x *bp = netdev_priv(dev);\n\tstruct bnx2x_vlan_entry *vlan;\n\tDP(NETIF_MSG_IFUP, \"Adding VLAN %d\\n\", vid);\n\tvlan = kmalloc(sizeof(*vlan), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\tvlan->vid = vid;\n\tvlan->hw = false;\n\tlist_add_tail(&vlan->link, &bp->vlan_reg);\n\tif (netif_running(dev))\n\t\tbnx2x_vlan_configure(bp, true);\n\treturn 0;\n}", "target": 0}
{"code": "const char *fz_colorspace_colorant(fz_context *ctx, const fz_colorspace *cs, int i)\n{\n\tif (!cs || i < 0 || i >= cs->n)\n\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Colorant out of range\");\n\treturn cs->colorant[i];\n}", "target": 0}
{"code": "snmp_mib_find(uint32_t *oid)\n{\n  snmp_mib_resource_t *resource;\n  resource = NULL;\n  for(resource = list_head(snmp_mib);\n      resource; resource = resource->next) {\n    if(!snmp_oid_cmp_oid(oid, resource->oid)) {\n      return resource;\n    }\n  }\n  return NULL;\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d,\n                  typename TTypes<T, 3>::ConstTensor gradient,\n                  typename TTypes<T, 3>::ConstTensor input,\n                  const Tensor* input_min_tensor,\n                  const Tensor* input_max_tensor,\n                  typename TTypes<T, 3>::Tensor input_backprop,\n                  typename TTypes<T>::Flat input_min_backprop,\n                  typename TTypes<T>::Flat input_max_backprop) {\n    QuantizeAndDequantizePerChannelGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }", "target": 1}
{"code": "snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)\n{\n  uint32_t i;\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    (*out_len)++;\n    *out-- = (uint8_t)*str--;\n  }\n  out = snmp_ber_encode_length(out, out_len, length);\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);\n  return out;\n}", "target": 1}
{"code": "spnego_gss_complete_auth_token(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_complete_auth_token(minor_status,\n\t\t\t\t      context_handle,\n\t\t\t\t      input_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_finish_object( bson *b ) {\n    char *start;\n    int i;\n    if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n    bson_append_byte( b , 0 );\n    start = b->data + b->stack[ --b->stackPos ];\n    i = b->cur - start;\n    bson_little_endian32( start, &i );\n    return BSON_OK;\n}", "target": 1}
{"code": "xmalloc (size_t size)\n{\n    void *ptr = malloc (size);\n    if (!ptr \n        && (size != 0))         \n    {\n        perror (\"xmalloc: Memory allocation failure\");\n        abort();\n    }\n    return ptr;\n}", "target": 1}
{"code": "RPVector *r_bin_wasm_get_types(RBinWasmObj *bin) {\n\tr_return_val_if_fail (bin && bin->g_sections, NULL);\n\treturn bin->g_types? bin->g_types: parse_unique_subsec_vec_by_id (bin, R_BIN_WASM_SECTION_TYPE);\n}", "target": 0}
{"code": "static optional<Principal> parse_principal(CephContext* cct, TokenID t,\n\t\t\t\t    string&& s) {\n  if ((t == TokenID::AWS) && (s == \"*\")) {\n    return Principal::wildcard();\n  } else if (t == TokenID::CanonicalUser) {\n  } else if (t == TokenID::AWS) {\n    auto a = ARN::parse(s);\n    if (!a) {\n      if (std::none_of(s.begin(), s.end(),\n\t\t       [](const char& c) {\n\t\t\t return (c == ':') || (c == '/');\n\t\t       })) {\n\treturn Principal::tenant(std::move(s));\n      }\n    }\n    if (a->resource == \"root\") {\n      return Principal::tenant(std::move(a->account));\n    }\n    static const char rx_str[] = \"([^/]*)/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      ceph_assert(match.size() == 3);\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }\n      if (match[1] == \"role\") {\n\treturn Principal::role(std::move(a->account),\n\t\t\t       match[2]);\n      }\n    }\n  }\n  ldout(cct, 0) << \"Supplied principal is discarded: \" << s << dendl;\n  return boost::none;\n}", "target": 1}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}", "target": 1}
{"code": "\t inline uLONG osdSwap4(uLONG *inLong) {\n\t return *inLong = DPT_Bswapl(*inLong);\n\t }", "target": 1}
{"code": "size_t copy_page_from_iter(struct page *page, size_t offset, size_t bytes,\n\t\t\t struct iov_iter *i)\n{\n\tsize_t skip, copy, left, wanted;\n\tconst struct iovec *iov;\n\tchar __user *buf;\n\tvoid *kaddr, *to;\n\tif (unlikely(bytes > i->count))\n\t\tbytes = i->count;\n\tif (unlikely(!bytes))\n\t\treturn 0;\n\twanted = bytes;\n\tiov = i->iov;\n\tskip = i->iov_offset;\n\tbuf = iov->iov_base + skip;\n\tcopy = min(bytes, iov->iov_len - skip);\n\tif (!fault_in_pages_readable(buf, copy)) {\n\t\tkaddr = kmap_atomic(page);\n\t\tto = kaddr + offset;\n\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n\t\tcopy -= left;\n\t\tskip += copy;\n\t\tto += copy;\n\t\tbytes -= copy;\n\t\twhile (unlikely(!left && bytes)) {\n\t\t\tiov++;\n\t\t\tbuf = iov->iov_base;\n\t\t\tcopy = min(bytes, iov->iov_len);\n\t\t\tleft = __copy_from_user_inatomic(to, buf, copy);\n\t\t\tcopy -= left;\n\t\t\tskip = copy;\n\t\t\tto += copy;\n\t\t\tbytes -= copy;\n\t\t}\n\t\tif (likely(!bytes)) {\n\t\t\tkunmap_atomic(kaddr);\n\t\t\tgoto done;\n\t\t}\n\t\toffset = to - kaddr;\n\t\tbuf += copy;\n\t\tkunmap_atomic(kaddr);\n\t\tcopy = min(bytes, iov->iov_len - skip);\n\t}\n\tkaddr = kmap(page);\n\tto = kaddr + offset;\n\tleft = __copy_from_user(to, buf, copy);\n\tcopy -= left;\n\tskip += copy;\n\tto += copy;\n\tbytes -= copy;\n\twhile (unlikely(!left && bytes)) {\n\t\tiov++;\n\t\tbuf = iov->iov_base;\n\t\tcopy = min(bytes, iov->iov_len);\n\t\tleft = __copy_from_user(to, buf, copy);\n\t\tcopy -= left;\n\t\tskip = copy;\n\t\tto += copy;\n\t\tbytes -= copy;\n\t}\n\tkunmap(page);\ndone:\n\ti->count -= wanted - bytes;\n\ti->nr_segs -= iov - i->iov;\n\ti->iov = iov;\n\ti->iov_offset = skip;\n\treturn wanted - bytes;\n}", "target": 0}
{"code": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; \n  int restlen = srclen - chunks * chunklen; \n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;\n  }\n  if (restlen) {\n    memcpy(q, p, restlen);\n    q += restlen;\n    memcpy(q, end, endlen);\n    q += endlen;\n  }\n  ret.setSize(q - dest);\n  return ret;\n}", "target": 1}
{"code": "BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& weights = context->input(1);\n    bool use_weights = weights.NumElements() > 0;\n    OP_REQUIRES(context,\n                TensorShapeUtils::IsVector(data.shape()) ||\n                    TensorShapeUtils::IsMatrix(data.shape()),\n                errors::InvalidArgument(\n                    \"Input must be a 1 or 2-dimensional tensor. Got: \",\n                    data.shape().DebugString()));\n    if (use_weights) {\n      OP_REQUIRES(\n          context, weights.shape() == data.shape(),\n          errors::InvalidArgument(\n              \"Weights and data must have the same shape. Weight shape: \",\n              weights.shape().DebugString(),\n              \"; data shape: \", data.shape().DebugString()));\n    }\n    bool is_1d = TensorShapeUtils::IsVector(data.shape());\n    int negative_valued_axis = -1;\n    int num_batch_dimensions = (data.shape().dims() + negative_valued_axis);\n    int num_batch_elements = 1;\n    for (int i = 0; i < num_batch_dimensions; ++i) {\n      OP_REQUIRES(context, data.shape().dim_size(i) != 0,\n                  errors::InvalidArgument(\n                      \"Invalid input: Shapes dimension cannot be 0.\"));\n      num_batch_elements *= data.shape().dim_size(i);\n    }\n    int num_value_elements = data.shape().num_elements() / num_batch_elements;\n    auto per_batch_counts = BatchedMap<W>(num_batch_elements);\n    T max_value = 0;\n    const auto data_values = data.flat<T>();\n    const auto weight_values = weights.flat<W>();\n    int i = 0;\n    for (int b = 0; b < num_batch_elements; ++b) {\n      for (int v = 0; v < num_value_elements; ++v) {\n        const auto& value = data_values(i);\n        if (value >= 0 && (maxlength_ <= 0 || value < maxlength_)) {\n          if (binary_output_) {\n            per_batch_counts[b][value] = 1;\n          } else if (use_weights) {\n            per_batch_counts[b][value] += weight_values(i);\n          } else {\n            per_batch_counts[b][value]++;\n          }\n          if (value > max_value) {\n            max_value = value;\n          }\n        }\n        ++i;\n      }\n    }\n    int num_output_values = GetOutputSize(max_value, maxlength_, minlength_);\n    OP_REQUIRES_OK(context, OutputSparse<W>(per_batch_counts, num_output_values,\n                                            is_1d, context));\n  }", "target": 0}
{"code": "hb_set_subtract (hb_set_t       *set,\n\t\t const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->subtract (*other);\n}", "target": 1}
{"code": "TfLiteStatus StoreAllDecodedSequences(\n    TfLiteContext* context,\n    const std::vector<std::vector<std::vector<int>>>& sequences,\n    TfLiteNode* node, int top_paths) {\n  const int32_t batch_size = sequences.size();\n  std::vector<int32_t> num_entries(top_paths, 0);\n  for (const auto& batch_s : sequences) {\n    TF_LITE_ENSURE_EQ(context, batch_s.size(), top_paths);\n    for (int p = 0; p < top_paths; ++p) {\n      num_entries[p] += batch_s[p].size();\n    }\n  }\n  for (int p = 0; p < top_paths; ++p) {\n    const int32_t p_num = num_entries[p];\n    TfLiteTensor* indices = GetOutput(context, node, p);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num, 2}, indices));\n    TfLiteTensor* values = GetOutput(context, node, p + top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {p_num}, values));\n    TfLiteTensor* decoded_shape = GetOutput(context, node, p + 2 * top_paths);\n    TF_LITE_ENSURE_OK(context, Resize(context, {2}, decoded_shape));\n    int32_t max_decoded = 0;\n    int32_t offset = 0;\n    int32_t* indices_data = GetTensorData<int32_t>(indices);\n    int32_t* values_data = GetTensorData<int32_t>(values);\n    int32_t* decoded_shape_data = GetTensorData<int32_t>(decoded_shape);\n    for (int b = 0; b < batch_size; ++b) {\n      auto& p_batch = sequences[b][p];\n      int32_t num_decoded = p_batch.size();\n      max_decoded = std::max(max_decoded, num_decoded);\n      std::copy_n(p_batch.begin(), num_decoded, values_data + offset);\n      for (int32_t t = 0; t < num_decoded; ++t, ++offset) {\n        indices_data[offset * 2] = b;\n        indices_data[offset * 2 + 1] = t;\n      }\n    }\n    decoded_shape_data[0] = batch_size;\n    decoded_shape_data[1] = max_decoded;\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "TEST(SerializerTest, DuplicateUnionData) {\n  const char data[] =\n      \"\\x0c\" \n      \"\\x00\\x01\" \n      \"\\x0b\" \n      \"\\x00\\x01\" \n      \"\\x00\\x00\\x00\\x00\" \n      \"\\x00\" \n      \"\\x0c\" \n      \"\\x00\\x01\" \n      \"\\x13\" \n      \"\\x00\\x02\"; \n  EXPECT_THROW(\n      BinarySerializer::deserialize<tablebased::TestStructWithUnion>(\n          folly::StringPiece(data, sizeof(data))),\n      std::out_of_range);\n}", "target": 0}
{"code": "static int mwifiex_pcie_alloc_cmdrsp_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct pcie_service_card *card = adapter->card;\n\tstruct sk_buff *skb;\n\tskb = dev_alloc_skb(MWIFIEX_UPLD_SIZE);\n\tif (!skb) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Unable to allocate skb for command response data.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, MWIFIEX_UPLD_SIZE);\n\tif (mwifiex_map_pci_memory(adapter, skb, MWIFIEX_UPLD_SIZE,\n\t\t\t\t   PCI_DMA_FROMDEVICE))\n\t\treturn -1;\n\tcard->cmdrsp_buf = skb;\n\treturn 0;\n}", "target": 1}
{"code": "template <class T> void testFeatTable(const T & table, const char * testName)\n{\n    FeatureMap testFeatureMap;\n    dummyFace.replace_table(TtfUtil::Tag::Feat, &table, sizeof(T));\n    gr_face * face = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n    if (!face) throw std::runtime_error(\"failed to load font\");\n    bool readStatus = testFeatureMap.readFeats(*face);\n    testAssert(\"readFeats\", readStatus);\n    fprintf(stderr, testName, NULL);\n    testAssertEqual(\"test num features %hu,%hu\\n\", testFeatureMap.numFeats(), table.m_header.m_numFeat);\n    for (size_t i = 0; i < sizeof(table.m_defs) / sizeof(FeatDefn); i++)\n    {\n        const FeatureRef * ref = testFeatureMap.findFeatureRef(table.m_defs[i].m_featId);\n        testAssert(\"test feat\\n\", ref);\n        testAssertEqual(\"test feat settings %hu %hu\\n\", ref->getNumSettings(), table.m_defs[i].m_numFeatSettings);\n        testAssertEqual(\"test feat label %hu %hu\\n\", ref->getNameId(), table.m_defs[i].m_label);\n        size_t settingsIndex = (table.m_defs[i].m_settingsOffset - sizeof(FeatHeader)\n            - (sizeof(FeatDefn) * table.m_header.m_numFeat)) / sizeof(FeatSetting);\n        for (size_t j = 0; j < table.m_defs[i].m_numFeatSettings; j++)\n        {\n            testAssertEqual(\"setting label %hu %hu\\n\", ref->getSettingName(j),\n                       table.m_settings[settingsIndex+j].m_label);\n        }\n    }\n    gr_face_destroy(face);\n}", "target": 1}
{"code": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\tadd_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, \n\t\t                         FE_REALLY_INTERNAL | flags ));\n}", "target": 1}
{"code": "void OfflineAudioDestinationHandler::DoOfflineRendering() {\n  DCHECK(!IsMainThread());\n  unsigned number_of_channels;\n  Vector<float*> destinations;\n  {\n    bool has_lock = ProcessHeap::CrossThreadPersistentMutex().TryLock();\n    if (!has_lock) {\n      render_thread_task_runner_->PostTask(\n          FROM_HERE,\n          WTF::Bind(&OfflineAudioDestinationHandler::DoOfflineRendering,\n                    WrapRefCounted(this)));\n      return;\n    }\n    number_of_channels = render_target_->numberOfChannels();\n    destinations.ReserveInitialCapacity(number_of_channels);\n    for (unsigned i = 0; i < number_of_channels; ++i)\n      destinations.push_back(render_target_->getChannelData(i).View()->Data());\n    ProcessHeap::CrossThreadPersistentMutex().unlock();\n  }\n  while (frames_to_process_ > 0) {\n    if (RenderIfNotSuspended(nullptr, render_bus_.get(),\n                             audio_utilities::kRenderQuantumFrames))\n      return;\n    uint32_t frames_available_to_copy =\n        std::min(frames_to_process_, audio_utilities::kRenderQuantumFrames);\n    for (unsigned channel_index = 0; channel_index < number_of_channels;\n         ++channel_index) {\n      const float* source = render_bus_->Channel(channel_index)->Data();\n      memcpy(destinations[channel_index] + frames_processed_, source,\n             sizeof(float) * frames_available_to_copy);\n    }\n    frames_processed_ += frames_available_to_copy;\n    DCHECK_GE(frames_to_process_, frames_available_to_copy);\n    frames_to_process_ -= frames_available_to_copy;\n  }\n  DCHECK_EQ(frames_to_process_, 0u);\n  FinishOfflineRendering();\n}", "target": 0}
{"code": "int linenoiseHistorySave(const char* filename) {\n    FILE* fp = fopen(filename, \"wt\");\n    if (fp == NULL) {\n        return -1;\n    }\n    for (int j = 0; j < historyLen; ++j) {\n        if (history[j][0] != '\\0') {\n            fprintf(fp, \"%s\\n\", history[j]);\n        }\n    }\n    fclose(fp);\n    return 0;\n}", "target": 1}
{"code": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}", "target": 1}
{"code": "gss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n    return status;\n}", "target": 0}
{"code": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\tkfree(old);\n\treturn count;\n}", "target": 1}
{"code": "int kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (__kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "explain_slow_path(enum slow_path_reason slow, struct ds *output)\n{\n    ds_put_cstr(output, \"\\nThis flow is handled by the userspace \"\n                \"slow path because it:\");\n    for (; slow; slow = zero_rightmost_1bit(slow)) {\n        enum slow_path_reason bit = rightmost_1bit(slow);\n        ds_put_format(output, \"\\n  - %s.\",\n                      slow_path_reason_to_explanation(bit));\n    }\n}", "target": 0}
{"code": "void SetDashSize(double dashsize,double phase) {\n    if ( dashsize ) outpos += sprintf(outpos,\" [%12.3f] %12.3f d\",dashsize,phase);\n    else outpos += sprintf(outpos,\" [] 0 d\");\n}", "target": 1}
{"code": "    const char* ExifThumbC::extension() const\n    {\n        Thumbnail::UniquePtr thumbnail = Thumbnail::create(exifData_);\n        if (thumbnail.get() == 0) return \"\";\n        return thumbnail->extension();\n    }", "target": 0}
{"code": "static int stellaris_enet_init(SysBusDevice *sbd)\n{\n    DeviceState *dev = DEVICE(sbd);\n    stellaris_enet_state *s = STELLARIS_ENET(dev);\n    memory_region_init_io(&s->mmio, OBJECT(s), &stellaris_enet_ops, s,\n                          \"stellaris_enet\", 0x1000);\n    sysbus_init_mmio(sbd, &s->mmio);\n    sysbus_init_irq(sbd, &s->irq);\n    qemu_macaddr_default_if_unset(&s->conf.macaddr);\n    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,\n                          object_get_typename(OBJECT(dev)), dev->id, s);\n    qemu_format_nic_info_str(qemu_get_queue(s->nic), s->conf.macaddr.a);\n    stellaris_enet_reset(s);\n    register_savevm(dev, \"stellaris_enet\", -1, 1,\n                    stellaris_enet_save, stellaris_enet_load, s);\n    return 0;\n}", "target": 1}
{"code": "static BOOL drive_file_remove_dir(const WCHAR* path)\n{\n\tWIN32_FIND_DATAW findFileData;\n\tBOOL ret = TRUE;\n\tHANDLE dir;\n\tWCHAR* fullpath;\n\tWCHAR* path_slash;\n\tsize_t base_path_length;\n\tif (!path)\n\t\treturn FALSE;\n\tbase_path_length = _wcslen(path) * 2;\n\tpath_slash = (WCHAR*)calloc(1, base_path_length + sizeof(WCHAR) * 3);\n\tif (!path_slash)\n\t{\n\t\tWLog_ERR(TAG, \"malloc failed!\");\n\t\treturn FALSE;\n\t}\n\tCopyMemory(path_slash, path, base_path_length);\n\tpath_slash[base_path_length / 2] = L'/';\n\tpath_slash[base_path_length / 2 + 1] = L'*';\n\tDEBUG_WSTR(\"Search in %s\", path_slash);\n\tdir = FindFirstFileW(path_slash, &findFileData);\n\tpath_slash[base_path_length / 2 + 1] = 0;\n\tif (dir == INVALID_HANDLE_VALUE)\n\t{\n\t\tfree(path_slash);\n\t\treturn FALSE;\n\t}\n\tdo\n\t{\n\t\tsize_t len = _wcslen(findFileData.cFileName);\n\t\tif ((len == 1 && findFileData.cFileName[0] == L'.') ||\n\t\t    (len == 2 && findFileData.cFileName[0] == L'.' && findFileData.cFileName[1] == L'.'))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tfullpath = drive_file_combine_fullpath(path_slash, findFileData.cFileName, len * 2);\n\t\tDEBUG_WSTR(\"Delete %s\", fullpath);\n\t\tif (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)\n\t\t{\n\t\t\tret = drive_file_remove_dir(fullpath);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret = DeleteFileW(fullpath);\n\t\t}\n\t\tfree(fullpath);\n\t\tif (!ret)\n\t\t\tbreak;\n\t} while (ret && FindNextFileW(dir, &findFileData) != 0);\n\tFindClose(dir);\n\tif (ret)\n\t{\n\t\tif (!RemoveDirectoryW(path))\n\t\t{\n\t\t\tret = FALSE;\n\t\t}\n\t}\n\tfree(path_slash);\n\treturn ret;\n}", "target": 1}
{"code": "coolkey_find_matching_cert(sc_card_t *card, sc_cardctl_coolkey_object_t *in_obj, sc_cardctl_coolkey_object_t **cert_obj) {\n\tsc_cardctl_coolkey_find_object_t fobj;\n\tsc_cardctl_coolkey_attribute_t template[2];\n\tu8 obj_class[4];\n\tint r;\n\ttemplate[0].attribute_type = CKA_CLASS;\n\ttemplate[0].attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\ttemplate[0].attribute_length = sizeof(obj_class);\n\ttemplate[0].attribute_value = obj_class;\n\tulong2bebytes(obj_class, CKO_CERTIFICATE);\n\ttemplate[1].attribute_type = CKA_ID;\n\ttemplate[1].object = in_obj;\n\tr = sc_card_ctl(card, SC_CARDCTL_COOLKEY_GET_ATTRIBUTE, &template[1]);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\ttemplate[0].object = NULL; \n\ttemplate[1].object = NULL; \n\tfobj.type = SC_CARDCTL_COOLKEY_FIND_BY_TEMPLATE;\n\tfobj.obj = NULL;\n\tfobj.coolkey_template = &template[0];\n\tfobj.template_count=2;\n\tr = sc_card_ctl(card, SC_CARDCTL_COOLKEY_FIND_OBJECT, &fobj);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\t*cert_obj = fobj.obj;\n\treturn SC_SUCCESS;\n}", "target": 0}
{"code": "xmlValidNormalizeAttributeValue(xmlDocPtr doc, xmlNodePtr elem,\n\t\t\t        const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n\txmlChar *fullname;\n\tfullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n\tif (fullname == NULL)\n\t    return(NULL);\n\tif ((fullname != fn) && (fullname != elem->name))\n\t    xmlFree(fullname);\n    }\n    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n    if ((attrDecl == NULL) && (doc->extSubset != NULL))\n\tattrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    return(ret);\n}", "target": 1}
{"code": "setup_connection (GsmXSMPClient *client)\n{\n        GIOChannel    *channel;\n        int            fd;\n        g_debug (\"GsmXSMPClient: Setting up new connection\");\n        fd = IceConnectionNumber (client->priv->ice_connection);\n        fcntl (fd, F_SETFD, fcntl (fd, F_GETFD, 0) | FD_CLOEXEC);\n        channel = g_io_channel_unix_new (fd);\n        client->priv->watch_id = g_io_add_watch (channel,\n                                                 G_IO_IN | G_IO_ERR,\n                                                 (GIOFunc)client_iochannel_watch,\n                                                 client);\n        g_io_channel_unref (channel);\n        client->priv->protocol_timeout = g_timeout_add_seconds (5,\n                                                                (GSourceFunc)_client_protocol_timeout,\n                                                                client);\n        set_description (client);\n        g_debug (\"GsmXSMPClient: New client '%s'\", client->priv->description);\n}", "target": 1}
{"code": "show_tree(tree_t *t,                    \n          int    indent)                \n{\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n    if (t->child)\n      show_tree(t->child, indent + 2);\n    t = t->next;\n  }\n}", "target": 1}
{"code": "TfLiteTensor* GetTemporary(TfLiteContext* context, const TfLiteNode* node,\n                           int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->temporaries->size, node->temporaries->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "xfs_attr_calc_size(\n\tstruct xfs_inode \t*ip,\n\tint\t\t\tnamelen,\n\tint\t\t\tvaluelen,\n\tint\t\t\t*local)\n{\n\tstruct xfs_mount \t*mp = ip->i_mount;\n\tint\t\t\tsize;\n\tint\t\t\tnblks;\n\tsize = xfs_attr_leaf_newentsize(namelen, valuelen,\n\t\t\t\t\tmp->m_sb.sb_blocksize, local);\n\tnblks = XFS_DAENTER_SPACE_RES(mp, XFS_ATTR_FORK);\n\tif (*local) {\n\t\tif (size > (mp->m_sb.sb_blocksize >> 1)) {\n\t\t\tnblks *= 2;\n\t\t}\n\t} else {\n\t\tuint\tdblocks = XFS_B_TO_FSB(mp, valuelen);\n\t\tnblks += dblocks;\n\t\tnblks += XFS_NEXTENTADD_SPACE_RES(mp, dblocks, XFS_ATTR_FORK);\n\t}\n\treturn nblks;\n}", "target": 1}
{"code": "cib_timeout_handler(gpointer data)\n{\n    struct timer_rec_s *timer = data;\n    timer_expired = TRUE;\n    crm_err(\"Call %d timed out after %ds\", timer->call_id, timer->timeout);\n    return TRUE;\n}", "target": 1}
{"code": "Http::FilterDataStatus Context::onResponseBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onResponseBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onResponseBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                                static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}", "target": 1}
{"code": "static int key_verify(pam_handle_t *pamh, int flags, PKCS11_KEY *authkey)\n{\n\tint ok = 0;\n\tunsigned char challenge[30];\n\tunsigned char signature[256];\n\tunsigned int siglen = sizeof signature;\n\tconst EVP_MD *md = EVP_sha1();\n\tEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n\tEVP_PKEY *privkey = PKCS11_get_private_key(authkey);\n\tEVP_PKEY *pubkey = PKCS11_get_public_key(authkey);\n\tif (1 != randomize(pamh, challenge, sizeof challenge)) {\n\t\tgoto err;\n\t}\n\tif (NULL == pubkey || NULL == privkey || NULL == md_ctx || NULL == md\n\t\t\t|| !EVP_SignInit(md_ctx, md)\n\t\t\t|| !EVP_SignUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| !EVP_SignFinal(md_ctx, signature, &siglen, privkey)\n\t\t\t|| !EVP_MD_CTX_reset(md_ctx)\n\t\t\t|| !EVP_VerifyInit(md_ctx, md)\n\t\t\t|| !EVP_VerifyUpdate(md_ctx, challenge, sizeof challenge)\n\t\t\t|| 1 != EVP_VerifyFinal(md_ctx, signature, siglen, pubkey)) {\n\t\tpam_syslog(pamh, LOG_DEBUG, \"Error verifying key: %s\\n\",\n\t\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tprompt(flags, pamh, PAM_ERROR_MSG, NULL, _(\"Error verifying key\"));\n\t\tgoto err;\n\t}\n\tok = 1;\nerr:\n\tif (NULL != pubkey)\n\t\tEVP_PKEY_free(pubkey);\n\tif (NULL != privkey)\n\t\tEVP_PKEY_free(privkey);\n\tif (NULL != md_ctx) {\n\t\tEVP_MD_CTX_free(md_ctx);\n\t}\n\treturn ok;\n}", "target": 1}
{"code": "bool SimpleMessenger::verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t\tint protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n\t\t\t\t\tbool& isvalid,CryptoKey& session_key)\n{\n  return ms_deliver_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid,session_key);\n}", "target": 1}
{"code": "static void iommu_disable_protect_mem_regions(struct intel_iommu *iommu)\n{\n\tu32 pmen;\n\tunsigned long flags;\n\traw_spin_lock_irqsave(&iommu->register_lock, flags);\n\tpmen = readl(iommu->reg + DMAR_PMEN_REG);\n\tpmen &= ~DMA_PMEN_EPM;\n\twritel(pmen, iommu->reg + DMAR_PMEN_REG);\n\tIOMMU_WAIT_OP(iommu, DMAR_PMEN_REG,\n\t\treadl, !(pmen & DMA_PMEN_PRS), pmen);\n\traw_spin_unlock_irqrestore(&iommu->register_lock, flags);\n}", "target": 0}
{"code": "static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)\n{\n\tstruct se_device *remote_dev;\n\tif (xop->op_origin == XCOL_SOURCE_RECV_OP)\n\t\tremote_dev = xop->dst_dev;\n\telse\n\t\tremote_dev = xop->src_dev;\n\tpr_debug(\"Calling configfs_undepend_item for\"\n\t\t  \" remote_dev: %p remote_dev->dev_group: %p\\n\",\n\t\t  remote_dev, &remote_dev->dev_group.cg_item);\n\ttarget_undepend_item(&remote_dev->dev_group.cg_item);\n}", "target": 1}
{"code": "static void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode,\n\t\t\t\t\tconst void *pdu, uint16_t length,\n\t\t\t\t\tvoid *user_data)\n{\n\tstruct bt_gatt_server *server = user_data;\n\tuint16_t handle = 0;\n\tuint16_t offset;\n\tstruct gatt_db_attribute *attr;\n\tstruct prep_write_complete_data *pwcd;\n\tuint8_t ecode, status;\n\tif (length < 4) {\n\t\tecode = BT_ATT_ERROR_INVALID_PDU;\n\t\tgoto error;\n\t}\n\tif (queue_length(server->prep_queue) >= server->max_prep_queue_len) {\n\t\tecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL;\n\t\tgoto error;\n\t}\n\thandle = get_le16(pdu);\n\toffset = get_le16(pdu + 2);\n\tattr = gatt_db_get_attribute(server->db, handle);\n\tif (!attr) {\n\t\tecode = BT_ATT_ERROR_INVALID_HANDLE;\n\t\tgoto error;\n\t}\n\tutil_debug(server->debug_callback, server->debug_data,\n\t\t\t\t\"Prep Write Req - handle: 0x%04x\", handle);\n\tecode = check_length(length, offset);\n\tif (ecode)\n\t\tgoto error;\n\tecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);\n\tif (ecode)\n\t\tgoto error;\n\tpwcd = new0(struct prep_write_complete_data, 1);\n\tpwcd->chan = chan;\n\tpwcd->pdu = malloc(length);\n\tmemcpy(pwcd->pdu, pdu, length);\n\tpwcd->length = length;\n\tpwcd->server = server;\n\tstatus = gatt_db_attribute_write(attr, offset, NULL, 0,\n\t\t\t\t\t\tBT_ATT_OP_PREP_WRITE_REQ,\n\t\t\t\t\t\tserver->att,\n\t\t\t\t\t\tprep_write_complete_cb, pwcd);\n\tif (status)\n\t\treturn;\n\tecode = BT_ATT_ERROR_UNLIKELY;\nerror:\n\tbt_att_chan_send_error_rsp(chan, opcode, handle, ecode);\n}", "target": 0}
{"code": "TIFFFlushData1(TIFF* tif)\n{\n\tif (tif->tif_rawcc > 0 && tif->tif_flags & TIFF_BUF4WRITE ) {\n\t\tif (!isFillOrder(tif, tif->tif_dir.td_fillorder) &&\n\t\t    (tif->tif_flags & TIFF_NOBITREV) == 0)\n\t\t\tTIFFReverseBits((uint8*)tif->tif_rawdata,\n\t\t\t    tif->tif_rawcc);\n\t\tif (!TIFFAppendToStrip(tif,\n\t\t    isTiled(tif) ? tif->tif_curtile : tif->tif_curstrip,\n\t\t    tif->tif_rawdata, tif->tif_rawcc))\n        {\n            tif->tif_rawcc = 0;\n            tif->tif_rawcp = tif->tif_rawdata;\n\t\t\treturn (0);\n        }\n\t\ttif->tif_rawcc = 0;\n\t\ttif->tif_rawcp = tif->tif_rawdata;\n\t}\n\treturn (1);\n}", "target": 0}
{"code": "find_jws(struct tang_keys_info* tki, const char* thp)\n{\n    if (!tki) {\n        return NULL;\n    }\n    if (thp == NULL) {\n        json_auto_t* jws = jwk_sign(tki->m_payload, tki->m_sign);\n        if (!jws) {\n            return NULL;\n        }\n        return json_incref(jws);\n    }\n    return find_by_thp(tki, thp);\n}", "target": 1}
{"code": "int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\tm->msg_iov = iov;\n\terr = 0;\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\treturn err;\n}", "target": 1}
{"code": "static inline ut32 r_read_at_le32(const void *src, size_t offset) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src + offset;\n\treturn r_read_le32 (s);\n}", "target": 0}
{"code": "bool ItemStackMetadata::setString(const std::string &name, const std::string &var)\n{\n\tbool result = Metadata::setString(name, var);\n\tif (name == TOOLCAP_KEY)\n\t\tupdateToolCapabilities();\n\treturn result;\n}", "target": 1}
{"code": "juniper_atm2_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM2;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[7] & ATM2_PKT_TYPE_MASK) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        ND_TCHECK2(p[0], 3);\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && \n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            return l2info.header_len;\n        }\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\ntrunc:\n\tND_PRINT((ndo, \"[|juniper_atm2]\"));\n\treturn l2info.header_len;\n}", "target": 0}
{"code": "static inline void sem_getref_and_unlock(struct sem_array *sma)\n{\n\tipc_rcu_getref(sma);\n\tipc_unlock(&(sma)->sem_perm);\n}", "target": 1}
{"code": "cib_remote_msg(gpointer data)\n{\n    const char *value = NULL;\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n    command = crm_recv_remote_msg(client->session, client->encrypted);\n    if (command == NULL) {\n        return -1;\n    }\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        goto bail;\n    }\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n  bail:\n    free_xml(command);\n    command = NULL;\n    return 0;\n}", "target": 1}
{"code": "int siphash_test(void) {\n    uint8_t in[64], k[16];\n    int i;\n    int fails = 0;\n    for (i = 0; i < 16; ++i)\n        k[i] = i;\n    for (i = 0; i < 64; ++i) {\n        in[i] = i;\n        uint64_t hash = siphash(in, i, k);\n        const uint8_t *v = NULL;\n        v = (uint8_t *)vectors_sip64;\n        if (memcmp(&hash, v + (i * 8), 8)) {\n            fails++;\n        }\n    }\n    uint64_t h1, h2;\n    h1 = siphash((uint8_t*)\"hello world\",11,(uint8_t*)\"1234567812345678\");\n    h2 = siphash_nocase((uint8_t*)\"hello world\",11,(uint8_t*)\"1234567812345678\");\n    if (h1 != h2) fails++;\n    h1 = siphash((uint8_t*)\"hello world\",11,(uint8_t*)\"1234567812345678\");\n    h2 = siphash_nocase((uint8_t*)\"HELLO world\",11,(uint8_t*)\"1234567812345678\");\n    if (h1 != h2) fails++;\n    h1 = siphash((uint8_t*)\"HELLO world\",11,(uint8_t*)\"1234567812345678\");\n    h2 = siphash_nocase((uint8_t*)\"HELLO world\",11,(uint8_t*)\"1234567812345678\");\n    if (h1 == h2) fails++;\n    if (!fails) return 0;\n    return 1;\n}", "target": 0}
{"code": "int kvm_arch_init_vm(struct kvm *kvm, unsigned long type)\n{\n\tif (type)\n\t\treturn -EINVAL;\n\tINIT_LIST_HEAD(&kvm->arch.active_mmu_pages);\n\tINIT_LIST_HEAD(&kvm->arch.assigned_dev_head);\n\tset_bit(KVM_USERSPACE_IRQ_SOURCE_ID, &kvm->arch.irq_sources_bitmap);\n\tset_bit(KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID,\n\t\t&kvm->arch.irq_sources_bitmap);\n\traw_spin_lock_init(&kvm->arch.tsc_write_lock);\n\tmutex_init(&kvm->arch.apic_map_lock);\n\tspin_lock_init(&kvm->arch.pvclock_gtod_sync_lock);\n\tpvclock_update_vm_gtod_copy(kvm);\n\treturn 0;\n}", "target": 0}
{"code": "void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\tif (!handle)\n\t\treturn NULL;\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\treturn pointer;\n}", "target": 1}
{"code": "static int sanitize_ptr_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn,\n\t\t\t    const struct bpf_reg_state *ptr_reg,\n\t\t\t    const struct bpf_reg_state *off_reg,\n\t\t\t    struct bpf_reg_state *dst_reg,\n\t\t\t    struct bpf_insn_aux_data *tmp_aux,\n\t\t\t    const bool commit_window)\n{\n\tstruct bpf_insn_aux_data *aux = commit_window ? cur_aux(env) : tmp_aux;\n\tstruct bpf_verifier_state *vstate = env->cur_state;\n\tbool off_is_imm = tnum_is_const(off_reg->var_off);\n\tbool off_is_neg = off_reg->smin_value < 0;\n\tbool ptr_is_dst_reg = ptr_reg == dst_reg;\n\tu8 opcode = BPF_OP(insn->code);\n\tu32 alu_state, alu_limit;\n\tstruct bpf_reg_state tmp;\n\tbool ret;\n\tint err;\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\tif (vstate->speculative)\n\t\tgoto do_sim;\n\terr = retrieve_ptr_limit(ptr_reg, off_reg, &alu_limit, opcode);\n\tif (err < 0)\n\t\treturn err;\n\tif (commit_window) {\n\t\talu_state = tmp_aux->alu_state;\n\t\talu_limit = abs(tmp_aux->alu_limit - alu_limit);\n\t} else {\n\t\talu_state  = off_is_neg ? BPF_ALU_NEG_VALUE : 0;\n\t\talu_state |= off_is_imm ? BPF_ALU_IMMEDIATE : 0;\n\t\talu_state |= ptr_is_dst_reg ?\n\t\t\t     BPF_ALU_SANITIZE_SRC : BPF_ALU_SANITIZE_DST;\n\t}\n\terr = update_alu_sanitation_state(aux, alu_state, alu_limit);\n\tif (err < 0)\n\t\treturn err;\ndo_sim:\n\tif (commit_window)\n\t\treturn 0;\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg && ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? REASON_STACK : 0;\n}", "target": 0}
{"code": "SSLNetVConnection::populate_protocol(std::string_view *results, int n) const\n{\n  int retval = 0;\n  if (n > retval) {\n    results[retval] = map_tls_protocol_to_tag(getSSLProtocol());\n    if (!results[retval].empty()) {\n      ++retval;\n    }\n    if (n > retval) {\n      retval += super::populate_protocol(results + retval, n - retval);\n    }\n  }\n  return retval;\n}", "target": 0}
{"code": "snmp_ber_decode_string_len_buffer(unsigned char *buf, uint32_t *buff_len, const char **str, uint32_t *length)\n{\n  uint8_t type, i, length_bytes;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL || type != BER_DATA_TYPE_OCTET_STRING) {\n    return NULL;\n  }\n  if((*buf & 0x80) == 0) {\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n  } else {\n    length_bytes = (uint8_t)(*buf++ & 0x7F);\n    (*buff_len)--;\n    if(length_bytes > 4) {\n      return NULL;\n    }\n    *length = (uint32_t)*buf++;\n    (*buff_len)--;\n    for(i = 1; i < length_bytes; ++i) {\n      *length <<= 8;\n      *length |= *buf++;\n      (*buff_len)--;\n    }\n  }\n  *str = (const char *)buf;\n  *buff_len -= *length;\n  return buf + *length;\n}", "target": 1}
{"code": "xfs_bmap_unmap_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_defer_ops\t*dfops,\n\tstruct xfs_inode\t*ip,\n\tstruct xfs_bmbt_irec\t*PREV)\n{\n\tif (!xfs_bmap_is_update_needed(PREV))\n\t\treturn 0;\n\treturn __xfs_bmap_add(mp, dfops, XFS_BMAP_UNMAP, ip,\n\t\t\tXFS_DATA_FORK, PREV);\n}", "target": 0}
{"code": "void _single_copy_to_wide( SQLWCHAR *out, LPCSTR in, int len )\n{\n    while ( len >= 0 )\n    {\n        *out = *in;\n        out++;\n        in++;\n        len --;\n    }\n}", "target": 0}
{"code": "static inline int alloc_debug_processing(struct kmem_cache *s,\n\tstruct page *page, void *object, void *addr) { return 0; }", "target": 0}
{"code": "void irsock_cleanup(void)\n{\n\tsock_unregister(PF_IRDA);\n\tproto_unregister(&irda_proto);\n}", "target": 0}
{"code": "static ssize_t nr_hugepages_show_common(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct hstate *h;\n\tunsigned long nr_huge_pages;\n\tint nid;\n\th = kobj_to_hstate(kobj, &nid);\n\tif (nid == NUMA_NO_NODE)\n\t\tnr_huge_pages = h->nr_huge_pages;\n\telse\n\t\tnr_huge_pages = h->nr_huge_pages_node[nid];\n\treturn sysfs_emit(buf, \"%lu\\n\", nr_huge_pages);\n}", "target": 0}
{"code": "memcmp_constant_time (const void *a, const void *b, size_t size) {\n  const uint8_t * a1 = a;\n  const uint8_t * b1 = b;\n  int ret = 0;\n  size_t i;\n  for (i = 0; i < size; i++) {\n      ret |= *a1++ ^ *b1++;\n  }\n  return ret;\n}", "target": 0}
{"code": "static int dir_contains_only_dotgit(const char *path)\n{\n\tDIR *dir = opendir(path);\n\tstruct dirent *e;\n\tint ret = 1;\n\tif (!dir)\n\t\treturn 0;\n\te = readdir_skip_dot_and_dotdot(dir);\n\tif (!e)\n\t\tret = 0;\n\telse if (strcmp(DEFAULT_GIT_DIR_ENVIRONMENT, e->d_name) ||\n\t\t (e = readdir_skip_dot_and_dotdot(dir))) {\n\t\terror(\"unexpected item '%s' in '%s'\", e->d_name, path);\n\t\tret = 0;\n\t}\n\tclosedir(dir);\n\treturn ret;\n}", "target": 0}
{"code": "inline int TensorProtoDataSize<tstring>(const TensorProto& t) {\n  return t.string_val_size();\n}", "target": 0}
{"code": "void traverse_commit_list(struct rev_info *revs,\n\t\t\t  show_commit_fn show_commit,\n\t\t\t  show_object_fn show_object,\n\t\t\t  void *data)\n{\n\tint i;\n\tstruct commit *commit;\n\tstruct strbuf base;\n\tstrbuf_init(&base, PATH_MAX);\n\twhile ((commit = get_revision(revs)) != NULL) {\n\t\tif (commit->tree)\n\t\t\tadd_pending_tree(revs, commit->tree);\n\t\tshow_commit(commit, data);\n\t}\n\tfor (i = 0; i < revs->pending.nr; i++) {\n\t\tstruct object_array_entry *pending = revs->pending.objects + i;\n\t\tstruct object *obj = pending->item;\n\t\tconst char *name = pending->name;\n\t\tconst char *path = pending->path;\n\t\tif (obj->flags & (UNINTERESTING | SEEN))\n\t\t\tcontinue;\n\t\tif (obj->type == OBJ_TAG) {\n\t\t\tobj->flags |= SEEN;\n\t\t\tshow_object(obj, NULL, name, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!path)\n\t\t\tpath = \"\";\n\t\tif (obj->type == OBJ_TREE) {\n\t\t\tprocess_tree(revs, (struct tree *)obj, show_object,\n\t\t\t\t     &base, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tif (obj->type == OBJ_BLOB) {\n\t\t\tprocess_blob(revs, (struct blob *)obj, show_object,\n\t\t\t\t     NULL, path, data);\n\t\t\tcontinue;\n\t\t}\n\t\tdie(\"unknown pending object %s (%s)\",\n\t\t    oid_to_hex(&obj->oid), name);\n\t}\n\tobject_array_clear(&revs->pending);\n\tstrbuf_release(&base);\n}", "target": 1}
{"code": "  Number_Ptr Parser::lexed_dimension(const ParserState& pstate, const std::string& parsed)\n  {\n    size_t L = parsed.length();\n    size_t num_pos = parsed.find_first_not_of(\" \\n\\r\\t\");\n    if (num_pos == std::string::npos) num_pos = L;\n    size_t unit_pos = parsed.find_first_not_of(\"-+0123456789.\", num_pos);\n    if (parsed[unit_pos] == 'e' && is_number(parsed[unit_pos+1]) ) {\n      unit_pos = parsed.find_first_not_of(\"-+0123456789.\", ++ unit_pos);\n    }\n    if (unit_pos == std::string::npos) unit_pos = L;\n    const std::string& num = parsed.substr(num_pos, unit_pos - num_pos);\n    Number_Ptr nr = SASS_MEMORY_NEW(Number,\n                                    pstate,\n                                    sass_strtod(num.c_str()),\n                                    Token(number(parsed.c_str())),\n                                    number_has_zero(parsed));\n    nr->is_interpolant(false);\n    nr->is_delayed(true);\n    return nr;\n  }", "target": 0}
{"code": "x509_vfy_callback_indicate_success(X509_STORE_CTX *ctx)\n{\n\treturn x509_vfy_internal_verify(ctx, 1);\n}", "target": 1}
{"code": "START_TEST(test_deltas_head_sort)\n{\n\tstruct deltas_head deltas;\n\tdeltas_head_init(&deltas);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 0));\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 1));\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 2));\n\tadd_serials(&deltas, 0, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 0));\n\tvalidate_serials(&deltas, 0, END);\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 2));\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 1));\n\tadd_serials(&deltas, 1, 2, 3, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 3));\n\tvalidate_serials(&deltas, 0, 1, 2, 3, END);\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 4));\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 2));\n\tdeltas_head_cleanup(&deltas, NULL);\n\tdeltas_head_init(&deltas);\n\tadd_serials(&deltas, 3, 0, 1, 2, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 3));\n\tvalidate_serials(&deltas, 0, 1, 2, 3, END);\n\tdeltas_head_cleanup(&deltas, NULL);\n\tdeltas_head_init(&deltas);\n\tadd_serials(&deltas, 4, 3, 2, 1, 0, END);\n\tck_assert_int_eq(0, deltas_head_sort(&deltas, 4));\n\tvalidate_serials(&deltas, 0, 1, 2, 3, 4, END);\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 5));\n\tck_assert_int_eq(-EINVAL, deltas_head_sort(&deltas, 3));\n\tdeltas_head_cleanup(&deltas, NULL);\n}", "target": 0}
{"code": "int ConnectionImpl::onHeadersCompleteBase() {\n  ENVOY_CONN_LOG(trace, \"headers complete\", connection_);\n  completeLastHeader();\n  ASSERT(current_header_map_->byteSize().has_value() &&\n         current_header_map_->byteSize() == current_header_map_->byteSizeInternal());\n  if (!(parser_.http_major == 1 && parser_.http_minor == 1)) {\n    protocol_ = Protocol::Http10;\n  }\n  if (Utility::isUpgrade(*current_header_map_)) {\n    if (current_header_map_->Upgrade() &&\n        absl::EqualsIgnoreCase(current_header_map_->Upgrade()->value().getStringView(),\n                               Http::Headers::get().UpgradeValues.H2c)) {\n      ENVOY_CONN_LOG(trace, \"removing unsupported h2c upgrade headers.\", connection_);\n      current_header_map_->removeUpgrade();\n      if (current_header_map_->Connection()) {\n        const auto& tokens_to_remove = caseUnorderdSetContainingUpgradeAndHttp2Settings();\n        std::string new_value = StringUtil::removeTokens(\n            current_header_map_->Connection()->value().getStringView(), \",\", tokens_to_remove, \",\");\n        if (new_value.empty()) {\n          current_header_map_->removeConnection();\n        } else {\n          current_header_map_->Connection()->value(new_value);\n        }\n      }\n      current_header_map_->remove(Headers::get().Http2Settings);\n    } else {\n      ENVOY_CONN_LOG(trace, \"codec entering upgrade mode.\", connection_);\n      handling_upgrade_ = true;\n    }\n  }\n  int rc = onHeadersComplete(std::move(current_header_map_));\n  current_header_map_.reset();\n  header_parsing_state_ = HeaderParsingState::Done;\n  return handling_upgrade_ ? 2 : rc;\n}", "target": 0}
{"code": "spnego_gss_unwrap_iov(OM_uint32 *minor_status,\n\t\t      gss_ctx_id_t context_handle,\n\t\t      int *conf_state,\n\t\t      gss_qop_t *qop_state,\n\t\t      gss_iov_buffer_desc *iov,\n\t\t      int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_iov(minor_status,\n\t\t\t     context_handle,\n\t\t\t     conf_state,\n\t\t\t     qop_state,\n\t\t\t     iov,\n\t\t\t     iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "static void sig_int_handler(int sig) {\n  struct sigaction *old = NULL;\n  switch (sig) {\n#if !FIO_DISABLE_HOT_RESTART\n  case SIGUSR1:\n    fio_signal_children_flag = 1;\n    old = &fio_old_sig_usr1;\n    break;\n#endif\n  case SIGINT:\n    if (!old)\n      old = &fio_old_sig_int;\n  case SIGTERM:\n    if (!old)\n      old = &fio_old_sig_term;\n    fio_stop();\n    break;\n  case SIGPIPE:\n    if (!old)\n      old = &fio_old_sig_pipe;\n  default:\n    break;\n  }\n  if (old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n    old->sa_handler(sig);\n}", "target": 1}
{"code": "void ChromotingInstance::PostChromotingMessage(\n    const std::string& method,\n    scoped_ptr<base::DictionaryValue> data) {\n  scoped_ptr<base::DictionaryValue> message(new base::DictionaryValue());\n  message->SetString(\"method\", method);\n  message->Set(\"data\", data.release());\n  std::string message_json;\n  base::JSONWriter::Write(message.get(), &message_json);\n  PostMessage(pp::Var(message_json));\n}", "target": 0}
{"code": "ServerSecurityFeature::ServerSecurityFeature(\n    application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"ServerSecurity\"),\n      _enableFoxxApi(true),\n      _enableFoxxStore(true),\n      _hardenedRestApi(false) {\n  setOptional(false);\n  startsAfter<application_features::GreetingsFeaturePhase>();\n}", "target": 1}
{"code": "static inline int crypto_rng_seedsize(struct crypto_rng *tfm)\n{\n\treturn tfm->seedsize;\n}", "target": 1}
{"code": "static void consume_one_event(unsigned cpu,\n\t\t\t      struct evtchn_fifo_control_block *control_block,\n\t\t\t      unsigned priority, unsigned long *ready,\n\t\t\t      bool drop)\n{\n\tstruct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);\n\tuint32_t head;\n\tevtchn_port_t port;\n\tevent_word_t *word;\n\thead = q->head[priority];\n\tif (head == 0) {\n\t\tvirt_rmb(); \n\t\thead = control_block->head[priority];\n\t}\n\tport = head;\n\tword = event_word_from_port(port);\n\thead = clear_linked(word);\n\tif (head == 0)\n\t\tclear_bit(priority, ready);\n\tif (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {\n\t\tif (unlikely(drop))\n\t\t\tpr_warn(\"Dropping pending event for port %u\\n\", port);\n\t\telse\n\t\t\thandle_irq_for_port(port);\n\t}\n\tq->head[priority] = head;\n}", "target": 1}
{"code": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\tptr++;\t\t\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}", "target": 1}
{"code": "GF_Err load_svg_run(GF_SceneLoader *load)\n{\n\tu32 in_time;\n\tGF_Err e;\n\tGF_SVG_Parser *parser = (GF_SVG_Parser *)load->loader_priv;\n\tif (!parser) {\n\t\te = gf_sm_load_initialize_svg(load, NULL, GF_FALSE);\n\t\tif (e) return e;\n\t\tparser = (GF_SVG_Parser *)load->loader_priv;\n\t}\n\tin_time = gf_sys_clock();\n\te = gf_xml_sax_parse_file(parser->sax_parser, (const char *)load->fileName, svg_progress);\n\tif (parser->last_error<0) e = parser->last_error;\n\tif (e<0) return svg_report(parser, e, \"Unable to parse file %s: %s\", load->fileName, gf_xml_sax_get_error(parser->sax_parser) );\n\tGF_LOG(GF_LOG_INFO, GF_LOG_PARSER, (\"[Parser] Scene parsed and Scene Graph built in %d ms\\n\", gf_sys_clock() - in_time));\n\tsvg_flush_animations(parser);\n\tgf_sm_svg_flush_state(parser);\n\treturn e;\n}", "target": 1}
{"code": "static int nfs4_open_recover_helper(struct nfs4_opendata *opendata, mode_t openflags, struct nfs4_state **res)\n{\n\tstruct nfs4_state *newstate;\n\tint ret;\n\topendata->o_arg.open_flags = openflags;\n\tmemset(&opendata->o_res, 0, sizeof(opendata->o_res));\n\tmemset(&opendata->c_res, 0, sizeof(opendata->c_res));\n\tnfs4_init_opendata_res(opendata);\n\tret = _nfs4_proc_open(opendata);\n\tif (ret != 0)\n\t\treturn ret; \n\tnewstate = nfs4_opendata_to_nfs4_state(opendata);\n\tif (IS_ERR(newstate))\n\t\treturn PTR_ERR(newstate);\n\tnfs4_close_state(&opendata->path, newstate, openflags);\n\t*res = newstate;\n\treturn 0;\n}", "target": 1}
{"code": "comics_document_save (EvDocument *document,\n\t\t      const char *uri,\n\t\t      GError    **error)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\treturn ev_xfer_uri_simple (comics_document->archive, uri, error);\n}", "target": 1}
{"code": "beep_print(netdissect_options *ndo, const u_char *bp, u_int length)\n{\n\tif (l_strnstart(\"MSG\", 4, (const char *)bp, length)) \n\t\tND_PRINT((ndo, \" BEEP MSG\"));\n\telse if (l_strnstart(\"RPY \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP RPY\"));\n\telse if (l_strnstart(\"ERR \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ERR\"));\n\telse if (l_strnstart(\"ANS \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP ANS\"));\n\telse if (l_strnstart(\"NUL \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP NUL\"));\n\telse if (l_strnstart(\"SEQ \", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP SEQ\"));\n\telse if (l_strnstart(\"END\", 4, (const char *)bp, length))\n\t\tND_PRINT((ndo, \" BEEP END\"));\n\telse\n\t\tND_PRINT((ndo, \" BEEP (payload or undecoded)\"));\n}", "target": 1}
{"code": "blockmix_salsa8(uint32_t * Bin, uint32_t * Bout, uint32_t * X, size_t r)\n{\n  size_t i;\n  blkcpy(X, &Bin[(2 * r - 1) * 16], 64);\n  for (i = 0; i < 2 * r; i += 2) {\n    blkxor(X, &Bin[i * 16], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 8], X, 64);\n    blkxor(X, &Bin[i * 16 + 16], 64);\n    salsa20_8(X);\n    blkcpy(&Bout[i * 8 + r * 16], X, 64);\n  }\n}", "target": 1}
{"code": "static CuckooFilter *cfCreate(RedisModuleKey *key, size_t capacity, size_t bucketSize,\n                              size_t maxIterations, size_t expansion) {\n    if (capacity < bucketSize * 2)\n        return NULL;\n    CuckooFilter *cf = RedisModule_Calloc(1, sizeof(*cf));\n    if (CuckooFilter_Init(cf, capacity, bucketSize, maxIterations, expansion) != 0) {\n        RedisModule_Free(cf); \n        cf = NULL;            \n    }\n    RedisModule_ModuleTypeSetValue(key, CFType, cf);\n    return cf;\n}", "target": 1}
{"code": "static void kvm_pv_disable_apf(void)\n{\n\tif (!__this_cpu_read(apf_reason.enabled))\n\t\treturn;\n\twrmsrl(MSR_KVM_ASYNC_PF_EN, 0);\n\t__this_cpu_write(apf_reason.enabled, 0);\n\tprintk(KERN_INFO\"Unregister pv shared memory for cpu %d\\n\",\n\t       smp_processor_id());\n}", "target": 0}
{"code": "netsnmp_mibindex_new( const char *dirname )\n{\n    FILE *fp;\n    char  tmpbuf[300];\n    char *cp;\n    int   i;\n    cp = netsnmp_mibindex_lookup( dirname );\n    if (!cp) {\n        i  = _mibindex_add( dirname, -1 );\n        snprintf( tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                  get_persistent_directory(), i );\n        tmpbuf[sizeof(tmpbuf)-1] = 0;\n        cp = tmpbuf;\n    }\n    DEBUGMSGTL((\"mibindex\", \"new: %s (%s)\\n\", dirname, cp ));\n    fp = fopen( cp, \"w\" );\n    if (fp)\n        fprintf( fp, \"DIR %s\\n\", dirname );\n    return fp;\n}", "target": 1}
{"code": "unsigned int get_random_int(void)\n{\n\tstruct keydata *keyptr;\n\t__u32 *hash = get_cpu_var(get_random_int_hash);\n\tint ret;\n\tkeyptr = get_keyptr();\n\thash[0] += current->pid + jiffies + get_cycles();\n\tret = half_md4_transform(hash, keyptr->secret);\n\tput_cpu_var(get_random_int_hash);\n\treturn ret;\n}", "target": 1}
{"code": "mptctl_mpt_command (unsigned long arg)\n{\n\tstruct mpt_ioctl_command __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_command  karg;\n\tMPT_ADAPTER\t*ioc;\n\tint\t\tiocnum;\n\tint\t\trc;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_command))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_mpt_command - \"\n\t\t\t\"Unable to read in mpt_ioctl_command struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_mpt_command() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\trc = mptctl_do_mpt_command (karg, &uarg->MF);\n\treturn rc;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* const context) override {\n    const Tensor* node_ids_t;\n    OP_REQUIRES_OK(context, context->input(\"node_ids\", &node_ids_t));\n    const auto node_ids = node_ids_t->vec<int32>();\n    const Tensor* gradients_t;\n    OP_REQUIRES_OK(context, context->input(\"gradients\", &gradients_t));\n    const auto gradients = gradients_t->matrix<float>();\n    OP_REQUIRES(\n        context, node_ids.size() == gradients.dimension(0),\n        errors::InvalidArgument(\n            \"node_ids size should match 0th dim of gradients. node ids \"\n            \"size: \",\n            node_ids.size(), \", gradients dim0: \", gradients.dimension(0)));\n    const Tensor* hessians_t;\n    OP_REQUIRES_OK(context, context->input(\"hessians\", &hessians_t));\n    const auto hessians = hessians_t->matrix<float>();\n    OpInputList bucketized_features_list;\n    OP_REQUIRES_OK(context, context->input_list(\"bucketized_features_list\",\n                                                &bucketized_features_list));\n    const int64_t batch_size = node_ids_t->dim_size(0);\n    Tensor temp_stats_double_t;\n    OP_REQUIRES_OK(context, context->allocate_temp(\n                                DT_DOUBLE,\n                                {num_features_, max_splits_, num_buckets_, 2},\n                                &temp_stats_double_t));\n    auto temp_stats_double = temp_stats_double_t.tensor<double, 4>();\n    temp_stats_double.setZero();\n    for (int feature_idx = 0; feature_idx < num_features_; ++feature_idx) {\n      const auto& features = bucketized_features_list[feature_idx].vec<int32>();\n      for (int i = 0; i < batch_size; ++i) {\n        const int32_t node = node_ids(i);\n        const int32_t bucket = features(i);\n        temp_stats_double(feature_idx, node, bucket, 0) += gradients(i, 0);\n        temp_stats_double(feature_idx, node, bucket, 1) += hessians(i, 0);\n      }\n    }\n    Tensor* output_stats_summary_t = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(\n                                \"stats_summary\", temp_stats_double_t.shape(),\n                                &output_stats_summary_t));\n    output_stats_summary_t->tensor<float, 4>() =\n        temp_stats_double.template cast<float>();\n  }", "target": 0}
{"code": "psf_close (SF_PRIVATE *psf)\n{\tuint32_t k ;\n\tint\terror = 0 ;\n\tif (psf->codec_close)\n\t{\terror = psf->codec_close (psf) ;\n\t\tpsf->codec_close = NULL ;\n\t\t} ;\n\tif (psf->container_close)\n\t\terror = psf->container_close (psf) ;\n\terror = psf_fclose (psf) ;\n\tpsf_close_rsrc (psf) ;\n\tfree (psf->header.ptr) ;\n\tfree (psf->container_data) ;\n\tfree (psf->codec_data) ;\n\tfree (psf->interleave) ;\n\tfree (psf->dither) ;\n\tfree (psf->peak_info) ;\n\tfree (psf->broadcast_16k) ;\n\tfree (psf->loop_info) ;\n\tfree (psf->instrument) ;\n\tfree (psf->cues) ;\n\tfree (psf->channel_map) ;\n\tfree (psf->format_desc) ;\n\tfree (psf->strings.storage) ;\n\tif (psf->wchunks.chunks)\n\t\tfor (k = 0 ; k < psf->wchunks.used ; k++)\n\t\t\tfree (psf->wchunks.chunks [k].data) ;\n\tfree (psf->rchunks.chunks) ;\n\tfree (psf->wchunks.chunks) ;\n\tfree (psf->iterator) ;\n\tfree (psf->cart_16k) ;\n\tmemset (psf, 0, sizeof (SF_PRIVATE)) ;\n\tfree (psf) ;\n\treturn error ;\n} ", "target": 0}
{"code": "int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,\n\t\t\t  __be32 saddr, __be32 daddr, struct ip_options *opt)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct iphdr *iph;\n\tskb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tiph->version  = 4;\n\tiph->ihl      = 5;\n\tiph->tos      = inet->tos;\n\tif (ip_dont_fragment(sk, &rt->dst))\n\t\tiph->frag_off = htons(IP_DF);\n\telse\n\t\tiph->frag_off = 0;\n\tiph->ttl      = ip_select_ttl(inet, &rt->dst);\n\tiph->daddr    = rt->rt_dst;\n\tiph->saddr    = rt->rt_src;\n\tiph->protocol = sk->sk_protocol;\n\tip_select_ident(iph, &rt->dst, sk);\n\tif (opt && opt->optlen) {\n\t\tiph->ihl += opt->optlen>>2;\n\t\tip_options_build(skb, opt, daddr, rt, 0);\n\t}\n\tskb->priority = sk->sk_priority;\n\tskb->mark = sk->sk_mark;\n\treturn ip_local_out(skb);\n}", "target": 1}
{"code": "static int slim_rx_mux_get(struct snd_kcontrol *kc,\n\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct snd_soc_dapm_context *dapm = snd_soc_dapm_kcontrol_dapm(kc);\n\tstruct wcd9335_codec *wcd = dev_get_drvdata(dapm->dev);\n\tucontrol->value.enumerated.item[0] = wcd->rx_port_value;\n\treturn 0;\n}", "target": 0}
{"code": "epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}", "target": 1}
{"code": "DownloadResult downloadFile(string url, string expectedETag)\n{\n    DownloadResult res;\n    Curl curl;\n    if (curl.fetch(url, expectedETag)) {\n        res.cached = false;\n        res.data = curl.data;\n    } else\n        res.cached = true;\n    res.etag = curl.etag;\n    return res;\n}", "target": 1}
{"code": "int string_rfind(const char *input, int len, const char *s, int s_len,\n                 int pos, bool case_sensitive) {\n  assertx(input);\n  assertx(s);\n  if (!s_len || pos < -len || pos > len) {\n    return -1;\n  }\n  void *ptr;\n  if (case_sensitive) {\n    if (pos >= 0) {\n      ptr = bstrrstr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrstr(input, len + pos + s_len, s, s_len);\n    }\n  } else {\n    if (pos >= 0) {\n      ptr = bstrrcasestr(input + pos, len - pos, s, s_len);\n    } else {\n      ptr = bstrrcasestr(input, len + pos + s_len, s, s_len);\n    }\n  }\n  if (ptr != nullptr) {\n    return (int)((const char *)ptr - input);\n  }\n  return -1;\n}", "target": 1}
{"code": "static void mov_parse_stsd_subtitle(MOVContext *c, AVIOContext *pb,\n                                    AVStream *st, MOVStreamContext *sc,\n                                    int64_t size)\n{\n    MOVAtom fake_atom = { .size = size };\n    if (st->codecpar->codec_tag != AV_RL32(\"mp4s\"))\n        mov_read_glbl(c, pb, fake_atom);\n    st->codecpar->width  = sc->width;\n    st->codecpar->height = sc->height;\n}", "target": 0}
{"code": "static void reds_update_agent_properties(RedsState *reds)\n{\n    if (!reds->agent_dev || reds->config == NULL) {\n        return;\n    }\n    reds->agent_dev->priv->write_filter.copy_paste_enabled = reds->config->agent_copypaste;\n    reds->agent_dev->priv->read_filter.copy_paste_enabled = reds->config->agent_copypaste;\n    reds->agent_dev->priv->write_filter.file_xfer_enabled = reds->config->agent_file_xfer;\n    reds->agent_dev->priv->read_filter.file_xfer_enabled = reds->config->agent_file_xfer;\n}", "target": 0}
{"code": "struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,\n\t\t\t\t   const struct sk_buff *skb,\n\t\t\t\t   int flags, pol_lookup_t lookup)\n{\n\tstruct rt6_info *rt;\n\trt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);\n\tif (rt->dst.error == -EAGAIN) {\n\t\tip6_rt_put_flags(rt, flags);\n\t\trt = net->ipv6.ip6_null_entry;\n\t\tif (!(flags | RT6_LOOKUP_F_DST_NOREF))\n\t\t\tdst_hold(&rt->dst);\n\t}\n\treturn &rt->dst;\n}", "target": 1}
{"code": "lys_restr_dup(struct lys_module *mod, struct lys_restr *old, int size, int shallow, struct unres_schema *unres)\n{\n    struct lys_restr *result;\n    int i;\n    if (!size) {\n        return NULL;\n    }\n    result = calloc(size, sizeof *result);\n    LY_CHECK_ERR_RETURN(!result, LOGMEM(mod->ctx), NULL);\n    for (i = 0; i < size; i++) {\n        result[i].ext_size = old[i].ext_size;\n        lys_ext_dup(mod->ctx, mod, old[i].ext, old[i].ext_size, &result[i], LYEXT_PAR_RESTR, &result[i].ext, shallow, unres);\n        result[i].expr = lydict_insert(mod->ctx, old[i].expr, 0);\n        result[i].dsc = lydict_insert(mod->ctx, old[i].dsc, 0);\n        result[i].ref = lydict_insert(mod->ctx, old[i].ref, 0);\n        result[i].eapptag = lydict_insert(mod->ctx, old[i].eapptag, 0);\n        result[i].emsg = lydict_insert(mod->ctx, old[i].emsg, 0);\n    }\n    return result;\n}", "target": 1}
{"code": "get_image_extensions(void)\n{\n\tGHashTable *extensions;\n\tGSList *formats = gdk_pixbuf_get_formats ();\n\tGSList *l;\n\tguint i;\n\tconst char *known_image_formats[] = {\n\t\t\"png\",\n\t\t\"jpg\",\n\t\t\"jpeg\",\n\t\t\"webp\"\n\t};\n\textensions = g_hash_table_new_full (g_str_hash, g_str_equal,\n\t\t\t\t\t    g_free, NULL);\n\tfor (l = formats; l != NULL; l = l->next) {\n\t\tint i;\n\t\tgchar **ext = gdk_pixbuf_format_get_extensions (l->data);\n\t\tfor (i = 0; ext[i] != NULL; i++) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (ext[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_SUPPORTED));\n\t\t}\n\t\tg_strfreev (ext);\n\t}\n\tg_slist_free (formats);\n\tfor (i = 0; i < G_N_ELEMENTS (known_image_formats); i++) {\n\t\tif (!g_hash_table_lookup (extensions, known_image_formats[i])) {\n\t\t\tg_hash_table_insert (extensions,\n\t\t\t\t\t     g_strdup (known_image_formats[i]),\n\t\t\t\t\t     GINT_TO_POINTER (FORMAT_UNSUPPORTED));\n\t\t}\n\t}\n\treturn extensions;\n}", "target": 0}
{"code": "void CLASS bad_pixels (const char *cfname)\n{\n  FILE *fp=NULL;\n#ifndef LIBRAW_LIBRARY_BUILD\n  char *fname, *cp, line[128];\n  int len, time, row, col, r, c, rad, tot, n, fixed=0;\n#else\n  char *cp, line[128];\n  int time, row, col, r, c, rad, tot, n;\n#ifdef DCRAW_VERBOSE\n  int fixed = 0;\n#endif\n#endif\n  if (!filters) return;\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,0,2);\n#endif\n  if (cfname)\n    fp = fopen (cfname, \"r\");\n#line 4151 \"dcraw/dcraw.c\"\n  if (!fp)\n      {\n#ifdef LIBRAW_LIBRARY_BUILD\n          imgdata.process_warnings |= LIBRAW_WARN_NO_BADPIXELMAP;\n#endif\n          return;\n      }\n  while (fgets (line, 128, fp)) {\n    cp = strchr (line, '#');\n    if (cp) *cp = 0;\n    if (sscanf (line, \"%d %d %d\", &col, &row, &time) != 3) continue;\n    if ((unsigned) col >= width || (unsigned) row >= height) continue;\n    if (time > timestamp) continue;\n    for (tot=n=0, rad=1; rad < 3 && n==0; rad++)\n      for (r = row-rad; r <= row+rad; r++)\n\tfor (c = col-rad; c <= col+rad; c++)\n\t  if ((unsigned) r < height && (unsigned) c < width &&\n\t\t(r != row || c != col) && fcol(r,c) == fcol(row,col)) {\n\t    tot += BAYER2(r,c);\n\t    n++;\n\t  }\n    BAYER2(row,col) = tot/n;\n#ifdef DCRAW_VERBOSE\n    if (verbose) {\n      if (!fixed++)\n\tfprintf (stderr,_(\"Fixed dead pixels at:\"));\n      fprintf (stderr, \" %d,%d\", col, row);\n    }\n#endif\n  }\n#ifdef DCRAW_VERBOSE\n  if (fixed) fputc ('\\n', stderr);\n#endif\n  fclose (fp);\n#ifdef LIBRAW_LIBRARY_BUILD\n  RUN_CALLBACK(LIBRAW_PROGRESS_BAD_PIXELS,1,2);\n#endif\n}", "target": 1}
{"code": "MagickExport int LocaleLowercase(const int c)\n{\n  if (c == EOF)\n    return(c);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(tolower_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(tolower((int) ((unsigned char) c)));\n}", "target": 0}
{"code": "char *QuotedString::extractFrom(char *input, char **endPtr) {\n  char firstChar = *input;\n  if (!isQuote(firstChar)) {\n    return NULL;\n  }\n  char stopChar = firstChar;  \n  char *startPtr = input + 1;  \n  char *readPtr = startPtr;\n  char *writePtr = startPtr;\n  char c;\n  for (;;) {\n    c = *readPtr++;\n    if (c == '\\0') {\n      return NULL;\n    }\n    if (c == stopChar) {\n      break;\n    }\n    if (c == '\\\\') {\n      c = unescapeChar(*readPtr++);\n    }\n    *writePtr++ = c;\n  }\n  *writePtr = '\\0';\n  *endPtr = readPtr;\n  return startPtr;\n}", "target": 1}
{"code": "void error_handler(int priority, const char *format, ...)\n{\n    gdTestAssert(priority == GD_WARNING);\n    gdTestAssert(!strcmp(format, MSG));\n}", "target": 0}
{"code": "DEFINE_TRACE(ContainerNode)\n{\n    visitor->trace(m_firstChild);\n    visitor->trace(m_lastChild);\n    Node::trace(visitor);\n}", "target": 0}
{"code": "static void do_free_publickey(struct rsa_public_key *s)\n{\n\tif (s) {\n\t\tcrypto_bignum_free(s->n);\n\t\tcrypto_bignum_free(s->e);\n\t}\n}", "target": 1}
{"code": "max3421_urb_done(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint status;\n\tstatus = max3421_hcd->urb_done;\n\tmax3421_hcd->urb_done = 0;\n\tif (status > 0)\n\t\tstatus = 0;\n\turb = max3421_hcd->curr_urb;\n\tif (urb) {\n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\tint rcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tint sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tint epnum = usb_endpoint_num(&urb->ep->desc);\n\t\tusb_settoggle(urb->dev, epnum, 0, rcvtog);\n\t\tusb_settoggle(urb->dev, epnum, 1, sndtog);\n\t\tmax3421_hcd->curr_urb = NULL;\n\t\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\t\tusb_hcd_giveback_urb(hcd, urb, status);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "  bool verify_authorizer(Connection *con, int peer_type, int protocol, bufferlist& auth, bufferlist& auth_reply,\n                         bool& isvalid, CryptoKey& session_key) {\n    return ms_deliver_verify_authorizer(con, peer_type, protocol, auth,\n                                        auth_reply, isvalid, session_key);\n  }", "target": 1}
{"code": "static Jsi_RC NumberToExponentialCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<0) prec = 0;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf), \"%.*\" JSI_NUMEFMT, prec, num);\n#ifdef __WIN32\n    char *e = strrchr(buf, 'e');\n    if (e && (e[1]=='+' || e[1]=='-')) {\n        e++;\n        int eNum = atoi(e);\n        if (e[0]=='-')\n            eNum = -eNum;\n        e++;\n        snprintf(e, (e-buf), \"%02d\", eNum);\n    }\n#endif\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}", "target": 1}
{"code": "void svhandler_flash_pgm_blk(void) {\n  uint32_t beginAddr = _param_1;\n  uint32_t data = _param_2;\n  uint32_t length = _param_3;\n  if (beginAddr + length < beginAddr) return;\n  if (((beginAddr >= BSTRP_FLASH_SECT_START) &&\n       (beginAddr <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1))) ||\n      (((beginAddr + length) >= BSTRP_FLASH_SECT_START) &&\n       ((beginAddr + length) <=\n        (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN - 1)))) {\n    return;\n  }\n  if (((beginAddr >= BLDR_FLASH_SECT_START) &&\n       (beginAddr <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1))) ||\n      (((beginAddr + length) >= BLDR_FLASH_SECT_START) &&\n       ((beginAddr + length) <=\n        (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN - 1)))) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_program(beginAddr, (uint8_t *)data, length);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "static void *smm_stub_place_stacks(char *base, size_t size,\n\t\t\t\t   struct smm_loader_params *params)\n{\n\tsize_t total_stack_size;\n\tchar *stacks_top;\n\ttotal_stack_size = params->per_cpu_stack_size *\n\t\t\t   params->num_concurrent_stacks;\n\tprintk(BIOS_DEBUG, \"%s: cpus: %zx : stack space: needed -> %zx\\n\",\n\t\t__func__, params->num_concurrent_stacks,\n\t\ttotal_stack_size);\n\tprintk(BIOS_DEBUG, \"  available -> %zx : per_cpu_stack_size : %zx\\n\",\n\t\tsize, params->per_cpu_stack_size);\n\tif (params->num_concurrent_stacks < 1)\n\t\treturn NULL;\n\tif (total_stack_size > size)\n\t\treturn NULL;\n\tstacks_top = &base[total_stack_size];\n\tprintk(BIOS_DEBUG, \"%s: exit, stack_top %p\\n\", __func__, stacks_top);\n\treturn stacks_top;\n}", "target": 0}
{"code": "      DSA_Verification_Operation(const DSA_PublicKey& dsa,\n                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {}", "target": 1}
{"code": "static char *mongo_data_append( char *start , const void *data , int len ) {\n    memcpy( start , data , len );\n    return start + len;\n}", "target": 1}
{"code": "nvmet_fc_find_target_queue(struct nvmet_fc_tgtport *tgtport,\n\t\t\t\tu64 connection_id)\n{\n\tstruct nvmet_fc_tgt_assoc *assoc;\n\tstruct nvmet_fc_tgt_queue *queue;\n\tu64 association_id = nvmet_fc_getassociationid(connection_id);\n\tu16 qid = nvmet_fc_getqueueid(connection_id);\n\tunsigned long flags;\n\tif (qid > NVMET_NR_QUEUES)\n\t\treturn NULL;\n\tspin_lock_irqsave(&tgtport->lock, flags);\n\tlist_for_each_entry(assoc, &tgtport->assoc_list, a_list) {\n\t\tif (association_id == assoc->association_id) {\n\t\t\tqueue = assoc->queues[qid];\n\t\t\tif (queue &&\n\t\t\t    (!atomic_read(&queue->connected) ||\n\t\t\t     !nvmet_fc_tgt_q_get(queue)))\n\t\t\t\tqueue = NULL;\n\t\t\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\t\t\treturn queue;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tgtport->lock, flags);\n\treturn NULL;\n}", "target": 0}
{"code": "sshsk_open(const char *path)\n{\n\tstruct sshsk_provider *ret = NULL;\n\tuint32_t version;\n\tif (path == NULL || *path == '\\0') {\n\t\terror(\"No FIDO SecurityKeyProvider specified\");\n\t\treturn NULL;\n\t}\n\tif ((ret = calloc(1, sizeof(*ret))) == NULL) {\n\t\terror_f(\"calloc failed\");\n\t\treturn NULL;\n\t}\n\tif ((ret->path = strdup(path)) == NULL) {\n\t\terror_f(\"strdup failed\");\n\t\tgoto fail;\n\t}\n\tif (strcasecmp(ret->path, \"internal\") == 0) {\n\t\tret->sk_enroll = ssh_sk_enroll;\n\t\tret->sk_sign = ssh_sk_sign;\n\t\tret->sk_load_resident_keys = ssh_sk_load_resident_keys;\n\t\treturn ret;\n\t}\n\tif ((ret->dlhandle = dlopen(path, RTLD_NOW)) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlopen failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_api_version = dlsym(ret->dlhandle,\n\t    \"sk_api_version\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_api_version) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tversion = ret->sk_api_version();\n\tdebug_f(\"provider %s implements version 0x%08lx\", ret->path,\n\t    (u_long)version);\n\tif ((version & SSH_SK_VERSION_MAJOR_MASK) != SSH_SK_VERSION_MAJOR) {\n\t\terror(\"Provider \\\"%s\\\" implements unsupported \"\n\t\t    \"version 0x%08lx (supported: 0x%08lx)\",\n\t\t    path, (u_long)version, (u_long)SSH_SK_VERSION_MAJOR);\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_enroll = dlsym(ret->dlhandle, \"sk_enroll\")) == NULL) {\n\t\terror(\"Provider %s dlsym(sk_enroll) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_sign = dlsym(ret->dlhandle, \"sk_sign\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_sign) failed: %s\",\n\t\t    path, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((ret->sk_load_resident_keys = dlsym(ret->dlhandle,\n\t    \"sk_load_resident_keys\")) == NULL) {\n\t\terror(\"Provider \\\"%s\\\" dlsym(sk_load_resident_keys) \"\n\t\t    \"failed: %s\", path, dlerror());\n\t\tgoto fail;\n\t}\n\treturn ret;\nfail:\n\tsshsk_free(ret);\n\treturn NULL;\n}", "target": 1}
{"code": "void ThreadWatcher::StartWatching(const WatchingParams& params) {\n  DCHECK_GE(params.sleep_time.InMilliseconds(), 0);\n  DCHECK_GE(params.unresponsive_time.InMilliseconds(),\n            params.sleep_time.InMilliseconds());\n  if (!WatchDogThread::CurrentlyOnWatchDogThread()) {\n    WatchDogThread::PostTask(\n        FROM_HERE,\n        base::Bind(&ThreadWatcher::StartWatching, params));\n    return;\n  }\n  DCHECK(WatchDogThread::CurrentlyOnWatchDogThread());\n  ThreadWatcher* watcher = new ThreadWatcher(params);\n  DCHECK(watcher);\n  if (!ThreadWatcherList::IsRegistered(params.thread_id))\n    return;\n  watcher->ActivateThreadWatching();\n}", "target": 0}
{"code": "MOBI_RET mobi_trie_insert_infl(MOBITrie **root, const MOBIIndx *indx, size_t i) {\n    MOBIIndexEntry e = indx->entries[i];\n    char *inflected = e.label;\n    for (size_t j = 0; j < e.tags_count; j++) {\n        MOBIIndexTag t = e.tags[j];\n        if (t.tagid == INDX_TAGARR_INFL_PARTS_V1) {\n            for (size_t k = 0; k < t.tagvalues_count - 1; k += 2) {\n                uint32_t len = t.tagvalues[k];\n                uint32_t offset = t.tagvalues[k + 1];\n                char *base = mobi_get_cncx_string_flat(indx->cncx_record, offset, len);\n                if (base == NULL) {\n                    return MOBI_MALLOC_FAILED;\n                }\n                MOBI_RET ret = mobi_trie_insert_reversed(root, base, inflected);\n                free(base);\n                if (ret != MOBI_SUCCESS) {\n                    return ret;\n                }\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n}", "target": 1}
{"code": "void fio_signal_handler_reset(void) {\n  struct sigaction old;\n  if (!fio_old_sig_int.sa_handler)\n    return;\n  memset(&old, 0, sizeof(old));\n  sigaction(SIGINT, &fio_old_sig_int, &old);\n  sigaction(SIGTERM, &fio_old_sig_term, &old);\n  sigaction(SIGPIPE, &fio_old_sig_pipe, &old);\n  if (fio_old_sig_chld.sa_handler)\n    sigaction(SIGCHLD, &fio_old_sig_chld, &old);\n#if !FIO_DISABLE_HOT_RESTART\n  sigaction(SIGUSR1, &fio_old_sig_usr1, &old);\n  memset(&fio_old_sig_usr1, 0, sizeof(fio_old_sig_usr1));\n#endif\n  memset(&fio_old_sig_int, 0, sizeof(fio_old_sig_int));\n  memset(&fio_old_sig_term, 0, sizeof(fio_old_sig_term));\n  memset(&fio_old_sig_pipe, 0, sizeof(fio_old_sig_pipe));\n  memset(&fio_old_sig_chld, 0, sizeof(fio_old_sig_chld));\n}", "target": 1}
{"code": "static void vhost_net_ubuf_put_and_wait(struct vhost_net_ubuf_ref *ubufs)\n{\n\tkref_put(&ubufs->kref, vhost_net_zerocopy_done_signal);\n\twait_event(ubufs->wait, !atomic_read(&ubufs->kref.refcount));\n}", "target": 0}
{"code": "int js_isuserdata(js_State *J, int idx, const char *tag)\n{\n\tjs_Value *v = stackidx(J, idx);\n\tif (v->type == JS_TOBJECT && v->u.object->type == JS_CUSERDATA)\n\t\treturn !strcmp(tag, v->u.object->u.user.tag);\n\treturn 0;\n}", "target": 0}
{"code": "int infra_wait_limit_allowed(struct infra_cache* infra, struct comm_reply* rep,\n\tint cookie_valid, struct config_file* cfg)\n{\n\tstruct lruhash_entry* entry;\n\tif(cfg->wait_limit == 0)\n\t\treturn 1;\n\tentry = infra_find_ip_ratedata(infra, &rep->client_addr,\n\t\trep->client_addrlen, 0);\n\tif(entry) {\n\t\trbtree_type* tree;\n\t\tstruct wait_limit_netblock_info* w;\n\t\tstruct rate_data* d = (struct rate_data*)entry->data;\n\t\tint mesh_wait = d->mesh_wait;\n\t\tlock_rw_unlock(&entry->lock);\n\t\tif(cookie_valid)\n\t\t\ttree = &infra->wait_limits_cookie_netblock;\n\t\telse\ttree = &infra->wait_limits_netblock;\n\t\tw = (struct wait_limit_netblock_info*)addr_tree_lookup(tree,\n\t\t\t&rep->client_addr, rep->client_addrlen);\n\t\tif(w) {\n\t\t\tif(w->limit != -1 && mesh_wait > w->limit)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif(mesh_wait > (cookie_valid?cfg->wait_limit_cookie:\n\t\t\t\tcfg->wait_limit))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "void mb2_cache_entry_touch(struct mb2_cache *cache,\n\t\t\t   struct mb2_cache_entry *entry)\n{\n\tspin_lock(&cache->c_lru_list_lock);\n\tif (!list_empty(&entry->e_lru_list))\n\t\tlist_move_tail(&cache->c_lru_list, &entry->e_lru_list);\n\tspin_unlock(&cache->c_lru_list_lock);\n}", "target": 0}
{"code": "NavigatorServiceWorker::NavigatorServiceWorker(Navigator& navigator)\n    : DOMWindowProperty(navigator.frame())\n{\n}", "target": 0}
{"code": "mptctl_fw_download(unsigned long arg)\n{\n\tstruct mpt_fw_xfer __user *ufwdl = (void __user *) arg;\n\tstruct mpt_fw_xfer\t kfwdl;\n\tif (copy_from_user(&kfwdl, ufwdl, sizeof(struct mpt_fw_xfer))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::_ioctl_fwdl - \"\n\t\t\t\t\"Unable to copy mpt_fw_xfer struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, ufwdl);\n\t\treturn -EFAULT;\n\t}\n\treturn mptctl_do_fw_download(kfwdl.iocnum, kfwdl.bufp, kfwdl.fwlen);\n}", "target": 1}
{"code": "int password_equal(const char *user_input, const char *secret) {\n    size_t i = 0;\n    size_t j = 0;\n    char out = 0;\n    while (1) {\n        out |= user_input[i] ^ secret[j];\n        if (user_input[i] == 0) break;\n        i++;\n        if (secret[j] != 0) j++;\n    }\n    out |= (i != j); \n    out |= (secret[j] != 0); \n    return out == 0;\n}", "target": 0}
{"code": "static inline ut64 dwarf_read_address(size_t size, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tswitch (size) {\n\t\tcase 2:\n\t\tresult = READ16 (*buf); break;\n\t\tcase 4:\n\t\tresult = READ32 (*buf); break;\n\t\tcase 8:\n\t\tresult = READ64 (*buf); break;\n\t\tdefault:\n\t\tresult = 0;\n\t\t*buf += size;\n\t\teprintf (\"Weird dwarf address size: %zu.\", size);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static int hashtable_do_rehash(hashtable_t *hashtable)\n{\n    list_t *list, *next;\n    pair_t *pair;\n    size_t i, index, new_size;\n    jsonp_free(hashtable->buckets);\n    hashtable->num_buckets++;\n    new_size = num_buckets(hashtable);\n    hashtable->buckets = jsonp_malloc(new_size * sizeof(bucket_t));\n    if(!hashtable->buckets)\n        return -1;\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list = hashtable->list.next;\n    list_init(&hashtable->list);\n    for(; list != &hashtable->list; list = next) {\n        next = list->next;\n        pair = list_to_pair(list);\n        index = pair->hash % new_size;\n        insert_to_bucket(hashtable, &hashtable->buckets[index], &pair->list);\n    }\n    return 0;\n}", "target": 1}
{"code": "void xmlrpc_char_encode(char *outbuffer, const char *s1)\n{\n\tlong unsigned int i;\n\tunsigned char c;\n\tchar buf2[15];\n\tmowgli_string_t *s = mowgli_string_create();\n\t*buf2 = '\\0';\n\t*outbuffer = '\\0';\n\tif ((!(s1) || (*(s1) == '\\0')))\n\t{\n\t\treturn;\n\t}\n\tfor (i = 0; s1[i] != '\\0'; i++)\n\t{\n\t\tc = s1[i];\n\t\tif (c > 127)\n\t\t{\n\t\t\tsnprintf(buf2, sizeof buf2, \"&#%d;\", c);\n\t\t\ts->append(s, buf2, strlen(buf2));\n\t\t}\n\t\telse if (c == '&')\n\t\t{\n\t\t\ts->append(s, \"&amp;\", 5);\n\t\t}\n\t\telse if (c == '<')\n\t\t{\n\t\t\ts->append(s, \"&lt;\", 4);\n\t\t}\n\t\telse if (c == '>')\n\t\t{\n\t\t\ts->append(s, \"&gt;\", 4);\n\t\t}\n\t\telse if (c == '\"')\n\t\t{\n\t\t\ts->append(s, \"&quot;\", 6);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ts->append_char(s, c);\n\t\t}\n\t}\n\tmemcpy(outbuffer, s->str, XMLRPC_BUFSIZE);\n}", "target": 1}
{"code": "validate_commit_metadata (GVariant   *commit_data,\n                          const char *ref,\n                          const char *required_metadata,\n                          gsize       required_metadata_size,\n                          GError   **error)\n{\n  g_autoptr(GVariant) commit_metadata = NULL;\n  g_autoptr(GVariant) xa_metadata_v = NULL;\n  const char *xa_metadata = NULL;\n  gsize xa_metadata_size = 0;\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  if (commit_metadata != NULL)\n    {\n      xa_metadata_v = g_variant_lookup_value (commit_metadata,\n                                              \"xa.metadata\",\n                                              G_VARIANT_TYPE_STRING);\n      if (xa_metadata_v)\n        xa_metadata = g_variant_get_string (xa_metadata_v, &xa_metadata_size);\n    }\n  if (xa_metadata == NULL ||\n      xa_metadata_size != required_metadata_size ||\n      memcmp (xa_metadata, required_metadata, xa_metadata_size) != 0)\n    {\n      g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                   _(\"Commit metadata for %s not matching expected metadata\"), ref);\n      return FALSE;\n    }\n  return TRUE;\n}", "target": 0}
{"code": "BOOL freerdp_bitmap_planar_context_reset(BITMAP_PLANAR_CONTEXT* context, UINT32 width,\n                                         UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\tcontext->bgr = FALSE;\n\tcontext->maxWidth = PLANAR_ALIGN(width, 4);\n\tcontext->maxHeight = PLANAR_ALIGN(height, 4);\n\tconst UINT64 tmp = (UINT64)context->maxWidth * context->maxHeight;\n\tif (tmp > UINT32_MAX)\n\t\treturn FALSE;\n\tcontext->maxPlaneSize = tmp;\n\tif (context->maxWidth > UINT32_MAX / 4)\n\t\treturn FALSE;\n\tcontext->nTempStep = context->maxWidth * 4;\n\tmemset(context->planes, 0, sizeof(context->planes));\n\tmemset(context->rlePlanes, 0, sizeof(context->rlePlanes));\n\tmemset(context->deltaPlanes, 0, sizeof(context->deltaPlanes));\n\tif (context->maxPlaneSize > 0)\n\t{\n\t\tvoid* tmp = winpr_aligned_recalloc(context->planesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->planesBuffer = tmp;\n\t\ttmp = winpr_aligned_recalloc(context->pTempData, context->maxPlaneSize, 6, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->pTempData = tmp;\n\t\ttmp = winpr_aligned_recalloc(context->deltaPlanesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->deltaPlanesBuffer = tmp;\n\t\ttmp = winpr_aligned_recalloc(context->rlePlanesBuffer, context->maxPlaneSize, 4, 32);\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\t\tcontext->rlePlanesBuffer = tmp;\n\t\tcontext->planes[0] = &context->planesBuffer[context->maxPlaneSize * 0];\n\t\tcontext->planes[1] = &context->planesBuffer[context->maxPlaneSize * 1];\n\t\tcontext->planes[2] = &context->planesBuffer[context->maxPlaneSize * 2];\n\t\tcontext->planes[3] = &context->planesBuffer[context->maxPlaneSize * 3];\n\t\tcontext->deltaPlanes[0] = &context->deltaPlanesBuffer[context->maxPlaneSize * 0];\n\t\tcontext->deltaPlanes[1] = &context->deltaPlanesBuffer[context->maxPlaneSize * 1];\n\t\tcontext->deltaPlanes[2] = &context->deltaPlanesBuffer[context->maxPlaneSize * 2];\n\t\tcontext->deltaPlanes[3] = &context->deltaPlanesBuffer[context->maxPlaneSize * 3];\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "s_free(STREAM s)\n{\n\tfree(s->data);\n\tfree(s);\n}", "target": 0}
{"code": "static enum sctp_ierror sctp_process_unk_param(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\tunion sctp_params param,\n\t\t\t\t\tstruct sctp_chunk *chunk,\n\t\t\t\t\tstruct sctp_chunk **errp)\n{\n\tint retval = SCTP_IERROR_NO_ERROR;\n\tswitch (param.p->type & SCTP_PARAM_ACTION_MASK) {\n\tcase SCTP_PARAM_ACTION_DISCARD:\n\t\tretval =  SCTP_IERROR_ERROR;\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_SKIP:\n\t\tbreak;\n\tcase SCTP_PARAM_ACTION_DISCARD_ERR:\n\t\tretval =  SCTP_IERROR_ERROR;\n\tcase SCTP_PARAM_ACTION_SKIP_ERR:\n\t\tif (NULL == *errp)\n\t\t\t*errp = sctp_make_op_error_fixed(asoc, chunk);\n\t\tif (*errp) {\n\t\t\tif (!sctp_init_cause_fixed(*errp, SCTP_ERROR_UNKNOWN_PARAM,\n\t\t\t\t\tSCTP_PAD4(ntohs(param.p->length))))\n\t\t\t\tsctp_addto_chunk_fixed(*errp,\n\t\t\t\t\t\tSCTP_PAD4(ntohs(param.p->length)),\n\t\t\t\t\t\tparam.v);\n\t\t} else {\n\t\t\tretval = SCTP_IERROR_NOMEM;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn retval;\n}", "target": 0}
{"code": "static int nfs4_map_errors(int err)\n{\n\tif (err >= -1000)\n\t\treturn err;\n\tswitch (err) {\n\tcase -NFS4ERR_RESOURCE:\n\t\treturn -EREMOTEIO;\n\tcase -NFS4ERR_WRONGSEC:\n\t\treturn -EPERM;\n\tcase -NFS4ERR_BADOWNER:\n\tcase -NFS4ERR_BADNAME:\n\t\treturn -EINVAL;\n\tcase -NFS4ERR_SHARE_DENIED:\n\t\treturn -EACCES;\n\tcase -NFS4ERR_MINOR_VERS_MISMATCH:\n\t\treturn -EPROTONOSUPPORT;\n\tdefault:\n\t\tdprintk(\"%s could not handle NFSv4 error %d\\n\",\n\t\t\t\t__func__, -err);\n\t\tbreak;\n\t}\n\treturn -EIO;\n}", "target": 0}
{"code": "bool ParamTraits<base::Time>::Read(const Message* m, PickleIterator* iter,\n                                   param_type* r) {\n  int64 value;\n  if (!ParamTraits<int64>::Read(m, iter, &value))\n    return false;\n  *r = base::Time::FromInternalValue(value);\n  return true;\n}", "target": 0}
{"code": "njs_function_frame_free(njs_vm_t *vm, njs_native_frame_t *native)\n{\n    njs_native_frame_t  *previous;\n    do {\n        previous = native->previous;\n        if (native->size != 0) {\n            vm->stack_size -= native->size;\n            njs_mp_free(vm->mem_pool, native);\n        }\n        native = previous;\n    } while (native->skip);\n}", "target": 0}
{"code": "eb_get_object(struct eb_objects *eb, unsigned long handle)\n{\n\tif (eb->and < 0) {\n\t\tif (handle >= -eb->and)\n\t\t\treturn NULL;\n\t\treturn eb->lut[handle];\n\t} else {\n\t\tstruct hlist_head *head;\n\t\tstruct hlist_node *node;\n\t\thead = &eb->buckets[handle & eb->and];\n\t\thlist_for_each(node, head) {\n\t\t\tstruct drm_i915_gem_object *obj;\n\t\t\tobj = hlist_entry(node, struct drm_i915_gem_object, exec_node);\n\t\t\tif (obj->exec_handle == handle)\n\t\t\t\treturn obj;\n\t\t}\n\t\treturn NULL;\n\t}\n}", "target": 0}
{"code": "void CoreUserInputHandler::putPrivmsg(const QByteArray &target, const QByteArray &message, Cipher *cipher)\n{\n    static const char *cmd = \"PRIVMSG\";\n    static const char *splitter = \" .,-!?\";\n    int maxSplitPos = message.count();\n    int splitPos = maxSplitPos;\n    forever {\n        QByteArray crypted = message.left(splitPos);\n        bool isEncrypted = false;\n#ifdef HAVE_QCA2\n        if (cipher && !cipher->key().isEmpty() && !message.isEmpty()) {\n            isEncrypted = cipher->encrypt(crypted);\n        }\n#endif\n        int overrun = lastParamOverrun(cmd, QList<QByteArray>() << target << crypted);\n        if (overrun) {\n            if (!isEncrypted)\n                maxSplitPos = message.count() - overrun;\n            splitPos = -1;\n            for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n                splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \n            }\n            if (splitPos <= 0 || splitPos > maxSplitPos)\n                splitPos = maxSplitPos;\n            maxSplitPos = splitPos - 1;\n            if (maxSplitPos <= 0) { \n                qWarning() << tr(\"[Error] Could not encrypt your message: %1\").arg(message.data());\n                return;\n            }\n            continue; \n        }\n        putCmd(cmd, QList<QByteArray>() << target << crypted);\n        if (splitPos < message.count())\n            putPrivmsg(target, message.mid(splitPos), cipher);\n        return;\n    }\n}", "target": 1}
{"code": "static bool isHexDigit(char ch) {\n  return (ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f') ||\n         (ch >= 'A' && ch <= 'F');\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    ValidateInputTensors(ctx, in0, in1);\n    if (!ctx->status().ok()) return;\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);  \n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d1);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchBandedTriangularSolve<Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }", "target": 0}
{"code": "gss_get_mic (minor_status,\n\t     context_handle,\n\t     qop_req,\n\t     message_buffer,\n\t     msg_token)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_get_mic_args(minor_status, context_handle,\n\t\t\t      qop_req, message_buffer, msg_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_get_mic) {\n\t    status = mech->gss_get_mic(\n\t\t\t\t    minor_status,\n\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t    qop_req,\n\t\t\t\t    message_buffer,\n\t\t\t\t    msg_token);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "int xmkstemp(char **tmpname, char *dir)\n{\n\tchar *localtmp;\n\tchar *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n\tif (rc < 0)\n\t\treturn -1;\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}\n\t*tmpname = localtmp;\n\treturn fd;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, SortSkipLimit) {\n    runQuerySortProjSkipNToReturn(BSONObj(), fromjson(\"{a: 1}\"), BSONObj(), 2, -3);\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{skip: {n: 2, node: \"\n        \"{sort: {pattern: {a: 1}, limit: 5, node: {sortKeyGen: \"\n        \"{node: {cscan: {dir: 1}}}}}}}}\");\n}", "target": 0}
{"code": "int CLASS ljpeg_diff_new (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushort *huff)\n{\n  int len, diff;\n  if(!huff || !buf)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  len = bits._gethuff_lj(buf,*huff,huff+1);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = bits._getbits_lj(buf,len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}", "target": 0}
{"code": "int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  int rc;\n  if (flags & IMAP_CMD_SINGLE)\n  {\n    if (adata->nextcmd != adata->lastcmd)\n      imap_exec(adata, NULL, IMAP_CMD_POLL);\n  }\n  rc = cmd_start(adata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n  if (flags & IMAP_CMD_QUEUE)\n    return IMAP_EXEC_SUCCESS;\n  if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&\n      ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))\n  {\n    mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n  mutt_sig_allow_interrupt(true);\n  do\n  {\n    rc = imap_cmd_step(adata);\n    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))\n      break;\n  } while (rc == IMAP_RES_CONTINUE);\n  mutt_sig_allow_interrupt(false);\n  if (rc == IMAP_RES_NO)\n    return IMAP_EXEC_ERROR;\n  if (rc != IMAP_RES_OK)\n  {\n    if (adata->status != IMAP_FATAL)\n      return IMAP_EXEC_ERROR;\n    mutt_debug(LL_DEBUG1, \"command failed: %s\\n\", adata->buf);\n    return IMAP_EXEC_FATAL;\n  }\n  return IMAP_EXEC_SUCCESS;\n}", "target": 0}
{"code": "void __meminit setup_zone_pageset(struct zone *zone)\n{\n\tint cpu;\n\tzone->pageset = alloc_percpu(struct per_cpu_pageset);\n\tfor_each_possible_cpu(cpu)\n\t\tzone_pageset_init(zone, cpu);\n}", "target": 0}
{"code": "static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tvmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tvmcs_set_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tvmcs_clear_bits(SECONDARY_VM_EXEC_CONTROL,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_set_msr_bitmap(vcpu);\n}", "target": 0}
{"code": "void gf_isom_sample_entry_init(GF_SampleEntryBox *ent)\n{\n\tent->internal_type = GF_ISOM_SAMPLE_ENTRY_MP4S;\n}", "target": 0}
{"code": "list_table_status(MYSQL *mysql,const char *db,const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  end=strxmov(query,\"show table status from `\",db,\"`\",NullS);\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot get status for db: %s, table: %s: %s\\n\",\n\t    my_progname,db,wild ? wild : \"\",mysql_error(mysql));\n    if (mysql_errno(mysql) == ER_PARSE_ERROR)\n      fprintf(stderr,\"This error probably means that your MySQL server doesn't support the\\n\\'show table status' command.\\n\");\n    return 1;\n  }\n  printf(\"Database: %s\",db);\n  if (wild)\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "static int count_args(const char **argv)\n{\n\tint i = 0;\n\tif (argv) {\n\t\twhile (argv[i] != NULL)\n\t\t\ti++;\n\t}\n\treturn i;\n}", "target": 0}
{"code": "  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n    currentBuffer.length = len;\n    wcb_->setSocket(socket_);\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n  }", "target": 1}
{"code": "void LightProcess::runShadow(int fdin, int fdout) {\n  FILE *fin = fdopen(fdin, \"r\");\n  FILE *fout = fdopen(fdout, \"w\");\n  char buf[BUFFER_SIZE];\n  pollfd pfd[1];\n  pfd[0].fd = fdin;\n  pfd[0].events = POLLIN;\n  while (true) {\n    int ret = poll(pfd, 1, -1);\n    if (ret < 0 && errno == EINTR) {\n      continue;\n    }\n    if (pfd[0].revents & POLLIN) {\n      if (!fgets(buf, BUFFER_SIZE, fin)) buf[0] = '\\0';\n      if (strncmp(buf, \"exit\", 4) == 0) {\n        Logger::Info(\"LightProcess exiting upon request\");\n        break;\n      } else if (strncmp(buf, \"popen\", 5) == 0) {\n        do_popen(fin, fout, m_afdt_fd);\n      } else if (strncmp(buf, \"pclose\", 6) == 0) {\n        do_pclose(fin, fout);\n      } else if (strncmp(buf, \"proc_open\", 9) == 0) {\n        do_proc_open(fin, fout, m_afdt_fd);\n      } else if (strncmp(buf, \"waitpid\", 7) == 0) {\n        do_waitpid(fin, fout);\n      } else if (strncmp(buf, \"change_user\", 11) == 0) {\n        do_change_user(fin, fout);\n      } else if (buf[0]) {\n        Logger::Info(\"LightProcess got invalid command: %.20s\", buf);\n      }\n    } else if (pfd[0].revents & POLLHUP) {\n      Logger::Error(\"Lost parent, LightProcess exiting\");\n      break;\n    }\n  }\n  fclose(fin);\n  fclose(fout);\n  ::close(m_afdt_fd);\n  remove(m_afdtFilename.c_str());\n  _Exit(0);\n}", "target": 1}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    PadContext *s = inlink->dst->priv;\n    AVFrame *out;\n    int needs_copy = frame_needs_copy(s, in);\n    if (needs_copy) {\n        av_log(inlink->dst, AV_LOG_DEBUG, \"Direct padding impossible allocating new frame\\n\");\n        out = ff_get_video_buffer(inlink->dst->outputs[0],\n                                  FFMAX(inlink->w, s->w),\n                                  FFMAX(inlink->h, s->h));\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    } else {\n        int i;\n        out = in;\n        for (i = 0; i < 4 && out->data[i]; i++) {\n            int hsub = s->draw.hsub[i];\n            int vsub = s->draw.vsub[i];\n            out->data[i] -= (s->x >> hsub) * s->draw.pixelstep[i] +\n                            (s->y >> vsub) * out->linesize[i];\n        }\n    }\n    if (s->y) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, 0, s->w, s->y);\n    }\n    if (s->h > s->y + s->in_h) {\n        ff_fill_rectangle(&s->draw, &s->color,\n                          out->data, out->linesize,\n                          0, s->y + s->in_h, s->w, s->h - s->y - s->in_h);\n    }\n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      0, s->y, s->x, in->height);\n    if (needs_copy) {\n        ff_copy_rectangle2(&s->draw,\n                          out->data, out->linesize, in->data, in->linesize,\n                          s->x, s->y, 0, 0, in->width, in->height);\n    }\n    ff_fill_rectangle(&s->draw, &s->color, out->data, out->linesize,\n                      s->x + s->in_w, s->y, s->w - s->x - s->in_w,\n                      in->height);\n    out->width  = s->w;\n    out->height = s->h;\n    if (in != out)\n        av_frame_free(&in);\n    return ff_filter_frame(inlink->dst->outputs[0], out);\n}", "target": 1}
{"code": "xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error = 0;\n\tif (!acl)\n\t\tgoto set_acl;\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}", "target": 1}
{"code": "static inline bool key_is_instantiated(const struct key *key)\n{\n\treturn test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t!test_bit(KEY_FLAG_NEGATIVE, &key->flags);\n}", "target": 1}
{"code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}", "target": 1}
{"code": "    int FixCom::run(const std::string& path)\n    {\n        try {\n            if (!Exiv2::fileExists(path, true)) {\n                std::cerr << path << \": \" << _(\"Failed to open the file\\n\");\n                return -1;\n            }\n            Timestamp ts;\n            if (Params::instance().preserve_)\n                ts.read(path);\n            Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open(path);\n            image->readMetadata();\n            Exiv2::ExifData& exifData = image->exifData();\n            if (exifData.empty()) {\n                std::cerr << path << \": \" << _(\"No Exif data found in the file\\n\");\n                return -3;\n            }\n            auto pos = exifData.findKey(Exiv2::ExifKey(\"Exif.Photo.UserComment\"));\n            if (pos == exifData.end()) {\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"No Exif user comment found\") << \"\\n\";\n                }\n                return 0;\n            }\n            Exiv2::Value::UniquePtr v = pos->getValue();\n            const Exiv2::CommentValue* pcv = dynamic_cast<const Exiv2::CommentValue*>(v.get());\n            if (!pcv) {\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"Found Exif user comment with unexpected value type\") << \"\\n\";\n                }\n                return 0;\n            }\n            Exiv2::CommentValue::CharsetId csId = pcv->charsetId();\n            if (csId != Exiv2::CommentValue::unicode) {\n                if (Params::instance().verbose_) {\n                    std::cout << _(\"No Exif UNICODE user comment found\") << \"\\n\";\n                }\n                return 0;\n            }\n            std::string comment = pcv->comment(Params::instance().charset_.c_str());\n            if (Params::instance().verbose_) {\n                std::cout << _(\"Setting Exif UNICODE user comment to\") << \" \\\"\" << comment << \"\\\"\\n\";\n            }\n            comment = std::string(\"charset=\\\"\") + Exiv2::CommentValue::CharsetInfo::name(csId) + \"\\\" \" + comment;\n            pos->setValue(comment);\n            image->writeMetadata();\n            if (Params::instance().preserve_)\n                ts.touch(path);\n            return 0;\n        } catch (const Exiv2::AnyError& e) {\n            std::cerr << \"Exiv2 exception in fixcom action for file \" << path << \":\\n\" << e << \"\\n\";\n            return 1;\n        }\n    }", "target": 0}
{"code": "char *strdup(const char *s1)\n{\n\tchar *s2 = 0;\n\tif (s1) {\n\t\ts2 = malloc(strlen(s1) + 1);\n\t\tstrcpy(s2, s1);\n\t}\n\treturn s2;\n}", "target": 1}
{"code": "HTTP_HANDLE HTTPAPI_CreateConnection(const char* hostName)\n{\n    HTTP_HANDLE_DATA* result;\n    if (g_HTTPAPIState != HTTPAPI_INITIALIZED)\n    {\n        LogError(\"g_HTTPAPIState not HTTPAPI_INITIALIZED\");\n        result = NULL;\n    }\n    else\n    {\n        result = (HTTP_HANDLE_DATA*)malloc(sizeof(HTTP_HANDLE_DATA));\n        if (result == NULL)\n        {\n            LogError(\"malloc returned NULL.\");\n        }\n        else\n        {\n            memset(result, 0, sizeof(*result));\n            wchar_t* hostNameTemp;\n            size_t hostNameTemp_size = MultiByteToWideChar(CP_ACP, 0, hostName, -1, NULL, 0);\n            if (hostNameTemp_size == 0)\n            {\n                LogError(\"MultiByteToWideChar failed\");\n                free(result);\n                result = NULL;\n            }\n            else\n            {\n                hostNameTemp = (wchar_t*)malloc(sizeof(wchar_t) * hostNameTemp_size);\n                if (hostNameTemp == NULL)\n                {\n                    LogError(\"malloc failed\");\n                    free(result);\n                    result = NULL;\n                }\n                else\n                {\n                    if (MultiByteToWideChar(CP_ACP, 0, hostName, -1, hostNameTemp, (int)hostNameTemp_size) == 0)\n                    {\n                        LogError(\"MultiByteToWideChar failed\");\n                        free(result);\n                        result = NULL;\n                    }\n                    else\n                    {\n                        result->ConnectionHandle = WinHttpConnect(\n                            g_SessionHandle,\n                            hostNameTemp,\n                            INTERNET_DEFAULT_HTTPS_PORT,\n                            0);\n                        if (result->ConnectionHandle == NULL)\n                        {\n                            LogErrorWinHTTPWithGetLastErrorAsString(\"WinHttpConnect returned NULL.\");\n                            free(result);\n                            result = NULL;\n                        }\n                        else\n                        {\n                            result->timeout = 60000;\n                        }\n                    }\n                    free(hostNameTemp);\n                }\n            }\n        }\n    }\n    return (HTTP_HANDLE)result;\n}", "target": 1}
{"code": "_PUBLIC_ char **file_lines_load(const char *fname, int *numlines, size_t maxsize, TALLOC_CTX *mem_ctx)\n{\n\tchar *p;\n\tsize_t size;\n\tp = file_load(fname, &size, maxsize, mem_ctx);\n\tif (!p) return NULL;\n\treturn file_lines_parse(p, size, numlines, mem_ctx);\n}", "target": 0}
{"code": "    Exifdatum& Exifdatum::operator=(const URational& value)\n    {\n        return Exiv2::setValue(*this, value);\n    }", "target": 0}
{"code": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *last,\n\t\t\tvoid *data)\n{\n\tchar *name = path_name(path, last);\n\tadd_preferred_base_object(name);\n\tadd_object_entry(obj->oid.hash, obj->type, name, 0);\n\tobj->flags |= OBJECT_ADDED;\n\tfree((char *)name);\n}", "target": 1}
{"code": "int __init acpi_debugger_init(void)\n{\n\tmutex_init(&acpi_debugger.lock);\n\tacpi_debugger_initialized = true;\n\treturn 0;\n}", "target": 0}
{"code": "static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tDRIVE_FILE* file;\n\tUINT32 Length;\n\tUINT64 Offset;\n\tif (!drive || !irp || !irp->input || !irp->output || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (!file)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_seek(file, Offset))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\telse if (!drive_file_write(file, Stream_Pointer(irp->input), Length))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t\tLength = 0;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "static void *HttpMultiBufHeaderThreadDataInit(void *data)\n{\n    HttpMultiBufHeaderThreadData *td = SCCalloc(1, sizeof(*td));\n    return td;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    Buffer* buf = nullptr;\n    OP_REQUIRES_OK(ctx, GetBuffer(ctx, def(), &buf));\n    core::ScopedUnref scope(buf);\n    Buffer::Tuple tuple;\n    OP_REQUIRES(ctx, TensorShapeUtils::IsScalar(ctx->input(0).shape()),\n                errors::InvalidArgument(\"index must be scalar\"));\n    std::size_t index = ctx->input(0).scalar<int>()();\n    OP_REQUIRES_OK(ctx, buf->Peek(index, &tuple));\n    OP_REQUIRES(\n        ctx, tuple.size() == (size_t)ctx->num_outputs(),\n        errors::InvalidArgument(\"Mismatch stage/unstage: \", tuple.size(),\n                                \" vs. \", ctx->num_outputs()));\n    for (size_t i = 0; i < tuple.size(); ++i) {\n      ctx->set_output(i, tuple[i]);\n    }\n  }", "target": 0}
{"code": "static void enqueue_huge_page(struct hstate *h, struct page *page)\n{\n\tint nid = page_to_nid(page);\n\tlockdep_assert_held(&hugetlb_lock);\n\tVM_BUG_ON_PAGE(page_count(page), page);\n\tlist_move(&page->lru, &h->hugepage_freelists[nid]);\n\th->free_huge_pages++;\n\th->free_huge_pages_node[nid]++;\n\tSetHPageFreed(page);\n}", "target": 0}
{"code": "PrintBackend *cpdbCreateBackendFromFile(GDBusConnection *connection,\n                                        const char *backend_file_name)\n{\n    FILE *file = NULL;\n    PrintBackend *proxy;\n    GError *error = NULL;\n    char *path, *backend_name;\n    const char *info_dir_name;\n    char obj_path[CPDB_BSIZE];\n    backend_name = cpdbGetStringCopy(backend_file_name);\n    if ((info_dir_name = getenv(\"CPDB_BACKEND_INFO_DIR\")) == NULL)\n      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    proxy = print_backend_proxy_new_sync(connection,\n                                         0,\n                                         backend_name,\n                                         obj_path,\n                                         NULL,\n                                         &error);\n    if (error)\n    {\n        logerror(\"Error creating backend proxy for %s : %s\\n\",\n                    backend_name, error->message);\n        return NULL;\n    }\n    return proxy;\n}", "target": 1}
{"code": "void LIRGenerator::do_BlockBegin(BlockBegin* x) {\n}", "target": 0}
{"code": "static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)\n{\n    cJSON *current_element = NULL;\n    if ((object == NULL) || (name == NULL))\n    {\n        return NULL;\n    }\n    current_element = object->child;\n    if (case_sensitive)\n    {\n        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    else\n    {\n        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))\n        {\n            current_element = current_element->next;\n        }\n    }\n    return current_element;\n}", "target": 1}
{"code": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}", "target": 1}
{"code": "DumpIoStats(Mgr::IoActionData& stats, StoreEntry* sentry)\n{\n    int i;\n    storeAppendPrintf(sentry, \"HTTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.http_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.http_read_hist[i],\n                          Math::doublePercent(stats.http_read_hist[i], stats.http_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"FTP I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.ftp_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.ftp_read_hist[i],\n                          Math::doublePercent(stats.ftp_read_hist[i], stats.ftp_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n    storeAppendPrintf(sentry, \"Gopher I/O\\n\");\n    storeAppendPrintf(sentry, \"number of reads: %.0f\\n\", stats.gopher_reads);\n    storeAppendPrintf(sentry, \"Read Histogram:\\n\");\n    for (i = 0; i < IoStats::histSize; ++i) {\n        storeAppendPrintf(sentry, \"%5d-%5d: %9.0f %2.0f%%\\n\",\n                          i ? (1 << (i - 1)) + 1 : 1,\n                          1 << i,\n                          stats.gopher_read_hist[i],\n                          Math::doublePercent(stats.gopher_read_hist[i], stats.gopher_reads));\n    }\n    storeAppendPrintf(sentry, \"\\n\");\n}", "target": 1}
{"code": "LUA_API void lua_upvaluejoin (lua_State *L, int fidx1, int n1,\n                                            int fidx2, int n2) {\n  LClosure *f1;\n  UpVal **up1 = getupvalref(L, fidx1, n1, &f1);\n  UpVal **up2 = getupvalref(L, fidx2, n2, NULL);\n  luaC_upvdeccount(L, *up1);\n  *up1 = *up2;\n  (*up1)->refcount++;\n  if (upisopen(*up1)) (*up1)->u.open.touched = 1;\n  luaC_upvalbarrier(L, *up1);\n}", "target": 1}
{"code": "raw_copy_to_user(void __user *dst, const void *src, unsigned long size)\n{\n\tint ret = 0;\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u8 *)src, (u8 __user *)dst,\n\t\t\t      ret, \"b\", \"b\", \"iq\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u16 *)src, (u16 __user *)dst,\n\t\t\t      ret, \"w\", \"w\", \"ir\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u32 *)src, (u32 __user *)dst,\n\t\t\t      ret, \"l\", \"k\", \"ir\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t      ret, \"q\", \"\", \"er\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 10);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(4[(u16 *)src], 4 + (u16 __user *)dst,\n\t\t\t\t       ret, \"w\", \"w\", \"ir\", 2);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 16);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(1[(u64 *)src], 1 + (u64 __user *)dst,\n\t\t\t\t       ret, \"q\", \"\", \"er\", 8);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\t}\n}", "target": 1}
{"code": "void UpstreamRequest::onPerTryIdleTimeout() {\n  ENVOY_STREAM_LOG(debug, \"upstream per try idle timeout\", *parent_.callbacks());\n  if (per_try_timeout_) {\n    per_try_timeout_->disableTimer();\n  }\n  stream_info_.setResponseFlag(StreamInfo::CoreResponseFlag::StreamIdleTimeout);\n  parent_.onPerTryIdleTimeout(*this);\n}", "target": 0}
{"code": "int pdf_load_xrefs(FILE *fp, pdf_t *pdf)\n{\n    int  i, ver, is_linear;\n    long pos, pos_count;\n    char x, *c, buf[256];\n    c = NULL;\n    pdf->n_xrefs = 0;\n    fseek(fp, 0, SEEK_SET);\n    while (get_next_eof(fp) >= 0)\n      ++pdf->n_xrefs;\n    if (!pdf->n_xrefs)\n      return 0;\n    fseek(fp, 0, SEEK_SET);\n    pdf->xrefs = calloc(1, sizeof(xref_t) * pdf->n_xrefs);\n    ver = 1;\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if ((pos = get_next_eof(fp)) < 0)\n          break;\n        pdf->xrefs[i].version = ver++;\n        pos_count = 0;\n        while (SAFE_F(fp, ((x = fgetc(fp)) != 'f')))\n          fseek(fp, pos - (++pos_count), SEEK_SET);\n        if (pos_count >= sizeof(buf)) {\n          ERR(\"Failed to locate the startxref token. \"\n              \"This might be a corrupt PDF.\\n\");\n          return -1;\n        }\n        memset(buf, 0, sizeof(buf));\n        SAFE_E(fread(buf, 1, pos_count, fp), pos_count,\n               \"Failed to read startxref.\\n\");\n        c = buf;\n        while (*c == ' ' || *c == '\\n' || *c == '\\r')\n          ++c;\n        pdf->xrefs[i].start = atol(c);\n        if (pdf->xrefs[i].start == 0)\n          get_xref_linear_skipped(fp, &pdf->xrefs[i]);\n        else\n        {\n            pos = ftell(fp);\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            pdf->xrefs[i].end = get_next_eof(fp);\n            fseek(fp, pos, SEEK_SET);\n        }\n        if (!is_valid_xref(fp, pdf, &pdf->xrefs[i]))\n        {\n            is_linear = pdf->xrefs[i].is_linear;\n            memset(&pdf->xrefs[i], 0, sizeof(xref_t));\n            pdf->xrefs[i].is_linear = is_linear;\n            rewind(fp);\n            get_next_eof(fp);\n            continue;\n        }\n        load_xref_entries(fp, &pdf->xrefs[i]);\n    }\n    if (pdf->xrefs[0].is_linear)\n      resolve_linearized_pdf(pdf);\n    load_creator(fp, pdf);\n    return pdf->n_xrefs;\n}", "target": 1}
{"code": "static TEE_Result do_allocate_keypair(struct dh_keypair *key, size_t size_bits)\n{\n\tDH_TRACE(\"Allocate Keypair of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(size_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(size_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(size_bits);\n\tif (!key->q)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDH_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static Eina_Bool _ewk_view_smart_key_up(Ewk_View_Smart_Data* smartData, const Evas_Event_Key_Up* upEvent)\n{\n    Evas_Object* frame = ewk_view_frame_focused_get(smartData->self);\n    if (!frame)\n        frame = smartData->main_frame;\n    return ewk_frame_feed_key_up(frame, upEvent);\n}", "target": 0}
{"code": "void* ipc_alloc(int size)\n{\n\tvoid* out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}", "target": 1}
{"code": "is_url(const char *source)\n{\n\tchar *colonp;\n\tcolonp = strchr(source, ':');\n\tif (colonp == NULL)\n\t{\n\t\treturn (0);\n\t}\n\tif (strncmp(colonp + 1, \"\n\t{\n\t\treturn (0);\n\t}\n\treturn (1);\n}", "target": 0}
{"code": "static inline bool unconditional(const struct ip6t_ip6 *ipv6)\n{\n\tstatic const struct ip6t_ip6 uncond;\n\treturn memcmp(ipv6, &uncond, sizeof(uncond)) == 0;\n}", "target": 1}
{"code": "void BytecodeModuleGenerator::setFunctionGenerator(\n    Function *F,\n    unique_ptr<BytecodeFunctionGenerator> BFG) {\n  assert(\n      functionGenerators_.find(F) == functionGenerators_.end() &&\n      \"Adding same function twice.\");\n  assert(\n      !BFG->hasEncodingError() && \"Error should have been reported already.\");\n  functionGenerators_[F] = std::move(BFG);\n}", "target": 0}
{"code": "aiff_read_chanmap (SF_PRIVATE * psf, unsigned dword)\n{\tconst AIFF_CAF_CHANNEL_MAP * map_info ;\n\tunsigned channel_bitmap, channel_decriptions, bytesread ;\n\tint layout_tag ;\n\tbytesread = psf_binheader_readf (psf, \"444\", &layout_tag, &channel_bitmap, &channel_decriptions) ;\n\tif ((map_info = aiff_caf_of_channel_layout_tag (layout_tag)) == NULL)\n\t\treturn 0 ;\n\tpsf_log_printf (psf, \"  Tag    : %x\\n\", layout_tag) ;\n\tif (map_info)\n\t\tpsf_log_printf (psf, \"  Layout : %s\\n\", map_info->name) ;\n\tif (bytesread < dword)\n\t\tpsf_binheader_readf (psf, \"j\", dword - bytesread) ;\n\tif (map_info->channel_map != NULL)\n\t{\tsize_t chanmap_size = psf->sf.channels * sizeof (psf->channel_map [0]) ;\n\t\tfree (psf->channel_map) ;\n\t\tif ((psf->channel_map = malloc (chanmap_size)) == NULL)\n\t\t\treturn SFE_MALLOC_FAILED ;\n\t\tmemcpy (psf->channel_map, map_info->channel_map, chanmap_size) ;\n\t\t} ;\n\treturn 0 ;\n} ", "target": 1}
{"code": "GF_Err gf_bin128_parse(const char *string, bin128 value)\n{\n\tu32 len;\n\tu32\ti=0;\n\tif (!strnicmp(string, \"0x\", 2)) string += 2;\n\tlen = (u32) strlen(string);\n\tif (len >= 32) {\n\t\tu32 j;\n\t\tfor (j=0; j<len; j+=2) {\n\t\t\tu32 v;\n\t\t\tchar szV[5];\n\t\t\twhile (string[j] && !isalnum(string[j]))\n\t\t\t\tj++;\n\t\t\tif (!string[j])\n\t\t\t\tbreak;\n\t\t\tsprintf(szV, \"%c%c\", string[j], string[j+1]);\n\t\t\tsscanf(szV, \"%x\", &v);\n\t\t\tif (i > 15) {\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue[i] = v;\n\t\t\ti++;\n\t\t}\n\t}\n\tif (i != 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (\"[CORE] 128bit blob is not 16-bytes long: %s\\n\", string));\n\t\treturn GF_BAD_PARAM;\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "void FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  trust_ary_free(&tls->trust);\n  free(tls);\n}", "target": 0}
{"code": "int dns_HTTPS_add_alpn(struct dns_rr_nested *svcparam, const char *alpn, int alpn_len)\n{\n\tif (_dns_left_len(&svcparam->context) < 2 + 2 + alpn_len) {\n\t\treturn -1;\n\t}\n\tunsigned short value = DNS_HTTPS_T_ALPN;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tvalue = alpn_len;\n\tdns_add_rr_nested_memcpy(svcparam, &value, 2);\n\tdns_add_rr_nested_memcpy(svcparam, alpn, alpn_len);\n\treturn 0;\n}", "target": 0}
{"code": "gstd_accept(int fd, char **display_creds, char **export_name, char **mech)\n{\n\tgss_name_t\t client;\n\tgss_OID\t\t mech_oid;\n\tstruct gstd_tok *tok;\n\tgss_ctx_id_t\t ctx = GSS_C_NO_CONTEXT;\n\tgss_buffer_desc\t in, out;\n\tOM_uint32\t maj, min;\n\tint\t\t ret;\n\t*display_creds = NULL;\n\t*export_name = NULL;\n\tout.length = 0;\n\tin.length = 0;\n\tread_packet(fd, &in, 60000, 1);\nagain:\n\twhile ((ret = read_packet(fd, &in, 60000, 0)) == -2)\n\t\t;\n\tif (ret < 1)\n\t\treturn NULL;\n\tmaj = gss_accept_sec_context(&min, &ctx, GSS_C_NO_CREDENTIAL,\n\t    &in, GSS_C_NO_CHANNEL_BINDINGS, &client, &mech_oid, &out, NULL,\n\t    NULL, NULL);\n\tgss_release_buffer(&min, &in);\n\tif (out.length && write_packet(fd, &out)) {\n\t\tgss_release_buffer(&min, &out);\n\t\treturn NULL;\n\t}\n\tgss_release_buffer(&min, &out);\n\tGSTD_GSS_ERROR(maj, min, NULL, \"gss_accept_sec_context\");\n\tif (maj & GSS_S_CONTINUE_NEEDED)\n\t\tgoto again;\n\t*display_creds = gstd_get_display_name(client);\n\t*export_name = gstd_get_export_name(client);\n\t*mech = gstd_get_mech(mech_oid);\n\tgss_release_name(&min, &client);\n\tSETUP_GSTD_TOK(tok, ctx, fd, \"gstd_accept\");\n\treturn tok;\n}", "target": 0}
{"code": "int btrfs_run_qgroups(struct btrfs_trans_handle *trans)\n{\n\tstruct btrfs_fs_info *fs_info = trans->fs_info;\n\tint ret = 0;\n\tif (trans->transaction->state != TRANS_STATE_COMMIT_DOING)\n\t\tlockdep_assert_held(&fs_info->qgroup_ioctl_lock);\n\tif (!fs_info->quota_root)\n\t\treturn ret;\n\tspin_lock(&fs_info->qgroup_lock);\n\twhile (!list_empty(&fs_info->dirty_qgroups)) {\n\t\tstruct btrfs_qgroup *qgroup;\n\t\tqgroup = list_first_entry(&fs_info->dirty_qgroups,\n\t\t\t\t\t  struct btrfs_qgroup, dirty);\n\t\tlist_del_init(&qgroup->dirty);\n\t\tspin_unlock(&fs_info->qgroup_lock);\n\t\tret = update_qgroup_info_item(trans, qgroup);\n\t\tif (ret)\n\t\t\tqgroup_mark_inconsistent(fs_info);\n\t\tret = update_qgroup_limit_item(trans, qgroup);\n\t\tif (ret)\n\t\t\tqgroup_mark_inconsistent(fs_info);\n\t\tspin_lock(&fs_info->qgroup_lock);\n\t}\n\tif (test_bit(BTRFS_FS_QUOTA_ENABLED, &fs_info->flags))\n\t\tfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;\n\telse\n\t\tfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;\n\tspin_unlock(&fs_info->qgroup_lock);\n\tret = update_qgroup_status_item(trans);\n\tif (ret)\n\t\tqgroup_mark_inconsistent(fs_info);\n\treturn ret;\n}", "target": 0}
{"code": "static u32 gasp_specifier_id(__be32 *p)\n{\n\treturn (be32_to_cpu(p[0]) & 0xffff) << 8 |\n\t       (be32_to_cpu(p[1]) & 0xff000000) >> 24;\n}", "target": 0}
{"code": "void Bezier(double x1,double y1,double x2,double y2,double x3,double y3) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f %12.3f %12.3f %12.3f %12.3f c\",x1,y1,x2,y2,x3,y3);\n}", "target": 1}
{"code": "static int _nfs4_do_open(struct inode *dir, struct path *path, int flags, struct iattr *sattr, struct rpc_cred *cred, struct nfs4_state **res)\n{\n\tstruct nfs4_state_owner  *sp;\n\tstruct nfs4_state     *state = NULL;\n\tstruct nfs_server       *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *opendata;\n\tint status;\n\tstatus = -ENOMEM;\n\tif (!(sp = nfs4_get_state_owner(server, cred))) {\n\t\tdprintk(\"nfs4_do_open: nfs4_get_state_owner failed!\\n\");\n\t\tgoto out_err;\n\t}\n\tstatus = nfs4_recover_expired_lease(server);\n\tif (status != 0)\n\t\tgoto err_put_state_owner;\n\tif (path->dentry->d_inode != NULL)\n\t\tnfs4_return_incompatible_delegation(path->dentry->d_inode, flags & (FMODE_READ|FMODE_WRITE));\n\tstatus = -ENOMEM;\n\topendata = nfs4_opendata_alloc(path, sp, flags, sattr);\n\tif (opendata == NULL)\n\t\tgoto err_put_state_owner;\n\tif (path->dentry->d_inode != NULL)\n\t\topendata->state = nfs4_get_open_state(path->dentry->d_inode, sp);\n\tstatus = _nfs4_proc_open(opendata);\n\tif (status != 0)\n\t\tgoto err_opendata_put;\n\tif (opendata->o_arg.open_flags & O_EXCL)\n\t\tnfs4_exclusive_attrset(opendata, sattr);\n\tstate = nfs4_opendata_to_nfs4_state(opendata);\n\tstatus = PTR_ERR(state);\n\tif (IS_ERR(state))\n\t\tgoto err_opendata_put;\n\tnfs4_opendata_put(opendata);\n\tnfs4_put_state_owner(sp);\n\t*res = state;\n\treturn 0;\nerr_opendata_put:\n\tnfs4_opendata_put(opendata);\nerr_put_state_owner:\n\tnfs4_put_state_owner(sp);\nout_err:\n\t*res = NULL;\n\treturn status;\n}", "target": 1}
{"code": "int cma_get_default_gid_type(struct cma_device *cma_dev,\n\t\t\t     u32 port)\n{\n\tif (!rdma_is_port_valid(cma_dev->device, port))\n\t\treturn -EINVAL;\n\treturn cma_dev->default_gid_type[port - rdma_start_port(cma_dev->device)];\n}", "target": 0}
{"code": "is_char_safe (gunichar c)\n{\n  return g_unichar_isgraph (c) || c == ' ';\n}", "target": 0}
{"code": "BaseAudioContext::~BaseAudioContext() {\n  {\n    GraphAutoLocker locker(this);\n    destination_handler_ = nullptr;\n  }\n  GetDeferredTaskHandler().ContextWillBeDestroyed();\n}", "target": 0}
{"code": "chdlc_print(netdissect_options *ndo, register const u_char *p, u_int length)\n{\n\tu_int proto;\n\tconst u_char *bp = p;\n\tif (length < CHDLC_HDRLEN)\n\t\tgoto trunc;\n\tND_TCHECK2(*p, CHDLC_HDRLEN);\n\tproto = EXTRACT_16BITS(&p[2]);\n\tif (ndo->ndo_eflag) {\n                ND_PRINT((ndo, \"%s, ethertype %s (0x%04x), length %u: \",\n                       tok2str(chdlc_cast_values, \"0x%02x\", p[0]),\n                       tok2str(ethertype_values, \"Unknown\", proto),\n                       proto,\n                       length));\n\t}\n\tlength -= CHDLC_HDRLEN;\n\tp += CHDLC_HDRLEN;\n\tswitch (proto) {\n\tcase ETHERTYPE_IP:\n\t\tip_print(ndo, p, length);\n\t\tbreak;\n\tcase ETHERTYPE_IPV6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\tcase CHDLC_TYPE_SLARP:\n\t\tchdlc_slarp_print(ndo, p, length);\n\t\tbreak;\n#if 0\n\tcase CHDLC_TYPE_CDP:\n\t\tchdlc_cdp_print(p, length);\n\t\tbreak;\n#endif\n        case ETHERTYPE_MPLS:\n        case ETHERTYPE_MPLS_MULTI:\n                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\treturn (CHDLC_HDRLEN);\ntrunc:\n\tND_PRINT((ndo, \"[|chdlc]\"));\n\treturn ndo->ndo_snapend - bp;\n}", "target": 0}
{"code": "u16 inverse_translate(struct vc_data *conp, int glyph, int use_unicode)\n{\n\tstruct uni_pagedir *p;\n\tint m;\n\tif (glyph < 0 || glyph >= MAX_GLYPH)\n\t\treturn 0;\n\telse {\n\t\tp = *conp->vc_uni_pagedir_loc;\n\t\tif (!p)\n\t\t\treturn glyph;\n\t\telse if (use_unicode) {\n\t\t\tif (!p->inverse_trans_unicode)\n\t\t\t\treturn glyph;\n\t\t\telse\n\t\t\t\treturn p->inverse_trans_unicode[glyph];\n\t\t\t} else {\n\t\t\tm = inv_translate[conp->vc_num];\n\t\t\tif (!p->inverse_translations[m])\n\t\t\t\treturn glyph;\n\t\t\telse\n\t\t\t\treturn p->inverse_translations[m][glyph];\n\t\t\t}\n\t}\n}", "target": 0}
{"code": "ut64 MACH0_(get_main)(struct MACH0_(obj_t)* bin) {\n\tut64 addr = 0LL;\n\tstruct symbol_t *symbols;\n\tint i;\n\tif (!(symbols = MACH0_(get_symbols) (bin))) {\n\t\treturn 0;\n\t}\n\tfor (i = 0; !symbols[i].last; i++) {\n\t\tif (!strcmp (symbols[i].name, \"_main\")) {\n\t\t\taddr = symbols[i].addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree (symbols);\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n\t\t\treturn 0;\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\t\t\t}\n\t\t}\n\t}\n\treturn addr;\n}", "target": 1}
{"code": "void HTMLMediaElement::OnRemovedFromDocumentTimerFired(TimerBase*) {\n  if (InActiveDocument())\n    return;\n  PauseInternal();\n}", "target": 0}
{"code": "static bool ParseSparseAccessor(Accessor *accessor, std::string *err,\n                                const json &o) {\n  accessor->sparse.isSparse = true;\n  int count = 0;\n  if (!ParseIntegerProperty(&count, err, o, \"count\", true, \"SparseAccessor\")) {\n    return false;\n  }\n  json_const_iterator indices_iterator;\n  json_const_iterator values_iterator;\n  if (!FindMember(o, \"indices\", indices_iterator)) {\n    (*err) = \"the sparse object of this accessor doesn't have indices\";\n    return false;\n  }\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;\n  accessor->sparse.values.byteOffset = values_byte_offset;\n  return true;\n}", "target": 1}
{"code": "fp_read(CBORDecoderObject *self, char *buf, const Py_ssize_t size)\n{\n    PyObject *obj, *size_obj;\n    char *data;\n    int ret = -1;\n    size_obj = PyLong_FromSsize_t(size);\n    if (size_obj) {\n        obj = PyObject_CallFunctionObjArgs(self->read, size_obj, NULL);\n        if (obj) {\n            assert(PyBytes_CheckExact(obj));\n            if (PyBytes_GET_SIZE(obj) == (Py_ssize_t) size) {\n                data = PyBytes_AS_STRING(obj);\n                memcpy(buf, data, size);\n                ret = 0;\n            } else {\n                PyErr_Format(\n                    _CBOR2_CBORDecodeEOF,\n                    \"premature end of stream (expected to read %zd bytes, \"\n                    \"got %zd instead)\", size, PyBytes_GET_SIZE(obj));\n            }\n            Py_DECREF(obj);\n        }\n        Py_DECREF(size_obj);\n    }\n    return ret;\n}", "target": 1}
{"code": "static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);\n\tint ret;\n\tif (!synic->active && !host)\n\t\treturn 1;\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "void CefVideoConsumerOSR::OnFrameCaptured(\n    media::mojom::VideoBufferHandlePtr data,\n    media::mojom::VideoFrameInfoPtr info,\n    const gfx::Rect& content_rect,\n    mojo::PendingRemote<viz::mojom::FrameSinkVideoConsumerFrameCallbacks>\n        callbacks) {\n  ScopedVideoFrameDone scoped_done(std::move(callbacks));\n  if (info->pixel_format != media::PIXEL_FORMAT_ARGB) {\n    DLOG(ERROR) << \"Unsupported pixel format \" << info->pixel_format;\n    return;\n  }\n  CHECK(data->is_read_only_shmem_region());\n  base::ReadOnlySharedMemoryRegion& shmem_region =\n      data->get_read_only_shmem_region();\n  DCHECK(shmem_region.IsValid());\n  base::ReadOnlySharedMemoryMapping mapping = shmem_region.Map();\n  if (!mapping.IsValid()) {\n    DLOG(ERROR) << \"Shared memory mapping failed.\";\n    return;\n  }\n  if (mapping.size() <\n      media::VideoFrame::AllocationSize(info->pixel_format, info->coded_size)) {\n    DLOG(ERROR) << \"Shared memory size was less than expected.\";\n    return;\n  }\n  void* const pixels = const_cast<void*>(mapping.memory());\n  media::VideoFrameMetadata metadata = info->metadata;\n  gfx::Rect damage_rect;\n  if (bounds_in_pixels_) {\n    damage_rect = gfx::Rect(info->coded_size);\n    damage_rect.Intersect(*bounds_in_pixels_);\n    bounds_in_pixels_ = absl::nullopt;\n  } else {\n    if (metadata.capture_update_rect) {\n      damage_rect = *metadata.capture_update_rect;\n    }\n    if (damage_rect.IsEmpty()) {\n      damage_rect = gfx::Rect(info->coded_size);\n    }\n  }\n  view_->OnPaint(damage_rect, info->coded_size, pixels);\n}", "target": 0}
{"code": " void RootWindowHostWin::UnConfineCursor() {\n   ClipCursor(NULL);\n }", "target": 0}
{"code": "TfLiteStatus GetIntermediatesSafe(const TfLiteContext* context,\n                                  const TfLiteNode* node, int index,\n                                  TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(context, ValidateTensorIndexingSafe(\n                                 context, index, node->intermediates->size,\n                                 node->intermediates->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields)\n\t{\n\t\tif (fields->Buffer)\n\t\t{\n\t\t\tfree(fields->Buffer);\n\t\t\tfields->Len = 0;\n\t\t\tfields->MaxLen = 0;\n\t\t\tfields->Buffer = NULL;\n\t\t\tfields->BufferOffset = 0;\n\t\t}\n\t}\n}", "target": 1}
{"code": "static void draw_fill_color_rgb( wmfAPI* API, const wmfRGB* rgb )\n{\n  PixelWand\n    *fill_color;\n  fill_color=NewPixelWand();\n  PixelSetRedQuantum(fill_color,ScaleCharToQuantum(rgb->r));\n  PixelSetGreenQuantum(fill_color,ScaleCharToQuantum(rgb->g));\n  PixelSetBlueQuantum(fill_color,ScaleCharToQuantum(rgb->b));\n  PixelSetAlphaQuantum(fill_color,OpaqueAlpha);\n  DrawSetFillColor(WmfDrawingWand,fill_color);\n  fill_color=DestroyPixelWand(fill_color);\n}", "target": 0}
{"code": "void mk_request_free(struct session_request *sr)\n{\n    if (sr->fd_file > 0) {\n        mk_vhost_close(sr);\n    }\n    if (sr->headers.location) {\n        mk_mem_free(sr->headers.location);\n    }\n    if (sr->uri_processed.data != sr->uri.data) {\n        mk_ptr_free(&sr->uri_processed);\n    }\n    if (sr->real_path.data != sr->real_path_static) {\n        mk_ptr_free(&sr->real_path);\n    }\n}", "target": 1}
{"code": "static int CFScanDump_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {\n    RedisModule_AutoMemory(ctx);\n    if (argc != 3) {\n        return RedisModule_WrongArity(ctx);\n    }\n    long long pos;\n    if (RedisModule_StringToLongLong(argv[2], &pos) != REDISMODULE_OK) {\n        return RedisModule_ReplyWithError(ctx, \"Invalid position\");\n    }\n    RedisModuleKey *key = RedisModule_OpenKey(ctx, argv[1], REDISMODULE_READ);\n    CuckooFilter *cf;\n    int status = cfGetFilter(key, &cf);\n    if (status != SB_OK) {\n        return RedisModule_ReplyWithError(ctx, statusStrerror(status));\n    }\n    RedisModule_ReplyWithArray(ctx, 2);\n    if (!cf->numItems) {\n        RedisModule_ReplyWithLongLong(ctx, 0);\n        RedisModule_ReplyWithNull(ctx);\n        return REDISMODULE_OK;\n    }\n    if (pos == 0) {\n        CFHeader header;\n        fillCFHeader(&header, cf);\n        RedisModule_ReplyWithLongLong(ctx, 1);\n        RedisModule_ReplyWithStringBuffer(ctx, (const char *)&header, sizeof header);\n        return REDISMODULE_OK;\n    }\n    size_t chunkLen = 0;\n    const char *chunk = CF_GetEncodedChunk(cf, &pos, &chunkLen, MAX_SCANDUMP_SIZE);\n    if (chunk == NULL) {\n        RedisModule_ReplyWithLongLong(ctx, 0);\n        RedisModule_ReplyWithNull(ctx);\n    } else {\n        RedisModule_ReplyWithLongLong(ctx, pos);\n        RedisModule_ReplyWithStringBuffer(ctx, chunk, chunkLen);\n    }\n    return REDISMODULE_OK;\n}", "target": 1}
{"code": "struct clock_source *dcn20_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dcn20_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static void lwp_read_int64(FILE *fin, int64_t &d) {\n  fread(&d, sizeof(d), 1, fin);\n}", "target": 0}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteInt8);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  const int block_size = params->block_size;\n  TF_LITE_ENSURE(context, block_size > 0);\n  const int input_height = input->dims->data[kHeightRank];\n  const int input_width = input->dims->data[kWidthRank];\n  const int input_channels = input->dims->data[kDepthRank];\n  int output_height = input_height * block_size;\n  int output_width = input_width * block_size;\n  int output_channels = input_channels / block_size / block_size;\n  TF_LITE_ENSURE_EQ(context, input_height, output_height / block_size);\n  TF_LITE_ENSURE_EQ(context, input_width, output_width / block_size);\n  TF_LITE_ENSURE_EQ(context, input_channels,\n                    output_channels * block_size * block_size);\n  TfLiteEvalTensor* output_eval =\n      tflite::micro::GetEvalOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_OK(context, tflite::micro::CreateWritableTensorDimsWithCopy(\n                                 context, output, output_eval));\n  output->dims->data[kBatchRank] = input->dims->data[kBatchRank];\n  output->dims->data[kHeightRank] = output_height;\n  output->dims->data[kWidthRank] = output_width;\n  output->dims->data[kDepthRank] = output_channels;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "print_al(const gs_memory_t *mem, const char *label, const active_line * alp)\n{\n    if (gs_debug_c('F'))\n        print_active_line(mem, label, alp);\n}", "target": 0}
{"code": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\tif (!update || !s)\n\t\treturn NULL;\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); \n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       \n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       \n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\tStream_Seek_UINT8(s);                      \n\tStream_Seek_UINT8(s);                      \n\tStream_Read_UINT8(s, bitmapData->codecID); \n\tStream_Read_UINT16(s, bitmapData->width);  \n\tStream_Read_UINT16(s, bitmapData->height); \n\tStream_Read_UINT32(s, new_len);            \n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\tif (!new_data)\n\t\tgoto fail;\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}", "target": 1}
{"code": "ev_archive_read_data (EvArchive *archive,\n\t\t      void      *buf,\n\t\t      gsize      count,\n\t\t      GError   **error)\n{\n\tgssize r = -1;\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), -1);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, -1);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_NONE:\n\t\tg_assert_not_reached ();\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_return_val_if_fail (archive->libar_entry != NULL, -1);\n\t\tr = archive_read_data (archive->libar, buf, count);\n\t\tif (r < 0) {\n\t\t\tg_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n\t\t\t\t     \"Failed to decompress data: %s\", archive_error_string (archive->libar));\n\t\t}\n\t\tbreak;\n\t}\n\treturn r;\n}", "target": 0}
{"code": "initpyfribidi (void)\n{\n\tPyObject *module;\n\tmodule = Py_InitModule3 (\"pyfribidi\", PyfribidiMethods,\n\t\t\t\t _pyfribidi__doc__);\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n\tPyModule_AddStringConstant (module, \"__author__\",\n\t\t\t\t    \"Yaacov Zamir and Nir Soffer\");\n}", "target": 1}
{"code": "static int oidc_cache_crypto_decrypt_impl(request_rec *r,\n\t\tunsigned char *ciphertext, int ciphertext_len, const unsigned char *aad,\n\t\tint aad_len, const unsigned char *tag, int tag_len, unsigned char *key,\n\t\tconst unsigned char *iv, int iv_len, unsigned char *plaintext) {\n\tEVP_CIPHER_CTX *ctx;\n\tint len;\n\tint plaintext_len;\n\tint ret;\n\tif (!(ctx = EVP_CIPHER_CTX_new())) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_new\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptInit_ex(ctx, OIDC_CACHE_CIPHER, NULL, NULL, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_IVLEN, iv_len, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptInit_ex(ctx, NULL, NULL, key, iv)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptUpdate(ctx, NULL, &len, aad, aad_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate aad: aad_len=%d\",\n\t\t\t\taad_len);\n\t\treturn -1;\n\t}\n\tif (!EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext, ciphertext_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate ciphertext\");\n\t\treturn -1;\n\t}\n\tplaintext_len = len;\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_TAG, tag_len,\n\t\t\t(void *) tag)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tret = EVP_DecryptFinal_ex(ctx, plaintext + len, &len);\n\tEVP_CIPHER_CTX_free(ctx);\n\tif (ret > 0) {\n\t\tplaintext_len += len;\n\t\treturn plaintext_len;\n\t} else {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptFinal_ex\");\n\t\treturn -1;\n\t}\n}", "target": 1}
{"code": "static GroupList collectGroups(const std::string &fulltext)\n{\n\tGroupList groupList; \n\tint lineNo = 1; \n\tbool inString = false; \n\tfor (unsigned int i=0; i<fulltext.length(); ++i) {\n\t\tif (fulltext[i] == '\\n') {\n\t\t\tlineNo++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (inString && fulltext.compare(i, 2, \"\\\\\\\"\") == 0) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (fulltext[i] == '\"') {\n\t\t\tinString = !inString;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!inString && fulltext.compare(i, 2, \"\n\t\t\ti++;\n\t\t\twhile (fulltext[i] != '\\n' && i<fulltext.length() ) i++;\n\t\t\tlineNo++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!inString && fulltext.compare(i, 2, \" every character is comment\n\t\t\twhile (fulltext.compare(i, 2, \"*/\") != 0 && i<fulltext.length()) {\n\t\t\t\tif(fulltext[i]=='\\n'){\n\t\t\t\t\tlineNo++;\n\t\t\t\t\tisGroup=false;\n\t\t\t\t}\n\t\t\t\tcomment += fulltext[i];\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif(isGroup)\n\t\t\t\tgroupList.push_back(createGroup(comment,lineNo));\n\t\t}\n\t}\n\treturn groupList;\n}", "target": 0}
{"code": "static inline int mb2_cache_entry_put(struct mb2_cache *cache,\n\t\t\t\t      struct mb2_cache_entry *entry)\n{\n\tif (!atomic_dec_and_test(&entry->e_refcnt))\n\t\treturn 0;\n\t__mb2_cache_entry_free(entry);\n\treturn 1;\n}", "target": 0}
{"code": "void TestSocketLineReader::badData()\n{\n    const QList<QByteArray> dataToSend = { \"data1\\n\", \"data\" }; \n    for (const QByteArray& line : qAsConst(dataToSend)) {\n        m_conn->write(line);\n    }\n    m_conn->flush();\n    QSignalSpy spy(m_server, &QTcpServer::newConnection);\n    QVERIFY(m_server->hasPendingConnections() || spy.wait(1000));\n    QSslSocket* sock = m_server->nextPendingConnection();\n    QVERIFY2(sock != nullptr, \"Could not open a connection to the client\");\n    m_reader = new SocketLineReader(sock, this);\n    connect(m_reader, &SocketLineReader::readyRead, this, &TestSocketLineReader::newPacket);\n    m_timer.start();\n    m_loop.exec();\n    QCOMPARE(m_packets.count(), 1);\n    QCOMPARE(m_packets[0], dataToSend[0]);\n}", "target": 0}
{"code": "static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {\n\tif (disk != NULL) {\n\t\tconst int blocksize = 512; \n\t\tint ret;\n\t\tRIOBind *iob = disk->data;\n\t\tif (bio) iob = bio;\n\t\tret = iob->read_at (iob->io, delta+(blocksize*sector),\n\t\t\t(ut8*)buf, size*blocksize);\n\t\tif (ret == -1)\n\t\t\treturn 1;\n\t} else eprintf (\"oops. no disk\\n\");\n\treturn 0; \n}", "target": 1}
{"code": "Status QuantizeV2Shape(InferenceContext* c) {\n  int axis = -1;\n  Status s = c->GetAttr(\"axis\", &axis);\n  if (!s.ok() && s.code() != error::NOT_FOUND) {\n    return s;\n  }\n  if (axis < -1) {\n    return errors::InvalidArgument(\"axis should be at least -1, got \", axis);\n  }\n  const int minmax_rank = (axis == -1) ? 0 : 1;\n  TF_RETURN_IF_ERROR(shape_inference::UnchangedShape(c));\n  ShapeHandle minmax;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(1), minmax_rank, &minmax));\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(2), minmax_rank, &minmax));\n  if (axis != -1) {\n    ShapeHandle input;\n    TF_RETURN_IF_ERROR(c->WithRankAtLeast(c->input(0), axis + 1, &input));\n    DimensionHandle depth;\n    TF_RETURN_IF_ERROR(\n        c->Merge(c->Dim(minmax, 0), c->Dim(input, axis), &depth));\n  }\n  c->set_output(1, minmax);\n  c->set_output(2, minmax);\n  return Status::OK();\n}", "target": 0}
{"code": "snmp_engine_get(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_NO_SUCH_INSTANCE;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static inline void set_attr(map<string, bufferlist>& attrs, const char* key, const char* value)\n{\n  bufferlist bl;\n  encode(value,bl);\n  attrs.emplace(key, std::move(bl));\n}", "target": 0}
{"code": "static inline int copy_regset_from_user(struct task_struct *target,\n\t\t\t\t\tconst struct user_regset_view *view,\n\t\t\t\t\tunsigned int setno,\n\t\t\t\t\tunsigned int offset, unsigned int size,\n\t\t\t\t\tconst void __user *data)\n{\n\tconst struct user_regset *regset = &view->regsets[setno];\n\tif (!regset->set)\n\t\treturn -EOPNOTSUPP;\n\tif (!access_ok(VERIFY_READ, data, size))\n\t\treturn -EIO;\n\treturn regset->set(target, regset, offset, size, NULL, data);\n}", "target": 0}
{"code": "cib_remote_signon(cib_t * cib, const char *name, enum cib_conn_type type)\n{\n    int rc = pcmk_ok;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    if (private->passwd == NULL) {\n        struct termios settings;\n        int rc;\n        rc = tcgetattr(0, &settings);\n        settings.c_lflag &= ~ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n        fprintf(stderr, \"Password: \");\n        private->passwd = calloc(1, 1024);\n        rc = scanf(\"%s\", private->passwd);\n        fprintf(stdout, \"\\n\");\n        if (rc < 1) {\n            private->passwd = NULL;\n        }\n        settings.c_lflag |= ECHO;\n        rc = tcsetattr(0, TCSANOW, &settings);\n    }\n    if (private->server == NULL || private->user == NULL) {\n        rc = -EINVAL;\n    }\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->command));\n    }\n    if (rc == pcmk_ok) {\n        rc = cib_tls_signon(cib, &(private->callback));\n    }\n    if (rc == pcmk_ok) {\n        xmlNode *hello =\n            cib_create_op(0, private->callback.token, CRM_OP_REGISTER, NULL, NULL, NULL, 0, NULL);\n        crm_xml_add(hello, F_CIB_CLIENTNAME, name);\n        crm_send_remote_msg(private->command.session, hello, private->command.encrypted);\n        free_xml(hello);\n    }\n    if (rc == pcmk_ok) {\n        fprintf(stderr, \"%s: Opened connection to %s:%d\\n\", name, private->server, private->port);\n        cib->state = cib_connected_command;\n        cib->type = cib_command;\n    } else {\n        fprintf(stderr, \"%s: Connection to %s:%d failed: %s\\n\",\n                name, private->server, private->port, pcmk_strerror(rc));\n    }\n    return rc;\n}", "target": 1}
{"code": "int bson_ensure_space( bson *b, const int bytesNeeded ) {\n    int pos = b->cur - b->data;\n    char *orig = b->data;\n    int new_size;\n    if ( pos + bytesNeeded <= b->dataSize )\n        return BSON_OK;\n    new_size = 1.5 * ( b->dataSize + bytesNeeded );\n    if( new_size < b->dataSize ) {\n        if( ( b->dataSize + bytesNeeded ) < INT_MAX )\n            new_size = INT_MAX;\n        else {\n            b->err = BSON_SIZE_OVERFLOW;\n            return BSON_ERROR;\n        }\n    }\n    b->data = bson_realloc( b->data, new_size );\n    if ( !b->data )\n        bson_fatal_msg( !!b->data, \"realloc() failed\" );\n    b->dataSize = new_size;\n    b->cur += b->data - orig;\n    return BSON_OK;\n}", "target": 1}
{"code": "MOBI_RET mobi_search_links_kf7(MOBIResult *result, const unsigned char *data_start, const unsigned char *data_end) {\n    if (!result) {\n        debug_print(\"Result structure is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    result->start = result->end = NULL;\n    *(result->value) = '\\0';\n    if (!data_start || !data_end) {\n        debug_print(\"Data is null%s\", \"\\n\");\n        return MOBI_PARAM_ERR;\n    }\n    const char *needle1 = \"filepos=\";\n    const char *needle2 = \"recindex=\";\n    const size_t needle1_length = strlen(needle1);\n    const size_t needle2_length = strlen(needle2);\n    const size_t needle_length = max(needle1_length,needle2_length);\n    if (data_start + needle_length > data_end) {\n        return MOBI_SUCCESS;\n    }\n    unsigned char *data = (unsigned char *) data_start;\n    const unsigned char tag_open = '<';\n    const unsigned char tag_close = '>';\n    unsigned char last_border = tag_open;\n    while (data <= data_end) {\n        if (*data == tag_open || *data == tag_close) {\n            last_border = *data;\n        }\n        if (data + needle_length <= data_end &&\n            (memcmp(data, needle1, needle1_length) == 0 ||\n             memcmp(data, needle2, needle2_length) == 0)) {\n                if (last_border != tag_open) {\n                    data += needle_length;\n                    continue;\n                }\n                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                if (*(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "struct clock_source *dce110_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce110_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "smix(uint8_t * B, size_t r, uint64_t N, void * V, void * XY)\n{\n  __m128i * X = (__m128i *) XY;\n  __m128i * Y = (__m128i *) ((uintptr_t)(XY) + 128 * r);\n  __m128i * Z = (__m128i *) ((uintptr_t)(XY) + 256 * r);\n  uint32_t * X32 = (uint32_t *)X;\n  uint64_t i, j;\n  size_t k;\n  for (k = 0; k < 2 * r; k++) {\n    for (i = 0; i < 16; i++) {\n      X32[k * 16 + i] = folly::Endian::little32(\n                          *((uint32_t *) &B[(k * 16 + (i * 5 % 16)) * 4]));\n    }\n  }\n  for (i = 0; i < N; i += 2) {\n    blkcpy((void *)((uintptr_t)(V) + i * 128 * r), X, 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    blkcpy((void *)((uintptr_t)(V) + (i + 1) * 128 * r),\n        Y, 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (i = 0; i < N; i += 2) {\n    j = integerify(X, r) & (N - 1);\n    blkxor(X, (void *)((uintptr_t)(V) + j * 128 * r), 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    j = integerify(Y, r) & (N - 1);\n    blkxor(Y, (void *)((uintptr_t)(V) + j * 128 * r), 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (k = 0; k < 2 * r; k++) {\n    for (i = 0; i < 16; i++) {\n      *((uint32_t *) &B[(k * 16 + (i * 5 % 16)) * 4]) =\n          folly::Endian::little32(X32[k * 16 + i]);\n    }\n  }\n}", "target": 1}
{"code": "GF_Err gf_media_change_pl(GF_ISOFile *file, u32 track, u32 profile, u32 compat, u32 level)\n{\n\tu32 i, count, stype;\n\tGF_Err e;\n\tGF_AVCConfig *avcc;\n\tstype = gf_isom_get_media_subtype(file, track, 1);\n\tswitch (stype) {\n\tcase GF_ISOM_SUBTYPE_AVC_H264:\n\tcase GF_ISOM_SUBTYPE_AVC2_H264:\n\tcase GF_ISOM_SUBTYPE_AVC3_H264:\n\tcase GF_ISOM_SUBTYPE_AVC4_H264:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_OK;\n\t}\n\tavcc = gf_isom_avc_config_get(file, track, 1);\n\tif (!avcc)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tif (level) avcc->AVCLevelIndication = level;\n\tif (compat) avcc->profile_compatibility = compat;\n\tif (profile) avcc->AVCProfileIndication = profile;\n\tcount = gf_list_count(avcc->sequenceParameterSets);\n\tfor (i=0; i<count; i++) {\n\t\tGF_NALUFFParam *slc = gf_list_get(avcc->sequenceParameterSets, i);\n\t\tif (profile) slc->data[1] = profile;\n\t\tif (level) slc->data[3] = level;\n\t}\n\te = gf_isom_avc_config_update(file, track, 1, avcc);\n\tgf_odf_avc_cfg_del(avcc);\n\treturn e;\n}", "target": 0}
{"code": "static bool add_free_nid(struct f2fs_sb_info *sbi, nid_t nid, bool build)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct free_nid *i;\n\tstruct nat_entry *ne;\n\tint err;\n\tif (unlikely(nid == 0))\n\t\treturn false;\n\tif (build) {\n\t\tne = __lookup_nat_cache(nm_i, nid);\n\t\tif (ne && (!get_nat_flag(ne, IS_CHECKPOINTED) ||\n\t\t\t\tnat_get_blkaddr(ne) != NULL_ADDR))\n\t\t\treturn false;\n\t}\n\ti = f2fs_kmem_cache_alloc(free_nid_slab, GFP_NOFS);\n\ti->nid = nid;\n\ti->state = NID_NEW;\n\tif (radix_tree_preload(GFP_NOFS)) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\tspin_lock(&nm_i->nid_list_lock);\n\terr = __insert_nid_to_list(sbi, i, FREE_NID_LIST, true);\n\tspin_unlock(&nm_i->nid_list_lock);\n\tradix_tree_preload_end();\n\tif (err) {\n\t\tkmem_cache_free(free_nid_slab, i);\n\t\treturn true;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "static void TEST_sub_add_single(void)\n{\n\tstruct mosquitto__config config;\n\tstruct mosquitto__listener listener;\n\tstruct mosquitto context;\n\tstruct mosquitto__subhier *sub;\n\tint rc;\n\tmemset(&db, 0, sizeof(struct mosquitto_db));\n\tmemset(&config, 0, sizeof(struct mosquitto__config));\n\tmemset(&listener, 0, sizeof(struct mosquitto__listener));\n\tmemset(&context, 0, sizeof(struct mosquitto));\n\tcontext.id = \"client\";\n\tdb.config = &config;\n\tlistener.port = 1883;\n\tconfig.listeners = &listener;\n\tconfig.listener_count = 1;\n\tdb__open(&config);\n\trc = sub__add(&context, \"a/b/c/d/e\", 0, 0, 0);\n\tCU_ASSERT_EQUAL(rc, MOSQ_ERR_SUCCESS);\n\tCU_ASSERT_PTR_NOT_NULL(db.subs);\n\tif(db.subs){\n\t\tsub = db.subs;\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"\");\n\t\thier_quick_check(&sub, NULL, \"a\");\n\t\thier_quick_check(&sub, NULL, \"b\");\n\t\thier_quick_check(&sub, NULL, \"c\");\n\t\thier_quick_check(&sub, NULL, \"d\");\n\t\thier_quick_check(&sub, &context, \"e\");\n\t\tCU_ASSERT_PTR_NULL(sub);\n\t}\n\tmosquitto__free(context.subs);\n\tdb__close();\n}", "target": 1}
{"code": "int bad_format(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == 's' || *ptr == 'S' || *ptr == '%')\n                ptr++;\n            else if (*ptr == 'c') {\n                ptr++;\n                n = 1;\n            }\n            else {\n                if (*ptr == ' ' || *ptr == '+' || *ptr == '-')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr == '.')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'e' || *ptr == 'f' || *ptr == 'g')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 1);\n}", "target": 1}
{"code": "MagickExport MemoryInfo *AcquireVirtualMemory(const size_t count,\n  const size_t quantum)\n{\n  MemoryInfo\n    *memory_info;\n  size_t\n    extent;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((MemoryInfo *) NULL);\n  memory_info=(MemoryInfo *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    sizeof(*memory_info)));\n  if (memory_info == (MemoryInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(memory_info,0,sizeof(*memory_info));\n  extent=count*quantum;\n  memory_info->length=extent;\n  memory_info->signature=MagickCoreSignature;\n  if (AcquireMagickResource(MemoryResource,extent) != MagickFalse)\n    {\n      memory_info->blob=AcquireAlignedMemory(1,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=AlignedVirtualMemory;\n          return(memory_info);\n        }\n    }\n  RelinquishMagickResource(MemoryResource,extent);\n  if (AcquireMagickResource(MapResource,extent) != MagickFalse)\n    {\n      memory_info->blob=MapBlob(-1,IOMode,0,extent);\n      if (memory_info->blob != NULL)\n        {\n          memory_info->type=MapVirtualMemory;\n          return(memory_info);\n        }\n      if (AcquireMagickResource(DiskResource,extent) != MagickFalse)\n        {\n          int\n            file;\n          file=AcquireUniqueFileResource(memory_info->filename);\n          if (file != -1)\n            {\n              MagickOffsetType\n                offset;\n              offset=(MagickOffsetType) lseek(file,extent-1,SEEK_SET);\n              if ((offset == (MagickOffsetType) (extent-1)) &&\n                  (write(file,\"\",1) == 1))\n                {\n                  memory_info->blob=MapBlob(file,IOMode,0,extent);\n                  if (memory_info->blob != NULL)\n                    {\n                      (void) close(file);\n                      memory_info->type=MapVirtualMemory;\n                      return(memory_info);\n                    }\n                }\n              (void) close(file);\n              (void) RelinquishUniqueFileResource(memory_info->filename);\n              *memory_info->filename = '\\0';\n            }\n        }\n      RelinquishMagickResource(DiskResource,extent);\n    }\n  RelinquishMagickResource(MapResource,extent);\n  if (memory_info->blob == NULL)\n    {\n      memory_info->blob=AcquireMagickMemory(extent);\n      if (memory_info->blob != NULL)\n        memory_info->type=UnalignedVirtualMemory;\n    }\n  if (memory_info->blob == NULL)\n    memory_info=RelinquishVirtualMemory(memory_info);\n  return(memory_info);\n}", "target": 1}
{"code": "    template<typename t>\n    CImg<T>& operator+=(const t value) {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=524288))\n      cimg_rof(*this,ptrd,T) *ptrd = (T)(*ptrd + value);\n      return *this;", "target": 0}
{"code": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  \n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}", "target": 1}
{"code": "decode_NXAST_RAW_ENCAP(const struct nx_action_encap *nae,\n                       enum ofp_version ofp_version OVS_UNUSED,\n                       struct ofpbuf *out)\n{\n    struct ofpact_encap *encap;\n    const struct ofp_ed_prop_header *ofp_prop;\n    const size_t encap_ofs = out->size;\n    size_t props_len;\n    uint16_t n_props = 0;\n    int err;\n    encap = ofpact_put_ENCAP(out);\n    encap->ofpact.raw = NXAST_RAW_ENCAP;\n    switch (ntohl(nae->new_pkt_type)) {\n    case PT_ETH:\n    case PT_NSH:\n        break;\n    default:\n        return OFPERR_NXBAC_BAD_HEADER_TYPE;\n    }\n    encap->new_pkt_type = nae->new_pkt_type;\n    encap->hdr_size = ntohs(nae->hdr_size);\n    ofp_prop = nae->props;\n    props_len = ntohs(nae->len) - offsetof(struct nx_action_encap, props);\n    n_props = 0;\n    while (props_len > 0) {\n        err = decode_ed_prop(&ofp_prop, out, &props_len);\n        if (err) {\n            return err;\n        }\n        n_props++;\n    }\n    encap = ofpbuf_at_assert(out, encap_ofs, sizeof *encap);\n    encap->n_props = n_props;\n    out->header = &encap->ofpact;\n    ofpact_finish_ENCAP(out, &encap);\n    return 0;\n}", "target": 0}
{"code": "static void packet_flush_mclist(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_mclist *ml;\n\tif (!po->mclist)\n\t\treturn;\n\trtnl_lock();\n\twhile ((ml = po->mclist) != NULL) {\n\t\tstruct net_device *dev;\n\t\tpo->mclist = ml->next;\n\t\tdev = __dev_get_by_index(sock_net(sk), ml->ifindex);\n\t\tif (dev != NULL)\n\t\t\tpacket_dev_mc(dev, ml, -1);\n\t\tkfree(ml);\n\t}\n\trtnl_unlock();\n}", "target": 0}
{"code": "static int logi_dj_ll_raw_request(struct hid_device *hid,\n\t\t\t\t  unsigned char reportnum, __u8 *buf,\n\t\t\t\t  size_t count, unsigned char report_type,\n\t\t\t\t  int reqtype)\n{\n\tstruct dj_device *djdev = hid->driver_data;\n\tstruct dj_receiver_dev *djrcv_dev = djdev->dj_receiver_dev;\n\tu8 *out_buf;\n\tint ret;\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\tkfree(out_buf);\n\treturn ret;\n}", "target": 1}
{"code": "static bool read_header_from_file(zckCtx *zck) {\n    if(zck->lead_size == 0 || zck->header_length == 0) {\n        set_error(zck, \"Lead and header sizes are both 0.  Have you run zck_read_lead() yet?\");\n        return false;\n    }\n    zck->header = zrealloc(zck->header, zck->lead_size + zck->header_length);\n    if (!zck->header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck->lead_string = zck->header;\n    char *header = zck->header + zck->lead_size;\n    size_t loaded = 0;\n    if(zck->header_length < zck->header_size - zck->lead_size) {\n        set_fatal_error(zck, \"Header size is too small for actual data\");\n        return false;\n    }\n    if(zck->lead_size < zck->header_size)\n        loaded = zck->header_size - zck->lead_size;\n    zck_log(ZCK_LOG_DEBUG, \"Reading the rest of the header: %llu bytes\",\n            (long long unsigned) zck->header_length);\n    if(loaded < zck->header_length) {\n        if(read_data(zck, header + loaded, zck->header_length - loaded) < zck->header_length - loaded) {\n            set_fatal_error(zck, \"Unable to read %llu bytes from the file\", zck->header_length - loaded);\n            return false;\n        }\n        zck->header_size = zck->lead_size + zck->header_length;\n    }\n    if(!hash_init(zck, &(zck->check_full_hash), &(zck->hash_type)))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), \"\\0ZCK1\", 5))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), zck->header+5,\n                    zck->hdr_digest_loc-5))\n        return false;\n    if(!hash_update(zck, &(zck->check_full_hash), header, zck->header_length))\n        return false;\n    int ret = validate_header(zck);\n    if(ret < 1) {\n        if(ret == -1)\n            set_fatal_error(zck, \"Header checksum failed verification\");\n        return false;\n    }\n    return true;\n}", "target": 1}
{"code": "static void do_pclose(FILE *fin, FILE *fout) {\n  char buf[BUFFER_SIZE];\n  int64_t fptr = 0;\n  read_buf(fin, buf);\n  sscanf(buf, \"%\" PRId64, &fptr);\n  FILE *f = (FILE *)fptr;\n  int ret = ::pclose(f);\n  fprintf(fout, \"%d\\n\", ret);\n  if (ret < 0) {\n    fprintf(fout, \"%d\\n\", errno);\n  }\n  fflush(fout);\n}", "target": 1}
{"code": "void nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx,\n\t\t\tu8 comm_mode, u8 rf_mode)\n{\n\tstruct nfc_llcp_local *local;\n\tpr_debug(\"rf mode %d\\n\", rf_mode);\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL)\n\t\treturn;\n\tlocal->target_idx = target_idx;\n\tlocal->comm_mode = comm_mode;\n\tlocal->rf_mode = rf_mode;\n\tif (rf_mode == NFC_RF_INITIATOR) {\n\t\tpr_debug(\"Queueing Tx work\\n\");\n\t\tschedule_work(&local->tx_work);\n\t} else {\n\t\tmod_timer(&local->link_timer,\n\t\t\t  jiffies + msecs_to_jiffies(local->remote_lto));\n\t}\n\tnfc_llcp_local_put(local);\n}", "target": 0}
{"code": "snmp_ber_encode_unsigned_integer(unsigned char *out, uint32_t *out_len, uint8_t type, uint32_t number)\n{\n  uint32_t original_out_len;\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, type);\n  return out;\n}", "target": 1}
{"code": "CoreBasicHandler::CoreBasicHandler(CoreNetwork *parent)\n    : BasicHandler(parent),\n    _network(parent)\n{\n    connect(this, SIGNAL(displayMsg(Message::Type, BufferInfo::Type, const QString &, const QString &, const QString &, Message::Flags)),\n        network(), SLOT(displayMsg(Message::Type, BufferInfo::Type, const QString &, const QString &, const QString &, Message::Flags)));\n    connect(this, SIGNAL(putCmd(QString, const QList<QByteArray> &, const QByteArray &)),\n        network(), SLOT(putCmd(QString, const QList<QByteArray> &, const QByteArray &)));\n    connect(this, SIGNAL(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)),\n        network(), SLOT(putCmd(QString, const QList<QList<QByteArray>> &, const QByteArray &)));\n    connect(this, SIGNAL(putRawLine(const QByteArray &)),\n        network(), SLOT(putRawLine(const QByteArray &)));\n}", "target": 0}
{"code": "int rose_add_loopback_node(const rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\tint err = 0;\n\tspin_lock_bh(&rose_node_list_lock);\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t     (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t     rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\tif (rose_node != NULL)\n\t\tgoto out;\n\tif ((rose_node = kmalloc(sizeof(*rose_node), GFP_ATOMIC)) == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\trose_node->address      = *address;\n\trose_node->mask         = 10;\n\trose_node->count        = 1;\n\trose_node->loopback     = 1;\n\trose_node->neighbour[0] = rose_loopback_neigh;\n\trose_node->next = rose_node_list;\n\trose_node_list  = rose_node;\n\trose_loopback_neigh->count++;\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n\treturn err;\n}", "target": 0}
{"code": "static bool check_buffer(RBinFile *bf, RBuffer *b) {\n\tut8 buf[4];\n\tr_buf_read_at (b, 0, buf, sizeof (buf));\n\treturn !memcmp (buf, \"\\x02\\xff\\x01\\xff\", 4);\n}", "target": 0}
{"code": "gen_hash(codegen_scope *s, node *tree, int val, int limit)\n{\n  int slimit = GEN_VAL_STACK_MAX;\n  if (cursp() >= GEN_LIT_ARY_MAX) slimit = INT16_MAX;\n  int len = 0;\n  mrb_bool update = FALSE;\n  while (tree) {\n    if (nint(tree->car->car->car) == NODE_KW_REST_ARGS) {\n      if (val && len > 0) {\n        pop_n(len*2);\n        if (!update) {\n          genop_2(s, OP_HASH, cursp(), len);\n        }\n        else {\n          pop();\n          genop_2(s, OP_HASHADD, cursp(), len);\n        }\n        push();\n      }\n      codegen(s, tree->car->cdr, val);\n      if (val && (len > 0 || update)) {\n        pop(); pop();\n        genop_1(s, OP_HASHCAT, cursp());\n        push();\n      }\n      update = TRUE;\n      len = 0;\n    }\n    else {\n      codegen(s, tree->car->car, val);\n      codegen(s, tree->car->cdr, val);\n      len++;\n    }\n    tree = tree->cdr;\n    if (val && cursp() >= slimit) {\n      pop_n(len*2);\n      if (!update) {\n        genop_2(s, OP_HASH, cursp(), len);\n      }\n      else {\n        pop();\n        genop_2(s, OP_HASHADD, cursp(), len);\n      }\n      push();\n      update = TRUE;\n      len = 0;\n    }\n  }\n  if (update) {\n    if (val && len > 0) {\n      pop_n(len*2+1);\n      genop_2(s, OP_HASHADD, cursp(), len);\n      push();\n    }\n    return -1;                  \n  }\n  return len;\n}", "target": 0}
{"code": "    size_t Exifdatum::size() const\n    {\n        return value_.get() == 0 ? 0 : value_->size();\n    }", "target": 0}
{"code": "static int muscle_delete_file(sc_card_t *card, const sc_path_t *path_in)\n{\n\tmscfs_t *fs = MUSCLE_FS(card);\n\tmscfs_file_t *file_data = NULL;\n\tint r = 0;\n\tr = mscfs_loadFileInfo(fs, path_in->value, path_in->len, &file_data, NULL);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\tr = muscle_delete_mscfs_file(card, file_data);\n\tmscfs_clear_cache(fs);\n\tif(r < 0) SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE,r);\n\treturn 0;\n}", "target": 0}
{"code": "PrimitiveStatus TrustedPrimitives::UntrustedCall(uint64_t untrusted_selector,\n                                                 MessageWriter *input,\n                                                 MessageReader *output) {\n  int ret;\n  UntrustedCacheMalloc *untrusted_cache = UntrustedCacheMalloc::Instance();\n  SgxParams *const sgx_params =\n      reinterpret_cast<SgxParams *>(untrusted_cache->Malloc(sizeof(SgxParams)));\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params, sizeof(SgxParams))) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param should be in untrusted memory\");\n  }\n  Cleanup clean_up(\n      [sgx_params, untrusted_cache] { untrusted_cache->Free(sgx_params); });\n  sgx_params->input_size = 0;\n  sgx_params->input = nullptr;\n  if (input) {\n    sgx_params->input_size = input->MessageSize();\n    if (sgx_params->input_size > 0) {\n      sgx_params->input = untrusted_cache->Malloc(sgx_params->input_size);\n      if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->input,\n                                               sgx_params->input_size)) {\n        TrustedPrimitives::BestEffortAbort(\n            \"UntrustedCall: sgx_param input should be in untrusted memory\");\n      }\n      input->Serialize(const_cast<void *>(sgx_params->input));\n    }\n  }\n  sgx_params->output_size = 0;\n  sgx_params->output = nullptr;\n  CHECK_OCALL(\n      ocall_dispatch_untrusted_call(&ret, untrusted_selector, sgx_params));\n  if (sgx_params->input) {\n    untrusted_cache->Free(const_cast<void *>(sgx_params->input));\n  }\n  if (!TrustedPrimitives::IsOutsideEnclave(sgx_params->output,\n                                           sgx_params->output_size)) {\n    TrustedPrimitives::BestEffortAbort(\n        \"UntrustedCall: sgx_param output should be in untrusted memory\");\n  }\n  if (sgx_params->output) {\n    output->Deserialize(sgx_params->output, sgx_params->output_size);\n    TrustedPrimitives::UntrustedLocalFree(sgx_params->output);\n  }\n  return PrimitiveStatus::OkStatus();\n}", "target": 1}
{"code": "static void fio_cluster_listen_on_close(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  free(protocol);\n  cluster_data.uuid = -1;\n  if (fio_parent_pid() == getpid()) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) stopped listening for cluster connections\",\n                  (int)getpid());\n#endif\n    if (fio_data->active)\n      fio_stop();\n  }\n  (void)uuid;\n}", "target": 1}
{"code": "static int xar_get_numeric_from_xml_element(xmlTextReaderPtr reader, long * value)\n{\n    const xmlChar * numstr;\n    if (xmlTextReaderRead(reader) == 1 && xmlTextReaderNodeType(reader) == XML_READER_TYPE_TEXT) {\n        numstr = xmlTextReaderConstValue(reader);\n        if (numstr) {\n            *value = atol((const char *)numstr);\n            if (*value < 0) {\n                cli_dbgmsg(\"cli_scanxar: XML element value %li\\n\", *value);\n                return CL_EFORMAT;\n            }\n            return CL_SUCCESS;\n        }\n    }\n    cli_dbgmsg(\"cli_scanxar: No text for XML element\\n\");\n    return CL_EFORMAT;\n}", "target": 1}
{"code": "static Jsi_RC DebugRemoveCmd_(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr, int op)\n{\n    Jsi_Value *val = Jsi_ValueArrayIndex(interp, args, 0);\n    if (interp->breakpointHash)\n    {\n        int num;\n        char nbuf[100];\n        if (Jsi_GetIntFromValue(interp, val, &num) != JSI_OK) \n            return Jsi_LogError(\"bad number\");\n        snprintf(nbuf, sizeof(nbuf), \"%d\", num);\n        Jsi_HashEntry *hPtr = Jsi_HashEntryFind(interp->breakpointHash, nbuf);\n        jsi_BreakPoint* bptr;\n        if (hPtr && (bptr = (jsi_BreakPoint*)Jsi_HashValueGet(hPtr))) {\n            switch (op) {\n                case 1: bptr->enabled = 0; break;\n                case 2: bptr->enabled = 1; break;\n                default:\n                    Jsi_HashEntryDelete(hPtr);\n            }\n            return JSI_OK;\n        }\n    }\n    return Jsi_LogError(\"unknown breakpoint\");\n}", "target": 1}
{"code": "static int oidc_request_post_preserved_restore(request_rec *r,\n\t\tconst char *original_url) {\n\toidc_debug(r, \"enter: original_url=%s\", original_url);\n\tconst char *method = \"postOnLoad\";\n\tconst char *script =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function str_decode(string) {\\n\"\n\t\t\t\t\t\"        try {\\n\"\n\t\t\t\t\t\"          result = decodeURIComponent(string);\\n\"\n\t\t\t\t\t\"        } catch (e) {\\n\"\n\t\t\t\t\t\"          result =  unescape(string);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        return result;\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\\n\"\n\t\t\t\t\t\"\t\t sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\\n\"\n\t\t\t\t\t\"        for (var key in mod_auth_openidc_preserve_post_params) {\\n\"\n\t\t\t\t\t\"          var input = document.createElement(\\\"input\\\");\\n\"\n\t\t\t\t\t\"          input.name = str_decode(key);\\n\"\n\t\t\t\t\t\"          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\\n\"\n\t\t\t\t\t\"          input.type = \\\"hidden\\\";\\n\"\n\t\t\t\t\t\"          document.forms[0].appendChild(input);\\n\"\n\t\t\t\t\t\"        }\\n\"\n\t\t\t\t\t\"        document.forms[0].action = '%s';\\n\"\n\t\t\t\t\t\"        document.forms[0].submit();\\n\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", method, original_url);\n\tconst char *body = \"    <p>Restoring...</p>\\n\"\n\t\t\t\"    <form method=\\\"post\\\"></form>\\n\";\n\treturn oidc_util_html_send(r, \"Restoring...\", script, method, body,\n\t\t\tOK);\n}", "target": 1}
{"code": "ciEnv::ciEnv(CompileTask* task)\n  : _ciEnv_arena(mtCompiler) {\n  VM_ENTRY_MARK;\n  thread->set_env(this);\n  assert(ciEnv::current() == this, \"sanity\");\n  _oop_recorder = NULL;\n  _debug_info = NULL;\n  _dependencies = NULL;\n  _failure_reason = NULL;\n  _inc_decompile_count_on_failure = true;\n  _compilable = MethodCompilable;\n  _break_at_compile = false;\n  _compiler_data = NULL;\n#ifndef PRODUCT\n  assert(!firstEnv, \"not initialized properly\");\n#endif \n  _num_inlined_bytecodes = 0;\n  assert(task == NULL || thread->task() == task, \"sanity\");\n  if (task != NULL) {\n    task->mark_started(os::elapsed_counter());\n  }\n  _task = task;\n  _log = NULL;\n  _name_buffer = NULL;\n  _name_buffer_len = 0;\n  _arena   = &_ciEnv_arena;\n  _factory = new (_arena) ciObjectFactory(_arena, 128);\n  assert(Universe::is_fully_initialized(), \"should be complete\");\n  oop o = Universe::null_ptr_exception_instance();\n  assert(o != NULL, \"should have been initialized\");\n  _NullPointerException_instance = get_object(o)->as_instance();\n  o = Universe::arithmetic_exception_instance();\n  assert(o != NULL, \"should have been initialized\");\n  _ArithmeticException_instance = get_object(o)->as_instance();\n  _ArrayIndexOutOfBoundsException_instance = NULL;\n  _ArrayStoreException_instance = NULL;\n  _ClassCastException_instance = NULL;\n  _the_null_string = NULL;\n  _the_min_jint_string = NULL;\n  _jvmti_redefinition_count = 0;\n  _jvmti_can_hotswap_or_post_breakpoint = false;\n  _jvmti_can_access_local_variables = false;\n  _jvmti_can_post_on_exceptions = false;\n  _jvmti_can_pop_frame = false;\n}", "target": 0}
{"code": "bool Monitor::ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t   int protocol, bufferlist& authorizer_data,\n\t\t\t\t   bufferlist& authorizer_reply,\n\t\t\t\t   bool& isvalid, CryptoKey& session_key)\n{\n  dout(10) << \"ms_verify_authorizer \" << con->get_peer_addr()\n\t   << \" \" << ceph_entity_type_name(peer_type)\n\t   << \" protocol \" << protocol << dendl;\n  if (is_shutdown())\n    return false;\n  if (peer_type == CEPH_ENTITY_TYPE_MON &&\n      auth_cluster_required.is_supported_auth(CEPH_AUTH_CEPHX)) {\n    isvalid = false;\n    if (protocol == CEPH_AUTH_CEPHX) {\n      bufferlist::iterator iter = authorizer_data.begin();\n      CephXServiceTicketInfo auth_ticket_info;\n      if (authorizer_data.length()) {\n\tbool ret = cephx_verify_authorizer(g_ceph_context, &keyring, iter,\n\t\t\t\t\t  auth_ticket_info, authorizer_reply);\n\tif (ret) {\n\t  session_key = auth_ticket_info.session_key;\n\t  isvalid = true;\n\t} else {\n\t  dout(0) << \"ms_verify_authorizer bad authorizer from mon \" << con->get_peer_addr() << dendl;\n        }\n      }\n    } else {\n      dout(0) << \"ms_verify_authorizer cephx enabled, but no authorizer (required for mon)\" << dendl;\n    }\n  } else {\n    isvalid = true;\n  }\n  return true;\n}", "target": 1}
{"code": "static unsigned int __blk_mq_get_reserved_tag(struct blk_mq_alloc_data *data)\n{\n\tint tag, zero = 0;\n\tif (unlikely(!data->hctx->tags->nr_reserved_tags)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn BLK_MQ_TAG_FAIL;\n\t}\n\ttag = bt_get(data, &data->hctx->tags->breserved_tags, NULL, &zero,\n\t\tdata->hctx->tags);\n\tif (tag < 0)\n\t\treturn BLK_MQ_TAG_FAIL;\n\treturn tag;\n}", "target": 0}
{"code": "AsfVideo::HeaderReader::HeaderReader(const BasicIo::UniquePtr& io) : IdBuf_(GUID) {\n  if (io->size() >= io->tell() + GUID + QWORD) {\n    IdBuf_ = io->read(GUID);\n    size_ = readQWORDTag(io);\n    if (size_ >= GUID + QWORD)\n      remaining_size_ = size_ - GUID - QWORD;\n  }\n}", "target": 1}
{"code": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !inode_capable(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}", "target": 1}
{"code": "snmp_oid_encode_oid(unsigned char *out, uint32_t *out_len, uint32_t *oid)\n{\n  uint32_t original_out_len;\n  uint32_t *oid_start = oid;\n  uint32_t num;\n  original_out_len = *out_len;\n  while(*oid != ((uint32_t)-1)) {\n    ++oid;\n  }\n  --oid;\n  while(oid != oid_start) {\n    num = *oid;\n    (*out_len)++;\n    *out-- = (uint8_t)(num & 0x7F);\n    num >>= 7;\n    while(num) {\n      (*out_len)++;\n      *out-- = (uint8_t)((num & 0x7F) | 0x80);\n      num >>= 7;\n    }\n    --oid;\n  }\n  num = *(out + 1) + 40 * *oid;\n  (*out_len)--;\n  out++;\n  (*out_len)++;\n  *out-- = (uint8_t)(num & 0x7F);\n  num >>= 7;\n  while(num) {\n    (*out_len)++;\n    *out-- = (uint8_t)((num & 0x7F) | 0x80);\n    num >>= 7;\n  }\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, SNMP_DATA_TYPE_OBJECT);\n  return out;\n}", "target": 1}
{"code": "option_env_fd_cb (const gchar *option_name,\n                  const gchar *value,\n                  gpointer     data,\n                  GError     **error)\n{\n  FlatpakContext *context = data;\n  g_autoptr(GBytes) env_block = NULL;\n  gsize remaining;\n  const char *p;\n  guint64 fd;\n  gchar *endptr;\n  fd = g_ascii_strtoull (value, &endptr, 10);\n  if (endptr == NULL || *endptr != '\\0' || fd > G_MAXINT)\n    return glnx_throw (error, \"Not a valid file descriptor: %s\", value);\n  env_block = glnx_fd_readall_bytes ((int) fd, NULL, error);\n  if (env_block == NULL)\n    return FALSE;\n  p = g_bytes_get_data (env_block, &remaining);\n  while (remaining > 0)\n    {\n      size_t len = strnlen (p, remaining);\n      const char *equals;\n      g_assert (len <= remaining);\n      equals = memchr (p, '=', len);\n      if (equals == NULL || equals == p)\n        return glnx_throw (error,\n                           \"Environment variable must be given in the form VARIABLE=VALUE, not %.*s\", (int) len, p);\n      flatpak_context_set_env_var (context,\n                                   g_strndup (p, equals - p),\n                                   g_strndup (equals + 1, len - (equals - p) - 1));\n      p += len;\n      remaining -= len;\n      if (remaining > 0)\n        {\n          g_assert (*p == '\\0');\n          p += 1;\n          remaining -= 1;\n        }\n    }\n  if (fd >= 3)\n    close (fd);\n  return TRUE;\n}", "target": 0}
{"code": "static const char *set_add_default_charset(cmd_parms *cmd,\n                                           void *d_, const char *arg)\n{\n    core_dir_config *d = d_;\n    if (!ap_cstr_casecmp(arg, \"Off\")) {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_OFF;\n    }\n    else if (!ap_cstr_casecmp(arg, \"On\")) {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;\n       d->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;\n    }\n    else {\n       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;\n       d->add_default_charset_name = arg;\n    }\n    return NULL;\n}", "target": 0}
{"code": "ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse\n\t\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}", "target": 1}
{"code": "int LayerTilerChromium::tileIndex(int i, int j) const\n{\n    ASSERT(i >= 0 && j >= 0 && i < m_layerTileSize.width() && j < m_layerTileSize.height());\n    return i + j * m_layerTileSize.width();\n}", "target": 0}
{"code": "static gpointer openssl_global_init_once(gpointer arg)\n{\n    SSL_library_init();\n    SSL_load_error_strings();\n    openssl_thread_setup();\n    return NULL;\n}", "target": 0}
{"code": "void RootWindowHostLinux::ShowCursor(bool show) {\n  if (show == cursor_shown_)\n    return;\n  cursor_shown_ = show;\n  SetCursorInternal(show ? current_cursor_ : ui::kCursorNone);\n}", "target": 0}
{"code": "static const char *findNextNonWSBack(const char *q, const char *start)\n{\n    while (q > start &&\n\t   (*q == 0 || *q == 9 || *q == 0xa || *q == 0xc || *q == 0xd || *q == 0x20))\n    {\n\tq--;\n    }\n    return q;\n}", "target": 0}
{"code": "gfx::Size OverlayWindowViews::GetMinimumSize() const {\n  return min_size_;\n}", "target": 0}
{"code": "cdf_dump(void *v, size_t len)\n{\n\tsize_t i, j;\n\tunsigned char *p = v;\n\tchar abuf[16];\n\t(void)fprintf(stderr, \"%.4x: \", 0);\n\tfor (i = 0, j = 0; i < len; i++, p++) {\n\t\t(void)fprintf(stderr, \"%.2x \", *p);\n\t\tabuf[j++] = isprint(*p) ? *p : '.';\n\t\tif (j == 16) {\n\t\t\tj = 0;\n\t\t\tabuf[15] = '\\0';\n\t\t\t(void)fprintf(stderr, \"%s\\n%.4\" SIZE_T_FORMAT \"x: \",\n\t\t\t    abuf, i + 1);\n\t\t}\n\t}\n\t(void)fprintf(stderr, \"\\n\");\n}", "target": 0}
{"code": "static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    result = (CONSTBUFFER_HANDLE)calloc(1, (sizeof(CONSTBUFFER_HANDLE_DATA) + size));\n    if (result == NULL)\n    {\n        LogError(\"unable to malloc\");\n    }\n    else\n    {\n        INIT_REF_VAR(result->count);\n        result->alias.size = size;\n        if (size == 0)\n        {\n            result->alias.buffer = NULL;\n        }\n        else\n        {\n            unsigned char* temp = (unsigned char*)(result + 1);\n            (void)memcpy(temp, source, size);\n            result->alias.buffer = temp;\n        }\n        result->buffer_type = CONSTBUFFER_TYPE_COPIED;\n    }\n    return result;\n}", "target": 1}
{"code": "static char *r_socket_http_answer (RSocket *s, int *code, int *rlen) {\n\tr_return_val_if_fail (s, NULL);\n\tconst char *p;\n\tint ret, len = 0, bufsz = 32768, delta = 0;\n\tchar *dn, *buf = calloc (1, bufsz + 32); \n\tif (!buf) {\n\t\treturn NULL;\n\t}\n\tchar *res = NULL;\n\tint olen = __socket_slurp (s, (ut8*)buf, bufsz);\n\tif ((dn = (char*)r_str_casestr (buf, \"\\n\\n\"))) {\n\t\tdelta += 2;\n\t} else if ((dn = (char*)r_str_casestr (buf, \"\\r\\n\\r\\n\"))) {\n\t\tdelta += 4;\n\t} else {\n\t\tgoto fail;\n\t}\n\tolen -= delta;\n\t*dn = 0; \n\tp = r_str_casestr (buf, \"Content-Length: \");\n\tif (p) {\n\t\tlen = atoi (p + 16);\n\t} else {\n\t\tlen = olen - (dn - buf);\n\t}\n\tif (len > 0) {\n\t\tif (len > olen) {\n\t\t\tres = malloc (len + 2);\n\t\t\tmemcpy (res, dn + delta, olen);\n\t\t\tdo {\n\t\t\t\tret = r_socket_read_block (s, (ut8*) res + olen, len - olen);\n\t\t\t\tif (ret < 1) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tolen += ret;\n\t\t\t} while (olen < len);\n\t\t\tres[len] = 0;\n\t\t} else {\n\t\t\tres = malloc (len + 1);\n\t\t\tif (res) {\n\t\t\t\tmemcpy (res, dn + delta, len);\n\t\t\t\tres[len] = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tres = NULL;\n\t}\nfail:\n\tfree (buf);\n\tr_socket_close (s);\n\tif (rlen) {\n\t\t*rlen = len;\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)\n{\n\tstruct ucma_multicast *mc;\n\tmc = kzalloc(sizeof(*mc), GFP_KERNEL);\n\tif (!mc)\n\t\treturn NULL;\n\tmutex_lock(&mut);\n\tmc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);\n\tmutex_unlock(&mut);\n\tif (mc->id < 0)\n\t\tgoto error;\n\tmc->ctx = ctx;\n\tlist_add_tail(&mc->list, &ctx->mc_list);\n\treturn mc;\nerror:\n\tkfree(mc);\n\treturn NULL;\n}", "target": 1}
{"code": "double AccessibilityUIElement::width()\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return 0.0f;\n    int width, height;\n    atk_component_get_size(ATK_COMPONENT(m_element), &width, &height);\n    return width;\n}", "target": 0}
{"code": "BOOL update_write_cache_brush_order(wStream* s, const CACHE_BRUSH_ORDER* cache_brush, UINT16* flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tif (!Stream_EnsureRemainingCapacity(s,\n\t                                    update_approximate_cache_brush_order(cache_brush, flags)))\n\t\treturn FALSE;\n\tiBitmapFormat = BPP_BMF[cache_brush->bpp];\n\tStream_Write_UINT8(s, cache_brush->index);  \n\tStream_Write_UINT8(s, iBitmapFormat);       \n\tStream_Write_UINT8(s, cache_brush->cx);     \n\tStream_Write_UINT8(s, cache_brush->cy);     \n\tStream_Write_UINT8(s, cache_brush->style);  \n\tStream_Write_UINT8(s, cache_brush->length); \n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"incompatible 1bpp brush of length:%\" PRIu32 \"\", cache_brush->length);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t{\n\t\t\t\tStream_Write_UINT8(s, cache_brush->data[i]);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ((iBitmapFormat == BMF_8BPP) && (cache_brush->length == 20))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_16BPP) && (cache_brush->length == 24))\n\t\t\t\tcompressed = TRUE;\n\t\t\telse if ((iBitmapFormat == BMF_32BPP) && (cache_brush->length == 32))\n\t\t\t\tcompressed = TRUE;\n\t\t\tif (compressed != FALSE)\n\t\t\t{\n\t\t\t\tif (!update_compress_brush(s, cache_brush->data, cache_brush->bpp))\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint scanline = (cache_brush->bpp / 8) * 8;\n\t\t\t\tfor (i = 7; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\tStream_Write(s, &cache_brush->data[i * scanline], scanline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn TRUE;\n}", "target": 1}
{"code": "PassRefPtr<WebProcessProxy> WebProcessProxy::create(PassRefPtr<WebContext> context)\n{\n    return adoptRef(new WebProcessProxy(context));\n}", "target": 0}
{"code": "static void cjson_get_object_item_case_sensitive_should_not_crash_with_array(void) {\n    cJSON *array = NULL;\n    cJSON *found = NULL;\n    array = cJSON_Parse(\"[1]\");\n    found = cJSON_GetObjectItemCaseSensitive(array, \"name\");\n    TEST_ASSERT_NULL(found);\n    cJSON_Delete(array);\n}", "target": 0}
{"code": "sg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\tsrp->data.cmd_opcode = cmnd[0];\t\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n\t\treturn k;\t\n\t}\n\tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio)\n\t\t\tblk_end_request_all(srp->rq, -EIO);\n\t\tsg_finish_rem_req(srp);\n\t\treturn -ENODEV;\n\t}\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); \n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}", "target": 1}
{"code": "    template<typename tc>\n    CImg<T>& draw_circle(const int x0, const int y0, int radius,\n                         const tc *const color, const float opacity=1) {\n      if (is_empty()) return *this;\n      if (!color)\n        throw CImgArgumentException(_cimg_instance\n                                    \"draw_circle(): Specified color is (null).\",\n                                    cimg_instance);\n      cimg_init_scanline(color,opacity);\n      if (radius<0 || x0 - radius>=width() || y0 + radius<0 || y0 - radius>=height()) return *this;\n      if (y0>=0 && y0<height()) cimg_draw_scanline(x0 - radius,x0 + radius,y0,color,opacity,1);\n      for (int f = 1 - radius, ddFx = 0, ddFy = -(radius<<1), x = 0, y = radius; x<y; ) {\n        if (f>=0) {\n          const int x1 = x0 - x, x2 = x0 + x, y1 = y0 - y, y2 = y0 + y;\n          if (y1>=0 && y1<height()) cimg_draw_scanline(x1,x2,y1,color,opacity,1);\n          if (y2>=0 && y2<height()) cimg_draw_scanline(x1,x2,y2,color,opacity,1);\n          f+=(ddFy+=2); --y;\n        }\n        const bool no_diag = y!=(x++);\n        ++(f+=(ddFx+=2));\n        const int x1 = x0 - y, x2 = x0 + y, y1 = y0 - x, y2 = y0 + x;\n        if (no_diag) {\n          if (y1>=0 && y1<height()) cimg_draw_scanline(x1,x2,y1,color,opacity,1);\n          if (y2>=0 && y2<height()) cimg_draw_scanline(x1,x2,y2,color,opacity,1);\n        }\n      }\n      return *this;", "target": 0}
{"code": "int VP8LDecodeImage(VP8LDecoder* const dec) {\n  VP8Io* io = NULL;\n  WebPDecParams* params = NULL;\n  if (dec == NULL) return 0;\n  assert(dec->hdr_.huffman_tables_ != NULL);\n  assert(dec->hdr_.htree_groups_ != NULL);\n  assert(dec->hdr_.num_htree_groups_ > 0);\n  io = dec->io_;\n  assert(io != NULL);\n  params = (WebPDecParams*)io->opaque;\n  assert(params != NULL);\n  if (dec->state_ != READ_DATA) {\n    dec->output_ = params->output;\n    assert(dec->output_ != NULL);\n    if (!WebPIoInitFromOptions(params->options, io, MODE_BGRA)) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n    if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;\n#if !defined(WEBP_REDUCE_SIZE)\n    if (io->use_scaling && !AllocateAndInitRescaler(dec, io)) goto Err;\n#else\n    if (io->use_scaling) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n#endif\n    if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {\n      WebPInitAlphaProcessing();\n    }\n    if (!WebPIsRGBMode(dec->output_->colorspace)) {\n      WebPInitConvertARGBToYUV();\n      if (dec->output_->u.YUVA.a != NULL) WebPInitAlphaProcessing();\n    }\n    if (dec->incremental_) {\n      if (dec->hdr_.color_cache_size_ > 0 &&\n          dec->hdr_.saved_color_cache_.colors_ == NULL) {\n        if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,\n                                dec->hdr_.color_cache_.hash_bits_)) {\n          VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n          goto Err;\n        }\n      }\n    }\n    dec->state_ = READ_DATA;\n  }\n  if (!DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,\n                       io->crop_bottom, ProcessRows)) {\n    goto Err;\n  }\n  params->last_y = dec->last_out_row_;\n  return 1;\n Err:\n  VP8LClear(dec);\n  assert(dec->status_ != VP8_STATUS_OK);\n  return 0;\n}", "target": 1}
{"code": "cib_remote_callback_dispatch(gpointer user_data)\n{\n    cib_t *cib = user_data;\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    xmlNode *msg = NULL;\n    int disconnected = 0;\n    crm_info(\"Message on callback channel\");\n    crm_recv_remote_msg(private->callback.session, &private->callback.recv_buf, private->callback.encrypted, -1, &disconnected);\n    msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    while (msg) {\n        const char *type = crm_element_value(msg, F_TYPE);\n        crm_trace(\"Activating %s callbacks...\", type);\n        if (safe_str_eq(type, T_CIB)) {\n            cib_native_callback(cib, msg, 0, 0);\n        } else if (safe_str_eq(type, T_CIB_NOTIFY)) {\n            g_list_foreach(cib->notify_list, cib_native_notify, msg);\n        } else {\n            crm_err(\"Unknown message type: %s\", type);\n        }\n        free_xml(msg);\n        msg = crm_parse_remote_buffer(&private->callback.recv_buf);\n    }\n    if (disconnected) {\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "escape_character (gunichar c)\n{\n  g_autoptr(GString) res = g_string_new (\"\");\n  append_hex_escaped_character (res, c);\n  return g_string_free (g_steal_pointer (&res), FALSE);\n}", "target": 0}
{"code": "  void DidGetGlobalUsage(StorageType type, int64 usage,\n                         int64 unlimited_usage) {\n    DCHECK_EQ(type_, type);\n    DCHECK_GE(usage, unlimited_usage);\n    global_usage_ = usage;\n    global_unlimited_usage_ = unlimited_usage;\n    CheckCompleted();\n  }", "target": 0}
{"code": "static int encrypt(struct blkcipher_desc *desc,\n\t\t   struct scatterlist *dst, struct scatterlist *src,\n\t\t   unsigned int nbytes)\n{\n\tstruct blkcipher_walk walk;\n\tstruct crypto_blkcipher *tfm = desc->tfm;\n\tstruct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);\n\tint err;\n\tblkcipher_walk_init(&walk, dst, src, nbytes);\n\terr = blkcipher_walk_virt_block(desc, &walk, 64);\n\tsalsa20_ivsetup(ctx, walk.iv);\n\tif (likely(walk.nbytes == nbytes))\n\t{\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, nbytes);\n\t\treturn blkcipher_walk_done(desc, &walk, 0);\n\t}\n\twhile (walk.nbytes >= 64) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr,\n\t\t\t\t      walk.nbytes - (walk.nbytes % 64));\n\t\terr = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);\n\t}\n\tif (walk.nbytes) {\n\t\tsalsa20_encrypt_bytes(ctx, walk.dst.virt.addr,\n\t\t\t\t      walk.src.virt.addr, walk.nbytes);\n\t\terr = blkcipher_walk_done(desc, &walk, 0);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "apply_all_case_fold(OnigCaseFoldType flag,\n\t\t    OnigApplyAllCaseFoldFunc f, void* arg,\n\t\t    OnigEncoding enc ARG_UNUSED)\n{\n  return onigenc_apply_all_case_fold_with_map(\n             sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 1,\n             flag, f, arg);\n}", "target": 0}
{"code": "krb5_pac_parse(krb5_context context,\n               const void *ptr,\n               size_t len,\n               krb5_pac *ppac)\n{\n    krb5_error_code ret;\n    size_t i;\n    const unsigned char *p = (const unsigned char *)ptr;\n    krb5_pac pac;\n    size_t header_len;\n    krb5_ui_4 cbuffers, version;\n    *ppac = NULL;\n    if (len < PACTYPE_LENGTH)\n        return ERANGE;\n    cbuffers = load_32_le(p);\n    p += 4;\n    version = load_32_le(p);\n    p += 4;\n    if (version != 0)\n        return EINVAL;\n    header_len = PACTYPE_LENGTH + (cbuffers * PAC_INFO_BUFFER_LENGTH);\n    if (len < header_len)\n        return ERANGE;\n    ret = krb5_pac_init(context, &pac);\n    if (ret != 0)\n        return ret;\n    pac->pac = (PACTYPE *)realloc(pac->pac,\n                                  sizeof(PACTYPE) + ((cbuffers - 1) * sizeof(PAC_INFO_BUFFER)));\n    if (pac->pac == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    pac->pac->cBuffers = cbuffers;\n    pac->pac->Version = version;\n    for (i = 0; i < pac->pac->cBuffers; i++) {\n        PAC_INFO_BUFFER *buffer = &pac->pac->Buffers[i];\n        buffer->ulType = load_32_le(p);\n        p += 4;\n        buffer->cbBufferSize = load_32_le(p);\n        p += 4;\n        buffer->Offset = load_64_le(p);\n        p += 8;\n        if (buffer->Offset % PAC_ALIGNMENT) {\n            krb5_pac_free(context, pac);\n            return EINVAL;\n        }\n        if (buffer->Offset < header_len ||\n            buffer->Offset + buffer->cbBufferSize > len) {\n            krb5_pac_free(context, pac);\n            return ERANGE;\n        }\n    }\n    pac->data.data = realloc(pac->data.data, len);\n    if (pac->data.data == NULL) {\n        krb5_pac_free(context, pac);\n        return ENOMEM;\n    }\n    memcpy(pac->data.data, ptr, len);\n    pac->data.length = len;\n    *ppac = pac;\n    return 0;\n}", "target": 1}
{"code": "xsltFreeKeyDef(xsltKeyDefPtr keyd) {\n    if (keyd == NULL)\n\treturn;\n    if (keyd->comp != NULL)\n\txmlXPathFreeCompExpr(keyd->comp);\n    if (keyd->usecomp != NULL)\n\txmlXPathFreeCompExpr(keyd->usecomp);\n    if (keyd->name != NULL)\n\txmlFree(keyd->name);\n    if (keyd->nameURI != NULL)\n\txmlFree(keyd->nameURI);\n    if (keyd->match != NULL)\n\txmlFree(keyd->match);\n    if (keyd->use != NULL)\n\txmlFree(keyd->use);\n    if (keyd->nsList != NULL)\n        xmlFree(keyd->nsList);\n    memset(keyd, -1, sizeof(xsltKeyDef));\n    xmlFree(keyd);\n}", "target": 0}
{"code": "int compat_sock_common_setsockopt(struct socket *sock, int level, int optname,\n\t\t\t\t  char __user *optval, int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tif (sk->sk_prot->compat_setsockopt != NULL)\n\t\treturn sk->sk_prot->compat_setsockopt(sk, level, optname,\n\t\t\t\t\t\t      optval, optlen);\n\treturn sk->sk_prot->setsockopt(sk, level, optname, optval, optlen);\n}", "target": 0}
{"code": "static void jpc_undo_roi(jas_matrix_t *x, int roishift, int bgshift, int numbps)\n{\n\tint i;\n\tint j;\n\tint thresh;\n\tjpc_fix_t val;\n\tjpc_fix_t mag;\n\tbool warn;\n\tuint_fast32_t mask;\n\tif (roishift == 0 && bgshift == 0) {\n\t\treturn;\n\t}\n\tthresh = 1 << roishift;\n\twarn = false;\n\tfor (i = 0; i < jas_matrix_numrows(x); ++i) {\n\t\tfor (j = 0; j < jas_matrix_numcols(x); ++j) {\n\t\t\tval = jas_matrix_get(x, i, j);\n\t\t\tmag = JAS_ABS(val);\n\t\t\tif (mag >= thresh) {\n\t\t\t\tmag >>= roishift;\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t} else {\n\t\t\t\tmag <<= bgshift;\n\t\t\t\tmask = (1 << numbps) - 1;\n\t\t\t\tif (mag & (~mask)) {\n\t\t\t\t\tif (!warn) {\n\t\t\t\t\t\tjas_eprintf(\"warning: possibly corrupt code stream\\n\");\n\t\t\t\t\t\twarn = true;\n\t\t\t\t\t}\n\t\t\t\t\tmag &= mask;\n\t\t\t\t}\n\t\t\t\tval = (val < 0) ? (-mag) : mag;\n\t\t\t\tjas_matrix_set(x, i, j, val);\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)\n{\n  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);\n}", "target": 0}
{"code": "int TS_OBJ_print_bio(BIO *bio, const ASN1_OBJECT *obj)\n{\n    char obj_txt[128];\n    int len = OBJ_obj2txt(obj_txt, sizeof(obj_txt), obj, 0);\n    BIO_write(bio, obj_txt, len);\n    BIO_write(bio, \"\\n\", 1);\n    return 1;\n}", "target": 1}
{"code": "mm_zfree(struct mm_master *mm, void *address)\n{\n\tmm_free(mm, address);\n}", "target": 1}
{"code": "nfs4_state_set_mode_locked(struct nfs4_state *state, mode_t mode)\n{\n\tif (state->state == mode)\n\t\treturn;\n\tif ((mode & FMODE_WRITE) != (state->state & FMODE_WRITE)) {\n\t\tif (mode & FMODE_WRITE)\n\t\t\tlist_move(&state->open_states, &state->owner->so_states);\n\t\telse\n\t\t\tlist_move_tail(&state->open_states, &state->owner->so_states);\n\t}\n\tstate->state = mode;\n}", "target": 1}
{"code": "xfs_attr3_leaf_getvalue(\n\tstruct xfs_buf\t\t*bp,\n\tstruct xfs_da_args\t*args)\n{\n\tstruct xfs_attr_leafblock *leaf;\n\tstruct xfs_attr3_icleaf_hdr ichdr;\n\tstruct xfs_attr_leaf_entry *entry;\n\tstruct xfs_attr_leaf_name_local *name_loc;\n\tstruct xfs_attr_leaf_name_remote *name_rmt;\n\tint\t\t\tvaluelen;\n\tleaf = bp->b_addr;\n\txfs_attr3_leaf_hdr_from_disk(&ichdr, leaf);\n\tASSERT(ichdr.count < XFS_LBSIZE(args->dp->i_mount) / 8);\n\tASSERT(args->index < ichdr.count);\n\tentry = &xfs_attr3_leaf_entryp(leaf)[args->index];\n\tif (entry->flags & XFS_ATTR_LOCAL) {\n\t\tname_loc = xfs_attr3_leaf_name_local(leaf, args->index);\n\t\tASSERT(name_loc->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_loc->nameval, args->namelen) == 0);\n\t\tvaluelen = be16_to_cpu(name_loc->valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void BezierOval(double w, double h, char *action)\n{\n    char *outpos = outputbuffer;\n    outpos +=\n    sprintf(outpos,\" %12.3f 0 m %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",-w,-w,h*BzK,-w*BzK,h,h);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c\\n\",w*BzK,h,w,h*BzK,w);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f 0 %12.3f c\\n\",w,-h*BzK,w*BzK,-h,-h);\n    outpos +=\n    sprintf(outpos,\" %12.3f %12.3f %12.3f %12.3f %12.3f 0 c %s\\n\",-w*BzK,-h,-w,-h*BzK,-w,action);\n    sendClean(outputbuffer);\n}", "target": 0}
{"code": "TEST(BasicFlatBufferModel, TestHandleMalformedModel) {\n  const auto model_paths = {\n      \"tensorflow/lite/testdata/add_shared_tensors.bin\",\n  };\n  for (const auto& model_path : model_paths) {\n    std::unique_ptr<tflite::FlatBufferModel> model =\n        FlatBufferModel::BuildFromFile(model_path);\n    ASSERT_NE(model, nullptr);\n    tflite::ops::builtin::BuiltinOpResolver resolver;\n    InterpreterBuilder builder(*model, resolver);\n    std::unique_ptr<Interpreter> interpreter;\n    ASSERT_EQ(builder(&interpreter), kTfLiteOk);\n    ASSERT_NE(interpreter, nullptr);\n    ASSERT_NE(interpreter->AllocateTensors(), kTfLiteOk);\n  }\n}", "target": 0}
{"code": "static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops)\n{\n\twhile (elements-- > 0) {\n\t\tzval *key, *data, **old_data;\n\t\tALLOC_INIT_ZVAL(key);\n\t\tif (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tif (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\treturn 0;\n\t\t}\n\t\tALLOC_INIT_ZVAL(data);\n\t\tif (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) {\n\t\t\tzval_dtor(key);\n\t\t\tFREE_ZVAL(key);\n\t\t\tzval_dtor(data);\n\t\t\tFREE_ZVAL(data);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!objprops) {\n\t\t\tswitch (Z_TYPE_P(key)) {\n\t\t\tcase IS_LONG:\n\t\t\t\tif (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\tcase IS_STRING:\n\t\t\t\tif (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n\t\t\t\t\tvar_push_dtor(var_hash, old_data);\n\t\t\t\t}\n\t\t\t\tzend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL);\n\t\t\t\tbreak;\n\t\t\t}\n                } else {\n                        convert_to_string(key);\n                       if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {\n                               var_push_dtor(var_hash, old_data);\n                       }\n                        zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data,\n                                        sizeof data, NULL);\n                }\n\t\tif (elements && *(*p-1) != ';' && *(*p-1) != '}') {\n\t\t\t(*p)--;\n\t\t\treturn 0;\n\t\t}\n\t}", "target": 0}
{"code": "Integer InvertibleRWFunction::CalculateInverse(RandomNumberGenerator &rng, const Integer &x) const\n{\n\tDoQuickSanityCheck();\n\tModularArithmetic modn(m_n);\n\tInteger r, rInv;\n\tdo {\t\n\t\tr.Randomize(rng, Integer::One(), m_n - Integer::One());\n\t\trInv = modn.MultiplicativeInverse(r);\n\t} while (rInv.IsZero());\n\tInteger re = modn.Square(r);\n\tre = modn.Multiply(re, x);\t\t\t\n\tInteger cp=re%m_p, cq=re%m_q;\n\tif (Jacobi(cp, m_p) * Jacobi(cq, m_q) != 1)\n\t{\n\t\tcp = cp.IsOdd() ? (cp+m_p) >> 1 : cp >> 1;\n\t\tcq = cq.IsOdd() ? (cq+m_q) >> 1 : cq >> 1;\n\t}\n\t#pragma omp parallel\n\t\t#pragma omp sections\n\t\t{\n\t\t\t#pragma omp section\n\t\t\t\tcp = ModularSquareRoot(cp, m_p);\n\t\t\t#pragma omp section\n\t\t\t\tcq = ModularSquareRoot(cq, m_q);\n\t\t}\n\tInteger y = CRT(cq, m_q, cp, m_p, m_u);\n\ty = modn.Multiply(y, rInv);\t\t\t\t\n\ty = STDMIN(y, m_n-y);\n\tif (ApplyFunction(y) != x)\t\t\t\t\n\t\tthrow Exception(Exception::OTHER_ERROR, \"InvertibleRWFunction: computational error during private key operation\");\n\treturn y;\n}", "target": 1}
{"code": "int LuaSettings::l_write(lua_State* L)\n{\n\tNO_MAP_LOCK_REQUIRED;\n\tLuaSettings* o = checkobject(L, 1);\n\tif (!o->m_write_allowed) {\n\t\tthrow LuaError(\"Settings: writing \" + o->m_filename +\n\t\t\t\t\" not allowed with mod security on.\");\n\t}\n\tbool success = o->m_settings->updateConfigFile(o->m_filename.c_str());\n\tlua_pushboolean(L, success);\n\treturn 1;\n}", "target": 0}
{"code": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint64 iskew = (int64)imagew - (int64)tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n\tfor (row = 0; row < imagelength; row += tl) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb > iskew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;\n\t\t}\n\t\tbufp += imagew * nrow;\n\t}\ndone:\n\t_TIFFfree(tilebuf);\n\treturn status;\n}", "target": 0}
{"code": "PHPAPI char *php_unescape_html_entities(unsigned char *old, size_t oldlen, size_t *newlen, int all, int flags, char *hint_charset TSRMLS_DC)\n{\n\tsize_t retlen;\n\tchar *ret;\n\tenum entity_charset charset;\n\tconst entity_ht *inverse_map = NULL;\n\tsize_t new_size = TRAVERSE_FOR_ENTITIES_EXPAND_SIZE(oldlen);\n\tif (all) {\n\t\tcharset = determine_charset(hint_charset TSRMLS_CC);\n\t} else {\n\t\tcharset = cs_8859_1; \n\t}\n\tif (oldlen > new_size) {\n\t\tret = estrndup((char*)old, oldlen);\n\t\tretlen = oldlen;\n\t\tgoto empty_source;\n\t}\n\tret = emalloc(new_size);\n\t*ret = '\\0';\n\tretlen = oldlen;\n\tif (retlen == 0) {\n\t\tgoto empty_source;\n\t}\n\tinverse_map = unescape_inverse_map(all, flags);\n\ttraverse_for_entities(old, oldlen, ret, &retlen, all, flags, inverse_map, charset);\nempty_source:\t\n\t*newlen = retlen;\n\treturn ret;\n}", "target": 1}
{"code": "long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret;\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\t__pipe_lock(pipe);\n\tswitch (cmd) {\n\tcase F_SETPIPE_SZ: {\n\t\tunsigned int size, nr_pages;\n\t\tsize = round_pipe_size(arg);\n\t\tnr_pages = size >> PAGE_SHIFT;\n\t\tret = -EINVAL;\n\t\tif (!nr_pages)\n\t\t\tgoto out;\n\t\tif (!capable(CAP_SYS_RESOURCE) && size > pipe_max_size) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t} else if ((too_many_pipe_buffers_hard(pipe->user) ||\n\t\t\t    too_many_pipe_buffers_soft(pipe->user)) &&\n\t\t           !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = pipe_set_size(pipe, nr_pages);\n\t\tbreak;\n\t\t}\n\tcase F_GETPIPE_SZ:\n\t\tret = pipe->buffers * PAGE_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\nout:\n\t__pipe_unlock(pipe);\n\treturn ret;\n}", "target": 0}
{"code": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrlcpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrlcpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = refcount_read(&alg->cra_refcnt);\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\t\tstrlcpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\tswitch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {\n\tcase CRYPTO_ALG_TYPE_CIPHER:\n\t\tif (crypto_report_cipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_COMPRESS:\n\t\tif (crypto_report_comp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_ACOMPRESS:\n\t\tif (crypto_report_acomp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_AKCIPHER:\n\t\tif (crypto_report_akcipher(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\tcase CRYPTO_ALG_TYPE_KPP:\n\t\tif (crypto_report_kpp(skb, alg))\n\t\t\tgoto nla_put_failure;\n\t\tbreak;\n\t}\nout:\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static void cleanup_timers(struct list_head *head,\n\t\t\t   cputime_t utime, cputime_t stime,\n\t\t\t   unsigned long long sum_exec_runtime)\n{\n\tstruct cpu_timer_list *timer, *next;\n\tcputime_t ptime = cputime_add(utime, stime);\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (cputime_lt(timer->expires.cpu, ptime)) {\n\t\t\ttimer->expires.cpu = cputime_zero;\n\t\t} else {\n\t\t\ttimer->expires.cpu = cputime_sub(timer->expires.cpu,\n\t\t\t\t\t\t\t ptime);\n\t\t}\n\t}\n\t++head;\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (cputime_lt(timer->expires.cpu, utime)) {\n\t\t\ttimer->expires.cpu = cputime_zero;\n\t\t} else {\n\t\t\ttimer->expires.cpu = cputime_sub(timer->expires.cpu,\n\t\t\t\t\t\t\t utime);\n\t\t}\n\t}\n\t++head;\n\tlist_for_each_entry_safe(timer, next, head, entry) {\n\t\tlist_del_init(&timer->entry);\n\t\tif (timer->expires.sched < sum_exec_runtime) {\n\t\t\ttimer->expires.sched = 0;\n\t\t} else {\n\t\t\ttimer->expires.sched -= sum_exec_runtime;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static inline bool sctp_chunk_pending(const struct sctp_chunk *chunk)\n{\n\treturn !list_empty(&chunk->list);\n}", "target": 0}
{"code": "static void unix_dgram_peer_wake_disconnect_wakeup(struct sock *sk,\n\t\t\t\t\t\t   struct sock *other)\n{\n\tunix_dgram_peer_wake_disconnect(sk, other);\n\twake_up_interruptible_poll(sk_sleep(sk),\n\t\t\t\t   POLLOUT |\n\t\t\t\t   POLLWRNORM |\n\t\t\t\t   POLLWRBAND);\n}", "target": 0}
{"code": "struct nfs_open_context *nfs_find_open_context(struct inode *inode, struct rpc_cred *cred, int mode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(inode);\n\tstruct nfs_open_context *pos, *ctx = NULL;\n\tspin_lock(&inode->i_lock);\n\tlist_for_each_entry(pos, &nfsi->open_files, list) {\n\t\tif (cred != NULL && pos->cred != cred)\n\t\t\tcontinue;\n\t\tif ((pos->mode & mode) == mode) {\n\t\t\tctx = get_nfs_open_context(pos);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn ctx;\n}", "target": 1}
{"code": "void nfs_idmap_quit(void)\n{\n\tnfs_idmap_quit_keyring();\n}", "target": 0}
{"code": "static int dbConnect(char *host, char *user, char *passwd)\n{\n  DBUG_ENTER(\"dbConnect\");\n  if (verbose)\n  {\n    fprintf(stderr, \"# Connecting to %s...\\n\", host ? host : \"localhost\");\n  }\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n\t\t  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection, MYSQL_OPT_BIND, opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  if (opt_plugin_dir && *opt_plugin_dir)\n    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);\n  if (opt_default_auth && *opt_default_auth)\n    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n  mysql_options(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_RESET, 0);\n  mysql_options4(&mysql_connection, MYSQL_OPT_CONNECT_ATTR_ADD,\n                 \"program_name\", \"mysqlcheck\");\n  if (!(sock = mysql_real_connect(&mysql_connection, host, user, passwd,\n         NULL, opt_mysql_port, opt_mysql_unix_port, 0)))\n  {\n    DBerror(&mysql_connection, \"when trying to connect\");\n    DBUG_RETURN(1);\n  }\n  mysql_connection.reconnect= 1;\n  DBUG_RETURN(0);\n} ", "target": 1}
{"code": "int ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tstruct sk_buff *skb;\n\tunsigned long time_left;\n\tint ret = 0;\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_reserve(skb, headroom);\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\tmutex_lock(&wmi->op_mutex);\n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len);\n\tif (ret)\n\t\tgoto out;\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\tmutex_unlock(&wmi->op_mutex);\n\treturn 0;\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "static void ConvertLoopSlice(ModSample &src, ModSample &dest, SmpLength start, SmpLength len, bool loop)\n{\n\tif(!src.HasSampleData()) return;\n\tdest.FreeSample();\n\tdest = src;\n\tdest.nLength = len;\n\tdest.pSample = nullptr;\n\tif(!dest.AllocateSample())\n\t{\n\t\treturn;\n\t}\n\tif(len != src.nLength)\n\t\tMemsetZero(dest.cues);\n\tstd::memcpy(dest.pSample8, src.pSample8 + start, len);\n\tdest.uFlags.set(CHN_LOOP, loop);\n\tif(loop)\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = len;\n\t} else\n\t{\n\t\tdest.nLoopStart = 0;\n\t\tdest.nLoopEnd = 0;\n\t}\n}", "target": 1}
{"code": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}", "target": 1}
{"code": "void pdf_load_pages_kids(FILE *fp, pdf_t *pdf)\n{\n    int     i, id, dummy;\n    char   *buf, *c;\n    long    start, sz;\n    start = ftell(fp);\n    for (i=0; i<pdf->n_xrefs; i++)\n    {\n        if (pdf->xrefs[i].version && (pdf->xrefs[i].end != 0))\n        {\n            fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n            while (SAFE_F(fp, (fgetc(fp) != 't')))\n                ; \n            sz = pdf->xrefs[i].end - ftell(fp);\n            buf = malloc(sz + 1);\n            SAFE_E(fread(buf, 1, sz, fp), sz, \"Failed to load /Root.\\n\");\n            buf[sz] = '\\0';\n            if (!(c = strstr(buf, \"/Root\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Root\") + 1);\n            free(buf);\n            buf = get_object(fp, id, &pdf->xrefs[i], NULL, &dummy);\n            if (!buf || !(c = strstr(buf, \"/Pages\")))\n            {\n                free(buf);\n                continue;\n            }\n            id = atoi(c + strlen(\"/Pages\") + 1);\n            load_kids(fp, id, &pdf->xrefs[i]);\n            free(buf); \n        }\n    }\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tstruct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);\n\tint error = 0;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tconst char *name = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (error < 0) {\n\t\t\t\tgossip_err(\"%s: posix_acl_equiv_mode err: %d\\n\",\n\t\t\t\t\t   __func__,\n\t\t\t\t\t   error);\n\t\t\t\treturn error;\n\t\t\t}\n\t\t\tif (inode->i_mode != mode)\n\t\t\t\tSetModeFlag(orangefs_inode);\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tgossip_err(\"%s: invalid type %d!\\n\", __func__, type);\n\t\treturn -EINVAL;\n\t}\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: inode %pU, key %s type %d\\n\",\n\t\t     __func__, get_khandle_from_ino(inode),\n\t\t     name,\n\t\t     type);\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t}\n\tgossip_debug(GOSSIP_ACL_DEBUG,\n\t\t     \"%s: name %s, value %p, size %zd, acl %p\\n\",\n\t\t     __func__, name, value, size, acl);\n\terror = orangefs_inode_setxattr(inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}", "target": 1}
{"code": "static av_cold void uninit(AVFilterContext *ctx)\n{\n    ColorCorrectContext *s = ctx->priv;\n    av_freep(&s->analyzeret);\n    av_freep(&s->uhistogram);\n    av_freep(&s->vhistogram);\n}", "target": 0}
{"code": "int handle(int s, unsigned char* data, int len, struct sockaddr_in *s_in)\n{\n\tchar buf[2048];\n\tunsigned short *cmd = (unsigned short *)buf;\n\tint plen;\n\tstruct in_addr *addr = &s_in->sin_addr;\n\tunsigned short *pid = (unsigned short*) data;\n\tif (len == S_HELLO_LEN && memcmp(data, \"sorbo\", 5) == 0) {\n\t\tunsigned short *id = (unsigned short*) (data+5);\n\t\tint x = 2+4+2;\n\t\t*cmd = htons(S_CMD_INET_CHECK);\n\t\tmemcpy(cmd+1, addr, 4);\n\t\tmemcpy(cmd+1+2, id, 2);\n\t\tprintf(\"Inet check by %s %d\\n\",\n\t\t       inet_ntoa(*addr), ntohs(*id));\n\t\tif (send(s, buf, x, 0) != x)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\t*cmd++ = htons(S_CMD_PACKET);\n\t*cmd++ = *pid;\n\tplen = len - 2;\n    if (plen < 0)\n        return 0;\n\tlast_id = ntohs(*pid);\n\tif (last_id > 20000)\n\t\twrap = 1;\n\tif (wrap && last_id < 100) {\n\t\twrap = 0;\n\t\tmemset(ids, 0, sizeof(ids));\n\t}\n\tprintf(\"Got packet %d %d\", last_id, plen);\n\tif (is_dup(last_id)) {\n\t\tprintf(\" (DUP)\\n\");\n\t\treturn 0;\n\t}\n\tprintf(\"\\n\");\n\t*cmd++ = htons(plen);\n\tmemcpy(cmd, data+2, plen);\n\tplen += 2 + 2 + 2;\n\tassert(plen <= (int) sizeof(buf));\n\tif (send(s, buf, plen, 0) != plen)\n\t\treturn 1;\n\treturn 0;\n}", "target": 0}
{"code": "static int spl_heap_it_valid(zend_object_iterator *iter TSRMLS_DC) \n{\n\tspl_heap_it         *iterator = (spl_heap_it *)iter;\n\treturn (iterator->object->heap->count != 0 ? SUCCESS : FAILURE);\n}", "target": 0}
{"code": "static void copyIPv6IfDifferent(void * dest, const void * src)\n{\n\tif(dest != src) {\n\t\tmemcpy(dest, src, sizeof(struct in6_addr));\n\t}\n}", "target": 1}
{"code": "static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_unaligned_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\t*ie_ptr = ie;\n\treturn 0;\n}", "target": 0}
{"code": "EventQueue* Document::GetEventQueue() const {\n  if (!dom_window_)\n    return nullptr;\n  return dom_window_->GetEventQueue();\n}", "target": 0}
{"code": "header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\tpsf->header [psf->headindex++] = 0 ;\n\t\t} ;\n} ", "target": 1}
{"code": "Pl_AES_PDF::flush(bool strip_padding)\n{\n    assert(this->offset == this->buf_size);\n    if (first)\n    {\n\tfirst = false;\n        bool return_after_init = false;\n\tif (this->cbc_mode)\n\t{\n\t    if (encrypt)\n\t    {\n\t\tinitializeVector();\n                if (! (this->use_zero_iv || this->use_specified_iv))\n                {\n                    getNext()->write(this->cbc_block, this->buf_size);\n                }\n\t    }\n\t    else if (this->use_zero_iv || this->use_specified_iv)\n            {\n                initializeVector();\n            }\n            else\n\t    {\n\t\tmemcpy(this->cbc_block, this->inbuf, this->buf_size);\n\t\tthis->offset = 0;\n                return_after_init = true;\n\t    }\n\t}\n        this->crypto->rijndael_init(\n            encrypt, this->key.get(), key_bytes,\n            this->cbc_mode, this->cbc_block);\n        if (return_after_init)\n        {\n            return;\n        }\n    }\n    if (this->encrypt)\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    else\n    {\n\tthis->crypto->rijndael_process(this->inbuf, this->outbuf);\n    }\n    unsigned int bytes = this->buf_size;\n    if (strip_padding)\n    {\n\tunsigned char last = this->outbuf[this->buf_size - 1];\n\tif (last <= this->buf_size)\n\t{\n\t    bool strip = true;\n\t    for (unsigned int i = 1; i <= last; ++i)\n\t    {\n\t\tif (this->outbuf[this->buf_size - i] != last)\n\t\t{\n\t\t    strip = false;\n\t\t    break;\n\t\t}\n\t    }\n\t    if (strip)\n\t    {\n\t\tbytes -= last;\n\t    }\n\t}\n    }\n    getNext()->write(this->outbuf, bytes);\n    this->offset = 0;\n}", "target": 1}
{"code": "njs_function_capture_closure(njs_vm_t *vm, njs_function_t *function,\n    njs_function_lambda_t *lambda)\n{\n    void                *start, *end;\n    uint32_t            n;\n    njs_value_t         *value, **closure;\n    njs_native_frame_t  *frame;\n    if (lambda->nclosures == 0) {\n        return NJS_OK;\n    }\n    frame = &vm->active_frame->native;\n    while (frame->native) {\n        frame = frame->previous;\n    }\n    start = frame;\n    end = frame->free;\n    closure = njs_function_closures(function);\n    n = lambda->nclosures;\n    do {\n        n--;\n        value = njs_scope_value(vm, lambda->closures[n]);\n        if (start <= (void *) value && (void *) value < end) {\n            value = njs_scope_value_clone(vm, lambda->closures[n], value);\n            if (njs_slow_path(value == NULL)) {\n                return NJS_ERROR;\n            }\n        }\n        closure[n] = value;\n    } while (n != 0);\n    return NJS_OK;\n}", "target": 0}
{"code": "bool MainWindow::serverArgs(QStringList& args, QString& app)\n{\n    app = appPath(appConfig().barriersName());\n    if (!QFile::exists(app))\n    {\n        QMessageBox::warning(this, tr(\"Barrier server not found\"),\n                             tr(\"The executable for the barrier server does not exist.\"));\n        return false;\n    }\n#if defined(Q_OS_WIN)\n    app = QString(\"\\\"%1\\\"\").arg(app);\n#endif\n    if (appConfig().logToFile())\n    {\n        appConfig().persistLogDir();\n        args << \"--log\" << appConfig().logFilenameCmd();\n    }\n    if (!appConfig().getRequireClientCertificate()) {\n        args << \"--disable-client-cert-checking\";\n    }\n    QString configFilename = this->configFilename();\n#if defined(Q_OS_WIN)\n    configFilename = QString(\"\\\"%1\\\"\").arg(configFilename);\n#endif\n    args << \"-c\" << configFilename << \"--address\" << address();\n    return true;\n}", "target": 0}
{"code": "static int hashKey(DIGEST_CTX hash, const struct pgpPkt *pkt, int exptag)\n{\n    int rc = -1;\n    if (pkt->tag == exptag) {\n\tuint8_t head[] = {\n\t    0x99,\n\t    (pkt->blen >> 8),\n\t    (pkt->blen     ),\n\t};\n\trpmDigestUpdate(hash, head, 3);\n\trpmDigestUpdate(hash, pkt->body, pkt->blen);\n\trc = 0;\n    }\n    return rc;\n}", "target": 0}
{"code": "MOBI_RET mobi_decode_infl(unsigned char *decoded, int *decoded_size, const unsigned char *rule) {\n    int pos = *decoded_size;\n    char mod = 'i';\n    char dir = '<';\n    char olddir;\n    unsigned char c;\n    while ((c = *rule++)) {\n        if (c <= 4) {\n            mod = (c <= 2) ? 'i' : 'd'; \n            olddir = dir;\n            dir = (c & 2) ? '<' : '>'; \n            if (olddir != dir && olddir) {\n                pos = (c & 2) ? *decoded_size : 0;\n            }\n        }\n        else if (c > 10 && c < 20) {\n            if (dir == '>') {\n                pos = *decoded_size;\n            }\n            pos -= c - 10;\n            dir = 0;\n            if (pos < 0 || pos > *decoded_size) {\n                debug_print(\"Position setting failed (%s)\\n\", decoded);\n                return MOBI_DATA_CORRUPT;\n            }\n        }\n        else {\n            if (mod == 'i') {\n                const unsigned char *s = decoded + pos;\n                unsigned char *d = decoded + pos + 1;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                decoded[pos] = c;\n                (*decoded_size)++;\n                if (dir == '>') { pos++; }\n            } else {\n                if (dir == '<') { pos--; }\n                const unsigned char *s = decoded + pos + 1;\n                unsigned char *d = decoded + pos;\n                const int l = *decoded_size - pos;\n                if (l < 0 || d + l > decoded + INDX_INFLBUF_SIZEMAX) {\n                    debug_print(\"Out of buffer in %s at pos: %i\\n\", decoded, pos);\n                    return MOBI_DATA_CORRUPT;\n                }\n                if (decoded[pos] != c) {\n                    debug_print(\"Character mismatch in %s at pos: %i (%c != %c)\\n\", decoded, pos, decoded[pos], c);\n                    return MOBI_DATA_CORRUPT;\n                }\n                memmove(d, s, (size_t) l);\n                (*decoded_size)--;\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}", "target": 1}
{"code": "void V8DOMWrapper::setJSWrapperForActiveDOMObject(void* object, v8::Persistent<v8::Object> wrapper)\n{\n    ASSERT(V8DOMWrapper::maybeDOMWrapper(wrapper));\n#ifndef NDEBUG\n    V8ClassIndex::V8WrapperType type = V8DOMWrapper::domWrapperType(wrapper);\n    switch (type) {\n#define MAKE_CASE(TYPE, NAME) case V8ClassIndex::TYPE: break;\n        ACTIVE_DOM_OBJECT_TYPES(MAKE_CASE)\n    default: \n        ASSERT_NOT_REACHED();\n#undef MAKE_CASE\n    }\n#endif\n    getActiveDOMObjectMap().set(object, wrapper);\n}", "target": 0}
{"code": "check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tint ret, off, h;\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_arpt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset < sizeof(struct compat_arpt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tret = check_entry((struct arpt_entry *)e);\n\tif (ret)\n\t\treturn ret;\n\toff = sizeof(struct arpt_entry) - sizeof(struct compat_arpt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tt = compat_arpt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_ARP, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto out;\n\t}\n\tt->u.kernel.target = target;\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(NFPROTO_ARP, entry_offset, off);\n\tif (ret)\n\t\tgoto release_target;\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\nrelease_target:\n\tmodule_put(t->u.kernel.target->me);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "TfLiteStatus MockCustom::Invoke(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n  const int32_t* input_data = input->data.i32;\n  const TfLiteTensor* weight = tflite::GetInput(context, node, 1);\n  const uint8_t* weight_data = weight->data.uint8;\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  int32_t* output_data = output->data.i32;\n  output_data[0] =\n      0;  \n  output_data[0] = input_data[0] + weight_data[0];\n  return kTfLiteOk;\n}", "target": 1}
{"code": "void HTMLMediaElement::setPlaybackRate(double rate,\n                                       ExceptionState& exception_state) {\n  BLINK_MEDIA_LOG << \"setPlaybackRate(\" << (void*)this << \", \" << rate << \")\";\n  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)\n    return;\n  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {\n    UseCounter::Count(GetDocument(),\n                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);\n    exception_state.ThrowDOMException(\n        DOMExceptionCode::kNotSupportedError,\n        \"The provided playback rate (\" + String::Number(rate) +\n            \") is not in the \" + \"supported playback range.\");\n    return;\n  }\n  if (playback_rate_ != rate) {\n    playback_rate_ = rate;\n    ScheduleEvent(event_type_names::kRatechange);\n  }\n  UpdatePlaybackRate();\n}", "target": 0}
{"code": "PackLinuxElf64::elf_find_dynamic(unsigned int key) const\n{\n    Elf64_Dyn const *dynp= dynseg;\n    if (dynp)\n    for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg\n            && Elf64_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te64(&dynp->d_tag)==key) {\n        upx_uint64_t const t= elf_get_offset_from_address(get_te64(&dynp->d_val));\n        if (t) {\n            return &((unsigned char const *)file_image)[(size_t)t];\n        }\n        break;\n    }\n    return 0;\n}", "target": 1}
{"code": "void kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n\tshared_msrs_global.msrs[slot] = msr;\n\tsmp_wmb();\n}", "target": 0}
{"code": "int nfc_llcp_set_remote_gb(struct nfc_dev *dev, const u8 *gb, u8 gb_len)\n{\n\tstruct nfc_llcp_local *local;\n\tif (gb_len < 3 || gb_len > NFC_MAX_GT_LEN)\n\t\treturn -EINVAL;\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tpr_err(\"No LLCP device\\n\");\n\t\treturn -ENODEV;\n\t}\n\tmemset(local->remote_gb, 0, NFC_MAX_GT_LEN);\n\tmemcpy(local->remote_gb, gb, gb_len);\n\tlocal->remote_gb_len = gb_len;\n\tif (memcmp(local->remote_gb, llcp_magic, 3)) {\n\t\tpr_err(\"MAC does not support LLCP\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn nfc_llcp_parse_gb_tlv(local,\n\t\t\t\t     &local->remote_gb[3],\n\t\t\t\t     local->remote_gb_len - 3);\n}", "target": 1}
{"code": "static inline struct htx_blk *htx_add_trailer(struct htx *htx, const struct ist name,\n\t\t\t\t\t      const struct ist value)\n{\n\tstruct htx_blk *blk;\n\tblk = htx_add_blk(htx, HTX_BLK_TLR, name.len + value.len);\n\tif (!blk)\n\t\treturn NULL;\n\tblk->info += (value.len << 8) + name.len;\n\tist2bin_lc(htx_get_blk_ptr(htx, blk), name);\n\tmemcpy(htx_get_blk_ptr(htx, blk)  + name.len, value.ptr, value.len);\n\treturn blk;\n}", "target": 1}
{"code": "static void __mark_reg32_unbounded(struct bpf_reg_state *reg)\n{\n\treg->s32_min_value = S32_MIN;\n\treg->s32_max_value = S32_MAX;\n\treg->u32_min_value = 0;\n\treg->u32_max_value = U32_MAX;\n}", "target": 0}
{"code": "int64 Archive::Tell()\n{\n#ifdef USE_QOPEN\n  int64 QPos;\n  if (QOpen.Tell(&QPos))\n    return QPos;\n#endif\n#ifdef USE_ARCMEM\n  int64 APos;\n  if (ArcMem.Tell(&APos))\n    return APos;\n#endif\n  return File::Tell();\n}", "target": 0}
{"code": "static inline ut32 r_read_le32(const void *src) {\n\tif (!src) {\n\t\treturn UT32_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut32)s[3]) << 24) | (((ut32)s[2]) << 16) |\n\t\t(((ut32)s[1]) << 8) | (((ut32)s[0]) << 0);\n}", "target": 0}
{"code": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain == 0) {\n\t\t\treturn 0; \n\t\t}\n\t\trlen = remain;\n\t}\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\treturn rlen;\n}", "target": 1}
{"code": "static inline bool is_nmi(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);\n}", "target": 0}
{"code": "static void release_posix_timer(struct k_itimer *tmr, int it_id_set)\n{\n\tif (it_id_set) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&hash_lock, flags);\n\t\thlist_del_rcu(&tmr->t_hash);\n\t\tspin_unlock_irqrestore(&hash_lock, flags);\n\t}\n\tput_pid(tmr->it_pid);\n\tsigqueue_free(tmr->sigq);\n\tcall_rcu(&tmr->it.rcu, k_itimer_rcu_free);\n}", "target": 0}
{"code": "opfunc_construct (vm_frame_ctx_t *frame_ctx_p) \n{\n  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;\n  uint8_t opcode = byte_code_p[-1];\n  unsigned int arguments_list_len;\n  if (opcode >= CBC_NEW0)\n  {\n    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);\n  }\n  else\n  {\n    arguments_list_len = *byte_code_p++;\n  }\n  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;\n  ecma_value_t constructor_value = stack_top_p[-1];\n  ecma_value_t completion_value;\n  const char *constructor_message_p = ecma_check_constructor (constructor_value);\n  if (constructor_message_p != ECMA_IS_VALID_CONSTRUCTOR)\n  {\n    completion_value = ecma_raise_type_error (constructor_message_p);\n  }\n  else\n  {\n    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);\n    completion_value = ecma_op_function_construct (constructor_obj_p,\n                                                   constructor_obj_p,\n                                                   stack_top_p,\n                                                   arguments_list_len);\n  }\n  for (uint32_t i = 0; i < arguments_list_len; i++)\n  {\n    ecma_fast_free_value (stack_top_p[i]);\n  }\n  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))\n  {\n#if JERRY_DEBUGGER\n    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;\n#endif \n    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;\n  }\n  else\n  {\n    ecma_free_value (stack_top_p[-1]);\n    frame_ctx_p->byte_code_p = byte_code_p;\n    stack_top_p[-1] = completion_value;\n  }\n  frame_ctx_p->stack_top_p = stack_top_p;\n} ", "target": 0}
{"code": "NOEXPORT void tray_update(const int num) {\n    NOTIFYICONDATA nid;\n    static ICON_TYPE previous_icon=ICON_NONE;\n    ICON_TYPE current_icon;\n    LPTSTR tip;\n    if(!global_options.option.taskbar) { \n        tray_delete(); \n        return;\n    }\n    if(!tray_menu_handle) \n        tray_menu_handle=LoadMenu(ghInst, MAKEINTRESOURCE(IDM_TRAYMENU));\n    if(!tray_menu_handle) {\n        ioerror(\"LoadMenu\");\n        return;\n    }\n    if(cmdline.service)\n        EnableMenuItem(tray_menu_handle, IDM_EDIT_CONFIG, MF_GRAYED);\n    ZeroMemory(&nid, sizeof nid);\n    nid.cbSize=sizeof nid;\n    nid.uID=1; \n    nid.uFlags=NIF_MESSAGE|NIF_TIP;\n    nid.uCallbackMessage=WM_SYSTRAY; \n    nid.hWnd=hwnd; \n    if(num<0) {\n        tip=str_tprintf(TEXT(\"Server is down\"));\n        current_icon=ICON_ERROR;\n    } else if(num>0) {\n        tip=str_tprintf(TEXT(\"%d active session(s)\"), num);\n        current_icon=ICON_ACTIVE;\n    } else {\n        tip=str_tprintf(TEXT(\"Server is idle\"));\n        current_icon=ICON_IDLE;\n    }\n    _tcsncpy(nid.szTip, tip, 63);\n    nid.szTip[63]=TEXT('\\0');\n    str_free(tip);\n    nid.hIcon=global_options.icon[current_icon];\n    if(current_icon!=previous_icon) {\n        nid.uFlags|=NIF_ICON;\n        previous_icon=current_icon;\n    }\n    if(Shell_NotifyIcon(NIM_MODIFY, &nid)) \n        return; \n    nid.uFlags|=NIF_ICON;\n    Shell_NotifyIcon(NIM_ADD, &nid);\n}", "target": 1}
{"code": "static void __pam_log(const pam_handle_t *pamh, int ctrl, int err, const char *format, ...)\n{\n\tva_list args;\n\tif (_pam_log_is_silent(ctrl)) {\n\t\treturn;\n\t}\n\tva_start(args, format);\n\t_pam_log_int(pamh, err, format, args);\n\tva_end(args);\n}", "target": 0}
{"code": "static inline void verify_event(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t void *event)\n{\n}", "target": 0}
{"code": "static int xar_hash_check(int hash, const void * result, const void * expected)\n{\n    int len;\n    if (!result || !expected)\n        return 1;\n    switch (hash) {\n    case XAR_CKSUM_SHA1:\n        len = SHA1_HASH_SIZE;\n        break;\n    case XAR_CKSUM_MD5:\n        len = CLI_HASH_MD5;\n        break;\n    case XAR_CKSUM_OTHER:\n    case XAR_CKSUM_NONE:\n    default:\n        return 1;\n    }\n    return memcmp(result, expected, len);\n}", "target": 1}
{"code": "  void operator()(OpKernelContext* context, const Tensor& input_tensor,\n                  Tensor& output_tensor, int n, bool reverse) {\n    const T* input = input_tensor.flat<T>().data();\n    T* output = output_tensor.flat<T>().data();\n    const int num_rows = output_tensor.NumElements();\n    const int last_dim = input_tensor.dim_size(input_tensor.dims() - 1);\n    auto SubNthElement = [&, input, output, last_dim, n](int start, int limit) {\n      std::vector<T> buf(last_dim);\n      for (int b = start; b < limit; ++b) {\n        const T* input_start = input + b * last_dim;\n        const T* input_end = input + (b + 1) * last_dim;\n        std::copy(input_start, input_end, buf.begin());\n        std::nth_element(buf.begin(), buf.begin() + n, buf.end());\n        output[b] = buf[n];\n      }\n    };\n    auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads());\n    Shard(worker_threads.num_threads, worker_threads.workers, num_rows,\n          20 * last_dim, SubNthElement);\n  }", "target": 1}
{"code": "static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pcu)\n{\n\tconst struct usb_cdc_union_desc *union_desc;\n\tstruct usb_host_interface *alt;\n\tunion_desc = ims_pcu_get_cdc_union_desc(intf);\n\tif (!union_desc)\n\t\treturn -EINVAL;\n\tpcu->ctrl_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bMasterInterface0);\n\tif (!pcu->ctrl_intf)\n\t\treturn -EINVAL;\n\talt = pcu->ctrl_intf->cur_altsetting;\n\tpcu->ep_ctrl = &alt->endpoint[0].desc;\n\tpcu->max_ctrl_size = usb_endpoint_maxp(pcu->ep_ctrl);\n\tpcu->data_intf = usb_ifnum_to_if(pcu->udev,\n\t\t\t\t\t union_desc->bSlaveInterface0);\n\tif (!pcu->data_intf)\n\t\treturn -EINVAL;\n\talt = pcu->data_intf->cur_altsetting;\n\tif (alt->desc.bNumEndpoints != 2) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Incorrect number of endpoints on data interface (%d)\\n\",\n\t\t\talt->desc.bNumEndpoints);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_out = &alt->endpoint[0].desc;\n\tif (!usb_endpoint_is_bulk_out(pcu->ep_out)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"First endpoint on data interface is not BULK OUT\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_out_size = usb_endpoint_maxp(pcu->ep_out);\n\tif (pcu->max_out_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max OUT packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_out_size);\n\t\treturn -EINVAL;\n\t}\n\tpcu->ep_in = &alt->endpoint[1].desc;\n\tif (!usb_endpoint_is_bulk_in(pcu->ep_in)) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Second endpoint on data interface is not BULK IN\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpcu->max_in_size = usb_endpoint_maxp(pcu->ep_in);\n\tif (pcu->max_in_size < 8) {\n\t\tdev_err(pcu->dev,\n\t\t\t\"Max IN packet size is too small (%zd)\\n\",\n\t\t\tpcu->max_in_size);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;", "target": 0}
{"code": "static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n#endif\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy, extack);\n\tif (err < 0)\n\t\treturn err;\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\treturn link->doit(skb, nlh, attrs);\n}", "target": 0}
{"code": "static inline void init_fs_pin(struct fs_pin *p, void (*kill)(struct fs_pin *))\n{\n\tinit_waitqueue_head(&p->wait);\n\tINIT_HLIST_NODE(&p->s_list);\n\tINIT_HLIST_NODE(&p->m_list);\n\tp->kill = kill;\n}", "target": 0}
{"code": "inline typename V::VariantType FBUnserializer<V>::unserialize(\n  folly::StringPiece serialized) {\n  FBUnserializer<V> unserializer(serialized);\n  return unserializer.unserializeThing();\n}", "target": 1}
{"code": "spnego_gss_wrap_iov_length(OM_uint32 *minor_status,\n\t\t\t   gss_ctx_id_t context_handle,\n\t\t\t   int conf_req_flag,\n\t\t\t   gss_qop_t qop_req,\n\t\t\t   int *conf_state,\n\t\t\t   gss_iov_buffer_desc *iov,\n\t\t\t   int iov_count)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_iov_length(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  conf_req_flag,\n\t\t\t\t  qop_req,\n\t\t\t\t  conf_state,\n\t\t\t\t  iov,\n\t\t\t\t  iov_count);\n\treturn (ret);\n}", "target": 1}
{"code": "HMAC_SHA256_Final(unsigned char digest[32], struct HMAC_SHA256_CTX * ctx)\n{\n  unsigned char ihash[32];\n  scrypt_SHA256_Final(ihash, &ctx->ictx);\n  scrypt_SHA256_Update(&ctx->octx, ihash, 32);\n  scrypt_SHA256_Final(digest, &ctx->octx);\n  memset(ihash, 0, 32);\n}", "target": 1}
{"code": "NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\twhile (pAvPair)\n\t{\n\t\tUINT16 id = ntlm_av_pair_get_id(pAvPair);\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n\tif (!pAvPair)\n\t\tcbAvPair = 0;\n\tif (pcbAvPairListRemaining)\n\t\t*pcbAvPairListRemaining = cbAvPair;\n\treturn pAvPair;\n}", "target": 1}
{"code": "juniper_mlppp_print(netdissect_options *ndo,\n                    const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_MLPPP;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        if (ndo->ndo_eflag &&\n            EXTRACT_16BITS(&l2info.cookie) != PPP_OSI &&\n            EXTRACT_16BITS(&l2info.cookie) !=  (PPP_ADDRESS << 8 | PPP_CONTROL))\n            ND_PRINT((ndo, \"Bundle-ID %u: \", l2info.bundle));\n        p+=l2info.header_len;\n        switch(l2info.proto) {\n        case JUNIPER_LSQ_L3_PROTO_IPV4:\n            if (l2info.cookie[4] == (JUNIPER_LSQ_COOKIE_RE|JUNIPER_LSQ_COOKIE_DIR))\n                ppp_print(ndo, p, l2info.length);\n            else\n                ip_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_IPV6:\n            ip6_print(ndo, p,l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_MPLS:\n            mpls_print(ndo, p, l2info.length);\n            return l2info.header_len;\n        case JUNIPER_LSQ_L3_PROTO_ISO:\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            return l2info.header_len;\n        default:\n            break;\n        }\n        switch (EXTRACT_16BITS(&l2info.cookie)) {\n        case PPP_OSI:\n            ppp_print(ndo, p - 2, l2info.length + 2);\n            break;\n        case (PPP_ADDRESS << 8 | PPP_CONTROL): \n        default:\n            ppp_print(ndo, p, l2info.length);\n            break;\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "static void netbk_fatal_tx_err(struct xenvif *vif)\n{\n\tnetdev_err(vif->dev, \"fatal error; disabling device\\n\");\n\txenvif_carrier_off(vif);\n\txenvif_put(vif);\n}", "target": 0}
{"code": "long keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\told_setting = current_cred_xxx(jit_keyring);\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0) {\n\t\t\tif (ret != -EEXIST)\n\t\t\t\tgoto error;\n\t\t\tret = 0;\n\t\t}\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}", "target": 1}
{"code": "static bool too_many_pipe_buffers_hard(struct user_struct *user)\n{\n\treturn pipe_user_pages_hard &&\n\t       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_hard;\n}", "target": 0}
{"code": "Http::FilterMetadataStatus Context::onRequestMetadata() {\n  if (!wasm_->onRequestMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \n}", "target": 1}
{"code": "static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,\n\t\t       struct posix_acl *acl)\n{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value)\n\t\t\treturn -ENOMEM;\n\t\trc = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\trc = __jfs_setxattr(tid, inode, ea_name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "static int __btrfs_set_acl(struct btrfs_trans_handle *trans,\n\t\t\t struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint ret, size = 0;\n\tconst char *name;\n\tchar *value = NULL;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tret = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EINVAL : 0;\n\t\tname = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tvalue = kmalloc(size, GFP_KERNEL);\n\t\tif (!value) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\tret = __btrfs_setxattr(trans, inode, name, value, size, 0);\nout:\n\tkfree(value);\n\tif (!ret)\n\t\tset_cached_acl(inode, type, acl);\n\treturn ret;\n}", "target": 1}
{"code": "int main(int argc, char * argv[])\n{\n    gr_face * face = 0;\n    try\n\t{\n\t\tif (argc != 2)\tthrow std::length_error(\"not enough arguments: need a backing font\");\n\t\tdummyFace = face_handle(argv[1]);\n\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n    gr_face_destroy(face);\n    return 0;\n}", "target": 1}
{"code": "static inline int l2cap_connect_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conn_rsp *rsp = (struct l2cap_conn_rsp *) data;\n\tu16 scid, dcid, result, status;\n\tstruct sock *sk;\n\tu8 req[128];\n\tscid   = __le16_to_cpu(rsp->scid);\n\tdcid   = __le16_to_cpu(rsp->dcid);\n\tresult = __le16_to_cpu(rsp->result);\n\tstatus = __le16_to_cpu(rsp->status);\n\tBT_DBG(\"dcid 0x%4.4x scid 0x%4.4x result 0x%2.2x status 0x%2.2x\", dcid, scid, result, status);\n\tif (scid) {\n\t\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\t\tif (!sk)\n\t\t\treturn 0;\n\t} else {\n\t\tsk = l2cap_get_chan_by_ident(&conn->chan_list, cmd->ident);\n\t\tif (!sk)\n\t\t\treturn 0;\n\t}\n\tswitch (result) {\n\tcase L2CAP_CR_SUCCESS:\n\t\tsk->sk_state = BT_CONFIG;\n\t\tl2cap_pi(sk)->ident = 0;\n\t\tl2cap_pi(sk)->dcid = dcid;\n\t\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_REQ_SENT;\n\t\tl2cap_pi(sk)->conf_state &= ~L2CAP_CONF_CONNECT_PEND;\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\tl2cap_pi(sk)->num_conf_req++;\n\t\tbreak;\n\tcase L2CAP_CR_PEND:\n\t\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_CONNECT_PEND;\n\t\tbreak;\n\tdefault:\n\t\tl2cap_chan_del(sk, ECONNREFUSED);\n\t\tbreak;\n\t}\n\tbh_unlock_sock(sk);\n\treturn 0;\n}", "target": 0}
{"code": "int ScriptController::contextDebugId(v8::Handle<v8::Context> context)\n{\n    return V8PerContextDebugData::contextDebugId(context);\n}", "target": 0}
{"code": "int ip_options_get_from_user(struct net *net, struct ip_options **optp,\n\t\t\t     unsigned char __user *data, int optlen)\n{\n\tstruct ip_options *opt = ip_options_get_alloc(optlen);\n\tif (!opt)\n\t\treturn -ENOMEM;\n\tif (optlen && copy_from_user(opt->__data, data, optlen)) {\n\t\tkfree(opt);\n\t\treturn -EFAULT;\n\t}\n\treturn ip_options_get_finish(net, optp, opt, optlen);\n}", "target": 1}
{"code": "static void cma_id_get(struct rdma_id_private *id_priv)\n{\n\trefcount_inc(&id_priv->refcount);\n}", "target": 0}
{"code": "ev_archive_new (void)\n{\n\treturn g_object_new (EV_TYPE_ARCHIVE, NULL);\n}", "target": 0}
{"code": "hb_set_intersect (hb_set_t       *set,\n\t\t  const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->intersect (*other);\n}", "target": 1}
{"code": "avp_enum(struct l2tp_avp *avp, const u_char *pkt, int pktlen, int filldata)\n{\n\tuint16_t flags;\n\tL2TP_SUBR_ASSERT(pktlen >= 6);\n\tif (pktlen < 6)\n\t\treturn -1;\n\tGETSHORT(flags, pkt);\n\tavp->is_mandatory = ((flags & 0x8000) != 0)? 1 : 0;\n\tavp->is_hidden = ((flags & 0x4000) != 0)? 1 : 0;\n\tavp->length = flags & 0x03ff;\n\tGETSHORT(avp->vendor_id, pkt);\n\tavp->attr_type = *pkt << 8;\n\tavp->attr_type |= *(pkt + 1);\n\tpkt += 2;\n\tif (avp->length > pktlen)\n\t\treturn -1;\n\tif (filldata != 0)\n\t\tmemcpy(avp->attr_value, pkt, avp->length - 6);\n\treturn avp->length;\n}", "target": 1}
{"code": "runas_grouplist_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct member_list *group_list, struct member **matching_group)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    int group_matched = UNSPEC;\n    struct member *m;\n    struct alias *a;\n    debug_decl(runas_grouplist_matches, SUDOERS_DEBUG_MATCH);\n    if (group_list != NULL) {\n\tTAILQ_FOREACH_REVERSE(m, group_list, member_list, entries) {\n\t    switch (m->type) {\n\t\tcase ALL:\n\t\t    group_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t\tcase ALIAS:\n\t\t    a = alias_get(parse_tree, m->name, RUNASALIAS);\n\t\t    if (a != NULL) {\n\t\t\tconst int rc = runas_grouplist_matches(parse_tree,\n\t\t\t    &a->members, matching_group);\n\t\t\tif (rc != UNSPEC) {\n\t\t\t    if (m->negated) {\n\t\t\t\tgroup_matched = rc == ALLOW ? DENY : ALLOW;\n\t\t\t    } else {\n\t\t\t\tgroup_matched = rc;\n\t\t\t    }\n\t\t\t}\n\t\t\talias_put(a);\n\t\t\tbreak;\n\t\t    }\n\t\t    FALLTHROUGH;\n\t\tcase WORD:\n\t\t    if (group_matches(m->name, ctx->runas.gr))\n\t\t\tgroup_matched = m->negated ? DENY : ALLOW;\n\t\t    break;\n\t    }\n\t    if (group_matched != UNSPEC) {\n\t\tif (matching_group != NULL && m->type != ALIAS)\n\t\t    *matching_group = m;\n\t\tbreak;\n\t    }\n\t}\n    }\n    if (group_matched == UNSPEC) {\n\tstruct gid_list *runas_groups;\n\tif (ctx->runas.pw->pw_gid == ctx->runas.gr->gr_gid) {\n\t    group_matched = ALLOW;\t\n\t} else if ((runas_groups = runas_getgroups(ctx)) != NULL) {\n\t    int i;\n\t    for (i = 0; i < runas_groups->ngids; i++) {\n\t\tif (runas_groups->gids[i] == ctx->runas.gr->gr_gid) {\n\t\t    group_matched = ALLOW;\t\n\t\t    break;\n\t\t}\n\t    }\n\t    sudo_gidlist_delref(runas_groups);\n\t}\n    }\n    debug_return_int(group_matched);\n}", "target": 1}
{"code": "static void account_pipe_buffers(struct pipe_inode_info *pipe,\n                                 unsigned long old, unsigned long new)\n{\n\tatomic_long_add(new - old, &pipe->user->pipe_bufs);\n}", "target": 0}
{"code": "static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)\n{\n\tstruct file *filp;\n\tint ret;\n\tif (nd->intent.open.flags & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path->dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, nd->intent.open.flags);\n\treturn ret;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}", "target": 1}
{"code": "set_option_info(struct archive_string *info, int *opt, const char *key,\n    enum keytype type,  ...)\n{\n\tva_list ap;\n\tchar prefix;\n\tconst char *s;\n\tint d;\n\tprefix = (*opt==0)? ' ':',';\n\tva_start(ap, type);\n\tswitch (type) {\n\tcase KEY_FLG:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s%s\",\n\t\t    prefix, (d == 0)?\"!\":\"\", key);\n\t\tbreak;\n\tcase KEY_STR:\n\t\ts = va_arg(ap, const char *);\n\t\tarchive_string_sprintf(info, \"%c%s=%s\",\n\t\t    prefix, key, s);\n\t\tbreak;\n\tcase KEY_INT:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s=%d\",\n\t\t    prefix, key, d);\n\t\tbreak;\n\tcase KEY_HEX:\n\t\td = va_arg(ap, int);\n\t\tarchive_string_sprintf(info, \"%c%s=%x\",\n\t\t    prefix, key, d);\n\t\tbreak;\n\t}\n\tva_end(ap);\n\t*opt = 1;\n}", "target": 0}
{"code": "const u32 *gf_isom_get_track_switch_parameter(GF_ISOFile *movie, u32 trackNumber, u32 group_index, u32 *switchGroupID, u32 *criteriaListSize)\n{\n\tGF_TrackBox *trak;\n\tGF_UserDataMap *map;\n\tGF_TrackSelectionBox *tsel;\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!group_index || !trak || !trak->udta) return NULL;\n\tmap = udta_getEntry(trak->udta, GF_ISOM_BOX_TYPE_TSEL, NULL);\n\tif (!map) return NULL;\n\ttsel = (GF_TrackSelectionBox*)gf_list_get(map->boxes, group_index-1);\n\tif (!tsel) return NULL;\n\t*switchGroupID = tsel->switchGroup;\n\t*criteriaListSize = tsel->attributeListCount;\n\treturn (const u32 *) tsel->attributeList;\n}", "target": 0}
{"code": "static pyc_object *get_set_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}", "target": 1}
{"code": "list_fields(MYSQL *mysql,const char *db,const char *table,\n\t    const char *wild)\n{\n  char query[1024],*end;\n  MYSQL_RES *result;\n  MYSQL_ROW row;\n  ulong UNINIT_VAR(rows);\n  if (mysql_select_db(mysql,db))\n  {\n    fprintf(stderr,\"%s: Cannot connect to db: %s: %s\\n\",my_progname,db,\n\t    mysql_error(mysql));\n    return 1;\n  }\n  if (opt_count)\n  {\n    sprintf(query,\"select count(*) from `%s`\", table);\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot get record count for db: %s, table: %s: %s\\n\",\n              my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    row= mysql_fetch_row(result);\n    rows= (ulong) strtoull(row[0], (char**) 0, 10);\n    mysql_free_result(result);\n  }\n  end=strmov(strmov(strmov(query,\"show  columns from `\"),table),\"`\");\n  if (wild && wild[0])\n    strxmov(end,\" like '\",wild,\"'\",NullS);\n  if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n  {\n    fprintf(stderr,\"%s: Cannot list columns in db: %s, table: %s: %s\\n\",\n\t    my_progname,db,table,mysql_error(mysql));\n    return 1;\n  }\n  printf(\"Database: %s  Table: %s\", db, table);\n  if (opt_count)\n    printf(\"  Rows: %lu\", rows);\n  if (wild && wild[0])\n    printf(\"  Wildcard: %s\",wild);\n  putchar('\\n');\n  print_res_header(result);\n  while ((row=mysql_fetch_row(result)))\n    print_res_row(result,row);\n  print_res_top(result);\n  if (opt_show_keys)\n  {\n    end=strmov(strmov(strmov(query,\"show keys from `\"),table),\"`\");\n    if (mysql_query(mysql,query) || !(result=mysql_store_result(mysql)))\n    {\n      fprintf(stderr,\"%s: Cannot list keys in db: %s, table: %s: %s\\n\",\n\t      my_progname,db,table,mysql_error(mysql));\n      return 1;\n    }\n    if (mysql_num_rows(result))\n    {\n      print_res_header(result);\n      while ((row=mysql_fetch_row(result)))\n\tprint_res_row(result,row);\n      print_res_top(result);\n    }\n    else\n      puts(\"Table has no keys\");\n  }\n  mysql_free_result(result);\n  return 0;\n}", "target": 1}
{"code": "d_lite_step(int argc, VALUE *argv, VALUE self)\n{\n    VALUE limit, step, date;\n    int c;\n    rb_scan_args(argc, argv, \"11\", &limit, &step);\n    if (argc < 2)\n\tstep = INT2FIX(1);\n#if 0\n    if (f_zero_p(step))\n\trb_raise(rb_eArgError, \"step can't be 0\");\n#endif\n    RETURN_ENUMERATOR(self, argc, argv);\n    date = self;\n    c = f_cmp(step, INT2FIX(0));\n    if (c < 0) {\n\twhile (FIX2INT(d_lite_cmp(date, limit)) >= 0) {\n\t    rb_yield(date);\n\t    date = d_lite_plus(date, step);\n\t}\n    }\n    else if (c == 0) {\n\twhile (1)\n\t    rb_yield(date);\n    }\n    else  {\n\twhile (FIX2INT(d_lite_cmp(date, limit)) <= 0) {\n\t    rb_yield(date);\n\t    date = d_lite_plus(date, step);\n\t}\n    }\n    return self;\n}", "target": 0}
{"code": "    **/\n    CImg<T>& autocrop(const T *const color=0, const char *const axes=\"zyx\") {\n      if (is_empty()) return *this;\n      if (!color) { \n        const CImg<T> col1 = get_vector_at(0,0,0);\n        const unsigned int w = _width, h = _height, d = _depth, s = _spectrum;\n        autocrop(col1,axes);\n        if (_width==w && _height==h && _depth==d && _spectrum==s) {\n          const CImg<T> col2 = get_vector_at(w - 1,h - 1,d - 1);\n          autocrop(col2,axes);\n        }\n        return *this;\n      }\n      for (const char *s = axes; *s; ++s) {\n        const char axis = cimg::lowercase(*s);\n        switch (axis) {\n        case 'x' : {\n\t  int x0 = width(), x1 = -1;\n\t  cimg_forC(*this,c) {\n\t    const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'x');\n\t    const int nx0 = coords[0], nx1 = coords[1];\n\t    if (nx0>=0 && nx1>=0) { x0 = std::min(x0,nx0); x1 = std::max(x1,nx1); }\n\t  }\n          if (x0==width() && x1==-1) return assign(); else crop(x0,x1);\n\t} break;\n        case 'y' : {\n\t  int y0 = height(), y1 = -1;\n\t  cimg_forC(*this,c) {\n\t    const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'y');\n\t    const int ny0 = coords[0], ny1 = coords[1];\n\t    if (ny0>=0 && ny1>=0) { y0 = std::min(y0,ny0); y1 = std::max(y1,ny1); }\n\t  }\n          if (y0==height() && y1==-1) return assign(); else crop(0,y0,_width - 1,y1);\n\t} break;\n        default : {\n\t  int z0 = depth(), z1 = -1;\n\t  cimg_forC(*this,c) {\n\t    const CImg<intT> coords = get_shared_channel(c)._autocrop(color[c],'z');\n\t    const int nz0 = coords[0], nz1 = coords[1];\n\t    if (nz0>=0 && nz1>=0) { z0 = std::min(z0,nz0); z1 = std::max(z1,nz1); }\n\t  }\n\t  if (z0==depth() && z1==-1) return assign(); else crop(0,0,z0,_width - 1,_height - 1,z1);\n\t}\n        }\n      }\n      return *this;", "target": 0}
{"code": "soup_server_get_listener (SoupServer *server)\n{\n\tSoupServerPrivate *priv;\n\tg_return_val_if_fail (SOUP_IS_SERVER (server), NULL);\n\tpriv = SOUP_SERVER_GET_PRIVATE (server);\n\treturn priv->listen_sock;\n}", "target": 0}
{"code": "int ConnectionImpl::onFrameSend(const nghttp2_frame* frame) {\n  ENVOY_CONN_LOG(trace, \"sent frame type={}\", connection_, static_cast<uint64_t>(frame->hd.type));\n  switch (frame->hd.type) {\n  case NGHTTP2_GOAWAY: {\n    ENVOY_CONN_LOG(debug, \"sent goaway code={}\", connection_, frame->goaway.error_code);\n    if (frame->goaway.error_code != NGHTTP2_NO_ERROR) {\n      return NGHTTP2_ERR_CALLBACK_FAILURE;\n    }\n    break;\n  }\n  case NGHTTP2_RST_STREAM: {\n    ENVOY_CONN_LOG(debug, \"sent reset code={}\", connection_, frame->rst_stream.error_code);\n    stats_.tx_reset_.inc();\n    break;\n  }\n  case NGHTTP2_HEADERS:\n  case NGHTTP2_DATA: {\n    StreamImpl* stream = getStream(frame->hd.stream_id);\n    if (stream->headers_) {\n      ASSERT(stream->headers_->byteSize().has_value() &&\n             stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());\n    }\n    stream->local_end_stream_sent_ = frame->hd.flags & NGHTTP2_FLAG_END_STREAM;\n    break;\n  }\n  }\n  return 0;\n}", "target": 0}
{"code": "void PdfXRefStreamParserObject::ReadXRefTable()\n{\n    int64_t size = this->GetDictionary().FindKeyAs<int64_t>(PdfName::KeySize, 0);\n    auto& arrObj = this->GetDictionary().MustFindKey(\"W\");\n    const PdfArray* arr;\n    if (!arrObj.TryGetArray(arr) || arr->size() != 3)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n    int64_t wArray[W_ARRAY_SIZE] = { 0, 0, 0 };\n    int64_t num;\n    for (unsigned i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (!(*arr)[i].TryGetNumber(num))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef stream /W array\");\n        wArray[i] = num;\n    }\n    vector<int64_t> indices;\n    getIndices(indices, static_cast<int64_t>(size));\n    parseStream(wArray, indices);\n}", "target": 1}
{"code": "static int IntensityCompare(const void *x,const void *y)\n{\n  const PixelChannels\n    *color_1,\n    *color_2;\n  double\n    distance;\n  ssize_t\n    i;\n  color_1=(const PixelChannels *) x;\n  color_2=(const PixelChannels *) y;\n  distance=0.0;\n  for (i=0; i < MaxPixelChannels; i++)\n    distance+=color_1->channel[i]-(double) color_2->channel[i];\n  return(distance < 0.0 ? -1 : distance > 0.0 ? 1 : 0);\n}", "target": 0}
{"code": "void * malloc(size_t lb)\n{\n#   if defined(I386) && defined(GC_SOLARIS_THREADS)\n      if (!EXPECT(GC_is_initialized, TRUE)) return sbrk(lb);\n#   endif \n    return((void *)REDIRECT_MALLOC(lb));\n}", "target": 0}
{"code": "static inline void pfkey_hdr_dup(struct sadb_msg *new,\n\t\t\t\t const struct sadb_msg *orig)\n{\n\t*new = *orig;\n}", "target": 0}
{"code": "void LightProcess::closeShadow() {\n  Lock lock(m_procMutex);\n  if (m_shadowProcess) {\n    fprintf(m_fout, \"exit\\n\");\n    fflush(m_fout);\n    fclose(m_fin);\n    fclose(m_fout);\n    ::waitpid(m_shadowProcess, nullptr, 0);\n  }\n  if (!m_afdtFilename.empty()) {\n    remove(m_afdtFilename.c_str());\n  }\n  if (m_afdt_fd >= 0) {\n    ::close(m_afdt_fd);\n    m_afdt_fd = -1;\n  }\n  m_shadowProcess = 0;\n}", "target": 1}
{"code": "smix(uint8_t * B, size_t r, uint64_t N, uint32_t * V, uint32_t * XY)\n{\n  uint32_t * X = XY;\n  uint32_t * Y = &XY[32 * r];\n  uint32_t * Z = &XY[64 * r];\n  uint64_t i;\n  uint64_t j;\n  size_t k;\n  for (k = 0; k < 32 * r; k++) {\n    X[k] = folly::Endian::little32(*((uint32_t *) &B[4 * k]));\n  }\n  for (i = 0; i < N; i += 2) {\n    blkcpy(&V[i * (32 * r)], X, 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    blkcpy(&V[(i + 1) * (32 * r)], Y, 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (i = 0; i < N; i += 2) {\n    j = integerify(X, r) & (N - 1);\n    blkxor(X, &V[j * (32 * r)], 128 * r);\n    blockmix_salsa8(X, Y, Z, r);\n    j = integerify(Y, r) & (N - 1);\n    blkxor(Y, &V[j * (32 * r)], 128 * r);\n    blockmix_salsa8(Y, X, Z, r);\n  }\n  for (k = 0; k < 32 * r; k++) {\n    *((uint32_t *) &B[4 * k]) = folly::Endian::little32(X[k]);\n  }\n}", "target": 1}
{"code": "uipbuf_add_ext_hdr(int16_t len)\n{\n  if(len + uip_len <= UIP_LINK_MTU && len + uip_len >= 0 && len + uip_ext_len >= 0) {\n    uip_ext_len += len;\n    uip_len += len;\n    return true;\n  } else {\n    return false;\n  }\n}", "target": 0}
{"code": "void AuthenticationFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOldOption(\"server.disable-authentication\",\n                        \"server.authentication\");\n  options->addOldOption(\"server.disable-authentication-unix-sockets\",\n                        \"server.authentication-unix-sockets\");\n  options->addOldOption(\"server.authenticate-system-only\",\n                        \"server.authentication-system-only\");\n  options->addOldOption(\"server.allow-method-override\",\n                        \"http.allow-method-override\");\n  options->addOldOption(\"server.hide-product-header\",\n                        \"http.hide-product-header\");\n  options->addOldOption(\"server.keep-alive-timeout\", \"http.keep-alive-timeout\");\n  options->addOldOption(\"server.default-api-compatibility\", \"\");\n  options->addOldOption(\"no-server\", \"server.rest-server\");\n  options->addOption(\"--server.authentication\",\n                     \"enable authentication for ALL client requests\",\n                     new BooleanParameter(&_active));\n  options->addOption(\n      \"--server.authentication-timeout\",\n      \"timeout for the authentication cache in seconds (0 = indefinitely)\",\n      new DoubleParameter(&_authenticationTimeout));\n  options->addOption(\"--server.local-authentication\",\n                     \"enable authentication using the local user database\",\n                     new BooleanParameter(&_localAuthentication));\n  options->addOption(\n      \"--server.authentication-system-only\",\n      \"use HTTP authentication only for requests to /_api and /_admin\",\n      new BooleanParameter(&_authenticationSystemOnly));\n#ifdef ARANGODB_HAVE_DOMAIN_SOCKETS\n  options->addOption(\"--server.authentication-unix-sockets\",\n                     \"authentication for requests via UNIX domain sockets\",\n                     new BooleanParameter(&_authenticationUnixSockets));\n#endif\n  options\n      ->addOption(\"--server.jwt-secret\",\n                  \"secret to use when doing jwt authentication\",\n                  new StringParameter(&_jwtSecretProgramOption))\n      .setDeprecatedIn(30322)\n      .setDeprecatedIn(30402);\n  options->addOption(\n      \"--server.jwt-secret-keyfile\",\n      \"file containing jwt secret to use when doing jwt authentication.\",\n      new StringParameter(&_jwtSecretKeyfileProgramOption));\n  options->addOption(\n      \"--server.jwt-secret-folder\",\n      \"folder containing one or more jwt secret files to use for jwt \"\n      \"authentication. Files are sorted alphabetically: First secret \"\n      \"is used for signing + verifying JWT tokens. The latter secrets \"\n      \"are only used for verifying.\",\n      new StringParameter(&_jwtSecretFolderProgramOption),\n      arangodb::options::makeDefaultFlags(arangodb::options::Flags::Enterprise))\n      .setIntroducedIn(30700);\n}", "target": 1}
{"code": "\t\tauto GetTargetAndAlsoCheckForProxy() -> Local<Object> {\n\t\t\tauto object = Local<Object>::Cast(Deref(target));\n\t\t\tif (HasProxy(object)) {\n\t\t\t\tthrow RuntimeTypeError(\"Object is or has proxy\");\n\t\t\t}\n\t\t\treturn object;\n\t\t}", "target": 0}
{"code": "gopherStateFree(const CommCloseCbParams &params)\n{\n    GopherStateData *gopherState = (GopherStateData *)params.data;\n    delete gopherState;\n}", "target": 1}
{"code": "static UpVal **getupvalref (lua_State *L, int fidx, int n, LClosure **pf) {\n  LClosure *f;\n  StkId fi = index2addr(L, fidx);\n  api_check(L, ttisLclosure(fi), \"Lua function expected\");\n  f = clLvalue(fi);\n  api_check(L, (1 <= n && n <= f->p->sizeupvalues), \"invalid upvalue index\");\n  if (pf) *pf = f;\n  return &f->upvals[n - 1];  \n}", "target": 1}
{"code": "static BOOL recurse_check_bit(compiler_common *common, sljit_sw bit_index)\n{\nuint8_t *byte;\nuint8_t mask;\nSLJIT_ASSERT((bit_index & (sizeof(sljit_sw) - 1)) == 0);\nbit_index >>= SLJIT_WORD_SHIFT;\nmask = 1 << (bit_index & 0x7);\nbyte = common->recurse_bitset + (bit_index >> 3);\nif (*byte & mask)\n  return FALSE;\n*byte |= mask;\nreturn TRUE;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* c) override {\n    const Tensor& tag = c->input(0);\n    OP_REQUIRES(c, TensorShapeUtils::IsScalar(tag.shape()),\n                errors::InvalidArgument(\"tag must be scalar\"));\n    const Tensor& tensor = c->input(1);\n    const Tensor& serialized_summary_metadata_tensor = c->input(2);\n    OP_REQUIRES(\n        c,\n        TensorShapeUtils::IsScalar(serialized_summary_metadata_tensor.shape()),\n        errors::InvalidArgument(\"serialized_summary_metadata must be scalar\"));\n    Summary s;\n    Summary::Value* v = s.add_value();\n    v->set_tag(string(tag.scalar<tstring>()()));  \n    if (tensor.dtype() == DT_STRING) {\n      tensor.AsProtoField(v->mutable_tensor());\n    } else {\n      tensor.AsProtoTensorContent(v->mutable_tensor());\n    }\n    ParseFromTString(serialized_summary_metadata_tensor.scalar<tstring>()(),\n                     v->mutable_metadata());\n    Tensor* summary_tensor = nullptr;\n    OP_REQUIRES_OK(c, c->allocate_output(0, TensorShape({}), &summary_tensor));\n    CHECK(SerializeToTString(s, &summary_tensor->scalar<tstring>()()));\n  }", "target": 0}
{"code": "parse_range(char *str, size_t file_sz, int *nranges)\n{\n\tstatic struct range\t ranges[MAX_RANGES];\n\tint\t\t\t i = 0;\n\tchar\t\t\t*p, *q;\n\tif ((p = strchr(str, '=')) == NULL)\n\t\treturn (NULL);\n\t*p++ = '\\0';\n\tif (strcmp(str, \"bytes\") != 0)\n\t\treturn (NULL);\n\twhile ((q = strchr(p, ',')) != NULL) {\n\t\t*q++ = '\\0';\n\t\tif (parse_range_spec(p, file_sz, &ranges[i]) == 0)\n\t\t\tcontinue;\n\t\ti++;\n\t\tif (i == MAX_RANGES)\n\t\t\treturn (NULL);\n\t\tp = q;\n\t}\n\tif (parse_range_spec(p, file_sz, &ranges[i]) != 0)\n\t\ti++;\n\t*nranges = i;\n\treturn (i ? ranges : NULL);\n}", "target": 1}
{"code": "static int do_i2c_loop(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t       char *const argv[])\n{\n\tuint\tchip;\n\tint alen;\n\tuint\taddr;\n\tuint\tlength;\n\tu_char\tbytes[16];\n\tint\tdelay;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif (argc < 3)\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tlength = 1;\n\tlength = hextoul(argv[3], NULL);\n\tif (length > sizeof(bytes))\n\t\tlength = sizeof(bytes);\n\tdelay = 1000;\n\tif (argc > 3)\n\t\tdelay = dectoul(argv[4], NULL);\n\twhile (1) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_read(dev, addr, bytes, length);\n#else\n\t\tret = i2c_read(chip, addr, alen, bytes, length);\n#endif\n\t\tif (ret)\n\t\t\ti2c_report_err(ret, I2C_ERR_READ);\n\t\tudelay(delay);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n    i = 10; \n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    bi_clear_cache(ctx);\n    return bir;\n}", "target": 1}
{"code": "static void utee_param_to_param(struct tee_ta_param *p, struct utee_params *up)\n{\n\tsize_t n;\n\tuint32_t types = up->types;\n\tp->types = types;\n\tfor (n = 0; n < TEE_NUM_PARAMS; n++) {\n\t\tuintptr_t a = up->vals[n * 2];\n\t\tsize_t b = up->vals[n * 2 + 1];\n\t\tswitch (TEE_PARAM_TYPE_GET(types, n)) {\n\t\tcase TEE_PARAM_TYPE_MEMREF_INPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_OUTPUT:\n\t\tcase TEE_PARAM_TYPE_MEMREF_INOUT:\n\t\t\tp->u[n].mem.mobj = &mobj_virt;\n\t\t\tp->u[n].mem.offs = a;\n\t\t\tp->u[n].mem.size = b;\n\t\t\tbreak;\n\t\tcase TEE_PARAM_TYPE_VALUE_INPUT:\n\t\tcase TEE_PARAM_TYPE_VALUE_INOUT:\n\t\t\tp->u[n].val.a = a;\n\t\t\tp->u[n].val.b = b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmemset(&p->u[n], 0, sizeof(p->u[n]));\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 1}
{"code": "DSA_PrivateKey::create_signature_op(RandomNumberGenerator& ,\n                                    const std::string& params,\n                                    const std::string& provider) const\n   {\n   if(provider == \"base\" || provider.empty())\n      return std::unique_ptr<PK_Ops::Signature>(new DSA_Signature_Operation(*this, params));\n   throw Provider_Not_Found(algo_name(), provider);\n   }", "target": 1}
{"code": "static Image *ExtractPostscript(Image *image,const ImageInfo *image_info,\n  MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception)\n{\n  char\n    postscript_file[MagickPathExtent];\n  const MagicInfo\n    *magic_info;    \n  FILE\n    *ps_file;\n  ImageInfo\n    *clone_info;\n  Image\n    *image2;\n  unsigned char\n    magick[2*MagickPathExtent];    \n  if ((clone_info=CloneImageInfo(image_info)) == NULL)\n    return(image);\n  clone_info->blob=(void *) NULL;\n  clone_info->length=0;\n  (void) AcquireUniqueFilename(postscript_file);\n  ps_file=fopen_utf8(postscript_file,\"wb\");\n  if (ps_file == (FILE *) NULL)\n    goto FINISH;\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  (void) ReadBlob(image, 2*MagickPathExtent, magick);\n  (void) SeekBlob(image,PS_Offset,SEEK_SET);\n  while(PS_Size-- > 0)\n    {\n      (void) fputc(ReadBlobByte(image),ps_file);\n    }\n  (void) fclose(ps_file);\n  magic_info=GetMagicInfo(magick,2*MagickPathExtent,exception);\n  if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL;\n  if(exception->severity != UndefinedException) goto FINISH_UNL;     \n  if(magic_info->name == (char *) NULL) goto FINISH_UNL;\n  (void) CopyMagickMemory(clone_info->magick,magic_info->name,MagickPathExtent);\n  FormatLocaleString(clone_info->filename,MagickPathExtent,\"%s\",postscript_file);\n  image2=ReadImage(clone_info,exception);\n  if (!image2)\n    goto FINISH_UNL;\n  (void) CopyMagickMemory(image2->filename,image->filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick_filename,image->magick_filename,MagickPathExtent);\n  (void) CopyMagickMemory(image2->magick,image->magick,MagickPathExtent);\n  image2->depth=image->depth;\n  DestroyBlob(image2);\n  image2->blob=ReferenceBlob(image->blob);\n  if ((image->rows == 0) || (image->columns == 0))\n    DeleteImageFromList(&image);\n  AppendImageToList(&image,image2);\n FINISH_UNL:    \n  (void) RelinquishUniqueFileResource(postscript_file);\n FINISH:\n  DestroyImageInfo(clone_info);\n  return(image);\n}", "target": 1}
{"code": "inline void GatherNd(const RuntimeShape& params_shape,\n                     const ParamsT* params_data,\n                     const RuntimeShape& indices_shape,\n                     const IndicesT* indices_data,\n                     const RuntimeShape& output_shape, ParamsT* output_data) {\n  ruy::profiler::ScopeLabel label(\"GatherNd\");\n  const GatherNdHelperResult res = GatherNdHelper(params_shape, indices_shape);\n  for (int i = 0; i < res.n_slices; ++i) {\n    int from_pos = 0;\n    for (int j = 0; j < res.indices_nd; ++j) {\n      from_pos += indices_data[i * res.indices_nd + j] * res.dims_to_count[j];\n    }\n    std::memcpy(output_data + i * res.slice_size, params_data + from_pos,\n                sizeof(ParamsT) * res.slice_size);\n  }\n}", "target": 1}
{"code": "static gboolean restart_dhcp_timeout(gpointer user_data)\n{\n\tGDHCPClient *dhcp_client = user_data;\n\tdebug(dhcp_client, \"restart DHCP timeout\");\n\tif (dhcp_client->state == REBOOTING) {\n\t\tg_free(dhcp_client->last_address);\n\t\tdhcp_client->last_address = NULL;\n\t\trestart_dhcp(dhcp_client, 0);\n\t} else {\n\t\tdhcp_client->ack_retry_times++;\n\t\trestart_dhcp(dhcp_client, dhcp_client->ack_retry_times);\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "static int cp2112_gpio_get_all(struct gpio_chip *chip)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,\n\t\t\t\t CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_GET_REPORT);\n\tif (ret != CP2112_GPIO_GET_LENGTH) {\n\t\thid_err(hdev, \"error requesting GPIO values: %d\\n\", ret);\n\t\tret = ret < 0 ? ret : -EIO;\n\t\tgoto exit;\n\t}\n\tret = buf[1];\nexit:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}", "target": 1}
{"code": "order_notification_deltas(struct rdr_notification_ctx *ctx)\n{\n\tstruct delta_head **ptr;\n\tarray_index i;\n\tint error;\n\terror = deltas_head_set_size(ctx->notification->deltas_list,\n\t    ctx->deltas.len);\n\tif (error)\n\t\treturn error;\n\tARRAYLIST_FOREACH(&ctx->deltas, ptr, i) {\n\t\terror = deltas_head_add(ctx->notification->deltas_list,\n\t\t    ctx->notification->global_data.serial,\n\t\t    (*ptr)->serial,\n\t\t    (*ptr)->doc_data.uri,\n\t\t    (*ptr)->doc_data.hash,\n\t\t    (*ptr)->doc_data.hash_len);\n\t\tif (!error)\n\t\t\tcontinue;\n\t\tif (error == -EINVAL)\n\t\t\treturn pr_val_err(\"Serial '%lu' at delta elements isn't part of a contiguous list of serials.\",\n\t\t\t    (*ptr)->serial);\n\t\tif (error == -EEXIST)\n\t\t\treturn pr_val_err(\"Duplicated serial '%lu' at delta elements.\",\n\t\t\t    (*ptr)->serial);\n\t\treturn error;\n\t}\n\tif (!deltas_head_values_set(ctx->notification->deltas_list))\n\t\treturn pr_val_err(\"Deltas listed don't have a contiguous sequence of serial numbers\");\n\treturn 0;\n}", "target": 1}
{"code": "SendScaleSetting(rfbClient* client,int scaleSetting)\n{\n  rfbSetScaleMsg ssm;\n  ssm.scale = scaleSetting;\n  ssm.pad = 0;\n  if (SupportsClient2Server(client, rfbSetScale)) {\n      ssm.type = rfbSetScale;\n      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))\n          return FALSE;\n  }\n  if (SupportsClient2Server(client, rfbPalmVNCSetScaleFactor)) {\n      ssm.type = rfbPalmVNCSetScaleFactor;\n      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))\n          return FALSE;\n  }\n  return TRUE;\n}", "target": 0}
{"code": "static void update_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tclr_exception_intercept(svm, BP_VECTOR);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}", "target": 0}
{"code": "SHA256_Pad(struct SHA256_CTX * ctx)\n{\n  unsigned char len[8];\n  uint32_t r, plen;\n  be32enc_vect(len, ctx->count, 8);\n  r = (ctx->count[1] >> 3) & 0x3f;\n  plen = (r < 56) ? (56 - r) : (120 - r);\n  scrypt_SHA256_Update(ctx, PAD, (size_t)plen);\n  scrypt_SHA256_Update(ctx, len, 8);\n}", "target": 1}
{"code": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n\t\t}\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}", "target": 1}
{"code": "mptctl_replace_fw (unsigned long arg)\n{\n\tstruct mpt_ioctl_replace_fw __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_replace_fw\t karg;\n\tMPT_ADAPTER\t\t *ioc;\n\tint\t\t\t iocnum;\n\tint\t\t\t newFwSize;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_replace_fw))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\"Unable to read in mpt_ioctl_replace_fw struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_replace_fw() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_replace_fw called.\\n\",\n\t    ioc->name));\n\tif (ioc->cached_fw == NULL)\n\t\treturn 0;\n\tmpt_free_fw_memory(ioc);\n\tnewFwSize = ALIGN(karg.newImageSize, 4);\n\tmpt_alloc_fw_memory(ioc, newFwSize);\n\tif (ioc->cached_fw == NULL)\n\t\treturn -ENOMEM;\n\tif (copy_from_user(ioc->cached_fw, uarg->newImage, newFwSize)) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_replace_fw - \"\n\t\t\t\t\"Unable to read in mpt_ioctl_replace_fw image \"\n\t\t\t\t\"@ %p\\n\", ioc->name, __FILE__, __LINE__, uarg);\n\t\tmpt_free_fw_memory(ioc);\n\t\treturn -EFAULT;\n\t}\n\tioc->facts.FWImageSize = newFwSize;\n\treturn 0;\n}", "target": 1}
{"code": "int git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\t\treturn (int)len;\n\t}\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\tline += PKT_LEN_SIZE;\n\tif (len == PKT_LEN_SIZE) {\n\t\tgiterr_set_str(GITERR_NET, \"Invalid empty packet\");\n\t\treturn GIT_ERROR;\n\t}\n\tif (len == 0) { \n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\tlen -= PKT_LEN_SIZE; \n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\t*out = line + len;\n\treturn ret;\n}", "target": 0}
{"code": "static int handle_emulation_failure(struct kvm_vcpu *vcpu)\n{\n\tint r = EMULATE_DONE;\n\t++vcpu->stat.insn_emulation_fail;\n\ttrace_kvm_emulate_insn_failed(vcpu);\n\tif (!is_guest_mode(vcpu) && kvm_x86_ops->get_cpl(vcpu) == 0) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\tr = EMULATE_FAIL;\n\t}\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn r;\n}", "target": 0}
{"code": "static void ida_check_bad_free(struct ida *ida)\n{\n\tunsigned long i;\n\tprintk(\"vvv Ignore \\\"not allocated\\\" warnings\\n\");\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, 3, GFP_KERNEL) != 3);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, 1023, GFP_KERNEL) != 1023);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tIDA_BUG_ON(ida, ida_alloc_min(ida, (1 << 20) - 1, GFP_KERNEL) != (1 << 20) - 1);\n\tida_free(ida, 0);\n\tfor (i = 0; i < 31; i++)\n\t\tida_free(ida, 1 << i);\n\tprintk(\"^^^ \\\"not allocated\\\" warnings over\\n\");\n\tida_free(ida, 3);\n\tida_free(ida, 1023);\n\tida_free(ida, (1 << 20) - 1);\n\tIDA_BUG_ON(ida, !ida_is_empty(ida));\n}", "target": 0}
{"code": "is_anychar_star_quantifier(QtfrNode* qn)\n{\n  if (qn->greedy && IS_REPEAT_INFINITE(qn->upper) &&\n      NTYPE(qn->target) == NT_CANY)\n    return 1;\n  else\n    return 0;\n}", "target": 0}
{"code": "void init_tls_dissector(struct ndpi_detection_module_struct *ndpi_struct,\n\t\t\tu_int32_t *id, NDPI_PROTOCOL_BITMASK *detection_bitmask) {\n  ndpi_set_bitmask_protocol_detection(\"TLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_TLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_TCP_WITH_PAYLOAD_WITHOUT_RETRANSMISSION,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n  *id += 1;\n  ndpi_set_bitmask_protocol_detection(\"TLS\", ndpi_struct, detection_bitmask, *id,\n\t\t\t\t      NDPI_PROTOCOL_TLS,\n\t\t\t\t      ndpi_search_tls_wrapper,\n\t\t\t\t      NDPI_SELECTION_BITMASK_PROTOCOL_V4_V6_UDP_WITH_PAYLOAD,\n\t\t\t\t      SAVE_DETECTION_BITMASK_AS_UNKNOWN,\n\t\t\t\t      ADD_TO_DETECTION_BITMASK);\n  *id += 1;\n}", "target": 0}
{"code": "decode_definite_short_string(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *bytes_obj = fp_read_object(self, length);\n    if (!bytes_obj)\n        return NULL;\n    const char *bytes = PyBytes_AS_STRING(bytes_obj);\n    PyObject *ret = PyUnicode_FromStringAndSize(bytes, length);\n    Py_DECREF(bytes_obj);\n    if (ret && string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 0}
{"code": "void ParamTraits<ListValue>::Write(Message* m, const param_type& p) {\n  WriteValue(m, &p, 0);\n}", "target": 0}
{"code": "int nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n\tint rc = 0;\n\tu8 *gb;\n\tsize_t gb_len;\n\tstruct nfc_target *target;\n\tpr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\tif (!dev->ops->dep_link_up)\n\t\treturn -EOPNOTSUPP;\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->dep_link_up == true) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tgb = nfc_llcp_general_bytes(dev, &gb_len);\n\tif (gb_len > NFC_MAX_GT_LEN) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\ttarget = nfc_find_target(dev, target_index);\n\tif (target == NULL) {\n\t\trc = -ENOTCONN;\n\t\tgoto error;\n\t}\n\trc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n\tif (!rc) {\n\t\tdev->active_target = target;\n\t\tdev->rf_mode = NFC_RF_INITIATOR;\n\t}\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "void test_readlink(const char *path)\n{\n\tchar *dest = alloca(2 * strlen(path));\n\tif (readlink(path, dest, 2 * strlen(path)) >= 0) {\n\t\tfprintf(stderr, \"leak at readlink of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at readlink of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == '%')\n                ptr++;\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n            else {\n                if (*ptr == ' ')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 3);\n}", "target": 1}
{"code": "void NotificationService::AddObserver(NotificationObserver* observer,\n                                      NotificationType type,\n                                      const NotificationSource& source) {\n  DCHECK(type.value < NotificationType::NOTIFICATION_TYPE_COUNT);\n  CHECK(observer);\n  NotificationObserverList* observer_list;\n  if (HasKey(observers_[type.value], source)) {\n    observer_list = observers_[type.value][source.map_key()];\n  } else {\n    observer_list = new NotificationObserverList;\n    observers_[type.value][source.map_key()] = observer_list;\n  }\n  observer_list->AddObserver(observer);\n#ifndef NDEBUG\n  ++observer_counts_[type.value];\n#endif\n}", "target": 0}
{"code": "R_API char *r_socket_http_post (const char *url, const char *data, int *code, int *rlen) {\n\tRSocket *s;\n\tbool ssl = r_str_startswith (url, \"https:\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\tchar *host = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\tprintf (\"Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tchar *port = strchr (host, ':');\n\tif (!port) {\n\t\tport = (ssl)? \"443\": \"80\";\n\t} else {\n\t\t*port++ = 0;\n\t}\n\tchar *path = strchr (host, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\tprintf (\"Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (!r_socket_connect_tcp (s, host, port, 0)) {\n\t\teprintf (\"Cannot connect to %s:%s\\n\", host, port);\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tr_socket_printf (s,\n\t\t\t\"POST /%s HTTP/1.0\\r\\n\"\n\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\"Accept: *", "target": 1}
{"code": "sixel_allocator_realloc(\n    sixel_allocator_t    *allocator,  \n    void                 *p,          \n    size_t               n)           \n{\n    assert(allocator);\n    assert(allocator->fn_realloc);\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n    return allocator->fn_realloc(p, n);\n}", "target": 0}
{"code": "clamp_lab(const fz_colorspace *cs, const float *src, float *dst)\n{\n\tint i;\n\tfor (i = 0; i < 3; i++)\n\t\tdst[i] = fz_clamp(src[i], i ? -128 : 0, i ? 127 : 100);\n}", "target": 0}
{"code": "ev_archive_get_archive_type (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), EV_ARCHIVE_TYPE_NONE);\n\treturn archive->type;\n}", "target": 0}
{"code": "int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt)\n{\n\tint n;\n\tconst char *bufptr;\n\tif (cnt < 0) {\n\t\tjas_deprecated(\"negative count for jas_stream_write\");\n\t}\n\tbufptr = buf;\n\tn = 0;\n\twhile (n < cnt) {\n\t\tif (jas_stream_putc(stream, *bufptr) == EOF) {\n\t\t\treturn n;\n\t\t}\n\t\t++bufptr;\n\t\t++n;\n\t}\n\treturn n;\n}", "target": 0}
{"code": "static int hi3660_stub_clk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tunsigned int i;\n\tint ret;\n\tstub_clk_chan.cl.dev = dev;\n\tstub_clk_chan.cl.tx_done = NULL;\n\tstub_clk_chan.cl.tx_block = false;\n\tstub_clk_chan.cl.knows_txdone = false;\n\tstub_clk_chan.mbox = mbox_request_channel(&stub_clk_chan.cl, 0);\n\tif (IS_ERR(stub_clk_chan.mbox))\n\t\treturn PTR_ERR(stub_clk_chan.mbox);\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tfreq_reg = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!freq_reg)\n\t\treturn -ENOMEM;\n\tfreq_reg += HI3660_STUB_CLOCK_DATA;\n\tfor (i = 0; i < HI3660_CLK_STUB_NUM; i++) {\n\t\tret = devm_clk_hw_register(&pdev->dev, &hi3660_stub_clks[i].hw);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn devm_of_clk_add_hw_provider(&pdev->dev, hi3660_stub_clk_hw_get,\n\t\t\t\t\t   hi3660_stub_clks);\n}", "target": 0}
{"code": "static bool couldRecur(const Variant& v, const ArrayData* arr) {\n  return v.isReferenced() ||\n    arr->kind() == ArrayData::kGlobalsKind ||\n    arr->kind() == ArrayData::kProxyKind;\n}", "target": 0}
{"code": "static int udf_symlink_filler(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct buffer_head *bh = NULL;\n\tunsigned char *symlink;\n\tint err;\n\tunsigned char *p = kmap(page);\n\tstruct udf_inode_info *iinfo;\n\tuint32_t pos;\n\tif (inode->i_size > inode->i_sb->s_blocksize) {\n\t\terr = -ENAMETOOLONG;\n\t\tgoto out_unmap;\n\t}\n\tiinfo = UDF_I(inode);\n\tpos = udf_block_map(inode, 0);\n\tdown_read(&iinfo->i_data_sem);\n\tif (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {\n\t\tsymlink = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n\t} else {\n\t\tbh = sb_bread(inode->i_sb, pos);\n\t\tif (!bh) {\n\t\t\terr = -EIO;\n\t\t\tgoto out_unlock_inode;\n\t\t}\n\t\tsymlink = bh->b_data;\n\t}\n\terr = udf_pc_to_char(inode->i_sb, symlink, inode->i_size, p, PAGE_SIZE);\n\tbrelse(bh);\n\tif (err)\n\t\tgoto out_unlock_inode;\n\tup_read(&iinfo->i_data_sem);\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\nout_unlock_inode:\n\tup_read(&iinfo->i_data_sem);\n\tSetPageError(page);\nout_unmap:\n\tkunmap(page);\n\tunlock_page(page);\n\treturn err;\n}", "target": 0}
{"code": "ut32 armass_assemble(const char *str, ut64 off, int thumb) {\n\tint i, j;\n\tchar buf[128];\n\tArmOpcode aop = {.off = off};\n\tfor (i = j = 0; i < sizeof (buf) - 1 && str[i]; i++, j++) {\n\t\tif (str[j] == '#') {\n\t\t\ti--; continue;\n\t\t}\n\t\tbuf[i] = tolower ((const ut8)str[j]);\n\t}\n\tbuf[i] = 0;\n\tarm_opcode_parse (&aop, buf);\n\taop.off = off;\n\tif (thumb < 0 || thumb > 1) {\n\t\treturn -1;\n\t}\n\tif (!assemble[thumb] (&aop, off, buf)) {\n\t\treturn -1;\n\t}\n\treturn aop.o;\n}", "target": 1}
{"code": "bool may_move_pid(pid_t r, uid_t r_uid, pid_t v)\n{\n\tuid_t v_uid, tmpuid;\n\tgid_t v_gid;\n\tif (r == v)\n\t\treturn true;\n\tif (r_uid == 0)\n\t\treturn true;\n\tget_pid_creds(v, &v_uid, &v_gid);\n\tif (r_uid == v_uid)\n\t\treturn true;\n\tif (hostuid_to_ns(r_uid, r, &tmpuid) && tmpuid == 0\n\t\t\t&& hostuid_to_ns(v_uid, r, &tmpuid))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            return;\n        }\n        Jsi_DSAppendLen(dStr, zBlob, bytes);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_DSAppend(dStr, str?str:\"\", NULL);\n}", "target": 1}
{"code": "static void write_palette(int idx, uint32_t color, void *opaque)\n{\n    struct palette_cb_priv *priv = opaque;\n    VncState *vs = priv->vs;\n    uint32_t bytes = vs->client_pf.bytes_per_pixel;\n    if (bytes == 4) {\n        ((uint32_t*)priv->header)[idx] = color;\n    } else {\n        ((uint16_t*)priv->header)[idx] = color;\n    }\n}", "target": 0}
{"code": "path_poly(PG_FUNCTION_ARGS)\n{\n\tPATH\t   *path = PG_GETARG_PATH_P(0);\n\tPOLYGON    *poly;\n\tint\t\t\tsize;\n\tint\t\t\ti;\n\tif (!path->closed)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_PARAMETER_VALUE),\n\t\t\t\t errmsg(\"open path cannot be converted to polygon\")));\n\tsize = offsetof(POLYGON, p[0]) +sizeof(poly->p[0]) * path->npts;\n\tpoly = (POLYGON *) palloc(size);\n\tSET_VARSIZE(poly, size);\n\tpoly->npts = path->npts;\n\tfor (i = 0; i < path->npts; i++)\n\t{\n\t\tpoly->p[i].x = path->p[i].x;\n\t\tpoly->p[i].y = path->p[i].y;\n\t}\n\tmake_bound_box(poly);\n\tPG_RETURN_POLYGON_P(poly);\n}", "target": 0}
{"code": "R_API RSocket *r_socket_accept_timeout(RSocket *s, unsigned int timeout) {\n\tfd_set read_fds;\n\tfd_set except_fds;\n\tFD_ZERO (&read_fds);\n\tFD_SET (s->fd, &read_fds);\n\tFD_ZERO (&except_fds);\n\tFD_SET (s->fd, &except_fds);\n\tstruct timeval t;\n\tt.tv_sec = timeout;\n\tt.tv_usec = 0;\n\tint r = select (s->fd + 1, &read_fds, NULL, &except_fds, &t);\n\tif(r < 0) {\n\t\tperror (\"select\");\n\t} else if (r > 0 && FD_ISSET (s->fd, &read_fds)) {\n\t\treturn r_socket_accept (s);\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      struct mcryptd_queue *queue)\n{\n\tstruct hashd_instance_ctx *ctx;\n\tstruct ahash_instance *inst;\n\tstruct hash_alg_common *halg;\n\tstruct crypto_alg *alg;\n\tu32 type = 0;\n\tu32 mask = 0;\n\tint err;\n\tmcryptd_check_internal(tb, &type, &mask);\n\thalg = ahash_attr_alg(tb[1], type, mask);\n\tif (IS_ERR(halg))\n\t\treturn PTR_ERR(halg);\n\talg = &halg->base;\n\tpr_debug(\"crypto: mcryptd hash alg: %s\\n\", alg->cra_name);\n\tinst = mcryptd_alloc_instance(alg, ahash_instance_headroom(),\n\t\t\t\t\tsizeof(*ctx));\n\terr = PTR_ERR(inst);\n\tif (IS_ERR(inst))\n\t\tgoto out_put_alg;\n\tctx = ahash_instance_ctx(inst);\n\tctx->queue = queue;\n\terr = crypto_init_ahash_spawn(&ctx->spawn, halg,\n\t\t\t\t      ahash_crypto_instance(inst));\n\tif (err)\n\t\tgoto out_free_inst;\n\ttype = CRYPTO_ALG_ASYNC;\n\tif (alg->cra_flags & CRYPTO_ALG_INTERNAL)\n\t\ttype |= CRYPTO_ALG_INTERNAL;\n\tinst->alg.halg.base.cra_flags = type;\n\tinst->alg.halg.digestsize = halg->digestsize;\n\tinst->alg.halg.statesize = halg->statesize;\n\tinst->alg.halg.base.cra_ctxsize = sizeof(struct mcryptd_hash_ctx);\n\tinst->alg.halg.base.cra_init = mcryptd_hash_init_tfm;\n\tinst->alg.halg.base.cra_exit = mcryptd_hash_exit_tfm;\n\tinst->alg.init   = mcryptd_hash_init_enqueue;\n\tinst->alg.update = mcryptd_hash_update_enqueue;\n\tinst->alg.final  = mcryptd_hash_final_enqueue;\n\tinst->alg.finup  = mcryptd_hash_finup_enqueue;\n\tinst->alg.export = mcryptd_hash_export;\n\tinst->alg.import = mcryptd_hash_import;\n\tinst->alg.setkey = mcryptd_hash_setkey;\n\tinst->alg.digest = mcryptd_hash_digest_enqueue;\n\terr = ahash_register_instance(tmpl, inst);\n\tif (err) {\n\t\tcrypto_drop_ahash(&ctx->spawn);\nout_free_inst:\n\t\tkfree(inst);\n\t}\nout_put_alg:\n\tcrypto_mod_put(alg);\n\treturn err;\n}", "target": 1}
{"code": "static int config_req_handler(void *arg)\n{\n\tprintf(\"requesing config\\n\");\n\treturn rest_request(NULL, engine_get_restcli(engine), 0,\n\t\t\t    \"GET\", cfg_resp_handler, NULL,\n\t\t\t    \"/calls/config/v2\", NULL);\n}", "target": 0}
{"code": "static int getid(char ch) {\n\tconst char *keys = \"[]<>+-,.\";\n\tconst char *cidx = strchr (keys, ch);\n\treturn cidx? cidx - keys + 1: 0;\n}", "target": 1}
{"code": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}", "target": 1}
{"code": "static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){\n    long i;\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n        long a = *(long*)(src+i);\n        long b = *(long*)(dst+i);\n        *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);\n    }\n    for(; i<w; i++)\n        dst[i+0] += src[i+0];\n}", "target": 1}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 4>::ConstTensor input,\n                  typename TTypes<T, 3>::ConstTensor filter,\n                  typename TTypes<T, 4>::ConstTensor out_backprop,\n                  int stride_rows, int stride_cols, int rate_rows,\n                  int rate_cols, int pad_top, int pad_left,\n                  typename TTypes<T, 4>::Tensor in_backprop) {\n    const int batch = input.dimension(0);\n    const int input_rows = input.dimension(1);\n    const int input_cols = input.dimension(2);\n    const int depth = input.dimension(3);\n    const int filter_rows = filter.dimension(0);\n    const int filter_cols = filter.dimension(1);\n    const int output_rows = out_backprop.dimension(1);\n    const int output_cols = out_backprop.dimension(2);\n    in_backprop.setZero();\n    for (int b = 0; b < batch; ++b) {\n      for (int h_out = 0; h_out < output_rows; ++h_out) {\n        int h_beg = h_out * stride_rows - pad_top;\n        for (int w_out = 0; w_out < output_cols; ++w_out) {\n          int w_beg = w_out * stride_cols - pad_left;\n          for (int d = 0; d < depth; ++d) {\n            T cur_val = Eigen::NumTraits<T>::lowest();\n            int h_in_max = (h_beg < 0) ? 0 : h_beg;\n            int w_in_max = (w_beg < 0) ? 0 : w_beg;\n            for (int h = 0; h < filter_rows; ++h) {\n              const int h_in = h_beg + h * rate_rows;\n              if (h_in >= 0 && h_in < input_rows) {\n                for (int w = 0; w < filter_cols; ++w) {\n                  const int w_in = w_beg + w * rate_cols;\n                  if (w_in >= 0 && w_in < input_cols) {\n                    const T val = input(b, h_in, w_in, d) + filter(h, w, d);\n                    if (val > cur_val) {\n                      cur_val = val;\n                      h_in_max = h_in;\n                      w_in_max = w_in;\n                    }\n                  }\n                }\n              }\n            }\n            in_backprop(b, h_in_max, w_in_max, d) +=\n                out_backprop(b, h_out, w_out, d);\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "static void ext_session_lock_v1_handle_finished(void *data, struct ext_session_lock_v1 *lock) {\n\tswaylock_log(LOG_ERROR, \"Failed to lock session -- \"\n\t\t\t\"is another lockscreen running?\");\n\texit(2);\n}", "target": 0}
{"code": "void pickHyprPicker(sdbus::MethodCall& call) {\n    const std::string HYPRPICKER_CMD = \"hyprpicker --format=rgb --no-fancy\";\n    std::string       rgbColor       = execAndGet(HYPRPICKER_CMD.c_str());\n    if (rgbColor.size() > 12) {\n        Debug::log(ERR, \"hyprpicker returned strange output: \" + rgbColor);\n        sendEmptyDbusMethodReply(call, 1);\n        return;\n    }\n    std::array<uint8_t, 3> colors{0, 0, 0};\n    try {\n        for (uint8_t i = 0; i < 2; i++) {\n            uint64_t next = rgbColor.find(' ');\n            if (next == std::string::npos) {\n                Debug::log(ERR, \"hyprpicker returned strange output: \" + rgbColor);\n                sendEmptyDbusMethodReply(call, 1);\n                return;\n            }\n            colors[i] = std::stoi(rgbColor.substr(0, next));\n            rgbColor  = rgbColor.substr(next + 1, rgbColor.size() - next);\n        }\n        colors[2] = std::stoi(rgbColor);\n    } catch (...) {\n        Debug::log(ERR, \"Reading RGB values from hyprpicker failed. This is likely a string to integer error.\");\n        sendEmptyDbusMethodReply(call, 1);\n    }\n    auto [r, g, b] = colors;\n    std::unordered_map<std::string, sdbus::Variant> results;\n    results[\"color\"] = sdbus::Struct(std::tuple{r / 255.0, g / 255.0, b / 255.0});\n    auto reply = call.createReply();\n    reply << (uint32_t)0;\n    reply << results;\n    reply.send();\n}", "target": 1}
{"code": "inline int NumOutputs(const TfLiteNode* node) { return node->outputs->size; }", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(4, context->num_inputs());\n    const Tensor& gradient = context->input(0);\n    const Tensor& input = context->input(1);\n    OP_REQUIRES(context, input.IsSameSize(gradient),\n                InvalidArgument(\"gradient and input must be the same size\"));\n    const int depth = input.dim_size(input.dims() - 1);  \n    const Tensor& min = context->input(2);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(min.shape()),\n        InvalidArgument(\"`min` must be rank 1 but is rank \", min.dims()));\n    OP_REQUIRES(context, min.dim_size(0) == depth,\n                InvalidArgument(\"min has incorrect size, expected \", depth,\n                                \" was \", min.dim_size(0)));\n    const Tensor& max = context->input(3);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(max.shape()),\n        InvalidArgument(\"`max` must be rank 1 but is rank \", max.dims()));\n    OP_REQUIRES(context, max.dim_size(0) == depth,\n                InvalidArgument(\"max has incorrect size, expected \", depth,\n                                \" was \", max.dim_size(0)));\n    Tensor* grad_wrt_input;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &grad_wrt_input));\n    TensorShape min_max_shape({input.dim_size(input.dims() - 1)});\n    Tensor* grad_wrt_min;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, min_max_shape, &grad_wrt_min));\n    Tensor* grad_wrt_max;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, min_max_shape, &grad_wrt_max));\n    FakeQuantWithMinMaxVarsPerChannelGradientFunctor<Device> functor;\n    functor(\n        context->eigen_device<Device>(), gradient.flat_inner_dims<float, 2>(),\n        input.flat_inner_dims<float, 2>(), min.vec<float>(), max.vec<float>(),\n        quant_min_, quant_max_, grad_wrt_input->flat_inner_dims<float, 2>(),\n        grad_wrt_min->vec<float>(), grad_wrt_max->vec<float>());\n  }", "target": 0}
{"code": "void fiin_box_del(GF_Box *s)\n{\n\tFDItemInformationBox *ptr = (FDItemInformationBox *)s;\n\tif (ptr == NULL) return;\n\tif (ptr->partition_entries) gf_list_del(ptr->partition_entries);\n\tgf_free(ptr);\n}", "target": 0}
{"code": "struct l2tp_packet_t *l2tp_packet_alloc(int ver, int msg_type,\n\t\t\t\t\tconst struct sockaddr_in *addr, int H,\n\t\t\t\t\tconst char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack = mempool_alloc(pack_pool);\n\tif (!pack)\n\t\treturn NULL;\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\tpack->hdr.ver = ver;\n\tpack->hdr.T = 1;\n\tpack->hdr.L = 1;\n\tpack->hdr.S = 1;\n\tmemcpy(&pack->addr, addr, sizeof(*addr));\n\tpack->hide_avps = H;\n\tpack->secret = secret;\n\tpack->secret_len = secret_len;\n\tif (msg_type) {\n\t\tif (l2tp_packet_add_int16(pack, Message_Type, msg_type, 1)) {\n\t\t\tmempool_free(pack);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn pack;\n}", "target": 1}
{"code": "nfs4_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct nfs_open_context *ctx;\n\tstruct dentry *dentry = file_dentry(filp);\n\tstruct dentry *parent = NULL;\n\tstruct inode *dir;\n\tunsigned openflags = filp->f_flags;\n\tstruct iattr attr;\n\tint err;\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\topenflags &= ~(O_CREAT|O_EXCL);\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))\n\t\tgoto out;\n\tattr.ia_valid = ATTR_OPEN;\n\tif (openflags & O_TRUNC) {\n\t\tattr.ia_valid |= ATTR_SIZE;\n\t\tattr.ia_size = 0;\n\t\tfilemap_write_and_wait(inode->i_mapping);\n\t}\n\tinode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tswitch (err) {\n\t\tdefault:\n\t\t\tgoto out_put_ctx;\n\t\tcase -ENOENT:\n\t\tcase -ESTALE:\n\t\tcase -EISDIR:\n\t\tcase -ENOTDIR:\n\t\tcase -ELOOP:\n\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (inode != d_inode(dentry))\n\t\tgoto out_drop;\n\tnfs_file_set_open_context(filp, ctx);\n\tnfs_fscache_open_file(inode, filp);\n\terr = 0;\nout_put_ctx:\n\tput_nfs_open_context(ctx);\nout:\n\tdput(parent);\n\treturn err;\nout_drop:\n\td_drop(dentry);\n\terr = -EOPENSTALE;\n\tgoto out_put_ctx;\n}", "target": 1}
{"code": "int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)\n{\n    char *str;\n    ASN1_TIME atm;\n    long offset;\n    char buff1[24], buff2[24], *p;\n    int i, j;\n    p = buff1;\n    i = ctm->length;\n    str = (char *)ctm->data;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        if ((i < 11) || (i > 17))\n            return 0;\n        memcpy(p, str, 10);\n        p += 10;\n        str += 10;\n    } else {\n        if (i < 13)\n            return 0;\n        memcpy(p, str, 12);\n        p += 12;\n        str += 12;\n    }\n    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {\n        *(p++) = '0';\n        *(p++) = '0';\n    } else {\n        *(p++) = *(str++);\n        *(p++) = *(str++);\n        if (*str == '.') {\n            str++;\n            while ((*str >= '0') && (*str <= '9'))\n                str++;\n        }\n    }\n    *(p++) = 'Z';\n    *(p++) = '\\0';\n    if (*str == 'Z')\n        offset = 0;\n    else {\n        if ((*str != '+') && (*str != '-'))\n            return 0;\n        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;\n        offset += (str[3] - '0') * 10 + (str[4] - '0');\n        if (*str == '-')\n            offset = -offset;\n    }\n    atm.type = ctm->type;\n    atm.flags = 0;\n    atm.length = sizeof(buff2);\n    atm.data = (unsigned char *)buff2;\n    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)\n        return 0;\n    if (ctm->type == V_ASN1_UTCTIME) {\n        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');\n        if (i < 50)\n            i += 100;           \n        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');\n        if (j < 50)\n            j += 100;\n        if (i < j)\n            return -1;\n        if (i > j)\n            return 1;\n    }\n    i = strcmp(buff1, buff2);\n    if (i == 0)                 \n        return -1;\n    else\n        return i;\n}", "target": 1}
{"code": "static inline u64 get_canonical(u64 la)\n{\n\treturn ((int64_t)la << 16) >> 16;\n}", "target": 0}
{"code": "OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)\n{\n        static const char module[]=\"OJPEGDecode\";\n\tOJPEGState* sp=(OJPEGState*)tif->tif_data;\n\t(void)s;\n        if( !sp->decoder_ok )\n        {\n            TIFFErrorExt(tif->tif_clientdata,module,\"Cannot decode: decoder not correctly initialized\");\n            return 0;\n        }\n\tif (sp->libjpeg_jpeg_query_style==0)\n\t{\n\t\tif (OJPEGDecodeRaw(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\telse\n\t{\n\t\tif (OJPEGDecodeScanlines(tif,buf,cc)==0)\n\t\t\treturn(0);\n\t}\n\treturn(1);\n}", "target": 0}
{"code": "Status SubstituteForEach(AttrMap& attrs, FullTypeDef& t) {\n  DCHECK_EQ(t.args_size(), 3);\n  const auto& cont = t.args(0);\n  const auto& tmpl = t.args(1);\n  const auto& t_var = t.args(2);\n  StringPiece var_name = t_var.s();\n  if (!attrs.contains(var_name)) {\n    return Status(\n        error::INVALID_ARGUMENT,\n        absl::StrCat(\"could not find an attribute for key '\", var_name, \"'\"));\n  }\n  const AttrValue* attr = attrs.at(var_name);\n  FullTypeDef result;\n  result.set_type_id(cont.type_id());\n  const auto attr_type = attr->value_case();\n  if (attr_type == AttrValue::kType) {\n    FullTypeDef* target = result.add_args();\n    *target = tmpl;\n    TF_RETURN_WITH_CONTEXT_IF_ERROR(\n        SubstituteFromAttrs(attrs, *target), \"while substituting '\", var_name,\n        \"' from\\n\", attr->DebugString(), \"\\ninto \", target->DebugString());\n  } else if (attr_type == AttrValue::kList) {\n    const auto& attr_list = attr->list();\n    int tsize = attr_list.type_size();\n    if (tsize == 0) {\n      return Status(error::UNIMPLEMENTED,\n                    absl::StrCat(\"unsupported list attribute type\\n\",\n                                 attr_list.DebugString(), \"\\nkey=\", var_name));\n    }\n    AttrValue replacement;\n    attrs[var_name] = &replacement;\n    for (int i = 0; i < tsize; i++) {\n      replacement.set_type(attr_list.type(i));\n      FullTypeDef* target = result.add_args();\n      *target = tmpl;\n      TF_RETURN_WITH_CONTEXT_IF_ERROR(SubstituteFromAttrs(attrs, *target),\n                                      \"while substituting '\", var_name,\n                                      \"' from\\n\", attr->DebugString(), \"\\n[\", i,\n                                      \"] into\\n\", target->DebugString());\n    }\n    attrs[var_name] = attr;\n  } else {\n    return Status(error::UNIMPLEMENTED,\n                  absl::StrCat(\"unsupported attribute type\\n\",\n                               attr->DebugString(), \"\\nfor name \", var_name));\n  }\n  t = result;\n  return OkStatus();\n}", "target": 1}
{"code": "TIFFReadEncodedStrip(TIFF* tif, uint32 strip, void* buf, tmsize_t size)\n{\n\tstatic const char module[] = \"TIFFReadEncodedStrip\";\n\tTIFFDirectory *td = &tif->tif_dir;\n\tuint32 rowsperstrip;\n\tuint32 stripsperplane;\n\tuint32 stripinplane;\n\tuint16 plane;\n\tuint32 rows;\n\ttmsize_t stripsize;\n\tif (!TIFFCheckRead(tif,0))\n\t\treturn((tmsize_t)(-1));\n\tif (strip>=td->td_nstrips)\n\t{\n\t\tTIFFErrorExt(tif->tif_clientdata,module,\n\t\t    \"%lu: Strip out of range, max %lu\",(unsigned long)strip,\n\t\t    (unsigned long)td->td_nstrips);\n\t\treturn((tmsize_t)(-1));\n\t}\n\trowsperstrip=td->td_rowsperstrip;\n\tif (rowsperstrip>td->td_imagelength)\n\t\trowsperstrip=td->td_imagelength;\n\tstripsperplane=((td->td_imagelength+rowsperstrip-1)/rowsperstrip);\n\tstripinplane=(strip%stripsperplane);\n\tplane=(uint16)(strip/stripsperplane);\n\trows=td->td_imagelength-stripinplane*rowsperstrip;\n\tif (rows>rowsperstrip)\n\t\trows=rowsperstrip;\n\tstripsize=TIFFVStripSize(tif,rows);\n\tif (stripsize==0)\n\t\treturn((tmsize_t)(-1));\n    if( td->td_compression == COMPRESSION_NONE &&\n        size!=(tmsize_t)(-1) && size >= stripsize &&\n        !isMapped(tif) &&\n        ((tif->tif_flags&TIFF_NOREADRAW)==0) )\n    {\n        if (TIFFReadRawStrip1(tif, strip, buf, stripsize, module) != stripsize)\n            return ((tmsize_t)(-1));\n        if (!isFillOrder(tif, td->td_fillorder) &&\n            (tif->tif_flags & TIFF_NOBITREV) == 0)\n            TIFFReverseBits(buf,stripsize);\n        (*tif->tif_postdecode)(tif,buf,stripsize);\n        return (stripsize);\n    }\n\tif ((size!=(tmsize_t)(-1))&&(size<stripsize))\n\t\tstripsize=size;\n\tif (!TIFFFillStrip(tif,strip))\n\t\treturn((tmsize_t)(-1));\n\tif ((*tif->tif_decodestrip)(tif,buf,stripsize,plane)<=0)\n\t\treturn((tmsize_t)(-1));\n\t(*tif->tif_postdecode)(tif,buf,stripsize);\n\treturn(stripsize);\n}", "target": 1}
{"code": "ssl3_free(SSL *s)\n{\n\tif (s == NULL)\n\t\treturn;\n\ttls1_cleanup_key_block(s);\n\tssl3_release_read_buffer(s);\n\tssl3_release_write_buffer(s);\n\ttls_content_free(s->s3->rcontent);\n\ttls_buffer_free(s->s3->alert_fragment);\n\ttls_buffer_free(s->s3->handshake_fragment);\n\tfreezero(s->s3->hs.sigalgs, s->s3->hs.sigalgs_len);\n\tsk_X509_pop_free(s->s3->hs.peer_certs, X509_free);\n\tsk_X509_pop_free(s->s3->hs.peer_certs_no_leaf, X509_free);\n\ttls_key_share_free(s->s3->hs.key_share);\n\ttls13_secrets_destroy(s->s3->hs.tls13.secrets);\n\tfreezero(s->s3->hs.tls13.cookie, s->s3->hs.tls13.cookie_len);\n\ttls13_clienthello_hash_clear(&s->s3->hs.tls13);\n\ttls_buffer_free(s->s3->hs.tls13.quic_read_buffer);\n\tsk_X509_NAME_pop_free(s->s3->hs.tls12.ca_names, X509_NAME_free);\n\tsk_X509_pop_free(s->verified_chain, X509_free);\n\ts->verified_chain = NULL;\n\ttls1_transcript_free(s);\n\ttls1_transcript_hash_free(s);\n\tfree(s->s3->alpn_selected);\n\tfreezero(s->s3->peer_quic_transport_params,\n\t    s->s3->peer_quic_transport_params_len);\n\tfreezero(s->s3, sizeof(*s->s3));\n\ts->s3 = NULL;\n}", "target": 0}
{"code": "static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_cipher rcipher;\n\tstrlcpy(rcipher.type, \"cipher\", sizeof(rcipher.type));\n\trcipher.blocksize = alg->cra_blocksize;\n\trcipher.min_keysize = alg->cra_cipher.cia_min_keysize;\n\trcipher.max_keysize = alg->cra_cipher.cia_max_keysize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,\n\t\t    sizeof(struct crypto_report_cipher), &rcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "_dbus_get_monotonic_time (long *tv_sec,\n                          long *tv_usec)\n{\n#ifdef HAVE_MONOTONIC_CLOCK\n  struct timespec ts;\n  clock_gettime (CLOCK_MONOTONIC, &ts);\n  if (tv_sec)\n    *tv_sec = ts.tv_sec;\n  if (tv_usec)\n    *tv_usec = ts.tv_nsec / 1000;\n#else\n  struct timeval t;\n  gettimeofday (&t, NULL);\n  if (tv_sec)\n    *tv_sec = t.tv_sec;\n  if (tv_usec)\n    *tv_usec = t.tv_usec;\n#endif\n}", "target": 0}
{"code": "static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_kpp rkpp;\n\tstrlcpy(rkpp.type, \"kpp\", sizeof(rkpp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_KPP,\n\t\t    sizeof(struct crypto_report_kpp), &rkpp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "String UnbufferedAsioTlsStream::GetVerifyError() const\n{\n\treturn m_VerifyError;\n}", "target": 1}
{"code": "STACK_OF(PKCS12_SAFEBAG) *PKCS12_unpack_p7data(PKCS7 *p7)\n{\n    if (!PKCS7_type_is_data(p7)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p7->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    return ASN1_item_unpack_ex(p7->d.data, ASN1_ITEM_rptr(PKCS12_SAFEBAGS),\n                               ossl_pkcs7_ctx_get0_libctx(&p7->ctx),\n                               ossl_pkcs7_ctx_get0_propq(&p7->ctx));\n}", "target": 0}
{"code": "void bn_mul_comba4(BN_ULONG *r, BN_ULONG *a, BN_ULONG *b)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tmul_add_c(a[0],b[0],c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tmul_add_c(a[0],b[1],c2,c3,c1);\n\tmul_add_c(a[1],b[0],c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[0],c3,c1,c2);\n\tmul_add_c(a[1],b[1],c3,c1,c2);\n\tmul_add_c(a[0],b[2],c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tmul_add_c(a[0],b[3],c1,c2,c3);\n\tmul_add_c(a[1],b[2],c1,c2,c3);\n\tmul_add_c(a[2],b[1],c1,c2,c3);\n\tmul_add_c(a[3],b[0],c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tmul_add_c(a[3],b[1],c2,c3,c1);\n\tmul_add_c(a[2],b[2],c2,c3,c1);\n\tmul_add_c(a[1],b[3],c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tmul_add_c(a[2],b[3],c3,c1,c2);\n\tmul_add_c(a[3],b[2],c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tmul_add_c(a[3],b[3],c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,\n\t\t\t      int nsops)\n{\n\tint locknum;\n again:\n\tif (nsops == 1 && !sma->complex_count) {\n\t\tstruct sem *sem = sma->sem_base + sops->sem_num;\n\t\tspin_lock(&sem->lock);\n\t\tif (unlikely(sma->complex_count)) {\n\t\t\tspin_unlock(&sem->lock);\n\t\t\tgoto lock_array;\n\t\t}\n\t\tif (unlikely(spin_is_locked(&sma->sem_perm.lock))) {\n\t\t\tspin_unlock(&sem->lock);\n\t\t\tspin_unlock_wait(&sma->sem_perm.lock);\n\t\t\tgoto again;\n\t\t}\n\t\tlocknum = sops->sem_num;\n\t} else {\n\t\tint i;\n lock_array:\n\t\tspin_lock(&sma->sem_perm.lock);\n\t\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\t\tstruct sem *sem = sma->sem_base + i;\n\t\t\tspin_unlock_wait(&sem->lock);\n\t\t}\n\t\tlocknum = -1;\n\t}\n\treturn locknum;\n}", "target": 0}
{"code": "MagickExport int LocaleUppercase(const int c)\n{\n  if (c == EOF)\n    return(c);\n#if defined(MAGICKCORE_LOCALE_SUPPORT)\n  if (c_locale != (locale_t) NULL)\n    return(toupper_l((int) ((unsigned char) c),c_locale));\n#endif\n  return(toupper((int) ((unsigned char) c)));\n}", "target": 0}
{"code": "void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;\n}", "target": 1}
{"code": "mrb_obj_clone(mrb_state *mrb, mrb_value self)\n{\n  struct RObject *p;\n  mrb_value clone;\n  if (mrb_immediate_p(self)) {\n    mrb_raisef(mrb, E_TYPE_ERROR, \"can't clone %S\", self);\n  }\n  if (mrb_type(self) == MRB_TT_SCLASS) {\n    mrb_raise(mrb, E_TYPE_ERROR, \"can't clone singleton class\");\n  }\n  p = (struct RObject*)mrb_obj_alloc(mrb, mrb_type(self), mrb_obj_class(mrb, self));\n  p->c = mrb_singleton_class_clone(mrb, self);\n  mrb_field_write_barrier(mrb, (struct RBasic*)p, (struct RBasic*)p->c);\n  clone = mrb_obj_value(p);\n  init_copy(mrb, clone, self);\n  p->flags = mrb_obj_ptr(self)->flags;\n  return clone;\n}", "target": 1}
{"code": "static Quantum *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n  const int\n    id = GetOpenMPThreadId();\n  Quantum\n    *magick_restrict pixels;\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return((Quantum *) NULL);\n  assert(cache_info->signature == MagickCoreSignature);\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception);\n  return(pixels);\n}", "target": 0}
{"code": "void securityWarningCommand(client *c) {\n    static time_t logged_time;\n    time_t now = time(NULL);\n    if (labs(now-logged_time) > 60) {\n        serverLog(LL_WARNING,\"Possible SECURITY ATTACK detected. It looks like somebody is sending POST or Host: commands to Redis. This is likely due to an attacker attempting to use Cross Protocol Scripting to compromise your Redis instance. Connection aborted.\");\n        logged_time = now;\n    }\n    freeClientAsync(c);\n}", "target": 0}
{"code": "sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)\n{\n\tSg_request *srp;\n\tint val;\n\tunsigned int ms;\n\tval = 0;\n\tlist_for_each_entry(srp, &sfp->rq_list, entry) {\n\t\tif (val > SG_MAX_QUEUE)\n\t\t\tbreak;\n\t\tmemset(&rinfo[val], 0, SZ_SG_REQ_INFO);\n\t\trinfo[val].req_state = srp->done + 1;\n\t\trinfo[val].problem =\n\t\t\tsrp->header.masked_status &\n\t\t\tsrp->header.host_status &\n\t\t\tsrp->header.driver_status;\n\t\tif (srp->done)\n\t\t\trinfo[val].duration =\n\t\t\t\tsrp->header.duration;\n\t\telse {\n\t\t\tms = jiffies_to_msecs(jiffies);\n\t\t\trinfo[val].duration =\n\t\t\t\t(ms > srp->header.duration) ?\n\t\t\t\t(ms - srp->header.duration) : 0;\n\t\t}\n\t\trinfo[val].orphan = srp->orphan;\n\t\trinfo[val].sg_io_owned = srp->sg_io_owned;\n\t\trinfo[val].pack_id = srp->header.pack_id;\n\t\trinfo[val].usr_ptr = srp->header.usr_ptr;\n\t\tval++;\n\t}\n}", "target": 1}
{"code": "is_note (Elf_Internal_Phdr *p, asection *s)\n{\n  return (p->p_type == PT_NOTE\n\t  && elf_section_type (s) == SHT_NOTE\n\t  && (ufile_ptr) s->filepos >= p->p_offset\n\t  && p->p_filesz >= s->size\n\t  && ((ufile_ptr) s->filepos - p->p_offset\n\t      <= p->p_filesz - s->size));\n}", "target": 0}
{"code": "void LayerTilerChromium::growLayerToContain(const IntRect& contentRect)\n{\n    IntRect layerRect = contentRectToLayerRect(contentRect);\n    IntSize layerSize = IntSize(layerRect.maxX(), layerRect.maxY());\n    IntSize newSize = layerSize.expandedTo(m_layerSize);\n    resizeLayer(newSize);\n}", "target": 0}
{"code": "KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){\n  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);\n  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);\n  if( p ){\n    p->aSortOrder = (u8*)&p->aColl[N+X];\n    p->nKeyField = (u16)N;\n    p->nAllField = (u16)(N+X);\n    p->enc = ENC(db);\n    p->db = db;\n    p->nRef = 1;\n    memset(&p[1], 0, nExtra);\n  }else{\n    sqlite3OomFault(db);\n  }\n  return p;\n}", "target": 0}
{"code": "static NTSTATUS dcesrv_interface_dnsserver_bind(struct dcesrv_connection_context *context,\n\t\t\t\t\t        const struct dcesrv_interface *iface)\n{\n\treturn dcesrv_interface_bind_require_integrity(context, iface);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const float in_min = context->input(2).flat<float>()(0);\n    const float in_max = context->input(3).flat<float>()(0);\n    ImageResizerState st(align_corners_, false);\n    st.ValidateAndCreateOutput(context);\n    if (!context->status().ok()) return;\n    if (st.output->NumElements() == 0) return;\n    typename TTypes<T, 4>::ConstTensor image_data(\n        context->input(0).tensor<T, 4>());\n    typename TTypes<T, 4>::Tensor output_data(st.output->tensor<T, 4>());\n    ResizeBilinear<T>(image_data, st.height_scale, st.width_scale, in_min,\n                      in_max, half_pixel_centers_, &output_data);\n    Tensor* out_min = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, {}, &out_min));\n    out_min->flat<float>()(0) = in_min;\n    Tensor* out_max = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(2, {}, &out_max));\n    out_max->flat<float>()(0) = in_max;\n  }", "target": 1}
{"code": "static int get_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\tu32 off;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (copy_to_user(uaddr, ((u32 *)regs) + off, KVM_REG_SIZE(reg->id)))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "static int count_channels(uint8_t (*layout)[3], int tags)\n{\n    int i, sum = 0;\n    for (i = 0; i < tags; i++) {\n        int syn_ele = layout[i][0];\n        int pos     = layout[i][2];\n        sum += (1 + (syn_ele == TYPE_CPE)) *\n               (pos != AAC_CHANNEL_OFF && pos != AAC_CHANNEL_CC);\n    }\n    return sum;\n}", "target": 0}
{"code": "void PDPSimple::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->tlm_ != nullptr)\n    {\n        mp_builtin->tlm_->assign_remote_endpoints(pdata);\n    }\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, CantExplodeMetaSort) {\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1 << \"c\"\n                      << \"text\"));\n    runQuerySortProj(fromjson(\"{a: {$in: [1, 2]}, b: {$in: [3, 4]}}\"),\n                     fromjson(\"{c: {$meta: 'textScore'}}\"),\n                     fromjson(\"{c: {$meta: 'textScore'}}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\n        \"{proj: {spec: {c:{$meta:'textScore'}}, node: \"\n        \"{sort: {pattern: {c:{$meta:'textScore'}}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {filter: {a:{$in:[1,2]},b:{$in:[3,4]}}, dir: 1}}}}}}}}\");\n}", "target": 0}
{"code": "std::wstring GetUniqueTempDirectoryPrefix()\n{\n    wchar_t tmpdir[MAX_PATH + 1];\n    if (GetTempPath(MAX_PATH + 1, tmpdir) == 0)\n        throw Win32Exception(\"Cannot create temporary directory\");\n    std::wstring dir(tmpdir);\n    dir += L\"Update-\";\n    return dir;\n}", "target": 0}
{"code": "static unsigned int btrfs_mask_fsflags_for_type(struct inode *inode,\n\t\tunsigned int flags)\n{\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn flags;\n\telse if (S_ISREG(inode->i_mode))\n\t\treturn flags & ~FS_DIRSYNC_FL;\n\telse\n\t\treturn flags & (FS_NODUMP_FL | FS_NOATIME_FL);\n}", "target": 0}
{"code": "local block_state deflate_rle(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    uInt prev;              \n    Bytef *scan, *strend;   \n    for (;;) {\n        if (s->lookahead <= MAX_MATCH) {\n            fill_window(s);\n            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {\n                return need_more;\n            }\n            if (s->lookahead == 0) break; \n        }\n        s->match_length = 0;\n        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {\n            scan = s->window + s->strstart - 1;\n            prev = *scan;\n            if (prev == *++scan && prev == *++scan && prev == *++scan) {\n                strend = s->window + s->strstart + MAX_MATCH;\n                do {\n                } while (prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         prev == *++scan && prev == *++scan &&\n                         scan < strend);\n                s->match_length = MAX_MATCH - (uInt)(strend - scan);\n                if (s->match_length > s->lookahead)\n                    s->match_length = s->lookahead;\n            }\n            Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n        }\n        if (s->match_length >= MIN_MATCH) {\n            check_match(s, s->strstart, s->strstart - 1, s->match_length);\n            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);\n            s->lookahead -= s->match_length;\n            s->strstart += s->match_length;\n            s->match_length = 0;\n        } else {\n            Tracevv((stderr,\"%c\", s->window[s->strstart]));\n            _tr_tally_lit (s, s->window[s->strstart], bflush);\n            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "static int pgpVerifySelf(pgpDigParams key, pgpDigParams selfsig,\n\t\t\tconst struct pgpPkt *all, int i)\n{\n    int rc = -1;\n    DIGEST_CTX hash = NULL;\n    switch (selfsig->sigtype) {\n    case PGPSIGTYPE_SUBKEY_BINDING:\n\thash = rpmDigestInit(selfsig->hash_algo, 0);\n\tif (hash) {\n\t    rc = hashKey(hash, &all[0], PGPTAG_PUBLIC_KEY);\n\t    if (!rc)\n\t\trc = hashKey(hash, &all[i-1], PGPTAG_PUBLIC_SUBKEY);\n\t}\n\tbreak;\n    default:\n\trc = 0;\n\tbreak;\n    }\n    if (hash && rc == 0)\n\trc = pgpVerifySignature(key, selfsig, hash);\n    rpmDigestFinal(hash, NULL, NULL, 0);\n    return rc;\n}", "target": 0}
{"code": "decodeJsonStructure(void *dst, const UA_DataType *type, CtxJson *ctx, \n                    ParseCtx *parseCtx, UA_Boolean moveToken) {\n    (void) moveToken;\n    if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    uintptr_t ptr = (uintptr_t)dst;\n    status ret = UA_STATUSCODE_GOOD;\n    u8 membersSize = type->membersSize;\n    const UA_DataType *typelists[2] = { UA_TYPES, &type[-type->typeIndex] };\n    UA_STACKARRAY(DecodeEntry, entries, membersSize);\n    for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) {\n        const UA_DataTypeMember *m = &type->members[i];\n        const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex];\n        entries[i].type = mt;\n        if(!m->isArray) {\n            ptr += m->padding;\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = decodeJsonJumpTable[mt->typeKind];\n            entries[i].found = false;\n            ptr += mt->memSize;\n        } else {\n            ptr += m->padding;\n            ptr += sizeof(size_t);\n            entries[i].fieldName = m->memberName;\n            entries[i].fieldPointer = (void*)ptr;\n            entries[i].function = (decodeJsonSignature)Array_decodeJson;\n            entries[i].found = false;\n            ptr += sizeof(void*);\n        }\n    }\n    ret = decodeFields(ctx, parseCtx, entries, membersSize, type);\n    ctx->depth--;\n    return ret;\n}", "target": 1}
{"code": "static Jsi_RC jsi_BitfieldToValue(Jsi_Interp *interp, Jsi_OptionSpec* spec, Jsi_Value **outValue,\n    Jsi_DString *outStr, void *record, Jsi_Wide flags)\n{\n    Jsi_csgset *bsget = spec->init.OPT_BITS;\n    Jsi_Interp *d = interp;\n    int idx = spec->idx;\n    uchar *data = (uchar*)record;\n    int64_t inum;\n    Jsi_OptionSpec* enumSpec = (typeof(enumSpec))spec->data;\n    if (!d || !bsget || idx<0) \n        return Jsi_LogBug(\"invalid bitfield\");\n    Jsi_RC rc = (*bsget)(interp, data, &inum, spec, idx, 0);\n    if (rc != JSI_OK)\n        return JSI_ERROR;\n    if (enumSpec) {\n        struct numStruct { int64_t numVal; } nval = { inum };\n        Jsi_OptionSpec eSpec[] = {\n            JSI_OPT(CUSTOM, struct numStruct, numVal, .help=spec->help, .flags=JSI_OPT_ENUM_SPEC, .custom=Jsi_Opt_SwitchEnum,\n            .data=(void*)enumSpec, .info=0, .tname=spec->tname, .value=0, .bits=0, .boffset=8*sizeof(int64_t) ), \n            JSI_OPT_END(struct numStruct)\n        };\n        if (JSI_OK != jsi_EnumToValue(interp, eSpec, outValue, outStr, (void*)&nval, flags))\n            return JSI_ERROR;\n    } else if (outStr) {\n        char obuf[100];\n        snprintf(obuf, sizeof(obuf), \"%\" PRId64, inum);\n        Jsi_DSAppend(outStr, obuf, NULL);\n    } else {\n        Jsi_Number num = (Jsi_Number)inum;\n        Jsi_ValueMakeNumber(interp, outValue, num);\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "static int amf_get_field_value2(GetByteContext *gb,\n                           const uint8_t *name, uint8_t *dst, int dst_size)\n{\n    int namelen = strlen(name);\n    int len;\n    while (bytestream2_peek_byte(gb) != AMF_DATA_TYPE_OBJECT && bytestream2_get_bytes_left(gb) > 0) {\n        int ret = amf_tag_skip(gb);\n        if (ret < 0)\n            return -1;\n    }\n    if (bytestream2_get_bytes_left(gb) < 3)\n        return -1;\n    bytestream2_get_byte(gb);\n    for (;;) {\n        int size = bytestream2_get_be16(gb);\n        if (!size)\n            break;\n        if (size < 0 || size >= bytestream2_get_bytes_left(gb))\n            return -1;\n        bytestream2_skip(gb, size);\n        if (size == namelen && !memcmp(gb->buffer-size, name, namelen)) {\n            switch (bytestream2_get_byte(gb)) {\n            case AMF_DATA_TYPE_NUMBER:\n                snprintf(dst, dst_size, \"%g\", av_int2double(bytestream2_get_be64(gb)));\n                break;\n            case AMF_DATA_TYPE_BOOL:\n                snprintf(dst, dst_size, \"%s\", bytestream2_get_byte(gb) ? \"true\" : \"false\");\n                break;\n            case AMF_DATA_TYPE_STRING:\n                len = bytestream2_get_be16(gb);\n                if (dst_size < 1)\n                    return -1;\n                if (dst_size < len + 1)\n                    len = dst_size - 1;\n                bytestream2_get_buffer(gb, dst, len);\n                dst[len] = 0;\n                break;\n            default:\n                return -1;\n            }\n            return 0;\n        }\n        len = amf_tag_skip(gb);\n        if (len < 0 || bytestream2_get_bytes_left(gb) <= 0)\n            return -1;\n    }\n    return -1;\n}", "target": 0}
{"code": "const char *enter_repo(const char *path, int strict)\n{\n\tstatic struct strbuf validated_path = STRBUF_INIT;\n\tstatic struct strbuf used_path = STRBUF_INIT;\n\tif (!path)\n\t\treturn NULL;\n\tif (!strict) {\n\t\tstatic const char *suffix[] = {\n\t\t\t\"/.git\", \"\", \".git/.git\", \".git\", NULL,\n\t\t};\n\t\tconst char *gitfile;\n\t\tint len = strlen(path);\n\t\tint i;\n\t\twhile ((1 < len) && (path[len-1] == '/'))\n\t\t\tlen--;\n\t\tif (PATH_MAX <= len)\n\t\t\treturn NULL;\n\t\tstrbuf_reset(&used_path);\n\t\tstrbuf_reset(&validated_path);\n\t\tstrbuf_add(&used_path, path, len);\n\t\tstrbuf_add(&validated_path, path, len);\n\t\tif (used_path.buf[0] == '~') {\n\t\t\tchar *newpath = interpolate_path(used_path.buf, 0);\n\t\t\tif (!newpath)\n\t\t\t\treturn NULL;\n\t\t\tstrbuf_attach(&used_path, newpath, strlen(newpath),\n\t\t\t\t      strlen(newpath));\n\t\t}\n\t\tfor (i = 0; suffix[i]; i++) {\n\t\t\tstruct stat st;\n\t\t\tsize_t baselen = used_path.len;\n\t\t\tstrbuf_addstr(&used_path, suffix[i]);\n\t\t\tif (!stat(used_path.buf, &st) &&\n\t\t\t    (S_ISREG(st.st_mode) ||\n\t\t\t    (S_ISDIR(st.st_mode) && is_git_directory(used_path.buf)))) {\n\t\t\t\tstrbuf_addstr(&validated_path, suffix[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrbuf_setlen(&used_path, baselen);\n\t\t}\n\t\tif (!suffix[i])\n\t\t\treturn NULL;\n\t\tgitfile = read_gitfile(used_path.buf);\n\t\tdie_upon_dubious_ownership(gitfile, NULL, used_path.buf);\n\t\tif (gitfile) {\n\t\t\tstrbuf_reset(&used_path);\n\t\t\tstrbuf_addstr(&used_path, gitfile);\n\t\t}\n\t\tif (chdir(used_path.buf))\n\t\t\treturn NULL;\n\t\tpath = validated_path.buf;\n\t}\n\telse {\n\t\tconst char *gitfile = read_gitfile(path);\n\t\tdie_upon_dubious_ownership(gitfile, NULL, path);\n\t\tif (gitfile)\n\t\t\tpath = gitfile;\n\t\tif (chdir(path))\n\t\t\treturn NULL;\n\t}\n\tif (is_git_directory(\".\")) {\n\t\tset_git_dir(\".\", 0);\n\t\tcheck_repository_format(NULL);\n\t\treturn path;\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "internalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n  entity = openEntity->entity;\n  textStart = ((char *)entity->textPtr) + entity->processed;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif \n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE);\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (char *)entity->textPtr);\n    return result;\n  } else {\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  } else\n#endif \n  {\n    parser->m_processor = contentProcessor;\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  }\n}", "target": 1}
{"code": "void OfflineAudioDestinationHandler::SuspendOfflineRendering() {\n  DCHECK(!IsMainThread());\n  PostCrossThreadTask(\n      *main_thread_task_runner_, FROM_HERE,\n      CrossThreadBind(&OfflineAudioDestinationHandler::NotifySuspend,\n                      WrapRefCounted(this), Context()->CurrentSampleFrame()));\n}", "target": 0}
{"code": "static void seek_floppy(void)\n{\n\tint track;\n\tblind_seek = 0;\n\tdebug_dcl(DP->flags, \"calling disk change from %s\\n\", __func__);\n\tif (!test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t    disk_change(current_drive) && (raw_cmd->flags & FD_RAW_NEED_DISK)) {\n\t\tset_bit(FD_DISK_CHANGED_BIT, &DRS->flags);\n\t\tcont->done(0);\n\t\tcont->redo();\n\t\treturn;\n\t}\n\tif (DRS->track <= NEED_1_RECAL) {\n\t\trecalibrate_floppy();\n\t\treturn;\n\t} else if (test_bit(FD_DISK_NEWCHANGE_BIT, &DRS->flags) &&\n\t\t   (raw_cmd->flags & FD_RAW_NEED_DISK) &&\n\t\t   (DRS->track <= NO_TRACK || DRS->track == raw_cmd->track)) {\n\t\tif (raw_cmd->track)\n\t\t\ttrack = raw_cmd->track - 1;\n\t\telse {\n\t\t\tif (DP->flags & FD_SILENT_DCL_CLEAR) {\n\t\t\t\tset_dor(fdc, ~(0x10 << UNIT(current_drive)), 0);\n\t\t\t\tblind_seek = 1;\n\t\t\t\traw_cmd->flags |= FD_RAW_NEED_SEEK;\n\t\t\t}\n\t\t\ttrack = 1;\n\t\t}\n\t} else {\n\t\tcheck_wp();\n\t\tif (raw_cmd->track != DRS->track &&\n\t\t    (raw_cmd->flags & FD_RAW_NEED_SEEK))\n\t\t\ttrack = raw_cmd->track;\n\t\telse {\n\t\t\tsetup_rw_floppy();\n\t\t\treturn;\n\t\t}\n\t}\n\tdo_floppy = seek_interrupt;\n\toutput_byte(FD_SEEK);\n\toutput_byte(UNIT(current_drive));\n\tif (output_byte(track) < 0) {\n\t\treset_fdc();\n\t\treturn;\n\t}\n\tdebugt(__func__, \"\");\n}", "target": 0}
{"code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRDyldCache *cache = R_NEW0 (RDyldCache);\n\tmemcpy (cache->magic, \"dyldcac\", 7);\n\tcache->buf = r_buf_ref (buf);\n\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {\n\t\t\t\tpending_bin_files = r_list_new ();\n\t\t\t\tif (!pending_bin_files) {\n\t\t\t\t\tr_dyldcache_free (cache);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_push (pending_bin_files, bf);\n\t\t\tswizzle_io_read (cache, bf->rbin->iob.io);\n\t\t}\n\t}\n\t*bin_obj = cache;\n\treturn true;\n}", "target": 1}
{"code": "getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static getprivs_ret            ret;\n    gss_buffer_desc                client_name, service_name;\n    OM_uint32                      minor_stat;\n    kadm5_server_handle_t          handle;\n    const char                     *errmsg = NULL;\n    xdr_free(xdr_getprivs_ret, &ret);\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    ret.code = kadm5_get_privs((void *)handle, &ret.privs);\n    if( ret.code != 0 )\n        errmsg = krb5_get_error_message(handle->context, ret.code);\n    log_done(\"kadm5_get_privs\", client_name.value, errmsg,\n             &client_name, &service_name, rqstp);\n    if (errmsg != NULL)\n        krb5_free_error_message(handle->context, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "  bool IsInUse() { return entry_stack_ != NULL; }", "target": 0}
{"code": "kg_unseal(minor_status, context_handle, input_token_buffer,\n          message_buffer, conf_state, qop_state, toktype)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t input_token_buffer;\n    gss_buffer_t message_buffer;\n    int *conf_state;\n    gss_qop_t *qop_state;\n    int toktype;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    ptr = (unsigned char *) input_token_buffer->value;\n    err = g_verify_token_header(ctx->mech_used,\n                                &bodysize, &ptr, -1,\n                                input_token_buffer->length,\n                                vfyflags);\n    if (err) {\n        *minor_status = err;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n    if (bodysize < 2) {\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        return GSS_S_DEFECTIVE_TOKEN;\n    }\n    toktype2 = load_16_be(ptr);\n    ptr += 2;\n    bodysize -= 2;\n    switch (toktype2) {\n    case KG2_TOK_MIC_MSG:\n    case KG2_TOK_WRAP_MSG:\n    case KG2_TOK_DEL_CTX:\n        ret = gss_krb5int_unseal_token_v3(&ctx->k5_context, minor_status, ctx,\n                                          ptr, bodysize, message_buffer,\n                                          conf_state, qop_state, toktype);\n        break;\n    case KG_TOK_MIC_MSG:\n    case KG_TOK_WRAP_MSG:\n    case KG_TOK_DEL_CTX:\n        ret = kg_unseal_v1(ctx->k5_context, minor_status, ctx, ptr, bodysize,\n                           message_buffer, conf_state, qop_state,\n                           toktype);\n        break;\n    default:\n        *minor_status = (OM_uint32)G_BAD_TOK_HEADER;\n        ret = GSS_S_DEFECTIVE_TOKEN;\n        break;\n    }\n    if (ret != 0)\n        save_error_info (*minor_status, ctx->k5_context);\n    return ret;\n}", "target": 1}
{"code": "find_node_in_range(struct inode *inode, loff_t min, loff_t max)\n{\n\tstruct rb_node *n = uprobes_tree.rb_node;\n\twhile (n) {\n\t\tstruct uprobe *u = rb_entry(n, struct uprobe, rb_node);\n\t\tif (inode < u->inode) {\n\t\t\tn = n->rb_left;\n\t\t} else if (inode > u->inode) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tif (max < u->offset)\n\t\t\t\tn = n->rb_left;\n\t\t\telse if (min > u->offset)\n\t\t\t\tn = n->rb_right;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn n;\n}", "target": 0}
{"code": "int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {\n        int r;\n        assert(p);\n        assert(key);\n        if (DNS_PACKET_QR(p) != 1)\n                return 0;\n        r = dns_packet_extract(p);\n        if (r < 0)\n                return r;\n        if (!p->question)\n                return 0;\n        if (p->question->n_keys != 1)\n                return 0;\n        return dns_resource_key_equal(p->question->keys[0], key);\n}", "target": 0}
{"code": "void test_base64_lengths(void)\n{\n  const char *in = \"FuseMuse\";\n  char out1[32];\n  char out2[32];\n  size_t enclen;\n  int declen;\n  enclen = mutt_b64_encode(out1, in, 0, 32);\n  if (!TEST_CHECK(enclen == 0))\n  {\n    TEST_MSG(\"Expected: %zu\", 0);\n    TEST_MSG(\"Actual  : %zu\", enclen);\n  }\n  out1[0] = '\\0';\n  declen = mutt_b64_decode(out2, out1);\n  if (!TEST_CHECK(declen == -1))\n  {\n    TEST_MSG(\"Expected: %zu\", -1);\n    TEST_MSG(\"Actual  : %zu\", declen);\n  }\n  for (size_t i = 1; i <= 8; ++i)\n  {\n    enclen = mutt_b64_encode(out1, in, i, 32);\n    size_t exp = ((i + 2) / 3) << 2;\n    if (!TEST_CHECK(enclen == exp))\n    {\n      TEST_MSG(\"Expected: %zu\", exp);\n      TEST_MSG(\"Actual  : %zu\", enclen);\n    }\n    declen = mutt_b64_decode(out2, out1);\n    if (!TEST_CHECK(declen == i))\n    {\n      TEST_MSG(\"Expected: %zu\", i);\n      TEST_MSG(\"Actual  : %zu\", declen);\n    }\n    out2[declen] = '\\0';\n    if (!TEST_CHECK(strncmp(out2, in, i) == 0))\n    {\n      TEST_MSG(\"Expected: %s\", in);\n      TEST_MSG(\"Actual  : %s\", out2);\n    }\n  }\n}", "target": 1}
{"code": "void comps_rtree_unite(COMPS_RTree *rt1, COMPS_RTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_RTreeData*)it->data)->subnodes;\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_RTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_RTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_RTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_RTreeData*)it->data)->key)+1));\n            }\n            if (((COMPS_RTreeData*)it->data)->data != NULL) {\n                    comps_rtree_set(rt1,\n                                    pair->key,\n                        rt2->data_cloner(((COMPS_RTreeData*)it->data)->data));\n            }\n            if (((COMPS_RTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}", "target": 1}
{"code": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n    clear(); \n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {\n        processRequest();\n    }\n    return response();\n}", "target": 1}
{"code": "void file_sb_list_del(struct file *file)\n{\n\tif (!list_empty(&file->f_u.fu_list)) {\n\t\tlg_local_lock_cpu(&files_lglock, file_list_cpu(file));\n\t\tlist_del_init(&file->f_u.fu_list);\n\t\tlg_local_unlock_cpu(&files_lglock, file_list_cpu(file));\n\t}\n}", "target": 1}
{"code": "_defbackend_gen_returntext(char *buffer, size_t buflen, char **dns)\n{\n    int dnidx;\n    int sidx;\n    struct suffix_repeat {\n        char *suffix;\n        int size;\n    } candidates[] = {\n        {\"dc=\", 3}, \n        {NULL, 0}\n    };\n    PR_snprintf(buffer, buflen, \"%s (\", DEFBE_NO_SUCH_SUFFIX);\n    for (dnidx = 0; dns[dnidx]; dnidx++) ; \n    dnidx--; \n    for (sidx = 0; candidates[sidx].suffix; sidx++) {\n        if (!PL_strncasecmp(dns[dnidx], candidates[sidx].suffix, candidates[sidx].size)) {\n            while (!PL_strncasecmp(dns[--dnidx], candidates[sidx].suffix, candidates[sidx].size)) ;\n            PL_strcat(buffer, dns[++dnidx]); \n            for (++dnidx; dns[dnidx]; dnidx++) {\n                PL_strcat(buffer, \",\");\n                PL_strcat(buffer, dns[dnidx]);\n            }\n            PL_strcat(buffer, \")\");\n            return; \n        }\n    }\n    PL_strcat(buffer, dns[dnidx]);\n    PL_strcat(buffer, \")\");\n    return;\n}", "target": 0}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (ACCESS_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\tuserfaultfd_ctx_put(new);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, POLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\nout:\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "bgp_capability_vty_out (struct vty *vty, struct peer *peer)\n{\n  char *pnt;\n  char *end;\n  struct capability cap;\n  pnt = peer->notify.data;\n  end = pnt + peer->notify.length;\n  while (pnt < end)\n    {\n      memcpy(&cap, pnt, sizeof(struct capability));\n      if (pnt + 2 > end)\n\treturn;\n      if (pnt + (cap.length + 2) > end)\n\treturn;\n      if (cap.code == CAPABILITY_CODE_MP)\n\t{\n\t  vty_out (vty, \"  Capability error for: Multi protocol \");\n\t  switch (ntohs (cap.mpc.afi))\n\t    {\n\t    case AFI_IP:\n\t      vty_out (vty, \"AFI IPv4, \");\n\t      break;\n\t    case AFI_IP6:\n\t      vty_out (vty, \"AFI IPv6, \");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"AFI Unknown %d, \", ntohs (cap.mpc.afi));\n\t      break;\n\t    }\n\t  switch (cap.mpc.safi)\n\t    {\n\t    case SAFI_UNICAST:\n\t      vty_out (vty, \"SAFI Unicast\");\n\t      break;\n\t    case SAFI_MULTICAST:\n\t      vty_out (vty, \"SAFI Multicast\");\n\t      break;\n\t    case SAFI_UNICAST_MULTICAST:\n\t      vty_out (vty, \"SAFI Unicast Multicast\");\n\t      break;\n\t    case BGP_SAFI_VPNV4:\n\t      vty_out (vty, \"SAFI MPLS-VPN\");\n\t      break;\n\t    default:\n\t      vty_out (vty, \"SAFI Unknown %d \", cap.mpc.safi);\n\t      break;\n\t    }\n\t  vty_out (vty, \"%s\", VTY_NEWLINE);\n\t}\n      else if (cap.code >= 128)\n\tvty_out (vty, \"  Capability error: vendor specific capability code %d\",\n\t\t cap.code);\n      else\n\tvty_out (vty, \"  Capability error: unknown capability code %d\", \n\t\t cap.code);\n      pnt += cap.length + 2;\n    }\n}", "target": 1}
{"code": "IOBasicTypes::LongFilePositionType ObjectByteWriterWithPosition::GetCurrentPosition()\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"getCurrentPosition\")).ToLocalChecked();\n    if(value->IsUndefined())\n        return true;\n    Local<Function> func = Local<Function>::Cast(value);\n\treturn TO_NUMBER(func->Call(GET_CURRENT_CONTEXT, OBJECT_FROM_PERSISTENT(mObject), 0, NULL).ToLocalChecked())->Value();\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* epsilon_t;\n    OP_REQUIRES_OK(context, context->input(kEpsilonName, &epsilon_t));\n    float epsilon = epsilon_t->scalar<float>()();\n    OP_REQUIRES(\n        context, epsilon > 0,\n        errors::InvalidArgument(\"An epsilon value of zero is not allowed.\"));\n    const Tensor* num_streams_t;\n    OP_REQUIRES_OK(context, context->input(kNumStreamsName, &num_streams_t));\n    int64_t num_streams = num_streams_t->scalar<int64>()();\n    OP_REQUIRES(context, num_streams >= 0,\n                errors::InvalidArgument(\n                    \"Num_streams input cannot be a negative integer\"));\n    auto result =\n        new QuantileStreamResource(epsilon, max_elements_, num_streams);\n    auto status = CreateResource(context, HandleFromInput(context, 0), result);\n    if (!status.ok() && status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES(context, false, status);\n    }\n  }", "target": 0}
{"code": "DEFINE_TEST(test_read_format_mtree_crash747)\n{\n\tconst char *reffile = \"test_read_format_mtree_crash747.mtree.bz2\";\n\tstruct archive *a;\n\textract_reference_file(reffile);\n\tassert((a = archive_read_new()) != NULL);\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_filter_bzip2(a));\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_mtree(a));\n\tassertEqualIntA(a, ARCHIVE_FATAL, archive_read_open_filename(a, reffile, 10240));\n\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n}", "target": 0}
{"code": "static inline void x86_assign_hw_event(struct perf_event *event,\n\t\t\t\tstruct cpu_hw_events *cpuc, int i)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\thwc->idx = cpuc->assign[i];\n\thwc->last_cpu = smp_processor_id();\n\thwc->last_tag = ++cpuc->tags[i];\n\tif (hwc->idx == X86_PMC_IDX_FIXED_BTS) {\n\t\thwc->config_base = 0;\n\t\thwc->event_base\t= 0;\n\t} else if (hwc->idx >= X86_PMC_IDX_FIXED) {\n\t\thwc->config_base = MSR_ARCH_PERFMON_FIXED_CTR_CTRL;\n\t\thwc->event_base = MSR_ARCH_PERFMON_FIXED_CTR0;\n\t} else {\n\t\thwc->config_base = x86_pmu_config_addr(hwc->idx);\n\t\thwc->event_base  = x86_pmu_event_addr(hwc->idx);\n\t}\n}", "target": 1}
{"code": "void StelScriptOutput::saveOutputAs(const QString &name)\n{\n\tQFile asFile;\n\tQFileInfo outputInfo(outputFile);\n\tQDir dir=outputInfo.dir(); \n\tQFileInfo newFileNameInfo(name);\n\tbool okToSaveToAbsolutePath=StelApp::getInstance().getSettings()->value(\"scripts/flag_script_allow_write_absolute_path\", false).toBool();\n\tif (!okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tqWarning() << \"SCRIPTING CONFIGURATION ISSUE: You are trying to save to an absolute pathname.\";\n\t\tqWarning() << \"  To enable this, edit config.ini and set [scripts]/flag_script_allow_write_absolute_path=true\";\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + newFileNameInfo.fileName());\n\t\tqWarning() << \"  Storing to \" << asFile.fileName() << \" instead\";\n\t}\n\telse if (okToSaveToAbsolutePath && (newFileNameInfo.isAbsolute()))\n\t{\n\t\tasFile.setFileName(name);\n\t}\n\telse\n\t{\n\t\tasFile.setFileName(dir.absolutePath() + \"/\" + name);\n\t}\n\tif (!asFile.open(QIODevice::WriteOnly | QIODevice::Truncate | QIODevice::Text | QIODevice::Unbuffered))\n\t{\n\t\tqDebug() << \"ERROR: Cannot open file\" << asFile.fileName();\n\t\treturn;\n\t}\n\tqDebug() << \"saving copy of output.txt to \" << asFile.fileName();\n\tasFile.write(qPrintable(outputText), outputText.size());\n\tasFile.close();\n}", "target": 1}
{"code": "_archive_write_data(struct archive *_a, const void *buff, size_t s)\n{\n\tstruct archive_write *a = (struct archive_write *)_a;\n\tconst size_t max_write = INT_MAX;\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_MAGIC,\n\t    ARCHIVE_STATE_DATA, \"archive_write_data\");\n\tif (s > max_write)\n\t\ts = max_write;\n\tarchive_clear_error(&a->archive);\n\treturn ((a->format_write_data)(a, buff, s));\n}", "target": 0}
{"code": "bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success)\n{\n  if (wcschr(Src,(wchar)MappedStringMark)==NULL)\n    return false;\n  Success=true;\n  uint SrcPos=0,DestPos=0;\n  while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX)\n  {\n    if (uint(Src[SrcPos])==MappedStringMark)\n    {\n      SrcPos++;\n      continue;\n    }\n    if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100)\n      Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart);\n    else\n    {\n      mbstate_t ps;\n      memset(&ps,0,sizeof(ps));\n      if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==-1)\n      {\n        Dest[DestPos]='_';\n        Success=false;\n      }\n      SrcPos++;\n      memset(&ps,0,sizeof(ps));\n      int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps);\n      DestPos+=Max(Length,1);\n    }\n  }\n  Dest[Min(DestPos,DestSize-1)]=0;\n  return true;\n}", "target": 1}
{"code": "static long aio_read_events_ring(struct kioctx *ctx,\n\t\t\t\t struct io_event __user *event, long nr)\n{\n\tstruct aio_ring *ring;\n\tunsigned head, tail, pos;\n\tlong ret = 0;\n\tint copy_ret;\n\tmutex_lock(&ctx->ring_lock);\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\thead = ring->head;\n\ttail = ring->tail;\n\tkunmap_atomic(ring);\n\tpr_debug(\"h%u t%u m%u\\n\", head, tail, ctx->nr_events);\n\tif (head == tail)\n\t\tgoto out;\n\thead %= ctx->nr_events;\n\ttail %= ctx->nr_events;\n\twhile (ret < nr) {\n\t\tlong avail;\n\t\tstruct io_event *ev;\n\t\tstruct page *page;\n\t\tavail = (head <= tail ?  tail : ctx->nr_events) - head;\n\t\tif (head == tail)\n\t\t\tbreak;\n\t\tavail = min(avail, nr - ret);\n\t\tavail = min_t(long, avail, AIO_EVENTS_PER_PAGE -\n\t\t\t    ((head + AIO_EVENTS_OFFSET) % AIO_EVENTS_PER_PAGE));\n\t\tpos = head + AIO_EVENTS_OFFSET;\n\t\tpage = ctx->ring_pages[pos / AIO_EVENTS_PER_PAGE];\n\t\tpos %= AIO_EVENTS_PER_PAGE;\n\t\tev = kmap(page);\n\t\tcopy_ret = copy_to_user(event + ret, ev + pos,\n\t\t\t\t\tsizeof(*ev) * avail);\n\t\tkunmap(page);\n\t\tif (unlikely(copy_ret)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tret += avail;\n\t\thead += avail;\n\t\thead %= ctx->nr_events;\n\t}\n\tring = kmap_atomic(ctx->ring_pages[0]);\n\tring->head = head;\n\tkunmap_atomic(ring);\n\tflush_dcache_page(ctx->ring_pages[0]);\n\tpr_debug(\"%li  h%u t%u\\n\", ret, head, tail);\nout:\n\tmutex_unlock(&ctx->ring_lock);\n\treturn ret;\n}", "target": 0}
{"code": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\tif (ns_capable(ns->parent, cap_setid) &&\n\t    file_ns_capable(file, ns->parent, cap_setid))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "static GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)\n{\n\tu32 size = parser->line_size;\n\tu32 nl_size = (u32) strlen(string);\n\tif (!nl_size) return GF_OK;\n\tif ( (parser->alloc_size < size+nl_size+1)\n\t   )\n\t{\n\t\tparser->alloc_size = size+nl_size+1;\n\t\tparser->alloc_size = 3 * parser->alloc_size / 2;\n\t\tparser->buffer = (char*)gf_realloc(parser->buffer, sizeof(char) * parser->alloc_size);\n\t\tif (!parser->buffer ) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(parser->buffer+size, string, sizeof(char)*nl_size);\n\tparser->buffer[size+nl_size] = 0;\n\tparser->line_size = size+nl_size;\n\treturn GF_OK;\n}", "target": 1}
{"code": "nfsd4_encode_getdeviceinfo(struct nfsd4_compoundres *resp, __be32 nfserr,\n\t\tstruct nfsd4_getdeviceinfo *gdev)\n{\n\tstruct xdr_stream *xdr = &resp->xdr;\n\tconst struct nfsd4_layout_ops *ops =\n\t\tnfsd4_layout_ops[gdev->gd_layout_type];\n\tu32 starting_len = xdr->buf->len, needed_len;\n\t__be32 *p;\n\tdprintk(\"%s: err %d\\n\", __func__, be32_to_cpu(nfserr));\n\tif (nfserr)\n\t\tgoto out;\n\tnfserr = nfserr_resource;\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p)\n\t\tgoto out;\n\t*p++ = cpu_to_be32(gdev->gd_layout_type);\n\tif (gdev->gd_maxcount != 0) {\n\t\tnfserr = ops->encode_getdeviceinfo(xdr, gdev);\n\t\tif (nfserr) {\n\t\t\tif (xdr->buf->len + 4 > gdev->gd_maxcount)\n\t\t\t\tgoto toosmall;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnfserr = nfserr_resource;\n\tif (gdev->gd_notify_types) {\n\t\tp = xdr_reserve_space(xdr, 4 + 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = cpu_to_be32(1);\t\t\t\n\t\t*p++ = cpu_to_be32(gdev->gd_notify_types);\n\t} else {\n\t\tp = xdr_reserve_space(xdr, 4);\n\t\tif (!p)\n\t\t\tgoto out;\n\t\t*p++ = 0;\n\t}\n\tnfserr = 0;\nout:\n\tkfree(gdev->gd_device);\n\tdprintk(\"%s: done: %d\\n\", __func__, be32_to_cpu(nfserr));\n\treturn nfserr;\ntoosmall:\n\tdprintk(\"%s: maxcount too small\\n\", __func__);\n\tneeded_len = xdr->buf->len + 4 ;\n\txdr_truncate_encode(xdr, starting_len);\n\tp = xdr_reserve_space(xdr, 4);\n\tif (!p) {\n\t\tnfserr = nfserr_resource;\n\t} else {\n\t\t*p++ = cpu_to_be32(needed_len);\n\t\tnfserr = nfserr_toosmall;\n\t}\n\tgoto out;\n}", "target": 1}
{"code": "vg_ctrl_response(VuGpu *g,\n                 struct virtio_gpu_ctrl_command *cmd,\n                 struct virtio_gpu_ctrl_hdr *resp,\n                 size_t resp_len)\n{\n    size_t s;\n    if (cmd->cmd_hdr.flags & VIRTIO_GPU_FLAG_FENCE) {\n        resp->flags |= VIRTIO_GPU_FLAG_FENCE;\n        resp->fence_id = cmd->cmd_hdr.fence_id;\n        resp->ctx_id = cmd->cmd_hdr.ctx_id;\n    }\n    virtio_gpu_ctrl_hdr_bswap(resp);\n    s = iov_from_buf(cmd->elem.in_sg, cmd->elem.in_num, 0, resp, resp_len);\n    if (s != resp_len) {\n        g_critical(\"%s: response size incorrect %zu vs %zu\",\n                   __func__, s, resp_len);\n    }\n    vu_queue_push(&g->dev.parent, cmd->vq, &cmd->elem, s);\n    vu_queue_notify(&g->dev.parent, cmd->vq);\n    cmd->state = VG_CMD_STATE_FINISHED;\n}", "target": 0}
{"code": "static char *get_header(FILE *fp)\n{\n    long start;\n    char *header;\n    header = calloc(1, 1024);\n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}", "target": 1}
{"code": "bool DependencyOptimizer::SafeToRemoveIdentity(const NodeDef& node) const {\n  if (!IsIdentity(node) && !IsIdentityN(node)) {\n    return true;\n  }\n  if (nodes_to_preserve_.find(node.name()) != nodes_to_preserve_.end()) {\n    return false;\n  }\n  if (!fetch_nodes_known_) {\n    return false;\n  }\n  if (node.input_size() < 1) {\n    return false;\n  }\n  const NodeDef* input = node_map_->GetNode(NodeName(node.input(0)));\n  CHECK(input != nullptr) << \"node = \" << node.name()\n                          << \" input = \" << node.input(0);\n  if (IsVariable(*input) || IsRecv(*input)) {\n    return false;\n  }\n  for (const auto& consumer : node_map_->GetOutputs(node.name())) {\n    if (node.input_size() > 1 && (IsRetval(*consumer) || IsMerge(*consumer))) {\n      return false;\n    }\n    if (IsSwitch(*input)) {\n      for (const string& consumer_input : consumer->input()) {\n        if (consumer_input == AsControlDependency(node.name())) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static MagickBooleanType load_tile(Image *image,Image *tile_image,\n  XCFDocInfo *inDocInfo,XCFLayerInfo *inLayerInfo,size_t data_length,\n  ExceptionInfo *exception)\n{\n  ssize_t\n    y;\n  register ssize_t\n    x;\n  register Quantum\n    *q;\n  ssize_t\n    count;\n  unsigned char\n    *graydata;\n  XCFPixelInfo\n    *xcfdata,\n    *xcfodata;\n  xcfdata=(XCFPixelInfo *) AcquireQuantumMemory(data_length,sizeof(*xcfdata));\n  if (xcfdata == (XCFPixelInfo *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  xcfodata=xcfdata;\n  graydata=(unsigned char *) xcfdata;  \n  count=ReadBlob(image,data_length,(unsigned char *) xcfdata);\n  if (count != (ssize_t) data_length)\n    ThrowBinaryException(CorruptImageError,\"NotEnoughPixelData\",\n      image->filename);\n  for (y=0; y < (ssize_t) tile_image->rows; y++)\n  {\n    q=GetAuthenticPixels(tile_image,0,y,tile_image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    if (inDocInfo->image_type == GIMP_GRAY)\n      {\n        for (x=0; x < (ssize_t) tile_image->columns; x++)\n        {\n          SetPixelGray(tile_image,ScaleCharToQuantum(*graydata),q);\n          SetPixelAlpha(tile_image,ScaleCharToQuantum((unsigned char)\n            inLayerInfo->alpha),q);\n          graydata++;\n          q+=GetPixelChannels(tile_image);\n        }\n      }\n    else\n      if (inDocInfo->image_type == GIMP_RGB)\n        {\n          for (x=0; x < (ssize_t) tile_image->columns; x++)\n          {\n            SetPixelRed(tile_image,ScaleCharToQuantum(xcfdata->red),q);\n            SetPixelGreen(tile_image,ScaleCharToQuantum(xcfdata->green),q);\n            SetPixelBlue(tile_image,ScaleCharToQuantum(xcfdata->blue),q);\n            SetPixelAlpha(tile_image,xcfdata->alpha == 255U ? TransparentAlpha :\n              ScaleCharToQuantum((unsigned char) inLayerInfo->alpha),q);\n            xcfdata++;\n            q+=GetPixelChannels(tile_image);\n          }\n        }\n     if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n       break;\n  }\n  xcfodata=(XCFPixelInfo *) RelinquishMagickMemory(xcfodata);\n  return MagickTrue;\n}", "target": 1}
{"code": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) \n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\tumount2(path, MNT_DETACH); \n\t\tgoto domount;\n\t}\n\treturn 0;\ndomount:\n\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}", "target": 1}
{"code": "static TEE_Result do_allocate_publickey(struct dsa_public_key *key,\n\t\t\t\t\tsize_t l_bits, size_t n_bits)\n{\n\tDSA_TRACE(\"DSA Allocate Public of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static int sdp_parse_fmtp_config_h264(AVFormatContext *s,\n                                      AVStream *stream,\n                                      PayloadContext *h264_data,\n                                      const char *attr, const char *value)\n{\n    AVCodecParameters *par = stream->codecpar;\n    if (!strcmp(attr, \"packetization-mode\")) {\n        av_log(s, AV_LOG_DEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value));\n        h264_data->packetization_mode = atoi(value);\n        if (h264_data->packetization_mode > 1)\n            av_log(s, AV_LOG_ERROR,\n                   \"Interleaved RTP mode is not supported yet.\\n\");\n    } else if (!strcmp(attr, \"profile-level-id\")) {\n        if (strlen(value) == 6)\n            parse_profile_level_id(s, h264_data, value);\n    } else if (!strcmp(attr, \"sprop-parameter-sets\")) {\n        int ret;\n        if (value[strlen(value) - 1] == ',') {\n            av_log(s, AV_LOG_WARNING, \"Missing PPS in sprop-parameter-sets, ignoring\\n\");\n            return 0;\n        }\n        par->extradata_size = 0;\n        av_freep(&par->extradata);\n        ret = ff_h264_parse_sprop_parameter_sets(s, &par->extradata,\n                                                 &par->extradata_size, value);\n        av_log(s, AV_LOG_DEBUG, \"Extradata set to %p (size: %d)\\n\",\n               par->extradata, par->extradata_size);\n        return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "bool generateV2Header(const Network::ProxyProtocolData& proxy_proto_data, Buffer::Instance& out,\n                      bool pass_all_tlvs, const absl::flat_hash_set<uint8_t>& pass_through_tlvs) {\n  uint64_t extension_length = 0;\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    extension_length += PROXY_PROTO_V2_TLV_TYPE_LENGTH_LEN + tlv.value.size();\n    if (extension_length > std::numeric_limits<uint16_t>::max()) {\n      ENVOY_LOG_MISC(\n          warn, \"Generating Proxy Protocol V2 header: TLVs exceed length limit {}, already got {}\",\n          std::numeric_limits<uint16_t>::max(), extension_length);\n      return false;\n    }\n  }\n  ASSERT(extension_length <= std::numeric_limits<uint16_t>::max());\n  if (proxy_proto_data.src_addr_ == nullptr || proxy_proto_data.src_addr_->ip() == nullptr) {\n    IS_ENVOY_BUG(\"Missing or incorrect source IP in proxy_proto_data_\");\n    return false;\n  }\n  if (proxy_proto_data.dst_addr_ == nullptr || proxy_proto_data.dst_addr_->ip() == nullptr) {\n    IS_ENVOY_BUG(\"Missing or incorrect dest IP in proxy_proto_data_\");\n    return false;\n  }\n  const auto& src = *proxy_proto_data.src_addr_->ip();\n  const auto& dst = *proxy_proto_data.dst_addr_->ip();\n  generateV2Header(src.addressAsString(), dst.addressAsString(), src.port(), dst.port(),\n                   src.version(), static_cast<uint16_t>(extension_length), out);\n  for (auto&& tlv : proxy_proto_data.tlv_vector_) {\n    if (!pass_all_tlvs && !pass_through_tlvs.contains(tlv.type)) {\n      continue;\n    }\n    out.add(&tlv.type, 1);\n    uint16_t size = htons(static_cast<uint16_t>(tlv.value.size()));\n    out.add(&size, sizeof(uint16_t));\n    out.add(&tlv.value.front(), tlv.value.size());\n  }\n  return true;\n}", "target": 0}
{"code": "irc_ctcp_dcc_filename_without_quotes (const char *filename)\n{\n    int length;\n    length = strlen (filename);\n    if (length > 0)\n    {\n        if ((filename[0] == '\\\"') && (filename[length - 1] == '\\\"'))\n            return weechat_strndup (filename + 1, length - 2);\n    }\n    return strdup (filename);\n}", "target": 1}
{"code": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\nout:\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}", "target": 1}
{"code": "gplotMakeOutput(GPLOT  *gplot)\n{\nchar     buf[L_BUF_SIZE];\nchar    *cmdname;\nl_int32  ignore;\n    PROCNAME(\"gplotMakeOutput\");\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    gplotGenCommandFile(gplot);\n    gplotGenDataFiles(gplot);\n    cmdname = genPathname(gplot->cmdname, NULL);\n#ifndef _WIN32\n    snprintf(buf, L_BUF_SIZE, \"gnuplot %s\", cmdname);\n#else\n    snprintf(buf, L_BUF_SIZE, \"wgnuplot %s\", cmdname);\n#endif  \n#ifndef OS_IOS \n    ignore = system(buf);  \n#endif \n    LEPT_FREE(cmdname);\n    return 0;\n}", "target": 1}
{"code": "String roamingUserSpecificStorageDirectory()\n{\n    return cachedStorageDirectory(CSIDL_APPDATA);\n}", "target": 0}
{"code": "MmkvHostObject::MmkvHostObject(const std::string& instanceId, std::string path,\n                               std::string cryptKey) {\n  __android_log_print(ANDROID_LOG_INFO, \"RNMMKV\",\n                      \"Creating MMKV instance \\\"%s\\\"... (Path: %s, Encryption-Key: %s)\",\n                      instanceId.c_str(), path.c_str(), cryptKey.c_str());\n  std::string* pathPtr = path.size() > 0 ? &path : nullptr;\n  std::string* cryptKeyPtr = cryptKey.size() > 0 ? &cryptKey : nullptr;\n  instance = MMKV::mmkvWithID(instanceId, mmkv::DEFAULT_MMAP_SIZE, MMKV_SINGLE_PROCESS, cryptKeyPtr,\n                              pathPtr);\n  if (instance == nullptr) {\n    if (instanceId.empty()) {\n      throw std::runtime_error(\"Failed to create MMKV instance! `id` cannot be empty!\");\n    }\n    if (cryptKey.size() > 16) {\n      throw std::runtime_error(\n          \"Failed to create MMKV instance! `encryptionKey` cannot be longer than 16 bytes!\");\n    }\n    throw std::runtime_error(\"Failed to create MMKV instance!\");\n  }\n}", "target": 1}
{"code": "int smb2_tree_disconnect(struct ksmbd_work *work)\n{\n\tstruct smb2_tree_disconnect_rsp *rsp = smb2_get_msg(work->response_buf);\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct ksmbd_tree_connect *tcon = work->tcon;\n\trsp->StructureSize = cpu_to_le16(4);\n\tinc_rfc1001_len(work->response_buf, 4);\n\tksmbd_debug(SMB, \"request\\n\");\n\tif (!tcon) {\n\t\tstruct smb2_tree_disconnect_req *req =\n\t\t\tsmb2_get_msg(work->request_buf);\n\t\tksmbd_debug(SMB, \"Invalid tid %d\\n\", req->hdr.Id.SyncId.TreeId);\n\t\trsp->hdr.Status = STATUS_NETWORK_NAME_DELETED;\n\t\tsmb2_set_err_rsp(work);\n\t\treturn 0;\n\t}\n\tksmbd_close_tree_conn_fds(work);\n\tksmbd_tree_conn_disconnect(sess, tcon);\n\twork->tcon = NULL;\n\treturn 0;\n}", "target": 0}
{"code": "static inline bool nested_cpu_has_pml(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_PML);\n}", "target": 0}
{"code": "QByteArray Cipher::blowfishECB(QByteArray cipherText, bool direction)\n{\n    QCA::Initializer init;\n    QByteArray temp = cipherText;\n    if (direction)\n    {\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    else\n    {\n        temp = b64ToByte(temp);\n        while ((temp.length() % 8) != 0) temp.append('\\0');\n    }\n    QCA::Direction dir = (direction) ? QCA::Encode : QCA::Decode;\n    QCA::Cipher cipher(m_type, QCA::Cipher::ECB, QCA::Cipher::NoPadding, dir, m_key);\n    QByteArray temp2 = cipher.update(QCA::MemoryRegion(temp)).toByteArray();\n    temp2 += cipher.final().toByteArray();\n    if (!cipher.ok())\n        return cipherText;\n    if (direction)\n        temp2 = byteToB64(temp2);\n    return temp2;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "void Huff_transmit (huff_t *huff, int ch, byte *fout) {\n\tint i;\n\tif (huff->loc[ch] == NULL) { \n\t\tHuff_transmit(huff, NYT, fout);\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tadd_bit((char)((ch >> i) & 0x1), fout);\n\t\t}\n\t} else {\n\t\tsend(huff->loc[ch], NULL, fout);\n\t}\n}", "target": 1}
{"code": "int IniParser::write()\n{\n    int bugs = 0;\n    if (!inifile.isDirty())\n    {\n        y2debug (\"File %s did not change. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    if (read_only)\n    {\n        y2debug (\"Attempt to write file %s that was mounted read-only. Not saving.\", multiple_files ? files[0].c_str () : file.c_str ());\n\treturn 0;\n    }\n    UpdateIfModif ();\n    if (multiple_files)\n    {\n\tIniIterator\n\t    ci = inifile.getContainerBegin (),\n\t    ce = inifile.getContainerEnd ();\n\tfor (;ci != ce; ++ci)\n\t    {\n\t\tif (ci->t () == SECTION)\n\t\t    {\n\t\t\tIniSection&s = ci->s ();\n\t\t\tint wb = s.getRewriteBy (); \n\t\t\tstring filename = getFileName (s.getName (), wb);\n\t\t\tdeleted_sections.erase (filename);\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\twrite_helper (inifile, of, 0);\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}", "target": 1}
{"code": "void RtmpProtocol::reset() {\n    _chunk_size_in = DEFAULT_CHUNK_LEN;\n    _chunk_size_out = DEFAULT_CHUNK_LEN;\n    _bytes_sent = 0;\n    _bytes_sent_last = 0;\n    _windows_size = 0;\n    _bandwidth = 2500000;\n    _band_limit_type = 2;\n    _map_chunk_data.clear();\n    _now_stream_index = 0;\n    _now_chunk_id = 0;\n    _send_req_id = 0;\n    HttpRequestSplitter::reset();\n    _stream_index = STREAM_CONTROL;\n    _next_step_func = [this](const char *data, size_t len) {\n        return handle_C0C1(data, len);\n    };\n}", "target": 0}
{"code": "static void bnx2x_hw_enable_status(struct bnx2x *bp)\n{\n\tu32 val;\n\tval = REG_RD(bp, CFC_REG_WEAK_ENABLE_PF);\n\tDP(BNX2X_MSG_SP, \"CFC_REG_WEAK_ENABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, PBF_REG_DISABLE_PF);\n\tDP(BNX2X_MSG_SP, \"PBF_REG_DISABLE_PF is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSI_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSI_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_EN);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_EN is 0x%x\\n\", val);\n\tval = REG_RD(bp, IGU_REG_PCI_PF_MSIX_FUNC_MASK);\n\tDP(BNX2X_MSG_SP, \"IGU_REG_PCI_PF_MSIX_FUNC_MASK is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_SHADOW_BME_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_FLR_REQUEST_PF_7_0_CLR is 0x%x\\n\", val);\n\tval = REG_RD(bp, PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER);\n\tDP(BNX2X_MSG_SP, \"PGLUE_B_REG_INTERNAL_PFID_ENABLE_MASTER is 0x%x\\n\",\n\t   val);\n}", "target": 0}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "static int selinux_inode_getsecurity(struct inode *inode, const char *name, void **buffer, bool alloc)\n{\n\tu32 size;\n\tint error;\n\tchar *context = NULL;\n\tstruct inode_security_struct *isec;\n\tif (strcmp(name, XATTR_SELINUX_SUFFIX))\n\t\treturn -EOPNOTSUPP;\n\tisec = inode_security(inode);\n\tif (has_cap_mac_admin(false))\n\t\terror = security_sid_to_context_force(&selinux_state,\n\t\t\t\t\t\t      isec->sid, &context,\n\t\t\t\t\t\t      &size);\n\telse\n\t\terror = security_sid_to_context(&selinux_state, isec->sid,\n\t\t\t\t\t\t&context, &size);\n\tif (error)\n\t\treturn error;\n\terror = size;\n\tif (alloc) {\n\t\t*buffer = context;\n\t\tgoto out_nofree;\n\t}\n\tkfree(context);\nout_nofree:\n\treturn error;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(4, context->num_inputs());\n    const Tensor& gradient = context->input(0);\n    const Tensor& input = context->input(1);\n    OP_REQUIRES(context, input.IsSameSize(gradient),\n                InvalidArgument(\"gradient and input must be the same size\"));\n    const Tensor& min = context->input(2);\n    const Tensor& max = context->input(3);\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(min.shape()),\n        InvalidArgument(\"`min` must be rank 0 but is rank \", min.dims()));\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsScalar(max.shape()),\n        InvalidArgument(\"`max` must be rank 0 but is rank \", max.dims()));\n    Tensor* grad_wrt_input;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &grad_wrt_input));\n    TensorShape scalar_shape;\n    Tensor* grad_wrt_min;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(1, scalar_shape, &grad_wrt_min));\n    Tensor* grad_wrt_max;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(2, scalar_shape, &grad_wrt_max));\n    FakeQuantWithMinMaxVarsGradientFunctor<Device> functor;\n    functor(context->eigen_device<Device>(), gradient.flat<float>(),\n            input.flat<float>(), min.scalar<float>(), max.scalar<float>(),\n            quant_min_, quant_max_, grad_wrt_input->flat<float>(),\n            grad_wrt_min->scalar<float>(), grad_wrt_max->scalar<float>());\n  }", "target": 0}
{"code": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_flags);\n\tadd_bool_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table, 0, &anope_flags_compat, true);\n\thook_add_event(\"nick_can_register\");\n\thook_add_nick_can_register(check_registration_keywords);\n\thook_add_event(\"user_can_register\");\n\thook_add_user_can_register(check_registration_keywords);\n}", "target": 0}
{"code": "YCPBoolean IniAgent::Write(const YCPPath &path, const YCPValue& value, const YCPValue& arg)\n{\n    if (!parser.isStarted())\n    {\n\ty2warning(\"Can't execute Write before being mounted.\");\n\treturn YCPBoolean (false);\n    }\n    bool ok = false; \n    YCPBoolean b (true);\n    if (0 == path->length ())\n    {\n\tif (value->isString() && value->asString()->value() == \"force\")\n\t    parser.inifile.setDirty();\n\telse if (value->isString () && value->asString()->value() == \"clean\")\n\t    parser.inifile.clean ();\n\tif (0 != parser.write ())\n\t    b = false;\n\tok = true;\n    }\n    else\n    {\n\tif (( parser.repeatNames () && value->isList ()) ||\n\t    (!parser.repeatNames () &&  (value->isString () || value->isInteger())) ||\n\t    path->component_str(0) == \"all\"\n\t    )\n\t    {\n\t\tok = true;\n\t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))\n\t\t    b = false;\n\t    }\n        else if (value->isVoid ())\n\t    {\n\t\tint wb  = -1;\n\t\tstring del_sec = \"\";\n\t\tok = true;\n\t\tif (2 == path->length ())\n\t\t{\n\t\t    string pc = path->component_str(0);\n\t\t    if (\"s\" == pc || \"section\" == pc)\n\t\t    {\t\n\t\t\tdel_sec = path->component_str (1);\n\t\t\twb = parser.inifile.getSubSectionRewriteBy (del_sec.c_str());\n\t\t    }\n\t\t}\n\t\tif (parser.inifile.Delete (path))\n\t\t    b = false;\n\t\telse if (del_sec != \"\")\n\t\t{\n\t\t    parser.deleted_sections.insert (parser.getFileName (del_sec, wb));\n\t\t}\n\t    }\n\telse\n\t{\n\t    ycp2error (\"Wrong value for path %s: %s\", path->toString ().c_str (), value->toString ().c_str ());\n\t    b = false;\n\t}\n    }\n    if (!ok)\n    {\n    \tycp2error ( \"Wrong path '%s' in Write().\", path->toString().c_str () );\n    }\n    return b;\n}", "target": 1}
{"code": "const RootWindow* RootWindow::GetRootWindow() const {\n  return this;\n}", "target": 0}
{"code": "int verify_compat_iovec(struct msghdr *kern_msg, struct iovec *kern_iov,\n\t\t   struct sockaddr_storage *kern_address, int mode)\n{\n\tint tot_len;\n\tif (kern_msg->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tint err = move_addr_to_kernel(kern_msg->msg_name,\n\t\t\t\t\t\t      kern_msg->msg_namelen,\n\t\t\t\t\t\t      kern_address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tkern_msg->msg_name = kern_address;\n\t} else\n\t\tkern_msg->msg_name = NULL;\n\ttot_len = iov_from_user_compat_to_kern(kern_iov,\n\t\t\t\t\t  (struct compat_iovec __user *)kern_msg->msg_iov,\n\t\t\t\t\t  kern_msg->msg_iovlen);\n\tif (tot_len >= 0)\n\t\tkern_msg->msg_iov = kern_iov;\n\treturn tot_len;\n}", "target": 1}
{"code": "cib_remote_connection_destroy(gpointer user_data)\n{\n    cib_client_t *client = user_data;\n    int csock = 0;\n    if (client == NULL) {\n        return;\n    }\n    crm_trace(\"Cleaning up after client disconnect: %s/%s\",\n              crm_str(client->name), client->id);\n    if (client->id != NULL) {\n        if (!g_hash_table_remove(client_list, client->id)) {\n            crm_err(\"Client %s not found in the hashtable\", client->name);\n        }\n    }\n    crm_trace(\"Destroying %s (%p)\", client->name, user_data);\n    num_clients--;\n    crm_trace(\"Num unfree'd clients: %d\", num_clients);\n    if (client->remote_auth_timeout) {\n        g_source_remove(client->remote_auth_timeout);\n    }\n    if (client->encrypted) {\n#ifdef HAVE_GNUTLS_GNUTLS_H\n        if (client->session) {\n            void *sock_ptr = gnutls_transport_get_ptr(*client->session);\n            csock = GPOINTER_TO_INT(sock_ptr);\n            if (client->handshake_complete) {\n                gnutls_bye(*client->session, GNUTLS_SHUT_WR);\n            }\n            gnutls_deinit(*client->session);\n            gnutls_free(client->session);\n        }\n#endif\n    } else {\n        csock = GPOINTER_TO_INT(client->session);\n    }\n    client->session = NULL;\n    if (csock > 0) {\n        close(csock);\n    }\n    free(client->name);\n    free(client->callback_id);\n    free(client->id);\n    free(client->user);\n    free(client->recv_buf);\n    free(client);\n    crm_trace(\"Freed the cib client\");\n    if (cib_shutdown_flag) {\n        cib_shutdown(0);\n    }\n    return;\n}", "target": 0}
{"code": "static BYTE get_cbr2_bpp(UINT32 bpp, BOOL* pValid)\n{\n\tif (pValid)\n\t\t*pValid = TRUE;\n\tswitch (bpp)\n\t{\n\t\tcase 3:\n\t\t\treturn 8;\n\t\tcase 4:\n\t\t\treturn 16;\n\t\tcase 5:\n\t\t\treturn 24;\n\t\tcase 6:\n\t\t\treturn 32;\n\t\tdefault:\n\t\t\tWLog_WARN(TAG, \"Invalid bpp %\" PRIu32, bpp);\n\t\t\tif (pValid)\n\t\t\t\t*pValid = FALSE;\n\t\t\treturn 0;\n\t}\n}", "target": 0}
{"code": "struct addr_t* MACH0_(get_entrypoint)(struct MACH0_(obj_t)* bin) {\n\tstruct addr_t *entry;\n\tint i;\n\tif (!bin->entry && !bin->sects) {\n\t\treturn NULL;\n\t}\n\tif (!(entry = calloc (1, sizeof (struct addr_t)))) {\n\t\treturn NULL;\n\t}\n\tif (bin->entry) {\n\t\tentry->addr = entry_to_vaddr (bin);\n\t\tentry->offset = addr_to_offset (bin, entry->addr);\n\t\tentry->haddr = sdb_num_get (bin->kv, \"mach0.entry.offset\", 0);\n\t}\n\tif (!bin->entry || entry->offset == 0) {\n\t\tfor (i = 0; i < bin->nsects; i++) {\n\t\t\tif (!strncmp (bin->sects[i].sectname, \"__text\", 6)) {\n\t\t\t\tentry->offset = (ut64)bin->sects[i].offset;\n\t\t\t\tsdb_num_set (bin->kv, \"mach0.entry\", entry->offset, 0);\n\t\t\t\tentry->addr = (ut64)bin->sects[i].addr;\n\t\t\t\tif (!entry->addr) { \n\t\t\t\t\tentry->addr = entry->offset;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbin->entry = entry->addr;\n\t}\n\treturn entry;\n}", "target": 1}
{"code": "script_autoload(\n    char_u\t*name,\n    int\t\treload)\t    \n{\n    char_u\t*p;\n    char_u\t*scriptname, *tofree;\n    int\t\tret = FALSE;\n    int\t\ti;\n    int\t\tret_sid;\n    p = vim_strchr(name, AUTOLOAD_CHAR);\n    if (p == NULL || p == name)\n\treturn FALSE;\n    tofree = scriptname = autoload_name(name);\n    if (scriptname == NULL)\n\treturn FALSE;\n    for (i = 0; i < ga_loaded.ga_len; ++i)\n\tif (STRCMP(((char_u **)ga_loaded.ga_data)[i] + 9, scriptname + 9) == 0)\n\t    break;\n    if (!reload && i < ga_loaded.ga_len)\n\tret = FALSE;\t    \n    else\n    {\n\tif (i == ga_loaded.ga_len && ga_grow(&ga_loaded, 1) == OK)\n\t{\n\t    ((char_u **)ga_loaded.ga_data)[ga_loaded.ga_len++] = scriptname;\n\t    tofree = NULL;\n\t}\n\tif (source_in_path(p_rtp, scriptname, DIP_START, &ret_sid) == OK)\n\t    ret = TRUE;\n    }\n    vim_free(tofree);\n    return ret;\n}", "target": 0}
{"code": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\treturn err;\n}", "target": 1}
{"code": "swap_until_sorted(struct delta_head *deltas, unsigned int i,\n    unsigned long min, unsigned long max)\n{\n\tunsigned int target_slot;\n\tstruct delta_head tmp;\n\twhile (true) {\n\t\tif (deltas[i].serial < min || max < deltas[i].serial) {\n\t\t\treturn pr_val_err(\"Deltas: Serial '%lu' is out of bounds. (min:%lu, max:%lu)\",\n\t\t\t    deltas[i].serial, min, max);\n\t\t}\n\t\ttarget_slot = deltas[i].serial - min;\n\t\tif (i == target_slot)\n\t\t\treturn 0;\n\t\tif (deltas[target_slot].serial == deltas[i].serial) {\n\t\t\treturn pr_val_err(\"Deltas: Serial '%lu' is not unique.\",\n\t\t\t    deltas[i].serial);\n\t\t}\n\t\ttmp = deltas[target_slot];\n\t\tdeltas[target_slot] = deltas[i];\n\t\tdeltas[i] = tmp;\n\t}\n}", "target": 0}
{"code": "static int _dns_encode_HTTPS(struct dns_context *context, struct dns_rrs *rrs)\n{\n\tint ret = 0;\n\tint qtype = 0;\n\tint qclass = 0;\n\tchar domain[DNS_MAX_CNAME_LEN];\n\tchar target[DNS_MAX_CNAME_LEN] = {0};\n\tunsigned char *rr_len_ptr = NULL;\n\tunsigned char *start = NULL;\n\tunsigned char *rr_start = NULL;\n\tint ttl = 0;\n\tint priority = 0;\n\tstruct dns_https_param *param = NULL;\n\tparam = dns_get_HTTPS_svcparm_start(rrs, domain, DNS_MAX_CNAME_LEN, &ttl, &priority, target, DNS_MAX_CNAME_LEN);\n\tif (param == NULL) {\n\t\ttlog(TLOG_ERROR, \"get https param failed.\");\n\t\treturn -1;\n\t}\n\tret = _dns_encode_rr_head(context, domain, qtype, qclass, ttl, 0, &rr_len_ptr);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\trr_start = context->ptr;\n\tif (_dns_left_len(context) < 2) {\n\t\ttlog(TLOG_ERROR, \"left len is invalid.\");\n\t\treturn -1;\n\t}\n\t_dns_write_short(&context->ptr, priority);\n\tret = _dns_encode_domain(context, target);\n\tif (ret < 0) {\n\t\treturn -1;\n\t}\n\tstart = context->ptr;\n\tfor (; param != NULL; param = dns_get_HTTPS_svcparm_next(rrs, param)) {\n\t\tif (context->ptr - start > rrs->len || _dns_left_len(context) <= 0) {\n\t\t\treturn -1;\n\t\t}\n\t\t_dns_write_short(&context->ptr, param->key);\n\t\t_dns_write_short(&context->ptr, param->len);\n\t\tswitch (param->key) {\n\t\tcase DNS_HTTPS_T_MANDATORY:\n\t\tcase DNS_HTTPS_T_NO_DEFAULT_ALPN:\n\t\tcase DNS_HTTPS_T_ALPN:\n\t\tcase DNS_HTTPS_T_PORT:\n\t\tcase DNS_HTTPS_T_IPV4HINT:\n\t\tcase DNS_HTTPS_T_ECH:\n\t\tcase DNS_HTTPS_T_IPV6HINT: {\n\t\t\tmemcpy(context->ptr, param->value, param->len);\n\t\t\tcontext->ptr += param->len;\n\t\t} break;\n\t\tdefault:\n\t\t\tcontext->ptr -= 4;\n\t\t\tbreak;\n\t\t}\n\t}\n\t_dns_write_short(&rr_len_ptr, context->ptr - rr_start);\n\treturn 0;\n}", "target": 1}
{"code": "static void prekey_handler(const char *userid,\n\t\t\t   const uint8_t *key, size_t key_len,\n\t\t\t   uint16_t id, const char *clientid,\n\t\t\t   bool last, void *arg)\n{\n\tstruct session *sess;\n\tchar lclientid[64];\n\tint err;\n\toutput(\"prekey_handler: %zu bytes, user:%s[%u] -> %s\\n\",\n\t       key_len, userid, id, clientid);\n\terr = client_id_load(lclientid, sizeof(lclientid));\n\tif (err) {\n\t\tdebug(\"my clientid not set -- cannot store prekeys\\n\");\n\t\treturn;\n\t}\n\tsess = cryptobox_session_find(g_cryptobox, userid, clientid, lclientid);\n\tif (sess) {\n\t\toutput(\"prekey: session found\\n\");\n\t}\n\telse {\n\t\tinfo(\"conv: adding key to cryptobox for clientid=%s\\n\",\n\t\t     clientid);\n\t\terr = cryptobox_session_add_send(g_cryptobox, userid, clientid, lclientid,\n\t\t\t\t\t\t key, key_len);\n\t\tif (err) {\n\t\t\twarning(\"cryptobox_session_add_send failed (%m)\\n\",\n\t\t\t\terr);\n\t\t}\n\t}\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictAvgPool(const OpContext& op_context,\n                                            NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n  int64_t ops = dims.batch * dims.ox * dims.oy * dims.oz * dims.kx * dims.ky;\n  node_costs->num_compute_ops = ops;\n  int64_t input_size;\n  if (dims.ky >= dims.sy) {\n    input_size = CalculateTensorSize(op_info.inputs(0), &found_unknown_shapes);\n  } else {  \n    const auto data_size = DataTypeSize(BaseType(op_info.inputs(0).dtype()));\n    input_size = data_size * dims.batch * dims.ix * dims.ky * dims.oy * dims.iz;\n  }\n  node_costs->num_input_bytes_accessed = {input_size};\n  const int64_t output_size =\n      CalculateOutputSize(op_info, &found_unknown_shapes);\n  node_costs->num_output_bytes_accessed = {output_size};\n  node_costs->max_memory = output_size;\n  if (found_unknown_shapes) {\n    node_costs->inaccurate = true;\n    node_costs->num_nodes_with_unknown_shapes = 1;\n  }\n  return Status::OK();\n}", "target": 1}
{"code": "SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)\n{\n\tint ufd;\n\tstruct timerfd_ctx *ctx;\n\tBUILD_BUG_ON(TFD_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON(TFD_NONBLOCK != O_NONBLOCK);\n\tif ((flags & ~TFD_CREATE_FLAGS) ||\n\t    (clockid != CLOCK_MONOTONIC &&\n\t     clockid != CLOCK_REALTIME &&\n\t     clockid != CLOCK_REALTIME_ALARM &&\n\t     clockid != CLOCK_BOOTTIME &&\n\t     clockid != CLOCK_BOOTTIME_ALARM))\n\t\treturn -EINVAL;\n\tif (!capable(CAP_WAKE_ALARM) &&\n\t    (clockid == CLOCK_REALTIME_ALARM ||\n\t     clockid == CLOCK_BOOTTIME_ALARM))\n\t\treturn -EPERM;\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\tinit_waitqueue_head(&ctx->wqh);\n\tspin_lock_init(&ctx->cancel_lock);\n\tctx->clockid = clockid;\n\tif (isalarm(ctx))\n\t\talarm_init(&ctx->t.alarm,\n\t\t\t   ctx->clockid == CLOCK_REALTIME_ALARM ?\n\t\t\t   ALARM_REALTIME : ALARM_BOOTTIME,\n\t\t\t   timerfd_alarmproc);\n\telse\n\t\thrtimer_init(&ctx->t.tmr, clockid, HRTIMER_MODE_ABS);\n\tctx->moffs = ktime_mono_to_real(0);\n\tufd = anon_inode_getfd(\"[timerfd]\", &timerfd_fops, ctx,\n\t\t\t       O_RDWR | (flags & TFD_SHARED_FCNTL_FLAGS));\n\tif (ufd < 0)\n\t\tkfree(ctx);\n\treturn ufd;\n}", "target": 0}
{"code": "static void ext4_end_io_work(struct work_struct *work)\n{\n\text4_io_end_t *io  = container_of(work, ext4_io_end_t, work);\n\tstruct inode *inode = io->inode;\n\tint ret = 0;\n\tmutex_lock(&inode->i_mutex);\n\tret = ext4_end_io_nolock(io);\n\tif (ret >= 0) {\n\t\tif (!list_empty(&io->list))\n\t\t\tlist_del_init(&io->list);\n\t\text4_free_io_end(io);\n\t}\n\tmutex_unlock(&inode->i_mutex);\n}", "target": 1}
{"code": "void RootWindow::SetHostSize(const gfx::Size& size_in_pixel) {\n  DispatchHeldMouseMove();\n  gfx::Rect bounds = host_->GetBounds();\n  bounds.set_size(size_in_pixel);\n  host_->SetBounds(bounds);\n  last_mouse_location_ =\n      ui::ConvertPointToDIP(layer(), host_->QueryMouseLocation());\n  synthesize_mouse_move_ = false;\n}", "target": 0}
{"code": "static inline int GetFirstGlobbingEntry(const std::vector<std::string>& dirs) {\n  int i = 0;\n  for (const auto& d : dirs) {\n    if (IsGlobbingPattern(d)) {\n      break;\n    }\n    i++;\n  }\n  return i;\n}", "target": 0}
{"code": "pci_emul_mem_handler(struct vmctx *ctx, int vcpu, int dir, uint64_t addr,\n\t\t     int size, uint64_t *val, void *arg1, long arg2)\n{\n\tstruct pci_vdev *pdi = arg1;\n\tstruct pci_vdev_ops *ops = pdi->dev_ops;\n\tuint64_t offset;\n\tint bidx = (int) arg2;\n\tassert(bidx <= PCI_BARMAX);\n\tassert(pdi->bar[bidx].type == PCIBAR_MEM32 ||\n\t       pdi->bar[bidx].type == PCIBAR_MEM64);\n\tassert(addr >= pdi->bar[bidx].addr &&\n\t       addr + size <= pdi->bar[bidx].addr + pdi->bar[bidx].size);\n\toffset = addr - pdi->bar[bidx].addr;\n\tif (dir == MEM_F_WRITE) {\n\t\tif (size == 8) {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   4, *val & 0xffffffff);\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset + 4,\n\t\t\t\t\t   4, *val >> 32);\n\t\t} else {\n\t\t\t(*ops->vdev_barwrite)(ctx, vcpu, pdi, bidx, offset,\n\t\t\t\t\t   size, bar_value(size, *val));\n\t\t}\n\t} else {\n\t\tif (size == 8) {\n\t\t\tuint64_t val_lo, val_hi;\n\t\t\tval_lo = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset, 4);\n\t\t\tval_lo = bar_value(4, val_lo);\n\t\t\tval_hi = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                              offset + 4, 4);\n\t\t\t*val = val_lo | (val_hi << 32);\n\t\t} else {\n\t\t\t*val = (*ops->vdev_barread)(ctx, vcpu, pdi, bidx,\n\t\t\t                            offset, size);\n\t\t\t*val = bar_value(size, *val);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "cib_send_tls(gnutls_session * session, xmlNode * msg)\n{\n    char *xml_text = NULL;\n#  if 0\n    const char *name = crm_element_name(msg);\n    if (safe_str_neq(name, \"cib_command\")) {\n        xmlNodeSetName(msg, \"cib_result\");\n    }\n#  endif\n    xml_text = dump_xml_unformatted(msg);\n    if (xml_text != NULL) {\n        char *unsent = xml_text;\n        int len = strlen(xml_text);\n        int rc = 0;\n        len++;                  \n        crm_trace(\"Message size: %d\", len);\n        while (TRUE) {\n            rc = gnutls_record_send(*session, unsent, len);\n            crm_debug(\"Sent %d bytes\", rc);\n            if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n                crm_debug(\"Retry\");\n            } else if (rc < 0) {\n                crm_debug(\"Connection terminated\");\n                break;\n            } else if (rc < len) {\n                crm_debug(\"Only sent %d of %d bytes\", rc, len);\n                len -= rc;\n                unsent += rc;\n            } else {\n                break;\n            }\n        }\n    }\n    free(xml_text);\n    return NULL;\n}", "target": 1}
{"code": "static void begin_read(TsHashTable *ht)\n{\n#ifdef ZTS\n\ttsrm_mutex_lock(ht->mx_reader);\n\tif ((++(ht->reader)) == 1) {\n\t\ttsrm_mutex_lock(ht->mx_writer);\n\t}\n\ttsrm_mutex_unlock(ht->mx_reader);\n#endif\n}", "target": 0}
{"code": "int sqliteAuthorizer(void* userData,\n                     int code,\n                     const char* arg3,\n                     const char* arg4,\n                     const char* arg5,\n                     const char* arg6) {\n  if (kAllowedSQLiteActionCodes.count(code) > 0) {\n    return SQLITE_OK;\n  }\n  LOG(ERROR) << \"Authorizer denied action \" << code << \" \"\n             << (arg3 ? arg3 : \"null\") << \" \" << (arg4 ? arg4 : \"null\") << \" \"\n             << (arg5 ? arg5 : \"null\") << \" \" << (arg6 ? arg6 : \"null\");\n  return SQLITE_DENY;\n}", "target": 0}
{"code": "bool PrintMsg_Print_Params_IsEqual(\n    const PrintMsg_PrintPages_Params& oldParams,\n    const PrintMsg_PrintPages_Params& newParams) {\n  return PageLayoutIsEqual(oldParams, newParams) &&\n         oldParams.params.max_shrink == newParams.params.max_shrink &&\n         oldParams.params.min_shrink == newParams.params.min_shrink &&\n         oldParams.params.selection_only == newParams.params.selection_only &&\n         oldParams.params.supports_alpha_blend ==\n             newParams.params.supports_alpha_blend &&\n         oldParams.pages.size() == newParams.pages.size() &&\n         oldParams.params.display_header_footer ==\n             newParams.params.display_header_footer &&\n         oldParams.params.date == newParams.params.date &&\n         oldParams.params.title == newParams.params.title &&\n         oldParams.params.url == newParams.params.url &&\n         std::equal(oldParams.pages.begin(), oldParams.pages.end(),\n             newParams.pages.begin());\n}", "target": 0}
{"code": "static int pvc_getname(struct socket *sock, struct sockaddr *sockaddr,\n\t\t       int *sockaddr_len, int peer)\n{\n\tstruct sockaddr_atmpvc *addr;\n\tstruct atm_vcc *vcc = ATM_SD(sock);\n\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\treturn -ENOTCONN;\n\t*sockaddr_len = sizeof(struct sockaddr_atmpvc);\n\taddr = (struct sockaddr_atmpvc *)sockaddr;\n\tmemset(addr, 0, sizeof(*addr));\n\taddr->sap_family = AF_ATMPVC;\n\taddr->sap_addr.itf = vcc->dev->number;\n\taddr->sap_addr.vpi = vcc->vpi;\n\taddr->sap_addr.vci = vcc->vci;\n\treturn 0;\n}", "target": 0}
{"code": "static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n\tconst char *p;\n\tchar *fileline;\n\tchar offset[SDB_NUM_BUFSZ];\n\tchar *offset_ptr;\n\tif (!s || !file) {\n\t\treturn;\n\t}\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tprint (\"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\toffset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}", "target": 1}
{"code": "static int vmx_cpu_uses_apicv(struct kvm_vcpu *vcpu)\n{\n\treturn enable_apicv && lapic_in_kernel(vcpu);\n}", "target": 0}
{"code": "void nego_process_negotiation_response(rdpNego* nego, wStream* s)\n{\n\tUINT16 length;\n\tWLog_DBG(TAG, \"RDP_NEG_RSP\");\n\tif (Stream_GetRemainingLength(s) < 7)\n\t{\n\t\tWLog_ERR(TAG, \"Invalid RDP_NEG_RSP\");\n\t\tnego->state = NEGO_STATE_FAIL;\n\t\treturn;\n\t}\n\tStream_Read_UINT8(s, nego->flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, nego->SelectedProtocol);\n\tnego->state = NEGO_STATE_FINAL;\n}", "target": 1}
{"code": "gx_fill_edgebuffer_app(gx_device       * pdev,\n                 const gx_device_color * pdevc,\n                       gx_edgebuffer   * edgebuffer,\n                       int               log_op)\n{\n    int i, code;\n    for (i=0; i < edgebuffer->height; i++) {\n        int *row    = &edgebuffer->table[edgebuffer->index[i]];\n        int  rowlen = *row++;\n        int  left, right;\n        while (rowlen > 0) {\n            left  = *row++;\n            right = *row++;\n            left  = fixed2int(left);\n            right = fixed2int(right + fixed_1 - 1);\n            rowlen -= 2;\n            right -= left;\n            if (right > 0) {\n                if (log_op < 0)\n                    code = dev_proc(pdev, fill_rectangle)(pdev, left, edgebuffer->base+i, right, 1, pdevc->colors.pure);\n                else\n                    code = gx_fill_rectangle_device_rop(left, edgebuffer->base+i, right, 1, pdevc, pdev, (gs_logical_operation_t)log_op);\n                if (code < 0)\n                    return code;\n            }\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "callbacks_new_project_activate (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tif (mainProject->last_loaded >= 0) {\n\t\tif (!interface_get_alert_dialog_response (\n\t\t\t_(\"Do you want to close any open layers \"\n\t\t\t\"and start a new project?\"),\n\t\t\t_(\"Starting a new project will cause all currently \"\n\t\t\t\"open layers to be closed. Any unsaved changes \"\n\t\t\t\"will be lost.\"),\n\t\t\tFALSE, NULL, GTK_STOCK_CLOSE, GTK_STOCK_CANCEL))\n\t\t\treturn;\n\t}\n\tgerbv_unload_all_layers (mainProject);\n\tcallbacks_update_layer_tree ();\n\tselection_clear (&screen.selectionInfo);\n\tupdate_selected_object_message (FALSE);\n\tif (mainProject->project) {\n\t    g_free(mainProject->project);\n\t    mainProject->project = NULL;\n\t}\n\trender_refresh_rendered_image_on_screen();\n}", "target": 0}
{"code": "    inline bool match(const EndpointSecurityAttributesMask remoteMask,\n        const PluginEndpointSecurityAttributesMask remotePluginMask) const\n    {\n        return security_mask_matches(mask(), remoteMask) &&\n            security_mask_matches(plugin_endpoint_attributes, remotePluginMask);\n    }", "target": 1}
{"code": "static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)\n{\n\tswitch (open_flags) {\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly++;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr++;\n\t}\n\tnfs4_state_set_mode_locked(state, state->state | open_flags);\n}", "target": 1}
{"code": "static int oidc_cache_crypto_encrypt_impl(request_rec *r,\n\t\tunsigned char *plaintext, int plaintext_len, const unsigned char *aad,\n\t\tint aad_len, unsigned char *key, const unsigned char *iv, int iv_len,\n\t\tunsigned char *ciphertext, const unsigned char *tag, int tag_len) {\n\tEVP_CIPHER_CTX *ctx;\n\tint len;\n\tint ciphertext_len;\n\tif (!(ctx = EVP_CIPHER_CTX_new())) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_new\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptInit_ex(ctx, OIDC_CACHE_CIPHER, NULL, NULL, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_SET_IVLEN, iv_len, NULL)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptInit_ex(ctx, NULL, NULL, key, iv)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptInit_ex\");\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptUpdate(ctx, NULL, &len, aad, aad_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_DecryptUpdate aad: aad_len=%d\",\n\t\t\t\taad_len);\n\t\treturn -1;\n\t}\n\tif (!EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptUpdate ciphertext\");\n\t\treturn -1;\n\t}\n\tciphertext_len = len;\n\tif (!EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_EncryptFinal_ex\");\n\t\treturn -1;\n\t}\n\tciphertext_len += len;\n\tif (!EVP_CIPHER_CTX_ctrl(ctx, OIDC_CACHE_CRYPTO_GET_TAG, tag_len,\n\t\t\t(void *) tag)) {\n\t\toidc_cache_crypto_openssl_error(r, \"EVP_CIPHER_CTX_ctrl\");\n\t\treturn -1;\n\t}\n\tEVP_CIPHER_CTX_free(ctx);\n\treturn ciphertext_len;\n}", "target": 1}
{"code": "TEE_Result crypto_acipher_alloc_dsa_keypair(struct dsa_keypair *s,\n\t\t\t\t\t    size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->x))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->y);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static int linkSane(FD_t wfd, const char *dest)\n{\n    struct stat sb, lsb;\n    return (fstat(Fileno(wfd), &sb) == 0 && sb.st_size == 0 &&\n\t    (sb.st_mode & ~S_IFMT) == S_IWUSR &&\n\t    lstat(dest, &lsb) == 0 && S_ISREG(lsb.st_mode) &&\n\t    sb.st_dev == lsb.st_dev && sb.st_ino == lsb.st_ino);\n}", "target": 0}
{"code": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\tvch->vrp = vrp;\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\treturn rpdev_ctrl;\n}", "target": 1}
{"code": "void PDFiumEngine::ScrollToPage(int page) {\n  in_flight_visible_page_ = page;\n  client_->ScrollToPage(page);\n}", "target": 0}
{"code": "test_copy_to (const char *from, const char *to)\n{\n  char buf[TESTBUFSIZE];\n  int ret;\n  snprintf_func (buf, TESTBUFSIZE, \"cp -f %s %s\", from, to);\n  if ((ret = system (buf)) != 0)\n    {\n      return XD3_INTERNAL;\n    }\n  return 0;\n}", "target": 0}
{"code": "static void gdCtxPrintf(gdIOCtx * out, const char *format, ...)\n{\n\tchar buf[4096];\n\tint len;\n\tva_list args;\n\tva_start(args, format);\n\tlen = vsnprintf(buf, sizeof(buf)-1, format, args);\n\tva_end(args);\n\tout->putBuf(out, buf, len);\n}", "target": 1}
{"code": "void *MACH0_(mach0_free)(struct MACH0_(obj_t) *mo) {\n\tif (!mo) {\n\t\treturn NULL;\n\t}\n\tsize_t i;\n\tif (mo->symbols) {\n\t\tfor (i = 0; !mo->symbols[i].last; i++) {\n\t\t\tfree (mo->symbols[i].name);\n\t\t}\n\t\tfree (mo->symbols);\n\t}\n\tfree (mo->segs);\n\tfree (mo->sects);\n\tfree (mo->symtab);\n\tfree (mo->symstr);\n\tfree (mo->indirectsyms);\n\tfree (mo->imports_by_ord);\n\tht_pp_free (mo->imports_by_name);\n\tfree (mo->dyld_info);\n\tfree (mo->toc);\n\tfree (mo->modtab);\n\tfree (mo->libs);\n\tfree (mo->func_start);\n\tfree (mo->signature);\n\tfree (mo->intrp);\n\tfree (mo->compiler);\n\tif (mo->chained_starts) {\n\t\tfor (i = 0; i < mo->nsegs; i++) {\n\t\t\tif (mo->chained_starts[i]) {\n\t\t\t\tfree (mo->chained_starts[i]->page_start);\n\t\t\t\tfree (mo->chained_starts[i]);\n\t\t\t}\n\t\t}\n\t\tfree (mo->chained_starts);\n\t}\n\tr_buf_free (mo->b);\n\tfree (mo);\n\treturn NULL;\n}", "target": 1}
{"code": "auth_line_is_valid (guint8 *line, guint8 *line_end)\n{\n  guint8 *p;\n  for (p = line; p < line_end; p++)\n    {\n      if (!_DBUS_ISASCII(*p))\n        return FALSE;\n      if (*p < ' ')\n        return FALSE;\n    }\n  if (line[0] < 'A' || line[0] > 'Z')\n    return FALSE;\n  return TRUE;\n}", "target": 0}
{"code": "void rose_start_idletimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->idletimer);\n\tif (rose->idle > 0) {\n\t\trose->idletimer.function = rose_idletimer_expiry;\n\t\trose->idletimer.expires  = jiffies + rose->idle;\n\t\tadd_timer(&rose->idletimer);\n\t}\n}", "target": 1}
{"code": "size_t _process_request_next_key(mcp_parser_t *pr) {\n    const char *cur = pr->request + pr->parsed;\n    int remain = pr->reqlen - pr->parsed - 2;\n    while (remain) {\n        if (*cur == ' ') {\n            remain--;\n            cur++;\n            pr->parsed++;\n        } else {\n            break;\n        }\n    }\n    const char *s = memchr(cur, ' ', remain);\n    if (s != NULL) {\n        pr->klen = s - cur;\n        pr->parsed += s - cur;\n    } else {\n        pr->klen = remain;\n        pr->parsed += remain;\n    }\n    return cur - pr->request;\n}", "target": 1}
{"code": "read_packet(int fd, gss_buffer_t buf, int timeout, int first)\n{\n\tint\t  ret;\n\tstatic uint32_t\t\tlen = 0;\n\tstatic char\t\tlen_buf[4];\n\tstatic int\t\tlen_buf_pos = 0;\n\tstatic char *\t\ttmpbuf = 0;\n\tstatic int\t\ttmpbuf_pos = 0;\n\tif (first) {\n\t\tlen_buf_pos = 0;\n\t\treturn -2;\n\t}\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\t\tif (ret == 0) {\t\t\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n\t\t}\n\t\tlen_buf_pos += ret;\n\t}\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\tlen = ntohl(*(uint32_t *)len_buf);\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n\t}\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n\t\t}\n\t}\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n\t}\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n\t}\n\ttmpbuf_pos += ret;\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\treturn -2;\n}", "target": 1}
{"code": "smbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\n\tint rc;\n\tunsigned char key2[8];\n\tstruct crypto_skcipher *tfm_des;\n\tstruct scatterlist sgin, sgout;\n\tstruct skcipher_request *req;\n\tstr_to_key(key, key2);\n\ttfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_des)) {\n\t\trc = PTR_ERR(tfm_des);\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_err;\n\t}\n\treq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_free_skcipher;\n\t}\n\tcrypto_skcipher_setkey(tfm_des, key2, 8);\n\tsg_init_one(&sgin, in, 8);\n\tsg_init_one(&sgout, out, 8);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\n\trc = crypto_skcipher_encrypt(req);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);\n\tskcipher_request_free(req);\nsmbhash_free_skcipher:\n\tcrypto_free_skcipher(tfm_des);\nsmbhash_err:\n\treturn rc;\n}", "target": 1}
{"code": "snmp_ber_encode_type(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  *out-- = type;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "ikev1_sig_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext, u_int item_len _U_,\n\t\tconst u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_SIG)));\n\treturn NULL;\n}", "target": 0}
{"code": "ldbm_txn_ruv_modify_context( Slapi_PBlock *pb, modify_context *mc )\n{\n    char *uniqueid = NULL;\n    backend *be;\n    Slapi_Mods *smods = NULL;\n    struct backentry *bentry;\n    entry_address bentry_addr;\n    IFP fn = NULL;\n    int rc = 0;\n    back_txn txn = {NULL};\n    slapi_pblock_get(pb, SLAPI_TXN_RUV_MODS_FN, (void *)&fn);\n    slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn);\n    if (NULL == fn) {\n        return (0);\n    }\n    rc = (*fn)(pb, &uniqueid, &smods);\n    if (1 != rc || NULL == smods || NULL == uniqueid) {\n        return (rc);\n    }\n    slapi_pblock_get( pb, SLAPI_BACKEND, &be);\n    bentry_addr.sdn = NULL;\n    bentry_addr.udn = NULL;\n    bentry_addr.uniqueid = uniqueid;\n    bentry = find_entry2modify_only( pb, be, &bentry_addr, &txn );\n    if (NULL == bentry) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to retrieve and lock RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        goto done;\n    }\n    modify_init( mc, bentry );\n    if (modify_apply_mods_ignore_error( mc, smods, LDAP_TYPE_OR_VALUE_EXISTS )) {\n        LDAPDebug( LDAP_DEBUG_ANY, \"Error: ldbm_txn_ruv_modify_context failed to apply updates to RUV entry\\n\",\n            0, 0, 0 );\n        rc = -1;\n        modify_term( mc, be );\n    }\ndone:\n    slapi_ch_free_string( &uniqueid );\n    return (rc);\n}", "target": 1}
{"code": "bool RenderWidgetHostImpl::GetResizeParams(ResizeParams* resize_params) {\n  *resize_params = ResizeParams();\n  GetWebScreenInfo(&resize_params->screen_info);\n  if (delegate_) {\n    resize_params->resizer_rect = delegate_->GetRootWindowResizerRect(this);\n    resize_params->is_fullscreen_granted =\n        delegate_->IsFullscreenForCurrentTab(this);\n    resize_params->display_mode = delegate_->GetDisplayMode(this);\n  } else {\n    resize_params->is_fullscreen_granted = false;\n    resize_params->display_mode = blink::WebDisplayModeBrowser;\n  }\n  if (view_) {\n    resize_params->new_size = view_->GetRequestedRendererSize();\n    resize_params->physical_backing_size = view_->GetPhysicalBackingSize();\n    resize_params->top_controls_height = view_->GetTopControlsHeight();\n    resize_params->top_controls_shrink_blink_size =\n        view_->DoTopControlsShrinkBlinkSize();\n    resize_params->visible_viewport_size = view_->GetVisibleViewportSize();\n  }\n  const bool size_changed =\n      !old_resize_params_ ||\n      old_resize_params_->new_size != resize_params->new_size ||\n      (old_resize_params_->physical_backing_size.IsEmpty() &&\n       !resize_params->physical_backing_size.IsEmpty());\n  bool dirty = size_changed ||\n      old_resize_params_->screen_info != resize_params->screen_info ||\n      old_resize_params_->physical_backing_size !=\n          resize_params->physical_backing_size ||\n      old_resize_params_->is_fullscreen_granted !=\n          resize_params->is_fullscreen_granted ||\n      old_resize_params_->display_mode != resize_params->display_mode ||\n      old_resize_params_->top_controls_height !=\n          resize_params->top_controls_height ||\n      old_resize_params_->top_controls_shrink_blink_size !=\n          resize_params->top_controls_shrink_blink_size ||\n      old_resize_params_->visible_viewport_size !=\n          resize_params->visible_viewport_size;\n  resize_params->needs_resize_ack =\n      g_check_for_pending_resize_ack && !resize_params->new_size.IsEmpty() &&\n      !resize_params->physical_backing_size.IsEmpty() && size_changed;\n  return dirty;\n}", "target": 0}
{"code": "TEST_F(HTTP2DownstreamSessionTest, TestDuplicateRequestStream) {\n  auto handler2 = addSimpleStrictHandler();\n  auto handler1 = addSimpleStrictHandler();\n  auto streamID1 = sendRequest(\"/withtrailers\", 0, false);\n  auto streamID2 = sendRequest();\n  HTTPHeaders trailers;\n  trailers.add(\"Foo\", \"Bar\");\n  clientCodec_->generateTrailers(requests_, streamID1, trailers);\n  clientCodec_->generateEOM(requests_, streamID1);\n  clientCodec_->generateHeader(requests_, streamID2, getGetRequest(), false);\n  handler1->expectHeaders();\n  handler2->expectHeaders();\n  handler2->expectEOM();\n  handler1->expectTrailers();\n  handler1->expectEOM([&] {\n      handler1->sendReplyWithBody(200, 100);\n      handler2->sendReplyWithBody(200, 100);\n    });\n  handler1->expectDetachTransaction();\n  handler2->expectDetachTransaction();\n  flushRequestsAndLoop();\n  gracefulShutdown();\n}", "target": 0}
{"code": "test_custom_handler(void **state)\n{\n    (void) state;\n    TSS2_RC_HANDLER old = Tss2_RC_SetHandler(1, \"cstm\", custom_err_handler);\n    assert_null(old);\n    unsigned i;\n    for (i = 1; i < 4; i++) {\n        TSS2_RC rc = TSS2_RC_LAYER(1) | i;\n        char buf[256];\n        snprintf(buf, sizeof(buf), \"cstm:error %u\", i);\n        const char *e = Tss2_RC_Decode(rc);\n        assert_string_equal(e, buf);\n    }\n    TSS2_RC rc = TSS2_RC_LAYER(1) | 42;\n    const char *e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"cstm:0x2A\");\n    old = Tss2_RC_SetHandler(1, \"cstm\", NULL);\n    assert_ptr_equal(old, custom_err_handler);\n    e = Tss2_RC_Decode(rc);\n    assert_string_equal(e, \"1:0x2A\");\n}", "target": 1}
{"code": "static void sas_revalidate_domain(struct work_struct *work)\n{\n\tint res = 0;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tstruct sas_ha_struct *ha = port->ha;\n\tstruct domain_device *ddev = port->port_dev;\n\tmutex_lock(&ha->disco_mutex);\n\tif (test_bit(SAS_HA_ATA_EH_ACTIVE, &ha->state)) {\n\t\tSAS_DPRINTK(\"REVALIDATION DEFERRED on port %d, pid:%d\\n\",\n\t\t\t    port->id, task_pid_nr(current));\n\t\tgoto out;\n\t}\n\tclear_bit(DISCE_REVALIDATE_DOMAIN, &port->disc.pending);\n\tSAS_DPRINTK(\"REVALIDATING DOMAIN on port %d, pid:%d\\n\", port->id,\n\t\t    task_pid_nr(current));\n\tif (ddev && (ddev->dev_type == SAS_FANOUT_EXPANDER_DEVICE ||\n\t\t     ddev->dev_type == SAS_EDGE_EXPANDER_DEVICE))\n\t\tres = sas_ex_revalidate_domain(ddev);\n\tSAS_DPRINTK(\"done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\\n\",\n\t\t    port->id, task_pid_nr(current), res);\n out:\n\tmutex_unlock(&ha->disco_mutex);\n\tsas_destruct_devices(port);\n\tsas_destruct_ports(port);\n\tsas_probe_devices(port);\n}", "target": 0}
{"code": "http_splitline(struct worker *w, int fd, struct http *hp,\n    const struct http_conn *htc, int h1, int h2, int h3)\n{\n\tchar *p, *q;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\tTcheck(htc->rxbuf);\n\tfor (p = htc->rxbuf.b ; vct_islws(*p); p++)\n\t\tcontinue;\n\tq = p;\n\tfor (; !vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\thp->hd[h1].b = q;\n\thp->hd[h1].e = p;\n\tfor (; vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\tq = p;\n\tfor (; !vct_islws(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\thp->hd[h2].b = q;\n\thp->hd[h2].e = p;\n\tif (!Tlen(hp->hd[h2]))\n\t\treturn (400);\n\tfor (; vct_issp(*p); p++) {\n\t\tif (vct_isctl(*p))\n\t\t\treturn (400);\n\t}\n\tq = p;\n\tif (!vct_iscrlf(*p)) {\n\t\tfor (; !vct_iscrlf(*p); p++)\n\t\t\tif (!vct_issep(*p) && vct_isctl(*p))\n\t\t\t\treturn (400);\n\t}\n\thp->hd[h3].b = q;\n\thp->hd[h3].e = p;\n\tp += vct_skipcrlf(p);\n\t*hp->hd[h1].e = '\\0';\n\tWSLH(w, fd, hp, h1);\n\t*hp->hd[h2].e = '\\0';\n\tWSLH(w, fd, hp, h2);\n\tif (hp->hd[h3].e != NULL) {\n\t\t*hp->hd[h3].e = '\\0';\n\t\tWSLH(w, fd, hp, h3);\n\t}\n\treturn (http_dissect_hdrs(w, hp, fd, p, htc));\n}", "target": 1}
{"code": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\t*r = -1;\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\tif (KVM_BUG_ON(!src, kvm)) {\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}", "target": 0}
{"code": "R_API char *r_cons_hud_line_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tr_str_ansi_strip (o);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud_line (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}", "target": 0}
{"code": "messageAddArgument(message *m, const char *arg)\n{\n\tint offset;\n\tchar *p;\n\tassert(m != NULL);\n\tif(arg == NULL)\n\t\treturn;\t\n\twhile(isspace(*arg))\n\t\targ++;\n\tif(*arg == '\\0')\n\t\treturn;\n\tcli_dbgmsg(\"messageAddArgument, arg='%s'\\n\", arg);\n\tif(!usefulArg(arg))\n\t\treturn;\n\tfor(offset = 0; offset < m->numberOfArguments; offset++)\n\t\tif(m->mimeArguments[offset] == NULL)\n\t\t\tbreak;\n\t\telse if(strcasecmp(arg, m->mimeArguments[offset]) == 0)\n\t\t\treturn;\t\n\tif(offset == m->numberOfArguments) {\n\t\tchar **q;\n\t\tm->numberOfArguments++;\n\t\tq = (char **)cli_realloc(m->mimeArguments, m->numberOfArguments * sizeof(char *));\n\t\tif(q == NULL) {\n\t\t\tm->numberOfArguments--;\n\t\t\treturn;\n\t\t}\n\t\tm->mimeArguments = q;\n\t}\n\tp = m->mimeArguments[offset] = rfc2231(arg);\n\tif(!p) {\n\t\tcli_dbgmsg(\"messageAddArgument, error from rfc2231()\\n\");\n\t\treturn;\n\t}\n\tif(strchr(p, '=') == NULL) {\n\t\tif(strncmp(p, \"filename\", 8) == 0) {\n\t\t\tcli_dbgmsg(\"Possible data corruption fixed\\n\");\n\t\t\tp[8] = '=';\n\t\t} else {\n\t\t\tif(*p)\n\t\t\t\tcli_dbgmsg(\"messageAddArgument, '%s' contains no '='\\n\", p);\n\t\t\tfree(m->mimeArguments[offset]);\n\t\t\tm->mimeArguments[offset] = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\tif((strncasecmp(p, \"filename=\", 9) == 0) || (strncasecmp(p, \"name=\", 5) == 0))\n\t\tif(messageGetMimeType(m) == NOMIME) {\n\t\t\tcli_dbgmsg(\"Force mime encoding to application\\n\");\n\t\t\tmessageSetMimeType(m, \"application\");\n\t\t}\n}", "target": 1}
{"code": "static int nested_vmx_check_permission(struct kvm_vcpu *vcpu)\n{\n\tif (vmx_get_cpl(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\tif (!to_vmx(vcpu)->nested.vmxon) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}", "target": 1}
{"code": "static void ext2_put_super (struct super_block * sb)\n{\n\tint db_count;\n\tint i;\n\tstruct ext2_sb_info *sbi = EXT2_SB(sb);\n\tdquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n\text2_xattr_put_super(sb);\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tstruct ext2_super_block *es = sbi->s_es;\n\t\tspin_lock(&sbi->s_lock);\n\t\tes->s_state = cpu_to_le16(sbi->s_mount_state);\n\t\tspin_unlock(&sbi->s_lock);\n\t\text2_sync_super(sb, es, 1);\n\t}\n\tdb_count = sbi->s_gdb_count;\n\tfor (i = 0; i < db_count; i++)\n\t\tif (sbi->s_group_desc[i])\n\t\t\tbrelse (sbi->s_group_desc[i]);\n\tkfree(sbi->s_group_desc);\n\tkfree(sbi->s_debts);\n\tpercpu_counter_destroy(&sbi->s_freeblocks_counter);\n\tpercpu_counter_destroy(&sbi->s_freeinodes_counter);\n\tpercpu_counter_destroy(&sbi->s_dirs_counter);\n\tbrelse (sbi->s_sbh);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi->s_blockgroup_lock);\n\tkfree(sbi);\n}", "target": 1}
{"code": "auth_line_is_begin (guint8 *line)\n{\n  guint8 next_char;\n  if (!g_str_has_prefix ((char *)line, AUTH_BEGIN))\n    return FALSE;\n  next_char = line[strlen (AUTH_BEGIN)];\n  return (next_char == 0 ||\n          next_char == ' ' ||\n          next_char == '\\t');\n}", "target": 0}
{"code": "static int em_sysenter(struct x86_emulate_ctxt *ctxt)\n{\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tstruct desc_struct cs, ss;\n\tu64 msr_data;\n\tu16 cs_sel, ss_sel;\n\tu64 efer = 0;\n\tops->get_msr(ctxt, MSR_EFER, &efer);\n\tif (ctxt->mode == X86EMUL_MODE_REAL)\n\t\treturn emulate_gp(ctxt, 0);\n\tif ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)\n\t    && !vendor_intel(ctxt))\n\t\treturn emulate_ud(ctxt);\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\tsetup_syscalls_segments(ctxt, &cs, &ss);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);\n\tswitch (ctxt->mode) {\n\tcase X86EMUL_MODE_PROT32:\n\t\tif ((msr_data & 0xfffc) == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT64:\n\t\tif (msr_data == 0x0)\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tctxt->eflags &= ~(EFLG_VM | EFLG_IF);\n\tcs_sel = (u16)msr_data;\n\tcs_sel &= ~SELECTOR_RPL_MASK;\n\tss_sel = cs_sel + 8;\n\tss_sel &= ~SELECTOR_RPL_MASK;\n\tif (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {\n\t\tcs.d = 0;\n\t\tcs.l = 1;\n\t}\n\tops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);\n\tops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);\n\tctxt->_eip = msr_data;\n\tops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);\n\t*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;\n\treturn X86EMUL_CONTINUE;\n}", "target": 1}
{"code": "static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,\n\t\t       struct in6_addr *addr, uint32_t *ifindex)\n{\n\tstruct sockaddr_in6 sin6;\n\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n\tstruct iovec iovec;\n\tstruct msghdr msghdr;\n\tstruct cmsghdr *cmsghdr;\n\tssize_t len;\n\tiovec.iov_len = *buflen;\n\tiovec.iov_base = buf;\n\tmemset(&msghdr, 0, sizeof(msghdr));\n\tmsghdr.msg_name = &sin6;\n\tmsghdr.msg_namelen = sizeof(sin6);\n\tmsghdr.msg_iov = &iovec;\n\tmsghdr.msg_iovlen = 1;\n\tmsghdr.msg_control = cbuf;\n\tmsghdr.msg_controllen = sizeof(cbuf);\n\tlen = recvmsg(sockfd, &msghdr, flags);\n\tif (len == -1)\n\t\treturn -errno;\n\t*buflen = len;\n\t*ifindex = sin6.sin6_scope_id;\n        for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;\n\t     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {\n\t\tif (cmsghdr->cmsg_level == IPPROTO_IPV6 &&\n\t\t    cmsghdr->cmsg_type == IPV6_PKTINFO &&\n\t\t    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\tstruct in6_pktinfo *pktinfo;\n\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);\n\t\t\t*ifindex = pktinfo->ipi6_ifindex;\n\t\t}\n\t}\n\t*addr = sin6.sin6_addr;\n\treturn 0;\n}", "target": 1}
{"code": "static inline bool _arq_scheduled(gnrc_sixlowpan_frag_fb_t *fbuf)\n{\n    evtimer_event_t *ptr = _arq_timer.events;\n    evtimer_event_t *event = &fbuf->sfr.arq_timeout_event.event;\n    while (ptr) {\n        if (ptr == event) {\n            return true;\n        }\n        ptr = ptr->next;\n    }\n    return false;\n}", "target": 0}
{"code": "  void setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n    san_matchers_ = san_matchers;\n  };", "target": 1}
{"code": "apr_byte_t oidc_enabled(request_rec *r) {\n\tif (ap_auth_type(r) == NULL)\n\t\treturn FALSE;\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_CONNECT) == 0)\n\t\treturn TRUE;\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_OAUTH20) == 0)\n\t\treturn TRUE;\n\tif (apr_strnatcasecmp((const char*) ap_auth_type(r),\n\t\t\tOIDC_AUTH_TYPE_OPENID_BOTH) == 0)\n\t\treturn TRUE;\n\treturn FALSE;\n}", "target": 0}
{"code": "batchInit(batch_t *pBatch, int maxElem) {\n\tDEFiRet;\n\tpBatch->iDoneUpTo = 0;\n\tpBatch->maxElem = maxElem;\n\tCHKmalloc(pBatch->pElem = calloc((size_t)maxElem, sizeof(batch_obj_t)));\nfinalize_it:\n\tRETiRet;\n}", "target": 0}
{"code": "sctp_disposition_t sctp_sf_ootb(struct net *net,\n\t\t\t\tconst struct sctp_endpoint *ep,\n\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\tconst sctp_subtype_t type,\n\t\t\t\tvoid *arg,\n\t\t\t\tsctp_cmd_seq_t *commands)\n{\n\tstruct sctp_chunk *chunk = arg;\n\tstruct sk_buff *skb = chunk->skb;\n\tsctp_chunkhdr_t *ch;\n\tsctp_errhdr_t *err;\n\t__u8 *ch_end;\n\tint ootb_shut_ack = 0;\n\tint ootb_cookie_ack = 0;\n\tSCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);\n\tch = (sctp_chunkhdr_t *) chunk->chunk_hdr;\n\tdo {\n\t\tif (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tif (SCTP_CID_SHUTDOWN_ACK == ch->type)\n\t\t\tootb_shut_ack = 1;\n\t\tif (SCTP_CID_ABORT == ch->type)\n\t\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\t\tif (SCTP_CID_COOKIE_ACK == ch->type)\n\t\t\tootb_cookie_ack = 1;\n\t\tif (SCTP_CID_ERROR == ch->type) {\n\t\t\tsctp_walk_errors(err, ch) {\n\t\t\t\tif (SCTP_ERROR_STALE_COOKIE == err->cause) {\n\t\t\t\t\tootb_cookie_ack = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));\n\t\tif (ch_end > skb_tail_pointer(skb))\n\t\t\treturn sctp_sf_violation_chunklen(net, ep, asoc, type, arg,\n\t\t\t\t\t\t  commands);\n\t\tch = (sctp_chunkhdr_t *) ch_end;\n\t} while (ch_end < skb_tail_pointer(skb));\n\tif (ootb_shut_ack)\n\t\treturn sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);\n\telse if (ootb_cookie_ack)\n\t\treturn sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);\n\telse\n\t\treturn sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);\n}", "target": 1}
{"code": "void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}", "target": 1}
{"code": "int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr)\n{\n\tstruct usb_descriptor_header *header;\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\t\tif (header->bLength < 2) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\t\tif (header->bDescriptorType == type) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}", "target": 1}
{"code": "void ciEnv::report_failure(const char* reason) {\n  EventCompilationFailure event;\n  if (event.should_commit()) {\n    CompilerEvent::CompilationFailureEvent::post(event, compile_id(), reason);\n  }\n}", "target": 0}
{"code": "void LinearAlgebraOp<InputScalar, OutputScalar>::PrepareOutputs(\n    OpKernelContext* context, const TensorShapes& input_matrix_shapes,\n    const TensorShape& batch_shape, TensorOutputs* outputs,\n    TensorShapes* output_matrix_shapes) {\n  *output_matrix_shapes = GetOutputMatrixShapes(input_matrix_shapes);\n  const int num_outputs = output_matrix_shapes->size();\n  OP_REQUIRES(\n      context, num_outputs <= context->num_outputs(),\n      errors::Internal(\n          \"Derived class expected more outputs (%d) that the op has (%d).\",\n          num_outputs, context->num_outputs()));\n  std::set<int> unused_inputs;\n  for (int input_idx = 0; input_idx < context->num_inputs(); ++input_idx) {\n    unused_inputs.insert(input_idx);\n  }\n  for (int output_idx = 0; output_idx < context->num_outputs(); ++output_idx) {\n    TensorShape output_tensor_shape({});\n    if (output_idx < num_outputs) {\n      const TensorShape& output_matrix_shape =\n          output_matrix_shapes->at(output_idx);\n      OP_REQUIRES(context, output_matrix_shape.dims() <= 2,\n                  errors::InvalidArgument(\n                      \"Rank of matrix output no. %d must be 0, 1 or 2, got %d.\",\n                      output_idx, output_matrix_shape.dims()));\n      output_tensor_shape = batch_shape;\n      output_tensor_shape.AppendShape(output_matrix_shape);\n    }\n    Tensor* out = nullptr;\n    bool reused_input = false;\n    if (EnableInputForwarding()) {\n      for (int input_idx : unused_inputs) {\n        if (context->forward_input_to_output_with_shape(\n                input_idx, output_idx, output_tensor_shape, &out)) {\n          reused_input = true;\n          unused_inputs.erase(input_idx);\n          break;\n        }\n      }\n    }\n    if (!reused_input) {\n      OP_REQUIRES_OK(context, context->allocate_output(\n                                  output_idx, output_tensor_shape, &out));\n    }\n    OP_REQUIRES(\n        context, out->dtype() == DataTypeToEnum<OutputScalar>::v(),\n        errors::InvalidArgument(\"Invalid output dtype \", out->dtype(), \" vs \",\n                                DataTypeToEnum<OutputScalar>::v()));\n    outputs->emplace_back(out);\n  }\n}", "target": 0}
{"code": "static __inline__ int scm_check_creds(struct ucred *creds)\n{\n\tconst struct cred *cred = current_cred();\n\tkuid_t uid = make_kuid(cred->user_ns, creds->uid);\n\tkgid_t gid = make_kgid(cred->user_ns, creds->gid);\n\tif (!uid_valid(uid) || !gid_valid(gid))\n\t\treturn -EINVAL;\n\tif ((creds->pid == task_tgid_vnr(current) ||\n\t     ns_capable(task_active_pid_ns(current)->user_ns, CAP_SYS_ADMIN)) &&\n\t    ((uid_eq(uid, cred->uid)   || uid_eq(uid, cred->euid) ||\n\t      uid_eq(uid, cred->suid)) || nsown_capable(CAP_SETUID)) &&\n\t    ((gid_eq(gid, cred->gid)   || gid_eq(gid, cred->egid) ||\n\t      gid_eq(gid, cred->sgid)) || nsown_capable(CAP_SETGID))) {\n\t       return 0;\n\t}\n\treturn -EPERM;\n}", "target": 0}
{"code": "bool all_tests () {\n\tmu_run_test (test_r_str_newf);\n\tmu_run_test (test_r_str_replace_char_once);\n\tmu_run_test (test_r_str_replace_char);\n\tmu_run_test (test_r_str_replace);\n\tmu_run_test (test_r_str_bits64);\n\tmu_run_test (test_r_str_rwx);\n\tmu_run_test (test_r_str_rwx_i);\n\tmu_run_test (test_r_str_bool);\n\tmu_run_test (test_r_str_trim);\n\tmu_run_test (test_r_str_case);\n\tmu_run_test (test_r_str_split);\n\tmu_run_test (test_r_str_tokenize);\n\tmu_run_test (test_r_str_char_count);\n\tmu_run_test (test_r_str_word_count);\n\tmu_run_test (test_r_str_ichr);\n\tmu_run_test (test_r_str_lchr);\n\tmu_run_test (test_r_sub_str_lchr);\n\tmu_run_test (test_r_sub_str_rchr);\n\tmu_run_test (test_r_str_rchr);\n\tmu_run_test (test_r_str_ansi_len);\n\tmu_run_test (test_r_str_len_utf8_ansi);\n\tmu_run_test (test_r_str_utf8_charsize);\n\tmu_run_test (test_r_str_utf8_charsize_prev);\n\tmu_run_test (test_r_str_sanitize_sdb_key);\n\tmu_run_test (test_r_str_escape_sh);\n\tmu_run_test (test_r_str_unescape);\n\tmu_run_test (test_r_str_constpool);\n\tmu_run_test (test_r_str_format_msvc_argv);\n\tmu_run_test (test_r_str_str_xy);\n\treturn tests_passed != tests_run;\n}", "target": 0}
{"code": "ref_stack_pop_block(ref_stack_t *pstack)\n{\n    s_ptr bot = pstack->bot;\n    uint count = pstack->p + 1 - bot;\n    ref_stack_block *pcur =\n    (ref_stack_block *) pstack->current.value.refs;\n    ref_stack_block *pnext =\n    (ref_stack_block *) pcur->next.value.refs;\n    uint used;\n    ref *body;\n    ref next;\n    if (pnext == 0)\n        return_error(pstack->params->underflow_error);\n    used = r_size(&pnext->used);\n    body = (ref *) (pnext + 1) + pstack->params->bot_guard;\n    next = pcur->next;\n    if (used + count > pstack->body_size) {\n        uint moved = pstack->body_size - count;\n        uint left;\n        if (moved == 0)\n            return_error(gs_error_Fatal);\n        memmove(bot + moved, bot, count * sizeof(ref));\n        left = used - moved;\n        memcpy(bot, body + left, moved * sizeof(ref));\n        refset_null_new(body + left, moved, 0);\n        r_dec_size(&pnext->used, moved);\n        pstack->p = pstack->top;\n        pstack->extension_used -= moved;\n    } else {\n        memcpy(body + used, bot, count * sizeof(ref));\n        pstack->bot = bot = body;\n        pstack->top = bot + pstack->body_size - 1;\n        gs_free_ref_array(pstack->memory, &pstack->current,\n                          \"ref_stack_pop_block\");\n        pstack->current = next;\n        pstack->p = bot + (used + count - 1);\n        pstack->extension_size -= pstack->body_size;\n        pstack->extension_used -= used;\n    }\n    return 0;\n}", "target": 0}
{"code": "void SetBackgroundColor(int par)\n{\n    if ( par == STROKING ) { outpos += sprintf(outpos,\" 0 0 0 0 K\"); }\n    else                   { outpos += sprintf(outpos,\" 0 0 0 0 k\"); }\n}", "target": 1}
{"code": "*/\nPHP_METHOD(DateTimeImmutable, __set_state)\n{\n\tphp_date_obj     *dateobj;\n\tzval             *array;\n\tHashTable        *myht;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a\", &array) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tmyht = HASH_OF(array);\n\tphp_date_instantiate(date_ce_immutable, return_value TSRMLS_CC);\n\tdateobj = (php_date_obj *) zend_object_store_get_object(return_value TSRMLS_CC);\n\tif (!php_date_initialize_from_hash(&dateobj, myht TSRMLS_CC)) {\n\t\tphp_error(E_ERROR, \"Invalid serialization data for DateTimeImmutable object\");\n\t}", "target": 0}
{"code": "static int pfkey_add(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\tx = pfkey_msg2xfrm_state(net, hdr, ext_hdrs);\n\tif (IS_ERR(x))\n\t\treturn PTR_ERR(x);\n\txfrm_state_hold(x);\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\txfrm_audit_state_add(x, err ? 0 : 1, true);\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\tif (hdr->sadb_msg_type == SADB_ADD)\n\t\tc.event = XFRM_MSG_NEWSA;\n\telse\n\t\tc.event = XFRM_MSG_UPDSA;\n\tc.seq = hdr->sadb_msg_seq;\n\tc.portid = hdr->sadb_msg_pid;\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}", "target": 0}
{"code": "stack_param_list_read(stack_param_list * plist, ref_stack_t * pstack,\n                      uint skip, const ref * ppolicies, bool require_all,\n                      gs_ref_memory_t *imem)\n{\n    iparam_list *const iplist = (iparam_list *) plist;\n    uint count = ref_stack_counttomark(pstack);\n    if (count == 0)\n        return_error(gs_error_unmatchedmark);\n    count -= skip + 1;\n    if (count & 1)\n        return_error(gs_error_rangecheck);\n    plist->u.r.read = stack_param_read;\n    plist->enumerate = stack_param_enumerate;\n    plist->pstack = pstack;\n    plist->skip = skip;\n    return ref_param_read_init(iplist, count >> 1, ppolicies, require_all, imem);\n}", "target": 0}
{"code": "  inline void init (hb_face_t *face,\n\t\t    hb_tag_t _hea_tag, hb_tag_t _mtx_tag,\n\t\t    unsigned int default_advance_)\n  {\n    this->default_advance = default_advance_;\n    this->num_metrics = face->get_num_glyphs ();\n    hb_blob_t *_hea_blob = OT::Sanitizer<OT::_hea>::sanitize (face->reference_table (_hea_tag));\n    const OT::_hea *_hea = OT::Sanitizer<OT::_hea>::lock_instance (_hea_blob);\n    this->num_advances = _hea->numberOfLongMetrics;\n    hb_blob_destroy (_hea_blob);\n    this->blob = OT::Sanitizer<OT::_mtx>::sanitize (face->reference_table (_mtx_tag));\n    if (unlikely (!this->num_advances ||\n\t\t  2 * (this->num_advances + this->num_metrics) < hb_blob_get_length (this->blob)))\n    {\n      this->num_metrics = this->num_advances = 0;\n      hb_blob_destroy (this->blob);\n      this->blob = hb_blob_get_empty ();\n    }\n    this->table = OT::Sanitizer<OT::_mtx>::lock_instance (this->blob);\n  }", "target": 1}
{"code": "void ip4_datagram_release_cb(struct sock *sk)\n{\n\tconst struct inet_sock *inet = inet_sk(sk);\n\tconst struct ip_options_rcu *inet_opt;\n\t__be32 daddr = inet->inet_daddr;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tif (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))\n\t\treturn;\n\trcu_read_lock();\n\tinet_opt = rcu_dereference(inet->inet_opt);\n\tif (inet_opt && inet_opt->opt.srr)\n\t\tdaddr = inet_opt->opt.faddr;\n\trt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,\n\t\t\t\t   inet->inet_saddr, inet->inet_dport,\n\t\t\t\t   inet->inet_sport, sk->sk_protocol,\n\t\t\t\t   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);\n\tif (!IS_ERR(rt))\n\t\t__sk_dst_set(sk, &rt->dst);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "ExprResolveGroup(struct xkb_context *ctx, const ExprDef *expr,\n                 xkb_layout_index_t *group_rtrn)\n{\n    bool ok;\n    int result;\n    ok = ExprResolveIntegerLookup(ctx, expr, &result, SimpleLookup,\n                                  groupNames);\n    if (!ok)\n        return false;\n    if (result <= 0 || result > XKB_MAX_GROUPS) {\n        log_err(ctx, \"Group index %u is out of range (1..%d)\\n\",\n                result, XKB_MAX_GROUPS);\n        return false;\n    }\n    *group_rtrn = (xkb_layout_index_t) result;\n    return true;\n}", "target": 0}
{"code": "static int do_i2c_write(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t\tchar *const argv[])\n{\n\tuint\tchip;\n\tuint\tdevaddr, length;\n\tint alen;\n\tu_char  *memaddr;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n\tstruct dm_i2c_chip *i2c_chip;\n#endif\n\tif ((argc < 5) || (argc > 6))\n\t\treturn cmd_usage(cmdtp);\n\tmemaddr = (u_char *)hextoul(argv[1], NULL);\n\tchip = hextoul(argv[2], NULL);\n\tdevaddr = hextoul(argv[3], NULL);\n\talen = get_alen(argv[3], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn cmd_usage(cmdtp);\n\tlength = hextoul(argv[4], NULL);\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\ti2c_chip = dev_get_parent_plat(dev);\n\tif (!i2c_chip)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tif (argc == 6 && !strcmp(argv[5], \"-s\")) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\ti2c_chip->flags &= ~DM_I2C_CHIP_WR_ADDRESS;\n\t\tret = dm_i2c_write(dev, devaddr, memaddr, length);\n#else\n\t\tret = i2c_write(chip, devaddr, alen, memaddr, length);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n\t} else {\n\t\twhile (length-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\t\ti2c_chip->flags |= DM_I2C_CHIP_WR_ADDRESS;\n\t\t\tret = dm_i2c_write(dev, devaddr++, memaddr++, 1);\n#else\n\t\t\tret = i2c_write(chip, devaddr++, alen, memaddr++, 1);\n#endif\n\t\t\tif (ret)\n\t\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\t\tudelay(11000);\n#endif\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "static int ext4_dax_pmd_fault(struct vm_area_struct *vma, unsigned long addr,\n\t\t\t\t\t\tpmd_t *pmd, unsigned int flags)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_chunk_trans_blocks(inode,\n\t\t\t\t\t\t\tPMD_SIZE / PAGE_SIZE));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_pmd_fault(vma, addr, pmd, flags,\n\t\t\t\text4_get_block_dax, ext4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "void inet6_destroy_sock(struct sock *sk)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sk_buff *skb;\n\tstruct ipv6_txoptions *opt;\n\tskb = xchg(&np->pktoptions, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\tskb = xchg(&np->rxpmtu, NULL);\n\tif (skb)\n\t\tkfree_skb(skb);\n\tfl6_free_socklist(sk);\n\topt = xchg(&np->opt, NULL);\n\tif (opt)\n\t\tsock_kfree_s(sk, opt, opt->tot_len);\n}", "target": 1}
{"code": "void ArrowHead()\n{\n    int k;\n    double length;\n    SaveGraphicsState;\n    if ( flip ) length = -arrow.length;\n    else        length =  arrow.length;\n    SetDashSize(0,0);\n    if ( arrow.stroke ) {\n        SetLineWidth(arrow.stroke);\n        for (k = 1; k <= 2; k++ ) {\n            SaveGraphicsState;\n            MoveTo(length*0.5,0);\n            LineTo(-length*0.5,arrow.width);\n            LineTo(-length*0.5+length*arrow.inset,0);\n            LineTo(-length*0.5,-arrow.width);\n            if (k == 1) {\n                SetBackgroundColor(NONSTROKING);\n                outpos += sprintf(outpos,\" h f\");\n            }\n            else {\n                outpos += sprintf(outpos,\" s\");\n            }\n            RestoreGraphicsState;\n        }\n    }\n    else {\n        MoveTo(length*0.5,0);\n        LineTo(-length*0.5,arrow.width);\n        LineTo(-length*0.5+length*arrow.inset,0);\n        LineTo(-length*0.5,-arrow.width);\n        outpos += sprintf(outpos,\" h f\");\n    }\n    RestoreGraphicsState;\n}", "target": 1}
{"code": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n  flash_clear_status_flags();\n  flash_unlock();\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;\n  flash_wait_for_last_operation();\n  FLASH_CR &= ~FLASH_CR_PG;\n  FLASH_CR |= FLASH_CR_LOCK;\n}", "target": 1}
{"code": "static int __init acpi_os_name_setup(char *str)\n{\n\tchar *p = acpi_os_name;\n\tint count = ACPI_MAX_OVERRIDE_LEN - 1;\n\tif (!str || !*str)\n\t\treturn 0;\n\tfor (; count-- && *str; str++) {\n\t\tif (isalnum(*str) || *str == ' ' || *str == ':')\n\t\t\t*p++ = *str;\n\t\telse if (*str == '\\'' || *str == '\"')\n\t\t\tcontinue;\n\t\telse\n\t\t\tbreak;\n\t}\n\t*p = 0;\n\treturn 1;\n}", "target": 0}
{"code": "build_unc_path_to_root(const struct smb_vol *vol,\n\t\tconst struct cifs_sb_info *cifs_sb)\n{\n\tchar *full_path, *pos;\n\tunsigned int pplen = vol->prepath ? strlen(vol->prepath) + 1 : 0;\n\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\t*pos = '\\0'; \n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}", "target": 1}
{"code": "  RectangleRequest &operator=(const struct RectangleRequest &req)\n  { \n    memcpy(this,&req,sizeof(struct RectangleRequest));\n    rr_pNext = NULL;\n    return *this;\n  }", "target": 1}
{"code": "static void *bpf_obj_do_get(const struct filename *pathname,\n\t\t\t    enum bpf_type *type)\n{\n\tstruct inode *inode;\n\tstruct path path;\n\tvoid *raw;\n\tint ret;\n\tret = kern_path(pathname->name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}", "target": 1}
{"code": "find_cleartext_device (Device *device)\n{\n  GList *devices;\n  GList *l;\n  Device *ret;\n  ret = NULL;\n  devices = daemon_local_get_all_devices (device->priv->daemon);\n  for (l = devices; l != NULL; l = l->next)\n    {\n      Device *d = DEVICE (l->data);\n      if (d->priv->device_is_luks_cleartext && d->priv->luks_cleartext_slave != NULL\n          && strcmp (d->priv->luks_cleartext_slave, device->priv->object_path) == 0)\n        {\n          ret = d;\n          goto out;\n        }\n    }\n out:\n  g_list_free (devices);\n  return ret;\n}", "target": 0}
{"code": "void AverageEvalFloat(TfLiteContext* context, TfLiteNode* node,\n                      TfLitePoolParams* params, OpData* data,\n                      const TfLiteTensor* input, TfLiteTensor* output) {\n  float activation_min, activation_max;\n  CalculateActivationRange(params->activation, &activation_min,\n                           &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                       \\\n  tflite::PoolParams op_params;                                          \\\n  op_params.stride_height = params->stride_height;                       \\\n  op_params.stride_width = params->stride_width;                         \\\n  op_params.filter_height = params->filter_height;                       \\\n  op_params.filter_width = params->filter_width;                         \\\n  op_params.padding_values.height = data->padding.height;                \\\n  op_params.padding_values.width = data->padding.width;                  \\\n  op_params.float_activation_min = activation_min;                       \\\n  op_params.float_activation_max = activation_max;                       \\\n  type::AveragePool(op_params, GetTensorShape(input),                    \\\n                    GetTensorData<float>(input), GetTensorShape(output), \\\n                    GetTensorData<float>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}", "target": 1}
{"code": "static int bnx2x_get_cmng_fns_mode(struct bnx2x *bp)\n{\n\tif (CHIP_REV_IS_SLOW(bp))\n\t\treturn CMNG_FNS_NONE;\n\tif (IS_MF(bp))\n\t\treturn CMNG_FNS_MINMAX;\n\treturn CMNG_FNS_NONE;\n}", "target": 0}
{"code": "int btrfs_check_dir_item_collision(struct btrfs_root *root, u64 dir,\n\t\t\t\t   const char *name, int name_len)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tstruct btrfs_dir_item *di;\n\tint data_size;\n\tstruct extent_buffer *leaf;\n\tint slot;\n\tstruct btrfs_path *path;\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tkey.objectid = dir;\n\tbtrfs_set_key_type(&key, BTRFS_DIR_ITEM_KEY);\n\tkey.offset = btrfs_name_hash(name, name_len);\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tdi = btrfs_match_dir_item_name(root, path, name, name_len);\n\tif (di) {\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\tdata_size = sizeof(*di) + name_len + sizeof(struct btrfs_item);\n\tleaf = path->nodes[0];\n\tslot = path->slots[0];\n\tif (data_size + btrfs_item_size_nr(leaf, slot) +\n\t    sizeof(struct btrfs_item) > BTRFS_LEAF_DATA_SIZE(root)) {\n\t\tret = -EOVERFLOW;\n\t} else {\n\t\tret = 0;\n\t}\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}", "target": 0}
{"code": "static int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tint r, alt;\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn 0;\n\tr = uas_find_endpoints(&intf->altsetting[alt], eps);\n\tif (r < 0)\n\t\treturn 0;\n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\tusb_stor_adjust_quirks(udev, &flags);\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is blacklisted for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\treturn 1;\n}", "target": 1}
{"code": "TEST_IMPL(utf8_decode1_overrun) {\n  const char* p;\n  char b[1];\n  char c[1];\n  p = b;\n  b[0] = 0x7F;\n  ASSERT_EQ(0x7F, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  p = b;\n  b[0] = 0xC0;\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  b[0] = 0x7F;\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 0, c, c + 1));\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n  return 0;\n}", "target": 0}
{"code": "int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint error;\n\tint len;\n\tchar *data;\n\tconst char *name = gfs2_acl_name(type);\n\tif (acl && acl->a_count > GFS2_ACL_MAX_ENTRIES(GFS2_SB(inode)))\n\t\treturn -E2BIG;\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t\tif (error == 0)\n\t\t\tacl = NULL;\n\t\tif (mode != inode->i_mode) {\n\t\t\tinode->i_mode = mode;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t}\n\tif (acl) {\n\t\tlen = posix_acl_to_xattr(&init_user_ns, acl, NULL, 0);\n\t\tif (len == 0)\n\t\t\treturn 0;\n\t\tdata = kmalloc(len, GFP_NOFS);\n\t\tif (data == NULL)\n\t\t\treturn -ENOMEM;\n\t\terror = posix_acl_to_xattr(&init_user_ns, acl, data, len);\n\t\tif (error < 0)\n\t\t\tgoto out;\n\t} else {\n\t\tdata = NULL;\n\t\tlen = 0;\n\t}\n\terror = __gfs2_xattr_set(inode, name, data, len, 0, GFS2_EATYPE_SYS);\n\tif (error)\n\t\tgoto out;\n\tset_cached_acl(inode, type, acl);\nout:\n\tkfree(data);\n\treturn error;\n}", "target": 1}
{"code": "void test_lchown(const char *path)\n{\n\tif (lchown(path, 0, 0) == 0) {\n\t\tfprintf(stderr, \"leak at lchown of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at lchown of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "gx_dc_pattern2_clip_with_bbox_simple(const gx_device_color * pdevc, gx_device * pdev,\n                              gx_clip_path *cpath_local)\n{\n    int code = 0;\n    if (gx_dc_is_pattern2_color(pdevc) && gx_dc_pattern2_color_has_bbox(pdevc) &&\n            (*dev_proc(pdev, dev_spec_op))(pdev, gxdso_pattern_shading_area, NULL, 0) == 0) {\n        gs_pattern2_instance_t *pinst = (gs_pattern2_instance_t *)pdevc->ccolor.pattern;\n        gx_path box_path;\n        gs_memory_t *mem = cpath_local->path.memory;\n        gx_path_init_local(&box_path, mem);\n        code = gx_dc_shading_path_add_box(&box_path, pdevc);\n        if (code == gs_error_limitcheck) {\n            code = 0;\n        } else if (code >= 0) {\n            code = gx_cpath_intersect(cpath_local, &box_path, gx_rule_winding_number, (gs_gstate *)pinst->saved);\n        }\n        gx_path_free(&box_path, \"gx_default_fill_path(path_bbox)\");\n    }\n    return code;\n}", "target": 0}
{"code": "bit_catenate(VarBit *arg1, VarBit *arg2)\n{\n\tVarBit\t   *result;\n\tint\t\t\tbitlen1,\n\t\t\t\tbitlen2,\n\t\t\t\tbytelen,\n\t\t\t\tbit1pad,\n\t\t\t\tbit2shift;\n\tbits8\t   *pr,\n\t\t\t   *pa;\n\tbitlen1 = VARBITLEN(arg1);\n\tbitlen2 = VARBITLEN(arg2);\n\tif (bitlen1 > VARBITMAXLEN - bitlen2)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\tbytelen = VARBITTOTALLEN(bitlen1 + bitlen2);\n\tresult = (VarBit *) palloc(bytelen);\n\tSET_VARSIZE(result, bytelen);\n\tVARBITLEN(result) = bitlen1 + bitlen2;\n\tmemcpy(VARBITS(result), VARBITS(arg1), VARBITBYTES(arg1));\n\tbit1pad = VARBITPAD(arg1);\n\tif (bit1pad == 0)\n\t{\n\t\tmemcpy(VARBITS(result) + VARBITBYTES(arg1), VARBITS(arg2),\n\t\t\t   VARBITBYTES(arg2));\n\t}\n\telse if (bitlen2 > 0)\n\t{\n\t\tbit2shift = BITS_PER_BYTE - bit1pad;\n\t\tpr = VARBITS(result) + VARBITBYTES(arg1) - 1;\n\t\tfor (pa = VARBITS(arg2); pa < VARBITEND(arg2); pa++)\n\t\t{\n\t\t\t*pr |= ((*pa >> bit2shift) & BITMASK);\n\t\t\tpr++;\n\t\t\tif (pr < VARBITEND(result))\n\t\t\t\t*pr = (*pa << bit1pad) & BITMASK;\n\t\t}\n\t}\n\treturn result;\n}", "target": 0}
{"code": "unset_nonblock(int fd)\n{\n\tint val;\n\tval = fcntl(fd, F_GETFL);\n\tif (val == -1) {\n\t\terror(\"fcntl(%d, F_GETFL): %s\", fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\tif (!(val & O_NONBLOCK)) {\n\t\tdebug3(\"fd %d is not O_NONBLOCK\", fd);\n\t\treturn (0);\n\t}\n\tdebug(\"fd %d clearing O_NONBLOCK\", fd);\n\tval &= ~O_NONBLOCK;\n\tif (fcntl(fd, F_SETFL, val) == -1) {\n\t\tdebug(\"fcntl(%d, F_SETFL, ~O_NONBLOCK): %s\",\n\t\t    fd, strerror(errno));\n\t\treturn (-1);\n\t}\n\treturn (0);\n}", "target": 0}
{"code": "set_umask(const char *optarg)\n{\n\tlong umask_long;\n\tmode_t umask_val;\n\tchar *endptr;\n\tumask_long = strtoll(optarg, &endptr, 0);\n\tif (*endptr || umask_long < 0 || umask_long & ~0777L) {\n\t\tfprintf(stderr, \"Invalid --umask option %s\", optarg);\n\t\treturn 0;\n\t}\n\tumask_val = umask_long & 0777;\n\tumask(umask_val);\n\tumask_cmdline = true;\n\treturn umask_val;\n}", "target": 0}
{"code": "strncat_from_utf8_libarchive2(struct archive_string *as,\n    const void *_p, size_t len, struct archive_string_conv *sc)\n{\n\tconst char *s;\n\tint n;\n\tchar *p;\n\tchar *end;\n\tuint32_t unicode;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\t(void)sc; \n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\ts = (const char *)_p;\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile ((n = _utf8_to_unicode(&unicode, s, len)) != 0) {\n\t\twchar_t wc;\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n\t\tif (n < 0) {\n\t\t\tn *= -1;\n\t\t\twc = L'?';\n\t\t} else\n\t\t\twc = (wchar_t)unicode;\n\t\ts += n;\n\t\tlen -= n;\n#if HAVE_WCRTOMB\n\t\tn = (int)wcrtomb(p, wc, &shift_state);\n#else\n\t\tn = (int)wctomb(p, wc);\n#endif\n\t\tif (n == -1)\n\t\t\treturn (-1);\n\t\tp += n;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (0);\n}", "target": 1}
{"code": "void grubfs_free (GrubFS *gf) {\n\tif (gf) {\n\t\tif (gf->file && gf->file->device)\n\t\t\tfree (gf->file->device->disk);\n\t\tfree (gf->file);\n\t\tfree (gf);\n\t}\n}", "target": 1}
{"code": "PBKDF2_SHA256(const uint8_t * passwd, size_t passwdlen, const uint8_t * salt,\n    size_t saltlen, uint64_t c, uint8_t * buf, size_t dkLen)\n{\n  struct HMAC_SHA256_CTX PShctx, hctx;\n  size_t i;\n  uint8_t ivec[4];\n  uint32_t *ivec_p;\n  uint8_t U[32];\n  uint8_t T[32];\n  uint64_t j;\n  int k;\n  size_t clen;\n  HMAC_SHA256_Init(&PShctx, passwd, passwdlen);\n  HMAC_SHA256_Update(&PShctx, salt, saltlen);\n  ivec_p = (uint32_t *) ivec;\n  for (i = 0; i * 32 < dkLen; i++) {\n    *ivec_p = folly::Endian::big32((uint32_t)(i + 1));\n    memcpy(&hctx, &PShctx, sizeof(struct HMAC_SHA256_CTX));\n    HMAC_SHA256_Update(&hctx, ivec, 4);\n    HMAC_SHA256_Final(U, &hctx);\n    memcpy(T, U, 32);\n    for (j = 2; j <= c; j++) {\n      HMAC_SHA256_Init(&hctx, passwd, passwdlen);\n      HMAC_SHA256_Update(&hctx, U, 32);\n      HMAC_SHA256_Final(U, &hctx);\n      for (k = 0; k < 32; k++)\n        T[k] ^= U[k];\n    }\n    clen = dkLen - i * 32;\n    if (clen > 32)\n      clen = 32;\n    memcpy(&buf[i * 32], T, clen);\n  }\n  memset(&PShctx, 0, sizeof(struct HMAC_SHA256_CTX));\n}", "target": 1}
{"code": "get_manuf_name_if_known(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    guint manuf_key;\n    guint8 oct;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t *)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL && manuf_value->status != HASHETHER_STATUS_UNRESOLVED) {\n        return manuf_value->resolved_longname;\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return long_name;\n    }\n    return NULL;\n} ", "target": 1}
{"code": "accept_ice_connection (GIOChannel           *source,\n                       GIOCondition          condition,\n                       GsmIceConnectionData *data)\n{\n        IceListenObj    listener;\n        IceConn         ice_conn;\n        IceAcceptStatus status;\n        GsmClient      *client;\n        GsmXsmpServer  *server;\n        listener = data->listener;\n        server = data->server;\n        g_debug (\"GsmXsmpServer: accept_ice_connection()\");\n        ice_conn = IceAcceptConnection (listener, &status);\n        if (status != IceAcceptSuccess) {\n                g_debug (\"GsmXsmpServer: IceAcceptConnection returned %d\", status);\n                return TRUE;\n        }\n        client = gsm_xsmp_client_new (ice_conn);\n        ice_conn->context = client;\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        g_object_unref (client);\n        return TRUE;\n}", "target": 1}
{"code": "  QInt8() {}", "target": 1}
{"code": "struct torture_suite *torture_winbind_struct_init(TALLOC_CTX *ctx)\n{\n\tstruct torture_suite *suite = torture_suite_create(ctx, \"struct\");\n\ttorture_suite_add_simple_test(suite, \"interface_version\", torture_winbind_struct_interface_version);\n\ttorture_suite_add_simple_test(suite, \"ping\", torture_winbind_struct_ping);\n\ttorture_suite_add_simple_test(suite, \"info\", torture_winbind_struct_info);\n\ttorture_suite_add_simple_test(suite, \"priv_pipe_dir\", torture_winbind_struct_priv_pipe_dir);\n\ttorture_suite_add_simple_test(suite, \"netbios_name\", torture_winbind_struct_netbios_name);\n\ttorture_suite_add_simple_test(suite, \"domain_name\", torture_winbind_struct_domain_name);\n\ttorture_suite_add_simple_test(suite, \"check_machacc\", torture_winbind_struct_check_machacc);\n\ttorture_suite_add_simple_test(suite, \"list_trustdom\", torture_winbind_struct_list_trustdom);\n\ttorture_suite_add_simple_test(suite, \"domain_info\", torture_winbind_struct_domain_info);\n\ttorture_suite_add_simple_test(suite, \"getdcname\", torture_winbind_struct_getdcname);\n\ttorture_suite_add_simple_test(suite, \"dsgetdcname\", torture_winbind_struct_dsgetdcname);\n\ttorture_suite_add_simple_test(suite, \"list_users\", torture_winbind_struct_list_users);\n\ttorture_suite_add_simple_test(suite, \"list_groups\", torture_winbind_struct_list_groups);\n\ttorture_suite_add_simple_test(suite, \"show_sequence\", torture_winbind_struct_show_sequence);\n\ttorture_suite_add_simple_test(suite, \"setpwent\", torture_winbind_struct_setpwent);\n\ttorture_suite_add_simple_test(suite, \"getpwent\", torture_winbind_struct_getpwent);\n\ttorture_suite_add_simple_test(suite, \"endpwent\", torture_winbind_struct_endpwent);\n\ttorture_suite_add_simple_test(suite, \"lookup_name_sid\", torture_winbind_struct_lookup_name_sid);\n\ttorture_suite_add_simple_test(\n\t\tsuite,\n\t\t\"lookup_sids_invalid\",\n\t\ttorture_winbind_struct_lookup_sids_invalid);\n\tsuite->description = talloc_strdup(suite, \"WINBIND - struct based protocol tests\");\n\treturn suite;\n}", "target": 0}
{"code": "int ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,\n\t\t\t  int __user *optlen)\n{\n\tint olr;\n\tint val;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\tswitch (optname) {\n\tcase MRT6_VERSION:\n\t\tval = 0x0305;\n\t\tbreak;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t\tval = mrt->mroute_do_pim;\n\t\tbreak;\n#endif\n\tcase MRT6_ASSERT:\n\t\tval = mrt->mroute_do_assert;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (get_user(olr, optlen))\n\t\treturn -EFAULT;\n\tolr = min_t(int, olr, sizeof(int));\n\tif (olr < 0)\n\t\treturn -EINVAL;\n\tif (put_user(olr, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, olr))\n\t\treturn -EFAULT;\n\treturn 0;\n}", "target": 0}
{"code": "void rds_inc_info_copy(struct rds_incoming *inc,\n\t\t       struct rds_info_iterator *iter,\n\t\t       __be32 saddr, __be32 daddr, int flip)\n{\n\tstruct rds_info_message minfo;\n\tminfo.seq = be64_to_cpu(inc->i_hdr.h_sequence);\n\tminfo.len = be32_to_cpu(inc->i_hdr.h_len);\n\tif (flip) {\n\t\tminfo.laddr = daddr;\n\t\tminfo.faddr = saddr;\n\t\tminfo.lport = inc->i_hdr.h_dport;\n\t\tminfo.fport = inc->i_hdr.h_sport;\n\t} else {\n\t\tminfo.laddr = saddr;\n\t\tminfo.faddr = daddr;\n\t\tminfo.lport = inc->i_hdr.h_sport;\n\t\tminfo.fport = inc->i_hdr.h_dport;\n\t}\n\tminfo.flags = 0;\n\trds_info_copy(iter, &minfo, sizeof(minfo));\n}", "target": 0}
{"code": "static int dn_create(struct net *net, struct socket *sock, int protocol,\n\t\t     int kern)\n{\n\tstruct sock *sk;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_SEQPACKET:\n\t\tif (protocol != DNPROTO_NSP)\n\t\t\treturn -EPROTONOSUPPORT;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tif ((sk = dn_alloc_sock(net, sock, GFP_KERNEL, kern)) == NULL)\n\t\treturn -ENOBUFS;\n\tsk->sk_protocol = protocol;\n\treturn 0;\n}", "target": 0}
{"code": "static int turn_dns_lookup(struct zapi_ice_server *turn,\n\t\t\t   struct stun_uri *uri)\n{\n\tstruct lookup_entry *lent;\n\tint err = 0;\n\tlent = mem_zalloc(sizeof(*lent), lent_destructor);\n\tif (!lent)\n\t\treturn ENOMEM;\n\tlent->turn = *turn;\n\tlent->ts = tmr_jiffies();\n\tlent->proto = uri->proto;\n\tlent->secure = uri->secure;\n\tlent->port = uri->port;\n\terr = str_dup(&lent->host, uri->host);\n\tif (err)\n\t\tgoto out;\n\tre_printf(\"dns_lookup for: %s:%d\\n\", lent->host, lent->port);\n\terr = dns_lookup(lent->host, dns_handler, lent);\n\tif (err) {\n\t\twarning(\"dns_lookup: failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n out:\n\tif (err)\n\t\tmem_deref(lent);\n\treturn err;\n}", "target": 0}
{"code": "setkey_principal_2_svc(setkey_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!(CHANGEPW_SERVICE(rqstp)) &&\n        kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                           ACL_SETKEY, arg->princ, NULL)) {\n        ret.code = kadm5_setkey_principal((void *)handle, arg->princ,\n                                          arg->keyblocks, arg->n_keys);\n    } else {\n        log_unauth(\"kadm5_setkey_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_SETKEY;\n    }\n    if(ret.code != KADM5_AUTH_SETKEY) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_setkey_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "void WasmBinaryBuilder::visitUnreachable(Unreachable* curr) {\n  BYN_TRACE(\"zz node: Unreachable\\n\");\n}", "target": 0}
{"code": "ZEND_API void zend_ts_hash_merge_ex(TsHashTable *target, TsHashTable *source, copy_ctor_func_t pCopyConstructor, uint size, merge_checker_func_t pMergeSource, void *pParam)\n{\n\tbegin_read(source);\n\tbegin_write(target);\n\tzend_hash_merge_ex(TS_HASH(target), TS_HASH(source), pCopyConstructor, size, pMergeSource, pParam);\n\tend_write(target);\n\tend_read(source);\n}", "target": 0}
{"code": "static void vmx_slot_disable_log_dirty(struct kvm *kvm,\n\t\t\t\t       struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_slot_set_dirty(kvm, slot);\n}", "target": 0}
{"code": "void Curl_ssl_associate_conn(struct Curl_easy *data,\n                             struct connectdata *conn)\n{\n  if(Curl_ssl->associate_connection) {\n    Curl_ssl->associate_connection(data, conn, FIRSTSOCKET);\n    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)\n      Curl_ssl->associate_connection(data, conn, SECONDARYSOCKET);\n  }\n}", "target": 0}
{"code": "child_setup_func (gpointer user_data)\n{\n  ChildSetupData *data = (ChildSetupData *) user_data;\n  FdMapEntry *fd_map = data->fd_map;\n  sigset_t set;\n  int i;\n  flatpak_close_fds_workaround (3);\n  if (data->instance_id_fd != -1)\n    drop_cloexec (data->instance_id_fd);\n  if (data->env_fd != -1)\n    drop_cloexec (data->env_fd);\n  sigemptyset (&set);\n  if (pthread_sigmask (SIG_SETMASK, &set, NULL) == -1)\n    {\n      g_warning (\"Failed to unblock signals when starting child\");\n      return;\n    }\n  for (i = 1; i < NSIG; i++)\n    {\n      if (i != SIGSTOP && i != SIGKILL)\n        signal (i, SIG_DFL);\n    }\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].from != fd_map[i].to)\n        {\n          dup2 (fd_map[i].from, fd_map[i].to);\n          close (fd_map[i].from);\n        }\n    }\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].to != fd_map[i].final)\n        {\n          dup2 (fd_map[i].to, fd_map[i].final);\n          close (fd_map[i].to);\n        }\n      drop_cloexec (fd_map[i].final);\n    }\n  setsid ();\n  setpgid (0, 0);\n  if (data->set_tty)\n    {\n      for (i = 0; i < data->fd_map_len; i++)\n        {\n          if (fd_map[i].from == data->tty)\n            {\n              if (ioctl (fd_map[i].final, TIOCSCTTY, 0) == -1)\n                g_debug (\"ioctl(%d, TIOCSCTTY, 0) failed: %s\",\n                         fd_map[i].final, strerror (errno));\n              break;\n            }\n        }\n    }\n}", "target": 0}
{"code": "static int walk_hugetlb_range(unsigned long addr, unsigned long end,\n\t\t\t      struct mm_walk *walk)\n{\n\tstruct vm_area_struct *vma = walk->vma;\n\tstruct hstate *h = hstate_vma(vma);\n\tunsigned long next;\n\tunsigned long hmask = huge_page_mask(h);\n\tunsigned long sz = huge_page_size(h);\n\tpte_t *pte;\n\tint err = 0;\n\tdo {\n\t\tnext = hugetlb_entry_end(h, addr, end);\n\t\tpte = huge_pte_offset(walk->mm, addr & hmask, sz);\n\t\tif (pte && walk->hugetlb_entry)\n\t\t\terr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\n\t\tif (err)\n\t\t\tbreak;\n\t} while (addr = next, addr != end);\n\treturn err;\n}", "target": 1}
{"code": "static bool pp_suppress_error(errflags severity)\n{\n    if (istk && istk->conds &&\n\t((severity & ERR_PP_PRECOND) ?\n\t istk->conds->state == COND_NEVER :\n\t !emitting(istk->conds->state)))\n        return true;\n    return false;\n}", "target": 0}
{"code": "static void nested_svm_uninit_mmu_context(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.walk_mmu = &vcpu->arch.mmu;\n}", "target": 0}
{"code": "static bool anal_fcn_data (RCore *core, const char *input) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, -1);\n\tut32 fcn_size = r_anal_function_size_from_entry (fcn);\n\tif (fcn) {\n\t\tint i;\n\t\tbool gap = false;\n\t\tut64 gap_addr = UT64_MAX;\n\t\tchar *bitmap = calloc (1, fcn_size);\n\t\tif (bitmap) {\n\t\t\tRAnalBlock *b;\n\t\t\tRListIter *iter;\n\t\t\tr_list_foreach (fcn->bbs, iter, b) {\n\t\t\t\tint f = b->addr - fcn->addr;\n\t\t\t\tint t = R_MIN (f + b->size, fcn_size);\n\t\t\t\tif (f >= 0) {\n\t\t\t\t\twhile (f < t) {\n\t\t\t\t\t\tbitmap[f++] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < fcn_size; i++) {\n\t\t\tut64 here = fcn->addr + i;\n\t\t\tif (bitmap && bitmap[i]) {\n\t\t\t\tif (gap) {\n\t\t\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", here - gap_addr, gap_addr);\n\t\t\t\t\tgap = false;\n\t\t\t\t}\n\t\t\t\tgap_addr = UT64_MAX;\n\t\t\t} else {\n\t\t\t\tif (!gap) {\n\t\t\t\t\tgap = true;\n\t\t\t\t\tgap_addr = here;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gap) {\n\t\t\tr_cons_printf (\"Cd %d @ 0x%08\"PFMT64x\"\\n\", fcn->addr + fcn_size - gap_addr, gap_addr);\n\t\t}\n\t\tfree (bitmap);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "COMPAT_SYSCALL_DEFINE6(mbind, compat_ulong_t, start, compat_ulong_t, len,\n\t\t       compat_ulong_t, mode, compat_ulong_t __user *, nmask,\n\t\t       compat_ulong_t, maxnode, compat_ulong_t, flags)\n{\n\tlong err = 0;\n\tunsigned long __user *nm = NULL;\n\tunsigned long nr_bits, alloc_size;\n\tnodemask_t bm;\n\tnr_bits = min_t(unsigned long, maxnode-1, MAX_NUMNODES);\n\talloc_size = ALIGN(nr_bits, BITS_PER_LONG) / 8;\n\tif (nmask) {\n\t\terr = compat_get_bitmap(nodes_addr(bm), nmask, nr_bits);\n\t\tnm = compat_alloc_user_space(alloc_size);\n\t\terr |= copy_to_user(nm, nodes_addr(bm), alloc_size);\n\t}\n\tif (err)\n\t\treturn -EFAULT;\n\treturn sys_mbind(start, len, mode, nm, nr_bits+1, flags);\n}", "target": 1}
{"code": "elg_get_nbits (int algo, gcry_mpi_t *pkey)\n{\n  (void)algo;\n  return mpi_get_nbits (pkey[0]);\n}", "target": 0}
{"code": "static inline int use_cpu_reloc(struct drm_i915_gem_object *obj)\n{\n\treturn (obj->base.write_domain == I915_GEM_DOMAIN_CPU ||\n\t\t!obj->map_and_fenceable ||\n\t\tobj->cache_level != I915_CACHE_NONE);\n}", "target": 0}
{"code": "int iscsi_decode_text_input(\n\tu8 phase,\n\tu8 sender,\n\tchar *textbuf,\n\tu32 length,\n\tstruct iscsi_conn *conn)\n{\n\tstruct iscsi_param_list *param_list = conn->param_list;\n\tchar *tmpbuf, *start = NULL, *end = NULL;\n\ttmpbuf = kzalloc(length + 1, GFP_KERNEL);\n\tif (!tmpbuf) {\n\t\tpr_err(\"Unable to allocate memory for tmpbuf.\\n\");\n\t\treturn -1;\n\t}\n\tmemcpy(tmpbuf, textbuf, length);\n\ttmpbuf[length] = '\\0';\n\tstart = tmpbuf;\n\tend = (start + length);\n\twhile (start < end) {\n\t\tchar *key, *value;\n\t\tstruct iscsi_param *param;\n\t\tif (iscsi_extract_key_value(start, &key, &value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tpr_debug(\"Got key: %s=%s\\n\", key, value);\n\t\tif (phase & PHASE_SECURITY) {\n\t\t\tif (iscsi_check_for_auth_key(key) > 0) {\n\t\t\t\tchar *tmpptr = key + strlen(key);\n\t\t\t\t*tmpptr = '=';\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tparam = iscsi_check_key(key, phase, sender, param_list);\n\t\tif (!param) {\n\t\t\tif (iscsi_add_notunderstood_response(key,\n\t\t\t\t\tvalue, param_list) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tstart += strlen(key) + strlen(value) + 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (iscsi_check_value(param, value) < 0) {\n\t\t\tkfree(tmpbuf);\n\t\t\treturn -1;\n\t\t}\n\t\tstart += strlen(key) + strlen(value) + 2;\n\t\tif (IS_PSTATE_PROPOSER(param)) {\n\t\t\tif (iscsi_check_proposer_state(param, value) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_RESPONSE_GOT(param);\n\t\t} else {\n\t\t\tif (iscsi_check_acceptor_state(param, value, conn) < 0) {\n\t\t\t\tkfree(tmpbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tSET_PSTATE_ACCEPTOR(param);\n\t\t}\n\t}\n\tkfree(tmpbuf);\n\treturn 0;\n}", "target": 1}
{"code": "static void skcipher_release(void *private)\n{\n\tcrypto_free_skcipher(private);\n}", "target": 1}
{"code": "Status OpLevelCostEstimator::PredictAvgPoolGrad(const OpContext& op_context,\n                                                NodeCosts* node_costs) const {\n  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  bool shape_found = false;\n  TensorShapeProto x_shape;\n  if (op_info.inputs_size() >= 1 && op_info.inputs(0).has_value()) {\n    const TensorProto& value = op_info.inputs(0).value();\n    shape_found = GetTensorShapeProtoFromTensorProto(value, &x_shape);\n  }\n  if (!shape_found && op_info.outputs_size() > 0) {\n    x_shape = op_info.outputs(0).shape();\n    shape_found = true;\n  }\n  if (!shape_found) {\n    x_shape.Clear();\n    for (int i = 0; i < 4; ++i) {\n      x_shape.add_dim()->set_size(1);\n    }\n    found_unknown_shapes = true;\n  }\n  ConvolutionDimensions dims =\n      OpDimensionsFromInputs(x_shape, op_info, &found_unknown_shapes);\n  int64_t ops = 0;\n  if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    ops = dims.batch * dims.iz * (dims.ix * dims.iy + dims.ox * dims.oy);\n  } else {\n    ops = dims.batch * dims.iz *\n          (dims.ix * dims.iy + dims.ox * dims.oy * (dims.kx * dims.ky + 1));\n  }\n  auto s = PredictDefaultNodeCosts(ops, op_context, &found_unknown_shapes,\n                                   node_costs);\n  node_costs->max_memory = node_costs->num_total_output_bytes();\n  return s;\n}", "target": 1}
{"code": "ldns_str2rdf_tag(ldns_rdf **rd, const char *str)\n{\n\tuint8_t *data;\n\tconst char* ptr;\n\tif (strlen(str) > 255) {\n\t\treturn LDNS_STATUS_INVALID_TAG;\n\t}\n\tfor (ptr = str; *ptr; ptr++) {\n\t\tif (! isalnum((unsigned char)*ptr)) {\n\t\t\treturn LDNS_STATUS_INVALID_TAG;\n\t\t}\n\t}\n\tdata = LDNS_XMALLOC(uint8_t, strlen(str) + 1);\n        if (!data) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\tdata[0] = strlen(str);\n\tmemcpy(data + 1, str, strlen(str));\n\t*rd = ldns_rdf_new(LDNS_RDF_TYPE_TAG, strlen(str) + 1, data);\n\tif (!*rd) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}", "target": 0}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 15;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }", "target": 1}
{"code": "static void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    ses->time.stop = pj_strtoul(&str);\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "void Filter::onSoftPerTryTimeout(UpstreamRequest& upstream_request) {\n  ASSERT(!upstream_request.retried());\n  updateOutlierDetection(Upstream::Outlier::Result::LocalOriginTimeout, upstream_request,\n                         absl::optional<uint64_t>(enumToInt(timeout_response_code_)));\n  upstream_request.outlierDetectionTimeoutRecorded(true);\n  if (!downstream_response_started_ && retry_state_) {\n    RetryStatus retry_status = retry_state_->shouldHedgeRetryPerTryTimeout(\n        [this, can_use_http3 = upstream_request.upstreamStreamOptions().can_use_http3_]() -> void {\n          doRetry( false, can_use_http3, TimeoutRetry::Yes);\n        });\n    if (retry_status == RetryStatus::Yes) {\n      runRetryOptionsPredicates(upstream_request);\n      pending_retries_++;\n      upstream_request.retried(true);\n    } else if (retry_status == RetryStatus::NoOverflow) {\n      callbacks_->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::UpstreamOverflow);\n    } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {\n      callbacks_->streamInfo().setResponseFlag(\n          StreamInfo::CoreResponseFlag::UpstreamRetryLimitExceeded);\n    }\n  }\n}", "target": 0}
{"code": "PLIST_API void plist_from_xml(const char *plist_xml, uint32_t length, plist_t * plist)\n{\n    xmlDocPtr plist_doc = xmlParseMemory(plist_xml, length);\n    xmlNodePtr root_node = xmlDocGetRootElement(plist_doc);\n    xml_to_node(root_node, plist);\n    xmlFreeDoc(plist_doc);\n}", "target": 1}
{"code": "  clientpairingsecret(std::shared_ptr<safe::queue_t<crypto::x509_t>> &add_cert, pair_session_t &sess, pt::ptree &tree, const args_t &args) {\n    auto &client = sess.client;\n    auto pairingsecret = util::from_hex_vec(get_arg(args, \"clientpairingsecret\"), true);\n    if (pairingsecret.size() <= 16) {\n      tree.put(\"root.paired\", 0);\n      tree.put(\"root.<xmlattr>.status_code\", 400);\n      tree.put(\"root.<xmlattr>.status_message\", \"Clientpairingsecret too short\");\n      return;\n    }\n    std::string_view secret { pairingsecret.data(), 16 };\n    std::string_view sign { pairingsecret.data() + secret.size(), pairingsecret.size() - secret.size() };\n    auto x509 = crypto::x509(client.cert);\n    auto x509_sign = crypto::signature(x509);\n    std::string data;\n    data.reserve(sess.serverchallenge.size() + x509_sign.size() + secret.size());\n    data.insert(std::end(data), std::begin(sess.serverchallenge), std::end(sess.serverchallenge));\n    data.insert(std::end(data), std::begin(x509_sign), std::end(x509_sign));\n    data.insert(std::end(data), std::begin(secret), std::end(secret));\n    auto hash = crypto::hash(data);\n    if (!std::memcmp(hash.data(), sess.clienthash.data(), hash.size()) && crypto::verify256(crypto::x509(client.cert), secret, sign)) {\n      tree.put(\"root.paired\", 1);\n      add_cert->raise(crypto::x509(client.cert));\n      auto it = map_id_sess.find(client.uniqueID);\n      update_id_client(client.uniqueID, std::move(client.cert), op_e::ADD);\n      map_id_sess.erase(it);\n    }\n    else {\n      map_id_sess.erase(client.uniqueID);\n      tree.put(\"root.paired\", 0);\n    }\n    tree.put(\"root.<xmlattr>.status_code\", 200);\n  }", "target": 1}
{"code": "ParseNameValue(const char * buffer, int bufsize,\n               struct NameValueParserData * data)\n{\n\tstruct xmlparser parser;\n\tdata->l_head = NULL;\n\tdata->portListing = NULL;\n\tdata->portListingLength = 0;\n\tparser.xmlstart = buffer;\n\tparser.xmlsize = bufsize;\n\tparser.data = data;\n\tparser.starteltfunc = NameValueParserStartElt;\n\tparser.endeltfunc = NameValueParserEndElt;\n\tparser.datafunc = NameValueParserGetData;\n\tparser.attfunc = 0;\n\tparsexml(&parser);\n}", "target": 1}
{"code": "int __cil_build_ast_first_child_helper(__attribute__((unused)) struct cil_tree_node *parse_current, void *extra_args)\n{\n\tstruct cil_args_build *args = extra_args;\n\tstruct cil_tree_node *ast = args->ast;\n\tif (ast->flavor == CIL_TUNABLEIF) {\n\t\targs->tunif = ast;\n\t}\n\tif (ast->flavor == CIL_IN) {\n\t\targs->in = ast;\n\t}\n\tif (ast->flavor == CIL_MACRO) {\n\t\targs->macro = ast;\n\t}\n\tif (ast->flavor == CIL_OPTIONAL) {\n\t\targs->optional = ast;\n\t}\n\tif (ast->flavor == CIL_BOOLEANIF) {\n\t\targs->boolif = ast;\n\t}\n\treturn SEPOL_OK;\n}", "target": 0}
{"code": "static JSON_INLINE size_t num_buckets(hashtable_t *hashtable)\n{\n    return primes[hashtable->num_buckets];\n}", "target": 1}
{"code": "  static TfLiteRegistration DelegateRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      TfLiteTensor* output0 = GetOutput(context, node, 0);\n      TF_LITE_ENSURE(context, IsDynamicTensor(output0));\n      const TfLiteTensor* input = GetInput(context, node, 0);\n      TfLiteTensor* output1 = GetOutput(context, node, 1);\n      TF_LITE_ENSURE(context, input->dims->size == output1->dims->size);\n      TF_LITE_ENSURE(context, input->dims->data[0] == output1->dims->data[0]);\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "void CtcpParser::query(CoreNetwork *net, const QString &bufname, const QString &ctcpTag, const QString &message)\n{\n    QList<QByteArray> params;\n    params << net->serverEncode(bufname) << lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message)));\n    static const char *splitter = \" .,-!?\";\n    int maxSplitPos = message.count();\n    int splitPos = maxSplitPos;\n    int overrun = net->userInputHandler()->lastParamOverrun(\"PRIVMSG\", params);\n    if (overrun) {\n        maxSplitPos = message.count() - overrun -2;\n        splitPos = -1;\n        for (const char *splitChar = splitter; *splitChar != 0; splitChar++) {\n            splitPos = qMax(splitPos, message.lastIndexOf(*splitChar, maxSplitPos) + 1); \n        }\n        if (splitPos <= 0 || splitPos > maxSplitPos)\n            splitPos = maxSplitPos;\n        params = params.mid(0, 1) <<  lowLevelQuote(pack(net->serverEncode(ctcpTag), net->userEncode(bufname, message.left(splitPos))));\n    }\n    net->putCmd(\"PRIVMSG\", params);\n    if (splitPos < message.count())\n        query(net, bufname, ctcpTag, message.mid(splitPos));\n}", "target": 1}
{"code": "static int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tstruct l2cap_chan *chan;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tif (!sk)\n\t\treturn 0;\n\tl2cap_sock_cleanup_listen(sk);\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\terr = l2cap_sock_shutdown(sock, SHUT_RDWR);\n\tchan = l2cap_pi(sk)->chan;\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\treturn err;\n}", "target": 0}
{"code": "static void svm_handle_exit_irqoff(struct kvm_vcpu *vcpu)\n{\n\tif (to_svm(vcpu)->vmcb->control.exit_code == SVM_EXIT_INTR)\n\t\tvcpu->arch.at_instruction_boundary = true;\n}", "target": 0}
{"code": "static mp_obj_t int_to_bytes(size_t n_args, const mp_obj_t *args) {\n    (void)n_args;\n    mp_int_t len = mp_obj_get_int(args[1]);\n    if (len < 0) {\n        mp_raise_ValueError(NULL);\n    }\n    bool big_endian = args[2] != MP_OBJ_NEW_QSTR(MP_QSTR_little);\n    vstr_t vstr;\n    vstr_init_len(&vstr, len);\n    byte *data = (byte *)vstr.buf;\n    memset(data, 0, len);\n    #if MICROPY_LONGINT_IMPL != MICROPY_LONGINT_IMPL_NONE\n    if (!mp_obj_is_small_int(args[0])) {\n        mp_obj_int_to_bytes_impl(args[0], big_endian, len, data);\n    } else\n    #endif\n    {\n        mp_int_t val = MP_OBJ_SMALL_INT_VALUE(args[0]);\n        size_t l = MIN((size_t)len, sizeof(val));\n        mp_binary_set_int(l, big_endian, data + (big_endian ? (len - l) : 0), val);\n    }\n    return mp_obj_new_bytes_from_vstr(&vstr);\n}", "target": 1}
{"code": "has_supported_extension (const char *name,\n\t\t\t GHashTable *supported_extensions)\n{\n\tgboolean ret = FALSE;\n\tgchar *suffix;\n\tsuffix = g_strrstr (name, \".\");\n\tif (!suffix)\n\t\treturn ret;\n\tsuffix = g_ascii_strdown (suffix + 1, -1);\n\tret = GPOINTER_TO_INT (g_hash_table_lookup (supported_extensions, suffix));\n\tg_free (suffix);\n\treturn ret;\n}", "target": 0}
{"code": "R_API int r_socket_block_time(RSocket *s, int block, int sec, int usec) {\n#if __UNIX__\n\tint ret, flags;\n#endif\n\tif (!s) {\n\t\treturn false;\n\t}\n#if __UNIX__\n\tflags = fcntl (s->fd, F_GETFL, 0);\n\tif (flags < 0) {\n\t\treturn false;\n\t}\n\tret = fcntl (s->fd, F_SETFL, block?\n\t\t\t(flags & ~O_NONBLOCK):\n\t\t\t(flags | O_NONBLOCK));\n\tif (ret < 0) {\n\t\treturn false;\n\t}\n#elif __WINDOWS__\n\tioctlsocket (s->fd, FIONBIO, (u_long FAR*)&block);\n#endif\n\tif (sec > 0 || usec > 0) {\n\t\tstruct timeval tv = {0};\n\t\ttv.tv_sec = sec;\n\t\ttv.tv_usec = usec;\n\t\tif (setsockopt (s->fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof (tv)) < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "ahcp_time_print(netdissect_options *ndo,\n                const u_char *cp, uint8_t len)\n{\n\ttime_t t;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tif (len != 4)\n\t\tgoto invalid;\n\tt = GET_BE_U_4(cp);\n\tif (NULL == (tm = gmtime(&t)))\n\t\tND_PRINT(\": gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\": strftime() error\");\n\telse\n\t\tND_PRINT(\": %s UTC\", buf);\n\treturn;\ninvalid:\n\tnd_print_invalid(ndo);\n\tND_TCHECK_LEN(cp, len);\n}", "target": 1}
{"code": "error(int n, ...)\n{\nint ec;\nmacroexe *me;\nistackstr *fe;\nva_list ap;\nva_start(ap, n);\nif (n > error_maxerror)\n  {\n  (void)fprintf(stderr, \"** Unknown error number %d\\n\", n);\n  ec = ec_disaster;\n  }\nelse\n  {\n  ec = error_data[n].ec;\n  if (ec == ec_warning)\n    {\n    if (suppress_warnings) return;\n    (void)fprintf(stderr, \"** Warning: \");\n    }\n  else if (ec > ec_warning)\n    (void)fprintf(stderr, \"** Error: \");\n  (void)vfprintf(stderr, error_data[n].text, ap);\n  (void)fprintf(stderr, \"\\n\");\n  }\nva_end(ap);\nme = macrocurrent;\nfe = istack;\nif (from_type_ptr < 0) (void)fprintf(stderr, \"   Detected near end of file\\n\");\nelse for (int i = from_type_ptr; i >= 0; i--)\n  {\n  if (from_type[i] == FROM_MACRO)\n    {\n    const char *eof = (i == 0)? \" at end of input\" : \"\";\n    (void)fprintf(stderr, \"   Processing macro %s%s\\n\", me->macro->name, eof);\n    me = me->prev;\n    }\n  else\n    {\n    if (fe != NULL)\n      {\n      if (fe->linenumber > 0) \n        (void)fprintf(stderr, \"   Detected near line %d of %s\\n\",\n          fe->linenumber, fe->filename);\n      fe = fe->prev;\n      }\n    else\n      {\n      (void)fprintf(stderr, \"   Detected near end of file\\n\"); \n      }\n    }\n  }\nif (ec == ec_warning)\n  {\n  warning_count++;\n  if (warning_count > 40)\n    {\n    (void)fprintf(stderr, \"** Too many warnings - subsequent ones suppressed\\n\");\n    suppress_warnings = TRUE;\n    }\n  }\nelse if (ec > ec_warning)\n  {\n  return_code = EXIT_FAILURE;\n  error_count++;\n  if (error_count > 40)\n    {\n    (void)fprintf(stderr, \"** Too many errors\\n\");\n    ec = ec_failed;\n    }\n  }\nif (ec >= ec_failed)\n  {\n  (void)fprintf(stderr, \"** xfpt abandoned\\n\");\n  suppress_warnings = TRUE;  \n  exit(EXIT_FAILURE);\n  }\n(void)fprintf(stderr, \"\\n\");   \n}", "target": 1}
{"code": "ArcMemory::ArcMemory()\n{\n  Loaded=false;\n  SeekPos=0;\n}", "target": 0}
{"code": "int TfLiteIntArrayGetSizeInBytes(int size) {\n  static TfLiteIntArray dummy;\n  int computed_size = sizeof(dummy) + sizeof(dummy.data[0]) * size;\n#if defined(_MSC_VER)\n  computed_size -= sizeof(dummy.data[0]);\n#endif\n  return computed_size;\n}", "target": 1}
{"code": "pci_emul_alloc_resource(uint64_t *baseptr, uint64_t limit, uint64_t size,\n\t\t\tuint64_t *addr)\n{\n\tuint64_t base;\n\tassert((size & (size - 1)) == 0);\t\n\tbase = roundup2(*baseptr, size);\n\tif (base + size <= limit) {\n\t\t*addr = base;\n\t\t*baseptr = base + size;\n\t\treturn 0;\n\t} else\n\t\treturn -1;\n}", "target": 1}
{"code": "void HeaderMapImpl::removeInline(HeaderEntryImpl** ptr_to_entry) {\n  if (!*ptr_to_entry) {\n    return;\n  }\n  HeaderEntryImpl* entry = *ptr_to_entry;\n  const uint64_t size_to_subtract = entry->entry_->key().size() + entry->entry_->value().size();\n  subtractSize(size_to_subtract);\n  *ptr_to_entry = nullptr;\n  headers_.erase(entry->entry_);\n}", "target": 0}
{"code": "static void freeary(struct ipc_namespace *ns, struct kern_ipc_perm *ipcp)\n{\n\tstruct sem_undo *un, *tu;\n\tstruct sem_queue *q, *tq;\n\tstruct sem_array *sma = container_of(ipcp, struct sem_array, sem_perm);\n\tstruct list_head tasks;\n\tint i;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry_safe(un, tu, &sma->list_id, list_id) {\n\t\tlist_del(&un->list_id);\n\t\tspin_lock(&un->ulp->lock);\n\t\tun->semid = -1;\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&un->ulp->lock);\n\t\tkfree_rcu(un, rcu);\n\t}\n\tINIT_LIST_HEAD(&tasks);\n\tlist_for_each_entry_safe(q, tq, &sma->sem_pending, list) {\n\t\tunlink_queue(sma, q);\n\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t}\n\tfor (i = 0; i < sma->sem_nsems; i++) {\n\t\tstruct sem *sem = sma->sem_base + i;\n\t\tlist_for_each_entry_safe(q, tq, &sem->sem_pending, list) {\n\t\t\tunlink_queue(sma, q);\n\t\t\twake_up_sem_queue_prepare(&tasks, q, -EIDRM);\n\t\t}\n\t}\n\tsem_rmid(ns, sma);\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\tns->used_sems -= sma->sem_nsems;\n\tsecurity_sem_free(sma);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "void FrameLoader::checkCompleted()\n{\n    RefPtr<Frame> protect(m_frame);\n    m_shouldCallCheckCompleted = false;\n    if (m_frame->view())\n        m_frame->view()->handleLoadCompleted();\n    if (m_isComplete)\n        return;\n    if (m_frame->document()->parsing())\n        return;\n    if (m_frame->document()->fetcher()->requestCount())\n        return;\n    if (m_frame->document()->isDelayingLoadEvent())\n        return;\n    if (!allChildrenAreComplete())\n        return;\n    m_isComplete = true;\n    m_requestedHistoryItem = 0;\n    m_frame->document()->setReadyState(Document::Complete);\n    if (m_frame->document()->loadEventStillNeeded())\n        m_frame->document()->implicitClose();\n    m_frame->navigationScheduler()->startTimer();\n    completed();\n    if (m_frame->page())\n        checkLoadComplete();\n    if (m_frame->view())\n        m_frame->view()->handleLoadCompleted();\n}", "target": 0}
{"code": "peek_from_buf(char *string, size_t string_len, const buf_t *buf)\n{\n  chunk_t *chunk;\n  tor_assert(string);\n  tor_assert(string_len <= buf->datalen);\n  chunk = buf->head;\n  while (string_len) {\n    size_t copy = string_len;\n    tor_assert(chunk);\n    if (chunk->datalen < copy)\n      copy = chunk->datalen;\n    memcpy(string, chunk->data, copy);\n    string_len -= copy;\n    string += copy;\n    chunk = chunk->next;\n  }\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T, 4>::ConstTensor input,\n                  typename TTypes<T, 3>::ConstTensor filter,\n                  typename TTypes<T, 4>::ConstTensor out_backprop,\n                  int stride_rows, int stride_cols, int rate_rows,\n                  int rate_cols, int pad_top, int pad_left,\n                  typename TTypes<T, 3>::Tensor filter_backprop) {\n    const int batch = input.dimension(0);\n    const int input_rows = input.dimension(1);\n    const int input_cols = input.dimension(2);\n    const int depth = input.dimension(3);\n    const int filter_rows = filter.dimension(0);\n    const int filter_cols = filter.dimension(1);\n    const int output_rows = out_backprop.dimension(1);\n    const int output_cols = out_backprop.dimension(2);\n    filter_backprop.setZero();\n    for (int b = 0; b < batch; ++b) {\n      for (int h_out = 0; h_out < output_rows; ++h_out) {\n        int h_beg = h_out * stride_rows - pad_top;\n        for (int w_out = 0; w_out < output_cols; ++w_out) {\n          int w_beg = w_out * stride_cols - pad_left;\n          for (int d = 0; d < depth; ++d) {\n            T cur_val = Eigen::NumTraits<T>::lowest();\n            int h_max = 0;\n            int w_max = 0;\n            for (int h = 0; h < filter_rows; ++h) {\n              const int h_in = h_beg + h * rate_rows;\n              if (h_in >= 0 && h_in < input_rows) {\n                for (int w = 0; w < filter_cols; ++w) {\n                  const int w_in = w_beg + w * rate_cols;\n                  if (w_in >= 0 && w_in < input_cols) {\n                    const T val = input(b, h_in, w_in, d) + filter(h, w, d);\n                    if (val > cur_val) {\n                      cur_val = val;\n                      h_max = h;\n                      w_max = w;\n                    }\n                  }\n                }\n              }\n            }\n            filter_backprop(h_max, w_max, d) +=\n                out_backprop(b, h_out, w_out, d);\n          }\n        }\n      }\n    }\n  }", "target": 1}
{"code": "zend_op_array *compile_string(zval *source_string, char *filename TSRMLS_DC)\n{\n\tzend_lex_state original_lex_state;\n\tzend_op_array *op_array = (zend_op_array *) emalloc(sizeof(zend_op_array));\n\tzend_op_array *original_active_op_array = CG(active_op_array);\n\tzend_op_array *retval;\n\tzval tmp;\n\tint compiler_result;\n\tzend_bool original_in_compilation = CG(in_compilation);\n\tif (source_string->value.str.len==0) {\n\t\tefree(op_array);\n\t\treturn NULL;\n\t}\n\tCG(in_compilation) = 1;\n\ttmp = *source_string;\n\tzval_copy_ctor(&tmp);\n\tconvert_to_string(&tmp);\n\tsource_string = &tmp;\n\tzend_save_lexical_state(&original_lex_state TSRMLS_CC);\n\tif (zend_prepare_string_for_scanning(source_string, filename TSRMLS_CC)==FAILURE) {\n\t\tefree(op_array);\n\t\tretval = NULL;\n\t} else {\n\t\tzend_bool orig_interactive = CG(interactive);\n\t\tCG(interactive) = 0;\n\t\tinit_op_array(op_array, ZEND_EVAL_CODE, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);\n\t\tCG(interactive) = orig_interactive;\n\t\tCG(active_op_array) = op_array;\n\t\tzend_stack_push(&CG(context_stack), (void *) &CG(context), sizeof(CG(context)));\n\t\tzend_init_compiler_context(TSRMLS_C);\n\t\tBEGIN(ST_IN_SCRIPTING);\n\t\tcompiler_result = zendparse(TSRMLS_C);\n\t\tif (SCNG(script_filtered)) {\n\t\t\tefree(SCNG(script_filtered));\n\t\t\tSCNG(script_filtered) = NULL;\n\t\t}\n\t\tif (compiler_result==1) {\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tCG(unclean_shutdown)=1;\n\t\t\tdestroy_op_array(op_array TSRMLS_CC);\n\t\t\tefree(op_array);\n\t\t\tretval = NULL;\n\t\t} else {\n\t\t\tzend_do_return(NULL, 0 TSRMLS_CC);\n\t\t\tCG(active_op_array) = original_active_op_array;\n\t\t\tpass_two(op_array TSRMLS_CC);\n\t\t\tzend_release_labels(0 TSRMLS_CC);\n\t\t\tretval = op_array;\n\t\t}\n\t}\n\tzend_restore_lexical_state(&original_lex_state TSRMLS_CC);\n\tzval_dtor(&tmp);\n\tCG(in_compilation) = original_in_compilation;\n\treturn retval;\n}", "target": 1}
{"code": "int lxc_switch_uid_gid(uid_t uid, gid_t gid)\n{\n\tif (setgid(gid) < 0) {\n\t\tSYSERROR(\"Failed to switch to gid %d.\", gid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to gid %d.\", gid);\n\tif (setuid(uid) < 0) {\n\t\tSYSERROR(\"Failed to switch to uid %d.\", uid);\n\t\treturn -errno;\n\t}\n\tNOTICE(\"Switched to uid %d.\", uid);\n\treturn 0;\n}", "target": 0}
{"code": "static void do_iccprofile_item(deark *c, lctx *d, i64 pos, i64 len)\n{\n\ti64 selector;\n\ti64 data_len;\n\tif(len<4) return;\n\tselector = de_getu32be(pos);\n\tdata_len = len-4;\n\tde_dbg(c, \"ICC profile segment, selector=%d, data len=%d\", (int)selector,\n\t\t(int)data_len);\n\tif(selector!=1) {\n\t\tdbuf_close(d->iccprofile_file);\n\t\td->iccprofile_file = NULL;\n\t}\n\tif(selector==0) { \n\t\td->iccprofile_file = dbuf_create_output_file(c, \"icc\", NULL, DE_CREATEFLAG_IS_AUX);\n\t}\n\tif(selector==0 || selector==1) {\n\t\tif(!d->iccprofile_file) {\n\t\t\tde_warn(c, \"Bad ICC profile segment\");\n\t\t\treturn;\n\t\t}\n\t\tdbuf_copy(c->infile, pos+4, data_len, d->iccprofile_file);\n\t}\n}", "target": 0}
{"code": "wait_limit_netblock_findcreate(struct infra_cache* infra, char* str,\n\tint cookie)\n{\n\trbtree_type* tree;\n\tstruct sockaddr_storage addr;\n\tint net;\n\tsocklen_t addrlen;\n\tstruct wait_limit_netblock_info* d;\n\tif(!netblockstrtoaddr(str, 0, &addr, &addrlen, &net)) {\n\t\tlog_err(\"cannot parse wait limit netblock '%s'\", str);\n\t\treturn 0;\n\t}\n\tif(cookie)\n\t\ttree = &infra->wait_limits_cookie_netblock;\n\telse\n\t\ttree = &infra->wait_limits_netblock;\n\td = (struct wait_limit_netblock_info*)addr_tree_find(tree, &addr,\n\t\taddrlen, net);\n\tif(d)\n\t\treturn d;\n\td = (struct wait_limit_netblock_info*)calloc(1, sizeof(*d));\n\tif(!d)\n\t\treturn NULL;\n\td->limit = -1;\n\tif(!addr_tree_insert(tree, &d->node, &addr, addrlen, net)) {\n\t\tlog_err(\"duplicate element in domainlimit tree\");\n\t\tfree(d);\n\t\treturn NULL;\n\t}\n\treturn d;\n}", "target": 0}
{"code": "htp_param_t *htp_tx_req_get_param_ex(htp_tx_t *tx, enum htp_data_source_t source, const char *name, size_t name_len) {\n    if ((tx == NULL) || (name == NULL)) return NULL;\n    htp_param_t *p = NULL;\n    for (size_t i = 0, n = htp_table_size(tx->request_params); i < n; i++) {\n        p = htp_table_get_index(tx->request_params, i, NULL);\n        if (p->source != source) continue;\n        if (bstr_cmp_mem_nocase(p->name, name, name_len) == 0) return p;\n    }\n    return NULL;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* c) override {\n    Tensor* output_tensor;\n    AllocatorAttributes attr;\n    attr.set_on_host(true);\n    OP_REQUIRES_OK(c, c->allocate_output(0, {}, &output_tensor, attr));\n    PartialTensorShape element_shape;\n    OP_REQUIRES(\n        c, !TensorShapeUtils::IsMatrixOrHigher(c->input(1).shape()),\n        errors::InvalidArgument(\n            \"TensorListFromTensor: element_shape must be at most rank 1 but \",\n            \"has the shape of \", c->input(1).shape().DebugString()));\n    OP_REQUIRES_OK(c, TensorShapeFromTensor(c->input(1), &element_shape));\n    TensorList output_list;\n    const Tensor& t = c->input(0);\n    output_list.element_dtype = t.dtype();\n    OP_REQUIRES(c, TensorShapeUtils::IsVectorOrHigher(t.shape()),\n                errors::InvalidArgument(\n                    \"Tensor must be at least a vector, but saw shape: \",\n                    t.shape().DebugString()));\n    TensorShape output_shape(t.shape());\n    output_shape.RemoveDim(0);\n    OP_REQUIRES(c, element_shape.IsCompatibleWith(output_shape),\n                errors::InvalidArgument(\n                    \"Specified a list with shape \", element_shape.DebugString(),\n                    \" from a tensor with shape \", output_shape.DebugString()));\n    output_list.element_shape = element_shape;\n    output_list.tensors().reserve(t.shape().dim_size(0));\n    const auto copy_tensor = IsPluggableDevice(c)\n                                 ? &CopyTensorPluggableDevice<T>\n                                 : &CopyTensor<Device, T>;\n    for (int i = 0; i < t.shape().dim_size(0); ++i) {\n      Tensor tmp = t.Slice(i, i + 1);\n      TensorShape tmp_shape = tmp.shape();\n      tmp_shape.RemoveDim(0);\n      OP_REQUIRES(c, tmp.CopyFrom(tmp, tmp_shape),\n                  errors::Unknown(\"Unexpected shape error.\"));\n      Tensor aligned;\n      OP_REQUIRES_OK(c, c->allocate_temp(tmp.dtype(), tmp.shape(), &aligned));\n      copy_tensor(c, tmp, aligned);\n      output_list.tensors().push_back(aligned);\n    }\n    output_tensor->scalar<Variant>()() = std::move(output_list);\n  }", "target": 0}
{"code": "int WebContentsImpl::GetEmbeddedInstanceID() const {\n  BrowserPluginGuest* guest = GetBrowserPluginGuest();\n  if (guest)\n    return guest->instance_id();\n  return 0;\n}", "target": 0}
{"code": "nfs4_open_revalidate(struct inode *dir, struct dentry *dentry, int openflags, struct nameidata *nd)\n{\n\tstruct path path = {\n\t\t.mnt = nd->path.mnt,\n\t\t.dentry = dentry,\n\t};\n\tstruct rpc_cred *cred;\n\tstruct nfs4_state *state;\n\tcred = rpc_lookup_cred();\n\tif (IS_ERR(cred))\n\t\treturn PTR_ERR(cred);\n\tstate = nfs4_do_open(dir, &path, openflags, NULL, cred);\n\tput_rpccred(cred);\n\tif (IS_ERR(state)) {\n\t\tswitch (PTR_ERR(state)) {\n\t\t\tcase -EPERM:\n\t\t\tcase -EACCES:\n\t\t\tcase -EDQUOT:\n\t\t\tcase -ENOSPC:\n\t\t\tcase -EROFS:\n\t\t\t\tlookup_instantiate_filp(nd, (struct dentry *)state, NULL);\n\t\t\t\treturn 1;\n\t\t\tdefault:\n\t\t\t\tgoto out_drop;\n\t\t}\n\t}\n\tif (state->inode == dentry->d_inode) {\n\t\tnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\n\t\tnfs4_intent_set_file(nd, &path, state);\n\t\treturn 1;\n\t}\n\tnfs4_close_sync(&path, state, openflags);\nout_drop:\n\td_drop(dentry);\n\treturn 0;\n}", "target": 1}
{"code": "ResolveStateAndPredicate(ExprDef *expr, enum xkb_match_operation *pred_rtrn,\n                         xkb_mod_mask_t *mods_rtrn, CompatInfo *info)\n{\n    if (expr == NULL) {\n        *pred_rtrn = MATCH_ANY_OR_NONE;\n        *mods_rtrn = MOD_REAL_MASK_ALL;\n        return true;\n    }\n    *pred_rtrn = MATCH_EXACTLY;\n    if (expr->expr.op == EXPR_ACTION_DECL) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->action.name);\n        if (!LookupString(symInterpretMatchMaskNames, pred_txt, pred_rtrn)) {\n            log_err(info->ctx,\n                    \"Illegal modifier predicate \\\"%s\\\"; Ignored\\n\", pred_txt);\n            return false;\n        }\n        expr = expr->action.args;\n    }\n    else if (expr->expr.op == EXPR_IDENT) {\n        const char *pred_txt = xkb_atom_text(info->ctx, expr->ident.ident);\n        if (pred_txt && istreq(pred_txt, \"any\")) {\n            *pred_rtrn = MATCH_ANY;\n            *mods_rtrn = MOD_REAL_MASK_ALL;\n            return true;\n        }\n    }\n    return ExprResolveModMask(info->ctx, expr, MOD_REAL, &info->mods,\n                              mods_rtrn);\n}", "target": 1}
{"code": "char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n{\n\tchar         *d   = NULL;\n\tchar         *out = NULL;\n\tM_fs_error_t  res;\n#ifdef _WIN32\n\tsize_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;\n\td = M_malloc_zero(len);\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/var/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n#endif\n\tif (d != NULL) {\n\t\tres = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tout = NULL;\n\t\t}\n\t}\n\tM_free(d);\n\treturn out;\n}", "target": 1}
{"code": "GSList* menu_cache_list_all_apps(MenuCache* cache)\n{\n    GSList* list;\n    MENU_CACHE_LOCK;\n    if (G_UNLIKELY(!cache->root_dir)) \n        list = NULL;\n    else\n        list = list_app_in_dir(cache->root_dir, NULL);\n    MENU_CACHE_UNLOCK;\n    return list;\n}", "target": 0}
{"code": "  void operator()(OpKernelContext* ctx, const Index num_segments,\n                  const TensorShape& segment_ids_shape,\n                  typename TTypes<Index>::ConstFlat segment_ids,\n                  const Index data_size, const T* data,\n                  typename TTypes<T, 2>::Tensor output) {\n    output.setConstant(InitialValueF()());\n    if (data_size == 0) {\n      return;\n    }\n    const int64 N = segment_ids.dimension(0);\n    ReductionF reduction;\n    auto data_flat = typename TTypes<T, 2>::ConstTensor(data, N, data_size / N);\n    for (int64 i = 0; i < N; ++i) {\n      Index j = internal::SubtleMustCopy(segment_ids(i));\n      if (j < 0) {\n        continue;\n      }\n      OP_REQUIRES(ctx, FastBoundsCheck(j, num_segments),\n                  errors::InvalidArgument(\n                      \"segment_ids\", SliceDebugString(segment_ids_shape, i),\n                      \" = \", j, \" is out of range [0, \", num_segments, \")\"));\n      reduction(data_flat.template chip<0>(i), output.template chip<0>(j));\n    }\n  }", "target": 1}
{"code": "print_attr_string(netdissect_options *ndo,\n                  register const u_char *data, u_int length, u_short attr_code)\n{\n   register u_int i;\n   ND_TCHECK2(data[0],length);\n   switch(attr_code)\n   {\n      case TUNNEL_PASS:\n           if (length < 3)\n           {\n              ND_PRINT((ndo, \"%s\", tstr));\n              return;\n           }\n           if (*data && (*data <=0x1F) )\n              ND_PRINT((ndo, \"Tag[%u] \", *data));\n           else\n              ND_PRINT((ndo, \"Tag[Unused] \"));\n           data++;\n           length--;\n           ND_PRINT((ndo, \"Salt %u \", EXTRACT_16BITS(data)));\n           data+=2;\n           length-=2;\n        break;\n      case TUNNEL_CLIENT_END:\n      case TUNNEL_SERVER_END:\n      case TUNNEL_PRIV_GROUP:\n      case TUNNEL_ASSIGN_ID:\n      case TUNNEL_CLIENT_AUTH:\n      case TUNNEL_SERVER_AUTH:\n           if (*data <= 0x1F)\n           {\n              if (length < 1)\n              {\n                 ND_PRINT((ndo, \"%s\", tstr));\n                 return;\n              }\n              if (*data)\n                ND_PRINT((ndo, \"Tag[%u] \", *data));\n              else\n                ND_PRINT((ndo, \"Tag[Unused] \"));\n              data++;\n              length--;\n           }\n        break;\n      case EGRESS_VLAN_NAME:\n           ND_PRINT((ndo, \"%s (0x%02x) \",\n                  tok2str(rfc4675_tagged,\"Unknown tag\",*data),\n                  *data));\n           data++;\n           length--;\n        break;\n   }\n   for (i=0; *data && i < length ; i++, data++)\n       ND_PRINT((ndo, \"%c\", (*data < 32 || *data > 126) ? '.' : *data));\n   return;\n   trunc:\n      ND_PRINT((ndo, \"%s\", tstr));\n}", "target": 1}
{"code": "static int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tint alt;\n\talt = uas_find_uas_alt_setting(intf);\n\tif (alt < 0)\n\t\treturn alt;\n\treturn usb_set_interface(udev,\n\t\t\tintf->altsetting[0].desc.bInterfaceNumber, alt);\n}", "target": 1}
{"code": "Eina_Bool ewk_view_editable_set(Evas_Object* ewkView, Eina_Bool editable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_editable_set(smartData->main_frame, editable);\n}", "target": 0}
{"code": "void UnbufferedAsioTlsStream::BeforeHandshake(handshake_type type)\n{\n\tnamespace ssl = boost::asio::ssl;\n\tif (!m_Hostname.IsEmpty()) {\n\t\tX509_VERIFY_PARAM_set1_host(SSL_get0_param(native_handle()), m_Hostname.CStr(), m_Hostname.GetLength());\n\t}\n\tset_verify_mode(ssl::verify_peer | ssl::verify_client_once);\n\tset_verify_callback([this](bool preverified, ssl::verify_context& ctx) {\n\t\tif (!preverified) {\n\t\t\tm_VerifyOK = false;\n\t\t\tstd::ostringstream msgbuf;\n\t\t\tint err = X509_STORE_CTX_get_error(ctx.native_handle());\n\t\t\tmsgbuf << \"code \" << err << \": \" << X509_verify_cert_error_string(err);\n\t\t\tm_VerifyError = msgbuf.str();\n\t\t}\n\t\treturn true;\n\t});\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n\tif (type == client && !m_Hostname.IsEmpty()) {\n\t\tString environmentName = Application::GetAppEnvironment();\n\t\tString serverName = m_Hostname;\n\t\tif (!environmentName.IsEmpty())\n\t\t\tserverName += \":\" + environmentName;\n\t\tSSL_set_tlsext_host_name(native_handle(), serverName.CStr());\n\t}\n#endif \n}", "target": 1}
{"code": "match_expr(struct search_node_list *head, struct eventlog *evlog, bool last_match)\n{\n    struct search_node *sn;\n    bool res = false, matched = last_match;\n    int rc;\n    debug_decl(match_expr, SUDO_DEBUG_UTIL);\n    STAILQ_FOREACH(sn, head, entries) {\n\tswitch (sn->type) {\n\tcase ST_EXPR:\n\t    res = match_expr(&sn->u.expr, evlog, matched);\n\t    break;\n\tcase ST_CWD:\n\t    if (evlog->cwd != NULL)\n\t\tres = strcmp(sn->u.cwd, evlog->cwd) == 0;\n\t    break;\n\tcase ST_HOST:\n\t    if (evlog->submithost != NULL)\n\t\tres = strcmp(sn->u.host, evlog->submithost) == 0;\n\t    break;\n\tcase ST_TTY:\n\t    if (evlog->ttyname != NULL)\n\t\tres = strcmp(sn->u.tty, evlog->ttyname) == 0;\n\t    break;\n\tcase ST_RUNASGROUP:\n\t    if (evlog->rungroup != NULL)\n\t\tres = strcmp(sn->u.runas_group, evlog->rungroup) == 0;\n\t    break;\n\tcase ST_RUNASUSER:\n\t    if (evlog->runuser != NULL)\n\t\tres = strcmp(sn->u.runas_user, evlog->runuser) == 0;\n\t    break;\n\tcase ST_USER:\n\t    if (evlog->submituser != NULL)\n\t\tres = strcmp(sn->u.user, evlog->submituser) == 0;\n\t    break;\n\tcase ST_PATTERN:\n\t    rc = regexec(&sn->u.cmdre, evlog->command, 0, NULL, 0);\n\t    if (rc && rc != REG_NOMATCH) {\n\t\tchar buf[BUFSIZ];\n\t\tregerror(rc, &sn->u.cmdre, buf, sizeof(buf));\n\t\tsudo_fatalx(\"%s\", buf);\n\t    }\n\t    res = rc == REG_NOMATCH ? 0 : 1;\n\t    break;\n\tcase ST_FROMDATE:\n\t    res = sudo_timespeccmp(&evlog->submit_time, &sn->u.tstamp, >=);\n\t    break;\n\tcase ST_TODATE:\n\t    res = sudo_timespeccmp(&evlog->submit_time, &sn->u.tstamp, <=);\n\t    break;\n\tdefault:\n\t    sudo_fatalx(U_(\"unknown search type %d\"), sn->type);\n\t}\n\tif (sn->negated)\n\t    res = !res;\n\tmatched = sn->or ? (res || last_match) : (res && last_match);\n\tlast_match = matched;\n    }\n    debug_return_bool(matched);\n}", "target": 1}
{"code": "PHP_FUNCTION(mb_ereg_search_setpos)\n{\n\tlong position;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &position) == FAILURE) {\n\t\treturn;\n\t}\n\tif (position < 0 || (MBREX(search_str) != NULL && Z_TYPE_P(MBREX(search_str)) == IS_STRING && position >= Z_STRLEN_P(MBREX(search_str)))) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Position is out of range\");\n\t\tMBREX(search_pos) = 0;\n\t\tRETURN_FALSE;\n\t}\n\tMBREX(search_pos) = position;\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "static void new_huffman_tree(x3f_hufftree_t *HTP, int bits)\n{\n  int leaves = 1 << bits;\n  HTP->free_node_index = 0;\n  HTP->total_node_index = HUF_TREE_MAX_NODES(leaves);\n  HTP->nodes = (x3f_huffnode_t *)calloc(1, HUF_TREE_MAX_NODES(leaves) *\n                                               sizeof(x3f_huffnode_t));\n}", "target": 0}
{"code": "processBatchMultiRuleset(batch_t *pBatch)\n{\n\truleset_t *currRuleset;\n\tbatch_t snglRuleBatch;\n\tint i;\n\tint iStart;\t\n\tint iNew;\t\n\tDEFiRet;\n\tCHKiRet(batchInit(&snglRuleBatch, pBatch->nElem));\n\tsnglRuleBatch.pbShutdownImmediate = pBatch->pbShutdownImmediate;\n\twhile(1) { \n\t\tfor(iStart = 0 ; iStart < pBatch->nElem && pBatch->pElem[iStart].state == BATCH_STATE_DISC ; ++iStart)\n\t\t\t;\n\t\tif(iStart == pBatch->nElem)\n\t\t\tFINALIZE; \n\t\tcurrRuleset = batchElemGetRuleset(pBatch, iStart);\n\t\tiNew = 0;\n\t\tfor(i = iStart ; i < pBatch->nElem ; ++i) {\n\t\t\tif(batchElemGetRuleset(pBatch, i) == currRuleset) {\n\t\t\t\tbatchCopyElem(&(snglRuleBatch.pElem[iNew++]), &(pBatch->pElem[i]));\n\t\t\t\tpBatch->pElem[i].state = BATCH_STATE_DISC;\n\t\t\t}\n\t\t}\n\t\tsnglRuleBatch.nElem = iNew; \n\t\tbatchSetSingleRuleset(&snglRuleBatch, 1);\n\t\tprocessBatch(&snglRuleBatch);\n\t}\n\tbatchFree(&snglRuleBatch);\nfinalize_it:\n\tRETiRet;\n}", "target": 1}
{"code": "Bool gf_isom_is_self_contained(GF_ISOFile *the_file, u32 trackNumber, u32 sampleDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_FALSE;\n\treturn Media_IsSelfContained(trak->Media, sampleDescriptionIndex);\n}", "target": 0}
{"code": "static void __net_exit sctp_defaults_exit(struct net *net)\n{\n\tsctp_free_addr_wq(net);\n\tsctp_free_local_addr_list(net);\n\tsctp_dbg_objcnt_exit(net);\n\tsctp_proc_exit(net);\n\tcleanup_sctp_mibs(net);\n\tsctp_sysctl_net_unregister(net);\n}", "target": 0}
{"code": "int options_cmdline(char *arg1, char *arg2) {\n    char *name;\n    CONF_TYPE type;\n#ifdef USE_WIN32\n    (void)arg2; \n#endif\n    if(!arg1) {\n        name=\n#ifdef CONFDIR\n            CONFDIR\n#ifdef USE_WIN32\n            \"\\\\\"\n#else\n            \"/\"\n#endif\n#endif\n            \"stunnel.conf\";\n        type=CONF_FILE;\n    } else if(!strcasecmp(arg1, \"-help\")) {\n        parse_global_option(CMD_PRINT_HELP, NULL, NULL);\n        parse_service_option(CMD_PRINT_HELP, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-version\")) {\n        parse_global_option(CMD_PRINT_DEFAULTS, NULL, NULL);\n        parse_service_option(CMD_PRINT_DEFAULTS, NULL, NULL, NULL);\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-sockets\")) {\n        socket_options_print();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else if(!strcasecmp(arg1, \"-options\")) {\n        print_ssl_options();\n        log_flush(LOG_MODE_INFO);\n        return 2;\n    } else\n#ifndef USE_WIN32\n    if(!strcasecmp(arg1, \"-fd\")) {\n        if(!arg2) {\n            s_log(LOG_ERR, \"No file descriptor specified\");\n            print_syntax();\n            return 1;\n        }\n        name=arg2;\n        type=CONF_FD;\n    } else\n#endif\n    {\n        name=arg1;\n        type=CONF_FILE;\n    }\n    if(type==CONF_FILE) {\n#ifdef HAVE_REALPATH\n        char *real_path=NULL;\n#ifdef MAXPATHLEN\n        real_path=malloc(MAXPATHLEN);\n#endif\n        real_path=realpath(name, real_path);\n        if(!real_path) {\n            s_log(LOG_ERR, \"Invalid configuration file name \\\"%s\\\"\", name);\n            ioerror(\"realpath\");\n            return 1;\n        }\n        configuration_file=str_dup(real_path);\n        free(real_path);\n#else\n        configuration_file=str_dup(name);\n#endif\n#ifndef USE_WIN32\n    } else if(type==CONF_FD) {\n        configuration_file=str_dup(name);\n#endif\n    }\n    return options_parse(type);\n}", "target": 1}
{"code": "static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,\n                                     uint32_t lun, void *hba_private)\n{\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);\n    SCSIRequest *req;\n    SCSIDiskReq *r;\n    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);\n    r = DO_UPCAST(SCSIDiskReq, req, req);\n    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);\n    return req;\n}", "target": 1}
{"code": "static int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\t\tcb->args[0] = 1;\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "static ssize_t cm_write(struct file *file, const char __user * user_buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstatic char *buf;\n\tstatic u32 max_size;\n\tstatic u32 uncopied_bytes;\n\tstruct acpi_table_header table;\n\tacpi_status status;\n\tif (!(*ppos)) {\n\t\tif (count <= sizeof(struct acpi_table_header))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&table, user_buf,\n\t\t\t\t   sizeof(struct acpi_table_header)))\n\t\t\treturn -EFAULT;\n\t\tuncopied_bytes = max_size = table.length;\n\t\tbuf = kzalloc(max_size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (buf == NULL)\n\t\treturn -EINVAL;\n\tif ((*ppos > max_size) ||\n\t    (*ppos + count > max_size) ||\n\t    (*ppos + count < count) ||\n\t    (count > uncopied_bytes))\n\t\treturn -EINVAL;\n\tif (copy_from_user(buf + (*ppos), user_buf, count)) {\n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t\treturn -EFAULT;\n\t}\n\tuncopied_bytes -= count;\n\t*ppos += count;\n\tif (!uncopied_bytes) {\n\t\tstatus = acpi_install_method(buf);\n\t\tkfree(buf);\n\t\tbuf = NULL;\n\t\tif (ACPI_FAILURE(status))\n\t\t\treturn -EINVAL;\n\t\tadd_taint(TAINT_OVERRIDDEN_ACPI_TABLE);\n\t}\n\treturn count;\n}", "target": 0}
{"code": "libxlDomainObjPrivateAlloc(void *opaque G_GNUC_UNUSED)\n{\n    libxlDomainObjPrivate *priv;\n    priv = g_new0(libxlDomainObjPrivate, 1);\n    if (!(priv->devs = virChrdevAlloc())) {\n        g_free(priv);\n        return NULL;\n    }\n    if (libxlDomainObjInitJob(priv) < 0) {\n        virChrdevFree(priv->devs);\n        g_free(priv);\n        return NULL;\n    }\n    return priv;\n}", "target": 0}
{"code": "static inline bool CheckForOverflow(double as_double, T* out) {\n  return (sizeof(T) < sizeof(double) && std::isinf(*out) &&\n          std::isfinite(as_double));\n}", "target": 0}
{"code": "STACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)\n{\n    STACK_OF(PKCS7) *p7s;\n    PKCS7_CTX *p7ctx;\n    PKCS7 *p7;\n    int i;\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p12->authsafes->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    p7ctx = &p12->authsafes->ctx;\n    p7s = ASN1_item_unpack_ex(p12->authsafes->d.data,\n                              ASN1_ITEM_rptr(PKCS12_AUTHSAFES),\n                              ossl_pkcs7_ctx_get0_libctx(p7ctx),\n                              ossl_pkcs7_ctx_get0_propq(p7ctx));\n    if (p7s != NULL) {\n        for (i = 0; i < sk_PKCS7_num(p7s); i++) {\n            p7 = sk_PKCS7_value(p7s, i);\n            if (!ossl_pkcs7_ctx_propagate(p12->authsafes, p7))\n                goto err;\n        }\n    }\n    return p7s;\nerr:\n    sk_PKCS7_free(p7s);\n    return NULL;\n}", "target": 0}
{"code": "static int target_xcopy_locate_se_dev_e4_iter(struct se_device *se_dev,\n\t\t\t\t\t      void *data)\n{\n\tstruct xcopy_dev_search_info *info = data;\n\tunsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];\n\tint rc;\n\tif (!se_dev->dev_attrib.emulate_3pc)\n\t\treturn 0;\n\tmemset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);\n\ttarget_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);\n\trc = memcmp(&tmp_dev_wwn[0], info->dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);\n\tif (rc != 0)\n\t\treturn 0;\n\tinfo->found_dev = se_dev;\n\tpr_debug(\"XCOPY 0xe4: located se_dev: %p\\n\", se_dev);\n\trc = target_depend_item(&se_dev->dev_group.cg_item);\n\tif (rc != 0) {\n\t\tpr_err(\"configfs_depend_item attempt failed: %d for se_dev: %p\\n\",\n\t\t       rc, se_dev);\n\t\treturn rc;\n\t}\n\tpr_debug(\"Called configfs_depend_item for se_dev: %p se_dev->se_dev_group: %p\\n\",\n\t\t se_dev, &se_dev->dev_group);\n\treturn 1;\n}", "target": 1}
{"code": "int ziplistSafeToAdd(unsigned char* zl, size_t add) {\n    size_t len = zl? ziplistBlobLen(zl): 0;\n    if (len + add > ZIPLIST_MAX_SAFETY_SIZE)\n        return 0;\n    return 1;\n}", "target": 0}
{"code": "yy_symbol_value_print (FILE *yyo,\n                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  FILE *yyoutput = yyo;\n  YY_USE (yyoutput);\n  YY_USE (yylocationp);\n  YY_USE (parm);\n  if (!yyvaluep)\n    return;\n# ifdef YYPRINT\n  if (yykind < YYNTOKENS)\n    YYPRINT (yyo, yytoknum[yykind], *yyvaluep);\n# endif\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  YY_USE (yykind);\n  YY_IGNORE_MAYBE_UNINITIALIZED_END\n}", "target": 1}
{"code": "int SSL_free_buffers(SSL *ssl)\n{\n    RECORD_LAYER *rl = &ssl->rlayer;\n    if (RECORD_LAYER_read_pending(rl) || RECORD_LAYER_write_pending(rl))\n        return 0;\n    if (RECORD_LAYER_data_present(rl))\n        return 0;\n    RECORD_LAYER_release(rl);\n    return 1;\n}", "target": 0}
{"code": "static TEE_Result do_alloc_keypair(struct rsa_keypair *s,\n\t\t\t\t   size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->d))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->n))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->qp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dp))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->dq))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "TEST_FUNCTION_INITIALIZE(test_init)\n{\n    if (TEST_MUTEX_ACQUIRE(g_testByTest))\n    {\n        ASSERT_FAIL(\"our mutex is ABANDONED. Failure in test framework\");\n    }\n    umock_c_reset_all_calls();\n}", "target": 0}
{"code": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}", "target": 1}
{"code": "ResourceHandle::ResourceHandle(const ResourceHandleProto& proto) {\n  FromProto(proto);\n}", "target": 1}
{"code": "void __scm_destroy(struct scm_cookie *scm)\n{\n\tstruct scm_fp_list *fpl = scm->fp;\n\tint i;\n\tif (fpl) {\n\t\tscm->fp = NULL;\n\t\tfor (i=fpl->count-1; i>=0; i--)\n\t\t\tfput(fpl->fp[i]);\n\t\tfree_uid(fpl->user);\n\t\tkfree(fpl);\n\t}\n}", "target": 0}
{"code": "double enclave_check_abi()\n{\n    double retval = NAN;\n    oe_result_t result = OE_UNEXPECTED;\n    abi_state_t before_ocall_state = {};\n    abi_state_t after_ocall_state = {};\n    typedef struct _host_check_abi_args_t\n    {\n        oe_result_t _result;\n        void* deepcopy_out_buffer;\n        size_t deepcopy_out_buffer_size;\n        double _retval;\n    } host_check_abi_args_t;\n    typedef struct _flat_ocall_args\n    {\n        oe_call_host_function_args_t host_function_args;\n        host_check_abi_args_t check_abi_args;\n    } flat_ocall_args_t;\n    static const size_t abi_fcn_id_host_check_abi = 0;\n    const flat_ocall_args_t args_template = {\n        {.function_id = abi_fcn_id_host_check_abi,\n         .input_buffer = NULL,\n         .input_buffer_size = sizeof(args_template.check_abi_args),\n         .output_buffer = NULL,\n         .output_buffer_size = sizeof(args_template.check_abi_args),\n         .output_bytes_written = 0,\n         .result = OE_UNEXPECTED},\n        {._result = OE_UNEXPECTED,\n         .deepcopy_out_buffer = NULL,\n         .deepcopy_out_buffer_size = 0,\n         ._retval = 0}};\n    flat_ocall_args_t* args =\n        (flat_ocall_args_t*)oe_allocate_ocall_buffer(sizeof(args_template));\n    if (!args)\n        goto done;\n    memcpy(args, &args_template, sizeof(args_template));\n    args->host_function_args.input_buffer = &args->check_abi_args;\n    args->host_function_args.output_buffer = &args->check_abi_args;\n    set_test_abi_state();\n    read_abi_state(&before_ocall_state);\n    result = oe_ocall(OE_OCALL_CALL_HOST_FUNCTION, (uint64_t)args, NULL);\n    read_abi_state(&after_ocall_state);\n    reset_test_abi_state();\n    if (result != OE_OK)\n        goto done;\n    if (args->host_function_args.result != OE_OK)\n        goto done;\n    if (args->host_function_args.output_bytes_written !=\n        sizeof(args_template.check_abi_args))\n        goto done;\n    if (args->check_abi_args._retval != EXPECTED_CHECK_ABI_RETURN_VALUE)\n        goto done;\n    if (!is_same_abi_state(&before_ocall_state, &after_ocall_state))\n        goto done;\n    retval = args->check_abi_args._retval;\ndone:\n    return retval;\n}", "target": 1}
{"code": "asmlinkage long sys_oabi_semtimedop(int semid,\n\t\t\t\t    struct oabi_sembuf __user *tsops,\n\t\t\t\t    unsigned nsops,\n\t\t\t\t    const struct timespec __user *timeout)\n{\n\tstruct sembuf *sops;\n\tstruct timespec local_timeout;\n\tlong err;\n\tint i;\n\tif (nsops < 1)\n\t\treturn -EINVAL;\n\tsops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);\n\tif (!sops)\n\t\treturn -ENOMEM;\n\terr = 0;\n\tfor (i = 0; i < nsops; i++) {\n\t\t__get_user_error(sops[i].sem_num, &tsops->sem_num, err);\n\t\t__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);\n\t\t__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);\n\t\ttsops++;\n\t}\n\tif (timeout) {\n\t\terr |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));\n\t\ttimeout = &local_timeout;\n\t}\n\tif (err) {\n\t\terr = -EFAULT;\n\t} else {\n\t\tmm_segment_t fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = sys_semtimedop(semid, sops, nsops, timeout);\n\t\tset_fs(fs);\n\t}\n\tkfree(sops);\n\treturn err;\n}", "target": 1}
{"code": "error::Error GLES2DecoderImpl::GetAttribLocationHelper(\n    GLuint client_id, uint32 location_shm_id, uint32 location_shm_offset,\n    const std::string& name_str) {\n  if (!StringIsValidForGLES(name_str.c_str())) {\n    SetGLError(GL_INVALID_VALUE, \"glGetAttribLocation: Invalid character\");\n    return error::kNoError;\n  }\n  ProgramManager::ProgramInfo* info = GetProgramInfoNotShader(\n      client_id, \"glGetAttribLocation\");\n  if (!info) {\n    return error::kNoError;\n  }\n  if (!info->IsValid()) {\n    SetGLError(GL_INVALID_OPERATION, \"glGetAttribLocation: program not linked\");\n    return error::kNoError;\n  }\n  GLint* location = GetSharedMemoryAs<GLint*>(\n      location_shm_id, location_shm_offset, sizeof(GLint));\n  if (!location) {\n    return error::kOutOfBounds;\n  }\n  if (*location != -1) {\n    return error::kGenericError;\n  }\n  *location = info->GetAttribLocation(name_str);\n  return error::kNoError;\n}", "target": 0}
{"code": "void nodeRename(Proxy &node, const RegexMatchConfigs &rename_array, extra_settings &ext)\n{\n    std::string &remark = node.Remark, original_remark = node.Remark, returned_remark, real_rule;\n    for(const RegexMatchConfig &x : rename_array)\n    {\n        if(!x.Script.empty())\n        {\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                std::string script = x.Script;\n                if(startsWith(script, \"path:\"))\n                    script = fileGet(script.substr(5), true);\n                try\n                {\n                    ctx.eval(script);\n                    auto rename = (std::function<std::string(const Proxy&)>) ctx.eval(\"rename\");\n                    returned_remark = rename(node);\n                    if(!returned_remark.empty())\n                        remark = returned_remark;\n                }\n                catch (qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n            continue;\n        }\n        if(applyMatcher(x.Match, real_rule, node) && real_rule.size())\n            remark = regReplace(remark, real_rule, x.Replace);\n    }\n    if(remark.empty())\n        remark = original_remark;\n    return;\n}", "target": 1}
{"code": "lt_dlgetinfo (lt_dlhandle handle)\n{\n  if (!handle)\n    {\n      LT__SETERROR (INVALID_HANDLE);\n      return 0;\n    }\n  return &(handle->info);\n}", "target": 0}
{"code": "absl::optional<CelValue> RequestWrapper::operator[](CelValue key) const {\n  if (!key.IsString()) {\n    return {};\n  }\n  auto value = key.StringOrDie().value();\n  if (value == Headers) {\n    return CelValue::CreateMap(&headers_);\n  } else if (value == Time) {\n    return CelValue::CreateTimestamp(absl::FromChrono(info_.startTime()));\n  } else if (value == Size) {\n    if (headers_.value_ != nullptr && headers_.value_->ContentLength() != nullptr) {\n      int64_t length;\n      if (absl::SimpleAtoi(headers_.value_->ContentLength()->value().getStringView(), &length)) {\n        return CelValue::CreateInt64(length);\n      }\n    } else {\n      return CelValue::CreateInt64(info_.bytesReceived());\n    }\n  } else if (value == Duration) {\n    auto duration = info_.requestComplete();\n    if (duration.has_value()) {\n      return CelValue::CreateDuration(absl::FromChrono(duration.value()));\n    }\n  }\n  if (headers_.value_ != nullptr) {\n    if (value == Path) {\n      return convertHeaderEntry(headers_.value_->Path());\n    } else if (value == UrlPath) {\n      absl::string_view path = headers_.value_->Path()->value().getStringView();\n      size_t query_offset = path.find('?');\n      if (query_offset == absl::string_view::npos) {\n        return CelValue::CreateString(path);\n      }\n      return CelValue::CreateString(path.substr(0, query_offset));\n    } else if (value == Host) {\n      return convertHeaderEntry(headers_.value_->Host());\n    } else if (value == Scheme) {\n      return convertHeaderEntry(headers_.value_->Scheme());\n    } else if (value == Method) {\n      return convertHeaderEntry(headers_.value_->Method());\n    } else if (value == Referer) {\n      return convertHeaderEntry(headers_.value_->Referer());\n    } else if (value == ID) {\n      return convertHeaderEntry(headers_.value_->RequestId());\n    } else if (value == UserAgent) {\n      return convertHeaderEntry(headers_.value_->UserAgent());\n    } else if (value == TotalSize) {\n      return CelValue::CreateInt64(info_.bytesReceived() + headers_.value_->byteSize());\n    }\n  }\n  return {};\n}", "target": 1}
{"code": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tint i, len;\n\tsize_t len_sent = 0;\n\tconst char __user *p;\n\tchar *buf;\n\tp = (const char __user *)current->mm->arg_start;\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\tbuf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tfor (i = 0; i < context->execve.argc; i++) {\n\t\tlen = audit_log_single_execve_arg(context, ab, i,\n\t\t\t\t\t\t  &len_sent, p, buf);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n}", "target": 1}
{"code": "ext2_xattr_cache_insert(struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\tce = mb_cache_entry_alloc(ext2_xattr_cache, GFP_NOFS);\n\tif (!ce)\n\t\treturn -ENOMEM;\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache (%d cache entries)\",\n\t\t\t\tatomic_read(&ext2_xattr_cache->c_entry_count));\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x] (%d cache entries)\", (int)hash,\n\t\t\t  atomic_read(&ext2_xattr_cache->c_entry_count));\n\t\tmb_cache_entry_release(ce);\n\t}\n\treturn error;\n}", "target": 1}
{"code": "TEST_F(QuotedString_ExtractFrom_Tests, UnterminatedEscapeSequence) {\n  whenInputIs(\"\\\"\\\\\\0\\\"\", 4);\n  resultMustBe(0);\n}", "target": 0}
{"code": "static QSvgNode *createPathNode(QSvgNode *parent,\n                                const QXmlStreamAttributes &attributes,\n                                QSvgHandler *)\n{\n    QStringRef data      = attributes.value(QLatin1String(\"d\"));\n    QPainterPath qpath;\n    qpath.setFillRule(Qt::WindingFill);\n    parsePathDataFast(data, qpath);\n    QSvgNode *path = new QSvgPath(parent, qpath);\n    return path;\n}", "target": 1}
{"code": "Mgr::IoActionData::operator += (const IoActionData& stats)\n{\n    http_reads += stats.http_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        http_read_hist[i] += stats.http_read_hist[i];\n    ftp_reads += stats.ftp_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        ftp_read_hist[i] += stats.ftp_read_hist[i];\n    gopher_reads += stats.gopher_reads;\n    for (int i = 0; i < IoStats::histSize; ++i)\n        gopher_read_hist[i] += stats.gopher_read_hist[i];\n    return *this;\n}", "target": 1}
{"code": "TfLiteStatus GatherNd(const TfLiteTensor* params, const TfLiteTensor* indices,\n                      TfLiteTensor* output) {\n  reference_ops::GatherNd(\n      GetTensorShape(params), GetTensorData<ParamsT>(params),\n      GetTensorShape(indices), GetTensorData<IndicesT>(indices),\n      GetTensorShape(output), GetTensorData<ParamsT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "GF_Err gf_isom_get_media_time(GF_ISOFile *the_file, u32 trackNumber, u32 movieTime, u64 *MediaTime)\n{\n\tGF_TrackBox *trak;\n\tu8 useEdit;\n\ts64 SegmentStartTime, mediaOffset;\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !MediaTime) return GF_BAD_PARAM;\n\tSegmentStartTime = 0;\n\treturn GetMediaTime(trak, GF_FALSE, movieTime, MediaTime, &SegmentStartTime, &mediaOffset, &useEdit, NULL);\n}", "target": 0}
{"code": "static uint16_t nvme_get_mgmt_zone_slba_idx(NvmeNamespace *ns, NvmeCmd *c,\n                                            uint64_t *slba, uint32_t *zone_idx)\n{\n    uint32_t dw10 = le32_to_cpu(c->cdw10);\n    uint32_t dw11 = le32_to_cpu(c->cdw11);\n    if (!ns->params.zoned) {\n        trace_pci_nvme_err_invalid_opc(c->opcode);\n        return NVME_INVALID_OPCODE | NVME_DNR;\n    }\n    *slba = ((uint64_t)dw11) << 32 | dw10;\n    if (unlikely(*slba >= ns->id_ns.nsze)) {\n        trace_pci_nvme_err_invalid_lba_range(*slba, 0, ns->id_ns.nsze);\n        *slba = 0;\n        return NVME_LBA_RANGE | NVME_DNR;\n    }\n    *zone_idx = nvme_zone_idx(ns, *slba);\n    assert(*zone_idx < ns->num_zones);\n    return NVME_SUCCESS;\n}", "target": 0}
{"code": "processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n#ifdef XML_DTD\n  entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (const char *)entity->textPtr;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  next = textStart;\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif \n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE,\n                       XML_ACCOUNT_ENTITY_EXPANSION);\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n#ifdef XML_DTD\n      entityTrackingOnClose(parser, entity, __LINE__);\n#endif \n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}", "target": 1}
{"code": "static void *nested_svm_map(struct vcpu_svm *svm, u64 gpa, struct page **_page)\n{\n\tstruct page *page;\n\tmight_sleep();\n\tpage = gfn_to_page(svm->vcpu.kvm, gpa >> PAGE_SHIFT);\n\tif (is_error_page(page))\n\t\tgoto error;\n\t*_page = page;\n\treturn kmap(page);\nerror:\n\tkvm_inject_gp(&svm->vcpu, 0);\n\treturn NULL;\n}", "target": 0}
{"code": "void * pvPortMalloc( size_t xWantedSize )\n{\n    void * pvReturn = NULL;\n    static uint8_t * pucAlignedHeap = NULL;\n    #if ( portBYTE_ALIGNMENT != 1 )\n        {\n            if( xWantedSize & portBYTE_ALIGNMENT_MASK )\n            {\n                xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );\n            }\n        }\n    #endif\n    vTaskSuspendAll();\n    {\n        if( pucAlignedHeap == NULL )\n        {\n            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );\n        }\n        if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&\n            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) \n        {\n            pvReturn = pucAlignedHeap + xNextFreeByte;\n            xNextFreeByte += xWantedSize;\n        }\n        traceMALLOC( pvReturn, xWantedSize );\n    }\n    ( void ) xTaskResumeAll();\n    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )\n        {\n            if( pvReturn == NULL )\n            {\n                extern void vApplicationMallocFailedHook( void );\n                vApplicationMallocFailedHook();\n            }\n        }\n    #endif\n    return pvReturn;\n}", "target": 1}
{"code": "int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\tStream_Read_UINT16(s, fields->Len); \n\tStream_Read_UINT16(s, fields->MaxLen); \n\tStream_Read_UINT32(s, fields->BufferOffset); \n\treturn 1;\n}", "target": 1}
{"code": "flushbuffer(PrintfTarget *target)\n{\n\tsize_t\t\tnc = target->bufptr - target->bufstart;\n\tif (nc > 0)\n\t\ttarget->nchars += fwrite(target->bufstart, 1, nc, target->stream);\n\ttarget->bufptr = target->bufstart;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      OP_REQUIRES(context, ragged_nested_splits_in[i].dims() == 1,\n                  errors::InvalidArgument(\"Requires nested_row_splits[\", i, \"]\",\n                                          \" to be rank 1 but is rank \",\n                                          ragged_nested_splits_in[i].dims()));\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n    if (!batched_input_) {\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n    Tensor* encoded_vector;\n    int64_t output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (auto i = decltype(output_size){}; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }", "target": 0}
{"code": "int nfc_dev_up(struct nfc_dev *dev)\n{\n\tint rc = 0;\n\tpr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (dev->rfkill && rfkill_blocked(dev->rfkill)) {\n\t\trc = -ERFKILL;\n\t\tgoto error;\n\t}\n\tif (dev->fw_download_in_progress) {\n\t\trc = -EBUSY;\n\t\tgoto error;\n\t}\n\tif (dev->dev_up) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\tif (dev->ops->dev_up)\n\t\trc = dev->ops->dev_up(dev);\n\tif (!rc)\n\t\tdev->dev_up = true;\n\tif (dev->ops->discover_se && dev->ops->discover_se(dev))\n\t\tpr_err(\"SE discovery failed\\n\");\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "compare_orports_(const void **_a, const void **_b)\n{\n  const tor_addr_port_t *a = *_a, *b = *_b;\n  int r;\n  if ((r = tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))\n    return r;\n  if ((r = (((int) b->port) - ((int) a->port))))\n    return r;\n  return 0;\n}", "target": 0}
{"code": "static int treo_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *swap_port;\n\tif (!((le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== HANDSPRING_VENDOR_ID) ||\n\t\t(le16_to_cpu(serial->dev->descriptor.idVendor)\n\t\t\t\t\t\t== KYOCERA_VENDOR_ID)) ||\n\t\t(serial->num_interrupt_in == 0))\n\t\treturn 0;\n\tif (serial->num_bulk_in < 2 || serial->num_interrupt_in < 2) {\n\t\tdev_err(&serial->interface->dev, \"missing endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n#define COPY_PORT(dest, src)\t\t\t\t\t\t\\\n\tdo { \\\n\t\tint i;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\tfor (i = 0; i < ARRAY_SIZE(src->read_urbs); ++i) {\t\\\n\t\t\tdest->read_urbs[i] = src->read_urbs[i];\t\t\\\n\t\t\tdest->read_urbs[i]->context = dest;\t\t\\\n\t\t\tdest->bulk_in_buffers[i] = src->bulk_in_buffers[i]; \\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tdest->read_urb = src->read_urb;\t\t\t\t\\\n\t\tdest->bulk_in_endpointAddress = src->bulk_in_endpointAddress;\\\n\t\tdest->bulk_in_buffer = src->bulk_in_buffer;\t\t\\\n\t\tdest->bulk_in_size = src->bulk_in_size;\t\t\t\\\n\t\tdest->interrupt_in_urb = src->interrupt_in_urb;\t\t\\\n\t\tdest->interrupt_in_urb->context = dest;\t\t\t\\\n\t\tdest->interrupt_in_endpointAddress = \\\n\t\t\t\t\tsrc->interrupt_in_endpointAddress;\\\n\t\tdest->interrupt_in_buffer = src->interrupt_in_buffer;\t\\\n\t} while (0);\n\tswap_port = kmalloc(sizeof(*swap_port), GFP_KERNEL);\n\tif (!swap_port)\n\t\treturn -ENOMEM;\n\tCOPY_PORT(swap_port, serial->port[0]);\n\tCOPY_PORT(serial->port[0], serial->port[1]);\n\tCOPY_PORT(serial->port[1], swap_port);\n\tkfree(swap_port);\n\treturn 0;\n}", "target": 0}
{"code": "int h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\tword.ptr = value->ptr - 1; \n\te = value->ptr + value->len;\n\twhile (++word.ptr < e) {\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\tif (unlikely(n == word.ptr)) \n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; \n\t\t\tcl = cl + c;\n\t\t}\n\t\tword.len = n - word.ptr;\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t}\n\treturn !not_first;\n fail:\n\treturn -1;\n}", "target": 1}
{"code": "      return *ptr_min;\n    }\n    const T& min() const {\n      if (is_empty())\n        throw CImgInstanceException(_cimglist_instance\n                                    \"min(): Empty instance.\",\n                                    cimglist_instance);\n      const T *ptr_min = _data->_data;\n      T min_value = *ptr_min;\n      cimglist_for(*this,l) {\n        const CImg<T>& img = _data[l];", "target": 0}
{"code": "static int me_unknown(struct page *p, unsigned long pfn)\n{\n\tpr_err(\"Memory failure: %#lx: Unknown page state\\n\", pfn);\n\treturn MF_FAILED;\n}", "target": 0}
{"code": "static void rb_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t      struct ring_buffer_event *event)\n{\n\tlocal_inc(&cpu_buffer->entries);\n\trb_update_write_stamp(cpu_buffer, event);\n\trb_end_commit(cpu_buffer);\n}", "target": 0}
{"code": "struct torture_suite *torture_smb2_notify_inotify_init(TALLOC_CTX *ctx)\n{\n\tstruct torture_suite *suite = torture_suite_create(ctx, \"notify-inotify\");\n\tsuite->description = talloc_strdup(suite, \"SMB2-NOTIFY tests that use inotify\");\n\ttorture_suite_add_2smb2_test(suite, \"inotify-rename\", torture_smb2_inotify_rename);\n\treturn suite;\n}", "target": 0}
{"code": "int jpc_ppxstab_insert(jpc_ppxstab_t *tab, jpc_ppxstabent_t *ent)\n{\n\tint inspt;\n\tint i;\n\tfor (i = 0; i < tab->numents; ++i) {\n\t\tif (tab->ents[i]->ind > ent->ind) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tinspt = i;\n\tif (tab->numents >= tab->maxents) {\n\t\tif (jpc_ppxstab_grow(tab, tab->maxents + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\tfor (i = tab->numents; i > inspt; --i) {\n\t\ttab->ents[i] = tab->ents[i - 1];\n\t}\n\ttab->ents[i] = ent;\n\t++tab->numents;\n\treturn 0;\n}", "target": 1}
{"code": "static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n\trefcount_set(&net->count, 1);\n\trefcount_set(&net->passive, 1);\n\tget_random_bytes(&net->hash_mix, sizeof(u32));\n\tnet->dev_base_seq = 1;\n\tnet->user_ns = user_ns;\n\tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\tmutex_init(&net->ipv4.ra_mutex);\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\n\tdown_write(&net_rwsem);\n\tlist_add_tail_rcu(&net->list, &net_namespace_list);\n\tup_write(&net_rwsem);\nout:\n\treturn error;\nout_undo:\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\trcu_barrier();\n\tgoto out;\n}", "target": 0}
{"code": "String *Item_decimal::val_str(String *result)\n{\n  result->set_charset(&my_charset_numeric);\n  my_decimal2string(E_DEC_FATAL_ERROR, &decimal_value, 0, 0, 0, result);\n  return result;\n}", "target": 0}
{"code": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}", "target": 1}
{"code": "CertificateValidationContextConfigImpl::getSubjectAltNameMatchers(\n    const envoy::extensions::transport_sockets::tls::v3::CertificateValidationContext& config) {\n  if (!config.match_typed_subject_alt_names().empty() &&\n      !config.match_subject_alt_names().empty()) {\n    throw EnvoyException(\"SAN-based verification using both match_typed_subject_alt_names and \"\n                         \"the deprecated match_subject_alt_names is not allowed\");\n  }\n  std::vector<envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher>\n      subject_alt_name_matchers(config.match_typed_subject_alt_names().begin(),\n                                config.match_typed_subject_alt_names().end());\n  for (const envoy::type::matcher::v3::StringMatcher& matcher : config.match_subject_alt_names()) {\n    static constexpr std::array<\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::SanType, 4>\n        san_types{envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL,\n                  envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS};\n    for (const auto san_type : san_types) {\n      subject_alt_name_matchers.emplace_back();\n      subject_alt_name_matchers.back().set_san_type(san_type);\n      *subject_alt_name_matchers.back().mutable_matcher() = matcher;\n    }\n  }\n  return subject_alt_name_matchers;\n}", "target": 0}
{"code": "merge_agg_lats_step (class ipcp_param_lattices *dest_plats,\n\t\t     HOST_WIDE_INT offset, HOST_WIDE_INT val_size,\n\t\t     struct ipcp_agg_lattice ***aglat,\n\t\t     bool pre_existing, bool *change)\n{\n  gcc_checking_assert (offset >= 0);\n  while (**aglat && (**aglat)->offset < offset)\n    {\n      if ((**aglat)->offset + (**aglat)->size > offset)\n\t{\n\t  set_agg_lats_to_bottom (dest_plats);\n\t  return false;\n\t}\n      *change |= (**aglat)->set_contains_variable ();\n      *aglat = &(**aglat)->next;\n    }\n  if (**aglat && (**aglat)->offset == offset)\n    {\n      if ((**aglat)->size != val_size)\n\t{\n\t  set_agg_lats_to_bottom (dest_plats);\n\t  return false;\n\t}\n      gcc_assert (!(**aglat)->next\n\t\t  || (**aglat)->next->offset >= offset + val_size);\n      return true;\n    }\n  else\n    {\n      struct ipcp_agg_lattice *new_al;\n      if (**aglat && (**aglat)->offset < offset + val_size)\n\t{\n\t  set_agg_lats_to_bottom (dest_plats);\n\t  return false;\n\t}\n      if (dest_plats->aggs_count == param_ipa_max_agg_items)\n\treturn false;\n      dest_plats->aggs_count++;\n      new_al = ipcp_agg_lattice_pool.allocate ();\n      memset (new_al, 0, sizeof (*new_al));\n      new_al->offset = offset;\n      new_al->size = val_size;\n      new_al->contains_variable = pre_existing;\n      new_al->next = **aglat;\n      **aglat = new_al;\n      return true;\n    }\n}", "target": 0}
{"code": "int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\tint rc, xprefix;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txprefix = JFFS2_XPREFIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\trc = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tif (inode->i_mode != mode) {\n\t\t\t\tstruct iattr attr;\n\t\t\t\tattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\t\t\tattr.ia_mode = mode;\n\t\t\t\tattr.ia_ctime = CURRENT_TIME_SEC;\n\t\t\t\trc = jffs2_do_setattr(inode, &attr);\n\t\t\t\tif (rc < 0)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txprefix = JFFS2_XPREFIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\trc = __jffs2_set_acl(inode, xprefix, acl);\n\tif (!rc)\n\t\tset_cached_acl(inode, type, acl);\n\treturn rc;\n}", "target": 1}
{"code": "void CleanupOutput(char *str)\n{\n    char *s, *t;\n    int period = 0;\n    s = t = str;\n    while ( *s && *s != '}' ) {\n        if ( *s == '\\n' ) *s = ' ';\n        if ( ( *s == ' ' || *s == '\\n' ) && ( s[1] == ' ' || s[1] == '\\n' ) ) s++;\n        else *t++ = *s++;\n    }\n    while ( *s ) *t++ = *s++;\n    *t = 0;\n    s = t = str;\n    while ( *s ) {\n        if ( *s == '.' ) { period = 1; *t++ = *s++; }\n        else if ( *s == '-' && s[1] == '0' && s[2] == ' ' ) { s++; }\n        else if ( *s <= '9' && *s >= '0' ) { *t++ = *s++; }\n        else if ( *s == '\\n' && ( t > str && t[-1] == '\\n' ) ) { s++; }\n        else if ( period ) {\n            while ( t > str && t[-1] == '0' ) t--;\n            if ( t > str && t[-1] == '.' ) t--;\n            while ( *s == ' ' && s[1] == ' ' ) s++;\n            period = 0; *t++ = *s++;\n        }\n        else if ( *s == ' ' && s[1] == ' ' ) s++;\n        else {\n            period = 0; *t++ = *s++;\n        }\n    }\n    *t = 0;\n    s = t = str;\n    while ( *s ) {\n        if ( *s == '-' && s[1] == '0' && s[2] == ' ' ) { s++; }\n        else *t++ = *s++;\n    }\n    *t = 0;\n}", "target": 1}
{"code": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}", "target": 1}
{"code": "vrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}", "target": 1}
{"code": "AnimatedPropertyType SVGAnimateElement::determineAnimatedPropertyType(SVGElement* targetElement) const\n{\n    ASSERT(targetElement);\n    Vector<AnimatedPropertyType> propertyTypes;\n    targetElement->animatedPropertyTypeForAttribute(attributeName(), propertyTypes);\n    if (propertyTypes.isEmpty())\n        return AnimatedUnknown;\n    ASSERT(propertyTypes.size() <= 2);\n    AnimatedPropertyType type = propertyTypes[0];\n    if (hasTagName(SVGNames::animateColorTag) && type != AnimatedColor)\n        return AnimatedUnknown;\n    if (type == AnimatedTransformList && !hasTagName(SVGNames::animateTransformTag))\n        return AnimatedUnknown;\n    if (targetElement->hasTagName(SVGNames::markerTag) && type == AnimatedAngle) {\n        ASSERT(propertyTypes.size() == 2);\n        ASSERT(propertyTypes[0] == AnimatedAngle);\n        ASSERT(propertyTypes[1] == AnimatedEnumeration);\n    } else if (propertyTypes.size() == 2)\n        ASSERT(propertyTypes[0] == propertyTypes[1]);\n    return type;\n}", "target": 0}
{"code": "int CLua::loadfile(lua_State *ls, const char *filename, bool trusted,\n                   bool die_on_fail)\n{\n    if (!ls)\n        return -1;\n    if (!is_path_safe(filename, trusted))\n    {\n        lua_pushstring(\n            ls,\n            make_stringf(\"invalid filename: %s\", filename).c_str());\n        return -1;\n    }\n    string file = datafile_path(filename, die_on_fail);\n    if (file.empty())\n    {\n        lua_pushstring(ls,\n                       make_stringf(\"Can't find \\\"%s\\\"\", filename).c_str());\n        return -1;\n    }\n    FileLineInput f(file.c_str());\n    string script;\n    while (!f.eof())\n        script += f.get_line() + \"\\n\";\n    if (script[0] == 0x1b)\n        abort();\n    return luaL_loadbuffer(ls, &script[0], script.length(),\n                           (\"@\" + file).c_str());\n}", "target": 0}
{"code": "ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tstruct buffer_head *bh = NULL;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tea_idebug(inode, \"buffer=%p, buffer_size=%ld\",\n\t\t  buffer, (long)buffer_size);\n\terror = 0;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\terror = -EIO;\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\terror = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}", "target": 1}
{"code": "static inline void encode_openhdr(struct xdr_stream *xdr, const struct nfs_openargs *arg)\n{\n\t__be32 *p;\n\tRESERVE_SPACE(8);\n\tWRITE32(OP_OPEN);\n\tWRITE32(arg->seqid->sequence->counter);\n\tencode_share_access(xdr, arg->open_flags);\n\tRESERVE_SPACE(28);\n\tWRITE64(arg->clientid);\n\tWRITE32(16);\n\tWRITEMEM(\"open id:\", 8);\n\tWRITE64(arg->id);\n}", "target": 1}
{"code": "bool CmdExtract::ExtractFileCopy(File &New,wchar *ArcName,const wchar *RedirName,wchar *NameNew,wchar *NameExisting,size_t NameExistingSize,int64 UnpSize)\n{\n  SlashToNative(NameExisting,NameExisting,NameExistingSize); \n  File Existing;\n  if (!Existing.Open(NameExisting))\n  {\n    bool OpenFailed=true;\n    for (size_t I=0;I<RefList.Size();I++)\n      if (wcscmp(RedirName,RefList[I].RefName)==0 && RefList[I].TmpName!=NULL)\n      {\n        bool RefMove=RefList[I].RefCount-- == 1;\n        NameExisting=RefList[I].TmpName;\n        if (RefMove) \n        {\n          New.Delete(); \n          bool MoveFailed=!RenameFile(NameExisting,NameNew);\n          if (MoveFailed)\n          {\n            if (!New.WCreate(NameNew,FMF_WRITE|FMF_SHAREREAD))\n              return false;\n            RefMove=false; \n          }\n          else\n          {\n            if (New.Open(NameNew))\n              New.Seek(0,SEEK_END);\n            free(RefList[I].TmpName);\n            RefList[I].TmpName=NULL;\n            return true;\n          }\n        }\n        if (!RefMove)\n          OpenFailed=!Existing.Open(NameExisting);\n        break;\n      }\n    if (OpenFailed)\n    {\n      ErrHandler.OpenErrorMsg(NameExisting);\n      uiMsg(UIERROR_FILECOPY,ArcName,NameExisting,NameNew);\n      uiMsg(UIERROR_FILECOPYHINT,ArcName);\n#ifdef RARDLL\n      Cmd->DllError=ERAR_EREFERENCE;\n#endif\n      return false;\n    }\n  }\n  Array<byte> Buffer(0x100000);\n  int64 CopySize=0;\n  while (true)\n  {\n    Wait();\n    int ReadSize=Existing.Read(&Buffer[0],Buffer.Size());\n    if (ReadSize==0)\n      break;\n    uiExtractProgress(CopySize,UnpSize,0,0);\n    New.Write(&Buffer[0],ReadSize);\n    CopySize+=ReadSize;\n  }\n  return true;\n}", "target": 1}
{"code": "unsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tsize_t l = 0;\n\tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}", "target": 1}
{"code": "static void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\"));\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); \n\tset_cur_state(st);\n\tst->st_calculating = FALSE;\n\te = ikev2_parent_inI2outR2_tail(pcrc, r);\n\tif ( e > STF_FAIL) {\n\t\tint v2_notify_num = e - STF_FAIL;\n\t\tDBG_log(\n\t\t\t\"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\",\n\t\t\tenum_name(&ikev2_notify_names, v2_notify_num));\n\t} else if ( e != STF_OK) {\n\t\tDBG_log(\"ikev2_parent_inI2outR2_tail returned %s\",\n\t\t\tenum_name(&stfstatus_name, e));\n\t}\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\tpassert(GLOBALS_ARE_RESET());\n}", "target": 1}
{"code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}", "target": 0}
{"code": "int db__close(void)\n{\n\tsubhier_clean(&db.subs);\n\tretain__clean(&db.retains);\n\tdb__msg_store_clean();\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "static int ocfs2_lock_get_block(struct inode *inode, sector_t iblock,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tdown_read(&oi->ip_alloc_sem);\n\tret = ocfs2_get_block(inode, iblock, bh_result, create);\n\tup_read(&oi->ip_alloc_sem);\n\treturn ret;\n}", "target": 0}
{"code": "void mb2_cache_entry_delete_block(struct mb2_cache *cache, u32 key,\n\t\t\t\t  sector_t block)\n{\n\tstruct hlist_bl_node *node;\n\tstruct hlist_bl_head *head;\n\tstruct mb2_cache_entry *entry;\n\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\thlist_bl_lock(head);\n\thlist_bl_for_each_entry(entry, node, head, e_hash_list) {\n\t\tif (entry->e_key == key && entry->e_block == block) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\thlist_bl_unlock(head);\n\t\t\tspin_lock(&cache->c_lru_list_lock);\n\t\t\tif (!list_empty(&entry->e_lru_list)) {\n\t\t\t\tlist_del_init(&entry->e_lru_list);\n\t\t\t\tcache->c_entry_count--;\n\t\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t\t}\n\t\t\tspin_unlock(&cache->c_lru_list_lock);\n\t\t\tmb2_cache_entry_put(cache, entry);\n\t\t\treturn;\n\t\t}\n\t}\n\thlist_bl_unlock(head);\n}", "target": 0}
{"code": "void start_cfs_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 overrun;\n\tlockdep_assert_held(&cfs_b->lock);\n\tif (cfs_b->period_active)\n\t\treturn;\n\tcfs_b->period_active = 1;\n\toverrun = hrtimer_forward_now(&cfs_b->period_timer, cfs_b->period);\n\tcfs_b->runtime_expires += (overrun + 1) * ktime_to_ns(cfs_b->period);\n\tcfs_b->expires_seq++;\n\thrtimer_start_expires(&cfs_b->period_timer, HRTIMER_MODE_ABS_PINNED);\n}", "target": 1}
{"code": "static void vgacon_scrollback_switch(int vc_num)\n{\n\tif (!scrollback_persistent)\n\t\tvc_num = 0;\n\tif (!vgacon_scrollbacks[vc_num].data) {\n\t\tvgacon_scrollback_init(vc_num);\n\t} else {\n\t\tif (scrollback_persistent) {\n\t\t\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\t\t} else {\n\t\t\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\t\t\tvgacon_scrollback_reset(vc_num, size);\n\t\t}\n\t}\n}", "target": 1}
{"code": "    OlympusMnHeader::~OlympusMnHeader()\n    {\n    }", "target": 0}
{"code": "static inline int assign_eip_far(struct x86_emulate_ctxt *ctxt, ulong dst,\n\t\t\t       int cs_l)\n{\n\tswitch (ctxt->op_bytes) {\n\tcase 2:\n\t\tctxt->_eip = (u16)dst;\n\t\tbreak;\n\tcase 4:\n\t\tctxt->_eip = (u32)dst;\n\t\tbreak;\n\tcase 8:\n\t\tif ((cs_l && is_noncanonical_address(dst)) ||\n\t\t    (!cs_l && (dst & ~(u32)-1)))\n\t\t\treturn emulate_gp(ctxt, 0);\n\t\tctxt->_eip = dst;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unsupported eip assignment size\\n\");\n\t}\n\treturn X86EMUL_CONTINUE;\n}", "target": 0}
{"code": " */\nint re_yyget_column  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    return yycolumn;", "target": 1}
{"code": "static ssize_t driver_override_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\treturn sprintf(buf, \"%s\\n\", pdev->driver_override);\n}", "target": 1}
{"code": "int sas_ex_revalidate_domain(struct domain_device *port_dev)\n{\n\tint res;\n\tstruct domain_device *dev = NULL;\n\tres = sas_find_bcast_dev(port_dev, &dev);\n\twhile (res == 0 && dev) {\n\t\tstruct expander_device *ex = &dev->ex_dev;\n\t\tint i = 0, phy_id;\n\t\tdo {\n\t\t\tphy_id = -1;\n\t\t\tres = sas_find_bcast_phy(dev, &phy_id, i, true);\n\t\t\tif (phy_id == -1)\n\t\t\t\tbreak;\n\t\t\tres = sas_rediscover(dev, phy_id);\n\t\t\ti = phy_id + 1;\n\t\t} while (i < ex->num_phys);\n\t\tdev = NULL;\n\t\tres = sas_find_bcast_dev(port_dev, &dev);\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static int virtio_net_set_vnet_endian_one(VirtIODevice *vdev,\n                                          NetClientState *peer,\n                                          bool enable)\n{\n    if (virtio_is_big_endian(vdev)) {\n        return qemu_set_vnet_be(peer, enable);\n    } else {\n        return qemu_set_vnet_le(peer, enable);\n    }\n}", "target": 0}
{"code": "static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,\n\t\tconst iw_byte *d, size_t d_len)\n{\n\tstruct iw_exif_state e;\n\tiw_uint32 ifd;\n\tif(d_len<8) return;\n\tiw_zeromem(&e,sizeof(struct iw_exif_state));\n\te.d = d;\n\te.d_len = d_len;\n\te.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;\n\tifd = iw_get_ui32_e(&d[4],e.endian);\n\tiwjpeg_scan_exif_ifd(rctx,&e,ifd);\n}", "target": 1}
{"code": "NOEXPORT int dh_init(SERVICE_OPTIONS *section) {\n    DH *dh=NULL;\n    int i, n;\n    char description[128];\n    STACK_OF(SSL_CIPHER) *ciphers;\n    section->option.dh_temp_params=0; \n    ciphers=SSL_CTX_get_ciphers(section->ctx);\n    if(!ciphers)\n        return 1; \n    n=sk_SSL_CIPHER_num(ciphers);\n    for(i=0; i<n; ++i) {\n        *description='\\0';\n        SSL_CIPHER_description(sk_SSL_CIPHER_value(ciphers, i),\n            description, sizeof description);\n        if(strstr(description, \" Kx=DH\")) {\n            s_log(LOG_INFO, \"DH initialization needed for %s\",\n                SSL_CIPHER_get_name(sk_SSL_CIPHER_value(ciphers, i)));\n            break;\n        }\n    }\n    if(i==n) { \n        s_log(LOG_INFO, \"DH initialization not needed\");\n        return 0; \n    }\n    s_log(LOG_DEBUG, \"DH initialization\");\n#ifndef OPENSSL_NO_ENGINE\n    if(!section->engine) \n#endif\n        dh=dh_read(section->cert);\n    if(dh) {\n        SSL_CTX_set_tmp_dh(section->ctx, dh);\n        s_log(LOG_INFO, \"%d-bit DH parameters loaded\", 8*DH_size(dh));\n        DH_free(dh);\n        return 0; \n    }\n    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_DH]);\n    SSL_CTX_set_tmp_dh(section->ctx, dh_params);\n    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_DH]);\n    dh_temp_params=1; \n    section->option.dh_temp_params=1; \n    s_log(LOG_INFO, \"Using dynamic DH parameters\");\n    return 0; \n}", "target": 1}
{"code": "  virtual void AddCellularDataPlanObserver(CellularDataPlanObserver* observer) {\n    if (!data_plan_observers_.HasObserver(observer))\n      data_plan_observers_.AddObserver(observer);\n  }", "target": 0}
{"code": "static ssize_t intel_iommu_show_ndoms(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct intel_iommu *iommu = dev_to_intel_iommu(dev);\n\treturn sprintf(buf, \"%ld\\n\", cap_ndoms(iommu->cap));\n}", "target": 0}
{"code": "void PrintWebViewHelper::PrintPreviewContext::set_error(\n    enum PrintPreviewErrorBuckets error) {\n  error_ = error;\n}", "target": 0}
{"code": "MagickExport MagickBooleanType FileToImage(Image *image,const char *filename,\n  ExceptionInfo *exception)\n{\n  int\n    file;\n  MagickBooleanType\n    status;\n  size_t\n    length,\n    quantum;\n  ssize_t\n    count;\n  struct stat\n    file_stats;\n  unsigned char\n    *blob;\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  assert(filename != (const char *) NULL);\n  (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",filename);\n  status=IsRightsAuthorized(PathPolicyDomain,WritePolicyRights,filename);\n  if (status == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  file=fileno(stdin);\n  if (LocaleCompare(filename,\"-\") != 0)\n    file=open_utf8(filename,O_RDONLY | O_BINARY,0);\n  if (file == -1)\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  blob=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*blob));\n  if (blob == (unsigned char *) NULL)\n    {\n      file=close(file);\n      ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n        filename);\n      return(MagickFalse);\n    }\n  for ( ; ; )\n  {\n    count=read(file,blob,quantum);\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n    length=(size_t) count;\n    count=WriteBlobStream(image,length,blob);\n    if (count != (ssize_t) length)\n      {\n        ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n        break;\n      }\n  }\n  file=close(file);\n  if (file == -1)\n    ThrowFileException(exception,BlobError,\"UnableToWriteBlob\",filename);\n  blob=(unsigned char *) RelinquishMagickMemory(blob);\n  return(MagickTrue);\n}", "target": 0}
{"code": "void ext4_es_insert_delayed_block(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t\t  bool allocated)\n{\n\tstruct extent_status newes;\n\tint err1 = 0;\n\tint err2 = 0;\n\tstruct extent_status *es1 = NULL;\n\tstruct extent_status *es2 = NULL;\n\tif (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)\n\t\treturn;\n\tes_debug(\"add [%u/1) delayed to extent status tree of inode %lu\\n\",\n\t\t lblk, inode->i_ino);\n\tnewes.es_lblk = lblk;\n\tnewes.es_len = 1;\n\text4_es_store_pblock_status(&newes, ~0, EXTENT_STATUS_DELAYED);\n\ttrace_ext4_es_insert_delayed_block(inode, &newes, allocated);\n\text4_es_insert_extent_check(inode, &newes);\nretry:\n\tif (err1 && !es1)\n\t\tes1 = __es_alloc_extent(true);\n\tif ((err1 || err2) && !es2)\n\t\tes2 = __es_alloc_extent(true);\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr1 = __es_remove_extent(inode, lblk, lblk, NULL, es1);\n\tif (err1 != 0)\n\t\tgoto error;\n\terr2 = __es_insert_extent(inode, &newes, es2);\n\tif (err2 != 0)\n\t\tgoto error;\n\tif (allocated)\n\t\t__insert_pending(inode, lblk);\n\tif (es1 && !es1->es_len)\n\t\t__es_free_extent(es1);\n\tif (es2 && !es2->es_len)\n\t\t__es_free_extent(es2);\nerror:\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err1 || err2)\n\t\tgoto retry;\n\text4_es_print_tree(inode);\n\text4_print_pending_tree(inode);\n\treturn;\n}", "target": 1}
{"code": "pkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n    *valid_kdcPkId = 0;\n    pkiDebug(\"found kdcPkId in AS REQ\\n\");\n    is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n    if (is == NULL)\n        goto cleanup;\n    status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n    if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n    }\n    retval = 0;\ncleanup:\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n    return retval;\n}", "target": 1}
{"code": "uint32_t negate_negative_int32(int32_t x)\n{\n  assert(x <= 0);\n  if (x == INT32_MIN) {\n    return static_cast<uint32_t>(INT32_MAX) + 1;\n  }\n  else {\n    return static_cast<uint32_t>(-x);\n  }\n}", "target": 0}
{"code": "static BOOL handle_SSH2_newkeys(PTInstVar pvar)\n{\n\tlogputs(LOG_LEVEL_VERBOSE, \"SSH2_MSG_NEWKEYS was received(DH key generation is completed).\");\n\tif (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) {\n\t\tsave_memdump(LOGDUMP);\n\t}\n\tfinish_memdump();\n\tpvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED;\n\tssh2_set_newkeys(pvar, MODE_IN);\n\tif (!CRYPT_start_encryption(pvar, 0, 1)) {\n\t}\n\tpvar->ssh2_keys[MODE_IN].mac.enabled = 1;\n\tpvar->ssh2_keys[MODE_IN].comp.enabled = 1;\n\tenable_recv_compression(pvar);\n\tif (pvar->server_strict_kex) {\n\t\tpvar->ssh_state.receiver_sequence_number = 0;\n\t}\n\tSSH2_dispatch_add_message(SSH2_MSG_EXT_INFO);\n\tif (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) {\n\t\tif (pvar->kex_status & KEX_FLAG_REKEYING) {\n\t\t\tint i;\n\t\t\tChannel_t *c;\n\t\t\tdo_SSH2_dispatch_setup_for_transfer(pvar);\n\t\t\tfor (i = 0 ; i < CHANNEL_MAX ; i++) {\n\t\t\t\tc = &channels[i];\n\t\t\t\tif (c->used) {\n\t\t\t\t\tssh2_channel_retry_send_bufchain(pvar, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tssh2_finish_encryption_setup(pvar);\n\t\t\tssh2_prep_userauth(pvar);\n\t\t}\n\t\tpvar->kex_status = KEX_FLAG_KEXDONE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "dirserv_remove_old_statuses(smartlist_t *fps, time_t cutoff)\n{\n  int found_any = 0;\n  SMARTLIST_FOREACH(fps, char *, digest,\n  {\n    cached_dir_t *d = lookup_cached_dir_by_fp(digest);\n    if (!d)\n      continue;\n    found_any = 1;\n    if (d->published <= cutoff) {\n      tor_free(digest);\n      SMARTLIST_DEL_CURRENT(fps, digest);\n    }\n  });\n  return found_any;\n}", "target": 0}
{"code": "    bool IsOpened() {return hFile!=FILE_BAD_HANDLE;};", "target": 1}
{"code": "char *RootdExpandPathName(const char *name)\n{\n   const char *patbuf = name;\n   while (*patbuf == ' ')\n      patbuf++;\n   for (const char *p = patbuf; *p; p++)\n      if (strchr(shellMeta, *p))\n         goto needshell;\n   return strdup(name);\nneedshell:\n   char escPatbuf[kMAXPATHLEN];\n   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);\n   char cmd[kMAXPATHLEN];\n#ifdef __hpux\n   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));\n#else\n   strlcpy(cmd, \"echo \", sizeof(cmd));\n#endif\n   if (escPatbuf[0] == '~') {\n      const char *hd;\n      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {\n         char uname[70], *p, *q;\n         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)\n            *q++ = *p++;\n         *q = '\\0';\n         hd = HomeDirectory(uname);\n         if (hd == 0)\n            strcat(cmd, escPatbuf);\n         else {\n            strcat(cmd, hd);\n            strcat(cmd, p);\n         }\n      } else {\n         hd = HomeDirectory(0);\n         if (hd == 0) {\n            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");\n            return 0;\n         }\n         strcat(cmd, hd);\n         strcat(cmd, &escPatbuf[1]);\n      }\n   } else\n      strcat(cmd, escPatbuf);\n   FILE *pf;\n   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {\n      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);\n      return 0;\n   }\n   char expPatbuf[kMAXPATHLEN];\n   int  ch, i, cnt = 0;\nagain:\n   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {\n      expPatbuf[i] = ch;\n      cnt++;\n   }\n   if (cnt == 0 && ch == EOF) goto again;\n   expPatbuf[cnt] = '\\0';\n   while (ch != EOF) {\n      ch = fgetc(pf);\n      if (ch == ' ' || ch == '\\t') {\n         ::pclose(pf);\n         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");\n         return 0;\n      }\n   }\n   ::pclose(pf);\n   return strdup(expPatbuf);\n}", "target": 1}
{"code": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}", "target": 1}
{"code": "spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}", "target": 1}
{"code": "static int atalk_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\t\t size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_at *sat = (struct sockaddr_at *)msg->msg_name;\n\tstruct ddpehdr *ddp;\n\tint copied = 0;\n\tint offset = 0;\n\tint err = 0;\n\tstruct sk_buff *skb;\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tlock_sock(sk);\n\tif (!skb)\n\t\tgoto out;\n\tddp = ddp_hdr(skb);\n\tcopied = ntohs(ddp->deh_len_hops) & 1023;\n\tif (sk->sk_type != SOCK_RAW) {\n\t\toffset = sizeof(*ddp);\n\t\tcopied -= offset;\n\t}\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\terr = skb_copy_datagram_iovec(skb, offset, msg->msg_iov, copied);\n\tif (!err) {\n\t\tif (sat) {\n\t\t\tsat->sat_family      = AF_APPLETALK;\n\t\t\tsat->sat_port        = ddp->deh_sport;\n\t\t\tsat->sat_addr.s_node = ddp->deh_snode;\n\t\t\tsat->sat_addr.s_net  = ddp->deh_snet;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*sat);\n\t}\n\tskb_free_datagram(sk, skb);\t\nout:\n\trelease_sock(sk);\n\treturn err ? : copied;\n}", "target": 1}
{"code": "static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tbool answer = false;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\tret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn false;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn false;\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2, *linecmp;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, contrl) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tprune_init_slice(c2);\n\t\tlinecmp = *cg == '/' ? c2 : c2+1;\n\t\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n\t\t\tif (nextcg)\n\t\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n\t\t\tgoto out;\n\t\t}\n\t\tanswer = true;\n\t\tgoto out;\n\t}\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}", "target": 1}
{"code": "p_ntp_time(netdissect_options *ndo,\n\t   const struct l_fixedpt *lfp)\n{\n\tuint32_t i;\n\tuint32_t uf;\n\tuint32_t f;\n\tdouble ff;\n\ti = GET_BE_U_4(lfp->int_part);\n\tuf = GET_BE_U_4(lfp->fraction);\n\tff = uf;\n\tif (ff < 0.0)\t\t\n\t\tff += FMAXINT;\n\tff = ff / FMAXINT;\t\t\t\n\tf = (uint32_t)(ff * 1000000000.0);\t\n\tND_PRINT(\"%u.%09u\", i, f);\n\tif (i) {\n\t    int64_t seconds_64bit = (int64_t)i - JAN_1970;\n\t    time_t seconds;\n\t    struct tm *tm;\n\t    char time_buf[128];\n\t    seconds = (time_t)seconds_64bit;\n\t    if (seconds != seconds_64bit) {\n\t\tND_PRINT(\" (unrepresentable)\");\n\t    } else {\n\t\ttm = gmtime(&seconds);\n\t\tif (tm == NULL) {\n\t\t    ND_PRINT(\" (unrepresentable)\");\n\t\t} else {\n\t\t    strftime(time_buf, sizeof (time_buf), \"%Y-%m-%dT%H:%M:%SZ\", tm);\n\t\t    ND_PRINT(\" (%s)\", time_buf);\n\t\t}\n\t    }\n\t}\n}", "target": 1}
{"code": "      DSA_Signature_Operation(const DSA_PrivateKey& dsa, const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_x(dsa.get_x()),\n         m_mod_q(dsa.group_q())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }", "target": 1}
{"code": "static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct bnep_connlist_req cl;\n\tstruct bnep_connadd_req  ca;\n\tstruct bnep_conndel_req  cd;\n\tstruct bnep_conninfo ci;\n\tstruct socket *nsock;\n\tvoid __user *argp = (void __user *)arg;\n\tint err;\n\tBT_DBG(\"cmd %x arg %lx\", cmd, arg);\n\tswitch (cmd) {\n\tcase BNEPCONNADD:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (copy_from_user(&ca, argp, sizeof(ca)))\n\t\t\treturn -EFAULT;\n\t\tnsock = sockfd_lookup(ca.sock, &err);\n\t\tif (!nsock)\n\t\t\treturn err;\n\t\tif (nsock->sk->sk_state != BT_CONNECTED) {\n\t\t\tsockfd_put(nsock);\n\t\t\treturn -EBADFD;\n\t\t}\n\t\tca.device[sizeof(ca.device)-1] = 0;\n\t\terr = bnep_add_connection(&ca, nsock);\n\t\tif (!err) {\n\t\t\tif (copy_to_user(argp, &ca, sizeof(ca)))\n\t\t\t\terr = -EFAULT;\n\t\t} else\n\t\t\tsockfd_put(nsock);\n\t\treturn err;\n\tcase BNEPCONNDEL:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EACCES;\n\t\tif (copy_from_user(&cd, argp, sizeof(cd)))\n\t\t\treturn -EFAULT;\n\t\treturn bnep_del_connection(&cd);\n\tcase BNEPGETCONNLIST:\n\t\tif (copy_from_user(&cl, argp, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\tif (cl.cnum <= 0)\n\t\t\treturn -EINVAL;\n\t\terr = bnep_get_connlist(&cl);\n\t\tif (!err && copy_to_user(argp, &cl, sizeof(cl)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tcase BNEPGETCONNINFO:\n\t\tif (copy_from_user(&ci, argp, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\terr = bnep_get_conninfo(&ci);\n\t\tif (!err && copy_to_user(argp, &ci, sizeof(ci)))\n\t\t\treturn -EFAULT;\n\t\treturn err;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false);\n}", "target": 0}
{"code": "bool IsHostMemoryArg(const EagerOperation& op, const NodeDef* node_def,\n                     const Device* op_device, const KernelDef* kernel_def,\n                     const int port_id) {\n  if (op.is_function()) return false;\n  if (node_def == nullptr) return false;\n  if (kernel_def == nullptr || op_device == nullptr) return false;\n  const auto& host_memory_args = kernel_def->host_memory_arg();\n  const OpDef& op_def = OpRegistry::Global()->LookUp(op.Name())->op_def;\n  const int arg_id = OpPortIdToArgId(*node_def, op_def.input_arg(), port_id);\n  if (arg_id < 0) {\n    return false;\n  }\n  return std::find(host_memory_args.begin(), host_memory_args.end(),\n                   op_def.input_arg(arg_id).name()) != host_memory_args.end();\n}", "target": 0}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = self_in;\n    long long val = self->val;\n    if (big_endian) {\n        byte *b = buf + len;\n        while (b > buf) {\n            *--b = val;\n            val >>= 8;\n        }\n    } else {\n        for (; len > 0; --len) {\n            *buf++ = val;\n            val >>= 8;\n        }\n    }\n}", "target": 1}
{"code": "gopherSendComplete(const Comm::ConnectionPointer &conn, char *, size_t size, Comm::Flag errflag, int xerrno, void *data)\n{\n    GopherStateData *gopherState = (GopherStateData *) data;\n    StoreEntry *entry = gopherState->entry;\n    debugs(10, 5, conn << \" size: \" << size << \" errflag: \" << errflag);\n    if (size > 0) {\n        fd_bytes(conn->fd, size, FD_WRITE);\n        statCounter.server.all.kbytes_out += size;\n        statCounter.server.other.kbytes_out += size;\n    }\n    if (!entry->isAccepting()) {\n        debugs(10, 3, \"terminating due to bad \" << *entry);\n        gopherState->serverConn->close();\n        return;\n    }\n    if (errflag) {\n        const auto err = new ErrorState(ERR_WRITE_ERROR, Http::scServiceUnavailable, gopherState->fwd->request, gopherState->fwd->al);\n        err->xerrno = xerrno;\n        err->port = gopherState->fwd->request->url.port();\n        err->url = xstrdup(entry->url());\n        gopherState->fwd->fail(err);\n        gopherState->serverConn->close();\n        return;\n    }\n    entry->buffer();\n    gopherMimeCreate(gopherState);\n    switch (gopherState->type_id) {\n    case GOPHER_DIRECTORY:\n        gopherState->conversion = GopherStateData::HTML_DIR;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_INDEX:\n        gopherState->conversion = GopherStateData::HTML_INDEX_RESULT;\n        gopherState->HTML_header_added = 0;\n        break;\n    case GOPHER_CSO:\n        gopherState->conversion = GopherStateData::HTML_CSO_RESULT;\n        gopherState->cso_recno = 0;\n        gopherState->HTML_header_added = 0;\n        break;\n    default:\n        gopherState->conversion = GopherStateData::NORMAL;\n        entry->flush();\n    }\n    GopherStateData::DelayAwareRead(gopherState);\n}", "target": 1}
{"code": "void print_cfs_stats(struct seq_file *m, int cpu)\n{\n\tstruct cfs_rq *cfs_rq, *pos;\n\trcu_read_lock();\n\tfor_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos)\n\t\tprint_cfs_rq(m, cpu, cfs_rq);\n\trcu_read_unlock();\n}", "target": 1}
{"code": "static inline int l2cap_config_rsp(struct l2cap_conn *conn, struct l2cap_cmd_hdr *cmd, u8 *data)\n{\n\tstruct l2cap_conf_rsp *rsp = (struct l2cap_conf_rsp *)data;\n\tu16 scid, flags, result;\n\tstruct sock *sk;\n\tscid   = __le16_to_cpu(rsp->scid);\n\tflags  = __le16_to_cpu(rsp->flags);\n\tresult = __le16_to_cpu(rsp->result);\n\tBT_DBG(\"scid 0x%4.4x flags 0x%2.2x result 0x%2.2x\",\n\t\t\tscid, flags, result);\n\tsk = l2cap_get_chan_by_scid(&conn->chan_list, scid);\n\tif (!sk)\n\t\treturn 0;\n\tswitch (result) {\n\tcase L2CAP_CONF_SUCCESS:\n\t\tbreak;\n\tcase L2CAP_CONF_UNACCEPT:\n\t\tif (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {\n\t\t\tchar req[128];\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t\t\t\tl2cap_build_conf_req(sk, req), req);\n\t\t\tgoto done;\n\t\t}\n\tdefault:\n\t\tsk->sk_state = BT_DISCONN;\n\t\tsk->sk_err = ECONNRESET;\n\t\tl2cap_sock_set_timer(sk, HZ * 5);\n\t\t{\n\t\t\tstruct l2cap_disconn_req req;\n\t\t\treq.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);\n\t\t\treq.scid = cpu_to_le16(l2cap_pi(sk)->scid);\n\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\tL2CAP_DISCONN_REQ, sizeof(req), &req);\n\t\t}\n\t\tgoto done;\n\t}\n\tif (flags & 0x01)\n\t\tgoto done;\n\tl2cap_pi(sk)->conf_state |= L2CAP_CONF_INPUT_DONE;\n\tif (l2cap_pi(sk)->conf_state & L2CAP_CONF_OUTPUT_DONE) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tl2cap_chan_ready(sk);\n\t}\ndone:\n\tbh_unlock_sock(sk);\n\treturn 0;\n}", "target": 1}
{"code": "static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)\n{\n\tunsigned char present = 0;\n\tstruct page *page;\n#ifdef CONFIG_SWAP\n\tif (shmem_mapping(mapping)) {\n\t\tpage = find_get_entry(mapping, pgoff);\n\t\tif (xa_is_value(page)) {\n\t\t\tswp_entry_t swp = radix_to_swp_entry(page);\n\t\t\tpage = find_get_page(swap_address_space(swp),\n\t\t\t\t\t     swp_offset(swp));\n\t\t}\n\t} else\n\t\tpage = find_get_page(mapping, pgoff);\n#else\n\tpage = find_get_page(mapping, pgoff);\n#endif\n\tif (page) {\n\t\tpresent = PageUptodate(page);\n\t\tput_page(page);\n\t}\n\treturn present;\n}", "target": 1}
{"code": "static void update_ia32_tsc_adjust_msr(struct kvm_vcpu *vcpu, s64 offset)\n{\n\tu64 curr_offset = kvm_x86_ops->read_tsc_offset(vcpu);\n\tvcpu->arch.ia32_tsc_adjust_msr += offset - curr_offset;\n}", "target": 0}
{"code": "static int __adpt_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tint rcode;\n\tchar name[32];\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tstrncpy(name, pHba->name, sizeof(name));\n\tprintk(KERN_WARNING\"%s: Hba Reset: scsi id %d: tid: %d\\n\", name, cmd->device->channel, pHba->channel[cmd->device->channel].tid);\n\trcode =  adpt_hba_reset(pHba);\n\tif(rcode == 0){\n\t\tprintk(KERN_WARNING\"%s: HBA reset complete\\n\", name);\n\t\treturn SUCCESS;\n\t} else {\n\t\tprintk(KERN_WARNING\"%s: HBA reset failed (%x)\\n\", name, rcode);\n\t\treturn FAILED;\n\t}\n}", "target": 1}
{"code": "void Statement::Work_Bind(napi_env e, void* data) {\n    STATEMENT_INIT(Baton);\n    STATEMENT_MUTEX(mtx);\n    sqlite3_mutex_enter(mtx);\n    stmt->Bind(baton->parameters);\n    sqlite3_mutex_leave(mtx);\n}", "target": 0}
{"code": "static bool ptrace_freeze_traced(struct task_struct *task)\n{\n\tbool ret = false;\n\tif (task->jobctl & JOBCTL_LISTENING)\n\t\treturn ret;\n\tspin_lock_irq(&task->sighand->siglock);\n\tif (task_is_traced(task) && !__fatal_signal_pending(task)) {\n\t\ttask->state = __TASK_TRACED;\n\t\tret = true;\n\t}\n\tspin_unlock_irq(&task->sighand->siglock);\n\treturn ret;\n}", "target": 0}
{"code": "\tCommandAuthenticate(Module* Creator, SimpleExtItem<SaslAuthenticator>& ext, GenericCap& Cap)\n\t\t: Command(Creator, \"AUTHENTICATE\", 1), authExt(ext), cap(Cap)\n\t{\n\t\tworks_before_reg = true;\n\t\tallow_empty_last_param = false;\n\t}", "target": 0}
{"code": "static void fpm_child_init(struct fpm_worker_pool_s *wp) \n{\n\tfpm_globals.max_requests = wp->config->pm_max_requests;\n\tfpm_globals.listening_socket = dup(wp->listening_socket);\n\tif (0 > fpm_stdio_init_child(wp)  ||\n\t    0 > fpm_log_init_child(wp)    ||\n\t    0 > fpm_status_init_child(wp) ||\n\t    0 > fpm_unix_init_child(wp)   ||\n\t    0 > fpm_signals_init_child()  ||\n\t    0 > fpm_env_init_child(wp)    ||\n\t    0 > fpm_php_init_child(wp)) {\n\t\tzlog(ZLOG_ERROR, \"[pool %s] child failed to initialize\", wp->config->name);\n\t\texit(FPM_EXIT_SOFTWARE);\n\t}\n}", "target": 0}
{"code": "innodb_clean_engine(\n\tENGINE_HANDLE*\t\thandle,\t\t\n\tconst void*\t\tcookie __attribute__((unused)),\n\tvoid*\t\t\tconn)\t\t\n{\n\tinnodb_conn_data_t*\tconn_data = (innodb_conn_data_t*)conn;\n\tstruct innodb_engine*\tengine = innodb_handle(handle);\n\tvoid*\t\t\torignal_thd;\n\tLOCK_CURRENT_CONN_IF_NOT_LOCKED(false, conn_data);\n\tif (conn_data->thd) {\n\t\thandler_thd_attach(conn_data->thd, &orignal_thd);\n\t}\n\tinnodb_reset_conn(conn_data, true, true, engine->enable_binlog);\n\tinnodb_conn_clean_data(conn_data, true, false);\n\tconn_data->is_stale = true;\n\tUNLOCK_CURRENT_CONN_IF_NOT_LOCKED(false, conn_data);\n}", "target": 0}
{"code": "bool FormContainsNonDefaultPasswordValue(const PasswordForm& password_form) {\n  return (!password_form.password_value.empty() &&\n          !password_form.password_value_is_default) ||\n      (!password_form.new_password_value.empty() &&\n       !password_form.new_password_value_is_default);\n}", "target": 0}
{"code": "void rose_stop_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n}", "target": 1}
{"code": "static int smacker_decode_tree(BitstreamContext *bc, HuffContext *hc,\n                               uint32_t prefix, int length)\n{\n    if (length > SMKTREE_DECODE_MAX_RECURSION) {\n        av_log(NULL, AV_LOG_ERROR, \"Maximum tree recursion level exceeded.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!bitstream_read_bit(bc)) { \n        if(hc->current >= 256){\n            av_log(NULL, AV_LOG_ERROR, \"Tree size exceeded!\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        if(length){\n            hc->bits[hc->current] = prefix;\n            hc->lengths[hc->current] = length;\n        } else {\n            hc->bits[hc->current] = 0;\n            hc->lengths[hc->current] = 0;\n        }\n        hc->values[hc->current] = bitstream_read(bc, 8);\n        hc->current++;\n        if(hc->maxlength < length)\n            hc->maxlength = length;\n        return 0;\n    } else { \n        int r;\n        length++;\n        r = smacker_decode_tree(bc, hc, prefix, length);\n        if(r)\n            return r;\n        return smacker_decode_tree(bc, hc, prefix | (1 << (length - 1)), length);\n    }\n}", "target": 0}
{"code": "static pj_status_t STATUS_FROM_SSL_ERR(char *action, pj_ssl_sock_t *ssock,\n\t\t\t\t       unsigned long err)\n{\n    int level = 0;\n    int len = 0; \n    ERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    level++;\n    if (err == SSL_ERROR_SSL) {\n\terr = ERR_get_error();\n\tERROR_LOG(\"STATUS_FROM_SSL_ERR\", err, ssock);\n    }\n    ssock->last_err = err;\n    return GET_STATUS_FROM_SSL_ERR(err);\n}", "target": 1}
{"code": "WifiNetwork::WifiNetwork()\n    : WirelessNetwork(),\n      encryption_(SECURITY_NONE) {\n  type_ = TYPE_WIFI;\n}", "target": 0}
{"code": "void SSecurityTLS::shutdown()\n{\n  if (session) {\n    if (gnutls_bye(session, GNUTLS_SHUT_RDWR) != GNUTLS_E_SUCCESS) {\n      vlog.error(\"TLS session wasn't terminated gracefully\");\n    }\n  }\n  if (dh_params) {\n    gnutls_dh_params_deinit(dh_params);\n    dh_params = 0;\n  }\n  if (anon_cred) {\n    gnutls_anon_free_server_credentials(anon_cred);\n    anon_cred = 0;\n  }\n  if (cert_cred) {\n    gnutls_certificate_free_credentials(cert_cred);\n    cert_cred = 0;\n  }\n  if (session) {\n    gnutls_deinit(session);\n    session = 0;\n    gnutls_global_deinit();\n  }\n}", "target": 1}
{"code": "static inline u16 skb_get_queue_mapping(const struct sk_buff *skb)\n{\n\treturn skb->queue_mapping;\n}", "target": 0}
{"code": "bool Curl_conncache_foreach(struct Curl_easy *data,\n                            struct conncache *connc,\n                            void *param,\n                            int (*func)(struct Curl_easy *data,\n                                        struct connectdata *conn, void *param))\n{\n  struct Curl_hash_iterator iter;\n  struct Curl_llist_element *curr;\n  struct Curl_hash_element *he;\n  if(!connc)\n    return FALSE;\n  CONNCACHE_LOCK(data);\n  Curl_hash_start_iterate(&connc->hash, &iter);\n  he = Curl_hash_next_element(&iter);\n  while(he) {\n    struct connectbundle *bundle;\n    bundle = he->ptr;\n    he = Curl_hash_next_element(&iter);\n    curr = bundle->conn_list.head;\n    while(curr) {\n      struct connectdata *conn = curr->ptr;\n      curr = curr->next;\n      if(1 == func(data, conn, param)) {\n        CONNCACHE_UNLOCK(data);\n        return TRUE;\n      }\n    }\n  }\n  CONNCACHE_UNLOCK(data);\n  return FALSE;\n}", "target": 0}
{"code": "PHPAPI PHP_FUNCTION(fread)\n{\n\tzval *arg1;\n\tlong len;\n\tphp_stream *stream;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rl\", &arg1, &len) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tPHP_STREAM_TO_ZVAL(stream, &arg1);\n\tif (len <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\tif (len > INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n\t\tRETURN_FALSE;\n\t}\n\tZ_STRVAL_P(return_value) = emalloc(len + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(stream, Z_STRVAL_P(return_value), len);\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}", "target": 0}
{"code": "struct nfc_llcp_local *nfc_llcp_local_get(struct nfc_llcp_local *local)\n{\n\tkref_get(&local->ref);\n\treturn local;\n}", "target": 1}
{"code": "int message_add_body_amqp_sequence(MESSAGE_HANDLE message, AMQP_VALUE sequence_list)\n{\n    int result;\n    if ((message == NULL) ||\n        (sequence_list == NULL))\n    {\n        LogError(\"Bad arguments: message = %p, sequence_list = %p\",\n            message, sequence_list);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        MESSAGE_BODY_TYPE body_type = internal_get_body_type(message);\n        if ((body_type == MESSAGE_BODY_TYPE_DATA) ||\n            (body_type == MESSAGE_BODY_TYPE_VALUE))\n        {\n            LogError(\"Body is already set to another body type\");\n            result = MU_FAILURE;\n        }\n        else\n        {\n            AMQP_VALUE* new_body_amqp_sequence_items = (AMQP_VALUE*)realloc(message->body_amqp_sequence_items, sizeof(AMQP_VALUE) * (message->body_amqp_sequence_count + 1));\n            if (new_body_amqp_sequence_items == NULL)\n            {\n                LogError(\"Cannot allocate enough memory for sequence items\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                message->body_amqp_sequence_items = new_body_amqp_sequence_items;\n                message->body_amqp_sequence_items[message->body_amqp_sequence_count] = amqpvalue_clone(sequence_list);\n                if (message->body_amqp_sequence_items[message->body_amqp_sequence_count] == NULL)\n                {\n                    LogError(\"Cloning sequence failed\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    message->body_amqp_sequence_count++;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,\n\t\t\t      int lookup, struct fscrypt_name *fname)\n{\n\tint ret = 0, bigname = 0;\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_crypt_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)\n\t\t\tgoto errout;\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t\treturn 0;\n\t}\n\tif (!lookup)\n\t\treturn -ENOKEY;\n\tif (iname->name[0] == '_')\n\t\tbigname = 1;\n\tif ((bigname && (iname->len != 33)) || (!bigname && (iname->len > 43)))\n\t\treturn -ENOENT;\n\tfname->crypto_buf.name = kmalloc(32, GFP_KERNEL);\n\tif (fname->crypto_buf.name == NULL)\n\t\treturn -ENOMEM;\n\tret = digest_decode(iname->name + bigname, iname->len - bigname,\n\t\t\t\tfname->crypto_buf.name);\n\tif (ret < 0) {\n\t\tret = -ENOENT;\n\t\tgoto errout;\n\t}\n\tfname->crypto_buf.len = ret;\n\tif (bigname) {\n\t\tmemcpy(&fname->hash, fname->crypto_buf.name, 4);\n\t\tmemcpy(&fname->minor_hash, fname->crypto_buf.name + 4, 4);\n\t} else {\n\t\tfname->disk_name.name = fname->crypto_buf.name;\n\t\tfname->disk_name.len = fname->crypto_buf.len;\n\t}\n\treturn 0;\nerrout:\n\tfscrypt_fname_free_buffer(&fname->crypto_buf);\n\treturn ret;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_until_chr( pj_scanner *scanner,\n\t\t\t\t     const char *until_spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_size_t speclen;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    speclen = strlen(until_spec);\n    while (PJ_SCAN_CHECK_EOF(s) && !memchr(until_spec, *s, speclen)) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "rx_cache_insert(netdissect_options *ndo,\n                const u_char *bp, const struct ip *ip, int dport)\n{\n\tstruct rx_cache_entry *rxent;\n\tconst struct rx_header *rxh = (const struct rx_header *) bp;\n\tif (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))\n\t\treturn;\n\trxent = &rx_cache[rx_cache_next];\n\tif (++rx_cache_next >= RX_CACHE_SIZE)\n\t\trx_cache_next = 0;\n\trxent->callnum = EXTRACT_32BITS(&rxh->callNumber);\n\tUNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));\n\tUNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));\n\trxent->dport = dport;\n\trxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);\n\trxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));\n}", "target": 1}
{"code": "mrb_f_send(mrb_state *mrb, mrb_value self)\n{\n  mrb_sym name;\n  mrb_value block, *regs;\n  mrb_method_t m;\n  struct RClass *c;\n  mrb_callinfo *ci = mrb->c->ci;\n  int n = ci->n;\n  if (ci->cci > CINFO_NONE) {\n  funcall:;\n    const mrb_value *argv;\n    mrb_int argc;\n    mrb_get_args(mrb, \"n*&\", &name, &argv, &argc, &block);\n    return mrb_funcall_with_block(mrb, self, name, argc, argv, block);\n  }\n  regs = mrb->c->ci->stack+1;\n  if (n == 0) {\n  argnum_error:\n    mrb_argnum_error(mrb, 0, 1, -1);\n  }\n  else if (n == 15) {\n    if (RARRAY_LEN(regs[0]) == 0) goto argnum_error;\n    name = mrb_obj_to_sym(mrb, RARRAY_PTR(regs[0])[0]);\n  }\n  else {\n    name = mrb_obj_to_sym(mrb, regs[0]);\n  }\n  c = mrb_class(mrb, self);\n  m = mrb_method_search_vm(mrb, &c, name);\n  if (MRB_METHOD_UNDEF_P(m)) {            \n    goto funcall;\n  }\n  ci->mid = name;\n  ci->u.target_class = c;\n  if (n == 15) {     \n    regs[0] = mrb_ary_subseq(mrb, regs[0], 1, RARRAY_LEN(regs[0]) - 1);\n  }\n  else { \n    for (int i=0; i<n; i++) {\n      regs[i] = regs[i+1];\n    }\n    regs[n] = regs[n+1];        \n    if (ci->nk > 0) {\n      regs[n+1] = regs[n+2];    \n    }\n    ci->n--;\n  }\n  if (MRB_METHOD_CFUNC_P(m)) {\n    if (MRB_METHOD_NOARG_P(m)) {\n      check_method_noarg(mrb, ci);\n    }\n    if (MRB_METHOD_PROC_P(m)) {\n      mrb_vm_ci_proc_set(ci, MRB_METHOD_PROC(m));\n    }\n    return MRB_METHOD_CFUNC(m)(mrb, self);\n  }\n  return exec_irep(mrb, self, MRB_METHOD_PROC(m));\n}", "target": 0}
{"code": "void lodepng_state_cleanup(LodePNGState* state)\n{\n  lodepng_color_mode_cleanup(&state->info_raw);\n  lodepng_info_cleanup(&state->info_png);\n}", "target": 0}
{"code": "static inline struct sec_path *skb_sec_path(struct sk_buff *skb)\n{\n\treturn NULL;\n}", "target": 0}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tassert ( *(GF_Node **)field.far_ptr);\n\t\tgf_dump_vrml_node(sdump, *(GF_Node **)field.far_ptr, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 1}
{"code": "PHP_FUNCTION(linkinfo)\n{\n\tchar *link;\n\tchar *dirname;\n\tsize_t link_len;\n\tzend_stat_t sb;\n\tint ret;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &link, &link_len) == FAILURE) {\n\t\treturn;\n\t}\n\tdirname = estrndup(link, link_len);\n\tphp_dirname(dirname, link_len);\n\tif (php_check_open_basedir(dirname)) {\n\t\tefree(dirname);\n\t\tRETURN_FALSE;\n\t}\n\tret = VCWD_STAT(link, &sb);\n\tif (ret == -1) {\n\t\tphp_error_docref(NULL, E_WARNING, \"%s\", strerror(errno));\n\t\tefree(dirname);\n\t\tRETURN_LONG(Z_L(-1));\n\t}\n\tefree(dirname);\n\tRETURN_LONG((zend_long) sb.st_dev);\n}", "target": 0}
{"code": "DECLAREContigPutFunc(put4bitbwtile)\n{\n    uint32** BWmap = img->BWmap;\n    (void) x; (void) y;\n    fromskew /= 2;\n    while (h-- > 0) {\n\tuint32* bw;\n\tUNROLL2(w, bw = BWmap[*pp++], *cp++ = *bw++);\n\tcp += toskew;\n\tpp += fromskew;\n    }\n}", "target": 0}
{"code": "init_util(void)\n{\n\tfilegen_register(statsdir, \"peerstats\",\t  &peerstats);\n\tfilegen_register(statsdir, \"loopstats\",\t  &loopstats);\n\tfilegen_register(statsdir, \"clockstats\",  &clockstats);\n\tfilegen_register(statsdir, \"rawstats\",\t  &rawstats);\n\tfilegen_register(statsdir, \"sysstats\",\t  &sysstats);\n\tfilegen_register(statsdir, \"protostats\",  &protostats);\n#ifdef AUTOKEY\n\tfilegen_register(statsdir, \"cryptostats\", &cryptostats);\n#endif\t\n#ifdef DEBUG_TIMING\n\tfilegen_register(statsdir, \"timingstats\", &timingstats);\n#endif\t\n\tstep_callback = &ntpd_time_stepped;\n#ifdef DEBUG\n\tatexit(&uninit_util);\n#endif \n}", "target": 1}
{"code": "unsigned int bounded_iostream::write_no_buffer(const void *from, size_t bytes_to_write) {\n    std::pair<unsigned int, Sirikata::JpegError> retval;\n    if (byte_bound != 0 && byte_position + bytes_to_write > byte_bound) {\n        size_t real_bytes_to_write = byte_bound - byte_position;\n        byte_position += real_bytes_to_write;\n        retval = parent->Write(reinterpret_cast<const unsigned char*>(from), real_bytes_to_write);\n        if (retval.first < real_bytes_to_write) {\n            err = retval.second;\n            return retval.first;\n        }\n        return bytes_to_write; \n    }\n    size_t total = bytes_to_write;\n    retval = parent->Write(reinterpret_cast<const unsigned char*>(from), total);\n    unsigned int written = retval.first;\n    byte_position += written;\n    if (written < total ) {\n        err = retval.second;\n        return written;\n    }\n    return bytes_to_write;\n}", "target": 1}
{"code": "static void dbEvalSetColumnJSON(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            Jsi_DSAppend(dStr, \"null\", NULL);\n            return;\n        }\n        Jsi_JSONQuote(interp, zBlob, bytes, dStr);\n        return;\n    }\n    case SQLITE_INTEGER: {\n        sqlite_int64 v = sqlite3_column_int64(pStmt, iCol);\n        if (v==0 || v==1) {\n            const char *dectyp = sqlite3_column_decltype(pStmt, iCol);\n            if (dectyp && !Jsi_Strncasecmp(dectyp,\"bool\", 4)) {\n                Jsi_DSAppend(dStr, (v?\"true\":\"false\"), NULL);\n                return;\n            }\n        }\n#ifdef __WIN32\n        snprintf(nbuf, sizeof(nbuf), \"%\" PRId64, (Jsi_Wide)v);\n#else\n        snprintf(nbuf, sizeof(nbuf), \"%lld\", v);\n#endif\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_FLOAT: {\n        Jsi_NumberToString(interp, sqlite3_column_double(pStmt, iCol), nbuf, sizeof(nbuf));\n        Jsi_DSAppend(dStr, nbuf, NULL);\n        return;\n    }\n    case SQLITE_NULL: {\n        Jsi_DSAppend(dStr, \"null\", NULL);\n        return;\n    }\n    }\n    const char *str = (char*)sqlite3_column_text(pStmt, iCol );\n    if (!str)\n        str = p->jdb->optPtr->nullvalue;\n    Jsi_JSONQuote(interp, str?str:\"\", -1, dStr);\n}", "target": 1}
{"code": "rpl_dao_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dao *dao = (const struct nd_rpl_dao *)bp;\n        const char *dagid_str = \"<elided>\";\n        ND_TCHECK(*dao);\n        if (length < ND_RPL_DAO_MIN_LEN)\n        \tgoto tooshort;\n        bp += ND_RPL_DAO_MIN_LEN;\n        length -= ND_RPL_DAO_MIN_LEN;\n        if(RPL_DAO_D(dao->rpl_flags)) {\n                ND_TCHECK2(dao->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, dao->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u%s%s,%02x]\",\n                  dagid_str,\n                  dao->rpl_daoseq,\n                  dao->rpl_instanceid,\n                  RPL_DAO_K(dao->rpl_flags) ? \",acK\":\"\",\n                  RPL_DAO_D(dao->rpl_flags) ? \",Dagid\":\"\",\n                  dao->rpl_flags));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\ntooshort:\n\tND_PRINT((ndo,\" [|length too short]\"));\n\treturn;\n}", "target": 1}
{"code": "void IndexedDBDatabase::CallUpgradeTransactionStartedForTesting(\n    int64_t old_version) {\n  DCHECK(active_request_);\n  active_request_->UpgradeTransactionStarted(old_version);\n}", "target": 0}
{"code": "static TEE_Result do_allocate_keypair(struct dsa_keypair *key, size_t l_bits,\n\t\t\t\t      size_t n_bits)\n{\n\tDSA_TRACE(\"DSA allocate Keypair of L=%zu bits and N=%zu bits\", l_bits,\n\t\t  n_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->g = crypto_bignum_allocate(l_bits);\n\tif (!key->g)\n\t\tgoto err;\n\tkey->p = crypto_bignum_allocate(l_bits);\n\tif (!key->p)\n\t\tgoto err;\n\tkey->q = crypto_bignum_allocate(n_bits);\n\tif (!key->q)\n\t\tgoto err;\n\tkey->x = crypto_bignum_allocate(n_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(l_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tDSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->g);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static void asmlinkage smm_do_relocation(void *arg)\n{\n\tconst struct smm_module_params *p;\n\tconst struct smm_runtime *runtime;\n\tint cpu;\n\tuintptr_t curr_smbase;\n\tuintptr_t perm_smbase;\n\tp = arg;\n\truntime = p->runtime;\n\tcpu = p->cpu;\n\tcurr_smbase = runtime->smbase;\n\tif (cpu >= CONFIG_MAX_CPUS) {\n\t\tprintk(BIOS_CRIT,\n\t\t       \"Invalid CPU number assigned in SMM stub: %d\\n\", cpu);\n\t\treturn;\n\t}\n\tperm_smbase = mp_state.perm_smbase;\n\tperm_smbase -= cpu * runtime->save_state_size;\n\tprintk(BIOS_DEBUG, \"New SMBASE 0x%08lx\\n\", perm_smbase);\n\tmp_state.ops.relocation_handler(cpu, curr_smbase, perm_smbase);\n\tif (CONFIG(STM)) {\n\t\tuintptr_t mseg;\n\t\tmseg = mp_state.perm_smbase +\n\t\t\t(mp_state.perm_smsize - CONFIG_MSEG_SIZE);\n\t\tstm_setup(mseg, p->cpu,\n\t\t\t\tperm_smbase,\n\t\t\t\tmp_state.perm_smbase,\n\t\t\t\truntime->start32_offset);\n\t}\n}", "target": 1}
{"code": "Java_org_tensorflow_lite_InterpreterTest_getNativeHandleForDelegate(\n    JNIEnv* env, jclass clazz) {\n  static TfLiteRegistration registration = {\n      .init = nullptr,\n      .free = nullptr,\n      .prepare =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n            output->type = kTfLiteFloat32;\n            return context->ResizeTensor(context, output, output_dims);\n          },\n      .invoke =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            std::fill(output->data.f,\n                      output->data.f + tflite::NumElements(output), 7.0f);\n            return kTfLiteOk;\n          },\n      .profiling_string = nullptr,\n      .builtin_code = 0,\n      .custom_name = \"\",\n      .version = 1,\n  };\n  static TfLiteDelegate delegate = {\n      .data_ = nullptr,\n      .Prepare = [](TfLiteContext* context,\n                    TfLiteDelegate* delegate) -> TfLiteStatus {\n        TfLiteIntArray* execution_plan;\n        TF_LITE_ENSURE_STATUS(\n            context->GetExecutionPlan(context, &execution_plan));\n        context->ReplaceNodeSubsetsWithDelegateKernels(\n            context, registration, execution_plan, delegate);\n        for (size_t i = 0; i < context->tensors_size; ++i) {\n          context->tensors[i].delegate = delegate;\n          context->tensors[i].buffer_handle = static_cast<int>(i);\n        }\n        return kTfLiteOk;\n      },\n      .CopyFromBufferHandle = nullptr,\n      .CopyToBufferHandle = nullptr,\n      .FreeBufferHandle = nullptr,\n      .flags = kTfLiteDelegateFlagsAllowDynamicTensors,\n  };\n  return reinterpret_cast<jlong>(&delegate);\n}", "target": 1}
{"code": "uint64_t HeaderMapImpl::byteSizeInternal() const {\n  uint64_t byte_size = 0;\n  for (const HeaderEntryImpl& header : headers_) {\n    byte_size += header.key().size();\n    byte_size += header.value().size();\n  }\n  return byte_size;\n}", "target": 0}
{"code": "RenderObject::SelectionState InlineFlowBox::selectionState()\n{\n    return RenderObject::SelectionNone;\n}", "target": 0}
{"code": "snmp_oid_decode_oid(uint8_t *buf, uint32_t *buff_len, uint32_t *oid, uint32_t *oid_len)\n{\n  uint32_t *start;\n  uint8_t *buf_end, type;\n  uint8_t len;\n  div_t first;\n  start = oid;\n  buf = snmp_ber_decode_type(buf, buff_len, &type);\n  if(buf == NULL) {\n    return NULL;\n  }\n  if(type != SNMP_DATA_TYPE_OBJECT) {\n    return NULL;\n  }\n  buf = snmp_ber_decode_length(buf, buff_len, &len);\n  if(buf == NULL) {\n    return NULL;\n  }\n  buf_end = buf + len;\n  (*buff_len)--;\n  first = div(*buf++, 40);\n  *oid++ = (uint32_t)first.quot;\n  *oid++ = (uint32_t)first.rem;\n  while(buf != buf_end) {\n    --(*oid_len);\n    if(*oid_len == 0) {\n      return NULL;\n    }\n    int i;\n    *oid = (uint32_t)(*buf & 0x7F);\n    for(i = 0; i < 4; i++) {\n      (*buff_len)--;\n      if((*buf++ & 0x80) == 0) {\n        break;\n      }\n      *oid <<= 7;\n      *oid |= (*buf & 0x7F);\n    }\n    ++oid;\n  }\n  *oid++ = ((uint32_t)-1);\n  *oid_len = (uint32_t)(oid - start);\n  return buf;\n}", "target": 1}
{"code": "ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,\n\t\tconst struct isakmp_gen *ext,\n\t\tu_int item_len _U_, const u_char *ep _U_,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_VID)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_VID)));\n\treturn NULL;\n}", "target": 0}
{"code": "static void load_xref_from_plaintext(FILE *fp, xref_t *xref)\n{\n    int  i, buf_idx, obj_id, added_entries;\n    char c, buf[32] = {0};\n    long start, pos;\n    start = ftell(fp);\n    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')\n          c = fgetc(fp);\n        buf_idx = 0;\n        while (c != '\\n' && c != '\\r' && !feof(fp) &&\n               !ferror(fp) && buf_idx < sizeof(buf))\n        {\n            buf[buf_idx++] = c;\n            c = fgetc(fp);\n        }\n        if (buf_idx >= sizeof(buf))\n        {\n            ERR(\"Failed to locate newline character. \"\n                \"This might be a corrupt PDF.\\n\");\n            exit(EXIT_FAILURE);\n        }\n        buf[buf_idx] = '\\0';\n        if (strchr(buf, 't'))\n          break;\n        if (strlen(buf) > 17)\n        {\n            xref->entries[i].obj_id = obj_id++;\n            xref->entries[i].offset = atol(strtok(buf, \" \"));\n            xref->entries[i].gen_num = atoi(strtok(NULL, \" \"));\n            xref->entries[i].f_or_n = buf[17];\n            ++added_entries;\n        }\n        else\n        {\n            obj_id = atoi(buf);\n            --i;\n        }\n    }\n    xref->n_entries = added_entries;\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "static int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct dentry *de;\n\tstruct vfsmount *mnt = NULL;\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\terror = PROC_I(inode)->op.proc_get_link(inode, &de, &mnt);\n\tif (error)\n\t\tgoto out;\n\terror = do_proc_readlink(de, mnt, buffer, buflen);\n\tdput(de);\n\tmntput(mnt);\nout:\n\treturn error;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor* stamp_token_t;\n    OP_REQUIRES_OK(context, context->input(\"stamp_token\", &stamp_token_t));\n    int64_t stamp_token = stamp_token_t->scalar<int64>()();\n    const Tensor* tree_ensemble_serialized_t;\n    OP_REQUIRES_OK(context, context->input(\"tree_ensemble_serialized\",\n                                           &tree_ensemble_serialized_t));\n    std::unique_ptr<BoostedTreesEnsembleResource> result(\n        new BoostedTreesEnsembleResource());\n    if (!result->InitFromSerialized(\n            tree_ensemble_serialized_t->scalar<tstring>()(), stamp_token)) {\n      result->Unref();\n      result.release();  \n      OP_REQUIRES(\n          context, false,\n          errors::InvalidArgument(\"Unable to parse tree ensemble proto.\"));\n    }\n    auto status =\n        CreateResource(context, HandleFromInput(context, 0), result.release());\n    if (status.code() != tensorflow::error::ALREADY_EXISTS) {\n      OP_REQUIRES_OK(context, status);\n    }\n  }", "target": 0}
{"code": "static unsigned int seedsize(struct crypto_alg *alg)\n{\n\tstruct rng_alg *ralg = container_of(alg, struct rng_alg, base);\n\treturn alg->cra_rng.rng_make_random ?\n\t       alg->cra_rng.seedsize : ralg->seedsize;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() == 2,\n        errors::InvalidArgument(absl::StrCat(\n            \"Shape must be rank 2 but is rank \", sorted_inputs_t.shape().dims(),\n            \" for \"\n            \"`sorted_inputs` argument\")));\n    OP_REQUIRES(ctx, values_t.shape().dims() == 2,\n                errors::InvalidArgument(absl::StrCat(\n                    \"Shape must be rank 2 but is rank \",\n                    values_t.shape().dims(), \" for `values` argument\")));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::UpperBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "tegra_xusb_find_port_node(struct tegra_xusb_padctl *padctl, const char *type,\n\t\t\t  unsigned int index)\n{\n\tstruct device_node *ports, *np;\n\tchar *name;\n\tports = of_get_child_by_name(padctl->dev->of_node, \"ports\");\n\tif (!ports)\n\t\treturn NULL;\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n\treturn np;\n}", "target": 1}
{"code": "void iwjson_ftoa(long double val, char buf[static IWNUMBUF_SIZE], size_t *out_len) {\n  int len = snprintf(buf, 64, \"%.8Lf\", val);\n  if (len <= 0) {\n    buf[0] = '\\0';\n    *out_len = 0;\n    return;\n  }\n  while (len > 0 && buf[len - 1] == '0') { \n    buf[len - 1] = '\\0';\n    len--;\n  }\n  if ((len > 0) && (buf[len - 1] == '.')) {\n    buf[len - 1] = '\\0';\n    len--;\n  }\n  *out_len = (size_t) len;\n}", "target": 1}
{"code": "struct resource_pool *dce110_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc,\n\tstruct hw_asic_id asic_id)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool, asic_id))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_sizes = context->input(0);\n    const Tensor& filter = context->input(1);\n    const Tensor& out_backprop = context->input(2);\n    TensorShape input_shape;\n    OP_REQUIRES_OK(context,\n                   Conv2DBackpropComputeInputShape(input_sizes, filter.shape(),\n                                                   out_backprop.shape(),\n                                                   data_format_, &input_shape));\n    Tensor* in_backprop = nullptr;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input_shape, &in_backprop));\n    if (input_shape.num_elements() == 0) {\n      return;\n    }\n    if (out_backprop.NumElements() == 0) {\n      functor::SetZeroFunctor<Device, T> set_zero;\n      set_zero(context->eigen_device<Device>(),\n               in_backprop->template flat<T>());\n      return;\n    }\n    const int stride_rows = GetTensorDim(strides_, data_format_, 'H');\n    const int stride_cols = GetTensorDim(strides_, data_format_, 'W');\n    const int dilation_rows = GetTensorDim(dilations_, data_format_, 'H');\n    const int dilation_cols = GetTensorDim(dilations_, data_format_, 'W');\n    VLOG(2) << \"Conv2DBackpropInput:\"\n            << \" input: \" << input_shape.DebugString()\n            << \" filter:\" << filter.shape().DebugString()\n            << \" out_backprop: \" << out_backprop.shape().DebugString()\n            << \" strides: [\" << stride_rows << \", \" << stride_cols << \"]\"\n            << \" dilations: [\" << dilation_rows << \", \" << dilation_cols << \"]\";\n    LaunchConv2DBackpropInputOp<Device, T> launch;\n    launch(context, use_cudnn_, cudnn_use_autotune_, out_backprop, filter,\n           dilation_rows, dilation_cols, stride_rows, stride_cols, padding_,\n           explicit_paddings_, in_backprop, data_format_);\n  }", "target": 0}
{"code": "bool Item_splocal::set_value(THD *thd, sp_rcontext *ctx, Item **it)\n{\n  return ctx->set_variable(thd, get_var_idx(), it);\n}", "target": 0}
{"code": "static int create_constraints(struct powercap_zone *power_zone,\n\t\t\tint nr_constraints,\n\t\t\tconst struct powercap_zone_constraint_ops *const_ops)\n{\n\tint i;\n\tint ret = 0;\n\tint count;\n\tstruct powercap_zone_constraint *pconst;\n\tif (!power_zone || !const_ops || !const_ops->get_power_limit_uw ||\n\t\t\t\t\t!const_ops->set_power_limit_uw ||\n\t\t\t\t\t!const_ops->get_time_window_us ||\n\t\t\t\t\t!const_ops->set_time_window_us)\n\t\treturn -EINVAL;\n\tcount = power_zone->zone_attr_count;\n\tfor (i = 0; i < nr_constraints; ++i) {\n\t\tpconst = &power_zone->constraints[i];\n\t\tpconst->ops = const_ops;\n\t\tpconst->id = power_zone->const_id_cnt;\n\t\tpower_zone->const_id_cnt++;\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].power_limit_attr.attr;\n\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].time_window_attr.attr;\n\t\tif (pconst->ops->get_name)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].name_attr.attr;\n\t\tif (pconst->ops->get_max_power_uw)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].max_power_attr.attr;\n\t\tif (pconst->ops->get_min_power_uw)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].min_power_attr.attr;\n\t\tif (pconst->ops->get_max_time_window_us)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].max_time_window_attr.attr;\n\t\tif (pconst->ops->get_min_time_window_us)\n\t\t\tpower_zone->zone_dev_attrs[count++] =\n\t\t\t\t&constraint_attrs[i].min_time_window_attr.attr;\n\t}\n\tpower_zone->zone_attr_count = count;\n\treturn ret;\n}", "target": 0}
{"code": "m_split(struct mbuf *m0, int len0, int wait)\n{\n\tstruct mbuf *m, *n;\n\tunsigned len = len0, remain, olen;\n\tfor (m = m0; m && len > m->m_len; m = m->m_next)\n\t\tlen -= m->m_len;\n\tif (m == NULL)\n\t\treturn (NULL);\n\tremain = m->m_len - len;\n\tif (m0->m_flags & M_PKTHDR) {\n\t\tMGETHDR(n, wait, m0->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tif (m_dup_pkthdr(n, m0, wait)) {\n\t\t\tm_freem(n);\n\t\t\treturn (NULL);\n\t\t}\n\t\tn->m_pkthdr.len -= len0;\n\t\tolen = m0->m_pkthdr.len;\n\t\tm0->m_pkthdr.len = len0;\n\t\tif (remain == 0) {\n\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif (m->m_flags & M_EXT)\n\t\t\tgoto extpacket;\n\t\tif (remain > MHLEN) {\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\tm0->m_pkthdr.len = olen;\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else\n\t\t\tm_align(n, remain);\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tm_align(n, remain);\n\t}\nextpacket:\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;\n\tm->m_next = NULL;\n\treturn (n);\n}", "target": 1}
{"code": "ebt_check_watcher(struct ebt_entry_watcher *w, struct xt_tgchk_param *par,\n\t\t  unsigned int *cnt)\n{\n\tconst struct ebt_entry *e = par->entryinfo;\n\tstruct xt_target *watcher;\n\tsize_t left = ((char *)e + e->target_offset) - (char *)w;\n\tint ret;\n\tif (left < sizeof(struct ebt_entry_watcher) ||\n\t   left - sizeof(struct ebt_entry_watcher) < w->watcher_size)\n\t\treturn -EINVAL;\n\twatcher = xt_request_find_target(NFPROTO_BRIDGE, w->u.name, 0);\n\tif (IS_ERR(watcher))\n\t\treturn PTR_ERR(watcher);\n\tw->u.watcher = watcher;\n\tpar->target   = watcher;\n\tpar->targinfo = w->data;\n\tret = xt_check_target(par, w->watcher_size,\n\t      e->ethproto, e->invflags & EBT_IPROTO);\n\tif (ret < 0) {\n\t\tmodule_put(watcher->me);\n\t\treturn ret;\n\t}\n\t(*cnt)++;\n\treturn 0;\n}", "target": 0}
{"code": "  explicit HashContext(const HashContext* ctx) {\n    assert(ctx->ops);\n    assert(ctx->ops->context_size >= 0);\n    ops = ctx->ops;\n    context = malloc(ops->context_size);\n    ops->hash_copy(context, ctx->context);\n    options = ctx->options;\n    key = ctx->key ? strdup(ctx->key) : nullptr;\n  }", "target": 1}
{"code": "static int hexagon_v6_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tHexInsn hi = {0};;\n\tut32 data = 0;\n\tdata = r_read_le32 (buf);\n\tint size = hexagon_disasm_instruction (data, &hi, (ut32) addr);\n\top->size = size;\n\tif (size <= 0) {\n\t\treturn size;\n\t}\n\top->addr = addr;\n\treturn hexagon_anal_instruction (&hi, op);\n}", "target": 1}
{"code": "nvkm_vmm_node_split(struct nvkm_vmm *vmm,\n\t\t    struct nvkm_vma *vma, u64 addr, u64 size)\n{\n\tstruct nvkm_vma *prev = NULL;\n\tif (vma->addr != addr) {\n\t\tprev = vma;\n\t\tif (!(vma = nvkm_vma_tail(vma, vma->size + vma->addr - addr)))\n\t\t\treturn NULL;\n\t\tvma->part = true;\n\t\tnvkm_vmm_node_insert(vmm, vma);\n\t}\n\tif (vma->size != size) {\n\t\tstruct nvkm_vma *tmp;\n\t\tif (!(tmp = nvkm_vma_tail(vma, vma->size - size))) {\n\t\t\tnvkm_vmm_node_merge(vmm, prev, vma, NULL, vma->size);\n\t\t\treturn NULL;\n\t\t}\n\t\ttmp->part = true;\n\t\tnvkm_vmm_node_insert(vmm, tmp);\n\t}\n\treturn vma;\n}", "target": 0}
{"code": "file_fmtcheck(struct magic_set *ms, const char *desc, const char *def,\n\tconst char *file, size_t line)\n{\n\tconst char *ptr = fmtcheck(desc, def);\n\tif (ptr == def)\n\t\tfile_magerror(ms,\n\t\t    \"%s, %\" SIZE_T_FORMAT \"u: format `%s' does not match\"\n\t\t    \" with `%s'\", file, line, desc, def);\n\treturn ptr;\n}", "target": 0}
{"code": "be32dec_vect(uint32_t *dst, const unsigned char *src, size_t len)\n{\n  size_t i;\n  uint32_t *s;\n  for (i = 0; i < len / 4; i++) {\n    s = (uint32_t *) (src + i * 4);\n    dst[i] = folly::Endian::big32(*s);\n  }\n}", "target": 1}
{"code": "nl80211_parse_mcast_rate(struct cfg80211_registered_device *rdev,\n\t\t\t int mcast_rate[IEEE80211_NUM_BANDS],\n\t\t\t int rateval)\n{\n\tstruct wiphy *wiphy = &rdev->wiphy;\n\tbool found = false;\n\tint band, i;\n\tfor (band = 0; band < IEEE80211_NUM_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tsband = wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif (sband->bitrates[i].bitrate == rateval) {\n\t\t\t\tmcast_rate[band] = i + 1;\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}", "target": 0}
{"code": "int db__message_store_find(struct mosquitto *context, uint16_t mid, struct mosquitto_msg_store **stored)\n{\n\tstruct mosquitto_client_msg *tail;\n\tif(!context) return MOSQ_ERR_INVAL;\n\t*stored = NULL;\n\tDL_FOREACH(context->msgs_in.inflight, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\tDL_FOREACH(context->msgs_in.queued, tail){\n\t\tif(tail->store->source_mid == mid){\n\t\t\t*stored = tail->store;\n\t\t\treturn MOSQ_ERR_SUCCESS;\n\t\t}\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "HMAC_SHA256_Init(struct HMAC_SHA256_CTX * ctx, const void * _K, size_t Klen)\n{\n  unsigned char pad[64];\n  unsigned char khash[32];\n  const unsigned char * K = (unsigned char *) _K;\n  size_t i;\n  if (Klen > 64) {\n    SHA256_Init(&ctx->ictx);\n    scrypt_SHA256_Update(&ctx->ictx, K, Klen);\n    scrypt_SHA256_Final(khash, &ctx->ictx);\n    K = khash;\n    Klen = 32;\n  }\n  SHA256_Init(&ctx->ictx);\n  memset(pad, 0x36, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  scrypt_SHA256_Update(&ctx->ictx, pad, 64);\n  SHA256_Init(&ctx->octx);\n  memset(pad, 0x5c, 64);\n  for (i = 0; i < Klen; i++)\n    pad[i] ^= K[i];\n  scrypt_SHA256_Update(&ctx->octx, pad, 64);\n  memset(khash, 0, 32);\n}", "target": 1}
{"code": "Pl_ASCIIHexDecoder::flush()\n{\n    if (this->pos == 0)\n    {\n\tQTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder no-op flush\");\n\treturn;\n    }\n    int b[2];\n    for (int i = 0; i < 2; ++i)\n    {\n\tif (this->inbuf[i] >= 'A')\n\t{\n\t    b[i] = this->inbuf[i] - 'A' + 10;\n\t}\n\telse\n\t{\n\t    b[i] = this->inbuf[i] - '0';\n\t}\n    }\n    unsigned char ch = static_cast<unsigned char>((b[0] << 4) + b[1]);\n    QTC::TC(\"libtests\", \"Pl_ASCIIHexDecoder partial flush\",\n\t    (this->pos == 2) ? 0 : 1);\n    getNext()->write(&ch, 1);\n    this->pos = 0;\n    this->inbuf[0] = '0';\n    this->inbuf[1] = '0';\n    this->inbuf[2] = '\\0';\n}", "target": 1}
{"code": "comics_decompress_temp_dir (const gchar *command_decompress_tmp,\n\t\t\t    const gchar *command,\n\t\t\t    GError      **error)\n{\n\tgboolean success;\n\tgchar *std_out, *basename;\n\tGError *err = NULL;\n\tgint retval;\n\tsuccess = g_spawn_command_line_sync (command_decompress_tmp, &std_out,\n\t\t\t\t\t     NULL, &retval, &err);\n\tbasename = g_path_get_basename (command);\n\tif (!success) {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"Error launching the command %s in order to \"\n\t\t\t     \"decompress the comic book: %s\"),\n\t\t\t     basename,\n\t\t\t     err->message);\n\t\tg_error_free (err);\n\t} else if (WIFEXITED (retval)) {\n\t\tif (WEXITSTATUS (retval) == EXIT_SUCCESS) {\n\t\t\tg_free (std_out);\n\t\t\tg_free (basename);\n\t\t\treturn TRUE;\n\t\t} else {\n\t\t\tg_set_error (error,\n\t\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t\t     _(\"The command %s failed at \"\n\t\t\t\t     \"decompressing the comic book.\"),\n\t\t\t\t     basename);\n\t\t\tg_free (std_out);\n\t\t}\n\t} else {\n\t\tg_set_error (error,\n\t\t\t     EV_DOCUMENT_ERROR,\n\t\t\t     EV_DOCUMENT_ERROR_INVALID,\n\t\t\t     _(\"The command %s did not end normally.\"),\n\t\t\t     basename);\n\t\tg_free (std_out);\n\t}\n\tg_free (basename);\n\treturn FALSE;\n}", "target": 1}
{"code": "TEST(RegexMatchExpression, MatchesElementExtendedOn) {\n    BSONObj match = BSON(\"x\"\n                         << \"ab\");\n    BSONObj notMatch = BSON(\"x\"\n                            << \"a b\");\n    RegexMatchExpression regex(\"\", \"a b\", \"x\");\n    ASSERT(regex.matchesSingleElement(match.firstElement()));\n    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));\n}", "target": 0}
{"code": "static int oidc_cache_crypto_decrypt(request_rec *r, const char *cache_value,\n\t\tunsigned char *key, unsigned char **plaintext) {\n\tint len = -1;\n\tchar *encoded_tag = strstr(cache_value, \".\");\n\tif (encoded_tag == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"corrupted cache value: no tag separator found in encrypted value\");\n\t\treturn FALSE;\n\t}\n\tcache_value = apr_pstrmemdup(r->pool, cache_value,\n\t\t\tstrlen(cache_value) - strlen(encoded_tag));\n\tencoded_tag++;\n\tchar *d_bytes = NULL;\n\tint d_len = oidc_base64url_decode(r->pool, &d_bytes, cache_value);\n\tchar *t_bytes = NULL;\n\tint t_len = oidc_base64url_decode(r->pool, &t_bytes, encoded_tag);\n\tif ((d_len > 0) && (t_len > 0)) {\n\t\t*plaintext = apr_pcalloc(r->pool,\n\t\t\t\t(d_len + EVP_CIPHER_block_size(OIDC_CACHE_CIPHER) - 1));\n\t\tlen = oidc_cache_crypto_decrypt_impl(r, (unsigned char *) d_bytes,\n\t\t\t\td_len, OIDC_CACHE_CRYPTO_GCM_AAD,\n\t\t\t\tsizeof(OIDC_CACHE_CRYPTO_GCM_AAD), (unsigned char *) t_bytes,\n\t\t\t\tt_len, key, OIDC_CACHE_CRYPTO_GCM_IV,\n\t\t\t\tsizeof(OIDC_CACHE_CRYPTO_GCM_IV), *plaintext);\n\t\tif (len > -1) {\n\t\t\t(*plaintext)[len] = '\\0';\n\t\t} else {\n\t\t\t*plaintext = NULL;\n\t\t}\n\t}\n\treturn len;\n}", "target": 1}
{"code": "void * calloc(size_t n, size_t lb)\n{\n    if ((lb | n) > GC_SQRT_SIZE_MAX \n        && lb && n > GC_SIZE_MAX / lb)\n      return NULL;\n#   if defined(GC_LINUX_THREADS) \n        {\n          static GC_bool lib_bounds_set = FALSE;\n          ptr_t caller = (ptr_t)__builtin_return_address(0);\n          if (!EXPECT(lib_bounds_set, TRUE)) {\n            GC_init_lib_bounds();\n            lib_bounds_set = TRUE;\n          }\n          if (((word)caller >= (word)GC_libpthread_start\n               && (word)caller < (word)GC_libpthread_end)\n              || ((word)caller >= (word)GC_libld_start\n                  && (word)caller < (word)GC_libld_end))\n            return GC_malloc_uncollectable(n*lb);\n        }\n#   endif\n    return((void *)REDIRECT_MALLOC(n*lb));\n}", "target": 0}
{"code": "hb_set_invert (hb_set_t *set)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->invert ();\n}", "target": 1}
{"code": "status_t Parcel::setDataSize(size_t size)\n{\n if (size > INT32_MAX) {\n return BAD_VALUE;\n }\n status_t err;\n    err = continueWrite(size);\n if (err == NO_ERROR) {\n        mDataSize = size;\n        ALOGV(\"setDataSize Setting data size of %p to %zu\", this, mDataSize);\n }\n return err;\n}", "target": 0}
{"code": "void pickSlurp(sdbus::MethodCall& call) {\n    const std::string PICK_COLOR_CMD = \"grim -g \\\"$(slurp -p)\\\" -t ppm -\";\n    std::string       ppmColor       = execAndGet(PICK_COLOR_CMD.c_str());\n    ppmColor = std::regex_replace(ppmColor, std::regex(\"\\\\s+\"), std::string(\" \"));\n    if (!ppmColor.starts_with(\"P6 1 1 \")) {\n        Debug::log(ERR, \"grim did not return a PPM Image for us.\");\n        sendEmptyDbusMethodReply(call, 1);\n        return;\n    }\n    try {\n        std::string maxValString = ppmColor.substr(7, ppmColor.size());\n        maxValString             = maxValString.substr(0, maxValString.find(' '));\n        uint32_t maxVal          = std::stoi(maxValString);\n        double r, g, b;\n        if (maxVal < 256) {\n            std::string byteString = ppmColor.substr(11, 14);\n            r = (uint8_t)byteString[0] / (maxVal * 1.0);\n            g = (uint8_t)byteString[1] / (maxVal * 1.0);\n            b = (uint8_t)byteString[2] / (maxVal * 1.0);\n        } else {\n            std::string byteString = ppmColor.substr(11, 17);\n            r = ((byteString[0] << 8) | byteString[1]) / (maxVal * 1.0);\n            g = ((byteString[2] << 8) | byteString[3]) / (maxVal * 1.0);\n            b = ((byteString[4] << 8) | byteString[5]) / (maxVal * 1.0);\n        }\n        auto reply = call.createReply();\n        std::unordered_map<std::string, sdbus::Variant> results;\n        results[\"color\"] = sdbus::Struct(std::tuple{r, g, b});\n        reply << (uint32_t)0;\n        reply << results;\n        reply.send();\n    } catch (...) {\n        Debug::log(ERR, \"Converting PPM to RGB failed. This is likely a string to integer error.\");\n        sendEmptyDbusMethodReply(call, 1);\n    }\n}", "target": 1}
{"code": "static int srv_init(uint16_t lport)\n{\n\tstruct sa laddr;\n\tstruct tcp_sock *tsock;\n\tint err;\n\tinfo(\"srv_init: lport=%d\\n\", (int)lport);\n\terr = sa_set_str(&laddr, \"0.0.0.0\", lport);\n\tif (err)\n\t\treturn err;\n\terr = http_listen(&verifyd.sock, &laddr, http_req_handler, NULL);\n\tif (err) {\n\t\tre_fprintf(stderr, \"http_listen: failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\ttsock = http_sock_tcp(verifyd.sock);\n\tif (tsock) {\n\t\ttcp_sock_local_get(tsock, &laddr);\n\t}\n\tre_fprintf(stderr, \"verifyd: listening on %J\\n\", &laddr);\n\treturn 0;\n}", "target": 0}
{"code": "GF_Err moof_on_child_box(GF_Box *s, GF_Box *a)\n{\n\tGF_MovieFragmentBox *ptr = (GF_MovieFragmentBox *)s;\n\tswitch (a->type) {\n\tcase GF_ISOM_BOX_TYPE_MFHD:\n\t\tif (ptr->mfhd) ERROR_ON_DUPLICATED_BOX(a, ptr)\n\t\tptr->mfhd = (GF_MovieFragmentHeaderBox *) a;\n\t\treturn GF_OK;\n\tcase GF_ISOM_BOX_TYPE_TRAF:\n\t\treturn gf_list_add(ptr->TrackList, a);\n\tcase GF_ISOM_BOX_TYPE_PSSH:\n\t\tif (!ptr->PSSHs) ptr->PSSHs = gf_list_new();\n\t\treturn gf_list_add(ptr->PSSHs, a);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "pci_get_cfgdata16(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\treturn (*(uint16_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "    uint32_t TiffEntryBase::doWriteImage(IoWrapper&,\n                                         ByteOrder ) const\n    {\n        return 0;\n    } ", "target": 0}
{"code": "void gdImageSetBrush (gdImagePtr im, gdImagePtr brush)\n{\n\tint i;\n\tim->brush = brush;\n\tif (!im->trueColor && !im->brush->trueColor) {\n\t\tfor (i = 0; i < gdImageColorsTotal(brush); i++) {\n\t\t\tint index;\n\t\t\tindex = gdImageColorResolveAlpha(im, gdImageRed(brush, i), gdImageGreen(brush, i), gdImageBlue(brush, i), gdImageAlpha(brush, i));\n\t\t\tim->brushColorMap[i] = index;\n\t\t}\n\t}\n}", "target": 0}
{"code": "ev_archive_at_entry (EvArchive *archive)\n{\n\tg_return_val_if_fail (EV_IS_ARCHIVE (archive), FALSE);\n\tg_return_val_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE, FALSE);\n\treturn (archive->libar_entry != NULL);\n}", "target": 0}
{"code": "int main(void)\n{\n    size_t failedTestCount = 0;\n    RUN_TEST_SUITE(link_ut, failedTestCount);\n    return (int)failedTestCount;\n}", "target": 0}
{"code": "http_DissectRequest(struct sess *sp)\n{\n\tstruct http_conn *htc;\n\tstruct http *hp;\n\tuint16_t retval;\n\tCHECK_OBJ_NOTNULL(sp, SESS_MAGIC);\n\thtc = sp->htc;\n\tCHECK_OBJ_NOTNULL(htc, HTTP_CONN_MAGIC);\n\thp = sp->http;\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\thp->logtag = HTTP_Rx;\n\tretval = http_splitline(sp->wrk, sp->fd, hp, htc,\n\t    HTTP_HDR_REQ, HTTP_HDR_URL, HTTP_HDR_PROTO);\n\tif (retval != 0) {\n\t\tWSPR(sp, SLT_HttpGarbage, htc->rxbuf);\n\t\treturn (retval);\n\t}\n\thttp_ProtoVer(hp);\n\tretval = htc_request_check_host_hdr(hp);\n\tif (retval != 0) {\n\t\tWSP(sp, SLT_Error, \"Duplicated Host header\");\n\t\treturn (retval);\n\t}\n\treturn (retval);\n}", "target": 1}
{"code": "delete_policy_2_svc(dpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->name;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_DELETE, NULL, NULL)) {\n        log_unauth(\"kadm5_delete_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_DELETE;\n    } else {\n        ret.code = kadm5_delete_policy((void *)handle, arg->name);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_delete_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "bool Url::Decode(string_view encoded, std::string* raw) {\n  for (auto iter = encoded.begin(); iter != encoded.end(); ++iter) {\n    if (*iter == '%') {\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int h_decimal = 0;\n      if (!HexToDecimal(*iter, &h_decimal)) {\n        return false;\n      }\n      if (++iter == encoded.end()) {\n        return false;\n      }\n      int l_decimal = 0;\n      if (!HexToDecimal(*iter, &l_decimal)) {\n        return false;\n      }\n      raw->push_back(static_cast<char>((h_decimal << 4) + l_decimal));\n    } else if (*iter > 127 || *iter < 0) {\n      return false;\n    } else {\n      raw->push_back(*iter);\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "  const std::string& get_tenant() const {\n    ceph_assert(t != Wildcard);\n    return u.tenant;\n  }", "target": 1}
{"code": "hb_set_set (hb_set_t       *set,\n\t    const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->set (*other);\n}", "target": 1}
{"code": "bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}", "target": 1}
{"code": "Status CompressElement(const std::vector<Tensor>& element,\n                       CompressedElement* out) {\n  std::vector<TensorProto> non_memcpy_components;\n  int64 total_size = 0;\n  for (auto& component : element) {\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      total_size += DMAHelper::buffer(&component)->size();\n    } else {\n      non_memcpy_components.emplace_back();\n      component.AsProtoTensorContent(&non_memcpy_components.back());\n      total_size += non_memcpy_components.back().ByteSizeLong();\n    }\n  }\n  tstring uncompressed;\n  uncompressed.resize_uninitialized(total_size);\n  char* position = uncompressed.mdata();\n  int non_memcpy_component_index = 0;\n  for (auto& component : element) {\n    CompressedComponentMetadata* metadata =\n        out->mutable_component_metadata()->Add();\n    metadata->set_dtype(component.dtype());\n    component.shape().AsProto(metadata->mutable_tensor_shape());\n    if (DataTypeCanUseMemcpy(component.dtype())) {\n      const TensorBuffer* buffer = DMAHelper::buffer(&component);\n      memcpy(position, buffer->data(), buffer->size());\n      metadata->set_tensor_size_bytes(buffer->size());\n    } else {\n      TensorProto& proto = non_memcpy_components[non_memcpy_component_index++];\n      proto.SerializeToArray(position, proto.ByteSizeLong());\n      metadata->set_tensor_size_bytes(proto.ByteSizeLong());\n    }\n    position += metadata->tensor_size_bytes();\n  }\n  DCHECK_EQ(position, uncompressed.mdata() + total_size);\n  if (!port::Snappy_Compress(uncompressed.mdata(), total_size,\n                             out->mutable_data())) {\n    return errors::Internal(\"Failed to compress using snappy.\");\n  }\n  VLOG(3) << \"Compressed element from \" << total_size << \" bytes to \"\n          << out->data().size() << \" bytes\";\n  return Status::OK();\n}", "target": 1}
{"code": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n  real_tty_path += 5;\t\t\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n  return result;\n}", "target": 1}
{"code": "netsnmp_mibindex_lookup( const char *dirname )\n{\n    int i;\n    static char tmpbuf[300];\n    for (i=0; i<_mibindex; i++) {\n        if ( _mibindexes[i] &&\n             strcmp( _mibindexes[i], dirname ) == 0) {\n             snprintf(tmpbuf, sizeof(tmpbuf), \"%s/mib_indexes/%d\",\n                      get_persistent_directory(), i);\n             tmpbuf[sizeof(tmpbuf)-1] = 0;\n             DEBUGMSGTL((\"mibindex\", \"lookup: %s (%d) %s\\n\", dirname, i, tmpbuf ));\n             return tmpbuf;\n        }\n    }\n    DEBUGMSGTL((\"mibindex\", \"lookup: (none)\\n\"));\n    return NULL;\n}", "target": 1}
{"code": "  bool ms_deliver_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer, bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    for (list<Dispatcher*>::iterator p = dispatchers.begin();\n\t p != dispatchers.end();\n\t ++p) {\n      if ((*p)->ms_verify_authorizer(con, peer_type, protocol, authorizer, authorizer_reply, isvalid, session_key))\n\treturn true;\n    }\n    return false;\n  }", "target": 1}
{"code": "ext4_xattr_put_super(struct super_block *sb)\n{\n\tmb_cache_shrink(sb->s_bdev);\n}", "target": 1}
{"code": "static inline bool set_page_guard(struct zone *zone, struct page *page,\n\t\t\t\tunsigned int order, int migratetype)\n{\n\tstruct page_ext *page_ext;\n\tif (!debug_guardpage_enabled())\n\t\treturn false;\n\tif (order >= debug_guardpage_minorder())\n\t\treturn false;\n\tpage_ext = lookup_page_ext(page);\n\tif (unlikely(!page_ext))\n\t\treturn false;\n\t__set_bit(PAGE_EXT_DEBUG_GUARD, &page_ext->flags);\n\tINIT_LIST_HEAD(&page->lru);\n\tset_page_private(page, order);\n\t__mod_zone_freepage_state(zone, -(1 << order), migratetype);\n\treturn true;\n}", "target": 0}
{"code": "static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair)\n{\n\tsize_t offset;\n\tif (!pcbAvPair)\n\t\treturn NULL;\n\tif (!ntlm_av_pair_check(pAvPair, *pcbAvPair))\n\t\treturn NULL;\n\toffset = ntlm_av_pair_get_next_offset(pAvPair);\n\t*pcbAvPair -= offset;\n\treturn (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset);\n}", "target": 1}
{"code": "static int DefragBsdPeose173Ipv6Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "static void test_double_compare()\n{\n  MYSQL_STMT *stmt;\n  int        rc;\n  char       real_data[10], tiny_data;\n  double     double_data;\n  MYSQL_RES  *result;\n  MYSQL_BIND my_bind[3];\n  ulong      length[3];\n  char query[MAX_TEST_QUERY_LENGTH];\n  myheader(\"test_double_compare\");\n  rc= mysql_autocommit(mysql, TRUE);\n  myquery(rc);\n  rc= mysql_query(mysql, \"DROP TABLE IF EXISTS test_double_compare\");\n  myquery(rc);\n  rc= mysql_query(mysql, \"CREATE TABLE test_double_compare(col1 tinyint, \"\n                         \" col2 float, col3 double )\");\n  myquery(rc);\n  rc= mysql_query(mysql, \"INSERT INTO test_double_compare \"\n                         \"VALUES (1, 10.2, 34.5)\");\n  myquery(rc);\n  strmov(query, \"UPDATE test_double_compare SET col1=100 \"\n                \"WHERE col1 = ? AND col2 = ? AND COL3 = ?\");\n  stmt= mysql_simple_prepare(mysql, query);\n  check_stmt(stmt);\n  verify_param_count(stmt, 3);\n  memset(my_bind, 0, sizeof(my_bind));\n  my_bind[0].buffer_type= MYSQL_TYPE_TINY;\n  my_bind[0].buffer= (void *)&tiny_data;\n  my_bind[1].buffer_type= MYSQL_TYPE_STRING;\n  my_bind[1].buffer= (void *)&real_data;\n  my_bind[1].buffer_length= sizeof(real_data);\n  my_bind[1].length= &length[1];\n  length[1]= 10;\n  my_bind[2].buffer_type= MYSQL_TYPE_DOUBLE;\n  my_bind[2].buffer= (void *)&double_data;\n  tiny_data= 1;\n  strmov(real_data, \"10.2\");\n  double_data= 34.5;\n  rc= mysql_stmt_bind_param(stmt, my_bind);\n  check_execute(stmt, rc);\n  rc= mysql_stmt_execute(stmt);\n  check_execute(stmt, rc);\n  verify_affected_rows(0);\n  mysql_stmt_close(stmt);\n  rc= mysql_commit(mysql);\n  myquery(rc);\n  rc= mysql_query(mysql, \"SELECT * FROM test_double_compare\");\n  myquery(rc);\n  result= mysql_store_result(mysql);\n  mytest(result);\n  rc= my_process_result_set(result);\n  DIE_UNLESS((int)tiny_data == rc);\n  mysql_free_result(result);\n}", "target": 0}
{"code": "void cgit_tag_link(const char *name, const char *title, const char *class,\n\t\t   const char *tag)\n{\n\treporevlink(\"tag\", name, title, class, tag, NULL, NULL);\n}", "target": 0}
{"code": "TEST(ModMatchExpression, MatchesScalar) {\n    ModMatchExpression mod(\"a\", 5, 2);\n    ASSERT(mod.matchesBSON(BSON(\"a\" << 7.0), NULL));\n    ASSERT(!mod.matchesBSON(BSON(\"a\" << 4), NULL));\n}", "target": 0}
{"code": "pid_t LightProcess::waitpid(pid_t pid, int *stat_loc, int options,\n                            int timeout) {\n  if (!Available()) {\n    return ::waitpid(pid, stat_loc, options);\n  }\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  fprintf(g_procs[id].m_fout, \"waitpid\\n%\" PRId64 \" %d %d\\n\", (int64_t)pid, options,\n          timeout);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (!buf[0]) return -1;\n  int64_t ret;\n  int stat;\n  sscanf(buf, \"%\" PRId64 \" %d\", &ret, &stat);\n  *stat_loc = stat;\n  if (ret < 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n  }\n  return (pid_t)ret;\n}", "target": 1}
{"code": "TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  \n    case kTfLiteFloat32:\n      return AverageEvalFloat<kernel_type>(context, node, params, data, input,\n                                           output);\n    case kTfLiteUInt8:\n      return AverageEvalQuantizedUint8<kernel_type>(context, node, params, data,\n                                                    input, output);\n    case kTfLiteInt8:\n      return AverageEvalQuantizedInt8<kernel_type>(context, node, params, data,\n                                                   input, output);\n    case kTfLiteInt16:\n      return AverageEvalQuantizedInt16<kernel_type>(context, node, params, data,\n                                                    input, output);\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static int target_xcopy_locate_se_dev_e4(const unsigned char *dev_wwn,\n\t\t\t\t\tstruct se_device **found_dev)\n{\n\tstruct xcopy_dev_search_info info;\n\tint ret;\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dev_wwn = dev_wwn;\n\tret = target_for_each_device(target_xcopy_locate_se_dev_e4_iter, &info);\n\tif (ret == 1) {\n\t\t*found_dev = info.found_dev;\n\t\treturn 0;\n\t} else {\n\t\tpr_debug_ratelimited(\"Unable to locate 0xe4 descriptor for EXTENDED_COPY\\n\");\n\t\treturn -EINVAL;\n\t}\n}", "target": 1}
{"code": "open_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\tif (!name)\n\t\treturn;\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\tFREE(file_name);\n}", "target": 1}
{"code": "krb5_gss_context_time(minor_status, context_handle, time_rec)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    OM_uint32 *time_rec;\n{\n    krb5_error_code code;\n    krb5_gss_ctx_id_rec *ctx;\n    krb5_timestamp now;\n    krb5_deltat lifetime;\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    if ((code = krb5_timeofday(ctx->k5_context, &now))) {\n        *minor_status = code;\n        save_error_info(*minor_status, ctx->k5_context);\n        return(GSS_S_FAILURE);\n    }\n    if ((lifetime = ctx->krb_times.endtime - now) <= 0) {\n        *time_rec = 0;\n        *minor_status = 0;\n        return(GSS_S_CONTEXT_EXPIRED);\n    } else {\n        *time_rec = lifetime;\n        *minor_status = 0;\n        return(GSS_S_COMPLETE);\n    }\n}", "target": 1}
{"code": "static int adpt_i2o_enable_hba(adpt_hba* pHba)\n{\n\tu32 msg[4];\n\tint ret;\n\tadpt_i2o_status_get(pHba);\n\tif(!pHba->status_block){\n\t\treturn -ENOMEM;\n\t}\n\tif(pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL)\n\t\treturn 0;\n\tif(pHba->status_block->iop_state != ADAPTER_STATE_READY)\n\t\treturn -EINVAL;\n\tmsg[0]=FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1]=I2O_CMD_SYS_ENABLE<<24|HOST_TID<<12|ADAPTER_TID;\n\tmsg[2]= 0;\n\tmsg[3]= 0;\n\tif ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {\n\t\tprintk(KERN_WARNING\"%s: Could not enable (status=%#10x).\\n\", \n\t\t\tpHba->name, ret);\n\t} else {\n\t\tPDEBUG(\"%s: Enabled.\\n\", pHba->name);\n\t}\n\tadpt_i2o_status_get(pHba);\n\treturn ret;\n}", "target": 1}
{"code": "int multiplyCheckOverflow(int a, int b, int *result)\n{\n#if (defined __GNUC__ && __GNUC__ >= 5) || ( __clang__ && __has_builtin(__builtin_mul_overflow))\n\treturn __builtin_mul_overflow(a, b, result);\n#else\n\tif (firstBitSet(a)+firstBitSet(b)>31) \n\t\treturn true;\n\t*result = a * b;\n\treturn false;\n#endif\n}", "target": 0}
{"code": "qedi_dbg_err(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t     const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_err(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t       nfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_err(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\n\tva_end(va);\n}", "target": 1}
{"code": "void HttpIntegrationTest::testLargeRequestTrailers(uint32_t size, uint32_t max_size) {\n  config_helper_.addConfigModifier(\n      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)\n          -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });\n  max_request_headers_kb_ = max_size;\n  Http::TestHeaderMapImpl request_trailers{{\"trailer\", \"trailer\"}};\n  request_trailers.addCopy(\"big\", std::string(size * 1024, 'a'));\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);\n  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  codec_client_->sendData(*request_encoder_, 10, false);\n  codec_client_->sendTrailers(*request_encoder_, request_trailers);\n  if (size >= max_size && downstream_protocol_ == Http::CodecClient::Type::HTTP2) {\n    response->waitForReset();\n    codec_client_->close();\n    EXPECT_FALSE(response->complete());\n  } else {\n    waitForNextUpstreamRequest();\n    upstream_request_->encodeHeaders(default_response_headers_, true);\n    response->waitForEndStream();\n    EXPECT_TRUE(response->complete());\n  }\n}", "target": 0}
{"code": "gs_heap_resize_object(gs_memory_t * mem, void *obj, uint new_num_elements,\n                      client_name_t cname)\n{\n    gs_malloc_memory_t *mmem = (gs_malloc_memory_t *) mem;\n    gs_malloc_block_t *ptr = (gs_malloc_block_t *) obj - 1;\n    gs_memory_type_ptr_t pstype = ptr->type;\n    uint old_size = gs_object_size(mem, obj) + sizeof(gs_malloc_block_t);\n    uint new_size =\n        gs_struct_type_size(pstype) * new_num_elements +\n        sizeof(gs_malloc_block_t);\n    gs_malloc_block_t *new_ptr;\n    if (new_size == old_size)\n        return obj;\n    if (mmem->monitor)\n        gx_monitor_enter(mmem->monitor);\t\n    new_ptr = (gs_malloc_block_t *) gs_realloc(ptr, old_size, new_size);\n    if (new_ptr == 0)\n        return 0;\n    if (new_ptr->prev)\n        new_ptr->prev->next = new_ptr;\n    else\n        mmem->allocated = new_ptr;\n    if (new_ptr->next)\n        new_ptr->next->prev = new_ptr;\n    new_ptr->size = new_size - sizeof(gs_malloc_block_t);\n    mmem->used -= old_size;\n    mmem->used += new_size;\n    if (mmem->monitor)\n        gx_monitor_leave(mmem->monitor);\t\n    if (new_size > old_size)\n        gs_alloc_fill((byte *) new_ptr + old_size,\n                      gs_alloc_fill_alloc, new_size - old_size);\n    return new_ptr + 1;\n}", "target": 0}
{"code": "void PDFiumEngine::Form_DoGoToAction(FPDF_FORMFILLINFO* param,\n                                     int page_index,\n                                     int zoom_mode,\n                                     float* position_array,\n                                     int size_of_array) {\n  PDFiumEngine* engine = static_cast<PDFiumEngine*>(param);\n  engine->ScrollToPage(page_index);\n}", "target": 0}
{"code": "deinit_authz(void *data)\n{\n  authz_pool = NULL;\n  filtered_pool = NULL;\n  authz_pool_initialized = FALSE;\n  return APR_SUCCESS;\n}", "target": 0}
{"code": "static NTSTATUS smb_set_file_dosmode(connection_struct *conn,\n\t\t\t\t     struct files_struct *fsp,\n\t\t\t\t     uint32_t dosmode)\n{\n\tstruct files_struct *dos_fsp = NULL;\n\tuint32_t current_dosmode;\n\tint ret;\n\tif (!VALID_STAT(fsp->fsp_name->st)) {\n\t\treturn NT_STATUS_OBJECT_NAME_NOT_FOUND;\n\t}\n\tdos_fsp = fsp->base_fsp != NULL ? fsp->base_fsp : fsp;\n\tif (dosmode != 0) {\n\t\tif (S_ISDIR(fsp->fsp_name->st.st_ex_mode)) {\n\t\t\tdosmode |= FILE_ATTRIBUTE_DIRECTORY;\n\t\t} else {\n\t\t\tdosmode &= ~FILE_ATTRIBUTE_DIRECTORY;\n\t\t}\n\t}\n\tDBG_DEBUG(\"dosmode: 0x%\" PRIx32 \"\\n\", dosmode);\n\tif (dosmode == 0) {\n\t\treturn NT_STATUS_OK;\n\t}\n\tcurrent_dosmode = fdos_mode(dos_fsp);\n\tif (dosmode == current_dosmode) {\n\t\treturn NT_STATUS_OK;\n\t}\n\tDBG_DEBUG(\"file %s : setting dos mode 0x%\" PRIx32 \"\\n\",\n\t\t  fsp_str_dbg(dos_fsp), dosmode);\n\tret = file_set_dosmode(conn, dos_fsp->fsp_name, dosmode, NULL, false);\n\tif (ret != 0) {\n\t\tDBG_WARNING(\"file_set_dosmode of %s failed: %s\\n\",\n\t\t\t    fsp_str_dbg(dos_fsp), strerror(errno));\n\t\treturn map_nt_error_from_unix(errno);\n\t}\n\treturn NT_STATUS_OK;\n}", "target": 0}
{"code": "hybiRemaining(ws_ctx_t *wsctx)\n{\n  return wsctx->nToRead - wsctx->nReadRaw;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() >= 2,\n        errors::InvalidArgument(\"sorted input argument must be a matrix\"));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::UpperBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "static void ToPropertyDescriptor(js_State *J, js_Object *obj, const char *name, js_Object *desc)\n{\n\tint haswritable = 0;\n\tint hasvalue = 0;\n\tint enumerable = 0;\n\tint configurable = 0;\n\tint writable = 0;\n\tint atts = 0;\n\tjs_pushobject(J, obj);\n\tjs_pushobject(J, desc);\n\tif (js_hasproperty(J, -1, \"writable\")) {\n\t\thaswritable = 1;\n\t\twritable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"enumerable\")) {\n\t\tenumerable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"configurable\")) {\n\t\tconfigurable = js_toboolean(J, -1);\n\t\tjs_pop(J, 1);\n\t}\n\tif (js_hasproperty(J, -1, \"value\")) {\n\t\thasvalue = 1;\n\t\tjs_setproperty(J, -3, name);\n\t}\n\tif (!writable) atts |= JS_READONLY;\n\tif (!enumerable) atts |= JS_DONTENUM;\n\tif (!configurable) atts |= JS_DONTCONF;\n\tif (js_hasproperty(J, -1, \"get\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\tif (js_hasproperty(J, -2, \"set\")) {\n\t\tif (haswritable || hasvalue)\n\t\t\tjs_typeerror(J, \"value/writable and get/set attributes are exclusive\");\n\t} else {\n\t\tjs_pushundefined(J);\n\t}\n\tjs_defaccessor(J, -4, name, atts);\n\tjs_pop(J, 2);\n}", "target": 1}
{"code": "PHP_FUNCTION(imagegammacorrect)\n{\n\tzval *IM;\n\tgdImagePtr im;\n\tint i;\n\tdouble input, output;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rdd\", &IM, &input, &output) == FAILURE) {\n\t\treturn;\n\t}\n\tif ( input <= 0.0 || output <= 0.0 ) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Gamma values should be positive\");\n\t\tRETURN_FALSE;\n\t}\n\tZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n\tif (gdImageTrueColor(im))\t{\n\t\tint x, y, c;\n\t\tfor (y = 0; y < gdImageSY(im); y++)\t{\n\t\t\tfor (x = 0; x < gdImageSX(im); x++)\t{\n\t\t\t\tc = gdImageGetPixel(im, x, y);\n\t\t\t\tgdImageSetPixel(im, x, y,\n\t\t\t\t\tgdTrueColorAlpha(\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetRed(c)   / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetGreen(c) / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\t(int) ((pow((pow((gdTrueColorGetBlue(c)  / 255.0), input)), 1.0 / output) * 255) + .5),\n\t\t\t\t\t\tgdTrueColorGetAlpha(c)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tRETURN_TRUE;\n\t}\n\tfor (i = 0; i < gdImageColorsTotal(im); i++) {\n\t\tim->red[i]   = (int)((pow((pow((im->red[i]   / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->green[i] = (int)((pow((pow((im->green[i] / 255.0), input)), 1.0 / output) * 255) + .5);\n\t\tim->blue[i]  = (int)((pow((pow((im->blue[i]  / 255.0), input)), 1.0 / output) * 255) + .5);\n\t}\n\tRETURN_TRUE;\n}", "target": 0}
{"code": "static void vgacon_flush_scrollback(struct vc_data *c)\n{\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tvgacon_scrollback_reset(c->vc_num, size);\n}", "target": 1}
{"code": "static void add_offer_options(uint8_t *option_start_address)\n{\n\tuint8_t *temp_option_addr;\n\ttemp_option_addr = fill_one_option_content(option_start_address,\n\t\t\tDHCP_OPTION_CODE_SUBNET_MASK, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_mask);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_ROUTER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_address);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_DNS_SERVER, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcps_local_address);\t\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_LEASE_TIME, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t\t(void *)&dhcp_option_lease_time);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\t\tDHCP_OPTION_CODE_SERVER_ID, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&dhcps_local_address);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_BROADCAST_ADDRESS, DHCP_OPTION_LENGTH_FOUR,\n\t\t\t\t(void *)&dhcps_subnet_broadcast);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_INTERFACE_MTU, DHCP_OPTION_LENGTH_TWO,\n\t\t\t\t\t(void *) &dhcp_option_interface_mtu);\n\ttemp_option_addr = fill_one_option_content(temp_option_addr,\n\t\tDHCP_OPTION_CODE_PERFORM_ROUTER_DISCOVERY, DHCP_OPTION_LENGTH_ONE,\n\t\t\t\t\t\t\t\tNULL);\n\t*temp_option_addr++ = DHCP_OPTION_CODE_END;\n}", "target": 1}
{"code": "int vcc_getsockopt(struct socket *sock, int level, int optname,\n\t\t   char __user *optval, int __user *optlen)\n{\n\tstruct atm_vcc *vcc;\n\tint len;\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\tif (__SO_LEVEL_MATCH(optname, level) && len != __SO_SIZE(optname))\n\t\treturn -EINVAL;\n\tvcc = ATM_SD(sock);\n\tswitch (optname) {\n\tcase SO_ATMQOS:\n\t\tif (!test_bit(ATM_VF_HASQOS, &vcc->flags))\n\t\t\treturn -EINVAL;\n\t\treturn copy_to_user(optval, &vcc->qos, sizeof(vcc->qos))\n\t\t\t? -EFAULT : 0;\n\tcase SO_SETCLP:\n\t\treturn put_user(vcc->atm_options & ATM_ATMOPT_CLP ? 1 : 0,\n\t\t\t\t(unsigned long __user *)optval) ? -EFAULT : 0;\n\tcase SO_ATMPVC:\n\t{\n\t\tstruct sockaddr_atmpvc pvc;\n\t\tif (!vcc->dev || !test_bit(ATM_VF_ADDR, &vcc->flags))\n\t\t\treturn -ENOTCONN;\n\t\tmemset(&pvc, 0, sizeof(pvc));\n\t\tpvc.sap_family = AF_ATMPVC;\n\t\tpvc.sap_addr.itf = vcc->dev->number;\n\t\tpvc.sap_addr.vpi = vcc->vpi;\n\t\tpvc.sap_addr.vci = vcc->vci;\n\t\treturn copy_to_user(optval, &pvc, sizeof(pvc)) ? -EFAULT : 0;\n\t}\n\tdefault:\n\t\tif (level == SOL_SOCKET)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\tif (!vcc->dev || !vcc->dev->ops->getsockopt)\n\t\treturn -EINVAL;\n\treturn vcc->dev->ops->getsockopt(vcc, level, optname, optval, len);\n}", "target": 0}
{"code": "void SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}", "target": 1}
{"code": "static inline void mcryptd_check_internal(struct rtattr **tb, u32 *type,\n\t\t\t\t\t  u32 *mask)\n{\n\tstruct crypto_attr_type *algt;\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn;\n\tif ((algt->type & CRYPTO_ALG_INTERNAL))\n\t\t*type |= CRYPTO_ALG_INTERNAL;\n\tif ((algt->mask & CRYPTO_ALG_INTERNAL))\n\t\t*mask |= CRYPTO_ALG_INTERNAL;\n}", "target": 1}
{"code": "static inline int dpt_dma64(adpt_hba *pHba)\n{\n\treturn (sizeof(dma_addr_t) > 4 && (pHba)->dma64);\n}", "target": 1}
{"code": "void jslGetTokenString(char *str, size_t len) {\n  if (lex->tk == LEX_ID) {\n    strncpy(str, \"ID:\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n  } else if (lex->tk == LEX_STR) {\n    strncpy(str, \"String:'\", len);\n    strncat(str, jslGetTokenValueAsString(), len);\n    strncat(str, \"'\", len);\n  } else\n    jslTokenAsString(lex->tk, str, len);\n}", "target": 1}
{"code": "auth_iochannel_watch (GIOChannel   *source,\n                      GIOCondition  condition,\n                      IceConn       ice_conn)\n{\n        GsmIceConnectionWatch *data;\n        gboolean               keep_going;\n        data = ice_conn->context;\n        switch (IceProcessMessages (ice_conn, NULL, NULL)) {\n        case IceProcessMessagesSuccess:\n                keep_going = TRUE;\n                break;\n        case IceProcessMessagesIOError:\n                g_debug (\"GsmXsmpServer: IceProcessMessages returned IceProcessMessagesIOError\");\n                free_ice_connection_watch (data);\n                disconnect_ice_connection (ice_conn);\n                keep_going = FALSE;\n                break;\n        case IceProcessMessagesConnectionClosed:\n                g_debug (\"GsmXsmpServer: IceProcessMessages returned IceProcessMessagesConnectionClosed\");\n                free_ice_connection_watch (data);\n                keep_going = FALSE;\n                break;\n        default:\n                g_assert_not_reached ();\n        }\n        return keep_going;\n}", "target": 0}
{"code": " */\nint re_yyget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    return yylineno;", "target": 1}
{"code": "static bool ndp_msg_addrto_validate_link_local(struct in6_addr *addr)\n{\n\treturn IN6_IS_ADDR_LINKLOCAL (addr);\n}", "target": 0}
{"code": "static void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tflush_kthread_work(&pit->expired);\n}", "target": 0}
{"code": "static void fio_signal_handler_setup(void) {\n  struct sigaction act;\n  if (fio_old_sig_int.sa_handler)\n    return;\n  memset(&act, 0, sizeof(act));\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}", "target": 1}
{"code": "int ipmi_si_port_setup(struct si_sm_io *io)\n{\n\tunsigned int addr = io->addr_data;\n\tint          idx;\n\tif (!addr)\n\t\treturn -ENODEV;\n\tio->io_cleanup = port_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = port_inb;\n\t\tio->outputb = port_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = port_inw;\n\t\tio->outputb = port_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = port_inl;\n\t\tio->outputb = port_outl;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_region(addr + idx * io->regspacing,\n\t\t\t\t   io->regsize, DEVICE_NAME) == NULL) {\n\t\t\twhile (idx--)\n\t\t\t\trelease_region(addr + idx * io->regspacing,\n\t\t\t\t\t       io->regsize);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "level_cost(unsigned int n)\n{\n    static const double log_1_1 = 0.09531017980432493;\n\treturn ceil(log(n + 0.1)/log_1_1);\n}", "target": 0}
{"code": "void ParamTraits<FilePath>::Write(Message* m, const param_type& p) {\n  ParamTraits<FilePath::StringType>::Write(m, p.value());\n}", "target": 0}
{"code": "static int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs;\n\tstruct inode *inode = page->mapping->host;\n\ttrace_ext4_writepage(inode, page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_CACHE_SHIFT)\n\t\tlen = size & ~PAGE_CACHE_MASK;\n\telse\n\t\tlen = PAGE_CACHE_SIZE;\n\tif (page_has_buffers(page)) {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tret = block_prepare_write(page, 0, len,\n\t\t\t\t\t  noalloc_get_block_write);\n\t\tif (!ret) {\n\t\t\tpage_bufs = page_buffers(page);\n\t\t\tif (walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t\t\text4_bh_delay_or_unwritten)) {\n\t\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\t\tunlock_page(page);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\tredirty_page_for_writepage(wbc, page);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tblock_commit_write(page, 0, len);\n\t}\n\tif (PageChecked(page) && ext4_should_journal_data(inode)) {\n\t\tClearPageChecked(page);\n\t\treturn __ext4_journalled_writepage(page, len);\n\t}\n\tif (test_opt(inode->i_sb, NOBH) && ext4_should_writeback_data(inode))\n\t\tret = nobh_writepage(page, noalloc_get_block_write, wbc);\n\telse\n\t\tret = block_write_full_page(page, noalloc_get_block_write,\n\t\t\t\t\t    wbc);\n\treturn ret;\n}", "target": 1}
{"code": "main(void)\n{\n    test(1, \"\", \"\");\n    test(1, \"a\", \"a\");\n    test(1, \"abc\", \"abc\");\n    test(0, \"a\", \"\");\n    test(0, \"ab\", \"\");\n    test(0, \"\", \"a\");\n    test(0, \"\", \"ab\");\n    test(0, \"abcd\", \"abc\");\n    test(0, \"abc\", \"abcd\");\n    return 0;\n}", "target": 0}
{"code": "static void __init clear_bss(void)\n{\n\tmemset(__bss_start, 0,\n\t       (unsigned long) __bss_stop - (unsigned long) __bss_start);\n}", "target": 1}
{"code": "void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {\n    assert(len <= UINT_MAX);\n    int index = 1;\n    lua_newtable(L);\n    luaL_checkstack(L, 1, \"in function mp_decode_to_lua_array\");\n    while(len--) {\n        lua_pushnumber(L,index++);\n        mp_decode_to_lua_type(L,c);\n        if (c->err) return;\n        lua_settable(L,-3);\n    }\n}", "target": 0}
{"code": "void bn_sqr_comba4(BN_ULONG *r, const BN_ULONG *a)\n\t{\n#ifdef BN_LLONG\n\tBN_ULLONG t,tt;\n#else\n\tBN_ULONG bl,bh;\n#endif\n\tBN_ULONG t1,t2;\n\tBN_ULONG c1,c2,c3;\n\tc1=0;\n\tc2=0;\n\tc3=0;\n\tsqr_add_c(a,0,c1,c2,c3);\n\tr[0]=c1;\n\tc1=0;\n\tsqr_add_c2(a,1,0,c2,c3,c1);\n\tr[1]=c2;\n\tc2=0;\n\tsqr_add_c(a,1,c3,c1,c2);\n\tsqr_add_c2(a,2,0,c3,c1,c2);\n\tr[2]=c3;\n\tc3=0;\n\tsqr_add_c2(a,3,0,c1,c2,c3);\n\tsqr_add_c2(a,2,1,c1,c2,c3);\n\tr[3]=c1;\n\tc1=0;\n\tsqr_add_c(a,2,c2,c3,c1);\n\tsqr_add_c2(a,3,1,c2,c3,c1);\n\tr[4]=c2;\n\tc2=0;\n\tsqr_add_c2(a,3,2,c3,c1,c2);\n\tr[5]=c3;\n\tc3=0;\n\tsqr_add_c(a,3,c1,c2,c3);\n\tr[6]=c1;\n\tr[7]=c2;\n\t}", "target": 1}
{"code": "int rpc_type_of_NPNVariable(int variable)\n{\n  int type;\n  switch (variable) {\n  case NPNVjavascriptEnabledBool:\n  case NPNVasdEnabledBool:\n  case NPNVisOfflineBool:\n  case NPNVSupportsXEmbedBool:\n  case NPNVSupportsWindowless:\n  case NPNVprivateModeBool:\n  case NPNVsupportsAdvancedKeyHandling:\n\ttype = RPC_TYPE_BOOLEAN;\n\tbreak;\n  case NPNVToolkit:\n  case NPNVnetscapeWindow:\n\ttype = RPC_TYPE_UINT32;\n\tbreak;\n  case NPNVWindowNPObject:\n  case NPNVPluginElementNPObject:\n\ttype = RPC_TYPE_NP_OBJECT;\n\tbreak;\n  default:\n\ttype = RPC_ERROR_GENERIC;\n\tbreak;\n  }\n  return type;\n}", "target": 0}
{"code": "int setup_tests(void)\n{\n    crv_len = EC_get_builtin_curves(NULL, 0);\n    if (!TEST_ptr(curves = OPENSSL_malloc(sizeof(*curves) * crv_len))\n        || !TEST_true(EC_get_builtin_curves(curves, crv_len)))\n        return 0;\n    ADD_TEST(field_tests_ecp_simple);\n    ADD_TEST(field_tests_ecp_mont);\n#ifndef OPENSSL_NO_EC2M\n    ADD_TEST(ec2m_field_sanity);\n    ADD_TEST(field_tests_ec2_simple);\n#endif\n    ADD_ALL_TESTS(field_tests_default, crv_len);\n#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128\n    ADD_TEST(underflow_test);\n#endif\n    ADD_TEST(set_private_key);\n    ADD_TEST(decoded_flag_test);\n    ADD_ALL_TESTS(ecpkparams_i2d2i_test, crv_len);\n    return 1;\n}", "target": 0}
{"code": "static void nodeConstruct(struct SaveNode* node, tr_variant const* v, bool sort_dicts)\n{\n    node->isVisited = false;\n    node->childIndex = 0;\n    if (sort_dicts && tr_variantIsDict(v))\n    {\n        size_t const n = v->val.l.count;\n        struct KeyIndex* tmp = tr_new(struct KeyIndex, n);\n        for (size_t i = 0; i < n; i++)\n        {\n            tmp[i].val = v->val.l.vals + i;\n            tmp[i].keystr = tr_quark_get_string(tmp[i].val->key, NULL);\n        }\n        qsort(tmp, n, sizeof(struct KeyIndex), compareKeyIndex);\n        tr_variantInitDict(&node->sorted, n);\n        for (size_t i = 0; i < n; ++i)\n        {\n            node->sorted.val.l.vals[i] = *tmp[i].val;\n        }\n        node->sorted.val.l.count = n;\n        tr_free(tmp);\n        node->v = &node->sorted;\n    }\n    else\n    {\n        node->v = v;\n    }\n}", "target": 1}
{"code": "PHP_MINFO_FUNCTION(mcrypt) \n{\n\tchar **modules;\n\tchar mcrypt_api_no[16];\n\tint i, count;\n\tsmart_str tmp1 = {0};\n\tsmart_str tmp2 = {0};\n\tmodules = mcrypt_list_algorithms(MCG(algorithms_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp1, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp1, modules[i]);\n\t\tsmart_str_appendc(&tmp1, ' ');\n\t}\n\tsmart_str_0(&tmp1);\n\tmcrypt_free_p(modules, count);\n\tmodules = mcrypt_list_modes(MCG(modes_dir), &count);\n\tif (count == 0) {\n\t\tsmart_str_appends(&tmp2, \"none\");\n\t}\n\tfor (i = 0; i < count; i++) {\n\t\tsmart_str_appends(&tmp2, modules[i]);\n\t\tsmart_str_appendc(&tmp2, ' ');\n\t}\n\tsmart_str_0 (&tmp2);\n\tmcrypt_free_p (modules, count);\n\tsnprintf (mcrypt_api_no, 16, \"%d\", MCRYPT_API_VERSION);\n\tphp_info_print_table_start();\n\tphp_info_print_table_header(2, \"mcrypt support\", \"enabled\");\n\tphp_info_print_table_header(2, \"mcrypt_filter support\", \"enabled\");\n\tphp_info_print_table_row(2, \"Version\", LIBMCRYPT_VERSION);\n\tphp_info_print_table_row(2, \"Api No\", mcrypt_api_no);\n\tphp_info_print_table_row(2, \"Supported ciphers\", tmp1.c);\n\tphp_info_print_table_row(2, \"Supported modes\", tmp2.c);\n\tsmart_str_free(&tmp1);\n\tsmart_str_free(&tmp2);\n\tphp_info_print_table_end();\n\tDISPLAY_INI_ENTRIES();", "target": 1}
{"code": "sixel_allocator_calloc(\n    sixel_allocator_t    *allocator,  \n    size_t               nelm,        \n    size_t               elsize)      \n{\n    size_t n;\n    assert(allocator);\n    assert(allocator->fn_calloc);\n    n = nelm * elsize;\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n    return allocator->fn_calloc(nelm, elsize);\n}", "target": 0}
{"code": "  absl::string_view failureReason() const override { return error_; }", "target": 0}
{"code": "void gdImageSetThickness (gdImagePtr im, int thickness)\n{\n\tim->thick = thickness;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &subtwolen );\n        bson_append_byte( b, type );\n        bson_append32( b, &len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "rrd_info_t *rrd_graph_v(\n    int argc,\n    char **argv)\n{\n    image_desc_t im;\n    rrd_info_t *grinfo;\n    rrd_graph_init(&im);\n    rrd_graph_options(argc, argv, &im);\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    if (optind >= argc) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        rrd_set_error(\"missing filename\");\n        return NULL;\n    }\n    if (strlen(argv[optind]) >= MAXPATH) {\n        rrd_set_error(\"filename (including path) too long\");\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    strncpy(im.graphfile, argv[optind], MAXPATH - 1);\n    im.graphfile[MAXPATH - 1] = '\\0';\n    if (strcmp(im.graphfile, \"-\") == 0) {\n        im.graphfile[0] = '\\0';\n    }\n    rrd_graph_script(argc, argv, &im, 1);\n    if (rrd_test_error()) {\n        rrd_info_free(im.grinfo);\n        im_free(&im);\n        return NULL;\n    }\n    if (graph_paint(&im) == -1) {\n      rrd_info_free(im.grinfo);\n      im_free(&im);\n      return NULL;\n    }\n    if (im.imginfo && *im.imginfo) {\n        rrd_infoval_t info;\n        char     *path;\n        char     *filename;\n        if (bad_format_imginfo(im.imginfo)) {\n            rrd_info_free(im.grinfo);\n            im_free(&im);\n            rrd_set_error(\"bad format for imginfo\");\n            return NULL;\n        }\n        path = strdup(im.graphfile);\n        filename = basename(path);\n        info.u_str =\n            sprintf_alloc(im.imginfo,\n                          filename,\n                          (long) (im.zoom *\n                                  im.ximg), (long) (im.zoom * im.yimg));\n        grinfo_push(&im, sprintf_alloc(\"image_info\"), RD_I_STR, info);\n        free(info.u_str);\n        free(path);\n    }\n    if (im.rendered_image) {\n        rrd_infoval_t img;\n        img.u_blo.size = im.rendered_image_size;\n        img.u_blo.ptr = im.rendered_image;\n        grinfo_push(&im, sprintf_alloc(\"image\"), RD_I_BLO, img);\n    }\n    grinfo = im.grinfo;\n    im_free(&im);\n    return grinfo;\n}", "target": 1}
{"code": "pci_emul_capwrite(struct pci_vdev *dev, int offset, int bytes, uint32_t val)\n{\n\tint capid;\n\tuint8_t capoff, nextoff;\n\tif ((offset & (bytes - 1)) != 0)\n\t\treturn;\n\tcapoff = CAP_START_OFFSET;\n\twhile (1) {\n\t\tnextoff = pci_get_cfgdata8(dev, capoff + 1);\n\t\tif (nextoff == 0)\n\t\t\tbreak;\n\t\tif (offset >= capoff && offset < nextoff)\n\t\t\tbreak;\n\t\tcapoff = nextoff;\n\t}\n\tassert(offset >= capoff);\n\tif (offset == capoff || offset == capoff + 1) {\n\t\tif (offset == capoff && bytes == 4) {\n\t\t\tbytes = 2;\n\t\t\toffset += 2;\n\t\t\tval >>= 16;\n\t\t} else\n\t\t\treturn;\n\t}\n\tcapid = pci_get_cfgdata8(dev, capoff);\n\tswitch (capid) {\n\tcase PCIY_MSI:\n\t\tmsicap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_MSIX:\n\t\tmsixcap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tcase PCIY_EXPRESS:\n\t\tpciecap_cfgwrite(dev, capoff, offset, bytes, val);\n\t\tbreak;\n\tdefault:\n\t\tCFGWRITE(dev, offset, val, bytes);\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "alt_merge_opt_map_info(OnigEncoding enc, OptMapInfo* to, OptMapInfo* add)\n{\n  int i, val;\n  if (to->value == 0) return ;\n  if (add->value == 0 || to->mmd.max < add->mmd.min) {\n    clear_opt_map_info(to);\n    return ;\n  }\n  alt_merge_mml(&to->mmd, &add->mmd);\n  val = 0;\n  for (i = 0; i < ONIG_CHAR_TABLE_SIZE; i++) {\n    if (add->map[i])\n      to->map[i] = 1;\n    if (to->map[i])\n      val += map_position_value(enc, i);\n  }\n  to->value = val;\n  alt_merge_opt_anc_info(&to->anc, &add->anc);\n}", "target": 0}
{"code": "TEST_F(MissingEKUTest, SignedData_missing_codesigning_EKU) {\n  auto certs = uthenticode::read_certs(pe);\n  auto signed_data = certs[0].as_signed_data();\n  ASSERT_FALSE(signed_data->verify_signature());\n}", "target": 0}
{"code": "static void ip_cmsg_recv_checksum(struct msghdr *msg, struct sk_buff *skb,\n\t\t\t\t  int tlen, int offset)\n{\n\t__wsum csum = skb->csum;\n\tif (skb->ip_summed != CHECKSUM_COMPLETE)\n\t\treturn;\n\tif (offset != 0)\n\t\tcsum = csum_sub(csum,\n\t\t\t\tcsum_partial(skb_transport_header(skb) + tlen,\n\t\t\t\t\t     offset, 0));\n\tput_cmsg(msg, SOL_IP, IP_CHECKSUM, sizeof(__wsum), &csum);\n}", "target": 1}
{"code": "inline int SizeOfDimension(const TfLiteTensor* t, int dim) {\n  return t->dims->data[dim];\n}", "target": 1}
{"code": "int secure_decrypt(void *data, unsigned int data_length, int is_signed)\n{\n\tat91_aes_key_size_t key_size;\n\tunsigned int cmac_key[8], cipher_key[8];\n\tunsigned int iv[AT91_AES_IV_SIZE_WORD];\n\tunsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];\n\tunsigned int fixed_length;\n\tconst unsigned int *cmac;\n\tint rc = -1;\n\tinit_keys(&key_size, cipher_key, cmac_key, iv);\n\tat91_aes_init();\n\tif (is_signed) {\n\t\tif (at91_aes_cmac(data_length, data, computed_cmac,\n\t\t\t\t  key_size, cmac_key))\n\t\t\tgoto exit;\n\t\tfixed_length = at91_aes_roundup(data_length);\n\t\tcmac = (const unsigned int *)((char *)data + fixed_length);\n\t\tif (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))\n\t\t\tgoto exit;\n\t}\n\tif (at91_aes_cbc(data_length, data, data, 0,\n\t\t\t key_size, cipher_key, iv))\n\t\tgoto exit;\n\trc = 0;\nexit:\n\tat91_aes_cleanup();\n\tmemset(cmac_key, 0, sizeof(cmac_key));\n\tmemset(cipher_key, 0, sizeof(cipher_key));\n\tmemset(iv, 0, sizeof(iv));\n\treturn rc;\n}", "target": 1}
{"code": "size_t HTTP2Codec::generateTrailers(folly::IOBufQueue& writeBuf,\n                                    StreamID stream,\n                                    const HTTPHeaders& trailers) {\n  VLOG(4) << \"generating TRAILERS for stream=\" << stream;\n  std::vector<compress::Header> allHeaders;\n  CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);\n  HTTPHeaderSize size;\n  auto out = encodeHeaders(trailers, allHeaders, &size);\n  IOBufQueue queue(IOBufQueue::cacheChainLength());\n  queue.append(std::move(out));\n  auto maxFrameSize = maxSendFrameSize();\n  if (queue.chainLength() > 0) {\n    folly::Optional<http2::PriorityUpdate> pri;\n    auto remainingFrameSize = maxFrameSize;\n    auto chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));\n    bool endHeaders = queue.chainLength() == 0;\n    generateHeaderCallbackWrapper(stream,\n                                  http2::FrameType::HEADERS,\n                                  http2::writeHeaders(writeBuf,\n                                                      std::move(chunk),\n                                                      stream,\n                                                      pri,\n                                                      http2::kNoPadding,\n                                                      true ,\n                                                      endHeaders));\n    if (!endHeaders) {\n      generateContinuation(writeBuf, queue, stream, maxFrameSize);\n    }\n  }\n  return size.compressed;\n}", "target": 0}
{"code": "static inline void SetPSDPixel(Image *image,const size_t channels,\n  const ssize_t type,const size_t packet_size,const Quantum pixel,Quantum *q,\n  ExceptionInfo *exception)\n{\n  if (image->storage_class == PseudoClass)\n    {\n      if (packet_size == 1)\n        SetPixelIndex(image,ScaleQuantumToChar(pixel),q);\n      else\n        SetPixelIndex(image,ScaleQuantumToShort(pixel),q);\n      SetPixelViaPixelInfo(image,image->colormap+(ssize_t)\n        ConstrainColormapIndex(image,GetPixelIndex(image,q),exception),q);\n      return;\n    }\n  switch (type)\n  {\n    case -1:\n    {\n      SetPixelAlpha(image, pixel,q);\n      break;\n    }\n    case -2:\n    case 0:\n    {\n      SetPixelRed(image,pixel,q);\n      if (channels == 1 || type == -2)\n        SetPixelGray(image,pixel,q);\n      break;\n    }\n    case 1:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelGreen(image,pixel,q);\n      break;\n    }\n    case 2:\n    {\n      if (image->storage_class == PseudoClass)\n        SetPixelAlpha(image,pixel,q);\n      else\n        SetPixelBlue(image,pixel,q);\n      break;\n    }\n    case 3:\n    {\n      if (image->colorspace == CMYKColorspace)\n        SetPixelBlack(image,pixel,q);\n      else\n        if (image->alpha_trait != UndefinedPixelTrait)\n          SetPixelAlpha(image,pixel,q);\n      break;\n    }\n    case 4:\n    {\n      if ((IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) &&\n          (channels > 3))\n        break;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,pixel,q);\n      break;\n    }\n  }\n}", "target": 0}
{"code": "decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \n\tif (0 == plen) {\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\tif (32 > plen)\n\t\treturn -1;\n        plen-=32; \n\tif (64 < plen)\n\t\treturn -1;\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\treturn 5 + (plen + 7) / 8;\ntrunc:\n\treturn -2;\n}", "target": 1}
{"code": "int __init nfc_llcp_sock_init(void)\n{\n\treturn nfc_proto_register(&llcp_nfc_proto);\n}", "target": 0}
{"code": "isis_print_id(const uint8_t *cp, int id_len)\n{\n    int i;\n    static char id[sizeof(\"xxxx.xxxx.xxxx.yy-zz\")];\n    char *pos = id;\n    for (i = 1; i <= SYSTEM_ID_LEN; i++) {\n        snprintf(pos, sizeof(id) - (pos - id), \"%02x\", *cp++);\n\tpos += strlen(pos);\n\tif (i == 2 || i == 4)\n\t    *pos++ = '.';\n\t}\n    if (id_len >= NODE_ID_LEN) {\n        snprintf(pos, sizeof(id) - (pos - id), \".%02x\", *cp++);\n\tpos += strlen(pos);\n    }\n    if (id_len == LSP_ID_LEN)\n        snprintf(pos, sizeof(id) - (pos - id), \"-%02x\", *cp);\n    return (id);\n}", "target": 1}
{"code": "static void dnsserver_reload_zones(struct dnsserver_state *dsstate)\n{\n\tstruct dnsserver_partition *p;\n\tstruct dnsserver_zone *zones, *z, *znext, *zmatch;\n\tstruct dnsserver_zone *old_list, *new_list;\n\told_list = dsstate->zones;\n\tnew_list = NULL;\n\tfor (p = dsstate->partitions; p; p = p->next) {\n\t\tzones = dnsserver_db_enumerate_zones(dsstate, dsstate->samdb, p);\n\t\tif (zones == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (z = zones; z; ) {\n\t\t\tznext = z->next;\n\t\t\tzmatch = dnsserver_find_zone(old_list, z->name);\n\t\t\tif (zmatch == NULL) {\n\t\t\t\tz->zoneinfo = dnsserver_init_zoneinfo(z, dsstate->serverinfo);\n\t\t\t\tif (z->zoneinfo == NULL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tDLIST_ADD_END(new_list, z);\n\t\t\t\tp->zones_count++;\n\t\t\t\tdsstate->zones_count++;\n\t\t\t} else {\n\t\t\t\ttalloc_free(z);\n\t\t\t\tDLIST_REMOVE(old_list, zmatch);\n\t\t\t\tDLIST_ADD_END(new_list, zmatch);\n\t\t\t}\n\t\t\tz = znext;\n\t\t}\n\t}\n\tif (new_list == NULL) {\n\t\treturn;\n\t}\n\tfor (z = old_list; z; ) {\n\t\tznext = z->next;\n\t\tz->partition->zones_count--;\n\t\tdsstate->zones_count--;\n\t\ttalloc_free(z);\n\t\tz = znext;\n\t}\n\tdsstate->zones = new_list;\n}", "target": 0}
{"code": "jiffies_to_compat_timeval(unsigned long jiffies, struct compat_timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong rem;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tvalue->tv_usec = rem / NSEC_PER_USEC;\n}", "target": 1}
{"code": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= user_match,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\tsprintf(description, \"%x\", target_id);\n\tauthkey_ref = search_process_keyrings(&ctx);\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\nerror:\n\treturn authkey;\n}", "target": 1}
{"code": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "size_t IOBuf::goodExtBufferSize(std::size_t minCapacity) {\n  if (minCapacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t minSize = static_cast<size_t>(minCapacity) + sizeof(SharedInfo);\n  minSize = (minSize + 7) & ~7;\n  return goodMallocSize(minSize);\n}", "target": 0}
{"code": "static void O_getOwnPropertyDescriptor(js_State *J)\n{\n\tjs_Object *obj;\n\tjs_Property *ref;\n\tif (!js_isobject(J, 1))\n\t\tjs_typeerror(J, \"not an object\");\n\tobj = js_toobject(J, 1);\n\tref = jsV_getproperty(J, obj, js_tostring(J, 2));\n\tif (!ref) {\n\t\tjs_pushundefined(J);\n\t} else {\n\t\tjs_newobject(J);\n\t\tif (!ref->getter && !ref->setter) {\n\t\t\tjs_pushvalue(J, ref->value);\n\t\t\tjs_setproperty(J, -2, \"value\");\n\t\t\tjs_pushboolean(J, !(ref->atts & JS_READONLY));\n\t\t\tjs_setproperty(J, -2, \"writable\");\n\t\t} else {\n\t\t\tif (ref->getter)\n\t\t\t\tjs_pushobject(J, ref->getter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_setproperty(J, -2, \"get\");\n\t\t\tif (ref->setter)\n\t\t\t\tjs_pushobject(J, ref->setter);\n\t\t\telse\n\t\t\t\tjs_pushundefined(J);\n\t\t\tjs_setproperty(J, -2, \"set\");\n\t\t}\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTENUM));\n\t\tjs_setproperty(J, -2, \"enumerable\");\n\t\tjs_pushboolean(J, !(ref->atts & JS_DONTCONF));\n\t\tjs_setproperty(J, -2, \"configurable\");\n\t}\n}", "target": 1}
{"code": "void SecurityManager::notify_participant_authorized(\n        const ParticipantProxyData& participant_data)\n{\n    participant_->pdp()->notifyAboveRemoteEndpoints(participant_data);\n    EPROSIMA_LOG_INFO(SECURITY, \"Participant \" << participant_data.m_guid << \" authenticated\");\n    if (participant_->getListener() != nullptr)\n    {\n        ParticipantAuthenticationInfo info;\n        info.status = ParticipantAuthenticationInfo::AUTHORIZED_PARTICIPANT;\n        info.guid = participant_data.m_guid;\n        participant_->getListener()->onParticipantAuthentication(\n            participant_->getUserRTPSParticipant(), std::move(info));\n    }\n}", "target": 1}
{"code": "static const char* jvp_literal_number_literal(jv n) {\n  assert(JVP_HAS_FLAGS(n, JVP_FLAGS_NUMBER_LITERAL));\n  decNumber *pdec = jvp_dec_number_ptr(n);\n  jvp_literal_number* plit = jvp_literal_number_ptr(n);\n  if (decNumberIsNaN(pdec)) {\n    return \"null\";\n  }\n  if (decNumberIsInfinite(pdec)) {\n    return NULL;\n  }\n  if (plit->literal_data == NULL) {\n    int len = jvp_dec_number_ptr(n)->digits + 14;\n    plit->literal_data = jv_mem_alloc(len);\n    decNumberToString(pdec, plit->literal_data);\n  }\n  return plit->literal_data;\n}", "target": 1}
{"code": "psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)\n{\tva_list\targptr ;\n\tint\t\tmaxlen ;\n\tchar\t*start ;\n\tmaxlen = strlen ((char*) psf->header) ;\n\tstart\t= ((char*) psf->header) + maxlen ;\n\tmaxlen\t= sizeof (psf->header) - maxlen ;\n\tva_start (argptr, format) ;\n\tvsnprintf (start, maxlen, format, argptr) ;\n\tva_end (argptr) ;\n\tstart [maxlen - 1] = 0 ;\n\tpsf->headindex = strlen ((char*) psf->header) ;\n\treturn ;\n} ", "target": 1}
{"code": "SSecurityTLS::~SSecurityTLS()\n{\n  shutdown();\n  if (fis)\n    delete fis;\n  if (fos)\n    delete fos;\n  delete[] keyfile;\n  delete[] certfile;\n  gnutls_global_deinit();\n}", "target": 0}
{"code": "static int l2cap_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_l2 *la = (struct sockaddr_l2 *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\taddr->sa_family = AF_BLUETOOTH;\n\t*len = sizeof(struct sockaddr_l2);\n\tif (peer) {\n\t\tla->l2_psm = chan->psm;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->dst);\n\t\tla->l2_cid = cpu_to_le16(chan->dcid);\n\t} else {\n\t\tla->l2_psm = chan->sport;\n\t\tbacpy(&la->l2_bdaddr, &bt_sk(sk)->src);\n\t\tla->l2_cid = cpu_to_le16(chan->scid);\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int ipmi_si_mem_setup(struct si_sm_io *io)\n{\n\tunsigned long addr = io->addr_data;\n\tint           mapsize, idx;\n\tif (!addr)\n\t\treturn -ENODEV;\n\tio->io_cleanup = mem_cleanup;\n\tswitch (io->regsize) {\n\tcase 1:\n\t\tio->inputb = intf_mem_inb;\n\t\tio->outputb = intf_mem_outb;\n\t\tbreak;\n\tcase 2:\n\t\tio->inputb = intf_mem_inw;\n\t\tio->outputb = intf_mem_outw;\n\t\tbreak;\n\tcase 4:\n\t\tio->inputb = intf_mem_inl;\n\t\tio->outputb = intf_mem_outl;\n\t\tbreak;\n#ifdef readq\n\tcase 8:\n\t\tio->inputb = mem_inq;\n\t\tio->outputb = mem_outq;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_warn(io->dev, \"Invalid register size: %d\\n\",\n\t\t\t io->regsize);\n\t\treturn -EINVAL;\n\t}\n\tfor (idx = 0; idx < io->io_size; idx++) {\n\t\tif (request_mem_region(addr + idx * io->regspacing,\n\t\t\t\t       io->regsize, DEVICE_NAME) == NULL) {\n\t\t\tmem_region_cleanup(io, idx);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\tmapsize = ((io->io_size * io->regspacing)\n\t\t   - (io->regspacing - io->regsize));\n\tio->addr = ioremap(addr, mapsize);\n\tif (io->addr == NULL) {\n\t\tmem_region_cleanup(io, io->io_size);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "u32 gf_isom_find_od_id_for_track(GF_ISOFile *file, u32 track)\n{\n\tu32 i, j, di, the_od_id;\n\tGF_TrackBox *od_tk;\n\tGF_TrackBox *tk = gf_isom_get_track_from_file(file, track);\n\tif (!tk) return 0;\n\ti=0;\n\twhile ( (od_tk = (GF_TrackBox*)gf_list_enum(file->moov->trackList, &i))) {\n\t\tif (!od_tk || !od_tk->Media || !od_tk->Media->handler  || !od_tk->Media->information ||\n\t\t\t!od_tk->Media->information->sampleTable || !od_tk->Media->information->sampleTable->SampleSize ) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (od_tk->Media->handler->handlerType != GF_ISOM_MEDIA_OD) continue;\n\t\tfor (j=0; j<od_tk->Media->information->sampleTable->SampleSize->sampleCount; j++) {\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(file, i, j+1, &di);\n\t\t\tthe_od_id = Media_FindOD_ID(od_tk->Media, samp, tk->Header->trackID);\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tif (the_od_id) return the_od_id;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    OpInputList ragged_nested_splits_in;\n    OP_REQUIRES_OK(context, context->input_list(\"rt_nested_splits\",\n                                                &ragged_nested_splits_in));\n    const int ragged_nested_splits_len = ragged_nested_splits_in.size();\n    RaggedTensorVariant batched_ragged_input;\n    batched_ragged_input.set_values(context->input(ragged_nested_splits_len));\n    batched_ragged_input.mutable_nested_splits()->reserve(\n        ragged_nested_splits_len);\n    for (int i = 0; i < ragged_nested_splits_len; i++) {\n      batched_ragged_input.append_splits(ragged_nested_splits_in[i]);\n    }\n    if (!batched_input_) {\n      Tensor* encoded_scalar;\n      OP_REQUIRES_OK(context, context->allocate_output(0, TensorShape({}),\n                                                       &encoded_scalar));\n      encoded_scalar->scalar<Variant>()() = std::move(batched_ragged_input);\n      return;\n    }\n    OP_REQUIRES(context, ragged_nested_splits_len > 0,\n                errors::InvalidArgument(\n                    \"rt_nested_splits must be a list of one or more, but \"\n                    \"received rt_nested_splits of length 0.\"));\n    std::vector<RaggedTensorVariant> unbatched_ragged_input;\n    auto batched_splits_top_vec =\n        batched_ragged_input.splits(0).vec<SPLIT_TYPE>();\n    int num_components = batched_splits_top_vec.size() - 1;\n    OP_REQUIRES(context, num_components >= 0,\n                errors::Internal(\"Invalid split argument.\"));\n    OP_REQUIRES_OK(context, UnbatchRaggedZerothDim<VALUE_TYPE, SPLIT_TYPE>(\n                                batched_ragged_input, &unbatched_ragged_input));\n    Tensor* encoded_vector;\n    int output_size = unbatched_ragged_input.size();\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({output_size}),\n                                            &encoded_vector));\n    auto encoded_vector_t = encoded_vector->vec<Variant>();\n    for (int i = 0; i < output_size; i++) {\n      encoded_vector_t(i) = unbatched_ragged_input[i];\n    }\n  }", "target": 0}
{"code": "static void udf_pc_to_char(struct super_block *sb, unsigned char *from,\n\t\t\t   int fromlen, unsigned char *to)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tunsigned char *p = to;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\tcase 2:\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmemcpy(p, \"../\", 3);\n\t\t\tp += 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tp += udf_get_filename(sb, pc->componentIdent, p,\n\t\t\t\t\t      pc->lengthComponentIdent);\n\t\t\t*p++ = '/';\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n}", "target": 1}
{"code": "void LineTo(double x1,double y1) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f l\",x1,y1);\n}", "target": 1}
{"code": "exim_tvcmp(struct timeval *t1, struct timeval *t2)\n{\nif (t1->tv_sec > t2->tv_sec) return +1;\nif (t1->tv_sec < t2->tv_sec) return -1;\nif (t1->tv_usec > t2->tv_usec) return +1;\nif (t1->tv_usec < t2->tv_usec) return -1;\nreturn 0;\n}", "target": 0}
{"code": "TEST(TensorSliceTest, BuildTensorSlice) {\n  TensorSliceProto proto;\n  TensorSlice({{0, -1}, {0, 10}, {14, 1}}).AsProto(&proto);\n  TensorSlice s;\n  {\n    TF_ASSERT_OK(TensorSlice::BuildTensorSlice(proto, &s));\n    EXPECT_EQ(\"-:0,10:14,1\", s.DebugString());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(0)->set_start(-1);\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->set_length(-1);\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->clear_length();\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n  {\n    TensorSliceProto invalid_proto = proto;\n    invalid_proto.mutable_extent(2)->set_length(\n        std::numeric_limits<int64_t>::max());\n    EXPECT_FALSE(TensorSlice::BuildTensorSlice(invalid_proto, &s).ok());\n  }\n}", "target": 0}
{"code": "void test_xattrs(const char *path)\n{\n\t char value[200];\n\t if (getxattr(path, \"security.selinux\", value, 200) >= 0) {\n\t\tfprintf(stderr, \"leak at getxattr of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at getxattr of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static void mpeg4_encode_gop_header(MpegEncContext *s)\n{\n    int hours, minutes, seconds;\n    int64_t time;\n    put_bits(&s->pb, 16, 0);\n    put_bits(&s->pb, 16, GOP_STARTCODE);\n    time = s->current_picture_ptr->f->pts;\n    if (s->reordered_input_picture[1])\n        time = FFMIN(time, s->reordered_input_picture[1]->f->pts);\n    time = time * s->avctx->time_base.num;\n    s->last_time_base = FFUDIV(time, s->avctx->time_base.den);\n    seconds = FFUDIV(time, s->avctx->time_base.den);\n    minutes = FFUDIV(seconds, 60); seconds = FFUMOD(seconds, 60);\n    hours   = FFUDIV(minutes, 60); minutes = FFUMOD(minutes, 60);\n    hours   = FFUMOD(hours  , 24);\n    put_bits(&s->pb, 5, hours);\n    put_bits(&s->pb, 6, minutes);\n    put_bits(&s->pb, 1, 1);\n    put_bits(&s->pb, 6, seconds);\n    put_bits(&s->pb, 1, !!(s->avctx->flags & AV_CODEC_FLAG_CLOSED_GOP));\n    put_bits(&s->pb, 1, 0);  \n    ff_mpeg4_stuffing(&s->pb);\n}", "target": 1}
{"code": "CbrDetectorRemote::Result CbrDetectorRemote::Decrypt(cricket::MediaType media_type,\n\t\t\t\t\t\tconst std::vector<uint32_t>& csrcs,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> additional_data,\n\t\t\t\t\t\trtc::ArrayView<const uint8_t> encrypted_frame,\n\t\t\t\t\t\trtc::ArrayView<uint8_t> frame)\n{\n\tconst uint8_t *src = encrypted_frame.data();\n\tuint8_t *dst = frame.data();\n\tuint32_t data_len = encrypted_frame.size();\n\tif (media_type == cricket::MEDIA_TYPE_AUDIO) {\n\t\tif (data_len == frame_size && frame_size >= 40) {\n\t\t\tframe_count++;\n\t\t\tif (frame_count > 200 && !detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected\\n\");\n\t\t\t\tdetected = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tframe_count = 0;\n\t\t\tframe_size = data_len;\n\t\t\tif (detected) {\n\t\t\t\tinfo(\"CBR detector: remote cbr detected disabled\\n\");\n\t\t\t\tdetected = false;\n\t\t\t}\n\t\t}\n\t}\n\tmemcpy(dst, src, data_len);\nout:\n\treturn CbrDetectorRemote::Result(CbrDetectorRemote::Status::kOk, data_len);\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& tensor_in = context->input(0);\n    const Tensor& tensor_out = context->input(1);\n    const Tensor& out_grad_backprop = context->input(2);\n    OP_REQUIRES(context, tensor_in.dims() == 5,\n                errors::InvalidArgument(\"tensor_in must be 5-dimensional\"));\n    OP_REQUIRES(context, tensor_out.dims() == 5,\n                errors::InvalidArgument(\"tensor_out must be 5-dimensional\"));\n    OP_REQUIRES(\n        context, out_grad_backprop.dims() == 5,\n        errors::InvalidArgument(\"out_grad_backprop must be 5-dimensional\"));\n    Pool3dParameters params{context,  ksize_,       stride_,\n                            padding_, data_format_, tensor_in.shape()};\n    if (!context->status().ok()) return;  \n    OP_REQUIRES(context, tensor_out.shape() == params.forward_output_shape(),\n                errors::InvalidArgument(\"Expected orig_output shape to be \",\n                                        params.forward_output_shape(),\n                                        \", but got \", tensor_out.shape()));\n    OP_REQUIRES(\n        context, out_grad_backprop.shape() == tensor_in.shape(),\n        errors::InvalidArgument(\"Expected grad shape to be \", tensor_in.shape(),\n                                \", but got \", out_grad_backprop.shape()));\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->forward_input_or_allocate_output(\n                                {2}, 0, tensor_out.shape(), &output));\n    OP_REQUIRES(context, tensor_in.NumElements() > 0,\n                errors::InvalidArgument(\"received empty tensor tensor_in: \",\n                                        tensor_in.DebugString()));\n    OP_REQUIRES(context, tensor_out.NumElements() > 0,\n                errors::InvalidArgument(\"received empty tensor tensor_out: \",\n                                        tensor_out.DebugString()));\n    OP_REQUIRES(\n        context, out_grad_backprop.NumElements() > 0,\n        errors::InvalidArgument(\"received empty tensor out_grad_backprop: \",\n                                out_grad_backprop.DebugString()));\n    OP_REQUIRES(context,\n                tensor_in.NumElements() == out_grad_backprop.NumElements(),\n                errors::InvalidArgument(\"tensor_in and out_grad_backprop must \"\n                                        \"have same number of elements, got <\",\n                                        tensor_in.DebugString(), \"> and <\",\n                                        out_grad_backprop.DebugString(), \">\"));\n    OP_REQUIRES(\n        context, tensor_out.NumElements() == output->NumElements(),\n        errors::InvalidArgument(\n            \"tensor_out and output must have same number of elements, got <\",\n            tensor_out.DebugString(), \"> and <\", output->DebugString(), \">\"));\n    LaunchMaxPooling3dGradGradOp<Device, T>::launch(\n        context, params, tensor_in, tensor_out, out_grad_backprop, output);\n  }", "target": 0}
{"code": "BigInt EC_Group::square_mod_order(const BigInt& x) const\n   {\n   return data().square_mod_order(x);\n   }", "target": 0}
{"code": "int oidc_handle_redirect_uri_request(request_rec *r, oidc_cfg *c,\n\t\toidc_session_t *session) {\n\tif (oidc_proto_is_redirect_authorization_response(r, c)) {\n\t\treturn oidc_handle_redirect_authorization_response(r, c, session);\n\t} else if (oidc_proto_is_post_authorization_response(r, c)) {\n\t\treturn oidc_handle_post_authorization_response(r, c, session);\n\t} else if (oidc_is_discovery_response(r, c)) {\n\t\treturn oidc_handle_discovery_response(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"logout\")) {\n\t\treturn oidc_handle_logout(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"jwks\")) {\n\t\treturn oidc_handle_jwks(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"session\")) {\n\t\treturn oidc_handle_session_management(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"refresh\")) {\n\t\treturn oidc_handle_refresh_token_request(r, c, session);\n\t} else if (oidc_util_request_has_parameter(r, \"request_uri\")) {\n\t\treturn oidc_handle_request_uri(r, c);\n\t} else if (oidc_util_request_has_parameter(r, \"remove_at_cache\")) {\n\t\treturn oidc_handle_remove_at_cache(r, c);\n\t} else if ((r->args == NULL) || (apr_strnatcmp(r->args, \"\") == 0)) {\n\t\treturn oidc_proto_javascript_implicit(r, c);\n\t}\n\tif (oidc_util_request_has_parameter(r, \"error\")) {\n\t\toidc_handle_redirect_authorization_response(r, c, session);\n\t}\n\treturn oidc_util_html_send_error(r, c->error_template, \"Invalid Request\",\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"The OpenID Connect callback URL received an invalid request: %s\",\n\t\t\t\t\tr->args), HTTP_INTERNAL_SERVER_ERROR);\n}", "target": 1}
{"code": "static int ct_play(struct media_player *mp, void *user_data)\n{\n\tstruct avrcp_player *player = user_data;\n\treturn ct_press(player, AVC_PLAY);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    int stride_rows = 0, stride_cols = 0;\n    int rate_rows = 0, rate_cols = 0;\n    int64 pad_top = 0, pad_left = 0;\n    int64 out_rows = 0, out_cols = 0;\n    ParseSizes(context, strides_, rates_, padding_, &stride_rows, &stride_cols,\n               &rate_rows, &rate_cols, &pad_top, &pad_left, &out_rows,\n               &out_cols);\n    if (!context->status().ok()) return;\n    const int batch = input.dim_size(0);\n    const int depth = input.dim_size(3);\n    const std::vector<int64> out_sizes = {batch, out_rows, out_cols, depth};\n    TensorShape out_shape(out_sizes);\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    if (out_shape.num_elements() == 0) {\n      return;\n    }\n    functor::Dilation<Device, T>()(\n        context->eigen_device<Device>(), input.tensor<T, 4>(),\n        filter.tensor<T, 3>(), stride_rows, stride_cols, rate_rows, rate_cols,\n        pad_top, pad_left, output->tensor<T, 4>());\n  }", "target": 0}
{"code": "static void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) \n{\n\tstruct zip *intern;\n\tzval *self = getThis();\n\tstruct zip_stat sb;\n\tstruct zip_file *zf;\n\tzend_long index = -1;\n\tzend_long flags = 0;\n\tzend_long len = 0;\n\tzend_string *filename;\n\tzend_string *buffer;\n\tint n = 0;\n\tif (!self) {\n\t\tRETURN_FALSE;\n\t}\n\tZIP_FROM_OBJECT(intern, self);\n\tif (type == 1) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"P|ll\", &filename, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS(), \"l|ll\", &index, &len, &flags) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tPHP_ZIP_STAT_INDEX(intern, index, 0, sb);\n\t}\n\tif (sb.size < 1) {\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tif (len < 1) {\n\t\tlen = sb.size;\n\t}\n\tif (index >= 0) {\n\t\tzf = zip_fopen_index(intern, index, flags);\n\t} else {\n\t\tzf = zip_fopen(intern, ZSTR_VAL(filename), flags);\n\t}\n\tif (zf == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\tbuffer = zend_string_alloc(len, 0);\n\tn = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));\n\tif (n < 1) {\n\t\tzend_string_free(buffer);\n\t\tRETURN_EMPTY_STRING();\n\t}\n\tzip_fclose(zf);\n\tZSTR_VAL(buffer)[n] = '\\0';\n\tZSTR_LEN(buffer) = n;\n\tRETURN_NEW_STR(buffer);\n}", "target": 1}
{"code": "void ZlibInStream::flushUnderlying()\n{\n  ptr = end = start;\n  while (bytesIn > 0) {\n    decompress(true);\n    end = start; \n  }\n  setUnderlying(NULL, 0);\n}", "target": 0}
{"code": "static int jpc_qcd_dumpparms(jpc_ms_t *ms, FILE *out)\n{\n\tjpc_qcd_t *qcd = &ms->parms.qcd;\n\tint i;\n\tfprintf(out, \"qntsty = %d; numguard = %d; numstepsizes = %d\\n\",\n\t  (int) qcd->compparms.qntsty, qcd->compparms.numguard, qcd->compparms.numstepsizes);\n\tfor (i = 0; i < qcd->compparms.numstepsizes; ++i) {\n\t\tfprintf(out, \"expn[%d] = 0x%04x; mant[%d] = 0x%04x;\\n\",\n\t\t  i, (unsigned) JPC_QCX_GETEXPN(qcd->compparms.stepsizes[i]),\n\t\t  i, (unsigned) JPC_QCX_GETMANT(qcd->compparms.stepsizes[i]));\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)\n{\n\tstruct fsck_gitmodules_data *data = vdata;\n\tconst char *subsection, *key;\n\tint subsection_len;\n\tchar *name;\n\tif (parse_config_key(var, \"submodule\", &subsection, &subsection_len, &key) < 0 ||\n\t    !subsection)\n\t\treturn 0;\n\tname = xmemdupz(subsection, subsection_len);\n\tif (check_submodule_name(name) < 0)\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_NAME,\n\t\t\t\t    \"disallowed submodule name: %s\",\n\t\t\t\t    name);\n\tif (!strcmp(key, \"url\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_URL,\n\t\t\t\t    \"disallowed submodule url: %s\",\n\t\t\t\t    value);\n\tif (!strcmp(key, \"path\") && value &&\n\t    looks_like_command_line_option(value))\n\t\tdata->ret |= report(data->options, data->obj,\n\t\t\t\t    FSCK_MSG_GITMODULES_PATH,\n\t\t\t\t    \"disallowed submodule path: %s\",\n\t\t\t\t    value);\n\tfree(name);\n\treturn 0;\n}", "target": 0}
{"code": "extract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n    gboolean result = FALSE;\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n\t\t\tgoto out;\n        }\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}", "target": 1}
{"code": "pci_lintr_release(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct slotinfo *si;\n\tint pin;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tsi = &bi->slotinfo[dev->slot];\n\tfor (pin = 1; pin < 4; pin++) {\n\t\tsi->si_intpins[pin].ii_count = 0;\n\t\tsi->si_intpins[pin].ii_pirq_pin = 0;\n\t\tsi->si_intpins[pin].ii_ioapic_irq = 0;\n\t}\n}", "target": 1}
{"code": "directory_fetches_dir_info_later(const or_options_t *options)\n{\n  return options->UseBridges != 0;\n}", "target": 0}
{"code": "void IGDstartelt(void * d, const char * name, int l)\n{\n\tstruct IGDdatas * datas = (struct IGDdatas *)d;\n\tmemcpy( datas->cureltname, name, l);\n\tdatas->cureltname[l] = '\\0';\n\tdatas->level++;\n\tif( (l==7) && !memcmp(name, \"service\", l) ) {\n\t\tdatas->tmp.controlurl[0] = '\\0';\n\t\tdatas->tmp.eventsuburl[0] = '\\0';\n\t\tdatas->tmp.scpdurl[0] = '\\0';\n\t\tdatas->tmp.servicetype[0] = '\\0';\n\t}\n}", "target": 1}
{"code": "rb_event_data(struct ring_buffer_event *event)\n{\n\tif (event->type_len == RINGBUF_TYPE_TIME_EXTEND)\n\t\tevent = skip_time_extend(event);\n\tBUG_ON(event->type_len > RINGBUF_TYPE_DATA_TYPE_LEN_MAX);\n\tif (event->type_len)\n\t\treturn (void *)&event->array[0];\n\treturn (void *)&event->array[1];\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, Cookie> &getCookies() const\n    {\n        return cookies();\n    }", "target": 1}
{"code": "\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\tset_current_state(TASK_TRACED);\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\ttask_clear_jobctl_trapping(current);\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\trecalc_sigpending_tsk(current);\n}", "target": 0}
{"code": "u64 local_clock(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn sched_clock_cpu(raw_smp_processor_id());\n\treturn sched_clock();\n}", "target": 0}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\t(void)mode;\t\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}", "target": 1}
{"code": "static int create_mr(PVRDMADev *dev, union pvrdma_cmd_req *req,\n                     union pvrdma_cmd_resp *rsp)\n{\n    struct pvrdma_cmd_create_mr *cmd = &req->create_mr;\n    struct pvrdma_cmd_create_mr_resp *resp = &rsp->create_mr_resp;\n    PCIDevice *pci_dev = PCI_DEVICE(dev);\n    void *host_virt = NULL;\n    int rc = 0;\n    memset(resp, 0, sizeof(*resp));\n    if (!(cmd->flags & PVRDMA_MR_FLAG_DMA)) {\n        host_virt = pvrdma_map_to_pdir(pci_dev, cmd->pdir_dma, cmd->nchunks,\n                                       cmd->length);\n        if (!host_virt) {\n            rdma_error_report(\"Failed to map to pdir\");\n            return -EINVAL;\n        }\n    }\n    rc = rdma_rm_alloc_mr(&dev->rdma_dev_res, cmd->pd_handle, cmd->start,\n                          cmd->length, host_virt, cmd->access_flags,\n                          &resp->mr_handle, &resp->lkey, &resp->rkey);\n    if (rc && host_virt) {\n        munmap(host_virt, cmd->length);\n    }\n    return rc;\n}", "target": 0}
{"code": "int dev_forward_skb(struct net_device *dev, struct sk_buff *skb)\n{\n\tskb_orphan(skb);\n\tif (!(dev->flags & IFF_UP))\n\t\treturn NET_RX_DROP;\n\tif (skb->len > (dev->mtu + dev->hard_header_len))\n\t\treturn NET_RX_DROP;\n\tskb_set_dev(skb, dev);\n\tskb->tstamp.tv64 = 0;\n\tskb->pkt_type = PACKET_HOST;\n\tskb->protocol = eth_type_trans(skb, dev);\n\treturn netif_rx(skb);\n}", "target": 1}
{"code": "static inline int rb_null_event(struct ring_buffer_event *event)\n{\n\treturn event->type_len == RINGBUF_TYPE_PADDING && !event->time_delta;\n}", "target": 0}
{"code": "static bool tipc_node_cleanup(struct tipc_node *peer)\n{\n\tstruct tipc_node *temp_node;\n\tstruct tipc_net *tn = tipc_net(peer->net);\n\tbool deleted = false;\n\tif (!spin_trylock_bh(&tn->node_list_lock))\n\t\treturn false;\n\ttipc_node_write_lock(peer);\n\tif (!node_is_up(peer) && time_after(jiffies, peer->delete_at)) {\n\t\ttipc_node_clear_links(peer);\n\t\ttipc_node_delete_from_list(peer);\n\t\tdeleted = true;\n\t}\n\ttipc_node_write_unlock(peer);\n\tif (!deleted) {\n\t\tspin_unlock_bh(&tn->node_list_lock);\n\t\treturn deleted;\n\t}\n\ttn->capabilities = TIPC_NODE_CAPABILITIES;\n\tlist_for_each_entry_rcu(temp_node, &tn->node_list, list) {\n\t\ttn->capabilities &= temp_node->capabilities;\n\t}\n\ttipc_bcast_toggle_rcast(peer->net,\n\t\t\t\t(tn->capabilities & TIPC_BCAST_RCAST));\n\tspin_unlock_bh(&tn->node_list_lock);\n\treturn deleted;\n}", "target": 0}
{"code": "static inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}", "target": 0}
{"code": "gss_verify_mic (minor_status,\n\t\tcontext_handle,\n\t\tmessage_buffer,\n\t\ttoken_buffer,\n\t\tqop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\ttoken_buffer;\ngss_qop_t *\t\tqop_state;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    if ((message_buffer == GSS_C_NO_BUFFER) ||\n\tGSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_verify_mic) {\n\t    status = mech->gss_verify_mic(\n\t\t\t\t\t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  message_buffer,\n\t\t\t\t\t  token_buffer,\n\t\t\t\t\t  qop_state);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "gss_wrap_aead (minor_status,\n               context_handle,\n               conf_req_flag,\n               qop_req,\n\t       input_assoc_buffer,\n\t       input_payload_buffer,\n               conf_state,\n               output_message_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\tinput_payload_buffer;\nint *\t\t\tconf_state;\ngss_buffer_t\t\toutput_message_buffer;\n{\n    OM_uint32\t\tstatus;\n    gss_mechanism\tmech;\n    gss_union_ctx_id_t\tctx;\n    status = val_wrap_aead_args(minor_status, context_handle,\n\t\t\t\tconf_req_flag, qop_req,\n\t\t\t\tinput_assoc_buffer, input_payload_buffer,\n\t\t\t\tconf_state, output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n    return gssint_wrap_aead(mech, minor_status, ctx,\n\t\t\t    conf_req_flag, qop_req,\n\t\t\t    input_assoc_buffer, input_payload_buffer,\n\t\t\t    conf_state, output_message_buffer);\n}", "target": 0}
{"code": "hybiWsFrameComplete(ws_ctx_t *wsctx)\n{\n  return wsctx != NULL && hybiRemaining(wsctx) == 0;\n}", "target": 0}
{"code": "int rds_get_mr_for_dest(struct rds_sock *rs, char __user *optval, int optlen)\n{\n\tstruct rds_get_mr_for_dest_args args;\n\tstruct rds_get_mr_args new_args;\n\tif (optlen != sizeof(struct rds_get_mr_for_dest_args))\n\t\treturn -EINVAL;\n\tif (copy_from_user(&args, (struct rds_get_mr_for_dest_args __user *)optval,\n\t\t\t   sizeof(struct rds_get_mr_for_dest_args)))\n\t\treturn -EFAULT;\n\tnew_args.vec = args.vec;\n\tnew_args.cookie_addr = args.cookie_addr;\n\tnew_args.flags = args.flags;\n\treturn __rds_rdma_map(rs, &new_args, NULL, NULL);\n}", "target": 0}
{"code": "imap_client_notify_starttls(struct client *client,\n\t\t\t    bool success, const char *text)\n{\n\tif (success)\n\t\tclient_send_reply(client, IMAP_CMD_REPLY_OK, text);\n\telse\n\t\tclient_send_reply(client, IMAP_CMD_REPLY_BAD, text);\n}", "target": 0}
{"code": "externalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; \n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif \n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}", "target": 1}
{"code": "static int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}", "target": 1}
{"code": "int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)\n{\n\tstruct hexline *hx;\n\tu8 reset;\n\tint ret,pos=0;\n\thx = kmalloc(sizeof(*hx), GFP_KERNEL);\n\tif (!hx)\n\t\treturn -ENOMEM;\n\treset = 1;\n\tif ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1)) != 1)\n\t\terr(\"could not stop the USB controller CPU.\");\n\twhile ((ret = dvb_usb_get_hexline(fw, hx, &pos)) > 0) {\n\t\tdeb_fw(\"writing to address 0x%04x (buffer: 0x%02x %02x)\\n\", hx->addr, hx->len, hx->chk);\n\t\tret = usb_cypress_writemem(udev, hx->addr, hx->data, hx->len);\n\t\tif (ret != hx->len) {\n\t\t\terr(\"error while transferring firmware (transferred size: %d, block size: %d)\",\n\t\t\t\tret, hx->len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret < 0) {\n\t\terr(\"firmware download failed at %d with %d\",pos,ret);\n\t\tkfree(hx);\n\t\treturn ret;\n\t}\n\tif (ret == 0) {\n\t\treset = 0;\n\t\tif (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&reset,1) != 1) {\n\t\t\terr(\"could not restart the USB controller CPU.\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else\n\t\tret = -EIO;\n\tkfree(hx);\n\treturn ret;\n}", "target": 1}
{"code": "static uint8_t check_length(uint16_t length, uint16_t offset)\n{\n\tif (length > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\tif (offset > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_OFFSET;\n\tif (length + offset > BT_ATT_MAX_VALUE_LEN)\n\t\treturn BT_ATT_ERROR_INVALID_ATTRIBUTE_VALUE_LEN;\n\treturn 0;\n}", "target": 0}
{"code": "int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n\tint\t\t\ti, nbits;\n\tvalue = 0;\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n\t}\n\tif (msg->oob) {\n\t\tif(bits==8)\n\t\t{\n\t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t}\n\t\telse if(bits==16)\n\t\t{\n\t\t\tshort temp;\n\t\t\tCopyLittleShort(&temp, &msg->data[msg->readcount]);\n\t\t\tvalue = temp;\n\t\t\tmsg->readcount += 2;\n\t\t\tmsg->bit += 16;\n\t\t}\n\t\telse if(bits==32)\n\t\t{\n\t\t\tCopyLittleLong(&value, &msg->data[msg->readcount]);\n\t\t\tmsg->readcount += 4;\n\t\t\tmsg->bit += 32;\n\t\t}\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n\t\tnbits = 0;\n\t\tif (bits&7) {\n\t\t\tnbits = bits&7;\n\t\t\tfor(i=0;i<nbits;i++) {\n\t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif (bits) {\n\t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);\n\t\t\t\tvalue |= (get<<(i+nbits));\n\t\t\t}\n\t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}\n\tif ( sgn && bits > 0 && bits < 32 ) {\n\t\tif ( value & ( 1 << ( bits - 1 ) ) ) {\n\t\t\tvalue |= -1 ^ ( ( 1 << bits ) - 1 );\n\t\t}\n\t}\n\treturn value;\n}", "target": 1}
{"code": "get_manuf_name(const guint8 *addr)\n{\n    hashmanuf_t *manuf_value;\n    manuf_value = manuf_name_lookup(addr);\n    if (gbl_resolv_flags.mac_name && manuf_value->status != HASHETHER_STATUS_UNRESOLVED)\n        return manuf_value->resolved_name;\n    return manuf_value->hexaddr;\n} ", "target": 1}
{"code": "int cipso_v4_req_setattr(struct request_sock *req,\n\t\t\t const struct cipso_v4_doi *doi_def,\n\t\t\t const struct netlbl_lsm_secattr *secattr)\n{\n\tint ret_val = -EPERM;\n\tunsigned char *buf = NULL;\n\tu32 buf_len;\n\tu32 opt_len;\n\tstruct ip_options *opt = NULL;\n\tstruct inet_request_sock *req_inet;\n\tbuf_len = CIPSO_V4_OPT_LEN_MAX;\n\tbuf = kmalloc(buf_len, GFP_ATOMIC);\n\tif (buf == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tret_val = cipso_v4_genopt(buf, buf_len, doi_def, secattr);\n\tif (ret_val < 0)\n\t\tgoto req_setattr_failure;\n\tbuf_len = ret_val;\n\topt_len = (buf_len + 3) & ~3;\n\topt = kzalloc(sizeof(*opt) + opt_len, GFP_ATOMIC);\n\tif (opt == NULL) {\n\t\tret_val = -ENOMEM;\n\t\tgoto req_setattr_failure;\n\t}\n\tmemcpy(opt->__data, buf, buf_len);\n\topt->optlen = opt_len;\n\topt->cipso = sizeof(struct iphdr);\n\tkfree(buf);\n\tbuf = NULL;\n\treq_inet = inet_rsk(req);\n\topt = xchg(&req_inet->opt, opt);\n\tkfree(opt);\n\treturn 0;\nreq_setattr_failure:\n\tkfree(buf);\n\tkfree(opt);\n\treturn ret_val;\n}", "target": 1}
{"code": "long video_ioctl2(struct file *file,\n\t       unsigned int cmd, unsigned long arg)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\tif (has_array_args) {\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\terr = __video_do_ioctl(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\nout_array_args:\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\nout:\n\tkfree(mbuf);\n\treturn err;\n}", "target": 1}
{"code": "static void test_on_link_flow_on(void* context)\n{\n    (void)context;\n}", "target": 0}
{"code": "void RenderWidgetHostImpl::DidStopFlinging() {\n  if (view_)\n    view_->DidStopFlinging();\n}", "target": 0}
{"code": "void PluginInfoMessageFilter::OnGetPluginInfo(\n    int render_view_id,\n    const GURL& url,\n    const GURL& top_origin_url,\n    const std::string& mime_type,\n    IPC::Message* reply_msg) {\n  GetPluginInfo_Params params = {\n    render_view_id,\n    url,\n    top_origin_url,\n    mime_type\n  };\n  PluginService::GetInstance()->GetPlugins(\n      base::Bind(&PluginInfoMessageFilter::PluginsLoaded,\n                 weak_ptr_factory_.GetWeakPtr(),\n                 params, reply_msg));\n}", "target": 0}
{"code": "void* IOBuf::operator new(size_t size) {\n  if (size > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t fullSize = offsetof(HeapStorage, buf) + size;\n  auto storage = static_cast<HeapStorage*>(checkedMalloc(fullSize));\n  new (&storage->prefix) HeapPrefix(kIOBufInUse, fullSize);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, fullSize);\n  }\n  return &(storage->buf);\n}", "target": 0}
{"code": "static INLINE SIZE_T ntlm_av_pair_get_len(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvLen;\n\tData_Read_UINT16(&pAvPair->AvLen, AvLen);\n\treturn AvLen;\n}", "target": 1}
{"code": "int validated_offset(uint32_t addr, uint32_t start, uint32_t end){\n    return addr <= end && addr >= start? 0:-1;\n}", "target": 0}
{"code": "do_pam_chauthtok(void)\n{\n\tstruct pam_conv pam_conv = { pam_chauthtok_conv, NULL };\n\tif (use_privsep)\n\t\tfatal(\"PAM: chauthtok not supprted with privsep\");\n\tsshpam_err = pam_set_item(sshpam_handle, PAM_CONV,\n\t    (const void *)&pam_conv);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: failed to set PAM_CONV: %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n\tdebug(\"PAM: changing password\");\n\tsshpam_err = pam_chauthtok(sshpam_handle, PAM_CHANGE_EXPIRED_AUTHTOK);\n\tif (sshpam_err != PAM_SUCCESS)\n\t\tfatal(\"PAM: pam_chauthtok(): %s\",\n\t\t    pam_strerror(sshpam_handle, sshpam_err));\n}", "target": 0}
{"code": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}", "target": 1}
{"code": "static intset *intsetResize(intset *is, uint32_t len) {\n    uint32_t size = len*intrev32ifbe(is->encoding);\n    is = zrealloc(is,sizeof(intset)+size);\n    return is;\n}", "target": 1}
{"code": "xmlCopyEnumeration(xmlEnumerationPtr cur) {\n    xmlEnumerationPtr ret;\n    if (cur == NULL) return(NULL);\n    ret = xmlCreateEnumeration((xmlChar *) cur->name);\n    if (ret == NULL) return(NULL);\n    if (cur->next != NULL) ret->next = xmlCopyEnumeration(cur->next);\n    else ret->next = NULL;\n    return(ret);\n}", "target": 0}
{"code": "static bool kvm_vcpu_check_code_breakpoint(struct kvm_vcpu *vcpu, int *r)\n{\n\tif (unlikely(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) &&\n\t    (vcpu->arch.guest_debug_dr7 & DR7_BP_EN_MASK)) {\n\t\tstruct kvm_run *kvm_run = vcpu->run;\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.guest_debug_dr7,\n\t\t\t\t\t   vcpu->arch.eff_db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_ACTIVE_LOW;\n\t\t\tkvm_run->debug.arch.pc = eip;\n\t\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\t*r = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (unlikely(vcpu->arch.dr7 & DR7_BP_EN_MASK) &&\n\t    !(kvm_get_rflags(vcpu) & X86_EFLAGS_RF)) {\n\t\tunsigned long eip = kvm_get_linear_rip(vcpu);\n\t\tu32 dr6 = kvm_vcpu_check_hw_bp(eip, 0,\n\t\t\t\t\t   vcpu->arch.dr7,\n\t\t\t\t\t   vcpu->arch.db);\n\t\tif (dr6 != 0) {\n\t\t\tkvm_queue_exception_p(vcpu, DB_VECTOR, dr6);\n\t\t\t*r = 1;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "static __u8 *cp_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tunsigned long quirks = (unsigned long)hid_get_drvdata(hdev);\n\tunsigned int i;\n\tif (!(quirks & CP_RDESC_SWAPPED_MIN_MAX))\n\t\treturn rdesc;\n\tif (*rsize < 4)\n\t\treturn rdesc;\n\tfor (i = 0; i < *rsize - 4; i++)\n\t\tif (rdesc[i] == 0x29 && rdesc[i + 2] == 0x19) {\n\t\t\trdesc[i] = 0x19;\n\t\t\trdesc[i + 2] = 0x29;\n\t\t\tswap(rdesc[i + 3], rdesc[i + 1]);\n\t\t}\n\treturn rdesc;\n}", "target": 0}
{"code": "int main()\n{\n\tgdImagePtr im, exp;\n\tint error = 0;\n\tim = gdImageCreate(50, 50);\n\tif (!im) {\n\t\tgdTestErrorMsg(\"gdImageCreate failed.\\n\");\n\t\treturn 1;\n\t}\n\tgdImageCropThreshold(im, 1337, 0);\n\tgdImageDestroy(im);\n\treturn 0;\n}", "target": 0}
{"code": "TEE_Result crypto_acipher_alloc_dsa_public_key(struct dsa_public_key *s,\n\t\t\t\t\t       size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->g))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->p))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->q))\n\t\tgoto err;\n\tif (!bn_alloc_max(&s->y))\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tcrypto_bignum_free(s->g);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)\n{\n\tif (!nb_bits) return 0;\n#ifdef GPAC_FIXED_POINT\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\tif (neg < -FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\tif (val > FIX_ONE / 2)\n\t\t\treturn 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#else\n\tif (val >> (nb_bits-1) ) {\n\t\ts32 neg = (s32) val - (1<<nb_bits);\n\t\treturn gf_divfix(INT2FIX(neg), lsr->res_factor);\n\t} else {\n\t\treturn gf_divfix(INT2FIX(val), lsr->res_factor);\n\t}\n#endif\n}", "target": 0}
{"code": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}", "target": 1}
{"code": "static int js_doregexec(js_State *J, Reprog *prog, const char *string, Resub *sub, int eflags)\n{\n\tint result = js_regexec(prog, string, sub, eflags);\n\tif (result < 0)\n\t\tjs_error(J, \"regexec failed\");\n\treturn result;\n}", "target": 0}
{"code": "static int crypto_skcipher_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_skcipher *skcipher = __crypto_skcipher_cast(tfm);\n\tstruct skcipher_alg *alg = crypto_skcipher_alg(skcipher);\n\tif (tfm->__crt_alg->cra_type == &crypto_blkcipher_type)\n\t\treturn crypto_init_skcipher_ops_blkcipher(tfm);\n\tif (tfm->__crt_alg->cra_type == &crypto_ablkcipher_type ||\n\t    tfm->__crt_alg->cra_type == &crypto_givcipher_type)\n\t\treturn crypto_init_skcipher_ops_ablkcipher(tfm);\n\tskcipher->setkey = alg->setkey;\n\tskcipher->encrypt = alg->encrypt;\n\tskcipher->decrypt = alg->decrypt;\n\tskcipher->ivsize = alg->ivsize;\n\tskcipher->keysize = alg->max_keysize;\n\tif (alg->exit)\n\t\tskcipher->base.exit = crypto_skcipher_exit_tfm;\n\tif (alg->init)\n\t\treturn alg->init(skcipher);\n\treturn 0;\n}", "target": 1}
{"code": "cdf_tole4(uint32_t sv)\n{\n\treturn CDF_TOLE4(sv);\n}", "target": 0}
{"code": "void AuthChecker::PassUserInfoOnSuccess() {\n  char *json_buf = auth::WriteUserInfoToJson(user_info_);\n  if (json_buf == nullptr) {\n    return;\n  }\n  char *base64_json_buf = auth::esp_base64_encode(\n      json_buf, strlen(json_buf), true, false, true );\n  context_->request()->AddHeaderToBackend(auth::kEndpointApiUserInfo,\n                                          base64_json_buf);\n  auth::esp_grpc_free(json_buf);\n  auth::esp_grpc_free(base64_json_buf);\n  TRACE(trace_span_) << \"Authenticated.\";\n  trace_span_.reset();\n  on_done_(Status::OK);\n}", "target": 1}
{"code": "    setSanMatchers(std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers) {\n      san_matchers_ = san_matchers;\n      return *this;\n    }", "target": 1}
{"code": "int ntlm_read_message_header(wStream* s, NTLM_MESSAGE_HEADER* header)\n{\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn -1;\n\tStream_Read(s, header->Signature, 8);\n\tStream_Read_UINT32(s, header->MessageType);\n\tif (strncmp((char*) header->Signature, NTLM_SIGNATURE, 8) != 0)\n\t\treturn -1;\n\treturn 1;\n}", "target": 1}
{"code": "static int v2g_incoming_v2gtp(struct v2g_connection* conn) {\n    int rv;\n    rv = connection_read(conn, conn->buffer, V2GTP_HEADER_LENGTH);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv == 0)\n        return 1;\n    if (rv != V2GTP_HEADER_LENGTH) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(header) too short: expected %d, got %d\", V2GTP_HEADER_LENGTH, rv);\n        return -1;\n    }\n    rv = read_v2gtpHeader(conn->buffer, &conn->payload_len);\n    if (rv == -1) {\n        dlog(DLOG_LEVEL_ERROR, \"Invalid v2gtp header\");\n        return -1;\n    }\n    if (conn->payload_len + V2GTP_HEADER_LENGTH > DEFAULT_BUFFER_SIZE) {\n        dlog(DLOG_LEVEL_ERROR, \"payload too long: have %d, would need %d\", DEFAULT_BUFFER_SIZE,\n             conn->payload_len + V2GTP_HEADER_LENGTH);\n        return -1;\n    }\n    rv = connection_read(conn, &conn->buffer[V2GTP_HEADER_LENGTH], conn->payload_len);\n    if (rv < 0) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) failed: %s\",\n             (rv == -1) ? strerror(errno) : \"connection terminated\");\n        return -1;\n    }\n    if (rv != conn->payload_len) {\n        dlog(DLOG_LEVEL_ERROR, \"connection_read(payload) too short: expected %d, got %d\", conn->payload_len, rv);\n        return -1;\n    }\n    conn->buffer_pos = V2GTP_HEADER_LENGTH;\n    conn->stream.size = conn->payload_len + V2GTP_HEADER_LENGTH;\n    return 0;\n}", "target": 1}
{"code": "Item *Item_hex_constant::safe_charset_converter(CHARSET_INFO *tocs)\n{\n  Item_string *conv;\n  String tmp, *str= val_str(&tmp);\n  if (!(conv= new Item_string(str->ptr(), str->length(), tocs)))\n    return NULL;\n  conv->str_value.copy();\n  conv->str_value.mark_as_const();\n  return conv;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &cookies() const override\n    {\n        return cookies_;\n    }", "target": 1}
{"code": "void codingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = scrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}\n}", "target": 1}
{"code": "static inline void vpid_sync_context(struct vcpu_vmx *vmx)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vmx);\n\telse\n\t\tvpid_sync_vcpu_global();\n}", "target": 0}
{"code": "juniper_atm1_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        int llc_hdrlen;\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_ATM1;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (l2info.cookie[0] == 0x80) { \n            oam_print(ndo, p, l2info.length, ATM_OAM_NOHEC);\n            return l2info.header_len;\n        }\n        if (EXTRACT_24BITS(p) == 0xfefe03 || \n            EXTRACT_24BITS(p) == 0xaaaa03) { \n            llc_hdrlen = llc_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            if (llc_hdrlen > 0)\n                return l2info.header_len;\n        }\n        if (p[0] == 0x03) { \n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            return l2info.header_len;\n        }\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) \n            return l2info.header_len;\n\treturn l2info.header_len;\n}", "target": 1}
{"code": "backref_match_at_nested_level(regex_t* reg,\n                              StackType* top, StackType* stk_base,\n                              int ignore_case, int case_fold_flag,\n                              int nest, int mem_num, MemNumType* memp,\n                              UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  StackType* k;\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pstart = k->u.mem.pstr;\n          if (IS_NOT_NULL(pend)) {\n            if (pend - pstart > send - *s) return 0; \n            p  = pstart;\n            ss = *s;\n            if (ignore_case != 0) {\n              if (string_cmp_ic(reg->enc, case_fold_flag,\n                                pstart, &ss, (int )(pend - pstart)) == 0)\n                return 0; \n            }\n            else {\n              while (p < pend) {\n                if (*p++ != *ss++) return 0; \n              }\n            }\n            *s = ss;\n            return 1;\n          }\n        }\n      }\n      else if (k->type == STK_MEM_END) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pend = k->u.mem.pstr;\n        }\n      }\n    }\n    k--;\n  }\n  return 0;\n}", "target": 0}
{"code": "static void do_free_publickey(struct ecc_public_key *key)\n{\n\tcrypto_bignum_free(key->x);\n\tcrypto_bignum_free(key->y);\n}", "target": 1}
{"code": "static int send_release(uint32_t server, uint32_t ciaddr)\n{\n\tstruct dhcp_packet packet;\n\tinit_packet(&packet, DHCPRELEASE);\n\tpacket.ciaddr = ciaddr;\n\tudhcp_add_simple_option(&packet, DHCP_SERVER_ID, server);\n\tbb_info_msg(\"Sending release...\");\n\treturn bcast_or_ucast(&packet, ciaddr, server);\n}", "target": 0}
{"code": "unsigned int munlock_vma_page(struct page *page)\n{\n\tunsigned int nr_pages;\n\tstruct zone *zone = page_zone(page);\n\tBUG_ON(!PageLocked(page));\n\tspin_lock_irq(&zone->lru_lock);\n\tnr_pages = hpage_nr_pages(page);\n\tif (!TestClearPageMlocked(page))\n\t\tgoto unlock_out;\n\t__mod_zone_page_state(zone, NR_MLOCK, -nr_pages);\n\tif (__munlock_isolate_lru_page(page, true)) {\n\t\tspin_unlock_irq(&zone->lru_lock);\n\t\t__munlock_isolated_page(page);\n\t\tgoto out;\n\t}\n\t__munlock_isolation_failed(page);\nunlock_out:\n\tspin_unlock_irq(&zone->lru_lock);\nout:\n\treturn nr_pages - 1;\n}", "target": 0}
{"code": "void mm_release(struct task_struct *tsk, struct mm_struct *mm)\n{\n\tstruct completion *vfork_done = tsk->vfork_done;\n#ifdef CONFIG_FUTEX\n\tif (unlikely(tsk->robust_list))\n\t\texit_robust_list(tsk);\n#ifdef CONFIG_COMPAT\n\tif (unlikely(tsk->compat_robust_list))\n\t\tcompat_exit_robust_list(tsk);\n#endif\n#endif\n\tdeactivate_mm(tsk, mm);\n\tif (vfork_done) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork_done);\n\t}\n\tif (tsk->clear_child_tid\n\t    && !(tsk->flags & PF_SIGNALED)\n\t    && atomic_read(&mm->mm_users) > 1) {\n\t\tu32 __user * tidptr = tsk->clear_child_tid;\n\t\ttsk->clear_child_tid = NULL;\n\t\tput_user(0, tidptr);\n\t\tsys_futex(tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);\n\t}\n}", "target": 0}
{"code": "spnego_gss_wrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tint conf_req_flag,\n\t\tgss_qop_t qop_req,\n\t\tgss_buffer_t input_message_buffer,\n\t\tint *conf_state,\n\t\tgss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap(minor_status,\n\t\t    context_handle,\n\t\t    conf_req_flag,\n\t\t    qop_req,\n\t\t    input_message_buffer,\n\t\t    conf_state,\n\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "void gtkui_conf_read(void) {\n   FILE *fd;\n   const char *path;\n   char line[100], name[30];\n   short value;\n#ifdef OS_WINDOWS\n   path = ec_win_get_user_dir();\n#else\n   path = g_get_tmp_dir();\n#endif\n   filename = g_build_filename(path, \".ettercap_gtk\", NULL);\n   DEBUG_MSG(\"gtkui_conf_read: %s\", filename);\n   fd = fopen(filename, \"r\");\n   if(!fd) \n      return;\n   while(fgets(line, 100, fd)) {\n      sscanf(line, \"%s = %hd\", name, &value);\n      gtkui_conf_set(name, value);\n   }\n   fclose(fd);\n}", "target": 1}
{"code": "u32 gf_isom_get_nalu_length_field(GF_ISOFile *file, u32 track, u32 StreamDescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_MPEGVisualSampleEntryBox *ve;\n\tGF_SampleDescriptionBox *stsd;\n\ttrak = gf_isom_get_track_from_file(file, track);\n\tif (!trak) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tstsd = trak->Media->information->sampleTable->SampleDescription;\n\tif (!stsd || !StreamDescriptionIndex || StreamDescriptionIndex > gf_list_count(stsd->child_boxes)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tentry = (GF_SampleEntryBox *)gf_list_get(stsd->child_boxes, StreamDescriptionIndex - 1);\n\tif (!entry || ! gf_isom_is_nalu_based_entry(trak->Media, entry)) {\n\t\tfile->LastError = GF_BAD_PARAM;\n\t\treturn 0;\n\t}\n\tve = (GF_MPEGVisualSampleEntryBox*)entry;\n\tif (ve->avc_config) return ve->avc_config->config->nal_unit_size;\n\tif (ve->svc_config) return ve->svc_config->config->nal_unit_size;\n\tif (ve->hevc_config) return ve->hevc_config->config->nal_unit_size;\n\tif (ve->lhvc_config) return ve->lhvc_config->config->nal_unit_size;\n\treturn 0;\n}", "target": 0}
{"code": "struct resource_pool *dce112_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "    std::ostream& DataValue::write(std::ostream& os) const\n    {\n        std::vector<byte>::size_type end = value_.size();\n        for (std::vector<byte>::size_type i = 0; i != end; ++i) {\n            os << static_cast<int>(value_[i]);\n            if (i < end - 1) os << \" \";\n        }\n        return os;\n    }", "target": 0}
{"code": "GF_Err hdlr_dump(GF_Box *a, FILE * trace)\n{\n\tGF_HandlerBox *p = (GF_HandlerBox *)a;\n\tgf_isom_box_dump_start(a, \"HandlerBox\", trace);\n\tif (p->nameUTF8 && (u32) p->nameUTF8[0] == strlen(p->nameUTF8+1)) {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8+1);\n\t} else {\n\t\tfprintf(trace, \"hdlrType=\\\"%s\\\" Name=\\\"%s\\\" \", gf_4cc_to_str(p->handlerType), p->nameUTF8);\n\t}\n\tfprintf(trace, \"reserved1=\\\"%d\\\" reserved2=\\\"\", p->reserved1);\n\tdump_data(trace, (char *) p->reserved2, 12);\n\tfprintf(trace, \"\\\"\");\n\tfprintf(trace, \">\\n\");\n\tgf_isom_box_dump_done(\"HandlerBox\", a, trace);\n\treturn GF_OK;\n}", "target": 1}
{"code": "static std::string WrapWithTH(std::string text) {\n  return \"<th>\" + text + \"</th>\";\n}", "target": 0}
{"code": "static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\t*data = &iterator->current;\n}", "target": 0}
{"code": "static void kvm_unload_vcpu_mmu(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tr = vcpu_load(vcpu);\n\tBUG_ON(r);\n\tkvm_mmu_unload(vcpu);\n\tvcpu_put(vcpu);\n}", "target": 0}
{"code": "void CIRCSock::ReadLine(const CString& sData) {\n    CString sLine = sData;\n    sLine.TrimRight(\"\\n\\r\");\n    DEBUG(\"(\" << m_pNetwork->GetUser()->GetUserName() << \"/\"\n              << m_pNetwork->GetName() << \") IRC -> ZNC [\" << sLine << \"]\");\n    bool bReturn = false;\n    IRCSOCKMODULECALL(OnRaw(sLine), &bReturn);\n    if (bReturn) return;\n    CMessage Message(sLine);\n    Message.SetNetwork(m_pNetwork);\n    IRCSOCKMODULECALL(OnRawMessage(Message), &bReturn);\n    if (bReturn) return;\n    switch (Message.GetType()) {\n        case CMessage::Type::Account:\n            bReturn = OnAccountMessage(Message);\n            break;\n        case CMessage::Type::Action:\n            bReturn = OnActionMessage(Message);\n            break;\n        case CMessage::Type::Away:\n            bReturn = OnAwayMessage(Message);\n            break;\n        case CMessage::Type::Capability:\n            bReturn = OnCapabilityMessage(Message);\n            break;\n        case CMessage::Type::CTCP:\n            bReturn = OnCTCPMessage(Message);\n            break;\n        case CMessage::Type::Error:\n            bReturn = OnErrorMessage(Message);\n            break;\n        case CMessage::Type::Invite:\n            bReturn = OnInviteMessage(Message);\n            break;\n        case CMessage::Type::Join:\n            bReturn = OnJoinMessage(Message);\n            break;\n        case CMessage::Type::Kick:\n            bReturn = OnKickMessage(Message);\n            break;\n        case CMessage::Type::Mode:\n            bReturn = OnModeMessage(Message);\n            break;\n        case CMessage::Type::Nick:\n            bReturn = OnNickMessage(Message);\n            break;\n        case CMessage::Type::Notice:\n            bReturn = OnNoticeMessage(Message);\n            break;\n        case CMessage::Type::Numeric:\n            bReturn = OnNumericMessage(Message);\n            break;\n        case CMessage::Type::Part:\n            bReturn = OnPartMessage(Message);\n            break;\n        case CMessage::Type::Ping:\n            bReturn = OnPingMessage(Message);\n            break;\n        case CMessage::Type::Pong:\n            bReturn = OnPongMessage(Message);\n            break;\n        case CMessage::Type::Quit:\n            bReturn = OnQuitMessage(Message);\n            break;\n        case CMessage::Type::Text:\n            bReturn = OnTextMessage(Message);\n            break;\n        case CMessage::Type::Topic:\n            bReturn = OnTopicMessage(Message);\n            break;\n        case CMessage::Type::Wallops:\n            bReturn = OnWallopsMessage(Message);\n            break;\n        default:\n            break;\n    }\n    if (bReturn) return;\n    m_pNetwork->PutUser(Message);\n}", "target": 1}
{"code": "int main(int argc, char **argv)\n{\n  test_cmp_parameters inParam;\n  FILE *fbase=NULL, *ftest=NULL;\n  int same = 0;\n  char lbase[256];\n  char strbase[256];\n  char ltest[256];\n  char strtest[256];\n  if( parse_cmdline_cmp(argc, argv, &inParam) == 1 )\n    {\n    compare_dump_files_help_display();\n    goto cleanup;\n    }\n  printf(\"******Parameters********* \\n\");\n  printf(\" base_filename = %s\\n\"\n    \" test_filename = %s\\n\",\n    inParam.base_filename, inParam.test_filename);\n  printf(\"************************* \\n\");\n  printf(\"Try to open: %s for reading ... \", inParam.base_filename);\n  if((fbase = fopen(inParam.base_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n  printf(\"Try to open: %s for reading ... \", inParam.test_filename);\n  if((ftest = fopen(inParam.test_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n  while (fgets(lbase, sizeof(lbase), fbase) && fgets(ltest,sizeof(ltest),ftest))\n    {\n    int nbase = sscanf(lbase, \"%255[^\\r\\n]\", strbase);\n    int ntest = sscanf(ltest, \"%255[^\\r\\n]\", strtest);\n    assert( nbase != 255 && ntest != 255 );\n    if( nbase != 1 || ntest != 1 )\n      {\n      fprintf(stderr, \"could not parse line from files\\n\" );\n      goto cleanup;\n      }\n    if( strcmp( strbase, strtest ) != 0 )\n      {\n      fprintf(stderr,\"<%s> vs. <%s>\\n\", strbase, strtest);\n      goto cleanup;\n      }\n    }\n  same = 1;\n  printf(\"\\n***** TEST SUCCEED: Files are the same. *****\\n\");\ncleanup:\n  if(fbase) fclose(fbase);\n  if(ftest) fclose(ftest);\n  free(inParam.base_filename);\n  free(inParam.test_filename);\n  return same ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "target": 1}
{"code": "int shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\tif (!server)\n\t\treturn -1;\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\tserver->capture = shadow_capture_new(server);\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\tclear_inode_flag(inode, FI_ACL_MODE);\n\treturn error;\n}", "target": 1}
{"code": "static void voutf(struct GlobalConfig *config,\n                  const char *prefix,\n                  const char *fmt,\n                  va_list ap)\n{\n  size_t width = (79 - strlen(prefix));\n  if(!config->mute) {\n    size_t len;\n    char *ptr;\n    char *print_buffer;\n    print_buffer = curlx_mvaprintf(fmt, ap);\n    if(!print_buffer)\n      return;\n    len = strlen(print_buffer);\n    ptr = print_buffer;\n    while(len > 0) {\n      fputs(prefix, config->errors);\n      if(len > width) {\n        size_t cut = width-1;\n        while(!ISSPACE(ptr[cut]) && cut) {\n          cut--;\n        }\n        if(0 == cut)\n          cut = width-1;\n        (void)fwrite(ptr, cut + 1, 1, config->errors);\n        fputs(\"\\n\", config->errors);\n        ptr += cut + 1; \n        len -= cut;\n      }\n      else {\n        fputs(ptr, config->errors);\n        len = 0;\n      }\n    }\n    curl_free(print_buffer);\n  }\n}", "target": 1}
{"code": "  TfLiteRegistration OkOpRegistration() {\n    TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n    reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n      const TfLiteTensor* in_tensor = GetInput(context, node, 0);\n      TfLiteTensor* out_tensor = GetOutput(context, node, 0);\n      TfLiteIntArray* new_size = TfLiteIntArrayCopy(in_tensor->dims);\n      return context->ResizeTensor(context, out_tensor, new_size);\n    };\n    reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n      return kTfLiteOk;\n    };\n    return reg;\n  }", "target": 1}
{"code": "static bool translation_pre_enabled(struct intel_iommu *iommu)\n{\n\treturn (iommu->flags & VTD_FLAG_TRANS_PRE_ENABLED);\n}", "target": 0}
{"code": "static int adpt_queue_lck(struct scsi_cmnd *cmd)\n{\n\tadpt_hba* pHba = NULL;\n\tstruct adpt_device* pDev = NULL;\t\n\tif ((cmd->cmnd[0] == REQUEST_SENSE) && (cmd->sense_buffer[0] != 0)) {\n\t\tcmd->result = (DID_OK << 16);\n\t\tscsi_done(cmd);\n\t\treturn 0;\n\t}\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tif (!pHba) {\n\t\treturn FAILED;\n\t}\n\trmb();\n\tif ((pHba->state) & DPTI_STATE_RESET)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\tif((pDev = (struct adpt_device*) (cmd->device->hostdata)) == NULL) {\n\t\tif ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun)) == NULL) {\n\t\t\tcmd->result = (DID_NO_CONNECT << 16);\n\t\t\tscsi_done(cmd);\n\t\t\treturn 0;\n\t\t}\n\t\tcmd->device->hostdata = pDev;\n\t}\n\tpDev->pScsi_dev = cmd->device;\n\tif (pDev->state & DPTI_DEV_RESET ) {\n\t\treturn FAILED;\n\t}\n\treturn adpt_scsi_to_i2o(pHba, cmd, pDev);\n}", "target": 1}
{"code": "void Interpreter::saveGenerator(\n    Runtime *runtime,\n    PinnedHermesValue *frameRegs,\n    const Inst *resumeIP) {\n  auto *innerFn = vmcast<GeneratorInnerFunction>(FRAME.getCalleeClosure());\n  innerFn->saveStack(runtime);\n  innerFn->setNextIP(resumeIP);\n  innerFn->setState(GeneratorInnerFunction::State::SuspendedYield);\n}", "target": 0}
{"code": "static int kvaser_usb_leaf_simple_cmd_async(struct kvaser_usb_net_priv *priv,\n\t\t\t\t\t    u8 cmd_id)\n{\n\tstruct kvaser_cmd *cmd;\n\tint err;\n\tcmd = kmalloc(sizeof(*cmd), GFP_ATOMIC);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_simple);\n\tcmd->id = cmd_id;\n\tcmd->u.simple.channel = priv->channel;\n\terr = kvaser_usb_send_cmd_async(priv, cmd, cmd->len);\n\tif (err)\n\t\tkfree(cmd);\n\treturn err;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_inq_pop(struct sctp_inq *queue)\n{\n\tstruct sctp_chunk *chunk;\n\tsctp_chunkhdr_t *ch = NULL;\n\tif ((chunk = queue->in_progress)) {\n\t\tif (chunk->singleton ||\n\t\t    chunk->end_of_packet ||\n\t\t    chunk->pdiscard) {\n\t\t\tsctp_chunk_free(chunk);\n\t\t\tchunk = queue->in_progress = NULL;\n\t\t} else {\n\t\t\tch = (sctp_chunkhdr_t *) chunk->chunk_end;\n\t\t\tskb_pull(chunk->skb,\n\t\t\t\t chunk->chunk_end - chunk->skb->data);\n\t\t\tif (skb_headlen(chunk->skb) < sizeof(sctp_chunkhdr_t)) {\n\t\t\t\tsctp_chunk_free(chunk);\n\t\t\t\tchunk = queue->in_progress = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (!chunk) {\n\t\tstruct list_head *entry;\n\t\tif (list_empty(&queue->in_chunk_list))\n\t\t\treturn NULL;\n\t\tentry = queue->in_chunk_list.next;\n\t\tchunk = queue->in_progress =\n\t\t\tlist_entry(entry, struct sctp_chunk, list);\n\t\tlist_del_init(entry);\n\t\tchunk->singleton = 1;\n\t\tch = (sctp_chunkhdr_t *) chunk->skb->data;\n\t\tchunk->data_accepted = 0;\n\t}\n\tchunk->chunk_hdr = ch;\n\tchunk->chunk_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch->length));\n\tif (unlikely(skb_is_nonlinear(chunk->skb))) {\n\t\tif (chunk->chunk_end > skb_tail_pointer(chunk->skb))\n\t\t\tchunk->chunk_end = skb_tail_pointer(chunk->skb);\n\t}\n\tskb_pull(chunk->skb, sizeof(sctp_chunkhdr_t));\n\tchunk->subh.v = NULL; \n\tif (chunk->chunk_end < skb_tail_pointer(chunk->skb)) {\n\t\tchunk->singleton = 0;\n\t} else if (chunk->chunk_end > skb_tail_pointer(chunk->skb)) {\n\t\tsctp_chunk_free(chunk);\n\t\tchunk = queue->in_progress = NULL;\n\t\treturn NULL;\n\t} else {\n\t\tchunk->end_of_packet = 1;\n\t}\n\tpr_debug(\"+++sctp_inq_pop+++ chunk:%p[%s], length:%d, skb->len:%d\\n\",\n\t\t chunk, sctp_cname(SCTP_ST_CHUNK(chunk->chunk_hdr->type)),\n\t\t ntohs(chunk->chunk_hdr->length), chunk->skb->len);\n\treturn chunk;\n}", "target": 1}
{"code": "static void jsonNewDString(Jsi_Interp *interp, Jsi_DString *dStr, const char* str, int len)\n{\n    char buf[100], *dp = buf;\n    const char *cp = str;\n    int ulen;\n    while ((cp-str)<len) {\n        if (*cp == '\\\\') {\n            switch (cp[1]) {\n                case 'b': *dp++ = '\\b'; break;\n                case 'n': *dp++ = '\\n'; break;\n                case 'r': *dp++ = '\\r'; break;\n                case 'f': *dp++ = '\\f'; break;\n                case 't': *dp++ = '\\t'; break;\n                case '\\\"': *dp++ = '\\\"'; break;\n                case '\\\\': *dp++ = '\\\\'; break;\n                case 'u': \n                    if ((ulen=Jsi_UtfDecode(cp+2, dp))) {\n                        dp += ulen;\n                        cp += 4;\n                    } else {                    \n                        *dp++ = '\\\\';\n                        *dp++ = 'u';\n                    }\n                    break;\n            }\n            cp+=2;\n        } else {\n            *dp++ = *cp++;\n        }\n        if ((dp-buf)>90) {\n            *dp = 0;\n            Jsi_DSAppendLen(dStr, buf, dp-buf);\n            dp = buf;\n        }\n    }\n    *dp = 0;\n    Jsi_DSAppendLen(dStr, buf, dp-buf);\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeDebugLocationEnd(Expression* curr, Function* func) {\n  if (func && !func->expressionLocations.empty()) {\n    auto& span = binaryLocations.expressions.at(curr);\n    span.end = o.size();\n  }\n}", "target": 0}
{"code": "x86_reg X86_insn_reg_intel(unsigned int id, enum cs_ac_type *access)\n{\n\tunsigned int first = 0;\n\tunsigned int last = ARR_SIZE(insn_regs_intel) - 1;\n\tunsigned int mid = ARR_SIZE(insn_regs_intel) / 2;\n\tif (!intel_regs_sorted) {\n\t\tmemcpy(insn_regs_intel_sorted, insn_regs_intel,\n\t\t\t\tsizeof(insn_regs_intel_sorted));\n\t\tqsort(insn_regs_intel_sorted,\n\t\t\t\tARR_SIZE(insn_regs_intel_sorted),\n\t\t\t\tsizeof(struct insn_reg), regs_cmp);\n\t\tintel_regs_sorted = true;\n\t}\n\twhile (first <= last) {\n\t\tif (insn_regs_intel_sorted[mid].insn < id) {\n\t\t\tfirst = mid + 1;\n\t\t} else if (insn_regs_intel_sorted[mid].insn == id) {\n\t\t\tif (access) {\n\t\t\t\t*access = insn_regs_intel_sorted[mid].access;\n\t\t\t}\n\t\t\treturn insn_regs_intel_sorted[mid].reg;\n\t\t} else {\n\t\t\tif (mid == 0)\n\t\t\t\tbreak;\n\t\t\tlast = mid - 1;\n\t\t}\n\t\tmid = (first + last) / 2;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_assoc_lookup_asconf_ack(\n\t\t\t\t\tconst struct sctp_association *asoc,\n\t\t\t\t\t__be32 serial)\n{\n\tstruct sctp_chunk *ack;\n\tlist_for_each_entry(ack, &asoc->asconf_ack_list, transmitted_list) {\n\t\tif (sctp_chunk_pending(ack))\n\t\t\tcontinue;\n\t\tif (ack->subh.addip_hdr->serial == serial) {\n\t\t\tsctp_chunk_hold(ack);\n\t\t\treturn ack;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "    size_t FileIo::write(BasicIo& src)\n    {\n        assert(p_->fp_ != 0);\n        if (static_cast<BasicIo*>(this) == &src) return 0;\n        if (!src.isopen()) return 0;\n        if (p_->switchMode(Impl::opWrite) != 0) return 0;\n        byte buf[4096];\n        size_t readCount = 0;\n        size_t writeTotal = 0;\n        while ((readCount = src.read(buf, sizeof(buf)))) {\n            const size_t writeCount = static_cast<long>(std::fwrite(buf, 1, static_cast<size_t>(readCount), p_->fp_));\n            writeTotal += writeCount;\n            if (writeCount != readCount) {\n                src.seek(writeCount-readCount, BasicIo::cur);\n                break;\n            }\n        }\n        return writeTotal;\n    }", "target": 0}
{"code": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin || !bin->segment_entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;\n\t\tbs->vsize = se->minAllocSz ? se->minAllocSz : 64000;\n\t\tbs->bits = R_SYS_BITS_16;\n\t\tbs->is_data = se->flags & IS_DATA;\n\t\tbs->perm = __translate_perms (se->flags);\n\t\tbs->paddr = (ut64)se->offset * bin->alignment;\n\t\tbs->name = r_str_newf (\"%s.%\" PFMT64d, se->flags & IS_MOVEABLE ? \"MOVEABLE\" : \"FIXED\", bs->paddr);\n\t\tbs->is_segment = true;\n\t\tr_list_append (segments, bs);\n\t}\n\tbin->segments = segments;\n\treturn segments;\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& in0 = ctx->input(0);\n    const Tensor& in1 = ctx->input(1);\n    ValidateInputTensors(ctx, in0, in1);\n    if (!ctx->status().ok()) {\n      return;\n    }\n    MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes());\n    OP_REQUIRES(\n        ctx, bcast.IsValid(),\n        errors::InvalidArgument(\n            \"In[0] and In[1] must have compatible batch dimensions: \",\n            in0.shape().DebugString(), \" vs. \", in1.shape().DebugString()));\n    TensorShape out_shape = bcast.output_batch_shape();\n    auto batch_size = bcast.output_batch_size();\n    auto d0 = in0.dim_size(in0.dims() - 2);\n    auto d1 = in0.dim_size(in0.dims() - 1);\n    Tensor in0_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})),\n        errors::Internal(\"Failed to reshape In[0] from \",\n                         in0.shape().DebugString()));\n    auto d2 = in1.dim_size(in1.dims() - 2);\n    auto d3 = in1.dim_size(in1.dims() - 1);\n    Tensor in1_reshaped;\n    OP_REQUIRES(\n        ctx,\n        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),\n        errors::Internal(\"Failed to reshape In[1] from \",\n                         in1.shape().DebugString()));\n    if (adjoint_) std::swap(d0, d1);\n    OP_REQUIRES(ctx, d1 == d2,\n                errors::InvalidArgument(\n                    \"In[0] mismatch In[1] shape: \", d1, \" vs. \", d2, \": \",\n                    in0.shape().DebugString(), \" \", in1.shape().DebugString(),\n                    \" \", lower_, \" \", adjoint_));\n    out_shape.AddDim(d0);\n    out_shape.AddDim(d3);\n    Tensor* out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out));\n    if (out->NumElements() == 0) {\n      return;\n    }\n    Tensor out_reshaped;\n    OP_REQUIRES(ctx,\n                out_reshaped.CopyFrom(*out, TensorShape({batch_size, d0, d3})),\n                errors::Internal(\"Failed to reshape output from \",\n                                 out->shape().DebugString()));\n    LaunchBatchMatrixTriangularSolve<Device, Scalar>::Launch(\n        ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast,\n        &out_reshaped);\n  }", "target": 0}
{"code": "Status FractionalPoolShapeFn(InferenceContext* c) {\n  ShapeHandle input;\n  TF_RETURN_IF_ERROR(c->WithRank(c->input(0), 4, &input));\n  std::vector<float> pooling_ratio;\n  TF_RETURN_IF_ERROR(c->GetAttr(\"pooling_ratio\", &pooling_ratio));\n  if (pooling_ratio.size() != 4) {\n    return errors::InvalidArgument(\n        \"pooling_ratio field must specify 4 dimensions\");\n  }\n  std::vector<DimensionHandle> output_dims;\n  for (int i = 0; i < 4; ++i) {\n    DimensionHandle d = c->Dim(input, i);\n    if (c->ValueKnown(d)) {\n      auto val =\n          static_cast<int64_t>(std::floor(c->Value(d) / pooling_ratio[i]));\n      if (val < 0) {\n        return errors::InvalidArgument(\"Size computed for dim \", i,\n                                       \" is negative: \", val);\n      }\n      output_dims.push_back(c->MakeDim(val));\n    } else {\n      output_dims.push_back(c->UnknownDim());\n    }\n  }\n  for (std::size_t i = 0; i < pooling_ratio.size(); ++i) {\n    if (pooling_ratio[i] < 1) {\n      return errors::InvalidArgument(\n          \"pooling_ratio cannot be smaller than 1, got: \", pooling_ratio[i]);\n    }\n  }\n  c->set_output(0, c->MakeShape(output_dims));\n  c->set_output(1, c->Vector(output_dims[1]));\n  c->set_output(2, c->Vector(output_dims[2]));\n  return OkStatus();\n}", "target": 0}
{"code": "ModHandle CModules::OpenModule(const CString& sModule, const CString& sModPath,\n                               CModInfo& Info, CString& sRetMsg) {\n    sRetMsg.clear();\n    for (unsigned int a = 0; a < sModule.length(); a++) {\n        if (((sModule[a] < '0') || (sModule[a] > '9')) &&\n            ((sModule[a] < 'a') || (sModule[a] > 'z')) &&\n            ((sModule[a] < 'A') || (sModule[a] > 'Z')) && (sModule[a] != '_')) {\n            sRetMsg =\n                t_f(\"Module names can only contain letters, numbers and \"\n                    \"underscores, [{1}] is invalid\")(sModule);\n            return nullptr;\n        }\n    }\n    ModHandle p = dlopen((sModPath).c_str(), RTLD_NOW | RTLD_GLOBAL);\n    if (!p) {\n        const char* cDlError = dlerror();\n        CString sDlError = cDlError ? cDlError : t_s(\"Unknown error\");\n        sRetMsg = t_f(\"Unable to open module {1}: {2}\")(sModule, sDlError);\n        return nullptr;\n    }\n    const CModuleEntry* (*fpZNCModuleEntry)() = nullptr;\n    *reinterpret_cast<void**>(&fpZNCModuleEntry) = dlsym(p, \"ZNCModuleEntry\");\n    if (!fpZNCModuleEntry) {\n        dlclose(p);\n        sRetMsg = t_f(\"Could not find ZNCModuleEntry in module {1}\")(sModule);\n        return nullptr;\n    }\n    const CModuleEntry* pModuleEntry = fpZNCModuleEntry();\n    if (std::strcmp(pModuleEntry->pcVersion, VERSION_STR) ||\n        std::strcmp(pModuleEntry->pcVersionExtra, VERSION_EXTRA)) {\n        sRetMsg = t_f(\n            \"Version mismatch for module {1}: core is {2}, module is built for \"\n            \"{3}. Recompile this module.\")(\n            sModule, VERSION_STR VERSION_EXTRA,\n            CString(pModuleEntry->pcVersion) + pModuleEntry->pcVersionExtra);\n        dlclose(p);\n        return nullptr;\n    }\n    if (std::strcmp(pModuleEntry->pcCompileOptions,\n                    ZNC_COMPILE_OPTIONS_STRING)) {\n        sRetMsg = t_f(\n            \"Module {1} is built incompatibly: core is '{2}', module is '{3}'. \"\n            \"Recompile this module.\")(sModule, ZNC_COMPILE_OPTIONS_STRING,\n                                      pModuleEntry->pcCompileOptions);\n        dlclose(p);\n        return nullptr;\n    }\n    CTranslationDomainRefHolder translation(\"znc-\" + sModule);\n    pModuleEntry->fpFillModInfo(Info);\n    sRetMsg = \"\";\n    return p;\n}", "target": 1}
{"code": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\tif (!fc)\n\t\treturn -EIO;\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\nout:\n\tfree(cgdir);\n\treturn ret;\n}", "target": 1}
{"code": "check_supported(item *new)\n{\nint c = -1;\nint bot = 0;\nint top = supported_elements_count;\nint mid;\ntree_node *tn;\nparamstr *param;\nwhile (top > bot)\n  {\n  mid = (top + bot)/2;\n  c = Ustrcmp(new->name, supported_elements[mid].name);\n  if (c == 0) break;\n  if (c < 0) top = mid; else bot = mid + 1;\n  }\nif (c != 0)\n  {\n  tn = tree_search(unknown_element_tree, new->name);\n  if (tn == NULL)\n    {\n    tn = misc_malloc(sizeof(tree_node) + Ustrlen(new->name));\n    Ustrcpy(tn->name, new->name);\n    (void)tree_insertnode(&unknown_element_tree, tn);\n    }\n  return;\n  }\nfor (param = new->p.param; param != NULL; param = param->next)\n  {\n  uschar buffer[256];\n  uschar **aptr;\n  if (param->name[0] == '#') continue;\n  if (Ustrcmp(param->name, \"revisionflag\") == 0)\n    {\n    if (Ustrcmp(param->value, \"changed\") == 0) continue;\n    (void)sprintf(CS buffer, \"+%s=%s:%s\", param->name, param->value,\n      new->name);\n    }\n  else\n    {\n    aptr = supported_elements[mid].attrs;\n    if (aptr != NULL)\n      {\n      if (Ustrcmp(*aptr, \"*\") == 0) continue;\n      for (; *aptr != NULL; aptr++)\n        if (Ustrcmp(*aptr, param->name) == 0) break;\n      if (*aptr != NULL) continue;\n      }\n    (void)sprintf(CS buffer, \"+%s:%s\", param->name, new->name);\n    }\n  tn = tree_search(unknown_element_tree, buffer);\n  if (tn == NULL)\n    {\n    tn = misc_malloc(sizeof(tree_node) + Ustrlen(buffer));\n    Ustrcpy(tn->name, buffer);\n    (void)tree_insertnode(&unknown_element_tree, tn);\n    }\n  }\n}", "target": 1}
{"code": "static inline bool mmget_still_valid(struct mm_struct *mm)\n{\n\treturn likely(!mm->core_state);\n}", "target": 0}
{"code": "static inline bool cpu_has_vmx_invept_context(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT;\n}", "target": 0}
{"code": "compat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2_f(\"original public key proposal: %s\", pkalg_prop);\n\tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat public key proposal: %s\", pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}", "target": 1}
{"code": "static int ext4_get_block_write(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\thandle_t *handle = NULL;\n\tint ret = 0;\n\tunsigned max_blocks = bh_result->b_size >> inode->i_blkbits;\n\tint dio_credits;\n\text4_debug(\"ext4_get_block_write: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\tcreate = EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (max_blocks > DIO_MAX_BLOCKS)\n\t\tmax_blocks = DIO_MAX_BLOCKS;\n\tdio_credits = ext4_chunk_trans_blocks(inode, max_blocks);\n\thandle = ext4_journal_start(inode, dio_credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tret = ext4_get_blocks(handle, inode, iblock, max_blocks, bh_result,\n\t\t\t      create);\n\tif (ret > 0) {\n\t\tbh_result->b_size = (ret << inode->i_blkbits);\n\t\tret = 0;\n\t}\n\text4_journal_stop(handle);\nout:\n\treturn ret;\n}", "target": 1}
{"code": "static inline void http1_consume_data(intptr_t uuid, http1pr_s *p) {\n  if (fio_pending(uuid) > 4) {\n    goto throttle;\n  }\n  ssize_t i = 0;\n  size_t org_len = p->buf_len;\n  int pipeline_limit = 8;\n  if (!p->buf_len)\n    return;\n  do {\n    i = http1_fio_parser(.parser = &p->parser,\n                         .buffer = p->buf + (org_len - p->buf_len),\n                         .length = p->buf_len, .on_request = http1_on_request,\n                         .on_response = http1_on_response,\n                         .on_method = http1_on_method,\n                         .on_status = http1_on_status, .on_path = http1_on_path,\n                         .on_query = http1_on_query,\n                         .on_http_version = http1_on_http_version,\n                         .on_header = http1_on_header,\n                         .on_body_chunk = http1_on_body_chunk,\n                         .on_error = http1_on_error);\n    p->buf_len -= i;\n    --pipeline_limit;\n  } while (i && p->buf_len && pipeline_limit && !p->stop);\n  if (p->buf_len && org_len != p->buf_len) {\n    memmove(p->buf, p->buf + (org_len - p->buf_len), p->buf_len);\n  }\n  if (p->buf_len == HTTP_MAX_HEADER_LENGTH) {\n    if (p->request.method)\n      http_send_error(&p->request, 413);\n    else {\n      p->request.method = fiobj_str_tmp();\n      http_send_error(&p->request, 413);\n    }\n  }\n  if (!pipeline_limit) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return;\nthrottle:\n  fio_suspend(uuid);\n  p->stop |= 4;\n  FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",\n                (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n}", "target": 1}
{"code": "void rose_stop_timer(struct sock *sk)\n{\n\tdel_timer(&rose_sk(sk)->timer);\n}", "target": 1}
{"code": "void QuickOpen::Load(uint64 BlockPos)\n{\n  if (!Loaded) \n  {\n    SeekPos=Arc->Tell();\n    UnsyncSeekPos=false;\n    SaveFilePos SavePos(*Arc);\n    Arc->Seek(BlockPos,SEEK_SET);\n    if (Arc->ReadHeader()==0 || Arc->GetHeaderType()!=HEAD_SERVICE ||\n        !Arc->SubHead.CmpName(SUBHEAD_TYPE_QOPEN))\n      return;\n    QLHeaderPos=Arc->CurBlockPos;\n    RawDataStart=Arc->Tell();\n    RawDataSize=Arc->SubHead.UnpSize;\n    Loaded=true; \n  }\n  if (Arc->SubHead.Encrypted)\n  {\n    RAROptions *Cmd=Arc->GetRAROptions();\n#ifndef RAR_NOCRYPT\n    if (Cmd->Password.IsSet())\n      Crypt.SetCryptKeys(false,CRYPT_RAR50,&Cmd->Password,Arc->SubHead.Salt,\n                         Arc->SubHead.InitV,Arc->SubHead.Lg2Count,\n                         Arc->SubHead.HashKey,Arc->SubHead.PswCheck);\n    else\n#endif\n      return;\n  }\n  RawDataPos=0;\n  ReadBufSize=0;\n  ReadBufPos=0;\n  LastReadHeader.Reset();\n  LastReadHeaderPos=0;\n  ReadBuffer();\n}", "target": 1}
{"code": "bool GTextFieldIsEmpty(GGadget *g) {\n    GTextField *gt = (GTextField *) g;\n    return gt->text == NULL || *gt->text == '\\0';\n}", "target": 0}
{"code": "choose_windows(s)\nconst char *s;\n{\n    register int i;\n    for (i = 0; winchoices[i].procs; i++) {\n        if ('+' == winchoices[i].procs->name[0])\n            continue;\n        if ('-' == winchoices[i].procs->name[0])\n            continue;\n        if (!strcmpi(s, winchoices[i].procs->name)) {\n            windowprocs = *winchoices[i].procs;\n            if (last_winchoice && last_winchoice->ini_routine)\n                (*last_winchoice->ini_routine)(WININIT_UNDO);\n            if (winchoices[i].ini_routine)\n                (*winchoices[i].ini_routine)(WININIT);\n            last_winchoice = &winchoices[i];\n            return;\n        }\n    }\n    if (!windowprocs.win_raw_print)\n        windowprocs.win_raw_print = def_raw_print;\n    if (!windowprocs.win_wait_synch)\n        windowprocs.win_wait_synch = def_wait_synch;\n    if (!winchoices[0].procs) {\n        raw_printf(\"No window types?\");\n        nh_terminate(EXIT_FAILURE);\n    }\n    if (!winchoices[1].procs) {\n        config_error_add(\n                     \"Window type %s not recognized.  The only choice is: %s\",\n                         s, winchoices[0].procs->name);\n    } else {\n        char buf[BUFSZ];\n        boolean first = TRUE;\n        buf[0] = '\\0';\n        for (i = 0; winchoices[i].procs; i++) {\n            if ('+' == winchoices[i].procs->name[0])\n                continue;\n            if ('-' == winchoices[i].procs->name[0])\n                continue;\n            Sprintf(eos(buf), \"%s%s\",\n                    first ? \"\" : \", \", winchoices[i].procs->name);\n            first = FALSE;\n        }\n        config_error_add(\"Window type %s not recognized.  Choices are:  %s\",\n                         s, buf);\n    }\n    if (windowprocs.win_raw_print == def_raw_print\n            || WINDOWPORT(\"safe-startup\"))\n        nh_terminate(EXIT_SUCCESS);\n}", "target": 1}
{"code": "static void do_free_publickey(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "static void cp2112_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\n{\n\tstruct cp2112_device *dev = gpiochip_get_data(chip);\n\tstruct hid_device *hdev = dev->hdev;\n\tu8 *buf = dev->in_out_buffer;\n\tunsigned long flags;\n\tint ret;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbuf[0] = CP2112_GPIO_SET;\n\tbuf[1] = value ? 0xff : 0;\n\tbuf[2] = 1 << offset;\n\tret = hid_hw_raw_request(hdev, CP2112_GPIO_SET, buf,\n\t\t\t\t CP2112_GPIO_SET_LENGTH, HID_FEATURE_REPORT,\n\t\t\t\t HID_REQ_SET_REPORT);\n\tif (ret < 0)\n\t\thid_err(hdev, \"error setting GPIO values: %d\\n\", ret);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}", "target": 1}
{"code": "static bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tchar *sockaddr_url, *stratum_port, *tmp;\n\tchar *url, *port, address[256];\n\tmemset(address, 0, 255);\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\telse {\n\t\tchar *dot_pool, *dot_reconnect;\n\t\tdot_pool = strchr(pool->sockaddr_url, '.');\n\t\tif (!dot_pool) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request for pool without domain '%s'\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tdot_reconnect = strchr(url, '.');\n\t\tif (!dot_reconnect) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to url without domain '%s'\",\n\t\t\t       url);\n\t\t\treturn false;\n\t\t}\n\t\tif (strcmp(dot_pool, dot_reconnect)) {\n\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\tsprintf(address, \"%s:%s\", url, port);\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\tclear_pool_work(pool);\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "TRIO_PUBLIC_STRING size_t trio_length TRIO_ARGS1((string), TRIO_CONST char* string)\n{\n\treturn strlen(string);\n}", "target": 1}
{"code": "IOBasicTypes::LongBufferSizeType ObjectByteWriterWithPosition::Write(const IOBasicTypes::Byte* inBuffer,IOBasicTypes::LongBufferSizeType inBufferSize)\n{\n\tCREATE_ISOLATE_CONTEXT;\n\tCREATE_ESCAPABLE_SCOPE;\n    Local<Object> anArray = NEW_ARRAY((int)inBufferSize);\n    for(int i=0;i<(int)inBufferSize;++i)\n        anArray->Set(GET_CURRENT_CONTEXT, NEW_NUMBER(i),NEW_NUMBER(inBuffer[i]));\n\tLocal<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(\"write\")).ToLocalChecked();\n    if(value->IsUndefined() || !value->IsFunction())\n    {\n\t\tTHROW_EXCEPTION(\"write is not a function, it should be you know...\");\n        return 0;\n    }\n    Local<Function> func = Local<Function>::Cast(value);\n    Local<Value> args[1];\n    args[0] = anArray;\n\tLocal<Value> result = func->Call(GET_CURRENT_CONTEXT,  OBJECT_FROM_PERSISTENT(mObject), 1, args).ToLocalChecked();\n    if(result.IsEmpty())\n    {\n\t\tTHROW_EXCEPTION(\"wrong return value. it's empty. return the number of written characters\");\n\t\treturn 0;\n    }\n    else if(result->IsNumber())\n    {\n        return TO_UINT32(result)->Value();\n    }\n    else\n    {\n\t\tTHROW_EXCEPTION(\"wrong return value. write should return the number of written characters\");\n\t\treturn 0;\n    }\n}", "target": 1}
{"code": "sraSpanRemove(sraSpan *span) {\n  span->_prev->_next = span->_next;\n  span->_next->_prev = span->_prev;\n}", "target": 1}
{"code": "void rose_del_loopback_node(const rose_address *address)\n{\n\tstruct rose_node *rose_node;\n\tspin_lock_bh(&rose_node_list_lock);\n\trose_node = rose_node_list;\n\twhile (rose_node != NULL) {\n\t\tif ((rose_node->mask == 10) &&\n\t\t    (rosecmpm(address, &rose_node->address, 10) == 0) &&\n\t\t    rose_node->loopback)\n\t\t\tbreak;\n\t\trose_node = rose_node->next;\n\t}\n\tif (rose_node == NULL)\n\t\tgoto out;\n\trose_remove_node(rose_node);\n\trose_loopback_neigh->count--;\nout:\n\tspin_unlock_bh(&rose_node_list_lock);\n}", "target": 0}
{"code": "merged_2v_upsample(j_decompress_ptr cinfo, JSAMPIMAGE input_buf,\n                   JDIMENSION *in_row_group_ctr,\n                   JDIMENSION in_row_groups_avail, JSAMPARRAY output_buf,\n                   JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail)\n{\n  my_upsample_ptr upsample = (my_upsample_ptr)cinfo->upsample;\n  JSAMPROW work_ptrs[2];\n  JDIMENSION num_rows;          \n  if (upsample->spare_full) {\n    JDIMENSION size = upsample->out_row_width;\n    if (cinfo->out_color_space == JCS_RGB565)\n      size = cinfo->output_width * 2;\n    jcopy_sample_rows(&upsample->spare_row, 0, output_buf + *out_row_ctr, 0, 1,\n                      size);\n    num_rows = 1;\n    upsample->spare_full = FALSE;\n  } else {\n    num_rows = 2;\n    if (num_rows > upsample->rows_to_go)\n      num_rows = upsample->rows_to_go;\n    out_rows_avail -= *out_row_ctr;\n    if (num_rows > out_rows_avail)\n      num_rows = out_rows_avail;\n    work_ptrs[0] = output_buf[*out_row_ctr];\n    if (num_rows > 1) {\n      work_ptrs[1] = output_buf[*out_row_ctr + 1];\n    } else {\n      work_ptrs[1] = upsample->spare_row;\n      upsample->spare_full = TRUE;\n    }\n    (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr, work_ptrs);\n  }\n  *out_row_ctr += num_rows;\n  upsample->rows_to_go -= num_rows;\n  if (!upsample->spare_full)\n    (*in_row_group_ctr)++;\n}", "target": 1}
{"code": "inline void aligned_free(void* ptr) {\n  folly::detail::aligned_free(ptr);\n}", "target": 1}
{"code": "static bool too_many_pipe_buffers_soft(struct user_struct *user)\n{\n\treturn pipe_user_pages_soft &&\n\t       atomic_long_read(&user->pipe_bufs) >= pipe_user_pages_soft;\n}", "target": 0}
{"code": "std::string encodeBase64(const std::string& input) {\n  using namespace boost::archive::iterators;\n  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;\n  auto data = input.data();\n  std::string encoded(b64it(data), b64it(data + (input.length())));\n  encoded.append((3 - (input.length() % 3)) % 3, '=');\n  return encoded;\n}", "target": 1}
{"code": "static void __iov_iter_advance_iov(struct iov_iter *i, size_t bytes)\n{\n\tif (likely(i->nr_segs == 1)) {\n\t\ti->iov_offset += bytes;\n\t} else {\n\t\tconst struct iovec *iov = i->iov;\n\t\tsize_t base = i->iov_offset;\n\t\twhile (bytes) {\n\t\t\tint copy = min(bytes, iov->iov_len - base);\n\t\t\tbytes -= copy;\n\t\t\tbase += copy;\n\t\t\tif (iov->iov_len == base) {\n\t\t\t\tiov++;\n\t\t\t\tbase = 0;\n\t\t\t}\n\t\t}\n\t\ti->iov = iov;\n\t\ti->iov_offset = base;\n\t}\n}", "target": 1}
{"code": "remove_this_reserved_job(conn c, job j)\n{\n    j = job_remove(j);\n    if (j) {\n        global_stat.reserved_ct--;\n        j->tube->stat.reserved_ct--;\n        j->reserver = NULL;\n    }\n    c->soonest_job = NULL;\n    if (!job_list_any_p(&c->reserved_jobs)) conn_remove(c);\n    return j;\n}", "target": 0}
{"code": "njs_json_parse(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t             ret;\n    njs_value_t           *text, value, lvalue;\n    const u_char          *p, *end;\n    njs_json_parse_t      *parse, json_parse;\n    const njs_value_t     *reviver;\n    njs_string_prop_t     string;\n    njs_json_parse_ctx_t  ctx;\n    parse = &json_parse;\n    text = njs_lvalue_arg(&lvalue, args, nargs, 1);\n    if (njs_slow_path(!njs_is_string(text))) {\n        ret = njs_value_to_string(vm, text, text);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n    }\n    (void) njs_string_prop(&string, text);\n    p = string.start;\n    end = p + string.size;\n    ctx.vm = vm;\n    ctx.pool = vm->mem_pool;\n    ctx.depth = NJS_JSON_MAX_DEPTH;\n    ctx.start = string.start;\n    ctx.end = end;\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p == end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected end of input\", p);\n        return NJS_ERROR;\n    }\n    p = njs_json_parse_value(&ctx, &value, p);\n    if (njs_slow_path(p == NULL)) {\n        return NJS_ERROR;\n    }\n    p = njs_json_skip_space(p, end);\n    if (njs_slow_path(p != end)) {\n        njs_json_parse_exception(&ctx, \"Unexpected token\", p);\n        return NJS_ERROR;\n    }\n    reviver = njs_arg(args, nargs, 2);\n    if (njs_slow_path(njs_is_function(reviver) && njs_is_object(&value))) {\n        parse->function = njs_function(reviver);\n        parse->depth = 0;\n        return njs_json_parse_iterator(vm, parse, &value);\n    }\n    vm->retval = value;\n    return NJS_OK;\n}", "target": 1}
{"code": "static void opl3_panning(int dev, int voice, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\tdevc->voc[voice].panning = value;\n}", "target": 0}
{"code": "SHA256_Init(struct SHA256_CTX * ctx)\n{\n  ctx->count[0] = ctx->count[1] = 0;\n  ctx->state[0] = 0x6A09E667;\n  ctx->state[1] = 0xBB67AE85;\n  ctx->state[2] = 0x3C6EF372;\n  ctx->state[3] = 0xA54FF53A;\n  ctx->state[4] = 0x510E527F;\n  ctx->state[5] = 0x9B05688C;\n  ctx->state[6] = 0x1F83D9AB;\n  ctx->state[7] = 0x5BE0CD19;\n}", "target": 1}
{"code": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}", "target": 1}
{"code": "ins_ctrl_hat(void)\n{\n    if (map_to_exists_mode((char_u *)\"\", LANGMAP, FALSE))\n    {\n\tif (State & LANGMAP)\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    State &= ~LANGMAP;\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_LMAP;\n\t    State |= LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\t    im_set_active(FALSE);\n#endif\n\t}\n    }\n#ifdef HAVE_INPUT_METHOD\n    else\n    {\n\tif (im_get_status())\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_NONE;\n\t    im_set_active(FALSE);\n\t}\n\telse\n\t{\n\t    curbuf->b_p_iminsert = B_IMODE_IM;\n\t    State &= ~LANGMAP;\n\t    im_set_active(TRUE);\n\t}\n    }\n#endif\n    set_iminsert_global();\n    showmode();\n#ifdef FEAT_GUI\n    if (gui.in_use)\n\tgui_update_cursor(TRUE, FALSE);\n#endif\n#if defined(FEAT_KEYMAP)\n    status_redraw_curbuf();\n#endif\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input_indices_in = context->input(0);\n    const Tensor& input_shape_in = context->input(1);\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices_in.shape()),\n                errors::InvalidArgument(\"Input must be a matrix.\"));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape_in.shape()),\n                errors::InvalidArgument(\"Input shape must be a vector.\"));\n    OP_REQUIRES(context,\n                input_indices_in.dim_size(1) == input_shape_in.dim_size(0),\n                errors::InvalidArgument(\n                    \"Input tensor rank must match input shape length.\"));\n    ReshapeSparseTensor<Device>(context, context->input(0), context->input(1),\n                                context->input(2), 0 ,\n                                1 );\n  }", "target": 0}
{"code": "int gdAlphaBlend (int dst, int src) {\n    int src_alpha = gdTrueColorGetAlpha(src);\n    int dst_alpha, alpha, red, green, blue;\n    int src_weight, dst_weight, tot_weight;\n    if( src_alpha == gdAlphaOpaque )\n        return src;\n    dst_alpha = gdTrueColorGetAlpha(dst);\n    if( src_alpha == gdAlphaTransparent )\n        return dst;\n    if( dst_alpha == gdAlphaTransparent )\n        return src;\n    src_weight = gdAlphaTransparent - src_alpha;\n    dst_weight = (gdAlphaTransparent - dst_alpha) * src_alpha / gdAlphaMax;\n    tot_weight = src_weight + dst_weight;\n    alpha = src_alpha * dst_alpha / gdAlphaMax;\n    red = (gdTrueColorGetRed(src) * src_weight\n           + gdTrueColorGetRed(dst) * dst_weight) / tot_weight;\n    green = (gdTrueColorGetGreen(src) * src_weight\n           + gdTrueColorGetGreen(dst) * dst_weight) / tot_weight;\n    blue = (gdTrueColorGetBlue(src) * src_weight\n           + gdTrueColorGetBlue(dst) * dst_weight) / tot_weight;\n    return ((alpha << 24) + (red << 16) + (green << 8) + blue);\n}", "target": 1}
{"code": "setup_secureChannel(void) {\n    TestingPolicy(&dummyPolicy, dummyCertificate, &fCalled, &keySizes);\n    UA_SecureChannel_init(&testChannel, &UA_ConnectionConfig_default);\n    UA_SecureChannel_setSecurityPolicy(&testChannel, &dummyPolicy, &dummyCertificate);\n    testingConnection = createDummyConnection(65535, &sentData);\n    UA_Connection_attachSecureChannel(&testingConnection, &testChannel);\n    testChannel.connection = &testingConnection;\n    testChannel.state = UA_SECURECHANNELSTATE_OPEN;\n}", "target": 1}
{"code": "WifiNetwork::WifiNetwork(const ServiceInfo* service)\n    : WirelessNetwork(service) {\n  encryption_ = service->security;\n  passphrase_ = SafeString(service->passphrase);\n  identity_ = SafeString(service->identity);\n  cert_path_ = SafeString(service->cert_path);\n  type_ = TYPE_WIFI;\n}", "target": 0}
{"code": "cib_tls_close(cib_t * cib)\n{\n    cib_remote_opaque_t *private = cib->variant_opaque;\n    shutdown(private->command.socket, SHUT_RDWR);       \n    shutdown(private->callback.socket, SHUT_RDWR);      \n    close(private->command.socket);\n    close(private->callback.socket);\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (private->command.encrypted) {\n        gnutls_bye(*(private->command.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->command.session));\n        gnutls_free(private->command.session);\n        gnutls_bye(*(private->callback.session), GNUTLS_SHUT_RDWR);\n        gnutls_deinit(*(private->callback.session));\n        gnutls_free(private->callback.session);\n        gnutls_anon_free_client_credentials(anon_cred_c);\n        gnutls_global_deinit();\n    }\n#endif\n    return 0;\n}", "target": 1}
{"code": "SYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned int, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\tif (size > INT_MAX)\n\t\tsize = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov = &iov;\n\tiov.iov_len = size;\n\tiov.iov_base = ubuf;\n\tmsg.msg_name = (struct sockaddr *)&address;\n\tmsg.msg_namelen = sizeof(address);\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, size, flags);\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user(&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}", "target": 1}
{"code": "TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->outputs->size, node->outputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "filter_session_io(struct io *io, int evt, void *arg)\n{\n\tstruct filter_session *fs = arg;\n\tchar *line = NULL;\n\tssize_t len;\n\tlog_trace(TRACE_IO, \"filter session: %p: %s %s\", fs, io_strevent(evt),\n\t    io_strio(io));\n\tswitch (evt) {\n\tcase IO_DATAIN:\n\tnextline:\n\t\tline = io_getline(fs->io, &len);\n\t\tif (line == NULL)\n\t\t\treturn;\n\t\tfilter_data(fs->id, line);\n\t\tgoto nextline;\n\tcase IO_DISCONNECTED:\n\t\tio_free(fs->io);\n\t\tfs->io = NULL;\n\t\tbreak;\n\t}\n}", "target": 1}
{"code": "resolve_list_keys(struct lys_node_list *list, const char *keys_str)\n{\n    int i, len, rc;\n    const char *value;\n    char *s = NULL;\n    struct ly_ctx *ctx = list->module->ctx;\n    for (i = 0; i < list->keys_size; ++i) {\n        assert(keys_str);\n        if (!list->child) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list keys\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if ((value = strpbrk(keys_str, \" \\t\\n\"))) {\n            len = value - keys_str;\n            while (isspace(value[0])) {\n                value++;\n            }\n        } else {\n            len = strlen(keys_str);\n        }\n        rc = lys_getnext_data(lys_node_module((struct lys_node *)list), (struct lys_node *)list, keys_str, len, LYS_LEAF,\n                              (const struct lys_node **)&list->keys[i]);\n        if (rc) {\n            LOGVAL(ctx, LYE_INRESOLV, LY_VLOG_LYS, list, \"list key\", keys_str);\n            return EXIT_FAILURE;\n        }\n        if (check_key(list, i, keys_str, len)) {\n            return -1;\n        }\n        if (lyp_check_status(list->flags, list->module, list->name,\n                             list->keys[i]->flags, list->keys[i]->module, list->keys[i]->name,\n                             (struct lys_node *)list->keys[i])) {\n            return -1;\n        }\n        if (list->keys[i]->dflt) {\n            assert(log_opt == ILO_STORE);\n            log_opt = ILO_LOG;\n            LOGWRN(ctx, \"Default value \\\"%s\\\" in the list key \\\"%s\\\" is ignored. (%s)\", list->keys[i]->dflt,\n                   list->keys[i]->name, s = lys_path((struct lys_node*)list, LYS_PATH_FIRST_PREFIX));\n            log_opt = ILO_STORE;\n            free(s);\n        }\n        while (value && isspace(value[0])) {\n            value++;\n        }\n        keys_str = value;\n    }\n    return EXIT_SUCCESS;\n}", "target": 1}
{"code": "LIR_Opr LIRGenerator::result_register_for(ValueType* type, bool callee) {\n  LIR_Opr opr;\n  switch (type->tag()) {\n    case intTag:     opr = FrameMap::rax_opr;          break;\n    case objectTag:  opr = FrameMap::rax_oop_opr;      break;\n    case longTag:    opr = FrameMap::long0_opr;        break;\n    case floatTag:   opr = UseSSE >= 1 ? FrameMap::xmm0_float_opr  : FrameMap::fpu0_float_opr;  break;\n    case doubleTag:  opr = UseSSE >= 2 ? FrameMap::xmm0_double_opr : FrameMap::fpu0_double_opr;  break;\n    case addressTag:\n    default: ShouldNotReachHere(); return LIR_OprFact::illegalOpr;\n  }\n  assert(opr->type_field() == as_OprType(as_BasicType(type)), \"type mismatch\");\n  return opr;\n}", "target": 0}
{"code": "PGTYPESdate_from_asc(char *str, char **endptr)\n{\n\tdate\t\tdDate;\n\tfsec_t\t\tfsec;\n\tstruct tm\ttt,\n\t\t\t   *tm = &tt;\n\tint\t\t\tdtype;\n\tint\t\t\tnf;\n\tchar\t   *field[MAXDATEFIELDS];\n\tint\t\t\tftype[MAXDATEFIELDS];\n\tchar\t\tlowstr[MAXDATELEN + 1];\n\tchar\t   *realptr;\n\tchar\t  **ptr = (endptr != NULL) ? endptr : &realptr;\n\tbool\t\tEuroDates = FALSE;\n\terrno = 0;\n\tif (strlen(str) >= sizeof(lowstr))\n\t{\n\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\treturn INT_MIN;\n\t}\n\tif (ParseDateTime(str, lowstr, field, ftype, &nf, ptr) != 0 ||\n\t\tDecodeDateTime(field, ftype, nf, &dtype, tm, &fsec, EuroDates) != 0)\n\t{\n\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\treturn INT_MIN;\n\t}\n\tswitch (dtype)\n\t{\n\t\tcase DTK_DATE:\n\t\t\tbreak;\n\t\tcase DTK_EPOCH:\n\t\t\tif (GetEpochTime(tm) < 0)\n\t\t\t{\n\t\t\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\t\t\treturn INT_MIN;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terrno = PGTYPES_DATE_BAD_DATE;\n\t\t\treturn INT_MIN;\n\t}\n\tdDate = (date2j(tm->tm_year, tm->tm_mon, tm->tm_mday) - date2j(2000, 1, 1));\n\treturn dDate;\n}", "target": 1}
{"code": "static __u8 *nci_extract_rf_params_nfca_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfca_poll *nfca_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfca_poll->sens_res = __le16_to_cpu(*((__u16 *)data));\n\tdata += 2;\n\tnfca_poll->nfcid1_len = *data++;\n\tpr_debug(\"sens_res 0x%x, nfcid1_len %d\\n\",\n\t\t nfca_poll->sens_res, nfca_poll->nfcid1_len);\n\tmemcpy(nfca_poll->nfcid1, data, nfca_poll->nfcid1_len);\n\tdata += nfca_poll->nfcid1_len;\n\tnfca_poll->sel_res_len = *data++;\n\tif (nfca_poll->sel_res_len != 0)\n\t\tnfca_poll->sel_res = *data++;\n\tpr_debug(\"sel_res_len %d, sel_res 0x%x\\n\",\n\t\t nfca_poll->sel_res_len,\n\t\t nfca_poll->sel_res);\n\treturn data;\n}", "target": 1}
{"code": "struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev)\n{\n\tstruct nfc_llcp_local *local;\n\tlist_for_each_entry(local, &llcp_devices, list)\n\t\tif (local->dev == dev)\n\t\t\treturn local;\n\tpr_debug(\"No device found\\n\");\n\treturn NULL;\n}", "target": 1}
{"code": " bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) {\n  if (render_view_host_->IsSwappedOut()) {\n    if (!SwappedOutMessages::CanHandleWhileSwappedOut(msg)) {\n      if (msg.is_sync()) {\n        IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg);\n        reply->set_reply_error();\n        Send(reply);\n      }\n      return true;\n    }\n  }\n   if (delegate_->OnMessageReceived(this, msg))\n     return true;\n  if (cross_process_frame_connector_ &&\n      cross_process_frame_connector_->OnMessageReceived(msg))\n    return true;\n  bool handled = true;\n  bool msg_is_ok = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(RenderFrameHostImpl, msg, msg_is_ok)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoadForFrame,\n                        OnDidStartProvisionalLoadForFrame)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError,\n                        OnDidFailProvisionalLoadWithError)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidRedirectProvisionalLoad,\n                        OnDidRedirectProvisionalLoad)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError,\n                        OnDidFailLoadWithError)\n    IPC_MESSAGE_HANDLER_GENERIC(FrameHostMsg_DidCommitProvisionalLoad,\n                                OnNavigate(msg))\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu)\n    IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse,\n                        OnJavaScriptExecuteResponse)\n  IPC_END_MESSAGE_MAP_EX()\n  if (!msg_is_ok) {\n    RecordAction(base::UserMetricsAction(\"BadMessageTerminate_RFH\"));\n    GetProcess()->ReceivedBadMessage();\n  }\n  return handled;\n}", "target": 0}
{"code": "TEST_P(ProxyProtocolTest, V2LocalConnectionFilterState) {\n  constexpr uint8_t buffer[] = {0x0d, 0x0a, 0x0d, 0x0a, 0x00, 0x0d, 0x0a, 0x51, 0x55, 0x49, 0x54,\n                                0x0a, 0x20, 0x00, 0x00, 0x07, 0x00, 0x00, 0x04, 0x0a, 0x0b, 0x0c,\n                                0x0d, 'm',  'o',  'r',  'e',  'd',  'a',  't',  'a'};\n  envoy::extensions::filters::listener::proxy_protocol::v3::ProxyProtocol proto_config;\n  connect(true, &proto_config);\n  write(buffer, sizeof(buffer));\n  expectData(\"moredata\");\n  auto& filter_state = server_connection_->streamInfo().filterState();\n  const auto& proxy_proto_data = filter_state\n                                     ->getDataReadOnly<Network::ProxyProtocolFilterState>(\n                                         Network::ProxyProtocolFilterState::key())\n                                     ->value();\n  if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n      Envoy::Network::Address::IpVersion::v6) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"::1\");\n  } else if (server_connection_->connectionInfoProvider().remoteAddress()->ip()->version() ==\n             Envoy::Network::Address::IpVersion::v4) {\n    EXPECT_EQ(proxy_proto_data.dst_addr_->ip()->addressAsString(), \"127.0.0.1\");\n  }\n  EXPECT_FALSE(server_connection_->connectionInfoProvider().localAddressRestored());\n  disconnect();\n}", "target": 0}
{"code": "kvp_respond_to_host(char *key, char *value, int error)\n{\n\tstruct hv_kvp_msg  *kvp_msg;\n\tstruct hv_kvp_msg_enumerate  *kvp_data;\n\tchar\t*key_name;\n\tstruct icmsg_hdr *icmsghdrp;\n\tint\tkeylen, valuelen;\n\tu32\tbuf_len;\n\tstruct vmbus_channel *channel;\n\tu64\treq_id;\n\tif (!kvp_transaction.active) {\n\t\tpr_warn(\"KVP: Transaction not active\\n\");\n\t\treturn;\n\t}\n\tbuf_len = kvp_transaction.recv_len;\n\tchannel = kvp_transaction.recv_channel;\n\treq_id = kvp_transaction.recv_req_id;\n\tkvp_transaction.active = false;\n\tif (channel->onchannel_callback == NULL)\n\t\treturn;\n\ticmsghdrp = (struct icmsg_hdr *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr)];\n\tkvp_msg = (struct hv_kvp_msg *)\n\t\t\t&recv_buffer[sizeof(struct vmbuspipe_hdr) +\n\t\t\tsizeof(struct icmsg_hdr)];\n\tkvp_data = &kvp_msg->kvp_data;\n\tkey_name = key;\n\tif (error) {\n\t\ticmsghdrp->status = HV_E_FAIL;\n\t\tgoto response_done;\n\t}\n\tkeylen = utf8s_to_utf16s(key_name, strlen(key_name),\n\t\t\t\t(wchar_t *)kvp_data->data.key);\n\tkvp_data->data.key_size = 2*(keylen + 1); \n\tvaluelen = utf8s_to_utf16s(value, strlen(value),\n\t\t\t\t(wchar_t *)kvp_data->data.value);\n\tkvp_data->data.value_size = 2*(valuelen + 1); \n\tkvp_data->data.value_type = REG_SZ; \n\ticmsghdrp->status = HV_S_OK;\nresponse_done:\n\ticmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE;\n\tvmbus_sendpacket(channel, recv_buffer, buf_len, req_id,\n\t\t\t\tVM_PKT_DATA_INBAND, 0);\n}", "target": 1}
{"code": "  bool ms_verify_authorizer(Connection *con, int peer_type, int protocol,\n                            bufferlist& authorizer, bufferlist& authorizer_reply,\n                            bool& isvalid, CryptoKey& session_key) override {\n    isvalid = true;\n    return true;\n  }", "target": 1}
{"code": "void PDPClient::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n#if HAVE_SECURITY\n    if (mp_RTPSParticipant->is_secure())\n    {\n        eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());\n        for (auto& svr : mp_builtin->m_DiscoveryServers)\n        {\n            if (data_matches_with_prefix(svr.guidPrefix, pdata))\n            {\n                if (nullptr == svr.proxy)\n                {\n                    svr.proxy = get_participant_proxy_data(svr.guidPrefix);\n                }\n                match_pdp_reader_nts_(svr, pdata.m_guid.guidPrefix);\n                match_pdp_writer_nts_(svr, pdata.m_guid.guidPrefix);\n                break;\n            }\n        }\n    }\n#endif \n    perform_builtin_endpoints_matching(pdata);\n}", "target": 1}
{"code": "static void pdfobj_flag(struct pdf_struct *pdf, struct pdf_obj *obj, enum pdf_flag flag)\n{\n    const char *s= \"\";\n    pdf->flags |= 1 << flag;\n    if (!cli_debug_flag)\n\treturn;\n    switch (flag) {\n\tcase UNTERMINATED_OBJ_DICT:\n\t    s = \"dictionary not terminated\";\n\t    break;\n\tcase ESCAPED_COMMON_PDFNAME:\n\t    s = \"escaped common pdfname\";\n\t    break;\n\tcase BAD_STREAM_FILTERS:\n\t    s = \"duplicate stream filters\";\n\t    break;\n\tcase BAD_PDF_VERSION:\n\t    s = \"bad pdf version\";\n\t    break;\n\tcase BAD_PDF_HEADERPOS:\n\t    s = \"bad pdf header position\";\n\t    break;\n\tcase BAD_PDF_TRAILER:\n\t    s = \"bad pdf trailer\";\n\t    break;\n\tcase BAD_PDF_TOOMANYOBJS:\n\t    s = \"too many pdf objs\";\n\t    break;\n\tcase BAD_FLATE:\n\t    s = \"bad deflate stream\";\n\t    break;\n\tcase BAD_FLATESTART:\n\t    s = \"bad deflate stream start\";\n\t    break;\n\tcase BAD_STREAMSTART:\n\t    s = \"bad stream start\";\n\t    break;\n\tcase UNKNOWN_FILTER:\n\t    s = \"unknown filter used\";\n\t    break;\n\tcase BAD_ASCIIDECODE:\n\t    s = \"bad ASCII decode\";\n\t    break;\n\tcase HEX_JAVASCRIPT:\n\t    s = \"hex javascript\";\n\t    break;\n\tcase BAD_INDOBJ:\n\t    s = \"referencing nonexistent obj\";\n\t    break;\n\tcase HAS_OPENACTION:\n\t    s = \"has /OpenAction\";\n\t    break;\n\tcase HAS_LAUNCHACTION:\n\t    s = \"has /LaunchAction\";\n\t    break;\n\tcase BAD_STREAMLEN:\n\t    s = \"bad /Length, too small\";\n\t    break;\n\tcase ENCRYPTED_PDF:\n\t    s = \"PDF is encrypted\";\n\t    break;\n\tcase LINEARIZED_PDF:\n\t    s = \"linearized PDF\";\n\t    break;\n\tcase MANY_FILTERS:\n\t    s = \"more than 2 filters per obj\";\n\t    break;\n\tcase DECRYPTABLE_PDF:\n\t    s = \"decryptable PDF\";\n\t    break;\n    }\n    cli_dbgmsg(\"cli_pdf: %s flagged in object %u %u\\n\", s, obj->id>>8, obj->id&0xff);\n}", "target": 0}
{"code": "static void __nfs4_close(struct path *path, struct nfs4_state *state, mode_t mode, int wait)\n{\n\tstruct nfs4_state_owner *owner = state->owner;\n\tint call_close = 0;\n\tint newstate;\n\tatomic_inc(&owner->so_count);\n\tspin_lock(&owner->so_lock);\n\tswitch (mode & (FMODE_READ | FMODE_WRITE)) {\n\t\tcase FMODE_READ:\n\t\t\tstate->n_rdonly--;\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tstate->n_wronly--;\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tstate->n_rdwr--;\n\t}\n\tnewstate = FMODE_READ|FMODE_WRITE;\n\tif (state->n_rdwr == 0) {\n\t\tif (state->n_rdonly == 0) {\n\t\t\tnewstate &= ~FMODE_READ;\n\t\t\tcall_close |= test_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (state->n_wronly == 0) {\n\t\t\tnewstate &= ~FMODE_WRITE;\n\t\t\tcall_close |= test_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tcall_close |= test_bit(NFS_O_RDWR_STATE, &state->flags);\n\t\t}\n\t\tif (newstate == 0)\n\t\t\tclear_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tnfs4_state_set_mode_locked(state, newstate);\n\tspin_unlock(&owner->so_lock);\n\tif (!call_close) {\n\t\tnfs4_put_open_state(state);\n\t\tnfs4_put_state_owner(owner);\n\t} else\n\t\tnfs4_do_close(path, state, wait);\n}", "target": 1}
{"code": "bool IsSupported(const tensorflow::DataType data_type) {\n  switch (data_type) {\n    case tensorflow::DT_FLOAT:\n    case tensorflow::DT_DOUBLE:\n    case tensorflow::DT_INT32:\n    case tensorflow::DT_UINT8:\n    case tensorflow::DT_INT16:\n    case tensorflow::DT_INT8:\n    case tensorflow::DT_STRING:\n    case tensorflow::DT_COMPLEX64:\n    case tensorflow::DT_INT64:\n    case tensorflow::DT_BOOL:\n    case tensorflow::DT_QINT8:\n    case tensorflow::DT_QUINT8:\n    case tensorflow::DT_QINT32:\n    case tensorflow::DT_BFLOAT16:\n    case tensorflow::DT_QINT16:\n    case tensorflow::DT_QUINT16:\n    case tensorflow::DT_UINT16:\n    case tensorflow::DT_COMPLEX128:\n    case tensorflow::DT_HALF:\n    case tensorflow::DT_UINT32:\n    case tensorflow::DT_UINT64:\n    case tensorflow::DT_FLOAT8_E5M2:\n    case tensorflow::DT_FLOAT8_E4M3FN:\n    case tensorflow::DT_INT4:\n    case tensorflow::DT_UINT4:\n      return true;\n    default:\n      return false;\n  }\n}", "target": 0}
{"code": "void nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\tnego->state = NEGO_STATE_FAIL;\n}", "target": 1}
{"code": "acc_ctx_cont(OM_uint32 *minstat,\n\t     gss_buffer_t buf,\n\t     gss_ctx_id_t *ctx,\n\t     gss_buffer_t *responseToken,\n\t     gss_buffer_t *mechListMIC,\n\t     OM_uint32 *negState,\n\t     send_token_flag *return_token)\n{\n\tOM_uint32 ret, tmpmin;\n\tgss_OID supportedMech;\n\tspnego_gss_ctx_id_t sc;\n\tunsigned int len;\n\tunsigned char *ptr, *bufstart;\n\tsc = (spnego_gss_ctx_id_t)*ctx;\n\tret = GSS_S_DEFECTIVE_TOKEN;\n\t*negState = REJECT;\n\t*minstat = 0;\n\tsupportedMech = GSS_C_NO_OID;\n\t*return_token = ERROR_TOKEN_SEND;\n\t*responseToken = *mechListMIC = GSS_C_NO_BUFFER;\n\tptr = bufstart = buf->value;\n#define REMAIN (buf->length - (ptr - bufstart))\n\tif (REMAIN > INT_MAX)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tif (*ptr == HEADER_ID) {\n\t\tret = g_verify_token_header(gss_mech_spnego,\n\t\t\t\t\t    &len, &ptr, 0, REMAIN);\n\t\tif (ret) {\n\t\t\t*minstat = ret;\n\t\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t\t}\n\t}\n\tif (*ptr != (CONTEXT | 0x01)) {\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\t}\n\tret = get_negTokenResp(minstat, ptr, REMAIN,\n\t\t\t       negState, &supportedMech,\n\t\t\t       responseToken, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\tif (*responseToken == GSS_C_NO_BUFFER &&\n\t    *mechListMIC == GSS_C_NO_BUFFER) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tret = GSS_S_DEFECTIVE_TOKEN;\n\t\tgoto cleanup;\n\t}\n\tsc->firstpass = 0;\n\t*negState = ACCEPT_INCOMPLETE;\n\t*return_token = CONT_TOKEN_SEND;\ncleanup:\n\tif (supportedMech != GSS_C_NO_OID) {\n\t\tgeneric_gss_release_oid(&tmpmin, &supportedMech);\n\t}\n\treturn ret;\n#undef REMAIN\n}", "target": 1}
{"code": "int ovl_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint err;\n\tstruct dentry *upperdentry;\n\terr = ovl_want_write(dentry);\n\tif (err)\n\t\tgoto out;\n\tupperdentry = ovl_dentry_upper(dentry);\n\tif (upperdentry) {\n\t\tmutex_lock(&upperdentry->d_inode->i_mutex);\n\t\terr = notify_change(upperdentry, attr, NULL);\n\t\tmutex_unlock(&upperdentry->d_inode->i_mutex);\n\t} else {\n\t\terr = ovl_copy_up_last(dentry, attr, false);\n\t}\n\tovl_drop_write(dentry);\nout:\n\treturn err;\n}", "target": 1}
{"code": "void* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\tif (!handle)\n\t\treturn NULL;\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\treturn pointer;\n}", "target": 1}
{"code": "update_request_allow_commands (UpdateRequest *request, gboolean allowCommands)\n{\n\trequest->allowCommands = allowCommands;\n}", "target": 0}
{"code": "header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->headindex < psf->headend)\n\t\t{\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\t} ;\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\tptr [k] = 0 ;\n\treturn k ;\n} ", "target": 1}
{"code": "void WebContentsImpl::SetParentNativeViewAccessible(\ngfx::NativeViewAccessible accessible_parent) {\n  accessible_parent_ = accessible_parent;\n  if (GetRenderViewHost())\n    GetRenderViewHostImpl()->SetParentNativeViewAccessible(accessible_parent);\n}", "target": 0}
{"code": "bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)\n{\n  if ((afi == AFI_IP6 && *safi == BGP_SAFI_VPNV4)\n      || (afi == AFI_IP && *safi == BGP_SAFI_VPNV6))\n    {\n      zlog_warn (\"Invalid afi/safi combination (%u/%u)\", afi, *safi);\n      return 0;\n    }\n  switch (afi)\n    {\n      case AFI_IP:\n#ifdef HAVE_IPV6\n      case AFI_IP6:\n#endif\n        switch (*safi)\n          {\n            case BGP_SAFI_VPNV4:\n            case BGP_SAFI_VPNV6:\n              *safi = SAFI_MPLS_VPN;\n            case SAFI_UNICAST:\n            case SAFI_MULTICAST:\n            case SAFI_MPLS_VPN:\n              return 1;\n          }\n    }\n  zlog_debug (\"unknown afi/safi (%u/%u)\", afi, *safi);\n  return 0;\n}", "target": 0}
{"code": "static inline int tcp_in_quickack_mode(const struct sock *sk)\n{\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\treturn icsk->icsk_ack.quick && !icsk->icsk_ack.pingpong;\n}", "target": 0}
{"code": "static int _FVMenuClose(FontView *fv) {\n    int i;\n    SplineFont *sf = fv->b.cidmaster?fv->b.cidmaster:fv->b.sf;\n    if ( !SFCloseAllInstrs(fv->b.sf) )\nreturn( false );\n    if ( fv->b.nextsame!=NULL || fv->b.sf->fv!=&fv->b ) {\n    } else if ( warn_script_unsaved && fv->script_unsaved && \n                AskScriptChanged()==2 ) {\n        return false;\n    } else if ( SFAnyChanged(sf) ) {\n\ti = AskChanged(fv->b.sf);\n\tif ( i==2 )\t\nreturn( false );\n\tif ( i==0 && !_FVMenuSave(fv))\t\t\nreturn(false);\n\telse\n\t    SFClearAutoSave(sf);\t\t\n    }\n    _FVCloseWindows(fv);\n    if ( sf->filename!=NULL )\n\tRecentFilesRemember(sf->filename);\n    else if ( sf->origname!=NULL )\n\tRecentFilesRemember(sf->origname);\n    GDrawDestroyWindow(fv->gw);\nreturn( true );\n}", "target": 0}
{"code": "static bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)\n{\n    uint32_t size;\n    pb_bytes_array_t *bdest;\n    if (!pb_decode_varint32(stream, &size))\n        return false;\n    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)\n    {\n#ifndef PB_ENABLE_MALLOC\n        PB_RETURN_ERROR(stream, \"no malloc support\");\n#else\n        if (!allocate_field(stream, dest, PB_BYTES_ARRAY_T_ALLOCSIZE(size), 1))\n            return false;\n        bdest = *(pb_bytes_array_t**)dest;\n#endif\n    }\n    else\n    {\n        if (PB_BYTES_ARRAY_T_ALLOCSIZE(size) > field->data_size)\n            PB_RETURN_ERROR(stream, \"bytes overflow\");\n        bdest = (pb_bytes_array_t*)dest;\n    }\n    if (size > PB_SIZE_MAX)\n    {\n        PB_RETURN_ERROR(stream, \"bytes overflow\");\n    }\n    bdest->size = (pb_size_t)size;\n    return pb_read(stream, bdest->bytes, size);\n}", "target": 1}
{"code": "ikev2_sa_print(netdissect_options *ndo, u_char tpay,\n\t\tconst struct isakmp_gen *ext1,\n\t\tu_int osa_length, const u_char *ep,\n\t\tuint32_t phase _U_, uint32_t doi _U_,\n\t\tuint32_t proto _U_, int depth)\n{\n\tconst struct isakmp_gen *ext;\n\tstruct isakmp_gen e;\n\tu_int sa_length;\n\tconst u_char *cp;\n\tint i;\n\tint pcount;\n\tu_char np;\n\tu_int item_len;\n\tND_TCHECK(*ext1);\n\tUNALIGNED_MEMCPY(&e, ext1, sizeof(e));\n\tikev2_pay_print(ndo, \"sa\", e.critical);\n\tosa_length= ntohs(e.len);\n\tsa_length = osa_length - 4;\n\tND_PRINT((ndo,\" len=%d\", sa_length));\n\tcp = (const u_char *)(ext1 + 1);\n\tpcount = 0;\n\tfor (np = ISAKMP_NPTYPE_P; np != 0; np = e.np) {\n\t\tpcount++;\n\t\text = (const struct isakmp_gen *)cp;\n\t\tif (sa_length < sizeof(*ext))\n\t\t\tgoto toolong;\n\t\tND_TCHECK(*ext);\n\t\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\t\titem_len = ntohs(e.len);\n\t\tif (item_len <= 4)\n\t\t\tgoto trunc;\n\t\tif (sa_length < item_len)\n\t\t\tgoto toolong;\n\t\tND_TCHECK2(*cp, item_len);\n\t\tdepth++;\n\t\tND_PRINT((ndo,\"\\n\"));\n\t\tfor (i = 0; i < depth; i++)\n\t\t\tND_PRINT((ndo,\"    \"));\n\t\tND_PRINT((ndo,\"(\"));\n\t\tif (np == ISAKMP_NPTYPE_P) {\n\t\t\tcp = ikev2_p_print(ndo, np, pcount, ext, item_len,\n\t\t\t\t\t   ep, depth);\n\t\t\tif (cp == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s\", NPSTR(np)));\n\t\t\tcp += item_len;\n\t\t}\n\t\tND_PRINT((ndo,\")\"));\n\t\tdepth--;\n\t\tsa_length -= item_len;\n\t}\n\treturn cp;\ntoolong:\n\tcp += sa_length;\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(tpay)));\n\treturn NULL;\n}", "target": 1}
{"code": "static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_akcipher rakcipher;\n\tstrlcpy(rakcipher.type, \"akcipher\", sizeof(rakcipher.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,\n\t\t    sizeof(struct crypto_report_akcipher), &rakcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "TfLiteStatus Subgraph::CheckInputAndOutputForOverlap(const int* input_indices,\n                                                     int num_inputs,\n                                                     const int* output_indices,\n                                                     int num_outputs) {\n  for (int i = 0; i < num_inputs; i++) {\n    for (int j = 0; j < num_outputs; j++) {\n      if (input_indices[i] == output_indices[j]) {\n        ReportError(\"Tensor %d is both input %d and output %d\\n\",\n                    input_indices[i], i, j);\n        consistent_ = false;\n        return kTfLiteError;\n      }\n    }\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "void RootWindow::RemoveRootWindowObserver(RootWindowObserver* observer) {\n  observers_.RemoveObserver(observer);\n}", "target": 0}
{"code": "      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,\n                                const std::string& emsa) :\n         PK_Ops::Signature_with_EMSA(emsa),\n         m_group(ecdsa.domain()),\n         m_x(ecdsa.private_value())\n         {\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n         m_rfc6979_hash = hash_for_emsa(emsa);\n#endif\n         }", "target": 1}
{"code": "int BUFFER_append(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)\n{\n    int result;\n    if ( (handle1 == NULL) || (handle2 == NULL) || (handle1 == handle2) )\n    {\n        result = MU_FAILURE;\n    }\n    else\n    {\n        BUFFER* b1 = (BUFFER*)handle1;\n        BUFFER* b2 = (BUFFER*)handle2;\n        if (b1->buffer == NULL)\n        {\n            result = MU_FAILURE;\n        }\n        else if (b2->buffer == NULL)\n        {\n            result = MU_FAILURE;\n        }\n        else\n        {\n            if (b2->size ==0)\n            {\n                result = 0;\n            }\n            else\n            {\n                unsigned char* temp = (unsigned char*)realloc(b1->buffer, b1->size + b2->size);\n                if (temp == NULL)\n                {\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    b1->buffer = temp;\n                    (void)memcpy(&b1->buffer[b1->size], b2->buffer, b2->size);\n                    b1->size += b2->size;\n                    result = 0;\n                }\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "void HeaderMapImpl::addSize(uint64_t size) {\n  if (cached_byte_size_.has_value()) {\n    cached_byte_size_.value() += size;\n  }\n}", "target": 0}
{"code": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\treturn task;\n}", "target": 1}
{"code": "static struct mobj *alloc_ta_mem(size_t size)\n{\n#ifdef CFG_PAGED_USER_TA\n\treturn mobj_paged_alloc(size);\n#else\n\tstruct mobj *mobj = mobj_mm_alloc(mobj_sec_ddr, size, &tee_mm_sec_ddr);\n\tif (mobj)\n\t\tmemset(mobj_get_va(mobj, 0), 0, size);\n\treturn mobj;\n#endif\n}", "target": 1}
{"code": "static NETWORK_INTERFACE_DESCRIPTION* create_network_interface_description(struct ifreq *ifr, NETWORK_INTERFACE_DESCRIPTION* previous_nid)\n{\n    NETWORK_INTERFACE_DESCRIPTION* result;\n    if ((result = (NETWORK_INTERFACE_DESCRIPTION*)malloc(sizeof(NETWORK_INTERFACE_DESCRIPTION))) == NULL)\n    {\n        LogError(\"Failed allocating NETWORK_INTERFACE_DESCRIPTION\");\n    }\n    else if ((result->name = (char*)malloc(sizeof(char) * (strlen(ifr->ifr_name) + 1))) == NULL)\n    {\n        LogError(\"failed setting interface description name (malloc failed)\");\n        destroy_network_interface_descriptions(result);\n        result = NULL;\n    }\n    else\n    {\n        strcpy(result->name, ifr->ifr_name);\n        char* ip_address;\n        unsigned char* mac = (unsigned char*)ifr->ifr_hwaddr.sa_data;\n        if ((result->mac_address = (char*)malloc(sizeof(char) * MAC_ADDRESS_STRING_LENGTH)) == NULL)\n        {\n            LogError(\"failed formatting mac address (malloc failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if (sprintf(result->mac_address, \"%02X:%02X:%02X:%02X:%02X:%02X\", mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]) <= 0)\n        {\n            LogError(\"failed formatting mac address (sprintf failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((ip_address = inet_ntoa(((struct sockaddr_in*)&ifr->ifr_addr)->sin_addr)) == NULL)\n        {\n            LogError(\"failed setting the ip address (inet_ntoa failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else if ((result->ip_address = (char*)malloc(sizeof(char) * (strlen(ip_address) + 1))) == NULL)\n        {\n            LogError(\"failed setting the ip address (malloc failed)\");\n            destroy_network_interface_descriptions(result);\n            result = NULL;\n        }\n        else\n        {\n            strcpy(result->ip_address, ip_address);\n            result->next = NULL;\n            if (previous_nid != NULL)\n            {\n                previous_nid->next = result;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "static inline struct inode *vfs_select_inode(struct dentry *dentry,\n\t\t\t\t\t     unsigned open_flags)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tif (inode && unlikely(dentry->d_flags & DCACHE_OP_SELECT_INODE))\n\t\tinode = dentry->d_op->d_select_inode(dentry, open_flags);\n\treturn inode;\n}", "target": 0}
{"code": "static int aac_compat_ioctl(struct scsi_device *sdev, int cmd, void __user *arg)\n{\n\tstruct aac_dev *dev = (struct aac_dev *)sdev->host->hostdata;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\treturn aac_compat_do_ioctl(dev, cmd, (unsigned long)arg);\n}", "target": 0}
{"code": "snmp_ber_encode_null(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  (*out_len)++;\n  *out-- = 0x00;\n  out = snmp_ber_encode_type(out, out_len, type);\n  return out;\n}", "target": 1}
{"code": "static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)\n{\n\tif (timr->it.mmtimer.clock == TIMER_OFF) {\n\t\tcur_setting->it_interval.tv_nsec = 0;\n\t\tcur_setting->it_interval.tv_sec = 0;\n\t\tcur_setting->it_value.tv_nsec = 0;\n\t\tcur_setting->it_value.tv_sec =0;\n\t\treturn;\n\t}\n\tns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);\n\tns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);\n\treturn;\n}", "target": 1}
{"code": "pci_populate_msicap(struct msicap *msicap, int msgnum, int nextptr)\n{\n\tint mmc;\n\tassert((msgnum & (msgnum - 1)) == 0 && msgnum >= 1 && msgnum <= 32);\n\tmmc = ffs(msgnum) - 1;\n\tbzero(msicap, sizeof(struct msicap));\n\tmsicap->capid = PCIY_MSI;\n\tmsicap->nextptr = nextptr;\n\tmsicap->msgctrl = PCIM_MSICTRL_64BIT | (mmc << 1);\n}", "target": 1}
{"code": "ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);\n\tif (!bh)\n\t\tgoto cleanup;\n\tea_bdebug(bh, \"b_count=%d, refcount=%d\",\n\t\tatomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));\n\tif (ext4_xattr_check_block(inode, bh)) {\nbad_block:\n\t\tEXT4_ERROR_INODE(inode, \"bad block %llu\",\n\t\t\t\t EXT4_I(inode)->i_file_acl);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\text4_xattr_cache_insert(ext4_mb_cache, bh);\n\tentry = BFIRST(bh);\n\terror = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);\n\tif (error == -EFSCORRUPTED)\n\t\tgoto bad_block;\n\tif (error)\n\t\tgoto cleanup;\n\tsize = le32_to_cpu(entry->e_value_size);\n\tif (buffer) {\n\t\terror = -ERANGE;\n\t\tif (size > buffer_size)\n\t\t\tgoto cleanup;\n\t\tmemcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),\n\t\t       size);\n\t}\n\terror = size;\ncleanup:\n\tbrelse(bh);\n\treturn error;\n}", "target": 1}
{"code": "static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) {\n\twhile (begin && isspace ((ut8)str[*begin])) {\n\t\t++(*begin);\n\t}\n\tif (!str[*begin]) {                \n\t\t*end = *begin;\n\t\treturn TT_EOF;\n\t} else if (isalpha ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {\n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_WORD;\n\t} else if (isdigit ((ut8)str[*begin])) {   \n\t\t*end = *begin;\n\t\twhile (end && isalnum ((ut8)str[*end])) {     \n\t\t\t++(*end);\n\t\t}\n\t\treturn TT_NUMBER;\n\t} else {                             \n\t\t*end = *begin + 1;\n\t\treturn TT_SPECIAL;\n\t}\n}", "target": 1}
{"code": "void ast_dns_resolver_completed(struct ast_dns_query *query)\n{\n\tsort_result(ast_dns_query_get_rr_type(query), query->result);\n\tquery->callback(query);\n}", "target": 1}
{"code": "void HTMLMediaElement::UpdatePlaybackRate() {\n  if (web_media_player_ && PotentiallyPlaying())\n    GetWebMediaPlayer()->SetRate(playbackRate());\n}", "target": 0}
{"code": "static bool vgacon_scroll(struct vc_data *c, unsigned int t, unsigned int b,\n\t\tenum con_scroll dir, unsigned int lines)\n{\n\tunsigned long oldo;\n\tunsigned int delta;\n\tif (t || b != c->vc_rows || vga_is_gfx || c->vc_mode != KD_TEXT)\n\t\treturn false;\n\tif (!vga_hardscroll_enabled || lines >= c->vc_rows / 2)\n\t\treturn false;\n\tvgacon_restore_screen(c);\n\toldo = c->vc_origin;\n\tdelta = lines * c->vc_size_row;\n\tif (dir == SM_UP) {\n\t\tvgacon_scrollback_update(c, t, lines);\n\t\tif (c->vc_scr_end + delta >= vga_vram_end) {\n\t\t\tscr_memcpyw((u16 *) vga_vram_base,\n\t\t\t\t    (u16 *) (oldo + delta),\n\t\t\t\t    c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_base;\n\t\t\tvga_rolled_over = oldo - vga_vram_base;\n\t\t} else\n\t\t\tc->vc_origin += delta;\n\t\tscr_memsetw((u16 *) (c->vc_origin + c->vc_screenbuf_size -\n\t\t\t\t     delta), c->vc_video_erase_char,\n\t\t\t    delta);\n\t} else {\n\t\tif (oldo - delta < vga_vram_base) {\n\t\t\tscr_memmovew((u16 *) (vga_vram_end -\n\t\t\t\t\t      c->vc_screenbuf_size +\n\t\t\t\t\t      delta), (u16 *) oldo,\n\t\t\t\t     c->vc_screenbuf_size - delta);\n\t\t\tc->vc_origin = vga_vram_end - c->vc_screenbuf_size;\n\t\t\tvga_rolled_over = 0;\n\t\t} else\n\t\t\tc->vc_origin -= delta;\n\t\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\t\tscr_memsetw((u16 *) (c->vc_origin), c->vc_video_erase_char,\n\t\t\t    delta);\n\t}\n\tc->vc_scr_end = c->vc_origin + c->vc_screenbuf_size;\n\tc->vc_visible_origin = c->vc_origin;\n\tvga_set_mem_top(c);\n\tc->vc_pos = (c->vc_pos - oldo) + c->vc_origin;\n\treturn true;\n}", "target": 1}
{"code": "static bool bt_att_disc_cancel(struct bt_att *att, unsigned int id)\n{\n\tstruct att_send_op *op;\n\top = queue_find(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_find(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\top = queue_find(att->write_queue, match_op_id, UINT_TO_PTR(id));\ndone:\n\tif (!op)\n\t\treturn false;\n\tcancel_att_send_op(op);\n\treturn true;\n}", "target": 0}
{"code": "CSecurityTLS::CSecurityTLS(bool _anon) : session(0), anon_cred(0),\n\t\t\t\t\t\t anon(_anon), fis(0), fos(0)\n{\n  cafile = X509CA.getData();\n  crlfile = X509CRL.getData();\n  if (gnutls_global_init() != GNUTLS_E_SUCCESS)\n    throw AuthFailureException(\"gnutls_global_init failed\");\n}", "target": 0}
{"code": "segment_end (Elf_Internal_Phdr *segment, bfd_vma start)\n{\n  return start + segment_size (segment);\n}", "target": 0}
{"code": "static char* umocktypes_stringify_bool_ptr(const bool** value)\n{\n    char* result;\n    result = (char*)my_gballoc_malloc(8);\n    if (result != NULL)\n    {\n        if (*value == NULL)\n        {\n            (void)strcpy(result, \"{NULL}\");\n        }\n        else if (*(*value) == true)\n        {\n            (void)strcpy(result, \"{true}\");\n        }\n        else\n        {\n            (void)strcpy(result, \"{false}\");\n        }\n    }\n    return result;\n}", "target": 0}
{"code": "  absl::optional<uint64_t> evaluate(const Network::Address::Instance*,\n                                    const RequestHeaderMap& headers,\n                                    const HashPolicy::AddCookieCallback add_cookie,\n                                    const StreamInfo::FilterStateSharedPtr) const override {\n    absl::optional<uint64_t> hash;\n    std::string value = Utility::parseCookieValue(headers, key_);\n    if (value.empty() && ttl_.has_value()) {\n      value = add_cookie(key_, path_, ttl_.value(), attributes_);\n      hash = HashUtil::xxHash64(value);\n    } else if (!value.empty()) {\n      hash = HashUtil::xxHash64(value);\n    }\n    return hash;\n  }", "target": 1}
{"code": "int am_check_url(request_rec *r, const char *url)\n{\n    const char *i;\n    if (url == NULL) {\n        return HTTP_BAD_REQUEST;\n    }\n    for (i = url; *i; i++) {\n        if (*i >= 0 && *i < ' ') {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Control character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n        if (*i == '\\\\') {\n            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"Backslash character detected in URL.\");\n            return HTTP_BAD_REQUEST;\n        }\n    }\n    if (strstr(url, \"\n        AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,\n                          \"URL starts with '\n        return HTTP_BAD_REQUEST;\n    }\n    return OK;\n}", "target": 0}
{"code": "inline void ImageLoader::ClearFailedLoadURL() {\n  failed_load_url_ = AtomicString();\n}", "target": 0}
{"code": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} ", "target": 1}
{"code": "void QuantizeMultiplier(double double_multiplier, int32_t* quantized_multiplier,\n                        int* left_shift) {\n  if (double_multiplier < 1.0) {\n    QuantizeMultiplierSmallerThanOneExp(double_multiplier, quantized_multiplier,\n                                        left_shift);\n  } else {\n    QuantizeMultiplierGreaterThanOne(double_multiplier, quantized_multiplier,\n                                     left_shift);\n  }\n}", "target": 0}
{"code": "decode_definite_bytestring(CBORDecoderObject *self, Py_ssize_t length)\n{\n    PyObject *ret = NULL;\n    ret = PyBytes_FromStringAndSize(NULL, length);\n    if (!ret)\n        return NULL;\n    if (fp_read(self, PyBytes_AS_STRING(ret), length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    if (string_namespace_add(self, ret, length) == -1) {\n        Py_DECREF(ret);\n        return NULL;\n    }\n    return ret;\n}", "target": 1}
{"code": "gfx::Rect RootWindowHostLinux::GetBounds() const {\n  return bounds_;\n}", "target": 0}
{"code": "int main()\n{\n    gdImagePtr im;\n    im = gdImageCreate(64970, 65111);\n    gdTestAssert(im == NULL);\n    return gdNumFailures();\n}", "target": 0}
{"code": "get_certificate_type(X509 *cert, bool is_ta, enum cert_type *result)\n{\n\tif (is_ta) {\n\t\t*result = TA;\n\t\treturn 0;\n\t}\n\tif (X509_check_ca(cert) == 1) {\n\t\t*result = CA;\n\t\treturn 0;\n\t}\n\tif (has_bgpsec_router_eku(cert)) {\n\t\t*result = BGPSEC;\n\t\treturn 0;\n\t}\n\t*result = EE; \n\treturn pr_val_err(\"Certificate is not TA, CA nor BGPsec. Ignoring...\");\n}", "target": 0}
{"code": "static int muscle_restore_security_env(sc_card_t *card, int se_num)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmemset(&priv->env, 0, sizeof(priv->env));\n\treturn 0;\n}", "target": 0}
{"code": "PassOwnPtr<SVGDocumentExtensions::SVGPendingElements> SVGDocumentExtensions::removePendingResource(const AtomicString& id)\n{\n    ASSERT(m_pendingResources.contains(id));\n    return m_pendingResources.take(id);\n}", "target": 0}
{"code": "  void readStructEnd() {\n    lastFieldId_ = nestedStructFieldIds_.back();\n    nestedStructFieldIds_.pop_back();\n  }", "target": 1}
{"code": "  void readErr(const AsyncSocketException&) noexcept override {}", "target": 0}
{"code": "  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {\n    const Tensor first_partition_tensor =\n        context->input(kFirstPartitionInputIndex);\n    if (row_partition_types_.empty()) {\n      return errors::InvalidArgument(\"No row_partition_types given.\");\n    }\n    const RowPartitionType first_partition_type = row_partition_types_[0];\n    switch (first_partition_type) {\n      case RowPartitionType::FIRST_DIM_SIZE:\n        *result = first_partition_tensor.scalar<INDEX_TYPE>()();\n        return Status::OK();\n      case RowPartitionType::VALUE_ROWIDS:\n        return errors::InvalidArgument(\n            \"Cannot handle VALUE_ROWIDS in first dimension.\");\n      case RowPartitionType::ROW_SPLITS:\n        *result = first_partition_tensor.shape().dim_size(0) - 1;\n        return Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Cannot handle type \",\n            RowPartitionTypeToString(first_partition_type));\n    }\n  }", "target": 0}
{"code": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \n  int nextra = actual - nfixparams;  \n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  setobjs2s(L, L->top++, ci->func);\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  \n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);\n}", "target": 1}
{"code": "static int http1_on_response(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_response_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.status_str && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}", "target": 1}
{"code": "static struct ast_sip_endpoint *transport_identify(pjsip_rx_data *rdata)\n{\n\tchar buffer[PJ_INET6_ADDRSTRLEN];\n\tpj_status_t status;\n\tstruct ast_sockaddr_with_tp addr_with_tp = { { { 0, } }, };\n\tunion pj_sockaddr sock = rdata->tp_info.transport->local_addr;\n\tpj_ansi_strxcpy(addr_with_tp.tp, rdata->tp_info.transport->type_name, sizeof(addr_with_tp.tp));\n\tif (sock.addr.sa_family == PJ_AF_INET6) {\n\t\tstatus = pj_inet_ntop(PJ_AF_INET6, &(sock.ipv6.sin6_addr), buffer, PJ_INET6_ADDRSTRLEN);\n\t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"::\")) {\n\t\t\tast_log(LOG_WARNING, \"Matching against '::' may be unpredictable.\\n\");\n\t\t}\n\t} else {\n\t\tstatus = pj_inet_ntop(PJ_AF_INET, &(sock.ipv4.sin_addr), buffer, PJ_INET_ADDRSTRLEN);\n\t\tif (status == PJ_SUCCESS && !strcmp(buffer, \"0.0.0.0\")) {\n\t\t\tast_log(LOG_WARNING, \"Matching against '0.0.0.0' may be unpredictable.\\n\");\n\t\t}\n\t}\n\tif (status == PJ_SUCCESS) {\n\t\tast_sockaddr_parse(&addr_with_tp.addr, buffer, PARSE_PORT_FORBID);\n\t\tast_sockaddr_set_port(&addr_with_tp.addr, rdata->tp_info.transport->local_name.port);\n\t\treturn common_identify(ip_identify_match_check, &addr_with_tp);\n\t} else {\n\t\treturn NULL;\n\t}\n}", "target": 1}
{"code": "bit_write_UMC (Bit_Chain *dat, BITCODE_UMC val)\n{\n  int i, j;\n  int negative;\n  unsigned char byte[5];\n  BITCODE_UMC mask;\n  BITCODE_UMC value;\n  value = val;\n  mask = 0x0000007f;\n  for (i = 4, j = 0; i >= 0; i--, j += 7)\n    {\n      byte[i] = (unsigned char)((value & mask) >> j);\n      byte[i] |= 0x80;\n      mask = mask << 7;\n    }\n  for (i = 0; i < 4; i++)\n    if (byte[i] & 0x7f)\n      break;\n  if (byte[i] & 0x40)\n    i--;\n  byte[i] &= 0x7f;\n  for (j = 4; j >= i; j--)\n    bit_write_RC (dat, byte[j]);\n}", "target": 1}
{"code": "static inline __must_check bool try_get_page(struct page *page)\n{\n\tpage = compound_head(page);\n\tif (WARN_ON_ONCE(page_ref_count(page) <= 0))\n\t\treturn false;\n\tpage_ref_inc(page);\n\treturn true;\n}", "target": 0}
{"code": "void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {\n    int i;\n    if (o->encoding != OBJ_ENCODING_ZIPLIST) return;\n    for (i = start; i <= end; i++) {\n        if (sdsEncodedObject(argv[i]) &&\n            sdslen(argv[i]->ptr) > server.hash_max_ziplist_value)\n        {\n            hashTypeConvert(o, OBJ_ENCODING_HT);\n            break;\n        }\n    }\n}", "target": 1}
{"code": "static void __route4_delete_filter(struct route4_filter *f)\n{\n\ttcf_exts_destroy(&f->exts);\n\ttcf_exts_put_net(&f->exts);\n\tkfree(f);\n}", "target": 0}
{"code": "cifs_put_tcp_session(struct TCP_Server_Info *server, int from_reconnect)\n{\n\tstruct task_struct *task;\n\tspin_lock(&cifs_tcp_ses_lock);\n\tif (--server->srv_count > 0) {\n\t\tspin_unlock(&cifs_tcp_ses_lock);\n\t\treturn;\n\t}\n\tWARN_ON(server->srv_count < 0);\n\tput_net(cifs_net_ns(server));\n\tlist_del_init(&server->tcp_ses_list);\n\tspin_unlock(&cifs_tcp_ses_lock);\n\tif (CIFS_SERVER_IS_CHAN(server))\n\t\tcifs_put_tcp_session(server->primary_server, from_reconnect);\n\tcancel_delayed_work_sync(&server->echo);\n\tcancel_delayed_work_sync(&server->resolve);\n\tif (from_reconnect)\n\t\tcancel_delayed_work(&server->reconnect);\n\telse\n\t\tcancel_delayed_work_sync(&server->reconnect);\n\tspin_lock(&server->srv_lock);\n\tserver->tcpStatus = CifsExiting;\n\tspin_unlock(&server->srv_lock);\n\tcifs_crypto_secmech_release(server);\n\tkfree_sensitive(server->session_key.response);\n\tserver->session_key.response = NULL;\n\tserver->session_key.len = 0;\n\tkfree(server->hostname);\n\tserver->hostname = NULL;\n\ttask = xchg(&server->tsk, NULL);\n\tif (task)\n\t\tsend_sig(SIGKILL, task, 1);\n}", "target": 0}
{"code": "  DllDef int libraw_get_raw_height(libraw_data_t *lr)\n  {\n    if (!lr)\n      return EINVAL;\n    return lr->sizes.raw_height;\n  }", "target": 0}
{"code": "ftrace_regex_lseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t ret;\n\tif (file->f_mode & FMODE_READ)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 1;\n\treturn ret;\n}", "target": 1}
{"code": "init_remote_listener(int port, gboolean encrypted)\n{\n    int rc;\n    int *ssock = NULL;\n    struct sockaddr_in saddr;\n    int optval;\n    static struct mainloop_fd_callbacks remote_listen_fd_callbacks = \n        {\n            .dispatch = cib_remote_listen,\n            .destroy = remote_connection_destroy,\n        };\n    if (port <= 0) {\n        return 0;\n    }\n    if (encrypted) {\n#ifndef HAVE_GNUTLS_GNUTLS_H\n        crm_warn(\"TLS support is not available\");\n        return 0;\n#else\n        crm_notice(\"Starting a tls listener on port %d.\", port);\n        gnutls_global_init();\n        gnutls_global_set_log_function(debug_log);\n        gnutls_dh_params_init(&dh_params);\n        gnutls_dh_params_generate2(dh_params, DH_BITS);\n        gnutls_anon_allocate_server_credentials(&anon_cred_s);\n        gnutls_anon_set_server_dh_params(anon_cred_s, dh_params);\n#endif\n    } else {\n        crm_warn(\"Starting a plain_text listener on port %d.\", port);\n    }\n#ifndef HAVE_PAM\n    crm_warn(\"PAM is _not_ enabled!\");\n#endif\n    ssock = malloc(sizeof(int));\n    *ssock = socket(AF_INET, SOCK_STREAM, 0);\n    if (*ssock == -1) {\n        crm_perror(LOG_ERR, \"Can not create server socket.\" ERROR_SUFFIX);\n        free(ssock);\n        return -1;\n    }\n    optval = 1;\n    rc = setsockopt(*ssock, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    if(rc < 0) {\n        crm_perror(LOG_INFO, \"Couldn't allow the reuse of local addresses by our remote listener\");\n    }\n    memset(&saddr, '\\0', sizeof(saddr));\n    saddr.sin_family = AF_INET;\n    saddr.sin_addr.s_addr = INADDR_ANY;\n    saddr.sin_port = htons(port);\n    if (bind(*ssock, (struct sockaddr *)&saddr, sizeof(saddr)) == -1) {\n        crm_perror(LOG_ERR, \"Can not bind server socket.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -2;\n    }\n    if (listen(*ssock, 10) == -1) {\n        crm_perror(LOG_ERR, \"Can not start listen.\" ERROR_SUFFIX);\n        close(*ssock);\n        free(ssock);\n        return -3;\n    }\n    mainloop_add_fd(\"cib-remote\", G_PRIORITY_DEFAULT, *ssock, ssock, &remote_listen_fd_callbacks);\n    return *ssock;\n}", "target": 1}
{"code": "int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,\n\t\tint type)\n{\n\tint err;\n\tchar *xattr_name;\n\tsize_t size = 0;\n\tchar *value = NULL;\n\thfs_dbg(ACL_MOD, \"[%s]: ino %lu\\n\", __func__, inode->i_ino);\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terr = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = 0;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\txattr_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tsize = posix_acl_xattr_size(acl->a_count);\n\t\tif (unlikely(size > HFSPLUS_MAX_INLINE_DATA_SIZE))\n\t\t\treturn -ENOMEM;\n\t\tvalue = (char *)hfsplus_alloc_attr_entry();\n\t\tif (unlikely(!value))\n\t\t\treturn -ENOMEM;\n\t\terr = posix_acl_to_xattr(&init_user_ns, acl, value, size);\n\t\tif (unlikely(err < 0))\n\t\t\tgoto end_set_acl;\n\t}\n\terr = __hfsplus_setxattr(inode, xattr_name, value, size, 0);\nend_set_acl:\n\thfsplus_destroy_attr_entry((hfsplus_attr_entry *)value);\n\tif (!err)\n\t\tset_cached_acl(inode, type, acl);\n\treturn err;\n}", "target": 1}
{"code": "void DetectSignatureApplyActions(Packet *p,\n        const Signature *s, const uint8_t alert_flags)\n{\n    PACKET_UPDATE_ACTION(p, s->action);\n    if (s->action & ACTION_DROP) {\n        if (p->alerts.drop.action == 0) {\n            p->alerts.drop.num = s->num;\n            p->alerts.drop.action = s->action;\n            p->alerts.drop.s = (Signature *)s;\n        }\n    } else if (s->action & ACTION_PASS) {\n        if ((p->flow != NULL) &&\n                (alert_flags & (PACKET_ALERT_FLAG_STATE_MATCH|PACKET_ALERT_FLAG_STREAM_MATCH)))\n        {\n            FlowSetNoPacketInspectionFlag(p->flow);\n        }\n    }\n}", "target": 0}
{"code": "void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent)\n{\n    clear();\n    m_torrent = torrent;\n    downloaded_pieces->setTorrent(m_torrent);\n    pieces_availability->setTorrent(m_torrent);\n    if (!m_torrent) return;\n    updateSavePath(m_torrent);\n    hash_lbl->setText(m_torrent->hash());\n    PropListModel->model()->clear();\n    if (m_torrent->hasMetadata()) {\n        lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate));\n        label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize()));\n        comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment()));\n        loadUrlSeeds();\n        label_created_by_val->setText(m_torrent->creator());\n        PropListModel->model()->setupModelData(m_torrent->info());\n        filesList->setExpanded(PropListModel->index(0, 0), true);\n        PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities());\n    }\n    loadDynamicData();\n}", "target": 1}
{"code": "rpki_rtr_print(netdissect_options *ndo, register const u_char *pptr, register u_int len)\n{\n    u_int tlen, pdu_type, pdu_len;\n    const u_char *tptr;\n    const rpki_rtr_pdu *pdu_header;\n    tptr = pptr;\n    tlen = len;\n    if (!ndo->ndo_vflag) {\n\tND_PRINT((ndo, \", RPKI-RTR\"));\n\treturn;\n    }\n    while (tlen >= sizeof(rpki_rtr_pdu)) {\n        ND_TCHECK2(*tptr, sizeof(rpki_rtr_pdu));\n\tpdu_header = (const rpki_rtr_pdu *)tptr;\n        pdu_type = pdu_header->pdu_type;\n        pdu_len = EXTRACT_32BITS(pdu_header->length);\n        ND_TCHECK2(*tptr, pdu_len);\n        if (!pdu_type || !pdu_len) {\n            break;\n        }\n        if (tlen < pdu_len) {\n            goto trunc;\n        }\n\tif (rpki_rtr_pdu_print(ndo, tptr, 8))\n\t\tgoto trunc;\n        tlen -= pdu_len;\n        tptr += pdu_len;\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo, \"\\n\\t%s\", tstr));\n}", "target": 1}
{"code": "std::string Network::GetErrorString() const {\n  switch (error_) {\n    case ERROR_UNKNOWN:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_UNKNOWN);\n    case ERROR_OUT_OF_RANGE:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_OUT_OF_RANGE);\n    case ERROR_PIN_MISSING:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_PIN_MISSING);\n    case ERROR_DHCP_FAILED:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_DHCP_FAILED);\n    case ERROR_CONNECT_FAILED:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_CONNECT_FAILED);\n    case ERROR_BAD_PASSPHRASE:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_BAD_PASSPHRASE);\n    case ERROR_BAD_WEPKEY:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_BAD_WEPKEY);\n    case ERROR_ACTIVATION_FAILED:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_ACTIVATION_FAILED);\n    case ERROR_NEED_EVDO:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_NEED_EVDO);\n    case ERROR_NEED_HOME_NETWORK:\n      return l10n_util::GetStringUTF8(\n          IDS_CHROMEOS_NETWORK_ERROR_NEED_HOME_NETWORK);\n    case ERROR_OTASP_FAILED:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_OTASP_FAILED);\n    case ERROR_AAA_FAILED:\n      return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_ERROR_AAA_FAILED);\n    default:\n      break;\n  }\n  return l10n_util::GetStringUTF8(IDS_CHROMEOS_NETWORK_STATE_UNRECOGNIZED);\n}", "target": 0}
{"code": "TEST(MultiplyAndCheckOverflow, Validate) {\n  size_t res = 0;\n  EXPECT_TRUE(MultiplyAndCheckOverflow(1, 2, &res) == kTfLiteOk);\n  EXPECT_FALSE(MultiplyAndCheckOverflow(static_cast<size_t>(123456789023),\n                                        1223423425, &res) == kTfLiteOk);\n}", "target": 0}
{"code": "static int load_segment_descriptor(struct x86_emulate_ctxt *ctxt,\n\t\t\t\t   u16 selector, int seg)\n{\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\tif (seg == VCPU_SREG_SS && selector == 3 &&\n\t    ctxt->mode == X86EMUL_MODE_PROT64)\n\t\treturn emulate_exception(ctxt, GP_VECTOR, 0, true);\n\treturn __load_segment_descriptor(ctxt, selector, seg, cpl,\n\t\t\t\t\t X86_TRANSFER_NONE, NULL);\n}", "target": 0}
{"code": "static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)\n{\n\tstruct sock *sk = NULL;\n\tstruct unix_sock *u;\n\tatomic_long_inc(&unix_nr_socks);\n\tif (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())\n\t\tgoto out;\n\tsk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern);\n\tif (!sk)\n\t\tgoto out;\n\tsock_init_data(sock, sk);\n\tlockdep_set_class(&sk->sk_receive_queue.lock,\n\t\t\t\t&af_unix_sk_receive_queue_lock_key);\n\tsk->sk_write_space\t= unix_write_space;\n\tsk->sk_max_ack_backlog\t= net->unx.sysctl_max_dgram_qlen;\n\tsk->sk_destruct\t\t= unix_sock_destructor;\n\tu\t  = unix_sk(sk);\n\tu->path.dentry = NULL;\n\tu->path.mnt = NULL;\n\tspin_lock_init(&u->lock);\n\tatomic_long_set(&u->inflight, 0);\n\tINIT_LIST_HEAD(&u->link);\n\tmutex_init(&u->readlock); \n\tinit_waitqueue_head(&u->peer_wait);\n\tinit_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);\n\tunix_insert_socket(unix_sockets_unbound(sk), sk);\nout:\n\tif (sk == NULL)\n\t\tatomic_long_dec(&unix_nr_socks);\n\telse {\n\t\tlocal_bh_disable();\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\n\t\tlocal_bh_enable();\n\t}\n\treturn sk;\n}", "target": 0}
{"code": "void nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t      struct nft_set_binding *binding,\n\t\t\t      enum nft_trans_phase phase)\n{\n\tswitch (phase) {\n\tcase NFT_TRANS_PREPARE:\n\t\tif (nft_set_is_anonymous(set))\n\t\t\tnft_deactivate_next(ctx->net, set);\n\t\tset->use--;\n\t\treturn;\n\tcase NFT_TRANS_ABORT:\n\tcase NFT_TRANS_RELEASE:\n\t\tset->use--;\n\t\tfallthrough;\n\tdefault:\n\t\tnf_tables_unbind_set(ctx, set, binding,\n\t\t\t\t     phase == NFT_TRANS_COMMIT);\n\t}\n}", "target": 0}
{"code": "static void engine_shutdown_handler(void *arg)\n{\n\t(void) arg;\n\tre_printf(\"The engine shutted down.\\n\");\n\tre_cancel();\n}", "target": 0}
{"code": "bool CxImage::Transfer(CxImage &from, bool bTransferFrames )\n{\n\tif (!Destroy())\n\t\treturn false;\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\treturn true;\n}", "target": 1}
{"code": "void *jas_malloc(size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_malloc called with %zu\\n\", size));\n\tresult = malloc(size);\n\tJAS_DBGLOG(100, (\"jas_malloc(%zu) -> %p\\n\", size, result));\n\treturn result;\n}", "target": 1}
{"code": "static void ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}", "target": 1}
{"code": "static int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->rc_family  = AF_BLUETOOTH;\n\tsa->rc_channel = rfcomm_pi(sk)->channel;\n\tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &bt_sk(sk)->src);\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}", "target": 0}
{"code": "static int ida_checks(void)\n{\n\tIDA_BUG_ON(&ida, !ida_is_empty(&ida));\n\tida_check_alloc(&ida);\n\tida_check_destroy(&ida);\n\tida_check_leaf(&ida, 0);\n\tida_check_leaf(&ida, 1024);\n\tida_check_leaf(&ida, 1024 * 64);\n\tida_check_max(&ida);\n\tida_check_conv(&ida);\n\tida_check_bad_free(&ida);\n\tprintk(\"IDA: %u of %u tests passed\\n\", tests_passed, tests_run);\n\treturn (tests_run != tests_passed) ? 0 : -EINVAL;\n}", "target": 0}
{"code": "void test_bindmount(const char *path)\n{\n\tif (mount(path, path, \"none\", MS_BIND, NULL) == 0) {\n\t\tfprintf(stderr, \"leak at bind mount of %s\\n\", path);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static inline void *get_freepointer(struct kmem_cache *s, void *object)\n{\n\treturn *(void **)(object + s->offset);\n}", "target": 0}
{"code": "spawn_child()\n{\n        pid_t pid;\n        sigset_t newset;\n        sigset_t oldset;\n        sigemptyset(&newset);\n        sigaddset(&newset, SIGCHLD);\n        sigaddset(&newset, SIGTERM);\n        sigprocmask(SIG_BLOCK, &newset, &oldset);\n        pid = fork();\n        if (pid < 0) {\n                msg(LOG_ERR, \"Could not fork (%s)\", strerror(errno));\n                goto out;\n        }\n        if (pid > 0) { \n                pid_t *pidp;\n                pidp = g_malloc(sizeof(pid_t));\n                *pidp = pid;\n                g_hash_table_insert(children, pidp, pidp);\n                goto out;\n        }\n        signal(SIGCHLD, SIG_DFL);\n        signal(SIGTERM, SIG_DFL);\n        signal(SIGHUP, SIG_DFL);\nout:\n        sigprocmask(SIG_SETMASK, &oldset, NULL);\n        return pid;\n}", "target": 0}
{"code": "static static void adpt_delay(int millisec)\n{\n\tint i;\n\tfor (i = 0; i < millisec; i++) {\n\t\tudelay(1000);\t\n\t}\n}", "target": 1}
{"code": "static int gup_pte_range(pmd_t pmd, unsigned long addr, unsigned long end,\n\t\t\t int write, struct page **pages, int *nr)\n{\n\tstruct dev_pagemap *pgmap = NULL;\n\tint nr_start = *nr, ret = 0;\n\tpte_t *ptep, *ptem;\n\tptem = ptep = pte_offset_map(&pmd, addr);\n\tdo {\n\t\tpte_t pte = gup_get_pte(ptep);\n\t\tstruct page *head, *page;\n\t\tif (pte_protnone(pte))\n\t\t\tgoto pte_unmap;\n\t\tif (!pte_access_permitted(pte, write))\n\t\t\tgoto pte_unmap;\n\t\tif (pte_devmap(pte)) {\n\t\t\tpgmap = get_dev_pagemap(pte_pfn(pte), pgmap);\n\t\t\tif (unlikely(!pgmap)) {\n\t\t\t\tundo_dev_pagemap(nr, nr_start, pages);\n\t\t\t\tgoto pte_unmap;\n\t\t\t}\n\t\t} else if (pte_special(pte))\n\t\t\tgoto pte_unmap;\n\t\tVM_BUG_ON(!pfn_valid(pte_pfn(pte)));\n\t\tpage = pte_page(pte);\n\t\thead = compound_head(page);\n\t\tif (!page_cache_get_speculative(head))\n\t\t\tgoto pte_unmap;\n\t\tif (unlikely(pte_val(pte) != pte_val(*ptep))) {\n\t\t\tput_page(head);\n\t\t\tgoto pte_unmap;\n\t\t}\n\t\tVM_BUG_ON_PAGE(compound_head(page) != head, page);\n\t\tSetPageReferenced(page);\n\t\tpages[*nr] = page;\n\t\t(*nr)++;\n\t} while (ptep++, addr += PAGE_SIZE, addr != end);\n\tret = 1;\npte_unmap:\n\tif (pgmap)\n\t\tput_dev_pagemap(pgmap);\n\tpte_unmap(ptem);\n\treturn ret;\n}", "target": 1}
{"code": "TEST(DepthToSpaceOpModel, NoBlockSize) {\n  EXPECT_DEATH(DepthToSpaceOpModel({TensorType_FLOAT32, {1, 1, 1, 4}}, 0),\n               \"Cannot allocate tensors\");\n}", "target": 0}
{"code": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n\tint r;\n\tstruct kvm_vcpu *vcpu, *v;\n\tif (id >= KVM_MAX_VCPUS)\n\t\treturn -EINVAL;\n\tvcpu = kvm_arch_vcpu_create(kvm, id);\n\tif (IS_ERR(vcpu))\n\t\treturn PTR_ERR(vcpu);\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}", "target": 0}
{"code": "void HTPStateFree(void *state)\n{\n    SCEnter();\n    HtpState *s = (HtpState *)state;\n    if (s == NULL) {\n        SCReturn;\n    }\n    if (s->connp != NULL) {\n        SCLogDebug(\"freeing HTP state\");\n        uint64_t tx_id;\n        uint64_t total_txs = HTPStateGetTxCnt(state);\n        if (s->conn != NULL) {\n            for (tx_id = 0; tx_id < total_txs; tx_id++) {\n                htp_tx_t *tx = HTPStateGetTx(s, tx_id);\n                if (tx != NULL) {\n                    HtpTxUserData *htud = (HtpTxUserData *) htp_tx_get_user_data(tx);\n                    HtpTxUserDataFree(s, htud);\n                    htp_tx_set_user_data(tx, NULL);\n                }\n            }\n        }\n        htp_connp_destroy_all(s->connp);\n    }\n    FileContainerFree(s->files_ts);\n    FileContainerFree(s->files_tc);\n    HTPFree(s, sizeof(HtpState));\n#ifdef DEBUG\n    SCMutexLock(&htp_state_mem_lock);\n    htp_state_memcnt--;\n    htp_state_memuse -= sizeof(HtpState);\n    SCLogDebug(\"htp memory %\"PRIu64\" (%\"PRIu64\")\", htp_state_memuse, htp_state_memcnt);\n    SCMutexUnlock(&htp_state_mem_lock);\n#endif\n    SCReturn;\n}", "target": 1}
{"code": "xmlAddID(xmlValidCtxtPtr ctxt, xmlDocPtr doc, const xmlChar *value,\n         xmlAttrPtr attr) {\n    xmlIDPtr ret;\n    xmlIDTablePtr table;\n    if (doc == NULL) {\n\treturn(NULL);\n    }\n    if (value == NULL) {\n\treturn(NULL);\n    }\n    if (attr == NULL) {\n\treturn(NULL);\n    }\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)  {\n        doc->ids = table = xmlHashCreateDict(0, doc->dict);\n    }\n    if (table == NULL) {\n\txmlVErrMemory(ctxt,\n\t\t\"xmlAddID: Table creation failed!\\n\");\n        return(NULL);\n    }\n    ret = (xmlIDPtr) xmlMalloc(sizeof(xmlID));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n\treturn(NULL);\n    }\n    ret->value = xmlStrdup(value);\n    ret->doc = doc;\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\tif (doc->dict != NULL)\n\t    ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n\telse\n\t    ret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->attr = attr;\n\tret->name = NULL;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);\n    if (xmlHashAddEntry(table, value, ret) < 0) {\n#ifdef LIBXML_VALID_ENABLED\n\tif (ctxt != NULL) {\n\t    xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n\t\t\t    \"ID %s already defined\\n\", value, NULL, NULL);\n\t}\n#endif \n\txmlFreeID(ret);\n\treturn(NULL);\n    }\n    if (attr != NULL)\n\tattr->atype = XML_ATTRIBUTE_ID;\n    return(ret);\n}", "target": 1}
{"code": "static ssize_t ucma_process_join(struct ucma_file *file,\n\t\t\t\t struct rdma_ucm_join_mcast *cmd,  int out_len)\n{\n\tstruct rdma_ucm_create_id_resp resp;\n\tstruct ucma_context *ctx;\n\tstruct ucma_multicast *mc;\n\tstruct sockaddr *addr;\n\tint ret;\n\tu8 join_state;\n\tif (out_len < sizeof(resp))\n\t\treturn -ENOSPC;\n\taddr = (struct sockaddr *) &cmd->addr;\n\tif (cmd->addr_size != rdma_addr_size(addr))\n\t\treturn -EINVAL;\n\tif (cmd->join_flags == RDMA_MC_JOIN_FLAG_FULLMEMBER)\n\t\tjoin_state = BIT(FULLMEMBER_JOIN);\n\telse if (cmd->join_flags == RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER)\n\t\tjoin_state = BIT(SENDONLY_FULLMEMBER_JOIN);\n\telse\n\t\treturn -EINVAL;\n\tctx = ucma_get_ctx_dev(file, cmd->id);\n\tif (IS_ERR(ctx))\n\t\treturn PTR_ERR(ctx);\n\tmutex_lock(&file->mut);\n\tmc = ucma_alloc_multicast(ctx);\n\tif (!mc) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmc->join_state = join_state;\n\tmc->uid = cmd->uid;\n\tmemcpy(&mc->addr, addr, cmd->addr_size);\n\tret = rdma_join_multicast(ctx->cm_id, (struct sockaddr *)&mc->addr,\n\t\t\t\t  join_state, mc);\n\tif (ret)\n\t\tgoto err2;\n\tresp.id = mc->id;\n\tif (copy_to_user(u64_to_user_ptr(cmd->response),\n\t\t\t &resp, sizeof(resp))) {\n\t\tret = -EFAULT;\n\t\tgoto err3;\n\t}\n\tmutex_lock(&mut);\n\tidr_replace(&multicast_idr, mc, mc->id);\n\tmutex_unlock(&mut);\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn 0;\nerr3:\n\trdma_leave_multicast(ctx->cm_id, (struct sockaddr *) &mc->addr);\n\tucma_cleanup_mc_events(mc);\nerr2:\n\tmutex_lock(&mut);\n\tidr_remove(&multicast_idr, mc->id);\n\tmutex_unlock(&mut);\n\tlist_del(&mc->list);\n\tkfree(mc);\nerr1:\n\tmutex_unlock(&file->mut);\n\tucma_put_ctx(ctx);\n\treturn ret;\n}", "target": 0}
{"code": "SQLiteDatabase::SQLiteDatabase()\n    : db_(nullptr),\n      page_size_(-1),\n      transaction_in_progress_(false),\n      opening_thread_(0),\n      open_error_(SQLITE_ERROR),\n      open_error_message_(),\n      last_changes_count_(0) {\n}", "target": 0}
{"code": "void pushGenericCommand(client *c, int where) {\n    int j, pushed = 0;\n    for (j = 2; j < c->argc; j++) {\n        if (sdslen(c->argv[j]->ptr) > LIST_MAX_ITEM_SIZE) {\n            addReplyError(c, \"Element too large\");\n            return;\n        }\n    }\n    robj *lobj = lookupKeyWrite(c->db,c->argv[1]);\n    if (lobj && lobj->type != OBJ_LIST) {\n        addReply(c,shared.wrongtypeerr);\n        return;\n    }\n    for (j = 2; j < c->argc; j++) {\n        if (!lobj) {\n            lobj = createQuicklistObject();\n            quicklistSetOptions(lobj->ptr, server.list_max_ziplist_size,\n                                server.list_compress_depth);\n            dbAdd(c->db,c->argv[1],lobj);\n        }\n        listTypePush(lobj,c->argv[j],where);\n        pushed++;\n    }\n    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : 0));\n    if (pushed) {\n        char *event = (where == LIST_HEAD) ? \"lpush\" : \"rpush\";\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_LIST,event,c->argv[1],c->db->id);\n    }\n    server.dirty += pushed;\n}", "target": 0}
{"code": "void ciEnv::cache_jvmti_state() {\n  VM_ENTRY_MARK;\n  MutexLocker mu(JvmtiThreadState_lock);\n  _jvmti_can_hotswap_or_post_breakpoint = JvmtiExport::can_hotswap_or_post_breakpoint();\n  _jvmti_can_access_local_variables     = JvmtiExport::can_access_local_variables();\n  _jvmti_can_post_on_exceptions         = JvmtiExport::can_post_on_exceptions();\n  _jvmti_can_pop_frame                  = JvmtiExport::can_pop_frame();\n}", "target": 0}
{"code": "static OPJ_BOOL opj_j2k_write_sot(opj_j2k_t *p_j2k,\n                                  OPJ_BYTE * p_data,\n                                  OPJ_UINT32 p_total_data_size,\n                                  OPJ_UINT32 * p_data_written,\n                                  const opj_stream_private_t *p_stream,\n                                  opj_event_mgr_t * p_manager\n                                 )\n{\n    assert(p_j2k != 00);\n    assert(p_manager != 00);\n    assert(p_stream != 00);\n    OPJ_UNUSED(p_stream);\n    OPJ_UNUSED(p_manager);\n    if (p_total_data_size < 12) {\n        opj_event_msg(p_manager, EVT_ERROR,\n                      \"Not enough bytes in output buffer to write SOT marker\\n\");\n        return OPJ_FALSE;\n    }\n    opj_write_bytes(p_data, J2K_MS_SOT,\n                    2);                                 \n    p_data += 2;\n    opj_write_bytes(p_data, 10,\n                    2);                                                   \n    p_data += 2;\n    opj_write_bytes(p_data, p_j2k->m_current_tile_number,\n                    2);                        \n    p_data += 2;\n    p_data += 4;\n    opj_write_bytes(p_data,\n                    p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,\n                    1);                        \n    ++p_data;\n    opj_write_bytes(p_data,\n                    p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,\n                    1);                      \n    ++p_data;\n#ifdef USE_JPWL\n    assert(0 && \"TODO\");\n#endif \n    * p_data_written = 12;\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "TfLiteRegistration GetPassthroughOpRegistration() {\n  TfLiteRegistration reg = {nullptr, nullptr, nullptr, nullptr};\n  reg.init = [](TfLiteContext* context, const char*, size_t) -> void* {\n    auto* first_new_tensor = new int;\n    context->AddTensors(context, 2, first_new_tensor);\n    return first_new_tensor;\n  };\n  reg.free = [](TfLiteContext* context, void* buffer) {\n    delete static_cast<int*>(buffer);\n  };\n  reg.prepare = [](TfLiteContext* context, TfLiteNode* node) {\n    auto* first_new_tensor = static_cast<int*>(node->user_data);\n    const TfLiteTensor* tensor0 = GetInput(context, node, 0);\n    TfLiteTensor* tensor1 = GetOutput(context, node, 0);\n    TfLiteIntArray* newSize = TfLiteIntArrayCopy(tensor0->dims);\n    TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, tensor1, newSize));\n    TfLiteIntArrayFree(node->temporaries);\n    node->temporaries = TfLiteIntArrayCreate(2);\n    for (int i = 0; i < 2; ++i) {\n      node->temporaries->data[i] = *(first_new_tensor) + i;\n    }\n    auto setup_temporary = [&](int id) {\n      TfLiteTensor* tmp = &context->tensors[id];\n      tmp->type = kTfLiteFloat32;\n      tmp->allocation_type = kTfLiteArenaRw;\n      return context->ResizeTensor(context, tmp,\n                                   TfLiteIntArrayCopy(tensor0->dims));\n    };\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[0]));\n    TF_LITE_ENSURE_STATUS(setup_temporary(node->temporaries->data[1]));\n    return kTfLiteOk;\n  };\n  reg.invoke = [](TfLiteContext* context, TfLiteNode* node) {\n    const TfLiteTensor* a0 = GetInput(context, node, 0);\n    auto populate = [&](int id) {\n      TfLiteTensor* t = &context->tensors[id];\n      int num = a0->dims->data[0];\n      for (int i = 0; i < num; i++) {\n        t->data.f[i] = a0->data.f[i];\n      }\n    };\n    populate(node->outputs->data[0]);\n    populate(node->temporaries->data[0]);\n    populate(node->temporaries->data[1]);\n    return kTfLiteOk;\n  };\n  return reg;\n}", "target": 1}
{"code": "user_matches(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const struct member *m)\n{\n    const struct sudoers_context *ctx = parse_tree->ctx;\n    const char *lhost = parse_tree->lhost ? parse_tree->lhost : ctx->runas.host;\n    const char *shost = parse_tree->shost ? parse_tree->shost : ctx->runas.shost;\n    int matched = UNSPEC;\n    struct alias *a;\n    debug_decl(user_matches, SUDOERS_DEBUG_MATCH);\n    switch (m->type) {\n\tcase ALL:\n\t    matched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase NETGROUP:\n\t    if (netgr_matches(parse_tree->nss, m->name,\n\t\tdef_netgroup_tuple ? lhost : NULL,\n\t\tdef_netgroup_tuple ? shost : NULL, pw->pw_name))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase USERGROUP:\n\t    if (usergr_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    if ((a = alias_get(parse_tree, m->name, USERALIAS)) != NULL) {\n\t\tconst int rc = userlist_matches(parse_tree, pw, &a->members);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t\tbreak;\n\t    }\n\t    FALLTHROUGH;\n\tcase WORD:\n\t    if (userpw_matches(m->name, pw->pw_name, pw))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n    }\n    debug_return_int(matched);\n}", "target": 1}
{"code": "CSecurityTLS::~CSecurityTLS()\n{\n  shutdown(true);\n  if (fis)\n    delete fis;\n  if (fos)\n    delete fos;\n  delete[] cafile;\n  delete[] crlfile;\n  gnutls_global_deinit();\n}", "target": 0}
{"code": "static int semctl_setval(struct ipc_namespace *ns, int semid, int semnum,\n\t\tunsigned long arg)\n{\n\tstruct sem_undo *un;\n\tstruct sem_array *sma;\n\tstruct sem* curr;\n\tint err;\n\tint nsems;\n\tstruct list_head tasks;\n\tint val;\n#if defined(CONFIG_64BIT) && defined(__BIG_ENDIAN)\n\tval = arg >> 32;\n#else\n\tval = arg;\n#endif\n\tsma = sem_lock_check(ns, semid);\n\tif (IS_ERR(sma))\n\t\treturn PTR_ERR(sma);\n\tINIT_LIST_HEAD(&tasks);\n\tnsems = sma->sem_nsems;\n\terr = -EACCES;\n\tif (ipcperms(ns, &sma->sem_perm, S_IWUGO))\n\t\tgoto out_unlock;\n\terr = security_sem_semctl(sma, SETVAL);\n\tif (err)\n\t\tgoto out_unlock;\n\terr = -EINVAL;\n\tif(semnum < 0 || semnum >= nsems)\n\t\tgoto out_unlock;\n\tcurr = &sma->sem_base[semnum];\n\terr = -ERANGE;\n\tif (val > SEMVMX || val < 0)\n\t\tgoto out_unlock;\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_for_each_entry(un, &sma->list_id, list_id)\n\t\tun->semadj[semnum] = 0;\n\tcurr->semval = val;\n\tcurr->sempid = task_tgid_vnr(current);\n\tsma->sem_ctime = get_seconds();\n\tdo_smart_update(sma, NULL, 0, 0, &tasks);\n\terr = 0;\nout_unlock:\n\tsem_unlock(sma);\n\twake_up_sem_queue_do(&tasks);\n\treturn err;\n}", "target": 1}
{"code": "win_vert_neighbor(tabpage_T *tp, win_T *wp, int up, long count)\n{\n    frame_T\t*fr;\n    frame_T\t*nfr;\n    frame_T\t*foundfr;\n    foundfr = wp->w_frame;\n    while (count--)\n    {\n\tfr = foundfr;\n\tfor (;;)\n\t{\n\t    if (fr == tp->tp_topframe)\n\t\tgoto end;\n\t    if (up)\n\t\tnfr = fr->fr_prev;\n\t    else\n\t\tnfr = fr->fr_next;\n\t    if (fr->fr_parent->fr_layout == FR_COL && nfr != NULL)\n\t\tbreak;\n\t    fr = fr->fr_parent;\n\t}\n\tfor (;;)\n\t{\n\t    if (nfr->fr_layout == FR_LEAF)\n\t    {\n\t\tfoundfr = nfr;\n\t\tbreak;\n\t    }\n\t    fr = nfr->fr_child;\n\t    if (nfr->fr_layout == FR_ROW)\n\t    {\n\t\twhile (fr->fr_next != NULL\n\t\t\t&& frame2win(fr)->w_wincol + fr->fr_width\n\t\t\t\t\t <= wp->w_wincol + wp->w_wcol)\n\t\t    fr = fr->fr_next;\n\t    }\n\t    if (nfr->fr_layout == FR_COL && up)\n\t\twhile (fr->fr_next != NULL)\n\t\t    fr = fr->fr_next;\n\t    nfr = fr;\n\t}\n    }\nend:\n    return foundfr != NULL ? foundfr->fr_win : NULL;\n}", "target": 0}
{"code": "static void nfs4_open_prepare(struct rpc_task *task, void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state_owner *sp = data->owner;\n\tif (nfs_wait_on_sequence(data->o_arg.seqid, task) != 0)\n\t\treturn;\n\tif (data->state != NULL) {\n\t\tstruct nfs_delegation *delegation;\n\t\tif (can_open_cached(data->state, data->o_arg.open_flags & (FMODE_READ|FMODE_WRITE|O_EXCL)))\n\t\t\tgoto out_no_action;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(data->state->inode)->delegation);\n\t\tif (delegation != NULL &&\n\t\t    test_bit(NFS_DELEGATION_NEED_RECLAIM, &delegation->flags) == 0) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out_no_action;\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\tdata->o_arg.id = sp->so_owner_id.id;\n\tdata->o_arg.clientid = sp->so_client->cl_clientid;\n\tif (data->o_arg.claim == NFS4_OPEN_CLAIM_PREVIOUS) {\n\t\ttask->tk_msg.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_OPEN_NOATTR];\n\t\tnfs_copy_fh(&data->o_res.fh, data->o_arg.fh);\n\t}\n\tdata->timestamp = jiffies;\n\trpc_call_start(task);\n\treturn;\nout_no_action:\n\ttask->tk_action = NULL;\n}", "target": 1}
{"code": "  llvh::ArrayRef<hbc::HBCExceptionHandlerInfo> getExceptionTable(\n      uint32_t) const override {\n    llvm_unreachable(\"Accessing exception info from a lazy module\");\n  }", "target": 1}
{"code": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\tref = references[hash % REF_TABLE_SIZE];\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\t\tref = ref->next;\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "Status ValidateInputs(const Tensor *a_indices, const Tensor *a_values,\n                      const Tensor *a_shape, const Tensor *b) {\n  if (!TensorShapeUtils::IsMatrix(a_indices->shape())) {\n    return errors::InvalidArgument(\n        \"Input a_indices should be a matrix but received shape: \",\n        a_indices->shape().DebugString());\n  }\n  if (!TensorShapeUtils::IsVector(a_values->shape()) ||\n      !TensorShapeUtils::IsVector(a_shape->shape())) {\n    return errors::InvalidArgument(\n        \"Inputs a_values and a_shape should be vectors \"\n        \"but received shapes: \",\n        a_values->shape().DebugString(), \" and \",\n        a_shape->shape().DebugString());\n  }\n  int64_t nnz = a_indices->dim_size(0);\n  int64_t ndims = a_indices->dim_size(1);\n  if (a_values->dim_size(0) != nnz) {\n    return errors::InvalidArgument(\"Dimensions \", nnz, \" and \",\n                                   a_values->dim_size(0),\n                                   \" are not compatible\");\n  }\n  if (a_shape->dim_size(0) != ndims) {\n    return errors::InvalidArgument(\"Dimensions \", ndims, \" and \",\n                                   a_shape->dim_size(0), \" are not compatible\");\n  }\n  if (a_shape->NumElements() != b->dims()) {\n    return errors::InvalidArgument(\n        \"Two operands have different ranks; received: \", a_shape->NumElements(),\n        \" and \", b->dims());\n  }\n  const auto a_shape_flat = a_shape->flat<Index>();\n  for (int i = 0; i < b->dims(); ++i) {\n    if (a_shape_flat(i) != b->dim_size(i)) {\n      return errors::InvalidArgument(\n          \"Dimension \", i,\n          \" does not equal (no broadcasting is supported): sparse side \",\n          a_shape_flat(i), \" vs dense side \", b->dim_size(i));\n    }\n  }\n  const auto a_indices_mat = a_indices->flat_inner_dims<Index>();\n  for (int64_t zidx = 0; zidx < nnz; ++zidx) {\n    for (int64_t didx = 0; didx < ndims; ++didx) {\n      const Index idx = a_indices_mat(zidx, didx);\n      if (idx < 0 || idx >= a_shape_flat(didx)) {\n        return errors::InvalidArgument(\n            \"Sparse tensor has an invalid index on dimension \", didx,\n            \": \"\n            \"a_indices(\",\n            zidx, \",\", didx, \") = \", idx,\n            \", dense tensor shape: \", a_shape_flat);\n      }\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; \n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}", "target": 1}
{"code": "static bool is_spilled_reg(const struct bpf_stack_state *stack)\n{\n\treturn stack->slot_type[BPF_REG_SIZE - 1] == STACK_SPILL;\n}", "target": 0}
{"code": "static void netprobe_handler(int err, const struct netprobe_result *result,\n\t\t\t     void *arg)\n{\n\tstruct probe_entry *np;\n\tsize_t ix = (size_t)arg;\n\tif (err) {\n\t\twarning(\"netprobe failed (%m)\\n\", err);\n\t\tgoto out;\n\t}\n\tnp = &netprobev[ix];\n\tre_printf(\"Network Probe results for %s TURN%s-server at %J\\n\",\n\t\t  net_proto2name(np->proto),\n\t\t  np->secure ? \"S\" : \"\", &np->turn_srv);\n\tre_printf(\"    Average RTT:   %.1f milliseconds\\n\",\n\t\t  result->rtt_avg / 1000.0);\n\tre_printf(\"    transmitted:   %u packets\\n\", result->n_pkt_sent);\n\tre_printf(\"    received:      %u packets\\n\", result->n_pkt_recv);\n\tre_printf(\"\\n\");\n out:\n\tnetprobec_ok++;\n\tif (netprobec_ok >= netprobec) {\n\t\tinfo(\"netprobing done. shutting down..\\n\");\n\t\tengine_shutdown(engine);\n\t}\n}", "target": 0}
{"code": "int nft_chain_validate_dependency(const struct nft_chain *chain,\n\t\t\t\t  enum nft_chain_type type)\n{\n\tconst struct nft_base_chain *basechain;\n\tif (chain->flags & NFT_BASE_CHAIN) {\n\t\tbasechain = nft_base_chain(chain);\n\t\tif (basechain->type->type != type)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static Jsi_Value *jsi_hashFmtKey(Jsi_MapEntry* h, struct Jsi_MapOpts *opts, int flags)\n{\n    Jsi_HashEntry* hPtr = (Jsi_HashEntry*)h;\n    void *key = Jsi_HashKeyGet(hPtr);\n    if (opts->keyType == JSI_KEYS_ONEWORD)\n        return Jsi_ValueNewNumber(opts->interp, (Jsi_Number)(intptr_t)key);\n    char nbuf[100];\n    snprintf(nbuf, sizeof(nbuf), \"%p\", key);\n    return Jsi_ValueNewStringDup(opts->interp, nbuf);\n}", "target": 1}
{"code": "static int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\talgo = nla_data(nla);\n\tstrcpy(algo->alg_name, auth->alg_name);\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\treturn 0;\n}", "target": 1}
{"code": "void appendCommand(client *c) {\n    size_t totlen;\n    robj *o, *append;\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        c->argv[2] = tryObjectEncoding(c->argv[2]);\n        dbAdd(c->db,c->argv[1],c->argv[2]);\n        incrRefCount(c->argv[2]);\n        totlen = stringObjectLen(c->argv[2]);\n    } else {\n        if (checkType(c,o,OBJ_STRING))\n            return;\n        append = c->argv[2];\n        totlen = stringObjectLen(o)+sdslen(append->ptr);\n        if (checkStringLength(c,totlen) != C_OK)\n            return;\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n        o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr));\n        totlen = sdslen(o->ptr);\n    }\n    signalModifiedKey(c,c->db,c->argv[1]);\n    notifyKeyspaceEvent(NOTIFY_STRING,\"append\",c->argv[1],c->db->id);\n    server.dirty++;\n    addReplyLongLong(c,totlen);\n}", "target": 1}
{"code": "static inline int route4_hash_to(u32 id)\n{\n\treturn id & 0xFF;\n}", "target": 0}
{"code": "void LibRaw::read_shorts(ushort *pixel, unsigned count)\n{\n  if (fread(pixel, 2, count, ifp) < count)\n    derror();\n  if ((order == 0x4949) == (ntohs(0x1234) == 0x1234))\n    swab((char *)pixel, (char *)pixel, count * 2);\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(date_sub)\n{\n\tzval *object, *interval;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"OO\", &object, date_ce_date, &interval, date_ce_interval) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tphp_date_sub(object, interval, return_value TSRMLS_CC);\n\tRETURN_ZVAL(object, 1, 0);", "target": 0}
{"code": "Opal::Call::get_local_party_name () const\n{\n  return local_party_name;\n}", "target": 0}
{"code": "userauth_gssapi(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tgss_OID_desc goid = {0, NULL};\n\tGssctxt *ctxt = NULL;\n\tint r, present;\n\tu_int mechs;\n\tOM_uint32 ms;\n\tsize_t len;\n\tu_char *doid = NULL;\n\tif (!authctxt->valid || authctxt->user == NULL)\n\t\treturn (0);\n\tif ((r = sshpkt_get_u32(ssh, &mechs)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tif (mechs == 0) {\n\t\tdebug(\"Mechanism negotiation is not supported\");\n\t\treturn (0);\n\t}\n\tdo {\n\t\tmechs--;\n\t\tfree(doid);\n\t\tpresent = 0;\n\t\tif ((r = sshpkt_get_string(ssh, &doid, &len)) != 0)\n\t\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\t\tif (len > 2 && doid[0] == SSH_GSS_OIDTYPE &&\n\t\t    doid[1] == len - 2) {\n\t\t\tgoid.elements = doid + 2;\n\t\t\tgoid.length   = len - 2;\n\t\t\tssh_gssapi_test_oid_supported(&ms, &goid, &present);\n\t\t} else {\n\t\t\tlogit(\"Badly formed OID received\");\n\t\t}\n\t} while (mechs > 0 && !present);\n\tif (!present) {\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\tif (GSS_ERROR(PRIVSEP(ssh_gssapi_server_ctx(&ctxt, &goid)))) {\n\t\tif (ctxt != NULL)\n\t\t\tssh_gssapi_delete_ctx(&ctxt);\n\t\tfree(doid);\n\t\tauthctxt->server_caused_failure = 1;\n\t\treturn (0);\n\t}\n\tauthctxt->methoddata = (void *)ctxt;\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_GSSAPI_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_string(ssh, doid, len)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal(\"%s: %s\", __func__, ssh_err(r));\n\tfree(doid);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_TOKEN, &input_gssapi_token);\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_GSSAPI_ERRTOK, &input_gssapi_errtok);\n\tauthctxt->postponed = 1;\n\treturn (0);\n}", "target": 1}
{"code": "    void resize (std::size_t new_size_) { _buf_size = new_size_; }", "target": 1}
{"code": "static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)\n{\n\tmutex_lock(&adpt_configuration_lock);\n\td->controller=pHba;\n\td->owner=NULL;\n\td->next=pHba->devices;\n\td->prev=NULL;\n\tif (pHba->devices != NULL){\n\t\tpHba->devices->prev=d;\n\t}\n\tpHba->devices=d;\n\t*d->dev_name = 0;\n\tmutex_unlock(&adpt_configuration_lock);\n\treturn 0;\n}", "target": 1}
{"code": "void ConnPoolImplBase::checkForIdleAndNotify() {\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}", "target": 0}
{"code": "static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,\n\t\t\t    struct msghdr *msg, size_t ignored, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_ctx *ctx = ask->private;\n\tunsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(\n\t\t&ctx->req));\n\tstruct skcipher_sg_list *sgl;\n\tstruct scatterlist *sg;\n\tint err = -EAGAIN;\n\tint used;\n\tlong copied = 0;\n\tlock_sock(sk);\n\twhile (iov_iter_count(&msg->msg_iter)) {\n\t\tsgl = list_first_entry(&ctx->tsgl,\n\t\t\t\t       struct skcipher_sg_list, list);\n\t\tsg = sgl->sg;\n\t\twhile (!sg->length)\n\t\t\tsg++;\n\t\tused = ctx->used;\n\t\tif (!used) {\n\t\t\terr = skcipher_wait_for_data(sk, flags);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\t\tused = min_t(unsigned long, used, iov_iter_count(&msg->msg_iter));\n\t\tused = af_alg_make_sg(&ctx->rsgl, &msg->msg_iter, used);\n\t\terr = used;\n\t\tif (err < 0)\n\t\t\tgoto unlock;\n\t\tif (ctx->more || used < ctx->used)\n\t\t\tused -= used % bs;\n\t\terr = -EINVAL;\n\t\tif (!used)\n\t\t\tgoto free;\n\t\tablkcipher_request_set_crypt(&ctx->req, sg,\n\t\t\t\t\t     ctx->rsgl.sg, used,\n\t\t\t\t\t     ctx->iv);\n\t\terr = af_alg_wait_for_completion(\n\t\t\t\tctx->enc ?\n\t\t\t\t\tcrypto_ablkcipher_encrypt(&ctx->req) :\n\t\t\t\t\tcrypto_ablkcipher_decrypt(&ctx->req),\n\t\t\t\t&ctx->completion);\nfree:\n\t\taf_alg_free_sg(&ctx->rsgl);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t\tcopied += used;\n\t\tskcipher_pull_sgl(sk, used);\n\t\tiov_iter_advance(&msg->msg_iter, used);\n\t}\n\terr = 0;\nunlock:\n\tskcipher_wmem_wakeup(sk);\n\trelease_sock(sk);\n\treturn copied ?: err;\n}", "target": 1}
{"code": "\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "sync_cookie_isvalid(Sync_Cookie *testcookie, Sync_Cookie *refcookie)\n{\n    if (testcookie == NULL || refcookie == NULL) {\n        return 0;\n    }\n    if ((testcookie->openldap_compat != refcookie->openldap_compat ||\n         strcmp(testcookie->cookie_client_signature, refcookie->cookie_client_signature) ||\n         testcookie->cookie_change_info == -1 ||\n         testcookie->cookie_change_info > refcookie->cookie_change_info)) {\n        return 0;\n    }\n    if (refcookie->openldap_compat) {\n        if (testcookie->cookie_server_signature != NULL ||\n            refcookie->cookie_server_signature != NULL) {\n            return 0;\n        }\n    } else {\n        if (strcmp(testcookie->cookie_server_signature, refcookie->cookie_server_signature)) {\n            return 0;\n        }\n    }\n    return 1;\n}", "target": 0}
{"code": " static void zgfx_history_buffer_ring_write(ZGFX_CONTEXT* zgfx, const BYTE* src, size_t count)\n {\n\tUINT32 front;\n\tif (count <= 0)\n\t\treturn;\n\tif (count > zgfx->HistoryBufferSize)\n\t{\n\t\tconst size_t residue = count - zgfx->HistoryBufferSize;\n\t\tcount = zgfx->HistoryBufferSize;\n\t\tsrc += residue;\n\t\tzgfx->HistoryIndex = (zgfx->HistoryIndex + residue) % zgfx->HistoryBufferSize;\n\t}\n\tif (zgfx->HistoryIndex + count <= zgfx->HistoryBufferSize)\n\t{\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, count);\n\t\tif ((zgfx->HistoryIndex += count) == zgfx->HistoryBufferSize)\n\t\t\tzgfx->HistoryIndex = 0;\n\t}\n\telse\n\t{\n\t\tfront = zgfx->HistoryBufferSize - zgfx->HistoryIndex;\n\t\tCopyMemory(&(zgfx->HistoryBuffer[zgfx->HistoryIndex]), src, front);\n\t\tCopyMemory(zgfx->HistoryBuffer, &src[front], count - front);\n\t\tzgfx->HistoryIndex = count - front;\n\t}\n}", "target": 0}
{"code": "ev_archive_finalize (GObject *object)\n{\n\tEvArchive *archive = EV_ARCHIVE (object);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_clear_pointer (&archive->libar, archive_free);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tG_OBJECT_CLASS (ev_archive_parent_class)->finalize (object);\n}", "target": 0}
{"code": "STACK_OF(PKCS7) *PKCS12_unpack_authsafes(const PKCS12 *p12)\n{\n    STACK_OF(PKCS7) *p7s;\n    PKCS7 *p7;\n    int i;\n    if (!PKCS7_type_is_data(p12->authsafes)) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_CONTENT_TYPE_NOT_DATA);\n        return NULL;\n    }\n    if (p12->authsafes->d.data == NULL) {\n        ERR_raise(ERR_LIB_PKCS12, PKCS12_R_DECODE_ERROR);\n        return NULL;\n    }\n    p7s = ASN1_item_unpack(p12->authsafes->d.data,\n                           ASN1_ITEM_rptr(PKCS12_AUTHSAFES));\n    if (p7s != NULL) {\n        for (i = 0; i < sk_PKCS7_num(p7s); i++) {\n            p7 = sk_PKCS7_value(p7s, i);\n            if (!ossl_pkcs7_ctx_propagate(p12->authsafes, p7))\n                goto err;\n        }\n    }\n    return p7s;\nerr:\n    sk_PKCS7_free(p7s);\n    return NULL;\n}", "target": 0}
{"code": "static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint max_irr;\n\tWARN_ON(!vcpu->arch.apicv_active);\n\tif (pi_test_on(&vmx->pi_desc)) {\n\t\tpi_clear_on(&vmx->pi_desc);\n\t\tsmp_mb__after_atomic();\n\t\tmax_irr = kvm_apic_update_irr(vcpu, vmx->pi_desc.pir);\n\t} else {\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\t}\n\tvmx_hwapic_irr_update(vcpu, max_irr);\n\treturn max_irr;\n}", "target": 0}
{"code": "GF_EXPORT\nBool gf_isom_get_oinf_info(GF_ISOFile *file, u32 trackNumber, GF_OperatingPointsInformation **ptr)\n{\n\tu32 oref_track, def_index=0;\n\tGF_TrackBox *trak = gf_isom_get_track_from_file(file, trackNumber);\n\tif (!ptr) return GF_FALSE;\n\toref_track=0;\n\tgf_isom_get_reference(file, trackNumber, GF_ISOM_REF_OREF, 1, &oref_track);\n\tif (oref_track) {\n\t\ttrak = gf_isom_get_track_from_file(file, oref_track);\n\t\tif (!trak) return GF_FALSE;\n\t}\n\t*ptr = (GF_OperatingPointsInformation *) gf_isom_get_sample_group_info_entry(file, trak, GF_ISOM_SAMPLE_GROUP_OINF, 1, &def_index, NULL);\n\treturn *ptr ? GF_TRUE : GF_FALSE;", "target": 0}
{"code": "void unix_inflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\tspin_lock(&unix_gc_lock);\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\t\tif (atomic_long_inc_return(&u->inflight) == 1) {\n\t\t\tBUG_ON(!list_empty(&u->link));\n\t\t\tlist_add_tail(&u->link, &gc_inflight_list);\n\t\t} else {\n\t\t\tBUG_ON(list_empty(&u->link));\n\t\t}\n\t\tunix_tot_inflight++;\n\t}\n\tuser->unix_inflight++;\n\tspin_unlock(&unix_gc_lock);\n}", "target": 0}
{"code": "void FrameFactory::rebuildAggregateFrames(ID3v2::Tag *tag) const\n{\n  if(tag->header()->majorVersion() < 4 &&\n     tag->frameList(\"TDRC\").size() == 1 &&\n     tag->frameList(\"TDAT\").size() == 1)\n  {\n    TextIdentificationFrame *tdrc =\n      static_cast<TextIdentificationFrame *>(tag->frameList(\"TDRC\").front());\n    UnknownFrame *tdat = static_cast<UnknownFrame *>(tag->frameList(\"TDAT\").front());\n    if(tdrc->fieldList().size() == 1 &&\n       tdrc->fieldList().front().size() == 4 &&\n       tdat->data().size() >= 5)\n    {\n      String date(tdat->data().mid(1), String::Type(tdat->data()[0]));\n      if(date.length() == 4) {\n        tdrc->setText(tdrc->toString() + '-' + date.substr(2, 2) + '-' + date.substr(0, 2));\n        if(tag->frameList(\"TIME\").size() == 1) {\n          UnknownFrame *timeframe = static_cast<UnknownFrame *>(tag->frameList(\"TIME\").front());\n          if(timeframe->data().size() >= 5) {\n            String time(timeframe->data().mid(1), String::Type(timeframe->data()[0]));\n            if(time.length() == 4) {\n              tdrc->setText(tdrc->toString() + 'T' + time.substr(0, 2) + ':' + time.substr(2, 2));\n            }\n          }\n        }\n      }\n    }\n  }\n}", "target": 1}
{"code": "ikev1_cert_print(netdissect_options *ndo, u_char tpay _U_,\n\t\t const struct isakmp_gen *ext, u_int item_len,\n\t\t const u_char *ep _U_, uint32_t phase _U_,\n\t\t uint32_t doi0 _U_,\n\t\t uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CERT)));\n\treturn NULL;\n}", "target": 0}
{"code": "pci_get_cfgdata8(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= PCI_REGMAX);\n\treturn (*(uint8_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "void slice_segment_header::set_defaults()\n{\n  slice_index = 0;\n  first_slice_segment_in_pic_flag = 1;\n  no_output_of_prior_pics_flag = 0;\n  slice_pic_parameter_set_id = 0;\n  dependent_slice_segment_flag = 0;\n  slice_segment_address = 0;\n  slice_type = SLICE_TYPE_I;\n  pic_output_flag = 1;\n  colour_plane_id = 0;\n  slice_pic_order_cnt_lsb = 0;\n  short_term_ref_pic_set_sps_flag = 1;\n  short_term_ref_pic_set_idx = 0;\n  num_long_term_sps = 0;\n  num_long_term_pics = 0;\n  slice_temporal_mvp_enabled_flag = 0;\n  slice_sao_luma_flag = 0;\n  slice_sao_chroma_flag = 0;\n  num_ref_idx_active_override_flag = 0;\n  num_ref_idx_l0_active=1; \n  num_ref_idx_l1_active=1; \n  ref_pic_list_modification_flag_l0 = 0;\n  ref_pic_list_modification_flag_l1 = 0;\n  mvd_l1_zero_flag = 0;\n  cabac_init_flag = 0;\n  collocated_from_l0_flag = 0;\n  collocated_ref_idx = 0;\n  luma_log2_weight_denom=0; \n  ChromaLog2WeightDenom=0;  \n  five_minus_max_num_merge_cand = 0;\n  slice_qp_delta = 0;\n  slice_cb_qp_offset = 0;\n  slice_cr_qp_offset = 0;\n  cu_chroma_qp_offset_enabled_flag = 0;\n  deblocking_filter_override_flag = 0;\n  slice_deblocking_filter_disabled_flag = 0;\n  slice_beta_offset=0; \n  slice_tc_offset=0;   \n  slice_loop_filter_across_slices_enabled_flag = 0;\n  num_entry_point_offsets = 0;\n  slice_segment_header_extension_length = 0;\n  SliceAddrRS = slice_segment_address;\n}", "target": 0}
{"code": "bool Archive::IsOpened()\n{\n#ifdef USE_ARCMEM\n  if (ArcMem.IsLoaded())\n    return true;\n#endif\n  return File::IsOpened();\n};", "target": 0}
{"code": "sraSpanInsertBefore(sraSpan *newspan, sraSpan *before) {\n  newspan->_next = before;\n  newspan->_prev = before->_prev;\n  before->_prev->_next = newspan;\n  before->_prev = newspan;\n}", "target": 1}
{"code": "bool DelegatedFrameHost::TransformPointToLocalCoordSpace(\n    const gfx::Point& point,\n    const viz::SurfaceId& original_surface,\n    gfx::Point* transformed_point) {\n  viz::SurfaceId surface_id(frame_sink_id_, local_surface_id_);\n  if (!surface_id.is_valid())\n    return false;\n  *transformed_point = point;\n  if (original_surface == surface_id)\n    return true;\n  viz::SurfaceHittest hittest(nullptr,\n                              GetFrameSinkManager()->surface_manager());\n  return hittest.TransformPointToTargetSurface(original_surface, surface_id,\n                                               transformed_point);\n}", "target": 0}
{"code": "static inline int ext4_should_dioread_nolock(struct inode *inode)\n{\n\tif (!test_opt(inode->i_sb, DIOREAD_NOLOCK))\n\t\treturn 0;\n\tif (test_opt(inode->i_sb, NOBH))\n\t\treturn 0;\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (!(EXT4_I(inode)->i_flags & EXT4_EXTENTS_FL))\n\t\treturn 0;\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\treturn 1;\n}", "target": 0}
{"code": "Value sendrawtransaction(const Array& params, bool fHelp)\n{\n    if (fHelp || params.size() < 1 || params.size() > 1)\n        throw runtime_error(\n            \"sendrawtransaction <hex string>\\n\"\n            \"Submits raw transaction (serialized, hex-encoded) to local node and network.\");\n    RPCTypeCheck(params, list_of(str_type));\n    vector<unsigned char> txData(ParseHex(params[0].get_str()));\n    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n    CTransaction tx;\n    try {\n        ssData >> tx;\n    }\n    catch (std::exception &e) {\n        throw JSONRPCError(-22, \"TX decode failed\");\n    }\n    uint256 hashTx = tx.GetHash();\n    CTransaction existingTx;\n    uint256 hashBlock = 0;\n    if (GetTransaction(hashTx, existingTx, hashBlock))\n    {\n        if (hashBlock != 0)\n            throw JSONRPCError(-5, string(\"transaction already in block \")+hashBlock.GetHex());\n    }\n    else\n    {\n        CTxDB txdb(\"r\");\n        if (!tx.AcceptToMemoryPool(txdb))\n            throw JSONRPCError(-22, \"TX rejected\");\n        SyncWithWallets(tx, NULL, true);\n    }\n    RelayMessage(CInv(MSG_TX, hashTx), tx);\n    return hashTx.GetHex();\n}", "target": 1}
{"code": "bool ArcMemory::Tell(int64 *Pos)\n{\n  if (!Loaded)\n    return false;\n  *Pos=SeekPos;\n  return true;\n}", "target": 0}
{"code": "uint64_t siphash_nocase(const uint8_t *in, const size_t inlen, const uint8_t *k)\n{\n    uint64_t hash;\n    uint8_t *out = (uint8_t*) &hash;\n    uint64_t v0 = 0x736f6d6570736575ULL;\n    uint64_t v1 = 0x646f72616e646f6dULL;\n    uint64_t v2 = 0x6c7967656e657261ULL;\n    uint64_t v3 = 0x7465646279746573ULL;\n    uint64_t k0 = U8TO64_LE(k);\n    uint64_t k1 = U8TO64_LE(k + 8);\n    uint64_t m;\n    const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));\n    const int left = inlen & 7;\n    uint64_t b = ((uint64_t)inlen) << 56;\n    v3 ^= k1;\n    v2 ^= k0;\n    v1 ^= k1;\n    v0 ^= k0;\n    for (; in != end; in += 8) {\n        m = U8TO64_LE_NOCASE(in);\n        v3 ^= m;\n        SIPROUND;\n        SIPROUND;\n        v0 ^= m;\n    }\n    switch (left) {\n    case 7: b |= ((uint64_t)tolower(in[6])) << 48;\n    case 6: b |= ((uint64_t)tolower(in[5])) << 40;\n    case 5: b |= ((uint64_t)tolower(in[4])) << 32;\n    case 4: b |= ((uint64_t)tolower(in[3])) << 24;\n    case 3: b |= ((uint64_t)tolower(in[2])) << 16;\n    case 2: b |= ((uint64_t)tolower(in[1])) << 8;\n    case 1: b |= ((uint64_t)tolower(in[0])); break;\n    case 0: break;\n    }\n    v3 ^= b;\n    SIPROUND;\n    SIPROUND;\n    v0 ^= b;\n    v2 ^= 0xff;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    SIPROUND;\n    b = v0 ^ v1 ^ v2 ^ v3;\n    U64TO8_LE(out, b);\n    return hash;\n}", "target": 0}
{"code": "void cipso_v4_req_delattr(struct request_sock *req)\n{\n\tstruct ip_options *opt;\n\tstruct inet_request_sock *req_inet;\n\treq_inet = inet_rsk(req);\n\topt = req_inet->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn;\n\tcipso_v4_delopt(&req_inet->opt);\n}", "target": 1}
{"code": "static void JS_FoxxAllowInstallFromRemote(v8::FunctionCallbackInfo<v8::Value> const& args) {\n  TRI_V8_TRY_CATCH_BEGIN(isolate)\n  v8::HandleScope scope(isolate);\n  TRI_GET_GLOBALS();\n  ServerSecurityFeature& security = v8g->_server.getFeature<ServerSecurityFeature>();\n  TRI_V8_RETURN_BOOL(security.foxxAllowInstallFromRemote());\n  TRI_V8_TRY_CATCH_END\n}", "target": 0}
{"code": "static int __init disable_acpi_irq(struct dmi_system_id *d)\n{\n\tif (!acpi_force) {\n\t\tprintk(KERN_NOTICE \"%s detected: force use of acpi=noirq\\n\",\n\t\t       d->ident);\n\t\tacpi_noirq_set();\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int blkdev_issue_flush(struct block_device *bdev, gfp_t gfp_mask,\n\t\tsector_t *error_sector)\n{\n\tstruct request_queue *q;\n\tstruct bio *bio;\n\tint ret = 0;\n\tif (bdev->bd_disk == NULL)\n\t\treturn -ENXIO;\n\tq = bdev_get_queue(bdev);\n\tif (!q)\n\t\treturn -ENXIO;\n\tif (!q->make_request_fn)\n\t\treturn -ENXIO;\n\tbio = bio_alloc(gfp_mask, 0);\n\tbio->bi_bdev = bdev;\n\tret = submit_bio_wait(WRITE_FLUSH, bio);\n\tif (error_sector)\n\t\t*error_sector = bio->bi_iter.bi_sector;\n\tbio_put(bio);\n\treturn ret;\n}", "target": 0}
{"code": "static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct user_element *ue = kcontrol->private_data;\n\tmutex_lock(&ue->card->user_ctl_lock);\n\tmemcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);\n\tmutex_unlock(&ue->card->user_ctl_lock);\n\treturn 0;\n}", "target": 0}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n    if( (*p) + len > end )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 0}
{"code": "RenderWidgetHostViewPort* GetRenderWidgetHostViewFromSurfaceID(\n    int surface_id) {\n  int render_process_id = 0;\n  int render_widget_id = 0;\n  if (!GpuSurfaceTracker::Get()->GetRenderWidgetIDForSurface(\n        surface_id, &render_process_id, &render_widget_id))\n    return NULL;\n  content::RenderProcessHost* process =\n      content::RenderProcessHost::FromID(render_process_id);\n  if (!process)\n    return NULL;\n  content::RenderWidgetHost* host = process->GetRenderWidgetHostByID(\n      render_widget_id);\n  return host ? RenderWidgetHostViewPort::FromRWHV(host->GetView()) : NULL;\n}", "target": 0}
{"code": "gss_wrap_size_limit(OM_uint32  *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int conf_req_flag,\n                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)\n{\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    OM_uint32           major_status;\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n    if (max_input_size == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n        return (GSS_S_BAD_MECH);\n    if (mech->gss_wrap_size_limit)\n        major_status = mech->gss_wrap_size_limit(minor_status,\n                                                 ctx->internal_ctx_id,\n                                                 conf_req_flag, qop_req,\n                                                 req_output_size, max_input_size);\n    else if (mech->gss_wrap_iov_length)\n        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,\n                                                       ctx->internal_ctx_id,\n                                                       conf_req_flag, qop_req,\n                                                       req_output_size, max_input_size);\n    else\n        major_status = GSS_S_UNAVAILABLE;\n    if (major_status != GSS_S_COMPLETE)\n        map_error(minor_status, mech);\n    return major_status;\n}", "target": 0}
{"code": "    static CImg<T> get_load_camera(const unsigned int camera_index=0, const unsigned int skip_frames=0,\n                                   const bool release_camera=true,\n                                   const unsigned int capture_width=0, const unsigned int capture_height=0) {\n      return CImg<T>().load_camera(camera_index,skip_frames,release_camera,capture_width,capture_height);", "target": 0}
{"code": "bool ArcMemory::Unload()\n{\n  if (!Loaded)\n    return false;\n  Loaded=false;\n  return true;\n}", "target": 0}
{"code": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\tref->ref++;\n}", "target": 1}
{"code": "FPDF_SYSTEMTIME PDFiumEngine::Form_GetLocalTime(FPDF_FORMFILLINFO* param) {\n  base::Time time = base::Time::Now();\n  base::Time::Exploded exploded;\n  time.LocalExplode(&exploded);\n  FPDF_SYSTEMTIME rv;\n  rv.wYear = exploded.year;\n  rv.wMonth = exploded.month;\n  rv.wDayOfWeek = exploded.day_of_week;\n  rv.wDay = exploded.day_of_month;\n  rv.wHour = exploded.hour;\n  rv.wMinute = exploded.minute;\n  rv.wSecond = exploded.second;\n  rv.wMilliseconds = exploded.millisecond;\n  return rv;\n}", "target": 0}
{"code": "static int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n            if (*ptr == '\\0')\n                return 1;\n            if (*ptr == '%')\n                ptr++;\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n            else {\n                if (*ptr == ' ')\n                    ptr++;\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n    return (n != 3);\n}", "target": 1}
{"code": "static int llc_ui_autobind(struct socket *sock, struct sockaddr_llc *addr)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct llc_sock *llc = llc_sk(sk);\n\tstruct llc_sap *sap;\n\tint rc = -EINVAL;\n\tif (!sock_flag(sk, SOCK_ZAPPED))\n\t\tgoto out;\n\tif (!addr->sllc_arphrd)\n\t\taddr->sllc_arphrd = ARPHRD_ETHER;\n\tif (addr->sllc_arphrd != ARPHRD_ETHER)\n\t\tgoto out;\n\trc = -ENODEV;\n\tif (sk->sk_bound_dev_if) {\n\t\tllc->dev = dev_get_by_index(&init_net, sk->sk_bound_dev_if);\n\t\tif (llc->dev && addr->sllc_arphrd != llc->dev->type) {\n\t\t\tdev_put(llc->dev);\n\t\t\tllc->dev = NULL;\n\t\t}\n\t} else\n\t\tllc->dev = dev_getfirstbyhwtype(&init_net, addr->sllc_arphrd);\n\tif (!llc->dev)\n\t\tgoto out;\n\tnetdev_tracker_alloc(llc->dev, &llc->dev_tracker, GFP_KERNEL);\n\trc = -EUSERS;\n\tllc->laddr.lsap = llc_ui_autoport();\n\tif (!llc->laddr.lsap)\n\t\tgoto out;\n\trc = -EBUSY; \n\tsap = llc_sap_open(llc->laddr.lsap, NULL);\n\tif (!sap)\n\t\tgoto out;\n\tmemcpy(llc->laddr.mac, llc->dev->dev_addr, IFHWADDRLEN);\n\tmemcpy(&llc->addr, addr, sizeof(llc->addr));\n\tllc_sap_add_socket(sap, sk);\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\trc = 0;\nout:\n\tif (rc) {\n\t\tdev_put_track(llc->dev, &llc->dev_tracker);\n\t\tllc->dev = NULL;\n\t}\n\treturn rc;\n}", "target": 0}
{"code": "static s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)\n{\n\tu32 m = EMPTY_QUEUE;\n\tu32 __iomem *msg;\n\tulong timeout = jiffies + 30*HZ;\n\tdo {\n\t\trmb();\n\t\tm = readl(pHba->post_port);\n\t\tif (m != EMPTY_QUEUE) {\n\t\t\tbreak;\n\t\t}\n\t\tif(time_after(jiffies,timeout)){\n\t\t\tprintk(KERN_WARNING\"dpti%d: Timeout waiting for message frame!\\n\", pHba->unit);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tschedule_timeout_uninterruptible(1);\n\t} while(m == EMPTY_QUEUE);\n\tmsg = pHba->msg_addr_virt + m;\n\tmemcpy_toio(msg, data, len);\n\twmb();\n\twritel(m, pHba->post_port);\n\twmb();\n\treturn 0;\n}", "target": 1}
{"code": "atmarp_tpaddr_print(netdissect_options *ndo,\n\t\t    const struct atmarp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (ATMTPROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong tplen>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, ATMTPA(ap))));\n}", "target": 0}
{"code": "static void tcp_illinois_info(struct sock *sk, u32 ext,\n\t\t\t      struct sk_buff *skb)\n{\n\tconst struct illinois *ca = inet_csk_ca(sk);\n\tif (ext & (1 << (INET_DIAG_VEGASINFO - 1))) {\n\t\tstruct tcpvegas_info info = {\n\t\t\t.tcpv_enabled = 1,\n\t\t\t.tcpv_rttcnt = ca->cnt_rtt,\n\t\t\t.tcpv_minrtt = ca->base_rtt,\n\t\t};\n\t\tu64 t = ca->sum_rtt;\n\t\tdo_div(t, ca->cnt_rtt);\n\t\tinfo.tcpv_rtt = t;\n\t\tnla_put(skb, INET_DIAG_VEGASINFO, sizeof(info), &info);\n\t}\n}", "target": 1}
{"code": "header_put_le_3byte (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 3)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\t} ;\n} ", "target": 1}
{"code": "int common_timer_set(struct k_itimer *timr, int flags,\n\t\t     struct itimerspec64 *new_setting,\n\t\t     struct itimerspec64 *old_setting)\n{\n\tconst struct k_clock *kc = timr->kclock;\n\tbool sigev_none;\n\tktime_t expires;\n\tif (old_setting)\n\t\tcommon_timer_get(timr, old_setting);\n\ttimr->it_interval = 0;\n\tif (kc->timer_try_to_cancel(timr) < 0)\n\t\treturn TIMER_RETRY;\n\ttimr->it_active = 0;\n\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}", "target": 1}
{"code": "static void dns_handler(int dns_err, const struct sa *srv, void *arg)\n{\n\tstruct lookup_entry *lent = arg;\n\tstruct sa turn_srv;\n\tre_printf(\"DNS lookup for: %s err=%d\\n\", lent->host, dns_err);\n\tif (dns_err)\n\t\tgoto out;\n\tsa_cpy(&turn_srv, srv);\n\tsa_set_port(&turn_srv, lent->port);\n\tre_printf(\"DNS lookup success: %s -> %J(proto=%s secure=%d)\\n\",\n\t\t  lent->host, &turn_srv, net_proto2name(lent->proto),\n\t\t  lent->secure);\n\tstart_netprobe(&turn_srv, lent->proto, lent->secure,\n\t\t       lent->turn.username, lent->turn.credential);\n out:\n\tmem_deref(lent);\n}", "target": 0}
{"code": "int _mkp_stage_30(struct plugin *p,\n        struct client_session *cs,\n        struct session_request *sr)\n{\n    mk_ptr_t referer;\n    (void) p;\n    (void) cs;\n    PLUGIN_TRACE(\"[FD %i] Mandril validating URL\", cs->socket);\n    if (mk_security_check_url(sr->uri) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, blocked URL\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    PLUGIN_TRACE(\"[FD %d] Mandril validating hotlinking\", cs->socket);\n    referer = mk_api->header_get(&sr->headers_toc, \"Referer\", strlen(\"Referer\"));\n    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {\n        PLUGIN_TRACE(\"[FD %i] Close connection, deny hotlinking.\", cs->socket);\n        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);\n        return MK_PLUGIN_RET_CLOSE_CONX;\n    }\n    return MK_PLUGIN_RET_NOT_ME;\n}", "target": 1}
{"code": "MagickExport void *AcquireAlignedMemory(const size_t count,const size_t quantum)\n{\n#define AlignedExtent(size,alignment) \\\n  (((size)+((alignment)-1)) & ~((alignment)-1))\n  size_t\n    alignment,\n    extent,\n    size;\n  void\n    *memory;\n  if (CheckMemoryOverflow(count,quantum) != MagickFalse)\n    return((void *) NULL);\n  memory=NULL;\n  alignment=CACHE_LINE_SIZE;\n  size=count*quantum;\n  extent=AlignedExtent(size,alignment);\n  if ((size == 0) || (alignment < sizeof(void *)) || (extent < size))\n    return((void *) NULL);\n#if defined(MAGICKCORE_HAVE_POSIX_MEMALIGN)\n  if (posix_memalign(&memory,alignment,extent) != 0)\n    memory=NULL;\n#elif defined(MAGICKCORE_HAVE__ALIGNED_MALLOC)\n  memory=_aligned_malloc(extent,alignment);\n#else\n  {\n    void\n      *p;\n    extent=(size+alignment-1)+sizeof(void *);\n    if (extent > size)\n      {\n        p=malloc(extent);\n        if (p != NULL)\n          {\n            memory=(void *) AlignedExtent((size_t) p+sizeof(void *),alignment);\n            *((void **) memory-1)=p;\n          }\n      }\n  }\n#endif\n  return(memory);\n}", "target": 1}
{"code": "void preprocessNodes(std::vector<Proxy> &nodes, extra_settings &ext)\n{\n    std::for_each(nodes.begin(), nodes.end(), [&ext](Proxy &x)\n    {\n        if(ext.remove_emoji)\n            x.Remark = trim(removeEmoji(x.Remark));\n        nodeRename(x, ext.rename_array, ext);\n        if(ext.add_emoji)\n            x.Remark = addEmoji(x, ext.emoji_array, ext);\n    });\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size())\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                try\n                {\n                    ctx.eval(script);\n                    auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(\"compare\");\n                    auto comparer = [&](const Proxy &a, const Proxy &b)\n                    {\n                        if(a.Type == ProxyType::Unknow)\n                            return 1;\n                        if(b.Type == ProxyType::Unknow)\n                            return 0;\n                        return compare(a, b);\n                    };\n                    std::stable_sort(nodes.begin(), nodes.end(), comparer);\n                    failed = false;\n                }\n                catch(qjs::exception)\n                {\n                    script_print_stack(ctx);\n                }\n            }, global.scriptCleanContext);\n        }\n        if(failed) std::stable_sort(nodes.begin(), nodes.end(), [](const Proxy &a, const Proxy &b)\n        {\n            return a.Remark < b.Remark;\n        });\n    }\n}", "target": 1}
{"code": "pci_set_cfgdata16(struct pci_vdev *dev, int offset, uint16_t val)\n{\n\tassert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);\n\t*(uint16_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "RawTile KakaduImage::getRegion( int seq, int ang, unsigned int res, int layers, int x, int y, unsigned int w, unsigned int h )\n{\n  unsigned int obpc = bpc;\n  if( bpc <= 16 && bpc > 8 ) obpc = 16;\n  else if( bpc <= 8 ) obpc = 8;\n#ifdef DEBUG\n  Timer timer;\n  timer.start();\n#endif\n  RawTile rawtile( 0, res, seq, ang, w, h, channels, obpc );\n  if( obpc == 16 ) rawtile.data = new unsigned short[w*h*channels];\n  else if( obpc == 8 ) rawtile.data = new unsigned char[w*h*channels];\n  else throw file_error( \"Kakadu :: Unsupported number of bits\" );\n  rawtile.dataLength = w*h*channels*(obpc/8);\n  rawtile.filename = getImagePath();\n  rawtile.timestamp = timestamp;\n  process( res, layers, x, y, w, h, rawtile.data );\n#ifdef DEBUG\n  logfile << \"Kakadu :: getRegion() :: \" << timer.getTime() << \" microseconds\" << endl;\n#endif\n  return rawtile;\n}", "target": 1}
{"code": "sixel_allocator_malloc(\n    sixel_allocator_t    *allocator,  \n    size_t               n)           \n{\n    assert(allocator);\n    assert(allocator->fn_malloc);\n    if (n == 0) {\n        sixel_helper_set_additional_message(\n            \"sixel_allocator_malloc: called with n == 0\");\n        return NULL;\n    }\n    if (n > SIXEL_ALLOCATE_BYTES_MAX) {\n        return NULL;\n    }\n    return allocator->fn_malloc(n);\n}", "target": 0}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& input = ctx->input(0);\n    OP_REQUIRES(ctx, ctx->input(1).NumElements() > 0,\n                errors::InvalidArgument(\"Input min must not be empty.\"));\n    OP_REQUIRES(ctx, ctx->input(2).NumElements() > 0,\n                errors::InvalidArgument(\"Input max must not be empty.\"));\n    const float input_min_float = ctx->input(1).flat<float>()(0);\n    const float input_max_float = ctx->input(2).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &output_min));\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_max));\n    qint32 used_min_quantized;\n    qint32 used_max_quantized;\n    CalculateUsedRange(input, &used_min_quantized, &used_max_quantized);\n    const float used_min_float = std::min(\n        0.0f,\n        QuantizedToFloat(used_min_quantized, input_min_float, input_max_float));\n    const float used_max_float =\n        QuantizedToFloat(used_max_quantized, input_min_float, input_max_float);\n    output_min->flat<float>().setConstant(used_min_float);\n    output_max->flat<float>().setConstant(used_max_float);\n  }", "target": 0}
{"code": "TEST_F(RaggedRangeOpTest, RangeSizeOverflow) {\n  BuildRaggedRangeGraph<float>();\n  AddInputFromArray<float>(TensorShape({2}), {1.1, 0.1});    \n  AddInputFromArray<float>(TensorShape({2}), {10.0, 1e10});  \n  AddInputFromArray<float>(TensorShape({2}), {1, 1e-10});    \n  EXPECT_EQ(absl::StrCat(\"Requires ((limit - start) / delta) <= \",\n                         std::numeric_limits<int64_t>::max()),\n            RunOpKernel().error_message());\n}", "target": 0}
{"code": "int mpol_parse_str(char *str, struct mempolicy **mpol)\n{\n\tstruct mempolicy *new = NULL;\n\tunsigned short mode_flags;\n\tnodemask_t nodes;\n\tchar *nodelist = strchr(str, ':');\n\tchar *flags = strchr(str, '=');\n\tint err = 1, mode;\n\tif (flags)\n\t\t*flags++ = '\\0';\t\n\tif (nodelist) {\n\t\t*nodelist++ = '\\0';\n\t\tif (nodelist_parse(nodelist, nodes))\n\t\t\tgoto out;\n\t\tif (!nodes_subset(nodes, node_states[N_MEMORY]))\n\t\t\tgoto out;\n\t} else\n\t\tnodes_clear(nodes);\n\tmode = match_string(policy_modes, MPOL_MAX, str);\n\tif (mode < 0)\n\t\tgoto out;\n\tswitch (mode) {\n\tcase MPOL_PREFERRED:\n\t\tif (nodelist) {\n\t\t\tchar *rest = nodelist;\n\t\t\twhile (isdigit(*rest))\n\t\t\t\trest++;\n\t\t\tif (*rest)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase MPOL_INTERLEAVE:\n\t\tif (!nodelist)\n\t\t\tnodes = node_states[N_MEMORY];\n\t\tbreak;\n\tcase MPOL_LOCAL:\n\t\tif (nodelist)\n\t\t\tgoto out;\n\t\tmode = MPOL_PREFERRED;\n\t\tbreak;\n\tcase MPOL_DEFAULT:\n\t\tif (!nodelist)\n\t\t\terr = 0;\n\t\tgoto out;\n\tcase MPOL_BIND:\n\t\tif (!nodelist)\n\t\t\tgoto out;\n\t}\n\tmode_flags = 0;\n\tif (flags) {\n\t\tif (!strcmp(flags, \"static\"))\n\t\t\tmode_flags |= MPOL_F_STATIC_NODES;\n\t\telse if (!strcmp(flags, \"relative\"))\n\t\t\tmode_flags |= MPOL_F_RELATIVE_NODES;\n\t\telse\n\t\t\tgoto out;\n\t}\n\tnew = mpol_new(mode, mode_flags, &nodes);\n\tif (IS_ERR(new))\n\t\tgoto out;\n\tif (mode != MPOL_PREFERRED)\n\t\tnew->v.nodes = nodes;\n\telse if (nodelist)\n\t\tnew->v.preferred_node = first_node(nodes);\n\telse\n\t\tnew->flags |= MPOL_F_LOCAL;\n\tnew->w.user_nodemask = nodes;\n\terr = 0;\nout:\n\tif (nodelist)\n\t\t*--nodelist = ':';\n\tif (flags)\n\t\t*--flags = '=';\n\tif (!err)\n\t\t*mpol = new;\n\treturn err;\n}", "target": 1}
{"code": "int wvlan_set_station_nickname(struct net_device *dev,\n\t\t      struct iw_request_info *info,\n\t\t      union iwreq_data *wrqu,\n\t\t      char *extra)\n{\n\tstruct wl_private *lp = wl_priv(dev);\n\tunsigned long flags;\n\tint         ret = 0;\n\tDBG_FUNC(\"wvlan_set_station_nickname\");\n\tDBG_ENTER(DbgInfo);\n\twl_lock(lp, &flags);\n\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\tmemcpy(lp->StationName, extra, wrqu->data.length);\n\twl_apply(lp);\n\twl_unlock(lp, &flags);\n\tDBG_LEAVE(DbgInfo);\n\treturn ret;\n} ", "target": 1}
{"code": "fbFetchPixel_g1 (const FbBits *bits, int offset, miIndexedPtr indexed)\n{\n    CARD32 pixel = ((CARD32 *)bits)[offset >> 5];\n    CARD32 a;\n#if BITMAP_BIT_ORDER == MSBFirst\n    a = pixel >> (0x1f - (offset & 0x1f));\n#else\n    a = pixel >> (offset & 0x1f);\n#endif\n    a = a & 1;\n    return indexed->rgba[a];\n}", "target": 0}
{"code": "static int oidc_session_redirect_parent_window_to_logout(request_rec *r,\n\t\toidc_cfg *c) {\n\toidc_debug(r, \"enter\");\n\tchar *java_script = apr_psprintf(r->pool,\n\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\"      window.top.location.href = '%s?session=logout';\\n\"\n\t\t\t\"    </script>\\n\", oidc_get_redirect_uri(r, c));\n\treturn oidc_util_html_send(r, \"Redirecting...\", java_script, NULL, NULL,\n\t\t\tOK);\n}", "target": 1}
{"code": "vips_malloc( VipsObject *object, size_t size )\n{\n\tvoid *buf;\n\tbuf = g_malloc( size );\n        if( object ) {\n\t\tg_signal_connect( object, \"postclose\", \n\t\t\tG_CALLBACK( vips_malloc_cb ), buf );\n\t\tobject->local_memory += size;\n\t}\n\treturn( buf );\n}", "target": 1}
{"code": "void sw_crypto_acipher_free_rsa_keypair(struct rsa_keypair *s)\n{\n\tif (!s)\n\t\treturn;\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}", "target": 1}
{"code": "static int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid, \n\t\t  void *opblk_va,  dma_addr_t opblk_pa, int oplen,\n\t\tvoid *resblk_va, dma_addr_t resblk_pa, int reslen)\n{\n\tu32 msg[9]; \n\tu32 *res = (u32 *)resblk_va;\n\tint wait_status;\n\tmsg[0] = NINE_WORD_MSG_SIZE | SGL_OFFSET_5;\n\tmsg[1] = cmd << 24 | HOST_TID << 12 | tid; \n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tmsg[4] = 0;\n\tmsg[5] = 0x54000000 | oplen;\t\n\tmsg[6] = (u32)opblk_pa;\n\tmsg[7] = 0xD0000000 | reslen;\t\n\tmsg[8] = (u32)resblk_pa;\n\tif ((wait_status = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 20))) {\n\t\tprintk(\"adpt_i2o_issue_params: post_wait failed (%p)\\n\", resblk_va);\n   \t\treturn wait_status; \t\n\t}\n\tif (res[1]&0x00FF0000) { \t\n\t\tprintk(KERN_WARNING \"%s: %s - Error:\\n  ErrorInfoSize = 0x%02x, \"\n\t\t\t\"BlockStatus = 0x%02x, BlockSize = 0x%04x\\n\",\n\t\t\tpHba->name,\n\t\t\t(cmd == I2O_CMD_UTIL_PARAMS_SET) ? \"PARAMS_SET\"\n\t\t\t\t\t\t\t : \"PARAMS_GET\",   \n\t\t\tres[1]>>24, (res[1]>>16)&0xFF, res[1]&0xFFFF);\n\t\treturn -((res[1] >> 16) & 0xFF); \n\t}\n\treturn 4 + ((res[1] & 0x0000FFFF) << 2); \n}", "target": 1}
{"code": "        int          Read(void* pDestBuffer, int nSize)\n        {\n            if ( m_nPos + nSize >= m_nLen )\n                nSize = m_nLen - m_nPos - 1;\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n            return nSize;\n        }", "target": 1}
{"code": "void generic_pipe_buf_get(struct pipe_inode_info *pipe, struct pipe_buffer *buf)\n{\n\tget_page(buf->page);\n}", "target": 1}
{"code": "static int htc_setup_complete(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_comp_msg *comp_msg;\n\tint ret = 0;\n\tunsigned long time_left;\n\tskb = alloc_skb(50 + sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"failed to allocate send buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tcomp_msg = skb_put(skb, sizeof(struct htc_comp_msg));\n\tcomp_msg->msg_id = cpu_to_be16(HTC_MSG_SETUP_COMPLETE_ID);\n\ttarget->htc_flags |= HTC_OP_START_WAIT;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"HTC start timeout\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn -EINVAL;\n}", "target": 0}
{"code": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\tu64 nsec;\n\tu64 rem;\n\tnsec = rtc_time() * sgi_clock_period;\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "  bool hasEncodingError() const {\n    return encodingError_;\n  }", "target": 0}
{"code": "bool LIRGenerator::can_store_as_constant(Value v, BasicType type) const {\n  if (type == T_SHORT || type == T_CHAR) {\n    return false;\n  }\n  Constant* c = v->as_Constant();\n  if (c && c->state_before() == NULL) {\n    return true;\n  }\n  return false;\n}", "target": 0}
{"code": "pipe_iov_copy_from_user(void *to, struct iovec *iov, unsigned long len,\n\t\t\tint atomic)\n{\n\tunsigned long copy;\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\t\tif (atomic) {\n\t\t\tif (__copy_from_user_inatomic(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_from_user(to, iov->iov_base, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tto += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\tif (!ss_initialized) {\n\t\tint i;\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\tif (force) {\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}", "target": 0}
{"code": "static int parse_token(char **name, char **value, char **cp)\n{\n\tchar *end;\n\tif (!name || !value || !cp)\n\t\treturn -BLKID_ERR_PARAM;\n\tif (!(*value = strchr(*cp, '=')))\n\t\treturn 0;\n\t**value = '\\0';\n\t*name = strip_line(*cp);\n\t*value = skip_over_blank(*value + 1);\n\tif (**value == '\"') {\n\t\tend = strchr(*value + 1, '\"');\n\t\tif (!end) {\n\t\t\tDBG(READ, ul_debug(\"unbalanced quotes at: %s\", *value));\n\t\t\t*cp = *value;\n\t\t\treturn -BLKID_ERR_CACHE;\n\t\t}\n\t\t(*value)++;\n\t\t*end = '\\0';\n\t\tend++;\n\t} else {\n\t\tend = skip_over_word(*value);\n\t\tif (*end) {\n\t\t\t*end = '\\0';\n\t\t\tend++;\n\t\t}\n\t}\n\t*cp = end;\n\treturn 1;\n}", "target": 1}
{"code": "inline typename V::VectorType FBUnserializer<V>::unserializeVector() {\n  p_ += CODE_SIZE;\n  typename V::VectorType ret = V::createVector();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "void Triangle(double x1,double y1,double x2,double y2,double x3,double y3) {\n    outpos +=\n    sprintf(outpos,\"\\n %12.3f %12.3f m %12.3f %12.3f l %12.3f %12.3f l h\",x1,y1,x2,y2,x3,y3);\n}", "target": 1}
{"code": "error::Error GLES2DecoderImpl::HandleGetUniformfv(\n    uint32 immediate_data_size, const gles2::GetUniformfv& c) {\n  GLuint program = c.program;\n  GLint fake_location = program_manager()->UnswizzleLocation(c.location);\n  GLuint service_id;\n  GLint real_location = -1;\n  Error error;\n  typedef gles2::GetUniformfv::Result Result;\n  Result* result;\n  GLenum result_type;\n  if (GetUniformSetup(\n      program, fake_location, c.params_shm_id, c.params_shm_offset,\n      &error, &real_location, &service_id,\n      reinterpret_cast<void**>(&result), &result_type)) {\n    if (result_type == GL_BOOL || result_type == GL_BOOL_VEC2 ||\n        result_type == GL_BOOL_VEC3 || result_type == GL_BOOL_VEC4) {\n      GLsizei num_values = result->GetNumResults();\n      scoped_array<GLint> temp(new GLint[num_values]);\n      glGetUniformiv(service_id, real_location, temp.get());\n      GLfloat* dst = result->GetData();\n      for (GLsizei ii = 0; ii < num_values; ++ii) {\n        dst[ii] = (temp[ii] != 0);\n      }\n    } else {\n      glGetUniformfv(service_id, real_location, result->GetData());\n    }\n  }\n  return error;\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MaxMinSelectCorrectlyOrderedIndex) {\n    addIndex(BSON(\"a\" << 1));\n    addIndex(BSON(\"a\" << -1));\n    runQueryFull(\n        BSONObj(), BSONObj(), BSONObj(), 0, 0, BSONObj(), fromjson(\"{a: 8}\"), fromjson(\"{a: 2}\"));\n    assertNumSolutions(1);\n    assertSolutionExists(\"{fetch: {node: {ixscan: {filter: null, dir: 1, pattern: {a: -1}}}}}\");\n    runQueryFull(\n        BSONObj(), BSONObj(), BSONObj(), 0, 0, BSONObj(), fromjson(\"{a: 2}\"), fromjson(\"{a: 8}\"));\n    assertNumSolutions(1);\n    assertSolutionExists(\"{fetch: {node: {ixscan: {filter: null, dir: 1, pattern: {a: 1}}}}}\");\n}", "target": 0}
{"code": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\tif (posix_timer_event(timr, si_private)) {\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += (unsigned int)\n\t\t\t\thrtimer_forward(timer, now,\n\t\t\t\t\t\ttimr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\tunlock_timer(timr, flags);\n\treturn ret;\n}", "target": 1}
{"code": "local block_state deflate_huff(s, flush)\n    deflate_state *s;\n    int flush;\n{\n    int bflush;             \n    for (;;) {\n        if (s->lookahead == 0) {\n            fill_window(s);\n            if (s->lookahead == 0) {\n                if (flush == Z_NO_FLUSH)\n                    return need_more;\n                break;      \n            }\n        }\n        s->match_length = 0;\n        Tracevv((stderr,\"%c\", s->window[s->strstart]));\n        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}", "target": 1}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                if (cid <= 0)\n                    continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "void builtinFetchurl(const BasicDerivation & drv)\n{\n    auto url = drv.env.find(\"url\");\n    if (url == drv.env.end()) throw Error(\"attribute url missing\");\n    printMsg(lvlInfo, format(\"downloading %1%...\") % url->second);\n    auto data = downloadFile(url->second); \n    auto out = drv.env.find(\"out\");\n    if (out == drv.env.end()) throw Error(\"attribute url missing\");\n    writeFile(out->second, data.data);\n    auto executable = drv.env.find(\"executable\");\n    if (executable != drv.env.end() && executable->second == \"1\") {\n        if (chmod(out->second.c_str(), 0755) == -1)\n            throw SysError(format(\"making %1% executable\") % out->second);\n    }\n}", "target": 1}
{"code": "int CJSON_CDECL main(void)\n{\n    UNITY_BEGIN();\n    RUN_TEST(cjson_array_foreach_should_loop_over_arrays);\n    RUN_TEST(cjson_array_foreach_should_not_dereference_null_pointer);\n    RUN_TEST(cjson_get_object_item_should_get_object_items);\n    RUN_TEST(cjson_get_object_item_case_sensitive_should_get_object_items);\n    RUN_TEST(cjson_get_object_item_should_not_crash_with_array);\n    RUN_TEST(cjson_get_object_item_case_sensitive_should_not_crash_with_array);\n    RUN_TEST(typecheck_functions_should_check_type);\n    RUN_TEST(cjson_should_not_parse_to_deeply_nested_jsons);\n    RUN_TEST(cjson_set_number_value_should_set_numbers);\n    RUN_TEST(cjson_detach_item_via_pointer_should_detach_items);\n    RUN_TEST(cjson_replace_item_via_pointer_should_replace_items);\n    RUN_TEST(cjson_replace_item_in_object_should_preserve_name);\n    RUN_TEST(cjson_functions_shouldnt_crash_with_null_pointers);\n    RUN_TEST(ensure_should_fail_on_failed_realloc);\n    RUN_TEST(skip_utf8_bom_should_skip_bom);\n    RUN_TEST(skip_utf8_bom_should_not_skip_bom_if_not_at_beginning);\n    RUN_TEST(cjson_get_string_value_should_get_a_string);\n    RUN_TEST(cjson_create_string_reference_should_create_a_string_reference);\n    RUN_TEST(cjson_create_object_reference_should_create_an_object_reference);\n    RUN_TEST(cjson_create_array_reference_should_create_an_array_reference);\n    RUN_TEST(cjson_add_item_to_object_should_not_use_after_free_when_string_is_aliased);\n    return UNITY_END();\n}", "target": 0}
{"code": "mountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tnd->flags &= ~LOOKUP_PARENT;\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n\tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n\t\treturn 1;\n\tfollow_mount(path);\n\terror = 0;\nout:\n\tterminate_walk(nd);\n\treturn error;\n}", "target": 1}
{"code": "static void *gp_worker_main(void *pvt)\n{\n    struct gp_thread *t = (struct gp_thread *)pvt;\n    struct gp_query *q = NULL;\n    char dummy = 0;\n    int ret;\n    while (!t->pool->shutdown) {\n        gp_debug_set_conn_id(0);\n        pthread_mutex_lock(&t->cond_mutex);\n        while (t->query == NULL) {\n            pthread_cond_wait(&t->cond_wakeup, &t->cond_mutex);\n            if (t->pool->shutdown) {\n                pthread_mutex_unlock(&t->cond_mutex);\n                pthread_exit(NULL);\n            }\n        }\n        q = t->query;\n        t->query = NULL;\n        pthread_mutex_unlock(&t->cond_mutex);\n        gp_debug_set_conn_id(gp_conn_get_cid(q->conn));\n        GPDEBUGN(3, \"[status] Handling query input: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        gp_handle_query(t->pool, q);\n        GPDEBUGN(3 ,\"[status] Handling query output: %p (%zu)\\n\", q->buffer,\n                 q->buflen);\n        pthread_mutex_lock(&t->pool->lock);\n        q->next = t->pool->reply_list;\n        t->pool->reply_list = q;\n        if (!t->pool->shutdown) {\n            LIST_DEL(t->pool->busy_list, t);\n            LIST_ADD(t->pool->free_list, t);\n        }\n        pthread_mutex_unlock(&t->pool->lock);\n        ret = write(t->pool->sig_pipe[1], &dummy, 1);\n        if (ret == -1) {\n            GPERROR(\"Failed to signal dispatcher!\");\n        }\n    }\n    pthread_exit(NULL);\n}", "target": 0}
{"code": "SYSCALL_DEFINE5(add_key, const char __user *, _type,\n\t\tconst char __user *, _description,\n\t\tconst void __user *, _payload,\n\t\tsize_t, plen,\n\t\tkey_serial_t, ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tchar type[32], *description;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\tdescription = NULL;\n\tif (_description) {\n\t\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(description)) {\n\t\t\tret = PTR_ERR(description);\n\t\t\tgoto error;\n\t\t}\n\t\tif (!*description) {\n\t\t\tkfree(description);\n\t\t\tdescription = NULL;\n\t\t} else if ((description[0] == '.') &&\n\t\t\t   (strncmp(type, \"keyring\", 7) == 0)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error2;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error3;\n\t}\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error3;\n\t}\n\tkey_ref = key_create_or_update(keyring_ref, type, description,\n\t\t\t\t       payload, plen, KEY_PERM_UNDEF,\n\t\t\t\t       KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key_ref)) {\n\t\tret = key_ref_to_ptr(key_ref)->serial;\n\t\tkey_ref_put(key_ref);\n\t}\n\telse {\n\t\tret = PTR_ERR(key_ref);\n\t}\n\tkey_ref_put(keyring_ref);\n error3:\n\tkvfree(payload);\n error2:\n\tkfree(description);\n error:\n\treturn ret;\n}", "target": 1}
{"code": "static int crypto_rng_init_tfm(struct crypto_tfm *tfm)\n{\n\tstruct crypto_rng *rng = __crypto_rng_cast(tfm);\n\tstruct rng_alg *alg = crypto_rng_alg(rng);\n\tstruct old_rng_alg *oalg = crypto_old_rng_alg(rng);\n\tif (oalg->rng_make_random) {\n\t\trng->generate = generate;\n\t\trng->seed = rngapi_reset;\n\t\trng->seedsize = oalg->seedsize;\n\t\treturn 0;\n\t}\n\trng->generate = alg->generate;\n\trng->seed = alg->seed;\n\trng->seedsize = alg->seedsize;\n\treturn 0;\n}", "target": 1}
{"code": "int delete_sdp_line( struct sip_msg * msg, char * s, struct sdp_stream_cell *stream)\n{\n\tchar * start,*end;\n\tif( !s )\n\t\treturn 1;\n\tstart = s;\n\tend  = s;\n\twhile(*start != '\\n' && start > stream->body.s)\n\t\tstart--;\n\tstart++;\n\twhile(*end != '\\n' && end < (stream->body.s+stream->body.len) )\n\t\tend++;\n\tif ( *end == '\\n')\n\t\tend++;\n\tif( del_lump(msg, start - msg->buf, end - start,0) == NULL )\n\t{\n\t\treturn -1;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int mg_http_parse(const char *s, size_t len, struct mg_http_message *hm) {\n  int is_response, req_len = mg_http_get_request_len((unsigned char *) s, len);\n  const char *end = s == NULL ? NULL : s + req_len, *qs;  \n  struct mg_str *cl;\n  memset(hm, 0, sizeof(*hm));\n  if (req_len <= 0) return req_len;\n  hm->message.ptr = hm->head.ptr = s;\n  hm->body.ptr = end;\n  hm->head.len = (size_t) req_len;\n  hm->chunk.ptr = end;\n  hm->message.len = hm->body.len = (size_t) ~0;  \n  s = skip(s, end, \" \", &hm->method);\n  s = skip(s, end, \" \", &hm->uri);\n  s = skip(s, end, \"\\r\\n\", &hm->proto);\n  if (hm->method.len == 0 || hm->uri.len == 0) return -1;\n  if ((qs = (const char *) memchr(hm->uri.ptr, '?', hm->uri.len)) != NULL) {\n    hm->query.ptr = qs + 1;\n    hm->query.len = (size_t) (&hm->uri.ptr[hm->uri.len] - (qs + 1));\n    hm->uri.len = (size_t) (qs - hm->uri.ptr);\n  }\n  mg_http_parse_headers(s, end, hm->headers,\n                        sizeof(hm->headers) / sizeof(hm->headers[0]));\n  if ((cl = mg_http_get_header(hm, \"Content-Length\")) != NULL) {\n    hm->body.len = (size_t) mg_to64(*cl);\n    hm->message.len = (size_t) req_len + hm->body.len;\n  }\n  is_response = mg_ncasecmp(hm->method.ptr, \"HTTP/\", 5) == 0;\n  if (hm->body.len == (size_t) ~0 && !is_response &&\n      mg_vcasecmp(&hm->method, \"PUT\") != 0 &&\n      mg_vcasecmp(&hm->method, \"POST\") != 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  if (hm->body.len == (size_t) ~0 && is_response &&\n      mg_vcasecmp(&hm->uri, \"204\") == 0) {\n    hm->body.len = 0;\n    hm->message.len = (size_t) req_len;\n  }\n  return req_len;\n}", "target": 1}
{"code": "update_info_in_idle_device_unreffed (gpointer user_data,\n                                     GObject *where_the_object_was)\n{\n  UpdateInfoInIdleData *data = user_data;\n  g_source_remove (data->idle_id);\n}", "target": 0}
{"code": "SecureSocket::secureAccept(int socket)\n{\n    createSSL();\n    SSL_set_fd(m_ssl->m_ssl, socket);\n    LOG((CLOG_DEBUG2 \"accepting secure socket\"));\n    int r = SSL_accept(m_ssl->m_ssl);\n    static int retry;\n    checkResult(r, retry);\n    if (isFatal()) {\n        LOG((CLOG_ERR \"failed to accept secure socket\"));\n        LOG((CLOG_INFO \"client connection may not be secure\"));\n        m_secureReady = false;\n        ARCH->sleep(1);\n        retry = 0;\n        return -1; \n    }\n    if (retry == 0) {\n        if (security_level_ == ConnectionSecurityLevel::ENCRYPTED_AUTHENTICATED) {\n            if (verify_cert_fingerprint(\n                        barrier::DataDirectories::trusted_clients_ssl_fingerprints_path())) {\n                LOG((CLOG_INFO \"accepted secure socket\"));\n                if (!ensure_peer_certificate()) {\n                    retry = 0;\n                    disconnect();\n                    return -1;\n                }\n            }\n            else {\n                LOG((CLOG_ERR \"failed to verify server certificate fingerprint\"));\n                retry = 0;\n                disconnect();\n                return -1; \n            }\n        }\n        m_secureReady = true;\n        LOG((CLOG_INFO \"accepted secure socket\"));\n        if (CLOG->getFilter() >= kDEBUG1) {\n            showSecureCipherInfo();\n        }\n        showSecureConnectInfo();\n        return 1;\n    }\n    if (retry > 0) {\n        LOG((CLOG_DEBUG2 \"retry accepting secure socket\"));\n        m_secureReady = false;\n        ARCH->sleep(s_retryDelay);\n        return 0;\n    }\n    LOG((CLOG_ERR \"unexpected state attempting to accept connection\"));\n    return -1;\n}", "target": 0}
{"code": "Status IndexedDBDatabase::DeleteIndexOperation(\n    int64_t object_store_id,\n    int64_t index_id,\n    IndexedDBTransaction* transaction) {\n  IDB_TRACE1(\n      \"IndexedDBDatabase::DeleteIndexOperation\", \"txn.id\", transaction->id());\n  IndexedDBIndexMetadata index_metadata =\n      RemoveIndex(object_store_id, index_id);\n  Status s = metadata_coding_->DeleteIndex(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), object_store_id, index_metadata);\n  if (!s.ok())\n    return s;\n  s = backing_store_->ClearIndex(transaction->BackingStoreTransaction(),\n                                 transaction->database()->id(), object_store_id,\n                                 index_id);\n  if (!s.ok()) {\n    AddIndex(object_store_id, std::move(index_metadata),\n             IndexedDBIndexMetadata::kInvalidId);\n    return s;\n  }\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::DeleteIndexAbortOperation, this,\n                     object_store_id, std::move(index_metadata)));\n  return s;\n}", "target": 0}
{"code": "raptor_rss_parse_start(raptor_parser *rdf_parser) \n{\n  raptor_uri *uri = rdf_parser->base_uri;\n  raptor_rss_parser* rss_parser = (raptor_rss_parser*)rdf_parser->context;\n  int n;\n  if(!uri)\n    return 1;\n  for(n = 0; n < RAPTOR_RSS_NAMESPACES_SIZE; n++)\n    rss_parser->nspaces_seen[n] = 'N';\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_NO_NET, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_NO_FILE, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_FILE));\n  raptor_sax2_set_option(rss_parser->sax2, \n                         RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES, NULL,\n                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES));\n  if(rdf_parser->uri_filter)\n    raptor_sax2_set_uri_filter(rss_parser->sax2, rdf_parser->uri_filter,\n                               rdf_parser->uri_filter_user_data);\n  raptor_sax2_parse_start(rss_parser->sax2, uri);\n  return 0;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}", "target": 1}
{"code": "build_config(char *prefix, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}", "target": 1}
{"code": "std::string controller::bookmark(\n\t\tconst std::string& url,\n\t\tconst std::string& title,\n\t\tconst std::string& description,\n\t\tconst std::string& feed_title)\n{\n\tstd::string bookmark_cmd = cfg.get_configvalue(\"bookmark-cmd\");\n\tbool is_interactive = cfg.get_configvalue_as_bool(\"bookmark-interactive\");\n\tif (bookmark_cmd.length() > 0) {\n\t\tstd::string cmdline = strprintf::fmt(\"%s '%s' %s %s %s\",\n\t\t                                       bookmark_cmd,\n\t\t                                       utils::replace_all(url,\"'\", \"%27\"),\n\t\t                                       quote_empty(stfl::quote(title)),\n\t\t                                       quote_empty(stfl::quote(description)),\n\t\t                                       quote_empty(stfl::quote(feed_title)));\n\t\tLOG(level::DEBUG, \"controller::bookmark: cmd = %s\", cmdline);\n\t\tif (is_interactive) {\n\t\t\tv->push_empty_formaction();\n\t\t\tstfl::reset();\n\t\t\tutils::run_interactively(cmdline, \"controller::bookmark\");\n\t\t\tv->pop_current_formaction();\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\tchar * my_argv[4];\n\t\t\tmy_argv[0] = const_cast<char *>(\"/bin/sh\");\n\t\t\tmy_argv[1] = const_cast<char *>(\"-c\");\n\t\t\tmy_argv[2] = const_cast<char *>(cmdline.c_str());\n\t\t\tmy_argv[3] = nullptr;\n\t\t\treturn utils::run_program(my_argv, \"\");\n\t\t}\n\t} else {\n\t\treturn _(\"bookmarking support is not configured. Please set the configuration variable `bookmark-cmd' accordingly.\");\n\t}\n}", "target": 1}
{"code": "gs_malloc_init(void)\n{\n    gs_malloc_memory_t *malloc_memory_default = gs_malloc_memory_init();\n    gs_memory_t *memory_t_default;\n    if (malloc_memory_default == NULL)\n        return NULL;\n    if (gs_lib_ctx_init((gs_memory_t *)malloc_memory_default) != 0)\n        return NULL;\n#if defined(USE_RETRY_MEMORY_WRAPPER)\n    gs_malloc_wrap(&memory_t_default, malloc_memory_default);\n#else\n    memory_t_default = (gs_memory_t *)malloc_memory_default;\n#endif\n    memory_t_default->stable_memory = memory_t_default;\n    return memory_t_default;\n}", "target": 0}
{"code": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;\n    }\n    return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);\n}", "target": 1}
{"code": "static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,\n                    AVDictionary *opts, AVDictionary *opts2, int *is_http)\n{\n    HLSContext *c = s->priv_data;\n    AVDictionary *tmp = NULL;\n    const char *proto_name = NULL;\n    int ret;\n    av_dict_copy(&tmp, opts, 0);\n    av_dict_copy(&tmp, opts2, 0);\n    if (av_strstart(url, \"crypto\", NULL)) {\n        if (url[6] == '+' || url[6] == ':')\n            proto_name = avio_find_protocol_name(url + 7);\n    }\n    if (!proto_name)\n        proto_name = avio_find_protocol_name(url);\n    if (!proto_name)\n        return AVERROR_INVALIDDATA;\n    if (!av_strstart(proto_name, \"http\", NULL) && !av_strstart(proto_name, \"file\", NULL))\n        return AVERROR_INVALIDDATA;\n    if (!strncmp(proto_name, url, strlen(proto_name)) && url[strlen(proto_name)] == ':')\n        ;\n    else if (av_strstart(url, \"crypto\", NULL) && !strncmp(proto_name, url + 7, strlen(proto_name)) && url[7 + strlen(proto_name)] == ':')\n        ;\n    else if (strcmp(proto_name, \"file\") || !strncmp(url, \"file,\", 5))\n        return AVERROR_INVALIDDATA;\n    ret = s->io_open(s, pb, url, AVIO_FLAG_READ, &tmp);\n    if (ret >= 0) {\n        char *new_cookies = NULL;\n        if (!(s->flags & AVFMT_FLAG_CUSTOM_IO))\n            av_opt_get(*pb, \"cookies\", AV_OPT_SEARCH_CHILDREN, (uint8_t**)&new_cookies);\n        if (new_cookies) {\n            av_free(c->cookies);\n            c->cookies = new_cookies;\n        }\n        av_dict_set(&opts, \"cookies\", c->cookies, 0);\n    }\n    av_dict_free(&tmp);\n    if (is_http)\n        *is_http = av_strstart(proto_name, \"http\", NULL);\n    return ret;\n}", "target": 1}
{"code": "static int snd_timer_user_tselect(struct file *file,\n\t\t\t\t  struct snd_timer_select __user *_tselect)\n{\n\tstruct snd_timer_user *tu;\n\tstruct snd_timer_select tselect;\n\tchar str[32];\n\tint err = 0;\n\ttu = file->private_data;\n\tif (tu->timeri) {\n\t\tsnd_timer_close(tu->timeri);\n\t\ttu->timeri = NULL;\n\t}\n\tif (copy_from_user(&tselect, _tselect, sizeof(tselect))) {\n\t\terr = -EFAULT;\n\t\tgoto __err;\n\t}\n\tsprintf(str, \"application %i\", current->pid);\n\tif (tselect.id.dev_class != SNDRV_TIMER_CLASS_SLAVE)\n\t\ttselect.id.dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION;\n\terr = snd_timer_open(&tu->timeri, str, &tselect.id, current->pid);\n\tif (err < 0)\n\t\tgoto __err;\n\ttu->qhead = tu->qtail = tu->qused = 0;\n\tkfree(tu->queue);\n\ttu->queue = NULL;\n\tkfree(tu->tqueue);\n\ttu->tqueue = NULL;\n\tif (tu->tread) {\n\t\ttu->tqueue = kmalloc(tu->queue_size * sizeof(struct snd_timer_tread),\n\t\t\t\t     GFP_KERNEL);\n\t\tif (tu->tqueue == NULL)\n\t\t\terr = -ENOMEM;\n\t} else {\n\t\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (tu->queue == NULL)\n\t\t\terr = -ENOMEM;\n\t}\n      \tif (err < 0) {\n\t\tsnd_timer_close(tu->timeri);\n      \t\ttu->timeri = NULL;\n      \t} else {\n\t\ttu->timeri->flags |= SNDRV_TIMER_IFLG_FAST;\n\t\ttu->timeri->callback = tu->tread\n\t\t\t? snd_timer_user_tinterrupt : snd_timer_user_interrupt;\n\t\ttu->timeri->ccallback = snd_timer_user_ccallback;\n\t\ttu->timeri->callback_data = (void *)tu;\n\t\ttu->timeri->disconnect = snd_timer_user_disconnect;\n\t}\n      __err:\n\treturn err;\n}", "target": 0}
{"code": "struct ucounts *alloc_ucounts(struct user_namespace *ns, kuid_t uid)\n{\n\tstruct hlist_head *hashent = ucounts_hashentry(ns, uid);\n\tstruct ucounts *ucounts, *new;\n\tbool wrapped;\n\tspin_lock_irq(&ucounts_lock);\n\tucounts = find_ucounts(ns, uid, hashent);\n\tif (!ucounts) {\n\t\tspin_unlock_irq(&ucounts_lock);\n\t\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn NULL;\n\t\tnew->ns = ns;\n\t\tnew->uid = uid;\n\t\tatomic_set(&new->count, 1);\n\t\tspin_lock_irq(&ucounts_lock);\n\t\tucounts = find_ucounts(ns, uid, hashent);\n\t\tif (ucounts) {\n\t\t\tkfree(new);\n\t\t} else {\n\t\t\thlist_add_head(&new->node, hashent);\n\t\t\tget_user_ns(new->ns);\n\t\t\tspin_unlock_irq(&ucounts_lock);\n\t\t\treturn new;\n\t\t}\n\t}\n\twrapped = !get_ucounts_or_wrap(ucounts);\n\tspin_unlock_irq(&ucounts_lock);\n\tif (wrapped) {\n\t\tput_ucounts(ucounts);\n\t\treturn NULL;\n\t}\n\treturn ucounts;\n}", "target": 0}
{"code": "static int parse_bigBN(BIGNUM **out, const char *bn_strings[])\n{\n    char *bigstring = glue_strings(bn_strings, NULL);\n    int ret = BN_hex2bn(out, bigstring);\n    OPENSSL_free(bigstring);\n    return ret;\n}", "target": 0}
{"code": "void ParamTraits<NullableString16>::Log(const param_type& p, std::string* l) {\n  l->append(\"(\");\n  LogParam(p.string(), l);\n  l->append(\", \");\n  LogParam(p.is_null(), l);\n  l->append(\")\");\n}", "target": 0}
{"code": "void HTMLSelectElement::setSize(int size)\n{\n    setIntegralAttribute(sizeAttr, size);\n}", "target": 0}
{"code": "void audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tcontext = audit_get_context(tsk, 0, 0);\n\tif (likely(!context))\n\t\treturn;\n\tif (context->in_syscall && context->auditable)\n\t\taudit_log_exit(context, tsk);\n\taudit_free_context(context);\n}", "target": 0}
{"code": "QSqlRecord QODBCDriver::record(const QString& tablename) const\n{\n    Q_D(const QODBCDriver);\n    QSqlRecord fil;\n    if (!isOpen())\n        return fil;\n    SQLHANDLE hStmt;\n    QString catalog, schema, table;\n    const_cast<QODBCDriverPrivate*>(d)->splitTableQualifier(tablename, catalog, schema, table);\n    if (isIdentifierEscaped(catalog, QSqlDriver::TableName))\n        catalog = stripDelimiters(catalog, QSqlDriver::TableName);\n    else\n        catalog = d->adjustCase(catalog);\n    if (isIdentifierEscaped(schema, QSqlDriver::TableName))\n        schema = stripDelimiters(schema, QSqlDriver::TableName);\n    else\n        schema = d->adjustCase(schema);\n    if (isIdentifierEscaped(table, QSqlDriver::TableName))\n        table = stripDelimiters(table, QSqlDriver::TableName);\n    else\n        table = d->adjustCase(table);\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::record: Unable to allocate handle\"_L1, d);\n        return fil;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    r =  SQLColumns(hStmt,\n                     catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),\n                     catalog.length(),\n                     schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),\n                     schema.length(),\n                     toSQLTCHAR(table).data(),\n                     table.length(),\n                     NULL,\n                     0);\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::record: Unable to execute column list\"_L1, d);\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n    while (r == SQL_SUCCESS) {\n        fil.append(qMakeFieldInfo(hStmt, d));\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle \"_L1 + QString::number(r), d);\n    return fil;\n}", "target": 1}
{"code": "static inline int mk_vhost_fdt_open(int id, unsigned int hash,\n                                    struct session_request *sr)\n{\n    int i;\n    int fd;\n    struct vhost_fdt_hash_table *ht = NULL;\n    struct vhost_fdt_hash_chain *hc;\n    if (config->fdt == MK_FALSE) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n    ht = mk_vhost_fdt_table_lookup(id, sr->host_conf);\n    if (mk_unlikely(!ht)) {\n        return open(sr->real_path.data, sr->file_info.flags_read_only);\n    }\n    hc = mk_vhost_fdt_chain_lookup(hash, ht);\n    if (hc) {\n        hc->readers++;\n        return hc->fd;\n    }\n    fd = open(sr->real_path.data, sr->file_info.flags_read_only);\n    if (fd == -1) {\n        return -1;\n    }\n    if (ht->av_slots <= 0) {\n        return fd;\n    }\n    for (i = 0; i < VHOST_FDT_HASHTABLE_CHAINS; i++) {\n        hc = &ht->chain[i];\n        if (hc->fd == -1) {\n            hc->fd   = fd;\n            hc->hash = hash;\n            hc->readers++;\n            ht->av_slots--;\n            sr->vhost_fdt_id   = id;\n            sr->vhost_fdt_hash = hash;\n            sr->fd_is_fdt      = MK_TRUE;\n            return fd;\n        }\n    }\n    return -1;\n}", "target": 0}
{"code": "static int manager_setup_time_change(Manager *m) {\n        int r;\n        struct itimerspec its = {\n                .it_value.tv_sec = TIME_T_MAX,\n        };\n        assert(m);\n        assert_cc(sizeof(time_t) == sizeof(TIME_T_MAX));\n        if (m->test_run)\n                return 0;\n        m->time_change_fd = timerfd_create(CLOCK_REALTIME, TFD_NONBLOCK|TFD_CLOEXEC);\n        if (m->time_change_fd < 0)\n                return log_error_errno(errno, \"Failed to create timerfd: %m\");\n        if (timerfd_settime(m->time_change_fd, TFD_TIMER_ABSTIME|TFD_TIMER_CANCEL_ON_SET, &its, NULL) < 0) {\n                log_debug_errno(errno, \"Failed to set up TFD_TIMER_CANCEL_ON_SET, ignoring: %m\");\n                m->time_change_fd = safe_close(m->time_change_fd);\n                return 0;\n        }\n        r = sd_event_add_io(m->event, &m->time_change_event_source, m->time_change_fd, EPOLLIN, manager_dispatch_time_change_fd, m);\n        if (r < 0)\n                return log_error_errno(r, \"Failed to create time change event source: %m\");\n        log_debug(\"Set up TFD_TIMER_CANCEL_ON_SET timerfd.\");\n        return 0;\n}", "target": 0}
{"code": "static int action_getconfig(struct mansession *s, const struct message *m)\n{\n\tstruct ast_config *cfg;\n\tconst char *fn = astman_get_header(m, \"Filename\");\n\tconst char *category = astman_get_header(m, \"Category\");\n\tconst char *filter = astman_get_header(m, \"Filter\");\n\tconst char *category_name;\n\tint catcount = 0;\n\tint lineno = 0;\n\tstruct ast_category *cur_category = NULL;\n\tstruct ast_variable *v;\n\tstruct ast_flags config_flags = { CONFIG_FLAG_WITHCOMMENTS | CONFIG_FLAG_NOCACHE };\n\tif (ast_strlen_zero(fn)) {\n\t\tastman_send_error(s, m, \"Filename not specified\");\n\t\treturn 0;\n\t}\n\tif (restrictedFile(fn)) {\n\t\tastman_send_error(s, m, \"File requires escalated priveledges\");\n\t\treturn 0;\n\t}\n\tcfg = ast_config_load2(fn, \"manager\", config_flags);\n\tif (cfg == CONFIG_STATUS_FILEMISSING) {\n\t\tastman_send_error(s, m, \"Config file not found\");\n\t\treturn 0;\n\t} else if (cfg == CONFIG_STATUS_FILEINVALID) {\n\t\tastman_send_error(s, m, \"Config file has invalid format\");\n\t\treturn 0;\n\t}\n\tastman_start_ack(s, m);\n\twhile ((cur_category = ast_category_browse_filtered(cfg, category, cur_category, filter))) {\n\t\tstruct ast_str *templates;\n\t\tcategory_name = ast_category_get_name(cur_category);\n\t\tlineno = 0;\n\t\tastman_append(s, \"Category-%06d: %s\\r\\n\", catcount, category_name);\n\t\tif (ast_category_is_template(cur_category)) {\n\t\t\tastman_append(s, \"IsTemplate-%06d: %d\\r\\n\", catcount, 1);\n\t\t}\n\t\tif ((templates = ast_category_get_templates(cur_category))\n\t\t\t&& ast_str_strlen(templates) > 0) {\n\t\t\tastman_append(s, \"Templates-%06d: %s\\r\\n\", catcount, ast_str_buffer(templates));\n\t\t\tast_free(templates);\n\t\t}\n\t\tfor (v = ast_category_first(cur_category); v; v = v->next) {\n\t\t\tastman_append(s, \"Line-%06d-%06d: %s=%s\\r\\n\", catcount, lineno++, v->name, v->value);\n\t\t}\n\t\tcatcount++;\n\t}\n\tif (!ast_strlen_zero(category) && catcount == 0) { \n\t\tastman_append(s, \"No categories found\\r\\n\");\n\t}\n\tast_config_destroy(cfg);\n\tastman_append(s, \"\\r\\n\");\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    if (input.dims() > 0) {\n      OP_REQUIRES(\n          context, input.dim_size(0) != 0,\n          errors::InvalidArgument(\"Invalid input first dimension. Found 0.\"));\n    }\n    const Tensor& dims = context->input(1);\n    if (TensorShapeUtils::IsScalar(input.shape())) {\n      context->set_output(0, input);\n    } else {\n      const int input_dims = input.dims();\n      OP_REQUIRES(context, TensorShapeUtils::IsVector(dims.shape()),\n                  errors::InvalidArgument(\"'dims' must be 1-dimension, not \",\n                                          dims.dims()));\n      OP_REQUIRES(\n          context, input_dims == dims.dim_size(0),\n          errors::InvalidArgument(\n              \"'dims' must have the same number of values as 'input' has \"\n              \"dimensions. 'input' has \",\n              input_dims, \"'dims' has \", dims.dim_size(0), \" values\"));\n      OP_REQUIRES(context, input_dims <= 8,\n                  errors::Unimplemented(\n                      \"reverse is not implemented for tensors of rank > 8.\"));\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(0, input.shape(), &output));\n#define HANDLE_REVERSE(NDIMS)                                               \\\n  case NDIMS:                                                               \\\n    HandleReverseCase<Device, T, NDIMS>(context, dims.vec<bool>(), output); \\\n    return;\n      switch (input_dims) {\n        HANDLE_REVERSE(0);\n        HANDLE_REVERSE(1);\n        HANDLE_REVERSE(2);\n        HANDLE_REVERSE(3);\n        HANDLE_REVERSE(4);\n        HANDLE_REVERSE(5);\n        HANDLE_REVERSE(6);\n        HANDLE_REVERSE(7);\n        HANDLE_REVERSE(8);\n      }\n#undef HANDLE_REVERSE\n    }\n  }", "target": 0}
{"code": "static int ati_remote2_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *alt = interface->cur_altsetting;\n\tstruct ati_remote2 *ar2;\n\tint r;\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n\tar2->udev = udev;\n\tar2->intf[0] = interface;\n\tar2->ep[0] = &alt->endpoint[0].desc;\n\tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n\tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n\tif (r)\n\t\tgoto fail1;\n\talt = ar2->intf[1]->cur_altsetting;\n\tar2->ep[1] = &alt->endpoint[0].desc;\n\tr = ati_remote2_urb_init(ar2);\n\tif (r)\n\t\tgoto fail2;\n\tar2->channel_mask = channel_mask;\n\tar2->mode_mask = mode_mask;\n\tr = ati_remote2_setup(ar2, ar2->channel_mask);\n\tif (r)\n\t\tgoto fail2;\n\tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n\tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n\tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n\tif (r)\n\t\tgoto fail2;\n\tr = ati_remote2_input_init(ar2);\n\tif (r)\n\t\tgoto fail3;\n\tusb_set_intfdata(interface, ar2);\n\tinterface->needs_remote_wakeup = 1;\n\treturn 0;\n fail3:\n\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail2:\n\tati_remote2_urb_cleanup(ar2);\n\tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n fail1:\n\tkfree(ar2);\n\treturn r;\n}", "target": 1}
{"code": "            AuthenticationInfo(\n                    AuthenticationStatus auth_status)\n                : identity_handle_(nullptr)\n                , handshake_handle_(nullptr)\n                , auth_status_(auth_status)\n                , expected_sequence_number_(0)\n                , change_sequence_number_(SequenceNumber_t::unknown())\n                , handshake_requests_sent_(0)\n            {\n            }", "target": 0}
{"code": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}", "target": 1}
{"code": "void GfxState::ReusablePathIterator::reset()\n{\n    coordOff = 0;\n    subPathOff = 0;\n    curSubPath = path->getSubpath(0);\n    numCoords = curSubPath->getNumPoints();\n}", "target": 0}
{"code": "static void lan78xx_disconnect(struct usb_interface *intf)\n{\n\tstruct lan78xx_net *dev;\n\tstruct usb_device *udev;\n\tstruct net_device *net;\n\tstruct phy_device *phydev;\n\tdev = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\tif (!dev)\n\t\treturn;\n\tset_bit(EVENT_DEV_DISCONNECT, &dev->flags);\n\tnetif_napi_del(&dev->napi);\n\tudev = interface_to_usbdev(intf);\n\tnet = dev->net;\n\tunregister_netdev(net);\n\tcancel_delayed_work_sync(&dev->wq);\n\tphydev = net->phydev;\n\tphy_unregister_fixup_for_uid(PHY_KSZ9031RNX, 0xfffffff0);\n\tphy_unregister_fixup_for_uid(PHY_LAN8835, 0xfffffff0);\n\tphy_disconnect(net->phydev);\n\tif (phy_is_pseudo_fixed_link(phydev))\n\t\tfixed_phy_unregister(phydev);\n\tusb_scuttle_anchored_urbs(&dev->deferred);\n\tif (timer_pending(&dev->stat_monitor))\n\t\tdel_timer_sync(&dev->stat_monitor);\n\tlan78xx_unbind(dev, intf);\n\tlan78xx_free_tx_resources(dev);\n\tlan78xx_free_rx_resources(dev);\n\tusb_kill_urb(dev->urb_intr);\n\tusb_free_urb(dev->urb_intr);\n\tfree_netdev(net);\n\tusb_put_dev(udev);\n}", "target": 1}
{"code": "SPL_METHOD(SplFileInfo, __construct)\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint len;\n\tzend_error_handling error_handling;\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &len) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}", "target": 0}
{"code": "spnego_gss_wrap_aead(OM_uint32 *minor_status,\n\t\t     gss_ctx_id_t context_handle,\n\t\t     int conf_req_flag,\n\t\t     gss_qop_t qop_req,\n\t\t     gss_buffer_t input_assoc_buffer,\n\t\t     gss_buffer_t input_payload_buffer,\n\t\t     int *conf_state,\n\t\t     gss_buffer_t output_message_buffer)\n{\n\tOM_uint32 ret;\n\tret = gss_wrap_aead(minor_status,\n\t\t\t    context_handle,\n\t\t\t    conf_req_flag,\n\t\t\t    qop_req,\n\t\t\t    input_assoc_buffer,\n\t\t\t    input_payload_buffer,\n\t\t\t    conf_state,\n\t\t\t    output_message_buffer);\n\treturn (ret);\n}", "target": 1}
{"code": "static int sd_ioctl(struct block_device *bdev, fmode_t mode,\n\t\t    unsigned int cmd, unsigned long arg)\n{\n\tstruct gendisk *disk = bdev->bd_disk;\n\tstruct scsi_disk *sdkp = scsi_disk(disk);\n\tstruct scsi_device *sdp = sdkp->device;\n\tvoid __user *p = (void __user *)arg;\n\tint error;\n\tSCSI_LOG_IOCTL(1, sd_printk(KERN_INFO, sdkp, \"sd_ioctl: disk=%s, \"\n\t\t\t\t    \"cmd=0x%x\\n\", disk->disk_name, cmd));\n\terror = scsi_verify_blk_ioctl(bdev, cmd);\n\tif (error < 0)\n\t\treturn error;\n\terror = scsi_nonblockable_ioctl(sdp, cmd, p,\n\t\t\t\t\t(mode & FMODE_NDELAY) != 0);\n\tif (!scsi_block_when_processing_errors(sdp) || !error)\n\t\tgoto out;\n\tswitch (cmd) {\n\t\tcase SCSI_IOCTL_GET_IDLUN:\n\t\tcase SCSI_IOCTL_GET_BUS_NUMBER:\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror = scsi_cmd_blk_ioctl(bdev, mode, cmd, p);\n\t\t\tif (error != -ENOTTY)\n\t\t\t\tbreak;\n\t\t\terror = scsi_ioctl(sdp, cmd, p);\n\t\t\tbreak;\n\t}\nout:\n\treturn error;\n}", "target": 0}
{"code": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}\n\tif (task == current)\n\t\tupdate_debugctlmsr(debugctl);\n\tlocal_irq_enable();\n}", "target": 1}
{"code": "usm_clone(netsnmp_pdu *pdu, netsnmp_pdu *new_pdu)\n{\n    struct usmStateReference *ref = pdu->securityStateRef;\n    struct usmStateReference **new_ref =\n        (struct usmStateReference **)&new_pdu->securityStateRef;\n    int ret = 0;\n    if (!ref)\n        return ret;\n    if (pdu->command == SNMP_MSG_TRAP2) {\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference(ref, new_ref);\n    } else {\n        netsnmp_assert(ref == *new_ref);\n        ref->refcnt++;\n    }\n    return ret;\n}", "target": 0}
{"code": "atmarp_spaddr_print(netdissect_options *ndo,\n\t\t    const struct atmarp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (ATMSPROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong splen>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, ATMSPA(ap))));\n}", "target": 0}
{"code": "ev_archive_init (EvArchive *archive)\n{\n}", "target": 0}
{"code": "ecma_op_function_call_constructor (vm_frame_ctx_shared_args_t *shared_args_p, \n                                   ecma_object_t *scope_p, \n                                   ecma_value_t this_binding) \n{\n  ECMA_CHECK_STACK_USAGE ();\n  shared_args_p->header.status_flags |= VM_FRAME_CTX_SHARED_NON_ARROW_FUNC;\n  ecma_value_t ret_value;\n  if (JERRY_CONTEXT (current_new_target_p) == NULL)\n  {\n    ret_value = ecma_raise_type_error (ECMA_ERR_CLASS_CONSTRUCTOR_REQUIRES_NEW);\n    goto exit;\n  }\n  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) shared_args_p->header.function_object_p;\n  if (ECMA_GET_THIRD_BIT_FROM_POINTER_TAG (ext_func_p->u.function.scope_cp))\n  {\n    this_binding = ECMA_VALUE_UNINITIALIZED;\n  }\n  ecma_op_create_environment_record (scope_p, this_binding, shared_args_p->header.function_object_p);\n#if JERRY_BUILTIN_REALMS\n  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);\n  JERRY_CONTEXT (global_object_p) = ecma_op_function_get_realm (shared_args_p->header.bytecode_header_p);\n#endif \n  ret_value = vm_run (&shared_args_p->header, this_binding, scope_p);\n#if JERRY_BUILTIN_REALMS\n  JERRY_CONTEXT (global_object_p) = saved_global_object_p;\n#endif \n  if (JERRY_UNLIKELY (this_binding == ECMA_VALUE_UNINITIALIZED))\n  {\n    if (!ECMA_IS_VALUE_ERROR (ret_value) && !ecma_is_value_object (ret_value))\n    {\n      if (!ecma_is_value_undefined (ret_value))\n      {\n        ecma_free_value (ret_value);\n        ret_value = ecma_raise_type_error (ECMA_ERR_DERIVED_CTOR_RETURN_NOR_OBJECT_OR_UNDEFINED);\n      }\n      else\n      {\n        ret_value = ecma_op_get_this_binding (scope_p);\n      }\n    }\n  }\nexit:\n  if (JERRY_UNLIKELY (shared_args_p->header.status_flags & VM_FRAME_CTX_SHARED_FREE_LOCAL_ENV))\n  {\n    ecma_deref_object (scope_p);\n  }\n  return ret_value;\n} ", "target": 0}
{"code": "char *path_name(const struct name_path *path, const char *name)\n{\n\tconst struct name_path *p;\n\tchar *n, *m;\n\tint nlen = strlen(name);\n\tint len = nlen + 1;\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len)\n\t\t\tlen += p->elem_len + 1;\n\t}\n\tn = xmalloc(len);\n\tm = n + len - (nlen + 1);\n\tstrcpy(m, name);\n\tfor (p = path; p; p = p->up) {\n\t\tif (p->elem_len) {\n\t\t\tm -= p->elem_len + 1;\n\t\t\tmemcpy(m, p->elem, p->elem_len);\n\t\t\tm[p->elem_len] = '/';\n\t\t}\n\t}\n\treturn n;\n}", "target": 1}
{"code": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}", "target": 1}
{"code": "copy_thread(unsigned long clone_flags, unsigned long stack_start,\n\t    unsigned long stk_sz, struct task_struct *p)\n{\n\tstruct thread_info *thread = task_thread_info(p);\n\tstruct pt_regs *childregs = task_pt_regs(p);\n\tmemset(&thread->cpu_context, 0, sizeof(struct cpu_context_save));\n\tif (likely(!(p->flags & PF_KTHREAD))) {\n\t\t*childregs = *current_pt_regs();\n\t\tchildregs->ARM_r0 = 0;\n\t\tif (stack_start)\n\t\t\tchildregs->ARM_sp = stack_start;\n\t} else {\n\t\tmemset(childregs, 0, sizeof(struct pt_regs));\n\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\tclear_ptrace_hw_breakpoint(p);\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value = childregs->ARM_r3;\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\treturn 0;\n}", "target": 1}
{"code": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}", "target": 1}
{"code": "rpl_dio_print(netdissect_options *ndo,\n              const u_char *bp, u_int length)\n{\n        const struct nd_rpl_dio *dio = (const struct nd_rpl_dio *)bp;\n        const char *dagid_str;\n        ND_TCHECK(*dio);\n        dagid_str = ip6addr_string (ndo, dio->rpl_dagid);\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]\",\n                  dagid_str,\n                  dio->rpl_dtsn,\n                  dio->rpl_instanceid,\n                  EXTRACT_16BITS(&dio->rpl_dagrank),\n                  RPL_DIO_GROUNDED(dio->rpl_mopprf) ? \"grounded,\":\"\",\n                  tok2str(rpl_mop_values, \"mop%u\", RPL_DIO_MOP(dio->rpl_mopprf)),\n                  RPL_DIO_PRF(dio->rpl_mopprf)));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)&dio[1];\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|truncated]\"));\n\treturn;\n}", "target": 1}
{"code": "static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct gnttab_copy **gopp)\n{\n\tstruct gnttab_copy *gop = *gopp;\n\tu16 pending_idx = *((u16 *)skb->data);\n\tstruct pending_tx_info *pending_tx_info = netbk->pending_tx_info;\n\tstruct xenvif *vif = pending_tx_info[pending_idx].vif;\n\tstruct xen_netif_tx_request *txp;\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i, err, start;\n\terr = gop->status;\n\tif (unlikely(err)) {\n\t\tpending_ring_idx_t index;\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\ttxp = &pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t}\n\tstart = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);\n\tfor (i = start; i < nr_frags; i++) {\n\t\tint j, newerr;\n\t\tpending_ring_idx_t index;\n\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[i]);\n\t\tnewerr = (++gop)->status;\n\t\tif (likely(!newerr)) {\n\t\t\tif (unlikely(err))\n\t\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t\tcontinue;\n\t\t}\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t\tif (err)\n\t\t\tcontinue;\n\t\tpending_idx = *((u16 *)skb->data);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\tfor (j = start; j < i; j++) {\n\t\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[j]);\n\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t}\n\t\terr = newerr;\n\t}\n\t*gopp = gop + 1;\n\treturn err;\n}", "target": 1}
{"code": "void jiffies_to_timeval(const unsigned long jiffies, struct timeval *value)\n{\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tlong tv_usec;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &tv_usec);\n\ttv_usec /= NSEC_PER_USEC;\n\tvalue->tv_usec = tv_usec;\n}", "target": 1}
{"code": "TfLiteStatus GatherNd(const TfLiteEvalTensor* params,\n                      const TfLiteEvalTensor* indices,\n                      TfLiteEvalTensor* output) {\n  const int indices_dims = indices->dims->size;\n  const int indices_nd = indices->dims->data[indices_dims - 1];\n  const int params_dims = params->dims->size;\n  const IndicesT* index_data = tflite::micro::GetTensorData<IndicesT>(indices);\n  const ParamsT* param_data = tflite::micro::GetTensorData<ParamsT>(params);\n  ParamsT* output_data = tflite::micro::GetTensorData<ParamsT>(output);\n  int n_slices = 1;\n  for (int i = 0; i < indices_dims - 1; ++i) {\n    n_slices *= indices->dims->data[i];\n  }\n  int slice_size = 1;\n  for (int i = indices_nd; i < params_dims; ++i) {\n    slice_size *= params->dims->data[i];\n  }\n  int remain_flat_size = ElementCount(*params->dims);\n  int dims_to_count[MAX_INDICES_ND];\n  for (int i = 0; i < indices_nd; ++i) {\n    dims_to_count[i] = remain_flat_size / params->dims->data[i];\n    remain_flat_size = dims_to_count[i];\n  }\n  for (int i = 0; i < n_slices; ++i) {\n    int from_pos = 0;\n    for (int j = 0; j < indices_nd; ++j) {\n      int offset = i * indices_nd + j;\n      IndicesT index = index_data[offset];\n      from_pos += index * dims_to_count[j];\n    }\n    std::memcpy(output_data + i * slice_size, param_data + from_pos,\n                sizeof(ParamsT) * slice_size);\n  }\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static int nft_verdict_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t\t    struct nft_data_desc *desc, const struct nlattr *nla)\n{\n\tu8 genmask = nft_genmask_next(ctx->net);\n\tstruct nlattr *tb[NFTA_VERDICT_MAX + 1];\n\tstruct nft_chain *chain;\n\tint err;\n\terr = nla_parse_nested_deprecated(tb, NFTA_VERDICT_MAX, nla,\n\t\t\t\t\t  nft_verdict_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\tif (!tb[NFTA_VERDICT_CODE])\n\t\treturn -EINVAL;\n\tdata->verdict.code = ntohl(nla_get_be32(tb[NFTA_VERDICT_CODE]));\n\tswitch (data->verdict.code) {\n\tdefault:\n\t\tswitch (data->verdict.code & NF_VERDICT_MASK) {\n\t\tcase NF_ACCEPT:\n\t\tcase NF_DROP:\n\t\tcase NF_QUEUE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase NFT_CONTINUE:\n\tcase NFT_BREAK:\n\tcase NFT_RETURN:\n\t\tbreak;\n\tcase NFT_JUMP:\n\tcase NFT_GOTO:\n\t\tif (tb[NFTA_VERDICT_CHAIN]) {\n\t\t\tchain = nft_chain_lookup(ctx->net, ctx->table,\n\t\t\t\t\t\t tb[NFTA_VERDICT_CHAIN],\n\t\t\t\t\t\t genmask);\n\t\t} else if (tb[NFTA_VERDICT_CHAIN_ID]) {\n\t\t\tchain = nft_chain_lookup_byid(ctx->net, ctx->table,\n\t\t\t\t\t\t      tb[NFTA_VERDICT_CHAIN_ID]);\n\t\t\tif (IS_ERR(chain))\n\t\t\t\treturn PTR_ERR(chain);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (IS_ERR(chain))\n\t\t\treturn PTR_ERR(chain);\n\t\tif (nft_is_base_chain(chain))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (nft_chain_is_bound(chain))\n\t\t\treturn -EINVAL;\n\t\tif (desc->flags & NFT_DATA_DESC_SETELEM &&\n\t\t    chain->flags & NFT_CHAIN_BINDING)\n\t\t\treturn -EINVAL;\n\t\tchain->use++;\n\t\tdata->verdict.chain = chain;\n\t\tbreak;\n\t}\n\tdesc->len = sizeof(data->verdict);\n\treturn 0;\n}", "target": 0}
{"code": "    OFCondition operator()(ImagePixel& pixel)\n    {\n        (void)pixel;\n        Uint16 rows = 0;\n        Uint16 cols = 0;\n        m_CT.getRows(rows);\n        m_CT.getColumns(cols);\n        const size_t numFrames      = m_CT.m_Frames.size();\n        const size_t numBytesFrame  = m_CT.m_Frames[0]->length;\n        const size_t numPixelsFrame = rows * cols;\n        DcmPixelData* pixData = new DcmPixelData(DCM_PixelData);\n        OFCondition result;\n        if (pixData)\n        {\n            pixData->setVR(EVR_OW);\n            Uint16* ptr          = NULL;\n            size_t numBytesTotal = numBytesFrame * numFrames / 2;\n            if (numBytesTotal <= 4294967294UL)\n            {\n                result = pixData->createUint16Array(OFstatic_cast(Uint32, numBytesTotal), ptr);\n                if (ptr)\n                {\n                    for (size_t f = 0; f < numFrames; ++f)\n                    {\n                        memcpy(ptr, m_CT.m_Frames[f]->pixData, numBytesFrame);\n                        ptr += numPixelsFrame;\n                    }\n                    return m_Item.insert(pixData);\n                }\n            }\n            else\n            {\n                result = FG_EC_PixelDataTooLarge;\n                delete pixData;\n            }\n        }\n        return result;\n    }", "target": 1}
{"code": "l2tp_bearer_cap_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_ANALOG_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_BEARER_CAP_DIGITAL_MASK) {\n\t\tND_PRINT((ndo, \"D\"));\n\t}\n}", "target": 1}
{"code": "bool allow_svhandler_flash_sector(const FlashSector* sector) {\n  return sector->use == FLASH_STORAGE1 ||\n         sector->use == FLASH_STORAGE2 ||\n         sector->use == FLASH_STORAGE3 ||\n         sector->use == FLASH_UNUSED0 ||\n         sector->use == FLASH_APP;\n}", "target": 0}
{"code": "void test_mkdir(const char *path)\n{\n\tsize_t len = strlen(path) + 30;\n\tchar *tmpname = alloca(len);\n\tsnprintf(tmpname, len, \"%s/%d\", path, (int)getpid());\n\tif (mkdir(path, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at mkdir of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n\tif (mkdir(tmpname, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at mkdir of %s\\n\", tmpname);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at mkdir of %s, errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static void nft_lookup_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_lookup *priv = nft_expr_priv(expr);\n\tpriv->set->use++;\n}", "target": 1}
{"code": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t}\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\t\tsecurity_key_free(key);\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\t\tatomic_dec(&key->user->nkeys);\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\tkey_user_put(key->user);\n\t\tkfree(key->description);\n\t\tmemzero_explicit(key, sizeof(*key));\n\t\tkmem_cache_free(key_jar, key);\n\t}\n}", "target": 1}
{"code": "bool do_memory_ranges_overlap(size_t range1Start, size_t range1End, size_t range2Start, size_t range2End) {\n  if (range1Start <= range2Start) {\n    return range2Start < range1End;\n  } else {\n    return range1Start < range2End;\n  }\n}", "target": 0}
{"code": "int ossl_dsa_check_pub_key(const DSA *dsa, const BIGNUM *pub_key, int *ret)\n{\n    if (!dsa_precheck_params(dsa, ret))\n        return 0;\n    return ossl_ffc_validate_public_key(&dsa->params, pub_key, ret)\n           && *ret == 0;\n}", "target": 0}
{"code": "suffix_requires_dir_check (char const *end)\n{\n  while (ISSLASH (*end))\n    {\n      do\n        end++;\n      while (ISSLASH (*end));\n      switch (*end++)\n        {\n        default: return false;  \n        case '\\0': return true; \n        case '.': break;        \n        }\n      if (!*end || (*end == '.' && (!end[1] || ISSLASH (end[1]))))\n        return true;\n    }\n  return false;\n}", "target": 0}
{"code": "void perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\tperf_sample_data_init(&sample, bp->attr.bp_addr, 0);\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, &sample, regs);\n}", "target": 0}
{"code": "static inline ut8 r_read_le8(const void *src) {\n\tif (!src) {\n\t\treturn UT8_MAX;\n\t}\n\treturn r_read_ble8 (src);\n}", "target": 0}
{"code": "filesystem_create_completed_cb (DBusGMethodInvocation *context,\n                                Device *device,\n                                gboolean job_was_cancelled,\n                                int status,\n                                const char *stderr,\n                                const char *stdout,\n                                gpointer user_data)\n{\n  MkfsData *data = user_data;\n  device_generate_kernel_change_event (device);\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      if (data->hook_func != NULL)\n        data->hook_func (context, device, TRUE, data->hook_user_data);\n      else\n        dbus_g_method_return (context);\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else if (WEXITSTATUS (status) == 3)\n        {\n          throw_error (context,\n                       ERROR_FILESYSTEM_TOOLS_MISSING,\n                       \"Error creating file system: Cannot run mkfs: %s\",\n                       stderr);\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error creating file system: helper exited with exit code %d: %s\\n%s\",\n                       WEXITSTATUS (status),\n                       stderr,\n                       stdout);\n        }\n      if (data->hook_func != NULL)\n        data->hook_func (context, device, FALSE, data->hook_user_data);\n    }\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_finish( bson *b ) {\n    int i;\n    if( b->err & BSON_NOT_UTF8 )\n        return BSON_ERROR;\n    if ( ! b->finished ) {\n        if ( bson_ensure_space( b, 1 ) == BSON_ERROR ) return BSON_ERROR;\n        bson_append_byte( b, 0 );\n        i = b->cur - b->data;\n        bson_little_endian32( b->data, &i );\n        b->finished = 1;\n    }\n    return BSON_OK;\n}", "target": 1}
{"code": "pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)\n{\n\tInitializeCriticalSection(mutex);\n\treturn 0;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n    const Tensor& filter = context->input(1);\n    OP_REQUIRES(context, input.dims() == 5,\n                errors::InvalidArgument(\"input must be 5-dimensional\"));\n    OP_REQUIRES(context, filter.dims() == 5,\n                errors::InvalidArgument(\"filter must be 5-dimensional\"));\n    const int64 in_depth = GetTensorDim(input, data_format_, 'C');\n    const int64 in_batch = GetTensorDim(input, data_format_, 'N');\n    const int64 filter_depth = filter.dim_size(3);\n    const int64 out_depth = filter.dim_size(4);\n    OP_REQUIRES(context, filter_depth != 0,\n                errors::InvalidArgument(\"filter_depth must be non-zero\"));\n    OP_REQUIRES(context, in_depth % filter_depth == 0,\n                errors::InvalidArgument(\n                    \"Input depth must be evenly divisible by filter depth: \",\n                    in_depth, \" vs \", filter_depth));\n    std::array<int64, 3> input_size = {\n        {GetTensorDim(input, data_format_, '0'),\n         GetTensorDim(input, data_format_, '1'),\n         GetTensorDim(input, data_format_, '2')}};\n    std::array<int64, 3> filter_size = {\n        {filter.dim_size(0), filter.dim_size(1), filter.dim_size(2)}};\n    std::array<int64, 3> dilations = {\n        {GetTensorDim(dilation_, data_format_, '0'),\n         GetTensorDim(dilation_, data_format_, '1'),\n         GetTensorDim(dilation_, data_format_, '2')}};\n    std::array<int64, 3> strides = {{GetTensorDim(stride_, data_format_, '0'),\n                                     GetTensorDim(stride_, data_format_, '1'),\n                                     GetTensorDim(stride_, data_format_, '2')}};\n    std::array<int64, 3> out, padding;\n    OP_REQUIRES_OK(\n        context, Get3dOutputSizeV2(input_size, filter_size, dilations, strides,\n                                   padding_, &out, &padding));\n    TensorShape out_shape = ShapeFromFormat(\n        data_format_, in_batch, {{out[0], out[1], out[2]}}, out_depth);\n    Tensor* output;\n    OP_REQUIRES_OK(context, context->allocate_output(0, out_shape, &output));\n    if (out_shape.num_elements() == 0) return;\n    LaunchConvOp<Device, T>::launch(context, cudnn_use_autotune_, input, filter,\n                                    dilations, strides, padding_, data_format_,\n                                    output);\n  }", "target": 0}
{"code": "static uint32_t mp_clzll(unsigned long long x) {\n    unsigned long lz = 0;\n    return _BitScanReverse64(&lz, x) ? (sizeof(x) * 8 - 1) - lz : 0;\n}", "target": 0}
{"code": "TEST(TensorSliceReaderTest, NegativeTensorShapeDimension) {\n  const string fname =\n      io::JoinPath(testing::TmpDir(), \"negative_dim_checkpoint\");\n  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  TF_CHECK_OK(writer.Add(\"test\", TensorShape({4, 5}),\n                         TensorSlice::ParseOrDie(\"0,2:-\"), data));\n  TF_CHECK_OK(writer.Finish());\n  MutateSavedTensorSlices(fname, [](SavedTensorSlices sts) {\n    if (sts.has_meta()) {\n      for (auto& tensor : *sts.mutable_meta()->mutable_tensor()) {\n        for (auto& dim : *tensor.mutable_shape()->mutable_dim()) {\n          dim.set_size(-dim.size());\n        }\n      }\n    }\n    return sts.SerializeAsString();\n  });\n  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n  EXPECT_FALSE(reader.status().ok());\n}", "target": 0}
{"code": "static int vhost_vdpa_open(struct inode *inode, struct file *filep)\n{\n\tstruct vhost_vdpa *v;\n\tstruct vhost_dev *dev;\n\tstruct vhost_virtqueue **vqs;\n\tint nvqs, i, r, opened;\n\tv = container_of(inode->i_cdev, struct vhost_vdpa, cdev);\n\topened = atomic_cmpxchg(&v->opened, 0, 1);\n\tif (opened)\n\t\treturn -EBUSY;\n\tnvqs = v->nvqs;\n\tr = vhost_vdpa_reset(v);\n\tif (r)\n\t\tgoto err;\n\tvqs = kmalloc_array(nvqs, sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs) {\n\t\tr = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev = &v->vdev;\n\tfor (i = 0; i < nvqs; i++) {\n\t\tvqs[i] = &v->vqs[i];\n\t\tvqs[i]->handle_kick = handle_vq_kick;\n\t}\n\tvhost_dev_init(dev, vqs, nvqs, 0, 0, 0, false,\n\t\t       vhost_vdpa_process_iotlb_msg);\n\tdev->iotlb = vhost_iotlb_alloc(0, 0);\n\tif (!dev->iotlb) {\n\t\tr = -ENOMEM;\n\t\tgoto err_init_iotlb;\n\t}\n\tr = vhost_vdpa_alloc_domain(v);\n\tif (r)\n\t\tgoto err_init_iotlb;\n\tvhost_vdpa_set_iova_range(v);\n\tfilep->private_data = v;\n\treturn 0;\nerr_init_iotlb:\n\tvhost_dev_cleanup(&v->vdev);\n\tkfree(vqs);\nerr:\n\tatomic_dec(&v->opened);\n\treturn r;\n}", "target": 0}
{"code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}", "target": 1}
{"code": "void MutateSavedTensorSlices(\n    const std::string& fname,\n    const std::function<std::string(SavedTensorSlices)>& mutator) {\n  table::Options options;\n  options.compression = table::kNoCompression;\n  std::vector<std::pair<std::string, std::string>> entries;\n  {\n    std::unique_ptr<RandomAccessFile> file;\n    TF_CHECK_OK(Env::Default()->NewRandomAccessFile(fname, &file));\n    uint64 file_size;\n    TF_CHECK_OK(Env::Default()->GetFileSize(fname, &file_size));\n    table::Table* t;\n    TF_CHECK_OK(table::Table::Open(options, file.get(), file_size, &t));\n    std::unique_ptr<table::Table> table(t);\n    std::unique_ptr<table::Iterator> it(table->NewIterator());\n    for (it->Seek(\"\"); it->Valid(); it->Next()) {\n      entries.emplace_back(it->key(), it->value());\n    }\n    TF_CHECK_OK(it->status());\n  }\n  {\n    std::unique_ptr<WritableFile> file;\n    TF_CHECK_OK(Env::Default()->NewWritableFile(fname, &file));\n    table::TableBuilder builder(options, file.get());\n    for (const auto& entry : entries) {\n      SavedTensorSlices sts;\n      CHECK(sts.ParseFromString(entry.second));\n      builder.Add(entry.first, mutator(std::move(sts)));\n    }\n    TF_CHECK_OK(builder.Finish());\n    TF_CHECK_OK(file->Close());\n  }\n}", "target": 0}
{"code": "static int xc2028_sleep(struct dvb_frontend *fe)\n{\n\tstruct xc2028_data *priv = fe->tuner_priv;\n\tint rc;\n\trc = check_device_status(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (!rc)\n\t\treturn 0;\n\tif (no_poweroff || priv->ctrl.disable_power_mgmt)\n\t\treturn 0;\n\ttuner_dbg(\"Putting xc2028/3028 into poweroff mode.\\n\");\n\tif (debug > 1) {\n\t\ttuner_dbg(\"Printing sleep stack trace:\\n\");\n\t\tdump_stack();\n\t}\n\tmutex_lock(&priv->lock);\n\tif (priv->firm_version < 0x0202)\n\t\trc = send_seq(priv, {0x00, XREG_POWER_DOWN, 0x00, 0x00});\n\telse\n\t\trc = send_seq(priv, {0x80, XREG_POWER_DOWN, 0x00, 0x00});\n\tif (rc >= 0)\n\t\tpriv->state = XC2028_SLEEP;\n\tmutex_unlock(&priv->lock);\n\treturn rc;\n}", "target": 0}
{"code": "\t\tGetRunner(\n\t\t\tconst ReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tMaybeLocal<Object> maybe_options,\n\t\t\tbool inherit\n\t\t) :\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference},\n\t\t\t\toptions{maybe_options, inherit ?\n\t\t\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n\t\t\t\tinherit{inherit} {\n\t\t\tthat.CheckDisposed();\n\t\t\tkey = ExternalCopy::CopyIfPrimitive(key_handle);\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}", "target": 1}
{"code": "static void free_sched_groups(struct sched_group *sg, int free_sgc)\n{\n\tstruct sched_group *tmp, *first;\n\tif (!sg)\n\t\treturn;\n\tfirst = sg;\n\tdo {\n\t\ttmp = sg->next;\n\t\tif (free_sgc && atomic_dec_and_test(&sg->sgc->ref))\n\t\t\tkfree(sg->sgc);\n\t\tkfree(sg);\n\t\tsg = tmp;\n\t} while (sg != first);\n}", "target": 0}
{"code": "static int mem_read(jas_stream_obj_t *obj, char *buf, int cnt)\n{\n\tint n;\n\tassert(cnt >= 0);\n\tassert(buf);\n\tJAS_DBGLOG(100, (\"mem_read(%p, %p, %d)\\n\", obj, buf, cnt));\n\tjas_stream_memobj_t *m = (jas_stream_memobj_t *)obj;\n\tn = m->len_ - m->pos_;\n\tcnt = JAS_MIN(n, cnt);\n\tmemcpy(buf, &m->buf_[m->pos_], cnt);\n\tm->pos_ += cnt;\n\treturn cnt;\n}", "target": 1}
{"code": "static uint16_t nvme_cmd_effects(NvmeCtrl *n, uint8_t csi, uint32_t buf_len,\n                                 uint64_t off, NvmeRequest *req)\n{\n    NvmeEffectsLog log = {};\n    const uint32_t *src_iocs = NULL;\n    uint32_t trans_len;\n    if (off >= sizeof(log)) {\n        trace_pci_nvme_err_invalid_log_page_offset(off, sizeof(log));\n        return NVME_INVALID_FIELD | NVME_DNR;\n    }\n    switch (NVME_CC_CSS(ldl_le_p(&n->bar.cc))) {\n    case NVME_CC_CSS_NVM:\n        src_iocs = nvme_cse_iocs_nvm;\n    case NVME_CC_CSS_ADMIN_ONLY:\n        break;\n    case NVME_CC_CSS_CSI:\n        switch (csi) {\n        case NVME_CSI_NVM:\n            src_iocs = nvme_cse_iocs_nvm;\n            break;\n        case NVME_CSI_ZONED:\n            src_iocs = nvme_cse_iocs_zoned;\n            break;\n        }\n    }\n    memcpy(log.acs, nvme_cse_acs, sizeof(nvme_cse_acs));\n    if (src_iocs) {\n        memcpy(log.iocs, src_iocs, sizeof(log.iocs));\n    }\n    trans_len = MIN(sizeof(log) - off, buf_len);\n    return nvme_c2h(n, ((uint8_t *)&log) + off, trans_len, req);\n}", "target": 0}
{"code": "  TestCertificateValidationContextConfig(\n      envoy::config::core::v3::TypedExtensionConfig config, bool allow_expired_certificate = false,\n      std::vector<envoy::type::matcher::v3::StringMatcher> san_matchers = {})\n      : allow_expired_certificate_(allow_expired_certificate), api_(Api::createApiForTest()),\n        custom_validator_config_(config), san_matchers_(san_matchers){};", "target": 1}
{"code": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n    for (i = 0; argv[i]; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n    if (ogs_app()->parameter.no_hss == 0)\n        hss_thread = test_child_create(\"hss\", argv_out);\n    if (ogs_app()->parameter.no_pcrf == 0)\n        pcrf_thread = test_child_create(\"pcrf\", argv_out);\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_sgwu == 0)\n        sgwu_thread = test_child_create(\"sgwu\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_sgwc == 0)\n        sgwc_thread = test_child_create(\"sgwc\", argv_out);\n    if (ogs_app()->parameter.no_mme == 0)\n        mme_thread = test_child_create(\"mme\", argv_out);\n    ogs_msleep(5000);\n    return OGS_OK;;\n}", "target": 1}
{"code": "static void tiny_dispatch(const MessagesMap_t *entry, uint8_t *msg, uint32_t msg_size)\n{\n    if (!pb_parse(entry, msg, msg_size, msg_tiny)) {\n        call_msg_failure_handler(FailureType_Failure_UnexpectedMessage,\n                                 \"Could not parse tiny protocol buffer message\");\n        return;\n    }\n    msg_tiny_id = entry->msg_id;\n}", "target": 1}
{"code": "assegment_dup_all (struct assegment *seg)\n{\n  struct assegment *new = NULL;\n  struct assegment *head = NULL;\n  while (seg)\n    {\n      if (head)\n        {\n          new->next = assegment_dup (seg);\n          new = new->next;\n        }\n      else\n        head = new = assegment_dup (seg);\n      seg = seg->next;\n    }\n  return head;\n}", "target": 0}
{"code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}", "target": 1}
{"code": "OFTEST(dcmect_overflow)\n{\n    if (!dcmDataDict.isDictionaryLoaded())\n    {\n        OFCHECK(dcmDataDict.isDictionaryLoaded());\n    }\n    EctEnhancedCT *ct = create();\n    configureIOD(ct);\n    setGenericValues(ct);\n    addSharedFGs(ct);\n    addFrames(ct);\n    addDimensions(ct);\n    DcmFileFormat dcmff;\n    OFTempFile tf(O_RDWR, \"\", \"t_overflow\", \".dcm\");\n    OFCondition result;\n    result = ct->saveFile(\"output.dcm\", EXS_LittleEndianExplicit);\n    OFCHECK_MSG(result == ECT_InvalidPixelInfo, result.text());\n}", "target": 0}
{"code": "void skip(Protocol_& prot, TType arg_type) {\n  switch (arg_type) {\n    case TType::T_BOOL: {\n      bool boolv;\n      prot.readBool(boolv);\n      return;\n    }\n    case TType::T_BYTE: {\n      int8_t bytev;\n      prot.readByte(bytev);\n      return;\n    }\n    case TType::T_I16: {\n      int16_t i16;\n      prot.readI16(i16);\n      return;\n    }\n    case TType::T_I32: {\n      int32_t i32;\n      prot.readI32(i32);\n      return;\n    }\n    case TType::T_I64: {\n      int64_t i64;\n      prot.readI64(i64);\n      return;\n    }\n    case TType::T_DOUBLE: {\n      double dub;\n      prot.readDouble(dub);\n      return;\n    }\n    case TType::T_FLOAT: {\n      float flt;\n      prot.readFloat(flt);\n      return;\n    }\n    case TType::T_STRING: {\n      std::string str;\n      prot.readBinary(str);\n      return;\n    }\n    case TType::T_STRUCT: {\n      std::string name;\n      int16_t fid;\n      TType ftype;\n      prot.readStructBegin(name);\n      while (true) {\n        prot.readFieldBegin(name, ftype, fid);\n        if (ftype == TType::T_STOP) {\n          break;\n        }\n        apache::thrift::skip(prot, ftype);\n        prot.readFieldEnd();\n      }\n      prot.readStructEnd();\n      return;\n    }\n    case TType::T_MAP: {\n      TType keyType;\n      TType valType;\n      uint32_t i, size;\n      prot.readMapBegin(keyType, valType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, keyType);\n        apache::thrift::skip(prot, valType);\n      }\n      prot.readMapEnd();\n      return;\n    }\n    case TType::T_SET: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readSetBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readSetEnd();\n      return;\n    }\n    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}", "target": 1}
{"code": "bool CephXAuthorizer::add_challenge(CephContext *cct, bufferlist& challenge)\n{\n  bl = base_bl;\n  CephXAuthorize msg;\n  msg.nonce = nonce;\n  auto p = challenge.begin();\n  if (!p.end()) {\n    std::string error;\n    CephXAuthorizeChallenge ch;\n    decode_decrypt_enc_bl(cct, ch, session_key, challenge, error);\n    if (!error.empty()) {\n      ldout(cct, 0) << \"failed to decrypt challenge (\" << challenge.length() << \" bytes): \"\n\t\t    << error << dendl;\n      return false;\n    }\n    msg.have_challenge = true;\n    msg.server_challenge_plus_one = ch.server_challenge + 1;\n  }\n  std::string error;\n  if (encode_encrypt(cct, msg, session_key, bl, error)) {\n    ldout(cct, 0) << __func__ << \" failed to encrypt authorizer: \" << error << dendl;\n    return false;\n  }\n  return true;\n}", "target": 0}
{"code": "int mp_invmod_mont_ct (mp_int * a, mp_int * b, mp_int * c, mp_digit mp)\n{\n  return fp_invmod_mont_ct(a, b, c, mp);\n}", "target": 0}
{"code": "static struct mb2_cache_entry *__entry_find(struct mb2_cache *cache,\n\t\t\t\t\t    struct mb2_cache_entry *entry,\n\t\t\t\t\t    u32 key)\n{\n\tstruct mb2_cache_entry *old_entry = entry;\n\tstruct hlist_bl_node *node;\n\tstruct hlist_bl_head *head;\n\tif (entry)\n\t\thead = entry->e_hash_list_head;\n\telse\n\t\thead = &cache->c_hash[hash_32(key, cache->c_bucket_bits)];\n\thlist_bl_lock(head);\n\tif (entry && !hlist_bl_unhashed(&entry->e_hash_list))\n\t\tnode = entry->e_hash_list.next;\n\telse\n\t\tnode = hlist_bl_first(head);\n\twhile (node) {\n\t\tentry = hlist_bl_entry(node, struct mb2_cache_entry,\n\t\t\t\t       e_hash_list);\n\t\tif (entry->e_key == key) {\n\t\t\tatomic_inc(&entry->e_refcnt);\n\t\t\tgoto out;\n\t\t}\n\t\tnode = node->next;\n\t}\n\tentry = NULL;\nout:\n\thlist_bl_unlock(head);\n\tif (old_entry)\n\t\tmb2_cache_entry_put(cache, old_entry);\n\treturn entry;\n}", "target": 0}
{"code": "static OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n\tOPCODE_DESC *opcode_desc;\n\tif (len < 2) {\n\t\treturn NULL;\n\t}\n\tut16 ins = (buf[1] << 8) | buf[0];\n\tint fail;\n\tchar *t;\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\top->addr = addr;\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\nINVALID_OP:\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\tr_strbuf_set (&op->esil, \"1,$\");\n\treturn NULL;\n}", "target": 0}
{"code": "bool GLES2DecoderImpl::IsDrawValid(GLuint max_vertex_accessed) {\n  if (!current_program_ || current_program_->IsDeleted()) {\n    return false;\n  }\n  const VertexAttribManager::VertexAttribInfoList& infos =\n      vertex_attrib_manager_.GetEnabledVertexAttribInfos();\n  for (VertexAttribManager::VertexAttribInfoList::const_iterator it =\n           infos.begin(); it != infos.end(); ++it) {\n    const VertexAttribManager::VertexAttribInfo* info = *it;\n    const ProgramManager::ProgramInfo::VertexAttribInfo* attrib_info =\n        current_program_->GetAttribInfoByLocation(info->index());\n    if (attrib_info) {\n      if (!info->CanAccess(max_vertex_accessed)) {\n        SetGLError(GL_INVALID_OPERATION,\n                   \"glDrawXXX: attempt to access out of range vertices\");\n        return false;\n      }\n    } else {\n      if (!info->buffer() || info->buffer()->IsDeleted()) {\n        SetGLError(\n            GL_INVALID_OPERATION,\n            \"glDrawXXX: attempt to render with no buffer attached to enabled \"\n            \"attrib\");\n        return false;\n      }\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "is_blank_line(char *line, int indent)\n{\n    int i, is_blank = 0;\n    for (i = 0; i < indent; i++) {\n\tif (line[i] == '\\0') {\n\t    is_blank = 1;\n\t}\n\telse if (line[i] != ' ') {\n\t    break;\n\t}\n    }\n    if (i == indent && line[i] == '\\0')\n\tis_blank = 1;\n    return is_blank;\n}", "target": 0}
{"code": "static int stv06xx_isoc_nego(struct gspca_dev *gspca_dev)\n{\n\tint ret, packet_size, min_packet_size;\n\tstruct usb_host_interface *alt;\n\tstruct sd *sd = (struct sd *) gspca_dev;\n\talt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1];\n\tpacket_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n\tmin_packet_size = sd->sensor->min_packet_size[gspca_dev->curr_mode];\n\tif (packet_size <= min_packet_size)\n\t\treturn -EIO;\n\tpacket_size -= 100;\n\tif (packet_size < min_packet_size)\n\t\tpacket_size = min_packet_size;\n\talt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(packet_size);\n\tret = usb_set_interface(gspca_dev->dev, gspca_dev->iface, 1);\n\tif (ret < 0)\n\t\tgspca_err(gspca_dev, \"set alt 1 err %d\\n\", ret);\n\treturn ret;\n}", "target": 0}
{"code": "void pjsua_init_tpselector(pjsua_transport_id tp_id,\n\t\t\t   pjsip_tpselector *sel)\n{\n    pjsua_transport_data *tpdata;\n    unsigned flag;\n    pj_bzero(sel, sizeof(*sel));\n    if (tp_id == PJSUA_INVALID_ID)\n\treturn;\n    pj_assert(tp_id >= 0 && tp_id < (int)PJ_ARRAY_SIZE(pjsua_var.tpdata));\n    tpdata = &pjsua_var.tpdata[tp_id];\n    flag = pjsip_transport_get_flag_from_type(tpdata->type);\n    if (flag & PJSIP_TRANSPORT_DATAGRAM) {\n\tsel->type = PJSIP_TPSELECTOR_TRANSPORT;\n\tsel->u.transport = tpdata->data.tp;\n    } else {\n\tsel->type = PJSIP_TPSELECTOR_LISTENER;\n\tsel->u.listener = tpdata->data.factory;\n    }\n}", "target": 1}
{"code": "snmp_engine(unsigned char *buff, uint32_t buff_len, unsigned char *out, uint32_t *out_len)\n{\n  static snmp_header_t header;\n  static snmp_varbind_t varbinds[SNMP_MAX_NR_VALUES];\n  static uint32_t varbind_length = SNMP_MAX_NR_VALUES;\n  buff = snmp_message_decode(buff, buff_len, &header, varbinds, &varbind_length);\n  if(buff == NULL) {\n    return NULL;\n  }\n  if(header.version != SNMP_VERSION_1) {\n    if(strncmp(header.community.community, SNMP_COMMUNITY, header.community.length)) {\n      LOG_ERR(\"Request with invalid community\\n\");\n      return NULL;\n    }\n  }\n  switch(header.pdu_type) {\n  case SNMP_DATA_TYPE_PDU_GET_REQUEST:\n    if(snmp_engine_get(&header, varbinds, varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  case SNMP_DATA_TYPE_PDU_GET_NEXT_REQUEST:\n    if(snmp_engine_get_next(&header, varbinds, varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  case SNMP_DATA_TYPE_PDU_GET_BULK:\n    if(snmp_engine_get_bulk(&header, varbinds, &varbind_length) == -1) {\n      return NULL;\n    }\n    break;\n  default:\n    LOG_ERR(\"Invalid request type\");\n    return NULL;\n  }\n  header.pdu_type = SNMP_DATA_TYPE_PDU_GET_RESPONSE;\n  out = snmp_message_encode(out, out_len, &header, varbinds, varbind_length);\n  return ++out;\n}", "target": 1}
{"code": "int PackTmt::readFileHeader() {\n#define H(x) get_le16(h + 2 * (x))\n#define H4(x) get_le32(h + (x))\n    unsigned char h[0x40];\n    int ic;\n    unsigned exe_offset = 0;\n    adam_offset = 0;\n    for (ic = 0; ic < 20; ic++) {\n        fi->seek(adam_offset, SEEK_SET);\n        fi->readx(h, sizeof(h));\n        if (memcmp(h, \"MZ\", 2) == 0) \n        {\n            exe_offset = adam_offset;\n            adam_offset += H(2) * 512 + H(1);\n            if (H(1))\n                adam_offset -= 512;\n            if (H(0x18 / 2) == 0x40 && H4(0x3c))\n                adam_offset = H4(0x3c);\n        } else if (memcmp(h, \"BW\", 2) == 0)\n            adam_offset += H(2) * 512 + H(1);\n        else if (memcmp(h, \"PMW1\", 4) == 0) {\n            fi->seek(adam_offset + H4(0x18), SEEK_SET);\n            adam_offset += H4(0x24);\n            int objs = H4(0x1c);\n            while (objs--) {\n                fi->readx(h, 0x18);\n                adam_offset += H4(4);\n            }\n        } else if (memcmp(h, \"LE\", 2) == 0) {\n            unsigned offs = exe_offset + (H4(0x14) - 1) * H4(0x28) + H4(0x2c);\n            fi->seek(adam_offset + 0x80, SEEK_SET);\n            fi->readx(h, 4);\n            adam_offset = offs + H4(0);\n        } else if (memcmp(h, \"Adam\", 4) == 0)\n            break;\n        else\n            return 0;\n    }\n    if (ic == 20)\n        return 0;\n    fi->seek(adam_offset, SEEK_SET);\n    fi->readx(&ih, sizeof(ih));\n    unsigned const imagesize = ih.imagesize;\n    unsigned const entry = ih.entry;\n    unsigned const relocsize = ih.relocsize;\n    if (!imagesize || file_size <= imagesize || file_size <= entry || file_size <= relocsize) {\n        printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n                  entry, relocsize);\n        return 0;\n    }\n    return UPX_F_TMT_ADAM;\n#undef H4\n#undef H\n}", "target": 1}
{"code": "unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\tif (v8086_mode(regs))\n\t\treturn (unsigned long)(sel << 4);\n\tif (user_64bit_mode(regs)) {\n\t\tunsigned long base;\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\tif (!sel)\n\t\treturn -1L;\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\treturn get_desc_base(desc);\n}", "target": 1}
{"code": "add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    }\n    DEBUGMSGTL((\"parse-mibs\", \"Checking file: %s...\\n\",\n                tmpstr));\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        if (ip)\n            fprintf(ip, \"%s %s\\n\", token, d_name);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}", "target": 1}
{"code": "static int adpt_bus_reset(struct scsi_cmnd* cmd)\n{\n\tadpt_hba* pHba;\n\tu32 msg[4];\n\tu32 rcode;\n\tpHba = (adpt_hba*)cmd->device->host->hostdata[0];\n\tmemset(msg, 0, sizeof(msg));\n\tprintk(KERN_WARNING\"%s: Bus reset: SCSI Bus %d: tid: %d\\n\",pHba->name, cmd->device->channel,pHba->channel[cmd->device->channel].tid );\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\trcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tprintk(KERN_WARNING\"%s: Bus reset failed.\\n\",pHba->name);\n\t\treturn FAILED;\n\t} else {\n\t\tprintk(KERN_WARNING\"%s: Bus reset success.\\n\",pHba->name);\n\t\treturn SUCCESS;\n\t}\n}", "target": 1}
{"code": "static void sctp_sock_rfree_frag(struct sk_buff *skb)\n{\n\tstruct sk_buff *frag;\n\tif (!skb->data_len)\n\t\tgoto done;\n\tfor (frag = skb_shinfo(skb)->frag_list; frag; frag = frag->next)\n\t\tsctp_sock_rfree_frag(frag);\ndone:\n\tsctp_sock_rfree(skb);\n}", "target": 0}
{"code": "TfLiteStatus SoftmaxPrepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = static_cast<TfLiteSoftmaxParams*>(node->builtin_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TFLITE_DCHECK(node->user_data != nullptr);\n  SoftmaxParams* data = static_cast<SoftmaxParams*>(node->user_data);\n  return CalculateSoftmaxParams(context, input, output, params, data);\n}", "target": 0}
{"code": "setup_wait_limits(struct infra_cache* infra, struct config_file* cfg)\n{\n\taddr_tree_init(&infra->wait_limits_netblock);\n\taddr_tree_init(&infra->wait_limits_cookie_netblock);\n\tif(!infra_wait_limit_netblock_insert(infra, cfg))\n\t\treturn 0;\n\taddr_tree_init_parents(&infra->wait_limits_netblock);\n\taddr_tree_init_parents(&infra->wait_limits_cookie_netblock);\n\treturn 1;\n}", "target": 0}
{"code": "test_validate_path_meta (void)\n{\n  gsize idx;\n  for (idx = 0; idx < G_N_ELEMENTS (invalid_path_meta); idx++)\n    {\n      g_autoptr(FlatpakContext) context = flatpak_context_new ();\n      g_autoptr(GKeyFile) metakey = g_key_file_new ();\n      g_autoptr(GError) local_error = NULL;\n      PathValidityData *data = &invalid_path_meta[idx];\n      gboolean ret = FALSE;\n      g_key_file_set_string_list (metakey, FLATPAK_METADATA_GROUP_CONTEXT,\n                                  data->key, &data->value, 1);\n      ret = flatpak_context_load_metadata (context, metakey, &local_error);\n      g_assert_false (ret);\n      g_assert_error (local_error, G_IO_ERROR, G_IO_ERROR_INVALID_DATA);\n      g_assert (strstr (local_error->message, \"Non-graphical character\"));\n    }\n}", "target": 0}
{"code": "get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,\n\t\t      const char *hookname, const char **chainname,\n\t\t      const char **comment, unsigned int *rulenum)\n{\n\tconst struct xt_standard_target *t = (void *)ipt_get_target_c(s);\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\t\tif (s->target_offset == sizeof(struct ipt_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t   t->verdict < 0 &&\n\t\t   unconditional(&s->ip)) {\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\treturn 0;\n}", "target": 1}
{"code": "static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\tlock_sock(sk);\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_name) {\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\tskb_free_datagram(sk, skb);\n\terr = copied;\nout:\n\trelease_sock(sk);\n\treturn err;\n}", "target": 0}
{"code": "static int validate_user_key(struct fscrypt_info *crypt_info,\n\t\t\tstruct fscrypt_context *ctx, u8 *raw_key,\n\t\t\tconst char *prefix)\n{\n\tchar *description;\n\tstruct key *keyring_key;\n\tstruct fscrypt_key *master_key;\n\tconst struct user_key_payload *ukp;\n\tint res;\n\tdescription = kasprintf(GFP_NOFS, \"%s%*phN\", prefix,\n\t\t\t\tFS_KEY_DESCRIPTOR_SIZE,\n\t\t\t\tctx->master_key_descriptor);\n\tif (!description)\n\t\treturn -ENOMEM;\n\tkeyring_key = request_key(&key_type_logon, description, NULL);\n\tkfree(description);\n\tif (IS_ERR(keyring_key))\n\t\treturn PTR_ERR(keyring_key);\n\tif (keyring_key->type != &key_type_logon) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key type must be logon\\n\", __func__);\n\t\tres = -ENOKEY;\n\t\tgoto out;\n\t}\n\tdown_read(&keyring_key->sem);\n\tukp = user_key_payload(keyring_key);\n\tif (ukp->datalen != sizeof(struct fscrypt_key)) {\n\t\tres = -EINVAL;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tmaster_key = (struct fscrypt_key *)ukp->data;\n\tBUILD_BUG_ON(FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE);\n\tif (master_key->size != FS_AES_256_XTS_KEY_SIZE) {\n\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"%s: key size incorrect: %d\\n\",\n\t\t\t\t__func__, master_key->size);\n\t\tres = -ENOKEY;\n\t\tup_read(&keyring_key->sem);\n\t\tgoto out;\n\t}\n\tres = derive_key_aes(ctx->nonce, master_key->raw, raw_key);\n\tup_read(&keyring_key->sem);\n\tif (res)\n\t\tgoto out;\n\tcrypt_info->ci_keyring_key = keyring_key;\n\treturn 0;\nout:\n\tkey_put(keyring_key);\n\treturn res;\n}", "target": 1}
{"code": "int af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len)\n{\n\tsize_t off;\n\tssize_t n;\n\tint npages, i;\n\tn = iov_iter_get_pages(iter, sgl->pages, len, ALG_MAX_PAGES, &off);\n\tif (n < 0)\n\t\treturn n;\n\tnpages = PAGE_ALIGN(off + n);\n\tif (WARN_ON(npages == 0))\n\t\treturn -EINVAL;\n\tsg_init_table(sgl->sg, npages);\n\tfor (i = 0, len = n; i < npages; i++) {\n\t\tint plen = min_t(int, len, PAGE_SIZE - off);\n\t\tsg_set_page(sgl->sg + i, sgl->pages[i], plen, off);\n\t\toff = 0;\n\t\tlen -= plen;\n\t}\n\treturn n;\n}", "target": 1}
{"code": "static __be32 nfsd4_open_omfg(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate, struct nfsd4_op *op)\n{\n\tstruct nfsd4_open *open = &op->u.open;\n\tif (!seqid_mutating_err(ntohl(op->status)))\n\t\treturn op->status;\n\tif (nfsd4_has_session(cstate))\n\t\treturn op->status;\n\topen->op_xdr_error = op->status;\n\treturn nfsd4_open(rqstp, cstate, &op->u);\n}", "target": 0}
{"code": "delta_head_destroy(struct delta_head *delta_head)\n{\n\tif (delta_head) {\n\t\tdoc_data_cleanup(&delta_head->doc_data);\n\t\tfree(delta_head);\n\t}\n}", "target": 1}
{"code": "BOOL security_fips_decrypt(BYTE* data, size_t length, rdpRdp* rdp)\n{\n\tsize_t olen;\n\tif (!rdp || !rdp->fips_decrypt)\n\t\treturn FALSE;\n\tif (!winpr_Cipher_Update(rdp->fips_decrypt, data, length, data, &olen))\n\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "WebProcessProxy::WebProcessProxy(PassRefPtr<WebContext> context)\n    : ChildProcessProxy(this)\n    , m_responsivenessTimer(this)\n    , m_context(context)\n    , m_mayHaveUniversalFileReadSandboxExtension(false)\n#if ENABLE(CUSTOM_PROTOCOLS)\n    , m_customProtocolManagerProxy(this)\n#endif\n#if PLATFORM(MAC)\n    , m_processSuppressionEnabled(false)\n#endif\n{\n    connect();\n}", "target": 0}
{"code": "static int dsa_precheck_params(const DSA *dsa, int *ret)\n{\n    if (dsa->params.p == NULL || dsa->params.q == NULL) {\n        ERR_raise(ERR_LIB_DSA, DSA_R_BAD_FFC_PARAMETERS);\n        *ret = FFC_CHECK_INVALID_PQ;\n        return 0;\n    }\n    if (BN_num_bits(dsa->params.p) > OPENSSL_DSA_MAX_MODULUS_BITS) {\n        ERR_raise(ERR_LIB_DSA, DSA_R_MODULUS_TOO_LARGE);\n        *ret = FFC_CHECK_INVALID_PQ;\n        return 0;\n    }\n    if (BN_num_bits(dsa->params.q) >= BN_num_bits(dsa->params.p)) {\n        ERR_raise(ERR_LIB_DSA, DSA_R_BAD_Q_VALUE);\n        *ret = FFC_CHECK_INVALID_PQ;\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "static char *socket_http_get_recursive(const char *url, int *code, int *rlen, ut32 redirections) {\n\tif (code) {\n\t\t*code = 0;\n\t}\n\tif (rlen) {\n\t\t*rlen = 0;\n\t}\n\tchar *curl_env = r_sys_getenv (\"R2_CURL\");\n\tif (!R_STR_ISEMPTY (curl_env) && atoi (curl_env)) {\n\t\tint len;\n\t\tchar *escaped_url = r_str_escape_sh (url);\n\t\tchar *command = r_str_newf (\"curl -sfL -o - \\\"%s\\\"\", escaped_url);\n\t\tchar *res = r_sys_cmd_str (command, NULL, &len);\n\t\tfree (escaped_url);\n\t\tfree (command);\n\t\tfree (curl_env);\n\t\tif (!res) {\n\t\t\treturn NULL;\n\t\t}\n\t\tif (res) {\n\t\t\tif (code) {\n\t\t\t\t*code = 200;\n\t\t\t}\n\t\t\tif (rlen) {\n\t\t\t\t*rlen = len;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tfree (curl_env);\n#if __WINDOWS__\n\treturn http_get_w32 (url, code, rlen);\n#else\n\tRSocket *s;\n\tint ssl = r_str_startswith (url, \"https:\n#if !HAVE_LIB_SSL\n\tif (ssl) {\n\t\teprintf (\"Tried to get '%s', but SSL support is disabled, set R2_CURL=1 to use curl\\n\", url);\n\t\treturn NULL;\n\t}\n#endif\n\tchar *response, *host, *path, *port = \"80\";\n\tchar *uri = strdup (url);\n\tif (!uri) {\n\t\treturn NULL;\n\t}\n\thost = strstr (uri, \":\n\tif (!host) {\n\t\tfree (uri);\n\t\teprintf (\"r_socket_http_get: Invalid URI\");\n\t\treturn NULL;\n\t}\n\thost += 3;\n\tport = strchr (host, ':');\n\tif (!port) {\n\t\tport = ssl? \"443\": \"80\";\n\t\tpath = host;\n\t} else {\n\t\t*port++ = 0;\n\t\tpath = port;\n\t}\n\tpath = strchr (path, '/');\n\tif (!path) {\n\t\tpath = \"\";\n\t} else {\n\t\t*path++ = 0;\n\t}\n\ts = r_socket_new (ssl);\n\tif (!s) {\n\t\teprintf (\"r_socket_http_get: Cannot create socket\\n\");\n\t\tfree (uri);\n\t\treturn NULL;\n\t}\n\tif (r_socket_connect_tcp (s, host, port, 0)) {\n\t\tr_socket_printf (s,\n\t\t\t\t\"GET /%s HTTP/1.1\\r\\n\"\n\t\t\t\t\"User-Agent: radare2 \"R2_VERSION\"\\r\\n\"\n\t\t\t\t\"Accept: *", "target": 0}
{"code": "static int dwc3_qcom_acpi_register_core(struct platform_device *pdev)\n{\n\tstruct dwc3_qcom\t*qcom = platform_get_drvdata(pdev);\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct resource\t\t*res, *child_res = NULL;\n\tstruct platform_device\t*pdev_irq = qcom->urs_usb ? qcom->urs_usb :\n\t\t\t\t\t\t\t    pdev;\n\tint\t\t\tirq;\n\tint\t\t\tret;\n\tqcom->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!qcom->dwc3)\n\t\treturn -ENOMEM;\n\tqcom->dwc3->dev.parent = dev;\n\tqcom->dwc3->dev.type = dev->type;\n\tqcom->dwc3->dev.dma_mask = dev->dma_mask;\n\tqcom->dwc3->dev.dma_parms = dev->dma_parms;\n\tqcom->dwc3->dev.coherent_dma_mask = dev->coherent_dma_mask;\n\tchild_res = kcalloc(2, sizeof(*child_res), GFP_KERNEL);\n\tif (!child_res)\n\t\treturn -ENOMEM;\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"failed to get memory resource\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tchild_res[0].flags = res->flags;\n\tchild_res[0].start = res->start;\n\tchild_res[0].end = child_res[0].start +\n\t\tqcom->acpi_pdata->dwc3_core_base_size;\n\tirq = platform_get_irq(pdev_irq, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto out;\n\t}\n\tchild_res[1].flags = IORESOURCE_IRQ;\n\tchild_res[1].start = child_res[1].end = irq;\n\tret = platform_device_add_resources(qcom->dwc3, child_res, 2);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add resources\\n\");\n\t\tgoto out;\n\t}\n\tret = device_add_software_node(&qcom->dwc3->dev, &dwc3_qcom_swnode);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add properties\\n\");\n\t\tgoto out;\n\t}\n\tret = platform_device_add(qcom->dwc3);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add device\\n\");\n\t\tdevice_remove_software_node(&qcom->dwc3->dev);\n\t}\nout:\n\tkfree(child_res);\n\treturn ret;\n}", "target": 1}
{"code": "  CdsIntegrationTest()\n      : HttpIntegrationTest(Http::CodecType::HTTP2, ipVersion(),\n                            ConfigHelper::discoveredClustersBootstrap(\n                                sotwOrDelta() == Grpc::SotwOrDelta::Sotw ||\n                                        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw\n                                    ? \"GRPC\"\n                                    : \"DELTA_GRPC\")) {\n    if (sotwOrDelta() == Grpc::SotwOrDelta::UnifiedSotw ||\n        sotwOrDelta() == Grpc::SotwOrDelta::UnifiedDelta) {\n      config_helper_.addRuntimeOverride(\"envoy.reloadable_features.unified_mux\", \"true\");\n    }\n    use_lds_ = false;\n    sotw_or_delta_ = sotwOrDelta();\n  }", "target": 1}
{"code": "static int cit_get_packet_size(struct gspca_dev *gspca_dev)\n{\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tintf = usb_ifnum_to_if(gspca_dev->dev, gspca_dev->iface);\n\talt = usb_altnum_to_altsetting(intf, gspca_dev->alt);\n\tif (!alt) {\n\t\tpr_err(\"Couldn't get altsetting\\n\");\n\t\treturn -EIO;\n\t}\n\tif (alt->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\treturn le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize);\n}", "target": 0}
{"code": "void pid_ns_release_proc(struct pid_namespace *ns)\n{\n\tmntput(ns->proc_mnt);\n}", "target": 1}
{"code": "static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size)\n{\n\tunsigned int u = 0;\n\tLineContribType *res;\n\tint overflow_error = 0;\n\tres = (LineContribType *) gdMalloc(sizeof(LineContribType));\n\tif (!res) {\n\t\treturn NULL;\n\t}\n\tres->WindowSize = windows_size;\n\tres->LineLength = line_length;\n\tif (overflow2(line_length, sizeof(ContributionType))) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tres->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType));\n\tif (res->ContribRow == NULL) {\n\t\tgdFree(res);\n\t\treturn NULL;\n\t}\n\tfor (u = 0 ; u < line_length ; u++) {\n\t\tif (overflow2(windows_size, sizeof(double))) {\n\t\t\toverflow_error = 1;\n\t\t} else {\n\t\t\tres->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double));\n\t\t}\n\t\tif (overflow_error == 1 || res->ContribRow[u].Weights == NULL) {\n\t\t\tunsigned int i;\n\t\t\tu--;\n\t\t\tfor (i=0;i<=u;i++) {\n\t\t\t\tgdFree(res->ContribRow[i].Weights);\n\t\t\t}\n\t\t\tgdFree(res->ContribRow);\n\t\t\tgdFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "static int http_read_stream(URLContext *h, uint8_t *buf, int size)\n{\n    HTTPContext *s = h->priv_data;\n    int err, new_location, read_ret;\n    int64_t seek_ret;\n    if (!s->hd)\n        return AVERROR_EOF;\n    if (s->end_chunked_post && !s->end_header) {\n        err = http_read_header(h, &new_location);\n        if (err < 0)\n            return err;\n    }\n    if (s->chunksize >= 0) {\n        if (!s->chunksize) {\n            char line[32];\n                do {\n                    if ((err = http_get_line(s, line, sizeof(line))) < 0)\n                        return err;\n                } while (!*line);    \n                s->chunksize = strtoll(line, NULL, 16);\n                av_log(NULL, AV_LOG_TRACE, \"Chunked encoding data size: %\"PRId64\"'\\n\",\n                        s->chunksize);\n                if (!s->chunksize)\n                    return 0;\n        }\n        size = FFMIN(size, s->chunksize);\n    }\n#if CONFIG_ZLIB\n    if (s->compressed)\n        return http_buf_read_compressed(h, buf, size);\n#endif \n    read_ret = http_buf_read(h, buf, size);\n    if (   (read_ret  < 0 && s->reconnect        && (!h->is_streamed || s->reconnect_streamed) && s->filesize > 0 && s->off < s->filesize)\n        || (read_ret == 0 && s->reconnect_at_eof && (!h->is_streamed || s->reconnect_streamed))) {\n        int64_t target = h->is_streamed ? 0 : s->off;\n        if (s->reconnect_delay > s->reconnect_delay_max)\n            return AVERROR(EIO);\n        av_log(h, AV_LOG_INFO, \"Will reconnect at %\"PRId64\" error=%s.\\n\", s->off, av_err2str(read_ret));\n        av_usleep(1000U*1000*s->reconnect_delay);\n        s->reconnect_delay = 1 + 2*s->reconnect_delay;\n        seek_ret = http_seek_internal(h, target, SEEK_SET, 1);\n        if (seek_ret != target) {\n            av_log(h, AV_LOG_ERROR, \"Failed to reconnect at %\"PRId64\".\\n\", target);\n            return read_ret;\n        }\n        read_ret = http_buf_read(h, buf, size);\n    } else\n        s->reconnect_delay = 0;\n    return read_ret;\n}", "target": 1}
{"code": "  explicit FractionalAvgPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\n                    \"pooling_ratio field must specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional average pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[100];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}", "target": 1}
{"code": "parse_notification(struct rpki_uri *uri, struct update_notification **file)\n{\n\tstruct rdr_notification_ctx ctx;\n\tstruct update_notification *tmp;\n\tchar *dup;\n\tint error;\n\tdup = strdup(uri_get_global(uri));\n\tif (dup == NULL)\n\t\treturn pr_enomem();\n\terror = update_notification_create(&tmp);\n\tif (error)\n\t\treturn error;\n\ttmp->uri = dup;\n\tctx.notification = tmp;\n\terror = relax_ng_parse(uri_get_local(uri), xml_read_notification,\n\t    &ctx);\n\tif (error) {\n\t\tupdate_notification_destroy(tmp);\n\t\treturn error;\n\t}\n\t*file = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "void ext4_xattr_destroy_cache(struct mb_cache *cache)\n{\n\tif (cache)\n\t\tmb_cache_destroy(cache);\n}", "target": 1}
{"code": "static inline struct rb_node *first_fair(struct cfs_rq *cfs_rq)\n{\n\treturn cfs_rq->rb_leftmost;\n}", "target": 0}
{"code": "static int kvaser_usb_leaf_set_opt_mode(const struct kvaser_usb_net_priv *priv)\n{\n\tstruct kvaser_cmd *cmd;\n\tint rc;\n\tcmd = kmalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->id = CMD_SET_CTRL_MODE;\n\tcmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_ctrl_mode);\n\tcmd->u.ctrl_mode.tid = 0xff;\n\tcmd->u.ctrl_mode.channel = priv->channel;\n\tif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_SILENT;\n\telse\n\t\tcmd->u.ctrl_mode.ctrl_mode = KVASER_CTRL_MODE_NORMAL;\n\trc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len);\n\tkfree(cmd);\n\treturn rc;\n}", "target": 1}
{"code": "PHP_FUNCTION(number_format)\n{\n\tdouble num;\n\tlong dec = 0;\n\tchar *thousand_sep = NULL, *dec_point = NULL;\n\tchar thousand_sep_chr = ',', dec_point_chr = '.';\n\tint thousand_sep_len = 0, dec_point_len = 0;\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"d|ls!s!\", &num, &dec, &dec_point, &dec_point_len, &thousand_sep, &thousand_sep_len) == FAILURE) {\n\t\treturn;\n\t}\n\tswitch(ZEND_NUM_ARGS()) {\n\tcase 1:\n\t\tRETURN_STRING(_php_math_number_format(num, 0, dec_point_chr, thousand_sep_chr), 0);\n\t\tbreak;\n\tcase 2:\n\t\tRETURN_STRING(_php_math_number_format(num, dec, dec_point_chr, thousand_sep_chr), 0);\n\t\tbreak;\n\tcase 4:\n\t\tif (dec_point == NULL) {\n\t\t\tdec_point = &dec_point_chr;\n\t\t\tdec_point_len = 1;\n\t\t}\n\t\tif (thousand_sep == NULL) {\n\t\t\tthousand_sep = &thousand_sep_chr;\n\t\t\tthousand_sep_len = 1;\n\t\t}\n\t\tZ_TYPE_P(return_value) = IS_STRING;\n\t\tZ_STRVAL_P(return_value) = _php_math_number_format_ex_len(num, dec,\n\t\t\t\tdec_point, dec_point_len, thousand_sep, thousand_sep_len,\n\t\t\t\t&Z_STRLEN_P(return_value));\n\t\tbreak;\n\tdefault:\n\t\tWRONG_PARAM_COUNT;\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "ssh_packet_set_compress_hooks(struct ssh *ssh, void *ctx,\n    void *(*allocfunc)(void *, u_int, u_int),\n    void (*freefunc)(void *, void *))\n{\n\tssh->state->compression_out_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_out_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_out_stream.opaque = ctx;\n\tssh->state->compression_in_stream.zalloc = (alloc_func)allocfunc;\n\tssh->state->compression_in_stream.zfree = (free_func)freefunc;\n\tssh->state->compression_in_stream.opaque = ctx;\n}", "target": 1}
{"code": "static void fts3SnippetAdvance(char **ppIter, int *piIter, int iNext){\n  char *pIter = *ppIter;\n  if( pIter ){\n    int iIter = *piIter;\n    while( iIter<iNext ){\n      if( 0==(*pIter & 0xFE) ){\n        iIter = -1;\n        pIter = 0;\n        break;\n      }\n      fts3GetDeltaPosition(&pIter, &iIter);\n    }\n    *piIter = iIter;\n    *ppIter = pIter;\n  }\n}", "target": 0}
{"code": "static void sas_destruct_devices(struct work_struct *work)\n{\n\tstruct domain_device *dev, *n;\n\tstruct sas_discovery_event *ev = to_sas_discovery_event(work);\n\tstruct asd_sas_port *port = ev->port;\n\tclear_bit(DISCE_DESTRUCT, &port->disc.pending);\n\tlist_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {\n\t\tlist_del_init(&dev->disco_list_node);\n\t\tsas_remove_children(&dev->rphy->dev);\n\t\tsas_rphy_delete(dev->rphy);\n\t\tsas_unregister_common_dev(port, dev);\n\t}\n}", "target": 1}
{"code": "static void do_free_keypair(struct rsa_keypair *s)\n{\n\tsss_status_t st = kStatus_SSS_Fail;\n\tsss_se05x_object_t k_object = { };\n\tuint32_t key_id = 0;\n\tif (!s)\n\t\treturn;\n\tkey_id = se050_rsa_keypair_from_nvm(s);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}", "target": 1}
{"code": "callbacks_show_selection_on_invisible (GtkMenuItem *menuitem, gpointer user_data)\n{\n\tmainProject->show_invisible_selection = GTK_CHECK_MENU_ITEM(menuitem)->active;\n\trender_refresh_rendered_image_on_screen();\n}", "target": 0}
{"code": "inline void ScatterNd(const RuntimeShape& indices_shape,\n                      const IndicesT* indices_data,\n                      const RuntimeShape& updates_shape,\n                      const UpdatesT* updates_data,\n                      const RuntimeShape& output_shape, UpdatesT* output_data) {\n  ruy::profiler::ScopeLabel label(\"ScatterNd\");\n  int n_slices = 1;\n  int slice_size = 1;\n  const int outer_dims = indices_shape.DimensionsCount() - 1;\n  const int indices_nd = indices_shape.Dims(outer_dims);\n  const int updates_dims = updates_shape.DimensionsCount();\n  for (int i = 0; i < outer_dims; ++i) {\n    n_slices *= indices_shape.Dims(i);\n  }\n  for (int i = outer_dims; i < updates_dims; ++i) {\n    slice_size *= updates_shape.Dims(i);\n  }\n  int output_flat_size = output_shape.FlatSize();\n  int remain_flat_size = output_flat_size;\n  std::vector<int> dims_to_count(indices_nd, 0);\n  for (int i = 0; i < indices_nd; ++i) {\n    dims_to_count[i] = remain_flat_size / output_shape.Dims(i);\n    remain_flat_size = dims_to_count[i];\n  }\n  memset(output_data, 0, sizeof(UpdatesT) * output_flat_size);\n  for (int i = 0; i < n_slices; ++i) {\n    int to_pos = 0;\n    for (int j = 0; j < indices_nd; ++j) {\n      IndicesT idx = indices_data[i * indices_nd + j];\n      TFLITE_DCHECK(0 <= idx && idx < output_shape.Dims(j));\n      to_pos += idx * dims_to_count[j];\n    }\n    for (int j = 0; j < slice_size; j++) {\n      output_data[to_pos + j] += updates_data[i * slice_size + j];\n    }\n  }\n}", "target": 1}
{"code": "void* ipc_rcu_alloc(int size)\n{\n\tvoid* out;\n\tif (rcu_use_vmalloc(size)) {\n\t\tout = vmalloc(HDRLEN_VMALLOC + size);\n\t\tif (out) {\n\t\t\tout += HDRLEN_VMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 1;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t} else {\n\t\tout = kmalloc(HDRLEN_KMALLOC + size, GFP_KERNEL);\n\t\tif (out) {\n\t\t\tout += HDRLEN_KMALLOC;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->is_vmalloc = 0;\n\t\t\tcontainer_of(out, struct ipc_rcu_hdr, data)->refcount = 1;\n\t\t}\n\t}\n\treturn out;\n}", "target": 1}
{"code": "PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;\n    if (NPT_SUCCEEDED(PLT_UPnPMessageHelper::GetIfModifiedSince((NPT_HttpMessage&)request, date)) &&\n        !range_spec) {\n        date.ToTimeStamp(timestamp);\n        NPT_LOG_INFO_5(\"File %s timestamps: request=%d (%s) vs file=%d (%s)\", \n                       (const char*)request.GetUrl().GetPath(),\n                       (NPT_UInt32)timestamp.ToSeconds(),\n                       (const char*)date.ToString(),\n                       (NPT_UInt32)file_info.m_ModificationTime,\n                       (const char*)NPT_DateTime(file_info.m_ModificationTime).ToString());\n        if (timestamp >= file_info.m_ModificationTime) {\n            NPT_LOG_FINE_1(\"Returning 304 for %s\", request.GetUrl().GetPath().GetChars());\n            response.SetStatus(304, \"Not Modified\", NPT_HTTP_PROTOCOL_1_1);\n            return NPT_SUCCESS;\n        }\n    }\n    if (NPT_FAILED(file.Open(NPT_FILE_OPEN_MODE_READ)) || \n        NPT_FAILED(file.GetInputStream(stream))        ||\n        stream.IsNull()) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    if (file_info.m_ModificationTime) {\n        NPT_DateTime last_modified = NPT_DateTime(file_info.m_ModificationTime);\n        response.GetHeaders().SetHeader(\"Last-Modified\", last_modified.ToString(NPT_DateTime::FORMAT_RFC_1123), true);\n        response.GetHeaders().SetHeader(\"Cache-Control\", \"max-age=0,must-revalidate\", true);\n    }\n    PLT_HttpRequestContext tmp_context(request, context);\n    return ServeStream(request, context, response, stream, PLT_MimeType::GetMimeType(file_path, &tmp_context));\n}", "target": 1}
{"code": "static void xmt_remove_link_for_descriptor(GF_XMTParser* parser, GF_Descriptor* desc) {\n\tu32 i=0;\n\tXMT_ODLink *l, *to_del=NULL;\n\twhile ((l = (XMT_ODLink*)gf_list_enum(parser->od_links, &i)) ) {\n\t\tif (l->od && l->od == (GF_ObjectDescriptor*)desc) {\n\t\t\tl->od = NULL;\n\t\t\tto_del = l;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (to_del) {\n\t\ti=0;\n\t\tGF_Descriptor* subdesc;\n\t\twhile ((subdesc = gf_list_enum(((GF_ObjectDescriptor*)desc)->ESDescriptors, &i))) {\n\t\t\tif (subdesc) xmt_remove_link_for_descriptor(parser, subdesc);\n\t\t}\n\t\tgf_list_del_item(parser->od_links, to_del);\n\t\tif (to_del->desc_name) gf_free(to_del->desc_name);\n\t\tgf_list_del(to_del->mf_urls);\n\t\tgf_free(to_del);\n\t}\n\tXMT_ESDLink *esdl, *esdl_del=NULL;\n\ti=0;\n\twhile ((esdl = (XMT_ESDLink *)gf_list_enum(parser->esd_links, &i))) {\n\t\tif (esdl->esd && esdl->esd == (GF_ESD*)desc) {\n\t\t\tesdl->esd = NULL;\n\t\t\tesdl_del = esdl;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (esdl_del) {\n\t\tgf_list_del_item(parser->esd_links, esdl_del);\n\t\tif (esdl_del->desc_name) gf_free(esdl_del->desc_name);\n\t\tgf_free(esdl_del);\n\t}\n}", "target": 0}
{"code": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\tif (key_is_instantiated(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}", "target": 1}
{"code": "static int rngapi_reset(struct crypto_rng *tfm, const u8 *seed,\n\t\t\tunsigned int slen)\n{\n\tu8 *buf = NULL;\n\tu8 *src = (u8 *)seed;\n\tint err;\n\tif (slen) {\n\t\tbuf = kmalloc(slen, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(buf, seed, slen);\n\t\tsrc = buf;\n\t}\n\terr = crypto_old_rng_alg(tfm)->rng_reset(tfm, src, slen);\n\tkzfree(buf);\n\treturn err;\n}", "target": 1}
{"code": "void uwbd_start(struct uwb_rc *rc)\n{\n\trc->uwbd.task = kthread_run(uwbd, rc, \"uwbd\");\n\tif (rc->uwbd.task == NULL)\n\t\tprintk(KERN_ERR \"UWB: Cannot start management daemon; \"\n\t\t       \"UWB won't work\\n\");\n\telse\n\t\trc->uwbd.pid = rc->uwbd.task->pid;\n}", "target": 1}
{"code": "ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context)\n    : OpKernel(context) {\n  OP_REQUIRES_OK(context,\n                 context->GetAttr(kMemoryRegionNameAttr, &region_name_));\n  OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_));\n  OP_REQUIRES(context, dtype_ != DT_RESOURCE && dtype_ != DT_VARIANT,\n              errors::InvalidArgument(\n                  \"Resource and variant dtypes are invalid for this op.\"));\n  OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_));\n}", "target": 0}
{"code": "static int unix_dgram_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int alen, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct sockaddr_un *sunaddr = (struct sockaddr_un *)addr;\n\tstruct sock *other;\n\tunsigned int hash;\n\tint err;\n\tif (addr->sa_family != AF_UNSPEC) {\n\t\terr = unix_mkname(sunaddr, alen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\talen = err;\n\t\tif (test_bit(SOCK_PASSCRED, &sock->flags) &&\n\t\t    !unix_sk(sk)->addr && (err = unix_autobind(sock)) != 0)\n\t\t\tgoto out;\nrestart:\n\t\tother = unix_find_other(net, sunaddr, alen, sock->type, hash, &err);\n\t\tif (!other)\n\t\t\tgoto out;\n\t\tunix_state_double_lock(sk, other);\n\t\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t\tunix_state_double_unlock(sk, other);\n\t\t\tsock_put(other);\n\t\t\tgoto restart;\n\t\t}\n\t\terr = -EPERM;\n\t\tif (!unix_may_send(sk, other))\n\t\t\tgoto out_unlock;\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t} else {\n\t\tother = NULL;\n\t\tunix_state_double_lock(sk, other);\n\t}\n\tif (unix_peer(sk)) {\n\t\tstruct sock *old_peer = unix_peer(sk);\n\t\tunix_peer(sk) = other;\n\t\tunix_dgram_peer_wake_disconnect_wakeup(sk, old_peer);\n\t\tunix_state_double_unlock(sk, other);\n\t\tif (other != old_peer)\n\t\t\tunix_dgram_disconnected(sk, old_peer);\n\t\tsock_put(old_peer);\n\t} else {\n\t\tunix_peer(sk) = other;\n\t\tunix_state_double_unlock(sk, other);\n\t}\n\treturn 0;\nout_unlock:\n\tunix_state_double_unlock(sk, other);\n\tsock_put(other);\nout:\n\treturn err;\n}", "target": 0}
{"code": "static TEE_Result do_allocate_publickey(struct rsa_public_key *key,\n\t\t\t\t\tsize_t size_bits)\n{\n\tRSA_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->e = crypto_bignum_allocate(MAX_BITS_EXP_E);\n\tif (!key->e)\n\t\tgoto err_alloc_publickey;\n\tkey->n = crypto_bignum_allocate(size_bits);\n\tif (!key->n)\n\t\tgoto err_alloc_publickey;\n\treturn TEE_SUCCESS;\nerr_alloc_publickey:\n\tRSA_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->n);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "char *uwsgi_expand_path(char *dir, int dir_len, char *ptr) {\n\tchar src[PATH_MAX + 1];\n\tmemcpy(src, dir, dir_len);\n\tsrc[dir_len] = 0;\n\tchar *dst = ptr;\n\tif (!dst)\n\t\tdst = uwsgi_malloc(PATH_MAX + 1);\n\tif (!realpath(src, dst)) {\n\t\tuwsgi_error_realpath(src);\n\t\tif (!ptr)\n\t\t\tfree(dst);\n\t\treturn NULL;\n\t}\n\treturn dst;\n}", "target": 1}
{"code": "    size_t operator()(const std::string &str) const\n    {\n        const size_t A = 6665339;\n        const size_t B = 2534641;\n        size_t h = fixedRandomNumber;\n        for (char ch : str)\n            h = (h * A) ^ (ch * B);\n        return h;\n    }", "target": 0}
{"code": "static const char *set_trace_enable(cmd_parms *cmd, void *dummy,\n                                    const char *arg1)\n{\n    core_server_config *conf =\n        ap_get_core_module_config(cmd->server->module_config);\n    if (ap_cstr_casecmp(arg1, \"on\") == 0) {\n        conf->trace_enable = AP_TRACE_ENABLE;\n    }\n    else if (ap_cstr_casecmp(arg1, \"off\") == 0) {\n        conf->trace_enable = AP_TRACE_DISABLE;\n    }\n    else if (ap_cstr_casecmp(arg1, \"extended\") == 0) {\n        conf->trace_enable = AP_TRACE_EXTENDED;\n    }\n    else {\n        return \"TraceEnable must be one of 'on', 'off', or 'extended'\";\n    }\n    return NULL;\n}", "target": 0}
{"code": "static void my_gballoc_free(void* ptr)\n{\n    free(ptr);\n}", "target": 0}
{"code": "\t\tvoid Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\tUnmaybe(object->Delete(context_handle, key_inner));\n\t\t\tLocal<Value> val_inner = val->TransferIn();\n\t\t\tdid_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));\n\t\t}", "target": 1}
{"code": "decode_sequence_of(const uint8_t *asn1, size_t len,\n                   const struct atype_info *elemtype, void **seq_out,\n                   size_t *count_out)\n{\n    krb5_error_code ret;\n    void *seq = NULL, *elem, *newseq;\n    const uint8_t *contents;\n    size_t clen, count = 0;\n    taginfo t;\n    *seq_out = NULL;\n    *count_out = 0;\n    while (len > 0) {\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        if (!check_atype_tag(elemtype, &t)) {\n            ret = ASN1_BAD_ID;\n            goto error;\n        }\n        newseq = realloc(seq, (count + 1) * elemtype->size);\n        if (newseq == NULL) {\n            ret = ENOMEM;\n            goto error;\n        }\n        seq = newseq;\n        elem = (char *)seq + count * elemtype->size;\n        memset(elem, 0, elemtype->size);\n        ret = decode_atype(&t, contents, clen, elemtype, elem);\n        if (ret)\n            goto error;\n        count++;\n    }\n    *seq_out = seq;\n    *count_out = count;\n    return 0;\nerror:\n    free_sequence_of(elemtype, seq, count);\n    free(seq);\n    return ret;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const auto splits = ctx->input(0).flat<int64_t>();\n    const auto values = ctx->input(1).flat<Tidx>();\n    const Tensor& size_t = ctx->input(2);\n    const auto weights = ctx->input(3).flat<T>();\n    const int64_t weights_size = weights.size();\n    OP_REQUIRES(ctx, size_t.dims() == 0,\n                errors::InvalidArgument(\"Shape must be rank 0 but is rank \",\n                                        size_t.dims()));\n    Tidx size = size_t.scalar<Tidx>()();\n    OP_REQUIRES(\n        ctx, size >= 0,\n        errors::InvalidArgument(\"size (\", size, \") must be non-negative\"));\n    int num_rows = splits.size() - 1;\n    int num_values = values.size();\n    int batch_idx = 0;\n    OP_REQUIRES(ctx, splits.size() > 0,\n                errors::InvalidArgument(\"Splits must be non-empty\"));\n    OP_REQUIRES(ctx, splits(0) == 0,\n                errors::InvalidArgument(\"Splits must start with 0, not with \",\n                                        splits(0)));\n    OP_REQUIRES(ctx, splits(num_rows) == num_values,\n                errors::InvalidArgument(\n                    \"Splits must end with the number of values, got \",\n                    splits(num_rows), \" instead of \", num_values));\n    Tensor* out_t;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_output(0, TensorShape({num_rows, size}), &out_t));\n    functor::SetZeroFunctor<Device, T> fill;\n    fill(ctx->eigen_device<Device>(), out_t->flat<T>());\n    const auto out = out_t->matrix<T>();\n    for (int idx = 0; idx < num_values; ++idx) {\n      while (idx >= splits(batch_idx)) {\n        batch_idx++;\n      }\n      Tidx bin = values(idx);\n      OP_REQUIRES(ctx, bin >= 0,\n                  errors::InvalidArgument(\"Input must be non-negative\"));\n      if (bin < size) {\n        if (binary_output_) {\n          out(batch_idx - 1, bin) = T(1);\n        } else {\n          T value = (weights_size > 0) ? weights(idx) : T(1);\n          out(batch_idx - 1, bin) += value;\n        }\n      }\n    }\n  }", "target": 0}
{"code": "static void bnx2x_init_cyclecounter(struct bnx2x *bp)\n{\n\tmemset(&bp->cyclecounter, 0, sizeof(bp->cyclecounter));\n\tbp->cyclecounter.read = bnx2x_cyclecounter_read;\n\tbp->cyclecounter.mask = CYCLECOUNTER_MASK(64);\n\tbp->cyclecounter.shift = 0;\n\tbp->cyclecounter.mult = 1;\n}", "target": 0}
{"code": "pci_get_cfgdata32(struct pci_vdev *dev, int offset)\n{\n\tassert(offset <= (PCI_REGMAX - 3) && (offset & 3) == 0);\n\treturn (*(uint32_t *)(dev->cfgdata + offset));\n}", "target": 1}
{"code": "static int make_ydt24_entry(int p1, int p2, int16_t *ydt)\n{\n    int lo, hi;\n    lo = ydt[p1];\n    hi = ydt[p2];\n    return (lo + (hi << 8) + (hi << 16)) << 1;\n}", "target": 0}
{"code": "Server::clientWriteDone(const CommIoCbParams &io)\n{\n    debugs(33,5, io.conn);\n    Must(writer != nullptr);\n    writer = nullptr;\n    if (io.flag == Comm::ERR_CLOSING || !Comm::IsConnOpen(clientConnection)) {\n        debugs(33,5, io.conn << \" closing Bailout.\");\n        return;\n    }\n    Must(io.conn->fd == clientConnection->fd);\n    if (io.flag && pipeline.front())\n        pipeline.front()->initiateClose(\"write failure\");\n    afterClientWrite(io.size); \n    writeSomeData(); \n}", "target": 1}
{"code": "static bool nf_generic_should_process(u8 proto)\n{\n\tswitch (proto) {\n#ifdef CONFIG_NF_CT_PROTO_SCTP_MODULE\n\tcase IPPROTO_SCTP:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_DCCP_MODULE\n\tcase IPPROTO_DCCP:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_GRE_MODULE\n\tcase IPPROTO_GRE:\n\t\treturn false;\n#endif\n#ifdef CONFIG_NF_CT_PROTO_UDPLITE_MODULE\n\tcase IPPROTO_UDPLITE:\n\t\treturn false;\n#endif\n\tdefault:\n\t\treturn true;\n\t}\n}", "target": 0}
{"code": "pacparser_find_proxy(const char *url, const char *host)\n{\n  char *error_prefix = \"pacparser.c: pacparser_find_proxy:\";\n  if (_debug()) print_error(\"DEBUG: Finding proxy for URL: %s and Host:\"\n                        \" %s\\n\", url, host);\n  jsval rval;\n  char *script;\n  if (url == NULL || (strcmp(url, \"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"URL not defined\");\n    return NULL;\n  }\n  if (host == NULL || (strcmp(host,\"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Host not defined\");\n    return NULL;\n  }\n  if (cx == NULL || global == NULL) {\n    print_error(\"%s %s\\n\", error_prefix, \"Pac parser is not initialized.\");\n    return NULL;\n  }\n  script = \"typeof(findProxyForURL);\";\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval);\n  if (strcmp(\"function\", JS_GetStringBytes(JS_ValueToString(cx, rval))) != 0) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Javascript function findProxyForURL not defined.\");\n    return NULL;\n  }\n  char *sanitized_url = str_replace(url, \"'\", \"%27\");\n  if (strchr(host, '\\'')) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t\"Invalid hostname: hostname can't have single quotes.\");\n    return NULL;\n  }\n  script = (char*) malloc(32 + strlen(url) + strlen(host));\n  script[0] = '\\0';\n  strcat(script, \"findProxyForURL('\");\n  strcat(script, sanitized_url);\n  strcat(script, \"', '\");\n  strcat(script, host);\n  strcat(script, \"')\");\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  if (!JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Problem in executing findProxyForURL.\");\n    free(sanitized_url);\n    free(script);\n    return NULL;\n  }\n  free(sanitized_url);\n  free(script);\n  return JS_GetStringBytes(JS_ValueToString(cx, rval));\n}", "target": 1}
{"code": "static void sas_resume_port(struct asd_sas_phy *phy)\n{\n\tstruct domain_device *dev;\n\tstruct asd_sas_port *port = phy->port;\n\tstruct sas_ha_struct *sas_ha = phy->ha;\n\tstruct sas_internal *si = to_sas_internal(sas_ha->core.shost->transportt);\n\tif (si->dft->lldd_port_formed)\n\t\tsi->dft->lldd_port_formed(phy);\n\tif (port->suspended)\n\t\tport->suspended = 0;\n\telse {\n\t\treturn;\n\t}\n\tlist_for_each_entry(dev, &port->dev_list, dev_list_node) {\n\t\tint i, rc;\n\t\trc = sas_notify_lldd_dev_found(dev);\n\t\tif (rc) {\n\t\t\tsas_unregister_dev(port, dev);\n\t\t\tsas_destruct_devices(port);\n\t\t\tcontinue;\n\t\t}\n\t\tif (dev->dev_type == SAS_EDGE_EXPANDER_DEVICE || dev->dev_type == SAS_FANOUT_EXPANDER_DEVICE) {\n\t\t\tdev->ex_dev.ex_change_count = -1;\n\t\t\tfor (i = 0; i < dev->ex_dev.num_phys; i++) {\n\t\t\t\tstruct ex_phy *phy = &dev->ex_dev.ex_phy[i];\n\t\t\t\tphy->phy_change_count = -1;\n\t\t\t}\n\t\t}\n\t}\n\tsas_discover_event(port, DISCE_RESUME);\n}", "target": 0}
{"code": "QTN2QT(QTNode *in)\n{\n\tTSQuery\t\tout;\n\tint\t\t\tlen;\n\tint\t\t\tsumlen = 0,\n\t\t\t\tnnode = 0;\n\tQTN2QTState state;\n\tcntsize(in, &sumlen, &nnode);\n\tif (TSQUERY_TOO_BIG(nnode, sumlen))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"tsquery is too large\")));\n\tlen = COMPUTESIZE(nnode, sumlen);\n\tout = (TSQuery) palloc0(len);\n\tSET_VARSIZE(out, len);\n\tout->size = nnode;\n\tstate.curitem = GETQUERY(out);\n\tstate.operand = state.curoperand = GETOPERAND(out);\n\tfillQT(&state, in);\n\treturn out;\n}", "target": 0}
{"code": "void WebContentsImpl::OnJSOutOfMemory() {\n  if (delegate_)\n    delegate_->JSOutOfMemory(this);\n}", "target": 0}
{"code": "TEST_F(StuffingTest, SignedData_missing_codesigning_EKU) {\n  auto certs = uthenticode::read_certs(pe);\n  auto signed_data = certs[0].as_signed_data();\n  ASSERT_TRUE(signed_data->verify_signature());\n}", "target": 0}
{"code": "    void publish(Topic *iterator, size_t start, size_t stop, std::string_view topic, std::pair<std::string_view, std::string_view> message) {\n        if (numTriggeredTopics == 64) {\n            drain();\n        }\n        for (; stop != std::string::npos; start = stop + 1) {\n            stop = topic.find('/', start);\n            std::string_view segment = topic.substr(start, stop - start);\n            if (segment.length() == 1) {\n                if (segment[0] == '+' || segment[0] == '#') {\n                    return;\n                }\n            }\n            if (iterator->terminatingWildcardChild) {\n                iterator->terminatingWildcardChild->messages[messageId] = message;\n                if (!iterator->terminatingWildcardChild->triggered) {\n                    triggeredTopics[numTriggeredTopics++] = iterator->terminatingWildcardChild;\n                    iterator->terminatingWildcardChild->triggered = true;\n                }\n            }\n            if (iterator->wildcardChild) {\n                publish(iterator->wildcardChild, stop + 1, stop, topic, message);\n            }\n            std::map<std::string_view, Topic *>::iterator it = iterator->children.find(segment);\n            if (it == iterator->children.end()) {\n                return;\n            }\n            iterator = it->second;\n        }\n        iterator->messages[messageId] = message;\n        if (!iterator->triggered) {\n            triggeredTopics[numTriggeredTopics++] = iterator;\n            iterator->triggered = true;\n        }\n    }", "target": 1}
{"code": "void user_describe(const struct key *key, struct seq_file *m)\n{\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %u\", key->datalen);\n}", "target": 1}
{"code": "static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,\n\t\t\t\t    struct net_device *ndev)\n{\n\tstruct hns_nic_priv *priv = netdev_priv(ndev);\n\tint ret;\n\tassert(skb->queue_mapping < ndev->ae_handle->q_num);\n\tret = hns_nic_net_xmit_hw(ndev, skb,\n\t\t\t\t  &tx_ring_data(priv, skb->queue_mapping));\n\tif (ret == NETDEV_TX_OK) {\n\t\tnetif_trans_update(ndev);\n\t\tndev->stats.tx_bytes += skb->len;\n\t\tndev->stats.tx_packets++;\n\t}\n\treturn (netdev_tx_t)ret;\n}", "target": 1}
{"code": "void RequestContext::AddInstanceIdentityToken() {\n  if (!method()) {\n    return;\n  }\n  const auto &audience = method()->backend_jwt_audience();\n  if (!audience.empty()) {\n    auto &token = service_context()\n                      ->global_context()\n                      ->GetInstanceIdentityToken(audience)\n                      ->GetAuthToken();\n    if (!token.empty()) {\n      std::string origin_auth_header;\n      if (request()->FindHeader(kAuthorizationHeader, &origin_auth_header)) {\n        Status status = request()->AddHeaderToBackend(\n            kXForwardedAuthorizationHeader, origin_auth_header);\n        if (!status.ok()) {\n          service_context()->env()->LogError(\n              \"Failed to set X-Forwarded-Authorization header to backend.\");\n        }\n      }\n      Status status = request()->AddHeaderToBackend(kAuthorizationHeader,\n                                                    kBearerPrefix + token);\n      if (!status.ok()) {\n        service_context()->env()->LogError(\n            \"Failed to set authorization header to backend.\");\n      }\n    }\n  }\n}", "target": 1}
{"code": "  CookieHashMethod(const std::string& key, const std::string& path,\n                   const absl::optional<std::chrono::seconds>& ttl, bool terminal,\n                   const CookieAttributeRefVector attributes)\n      : HashMethodImplBase(terminal), key_(key), path_(path), ttl_(ttl), attributes_(attributes) {}", "target": 1}
{"code": "TEST_F(HTTP2CodecTest, TrailersNotLatest) {\n  HTTPMessage req = getGetRequest(\"/guacamole\");\n  req.getHeaders().add(HTTP_HEADER_USER_AGENT, \"coolio\");\n  upstreamCodec_.generateHeader(output_, 1, req);\n  upstreamCodec_.generateHeader(output_, 3, req);\n  HTTPHeaders trailers;\n  trailers.add(\"x-trailer-1\", \"pico-de-gallo\");\n  upstreamCodec_.generateTrailers(output_, 1, trailers);\n  upstreamCodec_.generateHeader(output_, 3, req);\n  parse();\n  EXPECT_EQ(callbacks_.messageBegin, 2);\n  EXPECT_EQ(callbacks_.headersComplete, 2);\n  EXPECT_EQ(callbacks_.bodyCalls, 0);\n  EXPECT_EQ(callbacks_.trailers, 1);\n  EXPECT_NE(nullptr, callbacks_.msg->getTrailers());\n  EXPECT_EQ(\"pico-de-gallo\",\n            callbacks_.msg->getTrailers()->getSingleOrEmpty(\"x-trailer-1\"));\n  EXPECT_EQ(callbacks_.messageComplete, 1);\n  EXPECT_EQ(callbacks_.streamErrors, 1);\n  EXPECT_EQ(callbacks_.sessionErrors, 0);\n}", "target": 0}
{"code": "ZEND_API void zend_update_property_null(zend_class_entry *scope, zval *object, const char *name, int name_length TSRMLS_DC) \n{\n\tzval *tmp;\n\tALLOC_ZVAL(tmp);\n\tZ_UNSET_ISREF_P(tmp);\n\tZ_SET_REFCOUNT_P(tmp, 0);\n\tZVAL_NULL(tmp);\n\tzend_update_property(scope, object, name, name_length, tmp TSRMLS_CC);\n}", "target": 0}
{"code": "static int8_t sn_coap_parser_add_u16_limit(uint16_t a, uint16_t b, uint16_t *result)\n{\n    uint16_t c;\n    c = a + b;\n    if (c < a || c < b)\n    {\n        return -1;\n    }\n    *result = c;\n    return 0;\n}", "target": 0}
{"code": "char *curl_easy_unescape(CURL *handle, const char *string, int length,\n                         int *olen)\n{\n  int alloc = (length?length:(int)strlen(string))+1;\n  char *ns = malloc(alloc);\n  unsigned char in;\n  int strindex=0;\n  unsigned long hex;\n  CURLcode res;\n  if(!ns)\n    return NULL;\n  while(--alloc > 0) {\n    in = *string;\n    if(('%' == in) && ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {\n      char hexstr[3];\n      char *ptr;\n      hexstr[0] = string[1];\n      hexstr[1] = string[2];\n      hexstr[2] = 0;\n      hex = strtoul(hexstr, &ptr, 16);\n      in = curlx_ultouc(hex); \n      res = Curl_convert_from_network(handle, &in, 1);\n      if(res) {\n        free(ns);\n        return NULL;\n      }\n      string+=2;\n      alloc-=2;\n    }\n    ns[strindex++] = in;\n    string++;\n  }\n  ns[strindex]=0; \n  if(olen)\n    *olen = strindex;\n  return ns;\n}", "target": 1}
{"code": "static void adpt_i2o_report_hba_unit(adpt_hba* pHba, struct i2o_device *d)\n{\n\tchar buf[64];\n\tint unit = d->lct_data.tid;\n\tprintk(KERN_INFO \"TID %3.3d \", unit);\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 3, buf, 16)>=0)\n\t{\n\t\tbuf[16]=0;\n\t\tprintk(\" Vendor: %-12.12s\", buf);\n\t}\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 4, buf, 16)>=0)\n\t{\n\t\tbuf[16]=0;\n\t\tprintk(\" Device: %-12.12s\", buf);\n\t}\n\tif(adpt_i2o_query_scalar(pHba, unit, 0xF100, 6, buf, 8)>=0)\n\t{\n\t\tbuf[8]=0;\n\t\tprintk(\" Rev: %-12.12s\\n\", buf);\n\t}\n#ifdef DEBUG\n\t printk(KERN_INFO \"\\tClass: %.21s\\n\", adpt_i2o_get_class_name(d->lct_data.class_id));\n\t printk(KERN_INFO \"\\tSubclass: 0x%04X\\n\", d->lct_data.sub_class);\n\t printk(KERN_INFO \"\\tFlags: \");\n\t if(d->lct_data.device_flags&(1<<0))\n\t\t  printk(\"C\");\t     \n\t if(d->lct_data.device_flags&(1<<1))\n\t\t  printk(\"U\");\t     \n\t if(!(d->lct_data.device_flags&(1<<4)))\n\t\t  printk(\"P\");\t     \n\t if(!(d->lct_data.device_flags&(1<<5)))\n\t\t  printk(\"M\");\t     \n\t printk(\"\\n\");\n#endif\n}", "target": 1}
{"code": "CoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,\n                     Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m):\n\tparams(p),\n\tdenomination(coin.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((coin.getSerialNumber())),\n\taccumulatorPoK(&p->accumulatorParams),\n\tserialNumberSoK(p),\n\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\tif (!HasValidSerial()) {\n\t\tthrow ZerocoinException(\"Invalid serial # range\");\n\t}\n\tconst Commitment fullCommitmentToCoinUnderSerialParams(&p->serialNumberSoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = fullCommitmentToCoinUnderSerialParams.getCommitmentValue();\n\tconst Commitment fullCommitmentToCoinUnderAccParams(&p->accumulatorParams.accumulatorPoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = fullCommitmentToCoinUnderAccParams.getCommitmentValue();\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup, fullCommitmentToCoinUnderSerialParams, fullCommitmentToCoinUnderAccParams);\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&p->accumulatorParams, fullCommitmentToCoinUnderAccParams, witness, a);\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(p, coin, fullCommitmentToCoinUnderSerialParams, signatureHash(m));\n}", "target": 0}
{"code": "void RuleMatchCandidateTxArrayFree(DetectEngineThreadCtx *det_ctx)\n{\n    SCFree(det_ctx->tx_candidates);\n    det_ctx->tx_candidates_size = 0;\n}", "target": 0}
{"code": "spnego_gss_unwrap(\n\t\tOM_uint32 *minor_status,\n\t\tgss_ctx_id_t context_handle,\n\t\tgss_buffer_t input_message_buffer,\n\t\tgss_buffer_t output_message_buffer,\n\t\tint *conf_state,\n\t\tgss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap(minor_status,\n\t\t\tcontext_handle,\n\t\t\tinput_message_buffer,\n\t\t\toutput_message_buffer,\n\t\t\tconf_state,\n\t\t\tqop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "int bson_check_string( bson *b, const char *string,\n                       const int length ) {\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );\n}", "target": 1}
{"code": "void test_refs_revparse__parses_at_head(void)\n{\n\ttest_id(\"HEAD\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@{0}\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n\ttest_id(\"@\", \"a65fedf39aefe402d3bb6e24df4d4f5fe4547750\", NULL, GIT_REVSPEC_SINGLE);\n}", "target": 0}
{"code": "static void parse_version(pj_scanner *scanner, \n                          volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINVER;\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    if (*(scanner->curptr+2) != '0') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n    pj_scan_skip_line(scanner);\n}", "target": 1}
{"code": "void Huff_Compress(msg_t *mbuf, int offset) {\n\tint\t\t\ti, ch, size;\n\tbyte\t\tseq[65536];\n\tbyte*\t\tbuffer;\n\thuff_t\t\thuff;\n\tsize = mbuf->cursize - offset;\n\tbuffer = mbuf->data+ + offset;\n\tif (size<=0) {\n\t\treturn;\n\t}\n\tCom_Memset(&huff, 0, sizeof(huff_t));\n\thuff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]);\n\thuff.tree->symbol = NYT;\n\thuff.tree->weight = 0;\n\thuff.lhead->next = huff.lhead->prev = NULL;\n\thuff.tree->parent = huff.tree->left = huff.tree->right = NULL;\n\tseq[0] = (size>>8);\n\tseq[1] = size&0xff;\n\tbloc = 16;\n\tfor (i=0; i<size; i++ ) {\n\t\tch = buffer[i];\n\t\tHuff_transmit(&huff, ch, seq);\t\t\t\t\t\t\n\t\tHuff_addRef(&huff, (byte)ch);\t\t\t\t\t\t\t\t\n\t}\n\tbloc += 8;\t\t\t\t\t\t\t\t\t\t\t\t\n\tmbuf->cursize = (bloc>>3) + offset;\n\tCom_Memcpy(mbuf->data+offset, seq, (bloc>>3));\n}", "target": 1}
{"code": "void __init xen_init_IRQ(void)\n{\n\tint ret = -EINVAL;\n\tevtchn_port_t evtchn;\n\tif (fifo_events)\n\t\tret = xen_evtchn_fifo_init();\n\tif (ret < 0)\n\t\txen_evtchn_2l_init();\n\txen_cpu_init_eoi(smp_processor_id());\n\tcpuhp_setup_state_nocalls(CPUHP_XEN_EVTCHN_PREPARE,\n\t\t\t\t  \"xen/evtchn:prepare\",\n\t\t\t\t  xen_evtchn_cpu_prepare, xen_evtchn_cpu_dead);\n\tevtchn_to_irq = kcalloc(EVTCHN_ROW(xen_evtchn_max_channels()),\n\t\t\t\tsizeof(*evtchn_to_irq), GFP_KERNEL);\n\tBUG_ON(!evtchn_to_irq);\n\tfor (evtchn = 0; evtchn < xen_evtchn_nr_channels(); evtchn++)\n\t\tmask_evtchn(evtchn);\n\tpirq_needs_eoi = pirq_needs_eoi_flag;\n#ifdef CONFIG_X86\n\tif (xen_pv_domain()) {\n\t\tif (xen_initial_domain())\n\t\t\tpci_xen_initial_domain();\n\t}\n\tif (xen_feature(XENFEAT_hvm_callback_vector)) {\n\t\txen_setup_callback_vector();\n\t\txen_alloc_callback_vector();\n\t}\n\tif (xen_hvm_domain()) {\n\t\tnative_init_IRQ();\n\t\tpci_xen_hvm_init();\n\t} else {\n\t\tint rc;\n\t\tstruct physdev_pirq_eoi_gmfn eoi_gmfn;\n\t\tpirq_eoi_map = (void *)__get_free_page(GFP_KERNEL|__GFP_ZERO);\n\t\teoi_gmfn.gmfn = virt_to_gfn(pirq_eoi_map);\n\t\trc = HYPERVISOR_physdev_op(PHYSDEVOP_pirq_eoi_gmfn_v2, &eoi_gmfn);\n\t\tif (rc != 0) {\n\t\t\tfree_page((unsigned long) pirq_eoi_map);\n\t\t\tpirq_eoi_map = NULL;\n\t\t} else\n\t\t\tpirq_needs_eoi = pirq_check_eoi_map;\n\t}\n#endif\n}", "target": 0}
{"code": "void UTFstring::UpdateFromUTF8()\n{\n  delete [] _Data;\n  size_t i;\n  for (_Length=0, i=0; i<UTF8string.length(); _Length++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80)\n      i++;\n    else if ((lead >> 5) == 0x6)\n      i += 2;\n    else if ((lead >> 4) == 0xe)\n      i += 3;\n    else if ((lead >> 3) == 0x1e)\n      i += 4;\n    else\n      break;\n  }\n  _Data = new wchar_t[_Length+1];\n  size_t j;\n  for (j=0, i=0; i<UTF8string.length(); j++) {\n    uint8 lead = static_cast<uint8>(UTF8string[i]);\n    if (lead < 0x80) {\n      _Data[j] = lead;\n      i++;\n    } else if ((lead >> 5) == 0x6) {\n      _Data[j] = ((lead & 0x1F) << 6) + (UTF8string[i+1] & 0x3F);\n      i += 2;\n    } else if ((lead >> 4) == 0xe) {\n      _Data[j] = ((lead & 0x0F) << 12) + ((UTF8string[i+1] & 0x3F) << 6) + (UTF8string[i+2] & 0x3F);\n      i += 3;\n    } else if ((lead >> 3) == 0x1e) {\n      _Data[j] = ((lead & 0x07) << 18) + ((UTF8string[i+1] & 0x3F) << 12) + ((UTF8string[i+2] & 0x3F) << 6) + (UTF8string[i+3] & 0x3F);\n      i += 4;\n    } else\n      break;\n  }\n  _Data[j] = 0;\n}", "target": 1}
{"code": "void ip_options_build(struct sk_buff * skb, struct ip_options * opt,\n\t\t\t    __be32 daddr, struct rtable *rt, int is_frag)\n{\n\tunsigned char *iph = skb_network_header(skb);\n\tmemcpy(&(IPCB(skb)->opt), opt, sizeof(struct ip_options));\n\tmemcpy(iph+sizeof(struct iphdr), opt->__data, opt->optlen);\n\topt = &(IPCB(skb)->opt);\n\tif (opt->srr)\n\t\tmemcpy(iph+opt->srr+iph[opt->srr+1]-4, &daddr, 4);\n\tif (!is_frag) {\n\t\tif (opt->rr_needaddr)\n\t\t\tip_rt_get_source(iph+opt->rr+iph[opt->rr+2]-5, rt);\n\t\tif (opt->ts_needaddr)\n\t\t\tip_rt_get_source(iph+opt->ts+iph[opt->ts+2]-9, rt);\n\t\tif (opt->ts_needtime) {\n\t\t\tstruct timespec tv;\n\t\t\t__be32 midtime;\n\t\t\tgetnstimeofday(&tv);\n\t\t\tmidtime = htonl((tv.tv_sec % 86400) * MSEC_PER_SEC + tv.tv_nsec / NSEC_PER_MSEC);\n\t\t\tmemcpy(iph+opt->ts+iph[opt->ts+2]-5, &midtime, 4);\n\t\t}\n\t\treturn;\n\t}\n\tif (opt->rr) {\n\t\tmemset(iph+opt->rr, IPOPT_NOP, iph[opt->rr+1]);\n\t\topt->rr = 0;\n\t\topt->rr_needaddr = 0;\n\t}\n\tif (opt->ts) {\n\t\tmemset(iph+opt->ts, IPOPT_NOP, iph[opt->ts+1]);\n\t\topt->ts = 0;\n\t\topt->ts_needaddr = opt->ts_needtime = 0;\n\t}\n}", "target": 1}
{"code": "    const std::unordered_map<std::string, std::string> &getParameters() const\n    {\n        return parameters();\n    }", "target": 1}
{"code": "static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\treturn skb->len;\n}", "target": 1}
{"code": "static uint32_t mp_clzl(unsigned long x) {\n    unsigned long lz = 0;\n    return _BitScanReverse(&lz, x) ? (sizeof(x) * 8 - 1) - lz : 0;\n}", "target": 0}
{"code": "void SetTransferMatrix(double x11,double x12,double x21,double x22,double x,double y)\n{\n    if ( ( fabs(x11-1.) > 0.001 ) || ( fabs(x22-1.) > 0.001 )\n         || ( fabs(x12) > 0.001 ) || ( fabs(x21) > 0.001 )\n         || ( fabs(x) > 0.001 ) || ( fabs(y) > 0.001 ) ) {\n        outpos +=\n        sprintf(outpos,\"%12.3f %12.3f %12.3f %12.3f %12.3f %12.3f cm\\n\",x11,x12,x21,x22,x,y);\n    }\n}", "target": 1}
{"code": "Opal::Call::get_remote_party_name () const\n{\n  return remote_party_name;\n}", "target": 0}
{"code": "static void tight_send_compact_size(VncState *vs, size_t len)\n{\n    int lpc = 0;\n    int bytes = 0;\n    char buf[3] = {0, 0, 0};\n    buf[bytes++] = len & 0x7F;\n    if (len > 0x7F) {\n        buf[bytes-1] |= 0x80;\n        buf[bytes++] = (len >> 7) & 0x7F;\n        if (len > 0x3FFF) {\n            buf[bytes-1] |= 0x80;\n            buf[bytes++] = (len >> 14) & 0xFF;\n        }\n    }\n    for (lpc = 0; lpc < bytes; lpc++) {\n        vnc_write_u8(vs, buf[lpc]);\n    }\n}", "target": 0}
{"code": "inline static jas_int_asr(int x, int n)\n{\n\tassert(n >= 0);\n\treturn x >> n;\n}", "target": 0}
{"code": "MagickExport void RegisterStaticModules(void)\n{\n  PolicyRights\n    rights;\n  size_t\n    extent;\n  ssize_t\n    i;\n  rights=ReadPolicyRights|WritePolicyRights;\n  extent=sizeof(MagickModules)/sizeof(MagickModules[0]);\n  for (i=0; i < (ssize_t) extent; i++)\n  {\n    if (MagickModules[i].registered == MagickFalse)\n      {\n        if (IsRightsAuthorized(ModulePolicyDomain,rights,\n              MagickModules[i].module) == MagickFalse)\n          continue;\n        (void) (MagickModules[i].register_module)();\n        MagickModules[i].registered=MagickTrue;\n      }\n  }\n}", "target": 0}
{"code": "static void _out_result(conn_t out, nad_t nad) {\n    int attr;\n    jid_t from, to;\n    char *rkey;\n    int rkeylen;\n    attr = nad_find_attr(nad, 0, -1, \"from\", NULL);\n    if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid from on db result packet\");\n        nad_free(nad);\n        return;\n    }\n    attr = nad_find_attr(nad, 0, -1, \"to\", NULL);\n    if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {\n        log_debug(ZONE, \"missing or invalid to on db result packet\");\n        jid_free(from);\n        nad_free(nad);\n        return;\n    }\n    rkey = s2s_route_key(NULL, to->domain, from->domain);\n    rkeylen = strlen(rkey);\n    if(nad_find_attr(nad, 0, -1, \"type\", \"valid\") >= 0) {\n        log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s\", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? \", TLS negotiated\" : \"\", out->s->compressed ? \", ZLIB compression enabled\" : \"\");\n        xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    \n        log_debug(ZONE, \"%s valid, flushing queue\", rkey);\n        out_flush_route_queue(out->s2s, rkey, rkeylen);\n        free(rkey);\n        jid_free(from);\n        jid_free(to);\n        nad_free(nad);\n        return;\n    }\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] outgoing route '%s' is now invalid\", out->fd->fd, out->ip, out->port, rkey);\n    log_write(out->s2s->log, LOG_NOTICE, \"[%d] [%s, port=%d] closing connection\", out->fd->fd, out->ip, out->port);\n    sx_error(out->s, stream_err_INVALID_ID, \"dialback negotiation failed\");\n    sx_close(out->s);\n    out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);\n    free(rkey);\n    jid_free(from);\n    jid_free(to);\n    nad_free(nad);\n}", "target": 1}
{"code": "parse_CT_CLEAR(char *arg OVS_UNUSED, const struct ofpact_parse_params *pp)\n{\n    ofpact_put_CT_CLEAR(pp->ofpacts);\n    return NULL;\n}", "target": 0}
{"code": "static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter)\n{\n\tdouble width_d;\n\tdouble scale_f_d = 1.0;\n\tconst double filter_width_d = DEFAULT_BOX_RADIUS;\n\tint windows_size;\n\tunsigned int u;\n\tLineContribType *res;\n\tif (scale_d < 1.0) {\n\t\twidth_d = filter_width_d / scale_d;\n\t\tscale_f_d = scale_d;\n\t}  else {\n\t\twidth_d= filter_width_d;\n\t}\n\twindows_size = 2 * (int)ceil(width_d) + 1;\n\tres = _gdContributionsAlloc(line_size, windows_size);\n\tfor (u = 0; u < line_size; u++) {\n\t\tconst double dCenter = (double)u / scale_d;\n\t\tregister int iLeft = MAX(0, (int)floor (dCenter - width_d));\n\t\tint iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n\t\tdouble dTotalWeight = 0.0;\n\t\tint iSrc;\n\t\tres->ContribRow[u].Left = iLeft;\n\t\tres->ContribRow[u].Right = iRight;\n\t\tif (iRight - iLeft + 1 > windows_size)  {\n\t\t\tif (iLeft < ((int)src_size - 1 / 2))  {\n\t\t\t\tiLeft++;\n\t\t\t} else {\n\t\t\t\tiRight--;\n\t\t\t}\n\t\t}\n\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\tdTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n\t\t}\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dTotalWeight > 0.0) {\n\t\t\tfor (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n\t\t\t\tres->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}", "target": 1}
{"code": "sread(int fd, void *buf, size_t n, int canbepipe)\n{\n\tssize_t rv;\n#ifdef FIONREAD\n\tint t = 0;\n#endif\n\tsize_t rn = n;\n\tif (fd == STDIN_FILENO)\n\t\tgoto nocheck;\n#ifdef FIONREAD\n\tif (canbepipe && (ioctl(fd, FIONREAD, &t) == -1 || t == 0)) {\n#ifdef FD_ZERO\n\t\tssize_t cnt;\n\t\tfor (cnt = 0;; cnt++) {\n\t\t\tfd_set check;\n\t\t\tstruct timeval tout = {0, 100 * 1000};\n\t\t\tint selrv;\n\t\t\tFD_ZERO(&check);\n\t\t\tFD_SET(fd, &check);\n\t\t\tselrv = select(fd + 1, &check, NULL, NULL, &tout);\n\t\t\tif (selrv == -1) {\n\t\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\t\tcontinue;\n\t\t\t} else if (selrv == 0 && cnt >= 5) {\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n#endif\n\t\t(void)ioctl(fd, FIONREAD, &t);\n\t}\n\tif (t > 0 && (size_t)t < n) {\n\t\tn = t;\n\t\trn = n;\n\t}\n#endif\nnocheck:\n\tdo\n\t\tswitch ((rv = FINFO_READ_FUNC(fd, buf, n))) {\n\t\tcase -1:\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn -1;\n\t\tcase 0:\n\t\t\treturn rn - n;\n\t\tdefault:\n\t\t\tn -= rv;\n\t\t\tbuf = ((char *)buf) + rv;\n\t\t\tbreak;\n\t\t}\n\twhile (n > 0);\n\treturn rn;\n}", "target": 0}
{"code": "static void lwp_read(FILE *fin, std::string &buf) {\n  size_t len;\n  fread(&len, sizeof(len), 1, fin);\n  char *buffer = (char *)malloc(len + 1);\n  fread(buffer, sizeof(*buffer), len, fin);\n  buffer[len] = '\\0';\n  buf = std::string(buffer);\n  free(buffer);\n}", "target": 0}
{"code": "u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)\n{\n\tstruct keydata *keyptr = get_keyptr();\n\tu32 hash[4];\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = (__force u32)dport ^ keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}", "target": 1}
{"code": "GetIoStats(Mgr::IoActionData& stats)\n{\n    int i;\n    stats.http_reads = IOStats.Http.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.http_read_hist[i] = IOStats.Http.read_hist[i];\n    }\n    stats.ftp_reads = IOStats.Ftp.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.ftp_read_hist[i] = IOStats.Ftp.read_hist[i];\n    }\n    stats.gopher_reads = IOStats.Gopher.reads;\n    for (i = 0; i < IoStats::histSize; ++i) {\n        stats.gopher_read_hist[i] = IOStats.Gopher.read_hist[i];\n    }\n}", "target": 1}
{"code": "void PDPServer::notifyAboveRemoteEndpoints(\n        const ParticipantProxyData& pdata)\n{\n    static_cast<void>(pdata);\n#if HAVE_SECURITY\n    match_reliable_pdp_endpoints(pdata);\n#endif \n}", "target": 1}
{"code": "folly::Optional<TLSMessage> EncryptedReadRecordLayer::read(\n    folly::IOBufQueue& buf) {\n  auto decryptedBuf = getDecryptedBuf(buf);\n  if (!decryptedBuf) {\n    return folly::none;\n  }\n  TLSMessage msg{};\n  auto currentBuf = decryptedBuf->get();\n  bool nonZeroFound = false;\n  do {\n    currentBuf = currentBuf->prev();\n    size_t i = currentBuf->length();\n    while (i > 0 && !nonZeroFound) {\n      nonZeroFound = (currentBuf->data()[i - 1] != 0);\n      i--;\n    }\n    if (nonZeroFound) {\n      msg.type = static_cast<ContentType>(currentBuf->data()[i]);\n    }\n    currentBuf->trimEnd(currentBuf->length() - i);\n  } while (!nonZeroFound && currentBuf != decryptedBuf->get());\n  if (!nonZeroFound) {\n    throw std::runtime_error(\"No content type found\");\n  }\n  msg.fragment = std::move(*decryptedBuf);\n  switch (msg.type) {\n    case ContentType::handshake:\n    case ContentType::alert:\n    case ContentType::application_data:\n      break;\n    default:\n      throw std::runtime_error(folly::to<std::string>(\n          \"received encrypted content type \",\n          static_cast<ContentTypeType>(msg.type)));\n  }\n  if (!msg.fragment || msg.fragment->empty()) {\n    if (msg.type == ContentType::application_data) {\n      msg.fragment = folly::IOBuf::create(0);\n    } else {\n      throw std::runtime_error(\"received empty fragment\");\n    }\n  }\n  return msg;\n}", "target": 0}
{"code": "fst_get_iface(struct fst_card_info *card, struct fst_port_info *port,\n\t      struct ifreq *ifr)\n{\n\tsync_serial_settings sync;\n\tint i;\n\tswitch (port->hwif) {\n\tcase E1:\n\t\tifr->ifr_settings.type = IF_IFACE_E1;\n\t\tbreak;\n\tcase T1:\n\t\tifr->ifr_settings.type = IF_IFACE_T1;\n\t\tbreak;\n\tcase V35:\n\t\tifr->ifr_settings.type = IF_IFACE_V35;\n\t\tbreak;\n\tcase V24:\n\t\tifr->ifr_settings.type = IF_IFACE_V24;\n\t\tbreak;\n\tcase X21D:\n\t\tifr->ifr_settings.type = IF_IFACE_X21D;\n\t\tbreak;\n\tcase X21:\n\tdefault:\n\t\tifr->ifr_settings.type = IF_IFACE_X21;\n\t\tbreak;\n\t}\n\tif (ifr->ifr_settings.size == 0) {\n\t\treturn 0;\t\n\t}\n\tif (ifr->ifr_settings.size < sizeof (sync)) {\n\t\treturn -ENOMEM;\n\t}\n\ti = port->index;\n\tmemset(&sync, 0, sizeof(sync));\n\tsync.clock_rate = FST_RDL(card, portConfig[i].lineSpeed);\n\tsync.clock_type = FST_RDB(card, portConfig[i].internalClock) ==\n\t    INTCLK ? CLOCK_INT : CLOCK_EXT;\n\tsync.loopback = 0;\n\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.sync, &sync, sizeof (sync))) {\n\t\treturn -EFAULT;\n\t}\n\tifr->ifr_settings.size = sizeof (sync);\n\treturn 0;\n}", "target": 0}
{"code": "void handle_get_plugin_schema(nng_aio *aio)\n{\n    size_t      len                        = 0;\n    char *      schema_path                = NULL;\n    char        param[NEU_PLUGIN_NAME_LEN] = { 0 };\n    const char *schema_name                = param;\n    NEU_VALIDATE_JWT(aio);\n    int rv = neu_http_get_param_str(aio, \"schema_name\", param, sizeof(param));\n    if (-2 == rv) {\n        rv = neu_http_get_param_str(aio, \"plugin_name\", param, sizeof(param));\n        schema_name = plugin_name_to_schema_name(param);\n    }\n    if (rv < 0) {\n        neu_http_bad_request(aio, \"{\\\"error\\\": 1002}\");\n        return;\n    }\n    if (0 > neu_asprintf(&schema_path, \"%s/schema/%s.json\", g_plugin_dir,\n                         schema_name)) {\n        NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n            neu_http_response(aio, error_code.error, result_error);\n        });\n        return;\n    }\n    char *buf = NULL;\n    buf = file_string_read(&len, schema_path);\n    if (NULL == buf) {\n        free(schema_path);\n        if (0 > neu_asprintf(&schema_path, \"%s/custom/schema/%s.json\",\n                             g_plugin_dir, schema_name)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n    }\n    if (NULL == buf) {\n        free(schema_path);\n        if (0 > neu_asprintf(&schema_path, \"%s/system/schema/%s.json\",\n                             g_plugin_dir, schema_name)) {\n            NEU_JSON_RESPONSE_ERROR(NEU_ERR_EINTERNAL, {\n                neu_http_response(aio, error_code.error, result_error);\n            });\n            return;\n        }\n        buf = file_string_read(&len, schema_path);\n    }\n    if (NULL == buf) {\n        nlog_info(\"open %s error: %d\", schema_path, errno);\n        neu_http_not_found(aio, \"{\\\"status\\\": \\\"error\\\"}\");\n        free(schema_path);\n        return;\n    }\n    neu_http_ok(aio, buf);\n    free(buf);\n    free(schema_path);\n}", "target": 1}
{"code": "int xstateregs_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tstruct fpu *fpu = &target->thread.fpu;\n\tstruct xregs_state *xsave;\n\tint ret;\n\tif (!boot_cpu_has(X86_FEATURE_XSAVE))\n\t\treturn -ENODEV;\n\tif ((pos != 0) || (count < fpu_user_xstate_size))\n\t\treturn -EFAULT;\n\txsave = &fpu->state.xsave;\n\tfpu__activate_fpstate_write(fpu);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES)) {\n\t\tif (kbuf)\n\t\t\tret = copy_kernel_to_xstate(xsave, kbuf);\n\t\telse\n\t\t\tret = copy_user_to_xstate(xsave, ubuf);\n\t} else {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, xsave, 0, -1);\n\t\tif (!ret && xsave->header.xcomp_bv)\n\t\t\tret = -EINVAL;\n\t}\n\tif (ret)\n\t\tfpstate_init(&fpu->state);\n\txsave->i387.mxcsr &= mxcsr_feature_mask;\n\txsave->header.xfeatures &= xfeatures_mask;\n\tmemset(&xsave->header.reserved, 0, 48);\n\treturn ret;\n}", "target": 0}
{"code": "DRIVE_FILE* drive_file_new(const WCHAR* base_path, const WCHAR* path, UINT32 PathLength, UINT32 id,\n                           UINT32 DesiredAccess, UINT32 CreateDisposition, UINT32 CreateOptions,\n                           UINT32 FileAttributes, UINT32 SharedAccess)\n{\n\tDRIVE_FILE* file;\n\tif (!base_path || (!path && (PathLength > 0)))\n\t\treturn NULL;\n\tfile = (DRIVE_FILE*)calloc(1, sizeof(DRIVE_FILE));\n\tif (!file)\n\t{\n\t\tWLog_ERR(TAG, \"calloc failed!\");\n\t\treturn NULL;\n\t}\n\tfile->file_handle = INVALID_HANDLE_VALUE;\n\tfile->find_handle = INVALID_HANDLE_VALUE;\n\tfile->id = id;\n\tfile->basepath = base_path;\n\tfile->FileAttributes = FileAttributes;\n\tfile->DesiredAccess = DesiredAccess;\n\tfile->CreateDisposition = CreateDisposition;\n\tfile->CreateOptions = CreateOptions;\n\tfile->SharedAccess = SharedAccess;\n\tdrive_file_set_fullpath(file, drive_file_combine_fullpath(base_path, path, PathLength));\n\tif (!drive_file_init(file))\n\t{\n\t\tDWORD lastError = GetLastError();\n\t\tdrive_file_free(file);\n\t\tSetLastError(lastError);\n\t\treturn NULL;\n\t}\n\treturn file;\n}", "target": 1}
{"code": "compat_mpt_command(struct file *filp, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tstruct mpt_ioctl_command32 karg32;\n\tstruct mpt_ioctl_command32 __user *uarg = (struct mpt_ioctl_command32 __user *) arg;\n\tstruct mpt_ioctl_command karg;\n\tMPT_ADAPTER *iocp = NULL;\n\tint iocnum, iocnumX;\n\tint nonblock = (filp->f_flags & O_NONBLOCK);\n\tint ret;\n\tif (copy_from_user(&karg32, (char __user *)arg, sizeof(karg32)))\n\t\treturn -EFAULT;\n\tiocnumX = karg32.hdr.iocnum & 0xFF;\n\tif (((iocnum = mpt_verify_adapter(iocnumX, &iocp)) < 0) ||\n\t    (iocp == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"::compat_mpt_command @%d - ioc%d not found!\\n\",\n\t\t\t__LINE__, iocnumX);\n\t\treturn -ENODEV;\n\t}\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\tdctlprintk(iocp, printk(MYIOC_s_DEBUG_FMT \"compat_mpt_command() called\\n\",\n\t    iocp->name));\n\tkarg.hdr.iocnum = karg32.hdr.iocnum;\n\tkarg.hdr.port = karg32.hdr.port;\n\tkarg.timeout = karg32.timeout;\n\tkarg.maxReplyBytes = karg32.maxReplyBytes;\n\tkarg.dataInSize = karg32.dataInSize;\n\tkarg.dataOutSize = karg32.dataOutSize;\n\tkarg.maxSenseBytes = karg32.maxSenseBytes;\n\tkarg.dataSgeOffset = karg32.dataSgeOffset;\n\tkarg.replyFrameBufPtr = (char __user *)(unsigned long)karg32.replyFrameBufPtr;\n\tkarg.dataInBufPtr = (char __user *)(unsigned long)karg32.dataInBufPtr;\n\tkarg.dataOutBufPtr = (char __user *)(unsigned long)karg32.dataOutBufPtr;\n\tkarg.senseDataPtr = (char __user *)(unsigned long)karg32.senseDataPtr;\n\tret = mptctl_do_mpt_command (karg, &uarg->MF);\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\treturn ret;\n}", "target": 1}
{"code": "    void Encode(Key, const Value& value) {\n      AddToSummary(Key::key(), Key::Encode(value).size());\n    }", "target": 1}
{"code": "spaddr_print_ip(netdissect_options *ndo,\n\t        const struct arp_pkthdr *ap, u_short pro)\n{\n\tif (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)\n\t\tND_PRINT((ndo, \"<wrong proto type>\"));\n\telse if (PROTO_LEN(ap) != 4)\n\t\tND_PRINT((ndo, \"<wrong len>\"));\n\telse\n\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, SPA(ap))));\n}", "target": 0}
{"code": "R_API st64 r_buf_read_at(RBuffer *b, ut64 addr, ut8 *buf, ut64 len) {\n\tr_return_val_if_fail (b && buf, -1);\n\tst64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);\n\tst64 r = r_buf_seek (b, addr, R_BUF_SET);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tr = r_buf_read (b, buf, len);\n\tr_buf_seek (b, o_addr, R_BUF_SET);\n\treturn r;\n}", "target": 1}
{"code": "int kvm_get_dirty_log(struct kvm *kvm,\n\t\t\tstruct kvm_dirty_log *log, int *is_dirty)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint r, i, as_id, id;\n\tunsigned long n;\n\tunsigned long any = 0;\n\tr = -EINVAL;\n\tas_id = log->slot >> 16;\n\tid = (u16)log->slot;\n\tif (as_id >= KVM_ADDRESS_SPACE_NUM || id >= KVM_USER_MEM_SLOTS)\n\t\tgoto out;\n\tslots = __kvm_memslots(kvm, as_id);\n\tmemslot = id_to_memslot(slots, id);\n\tr = -ENOENT;\n\tif (!memslot->dirty_bitmap)\n\t\tgoto out;\n\tn = kvm_dirty_bitmap_bytes(memslot);\n\tfor (i = 0; !any && i < n/sizeof(long); ++i)\n\t\tany = memslot->dirty_bitmap[i];\n\tr = -EFAULT;\n\tif (copy_to_user(log->dirty_bitmap, memslot->dirty_bitmap, n))\n\t\tgoto out;\n\tif (any)\n\t\t*is_dirty = 1;\n\tr = 0;\nout:\n\treturn r;\n}", "target": 0}
{"code": "static int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages, bool is_readahead)\n{\n\tstruct bio *bio = NULL;\n\tsector_t last_block_in_bio = 0;\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_map_blocks map;\n\tint ret = 0;\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\tmap.m_may_create = false;\n\tfor (; nr_pages; nr_pages--) {\n\t\tif (pages) {\n\t\t\tpage = list_last_entry(pages, struct page, lru);\n\t\t\tprefetchw(&page->flags);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index,\n\t\t\t\t\t\t  readahead_gfp_mask(mapping)))\n\t\t\t\tgoto next_page;\n\t\t}\n\t\tret = f2fs_read_single_page(inode, page, nr_pages, &map, &bio,\n\t\t\t\t\t&last_block_in_bio, is_readahead);\n\t\tif (ret) {\n\t\t\tSetPageError(page);\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tunlock_page(page);\n\t\t}\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t}\n\tBUG_ON(pages && !list_empty(pages));\n\tif (bio)\n\t\t__submit_bio(F2FS_I_SB(inode), bio, DATA);\n\treturn pages ? 0 : ret;\n}", "target": 1}
{"code": "inline TfLiteStatus ValidateTensorIndexingSafe(const TfLiteContext* context,\n                                               int index, int max_size,\n                                               const int* tensor_indices,\n                                               int* tensor_index) {\n  if (index < 0 || index >= max_size) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Invalid tensor index %d (not in [0, %d))\\n\", index,\n                       max_size);\n    return kTfLiteError;\n  }\n  if (tensor_indices[index] == kTfLiteOptionalTensor) {\n    TF_LITE_KERNEL_LOG(const_cast<TfLiteContext*>(context),\n                       \"Tensor at index %d was optional but was expected\\n\",\n                       index);\n    return kTfLiteError;\n  }\n  *tensor_index = tensor_indices[index];\n  return kTfLiteOk;\n}", "target": 0}
{"code": "int cil_build_ast(struct cil_db *db, struct cil_tree_node *parse_tree, struct cil_tree_node *ast)\n{\n\tint rc = SEPOL_ERR;\n\tstruct cil_args_build extra_args;\n\tif (db == NULL || parse_tree == NULL || ast == NULL) {\n\t\tgoto exit;\n\t}\n\textra_args.ast = ast;\n\textra_args.db = db;\n\textra_args.tunif = NULL;\n\textra_args.in = NULL;\n\textra_args.macro = NULL;\n\textra_args.optional = NULL;\n\textra_args.boolif = NULL;\n\trc = cil_tree_walk(parse_tree, __cil_build_ast_node_helper, __cil_build_ast_first_child_helper, __cil_build_ast_last_child_helper, &extra_args);\n\tif (rc != SEPOL_OK) {\n\t\tgoto exit;\n\t}\n\treturn SEPOL_OK;\nexit:\n\treturn rc;\n}", "target": 0}
{"code": "mptctl_eventquery (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventquery __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventquery\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventquery() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventquery called.\\n\",\n\t    ioc->name));\n\tkarg.eventEntries = MPTCTL_EVENT_LOG_SIZE;\n\tkarg.eventTypes = ioc->eventTypes;\n\tif (copy_to_user((char __user *)arg, &karg, sizeof(struct mpt_ioctl_eventquery))) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_eventquery - \"\n\t\t\t\"Unable to write out mpt_ioctl_eventquery struct @ %p\\n\",\n\t\t\tioc->name, __FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void save_client_addr(struct ip_addr *client_ip, uint8_t *hwaddr)\n{\n\tuint8_t d = (uint8_t)ip4_addr4(client_ip);\n\txSemaphoreTake(dhcps_ip_table_semaphore, portMAX_DELAY);\n\tmemcpy(ip_table.client_mac[d], hwaddr, 6); \n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n%s: ip %d.%d.%d.%d, hwaddr %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\", __func__,\n\t\tip4_addr1(client_ip), ip4_addr2(client_ip), ip4_addr3(client_ip), ip4_addr4(client_ip),\n\t\thwaddr[0], hwaddr[1], hwaddr[2], hwaddr[3], hwaddr[4], hwaddr[5]);\n#endif\t\n\txSemaphoreGive(dhcps_ip_table_semaphore);\n}", "target": 1}
{"code": "std::string decodeBase64(\n    const std::string& encoded) {\n  if (encoded.size() == 0) {\n    return \"\";\n  }\n  using namespace boost::archive::iterators;\n  using b64it =\n    transform_width<binary_from_base64<std::string::const_iterator>, 8, 6>;\n  std::string decoded = std::string(b64it(std::begin(encoded)),\n                                    b64it(std::end(encoded)));\n  uint32_t numPadding = std::count(encoded.begin(), encoded.end(), '=');\n  decoded.erase(decoded.end() - numPadding, decoded.end());\n  return decoded;\n}", "target": 1}
{"code": "static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,\n\tint sockaddr_len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sockaddr_pppox *sp = (struct sockaddr_pppox *) uservaddr;\n\tstruct pppox_sock *po = pppox_sk(sk);\n\tstruct pptp_opt *opt = &po->proto.pptp;\n\tint error = 0;\n\tif (sockaddr_len < sizeof(struct sockaddr_pppox))\n\t\treturn -EINVAL;\n\tlock_sock(sk);\n\topt->src_addr = sp->sa_addr.pptp;\n\tif (add_chan(po))\n\t\terror = -EBUSY;\n\trelease_sock(sk);\n\treturn error;\n}", "target": 0}
{"code": "static UINT printer_process_irp_write(PRINTER_DEVICE* printer_dev, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\trdpPrintJob* printjob = NULL;\n\tUINT error = CHANNEL_RC_OK;\n\tStream_Read_UINT32(irp->input, Length);\n\tStream_Read_UINT64(irp->input, Offset);\n\tStream_Seek(irp->input, 20); \n\tif (printer_dev->printer)\n\t\tprintjob = printer_dev->printer->FindPrintJob(printer_dev->printer, irp->FileId);\n\tif (!printjob)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tLength = 0;\n\t}\n\telse\n\t{\n\t\terror = printjob->Write(printjob, Stream_Pointer(irp->input), Length);\n\t}\n\tif (error)\n\t{\n\t\tWLog_ERR(TAG, \"printjob->Write failed with error %\" PRIu32 \"!\", error);\n\t\treturn error;\n\t}\n\tStream_Write_UINT32(irp->output, Length);\n\tStream_Write_UINT8(irp->output, 0); \n\treturn irp->Complete(irp);\n}", "target": 1}
{"code": "  Status ValidateInputsGenerateOutputs(\n      OpKernelContext* ctx, const Tensor** inputs, const Tensor** seq_len,\n      Tensor** log_prob, OpOutputList* decoded_indices,\n      OpOutputList* decoded_values, OpOutputList* decoded_shape) const {\n    Status status = ctx->input(\"inputs\", inputs);\n    if (!status.ok()) return status;\n    status = ctx->input(\"sequence_length\", seq_len);\n    if (!status.ok()) return status;\n    const TensorShape& inputs_shape = (*inputs)->shape();\n    if (inputs_shape.dims() != 3) {\n      return errors::InvalidArgument(\"inputs is not a 3-Tensor\");\n    }\n    if (inputs_shape.num_elements() == 0) {\n      return errors::InvalidArgument(\"inputs must not be empty\");\n    }\n    const int64 max_time = inputs_shape.dim_size(0);\n    const int64 batch_size = inputs_shape.dim_size(1);\n    if (max_time == 0) {\n      return errors::InvalidArgument(\"max_time is 0\");\n    }\n    if (!TensorShapeUtils::IsVector((*seq_len)->shape())) {\n      return errors::InvalidArgument(\"sequence_length is not a vector\");\n    }\n    if (!(batch_size == (*seq_len)->dim_size(0))) {\n      return errors::FailedPrecondition(\n          \"len(sequence_length) != batch_size.  \",\n          \"len(sequence_length):  \", (*seq_len)->dim_size(0),\n          \" batch_size: \", batch_size);\n    }\n    auto seq_len_t = (*seq_len)->vec<int32>();\n    for (int b = 0; b < batch_size; ++b) {\n      if (!(seq_len_t(b) <= max_time)) {\n        return errors::FailedPrecondition(\"sequence_length(\", b,\n                                          \") <= \", max_time);\n      }\n    }\n    Status s = ctx->allocate_output(\n        \"log_probability\", TensorShape({batch_size, top_paths_}), log_prob);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_indices\", decoded_indices);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_values\", decoded_values);\n    if (!s.ok()) return s;\n    s = ctx->output_list(\"decoded_shape\", decoded_shape);\n    if (!s.ok()) return s;\n    return Status::OK();\n  }", "target": 0}
{"code": "int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tchar debug_buff[512];\n\tint remaining = sizeof(cmd) - 1;\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);\n\tdebug_print(debug_buff);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\tdebug_print(debug_buff);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_PERMISSION_DENIED;\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifndef DEBUG\n\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\t\tdebug_print(debug_buff);\n#endif\n\t}\n\tfree(inputline);\n\tg_free(proxy_auth);\n\treturn 0;\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, CantUseHashedIndexToProvideSortWithIndexablePred) {\n    addIndex(BSON(\"x\"\n                  << \"hashed\"));\n    runQuerySortProj(BSON(\"x\" << BSON(\"$in\" << BSON_ARRAY(0 << 1))), BSON(\"x\" << 1), BSONObj());\n    ASSERT_EQUALS(getNumSolutions(), 2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {x: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{fetch: {node: \"\n        \"{ixscan: {pattern: {x: 'hashed'}}}}}}}}}\");\n    assertSolutionExists(\n        \"{sort: {pattern: {x: 1}, limit: 0, node: {sortKeyGen: {node:\"\n        \"{cscan: {dir: 1, filter: {x: {$in: [0, 1]}}}}}}}}\");\n}", "target": 0}
{"code": "pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,\n\t\t      int atomic)\n{\n\tunsigned long copy;\n\twhile (len > 0) {\n\t\twhile (!iov->iov_len)\n\t\t\tiov++;\n\t\tcopy = min_t(unsigned long, len, iov->iov_len);\n\t\tif (atomic) {\n\t\t\tif (__copy_to_user_inatomic(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (copy_to_user(iov->iov_base, from, copy))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t\tfrom += copy;\n\t\tlen -= copy;\n\t\tiov->iov_base += copy;\n\t\tiov->iov_len -= copy;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static void __exit exit_ext2_fs(void)\n{\n\tunregister_filesystem(&ext2_fs_type);\n\tdestroy_inodecache();\n\texit_ext2_xattr();\n}", "target": 1}
{"code": "static void ene_remove(struct pnp_dev *pnp_dev)\n{\n\tstruct ene_device *dev = pnp_get_drvdata(pnp_dev);\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->hw_lock, flags);\n\tene_rx_disable(dev);\n\tene_rx_restore_hw_buffer(dev);\n\tspin_unlock_irqrestore(&dev->hw_lock, flags);\n\tfree_irq(dev->irq, dev);\n\trelease_region(dev->hw_io, ENE_IO_SIZE);\n\trc_unregister_device(dev->rdev);\n\tkfree(dev);\n}", "target": 1}
{"code": "print_perm_line (int        idx,\n                 GPtrArray *items,\n                 int        cols)\n{\n  g_autoptr(GString) res = g_string_new (NULL);\n  int i;\n  g_string_append_printf (res, \"    [%d] %s\", idx, (char *) items->pdata[0]);\n  for (i = 1; i < items->len; i++)\n    {\n      char *p;\n      int len;\n      p = strrchr (res->str, '\\n');\n      if (!p)\n        p = res->str;\n      len = (res->str + strlen (res->str)) - p;\n      if (len + strlen ((char *) items->pdata[i]) + 2 >= cols)\n        g_string_append_printf (res, \",\\n        %s\", (char *) items->pdata[i]);\n      else\n        g_string_append_printf (res, \", %s\", (char *) items->pdata[i]);\n    }\n  g_print (\"%s\\n\", res->str);\n}", "target": 1}
{"code": "koi8_r_is_mbc_ambiguous(OnigCaseFoldType flag, const UChar** pp,\n\t\t\tconst UChar* end, OnigEncoding enc ARG_UNUSED)\n{\n  int v;\n  const UChar* p = *pp;\n  (*pp)++;\n  v = (EncKOI8_R_CtypeTable[*p] & (BIT_CTYPE_UPPER | BIT_CTYPE_LOWER));\n  return (v != 0 ? TRUE : FALSE);\n}", "target": 0}
{"code": "static bool is_allowed_security_type(const struct nvnc* server, uint8_t type)\n{\n\tfor (int i = 0; i < server->n_security_types; ++i) {\n\t\tif ((uint8_t)server->security_types[i] == type) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 0}
{"code": "optional<ARN> ARN::parse(const string& s, bool wildcards) {\n  static const char str_wild[] = \"arn:([^:]*):([^:]*):([^:]*):([^:]*):([^:]*)\";\n  static const regex rx_wild(str_wild,\n\t\t\t\t    sizeof(str_wild) - 1,\n\t\t\t\t    ECMAScript | optimize);\n  static const char str_no_wild[]\n    = \"arn:([^:*]*):([^:*]*):([^:*]*):([^:*]*):([^:*]*)\";\n  static const regex rx_no_wild(str_no_wild,\n\t\t\t\tsizeof(str_no_wild) - 1,\n\t\t\t\tECMAScript | optimize);\n  smatch match;\n  if ((s == \"*\") && wildcards) {\n    return ARN(Partition::wildcard, Service::wildcard, \"*\", \"*\", \"*\");\n  } else if (regex_match(s, match, wildcards ? rx_wild : rx_no_wild)) {\n    ceph_assert(match.size() == 6);\n    ARN a;\n    {\n      auto p = to_partition(match[1], wildcards);\n      if (!p)\n\treturn none;\n      a.partition = *p;\n    }\n    {\n      auto s = to_service(match[2], wildcards);\n      if (!s) {\n\treturn none;\n      }\n      a.service = *s;\n    }\n    a.region = match[3];\n    a.account = match[4];\n    a.resource = match[5];\n    return a;\n  }\n  return none;\n}", "target": 1}
{"code": "static void f2fs_swap_deactivate(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tclear_inode_flag(inode, FI_PIN_FILE);\n}", "target": 0}
{"code": "AP4_VisualSampleEntry::ReadFields(AP4_ByteStream& stream)\n{\n    AP4_Result result = AP4_SampleEntry::ReadFields(stream);\n    if (result < 0) return result;\n    stream.ReadUI16(m_Predefined1);\n    stream.ReadUI16(m_Reserved2);\n    stream.Read(m_Predefined2, sizeof(m_Predefined2));\n    stream.ReadUI16(m_Width);\n    stream.ReadUI16(m_Height);\n    stream.ReadUI32(m_HorizResolution);\n    stream.ReadUI32(m_VertResolution);\n    stream.ReadUI32(m_Reserved3);\n    stream.ReadUI16(m_FrameCount);\n    char compressor_name[33];\n    compressor_name[32] = 0;\n    stream.Read(compressor_name, 32);\n    int name_length = compressor_name[0];\n    if (name_length < 32) {\n        compressor_name[name_length+1] = 0; \n        m_CompressorName = &compressor_name[1];\n    }\n    stream.ReadUI16(m_Depth);\n    stream.ReadUI16(m_Predefined3);\n    return AP4_SUCCESS;\n}", "target": 1}
{"code": "my_ulonglong STDCALL mysql_insert_id(MYSQL *mysql)\n{\n  return mysql->insert_id;\n}", "target": 0}
{"code": "create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal_3((void *)handle,\n                                            &arg->rec, arg->mask,\n                                            arg->n_ks_tuple,\n                                            arg->ks_tuple,\n                                            arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static int lua_websocket_close(lua_State *L) \n{\n    apr_socket_t *sock;\n    char prelude[2];\n    request_rec *r = ap_lua_check_request_rec(L, 1);\n    sock = ap_get_conn_socket(r->connection);\n    prelude[0] = 0x88; \n    prelude[1] = 0; \n    ap_rwrite(prelude, 2, r);\n    apr_socket_close(sock);\n    r->output_filters = NULL;\n    r->connection->keepalive = AP_CONN_CLOSE;\n    return 0;\n}", "target": 0}
{"code": "MONGO_EXPORT int bson_append_code_w_scope_n( bson *b, const char *name,\n        const char *code, int len, const bson *scope ) {\n    int sl, size;\n    if ( !scope ) return BSON_ERROR;\n    sl = len + 1;\n    size = 4 + 4 + sl + bson_size( scope );\n    if ( bson_append_estart( b, BSON_CODEWSCOPE, name, size ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append32( b, &size );\n    bson_append32( b, &sl );\n    bson_append( b, code, sl );\n    bson_append( b, scope->data, bson_size( scope ) );\n    return BSON_OK;\n}", "target": 1}
{"code": "ldap_pvt_tls_check_hostname( LDAP *ld, void *s, const char *name_in )\n{\n\ttls_session *session = s;\n\tif (ld->ld_options.ldo_tls_require_cert != LDAP_OPT_X_TLS_NEVER &&\n\t    ld->ld_options.ldo_tls_require_cert != LDAP_OPT_X_TLS_ALLOW) {\n\t\tld->ld_errno = tls_imp->ti_session_chkhost( ld, session, name_in );\n\t\tif (ld->ld_errno != LDAP_SUCCESS) {\n\t\t\treturn ld->ld_errno;\n\t\t}\n\t}\n\treturn LDAP_SUCCESS;\n}", "target": 0}
{"code": "void read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\n  decoder_info->width = get_flc(16, stream);\n  decoder_info->height = get_flc(16, stream);\n  decoder_info->log2_sb_size = get_flc(3, stream);\n  decoder_info->log2_sb_size = clip(decoder_info->log2_sb_size, log2i(MIN_BLOCK_SIZE), log2i(MAX_SB_SIZE));\n  decoder_info->pb_split = get_flc(1, stream);\n  decoder_info->tb_split_enable = get_flc(1, stream);\n  decoder_info->max_num_ref = get_flc(2, stream) + 1;\n  decoder_info->interp_ref = get_flc(2, stream);\n  decoder_info->max_delta_qp = get_flc(1, stream);\n  decoder_info->deblocking = get_flc(1, stream);\n  decoder_info->clpf = get_flc(1, stream);\n  decoder_info->use_block_contexts = get_flc(1, stream);\n  decoder_info->bipred = get_flc(2, stream);\n  decoder_info->qmtx = get_flc(1, stream);\n  if (decoder_info->qmtx) {\n    decoder_info->qmtx_offset = get_flc(6, stream) - 32;\n  }\n  decoder_info->subsample = get_flc(2, stream);\n    decoder_info->subsample = \n    (decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n    ((decoder_info->subsample & 3) == 3) * 2 + 400;\n  decoder_info->num_reorder_pics = get_flc(4, stream);\n  if (decoder_info->subsample != 400) {\n    decoder_info->cfl_intra = get_flc(1, stream);\n    decoder_info->cfl_inter = get_flc(1, stream);\n  }\n  decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->bitdepth == 10)\n    decoder_info->bitdepth += 2 * get_flc(1, stream);\n  decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->input_bitdepth == 10)\n    decoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}", "target": 0}
{"code": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n  if(index > size())\n    return v;\n  ConstIterator endIt;\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n  return v;\n}", "target": 1}
{"code": "static void handle_get_accept(struct http_conn *conn,\n\t\t\t      const struct http_msg *msg,\n\t\t\t      struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\tinfo(\"handle get accept\\n\");\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"accept: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"handle get accept (content=%s)\\n\", ie->content.accept);\n\tif (ie->content.accept) {\n\t\thttp_creply(conn, 200, \"OK\",\n\t\t\t    \"application/json\", \"%s\", ie->content.accept);\n\t}\n\telse {\n\t\thttp_ereply(conn, 404, \"Not Yet\");\n\t}\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "Map1to1(SDL_Palette * src, SDL_Palette * dst, int *identical)\n{\n    Uint8 *map;\n    int i;\n    if (identical) {\n        if (src->ncolors <= dst->ncolors) {\n            if (src == dst\n                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);\n}", "target": 1}
{"code": "AP_CORE_DECLARE_NONSTD(const char *) ap_limit_section(cmd_parms *cmd,\n                                                      void *dummy,\n                                                      const char *arg)\n{\n    const char *endp = ap_strrchr_c(arg, '>');\n    const char *limited_methods;\n    void *tog = cmd->cmd->cmd_data;\n    apr_int64_t limited = 0;\n    apr_int64_t old_limited = cmd->limited;\n    const char *errmsg;\n    if (endp == NULL) {\n        return unclosed_directive(cmd);\n    }\n    limited_methods = apr_pstrmemdup(cmd->temp_pool, arg, endp - arg);\n    if (!limited_methods[0]) {\n        return missing_container_arg(cmd);\n    }\n    while (limited_methods[0]) {\n        char *method = ap_getword_conf(cmd->temp_pool, &limited_methods);\n        int methnum;\n        methnum = ap_method_number_of(method);\n        if (methnum == M_TRACE && !tog) {\n            return \"TRACE cannot be controlled by <Limit>, see TraceEnable\";\n        }\n        else if (methnum == M_INVALID) {\n            if (cmd->pool == cmd->temp_pool) {\n                return apr_psprintf(cmd->pool, \"Could not register method '%s' \"\n                                   \"for %s from .htaccess configuration\",\n                                    method, cmd->cmd->name);\n            }\n            methnum = ap_method_register(cmd->pool,\n                                         apr_pstrdup(cmd->pool, method));\n        }\n        limited |= (AP_METHOD_BIT << methnum);\n    }\n    limited = tog ? ~limited : limited;\n    if (!(old_limited & limited)) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive excludes all methods\", NULL);\n    }\n    else if ((old_limited & limited) == old_limited) {\n        return apr_pstrcat(cmd->pool, cmd->cmd->name,\n                           \"> directive specifies methods already excluded\",\n                           NULL);\n    }\n    cmd->limited &= limited;\n    errmsg = ap_walk_config(cmd->directive->first_child, cmd, cmd->context);\n    cmd->limited = old_limited;\n    return errmsg;\n}", "target": 0}
{"code": "        bool         CheckRegion(int nPos, int nSize)\n        {\n            return (nPos >= 0 && nPos + nSize >= nPos && nPos + nSize <= m_nLen);\n        }", "target": 1}
{"code": "int qemu_ram_resize(ram_addr_t base, ram_addr_t newsize, Error **errp)\n{\n    RAMBlock *block = find_ram_block(base);\n    assert(block);\n    newsize = TARGET_PAGE_ALIGN(newsize);\n    if (block->used_length == newsize) {\n        return 0;\n    }\n    if (!(block->flags & RAM_RESIZEABLE)) {\n        error_setg_errno(errp, EINVAL,\n                         \"Length mismatch: %s: 0x\" RAM_ADDR_FMT\n                         \" in != 0x\" RAM_ADDR_FMT, block->idstr,\n                         newsize, block->used_length);\n        return -EINVAL;\n    }\n    if (block->max_length < newsize) {\n        error_setg_errno(errp, EINVAL,\n                         \"Length too large: %s: 0x\" RAM_ADDR_FMT\n                         \" > 0x\" RAM_ADDR_FMT, block->idstr,\n                         newsize, block->max_length);\n        return -EINVAL;\n    }\n    cpu_physical_memory_clear_dirty_range(block->offset, block->used_length);\n    block->used_length = newsize;\n    cpu_physical_memory_set_dirty_range(block->offset, block->used_length,\n                                        DIRTY_CLIENTS_ALL);\n    memory_region_set_size(block->mr, newsize);\n    if (block->resized) {\n        block->resized(block->idstr, newsize, block->host);\n    }\n    return 0;\n}", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &parameters()\n        const override\n    {\n        parseParametersOnce();\n        return parameters_;\n    }", "target": 1}
{"code": "efind(name)\nchar *name;\n{\n\tstatic char efbuf[100];\n\tmy_regex_t re;\n\tsprintf(efbuf, \"REG_%s\", name);\n\tassert(strlen(efbuf) < sizeof(efbuf));\n\tre.re_endp = efbuf;\n\t(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));\n\treturn(atoi(efbuf));\n}", "target": 1}
{"code": "static void http_req_handler(struct http_conn *conn,\n\t\t\t     const struct http_msg *msg, void *arg)\n{\n\tstruct mbuf *mb = mbuf_alloc(1024);\n\tint err = 0;\n\t(void)arg;\n\tinfo(\"restsrv: request %r %r%r from %J\\n\",\n\t     &msg->met, &msg->path, &msg->prm,\n\t     http_conn_peer(conn));\n\tif (0 == pl_strcasecmp(&msg->met, \"POST\") &&\n\t    0 == pl_strcasecmp(&msg->path, \"/create\")) {\n\t\thandle_post_create(conn, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"PUT\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n\t\thandle_put_publish(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"PUT\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/accept\")) {\n\t\thandle_put_accept(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/publish\")) {\n\t\thandle_get_publish(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse if (0 == pl_strcasecmp(&msg->met, \"GET\") &&\n\t\t 0 == pl_strcasecmp(&msg->path, \"/accept\")) {\n\t\thandle_get_accept(conn, msg, msg->mb, (size_t)msg->clen);\n\t}\n\telse {\n\t\twarning(\"no such resource\\n\");\n\t\terr = ENOENT;\n\t\tgoto out;\n\t}\n out:\n\tif (err) {\n\t\thttp_ereply(conn, 400, \"Bad Request\");\n\t\twarning(\"restsrv: response 400 Bad Request (%m)\\n\", err);\n\t\thttp_conn_close(conn);\n\t}\n\tmem_deref(mb);\n}", "target": 0}
{"code": "void OpenURL(const char *url)\n{\n    if (strchr(url, '\\'') != NULL)\n    {\n        TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL is not valid\");\n    }\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));\n    #if defined(_WIN32)\n        sprintf(cmd, \"explorer \\\"%s\\\"\", url);\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        sprintf(cmd, \"xdg-open '%s'\", url); \n    #endif\n    #if defined(__APPLE__)\n        sprintf(cmd, \"open '%s'\", url);\n    #endif\n        int result = system(cmd);\n        if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");\n        RL_FREE(cmd);\n#endif\n#if defined(PLATFORM_WEB)\n        emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));\n#endif\n#if defined(PLATFORM_ANDROID)\n        JNIEnv *env = NULL;\n        JavaVM *vm = CORE.Android.app->activity->vm;\n        (*vm)->AttachCurrentThread(vm, &env, NULL);\n        jstring urlString = (*env)->NewStringUTF(env, url);\n        jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");\n        jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");\n        jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);\n        jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");\n        jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");\n        jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);\n        jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");\n        jobject intent = (*env)->AllocObject(env, intentClass);\n        (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);\n        jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");\n        jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");\n        (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);\n        (*vm)->DetachCurrentThread(vm);\n#endif\n    }\n}", "target": 1}
{"code": "d_lite_next_day(int argc, VALUE *argv, VALUE self)\n{\n    VALUE n;\n    rb_scan_args(argc, argv, \"01\", &n);\n    if (argc < 1)\n\tn = INT2FIX(1);\n    return d_lite_plus(self, n);\n}", "target": 0}
{"code": "propname2ctype(ScanEnv* env, const char* propname)\n{\n  UChar* name = (UChar* )propname;\n  int ctype = env->enc->property_name_to_ctype(ONIG_ENCODING_ASCII,\n      name, name + strlen(propname));\n  return ctype;\n}", "target": 0}
{"code": "FragmentedSampleReader::ReadSample(AP4_Sample& sample, AP4_DataBuffer& sample_data)\n{\n    return m_FragmentReader.ReadNextSample(m_TrackId, sample, sample_data);\n}", "target": 0}
{"code": "base::string16 Browser::GetWindowTitleForTab(bool include_app_name,\n                                             int index) const {\n  return GetWindowTitleFromWebContents(\n      include_app_name, tab_strip_model_->GetWebContentsAt(index));\n}", "target": 0}
{"code": "void CodeBlock::lazyCompileImpl(Runtime &runtime) {\n  assert(isLazy() && \"Laziness has not been checked\");\n  PerfSection perf(\"Lazy function compilation\");\n  auto *provider = (hbc::BCProviderLazy *)runtimeModule_->getBytecode();\n  auto *func = provider->getBytecodeFunction();\n  auto *lazyData = func->getLazyCompilationData();\n  auto bcModule = compileLazyFunction(lazyData);\n  runtimeModule_->initializeLazyMayAllocate(\n      hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(bcModule)));\n  functionID_ = runtimeModule_->getBytecode()->getGlobalFunctionIndex();\n  functionHeader_ =\n      runtimeModule_->getBytecode()->getFunctionHeader(functionID_);\n  bytecode_ = runtimeModule_->getBytecode()->getBytecode(functionID_);\n}", "target": 1}
{"code": "void ResourceHandle::FromProto(const ResourceHandleProto& proto) {\n  set_device(proto.device());\n  set_container(proto.container());\n  set_name(proto.name());\n  set_hash_code(proto.hash_code());\n  set_maybe_type_name(proto.maybe_type_name());\n  std::vector<DtypeAndPartialTensorShape> dtypes_and_shapes;\n  for (const auto& dtype_and_shape : proto.dtypes_and_shapes()) {\n    DataType dtype = dtype_and_shape.dtype();\n    PartialTensorShape shape(dtype_and_shape.shape());\n    dtypes_and_shapes.push_back(DtypeAndPartialTensorShape{dtype, shape});\n  }\n  dtypes_and_shapes_ = std::move(dtypes_and_shapes);\n}", "target": 1}
{"code": "static inline u32 vm_exit_controls_get(struct vcpu_vmx *vmx)\n{\n\treturn vmx->vm_exit_controls_shadow;\n}", "target": 0}
{"code": "Network::TransportSocketPtr ClientSslSocketFactory::createTransportSocket(\n    Network::TransportSocketOptionsConstSharedPtr transport_socket_options,\n    Upstream::HostDescriptionConstSharedPtr) const {\n  Envoy::Ssl::ClientContextSharedPtr ssl_ctx;\n  {\n    absl::ReaderMutexLock l(&ssl_ctx_mu_);\n    ssl_ctx = ssl_ctx_;\n  }\n  if (ssl_ctx) {\n    return std::make_unique<SslSocket>(std::move(ssl_ctx), InitialState::Client,\n                                       transport_socket_options, config_->createHandshaker());\n  } else {\n    ENVOY_LOG(debug, \"Create NotReadySslSocket\");\n    stats_.upstream_context_secrets_not_ready_.inc();\n    return std::make_unique<NotReadySslSocket>();\n  }\n}", "target": 1}
{"code": "int mlx4_register_mac(struct mlx4_dev *dev, u8 port, u64 mac, int *index)\n{\n\tstruct mlx4_mac_table *table = &mlx4_priv(dev)->port[port].mac_table;\n\tint i, err = 0;\n\tint free = -1;\n\tmlx4_dbg(dev, \"Registering MAC: 0x%llx\\n\", (unsigned long long) mac);\n\tmutex_lock(&table->mutex);\n\tfor (i = 0; i < MLX4_MAX_MAC_NUM - 1; i++) {\n\t\tif (free < 0 && !table->refs[i]) {\n\t\t\tfree = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (mac == (MLX4_MAC_MASK & be64_to_cpu(table->entries[i]))) {\n\t\t\t*index = i;\n\t\t\t++table->refs[i];\n\t\t\tgoto out;\n\t\t}\n\t}\n\tif (free < 0) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmlx4_dbg(dev, \"Free MAC index is %d\\n\", free);\n\tif (table->total == table->max) {\n\t\terr = -ENOSPC;\n\t\tgoto out;\n\t}\n\ttable->refs[free] = 1;\n\ttable->entries[free] = cpu_to_be64(mac | MLX4_MAC_VALID);\n\terr = mlx4_set_port_mac_table(dev, port, table->entries);\n\tif (unlikely(err)) {\n\t\tmlx4_err(dev, \"Failed adding MAC: 0x%llx\\n\", (unsigned long long) mac);\n\t\ttable->refs[free] = 0;\n\t\ttable->entries[free] = 0;\n\t\tgoto out;\n\t}\n\t*index = free;\n\t++table->total;\nout:\n\tmutex_unlock(&table->mutex);\n\treturn err;\n}", "target": 0}
{"code": "png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)\n{\n   png_alloc_size_t limit = PNG_UINT_31_MAX;\n# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n   if (png_ptr->user_chunk_malloc_max > 0 &&\n       png_ptr->user_chunk_malloc_max < limit)\n      limit = png_ptr->user_chunk_malloc_max;\n# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n      limit = PNG_USER_CHUNK_MALLOC_MAX;\n# endif\n   if (png_ptr->chunk_name == png_IDAT)\n   {\n      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n      size_t row_factor =\n         (png_ptr->width * png_ptr->channels * (png_ptr->bit_depth > 8? 2: 1)\n          + 1 + (png_ptr->interlaced? 6: 0));\n      if (png_ptr->height > PNG_UINT_32_MAX/row_factor)\n         idat_limit=PNG_UINT_31_MAX;\n      else\n         idat_limit = png_ptr->height * row_factor;\n      row_factor = row_factor > 32566? 32566 : row_factor;\n      idat_limit += 6 + 5*(idat_limit/row_factor+1); \n      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n      limit = limit < idat_limit? idat_limit : limit;\n   }\n   if (length > limit)\n   {\n      png_debug2(0,\" length = %lu, limit = %lu\",\n         (unsigned long)length,(unsigned long)limit);\n      png_chunk_error(png_ptr, \"chunk data is too large\");\n   }\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, NoKeepWithGeoNear) {\n    params.options = QueryPlannerParams::KEEP_MUTATIONS;\n    addIndex(BSON(\"a\"\n                  << \"2d\"));\n    runQuery(fromjson(\"{a: {$near: [0,0], $maxDistance:0.3 }}\"));\n    ASSERT_EQUALS(getNumSolutions(), 1U);\n    assertSolutionExists(\"{geoNear2d: {a: '2d'}}\");\n}", "target": 0}
{"code": "void Document::ImplicitClose() {\n  DCHECK(!InStyleRecalc());\n  DCHECK(parser_);\n  load_event_progress_ = kLoadEventInProgress;\n  DetachParser();\n  if (SvgExtensions())\n    AccessSVGExtensions().DispatchSVGLoadEventToOutermostSVGElements();\n  if (domWindow())\n    domWindow()->DocumentWasClosed();\n  if (GetFrame()) {\n    GetFrame()->Client()->DispatchDidHandleOnloadEvents();\n    Loader()->GetApplicationCacheHost()->StopDeferringEvents();\n  }\n  if (!GetFrame()) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (GetFrame()->GetNavigationScheduler().LocationChangePending() &&\n      ElapsedTime() < kCLayoutScheduleThreshold) {\n    load_event_progress_ = kLoadEventCompleted;\n    return;\n  }\n  if (!LocalOwner() || (LocalOwner()->GetLayoutObject() &&\n                        !LocalOwner()->GetLayoutObject()->NeedsLayout())) {\n    UpdateStyleAndLayoutTree();\n    if (View() && !GetLayoutViewItem().IsNull() &&\n        (!GetLayoutViewItem().FirstChild() ||\n         GetLayoutViewItem().NeedsLayout()))\n      View()->UpdateLayout();\n  }\n  load_event_progress_ = kLoadEventCompleted;\n  if (GetFrame() && !GetLayoutViewItem().IsNull() &&\n      GetSettings()->GetAccessibilityEnabled()) {\n    if (AXObjectCache* cache = GetOrCreateAXObjectCache()) {\n      if (this == &AXObjectCacheOwner())\n        cache->HandleLoadComplete(this);\n      else\n        cache->HandleLayoutComplete(this);\n    }\n  }\n  if (SvgExtensions())\n    AccessSVGExtensions().StartAnimations();\n}", "target": 0}
{"code": "static void common_hrtimer_rearm(struct k_itimer *timr)\n{\n\tstruct hrtimer *timer = &timr->it.real.timer;\n\tif (!timr->it_interval)\n\t\treturn;\n\ttimr->it_overrun += (unsigned int) hrtimer_forward(timer,\n\t\t\t\t\t\ttimer->base->get_time(),\n\t\t\t\t\t\ttimr->it_interval);\n\thrtimer_restart(timer);\n}", "target": 1}
{"code": "void ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n   JpegOutput jpeg( filename );\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n   jpeg.cinfo().density_unit = 2; \n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); \n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}", "target": 1}
{"code": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\tpayload = NULL;\n\tif (_payload) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\tret = key_update(key_ref, payload, plen);\n\tkey_ref_put(key_ref);\nerror2:\n\tkfree(payload);\nerror:\n\treturn ret;\n}", "target": 1}
{"code": "static void ext_session_lock_surface_v1_handle_configure(void *data,\n\t\tstruct ext_session_lock_surface_v1 *lock_surface, uint32_t serial,\n\t\tuint32_t width, uint32_t height) {\n\tstruct swaylock_surface *surface = data;\n\tsurface->width = width;\n\tsurface->height = height;\n\tsurface->indicator_width = 0;\n\tsurface->indicator_height = 0;\n\text_session_lock_surface_v1_ack_configure(lock_surface, serial);\n\trender_frame_background(surface);\n\trender_frame(surface);\n}", "target": 0}
{"code": "static void addFrames(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n    FGFrameContent *fg = new FGFrameContent();\n    fg->setStackID(\"1\");\n    OFCHECK(fg);\n    if (fg)\n    {\n        EctEnhancedCT::FramesType frames = ct->getFrames();\n        for (Uint16 frameNo = 1; frameNo <= NUM_FRAMES; frameNo++)\n        {\n            OFCHECK(fg->setFrameAcquisitionNumber(frameNo).good());\n            OFCHECK(fg->setFrameReferenceDateTime(\"20190816092557\").good());\n            OFCHECK(fg->setFrameAcquisitionDateTime(\"20190816092557\").good());\n            OFCHECK(fg->setFrameAcquisitionDuration(0.001).good());\n            OFCHECK(fg->setInStackPositionNumber(frameNo).good());\n            OFCHECK(fg->setDimensionIndexValues(1, 0).good());\n            OFCHECK(fg->setDimensionIndexValues(frameNo, 1).good());\n            OFVector<FGBase *> groups;\n            groups.push_back(fg);\n            Uint16 *data = new Uint16[NUM_PIXELS_PER_FRAME];\n            for (size_t i = 0; i < NUM_PIXELS_PER_FRAME; ++i)\n            {\n                data[i] = 0x4141;\n            }\n            OFCHECK(\n                OFget<EctEnhancedCT::Frames<Uint16>>(&frames)->addFrame(data, NUM_PIXELS_PER_FRAME, groups).good());\n            delete[] data;\n        }\n    }\n    delete fg;\n}", "target": 0}
{"code": "void SocketLineReader::dataReceived()\n{\n    while (m_socket->canReadLine()) {\n        const QByteArray line = m_socket->readLine();\n        if (line.length() > 1) { \n            m_packets.enqueue(line);\n        }\n    }\n    if (m_socket->bytesAvailable() > 0) {\n        QMetaObject::invokeMethod(this, \"dataReceived\", Qt::QueuedConnection);\n        return;\n    }\n    if (!m_packets.isEmpty()) {\n        Q_EMIT readyRead();\n    }\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_rtv_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tif (buf_offset + 8 > sz) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_VISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.annotation_array.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t\t}\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "static inline int xrstor_state(struct xsave_struct *fx, u64 mask)\n{\n\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\t\"1: \" XRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "_gnutls_x509_get_signature_algorithm(ASN1_TYPE src, const char *src_name)\n{\n\tint result;\n\tgnutls_datum_t sa;\n\tresult = _gnutls_x509_read_value(src, src_name, &sa);\n\tif (result < 0) {\n\t\tgnutls_assert();\n\t\treturn result;\n\t}\n\tresult = _gnutls_x509_oid2sign_algorithm((char *) sa.data);\n\t_gnutls_free_datum(&sa);\n\treturn result;\n}", "target": 0}
{"code": "sysDescr_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_string(varbind, oid, CONTIKI_VERSION_STRING);\n}", "target": 1}
{"code": "sysObjectID_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  OID(sysObjectID_oid, 1, 3, 6, 1, 4, 1, 54352);\n  snmp_api_set_oid(varbind, oid, sysObjectID_oid);\n}", "target": 1}
{"code": "test_keys ( ELG_secret_key *sk, unsigned int nbits, int nodie )\n{\n  ELG_public_key pk;\n  gcry_mpi_t test = gcry_mpi_new ( 0 );\n  gcry_mpi_t out1_a = gcry_mpi_new ( nbits );\n  gcry_mpi_t out1_b = gcry_mpi_new ( nbits );\n  gcry_mpi_t out2 = gcry_mpi_new ( nbits );\n  int failed = 0;\n  pk.p = sk->p;\n  pk.g = sk->g;\n  pk.y = sk->y;\n  gcry_mpi_randomize ( test, nbits, GCRY_WEAK_RANDOM );\n  do_encrypt ( out1_a, out1_b, test, &pk );\n  decrypt ( out2, out1_a, out1_b, sk );\n  if ( mpi_cmp( test, out2 ) )\n    failed |= 1;\n  sign ( out1_a, out1_b, test, sk );\n  if ( !verify( out1_a, out1_b, test, &pk ) )\n    failed |= 2;\n  gcry_mpi_release ( test );\n  gcry_mpi_release ( out1_a );\n  gcry_mpi_release ( out1_b );\n  gcry_mpi_release ( out2 );\n  if (failed && !nodie)\n    log_fatal (\"Elgamal test key for %s %s failed\\n\",\n               (failed & 1)? \"encrypt+decrypt\":\"\",\n               (failed & 2)? \"sign+verify\":\"\");\n  if (failed && DBG_CIPHER)\n    log_debug (\"Elgamal test key for %s %s failed\\n\",\n               (failed & 1)? \"encrypt+decrypt\":\"\",\n               (failed & 2)? \"sign+verify\":\"\");\n  return failed;\n}", "target": 0}
{"code": "int ecall_start(struct ecall *ecall, enum icall_call_type call_type,\n\t\tbool audio_cbr)\n{\n\tint err;\n\tinfo(\"ecall(%p): start\\n\", ecall);\n\tif (!ecall)\n\t\treturn EINVAL;\n#ifdef ECALL_CBR_ALWAYS_ON\n\taudio_cbr = true;\n#endif\n\tif (ecall->econn) {\n\t\tif (ECONN_PENDING_INCOMING == econn_current_state(ecall->econn)) {\n\t\t\treturn ecall_answer(ecall, call_type, audio_cbr);\n\t\t}\n\t\telse {\n\t\t\twarning(\"ecall: start: already in progress (econn=%s)\\n\",\n\t\t\t\teconn_state_name(econn_current_state(ecall->econn)));\n\t\t\treturn EALREADY;\n\t\t}\n\t}\n#if 0\n\tif (ecall->turnc == 0) {\n\t\twarning(\"ecall: start: no TURN servers -- cannot start\\n\");\n\t\treturn EINTR;\n\t}\n#endif\n\tecall->call_type = call_type;\n\terr = ecall_create_econn(ecall);\n\tif (err) {\n\t\twarning(\"ecall: start: create_econn failed: %m\\n\", err);\n\t\treturn err;\n\t}\n\teconn_set_state(ecall_get_econn(ecall), ECONN_PENDING_OUTGOING);\n\terr = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, audio_cbr);\n\tif (err) {\n\t\twarning(\"ecall: start: alloc_flow failed: %m\\n\", err);\n\t\tgoto out;\n\t}\n\tIFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);\n\tif (ecall->props_local &&\n\t    (call_type == ICALL_CALL_TYPE_VIDEO\n\t     && ecall->vstate == ICALL_VIDEO_STATE_STARTED)) {\n\t\tconst char *vstate_string = \"true\";\n\t\tint err2 = econn_props_update(ecall->props_local,\n\t\t\t\t\t      \"videosend\", vstate_string);\n\t\tif (err2) {\n\t\t\twarning(\"ecall(%p): econn_props_update(videosend)\",\n\t\t\t\t\" failed (%m)\\n\", ecall, err2);\n\t\t}\n\t}\n\tecall->sdp.async = ASYNC_NONE;\n\terr = generate_offer(ecall);\n\tif (err) {\n\t\twarning(\"ecall(%p): start: generate_offer\"\n\t\t\t\" failed (%m)\\n\", ecall, err);\n\t\tgoto out;\n\t}\n\tecall->ts_started = tmr_jiffies();\n\tecall->call_setup_time = -1;\n out:\n\treturn err;\n}", "target": 1}
{"code": "PHP_FUNCTION( msgfmt_format_message )\n{\n\tzval       *args;\n\tUChar      *spattern = NULL;\n\tint         spattern_len = 0;\n\tchar       *pattern = NULL;\n\tint         pattern_len = 0;\n\tconst char *slocale = NULL;\n\tint         slocale_len = 0;\n\tMessageFormatter_object mf = {0};\n\tMessageFormatter_object *mfo = &mf;\n\tif( zend_parse_method_parameters( ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"ssa\",\n\t\t  &slocale, &slocale_len, &pattern, &pattern_len, &args ) == FAILURE )\n\t{\n\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\"msgfmt_format_message: unable to parse input params\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n\tINTL_CHECK_LOCALE_LEN(slocale_len);\n\tmsgformat_data_init(&mfo->mf_data TSRMLS_CC);\n\tif(pattern && pattern_len) {\n\t\tintl_convert_utf8_to_utf16(&spattern, &spattern_len, pattern, pattern_len, &INTL_DATA_ERROR_CODE(mfo));\n\t\tif( U_FAILURE(INTL_DATA_ERROR_CODE((mfo))) )\n\t\t{\n\t\t\tintl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,\n\t\t\t\t\"msgfmt_format_message: error converting pattern to UTF-16\", 0 TSRMLS_CC );\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tspattern_len = 0;\n\t\tspattern = NULL;\n\t}\n\tif(slocale_len == 0) {\n\t\tslocale = intl_locale_get_default(TSRMLS_C);\n\t}\n#ifdef MSG_FORMAT_QUOTE_APOS\n\tif(msgformat_fix_quotes(&spattern, &spattern_len, &INTL_DATA_ERROR_CODE(mfo)) != SUCCESS) {\n\t\tintl_error_set( NULL, U_INVALID_FORMAT_ERROR,\n\t\t\t\"msgfmt_format_message: error converting pattern to quote-friendly format\", 0 TSRMLS_CC );\n\t\tRETURN_FALSE;\n\t}\n#endif\n\tMSG_FORMAT_OBJECT(mfo) = umsg_open(spattern, spattern_len, slocale, NULL, &INTL_DATA_ERROR_CODE(mfo));\n\tif(spattern && spattern_len) {\n\t\tefree(spattern);\n\t}\n\tINTL_METHOD_CHECK_STATUS(mfo, \"Creating message formatter failed\");\n\tmsgfmt_do_format(mfo, args, return_value TSRMLS_CC);\n\tmsgformat_data_free(&mfo->mf_data TSRMLS_CC);\n}", "target": 0}
{"code": "char *path_name(struct strbuf *path, const char *name)\n{\n\tstruct strbuf ret = STRBUF_INIT;\n\tif (path)\n\t\tstrbuf_addbuf(&ret, path);\n\tstrbuf_addstr(&ret, name);\n\treturn strbuf_detach(&ret, NULL);\n}", "target": 1}
{"code": "struct crypto_alg *crypto_larval_lookup(const char *name, u32 type, u32 mask)\n{\n\tstruct crypto_alg *alg;\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"%s\", name);\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"%s-all\", name);\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\treturn crypto_larval_add(name, type, mask);\n}", "target": 1}
{"code": "bool SSecurityTLS::processMsg(SConnection *sc)\n{\n  rdr::InStream* is = sc->getInStream();\n  rdr::OutStream* os = sc->getOutStream();\n  vlog.debug(\"Process security message (session %p)\", session);\n  if (!session) {\n    initGlobal();\n    if (gnutls_init(&session, GNUTLS_SERVER) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_init failed\");\n    if (gnutls_set_default_priority(session) != GNUTLS_E_SUCCESS)\n      throw AuthFailureException(\"gnutls_set_default_priority failed\");\n    try {\n      setParams(session);\n    }\n    catch(...) {\n      os->writeU8(0);\n      throw;\n    }\n    os->writeU8(1);\n    os->flush();\n  }\n  rdr::TLSInStream *tlsis = new rdr::TLSInStream(is, session);\n  rdr::TLSOutStream *tlsos = new rdr::TLSOutStream(os, session);\n  int err;\n  err = gnutls_handshake(session);\n  if (err != GNUTLS_E_SUCCESS) {\n    delete tlsis;\n    delete tlsos;\n    if (!gnutls_error_is_fatal(err)) {\n      vlog.debug(\"Deferring completion of TLS handshake: %s\", gnutls_strerror(err));\n      return false;\n    }\n    vlog.error(\"TLS Handshake failed: %s\", gnutls_strerror (err));\n    shutdown();\n    throw AuthFailureException(\"TLS Handshake failed\");\n  }\n  vlog.debug(\"Handshake completed\");\n  sc->setStreams(fis = tlsis, fos = tlsos);\n  return true;\n}", "target": 1}
{"code": "my_bool STDCALL mysql_stmt_free_result(MYSQL_STMT *stmt)\n{\n  DBUG_ENTER(\"mysql_stmt_free_result\");\n  DBUG_RETURN(reset_stmt_handle(stmt, RESET_LONG_DATA | RESET_STORE_RESULT |\n                                RESET_CLEAR_ERROR));\n}", "target": 0}
{"code": "static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, const nfs4_stateid *deleg_stateid, int open_flags)\n{\n\twrite_seqlock(&state->seqlock);\n\tif (deleg_stateid != NULL) {\n\t\tmemcpy(state->stateid.data, deleg_stateid->data, sizeof(state->stateid.data));\n\t\tset_bit(NFS_DELEGATED_STATE, &state->flags);\n\t}\n\tif (open_stateid != NULL)\n\t\tnfs_set_open_stateid_locked(state, open_stateid, open_flags);\n\twrite_sequnlock(&state->seqlock);\n\tspin_lock(&state->owner->so_lock);\n\tupdate_open_stateflags(state, open_flags);\n\tspin_unlock(&state->owner->so_lock);\n}", "target": 1}
{"code": "bool neu_plugin_manager_schema_exist(neu_plugin_manager_t *mgr,\n                                     const char *          schema)\n{\n    bool             exist = false;\n    plugin_entity_t *el = NULL, *tmp = NULL;\n    HASH_ITER(hh, mgr->plugins, el, tmp)\n    {\n        if (strcmp(el->schema, schema) == 0) {\n            exist = true;\n            break;\n        }\n    }\n    return exist;\n}", "target": 0}
{"code": "parse_SET_IP_ECN(char *arg, const struct ofpact_parse_params *pp)\n{\n    uint8_t ecn;\n    char *error;\n    error = str_to_u8(arg, \"ECN\", &ecn);\n    if (error) {\n        return error;\n    }\n    if (ecn & ~IP_ECN_MASK) {\n        return xasprintf(\"%s: not a valid ECN\", arg);\n    }\n    ofpact_put_SET_IP_ECN(pp->ofpacts)->ecn = ecn;\n    return NULL;\n}", "target": 0}
{"code": "static int pcrypt_create_aead(struct crypto_template *tmpl, struct rtattr **tb,\n\t\t\t      u32 type, u32 mask)\n{\n\tstruct pcrypt_instance_ctx *ctx;\n\tstruct crypto_attr_type *algt;\n\tstruct aead_instance *inst;\n\tstruct aead_alg *alg;\n\tconst char *name;\n\tint err;\n\talgt = crypto_get_attr_type(tb);\n\tif (IS_ERR(algt))\n\t\treturn PTR_ERR(algt);\n\tname = crypto_attr_alg_name(tb[1]);\n\tif (IS_ERR(name))\n\t\treturn PTR_ERR(name);\n\tinst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\n\tif (!inst)\n\t\treturn -ENOMEM;\n\tctx = aead_instance_ctx(inst);\n\tcrypto_set_aead_spawn(&ctx->spawn, aead_crypto_instance(inst));\n\terr = crypto_grab_aead(&ctx->spawn, name, 0, 0);\n\tif (err)\n\t\tgoto out_free_inst;\n\talg = crypto_spawn_aead_alg(&ctx->spawn);\n\terr = pcrypt_init_instance(aead_crypto_instance(inst), &alg->base);\n\tif (err)\n\t\tgoto out_drop_aead;\n\tinst->alg.base.cra_flags = CRYPTO_ALG_ASYNC;\n\tinst->alg.ivsize = crypto_aead_alg_ivsize(alg);\n\tinst->alg.maxauthsize = crypto_aead_alg_maxauthsize(alg);\n\tinst->alg.base.cra_ctxsize = sizeof(struct pcrypt_aead_ctx);\n\tinst->alg.init = pcrypt_aead_init_tfm;\n\tinst->alg.exit = pcrypt_aead_exit_tfm;\n\tinst->alg.setkey = pcrypt_aead_setkey;\n\tinst->alg.setauthsize = pcrypt_aead_setauthsize;\n\tinst->alg.encrypt = pcrypt_aead_encrypt;\n\tinst->alg.decrypt = pcrypt_aead_decrypt;\n\tinst->free = pcrypt_free;\n\terr = aead_register_instance(tmpl, inst);\n\tif (err)\n\t\tgoto out_drop_aead;\nout:\n\treturn err;\nout_drop_aead:\n\tcrypto_drop_aead(&ctx->spawn);\nout_free_inst:\n\tkfree(inst);\n\tgoto out;\n}", "target": 0}
{"code": "static int decode_zbuf(AVBPrint *bp, const uint8_t *data,\n                       const uint8_t *data_end)\n{\n    z_stream zstream;\n    unsigned char *buf;\n    unsigned buf_size;\n    int ret;\n    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);\n    bp->str[bp->len] = 0;\n    return 0;\nfail:\n    inflateEnd(&zstream);\n    av_bprint_finalize(bp, NULL);\n    return ret;\n}", "target": 1}
{"code": "void ftoa_bounded_extra(JsVarFloat val,char *str, size_t len, int radix, int fractionalDigits) {\n  const JsVarFloat stopAtError = 0.0000001;\n  if (isnan(val)) strncpy(str,\"NaN\",len);\n  else if (!isfinite(val)) {\n    if (val<0) strncpy(str,\"-Infinity\",len);\n    else strncpy(str,\"Infinity\",len);\n  } else {\n    if (val<0) {\n      if (--len <= 0) { *str=0; return; } \n      *(str++) = '-';\n      val = -val;\n    }\n    if (((JsVarInt)(val+stopAtError)) == (1+(JsVarInt)val))\n      val = (JsVarFloat)(1+(JsVarInt)val);\n    JsVarFloat d = 1;\n    while (d*radix <= val) d*=radix;\n    while (d >= 1) {\n      int v = (int)(val / d);\n      val -= v*d;\n      if (--len <= 0) { *str=0; return; } \n      *(str++) = itoch(v);\n      d /= radix;\n    }\n#ifndef USE_NO_FLOATS\n    if (((fractionalDigits<0) && val>0) || fractionalDigits>0) {\n      bool hasPt = false;\n      val*=radix;\n      while (((fractionalDigits<0) && (fractionalDigits>-12) && (val > stopAtError)) || (fractionalDigits > 0)) {\n        int v = (int)(val+((fractionalDigits==1) ? 0.4 : 0.00000001) );\n        val = (val-v)*radix;\n\tif (v==radix) v=radix-1;\n        if (!hasPt) {\t\n\t  hasPt = true;\n          if (--len <= 0) { *str=0; return; } \n          *(str++)='.';\n        }\n        if (--len <= 0) { *str=0; return; } \n        *(str++)=itoch(v);\n        fractionalDigits--;\n      }\n    }\n#endif\n    *(str++)=0;\n  }\n}", "target": 1}
{"code": "gfx::Rect WebContentsImpl::GetRootWindowResizerRect() const {\n  if (delegate_)\n    return delegate_->GetRootWindowResizerRect();\n  return gfx::Rect();\n}", "target": 0}
{"code": "void ExtractStreams(Archive &Arc,const wchar *FileName,bool TestMode)\n{\n  wchar FullName[NM+2];\n  if (FileName[0]!=0 && FileName[1]==0)\n  {\n    wcsncpyz(FullName,L\".\\\\\",ASIZE(FullName));\n    wcsncatz(FullName,FileName,ASIZE(FullName));\n  }\n  else\n    wcsncpyz(FullName,FileName,ASIZE(FullName));\n  wchar StreamName[NM];\n  GetStreamNameNTFS(Arc,StreamName,ASIZE(StreamName));\n  if (*StreamName!=':')\n  {\n    uiMsg(UIERROR_STREAMBROKEN,Arc.FileName,FileName);\n    ErrHandler.SetErrorCode(RARX_CRC);\n    return;\n  }\n  if (TestMode)\n  {\n    File CurFile;\n    Arc.ReadSubData(NULL,&CurFile,true);\n    return;\n  }\n  wcsncatz(FullName,StreamName,ASIZE(FullName));\n  FindData fd;\n  bool HostFound=FindFile::FastFind(FileName,&fd);\n  if ((fd.FileAttr & FILE_ATTRIBUTE_READONLY)!=0)\n    SetFileAttr(FileName,fd.FileAttr & ~FILE_ATTRIBUTE_READONLY);\n  File CurFile;\n  if (CurFile.WCreate(FullName) && Arc.ReadSubData(NULL,&CurFile,false))\n    CurFile.Close();\n  File HostFile;\n  if (HostFound && HostFile.Open(FileName,FMF_OPENSHARED|FMF_UPDATE))\n    SetFileTime(HostFile.GetHandle(),&fd.ftCreationTime,&fd.ftLastAccessTime,\n                &fd.ftLastWriteTime);\n  SetFileAttr(FileName,fd.FileAttr);\n}", "target": 1}
{"code": "void CheckServiceControl(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span(\n      CreateSpan(context->cloud_trace(), \"CheckServiceControl\"));\n  if (!context->method()) {\n    if (context->GetRequestHTTPMethodWithOverride() == \"OPTIONS\") {\n      TRACE(trace_span) << \"OPTIONS request is rejected\";\n      continuation(Status(Code::PERMISSION_DENIED,\n                          \"The service does not allow CORS traffic.\",\n                          Status::SERVICE_CONTROL));\n    } else {\n      TRACE(trace_span) << \"Method is not configured in the service config\";\n      continuation(Status(Code::NOT_FOUND, \"Method does not exist.\",\n                          Status::SERVICE_CONTROL));\n    }\n    return;\n  } else if (!context->service_context()->service_control() ||\n             context->method()->skip_service_control()) {\n    TRACE(trace_span) << \"Service control check is not needed\";\n    continuation(Status::OK);\n    return;\n  }\n  if (context->api_key().empty()) {\n    if (context->method()->allow_unregistered_calls()) {\n      TRACE(trace_span) << \"Service control check is not needed\";\n      continuation(Status::OK);\n      return;\n    }\n    TRACE(trace_span) << \"Failed at checking caller identity.\";\n    continuation(\n        Status(Code::UNAUTHENTICATED,\n               \"Method doesn't allow unregistered callers (callers without \"\n               \"established identity). Please use API Key or other form of \"\n               \"API consumer identity to call this API.\",\n               Status::SERVICE_CONTROL));\n    return;\n  }\n  service_control::CheckRequestInfo info;\n  context->FillCheckRequestInfo(&info);\n  context->service_context()->service_control()->Check(\n      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        context->set_check_response_info(info);\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(kConsumerProjecId,\n                                                 info.consumer_project_id);\n        }\n        continuation(status);\n      });\n}", "target": 1}
{"code": "static inline int xsave_state(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\talternative_input_2(\n\t\t\"1:\"XSAVE,\n\t\t\"1:\"XSAVEOPT,\n\t\tX86_FEATURE_XSAVEOPT,\n\t\t\"1:\"XSAVES,\n\t\tX86_FEATURE_XSAVES,\n\t\t[fx] \"D\" (fx), \"a\" (lmask), \"d\" (hmask) :\n\t\t\"memory\");\n\tasm volatile(\"2:\\n\\t\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}", "target": 1}
{"code": "linux_lvm2_vg_remove_pv_completed_cb (DBusGMethodInvocation *context,\n                                      Device *device,\n                                      gboolean job_was_cancelled,\n                                      int status,\n                                      const char *stderr,\n                                      const char *stdout,\n                                      gpointer user_data)\n{\n  if (WEXITSTATUS (status) == 0 && !job_was_cancelled)\n    {\n      dbus_g_method_return (context);\n    }\n  else\n    {\n      if (job_was_cancelled)\n        {\n          throw_error (context, ERROR_CANCELLED, \"Job was cancelled\");\n        }\n      else\n        {\n          throw_error (context,\n                       ERROR_FAILED,\n                       \"Error removing PV for LVM2 Volume Group: vgreduce exited with exit code %d: %s\",\n                       WEXITSTATUS (status),\n                       stderr);\n        }\n    }\n}", "target": 0}
{"code": "finish_stop(int stop_count)\n{\n\tif (tracehook_notify_jctl(stop_count == 0, CLD_STOPPED)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, CLD_STOPPED);\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tdo {\n\t\tschedule();\n\t} while (try_to_freeze());\n\tcurrent->exit_code = 0;\n}", "target": 0}
{"code": "void setrangeCommand(client *c) {\n    robj *o;\n    long offset;\n    sds value = c->argv[3]->ptr;\n    if (getLongFromObjectOrReply(c,c->argv[2],&offset,NULL) != C_OK)\n        return;\n    if (offset < 0) {\n        addReplyError(c,\"offset is out of range\");\n        return;\n    }\n    o = lookupKeyWrite(c->db,c->argv[1]);\n    if (o == NULL) {\n        if (sdslen(value) == 0) {\n            addReply(c,shared.czero);\n            return;\n        }\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n        o = createObject(OBJ_STRING,sdsnewlen(NULL, offset+sdslen(value)));\n        dbAdd(c->db,c->argv[1],o);\n    } else {\n        size_t olen;\n        if (checkType(c,o,OBJ_STRING))\n            return;\n        olen = stringObjectLen(o);\n        if (sdslen(value) == 0) {\n            addReplyLongLong(c,olen);\n            return;\n        }\n        if (checkStringLength(c,offset+sdslen(value)) != C_OK)\n            return;\n        o = dbUnshareStringValue(c->db,c->argv[1],o);\n    }\n    if (sdslen(value) > 0) {\n        o->ptr = sdsgrowzero(o->ptr,offset+sdslen(value));\n        memcpy((char*)o->ptr+offset,value,sdslen(value));\n        signalModifiedKey(c,c->db,c->argv[1]);\n        notifyKeyspaceEvent(NOTIFY_STRING,\n            \"setrange\",c->argv[1],c->db->id);\n        server.dirty++;\n    }\n    addReplyLongLong(c,sdslen(o->ptr));\n}", "target": 1}
{"code": "SPL_METHOD(MultipleIterator, getFlags)\n{\n\tspl_SplObjectStorage *intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_LONG(intern->flags);\n}", "target": 0}
{"code": "  static Status ParseEquation(const string& equation,\n                              OperandLabels* input_labels,\n                              Labels* output_labels,\n                              std::vector<DimensionType>* label_types,\n                              OperandLabelCounts* input_label_counts,\n                              LabelCounts* output_label_counts,\n                              gtl::InlinedVector<bool, 2>* input_has_ellipsis,\n                              bool* output_has_ellipsis) {\n    gtl::InlinedVector<string, 2> input_str;\n    string output_str;\n    TF_RETURN_IF_ERROR(ParseEinsumEquation(equation, &input_str, &output_str));\n    absl::flat_hash_map<char, int> label_mapping;\n    int num_inputs = input_str.size();\n    input_labels->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      MapToLabels(input_str[i], &input_labels->at(i), &label_mapping);\n    }\n    MapToLabels(output_str, output_labels, &label_mapping);\n    int num_labels = label_mapping.size();\n    input_label_counts->resize(num_inputs);\n    input_has_ellipsis->resize(num_inputs);\n    for (int i = 0; i < num_inputs; ++i) {\n      input_label_counts->at(i).resize(num_labels);\n      input_has_ellipsis->at(i) = false;\n      for (const int label : input_labels->at(i)) {\n        if (label != kEllipsisLabel)\n          input_label_counts->at(i)[label] += 1;\n        else\n          input_has_ellipsis->at(i) = true;\n      }\n    }\n    output_label_counts->resize(num_labels);\n    *output_has_ellipsis = false;\n    for (const int label : *output_labels) {\n      if (label != kEllipsisLabel)\n        output_label_counts->at(label) += 1;\n      else\n        *output_has_ellipsis = true;\n    }\n    label_types->resize(num_labels);\n    for (int label = 0; label < num_labels; ++label) {\n      if (label == kEllipsisLabel) continue;\n      bool removed = (*output_label_counts)[label] == 0;\n      bool unique = num_inputs == 1 || (*input_label_counts)[0][label] == 0 ||\n                    (*input_label_counts)[1][label] == 0;\n      (*label_types)[label] = GetDimensionType(removed, unique);\n    }\n    return Status::OK();\n  }", "target": 0}
{"code": "static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}", "target": 1}
{"code": "void PdfXRefStreamParserObject::parseStream(const int64_t wArray[W_ARRAY_SIZE], const vector<int64_t>& indices)\n{\n    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] < 0)\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Negative field length in XRef stream\");\n        }\n        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Invalid entry length in XRef stream\");\n        }\n        else\n        {\n            lengthSum += wArray[i];\n        }\n    }\n    const size_t entryLen = static_cast<size_t>(wArray[0] + wArray[1] + wArray[2]);\n    charbuff buffer;\n    this->GetOrCreateStream().CopyTo(buffer);\n    vector<int64_t>::const_iterator it = indices.begin();\n    char* cursor = buffer.data();\n    while (it != indices.end())\n    {\n        int64_t firstObj = *it++;\n        int64_t count = *it++;\n        m_entries->Enlarge(firstObj + count);\n        for (unsigned index = 0; index < (unsigned)count; index++)\n        {\n            if ((size_t)(cursor - buffer.data()) >= buffer.size())\n                PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid count in XRef stream\");\n            unsigned objIndex = (unsigned)firstObj + index;\n            auto& entry = (*m_entries)[objIndex];\n            if (objIndex < m_entries->GetSize() && !entry.Parsed)\n                readXRefStreamEntry(entry, cursor, wArray);\n            cursor += entryLen;\n        }\n    }\n}", "target": 1}
{"code": "static OPJ_BOOL opj_tcd_code_block_dec_allocate(opj_tcd_cblk_dec_t *\n        p_code_block)\n{\n    if (! p_code_block->data) {\n        p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE);\n        if (! p_code_block->data) {\n            return OPJ_FALSE;\n        }\n        p_code_block->data_max_size = OPJ_COMMON_DEFAULT_CBLK_DATA_SIZE;\n        p_code_block->segs = (opj_tcd_seg_t *) opj_calloc(OPJ_J2K_DEFAULT_NB_SEGS,\n                             sizeof(opj_tcd_seg_t));\n        if (! p_code_block->segs) {\n            return OPJ_FALSE;\n        }\n        p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;\n    } else {\n        OPJ_BYTE* l_data = p_code_block->data;\n        OPJ_UINT32 l_data_max_size = p_code_block->data_max_size;\n        opj_tcd_seg_t * l_segs = p_code_block->segs;\n        OPJ_UINT32 l_current_max_segs = p_code_block->m_current_max_segs;\n        memset(p_code_block, 0, sizeof(opj_tcd_cblk_dec_t));\n        p_code_block->data = l_data;\n        p_code_block->data_max_size = l_data_max_size;\n        p_code_block->segs = l_segs;\n        p_code_block->m_current_max_segs = l_current_max_segs;\n    }\n    return OPJ_TRUE;\n}", "target": 0}
{"code": "snmp_ber_encode_length(unsigned char *out, uint32_t *out_len, uint8_t length)\n{\n  *out-- = length;\n  (*out_len)++;\n  return out;\n}", "target": 1}
{"code": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError    error        = OT_ERROR_NONE;\n    const char saltPrefix[] = \"Thread\";\n    uint8_t    salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t   saltLen = 0;\n    uint16_t   passphraseLen;\n    uint8_t    networkNameLen;\n    passphraseLen  = static_cast<uint16_t>(strnlen(aPassPhrase, OT_COMMISSIONING_PASSPHRASE_MAX_SIZE + 1));\n    networkNameLen = static_cast<uint8_t>(strnlen(aNetworkName, OT_NETWORK_NAME_MAX_SIZE + 1));\n    VerifyOrExit((passphraseLen >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (passphraseLen <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (networkNameLen <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, sizeof(saltPrefix) - 1);\n    saltLen += static_cast<uint16_t>(sizeof(saltPrefix) - 1);\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n    memcpy(salt + saltLen, aNetworkName, networkNameLen);\n    saltLen += networkNameLen;\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), passphraseLen, reinterpret_cast<const uint8_t *>(salt),\n                 saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\nexit:\n    return error;\n}", "target": 0}
{"code": "V8WindowShell* ScriptController::windowShell(DOMWrapperWorld* world)\n{\n    ASSERT(world);\n    V8WindowShell* shell = 0;\n    if (world->isMainWorld())\n        shell = m_windowShell.get();\n    else {\n        IsolatedWorldMap::iterator iter = m_isolatedWorlds.find(world->worldId());\n        if (iter != m_isolatedWorlds.end())\n            shell = iter->value.get();\n        else {\n            OwnPtr<V8WindowShell> isolatedWorldShell = V8WindowShell::create(m_frame, world, m_isolate);\n            shell = isolatedWorldShell.get();\n            m_isolatedWorlds.set(world->worldId(), isolatedWorldShell.release());\n        }\n    }\n    if (!shell->isContextInitialized() && shell->initializeIfNeeded()) {\n        if (world->isMainWorld()) {\n            m_frame->loader()->dispatchDidClearWindowObjectInWorld(existingWindowShellWorkaroundWorld());\n        } else\n            m_frame->loader()->dispatchDidClearWindowObjectInWorld(world);\n    }\n    return shell;\n}", "target": 0}
{"code": "static void sctp_process_ext_param(struct sctp_association *asoc,\n\t\t\t\t   union sctp_params param)\n{\n\t__u16 num_ext = ntohs(param.p->length) - sizeof(struct sctp_paramhdr);\n\tstruct net *net = sock_net(asoc->base.sk);\n\tint i;\n\tfor (i = 0; i < num_ext; i++) {\n\t\tswitch (param.ext->chunks[i]) {\n\t\tcase SCTP_CID_RECONF:\n\t\t\tif (asoc->reconf_enable &&\n\t\t\t    !asoc->peer.reconf_capable)\n\t\t\t\tasoc->peer.reconf_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_FWD_TSN:\n\t\t\tif (asoc->prsctp_enable && !asoc->peer.prsctp_capable)\n\t\t\t\tasoc->peer.prsctp_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_AUTH:\n\t\t\tif (asoc->ep->auth_enable)\n\t\t\t\tasoc->peer.auth_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_ASCONF:\n\t\tcase SCTP_CID_ASCONF_ACK:\n\t\t\tif (net->sctp.addip_enable)\n\t\t\t\tasoc->peer.asconf_capable = 1;\n\t\t\tbreak;\n\t\tcase SCTP_CID_I_DATA:\n\t\t\tif (sctp_sk(asoc->base.sk)->strm_interleave)\n\t\t\t\tasoc->intl_enable = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}", "target": 0}
{"code": "static inline ut64 dwarf_read_offset(bool is_64bit, const ut8 **buf, const ut8 *buf_end) {\n\tut64 result;\n\tif (is_64bit) {\n\t\tresult = READ64 (*buf);\n\t} else {\n\t\tresult = READ32 (*buf);\n\t}\n\treturn result;\n}", "target": 1}
{"code": "gopherStart(FwdState * fwd)\n{\n    GopherStateData *gopherState = new GopherStateData(fwd);\n    debugs(10, 3, gopherState->entry->url());\n    ++ statCounter.server.all.requests;\n    ++ statCounter.server.other.requests;\n    gopher_request_parse(fwd->request,\n                         &gopherState->type_id, gopherState->request);\n    comm_add_close_handler(fwd->serverConnection()->fd, gopherStateFree, gopherState);\n    if (((gopherState->type_id == GOPHER_INDEX) || (gopherState->type_id == GOPHER_CSO))\n            && (strchr(gopherState->request, '?') == nullptr)) {\n        gopherMimeCreate(gopherState);\n        if (gopherState->type_id == GOPHER_INDEX) {\n            gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n        } else {\n            if (gopherState->type_id == GOPHER_CSO) {\n                gopherState->conversion = GopherStateData::HTML_CSO_PAGE;\n            } else {\n                gopherState->conversion = GopherStateData::HTML_INDEX_PAGE;\n            }\n        }\n        gopherToHTML(gopherState, (char *) nullptr, 0);\n        fwd->markStoredReplyAsWhole(\"gopher instant internal request satisfaction\");\n        fwd->complete();\n        return;\n    }\n    gopherState->serverConn = fwd->serverConnection();\n    gopherSendRequest(fwd->serverConnection()->fd, gopherState);\n    AsyncCall::Pointer timeoutCall = commCbCall(5, 4, \"gopherTimeout\",\n                                     CommTimeoutCbPtrFun(gopherTimeout, gopherState));\n    commSetConnTimeout(fwd->serverConnection(), Config.Timeout.read, timeoutCall);\n}", "target": 1}
{"code": "static int crypto_ahash_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_hash rhash;\n\tsnprintf(rhash.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ahash\");\n\trhash.blocksize = alg->cra_blocksize;\n\trhash.digestsize = __crypto_hash_alg_common(alg)->digestsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_HASH,\n\t\t    sizeof(struct crypto_report_hash), &rhash))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "void DISOpticalFlowImpl::autoSelectPatchSizeAndScales(int img_width)\n{\n    switch (finest_scale)\n    {\n    case 1:\n        patch_size = 8;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-2, 0);\n        break;\n    case 3:\n        patch_size = 12;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-4, 0);\n        break;\n    case 4:\n        patch_size = 12;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-5, 0);\n        break;\n    case 2:\n    default:\n        patch_size = 8;\n        coarsest_scale = autoSelectCoarsestScale(img_width);\n        finest_scale = std::max(coarsest_scale-2, 0);\n        break;\n    }\n}", "target": 0}
{"code": "int use_env()\n{\n    int indent;\n    size_t flags = 0;\n    json_t *json;\n    json_error_t error;\n    #ifdef _WIN32\n    _setmode(_fileno(stdout), _O_BINARY);\n    _setmode(_fileno(stderr), _O_BINARY);\n    #endif\n    indent = getenv_int(\"JSON_INDENT\");\n    if(indent < 0 || indent > 255) {\n        fprintf(stderr, \"invalid value for JSON_INDENT: %d\\n\", indent);\n        return 2;\n    }\n    if(indent > 0)\n        flags |= JSON_INDENT(indent);\n    if(getenv_int(\"JSON_COMPACT\") > 0)\n        flags |= JSON_COMPACT;\n    if(getenv_int(\"JSON_ENSURE_ASCII\"))\n        flags |= JSON_ENSURE_ASCII;\n    if(getenv_int(\"JSON_PRESERVE_ORDER\"))\n        flags |= JSON_PRESERVE_ORDER;\n    if(getenv_int(\"JSON_SORT_KEYS\"))\n         flags |= JSON_SORT_KEYS;\n    if(getenv_int(\"STRIP\")) {\n        size_t size = 0, used = 0;\n        char *buffer = NULL;\n        while(1) {\n            size_t count;\n            size = (size == 0 ? 128 : size * 2);\n            buffer = realloc(buffer, size);\n            if(!buffer) {\n                fprintf(stderr, \"Unable to allocate %d bytes\\n\", (int)size);\n                return 1;\n            }\n            count = fread(buffer + used, 1, size - used, stdin);\n            if(count < size - used) {\n                buffer[used + count] = '\\0';\n                break;\n            }\n            used += count;\n        }\n        json = json_loads(strip(buffer), 0, &error);\n        free(buffer);\n    }\n    else\n        json = json_loadf(stdin, 0, &error);\n    if(!json) {\n        fprintf(stderr, \"%d %d %d\\n%s\\n\",\n            error.line, error.column,\n            error.position, error.text);\n        return 1;\n    }\n    json_dumpf(json, stdout, flags);\n    json_decref(json);\n    return 0;\n}", "target": 1}
{"code": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n    len = 0;\n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        chr[ len ] = in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = 0;\n    chr[ len ++ ] = 0;\n    return chr;\n}", "target": 1}
{"code": "static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u64 lun)\n{\n\tstruct adpt_device* d;\n\tif (chan >= MAX_CHANNEL)\n\t\treturn NULL;\n\td = pHba->channel[chan].device[id];\n\tif(!d || d->tid == 0) {\n\t\treturn NULL;\n\t}\n\tif(d->scsi_lun == lun){\n\t\treturn d;\n\t}\n\tfor(d=d->next_lun ; d ; d = d->next_lun){\n\t\tif(d->scsi_lun == lun){\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "TEST_P(TcpTunnelingIntegrationTest, UpstreamConnectingDownstreamDisconnect) {\n  if (upstreamProtocol() == Http::CodecType::HTTP1) {\n    return;\n  }\n#if defined(WIN32)\n  return;\n#endif\n  config_helper_.addConfigModifier([&](envoy::config::bootstrap::v3::Bootstrap& bootstrap) -> void {\n    envoy::extensions::filters::network::tcp_proxy::v3::TcpProxy proxy_config;\n    proxy_config.set_stat_prefix(\"tcp_stats\");\n    proxy_config.set_cluster(\"cluster_0\");\n    proxy_config.mutable_tunneling_config()->set_hostname(\"host.com:80\");\n    proxy_config.mutable_max_connect_attempts()->set_value(2);\n    auto* listeners = bootstrap.mutable_static_resources()->mutable_listeners();\n    for (auto& listener : *listeners) {\n      if (listener.name() != \"tcp_proxy\") {\n        continue;\n      }\n      auto* filter_chain = listener.mutable_filter_chains(0);\n      auto* filter = filter_chain->mutable_filters(0);\n      filter->mutable_typed_config()->PackFrom(proxy_config);\n      envoy::extensions::transport_sockets::tls::v3::DownstreamTlsContext tls_context;\n      ConfigHelper::initializeTls({}, *tls_context.mutable_common_tls_context());\n      filter_chain->mutable_transport_socket()->set_name(\"envoy.transport_sockets.tls\");\n      filter_chain->mutable_transport_socket()->mutable_typed_config()->PackFrom(tls_context);\n      break;\n    }\n  });\n  enableHalfClose(false);\n  initialize();\n  IntegrationTcpClientPtr tcp_client = makeTcpConnection(lookupPort(\"tcp_proxy\"));\n  ASSERT_TRUE(fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));\n  ASSERT_TRUE(fake_upstream_connection_->waitForNewStream(*dispatcher_, upstream_request_));\n  ASSERT_TRUE(upstream_request_->waitForHeadersComplete());\n  tcp_client->close();\n  ASSERT_TRUE(upstream_request_->waitForReset());\n  ASSERT_TRUE(fake_upstream_connection_->close());\n}", "target": 0}
{"code": "static inline int domain_pfn_mapping(struct dmar_domain *domain, unsigned long iov_pfn,\n\t\t\t\t     unsigned long phys_pfn, unsigned long nr_pages,\n\t\t\t\t     int prot)\n{\n\treturn domain_mapping(domain, iov_pfn, NULL, phys_pfn, nr_pages, prot);\n}", "target": 0}
{"code": "static int svm_vm_has_apicv(struct kvm *kvm)\n{\n\treturn 0;\n}", "target": 0}
{"code": "struct se_portal_group *tcm_loop_make_naa_tpg(\n\tstruct se_wwn *wwn,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct tcm_loop_hba *tl_hba = container_of(wwn,\n\t\t\tstruct tcm_loop_hba, tl_hba_wwn);\n\tstruct tcm_loop_tpg *tl_tpg;\n\tchar *tpgt_str, *end_ptr;\n\tint ret;\n\tunsigned short int tpgt;\n\ttpgt_str = strstr(name, \"tpgt_\");\n\tif (!tpgt_str) {\n\t\tprintk(KERN_ERR \"Unable to locate \\\"tpgt_#\\\" directory\"\n\t\t\t\t\" group\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttpgt_str += 5; \n\ttpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);\n\tif (tpgt > TL_TPGS_PER_HBA) {\n\t\tprintk(KERN_ERR \"Passed tpgt: %hu exceeds TL_TPGS_PER_HBA:\"\n\t\t\t\t\" %u\\n\", tpgt, TL_TPGS_PER_HBA);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\ttl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\n\ttl_tpg->tl_hba = tl_hba;\n\ttl_tpg->tl_tpgt = tpgt;\n\tret = core_tpg_register(&tcm_loop_fabric_configfs->tf_ops,\n\t\t\twwn, &tl_tpg->tl_se_tpg, tl_tpg,\n\t\t\tTRANSPORT_TPG_TYPE_NORMAL);\n\tif (ret < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\tprintk(KERN_INFO \"TCM_Loop_ConfigFS: Allocated Emulated %s\"\n\t\t\" Target Port %s,t,0x%04x\\n\", tcm_loop_dump_proto_id(tl_hba),\n\t\tconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\n\treturn &tl_tpg->tl_se_tpg;\n}", "target": 1}
{"code": "static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[100], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_regex( bson *b, const char *name, const char *pattern, const char *opts ) {\n    const int plen = strlen( pattern )+1;\n    const int olen = strlen( opts )+1;\n    if ( bson_append_estart( b, BSON_REGEX, name, plen + olen ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_check_string( b, pattern, plen - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    bson_append( b , pattern , plen );\n    bson_append( b , opts , olen );\n    return BSON_OK;\n}", "target": 1}
{"code": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}", "target": 1}
{"code": "static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,\n\tstruct user_namespace *user_ns)\n{\n\tmm->mmap = NULL;\n\tmm->mm_rb = RB_ROOT;\n\tmm->vmacache_seqnum = 0;\n\tatomic_set(&mm->mm_users, 1);\n\tatomic_set(&mm->mm_count, 1);\n\tinit_rwsem(&mm->mmap_sem);\n\tINIT_LIST_HEAD(&mm->mmlist);\n\tmm->core_state = NULL;\n\tatomic_long_set(&mm->nr_ptes, 0);\n\tmm_nr_pmds_init(mm);\n\tmm->map_count = 0;\n\tmm->locked_vm = 0;\n\tmm->pinned_vm = 0;\n\tmemset(&mm->rss_stat, 0, sizeof(mm->rss_stat));\n\tspin_lock_init(&mm->page_table_lock);\n\tmm_init_cpumask(mm);\n\tmm_init_aio(mm);\n\tmm_init_owner(mm, p);\n\tRCU_INIT_POINTER(mm->exe_file, NULL);\n\tmmu_notifier_mm_init(mm);\n\tinit_tlb_flush_pending(mm);\n#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS\n\tmm->pmd_huge_pte = NULL;\n#endif\n\tif (current->mm) {\n\t\tmm->flags = current->mm->flags & MMF_INIT_MASK;\n\t\tmm->def_flags = current->mm->def_flags & VM_INIT_DEF_MASK;\n\t} else {\n\t\tmm->flags = default_dump_filter;\n\t\tmm->def_flags = 0;\n\t}\n\tif (mm_alloc_pgd(mm))\n\t\tgoto fail_nopgd;\n\tif (init_new_context(p, mm))\n\t\tgoto fail_nocontext;\n\tmm->user_ns = get_user_ns(user_ns);\n\treturn mm;\nfail_nocontext:\n\tmm_free_pgd(mm);\nfail_nopgd:\n\tfree_mm(mm);\n\treturn NULL;\n}", "target": 0}
{"code": "GF_Err gf_avc_change_color(GF_AVCConfig *avcc, s32 fullrange, s32 vidformat, s32 colorprim, s32 transfer, s32 colmatrix)\n{\n\tGF_VUIInfo vuii;\n\tmemset(&vuii, 0, sizeof(GF_VUIInfo));\n\tvuii.ar_num = -1;\n\tvuii.ar_den = -1;\n\tvuii.fullrange = fullrange;\n\tvuii.video_format = vidformat;\n\tvuii.color_prim = colorprim;\n\tvuii.color_tfc = transfer;\n\tvuii.color_matrix = colmatrix;\n\treturn gf_avc_change_vui(avcc, &vuii);\n}", "target": 0}
{"code": "BOOL license_read_scope_list(wStream* s, SCOPE_LIST* scopeList)\n{\n\tUINT32 i;\n\tUINT32 scopeCount;\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\tStream_Read_UINT32(s, scopeCount); \n        if (Stream_GetRemainingLength(s) / sizeof(LICENSE_BLOB) < scopeCount)\n                return FALSE;  \n\tscopeList->count = scopeCount;\n\tscopeList->array = (LICENSE_BLOB*) malloc(sizeof(LICENSE_BLOB) * scopeCount);\n\tfor (i = 0; i < scopeCount; i++)\n\t{\n\t\tscopeList->array[i].type = BB_SCOPE_BLOB;\n\t\tif (!license_read_binary_blob(s, &scopeList->array[i]))\n\t\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "qedi_dbg_warn(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & QEDI_LOG_WARN))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_warn(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_warn(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "static void draw_pattern_push( wmfAPI* API,\n                               unsigned long id,\n                               unsigned long columns,\n                               unsigned long rows )\n{\n  char\n    pattern_id[MagickPathExtent];\n  (void) FormatLocaleString(pattern_id,MagickPathExtent,\"brush_%lu\",id);\n  (void) DrawPushPattern(WmfDrawingWand,pattern_id,0,0,columns,rows);\n}", "target": 0}
{"code": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "void RenderWidgetHostViewAura::SoftwareFrameWasFreed(\n    uint32 output_surface_id, unsigned frame_id) {\n  ReleaseSoftwareFrame(output_surface_id, frame_id);\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, MergeSortReverseSubtreeContainedOr) {\n    addIndex(BSON(\"a\" << 1 << \"e\" << 1));\n    addIndex(BSON(\"c\" << 1 << \"e\" << -1));\n    addIndex(BSON(\"d\" << 1 << \"e\" << -1));\n    runQueryAsCommand(fromjson(\n        \"{find: 'testns', filter: {$or: [{a: 1}, {b: 1, $or: [{c: 1}, {d: 1}]}]}, sort: {e: 1}}\"));\n    assertNumSolutions(2U);\n    assertSolutionExists(\n        \"{sort: {pattern: {e: 1}, limit: 0, node: {sortKeyGen: {node: \"\n        \"{cscan: {dir: 1}}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {a: 1, e: 1}, dir: 1}}, {fetch: {node: {mergeSort: {nodes: \"\n        \"[{ixscan: {pattern: {c: 1, e: -1}, dir: -1}}, {ixscan: {pattern: {d: 1, e: -1}, dir: \"\n        \"-1}}]}}}}]}}}}\");\n}", "target": 0}
{"code": "ice_protocol_timeout (IceConn ice_conn)\n{\n        GsmIceConnectionWatch *data;\n        g_debug (\"GsmXsmpServer: ice_protocol_timeout for IceConn %p with status %d\",\n                 ice_conn, IceConnectionStatus (ice_conn));\n        data = ice_conn->context;\n        free_ice_connection_watch (data);\n        disconnect_ice_connection (ice_conn);\n        return FALSE;\n}", "target": 0}
{"code": "child_func (void * const arg)\n{\n  xclose (sockfd[0]);\n  const int sock = sockfd[1];\n  char ch;\n  TEST_VERIFY_EXIT (read (sock, &ch, 1) == 1);\n  TEST_VERIFY_EXIT (ch == '1');\n  if (mount (\"/\", MOUNT_NAME, NULL, MS_BIND | MS_REC, NULL))\n    FAIL_EXIT1 (\"mount failed: %m\\n\");\n  const int fd = xopen (\"mpoint\",\n\t\t\tO_RDONLY | O_PATH | O_DIRECTORY | O_NOFOLLOW, 0);\n  send_fd (sock, fd);\n  xclose (fd);\n  TEST_VERIFY_EXIT (read (sock, &ch, 1) == 1);\n  TEST_VERIFY_EXIT (ch == 'a');\n  xclose (sock);\n  return 0;\n}", "target": 0}
{"code": "static bool pmc_overflow(unsigned long val)\n{\n\tif ((int)val < 0)\n\t\treturn true;\n\tif (__is_processor(PV_POWER7) && ((0x80000000 - val) <= 256))\n\t\treturn true;\n\treturn false;\n}", "target": 0}
{"code": "static inline void find_entity_for_char(\n\tunsigned int k,\n\tenum entity_charset charset,\n\tconst entity_stage1_row *table,\n\tconst unsigned char **entity,\n\tsize_t *entity_len,\n\tunsigned char *old,\n\tsize_t oldlen,\n\tsize_t *cursor)\n{\n\tunsigned stage1_idx = ENT_STAGE1_INDEX(k);\n\tconst entity_stage3_row *c;\n\tif (stage1_idx > 0x1D) {\n\t\t*entity     = NULL;\n\t\t*entity_len = 0;\n\t\treturn;\n\t}\n\tc = &table[stage1_idx][ENT_STAGE2_INDEX(k)][ENT_STAGE3_INDEX(k)];\n\tif (!c->ambiguous) {\n\t\t*entity     = (const unsigned char *)c->data.ent.entity;\n\t\t*entity_len = c->data.ent.entity_len;\n\t} else {\n\t\tsize_t\t cursor_before\t= *cursor;\n\t\tint\t\t status\t\t\t= SUCCESS;\n\t\tunsigned next_char;\n\t\tif (!(*cursor < oldlen))\n\t\t\tgoto no_suitable_2nd;\n\t\tnext_char = get_next_char(charset, old, oldlen, cursor, &status); \n\t\tif (status == FAILURE)\n\t\t\tgoto no_suitable_2nd;\n\t\t{\n\t\t\tconst entity_multicodepoint_row *s, *e;\n\t\t\ts = &c->data.multicodepoint_table[1];\n\t\t\te = s - 1 + c->data.multicodepoint_table[0].leading_entry.size;\n\t\t\tfor ( ; s <= e; s++) {\n\t\t\t\tif (s->normal_entry.second_cp == next_char) {\n\t\t\t\t\t*entity     = s->normal_entry.entity;\n\t\t\t\t\t*entity_len = s->normal_entry.entity_len;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nno_suitable_2nd:\n\t\t*cursor = cursor_before;\n\t\t*entity = (const unsigned char *)\n\t\t\tc->data.multicodepoint_table[0].leading_entry.default_entity;\n\t\t*entity_len = c->data.multicodepoint_table[0].leading_entry.default_entity_len;\n\t}\t\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    StagingMap<Ordered>* map = nullptr;\n    OP_REQUIRES_OK(ctx, GetStagingMap(ctx, def(), &map));\n    core::ScopedUnref scope(map);\n    typename StagingMap<Ordered>::OptionalTuple tuple;\n    const Tensor* key_tensor;\n    const Tensor* indices_tensor;\n    OpInputList values_tensor;\n    OP_REQUIRES_OK(ctx, ctx->input(\"key\", &key_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input(\"indices\", &indices_tensor));\n    OP_REQUIRES_OK(ctx, ctx->input_list(\"values\", &values_tensor));\n    OP_REQUIRES(ctx, key_tensor->NumElements() > 0,\n                errors::InvalidArgument(\"key must not be empty\"));\n    OP_REQUIRES(ctx, key_tensor->NumElements() == 1,\n                errors::InvalidArgument(\n                    \"key must be an int64 scalar, got tensor with shape: \",\n                    key_tensor->shape()));\n    Tensor key(*key_tensor);\n    for (std::size_t i = 0; i < values_tensor.size(); ++i) {\n      tuple.push_back(values_tensor[i]);\n    }\n    OP_REQUIRES_OK(ctx, map->put(&key, indices_tensor, &tuple));\n  }", "target": 0}
{"code": "dirserv_set_cached_directory(const char *directory, time_t published,\n                             int is_running_routers)\n{\n  time_t now = time(NULL);\n  if (is_running_routers) {\n    if (published >= now - MAX_V1_RR_AGE)\n      set_cached_dir(&cached_runningrouters, tor_strdup(directory), published);\n  } else {\n    if (published >= now - MAX_V1_DIRECTORY_AGE) {\n      cached_dir_decref(cached_directory);\n      cached_directory = new_cached_dir(tor_strdup(directory), published);\n    }\n  }\n}", "target": 0}
{"code": "int net_get(int s, void *arg, int *len)\n{\n\tstruct net_hdr nh;\n\tint plen;\n\tif (net_read_exact(s, &nh, sizeof(nh)) == -1)\n        {\n\t\treturn -1;\n        }\n\tplen = ntohl(nh.nh_len);\n\tif (!(plen <= *len))\n\t\tprintf(\"PLEN %d type %d len %d\\n\",\n\t\t\tplen, nh.nh_type, *len);\n\tassert(plen <= *len); \n\t*len = plen;\n\tif ((*len) && (net_read_exact(s, arg, *len) == -1))\n        {\n            return -1;\n        }\n\treturn nh.nh_type;\n}", "target": 1}
{"code": "static void draw_block_rectangle(uint8_t *buf, int sx, int sy, int w, int h, ptrdiff_t stride, int color)\n{\n    for (int x = sx; x < sx + w; x++)\n        buf[x] = color;\n    for (int y = sy; y < sy + h; y++) {\n        buf[sx] = color;\n        buf[sx + w - 1] = color;\n        buf += stride;\n    }\n    for (int x = sx; x < sx + w; x++)\n        buf[x] = color;\n}", "target": 1}
{"code": "NOEXPORT void reload_config() {\n    static int delay=10; \n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif \n    if(options_parse(CONF_RELOAD)) {\n        s_log(LOG_ERR, \"Failed to reload the configuration file\");\n        return;\n    }\n    unbind_ports();\n    log_flush(LOG_MODE_BUFFER);\n#ifdef HAVE_CHROOT\n    if(global_options.chroot_dir && stat(\"/dev/log\", &sb))\n        log_close(SINK_OUTFILE);\n    else\n#endif \n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    options_free();\n    options_apply();\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    if(bind_ports() | exec_connect_start()) {\n        s_poll_sleep(delay/1000, delay%1000); \n        signal_post(SIGNAL_RELOAD_CONFIG); \n        delay*=2;\n        if(delay > 10000) \n            delay=10000;\n    } else {\n        delay=10; \n    }\n}", "target": 1}
{"code": "static inline bool crypto_shash_alg_has_setkey(struct shash_alg *alg)\n{\n\treturn alg->setkey != shash_no_setkey;\n}", "target": 0}
{"code": "QStringList QODBCDriver::tables(QSql::TableType type) const\n{\n    Q_D(const QODBCDriver);\n    QStringList tl;\n    if (!isOpen())\n        return tl;\n    SQLHANDLE hStmt;\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::tables: Unable to allocate handle\"_L1, d);\n        return tl;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    QStringList tableType;\n    if (type & QSql::Tables)\n        tableType += \"TABLE\"_L1;\n    if (type & QSql::Views)\n        tableType += \"VIEW\"_L1;\n    if (type & QSql::SystemTables)\n        tableType += \"SYSTEM TABLE\"_L1;\n    if (tableType.isEmpty())\n        return tl;\n    QString joinedTableTypeString = tableType.join(u',');\n    r = SQLTables(hStmt,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   toSQLTCHAR(joinedTableTypeString).data(),\n                   joinedTableTypeString.length() );\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::tables Unable to execute table list\"_L1, d);\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r != SQL_NO_DATA) {\n        qWarning() << \"QODBCDriver::tables failed to retrieve table/view list: (\" << r << \",\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << \")\";\n        return QStringList();\n    }\n    while (r == SQL_SUCCESS) {\n        tl.append(qGetStringData(hStmt, 2, -1, d->unicode).toString());\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle\"_L1 + QString::number(r), d);\n    return tl;\n}", "target": 1}
{"code": "        unsigned int GetU32BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            return nRes;\n        }", "target": 1}
{"code": "crm_send_tls(gnutls_session * session, const char *buf, size_t len)\n{\n    const char *unsent = buf;\n    int rc = 0;\n    int total_send;\n    if (buf == NULL) {\n        return -1;\n    }\n    total_send = len;\n    crm_trace(\"Message size: %d\", len);\n    while (TRUE) {\n        rc = gnutls_record_send(*session, unsent, len);\n        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {\n            crm_debug(\"Retry\");\n        } else if (rc < 0) {\n            crm_err(\"Connection terminated rc = %d\", rc);\n            break;\n        } else if (rc < len) {\n            crm_debug(\"Only sent %d of %d bytes\", rc, len);\n            len -= rc;\n            unsent += rc;\n        } else {\n            crm_debug(\"Sent %d bytes\", rc);\n            break;\n        }\n    }\n    return rc < 0 ? rc : total_send;\n}", "target": 0}
{"code": "static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {\n    if (bind(s,sa,len) == -1) {\n        anetSetError(err, \"bind: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    if (listen(s, backlog) == -1) {\n        anetSetError(err, \"listen: %s\", strerror(errno));\n        close(s);\n        return ANET_ERR;\n    }\n    return ANET_OK;\n}", "target": 1}
{"code": "static void destroy_surface(struct swaylock_surface *surface) {\n\twl_list_remove(&surface->link);\n\tif (surface->layer_surface != NULL) {\n\t\tzwlr_layer_surface_v1_destroy(surface->layer_surface);\n\t}\n\tif (surface->ext_session_lock_surface_v1 != NULL) {\n\t\text_session_lock_surface_v1_destroy(surface->ext_session_lock_surface_v1);\n\t}\n\tif (surface->surface != NULL) {\n\t\twl_surface_destroy(surface->surface);\n\t}\n\tdestroy_buffer(&surface->buffers[0]);\n\tdestroy_buffer(&surface->buffers[1]);\n\tdestroy_buffer(&surface->indicator_buffers[0]);\n\tdestroy_buffer(&surface->indicator_buffers[1]);\n\twl_output_destroy(surface->output);\n\tfree(surface);\n}", "target": 0}
{"code": "static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,\n                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)\n{\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn FALSE;\n\treturn ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),\n\t                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));\n}", "target": 1}
{"code": "uint64_t countBytesForTest(const HeaderMapImpl& headers) {\n  uint64_t byte_size = 0;\n  headers.iterate(\n      [](const Http::HeaderEntry& header, void* context) -> Http::HeaderMap::Iterate {\n        auto* byte_size = static_cast<uint64_t*>(context);\n        *byte_size += header.key().getStringView().size() + header.value().getStringView().size();\n        return Http::HeaderMap::Iterate::Continue;\n      },\n      &byte_size);\n  return byte_size;\n}", "target": 0}
{"code": "static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unlinked)\n{\n\tif (sk->sk_send_head == skb_unlinked)\n\t\tsk->sk_send_head = NULL;\n\tif (tcp_sk(sk)->highest_sack == skb_unlinked)\n\t\ttcp_sk(sk)->highest_sack = NULL;\n}", "target": 0}
{"code": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\tif (border < 0) {\n\t\treturn;\n\t}\n\tleftLimit = (-1);\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;\n\t}\n\tif (y >= im->sy) {\n\t\ty = im->sy - 1;\n\t} else if (y < 0) {\n\t\ty = 0;\n\t}\n\tfor (i = x; (i >= 0); i--) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\tleftLimit = i;\n\t}\n\tif (leftLimit == (-1)) {\n\t\tim->alphaBlendingFlag = restoreAlphaBleding;\n\t\treturn;\n\t}\n\trightLimit = x;\n\tfor (i = (x + 1); (i < im->sx); i++) {\n\t\tif (gdImageGetPixel (im, i, y) == border) {\n\t\t\tbreak;\n\t\t}\n\t\tgdImageSetPixel (im, i, y, color);\n\t\trightLimit = i;\n\t}\n\tif (y > 0) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c;\n\t\t\tc = gdImageGetPixel (im, i, y - 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y - 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (y < ((im->sy) - 1)) {\n\t\tlastBorder = 1;\n\t\tfor (i = leftLimit; (i <= rightLimit); i++) {\n\t\t\tint c = gdImageGetPixel (im, i, y + 1);\n\t\t\tif (lastBorder) {\n\t\t\t\tif ((c != border) && (c != color)) {\n\t\t\t\t\tgdImageFillToBorder (im, i, y + 1, border, color);\n\t\t\t\t\tlastBorder = 0;\n\t\t\t\t}\n\t\t\t} else if ((c == border) || (c == color)) {\n\t\t\t\tlastBorder = 1;\n\t\t\t}\n\t\t}\n\t}\n\tim->alphaBlendingFlag = restoreAlphaBleding;\n}", "target": 1}
{"code": "void RenderFrameHostImpl::OnCrossSiteResponse(\n    const GlobalRequestID& global_request_id,\n    scoped_ptr<CrossSiteTransferringRequest> cross_site_transferring_request,\n    const std::vector<GURL>& transfer_url_chain,\n    const Referrer& referrer,\n    PageTransition page_transition,\n    bool should_replace_current_entry) {\n  frame_tree_node_->render_manager()->OnCrossSiteResponse(\n      this, global_request_id, cross_site_transferring_request.Pass(),\n      transfer_url_chain, referrer, page_transition,\n      should_replace_current_entry);\n}", "target": 0}
{"code": "inline int TensorProtoDataSize<Eigen::half>(const TensorProto& t) {\n  return t.half_val_size();\n}", "target": 0}
{"code": "hybiReturnData(char *dst, int len, ws_ctx_t *wsctx, int *nWritten)\n{\n  int nextState = WS_HYBI_STATE_ERR;\n  if (wsctx->readlen > 0) {\n    if (wsctx->readlen > len) {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", len, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, len);\n      *nWritten = len;\n      wsctx->readlen -= len;\n      wsctx->readPos += len;\n      nextState = WS_HYBI_STATE_DATA_AVAILABLE;\n    } else {\n      rfbLog(\"copy to %d bytes to dst buffer; readPos=%p, readLen=%d\\n\", wsctx->readlen, wsctx->readPos, wsctx->readlen);\n      memcpy(dst, wsctx->readPos, wsctx->readlen);\n      *nWritten = wsctx->readlen;\n      wsctx->readlen = 0;\n      wsctx->readPos = NULL;\n      if (hybiRemaining(wsctx) == 0) {\n        nextState = WS_HYBI_STATE_FRAME_COMPLETE;\n      } else {\n        nextState = WS_HYBI_STATE_DATA_NEEDED;\n      }\n    }\n    rfbLog(\"after copy: readPos=%p, readLen=%d\\n\", wsctx->readPos, wsctx->readlen);\n  } else if (wsctx->hybiDecodeState == WS_HYBI_STATE_CLOSE_REASON_PENDING) {\n    nextState = WS_HYBI_STATE_CLOSE_REASON_PENDING;\n  }\n  return nextState;\n}", "target": 0}
{"code": "NOEXPORT char *base64(int encode, const char *in, int len) {\n    BIO *bio, *b64;\n    char *out;\n    int n;\n    b64=BIO_new(BIO_f_base64());\n    if(!b64)\n        return NULL;\n    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);\n    bio=BIO_new(BIO_s_mem());\n    if(!bio) {\n        str_free(b64);\n        return NULL;\n    }\n    if(encode)\n        bio=BIO_push(b64, bio);\n    BIO_write(bio, in, len);\n    (void)BIO_flush(bio); \n    if(encode) {\n        bio=BIO_pop(bio);\n        BIO_free(b64);\n    } else {\n        bio=BIO_push(b64, bio);\n    }\n    n=BIO_pending(bio);\n    out=str_alloc(n<32?32:(size_t)n+1);\n    n=BIO_read(bio, out, n);\n    if(n<0) {\n        BIO_free_all(bio);\n        str_free(out);\n        return NULL;\n    }\n    BIO_free_all(bio);\n    return out;\n}", "target": 1}
{"code": "mm_answer_pam_init_ctx(int sock, Buffer *m)\n{\n\tdebug3(\"%s\", __func__);\n\tauthctxt->user = buffer_get_string(m, NULL);\n\tsshpam_ctxt = (sshpam_device.init_ctx)(authctxt);\n\tsshpam_authok = NULL;\n\tbuffer_clear(m);\n\tif (sshpam_ctxt != NULL) {\n\t\tmonitor_permit(mon_dispatch, MONITOR_REQ_PAM_FREE_CTX, 1);\n\t\tbuffer_put_int(m, 1);\n\t} else {\n\t\tbuffer_put_int(m, 0);\n\t}\n\tmm_request_send(sock, MONITOR_ANS_PAM_INIT_CTX, m);\n\treturn (0);\n}", "target": 1}
{"code": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlSchemaParserCtxtPtr ctx;\n  xmlSchemaPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc;\n  if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) {\n    rb_raise(rb_eArgError, \"Creating a schema from a document that has blank nodes exposed to Ruby is dangerous\");\n  }\n  ctx = xmlSchemaNewDocParserCtxt(doc);\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS\n  xmlSchemaSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlSchemaParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlSchemaFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n  return Qnil;\n}", "target": 1}
{"code": "purgekeys_2_svc(purgekeys_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    funcname = \"kadm5_purgekeys\";\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (!cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp)\n         || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,\n                                arg->princ, NULL))) {\n        ret.code = KADM5_AUTH_MODIFY;\n        log_unauth(funcname, prime_arg, &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_purgekeys((void *)handle, arg->princ,\n                                   arg->keepkvno);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "  bool matches(const Http::RequestHeaderMap& headers) const override {\n    if (BaseMatcherImpl::matchRoute(headers)) {\n      if (headers.Path() == nullptr) {\n        return false;\n      }\n      const Http::HeaderString& path = headers.Path()->value();\n      const absl::string_view query_string = Http::Utility::findQueryStringStart(path);\n      absl::string_view path_view = path.getStringView();\n      path_view.remove_suffix(query_string.length());\n      if (path_matcher_->match(path_view)) {\n        ENVOY_LOG(debug, \"Regex requirement '{}' matched.\", regex_str_);\n        return true;\n      }\n    }\n    return false;\n  }", "target": 0}
{"code": "void hsr_del_node(struct list_head *self_node_db)\n{\n\tstruct hsr_node *node;\n\trcu_read_lock();\n\tnode = list_first_or_null_rcu(self_node_db, struct hsr_node, mac_list);\n\trcu_read_unlock();\n\tif (node) {\n\t\tlist_del_rcu(&node->mac_list);\n\t\tkfree(node);\n\t}\n}", "target": 0}
{"code": "inline int NumDimensions(const TfLiteTensor* t) { return t->dims->size; }", "target": 1}
{"code": "void AAHD::refine_hv_dirs()\n{\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_hv_dirs(i, i & 1);\n  }\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_hv_dirs(i, (i & 1) ^ 1);\n  }\n  for (int i = 0; i < libraw.imgdata.sizes.iheight; ++i)\n  {\n    refine_ihv_dirs(i);\n  }\n}", "target": 0}
{"code": "static TEE_Result do_allocate_publickey(struct ecc_public_key *key,\n\t\t\t\t\tuint32_t type __unused,\n\t\t\t\t\tsize_t size_bits)\n{\n\tECC_TRACE(\"Allocate Public Key of %zu bits\", size_bits);\n\tmemset(key, 0, sizeof(*key));\n\tkey->x = crypto_bignum_allocate(size_bits);\n\tif (!key->x)\n\t\tgoto err;\n\tkey->y = crypto_bignum_allocate(size_bits);\n\tif (!key->y)\n\t\tgoto err;\n\treturn TEE_SUCCESS;\nerr:\n\tECC_TRACE(\"Allocation error\");\n\tcrypto_bignum_free(key->x);\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}", "target": 1}
{"code": "void CharCodeToUnicode::addMapping(CharCode code, char *uStr, int n,\n\t\t\t\t   int offset) {\n  CharCode oldLen, i;\n  Unicode u;\n  char uHex[5];\n  int j;\n  if (code >= mapLen) {\n    oldLen = mapLen;\n    mapLen = (code + 256) & ~255;\n    map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode));\n    for (i = oldLen; i < mapLen; ++i) {\n      map[i] = 0;\n    }\n  }\n  if (n <= 4) {\n    if (sscanf(uStr, \"%x\", &u) != 1) {\n      error(-1, \"Illegal entry in ToUnicode CMap\");\n      return;\n    }\n    map[code] = u + offset;\n  } else {\n    if (sMapLen >= sMapSize) {\n      sMapSize = sMapSize + 16;\n      sMap = (CharCodeToUnicodeString *)\n\t       greallocn(sMap, sMapSize, sizeof(CharCodeToUnicodeString));\n    }\n    map[code] = 0;\n    sMap[sMapLen].c = code;\n    sMap[sMapLen].len = n / 4;\n    for (j = 0; j < sMap[sMapLen].len && j < maxUnicodeString; ++j) {\n      strncpy(uHex, uStr + j*4, 4);\n      uHex[4] = '\\0';\n      if (sscanf(uHex, \"%x\", &sMap[sMapLen].u[j]) != 1) {\n\terror(-1, \"Illegal entry in ToUnicode CMap\");\n      }\n    }\n    sMap[sMapLen].u[sMap[sMapLen].len - 1] += offset;\n    ++sMapLen;\n  }\n}", "target": 1}
{"code": "static void nfs4_close_done(struct rpc_task *task, void *data)\n{\n\tstruct nfs4_closedata *calldata = data;\n\tstruct nfs4_state *state = calldata->state;\n\tstruct nfs_server *server = NFS_SERVER(calldata->inode);\n\tif (RPC_ASSASSINATED(task))\n\t\treturn;\n\tswitch (task->tk_status) {\n\t\tcase 0:\n\t\t\tnfs_set_open_stateid(state, &calldata->res.stateid, 0);\n\t\t\trenew_lease(server, calldata->timestamp);\n\t\t\tbreak;\n\t\tcase -NFS4ERR_STALE_STATEID:\n\t\tcase -NFS4ERR_OLD_STATEID:\n\t\tcase -NFS4ERR_BAD_STATEID:\n\t\tcase -NFS4ERR_EXPIRED:\n\t\t\tif (calldata->arg.open_flags == 0)\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (nfs4_async_handle_error(task, server, state) == -EAGAIN) {\n\t\t\t\trpc_restart_call(task);\n\t\t\t\treturn;\n\t\t\t}\n\t}\n\tnfs_refresh_inode(calldata->inode, calldata->res.fattr);\n}", "target": 1}
{"code": "static int seed_from_timestamp_and_pid(uint32_t *seed) {\n#ifdef HAVE_GETTIMEOFDAY\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    *seed = (uint32_t)tv.tv_sec ^ (uint32_t)tv.tv_usec;\n#else\n    *seed = (uint32_t)time(NULL);\n#endif\n#if defined(_WIN32)\n    *seed ^= (uint32_t)_getpid();\n#elif defined(HAVE_GETPID)\n    *seed ^= (uint32_t)getpid();\n#endif\n    return 0;\n}", "target": 0}
{"code": "static int ax25_create(struct net *net, struct socket *sock, int protocol,\n\t\t       int kern)\n{\n\tstruct sock *sk;\n\tax25_cb *ax25;\n\tif (protocol < 0 || protocol > SK_PROTOCOL_MAX)\n\t\treturn -EINVAL;\n\tif (!net_eq(net, &init_net))\n\t\treturn -EAFNOSUPPORT;\n\tswitch (sock->type) {\n\tcase SOCK_DGRAM:\n\t\tif (protocol == 0 || protocol == PF_AX25)\n\t\t\tprotocol = AX25_P_TEXT;\n\t\tbreak;\n\tcase SOCK_SEQPACKET:\n\t\tswitch (protocol) {\n\t\tcase 0:\n\t\tcase PF_AX25:\t\n\t\t\tprotocol = AX25_P_TEXT;\n\t\t\tbreak;\n\t\tcase AX25_P_SEGMENT:\n#ifdef CONFIG_INET\n\t\tcase AX25_P_ARP:\n\t\tcase AX25_P_IP:\n#endif\n#ifdef CONFIG_NETROM\n\t\tcase AX25_P_NETROM:\n#endif\n#ifdef CONFIG_ROSE\n\t\tcase AX25_P_ROSE:\n#endif\n\t\t\treturn -ESOCKTNOSUPPORT;\n#ifdef CONFIG_NETROM_MODULE\n\t\tcase AX25_P_NETROM:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_NETROM))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n\t\t\tbreak;\n#endif\n#ifdef CONFIG_ROSE_MODULE\n\t\tcase AX25_P_ROSE:\n\t\t\tif (ax25_protocol_is_registered(AX25_P_ROSE))\n\t\t\t\treturn -ESOCKTNOSUPPORT;\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase SOCK_RAW:\n\t\tbreak;\n\tdefault:\n\t\treturn -ESOCKTNOSUPPORT;\n\t}\n\tsk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern);\n\tif (sk == NULL)\n\t\treturn -ENOMEM;\n\tax25 = ax25_sk(sk)->cb = ax25_create_cb();\n\tif (!ax25) {\n\t\tsk_free(sk);\n\t\treturn -ENOMEM;\n\t}\n\tsock_init_data(sock, sk);\n\tsk->sk_destruct = ax25_free_sock;\n\tsock->ops    = &ax25_proto_ops;\n\tsk->sk_protocol = protocol;\n\tax25->sk    = sk;\n\treturn 0;\n}", "target": 0}
{"code": "hybiPayloadStart(ws_ctx_t *wsctx)\n{\n  return wsctx->codeBufDecode + wsctx->header.headerLen;\n}", "target": 0}
{"code": "gbk_mbc_case_fold(OnigCaseFoldType flag, const UChar** pp, const UChar* end,\n                    UChar* lower, OnigEncoding enc)\n{\n  return onigenc_mbn_mbc_case_fold(enc, flag,\n                                   pp, end, lower);\n}", "target": 0}
{"code": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\treturn surface;\n}", "target": 1}
{"code": "static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,\n\t\t\t\t      void *key)\n{\n\tstruct unix_sock *u;\n\twait_queue_head_t *u_sleep;\n\tu = container_of(q, struct unix_sock, peer_wake);\n\t__remove_wait_queue(&unix_sk(u->peer_wake.private)->peer_wait,\n\t\t\t    q);\n\tu->peer_wake.private = NULL;\n\tu_sleep = sk_sleep(&u->sk);\n\tif (u_sleep)\n\t\twake_up_interruptible_poll(u_sleep, key);\n\treturn 0;\n}", "target": 0}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, 1, output->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, 1, input->dims->data[0]);\n  TF_LITE_ENSURE_EQ(context, 1, input->dims->data[1]);\n  TF_LITE_ENSURE_EQ(context, 1, output->dims->data[2]);\n  TF_LITE_ENSURE_EQ(context, 1, input->dims->data[2]);\n  TF_LITE_ENSURE_EQ(context, output->dims->data[3], input->dims->data[3]);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteInt8);\n  TFLITE_DCHECK_LE(op_data_counter, kMaxOpDataSize);\n  OpData* op_data = &op_data_array[op_data_counter++];\n  if (output->dims->data[1] == 5) {\n    op_data->cycles_max = 1;\n  } else {\n    op_data->cycles_max = 2;\n  }\n  op_data->cycles_until_run = op_data->cycles_max;\n  node->user_data = op_data;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "idn2_to_ascii_4i (const uint32_t * input, size_t inlen, char * output, int flags)\n{\n  uint32_t *input_u32;\n  uint8_t *input_u8, *output_u8;\n  size_t length;\n  int rc;\n  if (!input)\n    {\n      if (output)\n\t*output = 0;\n      return IDN2_OK;\n    }\n  input_u32 = (uint32_t *) malloc ((inlen + 1) * sizeof(uint32_t));\n  if (!input_u32)\n    return IDN2_MALLOC;\n  u32_cpy (input_u32, input, inlen);\n  input_u32[inlen] = 0;\n  input_u8 = u32_to_u8 (input_u32, inlen + 1, NULL, &length);\n  free (input_u32);\n  if (!input_u8)\n    {\n      if (errno == ENOMEM)\n\treturn IDN2_MALLOC;\n      return IDN2_ENCODING_ERROR;\n    }\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n  if (rc == IDN2_OK)\n    {\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n      free(output_u8);\n    }\n  return rc;\n}", "target": 1}
{"code": "virDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n    virResetLastError();\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n    if (dom->conn->driver->domainGetTime) {\n        int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n    virReportUnsupportedError();\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}", "target": 0}
{"code": "xml_read_notification(xmlTextReaderPtr reader, void *arg)\n{\n\tstruct rdr_notification_ctx *ctx = arg;\n\txmlReaderTypes type;\n\txmlChar const *name;\n\tint error;\n\terror = 0;\n\tname = xmlTextReaderConstLocalName(reader);\n\ttype = xmlTextReaderNodeType(reader);\n\tswitch (type) {\n\tcase XML_READER_TYPE_ELEMENT:\n\t\tif (xmlStrEqual(name, BAD_CAST RRDP_ELEM_DELTA)) {\n\t\t\terror = parse_notification_delta(reader, ctx);\n\t\t} else if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_SNAPSHOT)) {\n\t\t\terror = parse_doc_data(reader, true, true,\n\t\t\t    &ctx->notification->snapshot);\n\t\t} else if (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {\n\t\t\terror = parse_global_data(reader,\n\t\t\t    &ctx->notification->global_data, NULL, 0);\n\t\t\trdr_notification_ctx_init(ctx);\n\t\t} else {\n\t\t\treturn pr_val_err(\"Unexpected '%s' element\", name);\n\t\t}\n\t\tbreak;\n\tcase XML_READER_TYPE_END_ELEMENT:\n\t\tif (xmlStrEqual(name, BAD_CAST RRDP_ELEM_NOTIFICATION)) {\n\t\t\terror = order_notification_deltas(ctx);\n\t\t\trdr_notification_ctx_cleanup(ctx);\n\t\t\treturn error; \n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (error) {\n\t\trdr_notification_ctx_cleanup(ctx);\n\t\treturn error;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "inline TfLiteTensor* GetMutableInput(const TfLiteContext* context,\n                                     const TfLiteNode* node, int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->inputs->size, node->inputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}", "target": 0}
{"code": "int nfc_disable_se(struct nfc_dev *dev, u32 se_idx)\n{\n\tstruct nfc_se *se;\n\tint rc;\n\tpr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\tdevice_lock(&dev->dev);\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->dev_up) {\n\t\trc = -ENODEV;\n\t\tgoto error;\n\t}\n\tif (!dev->ops->enable_se || !dev->ops->disable_se) {\n\t\trc = -EOPNOTSUPP;\n\t\tgoto error;\n\t}\n\tse = nfc_find_se(dev, se_idx);\n\tif (!se) {\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (se->state == NFC_SE_DISABLED) {\n\t\trc = -EALREADY;\n\t\tgoto error;\n\t}\n\trc = dev->ops->disable_se(dev, se_idx);\n\tif (rc >= 0)\n\t\tse->state = NFC_SE_DISABLED;\nerror:\n\tdevice_unlock(&dev->dev);\n\treturn rc;\n}", "target": 1}
{"code": "static AMQP_VALUE test_on_transfer_received(void* context, TRANSFER_HANDLE transfer, uint32_t payload_size, const unsigned char* payload_bytes)\n{\n    (void)context;\n    test_on_transfer_received_transfer = transfer;\n    test_on_transfer_received_payload_size = payload_size;\n    memcpy(test_on_transfer_received_payload_bytes, payload_bytes, payload_size);\n    return (AMQP_VALUE)0x6000;\n}", "target": 0}
{"code": "TRIO_PRIVATE void TrioWriteString TRIO_ARGS5((self, string, flags, width, precision),\n                                             trio_class_t* self, TRIO_CONST char* string,\n                                             trio_flags_t flags, int width, int precision)\n{\n\tint length;\n\tint ch;\n\tassert(VALID(self));\n\tassert(VALID(self->OutStream));\n\tif (string == NULL)\n\t{\n\t\tstring = internalNullString;\n\t\tlength = sizeof(internalNullString) - 1;\n#if TRIO_FEATURE_QUOTE\n\t\tflags &= (~FLAGS_QUOTE);\n#endif\n\t\twidth = 0;\n\t}\n\telse\n\t{\n\t\tif (precision == 0)\n\t\t{\n\t\t\tlength = trio_length(string);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlength = trio_length_max(string, precision);\n\t\t}\n\t}\n\tif ((NO_PRECISION != precision) && (precision < length))\n\t{\n\t\tlength = precision;\n\t}\n\twidth -= length;\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n\tif (!(flags & FLAGS_LEFTADJUST))\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n\twhile (length-- > 0)\n\t{\n\t\tch = (int)((unsigned char)(*string++));\n\t\tTrioWriteStringCharacter(self, ch, flags);\n\t}\n\tif (flags & FLAGS_LEFTADJUST)\n\t{\n\t\twhile (width-- > 0)\n\t\t\tself->OutStream(self, CHAR_ADJUST);\n\t}\n#if TRIO_FEATURE_QUOTE\n\tif (flags & FLAGS_QUOTE)\n\t\tself->OutStream(self, CHAR_QUOTE);\n#endif\n}", "target": 1}
{"code": "void sctp_generate_heartbeat_event(unsigned long data)\n{\n\tint error = 0;\n\tstruct sctp_transport *transport = (struct sctp_transport *) data;\n\tstruct sctp_association *asoc = transport->asoc;\n\tstruct net *net = sock_net(asoc->base.sk);\n\tbh_lock_sock(asoc->base.sk);\n\tif (sock_owned_by_user(asoc->base.sk)) {\n\t\tpr_debug(\"%s: sock is busy\\n\", __func__);\n\t\tif (!mod_timer(&transport->hb_timer, jiffies + (HZ/20)))\n\t\t\tsctp_transport_hold(transport);\n\t\tgoto out_unlock;\n\t}\n\tif (transport->dead)\n\t\tgoto out_unlock;\n\terror = sctp_do_sm(net, SCTP_EVENT_T_TIMEOUT,\n\t\t\t   SCTP_ST_TIMEOUT(SCTP_EVENT_TIMEOUT_HEARTBEAT),\n\t\t\t   asoc->state, asoc->ep, asoc,\n\t\t\t   transport, GFP_ATOMIC);\n\tif (error)\n\t\tasoc->base.sk->sk_err = -error;\nout_unlock:\n\tbh_unlock_sock(asoc->base.sk);\n\tsctp_transport_put(transport);\n}", "target": 1}
{"code": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc;\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlRelaxNGParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "valid_weeknum_sub(int argc, VALUE *argv, VALUE klass, int need_jd)\n{\n    VALUE nth, y;\n    int w, d, f, ry, rw, rd;\n    double sg;\n    y = argv[0];\n    w = NUM2INT(argv[1]);\n    d = NUM2INT(argv[2]);\n    f = NUM2INT(argv[3]);\n    sg = NUM2DBL(argv[4]);\n    valid_sg(sg);\n    {\n\tint rjd, ns;\n\tVALUE rjd2;\n\tif (!valid_weeknum_p(y, w, d, f, sg,\n\t\t\t     &nth, &ry,\n\t\t\t     &rw, &rd, &rjd,\n\t\t\t     &ns))\n\t    return Qnil;\n\tif (!need_jd)\n\t    return INT2FIX(0); \n\tencode_jd(nth, rjd, &rjd2);\n\treturn rjd2;\n    }\n}", "target": 0}
{"code": "int htc_connect_service(struct htc_target *target,\n\t\t     struct htc_service_connreq *service_connreq,\n\t\t     enum htc_endpoint_id *conn_rsp_epid)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_conn_svc_msg *conn_msg;\n\tint ret;\n\tunsigned long time_left;\n\tendpoint = get_next_avail_ep(target->endpoint);\n\tif (!endpoint) {\n\t\tdev_err(target->dev, \"Endpoint is not available for service %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\treturn -EINVAL;\n\t}\n\tendpoint->service_id = service_connreq->service_id;\n\tendpoint->max_txqdepth = service_connreq->max_send_qdepth;\n\tendpoint->ul_pipeid = service_to_ulpipe(service_connreq->service_id);\n\tendpoint->dl_pipeid = service_to_dlpipe(service_connreq->service_id);\n\tendpoint->ep_callbacks = service_connreq->ep_callbacks;\n\tskb = alloc_skb(sizeof(struct htc_conn_svc_msg) +\n\t\t\t    sizeof(struct htc_frame_hdr), GFP_ATOMIC);\n\tif (!skb) {\n\t\tdev_err(target->dev, \"Failed to allocate buf to send\"\n\t\t\t\"service connect req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_reserve(skb, sizeof(struct htc_frame_hdr));\n\tconn_msg = skb_put(skb, sizeof(struct htc_conn_svc_msg));\n\tconn_msg->service_id = cpu_to_be16(service_connreq->service_id);\n\tconn_msg->msg_id = cpu_to_be16(HTC_MSG_CONNECT_SERVICE_ID);\n\tconn_msg->con_flags = cpu_to_be16(service_connreq->con_flags);\n\tconn_msg->dl_pipeid = endpoint->dl_pipeid;\n\tconn_msg->ul_pipeid = endpoint->ul_pipeid;\n\tret = htc_issue_send(target, skb, skb->len, 0, ENDPOINT0);\n\tif (ret)\n\t\tgoto err;\n\ttime_left = wait_for_completion_timeout(&target->cmd_wait, HZ);\n\tif (!time_left) {\n\t\tdev_err(target->dev, \"Service connection timeout for: %d\\n\",\n\t\t\tservice_connreq->service_id);\n\t\tkfree_skb(skb);\n\t\treturn -ETIMEDOUT;\n\t}\n\t*conn_rsp_epid = target->conn_rsp_epid;\n\treturn 0;\nerr:\n\tkfree_skb(skb);\n\treturn ret;\n}", "target": 0}
{"code": "static void lwp_write_int64(FILE *fout, int64_t d) {\n  fwrite(&d, sizeof(d), 1, fout);\n  fflush(fout);\n}", "target": 0}
{"code": "void TEMPLATE(process_block_dec)(decoder_info_t *decoder_info,int size,int yposY,int xposY,int sub)\n{\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  stream_t *stream = decoder_info->stream;\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int split_flag = 0;\n  if (yposY >= height || xposY >= width)\n    return;\n  int decode_this_size = (yposY + size <= height) && (xposY + size <= width);\n  int decode_rectangular_size = !decode_this_size && frame_type != I_FRAME;\n  int bit_start = stream->bitcnt;\n  int mode = MODE_SKIP;\n  block_context_t block_context;\n  TEMPLATE(find_block_contexts)(yposY, xposY, height, width, size, decoder_info->deblock_data, &block_context, decoder_info->use_block_contexts);\n  decoder_info->block_context = &block_context;\n  split_flag = decode_super_mode(decoder_info,size,decode_this_size);\n  mode = decoder_info->mode;\n  if (size == (1<<decoder_info->log2_sb_size) && (split_flag || mode != MODE_SKIP) && decoder_info->max_delta_qp > 0) {\n    int delta_qp = read_delta_qp(stream);\n    int prev_qp;\n    if (yposY == 0 && xposY == 0)\n      prev_qp = decoder_info->frame_info.qp;\n    else\n      prev_qp = decoder_info->frame_info.qpb;\n    decoder_info->frame_info.qpb = prev_qp + delta_qp;\n  }\n  decoder_info->bit_count.super_mode[decoder_info->bit_count.stat_frame_type] += (stream->bitcnt - bit_start);\n  if (split_flag){\n    int new_size = size/2;\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+1*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+1*new_size,sub);\n  }\n  else if (decode_this_size || decode_rectangular_size){\n    decode_block(decoder_info,size,yposY,xposY,sub);\n  }\n}", "target": 1}
{"code": "static int bson_append_string_base( bson *b, const char *name,\n                                    const char *value, int len, bson_type type ) {\n    int sl = len + 1;\n    if ( bson_check_string( b, ( const char * )value, sl - 1 ) == BSON_ERROR )\n        return BSON_ERROR;\n    if ( bson_append_estart( b, type, name, 4 + sl ) == BSON_ERROR ) {\n        return BSON_ERROR;\n    }\n    bson_append32( b , &sl );\n    bson_append( b , value , sl - 1 );\n    bson_append( b , \"\\0\" , 1 );\n    return BSON_OK;\n}", "target": 1}
{"code": "static int jp2_bpcc_getdata(jp2_box_t *box, jas_stream_t *in)\n{\n\tjp2_bpcc_t *bpcc = &box->data.bpcc;\n\tunsigned int i;\n\tbpcc->bpcs = 0;\n\tbpcc->numcmpts = box->datalen;\n\tif (!(bpcc->bpcs = jas_alloc2(bpcc->numcmpts, sizeof(uint_fast8_t)))) {\n\t\treturn -1;\n\t}\n\tfor (i = 0; i < bpcc->numcmpts; ++i) {\n\t\tif (jp2_getuint8(in, &bpcc->bpcs[i])) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "*/\nMYSQL_PLUGIN_EXPORT\nchar *mysql_authentication_dialog_ask(MYSQL *mysql, int type,\n                                      const char *prompt,\n                                      char *buf, int buf_len)\n{\n  char *s=buf;\n  fputs(prompt, stdout);\n  fputs(\" \", stdout);\n  if (!fgets(buf, buf_len-1, stdin))\n    buf[0]= 0;\n  else if (buf[0] && (s= strend(buf))[-1] == '\\n')\n    s[-1]= 0;\n  for (s= buf; *s; s++)\n    fputc(type == 2 ? '*' : *s, stdout);\n  fputc('\\n', stdout);", "target": 0}
{"code": "char *compose_path(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tstatic char rpath[PATH_MAX];\n\tchar *name, *ptr;\n\tchar dir[PATH_MAX] = { 0 };\n\tstrlcpy(dir, ctrl->cwd, sizeof(dir));\n\tDBG(\"Compose path from cwd: %s, arg: %s\", ctrl->cwd, path ?: \"\");\n\tif (!path || !strlen(path))\n\t\tgoto check;\n\tif (path) {\n\t\tif (path[0] != '/') {\n\t\t\tif (dir[strlen(dir) - 1] != '/')\n\t\t\t\tstrlcat(dir, \"/\", sizeof(dir));\n\t\t}\n\t\tstrlcat(dir, path, sizeof(dir));\n\t}\ncheck:\n\twhile ((ptr = strstr(dir, \"\n\t\tmemmove(ptr, &ptr[1], strlen(&ptr[1]) + 1);\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\t\tDBG(\"Server path from CWD: %s\", dir);\n\t\tif (len > 0 && home[len - 1] == '/')\n\t\t\tlen--;\n\t\tmemmove(dir + len, dir, strlen(dir) + 1);\n\t\tmemcpy(dir, home, len);\n\t\tDBG(\"Resulting non-chroot path: %s\", dir);\n\t}\n\tif (!stat(dir, &st) && S_ISDIR(st.st_mode)) {\n\t\tif (!realpath(dir, rpath))\n\t\t\treturn NULL;\n\t} else {\n\t\tname = basename(path);\n\t\tptr = dirname(dir);\n\t\tmemset(rpath, 0, sizeof(rpath));\n\t\tif (!realpath(ptr, rpath)) {\n\t\t\tINFO(\"Failed realpath(%s): %m\", ptr);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (rpath[1] != 0)\n\t\t\tstrlcat(rpath, \"/\", sizeof(rpath));\n\t\tstrlcat(rpath, name, sizeof(rpath));\n\t}\n\tif (!chrooted && strncmp(dir, home, strlen(home))) {\n\t\tDBG(\"Failed non-chroot dir:%s vs home:%s\", dir, home);\n\t\treturn NULL;\n\t}\n\treturn rpath;\n}", "target": 1}
{"code": "static unsigned long mb2_cache_scan(struct shrinker *shrink,\n\t\t\t\t    struct shrink_control *sc)\n{\n\tint nr_to_scan = sc->nr_to_scan;\n\tstruct mb2_cache *cache = container_of(shrink, struct mb2_cache,\n\t\t\t\t\t      c_shrink);\n\tstruct mb2_cache_entry *entry;\n\tstruct hlist_bl_head *head;\n\tunsigned int shrunk = 0;\n\tspin_lock(&cache->c_lru_list_lock);\n\twhile (nr_to_scan-- && !list_empty(&cache->c_lru_list)) {\n\t\tentry = list_first_entry(&cache->c_lru_list,\n\t\t\t\t\t struct mb2_cache_entry, e_lru_list);\n\t\tlist_del_init(&entry->e_lru_list);\n\t\tcache->c_entry_count--;\n\t\tspin_unlock(&cache->c_lru_list_lock);\n\t\thead = entry->e_hash_list_head;\n\t\thlist_bl_lock(head);\n\t\tif (!hlist_bl_unhashed(&entry->e_hash_list)) {\n\t\t\thlist_bl_del_init(&entry->e_hash_list);\n\t\t\tatomic_dec(&entry->e_refcnt);\n\t\t}\n\t\thlist_bl_unlock(head);\n\t\tif (mb2_cache_entry_put(cache, entry))\n\t\t\tshrunk++;\n\t\tcond_resched();\n\t\tspin_lock(&cache->c_lru_list_lock);\n\t}\n\tspin_unlock(&cache->c_lru_list_lock);\n\treturn shrunk;\n}", "target": 0}
{"code": "static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,\n\t\t\t   unsigned long arg)\n{\n\tstruct multipath *m = (struct multipath *) ti->private;\n\tstruct block_device *bdev = NULL;\n\tfmode_t mode = 0;\n\tunsigned long flags;\n\tint r = 0;\n\tspin_lock_irqsave(&m->lock, flags);\n\tif (!m->current_pgpath)\n\t\t__choose_pgpath(m, 0);\n\tif (m->current_pgpath) {\n\t\tbdev = m->current_pgpath->path.dev->bdev;\n\t\tmode = m->current_pgpath->path.dev->mode;\n\t}\n\tif (m->queue_io)\n\t\tr = -EAGAIN;\n\telse if (!bdev)\n\t\tr = -EIO;\n\tspin_unlock_irqrestore(&m->lock, flags);\n\tif (!r && ti->len != i_size_read(bdev->bd_inode) >> SECTOR_SHIFT)\n\t\tr = scsi_verify_blk_ioctl(NULL, cmd);\n\treturn r ? : __blkdev_driver_ioctl(bdev, mode, cmd, arg);\n}", "target": 0}
{"code": "  inline Eigen::IndexList<Eigen::type2index<1>, int> OneByM(int m) {\n    Eigen::IndexList<Eigen::type2index<1>, int> ret;\n    ret.set(1, m);\n    return ret;\n  }", "target": 1}
{"code": "hb_map_clear (hb_map_t *map)\n{\n  if (unlikely (hb_object_is_immutable (map)))\n    return;\n  return map->clear ();\n}", "target": 1}
{"code": "bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tstruct bsg_device *bd = file->private_data;\n\tssize_t bytes_written;\n\tint ret;\n\tdprintk(\"%s: write %Zd bytes\\n\", bd->name, count);\n\tif (unlikely(segment_eq(get_fs(), KERNEL_DS)))\n\t\treturn -EINVAL;\n\tbsg_set_block(bd, file);\n\tbytes_written = 0;\n\tret = __bsg_write(bd, buf, count, &bytes_written,\n\t\t\t  file->f_mode & FMODE_WRITE);\n\t*ppos = bytes_written;\n\tif (!bytes_written || err_block_err(ret))\n\t\tbytes_written = ret;\n\tdprintk(\"%s: returning %Zd\\n\", bd->name, bytes_written);\n\treturn bytes_written;\n}", "target": 0}
{"code": "static inline void CleanupPDFInfo(PDFInfo *pdf_info)\n{\n  if (pdf_info->profile != (StringInfo *) NULL)\n    pdf_info->profile=DestroyStringInfo(pdf_info->profile);\n}", "target": 0}
{"code": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}", "target": 1}
{"code": "extract_argv (EvDocument *document, gint page)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tchar **argv;\n\tchar *command_line, *quoted_archive, *quoted_filename;\n\tGError *err = NULL;\n\tif (g_strrstr (comics_document->page_names->pdata[page], \"--checkpoint-action=\"))\n\t{\n\t\tg_warning (\"File unsupported\\n\");\n\t\tgtk_main_quit ();\n\t}\n        if (page >= comics_document->page_names->len)\n                return NULL;\n\tif (comics_document->regex_arg) {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename =\n\t\t\tcomics_regex_quote (comics_document->page_names->pdata[page]);\n\t} else {\n\t\tquoted_archive = g_shell_quote (comics_document->archive);\n\t\tquoted_filename = g_shell_quote (comics_document->page_names->pdata[page]);\n\t}\n\tcommand_line = g_strdup_printf (\"%s %s %s\",\n\t\t\t\t\tcomics_document->extract_command,\n\t\t\t\t\tquoted_archive,\n\t\t\t\t\tquoted_filename);\n\tg_free (quoted_archive);\n\tg_free (quoted_filename);\n\tg_shell_parse_argv (command_line, NULL, &argv, &err);\n\tg_free (command_line);\n\tif (err) {\n\t\tg_warning (_(\"Error %s\"), err->message);\n\t\tg_error_free (err);\n\t\treturn NULL;\n\t}\n\treturn argv;\n}", "target": 1}
{"code": "static UINT urb_isoch_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                               UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                               int transferDir)\n{\n\tUINT32 EndpointAddress;\n\tUINT32 PipeHandle, TransferFlags, StartFrame, NumberOfPackets;\n\tUINT32 ErrorCount, OutputBufferSize;\n\tBYTE* packetDescriptorData;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\tif (!pdev || !callback || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(s, PipeHandle);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tStream_Read_UINT32(s, TransferFlags);   \n\tStream_Read_UINT32(s, StartFrame);      \n\tStream_Read_UINT32(s, NumberOfPackets); \n\tStream_Read_UINT32(s, ErrorCount);      \n\tif (Stream_GetRemainingLength(s) < NumberOfPackets * 12 + 4)\n\t\treturn ERROR_INVALID_DATA;\n\tpacketDescriptorData = Stream_Pointer(s);\n\tStream_Seek(s, NumberOfPackets * 12);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (!Stream_CheckAndLogRequiredLength(TAG, s, OutputBufferSize))\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\treturn pdev->isoch_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, StartFrame,\n\t    ErrorCount, noAck, packetDescriptorData, NumberOfPackets, OutputBufferSize,\n\t    (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_isoch_transfer_cb, 2000);\n}", "target": 0}
{"code": "static void skip_metadata(struct pstore *ps)\n{\n\tuint32_t stride = ps->exceptions_per_area + 1;\n\tchunk_t next_free = ps->next_free;\n\tif (sector_div(next_free, stride) == NUM_SNAPSHOT_HDR_CHUNKS)\n\t\tps->next_free++;\n}", "target": 0}
{"code": "static unsigned int caif_poll(struct file *file,\n\t\t\t\tstruct socket *sock, poll_table *wait)\n{\n\tstruct sock *sk = sock->sk;\n\tunsigned int mask;\n\tstruct caifsock *cf_sk = container_of(sk, struct caifsock, sk);\n\tsock_poll_wait(file, sk_sleep(sk), wait);\n\tmask = 0;\n\tif (sk->sk_err)\n\t\tmask |= POLLERR;\n\tif (sk->sk_shutdown == SHUTDOWN_MASK)\n\t\tmask |= POLLHUP;\n\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\tmask |= POLLRDHUP;\n\tif (!skb_queue_empty(&sk->sk_receive_queue) ||\n\t\t(sk->sk_shutdown & RCV_SHUTDOWN))\n\t\tmask |= POLLIN | POLLRDNORM;\n\tif (sock_writeable(sk) && tx_flow_is_on(cf_sk))\n\t\tmask |= POLLOUT | POLLWRNORM | POLLWRBAND;\n\treturn mask;\n}", "target": 0}
{"code": "uint32_t WasmBinaryWriter::getTableIndex(Name name) const {\n  auto it = indexes.tableIndexes.find(name);\n  assert(it != indexes.tableIndexes.end());\n  return it->second;\n}", "target": 0}
{"code": "void SetGray(double grayscale,int par)\n{\n    if ( par == STROKING ) {\n        outpos += sprintf(outpos,\" %12.3f G\",grayscale);\n    }\n    else {\n        outpos += sprintf(outpos,\" %12.3f g\",grayscale);\n    }\n}", "target": 1}
{"code": "void *hashtable_iter_at(hashtable_t *hashtable, const char *key)\n{\n    pair_t *pair;\n    size_t hash;\n    bucket_t *bucket;\n    hash = hash_str(key);\n    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return NULL;\n    return &pair->list;\n}", "target": 1}
{"code": "static int unimac_mdio_probe(struct platform_device *pdev)\n{\n\tstruct unimac_mdio_pdata *pdata = pdev->dev.platform_data;\n\tstruct unimac_mdio_priv *priv;\n\tstruct device_node *np;\n\tstruct mii_bus *bus;\n\tstruct resource *r;\n\tint ret;\n\tnp = pdev->dev.of_node;\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -EINVAL;\n\tpriv->base = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!priv->base) {\n\t\tdev_err(&pdev->dev, \"failed to remap register\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tpriv->mii_bus = mdiobus_alloc();\n\tif (!priv->mii_bus)\n\t\treturn -ENOMEM;\n\tbus = priv->mii_bus;\n\tbus->priv = priv;\n\tif (pdata) {\n\t\tbus->name = pdata->bus_name;\n\t\tpriv->wait_func = pdata->wait_func;\n\t\tpriv->wait_func_data = pdata->wait_func_data;\n\t\tbus->phy_mask = ~pdata->phy_mask;\n\t} else {\n\t\tbus->name = \"unimac MII bus\";\n\t\tpriv->wait_func_data = priv;\n\t\tpriv->wait_func = unimac_mdio_poll;\n\t}\n\tbus->parent = &pdev->dev;\n\tbus->read = unimac_mdio_read;\n\tbus->write = unimac_mdio_write;\n\tbus->reset = unimac_mdio_reset;\n\tsnprintf(bus->id, MII_BUS_ID_SIZE, \"%s-%d\", pdev->name, pdev->id);\n\tret = of_mdiobus_register(bus, np);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"MDIO bus registration failed\\n\");\n\t\tgoto out_mdio_free;\n\t}\n\tplatform_set_drvdata(pdev, priv);\n\tdev_info(&pdev->dev, \"Broadcom UniMAC MDIO bus at 0x%p\\n\", priv->base);\n\treturn 0;\nout_mdio_free:\n\tmdiobus_free(bus);\n\treturn ret;\n}", "target": 0}
{"code": "static int semctl_down(struct ipc_namespace *ns, int semid,\n\t\t       int cmd, int version, void __user *p)\n{\n\tstruct sem_array *sma;\n\tint err;\n\tstruct semid64_ds semid64;\n\tstruct kern_ipc_perm *ipcp;\n\tif(cmd == IPC_SET) {\n\t\tif (copy_semid_from_user(&semid64, p, version))\n\t\t\treturn -EFAULT;\n\t}\n\tipcp = ipcctl_pre_down_nolock(ns, &sem_ids(ns), semid, cmd,\n\t\t\t\t      &semid64.sem_perm, 0);\n\tif (IS_ERR(ipcp))\n\t\treturn PTR_ERR(ipcp);\n\tsma = container_of(ipcp, struct sem_array, sem_perm);\n\terr = security_sem_semctl(sma, cmd);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\tgoto out_unlock;\n\t}\n\tswitch(cmd){\n\tcase IPC_RMID:\n\t\tipc_lock_object(&sma->sem_perm);\n\t\tfreeary(ns, ipcp);\n\t\tgoto out_up;\n\tcase IPC_SET:\n\t\tipc_lock_object(&sma->sem_perm);\n\t\terr = ipc_update_perm(&semid64.sem_perm, ipcp);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t\tsma->sem_ctime = get_seconds();\n\t\tbreak;\n\tdefault:\n\t\trcu_read_unlock();\n\t\terr = -EINVAL;\n\t\tgoto out_up;\n\t}\nout_unlock:\n\tsem_unlock(sma);\nout_up:\n\tup_write(&sem_ids(ns).rw_mutex);\n\treturn err;\n}", "target": 1}
{"code": "static int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < index->item_count; i++) {\n        int64_t time, offset;\n        if (avio_feof(f)) {\n            index->item_count = 0;\n            av_freep(&index->items);\n            return AVERROR_INVALIDDATA;\n        }\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}", "target": 0}
{"code": "DltReturnValue dlt_file_message(DltFile *file, int index, int verbose)\n{\n    PRINT_FUNCTION_VERBOSE(verbose);\n    if (file == NULL)\n        return DLT_RETURN_WRONG_PARAMETER;\n    if (index >= file->counter) {\n        dlt_vlog(LOG_WARNING, \"Message %d out of range!\\r\\n\", index);\n        return DLT_RETURN_WRONG_PARAMETER;\n    }\n    if (fseek(file->handle, file->index[index], SEEK_SET) != 0) {\n        dlt_vlog(LOG_WARNING, \"Seek to message %d to position %ld failed!\\r\\n\",\n                 index, file->index[index]);\n        return DLT_RETURN_ERROR;\n    }\n    if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    if (dlt_file_read_data(file, verbose) < DLT_RETURN_OK)\n        return DLT_RETURN_ERROR;\n    file->position = index;\n    return DLT_RETURN_OK;\n}", "target": 1}
{"code": "asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct oabi_flock64 user;\n\tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; \n\tunsigned long local_arg = arg;\n\tint ret;\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static const char *sip_endpoint_identifier_type2str(enum ast_sip_endpoint_identifier_type method)\n{\n\tconst char *str = \"<unknown>\";\n\tswitch (method) {\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME:\n\t\tstr = \"username\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME:\n\t\tstr = \"auth_username\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_IP:\n\t\tstr = \"ip\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER:\n\t\tstr = \"header\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI:\n\t\tstr = \"request_uri\";\n\t\tbreak;\n\tcase AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT:\n\t\tstr = \"transport\";\n\t\tbreak;\n\t}\n\treturn str;\n}", "target": 1}
{"code": "static pjmedia_sdp_attr *parse_attr( pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx)\n{\n    pjmedia_sdp_attr *attr;\n    ctx->last_error = PJMEDIA_SDP_EINATTR;\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn NULL;\n    }\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    pj_scan_get(scanner, &cs_token, &attr->name);\n    if (*scanner->curptr && *scanner->curptr != '\\r' && \n\t*scanner->curptr != '\\n') \n    {\n\tif (*scanner->curptr == ':')\n\t    pj_scan_get_char(scanner);\n\tif (*scanner->curptr != '\\r' && *scanner->curptr != '\\n') {\n\t    pj_scan_get_until_chr(scanner, \"\\r\\n\", &attr->value);\n\t} else {\n\t    attr->value.ptr = NULL;\n\t    attr->value.slen = 0;\n\t}\n    } else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n    pj_scan_skip_line(scanner);\n    return attr;\n}", "target": 1}
{"code": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n                                const uint8_t *buf, int buf_size)\n{\n    ParseContext *pc = &dctx->pc;\n    uint64_t state = pc->state64;\n    int pic_found = pc->frame_start_found;\n    int i = 0;\n    if (!pic_found) {\n        for (i = 0; i < buf_size; i++) {\n            state = (state << 8) | buf[i];\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n                i++;\n                pic_found = 1;\n                dctx->cur_byte = 0;\n                dctx->remaining = 0;\n                break;\n            }\n        }\n    }\n    if (pic_found && !dctx->remaining) {\n        if (!buf_size) \n            return 0;\n        for (; i < buf_size; i++) {\n            dctx->cur_byte++;\n            state = (state << 8) | buf[i];\n            if (dctx->cur_byte == 24) {\n                dctx->h = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 26) {\n                dctx->w = (state >> 32) & 0xFFFF;\n            } else if (dctx->cur_byte == 42) {\n                int cid = (state >> 32) & 0xFFFFFFFF;\n                if (cid <= 0)\n                    continue;\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n                if (dctx->remaining <= 0) {\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n                    if (dctx->remaining <= 0)\n                        return dctx->remaining;\n                }\n                if (buf_size - i + 47 >= dctx->remaining) {\n                    int remaining = dctx->remaining;\n                    pc->frame_start_found = 0;\n                    pc->state64 = -1;\n                    dctx->cur_byte = 0;\n                    dctx->remaining = 0;\n                    return remaining;\n                } else {\n                    dctx->remaining -= buf_size;\n                }\n            }\n        }\n    } else if (pic_found) {\n        if (dctx->remaining > buf_size) {\n            dctx->remaining -= buf_size;\n        } else {\n            int remaining = dctx->remaining;\n            pc->frame_start_found = 0;\n            pc->state64 = -1;\n            dctx->cur_byte = 0;\n            dctx->remaining = 0;\n            return remaining;\n        }\n    }\n    pc->frame_start_found = pic_found;\n    pc->state64 = state;\n    return END_NOT_FOUND;\n}", "target": 1}
{"code": "bool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work_t *pubkey) {\n  ecc_25519_work_t s2, work;\n  ecc_int256_t w, tmp;\n  if (ecc_25519_gf_is_zero(&ctx->r))\n    return false;\n  ecc_25519_scalarmult(&s2, &ctx->u2, pubkey);\n  ecc_25519_add(&work, &ctx->s1, &s2);\n  ecc_25519_store_xy_legacy(&w, NULL, &work);\n  ecc_25519_gf_sub(&tmp, &ctx->r, &w);\n  return ecc_25519_gf_is_zero(&tmp);\n}", "target": 0}
{"code": "static void error_handler(int err, void *arg)\n{\n\terror(\"Engine just broken: %m.\\n\", err);\n}", "target": 0}
{"code": "int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask)\n{\n\tstruct dentry *parent;\n\tstruct inode *p_inode;\n\tint ret = 0;\n\tif (!dentry)\n\t\tdentry = path->dentry;\n\tif (!(dentry->d_flags & DCACHE_FSNOTIFY_PARENT_WATCHED))\n\t\treturn 0;\n\tparent = dget_parent(dentry);\n\tp_inode = parent->d_inode;\n\tif (unlikely(!fsnotify_inode_watches_children(p_inode)))\n\t\t__fsnotify_update_child_dentry_flags(p_inode);\n\telse if (p_inode->i_fsnotify_mask & mask) {\n\t\tmask |= FS_EVENT_ON_CHILD;\n\t\tif (path)\n\t\t\tret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,\n\t\t\t\t       dentry->d_name.name, 0);\n\t\telse\n\t\t\tret = fsnotify(p_inode, mask, dentry->d_inode, FSNOTIFY_EVENT_INODE,\n\t\t\t\t       dentry->d_name.name, 0);\n\t}\n\tdput(parent);\n\treturn ret;\n}", "target": 1}
{"code": "static int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n    if (S_ISREG(mode)) {\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t\n}", "target": 1}
{"code": "static bool torture_smb2_notify_rmdir1(struct torture_context *torture,\n\t\t\t\t       struct smb2_tree *tree)\n{\n\treturn torture_smb2_notify_rmdir(torture, tree, tree, false);\n}", "target": 0}
{"code": "xfs_bmap_alloc(\n\tstruct xfs_bmalloca\t*ap)\t\n{\n\tif (XFS_IS_REALTIME_INODE(ap->ip) &&\n\t    xfs_alloc_is_userdata(ap->datatype))\n\t\treturn xfs_bmap_rtalloc(ap);\n\treturn xfs_bmap_btalloc(ap);\n}", "target": 0}
{"code": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct timespec now;\n\tint ret, awaken, link_ret = 0;\n\tkey_check(key);\n\tkey_check(keyring);\n\tawaken = 0;\n\tret = -EBUSY;\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\tmutex_lock(&key_construction_mutex);\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\tatomic_inc(&key->user->nikeys);\n\t\tmark_key_instantiated(key, -error);\n\t\tnow = current_kernel_time();\n\t\tkey->expiry = now.tv_sec + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\t\tret = 0;\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\tmutex_unlock(&key_construction_mutex);\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\treturn ret == 0 ? link_ret : ret;\n}", "target": 0}
{"code": "static struct sk_buff *ipv6_gso_segment(struct sk_buff *skb, int features)\n{\n\tstruct sk_buff *segs = ERR_PTR(-EINVAL);\n\tstruct ipv6hdr *ipv6h;\n\tstruct inet6_protocol *ops;\n\tif (!(features & NETIF_F_V6_CSUM))\n\t\tfeatures &= ~NETIF_F_SG;\n\tif (unlikely(skb_shinfo(skb)->gso_type &\n\t\t     ~(SKB_GSO_UDP |\n\t\t       SKB_GSO_DODGY |\n\t\t       SKB_GSO_TCP_ECN |\n\t\t       SKB_GSO_TCPV6 |\n\t\t       0)))\n\t\tgoto out;\n\tif (unlikely(!pskb_may_pull(skb, sizeof(*ipv6h))))\n\t\tgoto out;\n\tipv6h = ipv6_hdr(skb);\n\t__skb_pull(skb, sizeof(*ipv6h));\n\tsegs = ERR_PTR(-EPROTONOSUPPORT);\n\trcu_read_lock();\n\tops = ipv6_gso_pull_exthdrs(skb, ipv6h->nexthdr);\n\tif (likely(ops && ops->gso_segment)) {\n\t\tskb_reset_transport_header(skb);\n\t\tsegs = ops->gso_segment(skb, features);\n\t}\n\trcu_read_unlock();\n\tif (unlikely(IS_ERR(segs)))\n\t\tgoto out;\n\tfor (skb = segs; skb; skb = skb->next) {\n\t\tipv6h = ipv6_hdr(skb);\n\t\tipv6h->payload_len = htons(skb->len - skb->mac_len -\n\t\t\t\t\t   sizeof(*ipv6h));\n\t}\nout:\n\treturn segs;\n}", "target": 0}
{"code": "pci_set_cfgdata8(struct pci_vdev *dev, int offset, uint8_t val)\n{\n\tassert(offset <= PCI_REGMAX);\n\t*(uint8_t *)(dev->cfgdata + offset) = val;\n}", "target": 1}
{"code": "const char* ewk_view_setting_encoding_custom_get(const Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, 0);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, 0);\n    Evas_Object* main_frame = ewk_view_frame_main_get(ewkView);\n    WebCore::Frame* core_frame = EWKPrivate::coreFrame(main_frame);\n    String overrideEncoding = core_frame->loader()->documentLoader()->overrideEncoding();\n    if (overrideEncoding.isEmpty())\n        return 0;\n    eina_stringshare_replace(&priv->settings.encodingCustom, overrideEncoding.utf8().data());\n    return priv->settings.encodingCustom;\n}", "target": 0}
{"code": "int main(void)\n{\n\tFILE *f;\n\tchar *tmpname;\n\tf = xfmkstemp(&tmpname, NULL);\n\tunlink(tmpname);\n\tfree(tmpname);\n\tfclose(f);\n\treturn EXIT_FAILURE;\n}", "target": 1}
{"code": "Fraction::Fraction(int32_t num,int32_t den)\n{\n  int32_t g = gcd(num, den);\n  if (num == std::numeric_limits<int32_t>::min() && g == -1) {\n    num++;\n  }\n  if (den == std::numeric_limits<int32_t>::min() && g == -1) {\n    den++;\n  }\n  numerator = num / g;\n  denominator = den / g;\n  while (denominator > MAX_FRACTION_DENOMINATOR) {\n    numerator >>= 1;\n    denominator >>= 1;\n  }\n}", "target": 1}
{"code": "static void write_version(\n    FILE       *fp,\n    const char *fname,\n    const char *dirname,\n    xref_t     *xref)\n{\n    long  start;\n    char *c, *new_fname, data;\n    FILE *new_fp;\n    start = ftell(fp);\n    if ((c = strstr(fname, \".pdf\")))\n      *c = '\\0';\n    new_fname = malloc(strlen(fname) + strlen(dirname) + 16);\n    snprintf(new_fname, strlen(fname) + strlen(dirname) + 16,\n             \"%s/%s-version-%d.pdf\", dirname, fname, xref->version);\n    if (!(new_fp = fopen(new_fname, \"w\")))\n    {\n        ERR(\"Could not create file '%s'\\n\", new_fname);\n        fseek(fp, start, SEEK_SET);\n        free(new_fname);\n        return;\n    }\n    fseek(fp, 0, SEEK_SET);\n    while (fread(&data, 1, 1, fp))\n      fwrite(&data, 1, 1, new_fp);\n    fprintf(new_fp, \"\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF\", xref->start);\n    fclose(new_fp);\n    free(new_fname);\n    fseek(fp, start, SEEK_SET);\n}", "target": 1}
{"code": "process_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || \n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}", "target": 1}
{"code": "R_API int r_core_bin_set_env(RCore *r, RBinFile *binfile) {\n\tRBinObject *binobj = binfile ? binfile->o: NULL;\n\tRBinInfo *info = binobj ? binobj->info: NULL;\n\tif (info) {\n\t\tint va = info->has_va;\n\t\tconst char * arch = info->arch;\n\t\tut16 bits = info->bits;\n\t\tut64 baseaddr = r_bin_get_baddr (r->bin);\n\t\tr_config_set_i (r->config, \"io.va\",\n\t\t\t(binobj->info)? binobj->info->has_va: 0);\n\t\tr_config_set_i (r->config, \"bin.baddr\", baseaddr);\n\t\tr_config_set (r->config, \"asm.arch\", arch);\n\t\tr_config_set_i (r->config, \"asm.bits\", bits);\n\t\tr_config_set (r->config, \"anal.arch\", arch);\n\t\tif (info->cpu && *info->cpu) {\n\t\t\tr_config_set (r->config, \"anal.cpu\", info->cpu);\n\t\t} else {\n\t\t\tr_config_set (r->config, \"anal.cpu\", arch);\n\t\t}\n\t\tr_asm_use (r->assembler, arch);\n\t\tr_core_bin_info (r, R_CORE_BIN_ACC_ALL, R_CORE_BIN_SET, va, NULL, NULL);\n\t\tr_core_bin_set_cur (r, binfile);\n\t\treturn true;\n\t}\n\treturn false;\n}", "target": 1}
{"code": "static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)\n{\n\tns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tshm_rmid(ns, shp);\n\tshm_unlock(shp);\n\tif (!is_file_hugepages(shp->shm_file))\n\t\tshmem_lock(shp->shm_file, 0, shp->mlock_user);\n\telse if (shp->mlock_user)\n\t\tuser_shm_unlock(file_inode(shp->shm_file)->i_size,\n\t\t\t\t\t\tshp->mlock_user);\n\tfput (shp->shm_file);\n\tipc_rcu_putref(shp, shm_rcu_free);\n}", "target": 1}
{"code": "static int fts3ExprTermOffsetInit(Fts3Expr *pExpr, int iPhrase, void *ctx){\n  TermOffsetCtx *p = (TermOffsetCtx *)ctx;\n  int nTerm;                      \n  int iTerm;                      \n  char *pList;                    \n  int iPos = 0;                   \n  int rc;\n  UNUSED_PARAMETER(iPhrase);\n  rc = sqlite3Fts3EvalPhrasePoslist(p->pCsr, pExpr, p->iCol, &pList);\n  nTerm = pExpr->pPhrase->nToken;\n  if( pList ){\n    fts3GetDeltaPosition(&pList, &iPos);\n    assert( iPos>=0 );\n  }\n  for(iTerm=0; iTerm<nTerm; iTerm++){\n    TermOffset *pT = &p->aTerm[p->iTerm++];\n    pT->iOff = nTerm-iTerm-1;\n    pT->pList = pList;\n    pT->iPos = iPos;\n  }\n  return rc;\n}", "target": 0}
{"code": "smb_ofile_flush(struct smb_request *sr, struct smb_ofile *of)\n{\n\tswitch (of->f_ftype) {\n\tcase SMB_FTYPE_DISK:\n\t\tif ((of->f_node->flags & NODE_FLAGS_WRITE_THROUGH) == 0)\n\t\t\t(void) smb_fsop_commit(sr, of->f_cr, of->f_node);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static int lua_ap_usleep(lua_State *L)\n{\n    apr_interval_time_t msec;\n    luaL_checktype(L, 1, LUA_TNUMBER);\n    msec = (apr_interval_time_t)lua_tonumber(L, 1);\n    apr_sleep(msec);\n    return 0;\n}", "target": 0}
{"code": "static void control_work_handler(struct work_struct *work)\n{\n\tstruct ports_device *portdev;\n\tstruct virtqueue *vq;\n\tstruct port_buffer *buf;\n\tunsigned int len;\n\tportdev = container_of(work, struct ports_device, control_work);\n\tvq = portdev->c_ivq;\n\tspin_lock(&portdev->c_ivq_lock);\n\twhile ((buf = virtqueue_get_buf(vq, &len))) {\n\t\tspin_unlock(&portdev->c_ivq_lock);\n\t\tbuf->len = len;\n\t\tbuf->offset = 0;\n\t\thandle_control_message(vq->vdev, portdev, buf);\n\t\tspin_lock(&portdev->c_ivq_lock);\n\t\tif (add_inbuf(portdev->c_ivq, buf) < 0) {\n\t\t\tdev_warn(&portdev->vdev->dev,\n\t\t\t\t \"Error adding buffer to queue\\n\");\n\t\t\tfree_buf(buf, false);\n\t\t}\n\t}\n\tspin_unlock(&portdev->c_ivq_lock);\n}", "target": 1}
{"code": "TEST(ArrayOpsTest, QuantizeAndDequantizeV2_ShapeFn) {\n  ShapeInferenceTestOp op(\"QuantizeAndDequantizeV2\");\n  op.input_tensors.resize(3);\n  TF_ASSERT_OK(NodeDefBuilder(\"test\", \"QuantizeAndDequantizeV2\")\n                   .Input(\"input\", 0, DT_FLOAT)\n                   .Input(\"input_min\", 1, DT_FLOAT)\n                   .Input(\"input_max\", 2, DT_FLOAT)\n                   .Attr(\"signed_input\", true)\n                   .Attr(\"num_bits\", 8)\n                   .Attr(\"range_given\", false)\n                   .Attr(\"narrow_range\", false)\n                   .Attr(\"axis\", -1)\n                   .Finalize(&op.node_def));\n  INFER_OK(op, \"?;?;?\", \"in0\");\n  INFER_OK(op, \"[];?;?\", \"in0\");\n  INFER_OK(op, \"[1,2,?,4,5];?;?\", \"in0\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[]\");\n  INFER_ERROR(\"Shapes must be equal rank, but are 1 and 0\", op,\n              \"[1,2,?,4,5];[];[1]\");\n  INFER_ERROR(\"Shape must be rank 0 but is rank 1\", op, \"[1,2,?,4,5];[1];[1]\");\n  (*op.node_def.mutable_attr())[\"axis\"].set_i(-2);\n  INFER_ERROR(\"axis should be at least -1, got -2\", op, \"?;?;?\");\n}", "target": 0}
{"code": "        unsigned int GetU32LE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            unsigned int nRes = m_sFile[nPos + 3];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 0];\n            return nRes;\n        }", "target": 1}
{"code": "static Bool leap_year(u32 year) {\n\tyear += 1900;\n\treturn (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;\n}", "target": 0}
{"code": "void cql_server::response::write_short_bytes(bytes b)\n{\n    write_short(cast_if_fits<uint16_t>(b.size()));\n    _body.write(b);\n}", "target": 0}
{"code": "gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\tgss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,\n\t\t\t\t   iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}", "target": 0}
{"code": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n  free(copy);\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n  return result;\n}", "target": 1}
{"code": "static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)\n{\n    int s = -1, rv;\n    char _port[6];  \n    struct addrinfo hints, *servinfo, *p;\n    snprintf(_port,6,\"%d\",port);\n    memset(&hints,0,sizeof(hints));\n    hints.ai_family = af;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;    \n    if (bindaddr && !strcmp(\"*\", bindaddr))\n        bindaddr = NULL;\n    if (af == AF_INET6 && bindaddr && !strcmp(\"::*\", bindaddr))\n        bindaddr = NULL;\n    if ((rv = getaddrinfo(bindaddr,_port,&hints,&servinfo)) != 0) {\n        anetSetError(err, \"%s\", gai_strerror(rv));\n        return ANET_ERR;\n    }\n    for (p = servinfo; p != NULL; p = p->ai_next) {\n        if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1)\n            continue;\n        if (af == AF_INET6 && anetV6Only(err,s) == ANET_ERR) goto error;\n        if (anetSetReuseAddr(err,s) == ANET_ERR) goto error;\n        if (anetListen(err,s,p->ai_addr,p->ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;\n        goto end;\n    }\n    if (p == NULL) {\n        anetSetError(err, \"unable to bind socket, errno: %d\", errno);\n        goto error;\n    }\nerror:\n    if (s != -1) close(s);\n    s = ANET_ERR;\nend:\n    freeaddrinfo(servinfo);\n    return s;\n}", "target": 1}
{"code": "static long vhost_vdpa_set_config_call(struct vhost_vdpa *v, u32 __user *argp)\n{\n\tstruct vdpa_callback cb;\n\tint fd;\n\tstruct eventfd_ctx *ctx;\n\tcb.callback = vhost_vdpa_config_cb;\n\tcb.private = v->vdpa;\n\tif (copy_from_user(&fd, argp, sizeof(fd)))\n\t\treturn  -EFAULT;\n\tctx = fd == VHOST_FILE_UNBIND ? NULL : eventfd_ctx_fdget(fd);\n\tswap(ctx, v->config_ctx);\n\tif (!IS_ERR_OR_NULL(ctx))\n\t\teventfd_ctx_put(ctx);\n\tif (IS_ERR(v->config_ctx))\n\t\treturn PTR_ERR(v->config_ctx);\n\tv->vdpa->config->set_config_cb(v->vdpa, &cb);\n\treturn 0;\n}", "target": 0}
{"code": "static int msr_open(struct inode *inode, struct file *file)\n{\n\tunsigned int cpu;\n\tstruct cpuinfo_x86 *c;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tcpu = iminor(file->f_path.dentry->d_inode);\n\tif (cpu >= nr_cpu_ids || !cpu_online(cpu))\n\t\treturn -ENXIO;\t\n\tc = &cpu_data(cpu);\n\tif (!cpu_has(c, X86_FEATURE_MSR))\n\t\treturn -EIO;\t\n\treturn 0;\n}", "target": 0}
{"code": "bool isCPUDevice() {\n  return false;\n}", "target": 0}
{"code": "  Value GetValueOrCreatePlaceholder(StringRef full_name) {\n    StringRef node_name;\n    StringRef output_name = \"\";\n    bool is_control_dep = full_name[0] == '^';\n    int output_num = 0;\n    if (is_control_dep) full_name = full_name.drop_front();\n    {\n      size_t colon_sep = full_name.find_first_of(':');\n      if (colon_sep == StringRef::npos) {\n        node_name = full_name;\n      } else {\n        node_name = full_name.take_front(colon_sep);\n        output_name = full_name.drop_front(colon_sep + 1);\n      }\n      colon_sep = output_name.find_last_of(':');\n      if (colon_sep != StringRef::npos) {\n        unsigned long long value;\n        if (!llvm::getAsUnsignedInteger(output_name.drop_front(colon_sep + 1),\n                                        10, value))\n          output_num = value;\n        output_name = output_name.take_front(colon_sep);\n      }\n    }\n    llvm::StringMap<SmallVector<Value, 1>>& op_info = values_map_[node_name];\n    SmallVector<Value, 1>& base_operation = op_info[\"^\"];\n    if (base_operation.empty()) {\n      OperationState state(loc_, mlir_placeholder_);\n      state.addAttribute(TFGraphDialect::getNameAttrKey(),\n                         builder_.getStringAttr(node_name));\n      state.types.push_back(placeholder_ty_);\n      state.types.push_back(control_ty_);\n      Operation* placeholder = builder_.create(state);\n      base_operation.push_back(placeholder->getResult(1));\n      base_operation.push_back(placeholder->getResult(0));\n    }\n    if (is_control_dep) return base_operation[0];\n    SmallVector<Value, 1>& value_info = op_info[output_name];\n    if (value_info.size() <= output_num)\n      value_info.resize(output_num + 1, Value{});\n    if (!value_info[output_num]) {\n      value_info[output_num] = builder_.create<GetResultOp>(\n          loc_, base_operation[1], output_name, output_num);\n    }\n    return value_info[output_num];\n  }", "target": 1}
{"code": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t}\n\telse if (rc == -ENODATA)\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\treturn rc;\n}", "target": 1}
{"code": "bool AuthUnknownAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  return true;\n}", "target": 1}
{"code": "INST_HANDLER (lds) {\t\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}", "target": 0}
{"code": "bool AES_GCM_EncryptContext::Encrypt(\n\tconst void *pPlaintextData, size_t cbPlaintextData,\n\tconst void *pIV,\n\tvoid *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;\n    crypto_aead_aes256gcm_encrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,\n\t\tstatic_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,\n\t\tstatic_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pIV ),\n\t\tstatic_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;\n    return true;\n}", "target": 1}
{"code": "static inline void dec_snd_pages(int order)\n{\n\tsnd_allocated_pages -= 1 << order;\n}", "target": 0}
{"code": "ProcInstallColormap(ClientPtr client)\n{\n    ColormapPtr pcmp;\n    int rc;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupResourceByType((void **) &pcmp, stuff->id, RT_COLORMAP,\n                                 client, DixInstallAccess);\n    if (rc != Success)\n        goto out;\n    rc = XaceHook(XACE_SCREEN_ACCESS, client, pcmp->pScreen, DixSetAttrAccess);\n    if (rc != Success) {\n        if (rc == BadValue)\n            rc = BadColor;\n        goto out;\n    }\n    (*(pcmp->pScreen->InstallColormap)) (pcmp);\n    return Success;\n out:\n    client->errorValue = stuff->id;\n    return rc;\n}", "target": 0}
{"code": "  explicit FractionalAvgPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\n                    \"pooling_ratio field must specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional average pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }", "target": 0}
{"code": "  virtual bool ethernet_available() const { return true; }", "target": 0}
{"code": "TfLiteStatus GetOutputSafe(const TfLiteContext* context, const TfLiteNode* node,\n                           int index, TfLiteTensor** tensor) {\n  int tensor_index;\n  TF_LITE_ENSURE_OK(\n      context, ValidateTensorIndexingSafe(context, index, node->outputs->size,\n                                          node->outputs->data, &tensor_index));\n  *tensor = GetTensorAtIndex(context, tensor_index);\n  return kTfLiteOk;\n}", "target": 0}
{"code": "cp1250_mbc_case_fold(OnigCaseFoldType flag ARG_UNUSED,\n             const UChar** pp, const UChar* end ARG_UNUSED, UChar* lower, OnigEncoding enc ARG_UNUSED)\n{\n  const UChar* p = *pp;\n  *lower = ENC_CP1250_TO_LOWER_CASE(*p);\n  (*pp)++;\n  return 1;\n}", "target": 0}
{"code": "static const unsigned char *parse_object(cJSON *item, const unsigned char *value, const unsigned char **ep)\n{\n    cJSON *child = NULL;\n    if (*value != '{')\n    {\n        *ep = value;\n        goto fail;\n    }\n    item->type = cJSON_Object;\n    value = skip(value + 1);\n    if (*value == '}')\n    {\n        return value + 1;\n    }\n    child = cJSON_New_Item();\n    item->child = child;\n    if (!item->child)\n    {\n        goto fail;\n    }\n    value = skip(parse_string(child, skip(value), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n    child->string = child->valuestring;\n    child->valuestring = NULL;\n    if (*value != ':')\n    {\n        *ep = value;\n        goto fail;\n    }\n    value = skip(parse_value(child, skip(value + 1), ep));\n    if (!value)\n    {\n        goto fail;\n    }\n    while (*value == ',')\n    {\n        cJSON *new_item = NULL;\n        if (!(new_item = cJSON_New_Item()))\n        {\n            goto fail;\n        }\n        child->next = new_item;\n        new_item->prev = child;\n        child = new_item;\n        value = skip(parse_string(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n        child->string = child->valuestring;\n        child->valuestring = NULL;\n        if (*value != ':')\n        {\n            *ep = value;\n            goto fail;\n        }\n        value = skip(parse_value(child, skip(value + 1), ep));\n        if (!value)\n        {\n            goto fail;\n        }\n    }\n    if (*value == '}')\n    {\n        return value + 1;\n    }\n    *ep = value;\nfail:\n    if (item->child != NULL)\n    {\n        cJSON_Delete(child);\n        item->child = NULL;\n    }\n    return NULL;\n}", "target": 1}
{"code": "void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)\n{\n\tstatic u32 ip_idents_hashrnd __read_mostly;\n\tu32 hash, id;\n\tnet_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));\n\thash = jhash_3words((__force u32)iph->daddr,\n\t\t\t    (__force u32)iph->saddr,\n\t\t\t    iph->protocol ^ net_hash_mix(net),\n\t\t\t    ip_idents_hashrnd);\n\tid = ip_idents_reserve(hash, segs);\n\tiph->id = htons(id);\n}", "target": 1}
{"code": "format_SET_IP_ECN(const struct ofpact_ecn *a,\n                  const struct ofpact_format_params *fp)\n{\n    ds_put_format(fp->s, \"%smod_nw_ecn:%s%d\",\n                  colors.param, colors.end, a->ecn);\n}", "target": 0}
{"code": "static void ext_session_lock_v1_handle_locked(void *data, struct ext_session_lock_v1 *lock) {\n}", "target": 0}
{"code": "static bool append_rets(RStrBuf *sb, RBinWasmTypeVec *rets) {\n\tbool ret = true;\n\tif (!rets->count) {\n\t\tret &= r_strbuf_append (sb, \"nil\");\n\t} else if (rets->count == 1) {\n\t\tret &= r_strbuf_append (sb, r_bin_wasm_valuetype_to_string (rets->types[0]));\n\t} else {\n\t\tret &= strbuf_append_type_vec (sb, rets);\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "int BUFFER_append_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)\n{\n    int result;\n    if (handle == NULL || source == NULL || size == 0)\n    {\n        LogError(\"BUFFER_append_build failed invalid parameter handle: %p, source: %p, size: %lu\", handle, source, (unsigned long)size);\n        result = MU_FAILURE;\n    }\n    else\n    {\n        if (handle->buffer == NULL)\n        {\n            if (BUFFER_safemalloc(handle, size) != 0 || handle->buffer == NULL)\n            {\n                LogError(\"Failure with BUFFER_safemalloc\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                (void)memcpy(handle->buffer, source, size);\n                result = 0;\n            }\n        }\n        else\n        {\n            unsigned char* temp = (unsigned char*)realloc(handle->buffer, handle->size + size);\n            if (temp == NULL)\n            {\n                LogError(\"Failure reallocating temporary buffer\");\n                result = MU_FAILURE;\n            }\n            else\n            {\n                handle->buffer = temp;\n                (void)memcpy(&handle->buffer[handle->size], source, size);\n                handle->size += size;\n                result = 0;\n            }\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "    size_t Xmpdatum::count() const\n    {\n        return p_->value_.get() == 0 ? 0 : p_->value_->count();\n    }", "target": 0}
{"code": "date_s_jisx0301(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE str, sg, opt;\n    rb_scan_args(argc, argv, \"02:\", &str, &sg, &opt);\n    if (!NIL_P(opt)) argc--;\n    switch (argc) {\n      case 0:\n\tstr = rb_str_new2(\"-4712-01-01\");\n      case 1:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    {\n        int argc2 = 1;\n        VALUE argv2[2];\n        argv2[0] = str;\n        if (!NIL_P(opt)) argv2[argc2++] = opt;\n\tVALUE hash = date_s__jisx0301(argc2, argv2, klass);\n\treturn d_new_by_frags(klass, hash, sg);\n    }\n}", "target": 0}
{"code": "void ogs_pfcp_context_init(void)\n{\n    int i;\n    ogs_assert(context_initialized == 0);\n    memset(&self, 0, sizeof(ogs_pfcp_context_t));\n    self.local_recovery = ogs_time_ntp32_now();\n    ogs_log_install_domain(&__ogs_pfcp_domain, \"pfcp\", ogs_core()->log.level);\n    ogs_pool_init(&ogs_pfcp_node_pool, ogs_app()->pool.nf);\n    ogs_pool_init(&ogs_pfcp_sess_pool, ogs_app()->pool.sess);\n    ogs_pool_init(&ogs_pfcp_far_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_FAR);\n    ogs_pool_init(&ogs_pfcp_urr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_URR);\n    ogs_pool_init(&ogs_pfcp_qer_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_QER);\n    ogs_pool_init(&ogs_pfcp_bar_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_BAR);\n    ogs_pool_init(&ogs_pfcp_pdr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_PDR);\n    ogs_pool_init(&ogs_pfcp_pdr_teid_pool, ogs_pfcp_pdr_pool.size);\n    ogs_pool_random_id_generate(&ogs_pfcp_pdr_teid_pool);\n    pdr_random_to_index = ogs_calloc(\n            sizeof(ogs_pool_id_t), ogs_pfcp_pdr_pool.size);\n    ogs_assert(pdr_random_to_index);\n    for (i = 0; i < ogs_pfcp_pdr_pool.size; i++)\n        pdr_random_to_index[ogs_pfcp_pdr_teid_pool.array[i]] = i;\n    ogs_pool_init(&ogs_pfcp_rule_pool,\n            ogs_app()->pool.sess *\n            OGS_MAX_NUM_OF_PDR * OGS_MAX_NUM_OF_FLOW_IN_PDR);\n    ogs_pool_init(&ogs_pfcp_dev_pool, OGS_MAX_NUM_OF_DEV);\n    ogs_pool_init(&ogs_pfcp_subnet_pool, OGS_MAX_NUM_OF_SUBNET);\n    self.object_teid_hash = ogs_hash_make();\n    ogs_assert(self.object_teid_hash);\n    self.far_f_teid_hash = ogs_hash_make();\n    ogs_assert(self.far_f_teid_hash);\n    self.far_teid_hash = ogs_hash_make();\n    ogs_assert(self.far_teid_hash);\n    context_initialized = 1;\n}", "target": 1}
{"code": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n\trc = nfc_deactivate_target(dev, target_idx, NFC_TARGET_MODE_SLEEP);\n\tnfc_put_device(dev);\n\treturn rc;\n}", "target": 1}
{"code": "char *LibRaw_file_datastream::gets(char *str, int sz)\n{\n  if(sz<1) return NULL;\n  LR_STREAM_CHK();\n  std::istream is(f.get());\n  is.getline(str, sz);\n  if (is.fail())\n    return 0;\n  return str;\n}", "target": 0}
{"code": "static void do_waitpid(FILE *fin, FILE *fout) {\n  char buf[BUFFER_SIZE];\n  read_buf(fin, buf);\n  int64_t p = -1;\n  int options = 0;\n  int timeout = 0;\n  sscanf(buf, \"%\" PRId64 \" %d %d\", &p, &options, &timeout);\n  pid_t pid = (pid_t)p;\n  int stat;\n  if (timeout > 0) {\n    waited = pid;\n    signal(SIGALRM, kill_handler);\n    alarm(timeout);\n  }\n  pid_t ret = ::waitpid(pid, &stat, options);\n  alarm(0); \n  waited = 0;\n  fprintf(fout, \"%\" PRId64 \" %d\\n\", (int64_t)ret, stat);\n  if (ret < 0) {\n    fprintf(fout, \"%d\\n\", errno);\n  }\n  fflush(fout);\n}", "target": 1}
{"code": "sf_open\t(const char *path, int mode, SF_INFO *sfinfo)\n{\tSF_PRIVATE \t*psf ;\n\tassert (sizeof (sf_count_t) == 8) ;\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf_init_files (psf) ;\n\tpsf_log_printf (psf, \"File : %s\\n\", path) ;\n\tif (copy_filename (psf, path) != 0)\n\t{\tsf_errno = psf->error ;\n\t\treturn\tNULL ;\n\t\t} ;\n\tpsf->file.mode = mode ;\n\tif (strcmp (path, \"-\") == 0)\n\t\tpsf->error = psf_set_stdio (psf) ;\n\telse\n\t\tpsf->error = psf_fopen (psf) ;\n\treturn psf_open_file (psf, sfinfo) ;\n} ", "target": 1}
{"code": "onigenc_always_false_is_allowed_reverse_match(const UChar* s   ARG_UNUSED,\n\t\t\t\t\t      const UChar* end ARG_UNUSED,\n\t\t\t\t\t      OnigEncoding enc ARG_UNUSED)\n{\n  return FALSE;\n}", "target": 0}
{"code": "static inline void get_conn_text(const conn *c, const int af,\n                char* addr, struct sockaddr *sock_addr) {\n    char addr_text[MAXPATHLEN];\n    addr_text[0] = '\\0';\n    const char *protoname = \"?\";\n    unsigned short port = 0;\n    switch (af) {\n        case AF_INET:\n            (void) inet_ntop(af,\n                    &((struct sockaddr_in *)sock_addr)->sin_addr,\n                    addr_text,\n                    sizeof(addr_text) - 1);\n            port = ntohs(((struct sockaddr_in *)sock_addr)->sin_port);\n            protoname = IS_UDP(c->transport) ? \"udp\" : \"tcp\";\n            break;\n        case AF_INET6:\n            addr_text[0] = '[';\n            addr_text[1] = '\\0';\n            if (inet_ntop(af,\n                    &((struct sockaddr_in6 *)sock_addr)->sin6_addr,\n                    addr_text + 1,\n                    sizeof(addr_text) - 2)) {\n                strcat(addr_text, \"]\");\n            }\n            port = ntohs(((struct sockaddr_in6 *)sock_addr)->sin6_port);\n            protoname = IS_UDP(c->transport) ? \"udp6\" : \"tcp6\";\n            break;\n        case AF_UNIX:\n            strncpy(addr_text,\n                    ((struct sockaddr_un *)sock_addr)->sun_path,\n                    sizeof(addr_text) - 1);\n            addr_text[sizeof(addr_text)-1] = '\\0';\n            protoname = \"unix\";\n            break;\n    }\n    if (strlen(addr_text) < 2) {\n        sprintf(addr_text, \"<AF %d>\", af);\n    }\n    if (port) {\n        sprintf(addr, \"%s:%s:%u\", protoname, addr_text, port);\n    } else {\n        sprintf(addr, \"%s:%s\", protoname, addr_text);\n    }\n}", "target": 1}
{"code": "  base::WaitableEvent* event() { return event_.get(); }", "target": 0}
{"code": "    const std::unordered_map<std::string, std::string> &getHeaders() const\n    {\n        return headers();\n    }", "target": 1}
{"code": "static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType)\n{\n\tint length = 1;\n\torderInfo->fieldFlags = 0;\n\torderInfo->orderType = orderType;\n\torderInfo->controlFlags = ORDER_STANDARD;\n\torderInfo->controlFlags |= ORDER_TYPE_CHANGE;\n\tlength += 1;\n\tlength += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType];\n\tlength += update_prepare_bounds(context, orderInfo);\n\treturn length;\n}", "target": 1}
{"code": "static void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}", "target": 1}
{"code": "void queue_push(register Queue *qp, size_t extra_length, char const *info)\n{\n    register char *cp;\n    size_t memory_length;\n    size_t available_length;\n    size_t begin_length;\n    size_t n_begin;\n    size_t q_length;\n    if (!extra_length)\n        return;\n    memory_length    = qp->d_memory_end - qp->d_memory;\n    q_length = \n        qp->d_read <= qp->d_write ?\n            (size_t)(qp->d_write - qp->d_read)\n        :\n            memory_length - (qp->d_read - qp->d_write);\n    available_length = memory_length - q_length - 1;\n    if (message_show(MSG_INFO))\n        message(\"push_front %u bytes in `%s'\", (unsigned)extra_length, info);\n    if (extra_length > available_length)\n    {\n        memory_length += extra_length - available_length + BLOCK_QUEUE;\n        cp = new_memory(memory_length, sizeof(char));\n        if (message_show(MSG_INFO))\n            message(\"Reallocating queue at %p to %p\", qp->d_memory, cp);\n        if (qp->d_read > qp->d_write)               \n        {\n            size_t tail_len = qp->d_memory_end - qp->d_read;\n            memcpy(cp, qp->d_read, tail_len);       \n            memcpy(cp + tail_len, qp->d_memory, \n                                    (size_t)(qp->d_write - qp->d_memory));\n            qp->d_write = cp + q_length;\n            qp->d_read = cp;\n        }\n        else                                        \n        {\n            memcpy(cp, qp->d_memory, memory_length);\n            qp->d_read = cp + (qp->d_read - qp->d_memory);\n            qp->d_write = cp + (qp->d_write - qp->d_memory);\n        }\n        free(qp->d_memory);                         \n        qp->d_memory_end = cp + memory_length;      \n        qp->d_memory = cp;                          \n    }\n    begin_length = qp->d_read - qp->d_memory;   \n    n_begin = extra_length <= begin_length ?    \n                    extra_length                \n                :\n                    begin_length;\n    memcpy                                      \n    (                                           \n        qp->d_read -= n_begin,\n        info + extra_length - n_begin,\n        n_begin\n    );\n    if (extra_length > begin_length)            \n    {\n        extra_length -= begin_length;           \n        memcpy                                  \n        (                                       \n            qp->d_read = qp->d_memory_end - extra_length,\n            info,\n            extra_length\n        );\n    }\n}", "target": 1}
{"code": "deltas_head_set_size(struct deltas_head *deltas, size_t capacity)\n{\n\tsize_t i;\n\tif (deltas->array != NULL)\n\t\tpr_crit(\"Size of this list can't be modified\");\n\tdeltas->capacity = capacity;\n\tif (capacity == 0)\n\t\treturn 0; \n\tdeltas->array = malloc(deltas->capacity\n\t    * sizeof(struct delta_head *));\n\tif (deltas->array == NULL)\n\t\treturn pr_enomem();\n\tfor (i = 0; i < deltas->capacity; i++)\n\t\tdeltas->array[i] = NULL;\n\treturn 0;\n}", "target": 1}
{"code": "static struct sock *__udp4_lib_mcast_demux_lookup(struct net *net,\n\t\t\t\t\t\t  __be16 loc_port, __be32 loc_addr,\n\t\t\t\t\t\t  __be16 rmt_port, __be32 rmt_addr,\n\t\t\t\t\t\t  int dif)\n{\n\tstruct sock *sk, *result;\n\tstruct hlist_nulls_node *node;\n\tunsigned short hnum = ntohs(loc_port);\n\tunsigned int count, slot = udp_hashfn(net, hnum, udp_table.mask);\n\tstruct udp_hslot *hslot = &udp_table.hash[slot];\n\tif (hslot->count > 10)\n\t\treturn NULL;\n\trcu_read_lock();\nbegin:\n\tcount = 0;\n\tresult = NULL;\n\tsk_nulls_for_each_rcu(sk, node, &hslot->head) {\n\t\tif (__udp_is_mcast_sock(net, sk,\n\t\t\t\t\tloc_port, loc_addr,\n\t\t\t\t\trmt_port, rmt_addr,\n\t\t\t\t\tdif, hnum)) {\n\t\t\tresult = sk;\n\t\t\t++count;\n\t\t}\n\t}\n\tif (get_nulls_value(node) != slot)\n\t\tgoto begin;\n\tif (result) {\n\t\tif (count != 1 ||\n\t\t    unlikely(!atomic_inc_not_zero_hint(&result->sk_refcnt, 2)))\n\t\t\tresult = NULL;\n\t\telse if (unlikely(!__udp_is_mcast_sock(net, result,\n\t\t\t\t\t\t       loc_port, loc_addr,\n\t\t\t\t\t\t       rmt_port, rmt_addr,\n\t\t\t\t\t\t       dif, hnum))) {\n\t\t\tsock_put(result);\n\t\t\tresult = NULL;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn result;\n}", "target": 0}
{"code": "void TensorSliceReader::LoadShard(int shard) const {\n  CHECK_LT(shard, sss_.size());\n  if (sss_[shard] || !status_.ok()) {\n    return;  \n  }\n  string value;\n  SavedTensorSlices sts;\n  const string fname = fnames_[shard];\n  VLOG(1) << \"Reading meta data from file \" << fname << \"...\";\n  Table* table;\n  Status s = open_function_(fname, &table);\n  if (!s.ok()) {\n    status_ = errors::DataLoss(\"Unable to open table file \", fname, \": \",\n                               s.ToString());\n    return;\n  }\n  sss_[shard].reset(table);\n  if (!(table->Get(kSavedTensorSlicesKey, &value) &&\n        ParseProtoUnlimited(&sts, value))) {\n    status_ = errors::Internal(\n        \"Failed to find the saved tensor slices at the beginning of the \"\n        \"checkpoint file: \",\n        fname);\n    return;\n  }\n  status_ = CheckVersions(sts.meta().versions(), TF_CHECKPOINT_VERSION,\n                          TF_CHECKPOINT_VERSION_MIN_PRODUCER, \"Checkpoint\",\n                          \"checkpoint\");\n  if (!status_.ok()) return;\n  for (const SavedSliceMeta& ssm : sts.meta().tensor()) {\n    TensorShape ssm_shape;\n    status_ = TensorShape::BuildTensorShapeBase(ssm.shape(), &ssm_shape);\n    if (!status_.ok()) return;\n    for (const TensorSliceProto& tsp : ssm.slice()) {\n      TensorSlice ss_slice;\n      status_ = TensorSlice::BuildTensorSlice(tsp, &ss_slice);\n      if (!status_.ok()) return;\n      status_ = RegisterTensorSlice(ssm.name(), ssm_shape, ssm.type(), fname,\n                                    ss_slice, &tensors_);\n      if (!status_.ok()) return;\n    }\n  }\n}", "target": 0}
{"code": "static char *create_output_name(unsigned char *fname, unsigned char *dir,\n\t\t\t int lower, int isunix, int utf8)\n{\n  unsigned char *p, *name, c, *fe, sep, slash;\n  unsigned int x;\n  sep   = (isunix) ? '/'  : '\\\\'; \n  slash = (isunix) ? '\\\\' : '/';  \n  x = strlen((char *) fname);\n  if (utf8) x *= 3;\n  if (dir) x += strlen((char *) dir);\n  if (!(name = (unsigned char *) malloc(x + 2))) {\n    fprintf(stderr, \"out of memory!\\n\");\n    return NULL;\n  }\n  *name = '\\0';\n  if (dir) {\n    strcpy((char *) name, (char *) dir);\n    strcat((char *) name, \"/\");\n  }\n  while (*fname == sep) fname++;\n  p = &name[strlen((char *)name)];\n  fe = &fname[strlen((char *)fname)];\n  if (utf8) {\n    do {\n      if (fname >= fe) {\n\tfree(name);\n\treturn NULL;\n      }\n      if ((c = *fname++) < 0x80) x = c;\n      else {\n\tif ((c >= 0xC0) && (c < 0xE0)) {\n\t  x = (c & 0x1F) << 6;\n\t  x |= *fname++ & 0x3F;\n\t}\n\telse if ((c >= 0xE0) && (c < 0xF0)) {\n\t  x = (c & 0xF) << 12;\n\t  x |= (*fname++ & 0x3F) << 6;\n\t  x |= *fname++ & 0x3F;\n\t}\n\telse x = '?';\n      }\n      if      (x == sep)   x = '/';\n      else if (x == slash) x = '\\\\';\n      else if (lower)      x = (unsigned int) tolower((int) x);\n      if (x < 0x80) {\n\t*p++ = (unsigned char) x;\n      }\n      else if (x < 0x800) {\n\t*p++ = 0xC0 | (x >> 6);   \n\t*p++ = 0x80 | (x & 0x3F);\n      }\n      else {\n\t*p++ = 0xE0 | (x >> 12);\n\t*p++ = 0x80 | ((x >> 6) & 0x3F);\n\t*p++ = 0x80 | (x & 0x3F);\n      }\n    } while (x);\n  }\n  else {\n    do {\n      c = *fname++;\n      if      (c == sep)   c = '/';\n      else if (c == slash) c = '\\\\';\n      else if (lower)      c = (unsigned char) tolower((int) c);\n    } while ((*p++ = c));\n  }\n  return (char *) name;\n}", "target": 1}
{"code": "static TEE_Result do_alloc_publickey(struct rsa_public_key *s,\n\t\t\t\t     size_t key_size_bits __unused)\n{\n\tmemset(s, 0, sizeof(*s));\n\tif (!bn_alloc_max(&s->e))\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\tif (!bn_alloc_max(&s->n)) {\n\t\tcrypto_bignum_free(s->e);\n\t\treturn TEE_ERROR_OUT_OF_MEMORY;\n\t}\n\treturn TEE_SUCCESS;\n}", "target": 1}
{"code": "void nfcmrvl_nci_unregister_dev(struct nfcmrvl_private *priv)\n{\n\tstruct nci_dev *ndev = priv->ndev;\n\tif (priv->ndev->nfc_dev->fw_download_in_progress)\n\t\tnfcmrvl_fw_dnld_abort(priv);\n\tnfcmrvl_fw_dnld_deinit(priv);\n\tif (gpio_is_valid(priv->config.reset_n_io))\n\t\tgpio_free(priv->config.reset_n_io);\n\tnci_unregister_device(ndev);\n\tnci_free_device(ndev);\n\tkfree(priv);\n}", "target": 1}
{"code": "const AtomicString& HTMLInputElement::defaultValue() const\n{\n    return fastGetAttribute(valueAttr);\n}", "target": 0}
{"code": "git_commit_list_node *git_commit_list_alloc_node(git_revwalk *walk)\n{\n\treturn (git_commit_list_node *)git_pool_mallocz(&walk->commit_pool, 1);\n}", "target": 0}
{"code": "static long btrfs_ioctl_dev_info(struct btrfs_fs_info *fs_info,\n\t\t\t\t void __user *arg)\n{\n\tstruct btrfs_ioctl_dev_info_args *di_args;\n\tstruct btrfs_device *dev;\n\tint ret = 0;\n\tchar *s_uuid = NULL;\n\tdi_args = memdup_user(arg, sizeof(*di_args));\n\tif (IS_ERR(di_args))\n\t\treturn PTR_ERR(di_args);\n\tif (!btrfs_is_empty_uuid(di_args->uuid))\n\t\ts_uuid = di_args->uuid;\n\trcu_read_lock();\n\tdev = btrfs_find_device(fs_info->fs_devices, di_args->devid, s_uuid,\n\t\t\t\tNULL);\n\tif (!dev) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tdi_args->devid = dev->devid;\n\tdi_args->bytes_used = btrfs_device_get_bytes_used(dev);\n\tdi_args->total_bytes = btrfs_device_get_total_bytes(dev);\n\tmemcpy(di_args->uuid, dev->uuid, sizeof(di_args->uuid));\n\tif (dev->name) {\n\t\tstrncpy(di_args->path, rcu_str_deref(dev->name),\n\t\t\t\tsizeof(di_args->path) - 1);\n\t\tdi_args->path[sizeof(di_args->path) - 1] = 0;\n\t} else {\n\t\tdi_args->path[0] = '\\0';\n\t}\nout:\n\trcu_read_unlock();\n\tif (ret == 0 && copy_to_user(arg, di_args, sizeof(*di_args)))\n\t\tret = -EFAULT;\n\tkfree(di_args);\n\treturn ret;\n}", "target": 1}
{"code": "bool PixelFormat::is888(void) const\n{\n  if (!trueColour)\n    return false;\n  if (bpp != 32)\n    return false;\n  if (depth != 24)\n    return false;\n  if (redMax != 255)\n    return false;\n  if (greenMax != 255)\n    return false;\n  if (blueMax != 255)\n    return false;\n  if ((redShift & 0x7) != 0)\n    return false;\n  if ((greenShift & 0x7) != 0)\n    return false;\n  if ((blueShift & 0x7) != 0)\n    return false;\n  return true;\n}", "target": 0}
{"code": "void Magick::Image::read(MagickCore::Image *image,\n  MagickCore::ExceptionInfo *exceptionInfo)\n{\n  if (image != (MagickCore::Image *) NULL &&\n      image->next != (MagickCore::Image *) NULL)\n    {\n      MagickCore::Image\n        *next;\n      next=image->next;\n      image->next=(MagickCore::Image *) NULL;\n      next->previous=(MagickCore::Image *) NULL;\n      DestroyImageList(next);\n    }\n  replaceImage(image);\n  if (exceptionInfo->severity == MagickCore::UndefinedException &&\n      image == (MagickCore::Image *) NULL)\n    {\n      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);\n      if (!quiet())\n        throwExceptionExplicit(MagickCore::ImageWarning,\n          \"No image was loaded.\");\n      return;\n    }\n  ThrowImageException;\n}", "target": 0}
{"code": "static bool dump_fd_info(const char *dest_filename, char *source_filename, int source_base_ofs)\n{\n    FILE *fp = fopen(dest_filename, \"w\");\n    if (!fp)\n        return false;\n    unsigned fd = 0;\n    while (fd <= 99999) \n    {\n        sprintf(source_filename + source_base_ofs, \"fd/%u\", fd);\n        char *name = malloc_readlink(source_filename);\n        if (!name)\n            break;\n        fprintf(fp, \"%u:%s\\n\", fd, name);\n        free(name);\n        sprintf(source_filename + source_base_ofs, \"fdinfo/%u\", fd);\n        fd++;\n        FILE *in = fopen(source_filename, \"r\");\n        if (!in)\n            continue;\n        char buf[128];\n        while (fgets(buf, sizeof(buf)-1, in))\n        {\n            char *eol = strchrnul(buf, '\\n');\n            eol[0] = '\\n';\n            eol[1] = '\\0';\n            fputs(buf, fp);\n        }\n        fclose(in);\n    }\n    fclose(fp);\n    return true;\n}", "target": 1}
{"code": "static int mon_bin_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tvma->vm_ops = &mon_bin_vm_ops;\n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EPERM;\n\tvma->vm_flags &= ~VM_MAYWRITE;\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_private_data = filp->private_data;\n\tmon_bin_vma_open(vma);\n\treturn 0;\n}", "target": 0}
{"code": "void LibRaw::exp_bef(float shift, float smooth)\n{\n    if(shift>8) shift = 8;\n    if(shift<0.25) shift = 0.25;\n    if(smooth < 0.0) smooth = 0.0;\n    if(smooth > 1.0) smooth = 1.0;\n    unsigned short *lut = (ushort*)malloc((TBLN+1)*sizeof(unsigned short));\n    if(shift <=1.0)\n        {\n            for(int i=0;i<=TBLN;i++)\n                lut[i] = (unsigned short)((float)i*shift);\n        }\n    else\n        {\n            float x1,x2,y1,y2;\n            float cstops = log(shift)/log(2.0f);\n            float room = cstops*2;\n            float roomlin = powf(2.0f,room);\n            x2 = (float)TBLN;\n            x1 = (x2+1)/roomlin-1;\n            y1 = x1*shift;\n            y2 = x2*(1+(1-smooth)*(shift-1));\n            float sq3x=powf(x1*x1*x2,1.0f/3.0f);\n            float B = (y2-y1+shift*(3*x1-3.0f*sq3x)) / (x2+2.0f*x1-3.0f*sq3x);\n            float A = (shift - B)*3.0f*powf(x1*x1,1.0f/3.0f);\n            float CC = y2 - A*powf(x2,1.0f/3.0f)-B*x2;\n            for(int i=0;i<=TBLN;i++)\n                {\n                    float X = (float)i;\n                    float Y = A*powf(X,1.0f/3.0f)+B*X+CC;\n                    if(i<x1)\n                        lut[i] = (unsigned short)((float)i*shift);\n                    else\n                        lut[i] = Y<0?0:(Y>TBLN?TBLN:(unsigned short)(Y));\n                }\n        }\n    for(int i=0; i< S.height*S.width; i++)\n        {\n            imgdata.image[i][0] = lut[imgdata.image[i][0]];\n            imgdata.image[i][1] = lut[imgdata.image[i][1]];\n            imgdata.image[i][2] = lut[imgdata.image[i][2]];\n            imgdata.image[i][3] = lut[imgdata.image[i][3]];\n        }\n    C.data_maximum = lut[C.data_maximum];\n    C.maximum = lut[C.maximum];\n    free(lut);\n}", "target": 1}
{"code": "static CURLcode error_init_writer(struct Curl_easy *data,\n                                  struct contenc_writer *writer)\n{\n  (void) data;\n  return writer->downstream? CURLE_OK: CURLE_WRITE_ERROR;\n}", "target": 0}
{"code": "TfLiteTensor* GetVariableInput(TfLiteContext* context, const TfLiteNode* node,\n                               int index) {\n  TfLiteTensor* tensor = GetMutableInput(context, node, index);\n  if (tensor == nullptr) return nullptr;\n  return tensor->is_variable ? tensor : nullptr;\n}", "target": 0}
{"code": "int __ref online_pages(unsigned long pfn, unsigned long nr_pages)\n{\n\tunsigned long onlined_pages = 0;\n\tstruct zone *zone;\n\tint need_zonelists_rebuild = 0;\n\tint nid;\n\tint ret;\n\tstruct memory_notify arg;\n\tlock_memory_hotplug();\n\targ.start_pfn = pfn;\n\targ.nr_pages = nr_pages;\n\targ.status_change_nid = -1;\n\tnid = page_to_nid(pfn_to_page(pfn));\n\tif (node_present_pages(nid) == 0)\n\t\targ.status_change_nid = nid;\n\tret = memory_notify(MEM_GOING_ONLINE, &arg);\n\tret = notifier_to_errno(ret);\n\tif (ret) {\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone = page_zone(pfn_to_page(pfn));\n\tmutex_lock(&zonelists_mutex);\n\tif (!populated_zone(zone))\n\t\tneed_zonelists_rebuild = 1;\n\tret = walk_system_ram_range(pfn, nr_pages, &onlined_pages,\n\t\tonline_pages_range);\n\tif (ret) {\n\t\tmutex_unlock(&zonelists_mutex);\n\t\tprintk(KERN_DEBUG \"online_pages [mem %#010llx-%#010llx] failed\\n\",\n\t\t       (unsigned long long) pfn << PAGE_SHIFT,\n\t\t       (((unsigned long long) pfn + nr_pages)\n\t\t\t    << PAGE_SHIFT) - 1);\n\t\tmemory_notify(MEM_CANCEL_ONLINE, &arg);\n\t\tunlock_memory_hotplug();\n\t\treturn ret;\n\t}\n\tzone->present_pages += onlined_pages;\n\tzone->zone_pgdat->node_present_pages += onlined_pages;\n\tif (need_zonelists_rebuild)\n\t\tbuild_all_zonelists(NULL, zone);\n\telse\n\t\tzone_pcp_update(zone);\n\tmutex_unlock(&zonelists_mutex);\n\tinit_per_zone_wmark_min();\n\tif (onlined_pages) {\n\t\tkswapd_run(zone_to_nid(zone));\n\t\tnode_set_state(zone_to_nid(zone), N_HIGH_MEMORY);\n\t}\n\tvm_total_pages = nr_free_pagecache_pages();\n\twriteback_set_ratelimit();\n\tif (onlined_pages)\n\t\tmemory_notify(MEM_ONLINE, &arg);\n\tunlock_memory_hotplug();\n\treturn 0;\n}", "target": 1}
{"code": "void HTMLMediaElement::OnVisibilityChangedForLazyLoad(bool is_visible) {\n  if (!is_visible || !web_media_player_)\n    return;\n  web_media_player_->OnBecameVisible();\n  lazy_load_visibility_observer_->Stop();\n  lazy_load_visibility_observer_ = nullptr;\n}", "target": 0}
{"code": "void rdma_lock_handler(struct rdma_cm_id *id)\n{\n\tstruct rdma_id_private *id_priv =\n\t\tcontainer_of(id, struct rdma_id_private, id);\n\tmutex_lock(&id_priv->handler_mutex);\n}", "target": 0}
{"code": "static void rose_idletimer_expiry(struct timer_list *t)\n{\n\tstruct rose_sock *rose = from_timer(rose, t, idletimer);\n\tstruct sock *sk = &rose->sock;\n\tbh_lock_sock(sk);\n\trose_clear_queues(sk);\n\trose_write_internal(sk, ROSE_CLEAR_REQUEST);\n\trose_sk(sk)->state = ROSE_STATE_2;\n\trose_start_t3timer(sk);\n\tsk->sk_state     = TCP_CLOSE;\n\tsk->sk_err       = 0;\n\tsk->sk_shutdown |= SEND_SHUTDOWN;\n\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tsk->sk_state_change(sk);\n\t\tsock_set_flag(sk, SOCK_DEAD);\n\t}\n\tbh_unlock_sock(sk);\n\tsock_put(sk);\n}", "target": 0}
{"code": "static void gf_dump_vrml_simple_field(GF_SceneDumper *sdump, GF_FieldInfo field, GF_Node *parent)\n{\n\tu32 i, sf_type;\n\tGF_ChildNodeItem *list;\n\tvoid *slot_ptr;\n\tswitch (field.fieldType) {\n\tcase GF_SG_VRML_SFNODE:\n\t\tgf_dump_vrml_node(sdump, field.far_ptr ? *(GF_Node **)field.far_ptr : NULL, 0, NULL);\n\t\treturn;\n\tcase GF_SG_VRML_MFNODE:\n\t\tlist = * ((GF_ChildNodeItem **) field.far_ptr);\n\t\tassert( list );\n\t\tsdump->indent++;\n\t\twhile (list) {\n\t\t\tgf_dump_vrml_node(sdump, list->node, 1, NULL);\n\t\t\tlist = list->next;\n\t\t}\n\t\tsdump->indent--;\n\t\treturn;\n\tcase GF_SG_VRML_SFCOMMANDBUFFER:\n\t\treturn;\n\t}\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) {\n\t\tif (sdump->XMLDump) StartAttribute(sdump, \"value\");\n\t\tgf_dump_vrml_sffield(sdump, field.fieldType, field.far_ptr, 0, parent);\n\t\tif (sdump->XMLDump) EndAttribute(sdump);\n\t} else {\n\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {\n\t\t\tEndAttribute(sdump);\n\t\t}\n\t}\n}", "target": 0}
{"code": "static void HttpMultiBufHeaderThreadDataFree(void *data)\n{\n    HttpMultiBufHeaderThreadData *td = data;\n    for (size_t i = 0; i < td->cap; i++) {\n        SCFree(td->items[i].buffer);\n    }\n    SCFree(td->items);\n    SCFree(td);\n}", "target": 0}
{"code": "WebWidget* RenderView::createPopupMenu(WebKit::WebPopupType popup_type) {\n  RenderWidget* widget = RenderWidget::Create(routing_id_,\n                                              render_thread_,\n                                              popup_type);\n  return widget->webwidget();\n}", "target": 0}
{"code": "void usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}", "target": 1}
{"code": "TfLiteStatus SimpleOpEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = tflite::GetInput(context, node, 0);\n  const TfLiteTensor* input2 = tflite::GetInput(context, node, 1);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  int32_t* output_data = output->data.i32;\n  *output_data = *(input1->data.i32) + *(input2->data.i32);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "void VP8LHuffmanTablesDeallocate(HuffmanTables* const huffman_tables) {\n  HuffmanTablesSegment *current, *next;\n  if (huffman_tables == NULL) return;\n  current = &huffman_tables->root;\n  next = current->next;\n  WebPSafeFree(current->start);\n  current->start = NULL;\n  current->next = NULL;\n  current = next;\n  while (current != NULL) {\n    next = current->next;\n    WebPSafeFree(current->start);\n    WebPSafeFree(current);\n    current = next;\n  }\n}", "target": 0}
{"code": "vips_utf8_strcasestr( const char *haystack_start, const char *needle_start, \n\tint len_bytes )\n{\n        int needle_len = g_utf8_strlen( needle_start, -1 );\n        int needle_len_bytes = strlen( needle_start );\n\tconst char *haystack;\n\tfor( haystack = haystack_start; \n\t\thaystack - haystack_start <= len_bytes - needle_len_bytes; \n\t\thaystack = g_utf8_find_next_char( haystack, NULL ) ) {\n                const char *needle_char;\n                const char *haystack_char;\n\t\tint i;\n                haystack_char = haystack;\n                needle_char = needle_start;\n                for( i = 0; i < needle_len; i++ ) {\n                        gunichar a = \n\t\t\t\tg_utf8_get_char_validated( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes - haystack );\n                        gunichar b = \n\t\t\t\tg_utf8_get_char_validated( needle_char, -1 );\n                        if( a == (gunichar) -1 ||\n\t\t\t\ta == (gunichar) -2 ||\n\t\t\t\tb == (gunichar) -1 ||\n\t\t\t\tb == (gunichar) -2 )\n                                return( NULL );\n                        if( a == (gunichar) 0 )\n                                return( NULL );\n                        if( g_unichar_tolower( a ) != g_unichar_tolower( b ) )\n                                break;\n                        haystack_char = \n\t\t\t\tg_utf8_find_next_char( haystack_char, \n\t\t\t\t\thaystack_start + len_bytes );\n                        needle_char = \n\t\t\t\tg_utf8_find_next_char( needle_char, NULL );\n                }\n                if( i == needle_len )\n                        return( haystack );\n        }\n        return( NULL );\n}", "target": 1}
{"code": "ldns_str2rdf_str(ldns_rdf **rd, const char *str)\n{\n\tuint8_t *data, *dp, ch = 0;\n\tsize_t length;\n\tdp = data = LDNS_XMALLOC(uint8_t, strlen(str) > 255 ? 256 : (strlen(str) + 1));\n\tif (! data) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\twhile (parse_char(&ch, &str)) {\n\t\tif (dp - data >= 255) {\n\t\t\tLDNS_FREE(data);\n\t\t\treturn LDNS_STATUS_INVALID_STR;\n\t\t}\n\t\t*++dp = ch;\n\t}\n\tif (! str) {\n\t\treturn LDNS_STATUS_SYNTAX_BAD_ESCAPE;\n\t}\n\tlength = (size_t)(dp - data);\n\tdata[0] = (uint8_t)length;\n\tdata = LDNS_XREALLOC(dp = data, uint8_t, length + 1);\n\tif (! data) {\n\t\tLDNS_FREE(dp);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\t*rd = ldns_rdf_new(LDNS_RDF_TYPE_STR, length + 1, data);\n\tif (! *rd) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}", "target": 0}
{"code": "static char *decode_text_string(const char *str, size_t str_len)\n{\n    int   idx, is_hex, is_utf16be, ascii_idx;\n    char *ascii, hex_buf[5] = {0};\n    is_hex = is_utf16be = idx = ascii_idx = 0;\n    if (str[0] == '(')\n    {\n        ascii = malloc(strlen(str) + 1);\n        strncpy(ascii, str, strlen(str) + 1);\n        return ascii;\n    }\n    else if (str[0] == '<')\n    {\n        is_hex = 1;\n        ++idx;\n    }\n    if (is_hex && (str_len > 5) && \n        (str[idx] == 'F') && (str[idx+1] == 'E') &&\n        (str[idx+2] == 'F') && (str[idx+3] == 'F'))\n    {\n        is_utf16be = 1;\n        idx += 4;\n    }\n    else\n      return NULL;\n    ascii = malloc(str_len);\n    for ( ; idx<str_len; ++idx)\n    {\n        hex_buf[0] = str[idx++];\n        hex_buf[1] = str[idx++];\n        hex_buf[2] = str[idx++];\n        hex_buf[3] = str[idx];\n        ascii[ascii_idx++] = strtol(hex_buf, NULL, 16);\n    }\n    return ascii;\n}", "target": 1}
{"code": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\t\tcompare = strcmp (key_1, key_2);\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\treturn compare;\n}", "target": 1}
{"code": "static uint32_t color_string_to_rgba(const char *p, int len)\n{\n    uint32_t ret = 0xFF000000;\n    const ColorEntry *entry;\n    char color_name[100];\n    len = FFMIN(FFMAX(len, 0), sizeof(color_name) - 1);\n    if (*p == '#') {\n        p++;\n        len--;\n        if (len == 3) {\n            ret |= (hex_char_to_number(p[2]) <<  4) |\n                   (hex_char_to_number(p[1]) << 12) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 4) {\n            ret  = (hex_char_to_number(p[3]) <<  4) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 20) |\n                   (hex_char_to_number(p[0]) << 28);\n        } else if (len == 6) {\n            ret |=  hex_char_to_number(p[5])        |\n                   (hex_char_to_number(p[4]) <<  4) |\n                   (hex_char_to_number(p[3]) <<  8) |\n                   (hex_char_to_number(p[2]) << 12) |\n                   (hex_char_to_number(p[1]) << 16) |\n                   (hex_char_to_number(p[0]) << 20);\n        } else if (len == 8) {\n            ret  =  hex_char_to_number(p[7])        |\n                   (hex_char_to_number(p[6]) <<  4) |\n                   (hex_char_to_number(p[5]) <<  8) |\n                   (hex_char_to_number(p[4]) << 12) |\n                   (hex_char_to_number(p[3]) << 16) |\n                   (hex_char_to_number(p[2]) << 20) |\n                   (hex_char_to_number(p[1]) << 24) |\n                   (hex_char_to_number(p[0]) << 28);\n        }\n    } else {\n        strncpy(color_name, p, len);\n        color_name[len] = '\\0';\n        entry = bsearch(color_name,\n                        color_table,\n                        FF_ARRAY_ELEMS(color_table),\n                        sizeof(ColorEntry),\n                        color_table_compare);\n        if (!entry)\n            return ret;\n        ret = entry->rgb_color;\n    }\n    return ret;\n}", "target": 0}
{"code": "FIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {\n  const struct timespec tm = {.tv_nsec = (nano_sec % 1000000000),\n                              .tv_sec = (nano_sec / 1000000000)};\n  nanosleep(&tm, NULL);\n}", "target": 1}
{"code": "void RenderWidgetHostImpl::ForwardMouseEvent(const WebMouseEvent& mouse_event) {\n  ForwardMouseEventWithLatencyInfo(mouse_event, ui::LatencyInfo());\n  if (owner_delegate_)\n    owner_delegate_->RenderWidgetDidForwardMouseEvent(mouse_event);\n}", "target": 0}
{"code": "oftrace_node_list_destroy(struct ovs_list *nodes)\n{\n    if (nodes) {\n        struct oftrace_node *node, *next;\n        LIST_FOR_EACH_SAFE (node, next, node, nodes) {\n            ovs_list_remove(&node->node);\n            oftrace_node_destroy(node);\n        }\n    }\n}", "target": 0}
{"code": "  DllDef float libraw_get_pre_mul(libraw_data_t *lr, int index)\n  {\n    if (!lr)\n      return EINVAL;\n    return lr->color.pre_mul[LIM(index, 0, 3)];\n  }", "target": 0}
{"code": "AP_DECLARE(int) ap_update_vhost_from_headers_ex(request_rec *r, int require_match)\n{\n    core_server_config *conf = ap_get_core_module_config(r->server->module_config);\n    const char *host_header = apr_table_get(r->headers_in, \"Host\");\n    int is_v6literal = 0;\n    int have_hostname_from_url = 0;\n    int rc = HTTP_OK;\n    if (r->hostname) {\n        have_hostname_from_url = 1;\n        is_v6literal = fix_hostname(r, NULL, conf->http_conformance);\n    }\n    else if (host_header != NULL) {\n        is_v6literal = fix_hostname(r, host_header, conf->http_conformance);\n    }\n    if (!require_match && r->status != HTTP_OK)\n        return HTTP_OK;\n    if (conf->http_conformance != AP_HTTP_CONFORMANCE_UNSAFE) {\n        if (have_hostname_from_url && host_header != NULL) {\n            const char *repl = construct_host_header(r, is_v6literal);\n            apr_table_setn(r->headers_in, \"Host\", repl);\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02417)\n                          \"Replacing host header '%s' with host '%s' given \"\n                          \"in the request uri\", host_header, repl);\n        }\n    }\n    if (r->connection->vhost_lookup_data) {\n        if (r->hostname)\n            rc = update_server_from_aliases(r);\n        else\n            check_serverpath(r);\n    }\n    else if (require_match && r->hostname) { \n        rc = update_server_from_aliases(r);\n    }\n    return rc;\n}", "target": 0}
{"code": "static RzList  *__io_maps(RzDebug *dbg) {\n\tRzList *list = rz_list_new();\n\tchar *str = dbg->iob.system(dbg->iob.io, \"dm\");\n\tif (!str) {\n\t\trz_list_free(list);\n\t\treturn NULL;\n\t}\n\tchar *ostr = str;\n\tut64 map_start, map_end;\n\tchar perm[32];\n\tchar name[512];\n\tfor (;;) {\n\t\tchar *nl = strchr(str, '\\n');\n\t\tif (nl) {\n\t\t\t*nl = 0;\n\t\t\t*name = 0;\n\t\t\t*perm = 0;\n\t\t\tmap_start = map_end = 0LL;\n\t\t\tif (!strncmp(str, \"sys \", 4)) {\n\t\t\t\tchar *sp = strchr(str + 4, ' ');\n\t\t\t\tif (sp) {\n\t\t\t\t\tstr = sp + 1;\n\t\t\t\t} else {\n\t\t\t\t\tstr += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar *_s_ = strstr(str, \" s \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\t_s_ = strstr(str, \" ? \");\n\t\t\tif (_s_) {\n\t\t\t\tmemmove(_s_, _s_ + 2, strlen(_s_));\n\t\t\t}\n\t\t\tsscanf(str, \"0x%\" PFMT64x \" - 0x%\" PFMT64x \" %s %s\",\n\t\t\t\t&map_start, &map_end, perm, name);\n\t\t\tif (map_end != 0LL) {\n\t\t\t\tRzDebugMap *map = rz_debug_map_new(name, map_start, map_end, rz_str_rwx(perm), 0);\n\t\t\t\trz_list_append(list, map);\n\t\t\t}\n\t\t\tstr = nl + 1;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(ostr);\n\trz_cons_reset();\n\treturn list;\n}", "target": 1}
{"code": "device_drive_benchmark (Device *device,\n                        gboolean do_write_benchmark,\n                        char **options,\n                        DBusGMethodInvocation *context)\n{\n  if (!device->priv->device_is_drive)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not a drive\");\n      goto out;\n    }\n  daemon_local_check_auth (device->priv->daemon,\n                           device,\n                           \"org.freedesktop.udisks.change\",\n                           \"DriveBenchmark\",\n                           TRUE,\n                           device_drive_benchmark_authorized_cb,\n                           context,\n                           2,\n                           GINT_TO_POINTER (do_write_benchmark),\n                           NULL,\n                           g_strdupv (options),\n                           g_strfreev);\n out:\n  return TRUE;\n}", "target": 0}
{"code": "static void check_registration_keywords(hook_user_register_check_t *hdata)\n{\n\tif (hdata->approved || !anope_flags_compat)\n\t{\n\t\treturn;\n\t}\n\tif (!strcasecmp(hdata->account, \"LIST\") || !strcasecmp(hdata->account, \"CLEAR\") || !strcasecmp(hdata->account, \"MODIFY\"))\n\t{\n\t\tcommand_fail(hdata->si, fault_badparams, \"The nick \\2%s\\2 is reserved and cannot be registered.\", hdata->account);\n\t\thdata->approved = 1;\n\t}\n}", "target": 0}
{"code": "bool Router::MatchView(const std::string& method, const std::string& url,\n                       bool* stream) {\n  assert(stream != nullptr);\n  *stream = false;\n  for (auto& route : routes_) {\n    if (std::find(route.methods.begin(), route.methods.end(), method) ==\n        route.methods.end()) {\n      continue;\n    }\n    if (route.url.empty()) {\n      std::smatch match;\n      if (std::regex_match(url, match, route.url_regex)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    } else {\n      if (boost::iequals(route.url, url)) {\n        *stream = route.view->Stream(method);\n        return true;\n      }\n    }\n  }\n  return false;\n}", "target": 1}
{"code": "struct dns_https_param *dns_get_HTTPS_svcparm_start(struct dns_rrs *rrs, char *domain, int maxsize, int *ttl,\n\t\t\t\t\t\t\t\t\t\t\t\t\tint *priority, char *target, int target_size)\n{\n\tint qtype = 0;\n\tunsigned char *data = NULL;\n\tint rr_len = 0;\n\tdata = dns_get_rr_nested_start(rrs, domain, maxsize, &qtype, ttl, &rr_len);\n\tif (data == NULL) {\n\t\treturn NULL;\n\t}\n\tif (qtype != DNS_T_HTTPS) {\n\t\treturn NULL;\n\t}\n\tif (rr_len < 2) {\n\t\treturn NULL;\n\t}\n\t*priority = _dns_read_short(&data);\n\trr_len -= 2;\n\tif (rr_len <= 0) {\n\t\treturn NULL;\n\t}\n\tint len = strnlen((char *)data, rr_len);\n\tsafe_strncpy(target, (char *)data, target_size);\n\tdata += len + 1;\n\trr_len -= len + 1;\n\tif (rr_len <= 0) {\n\t\treturn NULL;\n\t}\n\treturn (struct dns_https_param *)data;\n}", "target": 1}
{"code": "static int adpt_open(struct inode *inode, struct file *file)\n{\n\tint minor;\n\tadpt_hba* pHba;\n\tmutex_lock(&adpt_mutex);\n\tminor = iminor(inode);\n\tif (minor >= hba_count) {\n\t\tmutex_unlock(&adpt_mutex);\n\t\treturn -ENXIO;\n\t}\n\tmutex_lock(&adpt_configuration_lock);\n\tfor (pHba = hba_chain; pHba; pHba = pHba->next) {\n\t\tif (pHba->unit == minor) {\n\t\t\tbreak;\t\n\t\t}\n\t}\n\tif (pHba == NULL) {\n\t\tmutex_unlock(&adpt_configuration_lock);\n\t\tmutex_unlock(&adpt_mutex);\n\t\treturn -ENXIO;\n\t}\n\tpHba->in_use = 1;\n\tmutex_unlock(&adpt_configuration_lock);\n\tmutex_unlock(&adpt_mutex);\n\treturn 0;\n}", "target": 1}
{"code": "struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t *entry;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tut8 b[512];\n\tZERO_FILL (b);\n\tentry = PE_ (r_bin_pe_get_entrypoint) (pe);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x\"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\tif (b[367] == 0xe8) {\n\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);\n\t\treturn entry;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < 512 - 16 ; i++) {\n\t\tif (!memcmp (b + i, \"\\xff\\x15\", 2)) {\n\t\t\tif (b[i + 6] == 0x50) {\n\t\t\t\tif (b[i + 7] == 0xe8) {\n\t\t\t\t\tfollow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);\n\t\t\t\t\treturn entry;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}", "target": 1}
{"code": "static void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tvmcs_writel(field, vmcs_readl(field) | mask);\n}", "target": 0}
{"code": "static int persist__subs_save_all(FILE *db_fptr)\n{\n\tstruct mosquitto__subhier *subhier, *subhier_tmp;\n\tHASH_ITER(hh, db.subs, subhier, subhier_tmp){\n\t\tif(subhier->children){\n\t\t\tpersist__subs_save(db_fptr, subhier->children, \"\", 0);\n\t\t}\n\t}\n\treturn MOSQ_ERR_SUCCESS;\n}", "target": 1}
{"code": "Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {\n    Sfdouble_t d;\n    char *last;\n    if (*str == 0) {\n        if (ptr) *ptr = (char *)str;\n        return 0;\n    }\n    errno = 0;\n    d = number(str, &last, shp->inarith ? 0 : 10, NULL);\n    if (*last) {\n        if (*last != '.' || last[1] != '.') {\n            d = strval(shp, str, &last, arith, mode);\n            Varsubscript = true;\n        }\n        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);\n    } else if (!d && *str == '-') {\n        d = -0.0;\n    }\n    if (ptr) *ptr = last;\n    return d;\n}", "target": 1}
{"code": "static void drop_privs(void)\n{\n\tif (getuid() != 0) {\n\t\toldfsuid = setfsuid(getuid());\n\t\toldfsgid = setfsgid(getgid());\n\t}\n}", "target": 0}
{"code": "init_pyfribidi (void)\n{\n        PyObject *module = Py_InitModule (\"_pyfribidi\", PyfribidiMethods);\n\tPyModule_AddIntConstant (module, \"RTL\", (long) FRIBIDI_TYPE_RTL);\n\tPyModule_AddIntConstant (module, \"LTR\", (long) FRIBIDI_TYPE_LTR);\n\tPyModule_AddIntConstant (module, \"ON\", (long) FRIBIDI_TYPE_ON);\n}", "target": 0}
{"code": "eui64_to_display(wmem_allocator_t *allocator, const guint64 addr_eui64)\n{\n    guint8 *addr = (guint8 *)wmem_alloc(NULL, 8);\n    hashmanuf_t *manuf_value;\n    gchar *ret;\n    *(guint64 *)(void *)(addr) = pntoh64(&(addr_eui64));\n    manuf_value = manuf_name_lookup(addr);\n    if (!gbl_resolv_flags.mac_name || (manuf_value->status == HASHETHER_STATUS_UNRESOLVED)) {\n        ret = wmem_strdup_printf(allocator, \"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\", addr[0], addr[1], addr[2], addr[3], addr[4], addr[5], addr[6], addr[7]);\n    } else {\n        ret = wmem_strdup_printf(allocator, \"%s_%02x:%02x:%02x:%02x:%02x\", manuf_value->resolved_name, addr[3], addr[4], addr[5], addr[6], addr[7]);\n    }\n    wmem_free(NULL, addr);\n    return ret;\n} ", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tattr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tif (attr) {\n\t\tattr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR;\n\t\tattr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset);\n\t\toffset += 2;\n\t\tattr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free);\n\t\tfor (i = 0; i < attr->info.rtv_annotations_attr.num_annotations; i++) {\n\t\t\tif (offset >= sz) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tRBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset);\n\t\t\tif (annotation) {\n\t\t\t\toffset += annotation->size;\n\t\t\t}\n\t\t\tr_list_append (attr->info.annotation_array.annotations, (void *) annotation);\n\t\t}\n\t\tattr->size = offset;\n\t}\n\treturn attr;\n}", "target": 1}
{"code": "int bind_ports(void) {\n    SERVICE_OPTIONS *opt;\n    int listening_section;\n#ifdef USE_LIBWRAP\n    libwrap_init();\n#endif \n    s_poll_init(fds, 1);\n    for(opt=service_options.next; opt; opt=opt->next) {\n        unsigned i;\n        for(i=0; i<opt->local_addr.num; ++i)\n            opt->local_fd[i]=INVALID_SOCKET;\n    }\n    listening_section=0;\n    for(opt=service_options.next; opt; opt=opt->next) {\n        opt->bound_ports=0;\n        if(opt->local_addr.num) { \n            unsigned i;\n            s_log(LOG_DEBUG, \"Binding service [%s]\", opt->servname);\n            for(i=0; i<opt->local_addr.num; ++i) {\n                SOCKET fd;\n                fd=bind_port(opt, listening_section, i);\n                opt->local_fd[i]=fd;\n                if(fd!=INVALID_SOCKET) {\n                    s_poll_add(fds, fd, 1, 0);\n                    ++opt->bound_ports;\n                }\n            }\n            if(!opt->bound_ports) {\n                s_log(LOG_ERR, \"Binding service [%s] failed\", opt->servname);\n                return 1;\n            }\n            ++listening_section;\n        } else if(opt->exec_name && opt->connect_addr.names) {\n            s_log(LOG_DEBUG, \"Skipped exec+connect service [%s]\", opt->servname);\n#ifndef OPENSSL_NO_TLSEXT\n        } else if(!opt->option.client && opt->sni) {\n            s_log(LOG_DEBUG, \"Skipped SNI slave service [%s]\", opt->servname);\n#endif\n        } else { \n            s_log(LOG_ERR, \"Invalid service [%s]\", opt->servname);\n            return 1;\n        }\n    }\n    if(listening_section<systemd_fds) {\n        s_log(LOG_ERR,\n            \"Too many listening file descriptors received from systemd, got %d\",\n            systemd_fds);\n        return 1;\n    }\n    return 0; \n}", "target": 1}
{"code": "static const gchar* fcwwn_name_res_str(const address* addr)\n{\n    const guint8 *addrp = (const guint8*)addr->data;\n    int fmt;\n    guint8 oui[6];\n    fmt = (addrp[0] & 0xF0) >> 4;\n    switch (fmt) {\n    case FC_NH_NAA_IEEE:\n    case FC_NH_NAA_IEEE_E:\n        memcpy (oui, &addrp[2], 6);\n        return get_manuf_name(oui);\n    case FC_NH_NAA_IEEE_R:\n        oui[0] = ((addrp[0] & 0x0F) << 4) | ((addrp[1] & 0xF0) >> 4);\n        oui[1] = ((addrp[1] & 0x0F) << 4) | ((addrp[2] & 0xF0) >> 4);\n        oui[2] = ((addrp[2] & 0x0F) << 4) | ((addrp[3] & 0xF0) >> 4);\n        oui[3] = ((addrp[3] & 0x0F) << 4) | ((addrp[4] & 0xF0) >> 4);\n        oui[4] = ((addrp[4] & 0x0F) << 4) | ((addrp[5] & 0xF0) >> 4);\n        oui[5] = ((addrp[5] & 0x0F) << 4) | ((addrp[6] & 0xF0) >> 4);\n        return get_manuf_name(oui);\n    }\n    return \"\";\n}", "target": 1}
{"code": "ev_archive_reset (EvArchive *archive)\n{\n\tg_return_if_fail (EV_IS_ARCHIVE (archive));\n\tg_return_if_fail (archive->type != EV_ARCHIVE_TYPE_NONE);\n\tswitch (archive->type) {\n\tcase EV_ARCHIVE_TYPE_RAR:\n\tcase EV_ARCHIVE_TYPE_ZIP:\n\tcase EV_ARCHIVE_TYPE_7Z:\n\tcase EV_ARCHIVE_TYPE_TAR:\n\t\tg_clear_pointer (&archive->libar, archive_free);\n\t\tlibarchive_set_archive_type (archive, archive->type);\n\t\tarchive->libar_entry = NULL;\n\t\tbreak;\n\tdefault:\n\t\tg_assert_not_reached ();\n\t}\n}", "target": 0}
{"code": "void WriteFromUrlOperation::GetDownloadTarget(\n    const base::Closure& continuation) {\n  DCHECK_CURRENTLY_ON(BrowserThread::FILE);\n  if (IsCancelled()) {\n    return;\n  }\n  if (url_.ExtractFileName().empty()) {\n    if (!base::CreateTemporaryFileInDir(temp_dir_.GetPath(), &image_path_)) {\n      Error(error::kTempFileError);\n      return;\n    }\n  } else {\n    base::FilePath file_name =\n        base::FilePath::FromUTF8Unsafe(url_.ExtractFileName());\n    image_path_ = temp_dir_.GetPath().Append(file_name);\n  }\n  BrowserThread::PostTask(BrowserThread::FILE, FROM_HERE, continuation);\n}", "target": 0}
{"code": "is_valid_filename (const char *p)\n{\n\tif (!*p)\n\t\treturn 0;\n\treturn strpbrk (p, \"\\\\\n}", "target": 0}
{"code": "create_principal_2_svc(cprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->rec.principal, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (CHANGEPW_SERVICE(rqstp)\n        || !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_ADD,\n                               arg->rec.principal, &rp)\n        || kadm5int_acl_impose_restrictions(handle->context,\n                                            &arg->rec, &arg->mask, rp)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_principal((void *)handle,\n                                          &arg->rec, arg->mask,\n                                          arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "vips_tracked_malloc( size_t size )\n{\n        void *buf;\n\tvips_tracked_init(); \n\tsize += 16;\n        if( !(buf = g_try_malloc( size )) ) {\n#ifdef DEBUG\n\t\tg_assert_not_reached();\n#endif \n\t\tvips_error( \"vips_tracked\", \n\t\t\t_( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n\t\tg_warning( _( \"out of memory --- size == %dMB\" ), \n\t\t\t(int) (size / (1024.0 * 1024.0))  );\n                return( NULL );\n\t}\n\tg_mutex_lock( vips_tracked_mutex );\n\t*((size_t *)buf) = size;\n\tbuf = (void *) ((char *)buf + 16);\n\tvips_tracked_mem += size;\n\tif( vips_tracked_mem > vips_tracked_mem_highwater ) \n\t\tvips_tracked_mem_highwater = vips_tracked_mem;\n\tvips_tracked_allocs += 1;\n#ifdef DEBUG_VERBOSE\n\tprintf( \"vips_tracked_malloc: %p, %zd bytes\\n\", buf, size ); \n#endif \n\tg_mutex_unlock( vips_tracked_mutex );\n\tVIPS_GATE_MALLOC( size ); \n        return( buf );\n}", "target": 1}
{"code": "int HttpFileImpl::save(const std::string &path) const\n{\n    assert(!path.empty());\n    if (fileName_.empty())\n        return -1;\n    filesystem::path fsPath(utils::toNativePath(path));\n    if (!fsPath.is_absolute() &&\n        (!fsPath.has_parent_path() ||\n         (fsPath.begin()->string() != \".\" && fsPath.begin()->string() != \"..\")))\n    {\n        filesystem::path fsUploadPath(utils::toNativePath(\n            HttpAppFrameworkImpl::instance().getUploadPath()));\n        fsPath = fsUploadPath / fsPath;\n    }\n    filesystem::path fsFileName(utils::toNativePath(fileName_));\n    if (!filesystem::exists(fsPath))\n    {\n        LOG_TRACE << \"create path:\" << fsPath;\n        drogon::error_code err;\n        filesystem::create_directories(fsPath, err);\n        if (err)\n        {\n            LOG_SYSERR;\n            return -1;\n        }\n    }\n    return saveTo(fsPath / fsFileName);\n}", "target": 1}
{"code": "void Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}", "target": 1}
{"code": "void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)\n{\n    unsigned char *data = NULL;\n    int size;\n    loff_t offs;\n    if (new == -1)\n\tnew = FAT_EOF(fs);\n    else if ((long)new == -2)\n\tnew = FAT_BAD(fs);\n    switch (fs->fat_bits) {\n    case 12:\n\tdata = fs->fat + cluster * 3 / 2;\n\toffs = fs->fat_start + cluster * 3 / 2;\n\tif (cluster & 1) {\n\t    FAT_ENTRY prevEntry;\n\t    get_fat(&prevEntry, fs->fat, cluster - 1, fs);\n\t    data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);\n\t    data[1] = new >> 4;\n\t} else {\n\t    FAT_ENTRY subseqEntry;\n\t    if (cluster != fs->clusters - 1)\n\t\tget_fat(&subseqEntry, fs->fat, cluster + 1, fs);\n\t    else\n\t\tsubseqEntry.value = 0;\n\t    data[0] = new & 0xff;\n\t    data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);\n\t}\n\tsize = 2;\n\tbreak;\n    case 16:\n\tdata = fs->fat + cluster * 2;\n\toffs = fs->fat_start + cluster * 2;\n\t*(unsigned short *)data = htole16(new);\n\tsize = 2;\n\tbreak;\n    case 32:\n\t{\n\t    FAT_ENTRY curEntry;\n\t    get_fat(&curEntry, fs->fat, cluster, fs);\n\t    data = fs->fat + cluster * 4;\n\t    offs = fs->fat_start + cluster * 4;\n\t    *(uint32_t *)data = htole32((new & 0xfffffff) |\n\t\t\t\t\t     (curEntry.reserved << 28));\n\t    size = 4;\n\t}\n\tbreak;\n    default:\n\tdie(\"Bad FAT entry size: %d bits.\", fs->fat_bits);\n    }\n    fs_write(offs, size, data);\n    if (fs->nfats > 1) {\n\tfs_write(offs + fs->fat_size, size, data);\n    }\n}", "target": 1}
{"code": "void RenderView::OnUndo() {\n  if (!webview())\n    return;\n  webview()->focusedFrame()->executeCommand(WebString::fromUTF8(\"Undo\"));\n  UserMetricsRecordAction(\"Undo\");\n}", "target": 0}
{"code": "void mlock_vma_page(struct page *page)\n{\n\tBUG_ON(!PageLocked(page));\n\tif (!TestSetPageMlocked(page)) {\n\t\tmod_zone_page_state(page_zone(page), NR_MLOCK,\n\t\t\t\t    hpage_nr_pages(page));\n\t\tcount_vm_event(UNEVICTABLE_PGMLOCKED);\n\t\tif (!isolate_lru_page(page))\n\t\t\tputback_lru_page(page);\n\t}\n}", "target": 0}
{"code": "static int http_read_header(URLContext *h, int *new_location)\n{\n    HTTPContext *s = h->priv_data;\n    char line[MAX_URL_SIZE];\n    int err = 0;\n    s->chunksize = -1;\n    for (;;) {\n        if ((err = http_get_line(s, line, sizeof(line))) < 0)\n            return err;\n        av_log(h, AV_LOG_TRACE, \"header='%s'\\n\", line);\n        err = process_line(h, line, s->line_count, new_location);\n        if (err < 0)\n            return err;\n        if (err == 0)\n            break;\n        s->line_count++;\n    }\n    if (s->seekable == -1 && s->is_mediagateway && s->filesize == 2000000000)\n        h->is_streamed = 1; \n    cookie_string(s->cookie_dict, &s->cookies);\n    av_dict_free(&s->cookie_dict);\n    return err;\n}", "target": 1}
{"code": "static struct clock_source *dce120_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(*clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\t\t     regs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "TEST(GifTest, Gif) {\n  Env* env = Env::Default();\n  const string testdata_path = kTestData;\n  std::vector<DecodeGifTestCase> testcases(\n      {\n       {testdata_path + \"lena.gif\", 1, 51, 26, 3},\n       {testdata_path + \"optimized.gif\", 12, 20, 40, 3},\n       {testdata_path + \"red_black.gif\", 1, 16, 16, 3},\n       {testdata_path + \"scan.gif\", 12, 20, 40, 3},\n       {testdata_path + \"squares.gif\", 2, 16, 16, 3}});\n  for (const auto& tc : testcases) {\n    TestDecodeGif(env, tc);\n  }\n}", "target": 1}
{"code": "void Jsi_ValueArrayShift(Jsi_Interp *interp, Jsi_Value *v)\n{\n    if (v->vt != JSI_VT_OBJECT) {\n        Jsi_LogBug(\"Jsi_ValueArrayShift, target is not object\");\n        return;\n    }\n    Jsi_Obj *o = v->d.obj;\n    if (o->isarrlist) {\n        uint i;\n        if (!o->arrCnt)\n            return;\n        if (o->arr[0])\n            Jsi_DecrRefCount(interp, o->arr[0]);\n        for (i=1; i<o->arrCnt; i++) {\n            o->arr[i-1] = o->arr[i];\n        }\n        o->arr[o->arrCnt--] = NULL;\n        return;\n    }\n    int len = Jsi_ObjGetLength(interp, v->d.obj);\n    if (len <= 0) return;\n    Jsi_Value *v0 = Jsi_ValueArrayIndex(interp, v, 0);\n    if (!v0) return;\n    Jsi_ValueReset(interp, &v0);\n    int i;\n    Jsi_Value *last = v0;\n    for (i = 1; i < len; ++i) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, v, i);\n        if (!t) return;\n        Jsi_ValueCopy(interp, last, t);\n        Jsi_ValueReset(interp, &t);\n        last = t;\n    }\n    Jsi_ObjSetLength(interp, v->d.obj, len - 1);\n}", "target": 1}
{"code": "GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n{\n    size_t size, len;\n    BOOL ret = FALSE;\n    WCHAR *data = NULL;\n    DWORD bytes, read;\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n        ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n    }\n    size = bytes / sizeof(*data);\n    if (size == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    data = malloc(bytes);\n    if (data == NULL)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n        ReturnLastError(pipe, L\"malloc\");\n        goto out;\n    }\n    read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n    if (bytes != read)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n        ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n    }\n    if (data[size - 1] != 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n    sud->std_input = sud->options + len;\n    data = NULL; \n    ret = TRUE;\nout:\n    free(data);\n    return ret;\n}", "target": 1}
{"code": "archive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n#if !ARCHIVE_ACL_LIBRICHACL\n\t(void)mode;\t\n#endif\n#if ARCHIVE_ACL_LIBRICHACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_richacl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#if ARCHIVE_ACL_LIBACL\n\telse\n#endif\n#endif\t\n#if ARCHIVE_ACL_LIBACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t}\n#endif\t\n\treturn (ret);\n}", "target": 1}
{"code": "rfbClientIteratorNext(rfbClientIteratorPtr i)\n{\n  if (!i)\n    return NULL;\n  if(i->next == 0) {\n    LOCK(rfbClientListMutex);\n    i->next = i->screen->clientHead;\n    UNLOCK(rfbClientListMutex);\n  } else {\n    rfbClientPtr cl = i->next;\n    i->next = i->next->next;\n    rfbDecrClientRef(cl);\n  }\n#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)\n    if(!i->closedToo)\n      while(i->next && i->next->sock<0)\n        i->next = i->next->next;\n    if(i->next)\n      rfbIncrClientRef(i->next);\n#endif\n    return i->next;\n}", "target": 0}
{"code": "finalize_subnode_array(apr_array_header_t *array,\n                       limited_rights_t *sum,\n                       apr_pool_t *scratch_pool)\n{\n  if (array)\n    {\n      int i;\n      for (i = 0; i < array->nelts; ++i)\n        finalize_tree(APR_ARRAY_IDX(array, i, sorted_pattern_t).node, sum,\n                      scratch_pool);\n    }\n}", "target": 0}
{"code": "chpass_principal_2_svc(chpass_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {\n        ret.code = chpass_principal_wrapper_3((void *)handle, arg->princ,\n                                              FALSE, 0, NULL, arg->pass);\n    } else if (!(CHANGEPW_SERVICE(rqstp)) &&\n               kadm5int_acl_check(handle->context, rqst2name(rqstp),\n                                  ACL_CHANGEPW, arg->princ, NULL)) {\n        ret.code = kadm5_chpass_principal((void *)handle, arg->princ,\n                                          arg->pass);\n    } else {\n        log_unauth(\"kadm5_chpass_principal\", prime_arg,\n                   &client_name, &service_name, rqstp);\n        ret.code = KADM5_AUTH_CHANGEPW;\n    }\n    if (ret.code != KADM5_AUTH_CHANGEPW) {\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static RList* entries(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinAddr* addr = NULL;\n\tpsxexe_header psxheader;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tif (!(addr = R_NEW0 (RBinAddr))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"PSXEXE Header truncated\\n\");\n\t\tr_list_free (ret);\n\t\tfree (addr);\n\t\treturn NULL;\n\t}\n\taddr->paddr = (psxheader.pc0 - psxheader.t_addr) + PSXEXE_TEXTSECTION_OFFSET;\n\taddr->vaddr = psxheader.pc0;\n\tr_list_append (ret, addr);\n\treturn ret;\n}", "target": 1}
{"code": "static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"blkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_blkcipher.geniv ?: \"<default>\");\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "int extractVersionQuadFromString(const char* string, int* quad) {\n    const char* nextNumber = string;\n    for (int i = 0; i < 4; i++) {\n        quad[i] = (int)strtol(nextNumber, (char**)&nextNumber, 10);\n        if (*nextNumber != 0) {\n            nextNumber++;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "errno_t sss_filter_sanitize(TALLOC_CTX *mem_ctx,\n                            const char *input,\n                            char **sanitized)\n{\n    return sss_filter_sanitize_ex(mem_ctx, input, sanitized, NULL);\n}", "target": 1}
{"code": "int check_directory(struct dir *dir)\n{\n\tint i;\n\tstruct dir_ent *ent;\n\tif(dir->dir_count < 2)\n\t\treturn TRUE;\n\tfor(ent = dir->dirs, i = 0; i < dir->dir_count - 1; ent = ent->next, i++)\n\t\tif(strcmp(ent->name, ent->next->name) >= 0)\n\t\t\treturn FALSE;\n\treturn TRUE;\n}", "target": 0}
{"code": "rb_iter_peek(struct ring_buffer_iter *iter, u64 *ts)\n{\n\tstruct trace_buffer *buffer;\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint nr_loops = 0;\n\tif (ts)\n\t\t*ts = 0;\n\tcpu_buffer = iter->cpu_buffer;\n\tbuffer = cpu_buffer->buffer;\n\tif (unlikely(iter->cache_read != cpu_buffer->read ||\n\t\t     iter->cache_reader_page != cpu_buffer->reader_page))\n\t\trb_iter_reset(iter);\n again:\n\tif (ring_buffer_iter_empty(iter))\n\t\treturn NULL;\n\tif (++nr_loops > 3)\n\t\treturn NULL;\n\tif (rb_per_cpu_empty(cpu_buffer))\n\t\treturn NULL;\n\tif (iter->head >= rb_page_size(iter->head_page)) {\n\t\trb_inc_iter(iter);\n\t\tgoto again;\n\t}\n\tevent = rb_iter_head_event(iter);\n\tif (!event)\n\t\tgoto again;\n\tswitch (event->type_len) {\n\tcase RINGBUF_TYPE_PADDING:\n\t\tif (rb_null_event(event)) {\n\t\t\trb_inc_iter(iter);\n\t\t\tgoto again;\n\t\t}\n\t\trb_advance_iter(iter);\n\t\treturn event;\n\tcase RINGBUF_TYPE_TIME_EXTEND:\n\t\trb_advance_iter(iter);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_TIME_STAMP:\n\t\tif (ts) {\n\t\t\t*ts = rb_event_time_stamp(event);\n\t\t\tring_buffer_normalize_time_stamp(cpu_buffer->buffer,\n\t\t\t\t\t\t\t cpu_buffer->cpu, ts);\n\t\t}\n\t\trb_advance_iter(iter);\n\t\tgoto again;\n\tcase RINGBUF_TYPE_DATA:\n\t\tif (ts && !(*ts)) {\n\t\t\t*ts = iter->read_stamp + event->time_delta;\n\t\t\tring_buffer_normalize_time_stamp(buffer,\n\t\t\t\t\t\t\t cpu_buffer->cpu, ts);\n\t\t}\n\t\treturn event;\n\tdefault:\n\t\tRB_WARN_ON(cpu_buffer, 1);\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int zerocopy_sg_from_iovec(struct sk_buff *skb, const struct iovec *from,\n\t\t\t\t  int offset, size_t count)\n{\n\tint len = iov_length(from, count) - offset;\n\tint copy = skb_headlen(skb);\n\tint size, offset1 = 0;\n\tint i = 0;\n\twhile (count && (offset >= from->iov_len)) {\n\t\toffset -= from->iov_len;\n\t\t++from;\n\t\t--count;\n\t}\n\twhile (count && (copy > 0)) {\n\t\tsize = min_t(unsigned int, copy, from->iov_len - offset);\n\t\tif (copy_from_user(skb->data + offset1, from->iov_base + offset,\n\t\t\t\t   size))\n\t\t\treturn -EFAULT;\n\t\tif (copy > size) {\n\t\t\t++from;\n\t\t\t--count;\n\t\t\toffset = 0;\n\t\t} else\n\t\t\toffset += size;\n\t\tcopy -= size;\n\t\toffset1 += size;\n\t}\n\tif (len == offset1)\n\t\treturn 0;\n\twhile (count--) {\n\t\tstruct page *page[MAX_SKB_FRAGS];\n\t\tint num_pages;\n\t\tunsigned long base;\n\t\tunsigned long truesize;\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif ((num_pages != size) ||\n\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {\n\t\t\tint off = base & ~PAGE_MASK;\n\t\t\tint size = min_t(int, len, PAGE_SIZE - off);\n\t\t\t__skb_fill_page_desc(skb, i, page[i], off, size);\n\t\t\tskb_shinfo(skb)->nr_frags++;\n\t\t\tbase += size;\n\t\t\tlen -= size;\n\t\t\ti++;\n\t\t}\n\t\toffset = 0;\n\t\t++from;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "static Elf64_Sym * __init find_symbol64(struct lib64_elfinfo *lib,\n\t\t\t\t\tconst char *symname)\n{\n\tunsigned int i;\n\tchar name[MAX_SYMNAME], *c;\n\tfor (i = 0; i < (lib->dynsymsize / sizeof(Elf64_Sym)); i++) {\n\t\tif (lib->dynsym[i].st_name == 0)\n\t\t\tcontinue;\n\t\tstrlcpy(name, lib->dynstr + lib->dynsym[i].st_name,\n\t\t\tMAX_SYMNAME);\n\t\tc = strchr(name, '@');\n\t\tif (c)\n\t\t\t*c = 0;\n\t\tif (strcmp(symname, name) == 0)\n\t\t\treturn &lib->dynsym[i];\n\t}\n\treturn NULL;\n}", "target": 0}
{"code": "static int SetupSavePath(const DetectEngineCtx *de_ctx,\n        char *save, size_t save_size)\n{\n    SCLogDebug(\"save %s\", save);\n    int allow_save = 1;\n    if (ConfGetBool(\"datasets.rules.allow-write\", &allow_save)) {\n        if (!allow_save) {\n            SCLogError(SC_ERR_INVALID_SIGNATURE,\n                    \"Rules containing save/state datasets have been disabled\");\n            return -1;\n        }\n    }\n    int allow_absolute = 0;\n    (void)ConfGetBool(\"datasets.rules.allow-absolute-filenames\", &allow_absolute);\n    if (allow_absolute) {\n        SCLogNotice(\"Allowing absolute filename for dataset rule: %s\", save);\n    } else {\n        if (PathIsAbsolute(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Absolute paths not allowed: %s\", save);\n            return -1;\n        }\n        if (SCPathContainsTraversal(save)) {\n            SCLogError(SC_ERR_INVALID_ARGUMENT, \"Directory traversals not allowed: %s\", save);\n            return -1;\n        }\n    }\n    const char *dir = ConfigGetDataDirectory();\n    BUG_ON(dir == NULL); \n    char path[PATH_MAX];\n    if (snprintf(path, sizeof(path), \"%s/%s\", dir, save) >= (int)sizeof(path)) \n        return -1;\n    strlcpy(save, path, save_size);\n    return 0;\n}", "target": 0}
{"code": "int main()\n{\n    gdImagePtr im;\n    FILE *fp;\n    fp = gdTestFileOpen2(\"gd2\", \"too_few_image_data.gd2\");\n    gdTestAssert(fp != NULL);\n    im = gdImageCreateFromGd2(fp);\n    gdTestAssert(im == NULL);\n    fclose(fp);\n    return gdNumFailures();\n}", "target": 0}
{"code": "static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,\n\t\t\t\t\t      struct userfaultfd_wait_queue *ewq)\n{\n\tstruct userfaultfd_ctx *release_new_ctx;\n\tif (WARN_ON_ONCE(current->flags & PF_EXITING))\n\t\tgoto out;\n\tewq->ctx = ctx;\n\tinit_waitqueue_entry(&ewq->wq, current);\n\trelease_new_ctx = NULL;\n\tspin_lock(&ctx->event_wqh.lock);\n\t__add_wait_queue(&ctx->event_wqh, &ewq->wq);\n\tfor (;;) {\n\t\tset_current_state(TASK_KILLABLE);\n\t\tif (ewq->msg.event == 0)\n\t\t\tbreak;\n\t\tif (READ_ONCE(ctx->released) ||\n\t\t    fatal_signal_pending(current)) {\n\t\t\t__remove_wait_queue(&ctx->event_wqh, &ewq->wq);\n\t\t\tif (ewq->msg.event == UFFD_EVENT_FORK) {\n\t\t\t\tstruct userfaultfd_ctx *new;\n\t\t\t\tnew = (struct userfaultfd_ctx *)\n\t\t\t\t\t(unsigned long)\n\t\t\t\t\tewq->msg.arg.reserved.reserved1;\n\t\t\t\trelease_new_ctx = new;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&ctx->event_wqh.lock);\n\t\twake_up_poll(&ctx->fd_wqh, EPOLLIN);\n\t\tschedule();\n\t\tspin_lock(&ctx->event_wqh.lock);\n\t}\n\t__set_current_state(TASK_RUNNING);\n\tspin_unlock(&ctx->event_wqh.lock);\n\tif (release_new_ctx) {\n\t\tstruct vm_area_struct *vma;\n\t\tstruct mm_struct *mm = release_new_ctx->mm;\n\t\tdown_write(&mm->mmap_sem);\n\t\tVM_WARN_ON(!mmget_still_valid(mm));\n\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next)\n\t\t\tif (vma->vm_userfaultfd_ctx.ctx == release_new_ctx) {\n\t\t\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\t\t\tvma->vm_flags &= ~(VM_UFFD_WP | VM_UFFD_MISSING);\n\t\t\t}\n\t\tup_write(&mm->mmap_sem);\n\t\tuserfaultfd_ctx_put(release_new_ctx);\n\t}\nout:\n\tWRITE_ONCE(ctx->mmap_changing, false);\n\tuserfaultfd_ctx_put(ctx);\n}", "target": 0}
{"code": "  void getReadBuffer(void** bufReturn, size_t* lenReturn) override {\n    *bufReturn = buf_.data();\n    *lenReturn = buf_.size();\n  }", "target": 0}
{"code": "ConnectToRFBServer(rfbClient* client,const char *hostname, int port)\n{\n  if (client->serverPort==-1) {\n    const char* magic=\"vncLog0.0\";\n    char buffer[10];\n    rfbVNCRec* rec = (rfbVNCRec*)malloc(sizeof(rfbVNCRec));\n    client->vncRec = rec;\n    rec->file = fopen(client->serverHost,\"rb\");\n    rec->tv.tv_sec = 0;\n    rec->readTimestamp = FALSE;\n    rec->doNotSleep = FALSE;\n    if (!rec->file) {\n      rfbClientLog(\"Could not open %s.\\n\",client->serverHost);\n      return FALSE;\n    }\n    setbuf(rec->file,NULL);\n    if (fread(buffer,1,strlen(magic),rec->file) != strlen(magic) || strncmp(buffer,magic,strlen(magic))) {\n      rfbClientLog(\"File %s was not recorded by vncrec.\\n\",client->serverHost);\n      fclose(rec->file);\n      return FALSE;\n    }\n    client->sock = -1;\n    return TRUE;\n  }\n#ifndef WIN32\n  if(IsUnixSocket(hostname))\n    client->sock = ConnectClientToUnixSock(hostname);\n  else\n#endif\n  {\n#ifdef LIBVNCSERVER_IPv6\n    client->sock = ConnectClientToTcpAddr6(hostname, port);\n    if (client->sock == -1)\n#endif\n    {\n      unsigned int host;\n      if (!StringToIPAddr(hostname, &host)) {\n        rfbClientLog(\"Couldn't convert '%s' to host address\\n\", hostname);\n        return FALSE;\n      }\n      client->sock = ConnectClientToTcpAddr(host, port);\n    }\n  }\n  if (client->sock < 0) {\n    rfbClientLog(\"Unable to connect to VNC server\\n\");\n    return FALSE;\n  }\n  if(client->QoS_DSCP && !SetDSCP(client->sock, client->QoS_DSCP))\n     return FALSE;\n  return SetNonBlocking(client->sock);\n}", "target": 0}
{"code": "static void cjson_get_object_item_should_not_crash_with_array(void) {\n    cJSON *array = NULL;\n    cJSON *found = NULL;\n    array = cJSON_Parse(\"[1]\");\n    found = cJSON_GetObjectItem(array, \"name\");\n    TEST_ASSERT_NULL(found);\n    cJSON_Delete(array);\n}", "target": 0}
{"code": "int nsim_bpf(struct net_device *dev, struct netdev_bpf *bpf)\n{\n\tstruct netdevsim *ns = netdev_priv(dev);\n\tint err;\n\tASSERT_RTNL();\n\tswitch (bpf->command) {\n\tcase XDP_SETUP_PROG:\n\t\terr = nsim_setup_prog_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp);\n\tcase XDP_SETUP_PROG_HW:\n\t\terr = nsim_setup_prog_hw_checks(ns, bpf);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn nsim_xdp_set_prog(ns, bpf, &ns->xdp_hw);\n\tcase BPF_OFFLOAD_MAP_ALLOC:\n\t\tif (!ns->bpf_map_accept)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn nsim_bpf_map_alloc(ns, bpf->offmap);\n\tcase BPF_OFFLOAD_MAP_FREE:\n\t\tnsim_bpf_map_free(bpf->offmap);\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}", "target": 0}
{"code": "int rdma_create_qp(struct rdma_cm_id *id, struct ib_pd *pd,\n\t\t   struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct rdma_id_private *id_priv;\n\tstruct ib_qp *qp;\n\tint ret;\n\tid_priv = container_of(id, struct rdma_id_private, id);\n\tif (id->device != pd->device) {\n\t\tret = -EINVAL;\n\t\tgoto out_err;\n\t}\n\tqp_init_attr->port_num = id->port_num;\n\tqp = ib_create_qp(pd, qp_init_attr);\n\tif (IS_ERR(qp)) {\n\t\tret = PTR_ERR(qp);\n\t\tgoto out_err;\n\t}\n\tif (id->qp_type == IB_QPT_UD)\n\t\tret = cma_init_ud_qp(id_priv, qp);\n\telse\n\t\tret = cma_init_conn_qp(id_priv, qp);\n\tif (ret)\n\t\tgoto out_destroy;\n\tid->qp = qp;\n\tid_priv->qp_num = qp->qp_num;\n\tid_priv->srq = (qp->srq != NULL);\n\ttrace_cm_qp_create(id_priv, pd, qp_init_attr, 0);\n\treturn 0;\nout_destroy:\n\tib_destroy_qp(qp);\nout_err:\n\ttrace_cm_qp_create(id_priv, pd, qp_init_attr, ret);\n\treturn ret;\n}", "target": 0}
{"code": "FileInformation ImageReadJPEG(\n      Image& out,\n      String const& filename\n) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   int nchan = jpeg.cinfo().num_components;\n   jpeg.cinfo().out_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   out.ReForge( info.sizes, info.tensorElements, DT_UINT8, Option::AcceptDataTypeChange::DONT_ALLOW );\n   out.SetPixelSize( info.pixelSize );\n   out.SetColorSpace( info.colorSpace );\n   jpeg_start_decompress( jpeg.cinfoptr() );\n   std::vector< JSAMPLE > buffer( info.sizes[ 0 ] * static_cast< unsigned >( nchan )); \n   dip::uint8* imagedata = static_cast< dip::uint8* >( out.Origin() );\n   auto stride = out.Strides();\n   auto tStride = out.TensorStride();\n   for( dip::uint ii = 0; ii < info.sizes[ 1 ]; ++ii ) {\n      JSAMPLE* indata = buffer.data();\n      jpeg_read_scanlines( jpeg.cinfoptr(), &indata, 1 );\n      dip::uint8* outdata = imagedata;\n      if( nchan > 1 ) {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            for( int kk = 0; kk < nchan; ++kk ) {\n               *( outdata + kk * tStride ) = *indata;\n               ++indata;\n            }\n            outdata += stride[ 0 ];\n         }\n      } else {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            *outdata = *indata;\n            ++indata;\n            outdata += stride[ 0 ];\n         }\n      }\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_decompress( jpeg.cinfoptr() );\n   return info;\n}", "target": 1}
{"code": "nfsd4_getattr(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,\n\t      union nfsd4_op_u *u)\n{\n\tstruct nfsd4_getattr *getattr = &u->getattr;\n\t__be32 status;\n\tstatus = fh_verify(rqstp, &cstate->current_fh, 0, NFSD_MAY_NOP);\n\tif (status)\n\t\treturn status;\n\tif (getattr->ga_bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1)\n\t\treturn nfserr_inval;\n\tgetattr->ga_bmval[0] &= nfsd_suppattrs[cstate->minorversion][0];\n\tgetattr->ga_bmval[1] &= nfsd_suppattrs[cstate->minorversion][1];\n\tgetattr->ga_bmval[2] &= nfsd_suppattrs[cstate->minorversion][2];\n\tgetattr->ga_fhp = &cstate->current_fh;\n\treturn nfs_ok;\n}", "target": 0}
{"code": "static int nfs4_proc_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle, struct nfs_fsinfo *fsinfo)\n{\n\tint error;\n\tnfs_fattr_init(fsinfo->fattr);\n\terror = nfs4_do_fsinfo(server, fhandle, fsinfo);\n\tif (error == 0) {\n\t\tserver->pnfs_blksize = fsinfo->blksize;\n\t\tset_pnfs_layoutdriver(server, fhandle, fsinfo->layouttype);\n\t}\n\treturn error;\n}", "target": 0}
{"code": "TfLiteStatus SimpleStatefulOp::Invoke(TfLiteContext* context,\n                                      TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n  *data->invoke_count += 1;\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const uint8_t* input_data = GetTensorData<uint8_t>(input);\n  int size = NumElements(input->dims);\n  uint8_t* sorting_buffer = reinterpret_cast<uint8_t*>(\n      context->GetScratchBuffer(context, data->sorting_buffer));\n  for (int i = 0; i < size; i++) {\n    sorting_buffer[i] = input_data[i];\n  }\n  for (int i = 1; i < size; i++) {\n    for (int j = i; j > 0 && sorting_buffer[j] < sorting_buffer[j - 1]; j--) {\n      std::swap(sorting_buffer[j], sorting_buffer[j - 1]);\n    }\n  }\n  TfLiteTensor* median = GetOutput(context, node, kMedianTensor);\n  uint8_t* median_data = GetTensorData<uint8_t>(median);\n  TfLiteTensor* invoke_count = GetOutput(context, node, kInvokeCount);\n  int32_t* invoke_count_data = GetTensorData<int32_t>(invoke_count);\n  median_data[0] = sorting_buffer[size / 2];\n  invoke_count_data[0] = *data->invoke_count;\n  return kTfLiteOk;\n}", "target": 1}
{"code": "static void sock_def_wakeup(struct sock *sk)\n{\n\tread_lock(&sk->sk_callback_lock);\n\tif (sk->sk_sleep && waitqueue_active(sk->sk_sleep))\n\t\twake_up_interruptible_all(sk->sk_sleep);\n\tread_unlock(&sk->sk_callback_lock);\n}", "target": 0}
{"code": "match_to_s(VALUE match)\n{\n    VALUE str = rb_reg_last_match(match);\n    match_check(match);\n    if (NIL_P(str)) str = rb_str_new(0,0);\n    if (OBJ_TAINTED(match)) OBJ_TAINT(str);\n    if (OBJ_TAINTED(RMATCH(match)->str)) OBJ_TAINT(str);\n    return str;\n}", "target": 0}
{"code": "static int scanbraces(const char* in) {\n    if (strncmp(in, \"{\\\\an\", 4) != 0) {\n        return 0;\n    }\n    if (!isdigit(in[4])) {\n        return 0;\n    }\n    if (in[5] != '}') {\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "GF_Box *emsg_box_new()\n{\n\tISOM_DECL_BOX_ALLOC(GF_EventMessageBox, GF_ISOM_BOX_TYPE_EMSG);\n\treturn (GF_Box *)tmp;\n}", "target": 0}
{"code": "  virtual bool ms_verify_authorizer(Connection *con,\n\t\t\t\t    int peer_type,\n\t\t\t\t    int protocol,\n\t\t\t\t    ceph::bufferlist& authorizer,\n\t\t\t\t    ceph::bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid,\n\t\t\t\t    CryptoKey& session_key) { return false; }", "target": 1}
{"code": "_TIFFmalloc(tsize_t s)\n{\n        if (s == 0)\n                return ((void *) NULL);\n\treturn (malloc((size_t) s));\n}", "target": 0}
{"code": "static int on_data_chunk_recv(nghttp2_session *session, uint8_t flags,\n                              int32_t stream_id, const uint8_t *data,\n                              size_t len, void *user_data)\n{\n    ogs_sbi_stream_t *stream = NULL;\n    ogs_sbi_request_t *request = NULL;\n    size_t offset = 0;\n    ogs_assert(session);\n    stream = nghttp2_session_get_stream_user_data(session, stream_id);\n    if (!stream) {\n        ogs_error(\"no stream [%d]\", stream_id);\n        return 0;\n    }\n    request = stream->request;\n    ogs_assert(request);\n    ogs_assert(data);\n    ogs_assert(len);\n    if (request->http.content == NULL) {\n        request->http.content_length = len;\n        request->http.content =\n            (char*)ogs_malloc(request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    } else {\n        offset = request->http.content_length;\n        if ((request->http.content_length + len) > OGS_HUGE_LEN) {\n            ogs_error(\"Overflow : Content-Length[%d], len[%d]\",\n                        (int)request->http.content_length, (int)len);\n            ogs_assert_if_reached();\n        }\n        request->http.content_length += len;\n        request->http.content = (char *)ogs_realloc(\n                request->http.content, request->http.content_length + 1);\n        ogs_assert(request->http.content);\n    }\n    memcpy(request->http.content + offset, data, len);\n    request->http.content[request->http.content_length] = '\\0';\n    return 0;\n}", "target": 1}
{"code": "static void vgacon_scrollback_init(int vc_num)\n{\n\tint pitch = vga_video_num_columns * 2;\n\tsize_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;\n\tint rows = size / pitch;\n\tvoid *data;\n\tdata = kmalloc_array(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024,\n\t\t\t     GFP_NOWAIT);\n\tvgacon_scrollbacks[vc_num].data = data;\n\tvgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];\n\tvgacon_scrollback_cur->rows = rows - 1;\n\tvgacon_scrollback_cur->size = rows * pitch;\n\tvgacon_scrollback_reset(vc_num, size);\n}", "target": 1}
{"code": "    FIO_NAME(_find_map_pos_)(FIO_NAME(s) * set, FIO_SET_HASH_TYPE hash_value,\n                             FIO_SET_TYPE obj) {\n  if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n    hash_value = FIO_SET_HASH_FORCE;\n  if (set->map) {\n    if (set->has_collisions && set->pos != set->count) {\n      FIO_NAME(rehash)(set);\n    }\n    size_t full_collisions_counter = 0;\n    FIO_NAME(_map_s_) * pos;\n    const uintptr_t mask = (1ULL << set->used_bits) - 1;\n    uintptr_t i;\n    const uintptr_t hash_value_i = FIO_SET_HASH2UINTPTR(hash_value, 0);\n    uintptr_t hash_alt = FIO_SET_HASH2UINTPTR(hash_value, set->used_bits);\n    pos = set->map + (hash_alt & mask);\n    if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n      return pos;\n    if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n      if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))\n        return pos;\n      set->has_collisions = 1;\n      ++full_collisions_counter;\n    }\n    i = 0;\n    const uintptr_t limit =\n        FIO_SET_CUCKOO_STEPS * (set->capa > (FIO_SET_MAX_MAP_SEEK << 2)\n                                    ? FIO_SET_MAX_MAP_SEEK\n                                    : (set->capa >> 2));\n    while (i < limit) {\n      i += FIO_SET_CUCKOO_STEPS;\n      pos = set->map + ((hash_alt + i) & mask);\n      if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n        return pos;\n      if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n        if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))\n          return pos;\n        set->has_collisions = 1;\n        if (++full_collisions_counter >= FIO_SET_MAX_MAP_FULL_COLLISIONS) {\n          FIO_LOG_WARNING(\n              \"(fio hash map) too many full collisions - under attack?\");\n          set->under_attack = 1;\n        }\n        if (set->under_attack) {\n          return pos;\n        }\n      }\n    }\n  }\n  return NULL;\n  (void)obj; \n}", "target": 1}
{"code": "const git_tree_entry *git_treebuilder_get(git_treebuilder *bld, const char *filename)\n{\n\treturn treebuilder_get(bld, filename);\n}", "target": 0}
{"code": "ciEnv::~ciEnv() {\n  CompilerThread* current_thread = CompilerThread::current();\n  _factory->remove_symbols();\n  GUARDED_VM_ENTRY(current_thread->set_env(NULL);)\n}", "target": 0}
{"code": "decode_sequence(const uint8_t *asn1, size_t len, const struct seq_info *seq,\n                void *val)\n{\n    krb5_error_code ret;\n    const uint8_t *contents;\n    size_t i, j, clen;\n    taginfo t;\n    assert(seq->n_fields > 0);\n    for (i = 0; i < seq->n_fields; i++) {\n        if (len == 0)\n            break;\n        ret = get_tag(asn1, len, &t, &contents, &clen, &asn1, &len);\n        if (ret)\n            goto error;\n        for (; i < seq->n_fields; i++) {\n            if (check_atype_tag(seq->fields[i], &t))\n                break;\n            ret = omit_atype(seq->fields[i], val);\n            if (ret)\n                goto error;\n        }\n        if (i == seq->n_fields)\n            break;\n        ret = decode_atype(&t, contents, clen, seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    for (; i < seq->n_fields; i++) {\n        ret = omit_atype(seq->fields[i], val);\n        if (ret)\n            goto error;\n    }\n    return 0;\nerror:\n    for (j = 0; j < i; j++)\n        free_atype(seq->fields[j], val);\n    for (j = 0; j < i; j++)\n        free_atype_ptr(seq->fields[j], val);\n    return ret;\n}", "target": 1}
{"code": "static pdf_creator_t *new_creator(int *n_elements)\n{\n    pdf_creator_t *daddy;\n    static const pdf_creator_t creator_template[] = \n    {\n        {\"Title\",        \"\"},\n        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n    daddy = malloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n    return daddy;\n}", "target": 1}
{"code": "enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method)\n{\n  char ibuf[LONG_STRING * 2], obuf[LONG_STRING];\n  unsigned char hmac_response[MD5_DIGEST_LEN];\n  int len;\n  int rc;\n  if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5))\n    return IMAP_AUTH_UNAVAIL;\n  mutt_message(_(\"Authenticating (CRAM-MD5)...\"));\n  if (mutt_account_getlogin(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  imap_cmd_start(idata, \"AUTHENTICATE CRAM-MD5\");\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    mutt_debug(1, \"Invalid response from server: %s\\n\", ibuf);\n    goto bail;\n  }\n  len = mutt_b64_decode(obuf, idata->buf + 2);\n  if (len == -1)\n  {\n    mutt_debug(1, \"Error decoding base64 response.\\n\");\n    goto bail;\n  }\n  obuf[len] = '\\0';\n  mutt_debug(2, \"CRAM challenge: %s\\n\", obuf);\n  hmac_md5(idata->conn->account.pass, obuf, hmac_response);\n  int off = snprintf(obuf, sizeof(obuf), \"%s \", idata->conn->account.user);\n  mutt_md5_toascii(hmac_response, obuf + off);\n  mutt_debug(2, \"CRAM response: %s\\n\", obuf);\n  mutt_b64_encode(ibuf, obuf, strlen(obuf), sizeof(ibuf) - 2);\n  mutt_str_strcat(ibuf, sizeof(ibuf), \"\\r\\n\");\n  mutt_socket_send(idata->conn, ibuf);\n  do\n    rc = imap_cmd_step(idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  if (rc != IMAP_CMD_OK)\n  {\n    mutt_debug(1, \"Error receiving server response.\\n\");\n    goto bail;\n  }\n  if (imap_code(idata->buf))\n    return IMAP_AUTH_SUCCESS;\nbail:\n  mutt_error(_(\"CRAM-MD5 authentication failed.\"));\n  return IMAP_AUTH_FAILURE;\n}", "target": 1}
{"code": "static UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); \n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); \n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path,\n\t                                     PathLength / sizeof(WCHAR), irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\treturn irp->Complete(irp);\n}", "target": 0}
{"code": "hb_set_symmetric_difference (hb_set_t       *set,\n\t\t\t     const hb_set_t *other)\n{\n  if (unlikely (hb_object_is_immutable (set)))\n    return;\n  set->symmetric_difference (*other);\n}", "target": 1}
{"code": "static int nlmsg_populate_mdb_fill(struct sk_buff *skb,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct br_mdb_entry *entry, u32 pid,\n\t\t\t\t   u32 seq, int type, unsigned int flags)\n{\n\tstruct nlmsghdr *nlh;\n\tstruct br_port_msg *bpm;\n\tstruct nlattr *nest, *nest2;\n\tnlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);\n\tif (!nlh)\n\t\treturn -EMSGSIZE;\n\tbpm = nlmsg_data(nlh);\n\tmemset(bpm, 0, sizeof(*bpm));\n\tbpm->family  = AF_BRIDGE;\n\tbpm->ifindex = dev->ifindex;\n\tnest = nla_nest_start(skb, MDBA_MDB);\n\tif (nest == NULL)\n\t\tgoto cancel;\n\tnest2 = nla_nest_start(skb, MDBA_MDB_ENTRY);\n\tif (nest2 == NULL)\n\t\tgoto end;\n\tif (nla_put(skb, MDBA_MDB_ENTRY_INFO, sizeof(*entry), entry))\n\t\tgoto end;\n\tnla_nest_end(skb, nest2);\n\tnla_nest_end(skb, nest);\n\treturn nlmsg_end(skb, nlh);\nend:\n\tnla_nest_end(skb, nest);\ncancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static void __exit pf_exit(void)\n{\n\tstruct pf_unit *pf;\n\tint unit;\n\tunregister_blkdev(major, name);\n\tfor (pf = units, unit = 0; unit < PF_UNITS; pf++, unit++) {\n\t\tif (!pf->disk)\n\t\t\tcontinue;\n\t\tif (pf->present)\n\t\t\tdel_gendisk(pf->disk);\n\t\tblk_cleanup_queue(pf->disk->queue);\n\t\tblk_mq_free_tag_set(&pf->tag_set);\n\t\tput_disk(pf->disk);\n\t\tif (pf->present)\n\t\t\tpi_release(pf->pi);\n\t}\n}", "target": 0}
{"code": "bool ParseAttrValue(StringPiece type, StringPiece text, AttrValue* out) {\n  string field_name;\n  bool is_list = absl::ConsumePrefix(&type, \"list(\");\n  if (absl::ConsumePrefix(&type, \"string\")) {\n    field_name = \"s\";\n  } else if (absl::ConsumePrefix(&type, \"int\")) {\n    field_name = \"i\";\n  } else if (absl::ConsumePrefix(&type, \"float\")) {\n    field_name = \"f\";\n  } else if (absl::ConsumePrefix(&type, \"bool\")) {\n    field_name = \"b\";\n  } else if (absl::ConsumePrefix(&type, \"type\")) {\n    field_name = \"type\";\n  } else if (absl::ConsumePrefix(&type, \"shape\")) {\n    field_name = \"shape\";\n  } else if (absl::ConsumePrefix(&type, \"tensor\")) {\n    field_name = \"tensor\";\n  } else if (absl::ConsumePrefix(&type, \"func\")) {\n    field_name = \"func\";\n  } else if (absl::ConsumePrefix(&type, \"placeholder\")) {\n    field_name = \"placeholder\";\n  } else {\n    return false;\n  }\n  if (is_list && !absl::ConsumePrefix(&type, \")\")) {\n    return false;\n  }\n  string to_parse;\n  if (is_list) {\n    StringPiece cleaned = text;\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    str_util::RemoveTrailingWhitespace(&cleaned);\n    if (cleaned.size() < 2 || cleaned[0] != '[' ||\n        cleaned[cleaned.size() - 1] != ']') {\n      return false;\n    }\n    cleaned.remove_prefix(1);\n    str_util::RemoveLeadingWhitespace(&cleaned);\n    if (cleaned.size() == 1) {\n      out->Clear();\n      out->mutable_list();\n      return true;\n    }\n    to_parse = strings::StrCat(\"list { \", field_name, \": \", text, \" }\");\n  } else {\n    to_parse = strings::StrCat(field_name, \": \", text);\n  }\n  return ProtoParseFromString(to_parse, out);\n}", "target": 1}
{"code": "static int shash_no_setkey(struct crypto_shash *tfm, const u8 *key,\n\t\t\t   unsigned int keylen)\n{\n\treturn -ENOSYS;\n}", "target": 1}
{"code": "Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onDownstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                         static_cast<uint32_t>(end_of_stream));\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}", "target": 1}
{"code": "create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_generic_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    prime_arg = arg->rec.policy;\n    if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                       rqst2name(rqstp),\n                                                       ACL_ADD, NULL, NULL)) {\n        ret.code = KADM5_AUTH_ADD;\n        log_unauth(\"kadm5_create_policy\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_create_policy((void *)handle, &arg->rec,\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "l_noret luaG_runerror (lua_State *L, const char *fmt, ...) {\n  CallInfo *ci = L->ci;\n  const char *msg;\n  va_list argp;\n  luaC_checkGC(L);  \n  va_start(argp, fmt);\n  msg = luaO_pushvfstring(L, fmt, argp);  \n  va_end(argp);\n  if (isLua(ci))  \n    luaG_addinfo(L, msg, ci_func(ci)->p->source, getcurrentline(ci));\n  luaG_errormsg(L);\n}", "target": 1}
{"code": "rpl_daoack_print(netdissect_options *ndo,\n                 const u_char *bp, u_int length)\n{\n        const struct nd_rpl_daoack *daoack = (const struct nd_rpl_daoack *)bp;\n        const char *dagid_str = \"<elided>\";\n        ND_TCHECK2(*daoack, ND_RPL_DAOACK_MIN_LEN);\n        if (length < ND_RPL_DAOACK_MIN_LEN)\n        \tgoto tooshort;\n        bp += ND_RPL_DAOACK_MIN_LEN;\n        length -= ND_RPL_DAOACK_MIN_LEN;\n        if(RPL_DAOACK_D(daoack->rpl_flags)) {\n                ND_TCHECK2(daoack->rpl_dagid, DAGID_LEN);\n                if (length < DAGID_LEN)\n                \tgoto tooshort;\n                dagid_str = ip6addr_string (ndo, daoack->rpl_dagid);\n                bp += DAGID_LEN;\n                length -= DAGID_LEN;\n        }\n        ND_PRINT((ndo, \" [dagid:%s,seq:%u,instance:%u,status:%u]\",\n                  dagid_str,\n                  daoack->rpl_daoseq,\n                  daoack->rpl_instanceid,\n                  daoack->rpl_status));\n        if(ndo->ndo_vflag > 1) {\n                const struct rpl_dio_genoption *opt = (const struct rpl_dio_genoption *)bp;\n                rpl_dio_printopt(ndo, opt, length);\n        }\n\treturn;\ntrunc:\n\tND_PRINT((ndo,\" [|dao-truncated]\"));\n\treturn;\ntooshort:\n\tND_PRINT((ndo,\" [|dao-length too short]\"));\n\treturn;\n}", "target": 1}
{"code": "static inline Quantum ClampPixel(const MagickRealType value)\n{\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  return((Quantum) value);\n#else\n  if (value < 0.0)\n    return((Quantum) 0.0);\n  if (value >= (MagickRealType) QuantumRange)\n    return((Quantum) QuantumRange);\n  return((Quantum) value);\n#endif\n}", "target": 0}
{"code": "static void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    fio_stop();\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}", "target": 1}
{"code": "hstore_recv(PG_FUNCTION_ARGS)\n{\n\tint32\t\tbuflen;\n\tHStore\t   *out;\n\tPairs\t   *pairs;\n\tint32\t\ti;\n\tint32\t\tpcount;\n\tStringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0);\n\tpcount = pq_getmsgint(buf, 4);\n\tif (pcount == 0)\n\t{\n\t\tout = hstorePairs(NULL, 0, 0);\n\t\tPG_RETURN_POINTER(out);\n\t}\n\tif (pcount < 0 || pcount > MaxAllocSize / sizeof(Pairs))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t  errmsg(\"number of pairs (%d) exceeds the maximum allowed (%d)\",\n\t\t\t\t\t pcount, (int) (MaxAllocSize / sizeof(Pairs)))));\n\tpairs = palloc(pcount * sizeof(Pairs));\n\tfor (i = 0; i < pcount; ++i)\n\t{\n\t\tint\t\t\trawlen = pq_getmsgint(buf, 4);\n\t\tint\t\t\tlen;\n\t\tif (rawlen < 0)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),\n\t\t\t\t\t errmsg(\"null value not allowed for hstore key\")));\n\t\tpairs[i].key = pq_getmsgtext(buf, rawlen, &len);\n\t\tpairs[i].keylen = hstoreCheckKeyLen(len);\n\t\tpairs[i].needfree = true;\n\t\trawlen = pq_getmsgint(buf, 4);\n\t\tif (rawlen < 0)\n\t\t{\n\t\t\tpairs[i].val = NULL;\n\t\t\tpairs[i].vallen = 0;\n\t\t\tpairs[i].isnull = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpairs[i].val = pq_getmsgtext(buf, rawlen, &len);\n\t\t\tpairs[i].vallen = hstoreCheckValLen(len);\n\t\t\tpairs[i].isnull = false;\n\t\t}\n\t}\n\tpcount = hstoreUniquePairs(pairs, pcount, &buflen);\n\tout = hstorePairs(pairs, pcount, buflen);\n\tPG_RETURN_POINTER(out);\n}", "target": 0}
{"code": "static void mark_object(struct object *obj, struct strbuf *path,\n\t\t\tconst char *name, void *data)\n{\n\tupdate_progress(data);\n}", "target": 1}
{"code": "Jsi_Value *jsi_ValueObjKeyAssign(Jsi_Interp *interp, Jsi_Value *target, Jsi_Value *keyval, Jsi_Value *value, int flag)\n{\n    int arrayindex = -1;\n    if (keyval->vt == JSI_VT_NUMBER && Jsi_NumberIsInteger(keyval->d.num) && keyval->d.num >= 0) {\n        arrayindex = (int)keyval->d.num;\n    }\n    if (arrayindex >= 0 && arrayindex < MAX_ARRAY_LIST &&\n        target->vt == JSI_VT_OBJECT && target->d.obj->arr) {\n        return jsi_ObjArraySetDup(interp, target->d.obj, value, arrayindex);\n    }\n    const char *kstr = Jsi_ValueToString(interp, keyval, NULL);\n#if (defined(JSI_HAS___PROTO__) && JSI_HAS___PROTO__==2)\n    if (Jsi_Strcmp(kstr, \"__proto__\")==0) {\n        Jsi_Obj *obj = target->d.obj;\n        obj->__proto__ = Jsi_ValueDup(interp, value);\n        return obj->__proto__;\n    }\n#endif\n    Jsi_Value *v = Jsi_ValueNew1(interp);\n    if (value)\n        Jsi_ValueCopy(interp, v, value);\n    jsi_ValueObjSet(interp, target, kstr, v, flag, (Jsi_ValueIsStringKey(interp, keyval)? JSI_OM_ISSTRKEY:0));\n    Jsi_DecrRefCount(interp, v);\n    return v;\n}", "target": 1}
{"code": "void faad_resetbits(bitfile *ld, int bits)\n{\n    uint32_t tmp;\n    int words = bits >> 5;\n    int remainder = bits & 0x1F;\n    ld->bytes_left = ld->buffer_size - words*4;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufa = tmp;\n    if (ld->bytes_left >= 4)\n    {\n        tmp = getdword(&ld->start[words+1]);\n        ld->bytes_left -= 4;\n    } else {\n        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);\n        ld->bytes_left = 0;\n    }\n    ld->bufb = tmp;\n    ld->bits_left = 32 - remainder;\n    ld->tail = &ld->start[words+2];\n    ld->error = 0;\n}", "target": 1}
{"code": "struct clock_source *dcn10_clock_source_create(\n\tstruct dc_context *ctx,\n\tstruct dc_bios *bios,\n\tenum clock_source_id id,\n\tconst struct dce110_clk_src_regs *regs,\n\tbool dp_clk_src)\n{\n\tstruct dce110_clk_src *clk_src =\n\t\tkzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);\n\tif (!clk_src)\n\t\treturn NULL;\n\tif (dce112_clk_src_construct(clk_src, ctx, bios, id,\n\t\t\tregs, &cs_shift, &cs_mask)) {\n\t\tclk_src->base.dp_clk_src = dp_clk_src;\n\t\treturn &clk_src->base;\n\t}\n\tkfree(clk_src);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "static void adpt_i2o_sys_shutdown(void)\n{\n\tadpt_hba *pHba, *pNext;\n\tstruct adpt_i2o_post_wait_data *p1, *old;\n\tprintk(KERN_INFO \"Shutting down Adaptec I2O controllers.\\n\");\n\tprintk(KERN_INFO \"   This could take a few minutes if there are many devices attached\\n\");\n\tfor (pHba = hba_chain; pHba; pHba = pNext) {\n\t\tpNext = pHba->next;\n\t\tadpt_i2o_delete_hba(pHba);\n\t}\n\tfor(p1 = adpt_post_wait_queue; p1;) {\n\t\told = p1;\n\t\tp1 = p1->next;\n\t\tkfree(old);\n\t}\n\tadpt_post_wait_queue = NULL;\n\tprintk(KERN_INFO \"Adaptec I2O controllers down.\\n\");\n}", "target": 1}
{"code": "static inline union cpu_time_count cpu_time_sub(const clockid_t which_clock,\n\t\t\t\t\t\tunion cpu_time_count a,\n\t\t\t\t\t\tunion cpu_time_count b)\n{\n\tif (CPUCLOCK_WHICH(which_clock) == CPUCLOCK_SCHED) {\n\t\ta.sched -= b.sched;\n\t}  else {\n\t\ta.cpu = cputime_sub(a.cpu, b.cpu);\n\t}\n\treturn a;\n}", "target": 0}
{"code": "int prepareForShutdown() {\n    redisLog(REDIS_WARNING,\"User requested shutdown, saving DB...\");\n    if (server.bgsavechildpid != -1) {\n        redisLog(REDIS_WARNING,\"There is a live saving child. Killing it!\");\n        kill(server.bgsavechildpid,SIGKILL);\n        rdbRemoveTempFile(server.bgsavechildpid);\n    }\n    if (server.appendonly) {\n        aof_fsync(server.appendfd);\n        if (server.vm_enabled) unlink(server.vm_swap_file);\n    } else if (server.saveparamslen > 0) {\n        if (rdbSave(server.dbfilename) != REDIS_OK) {\n            redisLog(REDIS_WARNING,\"Error trying to save the DB, can't exit\");\n            return REDIS_ERR;\n        }\n    } else {\n        redisLog(REDIS_WARNING,\"Not saving DB.\");\n    }\n    if (server.daemonize) unlink(server.pidfile);\n    redisLog(REDIS_WARNING,\"Server exit now, bye bye...\");\n    return REDIS_OK;\n}", "target": 1}
{"code": "static void r_bin_dwarf_dump_debug_info(FILE *f, const RBinDwarfDebugInfo *inf) {\n\tsize_t i, j, k;\n\tRBinDwarfDIE *dies;\n\tRBinDwarfAttrValue *values;\n\tif (!inf || !f) {\n\t\treturn;\n\t}\n\tfor (i = 0; i < inf->length; i++) {\n\t\tfprintf (f, \"  Compilation Unit @ offset 0x%\"PFMT64x\":\\n\", inf->comp_units [i].offset);\n\t\tfprintf (f, \"   Length:        0x%x\\n\", inf->comp_units [i].hdr.length);\n\t\tfprintf (f, \"   Version:       %d\\n\", inf->comp_units [i].hdr.version);\n\t\tfprintf (f, \"   Abbrev Offset: 0x%x\\n\", inf->comp_units [i].hdr.abbrev_offset);\n\t\tfprintf (f, \"   Pointer Size:  %d\\n\", inf->comp_units [i].hdr.pointer_size);\n\t\tdies = inf->comp_units[i].dies;\n\t\tfor (j = 0; j < inf->comp_units[i].length; j++) {\n\t\t\tfprintf (f, \"    Abbrev Number: %\"PFMT64u\" \", dies[j].abbrev_code);\n\t\t\tif (dies[j].tag && dies[j].tag <= DW_TAG_volatile_type &&\n\t\t\t\t       dwarf_tag_name_encodings[dies[j].tag]) {\n\t\t\t\tfprintf (f, \"(%s)\\n\", dwarf_tag_name_encodings[dies[j].tag]);\n\t\t\t} else {\n\t\t\t\tfprintf (f, \"(Unknown abbrev tag)\\n\");\n\t\t\t}\n\t\t\tif (!dies[j].abbrev_code) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvalues = dies[j].attr_values;\n\t\t\tfor (k = 0; k < dies[j].length; k++) {\n\t\t\t\tif (!values[k].name)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (values[k].name < DW_AT_vtable_elem_location &&\n\t\t\t\t\t\tdwarf_attr_encodings[values[k].name]) {\n\t\t\t\t\tfprintf (f, \"     %-18s : \", dwarf_attr_encodings[values[k].name]);\n\t\t\t\t} else {\n\t\t\t\t\tfprintf (f, \"     TODO\\t\");\n\t\t\t\t}\n\t\t\t\tr_bin_dwarf_dump_attr_value (&values[k], f);\n\t\t\t\tfprintf (f, \"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}", "target": 1}
{"code": "d_lite_inspect(VALUE self)\n{\n    get_d1(self);\n    return mk_inspect(dat, rb_obj_class(self), self);\n}", "target": 0}
{"code": "_dbus_get_monotonic_time (long *tv_sec,\n                          long *tv_usec)\n{\n  _dbus_get_real_time (tv_sec, tv_usec);\n}", "target": 0}
{"code": "bool CTransaction::AcceptToMemoryPool(CTxDB& txdb, bool fCheckInputs, bool* pfMissingInputs)\n{\n    return mempool.accept(txdb, *this, fCheckInputs, pfMissingInputs);\n}", "target": 1}
{"code": "static int start_netprobe(const struct sa *turn_srv,\n\t\t\t  int proto, bool secure,\n\t\t\t  const char *username, const char *password)\n{\n\tint err;\n\tre_printf(\"starting netprobe with TURN%s-server %J\"\n\t\t  \" (proto=%s) ..\\n\",\n\t\t  secure ? \"S\" : \"\", turn_srv,\n\t\t  net_proto2name(proto));\n#define PACKET_COUNT 50\n#define PACKET_INTERVAL 20\n\tif (netprobec >= ARRAY_SIZE(netprobev)) {\n\t\twarning(\"reached maximum %zu netprobes\\n\", netprobec);\n\t\treturn 0;\n\t}\n\tnetprobev[netprobec].turn_srv = *turn_srv;\n\tnetprobev[netprobec].secure = secure;\n\tnetprobev[netprobec].proto = proto;\n\terr = netprobe_alloc(&netprobev[netprobec].np,\n\t\t\t     turn_srv, proto, secure,\n\t\t\t     username, password,\n\t\t\t     PACKET_COUNT, PACKET_INTERVAL,\n\t\t\t     netprobe_handler, (void *)netprobec);\n\tif (err) {\n\t\twarning(\"could not create netprobe (%m)\\n\", err);\n\t\tgoto out;\n\t}\n\tnetprobec++;\n out:\n\treturn err;\n}", "target": 0}
{"code": "bool AuthNoneAuthorizeHandler::verify_authorizer(CephContext *cct, KeyStore *keys,\n\t\t\t\t\t\t bufferlist& authorizer_data, bufferlist& authorizer_reply,\n\t\t\t\t\t\t EntityName& entity_name, uint64_t& global_id, AuthCapsInfo& caps_info, CryptoKey& session_key,\nuint64_t *auid)\n{\n  bufferlist::iterator iter = authorizer_data.begin();\n  try {\n    __u8 struct_v = 1;\n    ::decode(struct_v, iter);\n    ::decode(entity_name, iter);\n    ::decode(global_id, iter);\n  } catch (const buffer::error &err) {\n    ldout(cct, 0) << \"AuthNoneAuthorizeHandle::verify_authorizer() failed to decode\" << dendl;\n    return false;\n  }\n  caps_info.allow_all = true;\n  return true;\n}", "target": 1}
{"code": "void ZydisFormatterBufferInitTokenized(ZydisFormatterBuffer* buffer,\n    ZydisFormatterToken** first_token, void* user_buffer, ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(first_token);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n    *first_token = user_buffer;\n    (*first_token)->type = ZYDIS_TOKEN_INVALID;\n    (*first_token)->next = 0;\n    user_buffer = (ZyanU8*)user_buffer + sizeof(ZydisFormatterToken);\n    length -= sizeof(ZydisFormatterToken);\n    buffer->is_token_list              = ZYAN_TRUE;\n    buffer->capacity                   = length;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *(char*)user_buffer = '\\0';\n}", "target": 1}
{"code": "static Status ValidateStrides(const T& strides) {\n  for (size_t i = 0; i < strides.size(); ++i) {\n    if (strides[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window stride field for dimension \", i,\n          \" must be positive but is \", strides[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,\n\t\t\t\t struct udphdr *uh)\n{\n\tstruct udp_offload_priv *uo_priv;\n\tstruct sk_buff *p, **pp = NULL;\n\tstruct udphdr *uh2;\n\tunsigned int off = skb_gro_offset(skb);\n\tint flush = 1;\n\tif (NAPI_GRO_CB(skb)->udp_mark ||\n\t    (skb->ip_summed != CHECKSUM_PARTIAL &&\n\t     NAPI_GRO_CB(skb)->csum_cnt == 0 &&\n\t     !NAPI_GRO_CB(skb)->csum_valid))\n\t\tgoto out;\n\tNAPI_GRO_CB(skb)->udp_mark = 1;\n\trcu_read_lock();\n\tuo_priv = rcu_dereference(udp_offload_base);\n\tfor (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {\n\t\tif (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&\n\t\t    uo_priv->offload->port == uh->dest &&\n\t\t    uo_priv->offload->callbacks.gro_receive)\n\t\t\tgoto unflush;\n\t}\n\tgoto out_unlock;\nunflush:\n\tflush = 0;\n\tfor (p = *head; p; p = p->next) {\n\t\tif (!NAPI_GRO_CB(p)->same_flow)\n\t\t\tcontinue;\n\t\tuh2 = (struct udphdr   *)(p->data + off);\n\t\tif ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||\n\t\t    (!uh->check ^ !uh2->check)) {\n\t\t\tNAPI_GRO_CB(p)->same_flow = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tskb_gro_pull(skb, sizeof(struct udphdr)); \n\tskb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));\n\tNAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;\n\tpp = uo_priv->offload->callbacks.gro_receive(head, skb,\n\t\t\t\t\t\t     uo_priv->offload);\nout_unlock:\n\trcu_read_unlock();\nout:\n\tNAPI_GRO_CB(skb)->flush |= flush;\n\treturn pp;\n}", "target": 1}
{"code": "CONCRETE_IO_HANDLE socketio_create(void* io_create_parameters)\n{\n    SOCKETIO_CONFIG* socket_io_config = (SOCKETIO_CONFIG*)io_create_parameters;\n    SOCKET_IO_INSTANCE* result;\n    struct tcp_keepalive tcp_keepalive = { 0, 0, 0 };\n    if (socket_io_config == NULL)\n    {\n        LogError(\"Invalid argument: socket_io_config is NULL\");\n        result = NULL;\n    }\n    else\n    {\n        result = (SOCKET_IO_INSTANCE*)malloc(sizeof(SOCKET_IO_INSTANCE));\n        if (result != NULL)\n        {\n            (void)memset(result, 0, sizeof(SOCKET_IO_INSTANCE));\n            result->address_type = ADDRESS_TYPE_IP;\n            result->pending_io_list = singlylinkedlist_create();\n            if (result->pending_io_list == NULL)\n            {\n                LogError(\"Failure: singlylinkedlist_create unable to create pending list.\");\n                destroy_socket_io_instance(result);\n                result = NULL;\n            }\n            else\n            {\n                if (socket_io_config->hostname != NULL)\n                {\n                    result->hostname = (char*)malloc(strlen(socket_io_config->hostname) + 1);\n                    if (result->hostname != NULL)\n                    {\n                        (void)strcpy(result->hostname, socket_io_config->hostname);\n                    }\n                    result->socket = INVALID_SOCKET;\n                }\n                else\n                {\n                    result->hostname = NULL;\n                    result->socket = *((SOCKET*)socket_io_config->accepted_socket);\n                }\n                if ((result->hostname == NULL) && (result->socket == INVALID_SOCKET))\n                {\n                    LogError(\"Failure: hostname == NULL and socket is invalid.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else if ((result->addrInfo = calloc(1, sizeof(struct addrinfo))) == NULL)\n                {\n                    LogError(\"Failure: addrInfo == NULL.\");\n                    destroy_socket_io_instance(result);\n                    result = NULL;\n                }\n                else\n                {\n                    result->port = socket_io_config->port;\n                    result->on_io_open_complete = NULL;\n                    result->dns_resolver = dns_resolver_create(result->hostname, socket_io_config->port, NULL);\n                    result->on_bytes_received = NULL;\n                    result->on_io_error = NULL;\n                    result->on_bytes_received_context = NULL;\n                    result->on_io_error_context = NULL;\n                    result->io_state = IO_STATE_CLOSED;\n                    result->keep_alive = tcp_keepalive;\n                }\n            }\n        }\n        else\n        {\n            LogError(\"Allocation Failure: SOCKET_IO_INSTANCE\");\n        }\n    }\n    return (XIO_HANDLE)result;\n}", "target": 1}
{"code": "mcs_send_connect_initial(STREAM mcs_data)\n{\n\tint datalen = mcs_data->end - mcs_data->data;\n\tint length = 9 + 3 * 34 + 4 + datalen;\n\tSTREAM s;\n\ts = iso_init(length + 5);\n\tber_out_header(s, MCS_CONNECT_INITIAL, length);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t\n\tout_uint8(s, 1);\n\tber_out_header(s, BER_TAG_OCTET_STRING, 1);\t\n\tout_uint8(s, 1);\n\tber_out_header(s, BER_TAG_BOOLEAN, 1);\n\tout_uint8(s, 0xff);\t\n\tmcs_out_domain_params(s, 34, 2, 0, 0xffff);\t\n\tmcs_out_domain_params(s, 1, 1, 1, 0x420);\t\n\tmcs_out_domain_params(s, 0xffff, 0xfc17, 0xffff, 0xffff);\t\n\tber_out_header(s, BER_TAG_OCTET_STRING, datalen);\n\tout_uint8p(s, mcs_data->data, datalen);\n\ts_mark_end(s);\n\tiso_send(s);\n}", "target": 0}
{"code": "GF_HEVCConfig *gf_isom_hevc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex)\n{\n\tGF_TrackBox *trak;\n\tGF_MPEGVisualSampleEntryBox *entry;\n\tif (gf_isom_get_reference_count(the_file, trackNumber, GF_ISOM_REF_TBAS)) {\n\t\tu32 ref_track;\n\t\tGF_Err e = gf_isom_get_reference(the_file, trackNumber, GF_ISOM_REF_TBAS, 1, &ref_track);\n\t\tif (e == GF_OK) {\n\t\t\ttrackNumber = ref_track;\n\t\t}\n\t}\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak || !trak->Media || !DescriptionIndex) return NULL;\n\tif (gf_isom_get_hevc_lhvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_HEVCTYPE_NONE)\n\t\treturn NULL;\n\tentry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1);\n\tif (!entry) return NULL;\n\tif (!entry->hevc_config) return NULL;\n\treturn HEVC_DuplicateConfig(entry->hevc_config->config);\n}", "target": 0}
{"code": "int rtnl_dump_request_n(struct rtnl_handle *rth, struct nlmsghdr *n)\n{\n\tstruct sockaddr_nl nladdr = { .nl_family = AF_NETLINK };\n\tstruct iovec iov = {\n\t\t.iov_base = n,\n\t\t.iov_len = n->nlmsg_len\n\t};\n\tstruct msghdr msg = {\n\t\t.msg_name = &nladdr,\n\t\t.msg_namelen = sizeof(nladdr),\n\t\t.msg_iov = &iov,\n\t\t.msg_iovlen = 1,\n\t};\n\tn->nlmsg_flags = NLM_F_DUMP|NLM_F_REQUEST;\n\tn->nlmsg_pid = 0;\n\tn->nlmsg_seq = rth->dump = ++rth->seq;\n\treturn sendmsg(rth->fd, &msg, 0);\n}", "target": 0}
{"code": "inline int ComputeOutSize(TfLitePadding padding, int image_size,\n                          int filter_size, int stride, int dilation_rate = 1) {\n  int effective_filter_size = (filter_size - 1) * dilation_rate + 1;\n  if (stride == 0) return 0;\n  switch (padding) {\n    case kTfLitePaddingSame:\n      return (image_size + stride - 1) / stride;\n    case kTfLitePaddingValid:\n      return (image_size + stride - effective_filter_size) / stride;\n    default:\n      return 0;\n  }\n}", "target": 0}
{"code": "TEST_F(QueryPlannerTest, IntersectCompoundInsteadThreeCompoundIndices) {\n    params.options = QueryPlannerParams::NO_TABLE_SCAN | QueryPlannerParams::INDEX_INTERSECTION;\n    addIndex(BSON(\"a\" << 1 << \"b\" << 1));\n    addIndex(BSON(\"c\" << 1 << \"d\" << 1));\n    addIndex(BSON(\"a\" << 1 << \"c\" << -1 << \"b\" << -1 << \"d\" << 1));\n    runQuery(fromjson(\"{a: 1, b: 1, c: 1, d: 1}\"));\n    assertNumSolutions(3U);\n    assertSolutionExists(\n        \"{fetch: {filter: {$and: [{c:1},{d:1}]}, node: \"\n        \"{ixscan: {filter: null, pattern: {a:1,b:1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: {$and:[{a:1},{b:1}]}, node: \"\n        \"{ixscan: {filter: null, pattern: {c:1,d:1}}}}}\");\n    assertSolutionExists(\n        \"{fetch: {filter: null, node: \"\n        \"{ixscan: {filter: null, pattern: {a:1,c:-1,b:-1,d:1}}}}}\");\n}", "target": 0}
{"code": "void pdo_stmt_init(TSRMLS_D)\n{\n\tzend_class_entry ce;\n\tINIT_CLASS_ENTRY(ce, \"PDOStatement\", pdo_dbstmt_functions);\n\tpdo_dbstmt_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tpdo_dbstmt_ce->get_iterator = pdo_stmt_iter_get;\n\tpdo_dbstmt_ce->create_object = pdo_dbstmt_new;\n\tzend_class_implements(pdo_dbstmt_ce TSRMLS_CC, 1, zend_ce_traversable);\n\tzend_declare_property_null(pdo_dbstmt_ce, \"queryString\", sizeof(\"queryString\")-1, ZEND_ACC_PUBLIC TSRMLS_CC);\n\tmemcpy(&pdo_dbstmt_object_handlers, &std_object_handlers, sizeof(zend_object_handlers));\n\tpdo_dbstmt_object_handlers.write_property = dbstmt_prop_write;\n\tpdo_dbstmt_object_handlers.unset_property = dbstmt_prop_delete;\n\tpdo_dbstmt_object_handlers.get_method = dbstmt_method_get;\n\tpdo_dbstmt_object_handlers.compare_objects = dbstmt_compare;\n\tpdo_dbstmt_object_handlers.clone_obj = dbstmt_clone_obj;\n\tINIT_CLASS_ENTRY(ce, \"PDORow\", pdo_row_functions);\n\tpdo_row_ce = zend_register_internal_class(&ce TSRMLS_CC);\n\tpdo_row_ce->ce_flags |= ZEND_ACC_FINAL_CLASS; \n\tpdo_row_ce->create_object = pdo_row_new;\n\tpdo_row_ce->serialize = pdo_row_serialize;\n\tpdo_row_ce->unserialize = zend_class_unserialize_deny;", "target": 0}
{"code": "void virtio_config_writew(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint16_t val = data;\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n    stw_p(vdev->config + addr, val);\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}", "target": 1}
{"code": "const char* sldns_get_errorstr_parse(int e)\n{\n\tsldns_lookup_table *lt;\n\tlt = sldns_lookup_by_id(sldns_wireparse_errors, LDNS_WIREPARSE_ERROR(e));\n\treturn lt?lt->name:\"unknown error\";\n}", "target": 0}
{"code": "TfLiteStatus EvalScatterNd(TfLiteContext* context, const TfLiteTensor* indices,\n                           const TfLiteTensor* updates,\n                           const TfLiteTensor* shape, TfLiteTensor* output) {\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(\n        context, CheckShapes<IndicesT>(\n                     context, GetTensorShape(indices), GetTensorShape(updates),\n                     GetTensorShape(shape), GetTensorData<IndicesT>(shape)));\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor<IndicesT>(context, shape, output));\n  }\n  switch (updates->type) {\n    case kTfLiteFloat32:\n      return ScatterNd<IndicesT, float>(indices, updates, output);\n    case kTfLiteUInt8:\n      return ScatterNd<IndicesT, uint8_t>(indices, updates, output);\n    case kTfLiteBool:\n      return ScatterNd<IndicesT, bool>(indices, updates, output);\n    case kTfLiteInt8:\n      return ScatterNd<IndicesT, int8_t>(indices, updates, output);\n    case kTfLiteInt32:\n      return ScatterNd<IndicesT, int32_t>(indices, updates, output);\n    case kTfLiteInt64:\n      return ScatterNd<IndicesT, int64_t>(indices, updates, output);\n    default:\n      TF_LITE_KERNEL_LOG(\n          context, \"Updates of type '%s' are not supported by scatter_nd.\",\n          TfLiteTypeGetName(updates->type));\n      return kTfLiteError;\n  }\n}", "target": 1}
{"code": "static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,\n\t\t\t&node->nd_set_attributes))\n\t\tret = -EBUSY;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\treturn count;\n}", "target": 1}
{"code": "int audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_aux_data_execve *ax;\n\tstruct audit_context *context = current->audit_context;\n\tif (likely(!audit_enabled || !context || context->dummy))\n\t\treturn 0;\n\tif (bprm->argv_len > (audit_argv_kb << 10))\n\t\treturn -E2BIG;\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\tax->argc = bprm->argc;\n\tax->envc = bprm->envc;\n\tax->mm = bprm->mm;\n\tax->d.type = AUDIT_EXECVE;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\treturn 0;\n}", "target": 0}
{"code": "        int          GetS8    (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            if ( nRes & 0x80 )\n                nRes |= ~0xff;\n            return nRes;\n        }", "target": 1}
{"code": "MONGO_EXPORT void __mongo_set_error( mongo *conn, mongo_error_t err, const char *str,\n                                     int errcode ) {\n    int errstr_size, str_size;\n    conn->err = err;\n    conn->errcode = errcode;\n    if( str ) {\n        str_size = strlen( str ) + 1;\n        errstr_size = str_size > MONGO_ERR_LEN ? MONGO_ERR_LEN : str_size;\n        memcpy( conn->errstr, str, errstr_size );\n        conn->errstr[errstr_size-1] = '\\0';\n    }\n}", "target": 1}
{"code": "void cql_server::response::serialize(const event::schema_change& event, uint8_t version)\n{\n    if (version >= 3) {\n        write_string(to_string(event.change));\n        write_string(to_string(event.target));\n        write_string(event.keyspace);\n        switch (event.target) {\n        case event::schema_change::target_type::KEYSPACE:\n            break;\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::TABLE:\n            write_string(event.arguments[0]);\n            break;\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(event.arguments[0]);\n            write_string_list(std::vector<sstring>(event.arguments.begin() + 1, event.arguments.end()));\n            break;\n        }\n    } else {\n        switch (event.target) {\n        case event::schema_change::target_type::TYPE:\n        case event::schema_change::target_type::FUNCTION:\n        case event::schema_change::target_type::AGGREGATE:\n            write_string(to_string(event::schema_change::change_type::UPDATED));\n            write_string(event.keyspace);\n            write_string(\"\");\n            break;\n        case event::schema_change::target_type::TABLE:\n        case event::schema_change::target_type::KEYSPACE:\n            write_string(to_string(event.change));\n            write_string(event.keyspace);\n            if (event.target == event::schema_change::target_type::TABLE) {\n                write_string(event.arguments[0]);\n            } else {\n                write_string(\"\");\n            }\n        }\n    }\n}", "target": 0}
{"code": "static int input_default_setkeycode(struct input_dev *dev,\n\t\t\t\t    const struct input_keymap_entry *ke,\n\t\t\t\t    unsigned int *old_keycode)\n{\n\tunsigned int index;\n\tint error;\n\tint i;\n\tif (!dev->keycodesize)\n\t\treturn -EINVAL;\n\tif (ke->flags & INPUT_KEYMAP_BY_INDEX) {\n\t\tindex = ke->index;\n\t} else {\n\t\terror = input_scancode_to_scalar(ke, &index);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif (index >= dev->keycodemax)\n\t\treturn -EINVAL;\n\tif (dev->keycodesize < sizeof(ke->keycode) &&\n\t\t\t(ke->keycode >> (dev->keycodesize * 8)))\n\t\treturn -EINVAL;\n\tswitch (dev->keycodesize) {\n\t\tcase 1: {\n\t\t\tu8 *k = (u8 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tu16 *k = (u16 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tu32 *k = (u32 *)dev->keycode;\n\t\t\t*old_keycode = k[index];\n\t\t\tk[index] = ke->keycode;\n\t\t\tbreak;\n\t\t}\n\t}\n\t__clear_bit(*old_keycode, dev->keybit);\n\t__set_bit(ke->keycode, dev->keybit);\n\tfor (i = 0; i < dev->keycodemax; i++) {\n\t\tif (input_fetch_keycode(dev, i) == *old_keycode) {\n\t\t\t__set_bit(*old_keycode, dev->keybit);\n\t\t\tbreak; \n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "char* _single_string_alloc_and_copy( LPCWSTR in )\n{\n    char *chr;\n    int len = 0;\n    if ( !in )\n    {\n        return in;\n    }\n    while ( in[ len ] != 0 )\n    {\n        len ++;\n    }\n    chr = malloc( len + 1 );\n    len = 0;\n    while ( in[ len ] != 0 )\n    {\n        chr[ len ] = 0xFF & in[ len ];\n        len ++;\n    }\n    chr[ len ++ ] = '\\0';\n    return chr;\n}", "target": 1}
{"code": "unique_ptr<IOBuf> IOBuf::createCombined(std::size_t capacity) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  size_t requiredStorage = offsetof(HeapFullStorage, align) + capacity;\n  size_t mallocSize = goodMallocSize(requiredStorage);\n  auto storage = static_cast<HeapFullStorage*>(checkedMalloc(mallocSize));\n  new (&storage->hs.prefix) HeapPrefix(kIOBufInUse | kDataInUse, mallocSize);\n  new (&storage->shared) SharedInfo(freeInternalBuf, storage);\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, mallocSize);\n  }\n  auto bufAddr = reinterpret_cast<uint8_t*>(&storage->align);\n  uint8_t* storageEnd = reinterpret_cast<uint8_t*>(storage) + mallocSize;\n  auto actualCapacity = size_t(storageEnd - bufAddr);\n  unique_ptr<IOBuf> ret(new (&storage->hs.buf) IOBuf(\n      InternalConstructor(),\n      packFlagsAndSharedInfo(0, &storage->shared),\n      bufAddr,\n      actualCapacity,\n      bufAddr,\n      0));\n  return ret;\n}", "target": 0}
{"code": "static int setup_config(int type)\n{\n\tint rv;\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\nout:\n\treturn rv;\n}", "target": 1}
{"code": "void test_chmod(const char *path)\n{\n\tif (chmod(path, 0755) == 0) {\n\t\tfprintf(stderr, \"leak at chmod of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT && errno != ENOSYS) {\n\t\tfprintf(stderr, \"leak at chmod of %s: errno was %s\\n\", path, strerror(errno));\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "static int check_ci(const struct atm_vcc *vcc, short vpi, int vci)\n{\n\tstruct hlist_head *head = &vcc_hash[vci & (VCC_HTABLE_SIZE - 1)];\n\tstruct hlist_node *node;\n\tstruct sock *s;\n\tstruct atm_vcc *walk;\n\tsk_for_each(s, node, head) {\n\t\twalk = atm_sk(s);\n\t\tif (walk->dev != vcc->dev)\n\t\t\tcontinue;\n\t\tif (test_bit(ATM_VF_ADDR, &walk->flags) && walk->vpi == vpi &&\n\t\t    walk->vci == vci && ((walk->qos.txtp.traffic_class !=\n\t\t    ATM_NONE && vcc->qos.txtp.traffic_class != ATM_NONE) ||\n\t\t    (walk->qos.rxtp.traffic_class != ATM_NONE &&\n\t\t    vcc->qos.rxtp.traffic_class != ATM_NONE)))\n\t\t\treturn -EADDRINUSE;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "int ext4_group_add(struct super_block *sb, struct ext4_new_group_data *input)\n{\n\tstruct ext4_new_flex_group_data flex_gd;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_super_block *es = sbi->s_es;\n\tint reserved_gdb = ext4_bg_has_super(sb, input->group) ?\n\t\tle16_to_cpu(es->s_reserved_gdt_blocks) : 0;\n\tstruct inode *inode = NULL;\n\tint gdb_off, gdb_num;\n\tint err;\n\t__u16 bg_flags = 0;\n\tgdb_num = input->group / EXT4_DESC_PER_BLOCK(sb);\n\tgdb_off = input->group % EXT4_DESC_PER_BLOCK(sb);\n\tif (gdb_off == 0 && !EXT4_HAS_RO_COMPAT_FEATURE(sb,\n\t\t\t\t\tEXT4_FEATURE_RO_COMPAT_SPARSE_SUPER)) {\n\t\text4_warning(sb, \"Can't resize non-sparse filesystem further\");\n\t\treturn -EPERM;\n\t}\n\tif (ext4_blocks_count(es) + input->blocks_count <\n\t    ext4_blocks_count(es)) {\n\t\text4_warning(sb, \"blocks_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (le32_to_cpu(es->s_inodes_count) + EXT4_INODES_PER_GROUP(sb) <\n\t    le32_to_cpu(es->s_inodes_count)) {\n\t\text4_warning(sb, \"inodes_count overflow\");\n\t\treturn -EINVAL;\n\t}\n\tif (reserved_gdb || gdb_off == 0) {\n\t\tif (!EXT4_HAS_COMPAT_FEATURE(sb,\n\t\t\t\t\t     EXT4_FEATURE_COMPAT_RESIZE_INODE)\n\t\t    || !le16_to_cpu(es->s_reserved_gdt_blocks)) {\n\t\t\text4_warning(sb,\n\t\t\t\t     \"No reserved GDT blocks, can't resize\");\n\t\t\treturn -EPERM;\n\t\t}\n\t\tinode = ext4_iget(sb, EXT4_RESIZE_INO);\n\t\tif (IS_ERR(inode)) {\n\t\t\text4_warning(sb, \"Error opening resize inode\");\n\t\t\treturn PTR_ERR(inode);\n\t\t}\n\t}\n\terr = verify_group_input(sb, input);\n\tif (err)\n\t\tgoto out;\n\tflex_gd.count = 1;\n\tflex_gd.groups = input;\n\tflex_gd.bg_flags = &bg_flags;\n\terr = ext4_flex_group_add(sb, inode, &flex_gd);\nout:\n\tiput(inode);\n\treturn err;\n} ", "target": 0}
{"code": "deltas_head_destroy(struct deltas_head *deltas)\n{\n\tdeltas_head_cleanup(deltas);\n\tfree(deltas);\n}", "target": 1}
{"code": "static s32 adpt_i2o_quiesce_hba(adpt_hba* pHba)\n{\n\tu32 msg[4];\n\tint ret;\n\tadpt_i2o_status_get(pHba);\n\tif((pHba->status_block->iop_state != ADAPTER_STATE_READY) &&\n   \t   (pHba->status_block->iop_state != ADAPTER_STATE_OPERATIONAL)){\n\t\treturn 0;\n\t}\n\tmsg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = I2O_CMD_SYS_QUIESCE<<24|HOST_TID<<12|ADAPTER_TID;\n\tmsg[2] = 0;\n\tmsg[3] = 0;\n\tif((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {\n\t\tprintk(KERN_INFO\"dpti%d: Unable to quiesce (status=%#x).\\n\",\n\t\t\t\tpHba->unit, -ret);\n\t} else {\n\t\tprintk(KERN_INFO\"dpti%d: Quiesced.\\n\",pHba->unit);\n\t}\n\tadpt_i2o_status_get(pHba);\n\treturn ret;\n}", "target": 1}
{"code": "header_put_le_short (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 2)\n\t{\tpsf->header [psf->headindex++] = x ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\t} ;\n} ", "target": 1}
{"code": "lyd_new_anydata(struct lyd_node *parent, const struct lys_module *module, const char *name,\n                void *value, LYD_ANYDATA_VALUETYPE value_type)\n{\n    const struct lys_node *siblings, *snode;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_ANYDATA, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return lyd_create_anydata(parent, snode, value, value_type);\n}", "target": 1}
{"code": "static struct timespec fio_timer_calc_due(size_t interval) {\n  struct timespec now = fio_last_tick();\n  if (interval > 1000) {\n    now.tv_sec += interval / 1000;\n    interval -= interval / 1000;\n  }\n  now.tv_nsec += (interval * 1000000UL);\n  if (now.tv_nsec > 1000000000L) {\n    now.tv_nsec -= 1000000000L;\n    now.tv_sec += 1;\n  }\n  return now;\n}", "target": 1}
{"code": "static inline void GetStandardDeviationPixelList(PixelList *pixel_list,\n  Quantum *pixel)\n{\n  double\n    sum,\n    sum_squared;\n  register SkipList\n    *p;\n  size_t\n    color;\n  ssize_t\n    count;\n  p=(&pixel_list->skip_list);\n  color=65536L;\n  count=0;\n  sum=0.0;\n  sum_squared=0.0;\n  do\n  {\n    register ssize_t\n      i;\n    color=p->nodes[color].next[0];\n    sum+=(double) p->nodes[color].count*color;\n    for (i=0; i < (ssize_t) p->nodes[color].count; i++)\n      sum_squared+=((double) color)*((double) color);\n    count+=p->nodes[color].count;\n  } while (count < (ssize_t) pixel_list->length);\n  sum/=pixel_list->length;\n  sum_squared/=pixel_list->length;\n  *pixel=ScaleShortToQuantum((unsigned short) sqrt(sum_squared-(sum*sum)));\n}", "target": 0}
{"code": "set_default_colour_sequences(void)\n{\n    fg_bg_sequences[COL_SEQ_FG].start = ztrdup(TC_COL_FG_START);\n    fg_bg_sequences[COL_SEQ_FG].end = ztrdup(TC_COL_FG_END);\n    fg_bg_sequences[COL_SEQ_FG].def = ztrdup(TC_COL_FG_DEFAULT);\n    fg_bg_sequences[COL_SEQ_BG].start = ztrdup(TC_COL_BG_START);\n    fg_bg_sequences[COL_SEQ_BG].end = ztrdup(TC_COL_BG_END);\n    fg_bg_sequences[COL_SEQ_BG].def = ztrdup(TC_COL_BG_DEFAULT);\n}", "target": 0}
{"code": "unsigned long get_zeroed_page(gfp_t gfp_mask)\n{\n\treturn __get_free_pages(gfp_mask | __GFP_ZERO, 0);\n}", "target": 0}
{"code": "static UINT drive_process_irp_query_directory(DRIVE_DEVICE* drive, IRP* irp)\n{\n\tconst WCHAR* path;\n\tDRIVE_FILE* file;\n\tBYTE InitialQuery;\n\tUINT32 PathLength;\n\tUINT32 FsInformationClass;\n\tif (!drive || !irp || !irp->Complete)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, FsInformationClass);\n\tStream_Read_UINT8(irp->input, InitialQuery);\n\tStream_Read_UINT32(irp->input, PathLength);\n\tStream_Seek(irp->input, 23); \n\tpath = (WCHAR*)Stream_Pointer(irp->input);\n\tif (!Stream_CheckAndLogRequiredLength(TAG, irp->input, PathLength))\n\t\treturn ERROR_INVALID_DATA;\n\tfile = drive_get_file_by_id(drive, irp->FileId);\n\tif (file == NULL)\n\t{\n\t\tirp->IoStatus = STATUS_UNSUCCESSFUL;\n\t\tStream_Write_UINT32(irp->output, 0); \n\t}\n\telse if (!drive_file_query_directory(file, FsInformationClass, InitialQuery, path, PathLength,\n\t                                     irp->output))\n\t{\n\t\tirp->IoStatus = drive_map_windows_err(GetLastError());\n\t}\n\treturn irp->Complete(irp);\n}", "target": 0}
{"code": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t    if(Z_TYPE_PP(rval) == IS_OBJECT) {\n\t       zend_hash_clean(Z_OBJPROP_PP(rval));\n\t       zend_object_store_ctor_failed(*rval TSRMLS_CC);\n\t    }\n\t    ZVAL_NULL(*rval);\n\t\treturn 0;\n\t}\n    if (Z_TYPE_PP(rval) != IS_OBJECT) {\n        return 0;\n    }\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}", "target": 0}
{"code": "juniper_mlfr_print(netdissect_options *ndo,\n                   const struct pcap_pkthdr *h, register const u_char *p)\n{\n        struct juniper_l2info_t l2info;\n        l2info.pictype = DLT_JUNIPER_MLFR;\n        if (juniper_parse_header(ndo, p, h, &l2info) == 0)\n            return l2info.header_len;\n        p+=l2info.header_len;\n        if (ndo->ndo_eflag && EXTRACT_32BITS(l2info.cookie) != 1)\n            ND_PRINT((ndo, \"Bundle-ID %u, \", l2info.bundle));\n        switch (l2info.proto) {\n        case (LLC_UI):\n        case (LLC_UI<<8):\n            isoclns_print(ndo, p, l2info.length, l2info.caplen);\n            break;\n        case (LLC_UI<<8 | NLPID_Q933):\n        case (LLC_UI<<8 | NLPID_IP):\n        case (LLC_UI<<8 | NLPID_IP6):\n            isoclns_print(ndo, p - 1, l2info.length + 1, l2info.caplen + 1);\n            break;\n        default:\n            ND_PRINT((ndo, \"unknown protocol 0x%04x, length %u\", l2info.proto, l2info.length));\n        }\n        return l2info.header_len;\n}", "target": 1}
{"code": "ikev1_ke_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len _U_,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi _U_,\n\t       uint32_t proto _U_, int depth _U_)\n{\n\tstruct isakmp_gen e;\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_KE)));\n\tND_TCHECK(*ext);\n\tUNALIGNED_MEMCPY(&e, ext, sizeof(e));\n\tND_PRINT((ndo,\" key len=%d\", ntohs(e.len) - 4));\n\tif (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + ntohs(e.len);\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_KE)));\n\treturn NULL;\n}", "target": 0}
{"code": "static void f2fs_put_super(struct super_block *sb)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_SB(sb);\n\tint i;\n\tf2fs_quota_off_umount(sb);\n\tmutex_lock(&sbi->umount_mutex);\n\tif (is_sbi_flag_set(sbi, SBI_IS_DIRTY) ||\n\t\t\t!is_set_ckpt_flags(sbi, CP_UMOUNT_FLAG)) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\tf2fs_wait_discard_bios(sbi);\n\tif (f2fs_discard_en(sbi) && !sbi->discard_blks) {\n\t\tstruct cp_control cpc = {\n\t\t\t.reason = CP_UMOUNT | CP_TRIMMED,\n\t\t};\n\t\twrite_checkpoint(sbi, &cpc);\n\t}\n\tf2fs_destroy_stats(sbi);\n\trelease_ino_entry(sbi, true);\n\tf2fs_leave_shrinker(sbi);\n\tmutex_unlock(&sbi->umount_mutex);\n\tf2fs_flush_merged_writes(sbi);\n\tiput(sbi->node_inode);\n\tiput(sbi->meta_inode);\n\tdestroy_node_manager(sbi);\n\tdestroy_segment_manager(sbi);\n\tkfree(sbi->ckpt);\n\tf2fs_unregister_sysfs(sbi);\n\tsb->s_fs_info = NULL;\n\tif (sbi->s_chksum_driver)\n\t\tcrypto_free_shash(sbi->s_chksum_driver);\n\tkfree(sbi->raw_super);\n\tdestroy_device_list(sbi);\n\tmempool_destroy(sbi->write_io_dummy);\n#ifdef CONFIG_QUOTA\n\tfor (i = 0; i < MAXQUOTAS; i++)\n\t\tkfree(sbi->s_qf_names[i]);\n#endif\n\tdestroy_percpu_info(sbi);\n\tfor (i = 0; i < NR_PAGE_TYPE; i++)\n\t\tkfree(sbi->write_io[i]);\n\tkfree(sbi);\n}", "target": 1}
{"code": "comics_document_finalize (GObject *object)\n{\n\tComicsDocument *comics_document = COMICS_DOCUMENT (object);\n\tif (comics_document->decompress_tmp) {\n\t\tif (comics_remove_dir (comics_document->dir) == -1)\n\t\t\tg_warning (_(\"There was an error deleting %s.\"),\n\t\t\t\t   comics_document->dir);\n\t\tg_free (comics_document->dir);\n\t}\n\tif (comics_document->page_names) {\n                g_ptr_array_foreach (comics_document->page_names, (GFunc) g_free, NULL);\n                g_ptr_array_free (comics_document->page_names, TRUE);\n\t}\n\tg_free (comics_document->archive);\n\tg_free (comics_document->selected_command);\n\tg_free (comics_document->alternative_command);\n\tg_free (comics_document->extract_command);\n\tg_free (comics_document->list_command);\n\tG_OBJECT_CLASS (comics_document_parent_class)->finalize (object);\n}", "target": 1}
{"code": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "find_entry_internal_uniqueid(\n\tSlapi_PBlock\t*pb,\n    backend *be,\n\tconst char \t\t\t*uniqueid,\n    int\t\t\t\tlock,\n\tback_txn\t\t*txn\n)\n{\n\tldbm_instance *inst = (ldbm_instance *) be->be_instance_info;\n\tstruct backentry\t*e;\n\tint\t\t\terr;\n\tsize_t tries = 0;\n\twhile ( (tries < LDBM_CACHE_RETRY_COUNT) && \n\t\t\t(e = uniqueid2entry(be, uniqueid, txn, &err ))\n\t    != NULL ) {\n\t\tif ( !lock || cache_lock_entry( &inst->inst_cache, e ) == 0 ) {\n\t\t\tLDAPDebug( LDAP_DEBUG_TRACE,\n\t\t\t    \"<= find_entry_internal_uniqueid found; uniqueid = (%s)\\n\", \n\t\t\tuniqueid, 0, 0 );\n\t\t\treturn( e );\n\t\t}\n\t\tLDAPDebug( LDAP_DEBUG_ARGS,\n\t\t\t\"   find_entry_internal_uniqueid retrying; uniqueid = (%s)\\n\", \n\t\t\tuniqueid, 0, 0 );\n\t\tCACHE_RETURN( &inst->inst_cache, &e );\n\t\ttries++;\n\t}\n\tif (tries >= LDBM_CACHE_RETRY_COUNT) {\n\t\tLDAPDebug( LDAP_DEBUG_ANY,\n\t\t\t\"find_entry_internal_uniqueid retry count exceeded; uniqueid = (%s)\\n\", \n\t\t\tuniqueid , 0, 0 );\n\t}\n\tslapi_send_ldap_result( pb, ( 0 == err || DB_NOTFOUND == err ) ?\n\t\tLDAP_NO_SUCH_OBJECT : LDAP_OPERATIONS_ERROR, NULL , NULL,\n\t\t0, NULL );\n\tLDAPDebug( LDAP_DEBUG_TRACE, \n\t\t\"<= find_entry_internal_uniqueid not found; uniqueid = (%s)\\n\",\n\t    uniqueid, 0, 0 );\n\treturn( NULL );\n}", "target": 1}
{"code": "  bool isReference() const { return type() == Type::Reference; }", "target": 0}
{"code": "static void oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\tif (cfg->scrub_request_headers != 0) {\n\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n\t\t\t\toidc_cfg_dir_authn_header(r));\n\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n\t\t\t\t!= cfg->claim_prefix)) {\n\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n\t\t}\n\t}\n}", "target": 1}
{"code": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\treturn 0;\n}", "target": 1}
{"code": "static Status ValidateSavedTensors(const GraphDef& graph_def) {\n  for (const auto& node : graph_def.node()) {\n    TF_RETURN_IF_ERROR(ValidateNode(node));\n  }\n  if (graph_def.has_library()) {\n    const FunctionDefLibrary& library = graph_def.library();\n    for (const auto& function : library.function()) {\n      for (const auto& node : function.node_def()) {\n        TF_RETURN_IF_ERROR(ValidateNode(node));\n      }\n      TF_RETURN_IF_ERROR(ValidateFunctionNotRecursive(function));\n    }\n  }\n  return Status::OK();\n}", "target": 0}
{"code": "int sss_certmap_expand_mapping_rule(struct sss_certmap_ctx *ctx,\n                                    const uint8_t *der_cert, size_t der_size,\n                                    char **_expanded, char ***_domains)\n{\n    return expand_mapping_rule_ex(ctx, der_cert, der_size, false,\n                                  _expanded, _domains);\n}", "target": 0}
{"code": "pte_t *huge_pmd_share(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\t      unsigned long addr, pud_t *pud)\n{\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tpgoff_t idx = ((addr - vma->vm_start) >> PAGE_SHIFT) +\n\t\t\tvma->vm_pgoff;\n\tstruct vm_area_struct *svma;\n\tunsigned long saddr;\n\tpte_t *spte = NULL;\n\tpte_t *pte;\n\tspinlock_t *ptl;\n\ti_mmap_assert_locked(mapping);\n\tvma_interval_tree_foreach(svma, &mapping->i_mmap, idx, idx) {\n\t\tif (svma == vma)\n\t\t\tcontinue;\n\t\tsaddr = page_table_shareable(svma, vma, addr, idx);\n\t\tif (saddr) {\n\t\t\tspte = huge_pte_offset(svma->vm_mm, saddr,\n\t\t\t\t\t       vma_mmu_pagesize(svma));\n\t\t\tif (spte) {\n\t\t\t\tget_page(virt_to_page(spte));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!spte)\n\t\tgoto out;\n\tptl = huge_pte_lock(hstate_vma(vma), mm, spte);\n\tif (pud_none(*pud)) {\n\t\tpud_populate(mm, pud,\n\t\t\t\t(pmd_t *)((unsigned long)spte & PAGE_MASK));\n\t\tmm_inc_nr_pmds(mm);\n\t} else {\n\t\tput_page(virt_to_page(spte));\n\t}\n\tspin_unlock(ptl);\nout:\n\tpte = (pte_t *)pmd_alloc(mm, pud, addr);\n\treturn pte;\n}", "target": 0}
{"code": "mm_zalloc(struct mm_master *mm, u_int ncount, u_int size)\n{\n\tif (size == 0 || ncount == 0 || ncount > SIZE_MAX / size)\n\t\tfatal(\"%s: mm_zalloc(%u, %u)\", __func__, ncount, size);\n\treturn mm_malloc(mm, size * ncount);\n}", "target": 1}
{"code": "mp_join_print(netdissect_options *ndo,\n              const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_join *mpj = (const struct mp_join *) opt;\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 16 && (flags & (TH_SYN | TH_ACK)) == (TH_SYN | TH_ACK)) &&\n            !(opt_len == 24 && flags & TH_ACK))\n                return 0;\n        if (opt_len != 24) {\n                if (mpj->sub_b & MP_JOIN_B)\n                        ND_PRINT((ndo, \" backup\"));\n                ND_PRINT((ndo, \" id %u\", mpj->addr_id));\n        }\n        switch (opt_len) {\n        case 12: \n                ND_PRINT((ndo, \" token 0x%x\" \" nonce 0x%x\",\n                        EXTRACT_32BITS(mpj->u.syn.token),\n                        EXTRACT_32BITS(mpj->u.syn.nonce)));\n                break;\n        case 16: \n                ND_PRINT((ndo, \" hmac 0x%\" PRIx64 \" nonce 0x%x\",\n                        EXTRACT_64BITS(mpj->u.synack.mac),\n                        EXTRACT_32BITS(mpj->u.synack.nonce)));\n                break;\n        case 24: {\n                size_t i;\n                ND_PRINT((ndo, \" hmac 0x\"));\n                for (i = 0; i < sizeof(mpj->u.ack.mac); ++i)\n                        ND_PRINT((ndo, \"%02x\", mpj->u.ack.mac[i]));\n        }\n        default:\n                break;\n        }\n        return 1;\n}", "target": 1}
{"code": "MagickExport size_t GetQuantumExtent(const Image *image,\n  const QuantumInfo *quantum_info,const QuantumType quantum_type)\n{\n  size_t\n    extent,\n    packet_size;\n  assert(quantum_info != (QuantumInfo *) NULL);\n  assert(quantum_info->signature == MagickCoreSignature);\n  packet_size=1;\n  switch (quantum_type)\n  {\n    case GrayAlphaQuantum: packet_size=2; break;\n    case IndexAlphaQuantum: packet_size=2; break;\n    case RGBQuantum: packet_size=3; break;\n    case BGRQuantum: packet_size=3; break;\n    case RGBAQuantum: packet_size=4; break;\n    case RGBOQuantum: packet_size=4; break;\n    case BGRAQuantum: packet_size=4; break;\n    case CMYKQuantum: packet_size=4; break;\n    case CMYKAQuantum: packet_size=5; break;\n    case CbYCrAQuantum: packet_size=4; break;\n    case CbYCrQuantum: packet_size=3; break;\n    case CbYCrYQuantum: packet_size=4; break;\n    default: break;\n  }\n  extent=MagickMax(image->columns,image->rows);\n  if (quantum_info->pack == MagickFalse)\n    return((size_t) (packet_size*extent*((quantum_info->depth+7)/8)));\n  return((size_t) ((packet_size*extent*quantum_info->depth+7)/8));\n}", "target": 0}
{"code": "l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\tptr++;\t\t\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"CRCErr=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"FrameErr=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"HardOver=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"BufOver=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"Timeout=%u \", (val_h<<16) + val_l));\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"AlignErr=%u \", (val_h<<16) + val_l));\n}", "target": 1}
{"code": "smb_fdata(netdissect_options *ndo,\n          const u_char *buf, const char *fmt, const u_char *maxbuf,\n          int unicodestr)\n{\n    static int depth = 0;\n    char s[128];\n    char *p;\n    while (*fmt) {\n\tswitch (*fmt) {\n\tcase '*':\n\t    fmt++;\n\t    while (buf < maxbuf) {\n\t\tconst u_char *buf2;\n\t\tdepth++;\n\t\tbuf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr);\n\t\tdepth--;\n\t\tif (buf2 == NULL)\n\t\t    return(NULL);\n\t\tif (buf2 == buf)\n\t\t    return(buf);\n\t\tbuf = buf2;\n\t    }\n\t    return(buf);\n\tcase '|':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    break;\n\tcase '%':\n\t    fmt++;\n\t    buf = maxbuf;\n\t    break;\n\tcase '#':\n\t    fmt++;\n\t    return(buf);\n\t    break;\n\tcase '[':\n\t    fmt++;\n\t    if (buf >= maxbuf)\n\t\treturn(buf);\n\t    memset(s, 0, sizeof(s));\n\t    p = strchr(fmt, ']');\n\t    if ((size_t)(p - fmt + 1) > sizeof(s)) {\n\t\treturn(buf);\n\t    }\n\t    strncpy(s, fmt, p - fmt);\n\t    s[p - fmt] = '\\0';\n\t    fmt = p + 1;\n\t    buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr);\n\t    if (buf == NULL)\n\t\treturn(NULL);\n\t    break;\n\tdefault:\n\t    ND_PRINT((ndo, \"%c\", *fmt));\n\t    fmt++;\n\t    break;\n\t}\n    }\n    if (!depth && buf < maxbuf) {\n\tsize_t len = PTR_DIFF(maxbuf, buf);\n\tND_PRINT((ndo, \"Data: (%lu bytes)\\n\", (unsigned long)len));\n\tsmb_print_data(ndo, buf, len);\n\treturn(buf + len);\n    }\n    return(buf);\n}", "target": 1}
{"code": "static int bad_format_check(const char *pattern, char *fmt) {\n    GError *gerr = NULL;\n    GRegex *re = g_regex_new(pattern, G_REGEX_EXTENDED, 0, &gerr);\n    GMatchInfo *mi;\n    if (gerr != NULL) {\n        rrd_set_error(\"cannot compile regular expression: %s (%s)\", gerr->message,pattern);\n        return 1;\n    }\n    int m = g_regex_match(re, fmt, 0, &mi);\n    g_match_info_free (mi);\n    g_regex_unref(re);\n    if (!m) {\n        rrd_set_error(\"invalid format string '%s' (should match '%s')\",fmt,pattern);\n        return 1;\n    }\n    return 0;\n}", "target": 0}
{"code": "u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t__be16 sport, __be16 dport)\n{\n\tu64 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\tseq = half_md4_transform(hash, keyptr->secret);\n\tseq |= ((u64)keyptr->count) << (32 - HASH_BITS);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 1}
{"code": "static int tls_construct_cke_ecdhe(SSL *s, unsigned char **p, int *len, int *al)\n{\n#ifndef OPENSSL_NO_EC\n    unsigned char *encodedPoint = NULL;\n    int encoded_pt_len = 0;\n    EVP_PKEY *ckey = NULL, *skey = NULL;\n    skey = s->s3->peer_tmp;\n    if (skey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n    ckey = ssl_generate_pkey(skey);\n    if (ckey == NULL) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n        goto err;\n    }\n    if (ssl_derive(s, ckey, skey) == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EVP_LIB);\n        goto err;\n    }\n    encoded_pt_len = EVP_PKEY_get1_tls_encodedpoint(ckey, &encodedPoint);\n    if (encoded_pt_len == 0) {\n        SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_EC_LIB);\n        goto err;\n    }\n    EVP_PKEY_free(ckey);\n    ckey = NULL;\n    *len = encoded_pt_len;\n    **p = *len;\n    *p += 1;\n    memcpy(*p, encodedPoint, *len);\n    *len += 1;\n    OPENSSL_free(encodedPoint);\n    return 1;\n err:\n    EVP_PKEY_free(ckey);\n    return 0;\n#else\n    SSLerr(SSL_F_TLS_CONSTRUCT_CKE_ECDHE, ERR_R_INTERNAL_ERROR);\n    *al = SSL_AD_INTERNAL_ERROR;\n    return 0;\n#endif\n}", "target": 0}
{"code": "acpi_parse_lapic_nmi(acpi_table_entry_header * header, const unsigned long end)\n{\n\tstruct acpi_table_lapic_nmi *lapic_nmi = NULL;\n\tlapic_nmi = (struct acpi_table_lapic_nmi *)header;\n\tif (BAD_MADT_ENTRY(lapic_nmi, end))\n\t\treturn -EINVAL;\n\tacpi_table_print_madt_entry(header);\n\tif (lapic_nmi->lint != 1)\n\t\tprintk(KERN_WARNING PREFIX \"NMI not connected to LINT 1!\\n\");\n\treturn 0;\n}", "target": 0}
{"code": "static ssize_t qrtr_tun_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct qrtr_tun *tun = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret;\n\tvoid *kbuf;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tret = qrtr_endpoint_post(&tun->ep, kbuf, len);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "static int timer_start(Unit *u) {\n        Timer *t = TIMER(u);\n        TimerValue *v;\n        assert(t);\n        assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);\n        if (UNIT_TRIGGER(u)->load_state != UNIT_LOADED)\n                return -ENOENT;\n        t->last_trigger = DUAL_TIMESTAMP_NULL;\n        LIST_FOREACH(value, v, t->values)\n                if (v->base == TIMER_ACTIVE)\n                        v->disabled = false;\n        if (t->stamp_path) {\n                struct stat st;\n                if (stat(t->stamp_path, &st) >= 0)\n                        t->last_trigger.realtime = timespec_load(&st.st_atim);\n                else if (errno == ENOENT)\n                        touch_file(t->stamp_path, true, USEC_INFINITY, UID_INVALID, GID_INVALID, 0);\n        }\n        t->result = TIMER_SUCCESS;\n        timer_enter_waiting(t, true);\n        return 1;\n}", "target": 1}
{"code": "void AcceptRoutingHandler<Pipeline, R>::onRoutingData(\n    uint64_t connId,\n    typename RoutingDataHandler<R>::RoutingData& routingData) {\n  auto routingPipelineIter = routingPipelines_.find(connId);\n  if (routingPipelineIter == routingPipelines_.end()) {\n    VLOG(2) << \"Connection has already been closed, \"\n               \"or routed to a worker thread.\";\n    return;\n  }\n  auto routingPipeline = std::move(routingPipelineIter->second);\n  routingPipelines_.erase(routingPipelineIter);\n  auto socket = std::dynamic_pointer_cast<folly::AsyncSocket>(\n      routingPipeline->getTransport());\n  routingPipeline->transportInactive();\n  socket->detachEventBase();\n  uint64_t hash = std::hash<R>()(routingData.routingData);\n  auto acceptor = acceptors_[hash % acceptors_.size()];\n  acceptor->getEventBase()->runInEventBaseThread(\n      [ =, routingData = std::move(routingData) ]() mutable {\n        socket->attachEventBase(acceptor->getEventBase());\n        auto routingHandler =\n            routingPipeline->template getHandler<RoutingDataHandler<R>>();\n        DCHECK(routingHandler);\n        auto transportInfo = routingPipeline->getTransportInfo();\n        auto pipeline = childPipelineFactory_->newPipeline(\n            socket, routingData.routingData, routingHandler, transportInfo);\n        auto connection =\n            new typename ServerAcceptor<Pipeline>::ServerConnection(pipeline);\n        acceptor->addConnection(connection);\n        pipeline->transportActive();\n        pipeline->read(routingData.bufQueue);\n      });\n}", "target": 1}
{"code": "TfLiteStatus ScatterNd(const TfLiteTensor* indices, const TfLiteTensor* updates,\n                       TfLiteTensor* output) {\n  reference_ops::ScatterNd(\n      GetTensorShape(indices), GetTensorData<IndicesT>(indices),\n      GetTensorShape(updates), GetTensorData<UpdatesT>(updates),\n      GetTensorShape(output), GetTensorData<UpdatesT>(output));\n  return kTfLiteOk;\n}", "target": 1}
{"code": "R_API RBinJavaAttrInfo *r_bin_java_enclosing_methods_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 6;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr || sz < 10) {\n\t\tfree (attr);\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_ENCLOSING_METHOD_ATTR;\n\tattr->info.enclosing_method_attr.class_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.enclosing_method_attr.method_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tattr->info.enclosing_method_attr.class_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.class_idx);\n\tif (attr->info.enclosing_method_attr.class_name == NULL) {\n\t\teprintf (\"Could not resolve enclosing class name for the enclosed method.\\n\");\n\t}\n\tattr->info.enclosing_method_attr.method_name = r_bin_java_get_name_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);\n\tif (attr->info.enclosing_method_attr.class_name == NULL) {\n\t\teprintf (\"Could not resolve method descriptor for the enclosed method.\\n\");\n\t}\n\tattr->info.enclosing_method_attr.method_descriptor = r_bin_java_get_desc_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, attr->info.enclosing_method_attr.method_idx);\n\tif (attr->info.enclosing_method_attr.method_name == NULL) {\n\t\teprintf (\"Could not resolve method name for the enclosed method.\\n\");\n\t}\n\tattr->size = offset;\n\treturn attr;\n}", "target": 0}
{"code": "  void operator()(const CPUDevice& d, typename TTypes<T>::ConstVec input,\n                  const bool signed_input, const int num_bits,\n                  const bool range_given, Tensor* input_min_tensor,\n                  Tensor* input_max_tensor, QuantizerRoundMode round_mode,\n                  bool narrow_range, typename TTypes<T>::Vec out) {\n    QuantizeAndDequantizeOneScaleImpl<CPUDevice, T>::Compute(\n        d, input, signed_input, num_bits, range_given, input_min_tensor,\n        input_max_tensor, round_mode, narrow_range, out);\n  }", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_STATUS(CalculateOpData(context, params, input, output, data));\n  if (input->type == kTfLiteFloat32) {\n    CalculateActivationRange(params->activation, &data->activation_min_f32,\n                             &data->activation_max_f32);\n  } else if (input->type == kTfLiteInt8 || input->type == kTfLiteUInt8) {\n    CalculateActivationRangeQuantized(context, params->activation, output,\n                                      &data->activation_min,\n                                      &data->activation_max);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "mm_sync_list(struct mmtree *oldtree, struct mmtree *newtree,\n    struct mm_master *mm, struct mm_master *mmold)\n{\n\tstruct mm_master *mmalloc = mm->mmalloc;\n\tstruct mm_share *mms, *new;\n\tRB_FOREACH(mms, mmtree, oldtree) {\n\t\tmm_memvalid(mmold, mms, sizeof(struct mm_share));\n\t\tmm_memvalid(mm, mms->address, mms->size);\n\t\tnew = mm_xmalloc(mmalloc, sizeof(struct mm_share));\n\t\tmemcpy(new, mms, sizeof(struct mm_share));\n\t\tRB_INSERT(mmtree, newtree, new);\n\t}\n}", "target": 1}
{"code": "static void __free_slab(struct kmem_cache *s, struct page *page)\n{\n\tint order = compound_order(page);\n\tint pages = 1 << order;\n\tif (s->flags & SLAB_CONSISTENCY_CHECKS) {\n\t\tvoid *p;\n\t\tslab_pad_check(s, page);\n\t\tfor_each_object(p, s, page_address(page),\n\t\t\t\t\t\tpage->objects)\n\t\t\tcheck_object(s, page, p, SLUB_RED_INACTIVE);\n\t}\n\t__ClearPageSlabPfmemalloc(page);\n\t__ClearPageSlab(page);\n\tpage->mapping = NULL;\n\tif (current->reclaim_state)\n\t\tcurrent->reclaim_state->reclaimed_slab += pages;\n\tuncharge_slab_page(page, order, s);\n\t__free_pages(page, order);\n}", "target": 0}
{"code": "void ComparisonQuantized(const TfLiteTensor* input1, const TfLiteTensor* input2,\n                         TfLiteTensor* output, bool requires_broadcast) {\n  if (input1->type == kTfLiteUInt8 || input1->type == kTfLiteInt8) {\n    auto input1_offset = -input1->params.zero_point;\n    auto input2_offset = -input2->params.zero_point;\n    const int left_shift = 8;\n    int32 input1_multiplier;\n    int input1_shift;\n    QuantizeMultiplierSmallerThanOneExp(input1->params.scale,\n                                        &input1_multiplier, &input1_shift);\n    int32 input2_multiplier;\n    int input2_shift;\n    QuantizeMultiplierSmallerThanOneExp(input2->params.scale,\n                                        &input2_multiplier, &input2_shift);\n    ComparisonParams op_params;\n    op_params.left_shift = left_shift;\n    op_params.input1_offset = input1_offset;\n    op_params.input1_multiplier = input1_multiplier;\n    op_params.input1_shift = input1_shift;\n    op_params.input2_offset = input2_offset;\n    op_params.input2_multiplier = input2_multiplier;\n    op_params.input2_shift = input2_shift;\n    if (requires_broadcast) {\n      reference_ops::BroadcastComparison4DSlowWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    } else {\n      reference_ops::ComparisonWithScaling<input_dtype, opname>(\n          op_params, GetTensorShape(input1), GetTensorData<input_dtype>(input1),\n          GetTensorShape(input2), GetTensorData<input_dtype>(input2),\n          GetTensorShape(output), GetTensorData<bool>(output));\n    }\n  }\n}", "target": 1}
{"code": "  const std::string& get_id() const {\n    ceph_assert(t != Wildcard && t != Tenant);\n    return u.id;\n  }", "target": 1}
{"code": "static inline struct keydata *get_keyptr(void)\n{\n\tstruct keydata *keyptr = &ip_keydata[ip_cnt & 1];\n\tsmp_rmb();\n\treturn keyptr;\n}", "target": 1}
{"code": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n{\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}", "target": 1}
{"code": "void hashtable_clear(hashtable_t *hashtable)\n{\n    size_t i;\n    hashtable_do_clear(hashtable);\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n    list_init(&hashtable->list);\n    hashtable->size = 0;\n}", "target": 1}
{"code": "void mpz_as_bytes(const mpz_t *z, bool big_endian, size_t len, byte *buf) {\n    byte *b = buf;\n    if (big_endian) {\n        b += len;\n    }\n    mpz_dig_t *zdig = z->dig;\n    int bits = 0;\n    mpz_dbl_dig_t d = 0;\n    mpz_dbl_dig_t carry = 1;\n    for (size_t zlen = z->len; zlen > 0; --zlen) {\n        bits += DIG_SIZE;\n        d = (d << DIG_SIZE) | *zdig++;\n        for (; bits >= 8; bits -= 8, d >>= 8) {\n            mpz_dig_t val = d;\n            if (z->neg) {\n                val = (~val & 0xff) + carry;\n                carry = val >> 8;\n            }\n            if (big_endian) {\n                *--b = val;\n                if (b == buf) {\n                    return;\n                }\n            } else {\n                *b++ = val;\n                if (b == buf + len) {\n                    return;\n                }\n            }\n        }\n    }\n    if (big_endian) {\n        len = b - buf;\n    } else {\n        len = buf + len - b;\n        buf = b;\n    }\n    memset(buf, z->neg ? 0xff : 0x00, len);\n}", "target": 1}
{"code": "receive_carbon(void **state)\n{\n    prof_input(\"/carbons on\");\n    prof_connect();\n    assert_true(stbbr_received(\n        \"<iq id='*' type='set'><enable xmlns='urn:xmpp:carbons:2'/></iq>\"\n    ));\n    stbbr_send(\n        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n    assert_true(prof_output_regex(\"Buddy1/mobile: .+test carbon from recipient\"));\n}", "target": 1}
{"code": "ff_layout_choose_valid_ds_for_read(struct pnfs_layout_segment *lseg,\n\t\t\t\t   u32 start_idx, u32 *best_idx)\n{\n\treturn ff_layout_choose_ds_for_read(lseg, start_idx, best_idx, true);\n}", "target": 0}
{"code": "uint16_t mesg_id (void) {\n\tstatic uint16_t id = 0;\n\tif (!id) {\n\t\tsrandom (time (NULL));\n\t\tid = random ();\n\t}\n\tid++;\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", id);\n\treturn id;\n}", "target": 1}
{"code": "para_macro_process(uschar *p, uschar *q)\n{\nint length = q - p;\nargstr **pp;\nmacrodef *md;\nmacroexe *me;\nfor (md = macrolist; md != NULL; md = md->next)\n  {\n  if (length == md->namelength && Ustrncmp(p, md->name, length) == 0) break;\n  }\nif (md == NULL)\n  {\n  error(23, length, p);\n  (void)fprintf(outfile, \"&\");\n  return p;\n  }\nme = misc_malloc(sizeof(macroexe));\nme->prev = macrocurrent;\nmacrocurrent = me;\nme->macro = md;\nme->nextline = md->lines;\nif (from_type_ptr >= FROM_TYPE_STACKSIZE - 1) error(32);  \nfrom_type[++from_type_ptr] = FROM_MACRO;\nme->args = NULL;\npp = &(me->args);\nwhile (isspace(*(++q)));\nwhile (*q != 0 && *q != ')')\n  {\n  argstr *as = misc_malloc(sizeof(argstr));\n  as->next = NULL;\n  *pp = as;\n  pp = &(as->next);\n  as->string = misc_readitem(q, US\",)\", &length, NULL, 0);\n  q += length;\n  if (*q == ',') while (isspace(*(++q)));\n  }\nif (*q != ')')\n  {\n  error(24, p);\n  (void)fprintf(outfile, \"&\");\n  return p;\n  }\npara_inline_macro++;\nfor (;;)\n  {\n  uschar buffer[INBUFFSIZE];\n  read_process_macroline(macrocurrent->nextline->string, buffer);\n  if (*buffer == '.')\n    {\n    dot_process(buffer);\n    if (macrocurrent != me) break;\n    }\n  else\n    {\n    uschar *qq = buffer + Ustrlen(buffer);\n    while (qq > buffer && isspace(qq[-1])) qq--;\n    *qq = 0;\n    para_process(buffer);\n    }\n  macrocurrent->nextline = macrocurrent->nextline->next;\n  if (macrocurrent->nextline == NULL)\n    {\n    macroexe *temp = macrocurrent;\n    macrocurrent = macrocurrent->prev;\n    macro_free(temp);\n    from_type_ptr--;\n    break;\n    }\n  }\npara_inline_macro--;\nreturn q + 1;\n}", "target": 1}
{"code": "static int crypto_report_comp(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rcomp;\n\tsnprintf(rcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"compression\");\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "static Jsi_RC jsi_ArrayJoinCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    const char *jstr = \"\";\n    int argc, curlen;\n    Jsi_DString dStr = {};\n    curlen = Jsi_ObjGetLength(interp, _this->d.obj);\n    if (curlen == 0) {\n        goto bail;\n    }\n    if (Jsi_ValueGetLength(interp, args) >= 1) {\n        Jsi_Value *sc = Jsi_ValueArrayIndex(interp, args, 0);\n        if (sc != NULL)\n            jstr = Jsi_ValueToString(interp, sc, NULL);\n    }\n    if (0 == (argc=Jsi_ObjGetLength(interp, _this->d.obj))) {\n        goto bail;\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        const char *cp;\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, _this, i);\n        if (!ov) {\n            continue;\n            cp = \"\";\n        } else\n            cp = Jsi_ValueToString(interp, ov, NULL);\n        if (i && jstr[0])\n            Jsi_DSAppend(&dStr, jstr, NULL);\n        Jsi_DSAppend(&dStr, cp, NULL);\n    }\n    Jsi_ValueMakeStringDup(interp, ret, Jsi_DSValue(&dStr));\n    Jsi_DSFree(&dStr);\n    return JSI_OK;\nbail:\n    Jsi_ValueMakeStringDup(interp, ret, \"\");\n    return JSI_OK;        \n}", "target": 1}
{"code": "flatpak_run_get_cups_server_name (void)\n{\n  g_autofree char * cups_server = NULL;\n  g_autofree char * cups_config_path = NULL;\n  cups_server = g_strdup (g_getenv (\"CUPS_SERVER\"));\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n  cups_config_path = g_build_filename (g_get_home_dir (), \".cups/client.conf\", NULL);\n  cups_server = flatpak_run_get_cups_server_name_config (cups_config_path);\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  g_clear_pointer (&cups_server, g_free);\n  cups_server = flatpak_run_get_cups_server_name_config (\"/etc/cups/client.conf\");\n  if (cups_server && flatpak_run_cups_check_server_is_socket (cups_server))\n    return g_steal_pointer (&cups_server);\n  return g_strdup (\"/var/run/cups/cups.sock\");\n}", "target": 0}
{"code": "ProcAllocColor(ClientPtr client)\n{\n    ColormapPtr pmap;\n    int rc;\n    REQUEST(xAllocColorReq);\n    REQUEST_SIZE_MATCH(xAllocColorReq);\n    rc = dixLookupResourceByType((void **) &pmap, stuff->cmap, RT_COLORMAP,\n                                 client, DixAddAccess);\n    if (rc == Success) {\n        xAllocColorReply acr = {\n            .type = X_Reply,\n            .sequenceNumber = client->sequence,\n            .length = 0,\n            .red = stuff->red,\n            .green = stuff->green,\n            .blue = stuff->blue,\n            .pixel = 0\n        };\n        if ((rc = AllocColor(pmap, &acr.red, &acr.green, &acr.blue,\n                             &acr.pixel, client->index)))\n            return rc;\n#ifdef PANORAMIX\n        if (noPanoramiXExtension || !pmap->pScreen->myNum)\n#endif\n            WriteReplyToClient(client, sizeof(xAllocColorReply), &acr);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->cmap;\n        return rc;\n    }\n}", "target": 0}
{"code": "parse_string(xmlTextReaderPtr reader, char const *attr, char **result)\n{\n\txmlChar *xml_value;\n\tchar *tmp;\n\tif (attr == NULL)\n\t\txml_value = xmlTextReaderValue(reader);\n\telse\n\t\txml_value = xmlTextReaderGetAttribute(reader, BAD_CAST attr);\n\tif (xml_value == NULL)\n\t\treturn pr_val_err(\"RRDP file: Couldn't find %s from '%s'\",\n\t\t    (attr == NULL ? \"string content\" : \"xml attribute\"),\n\t\t    xmlTextReaderConstLocalName(reader));\n\ttmp = malloc(xmlStrlen(xml_value) + 1);\n\tif (tmp == NULL) {\n\t\txmlFree(xml_value);\n\t\treturn pr_enomem();\n\t}\n\tmemcpy(tmp, xml_value, xmlStrlen(xml_value));\n\ttmp[xmlStrlen(xml_value)] = '\\0';\n\txmlFree(xml_value);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "void comps_objrtree_unite(COMPS_ObjRTree *rt1, COMPS_ObjRTree *rt2) {\n    COMPS_HSList *tmplist, *tmp_subnodes;\n    COMPS_HSListItem *it;\n    struct Pair {\n        COMPS_HSList * subnodes;\n        char * key;\n        char added;\n    } *pair, *parent_pair;\n    pair = malloc(sizeof(struct Pair));\n    pair->subnodes = rt2->subnodes;\n    pair->key = NULL;\n    tmplist = comps_hslist_create();\n    comps_hslist_init(tmplist, NULL, NULL, &free);\n    comps_hslist_append(tmplist, pair, 0);\n    while (tmplist->first != NULL) {\n        it = tmplist->first;\n        comps_hslist_remove(tmplist, tmplist->first);\n        tmp_subnodes = ((struct Pair*)it->data)->subnodes;\n        parent_pair = (struct Pair*) it->data;\n        free(it);\n        for (it = tmp_subnodes->first; it != NULL; it=it->next) {\n            pair = malloc(sizeof(struct Pair));\n            pair->subnodes = ((COMPS_ObjRTreeData*)it->data)->subnodes;\n            if (parent_pair->key != NULL) {\n                pair->key = malloc(sizeof(char)\n                               * (strlen(((COMPS_ObjRTreeData*)it->data)->key)\n                               + strlen(parent_pair->key) + 1));\n                memcpy(pair->key, parent_pair->key,\n                       sizeof(char) * strlen(parent_pair->key));\n                memcpy(pair->key + strlen(parent_pair->key),\n                       ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            } else {\n                pair->key = malloc(sizeof(char)*\n                                (strlen(((COMPS_ObjRTreeData*)it->data)->key) +1));\n                memcpy(pair->key, ((COMPS_ObjRTreeData*)it->data)->key,\n                       sizeof(char)*(strlen(((COMPS_ObjRTreeData*)it->data)->key)+1));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->data != NULL) {\n                    comps_objrtree_set(rt1, pair->key,\n                                      (((COMPS_ObjRTreeData*)it->data)->data));\n            }\n            if (((COMPS_ObjRTreeData*)it->data)->subnodes->first) {\n                comps_hslist_append(tmplist, pair, 0);\n            } else {\n                free(pair->key);\n                free(pair);\n            }\n        }\n        free(parent_pair->key);\n        free(parent_pair);\n    }\n    comps_hslist_destroy(&tmplist);\n}", "target": 1}
{"code": "static int scanbraces(const char* in) {\n    if (strncmp(in, \"{\\\\an\", 4) != 0) {\n        return 0;\n    }\n    if (!isdigit(in[4])) {\n        return 0;\n    }\n    if (in[5] != '}') {\n        return 0;\n    }\n    return 1;\n}", "target": 0}
{"code": "static int ovl_remove_upper(struct dentry *dentry, bool is_dir)\n{\n\tstruct dentry *upperdir = ovl_dentry_upper(dentry->d_parent);\n\tstruct inode *dir = upperdir->d_inode;\n\tstruct dentry *upper = ovl_dentry_upper(dentry);\n\tint err;\n\tinode_lock_nested(dir, I_MUTEX_PARENT);\n\terr = -ESTALE;\n\tif (upper->d_parent == upperdir) {\n\t\tdget(upper);\n\t\tif (is_dir)\n\t\t\terr = vfs_rmdir(dir, upper);\n\t\telse\n\t\t\terr = vfs_unlink(dir, upper, NULL);\n\t\tdput(upper);\n\t\tovl_dentry_version_inc(dentry->d_parent);\n\t}\n\tif (!err)\n\t\td_drop(dentry);\n\tinode_unlock(dir);\n\treturn err;\n}", "target": 1}
{"code": "comics_remove_dir (gchar *path_name)\n{\n\tGDir  *content_dir;\n\tconst gchar *filename;\n\tgchar *filename_with_path;\n\tif (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n\t\tcontent_dir = g_dir_open  (path_name, 0, NULL);\n\t\tfilename  = g_dir_read_name (content_dir);\n\t\twhile (filename) {\n\t\t\tfilename_with_path =\n\t\t\t\tg_build_filename (path_name,\n\t\t\t\t\t\t  filename, NULL);\n\t\t\tcomics_remove_dir (filename_with_path);\n\t\t\tg_free (filename_with_path);\n\t\t\tfilename = g_dir_read_name (content_dir);\n\t\t}\n\t\tg_dir_close (content_dir);\n\t}\n\treturn (g_remove (path_name));\n}", "target": 1}
{"code": "sanitize (GPtrArray *array)\n{\n        int i;\n        GPtrArray *new;\n        g_debug (\"before sanitizing\");\n        for (i = 0; i < array->len; ++i) {\n                if (array->pdata[i]) {\n                        print_configuration (array->pdata[i], \"before\");\n                }\n        }\n        for (i = 1; i < array->len; ++i) {\n                int j;\n                for (j = 0; j < i; ++j) {\n                        GnomeRRConfig *this = array->pdata[j];\n                        GnomeRRConfig *other = array->pdata[i];\n                        if (this && other && gnome_rr_config_equal (this, other)) {\n                                g_debug (\"removing duplicate configuration\");\n                                gnome_rr_config_free (this);\n                                array->pdata[j] = NULL;\n                                break;\n                        }\n                }\n        }\n        for (i = 0; i < array->len; ++i) {\n                GnomeRRConfig *config = array->pdata[i];\n                if (config) {\n                        gboolean all_off = TRUE;\n                        int j;\n                        for (j = 0; config->outputs[j] != NULL; ++j) {\n                                if (config->outputs[j]->on)\n                                        all_off = FALSE;\n                        }\n                        if (all_off) {\n                                gnome_rr_config_free (array->pdata[i]);\n                                array->pdata[i] = NULL;\n                        }\n                }\n        }\n        new = g_ptr_array_new ();\n        for (i = 0; i < array->len; ++i) {\n                if (array->pdata[i]) {\n                        g_ptr_array_add (new, array->pdata[i]);\n                        print_configuration (array->pdata[i], \"Final\");\n                }\n        }\n        if (new->len > 0) {\n                g_ptr_array_add (new, NULL);\n        } else {\n                g_ptr_array_free (new, TRUE);\n                new = NULL;\n        }\n        g_ptr_array_free (array, TRUE);\n        return new;\n}", "target": 0}
{"code": "static uint32_t qpp_hash(QppEntry e)\n{\n    return qemu_xxhash7(e.ino_prefix, e.dev, 0, 0, 0);\n}", "target": 0}
{"code": "static s32 adpt_i2o_hrt_get(adpt_hba* pHba)\n{\n\tu32 msg[6];\n\tint ret, size = sizeof(i2o_hrt);\n\tdo {\n\t\tif (pHba->hrt == NULL) {\n\t\t\tpHba->hrt = dma_alloc_coherent(&pHba->pDev->dev,\n\t\t\t\t\tsize, &pHba->hrt_pa, GFP_KERNEL);\n\t\t\tif (pHba->hrt == NULL) {\n\t\t\t\tprintk(KERN_CRIT \"%s: Hrt Get failed; Out of memory.\\n\", pHba->name);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tmsg[0]= SIX_WORD_MSG_SIZE| SGL_OFFSET_4;\n\t\tmsg[1]= I2O_CMD_HRT_GET<<24 | HOST_TID<<12 | ADAPTER_TID;\n\t\tmsg[2]= 0;\n\t\tmsg[3]= 0;\n\t\tmsg[4]= (0xD0000000 | size);    \n\t\tmsg[5]= (u32)pHba->hrt_pa;\t\n\t\tif ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg),20))) {\n\t\t\tprintk(KERN_ERR \"%s: Unable to get HRT (status=%#10x)\\n\", pHba->name, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tif (pHba->hrt->num_entries * pHba->hrt->entry_len << 2 > size) {\n\t\t\tint newsize = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;\n\t\t\tdma_free_coherent(&pHba->pDev->dev, size,\n\t\t\t\tpHba->hrt, pHba->hrt_pa);\n\t\t\tsize = newsize;\n\t\t\tpHba->hrt = NULL;\n\t\t}\n\t} while(pHba->hrt == NULL);\n\treturn 0;\n}                                                                                                                                       ", "target": 1}
{"code": "static int delete_path(const char *dump_dir_name)\n{\n    if (!dir_is_in_dump_location(dump_dir_name))\n    {\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dump_dir_name, g_settings_dump_location);\n        return 400; \n    }\n    if (!dir_has_correct_permissions(dump_dir_name))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dump_dir_name);\n        return 400; \n    }\n    if (!dump_dir_accessible_by_uid(dump_dir_name, client_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            error_msg(\"Path '%s' isn't problem directory\", dump_dir_name);\n            return 404; \n        }\n        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dump_dir_name, (long)client_uid);\n        return 403; \n    }\n    delete_dump_dir(dump_dir_name);\n    return 0; \n}", "target": 0}
{"code": "dirserv_add_multiple_descriptors(const char *desc, uint8_t purpose,\n                                 const char *source,\n                                 const char **msg)\n{\n  was_router_added_t r, r_tmp;\n  const char *msg_out;\n  smartlist_t *list;\n  const char *s;\n  int n_parsed = 0;\n  time_t now = time(NULL);\n  char annotation_buf[ROUTER_ANNOTATION_BUF_LEN];\n  char time_buf[ISO_TIME_LEN+1];\n  int general = purpose == ROUTER_PURPOSE_GENERAL;\n  tor_assert(msg);\n  r=ROUTER_ADDED_SUCCESSFULLY; \n  format_iso_time(time_buf, now);\n  if (tor_snprintf(annotation_buf, sizeof(annotation_buf),\n                   \"@uploaded-at %s\\n\"\n                   \"@source %s\\n\"\n                   \"%s%s%s\", time_buf, escaped(source),\n                   !general ? \"@purpose \" : \"\",\n                   !general ? router_purpose_to_string(purpose) : \"\",\n                   !general ? \"\\n\" : \"\")<0) {\n    *msg = \"Couldn't format annotations\";\n    return -1;\n  }\n  s = desc;\n  list = smartlist_create();\n  if (!router_parse_list_from_string(&s, NULL, list, SAVED_NOWHERE, 0, 0,\n                                     annotation_buf)) {\n    SMARTLIST_FOREACH(list, routerinfo_t *, ri, {\n        msg_out = NULL;\n        tor_assert(ri->purpose == purpose);\n        r_tmp = dirserv_add_descriptor(ri, &msg_out, source);\n        if (WRA_MORE_SEVERE(r_tmp, r)) {\n          r = r_tmp;\n          *msg = msg_out;\n        }\n      });\n  }\n  n_parsed += smartlist_len(list);\n  smartlist_clear(list);\n  s = desc;\n  if (!router_parse_list_from_string(&s, NULL, list, SAVED_NOWHERE, 1, 0,\n                                     NULL)) {\n    SMARTLIST_FOREACH(list, extrainfo_t *, ei, {\n        msg_out = NULL;\n        r_tmp = dirserv_add_extrainfo(ei, &msg_out);\n        if (WRA_MORE_SEVERE(r_tmp, r)) {\n          r = r_tmp;\n          *msg = msg_out;\n        }\n      });\n  }\n  n_parsed += smartlist_len(list);\n  smartlist_free(list);\n  if (! *msg) {\n    if (!n_parsed) {\n      *msg = \"No descriptors found in your POST.\";\n      if (WRA_WAS_ADDED(r))\n        r = ROUTER_WAS_NOT_NEW;\n    } else {\n      *msg = \"(no message)\";\n    }\n  }\n  return r;\n}", "target": 0}
{"code": "static bool validate_net_dev(struct net_device *net_dev,\n\t\t\t     const struct sockaddr *daddr,\n\t\t\t     const struct sockaddr *saddr)\n{\n\tconst struct sockaddr_in *daddr4 = (const struct sockaddr_in *)daddr;\n\tconst struct sockaddr_in *saddr4 = (const struct sockaddr_in *)saddr;\n\tconst struct sockaddr_in6 *daddr6 = (const struct sockaddr_in6 *)daddr;\n\tconst struct sockaddr_in6 *saddr6 = (const struct sockaddr_in6 *)saddr;\n\tswitch (daddr->sa_family) {\n\tcase AF_INET:\n\t\treturn saddr->sa_family == AF_INET &&\n\t\t       validate_ipv4_net_dev(net_dev, daddr4, saddr4);\n\tcase AF_INET6:\n\t\treturn saddr->sa_family == AF_INET6 &&\n\t\t       validate_ipv6_net_dev(net_dev, daddr6, saddr6);\n\tdefault:\n\t\treturn false;\n\t}\n}", "target": 0}
{"code": "static RList* sections(RBinFile* bf) {\n\tRList* ret = NULL;\n\tRBinSection* sect = NULL;\n\tpsxexe_header psxheader = {0};\n\tut64 sz = 0;\n\tif (!(ret = r_list_new ())) {\n\t\treturn NULL;\n\t}\n\tif (!(sect = R_NEW0 (RBinSection))) {\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (bf->buf, 0, (ut8*)&psxheader, \"8c17i\", 1) < sizeof (psxexe_header)) {\n\t\teprintf (\"Truncated Header\\n\");\n\t\tfree (sect);\n\t\tr_list_free (ret);\n\t\treturn NULL;\n\t}\n\tsz = r_buf_size (bf->buf);\n\tsect->name = strdup (\"TEXT\");\n\tsect->paddr = PSXEXE_TEXTSECTION_OFFSET;\n\tsect->size = sz - PSXEXE_TEXTSECTION_OFFSET;\n\tsect->vaddr = psxheader.t_addr;\n\tsect->vsize = psxheader.t_size;\n\tsect->perm = R_PERM_RX;\n\tsect->add = true;\n\tsect->has_strings = true;\n\tr_list_append (ret, sect);\n\treturn ret;\n}", "target": 1}
{"code": "_SSL_check_hostname (X509 *cert, const char *host)\n{\n\tint rv;\n\trv = _SSL_check_subject_altname (cert, host);\n\tif (rv == 0 || rv == -2)\n\t\treturn rv;\n\treturn _SSL_check_common_name (cert, host);\n}", "target": 0}
{"code": "log2vis_utf8 (PyObject * string, int unicode_length,\n\t      FriBidiParType base_direction, int clean, int reordernsm)\n{\n\tFriBidiChar *logical = NULL; \n\tFriBidiChar *visual = NULL;\t \n\tchar *visual_utf8 = NULL;    \n\tFriBidiStrIndex new_len = 0; \n\tPyObject *result = NULL;\t \n\tlogical = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (logical == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\tvisual = PyMem_New (FriBidiChar, unicode_length + 1);\n\tif (visual == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t \"failed to allocate unicode buffer\");\n\t\tgoto cleanup;\n\t}\n\tfribidi_set_reorder_nsm(reordernsm);\n\tfribidi_utf8_to_unicode (PyString_AS_STRING (string),\n\t\t\t\t PyString_GET_SIZE (string), logical);\n\tif (!fribidi_log2vis (logical, unicode_length, &base_direction, visual,\n\t\t\t      NULL, NULL, NULL))\n\t{\n\t\tPyErr_SetString (PyExc_RuntimeError,\n\t\t\t\t \"fribidi failed to order string\");\n\t\tgoto cleanup;\n\t}\n\tif (clean)\n\t\tfribidi_remove_bidi_marks (visual, unicode_length, NULL, NULL, NULL);\n\tvisual_utf8 = PyMem_New(char, (unicode_length * 4)+1);\n\tif (visual_utf8 == NULL)\n\t{\n\t\tPyErr_SetString (PyExc_MemoryError,\n\t\t\t\t\"failed to allocate UTF-8 buffer\");\n\t\tgoto cleanup;\n\t}\n\tnew_len = fribidi_unicode_to_utf8 (visual, unicode_length, visual_utf8);\n\tresult = PyString_FromStringAndSize (visual_utf8, new_len);\n\tif (result == NULL)\n\t\tgoto cleanup;\n      cleanup:\n\tPyMem_Del (logical);\n\tPyMem_Del (visual);\n\tPyMem_Del (visual_utf8);\n\treturn result;\n}", "target": 1}
{"code": "    void TiffSizeEntry::doAccept(TiffVisitor& visitor)\n    {\n        visitor.visitSizeEntry(this);\n    } ", "target": 0}
{"code": "__u32 secure_ip_id(__be32 daddr)\n{\n\tstruct keydata *keyptr;\n\t__u32 hash[4];\n\tkeyptr = get_keyptr();\n\thash[0] = (__force __u32)daddr;\n\thash[1] = keyptr->secret[9];\n\thash[2] = keyptr->secret[10];\n\thash[3] = keyptr->secret[11];\n\treturn half_md4_transform(hash, keyptr->secret);\n}", "target": 1}
{"code": "void UnicodeStringTest::runIndexedTest( int32_t index, UBool exec, const char* &name, char *par)\n{\n    if (exec) logln(\"TestSuite UnicodeStringTest: \");\n    TESTCASE_AUTO_BEGIN;\n    TESTCASE_AUTO_CREATE_CLASS(StringCaseTest);\n    TESTCASE_AUTO(TestBasicManipulation);\n    TESTCASE_AUTO(TestCompare);\n    TESTCASE_AUTO(TestExtract);\n    TESTCASE_AUTO(TestRemoveReplace);\n    TESTCASE_AUTO(TestSearching);\n    TESTCASE_AUTO(TestSpacePadding);\n    TESTCASE_AUTO(TestPrefixAndSuffix);\n    TESTCASE_AUTO(TestFindAndReplace);\n    TESTCASE_AUTO(TestBogus);\n    TESTCASE_AUTO(TestReverse);\n    TESTCASE_AUTO(TestMiscellaneous);\n    TESTCASE_AUTO(TestStackAllocation);\n    TESTCASE_AUTO(TestUnescape);\n    TESTCASE_AUTO(TestCountChar32);\n    TESTCASE_AUTO(TestStringEnumeration);\n    TESTCASE_AUTO(TestNameSpace);\n    TESTCASE_AUTO(TestUTF32);\n    TESTCASE_AUTO(TestUTF8);\n    TESTCASE_AUTO(TestReadOnlyAlias);\n    TESTCASE_AUTO(TestAppendable);\n    TESTCASE_AUTO(TestUnicodeStringImplementsAppendable);\n    TESTCASE_AUTO(TestSizeofUnicodeString);\n    TESTCASE_AUTO(TestStartsWithAndEndsWithNulTerminated);\n    TESTCASE_AUTO(TestMoveSwap);\n    TESTCASE_AUTO(TestUInt16Pointers);\n    TESTCASE_AUTO(TestWCharPointers);\n    TESTCASE_AUTO(TestNullPointers);\n    TESTCASE_AUTO(TestUnicodeStringInsertAppendToSelf);\n    TESTCASE_AUTO(TestLargeAppend);\n    TESTCASE_AUTO_END;\n}", "target": 0}
{"code": "callbacks_screen2board(gdouble *X, gdouble *Y, gint x, gint y) {\n\tif ((screenRenderInfo.scaleFactorX > 0.001)||(screenRenderInfo.scaleFactorY > 0.001)) {\n\t\t*X = screenRenderInfo.lowerLeftX + (x / screenRenderInfo.scaleFactorX);\n\t\t*Y = screenRenderInfo.lowerLeftY + ((screenRenderInfo.displayHeight - y)\n\t\t\t/ screenRenderInfo.scaleFactorY);\n\t}\n\telse {\n\t\t*X = *Y = 0.0;\n\t}\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext   *ctx     = inlink->dst;\n    FieldOrderContext *s       = ctx->priv;\n    AVFilterLink      *outlink = ctx->outputs[0];\n    int h, plane, line_step, line_size, line;\n    uint8_t *data;\n    if (!frame->interlaced_frame ||\n        frame->top_field_first == s->dst_tff)\n        return ff_filter_frame(outlink, frame);\n    av_dlog(ctx,\n            \"picture will move %s one line\\n\",\n            s->dst_tff ? \"up\" : \"down\");\n    h = frame->height;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        line_step = frame->linesize[plane];\n        line_size = s->line_size[plane];\n        data = frame->data[plane];\n        if (s->dst_tff) {\n            for (line = 0; line < h; line++) {\n                if (1 + line < frame->height) {\n                    memcpy(data, data + line_step, line_size);\n                } else {\n                    memcpy(data, data - line_step - line_step, line_size);\n                }\n                data += line_step;\n            }\n        } else {\n            data += (h - 1) * line_step;\n            for (line = h - 1; line >= 0 ; line--) {\n                if (line > 0) {\n                    memcpy(data, data - line_step, line_size);\n                } else {\n                    memcpy(data, data + line_step + line_step, line_size);\n                }\n                data -= line_step;\n            }\n        }\n    }\n    frame->top_field_first = s->dst_tff;\n    return ff_filter_frame(outlink, frame);\n}", "target": 1}
{"code": "utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n                                                const std::string &value) {\n  ngx_table_elt_t *h = nullptr;\n  for (auto &h_in : r_->headers_in) {\n    if (key.size() == h_in.key.len &&\n        strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                    h_in.key.len) == 0) {\n      h = &h_in;\n      break;\n    }\n  }\n  if (h == nullptr) {\n    h = reinterpret_cast<ngx_table_elt_t *>(\n        ngx_list_push(&r_->headers_in.headers));\n    if (h == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->lowcase_key =\n        reinterpret_cast<u_char *>(ngx_pcalloc(r_->pool, key.size()));\n    if (h->lowcase_key == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->hash = ngx_hash_strlow(\n        h->lowcase_key,\n        reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n        key.size());\n  }\n  if (ngx_str_copy_from_std(r_->pool, key, &h->key) != NGX_OK ||\n      ngx_str_copy_from_std(r_->pool, value, &h->value) != NGX_OK) {\n    return utils::Status(Code::INTERNAL, \"Out of memory\");\n  }\n  ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n                 \"updates header to backend: \\\"%V: %V\\\"\", &h->key, &h->value);\n  return utils::Status::OK;\n}", "target": 1}
{"code": "static int adpt_reset(struct scsi_cmnd* cmd)\n{\n\tint rc;\n\tspin_lock_irq(cmd->device->host->host_lock);\n\trc = __adpt_reset(cmd);\n\tspin_unlock_irq(cmd->device->host->host_lock);\n\treturn rc;\n}", "target": 1}
{"code": "static void handle_get_publish(struct http_conn *conn,\n\t\t\t       const struct http_msg *msg,\n\t\t\t       struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\tinfo(\"handle get publish\\n\");\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"publish: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"handle get publish (content=%s)\\n\", ie->content.publish);\n\tif (ie->content.publish) {\n\t\thttp_creply(conn, 200, \"OK\",\n\t\t\t    \"application/json\", \"%s\", ie->content.publish);\n\t}\n\telse {\n\t\thttp_ereply(conn, 404, \"Not Yet\");\n\t}\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "static unsigned long mb2_cache_count(struct shrinker *shrink,\n\t\t\t\t     struct shrink_control *sc)\n{\n\tstruct mb2_cache *cache = container_of(shrink, struct mb2_cache,\n\t\t\t\t\t       c_shrink);\n\treturn cache->c_entry_count;\n}", "target": 0}
{"code": "Status ExtractVariantFromInput(OpKernelContext* ctx, int index,\n                               const T** value) {\n  const Tensor& input_t = ctx->input(index);\n  if (!TensorShapeUtils::IsScalar(input_t.shape())) {\n    return errors::InvalidArgument(\n        \"Invalid input matrix: Shape must be rank 0 but is rank \",\n        input_t.dims());\n  }\n  const Variant& input_variant = input_t.scalar<Variant>()();\n  *value = input_variant.get<T>();\n  if (*value == nullptr) {\n    return errors::InvalidArgument(\"Could not retrieve Variant input \", index);\n  }\n  if (!(*value)->valid()) {\n    return errors::InvalidArgument(\"Variant input \", index, \" is not valid.\");\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "RecordFlushAllContexts(CallbackListPtr *pcbl,\n                       void *nulldata, void *calldata)\n{\n    int eci;                    \n    RecordContextPtr pContext;\n    for (eci = 0; eci < numEnabledContexts; eci++) {\n        pContext = ppAllContexts[eci];\n        if (pContext->numBufBytes)\n            RecordFlushReplyBuffer(ppAllContexts[eci], NULL, 0, NULL, 0);\n    }\n}                               ", "target": 0}
{"code": "static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)\n{\n\tstruct vivid_dev *dev = (struct vivid_dev *)info->par;\n\tswitch (cmd) {\n\tcase FBIOGET_VBLANK: {\n\t\tstruct fb_vblank vblank;\n\t\tmemset(&vblank, 0, sizeof(vblank));\n\t\tvblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |\n\t\t\tFB_VBLANK_HAVE_VSYNC;\n\t\tvblank.count = 0;\n\t\tvblank.vcount = 0;\n\t\tvblank.hcount = 0;\n\t\tif (copy_to_user((void __user *)arg, &vblank, sizeof(vblank)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\tdefault:\n\t\tdprintk(dev, 1, \"Unknown ioctl %08x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "TEST(InMatchExpression, MatchesNull) {\n    BSONObj operand = BSON_ARRAY(BSONNULL);\n    InMatchExpression in(\"a\");\n    std::vector<BSONElement> equalities{operand.firstElement()};\n    ASSERT_OK(in.setEqualities(std::move(equalities)));\n    ASSERT(in.matchesBSON(BSONObj(), NULL));\n    ASSERT(in.matchesBSON(BSON(\"a\" << BSONNULL), NULL));\n    ASSERT(!in.matchesBSON(BSON(\"a\" << 4), NULL));\n    ASSERT(in.matchesBSON(BSON(\"b\" << 4), NULL));\n}", "target": 0}
{"code": "AutoFillManager::AutoFillManager(TabContents* tab_contents,\n                                 PersonalDataManager* personal_data)\n    : tab_contents_(tab_contents),\n      personal_data_(personal_data),\n      download_manager_(NULL) {\n  DCHECK(tab_contents);\n}", "target": 0}
{"code": "  Status SetUnknownShape(const NodeDef* node, int output_port) {\n    shape_inference::ShapeHandle shape =\n        GetUnknownOutputShape(node, output_port);\n    InferenceContext* ctx = GetContext(node);\n    if (ctx == nullptr) {\n      return errors::InvalidArgument(\"Missing context\");\n    }\n    ctx->set_output(output_port, shape);\n    return Status::OK();\n  }", "target": 1}
{"code": "TEST_F(AutoParallelTest, SimpleParallelNoDequeue) {\n  tensorflow::Scope s = tensorflow::Scope::DisabledShapeInferenceScope();\n  Output constant_a = ops::Const(s.WithOpName(\"constant_a\"), 1.0f, {1});\n  Output constant_c = ops::Const(s.WithOpName(\"constant_c\"), 1.0f, {1});\n  Output constant_b = ops::Const(s.WithOpName(\"constant_b\"), 1, {1});\n  Output var = ops::Variable(s.WithOpName(\"var\"), {1}, DT_FLOAT);\n  Output assign = ops::Assign(s.WithOpName(\"assign\"), {var}, {constant_a});\n  Output add = ops::AddN(s.WithOpName(\"add\"), {constant_a, constant_c});\n  Output learning_rate = ops::Const(s.WithOpName(\"learning_rate\"), 0.01f, {1});\n  Output apply_gradient = ops::ApplyGradientDescent(\n      s.WithOpName(\"apply_gradient\"), {var}, {learning_rate}, {add});\n  GrapplerItem item;\n  item.init_ops.push_back(\"assign\");\n  item.fetch.push_back(\"apply_gradient\");\n  item.init_ops.push_back(\"assign\");\n  TF_CHECK_OK(s.ToGraphDef(&item.graph));\n  AutoParallel parallel(2);\n  GraphDef output;\n  Status status = parallel.Optimize(nullptr, item, &output);\n  TF_EXPECT_OK(status);\n}", "target": 0}
{"code": "REDIS_STATIC int _quicklistNodeAllowInsert(const quicklistNode *node,\n                                           const int fill, const size_t sz) {\n    if (unlikely(!node))\n        return 0;\n    int ziplist_overhead;\n    if (sz < 254)\n        ziplist_overhead = 1;\n    else\n        ziplist_overhead = 5;\n    if (sz < 64)\n        ziplist_overhead += 1;\n    else if (likely(sz < 16384))\n        ziplist_overhead += 2;\n    else\n        ziplist_overhead += 5;\n    unsigned int new_sz = node->sz + sz + ziplist_overhead;\n    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(new_sz, fill)))\n        return 1;\n    else if (!sizeMeetsSafetyLimit(new_sz))\n        return 0;\n    else if ((int)node->count < fill)\n        return 1;\n    else\n        return 0;\n}", "target": 0}
{"code": "name_parse(u8 *packet, int length, int *idx, char *name_out, int name_out_len) {\n\tint name_end = -1;\n\tint j = *idx;\n\tint ptr_count = 0;\n#define GET32(x) do { if (j + 4 > length) goto err; memcpy(&t32_, packet + j, 4); j += 4; x = ntohl(t32_); } while (0)\n#define GET16(x) do { if (j + 2 > length) goto err; memcpy(&t_, packet + j, 2); j += 2; x = ntohs(t_); } while (0)\n#define GET8(x) do { if (j >= length) goto err; x = packet[j++]; } while (0)\n\tchar *cp = name_out;\n\tconst char *const end = name_out + name_out_len;\n\tfor (;;) {\n\t\tu8 label_len;\n\t\tif (j >= length) return -1;\n\t\tGET8(label_len);\n\t\tif (!label_len) break;\n\t\tif (label_len & 0xc0) {\n\t\t\tu8 ptr_low;\n\t\t\tGET8(ptr_low);\n\t\t\tif (name_end < 0) name_end = j;\n\t\t\tj = (((int)label_len & 0x3f) << 8) + ptr_low;\n\t\t\tif (j < 0 || j >= length) return -1;\n\t\t\tif (++ptr_count > length) return -1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (label_len > 63) return -1;\n\t\tif (cp != name_out) {\n\t\t\tif (cp + 1 >= end) return -1;\n\t\t\t*cp++ = '.';\n\t\t}\n\t\tif (cp + label_len >= end) return -1;\n\t\tmemcpy(cp, packet + j, label_len);\n\t\tcp += label_len;\n\t\tj += label_len;\n\t}\n\tif (cp >= end) return -1;\n\t*cp = '\\0';\n\tif (name_end < 0)\n\t\t*idx = j;\n\telse\n\t\t*idx = name_end;\n\treturn 0;\n err:\n\treturn -1;\n}", "target": 1}
{"code": "static inline struct f2fs_sb_info *F2FS_P_SB(struct page *page)\n{\n\treturn F2FS_M_SB(page->mapping);\n}", "target": 1}
{"code": "void LibRaw::android_tight_load_raw()\n{\n  uchar *data, *dp;\n  int bwide, row, col, c;\n  bwide = -(-5 * raw_width >> 5) << 3;\n  data = (uchar *)malloc(bwide);\n  merror(data, \"android_tight_load_raw()\");\n  for (row = 0; row < raw_height; row++)\n  {\n    if (fread(data, 1, bwide, ifp) < bwide)\n      derror();\n    for (dp = data, col = 0; col < raw_width; dp += 5, col += 4)\n      FORC4 RAW(row, col + c) = (dp[c] << 2) | (dp[4] >> (c << 1) & 3);\n  }\n  free(data);\n}", "target": 0}
{"code": "AUpvlist _af_pv_pointer (void *val)\n{\n\tAUpvlist\tret = AUpvnew(1);\n\tAUpvsetparam(ret, 0, 0);\n\tAUpvsetvaltype(ret, 0, AU_PVTYPE_PTR);\n\tAUpvsetval(ret, 0, &val);\n\treturn ret;\n}", "target": 0}
{"code": "static int iov_fault_in_pages_write(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tif (fault_in_pages_writeable(iov->iov_base, this_len))\n\t\t\tbreak;\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n\treturn len;\n}", "target": 1}
{"code": "archive_string_append_from_wcs(struct archive_string *as,\n    const wchar_t *w, size_t len)\n{\n\tint n, ret_val = 0;\n\tchar *p;\n\tchar *end;\n#if HAVE_WCRTOMB\n\tmbstate_t shift_state;\n\tmemset(&shift_state, 0, sizeof(shift_state));\n#else\n\twctomb(NULL, L'\\0');\n#endif\n\tif (archive_string_ensure(as, as->length + len + 1) == NULL)\n\t\treturn (-1);\n\tp = as->s + as->length;\n\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\twhile (*w != L'\\0' && len > 0) {\n\t\tif (p >= end) {\n\t\t\tas->length = p - as->s;\n\t\t\tas->s[as->length] = '\\0';\n\t\t\tif (archive_string_ensure(as,\n\t\t\t    as->length + len * 2 + 1) == NULL)\n\t\t\t\treturn (-1);\n\t\t\tp = as->s + as->length;\n\t\t\tend = as->s + as->buffer_length - MB_CUR_MAX -1;\n\t\t}\n#if HAVE_WCRTOMB\n\t\tn = wcrtomb(p, *w++, &shift_state);\n#else\n\t\tn = wctomb(p, *w++);\n#endif\n\t\tif (n == -1) {\n\t\t\tif (errno == EILSEQ) {\n\t\t\t\t*p++ = '?';\n\t\t\t\tret_val = -1;\n\t\t\t} else {\n\t\t\t\tret_val = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else\n\t\t\tp += n;\n\t\tlen--;\n\t}\n\tas->length = p - as->s;\n\tas->s[as->length] = '\\0';\n\treturn (ret_val);\n}", "target": 1}
{"code": "attr_unknown_count (void)\n{\n  return transit_hash->count;\n}", "target": 0}
{"code": "file_extension(const char *s)\t\n{\n  const char\t*extension;\t\n  static char\tbuf[1024];\t\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n    return (\"jpg\");\n  else if (!strncmp(s, \"data:image/png;\", 15))\n    return (\"png\");\n  else if ((extension = strrchr(s, '/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n  strlcpy(buf, extension, sizeof(buf));\n  *(char *)strchr(buf, '#') = '\\0';\n  return (buf);\n}", "target": 1}
{"code": "clamp_indexed(const fz_colorspace *cs, const float *in, float *out)\n{\n\tstruct indexed *idx = cs->data;\n\t*out = fz_clamp(*in, 0, idx->high) / 255.0f; \n}", "target": 0}
{"code": "static Jsi_RC DebugAddCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    if (!interp->breakpointHash)\n        interp->breakpointHash = Jsi_HashNew(interp, JSI_KEYS_STRING, jsi_HashFree);\n    int argc = Jsi_ValueGetLength(interp, args);\n    jsi_BreakPoint *bptr, bp = {};\n    Jsi_Number vnum;\n    if (argc>1 && Jsi_ValueGetBoolean(interp, Jsi_ValueArrayIndex(interp, args, 1), &bp.temp) != JSI_OK) \n        return Jsi_LogError(\"bad boolean\");\n    Jsi_Value *v = Jsi_ValueArrayIndex(interp, args, 0);\n    if (Jsi_ValueGetNumber(interp, v, &vnum) == JSI_OK) {\n        bp.line = (int)vnum;\n        bp.file = interp->curFile;\n    } else {\n        const char *val = Jsi_ValueArrayIndexToStr(interp, args, 0, NULL);\n        const char *cp;\n        if (isdigit(val[0])) {\n            if (Jsi_GetInt(interp, val, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            bp.file = interp->curFile;\n        } else if ((cp = Jsi_Strchr(val, ':'))) {\n            if (Jsi_GetInt(interp, cp+1, &bp.line, 0) != JSI_OK) \n                return Jsi_LogError(\"bad number\");\n            Jsi_DString dStr = {};\n            Jsi_DSAppendLen(&dStr, val, cp-val);\n            bp.file = Jsi_KeyAdd(interp, Jsi_DSValue(&dStr));\n            Jsi_DSFree(&dStr);\n        } else {\n            bp.func = Jsi_KeyAdd(interp, val);\n        }\n    }\n    if (bp.line<=0 && !bp.func) \n        return Jsi_LogError(\"bad number\");\n    char nbuf[100];\n    bp.id = ++interp->debugOpts.breakIdx;\n    bp.enabled = 1;\n    snprintf(nbuf, sizeof(nbuf), \"%d\", bp.id);\n    bptr = (jsi_BreakPoint*)Jsi_Malloc(sizeof(*bptr));\n    *bptr = bp;\n    Jsi_HashSet(interp->breakpointHash, (void*)nbuf, bptr);\n    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)bp.id);\n    return JSI_OK;\n}", "target": 1}
{"code": "service_info *FindServiceEventURLPath(\n\tservice_table *table, const char *eventURLPath)\n{\n\tservice_info *finger = NULL;\n\turi_type parsed_url;\n\turi_type parsed_url_in;\n\tif (table &&\n\t\tparse_uri(eventURLPath, strlen(eventURLPath), &parsed_url_in) ==\n\t\t\tHTTP_SUCCESS) {\n\t\tfinger = table->serviceList;\n\t\twhile (finger) {\n\t\t\tif (finger->eventURL) {\n\t\t\t\tif (parse_uri(finger->eventURL,\n\t\t\t\t\t    strlen(finger->eventURL),\n\t\t\t\t\t    &parsed_url) == HTTP_SUCCESS) {\n\t\t\t\t\tif (!token_cmp(&parsed_url.pathquery,\n\t\t\t\t\t\t    &parsed_url_in.pathquery)) {\n\t\t\t\t\t\treturn finger;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinger = finger->next;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "    **/\n    CImg<T>& log2() {\n      if (is_empty()) return *this;\n      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=4096))\n      cimg_rof(*this,ptrd,T) *ptrd = (T)cimg::log2((double)*ptrd);\n      return *this;", "target": 0}
{"code": "int r_bin_pdb_download(RCore *core, int isradjson, int *actions_done, SPDBOptions *options) {\n\tint ret;\n\tSPDBDownloaderOpt opt;\n\tSPDBDownloader pdb_downloader;\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\tif (!info || !info->debug_file_name) {\n\t\teprintf (\"Can't find debug filename\\n\");\n\t\treturn 1;\n\t}\n\tif (!is_valid_guid (info->guid)) {\n\t\teprintf (\"Invalid GUID for file\\n\");\n\t\treturn 1;\n\t}\n\tif (!options || !options->symbol_server || !options->user_agent) {\n\t\teprintf (\"Can't retrieve pdb configurations\\n\");\n\t\treturn 1;\n\t}\n\topt.dbg_file = (char*) r_file_basename (info->debug_file_name);\n\topt.guid = info->guid;\n\topt.symbol_server = options->symbol_server;\n\topt.user_agent = options->user_agent;\n\topt.symbol_store_path = options->symbol_store_path;\n\topt.extract = options->extract;\n\tinit_pdb_downloader (&opt, &pdb_downloader);\n\tret = pdb_downloader.download ? pdb_downloader.download (&pdb_downloader) : 0;\n\tif (isradjson && actions_done) {\n\t\tprintf (\"%s\\\"pdb\\\":{\\\"file\\\":\\\"%s\\\",\\\"download\\\":%s}\",\n\t\t        *actions_done ? \",\" : \"\", opt.dbg_file, ret ? \"true\" : \"false\");\n\t} else {\n\t\tprintf (\"PDB \\\"%s\\\" download %s\\n\",\n\t\t        opt.dbg_file, ret ? \"success\" : \"failed\");\n\t}\n\tif (actions_done) {\n\t\t(*actions_done)++;\n\t}\n\tdeinit_pdb_downloader (&pdb_downloader);\n\treturn 0;\n}", "target": 0}
{"code": "static inline void vm_entry_controls_init(struct vcpu_vmx *vmx, u32 val)\n{\n\tvmcs_write32(VM_ENTRY_CONTROLS, val);\n\tvmx->vm_entry_controls_shadow = val;\n}", "target": 0}
{"code": "static inline bool rt6_qualify_for_ecmp(struct rt6_info *rt)\n{\n\treturn (rt->rt6i_flags & (RTF_GATEWAY|RTF_ADDRCONF|RTF_DYNAMIC)) ==\n\t       RTF_GATEWAY;\n}", "target": 0}
{"code": "static int DefragBsdPeose173Ipv4Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv4TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv4TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 20, GET_PKT_LEN(r) - 20);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "char *suhosin_encrypt_single_cookie(char *name, int name_len, char *value, int value_len, char *key TSRMLS_DC)\n{\n\tchar buffer[4096];\n    char buffer2[4096];\n\tchar *buf = buffer, *buf2 = buffer2, *d, *d_url;\n    int l;\n\tif (name_len > sizeof(buffer)-2) {\n\t\tbuf = estrndup(name, name_len);\n\t} else {\n\t\tmemcpy(buf, name, name_len);\n\t\tbuf[name_len] = 0;\n\t}\n\tname_len = php_url_decode(buf, name_len);\n    normalize_varname(buf);\n    name_len = strlen(buf);\n\tif (SUHOSIN_G(cookie_plainlist)) {\n\t\tif (zend_hash_exists(SUHOSIN_G(cookie_plainlist), buf, name_len+1)) {\nencrypt_return_plain:\n\t\t\tif (buf != buffer) {\n\t\t\t\tefree(buf);\n\t\t\t}\n\t\t\treturn estrndup(value, value_len);\n\t\t}\n\t} else if (SUHOSIN_G(cookie_cryptlist)) {\n\t\tif (!zend_hash_exists(SUHOSIN_G(cookie_cryptlist), buf, name_len+1)) {\n\t\t\tgoto encrypt_return_plain;\n\t\t}\n\t}\n\tif (strlen(value) <= sizeof(buffer2)-2) {\n\t\tmemcpy(buf2, value, value_len);\n\t\tbuf2[value_len] = 0;\n\t} else {\n\t\tbuf2 = estrndup(value, value_len);\n\t}\n\tvalue_len = php_url_decode(buf2, value_len);\n\td = suhosin_encrypt_string(buf2, value_len, buf, name_len, key TSRMLS_CC);\n\td_url = php_url_encode(d, strlen(d), &l);\n\tefree(d);\n    if (buf != buffer) {\n\t\tefree(buf);\n\t}\n    if (buf2 != buffer2) {\n\t\tefree(buf2);\n\t}\n\treturn d_url;\n}", "target": 1}
{"code": "static UINT serial_process_irp_write(SERIAL_DEVICE* serial, IRP* irp)\n{\n\tUINT32 Length;\n\tUINT64 Offset;\n\tDWORD nbWritten = 0;\n\tif (Stream_GetRemainingLength(irp->input) < 32)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(irp->input, Length); \n\tStream_Read_UINT64(irp->input, Offset); \n\tStream_Seek(irp->input, 20);            \n\tWLog_Print(serial->log, WLOG_DEBUG, \"writing %\" PRIu32 \" bytes to %s\", Length,\n\t           serial->device.name);\n\tif (CommWriteFile(serial->hComm, Stream_Pointer(irp->input), Length, &nbWritten, NULL))\n\t{\n\t\tirp->IoStatus = STATUS_SUCCESS;\n\t}\n\telse\n\t{\n\t\tWLog_Print(serial->log, WLOG_DEBUG,\n\t\t           \"write failure to %s, nbWritten=%\" PRIu32 \", last-error: 0x%08\" PRIX32 \"\",\n\t\t           serial->device.name, nbWritten, GetLastError());\n\t\tirp->IoStatus = _GetLastErrorToIoStatus(serial);\n\t}\n\tWLog_Print(serial->log, WLOG_DEBUG, \"%\" PRIu32 \" bytes written to %s\", nbWritten,\n\t           serial->device.name);\n\tStream_Write_UINT32(irp->output, nbWritten); \n\tStream_Write_UINT8(irp->output, 0);          \n\treturn CHANNEL_RC_OK;\n}", "target": 1}
{"code": "static HTTPAPI_RESULT ConstructHeadersString(HTTP_HEADERS_HANDLE httpHeadersHandle, wchar_t** httpHeaders)\n{\n    HTTPAPI_RESULT result;\n    size_t headersCount;\n    if (HTTPHeaders_GetHeaderCount(httpHeadersHandle, &headersCount) != HTTP_HEADERS_OK)\n    {\n        result = HTTPAPI_ERROR;\n        LogError(\"HTTPHeaders_GetHeaderCount failed (result = %\" PRI_MU_ENUM \").\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else\n    {\n        size_t i;\n        size_t toAlloc = 0;\n        for (i = 0; i < headersCount; i++)\n        {\n            char *temp;\n            if (HTTPHeaders_GetHeader(httpHeadersHandle, i, &temp) == HTTP_HEADERS_OK)\n            {\n                toAlloc += strlen(temp);\n                toAlloc += 2;\n                free(temp);\n            }\n            else\n            {\n                LogError(\"HTTPHeaders_GetHeader failed\");\n                break;\n            }\n        }\n        if (i < headersCount)\n        {\n            result = HTTPAPI_ERROR;\n        }\n        else\n        {\n            char *httpHeadersA;\n            size_t requiredCharactersForHeaders;\n            if ((httpHeadersA = ConcatHttpHeaders(httpHeadersHandle, toAlloc, headersCount)) == NULL)\n            {\n                result = HTTPAPI_ERROR;\n                LogError(\"Cannot concatenate headers\");\n            }\n            else if ((requiredCharactersForHeaders = MultiByteToWideChar(CP_ACP, 0, httpHeadersA, -1, NULL, 0)) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x (result = %\" PRI_MU_ENUM \")\", GetLastError(), MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n            }\n            else if ((*httpHeaders = (wchar_t*)malloc((requiredCharactersForHeaders + 1) * sizeof(wchar_t))) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"Cannot allocate memory (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n            }\n            else if (MultiByteToWideChar(CP_ACP, 0, httpHeadersA, -1, *httpHeaders, (int)requiredCharactersForHeaders) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"MultiByteToWideChar failed, GetLastError=0x%08x (result = %\" PRI_MU_ENUM \")\", GetLastError(), MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n                free(*httpHeaders);\n                *httpHeaders = NULL;\n            }\n            else\n            {\n                result = HTTPAPI_OK;\n            }\n            free(httpHeadersA);\n        }\n    }\n    return result;\n}", "target": 1}
{"code": "void MainWindow::showUpgradePrompt()\n{\n    if (Settings.checkUpgradeAutomatic()) {\n        showStatusMessage(\"Checking for upgrade...\");\n        QNetworkRequest request(QUrl(\"https:\n        QSslConfiguration sslConfig = request.sslConfiguration();\n        sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);\n        request.setSslConfiguration(sslConfig);\n        m_network.get(request);\n    } else {\n        m_network.setStrictTransportSecurityEnabled(false);\n        QAction* action = new QAction(tr(\"Click here to check for a new version of Shotcut.\"), 0);\n        connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered()));\n        showStatusMessage(action, 15 );\n    }\n}", "target": 1}
{"code": "static void drive_file_fix_path(WCHAR* path)\n{\n\tsize_t i;\n\tsize_t length = _wcslen(path);\n\tfor (i = 0; i < length; i++)\n\t{\n\t\tif (path[i] == L'\\\\')\n\t\t\tpath[i] = L'/';\n\t}\n#ifdef WIN32\n\tif ((length == 3) && (path[1] == L':') && (path[2] == L'/'))\n\t\treturn;\n#else\n\tif ((length == 1) && (path[0] == L'/'))\n\t\treturn;\n#endif\n\tif ((length > 0) && (path[length - 1] == L'/'))\n\t\tpath[length - 1] = L'\\0';\n}", "target": 1}
{"code": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev,\n\t\tRBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tfor (i = 0; i < abbrev->count - 1; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\tbuf = parse_attr_value (buf, buf_end - buf, &abbrev->defs[i],\n\t\t\t&die->attr_values[i], hdr, debug_str, debug_str_len);\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\t\tbool is_valid_string_form = (attribute->attr_form == DW_FORM_strp ||\n\t\t\tattribute->attr_form == DW_FORM_string) &&\n\t\t\tattribute->string.content;\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}", "target": 1}
{"code": "static int __init ipip_init(void)\n{\n\tint err;\n\tprintk(banner);\n\tif (xfrm4_tunnel_register(&ipip_handler, AF_INET)) {\n\t\tprintk(KERN_INFO \"ipip init: can't register tunnel\\n\");\n\t\treturn -EAGAIN;\n\t}\n\terr = register_pernet_device(&ipip_net_ops);\n\tif (err)\n\t\txfrm4_tunnel_deregister(&ipip_handler, AF_INET);\n\treturn err;\n}", "target": 1}
{"code": "void crypto_bignum_free(struct bignum *s)\n{\n\tmbedtls_mpi_free((mbedtls_mpi *)s);\n\tfree(s);\n}", "target": 1}
{"code": "void SMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n    zis.setUnderlying(is, len - 4);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n    zis.removeUnderlying();\n    handler->handleClipboardProvide(flags, lengths, buffers);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}", "target": 1}
{"code": "static void regulator_ena_gpio_free(struct regulator_dev *rdev)\n{\n\tstruct regulator_enable_gpio *pin, *n;\n\tif (!rdev->ena_pin)\n\t\treturn;\n\tlist_for_each_entry_safe(pin, n, &regulator_ena_gpio_list, list) {\n\t\tif (pin->gpiod == rdev->ena_pin->gpiod) {\n\t\t\tif (pin->request_count <= 1) {\n\t\t\t\tpin->request_count = 0;\n\t\t\t\tgpiod_put(pin->gpiod);\n\t\t\t\tlist_del(&pin->list);\n\t\t\t\tkfree(pin);\n\t\t\t\trdev->ena_pin = NULL;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tpin->request_count--;\n\t\t\t}\n\t\t}\n\t}\n}", "target": 0}
{"code": "is_query(const char *query)\n{\n\tconst char *query_list[] = {\"insert\", \"update\", \"delete\", \"replace\",\n\t\t\"alter\", \"load\", \"select\", \"do\", \"handler\", \"call\", \"execute\",\n\t\t\"begin\", NULL};\n\treturn is_query_from_list(query, query_list);\n}", "target": 0}
{"code": "CallResult<PseudoHandle<>> JSObject::getComputedWithReceiver_RJS(\n    Handle<JSObject> selfHandle,\n    Runtime *runtime,\n    Handle<> nameValHandle,\n    Handle<> receiver) {\n  if (selfHandle->flags_.fastIndexProperties) {\n    if (auto arrayIndex = toArrayIndexFastPath(*nameValHandle)) {\n      PseudoHandle<> ourValue = createPseudoHandle(\n          getOwnIndexed(selfHandle.get(), runtime, *arrayIndex));\n      if (LLVM_LIKELY(!ourValue->isEmpty()))\n        return ourValue;\n    }\n  }\n  auto converted = toPropertyKeyIfObject(runtime, nameValHandle);\n  if (LLVM_UNLIKELY(converted == ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  auto nameValPrimitiveHandle = *converted;\n  ComputedPropertyDescriptor desc;\n  MutableHandle<JSObject> propObj{runtime};\n  if (LLVM_UNLIKELY(\n          getComputedPrimitiveDescriptor(\n              selfHandle, runtime, nameValPrimitiveHandle, propObj, desc) ==\n          ExecutionStatus::EXCEPTION)) {\n    return ExecutionStatus::EXCEPTION;\n  }\n  if (!propObj)\n    return createPseudoHandle(HermesValue::encodeUndefinedValue());\n  if (LLVM_LIKELY(\n          !desc.flags.accessor && !desc.flags.hostObject &&\n          !desc.flags.proxyObject))\n    return createPseudoHandle(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n  if (desc.flags.accessor) {\n    auto *accessor = vmcast<PropertyAccessor>(\n        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }\n}", "target": 1}
{"code": "\t~Chunk()\n\t{\n\t\tif (ownsMemory)\n\t\t\t::operator delete(buffer);\n\t\tbuffer = NULL;\n\t}", "target": 0}
{"code": "struct expr_parse_ctx *expr__ctx_new(void)\n{\n\tstruct expr_parse_ctx *ctx;\n\tctx = malloc(sizeof(struct expr_parse_ctx));\n\tif (!ctx)\n\t\treturn NULL;\n\tctx->ids = hashmap__new(key_hash, key_equal, NULL);\n\tif (IS_ERR(ctx->ids)) {\n\t\tfree(ctx);\n\t\treturn NULL;\n\t}\n\tctx->runtime = 0;\n\treturn ctx;\n}", "target": 0}
{"code": "      static double mp_g(_cimg_math_parser& mp) {\n        cimg::unused(mp);\n        return cimg::grand();", "target": 0}
{"code": "void CIRCNetwork::SetEncoding(const CString& s) {\n    m_sEncoding = s;\n    if (GetIRCSock()) {\n        GetIRCSock()->SetEncoding(s);\n    }\n}", "target": 1}
{"code": "deltas_head_values_set(struct deltas_head *deltas)\n{\n\treturn deltas->len == deltas->capacity;\n}", "target": 1}
{"code": "static void dnss_receive_udp_packet_handler(void *arg, struct udp_pcb *udp_pcb,\nstruct pbuf *udp_packet_buffer, struct ip_addr *sender_addr, uint16_t sender_port)\n{\n\tint ret=0;\n\tstruct dns_hdr *dns_rsp;\n\tdns_rsp = (struct dns_hdr*) udp_packet_buffer->payload;\n\tdns_rsp->flags1 |= 0x80; \n\tdns_rsp->flags2 = 0x05;  \n\tret = udp_sendto(udp_pcb, udp_packet_buffer, sender_addr, sender_port);\n\tudp_disconnect(udp_pcb);\n\tpbuf_free(udp_packet_buffer);\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *frame)\n{\n    AVFilterContext *ctx = inlink->dst;\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n    uint32_t plane_checksum[4] = {0}, checksum = 0;\n    int i, plane, vsub = desc->log2_chroma_h;\n    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {\n        int64_t linesize = av_image_get_linesize(frame->format, frame->width, plane);\n        uint8_t *data = frame->data[plane];\n        int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT(inlink->h, vsub) : inlink->h;\n        if (linesize < 0)\n            return linesize;\n        for (i = 0; i < h; i++) {\n            plane_checksum[plane] = av_adler32_update(plane_checksum[plane], data, linesize);\n            checksum = av_adler32_update(checksum, data, linesize);\n            data += frame->linesize[plane];\n        }\n    }\n    av_log(ctx, AV_LOG_INFO,\n           \"n:%\"PRId64\" pts:%s pts_time:%s pos:%\"PRId64\" \"\n           \"fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c \"\n           \"checksum:%08X plane_checksum:[%08X\",\n           inlink->frame_count,\n           av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base), av_frame_get_pkt_pos(frame),\n           desc->name,\n           frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den,\n           frame->width, frame->height,\n           !frame->interlaced_frame ? 'P' :         \n           frame->top_field_first   ? 'T' : 'B',    \n           frame->key_frame,\n           av_get_picture_type_char(frame->pict_type),\n           checksum, plane_checksum[0]);\n    for (plane = 1; plane < 4 && frame->data[plane]; plane++)\n        av_log(ctx, AV_LOG_INFO, \" %08X\", plane_checksum[plane]);\n    av_log(ctx, AV_LOG_INFO, \"]\\n\");\n    return ff_filter_frame(inlink->dst->outputs[0], frame);\n}", "target": 1}
{"code": "static int ssl_parse_server_psk_hint( mbedtls_ssl_context *ssl,\n                                      unsigned char **p,\n                                      unsigned char *end )\n{\n    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;\n    size_t  len;\n    ((void) ssl);\n    if( (*p) > end - 2 )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    len = (*p)[0] << 8 | (*p)[1];\n    *p += 2;\n    if( (*p) > end - len )\n    {\n        MBEDTLS_SSL_DEBUG_MSG( 1, ( \"bad server key exchange message \"\n                                    \"(psk_identity_hint length)\" ) );\n        return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );\n    }\n    *p += len;\n    ret = 0;\n    return( ret );\n}", "target": 0}
{"code": "GF_Err void_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tif (s->size) return GF_ISOM_INVALID_FILE;\n\treturn GF_OK;\n}", "target": 0}
{"code": "void SetLineWidth(double w) {\n    outpos +=\n    sprintf(outpos,\" %12.3f w\",w);\n}", "target": 1}
{"code": "TfLiteStatus CalculateOpData(TfLiteContext* context, TfLiteNode* node,\n                             TfLiteDepthwiseConvParams* params, int width,\n                             int height, int filter_width, int filter_height,\n                             const TfLiteType data_type, OpData* data) {\n  bool has_bias = node->inputs->size == 3;\n  TF_LITE_ENSURE(context, has_bias || node->inputs->size == 2);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size, 1);\n  int unused_output_height, unused_output_width;\n  data->padding = ComputePaddingHeightWidth(\n      params->stride_height, params->stride_width, 1, 1, height, width,\n      filter_height, filter_width, params->padding, &unused_output_height,\n      &unused_output_width);\n  if (data_type != kTfLiteFloat32) {\n    const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n    TF_LITE_ENSURE(context, input != nullptr);\n    const TfLiteTensor* filter = GetInput(context, node, kFilterTensor);\n    TF_LITE_ENSURE(context, filter != nullptr);\n    const TfLiteTensor* bias =\n        GetOptionalInputTensor(context, node, kBiasTensor);\n    TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n    TF_LITE_ENSURE(context, output != nullptr);\n    int num_channels = filter->dims->data[kDepthwiseConvQuantizedDimension];\n    return tflite::PopulateConvolutionQuantizationParams(\n        context, input, filter, bias, output, params->activation,\n        &data->output_multiplier, &data->output_shift,\n        &data->output_activation_min, &data->output_activation_max,\n        data->per_channel_output_multiplier,\n        reinterpret_cast<int*>(data->per_channel_output_shift), num_channels);\n  }\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static void GTextFieldSave(GTextField *gt,int utf8) {\n    unichar_t *ret;\n    char *cret;\n    FILE *file;\n    unichar_t *pt;\n    if ( _ggadget_use_gettext ) {\n\tchar *temp = GWidgetOpenFile8(_(\"Save\"),NULL,\"*.{txt,py}\",NULL,NULL);\n\tret = utf82u_copy(temp);\n\tfree(temp);\n    } else\n\tret = GWidgetSaveAsFile(GStringGetResource(_STR_Save,NULL),NULL,\n\t\ttxt,NULL,NULL);\n    if ( ret==NULL )\nreturn;\n    cret = u2def_copy(ret);\n    free(ret);\n    file = fopen(cret,\"w\");\n    if ( file==NULL ) {\n\tif ( _ggadget_use_gettext )\n\t    GWidgetError8(_(\"Could not open file\"), _(\"Could not open %.100s\"),cret);\n\telse\n\t    GWidgetError(errort,error,cret);\n\tfree(cret);\nreturn;\n    }\n    free(cret);\n    if ( utf8 ) {\n\tputc(0xef,file);\t\t\n\tputc(0xbb,file);\n\tputc(0xbf,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    if ( *pt<0x80 )\n\t\tputc(*pt,file);\n\t    else if ( *pt<0x800 ) {\n\t\tputc(0xc0 | (*pt>>6), file);\n\t\tputc(0x80 | (*pt&0x3f), file);\n\t    } else if ( *pt>=0xd800 && *pt<0xdc00 && pt[1]>=0xdc00 && pt[1]<0xe000 ) {\n\t\tint u = ((*pt>>6)&0xf)+1, y = ((*pt&3)<<4) | ((pt[1]>>6)&0xf);\n\t\tputc( 0xf0 | (u>>2),file );\n\t\tputc( 0x80 | ((u&3)<<4) | ((*pt>>2)&0xf),file );\n\t\tputc( 0x80 | y,file );\n\t\tputc( 0x80 | (pt[1]&0x3f),file );\n\t    } else {\n\t\tputc( 0xe0 | (*pt>>12),file );\n\t\tputc( 0x80 | ((*pt>>6)&0x3f),file );\n\t\tputc( 0x80 | (*pt&0x3f),file );\n\t    }\n\t}\n    } else {\n\tputc(0xfeff>>8,file);\t\t\n\tputc(0xfeff&0xff,file);\n\tfor ( pt = gt->text ; *pt; ++pt ) {\n\t    putc(*pt>>8,file);\n\t    putc(*pt&0xff,file);\n\t}\n    }\n    fclose(file);\n    GTextFieldSaved(gt);\n}", "target": 0}
{"code": "*/\nPHP_FUNCTION(date_timestamp_get)\n{\n\tzval         *object;\n\tphp_date_obj *dateobj;\n\tlong          timestamp;\n\tint           error;\n\tif (zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, getThis(), \"O\", &object, date_ce_interface) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tdateobj = (php_date_obj *) zend_object_store_get_object(object TSRMLS_CC);\n\tDATE_CHECK_INITIALIZED(dateobj->time, DateTime);\n\ttimelib_update_ts(dateobj->time, NULL);\n\ttimestamp = timelib_date_to_int(dateobj->time, &error);\n\tif (error) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETVAL_LONG(timestamp);\n\t}", "target": 0}
{"code": "    CImg<intT> get_select(CImgDisplay &disp,\n\t\t          const unsigned int feature_type=2, unsigned int *const XYZ=0,\n                          const bool exit_on_anykey=false) const {\n      return _select(disp,0,feature_type,XYZ,0,0,0,exit_on_anykey,true,false);", "target": 0}
{"code": "static u8 adpt_read_blink_led(adpt_hba* host)\n{\n\tif (host->FwDebugBLEDflag_P) {\n\t\tif( readb(host->FwDebugBLEDflag_P) == 0xbc ){\n\t\t\treturn readb(host->FwDebugBLEDvalue_P);\n\t\t}\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif ) \n{\n\tVipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );\n\tGifFileType *file = gif->file;\n\tColorMapObject *map = file->Image.ColorMap ?\n\t\tfile->Image.ColorMap : file->SColorMap;\n\tGifByteType *extension;\n\tif( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {\n\t\tvips_foreign_load_gif_error( gif ); \n\t\treturn( -1 );\n\t}\n\tif( file->Image.Left < 0 ||\n\t\tfile->Image.Width < 1 ||\n\t\tfile->Image.Width > 10000 ||\n\t\tfile->Image.Left + file->Image.Width > file->SWidth ||\n\t\tfile->Image.Top < 0 ||\n\t\tfile->Image.Height < 1 ||\n\t\tfile->Image.Height > 10000 ||\n\t\tfile->Image.Top + file->Image.Height > file->SHeight ) {\n\t\tvips_error( class->nickname, \"%s\", _( \"bad frame size\" ) ); \n\t\treturn( -1 ); \n\t}\n\tif( !gif->has_colour &&\n\t\tmap ) {\n\t\tint i;\n\t\tfor( i = 0; i < map->ColorCount; i++ ) \n\t\t\tif( map->Colors[i].Red != map->Colors[i].Green ||\n\t\t\t\tmap->Colors[i].Green != map->Colors[i].Blue ) {\n\t\t\t\tgif->has_colour = TRUE;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tdo {\n\t\tif( vips_foreign_load_gif_code_next( gif, &extension ) ) \n\t\t\treturn( -1 );\n\t} while( extension != NULL );\n\treturn( 0 );\n}", "target": 1}
{"code": "  virtual bool ms_verify_authorizer(Connection *con, int peer_type,\n\t\t\t\t    int protocol, bufferlist& authorizer,\n\t\t\t\t    bufferlist& authorizer_reply,\n\t\t\t\t    bool& isvalid, CryptoKey& session_key) {\n    isvalid = true;\n    return true;\n  };", "target": 1}
{"code": "static Jsi_RC jsi_ArrayForeachCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) \n{\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_Obj *obj;\n    int curlen;\n    uint i;\n    Jsi_Value *func, *vpargs;\n    func = Jsi_ValueArrayIndex(interp, args, 0);\n    if (!Jsi_ValueIsFunction(interp, func)) \n        return Jsi_LogError(\"expected function\");\n    Jsi_Value *sthis = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Value *nthis = NULL;\n    if (!sthis)\n        sthis = nthis = Jsi_ValueNew1(interp);\n    obj = _this->d.obj;\n    curlen = Jsi_ObjGetLength(interp, obj);    \n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    Jsi_RC rc = JSI_OK;\n    Jsi_Value *vobjs[3];\n    Jsi_Func *fptr = func->d.obj->d.fobj->func;\n    int maa = (fptr->argnames?fptr->argnames->argCnt:0);\n    if (maa>3)\n        maa = 3;\n    for (i = 0; i < obj->arrCnt && rc == JSI_OK; i++) {\n        if (!obj->arr[i]) continue;\n        vobjs[0] = obj->arr[i];\n        vobjs[1] = (maa>1?Jsi_ValueNewNumber(interp, i):NULL);\n        vobjs[2] = _this;\n        vpargs = Jsi_ValueMakeObject(interp, NULL, Jsi_ObjNewArray(interp, vobjs, maa, 0));\n        Jsi_IncrRefCount(interp, vpargs);\n        rc = Jsi_FunctionInvoke(interp, func, vpargs, ret, sthis);\n        Jsi_DecrRefCount(interp, vpargs);\n    }\n    if (nthis)\n        Jsi_DecrRefCount(interp, nthis);\n    return rc;\n}", "target": 1}
{"code": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor& sorted_inputs_t = ctx->input(0);\n    const Tensor& values_t = ctx->input(1);\n    OP_REQUIRES(\n        ctx, sorted_inputs_t.shape().dims() == 2,\n        errors::InvalidArgument(absl::StrCat(\n            \"Shape must be rank 2 but is rank \", sorted_inputs_t.shape().dims(),\n            \" for \"\n            \"`sorted_inputs` argument\")));\n    OP_REQUIRES(ctx, values_t.shape().dims() == 2,\n                errors::InvalidArgument(absl::StrCat(\n                    \"Shape must be rank 2 but is rank \",\n                    values_t.shape().dims(), \" for `values` argument\")));\n    OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0),\n                Status(error::INVALID_ARGUMENT,\n                       \"Leading dim_size of both tensors must match.\"));\n    OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(),\n                Status(error::INVALID_ARGUMENT,\n                       \"values tensor size must less than INT_MAX\"));\n    Tensor* output_t;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t));\n    if (output_t->dtype() == DT_INT32) {\n      OP_REQUIRES(ctx,\n                  FastBoundsCheck(sorted_inputs_t.dim_size(1),\n                                  std::numeric_limits<int>::max()),\n                  errors::InvalidArgument(\"trailing dim_size must less than \"\n                                          \"INT_MAX for int32 output type, was \",\n                                          sorted_inputs_t.dim_size(1)));\n    }\n    auto output = output_t->template flat<OutType>();\n    const auto sorted_inputs = sorted_inputs_t.template flat<T>();\n    const auto values = values_t.template flat<T>();\n    if (sorted_inputs.size() == 0) {\n      functor::SetZeroFunctor<Device, OutType> set_zero;\n      set_zero(ctx->eigen_device<Device>(), output);\n      return;\n    }\n    OP_REQUIRES_OK(\n        ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute(\n                 ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0),\n                 sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output));\n  }", "target": 0}
{"code": "gss_unwrap_iov (minor_status,\n                context_handle,\n                conf_state,\n                qop_state,\n                iov,\n                iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint *\t\t\tconf_state;\ngss_qop_t\t\t*qop_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    status = val_unwrap_iov_args(minor_status, context_handle,\n\t\t\t\t conf_state, qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (mech) {\n\tif (mech->gss_unwrap_iov) {\n\t    status = mech->gss_unwrap_iov(\n\t\t\t\t \t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  conf_state,\n\t\t\t\t\t  qop_state,\n\t\t\t\t\t  iov,\n\t\t\t\t\t  iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\treturn(status);\n    }\n    return (GSS_S_BAD_MECH);\n}", "target": 0}
{"code": "static void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n\t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if (data[0] == WHITEHEAT_GET_DTR_RTS) {\n\t\tmemcpy(command_info->result_buffer, &data[1],\n\t\t\t\t\t\turb->actual_length - 1);\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}", "target": 1}
{"code": "R_API ut8 *r_bin_java_get_attr_buf(RBinJavaObj *bin, ut64 sz, const ut64 offset, const ut8 *buf, const ut64 len) {\n\tut8 *attr_buf = NULL;\n\tint pending = len - offset;\n\tconst ut8 *a_buf = offset + buf;\n\tattr_buf = (ut8 *) calloc (pending + 1, 1);\n\tif (!attr_buf) {\n\t\teprintf (\"Unable to allocate enough bytes (0x%04\"PFMT64x\n\t\t\t\") to read in the attribute.\\n\", sz);\n\t\treturn attr_buf;\n\t}\n\tmemcpy (attr_buf, a_buf, pending); \n\treturn attr_buf;\n}", "target": 1}
{"code": "static struct btrfs_device *find_device(struct btrfs_fs_devices *fs_devices,\n\t\tu64 devid, const u8 *uuid)\n{\n\tstruct btrfs_device *dev;\n\tlist_for_each_entry(dev, &fs_devices->devices, dev_list) {\n\t\tif (dev->devid == devid &&\n\t\t    (!uuid || !memcmp(dev->uuid, uuid, BTRFS_UUID_SIZE))) {\n\t\t\treturn dev;\n\t\t}\n\t}\n\treturn NULL;\n}", "target": 1}
{"code": "double AccessibilityUIElement::maxValue()\n{\n    if (!m_element || !ATK_IS_OBJECT(m_element))\n        return 0.0f;\n    GValue value = G_VALUE_INIT;\n    atk_value_get_maximum_value(ATK_VALUE(m_element), &value);\n    if (!G_VALUE_HOLDS_FLOAT(&value))\n        return 0.0f;\n    return g_value_get_float(&value);\n}", "target": 0}
{"code": "TEST(UriSuite, TestIpSixOverread) {\n\t\tUriUriA uri;\n\t\tconst char * errorPos;\n\t\tchar uriText[2 + 3 + 2 + 1 + 1];\n\t\tstrncpy(uriText, \"\n\t\tEXPECT_EQ(uriParseSingleUriExA(&uri, uriText,\n\t\t\t\turiText + sizeof(uriText), &errorPos), URI_ERROR_SYNTAX);\n\t\tEXPECT_EQ(errorPos, uriText + sizeof(uriText));\n}", "target": 0}
{"code": "static void iov_fault_in_pages_read(struct iovec *iov, unsigned long len)\n{\n\twhile (!iov->iov_len)\n\t\tiov++;\n\twhile (len > 0) {\n\t\tunsigned long this_len;\n\t\tthis_len = min_t(unsigned long, len, iov->iov_len);\n\t\tfault_in_pages_readable(iov->iov_base, this_len);\n\t\tlen -= this_len;\n\t\tiov++;\n\t}\n}", "target": 1}
{"code": "TEST_IMPL(utf8_decode1_overrun) {\n  const char* p;\n  char b[1];\n  char c[1];\n  p = b;\n  b[0] = 0x7F;\n  ASSERT_EQ(0x7F, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  p = b;\n  b[0] = 0xC0;\n  ASSERT_EQ((unsigned) -1, uv__utf8_decode1(&p, b + 1));\n  ASSERT_PTR_EQ(p, b + 1);\n  b[0] = 0x7F;\n  ASSERT_EQ(UV_EINVAL, uv__idna_toascii(b, b + 1, c, c + 1));\n  return 0;\n}", "target": 0}
{"code": "static void on_page_prepare(GtkNotebook *assistant, GtkWidget *page, gpointer user_data)\n{\n    if (!is_processing_finished())\n    {\n        show_next_step_button();\n        clear_warnings();\n    }\n    gtk_widget_hide(g_btn_detail);\n    gtk_widget_hide(g_btn_onfail);\n    if (!g_expert_mode)\n        gtk_widget_hide(g_btn_repeat);\n    save_items_from_notepad();\n    save_text_from_text_view(g_tv_comment, FILENAME_COMMENT);\n    if (pages[PAGENO_SUMMARY].page_widget == page)\n    {\n        if (!g_expert_mode)\n        {\n            int n = select_next_page_no(pages[PAGENO_SUMMARY].page_no, NULL);\n            log_info(\"switching to page_no:%d\", n);\n            gtk_notebook_set_current_page(assistant, n);\n            return;\n        }\n    }\n    if (pages[PAGENO_EDIT_ELEMENTS].page_widget == page)\n    {\n        if (highlight_forbidden())\n        {\n            add_sensitive_data_warning();\n            show_warnings();\n            gtk_expander_set_expanded(g_exp_search, TRUE);\n        }\n        else\n            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(g_rb_custom_search), TRUE);\n        show_warnings();\n    }\n    if (pages[PAGENO_REVIEW_DATA].page_widget == page)\n    {\n        update_ls_details_checkboxes(g_event_selected);\n        gtk_widget_set_sensitive(g_btn_next, gtk_toggle_button_get_active(g_tb_approve_bt));\n    }\n    if (pages[PAGENO_EDIT_COMMENT].page_widget == page)\n    {\n        gtk_widget_show(g_btn_detail);\n        gtk_widget_set_sensitive(g_btn_next, false);\n        on_comment_changed(gtk_text_view_get_buffer(g_tv_comment), NULL);\n    }\n    if (pages[PAGENO_EVENT_PROGRESS].page_widget == page)\n    {\n        log_info(\"g_event_selected:'%s'\", g_event_selected);\n        if (g_event_selected\n         && g_event_selected[0]\n        ) {\n            clear_warnings();\n            start_event_run(g_event_selected);\n        }\n    }\n    if(pages[PAGENO_EVENT_SELECTOR].page_widget == page)\n    {\n        if (!g_expert_mode && !g_auto_event_list)\n            hide_next_step_button();\n    }\n}", "target": 1}
{"code": "static inline bool cpu_has_vmx_ept_mt_wb(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_WB_BIT;\n}", "target": 0}
{"code": "struct mosquitto *context__init(mosq_sock_t sock)\n{\n\tstruct mosquitto *context;\n\tchar address[1024];\n\tcontext = mosquitto__calloc(1, sizeof(struct mosquitto));\n\tif(!context) return NULL;\n#ifdef WITH_EPOLL\n\tcontext->ident = id_client;\n#else\n\tcontext->pollfd_index = -1;\n#endif\n\tmosquitto__set_state(context, mosq_cs_new);\n\tcontext->sock = sock;\n\tcontext->last_msg_in = db.now_s;\n\tcontext->next_msg_out = db.now_s + 60;\n\tcontext->keepalive = 60; \n\tcontext->clean_start = true;\n\tcontext->id = NULL;\n\tcontext->last_mid = 0;\n\tcontext->will = NULL;\n\tcontext->username = NULL;\n\tcontext->password = NULL;\n\tcontext->listener = NULL;\n\tcontext->acl_list = NULL;\n\tcontext->retain_available = true;\n\tcontext->is_bridge = false;\n\tcontext->in_packet.payload = NULL;\n\tpacket__cleanup(&context->in_packet);\n\tcontext->out_packet = NULL;\n\tcontext->current_out_packet = NULL;\n\tcontext->out_packet_count = 0;\n\tcontext->address = NULL;\n\tif((int)sock >= 0){\n\t\tif(!net__socket_get_address(sock, address, 1024, &context->remote_port)){\n\t\t\tcontext->address = mosquitto__strdup(address);\n\t\t}\n\t\tif(!context->address){\n\t\t\tmosquitto__free(context);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tcontext->bridge = NULL;\n\tcontext->msgs_in.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_out.inflight_maximum = db.config->max_inflight_messages;\n\tcontext->msgs_in.inflight_quota = db.config->max_inflight_messages;\n\tcontext->msgs_out.inflight_quota = db.config->max_inflight_messages;\n\tcontext->max_qos = 2;\n#ifdef WITH_TLS\n\tcontext->ssl = NULL;\n#endif\n\tif((int)context->sock >= 0){\n\t\tHASH_ADD(hh_sock, db.contexts_by_sock, sock, sizeof(context->sock), context);\n\t}\n\treturn context;\n}", "target": 1}
{"code": "int main()\n{\n\tgdImagePtr im;\n\tFILE *fp;\n\tchar path[1024];\n\tsprintf(path, \"%s/gd2/invalid_neg_size.gd2\", GDTEST_TOP_DIR);\n\tfp = fopen(path, \"rb\");\n\tif (!fp) {\n\t\tprintf(\"failed, cannot open file\\n\");\n\t\treturn 1;\n\t}\n\tim = gdImageCreateFromGd2(fp);\n\tfclose(fp);\n\treturn im == NULL ? 0 : 1;\n}", "target": 0}
{"code": "mm_make_entry(struct mm_master *mm, struct mmtree *head,\n    void *address, size_t size)\n{\n\tstruct mm_share *tmp, *tmp2;\n\tif (mm->mmalloc == NULL)\n\t\ttmp = xcalloc(1, sizeof(struct mm_share));\n\telse\n\t\ttmp = mm_xmalloc(mm->mmalloc, sizeof(struct mm_share));\n\ttmp->address = address;\n\ttmp->size = size;\n\ttmp2 = RB_INSERT(mmtree, head, tmp);\n\tif (tmp2 != NULL)\n\t\tfatal(\"mm_make_entry(%p): double address %p->%p(%zu)\",\n\t\t    mm, tmp2, address, size);\n\treturn (tmp);\n}", "target": 1}
{"code": "TEST(TensorSliceReaderTest, MissingTensorData) {\n  const string fname =\n      io::JoinPath(testing::TmpDir(), \"missing_data_checkpoint\");\n  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  TF_ASSERT_OK(writer.Add(\"test\", TensorShape({4, 5}),\n                          TensorSlice::ParseOrDie(\"0,2:-\"), data));\n  TF_ASSERT_OK(writer.Finish());\n  MutateSavedTensorSlices(fname, [&](SavedTensorSlices sts) {\n    if (sts.has_data()) {\n      Fill(data, 4, sts.mutable_data()->mutable_data());\n    }\n    return sts.SerializeAsString();\n  });\n  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n  TF_ASSERT_OK(reader.status());\n  EXPECT_TRUE(reader.HasTensor(\"test\", nullptr, nullptr));\n  std::unique_ptr<Tensor> tensor;\n  EXPECT_FALSE(reader.GetTensor(\"test\", &tensor).ok());\n}", "target": 0}
{"code": "void ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        LONG v;\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); \n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            while(m_Coder.Get(mset.X[i])) {\n              m <<= 1;\n              i++;\n            }\n            m >>= 1;\n            sz  = m;\n            while((m >>= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}", "target": 1}
{"code": "bool req_is_in_chain(struct smb_request *req)\n{\n\tif (req->vwv != (uint16_t *)(req->inbuf+smb_vwv)) {\n\t\treturn true;\n\t}\n\tif (!is_andx_req(req->cmd)) {\n\t\treturn false;\n\t}\n\tif (req->wct < 2) {\n\t\treturn false;\n\t}\n\treturn (CVAL(req->vwv+0, 0) != 0xFF);\n}", "target": 0}
{"code": "snmp_ber_decode_type(unsigned char *buff, uint32_t *buff_len, uint8_t *type)\n{\n  if(*buff_len == 0) {\n    return NULL;\n  }\n  *type = *buff++;\n  (*buff_len)--;\n  return buff;\n}", "target": 1}
{"code": "static void numtostr(js_State *J, const char *fmt, int w, double n)\n{\n\tchar buf[32], *e;\n\tsprintf(buf, fmt, w, n);\n\te = strchr(buf, 'e');\n\tif (e) {\n\t\tint exp = atoi(e+1);\n\t\tsprintf(e, \"e%+d\", exp);\n\t}\n\tjs_pushstring(J, buf);\n}", "target": 1}
{"code": "static inline void o2nm_lock_subsystem(void)\n{\n\tmutex_lock(&o2nm_cluster_group.cs_subsys.su_mutex);\n}", "target": 0}
{"code": "static int check_stack_boundary(struct bpf_verifier_env *env, int regno,\n\t\t\t\tint access_size, bool zero_size_allowed,\n\t\t\t\tstruct bpf_call_arg_meta *meta)\n{\n\tstruct bpf_verifier_state *state = env->cur_state;\n\tstruct bpf_reg_state *regs = state->regs;\n\tint off, i, slot, spi;\n\tif (regs[regno].type != PTR_TO_STACK) {\n\t\tif (zero_size_allowed && access_size == 0 &&\n\t\t    register_is_null(regs[regno]))\n\t\t\treturn 0;\n\t\tverbose(env, \"R%d type=%s expected=%s\\n\", regno,\n\t\t\treg_type_str[regs[regno].type],\n\t\t\treg_type_str[PTR_TO_STACK]);\n\t\treturn -EACCES;\n\t}\n\tif (!tnum_is_const(regs[regno].var_off)) {\n\t\tchar tn_buf[48];\n\t\ttnum_strn(tn_buf, sizeof(tn_buf), regs[regno].var_off);\n\t\tverbose(env, \"invalid variable stack read R%d var_off=%s\\n\",\n\t\t\tregno, tn_buf);\n\t\treturn -EACCES;\n\t}\n\toff = regs[regno].off + regs[regno].var_off.value;\n\tif (off >= 0 || off < -MAX_BPF_STACK || off + access_size > 0 ||\n\t    access_size < 0 || (access_size == 0 && !zero_size_allowed)) {\n\t\tverbose(env, \"invalid stack type R%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -EACCES;\n\t}\n\tif (env->prog->aux->stack_depth < -off)\n\t\tenv->prog->aux->stack_depth = -off;\n\tif (meta && meta->raw_mode) {\n\t\tmeta->access_size = access_size;\n\t\tmeta->regno = regno;\n\t\treturn 0;\n\t}\n\tfor (i = 0; i < access_size; i++) {\n\t\tslot = -(off + i) - 1;\n\t\tspi = slot / BPF_REG_SIZE;\n\t\tif (state->allocated_stack <= slot ||\n\t\t    state->stack[spi].slot_type[slot % BPF_REG_SIZE] !=\n\t\t\tSTACK_MISC) {\n\t\t\tverbose(env, \"invalid indirect read from stack off %d+%d size %d\\n\",\n\t\t\t\toff, i, access_size);\n\t\t\treturn -EACCES;\n\t\t}\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int init_die(RzBinDwarfDie *die, ut64 abbr_code, ut64 attr_count) {\n\tif (!die) {\n\t\treturn -1;\n\t}\n\tdie->attr_values = calloc(sizeof(RzBinDwarfAttrValue), attr_count);\n\tif (!die->attr_values) {\n\t\treturn -1;\n\t}\n\tdie->abbrev_code = abbr_code;\n\tdie->capacity = attr_count;\n\tdie->count = 0;\n\treturn 0;\n}", "target": 1}
{"code": "void RootWindow::OnWindowBoundsChanged(Window* window,\n                                       bool contained_mouse_point) {\n  if (contained_mouse_point ||\n      (window->IsVisible() &&\n       window->ContainsPointInRoot(last_mouse_location_))) {\n    PostMouseMoveEventAfterWindowChange();\n  }\n}", "target": 0}
{"code": "static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\twhile (i < len && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tptr->offset.len = n;\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\t\tptr->data = sec->payload_data + i;\n\t\tr_list_append (ret, ptr);\n\t\tr += 1;\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "static void\nyydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)\n{\n  YYUSE (yyvaluep);\n  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: \n#line 94 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1023 \"hex_grammar.c\" \n        break;\n    case 17: \n#line 95 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1029 \"hex_grammar.c\" \n        break;\n    case 18: \n#line 96 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1035 \"hex_grammar.c\" \n        break;\n    case 19: \n#line 97 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1041 \"hex_grammar.c\" \n        break;\n    case 21: \n#line 100 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1047 \"hex_grammar.c\" \n        break;\n    case 22: \n#line 99 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1053 \"hex_grammar.c\" \n        break;\n    case 23: \n#line 98 \"hex_grammar.y\" \n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1059 \"hex_grammar.c\" \n        break;\n      default:\n        break;\n    }", "target": 1}
{"code": "static void add_password(AUTH_HDR *request, unsigned char type, CONST char *password, char *secret)\n{\n\tMD5_CTX md5_secret, my_md5;\n\tunsigned char misc[AUTH_VECTOR_LEN];\n\tint i;\n\tint length = strlen(password);\n\tunsigned char hashed[256 + AUTH_PASS_LEN];\t\n\tunsigned char *vector;\n\tattribute_t *attr;\n\tif (length > MAXPASS) {\t\t\t\t\n\t\tlength = MAXPASS;\n\t}\n\tif (length == 0) {\n\t\tlength = AUTH_PASS_LEN;\t\t\t\n\t} if ((length & (AUTH_PASS_LEN - 1)) != 0) {\n\t\tlength += (AUTH_PASS_LEN - 1);\t\t\n\t\tlength &= ~(AUTH_PASS_LEN - 1);\t\t\n\t}\t\t\t\t\t\t\n\tmemset(hashed, 0, length);\n\tmemcpy(hashed, password, strlen(password));\n\tattr = find_attribute(request, PW_PASSWORD);\n\tif (type == PW_PASSWORD) {\n\t\tvector = request->vector;\n\t} else {\n\t\tvector = attr->data;\t\t\t\n\t}\n\tMD5Init(&md5_secret);\n\tMD5Update(&md5_secret, (unsigned char *) secret, strlen(secret));\n\tmy_md5 = md5_secret;\t\t\t\t\n\tMD5Update(&my_md5, vector, AUTH_VECTOR_LEN);\n\tMD5Final(misc, &my_md5);\t\t\t\n\txor(hashed, misc, AUTH_PASS_LEN);\n\tfor (i = 1; i < (length >> 4); i++) {\n\t\tmy_md5 = md5_secret;\t\t\t\n\t\tMD5Update(&my_md5, &hashed[(i-1) * AUTH_PASS_LEN], AUTH_PASS_LEN);\n\t\tMD5Final(misc, &my_md5);\t\t\t\n\t\txor(&hashed[i * AUTH_PASS_LEN], misc, AUTH_PASS_LEN);\n\t}\n\tif (type == PW_OLD_PASSWORD) {\n\t\tattr = find_attribute(request, PW_OLD_PASSWORD);\n\t}\n\tif (!attr) {\n\t\tadd_attribute(request, type, hashed, length);\n\t} else {\n\t\tmemcpy(attr->data, hashed, length); \n\t}\n}", "target": 1}
{"code": "STATIC struct pollfd *poll_set_add_fd(poll_set_t *poll_set, int fd) {\n    struct pollfd *free_slot = NULL;\n    if (poll_set->used == poll_set->max_used) {\n        if (poll_set->max_used >= poll_set->alloc) {\n            poll_set->pollfds = m_renew(struct pollfd, poll_set->pollfds, poll_set->alloc, poll_set->alloc + 4);\n            poll_set->alloc += 4;\n        }\n        free_slot = &poll_set->pollfds[poll_set->max_used++];\n    } else {\n        for (unsigned int i = 0; i < poll_set->max_used; ++i) {\n            struct pollfd *slot = &poll_set->pollfds[i];\n            if (slot->fd == -1) {\n                free_slot = slot;\n                break;\n            }\n        }\n        assert(free_slot != NULL);\n    }\n    free_slot->fd = fd;\n    ++poll_set->used;\n    return free_slot;\n}", "target": 1}
{"code": "  Status ArgSortByRows(OpKernelContext* context, const GPUDevice& device,\n                       Tindex N, int rank, Tindex dense_rows,\n                       typename TTypes<Tindex>::ConstMatrix indices,\n                       Tensor* input_index_map_t) {\n    DataType index_type = DataTypeToEnum<Tindex>::value;\n    Tensor row_indices_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(index_type, TensorShape({N}), &row_indices_t));\n    auto row_indices = row_indices_t.flat<Tindex>();\n    TF_RETURN_IF_ERROR(wrap_kernel_call(CopyRowIndicesKernel<Tindex>,\n                                        device, N, rank,\n                                        indices, row_indices));\n    TF_RETURN_IF_ERROR(context->allocate_temp(index_type, TensorShape({N}),\n                                              input_index_map_t));\n    Tindex* input_index_map = input_index_map_t->flat<Tindex>().data();\n    return GpuRadixSort(context, N, row_indices.data(),\n                        static_cast<Tindex*>(nullptr),\n                        static_cast<Tindex*>(nullptr),\n                        input_index_map,\n                        Log2Ceiling64(dense_rows));\n  }", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TF_LITE_ENSURE(context, input1 != nullptr);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TF_LITE_ENSURE(context, input2 != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  auto* params = reinterpret_cast<TfLiteAddParams*>(node->builtin_data);\n  TF_LITE_ENSURE_STATUS(\n      CalculateOpData(context, params, input1, input2, output, data));\n  return kTfLiteOk;\n}", "target": 0}
{"code": "flush_buf_tls(tor_tls_t *tls, buf_t *buf, size_t flushlen,\n              size_t *buf_flushlen)\n{\n  int r;\n  size_t flushed = 0;\n  ssize_t sz;\n  tor_assert(buf_flushlen);\n  tor_assert(*buf_flushlen <= buf->datalen);\n  tor_assert(flushlen <= *buf_flushlen);\n  sz = (ssize_t) flushlen;\n  check_no_tls_errors();\n  check();\n  do {\n    size_t flushlen0;\n    if (buf->head) {\n      if ((ssize_t)buf->head->datalen >= sz)\n        flushlen0 = sz;\n      else\n        flushlen0 = buf->head->datalen;\n    } else {\n      flushlen0 = 0;\n    }\n    r = flush_chunk_tls(tls, buf, buf->head, flushlen0, buf_flushlen);\n    check();\n    if (r < 0)\n      return r;\n    flushed += r;\n    sz -= r;\n    if (r == 0) \n      break;\n  } while (sz > 0);\n  tor_assert(flushed < INT_MAX);\n  return (int)flushed;\n}", "target": 0}
{"code": "TEST_P(LocalJwksIntegrationTest, ConnectRequestWithRegExMatch) {\n  config_helper_.prependFilter(getAuthFilterConfig(ExampleConfigWithRegEx, true));\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  auto encoder_decoder = codec_client_->startRequest(Http::TestRequestHeaderMapImpl{\n      {\":method\", \"CONNECT\"},\n      {\":authority\", \"host.com:80\"},\n      {\"authorization\", \"Bearer \" + std::string(GoodToken)},\n  });\n  request_encoder_ = &encoder_decoder.first;\n  auto response = std::move(encoder_decoder.second);\n  if (downstreamProtocol() == Http::CodecType::HTTP1) {\n    ASSERT_TRUE(response->waitForEndStream());\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"404\", response->headers().getStatusValue());\n  } else {\n    ASSERT_TRUE(response->waitForReset());\n    ASSERT_TRUE(codec_client_->waitForDisconnect());\n  }\n}", "target": 0}
{"code": "int create_user_ns(struct cred *new)\n{\n\tstruct user_namespace *ns, *parent_ns = new->user_ns;\n\tkuid_t owner = new->euid;\n\tkgid_t group = new->egid;\n\tint ret;\n\tif (current_chrooted())\n\t\treturn -EPERM;\n\tif (!kuid_has_mapping(parent_ns, owner) ||\n\t    !kgid_has_mapping(parent_ns, group))\n\t\treturn -EPERM;\n\tns = kmem_cache_zalloc(user_ns_cachep, GFP_KERNEL);\n\tif (!ns)\n\t\treturn -ENOMEM;\n\tret = proc_alloc_inum(&ns->proc_inum);\n\tif (ret) {\n\t\tkmem_cache_free(user_ns_cachep, ns);\n\t\treturn ret;\n\t}\n\tatomic_set(&ns->count, 1);\n\tns->parent = parent_ns;\n\tns->owner = owner;\n\tns->group = group;\n\tset_cred_user_ns(new, ns);\n\treturn 0;\n}", "target": 0}
{"code": "int ossl_dsa_check_params(const DSA *dsa, int checktype, int *ret)\n{\n    if (!dsa_precheck_params(dsa, ret))\n        return 0;\n    if (checktype == OSSL_KEYMGMT_VALIDATE_QUICK_CHECK)\n        return ossl_ffc_params_simple_validate(dsa->libctx, &dsa->params,\n                                               FFC_PARAM_TYPE_DSA, ret);\n    else\n        return ossl_ffc_params_full_validate(dsa->libctx, &dsa->params,\n                                             FFC_PARAM_TYPE_DSA, ret);\n}", "target": 0}
{"code": "QList<QList<QByteArray>> CoreNetwork::splitMessage(const QString &cmd, const QString &message, std::function<QList<QByteArray>(QString &)> cmdGenerator)\n{\n    QString wrkMsg(message);\n    QList<QList<QByteArray>> msgsToSend;\n    do {\n        int splitPos = wrkMsg.size();\n        QList<QByteArray> initialSplitMsgEnc = cmdGenerator(wrkMsg);\n        int initialOverrun = userInputHandler()->lastParamOverrun(cmd, initialSplitMsgEnc);\n        if (initialOverrun) {\n            QString splitMsg(wrkMsg);\n            QTextBoundaryFinder qtbf(QTextBoundaryFinder::Word, splitMsg);\n            qtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n            QList<QByteArray> splitMsgEnc;\n            int overrun = initialOverrun;\n            while (overrun) {\n                splitPos = qtbf.toPreviousBoundary();\n                if (splitPos > 0) {\n                    splitMsg = splitMsg.left(splitPos);\n                    splitMsgEnc = cmdGenerator(splitMsg);\n                    overrun = userInputHandler()->lastParamOverrun(cmd, splitMsgEnc);\n                }\n                else {\n                    if (qtbf.type() == QTextBoundaryFinder::Word) {\n                        splitMsg = wrkMsg;\n                        splitPos = splitMsg.size();\n                        QTextBoundaryFinder graphemeQtbf(QTextBoundaryFinder::Grapheme, splitMsg);\n                        graphemeQtbf.setPosition(initialSplitMsgEnc[1].size() - initialOverrun);\n                        qtbf = graphemeQtbf;\n                    }\n                    else {\n                        qWarning() << \"Unexpected failure to split message!\";\n                        return msgsToSend;\n                    }\n                }\n            }\n            wrkMsg.remove(0, splitPos);\n            msgsToSend.append(splitMsgEnc);\n        }\n        else{\n            wrkMsg.remove(0, splitPos);\n            msgsToSend.append(initialSplitMsgEnc);\n        }\n    } while (wrkMsg.size() > 0);\n    return msgsToSend;\n}", "target": 0}
{"code": "static void timelib_eat_until_separator(char **ptr)\n{\n\twhile (strchr(\" \\t.,:;/-0123456789\", **ptr) == NULL) {\n\t\t++*ptr;\n\t}\n}", "target": 0}
{"code": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}", "target": 1}
{"code": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;\n    ret = ff_vp8_decode_frame(avctx, p, got_frame, &pkt);\n    if (ret < 0)\n        return ret;\n    update_canvas_size(avctx, avctx->width, avctx->height);\n    if (s->has_alpha) {\n        ret = vp8_lossy_decode_alpha(avctx, p, s->alpha_data,\n                                     s->alpha_data_size);\n        if (ret < 0)\n            return ret;\n    }\n    return ret;\n}", "target": 1}
{"code": "struct sctp_chunk *sctp_process_asconf(struct sctp_association *asoc,\n\t\t\t\t       struct sctp_chunk *asconf)\n{\n\tsctp_addiphdr_t\t\t*hdr;\n\tunion sctp_addr_param\t*addr_param;\n\tsctp_addip_param_t\t*asconf_param;\n\tstruct sctp_chunk\t*asconf_ack;\n\t__be16\terr_code;\n\tint\tlength = 0;\n\tint\tchunk_len;\n\t__u32\tserial;\n\tint\tall_param_pass = 1;\n\tchunk_len = ntohs(asconf->chunk_hdr->length) - sizeof(sctp_chunkhdr_t);\n\thdr = (sctp_addiphdr_t *)asconf->skb->data;\n\tserial = ntohl(hdr->serial);\n\tlength = sizeof(sctp_addiphdr_t);\n\taddr_param = (union sctp_addr_param *)(asconf->skb->data + length);\n\tchunk_len -= length;\n\tlength = ntohs(addr_param->p.length);\n\tasconf_param = (void *)addr_param + length;\n\tchunk_len -= length;\n\tasconf_ack = sctp_make_asconf_ack(asoc, serial, chunk_len * 4);\n\tif (!asconf_ack)\n\t\tgoto done;\n\twhile (chunk_len > 0) {\n\t\terr_code = sctp_process_asconf_param(asoc, asconf,\n\t\t\t\t\t\t     asconf_param);\n\t\tif (SCTP_ERROR_NO_ERROR != err_code)\n\t\t\tall_param_pass = 0;\n\t\tif (!all_param_pass)\n\t\t\tsctp_add_asconf_response(asconf_ack,\n\t\t\t\t\t\t asconf_param->crr_id, err_code,\n\t\t\t\t\t\t asconf_param);\n\t\tif (SCTP_ERROR_RSRC_LOW == err_code)\n\t\t\tgoto done;\n\t\tlength = ntohs(asconf_param->param_hdr.length);\n\t\tasconf_param = (void *)asconf_param + length;\n\t\tchunk_len -= length;\n\t}\ndone:\n\tasoc->peer.addip_serial++;\n\tif (asconf_ack) {\n\t\tsctp_chunk_hold(asconf_ack);\n\t\tlist_add_tail(&asconf_ack->transmitted_list,\n\t\t\t      &asoc->asconf_ack_list);\n\t}\n\treturn asconf_ack;\n}", "target": 1}
{"code": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}", "target": 1}
{"code": "snmp_engine_get_next(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i;\n  for(i = 0; i < varbinds_length; i++) {\n    resource = snmp_mib_find_next(varbinds[i].oid);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      resource->handler(&varbinds[i], resource->oid);\n    }\n  }\n  return 0;\n}", "target": 1}
{"code": "static BOOL ntlm_av_pair_check_data(const NTLM_AV_PAIR* pAvPair, size_t cbAvPair, size_t size)\n{\n\tsize_t offset;\n\tif (!pAvPair || cbAvPair < sizeof(NTLM_AV_PAIR) + size)\n\t\treturn FALSE;\n\tif (!ntlm_av_pair_get_next_offset(pAvPair, cbAvPair, &offset))\n\t\treturn FALSE;\n\treturn cbAvPair >= offset;\n}", "target": 0}
{"code": "static uint64_t generatePageID()\n{\n    static uint64_t uniquePageID = 1;\n    return uniquePageID++;\n}", "target": 0}
{"code": "static bool nvme_nsid_valid(NvmeCtrl *n, uint32_t nsid)\n{\n    return nsid &&\n        (nsid == NVME_NSID_BROADCAST || nsid <= NVME_MAX_NAMESPACES);\n}", "target": 0}
{"code": "struct ipv6_txoptions *ipv6_update_options(struct sock *sk,\n\t\t\t\t\t   struct ipv6_txoptions *opt)\n{\n\tif (inet_sk(sk)->is_icsk) {\n\t\tif (opt &&\n\t\t    !((1 << sk->sk_state) & (TCPF_LISTEN | TCPF_CLOSE)) &&\n\t\t    inet_sk(sk)->inet_daddr != LOOPBACK4_IPV6) {\n\t\t\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\t\t\ticsk->icsk_ext_hdr_len = opt->opt_flen + opt->opt_nflen;\n\t\t\ticsk->icsk_sync_mss(sk, icsk->icsk_pmtu_cookie);\n\t\t}\n\t}\n\topt = xchg(&inet6_sk(sk)->opt, opt);\n\tsk_dst_reset(sk);\n\treturn opt;\n}", "target": 1}
{"code": "mrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb_free(mrb, p);\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n  return p2;\n}", "target": 1}
{"code": "free_ice_connection_watch (GsmIceConnectionWatch *data)\n{\n        if (data->watch_id) {\n                g_source_remove (data->watch_id);\n                data->watch_id = 0;\n        }\n        if (data->protocol_timeout) {\n                g_source_remove (data->protocol_timeout);\n                data->protocol_timeout = 0;\n        }\n        g_free (data);\n}", "target": 0}
{"code": "static int nci_extract_activation_params_iso_dep(struct nci_dev *ndev,\n\t\t\tstruct nci_rf_intf_activated_ntf *ntf, __u8 *data)\n{\n\tstruct activation_params_nfca_poll_iso_dep *nfca_poll;\n\tstruct activation_params_nfcb_poll_iso_dep *nfcb_poll;\n\tswitch (ntf->activation_rf_tech_and_mode) {\n\tcase NCI_NFC_A_PASSIVE_POLL_MODE:\n\t\tnfca_poll = &ntf->activation_params.nfca_poll_iso_dep;\n\t\tnfca_poll->rats_res_len = *data++;\n\t\tpr_debug(\"rats_res_len %d\\n\", nfca_poll->rats_res_len);\n\t\tif (nfca_poll->rats_res_len > 0) {\n\t\t\tmemcpy(nfca_poll->rats_res,\n\t\t\t       data, nfca_poll->rats_res_len);\n\t\t}\n\t\tbreak;\n\tcase NCI_NFC_B_PASSIVE_POLL_MODE:\n\t\tnfcb_poll = &ntf->activation_params.nfcb_poll_iso_dep;\n\t\tnfcb_poll->attrib_res_len = *data++;\n\t\tpr_debug(\"attrib_res_len %d\\n\", nfcb_poll->attrib_res_len);\n\t\tif (nfcb_poll->attrib_res_len > 0) {\n\t\t\tmemcpy(nfcb_poll->attrib_res,\n\t\t\t       data, nfcb_poll->attrib_res_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unsupported activation_rf_tech_and_mode 0x%x\\n\",\n\t\t       ntf->activation_rf_tech_and_mode);\n\t\treturn NCI_STATUS_RF_PROTOCOL_ERROR;\n\t}\n\treturn NCI_STATUS_OK;\n}", "target": 1}
{"code": "IW_IMPL(unsigned int) iw_get_ui32be(const iw_byte *b)\n{\n\treturn (b[0]<<24) | (b[1]<<16) | (b[2]<<8) | b[3];\n}", "target": 1}
{"code": "void posixtimer_rearm(struct siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\tif (timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1;\n\t\t++timr->it_requeue_pending;\n\t\tinfo->si_overrun += timr->it_overrun_last;\n\t}\n\tunlock_timer(timr, flags);\n}", "target": 1}
{"code": "void MainWindow::on_actionUpgrade_triggered()\n{\n    if (Settings.askUpgradeAutmatic()) {\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"Do you want to automatically check for updates in the future?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"http:\n}", "target": 1}
{"code": "static void xen_irq_init(unsigned irq)\n{\n\tstruct irq_info *info;\n#ifdef CONFIG_SMP\n\tcpumask_copy(irq_get_affinity_mask(irq), cpumask_of(0));\n#endif\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (info == NULL)\n\t\tpanic(\"Unable to allocate metadata for IRQ%d\\n\", irq);\n\tinfo->type = IRQT_UNBOUND;\n\tinfo->refcnt = -1;\n\tset_info_for_irq(irq, info);\n\tINIT_LIST_HEAD(&info->eoi_list);\n\tlist_add_tail(&info->list, &xen_irq_list_head);\n}", "target": 0}
{"code": "bool DNP3_Base::AddToBuffer(Endpoint* endp, int target_len, const u_char** data, int* len)\n\t{\n\tif ( ! target_len )\n\t\treturn true;\n\tint to_copy = min(*len, target_len - endp->buffer_len);\n\tmemcpy(endp->buffer + endp->buffer_len, *data, to_copy);\n\t*data += to_copy;\n\t*len -= to_copy;\n\tendp->buffer_len += to_copy;\n\treturn endp->buffer_len == target_len;\n\t}", "target": 1}
{"code": "ip_optprint(netdissect_options *ndo,\n            register const u_char *cp, u_int length)\n{\n\tregister u_int option_len;\n\tconst char *sep = \"\";\n\tfor (; length > 0; cp += option_len, length -= option_len) {\n\t\tu_int option_code;\n\t\tND_PRINT((ndo, \"%s\", sep));\n\t\tsep = \",\";\n\t\tND_TCHECK(*cp);\n\t\toption_code = *cp;\n\t\tND_PRINT((ndo, \"%s\",\n\t\t          tok2str(ip_option_values,\"unknown %u\",option_code)));\n\t\tif (option_code == IPOPT_NOP ||\n                    option_code == IPOPT_EOL)\n\t\t\toption_len = 1;\n\t\telse {\n\t\t\tND_TCHECK(cp[1]);\n\t\t\toption_len = cp[1];\n\t\t\tif (option_len < 2) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (option_len > length) {\n\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\treturn;\n\t\t}\n\t\tND_TCHECK2(*cp, option_len);\n\t\tswitch (option_code) {\n\t\tcase IPOPT_EOL:\n\t\t\treturn;\n\t\tcase IPOPT_TS:\n\t\t\tif (ip_printts(ndo, cp, option_len) == -1)\n\t\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\tcase IPOPT_RR:       \n\t\tcase IPOPT_SSRR:\n\t\tcase IPOPT_LSRR:\n\t\t\tif (ip_printroute(ndo, cp, option_len) == -1)\n\t\t\t\tgoto trunc;\n\t\t\tbreak;\n\t\tcase IPOPT_RA:\n\t\t\tif (option_len < 4) {\n\t\t\t\tND_PRINT((ndo, \" [bad length %u]\", option_len));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tND_TCHECK(cp[3]);\n\t\t\tif (EXTRACT_16BITS(&cp[2]) != 0)\n\t\t\t\tND_PRINT((ndo, \" value %u\", EXTRACT_16BITS(&cp[2])));\n\t\t\tbreak;\n\t\tcase IPOPT_NOP:       \n\t\tcase IPOPT_SECURITY:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}", "target": 0}
{"code": "void InlineTextBox::paintCompositionUnderline(GraphicsContext* ctx, int tx, int ty, const CompositionUnderline& underline)\n{\n    tx += m_x;\n    ty += m_y;\n    if (m_truncation == cFullTruncation)\n        return;\n    int start = 0;                 \n    int width = m_logicalWidth;           \n    bool useWholeWidth = true;\n    unsigned paintStart = m_start;\n    unsigned paintEnd = end() + 1; \n    if (paintStart <= underline.startOffset) {\n        paintStart = underline.startOffset;\n        useWholeWidth = false;\n        start = toRenderText(renderer())->width(m_start, paintStart - m_start, textPos(), m_firstLine);\n    }\n    if (paintEnd != underline.endOffset) {      \n        paintEnd = min(paintEnd, (unsigned)underline.endOffset);\n        useWholeWidth = false;\n    }\n    if (m_truncation != cNoTruncation) {\n        paintEnd = min(paintEnd, (unsigned)m_start + m_truncation);\n        useWholeWidth = false;\n    }\n    if (!useWholeWidth) {\n        width = toRenderText(renderer())->width(paintStart, paintEnd - paintStart, textPos() + start, m_firstLine);\n    }\n    int lineThickness = 1;\n    int baseline = renderer()->style(m_firstLine)->font().ascent();\n    if (underline.thick && logicalHeight() - baseline >= 2)\n        lineThickness = 2;\n    start += 1;\n    width -= 2;\n    ctx->setStrokeColor(underline.color, renderer()->style()->colorSpace());\n    ctx->setStrokeThickness(lineThickness);\n    ctx->drawLineForText(IntPoint(tx + start, ty + logicalHeight() - lineThickness), width, textRenderer()->document()->printing());\n}", "target": 0}
{"code": "TEST_F(ExtractorTest, TestPrefixHeaderMatch) {\n  auto headers = TestRequestHeaderMapImpl{{\"prefix-header\", \"AAABBBjwt_token\"}};\n  auto tokens = extractor_->extract(headers);\n  EXPECT_EQ(tokens.size(), 2);\n  EXPECT_TRUE(tokens[0]->isIssuerSpecified(\"issuer5\"));\n  EXPECT_EQ(tokens[0]->token(), \"BBBjwt_token\");\n  EXPECT_TRUE(tokens[1]->isIssuerSpecified(\"issuer6\"));\n  EXPECT_EQ(tokens[1]->token(), \"jwt_token\");\n  tokens[0]->removeJwt(headers);\n  EXPECT_FALSE(headers.get(Http::LowerCaseString(\"prefix-header\")));\n}", "target": 0}
{"code": "bool ServerSecurityFeature::foxxAllowInstallFromRemote() const {\n  return _foxxAllowInstallFromRemote;\n}", "target": 0}
{"code": "static bool range_within(struct bpf_reg_state *old,\n\t\t\t struct bpf_reg_state *cur)\n{\n\treturn old->umin_value <= cur->umin_value &&\n\t       old->umax_value >= cur->umax_value &&\n\t       old->smin_value <= cur->smin_value &&\n\t       old->smax_value >= cur->smax_value;\n}", "target": 0}
{"code": "  QUInt8() {}", "target": 1}
{"code": "infra_wait_limit_netblock_insert(struct infra_cache* infra,\n\tstruct config_file* cfg)\n{\n\tstruct config_str2list* p;\n\tstruct wait_limit_netblock_info* d;\n\tfor(p = cfg->wait_limit_netblock; p; p = p->next) {\n\t\td = wait_limit_netblock_findcreate(infra, p->str, 0);\n\t\tif(!d)\n\t\t\treturn 0;\n\t\td->limit = atoi(p->str2);\n\t}\n\tfor(p = cfg->wait_limit_cookie_netblock; p; p = p->next) {\n\t\td = wait_limit_netblock_findcreate(infra, p->str, 1);\n\t\tif(!d)\n\t\t\treturn 0;\n\t\td->limit = atoi(p->str2);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "nfs_printfh(netdissect_options *ndo,\n            register const uint32_t *dp, const u_int len)\n{\n\tmy_fsid fsid;\n\tuint32_t ino;\n\tconst char *sfsname = NULL;\n\tchar *spacep;\n\tif (ndo->ndo_uflag) {\n\t\tu_int i;\n\t\tchar const *sep = \"\";\n\t\tND_PRINT((ndo, \" fh[\"));\n\t\tfor (i=0; i<len; i++) {\n\t\t\tND_PRINT((ndo, \"%s%x\", sep, dp[i]));\n\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\tif (sfsname) {\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}\n\tif(fsid.Fsid_dev.Minor == 257)\n\t\tND_PRINT((ndo, \"%s\", fsid.Opaque_Handle));\n\telse\n\t\tND_PRINT((ndo, \"%ld\", (long) ino));\n}", "target": 1}
{"code": "pci_lintr_deassert(struct pci_vdev *dev)\n{\n\tassert(dev->lintr.pin > 0);\n\tpthread_mutex_lock(&dev->lintr.lock);\n\tif (dev->lintr.state == ASSERTED) {\n\t\tdev->lintr.state = IDLE;\n\t\tpci_irq_deassert(dev);\n\t} else if (dev->lintr.state == PENDING)\n\t\tdev->lintr.state = IDLE;\n\tpthread_mutex_unlock(&dev->lintr.lock);\n}", "target": 1}
{"code": "static unsigned short get_tga_ushort(const unsigned char *data)\n{\n    return data[0] | (data[1] << 8);\n}", "target": 0}
{"code": "deallocateCharacterClasses ()\n{\n  while (characterClasses)\n    {\n      struct CharacterClass *class = characterClasses;\n      characterClasses = characterClasses->next;\n      if (class)\n\tfree (class);\n    }\n}", "target": 0}
{"code": "static bool IsAudible(const AudioBus* rendered_data) {\n  float energy = 0;\n  uint32_t data_size = rendered_data->length();\n  for (uint32_t k = 0; k < rendered_data->NumberOfChannels(); ++k) {\n    const float* data = rendered_data->Channel(k)->Data();\n    float channel_energy;\n    vector_math::Vsvesq(data, 1, &channel_energy, data_size);\n    energy += channel_energy;\n  }\n  return energy > 0;\n}", "target": 0}
{"code": "lsquic_qeh_settings (struct qpack_enc_hdl *qeh, unsigned max_table_size,\n             unsigned dyn_table_size, unsigned max_risked_streams, int server)\n{\n    enum lsqpack_enc_opts enc_opts;\n    assert(qeh->qeh_flags & QEH_INITIALIZED);\n    if (qeh->qeh_flags & QEH_HAVE_SETTINGS)\n    {\n        LSQ_WARN(\"settings already set\");\n        return -1;\n    }\n    enc_opts = LSQPACK_ENC_OPT_STAGE_2\n             | (server ? LSQPACK_ENC_OPT_SERVER : 0);\n    qeh->qeh_tsu_sz = sizeof(qeh->qeh_tsu_buf);\n    if (QENC_MIN_DYN_TABLE_SIZE > dyn_table_size)\n        dyn_table_size = 0;\n    if (0 != lsqpack_enc_init(&qeh->qeh_encoder, (void *) qeh->qeh_conn,\n                max_table_size, dyn_table_size, max_risked_streams, enc_opts,\n                qeh->qeh_tsu_buf, &qeh->qeh_tsu_sz))\n    {\n        LSQ_INFO(\"could not initialize QPACK encoder\");\n        return -1;\n    }\n    LSQ_DEBUG(\"%zu-byte post-init TSU\", qeh->qeh_tsu_sz);\n    qeh->qeh_flags |= QEH_HAVE_SETTINGS;\n    qeh->qeh_max_prefix_size =\n                        lsqpack_enc_header_block_prefix_size(&qeh->qeh_encoder);\n    LSQ_DEBUG(\"have settings: max table size=%u; dyn table size=%u; max risked \"\n        \"streams=%u\", max_table_size, dyn_table_size, max_risked_streams);\n    if (qeh->qeh_enc_sm_out)\n        qeh_begin_out(qeh);\n    return 0;\n}", "target": 0}
{"code": "ProcCloseFont(ClientPtr client)\n{\n    FontPtr pFont;\n    int rc;\n    REQUEST(xResourceReq);\n    REQUEST_SIZE_MATCH(xResourceReq);\n    rc = dixLookupResourceByType((void **) &pFont, stuff->id, RT_FONT,\n                                 client, DixDestroyAccess);\n    if (rc == Success) {\n        FreeResource(stuff->id, RT_NONE);\n        return Success;\n    }\n    else {\n        client->errorValue = stuff->id;\n        return rc;\n    }\n}", "target": 0}
{"code": "static int DefragBsdMissingFragmentIpv6Test(void)\n{\n    DefragInit();\n    default_policy = DEFRAG_POLICY_BSD;\n    Packet *packets[5];\n    packets[0] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 16 >> 3, 1, (uint8_t *)\"AABBCCDDAABBDDCC\", 16);\n    packets[1] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 40 >> 3, 1, (uint8_t *)\"AACCBBDD\", 8);\n    packets[2] = BuildIpv6TestPacketWithContent(\n            IPPROTO_ICMP, 189, 8 >> 3, 1, (uint8_t *)\"AACCDDBBAADDBBCC\", 16);\n    packets[3] = BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 0, 1, (uint8_t *)\"ZZZZZZZZ\", 8);\n    packets[4] =\n            BuildIpv6TestPacketWithContent(IPPROTO_ICMP, 189, 48 >> 3, 0, (uint8_t *)\"DDCCBBAA\", 8);\n    Packet *r = Defrag(NULL, NULL, packets[0]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[1]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[2]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[3]);\n    FAIL_IF_NOT_NULL(r);\n    r = Defrag(NULL, NULL, packets[4]);\n    FAIL_IF_NOT_NULL(r);\n#if 0\n    PrintRawDataFp(stdout, GET_PKT_DATA(r) + 40, GET_PKT_LEN(r) - 40);\n#endif\n    for (int i = 0; i < 5; i++) {\n        SCFree(packets[i]);\n    }\n    DefragDestroy();\n    PASS;\n}", "target": 0}
{"code": "int CLASS ljpeg_diff (ushort *huff)\n{\n  int len, diff;\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(!huff)\n    throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  len = gethuff(huff);\n  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n    return -32768;\n  diff = getbits(len);\n  if ((diff & (1 << (len-1))) == 0)\n    diff -= (1 << len) - 1;\n  return diff;\n}", "target": 0}
{"code": "GF_Err pssh_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_ProtectionSystemHeaderBox *ptr = (GF_ProtectionSystemHeaderBox *)s;\n\tgf_bs_read_data(bs, (char *) ptr->SystemID, 16);\n\tISOM_DECREASE_SIZE(ptr, 16);\n\tif (ptr->version > 0) {\n\t\tptr->KID_count = gf_bs_read_u32(bs);\n\t\tISOM_DECREASE_SIZE(ptr, 4);\n\t\tif (ptr->KID_count) {\n\t\t\tu32 i;\n\t\t\tif (ptr->size / sizeof(bin128) < ptr->KID_count)\n\t\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\t\tptr->KIDs = gf_malloc(ptr->KID_count*sizeof(bin128));\n\t\t\tif (!ptr->KIDs)\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\tfor (i=0; i<ptr->KID_count; i++) {\n\t\t\t\tgf_bs_read_data(bs, (char *) ptr->KIDs[i], 16);\n\t\t\t\tISOM_DECREASE_SIZE(ptr, 16);\n\t\t\t}\n\t\t}\n\t}\n\tptr->private_data_size = gf_bs_read_u32(bs);\n\tISOM_DECREASE_SIZE(ptr, 4);\n\tif (ptr->private_data_size) {\n\t\tif (ptr->size < ptr->private_data_size)\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tptr->private_data = gf_malloc(sizeof(char)*ptr->private_data_size);\n\t\tif (!ptr->private_data)\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tgf_bs_read_data(bs, (char *) ptr->private_data, ptr->private_data_size);\n\t\tISOM_DECREASE_SIZE(ptr, ptr->private_data_size);\n\t}\n\treturn GF_OK;\n}", "target": 0}
{"code": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}", "target": 1}
{"code": "char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL;\n\tchar *chunkValue = NULL;\n\tint i = 0;\n\tif (chunkSize == 0) {\n\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t} else {\n\t\tint chunkCount = oidc_util_get_chunked_count(r, cookieName);\n\t\tif (chunkCount > 0) {\n\t\t\tcookieValue = \"\";\n\t\t\tfor (i = 0; i < chunkCount; i++) {\n\t\t\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\t\t\tif (chunkValue != NULL)\n\t\t\t\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue, chunkValue);\n\t\t\t}\n\t\t} else {\n\t\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t\t}\n\t}\n\treturn cookieValue;\n}", "target": 1}
{"code": "  Status operator()(OpKernelContext* context,\n                    typename TTypes<Tindex>::ConstVec reverse_index_map,\n                    typename TTypes<T>::ConstVec grad_values,\n                    typename TTypes<T>::Vec d_values,\n                    typename TTypes<T>::Scalar d_default_value) {\n    const GPUDevice& device = context->eigen_device<GPUDevice>();\n    const Tindex N = reverse_index_map.dimension(0);\n    const Tindex N_full = grad_values.dimension(0);\n    Tensor visited_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(device) = visited.constant(false);\n    TF_RETURN_IF_ERROR(wrap_kernel_call(\n        GatherOriginalGradValuesKernel<T, Tindex>, device,\n        N, reverse_index_map, grad_values, d_values, visited));\n    gpuprim::CountingInputIterator<Tindex, Tindex> counting_iterator(Tindex(0));\n    ZeroMaskedValues<T, Tindex> mask_values_fn(visited.data(),\n                                               grad_values.data());\n    gpuprim::TransformInputIterator<T, decltype(mask_values_fn),\n                                    decltype(counting_iterator), Tindex>\n        transform_iterator(counting_iterator, mask_values_fn);\n    std::size_t temp_storage_bytes = 0;\n    auto gpuprim_status = gpuprim::DeviceReduce::Sum(\n        nullptr, temp_storage_bytes,\n        transform_iterator,\n        d_default_value.data(),\n        N_full,\n        device.stream());\n    if (gpuprim_status != gpuSuccess) {\n      return errors::Internal(\n          \"SparseFillEmptyRowsGrad: Could not launch \"\n          \"gpuprim::DeviceReduce::Sum to calculate temp_storage_bytes, \"\n          \"status: \",\n          GpuGetErrorString(gpuprim_status));\n    }\n    Tensor temp_storage;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        DT_INT8, TensorShape({static_cast<int64_t>(temp_storage_bytes)}),\n        &temp_storage));\n    gpuprim_status = gpuprim::DeviceReduce::Sum(\n        temp_storage.flat<int8>().data(), temp_storage_bytes,\n        transform_iterator,\n        d_default_value.data(),\n        N_full,\n        device.stream());\n    if (gpuprim_status != gpuSuccess) {\n      return errors::Internal(\n          \"SparseFillEmptyRowsGrad: Could not launch \"\n          \"gpuprim::DeviceReduce::Sum to sum values from originally-empty \"\n          \"rows. temp_storage_bytes: \",\n          temp_storage_bytes, \", status: \", GpuGetErrorString(gpuprim_status));\n    }\n    return OkStatus();\n  }", "target": 1}
{"code": "struct vfsmount *collect_mounts(struct path *path)\n{\n\tstruct mount *tree;\n\tnamespace_lock();\n\ttree = copy_tree(real_mount(path->mnt), path->dentry,\n\t\t\t CL_COPY_ALL | CL_PRIVATE);\n\tnamespace_unlock();\n\tif (IS_ERR(tree))\n\t\treturn ERR_CAST(tree);\n\treturn &tree->mnt;\n}", "target": 1}
{"code": "check_sudo (GError **error)\n{\n  const char *sudo_command_env = g_getenv (\"SUDO_COMMAND\");\n  g_auto(GStrv) split_command = NULL;\n  if (!sudo_command_env)\n    return TRUE;\n  split_command = g_strsplit (sudo_command_env, \" \", 2);\n  if (g_str_has_suffix (split_command[0], \"flatpak\"))\n    return flatpak_fail_error (error, FLATPAK_ERROR, _(\"\\\"flatpak run\\\" is not intended to be run as `sudo flatpak run`, use `sudo -i` or `su -l` instead and invoke \\\"flatpak run\\\" from inside the new shell\"));\n  return TRUE;\n}", "target": 0}
{"code": "InputMethodBase::~InputMethodBase() {\n}", "target": 0}
{"code": "njs_json_parse_iterator_call(njs_vm_t *vm, njs_json_parse_t *parse,\n    njs_json_state_t *state)\n{\n    njs_int_t          ret;\n    njs_value_t        arguments[3], *value;\n    njs_object_prop_t  *prop;\n    prop = state->prop;\n    arguments[0] = state->value;\n    arguments[1] = state->keys->start[state->index++];\n    switch (prop->type) {\n    case NJS_PROPERTY:\n        arguments[2] = prop->value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            prop->type = NJS_WHITEOUT;\n        } else {\n            prop->value = parse->retval;\n        }\n        break;\n    case NJS_PROPERTY_REF:\n        value = prop->value.data.u.value;\n        arguments[2] = *value;\n        ret = njs_function_apply(vm, parse->function, arguments, 3,\n                                 &parse->retval);\n        if (njs_slow_path(ret != NJS_OK)) {\n            return ret;\n        }\n        if (njs_is_undefined(&parse->retval)) {\n            ret = njs_value_property_i64_delete(vm, &state->value,\n                                                state->index - 1, NULL);\n        } else {\n            ret = njs_value_property_i64_set(vm, &state->value,\n                                             state->index - 1, &parse->retval);\n        }\n        if (njs_slow_path(ret == NJS_ERROR)) {\n            return NJS_ERROR;\n        }\n        break;\n    default:\n        njs_internal_error(vm, \"njs_json_parse_iterator_call() unexpected \"\n                         \"property type:%s\", njs_prop_type_string(prop->type));\n    }\n    return NJS_OK;\n}", "target": 1}
{"code": "static inline void __file_sb_list_add(struct file *file, struct super_block *sb)\n{\n\tstruct list_head *list;\n#ifdef CONFIG_SMP\n\tint cpu;\n\tcpu = smp_processor_id();\n\tfile->f_sb_list_cpu = cpu;\n\tlist = per_cpu_ptr(sb->s_files, cpu);\n#else\n\tlist = &sb->s_files;\n#endif\n\tlist_add(&file->f_u.fu_list, list);\n}", "target": 1}
{"code": "update_notification_destroy(struct update_notification *file)\n{\n\tdoc_data_cleanup(&file->snapshot);\n\tglobal_data_cleanup(&file->global_data);\n\tdeltas_head_destroy(file->deltas_list);\n\tfree(file->uri);\n\tfree(file);\n}", "target": 1}
{"code": "struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\tif (!bin->nlibs)\n\t\treturn NULL;\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n\t\treturn NULL;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}", "target": 1}
{"code": "static Status ValidateKernelSizes(const T& ksizes) {\n  for (size_t i = 0; i < ksizes.size(); ++i) {\n    if (ksizes[i] <= 0) {\n      return errors::InvalidArgument(\n          \"Sliding window ksize field for dimension \", i,\n          \" must be positive but is \", ksizes[i]);\n    }\n  }\n  return OkStatus();\n}", "target": 0}
{"code": "static void InsertNode(CPpmd8 *p, void *node, unsigned indx)\n{\n  ((CPpmd8_Node *)node)->Stamp = EMPTY_NODE;\n  ((CPpmd8_Node *)node)->Next = (CPpmd8_Node_Ref)p->FreeList[indx];\n  ((CPpmd8_Node *)node)->NU = I2U(indx);\n  p->FreeList[indx] = REF(node);\n  p->Stamps[indx]++;\n}", "target": 0}
{"code": "static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,\n\t\tstruct nfs4_state_owner *sp, int flags,\n\t\tconst struct iattr *attrs)\n{\n\tstruct dentry *parent = dget_parent(path->dentry);\n\tstruct inode *dir = parent->d_inode;\n\tstruct nfs_server *server = NFS_SERVER(dir);\n\tstruct nfs4_opendata *p;\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (p == NULL)\n\t\tgoto err;\n\tp->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid);\n\tif (p->o_arg.seqid == NULL)\n\t\tgoto err_free;\n\tp->path.mnt = mntget(path->mnt);\n\tp->path.dentry = dget(path->dentry);\n\tp->dir = parent;\n\tp->owner = sp;\n\tatomic_inc(&sp->so_count);\n\tp->o_arg.fh = NFS_FH(dir);\n\tp->o_arg.open_flags = flags,\n\tp->o_arg.clientid = server->nfs_client->cl_clientid;\n\tp->o_arg.id = sp->so_owner_id.id;\n\tp->o_arg.name = &p->path.dentry->d_name;\n\tp->o_arg.server = server;\n\tp->o_arg.bitmask = server->attr_bitmask;\n\tp->o_arg.claim = NFS4_OPEN_CLAIM_NULL;\n\tif (flags & O_EXCL) {\n\t\tu32 *s = (u32 *) p->o_arg.u.verifier.data;\n\t\ts[0] = jiffies;\n\t\ts[1] = current->pid;\n\t} else if (flags & O_CREAT) {\n\t\tp->o_arg.u.attrs = &p->attrs;\n\t\tmemcpy(&p->attrs, attrs, sizeof(p->attrs));\n\t}\n\tp->c_arg.fh = &p->o_res.fh;\n\tp->c_arg.stateid = &p->o_res.stateid;\n\tp->c_arg.seqid = p->o_arg.seqid;\n\tnfs4_init_opendata_res(p);\n\tkref_init(&p->kref);\n\treturn p;\nerr_free:\n\tkfree(p);\nerr:\n\tdput(parent);\n\treturn NULL;\n}", "target": 1}
{"code": "void free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}", "target": 0}
{"code": "  void Clear() {\n    size_ = 0;\n    SetOffset(0);\n  }", "target": 0}
{"code": "void zend_extension_dtor(zend_extension *extension)\n{\n#if ZEND_EXTENSIONS_SUPPORT && !ZEND_DEBUG\n\tif (extension->handle) {\n\t\tDL_UNLOAD(extension->handle);\n\t}\n#endif\n}", "target": 0}
{"code": "xmlRemoveID(xmlDocPtr doc, xmlAttrPtr attr) {\n    xmlIDTablePtr table;\n    xmlIDPtr id;\n    xmlChar *ID;\n    if (doc == NULL) return(-1);\n    if (attr == NULL) return(-1);\n    table = (xmlIDTablePtr) doc->ids;\n    if (table == NULL)\n        return(-1);\n    ID = xmlNodeListGetString(doc, attr->children, 1);\n    if (ID == NULL)\n        return(-1);\n    xmlValidNormalizeString(ID);\n    id = xmlHashLookup(table, ID);\n    if (id == NULL || id->attr != attr) {\n        xmlFree(ID);\n        return(-1);\n    }\n    xmlHashRemoveEntry(table, ID, xmlFreeIDTableEntry);\n    xmlFree(ID);\n    attr->atype = 0;\n    return(0);\n}", "target": 0}
{"code": "struct bpf_prog *bpf_patch_insn_single(struct bpf_prog *prog, u32 off,\n\t\t\t\t       const struct bpf_insn *patch, u32 len)\n{\n\tu32 insn_adj_cnt, insn_rest, insn_delta = len - 1;\n\tstruct bpf_prog *prog_adj;\n\tif (insn_delta == 0) {\n\t\tmemcpy(prog->insnsi + off, patch, sizeof(*patch));\n\t\treturn prog;\n\t}\n\tinsn_adj_cnt = prog->len + insn_delta;\n\tprog_adj = bpf_prog_realloc(prog, bpf_prog_size(insn_adj_cnt),\n\t\t\t\t    GFP_USER);\n\tif (!prog_adj)\n\t\treturn NULL;\n\tprog_adj->len = insn_adj_cnt;\n\tinsn_rest = insn_adj_cnt - off - len;\n\tmemmove(prog_adj->insnsi + off + len, prog_adj->insnsi + off + 1,\n\t\tsizeof(*patch) * insn_rest);\n\tmemcpy(prog_adj->insnsi + off, patch, sizeof(*patch) * len);\n\tbpf_adj_branches(prog_adj, off, insn_delta);\n\treturn prog_adj;\n}", "target": 1}
{"code": "extract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n    gboolean result = FALSE;\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n            goto out;\n        }\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}", "target": 1}
{"code": "static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) {\n\tRBuffer *fbuf = r_buf_ref (buf);\n\tstruct MACH0_(opts_t) opts;\n\tMACH0_(opts_set_default) (&opts, bf);\n\tstruct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts);\n\tif (!main_mach0) {\n\t\treturn false;\n\t}\n\tRRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0);\n\tRKernelCacheObj *obj = NULL;\n\tRPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0);\n\tif (!prelink_range) {\n\t\tgoto beach;\n\t}\n\tobj = R_NEW0 (RKernelCacheObj);\n\tif (!obj) {\n\t\tR_FREE (prelink_range);\n\t\tgoto beach;\n\t}\n\tRCFValueDict *prelink_info = NULL;\n\tif (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) {\n\t\tprelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset,\n\t\t\t\tprelink_range->range.size, R_CF_OPTION_SKIP_NSDATA);\n\t\tif (!prelink_info) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tif (!pending_bin_files) {\n\t\tpending_bin_files = r_list_new ();\n\t\tif (!pending_bin_files) {\n\t\t\tR_FREE (prelink_range);\n\t\t\tR_FREE (obj);\n\t\t\tR_FREE (prelink_info);\n\t\t\tgoto beach;\n\t\t}\n\t}\n\tobj->mach0 = main_mach0;\n\tobj->rebase_info = rebase_info;\n\tobj->prelink_info = prelink_info;\n\tobj->cache_buf = fbuf;\n\tobj->pa2va_exec = prelink_range->pa2va_exec;\n\tobj->pa2va_data = prelink_range->pa2va_data;\n\tR_FREE (prelink_range);\n\t*bin_obj = obj;\n\tr_list_push (pending_bin_files, bf);\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\treturn true;\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}", "target": 1}
{"code": "xcalloc (size_t num, size_t size)\n{\n    void *ptr = malloc(num * size);\n    if (ptr)\n    {\n        memset (ptr, '\\0', (num * size));\n    }\n    return ptr;\n}", "target": 1}
{"code": "PHP_FUNCTION(pg_version)\n{\n\tphp_pgsql_get_link_info(INTERNAL_FUNCTION_PARAM_PASSTHRU,PHP_PG_VERSION);\n}", "target": 0}
{"code": "static void ctrycatchfinally(JF, js_Ast *trystm, js_Ast *catchvar, js_Ast *catchstm, js_Ast *finallystm)\n{\n\tint L1, L2, L3;\n\tL1 = emitjump(J, F, OP_TRY);\n\t{\n\t\tL2 = emitjump(J, F, OP_TRY);\n\t\t{\n\t\t\tcstm(J, F, finallystm); \n\t\t\temit(J, F, OP_THROW); \n\t\t}\n\t\tlabel(J, F, L2);\n\t\tif (F->strict) {\n\t\t\tcheckfutureword(J, F, catchvar);\n\t\t\tif (!strcmp(catchvar->string, \"arguments\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'arguments' is not allowed in strict mode\");\n\t\t\tif (!strcmp(catchvar->string, \"eval\"))\n\t\t\t\tjsC_error(J, catchvar, \"redefining 'eval' is not allowed in strict mode\");\n\t\t}\n\t\temitline(J, F, catchvar);\n\t\temitstring(J, F, OP_CATCH, catchvar->string);\n\t\tcstm(J, F, catchstm);\n\t\temit(J, F, OP_ENDCATCH);\n\t\temit(J, F, OP_ENDTRY);\n\t\tL3 = emitjump(J, F, OP_JUMP); \n\t}\n\tlabel(J, F, L1);\n\tcstm(J, F, trystm);\n\temit(J, F, OP_ENDTRY);\n\tlabel(J, F, L3);\n\tcstm(J, F, finallystm);\n}", "target": 0}
{"code": "static int IsDigit(int enc ARG_UNUSED, int c)\n{\n  if (c >= 0x30 && c <= 0x39) return 1;\n  return 0;\n}", "target": 0}
{"code": "static inline ut16 r_read_le16(const void *src) {\n\tif (!src) {\n\t\treturn UT16_MAX;\n\t}\n\tconst ut8 *s = (const ut8*)src;\n\treturn (((ut16)s[1]) << 8) | (((ut16)s[0]) << 0);\n}", "target": 0}
{"code": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\tret = mount_entry_create_dir_file(mntent, path);\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\tcull_mntent_opt(mntent);\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n\t\t\t  mntflags, mntdata, optional);\n\tfree(mntdata);\n\treturn ret;\n}", "target": 1}
{"code": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n    Tensor group_assignment = c->input(2);\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment,\n                             ALL_TO_ALL_COLLECTIVE, resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    VLOG(1) << \"CollectiveAllToAll group_size \" << col_params->group.group_size\n            << \" group_key \" << col_params->group.group_key << \" instance_key \"\n            << col_params->instance.instance_key;\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK_ASYNC(c,\n                         c->forward_input_or_allocate_output(\n                             {0}, 0, col_params->instance.shape, &output),\n                         done_with_cleanup);\n    Run(c, col_params, std::move(done_with_cleanup));\n  }", "target": 1}
{"code": "void AllocateDataSet(cmsIT8* it8)\n{\n    TABLE* t = GetTable(it8);\n    if (t -> Data) return;    \n    t-> nSamples   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_FIELDS\"));\n    t-> nPatches   = atoi(cmsIT8GetProperty(it8, \"NUMBER_OF_SETS\"));\n    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));\n    if (t->Data == NULL) {\n        SynError(it8, \"AllocateDataSet: Unable to allocate data array\");\n    }\n}", "target": 1}
{"code": "void WasmBinaryWriter::writeFunctionSignatures() {\n  if (importInfo->getNumDefinedFunctions() == 0) {\n    return;\n  }\n  BYN_TRACE(\"== writeFunctionSignatures\\n\");\n  auto start = startSection(BinaryConsts::Section::Function);\n  o << U32LEB(importInfo->getNumDefinedFunctions());\n  ModuleUtils::iterDefinedFunctions(*wasm, [&](Function* func) {\n    BYN_TRACE(\"write one\\n\");\n    o << U32LEB(getTypeIndex(func->type));\n  });\n  finishSection(start);\n}", "target": 0}
{"code": "void FrameLoader::stopLoading(UnloadEventPolicy unloadEventPolicy, DatabasePolicy databasePolicy)\n{\n    if (m_frame->document() && m_frame->document()->tokenizer())\n        m_frame->document()->tokenizer()->stopParsing();\n    if (unloadEventPolicy != UnloadEventPolicyNone) {\n        if (m_frame->document()) {\n            if (m_didCallImplicitClose && !m_wasUnloadEventEmitted) {\n                Node* currentFocusedNode = m_frame->document()->focusedNode();\n                if (currentFocusedNode)\n                    currentFocusedNode->aboutToUnload();\n                m_unloadEventBeingDispatched = true;\n                if (m_frame->domWindow()) {\n                    if (unloadEventPolicy == UnloadEventPolicyUnloadAndPageHide)\n                        m_frame->domWindow()->dispatchEvent(PageTransitionEvent::create(EventNames().pagehideEvent, m_frame->document()->inPageCache()), m_frame->document());\n                    if (!m_frame->document()->inPageCache())\n                        m_frame->domWindow()->dispatchEvent(Event::create(eventNames().unloadEvent, false, false), m_frame->domWindow()->document());\n                }\n                m_unloadEventBeingDispatched = false;\n                if (m_frame->document())\n                    m_frame->document()->updateStyleIfNeeded();\n                m_wasUnloadEventEmitted = true;\n            }\n        }\n        if (m_frame->document() && !m_frame->document()->inPageCache()) {\n            bool keepEventListeners = m_isDisplayingInitialEmptyDocument && m_provisionalDocumentLoader\n                && m_frame->document()->securityOrigin()->isSecureTransitionTo(m_provisionalDocumentLoader->url());\n            if (!keepEventListeners)\n                m_frame->document()->removeAllEventListeners();\n        }\n    }\n    m_isComplete = true; \n    m_isLoadingMainResource = false;\n    m_didCallImplicitClose = true; \n    if (m_frame->document() && m_frame->document()->parsing()) {\n        finishedParsing();\n        m_frame->document()->setParsing(false);\n    }\n    m_workingURL = KURL();\n    if (Document* doc = m_frame->document()) {\n        if (DocLoader* docLoader = doc->docLoader())\n            cache()->loader()->cancelRequests(docLoader);\n#if ENABLE(DATABASE)\n        if (databasePolicy == DatabasePolicyStop)\n            doc->stopDatabases();\n#endif\n    }\n    for (Frame* child = m_frame->tree()->firstChild(); child; child = child->tree()->nextSibling())\n        child->loader()->stopLoading(unloadEventPolicy);\n    m_frame->redirectScheduler()->cancel();\n}", "target": 0}
{"code": "static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)\n{\n\tint ret;\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,\n\t\t\t      indx, &data, 1, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}", "target": 1}
{"code": "absl::Status CompressTensorAsProto(const tensorflow::Tensor& tensor,\n                                   tensorflow::TensorProto* proto) {\n  if (!IsSupported(tensor.dtype())) {\n    return absl::InvalidArgumentError(absl::StrCat(\n        \"Tensor of dtype \", tensorflow::DataTypeString(tensor.dtype()),\n        \" is not supported for compression.\"));\n  }\n  if (tensor.dtype() == tensorflow::DT_STRING) {\n    tensor.AsProtoTensorContent(proto);\n    return absl::OkStatus();\n  } else {\n    proto->set_dtype(tensor.dtype());\n    tensor.shape().AsProto(proto->mutable_tensor_shape());\n    SnappyCompressFromString(tensor.tensor_data(),\n                             proto->mutable_tensor_content());\n    return absl::OkStatus();\n  }\n}", "target": 0}
{"code": "static int tipc_nl_compat_media_dump(struct tipc_nl_compat_msg *msg,\n\t\t\t\t     struct nlattr **attrs)\n{\n\tstruct nlattr *media[TIPC_NLA_MEDIA_MAX + 1];\n\tint err;\n\tif (!attrs[TIPC_NLA_MEDIA])\n\t\treturn -EINVAL;\n\terr = nla_parse_nested(media, TIPC_NLA_MEDIA_MAX, attrs[TIPC_NLA_MEDIA],\n\t\t\t       NULL);\n\tif (err)\n\t\treturn err;\n\treturn tipc_add_tlv(msg->rep, TIPC_TLV_MEDIA_NAME,\n\t\t\t    nla_data(media[TIPC_NLA_MEDIA_NAME]),\n\t\t\t    nla_len(media[TIPC_NLA_MEDIA_NAME]));\n}", "target": 0}
{"code": "RequestHandler::RequestHandler(\n    std::shared_ptr<CheckWorkflow> check_workflow,\n    std::shared_ptr<context::ServiceContext> service_context,\n    std::unique_ptr<Request> request_data)\n    : context_(new context::RequestContext(service_context,\n                                           std::move(request_data))),\n      check_workflow_(check_workflow) {\n  std::string buffer;\n  if (context_->request()->FindHeader(\n          google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n    context_->request()->AddHeaderToBackend(\n        google::api_manager::auth::kEndpointApiUserInfo, \"\");\n  }\n}", "target": 1}
{"code": "mldv2_report_print(netdissect_options *ndo, const u_char *bp, u_int len)\n{\n    const struct icmp6_hdr *icp = (const struct icmp6_hdr *) bp;\n    u_int group, nsrcs, ngroups;\n    u_int i, j;\n    if (len < 8) {\n            ND_PRINT((ndo,\" [invalid len %d]\", len));\n            return;\n    }\n    ND_TCHECK(icp->icmp6_data16[1]);\n    ngroups = EXTRACT_16BITS(&icp->icmp6_data16[1]);\n    ND_PRINT((ndo,\", %d group record(s)\", ngroups));\n    if (ndo->ndo_vflag > 0) {\n\tgroup = 8;\n        for (i = 0; i < ngroups; i++) {\n\t    if (len < group + 20) {\n                    ND_PRINT((ndo,\" [invalid number of groups]\"));\n                    return;\n\t    }\n            ND_TCHECK2(bp[group + 4], sizeof(struct in6_addr));\n            ND_PRINT((ndo,\" [gaddr %s\", ip6addr_string(ndo, &bp[group + 4])));\n\t    ND_PRINT((ndo,\" %s\", tok2str(mldv2report2str, \" [v2-report-#%d]\",\n                                         bp[group])));\n            nsrcs = (bp[group + 2] << 8) + bp[group + 3];\n\t    if (len < group + 20 + (nsrcs * sizeof(struct in6_addr))) {\n                    ND_PRINT((ndo,\" [invalid number of sources %d]\", nsrcs));\n                    return;\n\t    }\n            if (ndo->ndo_vflag == 1)\n                    ND_PRINT((ndo,\", %d source(s)\", nsrcs));\n            else {\n                    ND_PRINT((ndo,\" {\"));\n                for (j = 0; j < nsrcs; j++) {\n                    ND_TCHECK2(bp[group + 20 + j * sizeof(struct in6_addr)],\n                            sizeof(struct in6_addr));\n\t\t    ND_PRINT((ndo,\" %s\", ip6addr_string(ndo, &bp[group + 20 + j * sizeof(struct in6_addr)])));\n\t\t}\n                ND_PRINT((ndo,\" }\"));\n            }\n            group += 20 + nsrcs * sizeof(struct in6_addr);\n\t    ND_PRINT((ndo,\"]\"));\n        }\n    }\n    return;\ntrunc:\n    ND_PRINT((ndo,\"[|icmp6]\"));\n    return;\n}", "target": 1}
{"code": "void Browser::RendererUnresponsive(\n    WebContents* source,\n    const content::WebContentsUnresponsiveState& unresponsive_state) {\n  int index = tab_strip_model_->GetIndexOfWebContents(source);\n  DCHECK_NE(TabStripModel::kNoTab, index);\n  if (tab_strip_model_->IsTabBlocked(index))\n    return;\n  TabDialogs::FromWebContents(source)->ShowHungRendererDialog(\n      unresponsive_state);\n}", "target": 0}
{"code": "archive_reopen_if_needed (ComicsDocument  *comics_document,\n\t\t\t  const char      *page_wanted,\n\t\t\t  GError         **error)\n{\n\tconst char *current_page;\n\tguint current_page_idx, page_wanted_idx;\n\tif (ev_archive_at_entry (comics_document->archive)) {\n\t\tcurrent_page = ev_archive_get_entry_pathname (comics_document->archive);\n\t\tif (current_page) {\n\t\t\tcurrent_page_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, current_page));\n\t\t\tpage_wanted_idx = GPOINTER_TO_UINT (g_hash_table_lookup (comics_document->page_positions, page_wanted));\n\t\t\tif (current_page_idx != 0 &&\n\t\t\t    page_wanted_idx != 0 &&\n\t\t\t    page_wanted_idx > current_page_idx)\n\t\t\t\treturn TRUE;\n\t\t}\n\t\tev_archive_reset (comics_document->archive);\n\t}\nreturn ev_archive_open_filename (comics_document->archive, comics_document->archive_path, error);\n}", "target": 0}
{"code": "int adis_update_scan_mode(struct iio_dev *indio_dev,\n\tconst unsigned long *scan_mask)\n{\n\tstruct adis *adis = iio_device_get_drvdata(indio_dev);\n\tconst struct iio_chan_spec *chan;\n\tunsigned int scan_count;\n\tunsigned int i, j;\n\t__be16 *tx, *rx;\n\tkfree(adis->xfer);\n\tkfree(adis->buffer);\n\tif (adis->burst && adis->burst->en)\n\t\treturn adis_update_scan_mode_burst(indio_dev, scan_mask);\n\tscan_count = indio_dev->scan_bytes / 2;\n\tadis->xfer = kcalloc(scan_count + 1, sizeof(*adis->xfer), GFP_KERNEL);\n\tif (!adis->xfer)\n\t\treturn -ENOMEM;\n\tadis->buffer = kcalloc(indio_dev->scan_bytes, 2, GFP_KERNEL);\n\tif (!adis->buffer)\n\t\treturn -ENOMEM;\n\trx = adis->buffer;\n\ttx = rx + scan_count;\n\tspi_message_init(&adis->msg);\n\tfor (j = 0; j <= scan_count; j++) {\n\t\tadis->xfer[j].bits_per_word = 8;\n\t\tif (j != scan_count)\n\t\t\tadis->xfer[j].cs_change = 1;\n\t\tadis->xfer[j].len = 2;\n\t\tadis->xfer[j].delay_usecs = adis->data->read_delay;\n\t\tif (j < scan_count)\n\t\t\tadis->xfer[j].tx_buf = &tx[j];\n\t\tif (j >= 1)\n\t\t\tadis->xfer[j].rx_buf = &rx[j - 1];\n\t\tspi_message_add_tail(&adis->xfer[j], &adis->msg);\n\t}\n\tchan = indio_dev->channels;\n\tfor (i = 0; i < indio_dev->num_channels; i++, chan++) {\n\t\tif (!test_bit(chan->scan_index, scan_mask))\n\t\t\tcontinue;\n\t\tif (chan->scan_type.storagebits == 32)\n\t\t\t*tx++ = cpu_to_be16((chan->address + 2) << 8);\n\t\t*tx++ = cpu_to_be16(chan->address << 8);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "pick_table_access_method(JOIN_TAB *tab)\n{\n  switch (tab->type) \n  {\n  case JT_REF:\n    tab->read_first_record= join_read_always_key;\n    tab->read_record.read_record_func= join_read_next_same;\n    break;\n  case JT_REF_OR_NULL:\n    tab->read_first_record= join_read_always_key_or_null;\n    tab->read_record.read_record_func= join_read_next_same_or_null;\n    break;\n  case JT_CONST:\n    tab->read_first_record= join_read_const;\n    tab->read_record.read_record_func= join_no_more_records;\n    break;\n  case JT_EQ_REF:\n    tab->read_first_record= join_read_key;\n    tab->read_record.read_record_func= join_no_more_records;\n    break;\n  case JT_FT:\n    tab->read_first_record= join_ft_read_first;\n    tab->read_record.read_record_func= join_ft_read_next;\n    break;\n  case JT_SYSTEM:\n    tab->read_first_record= join_read_system;\n    tab->read_record.read_record_func= join_no_more_records;\n    break;\n  default:\n    break;  \n  }\n}", "target": 0}
{"code": "void set_numabalancing_state(bool enabled)\n{\n\tif (enabled)\n\t\tstatic_branch_enable(&sched_numa_balancing);\n\telse\n\t\tstatic_branch_disable(&sched_numa_balancing);\n}", "target": 0}
{"code": "u_int32_t ndpi_bytestream_to_ipv4(const u_int8_t *str, u_int16_t max_chars_to_read, u_int16_t *bytes_read) {\n  u_int32_t val;\n  u_int16_t read = 0;\n  u_int16_t oldread;\n  u_int32_t c;\n  oldread = read;\n  c = ndpi_bytestream_to_number(str, max_chars_to_read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = c << 24;\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 16);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read || str[read] != '.')\n    return(0);\n  read++;\n  val = val + (c << 8);\n  oldread = read;\n  c = ndpi_bytestream_to_number(&str[read], max_chars_to_read - read, &read);\n  if(c > 255 || oldread == read || max_chars_to_read == read)\n    return(0);\n  val = val + c;\n  *bytes_read = *bytes_read + read;\n  return(htonl(val));\n}", "target": 0}
{"code": "static void nfs4_open_release(void *calldata)\n{\n\tstruct nfs4_opendata *data = calldata;\n\tstruct nfs4_state *state = NULL;\n\tif (data->cancelled == 0)\n\t\tgoto out_free;\n\tif (data->rpc_status != 0 || !data->rpc_done)\n\t\tgoto out_free;\n\tif (data->o_res.rflags & NFS4_OPEN_RESULT_CONFIRM)\n\t\tgoto out_free;\n\tstate = nfs4_opendata_to_nfs4_state(data);\n\tif (!IS_ERR(state))\n\t\tnfs4_close_state(&data->path, state, data->o_arg.open_flags);\nout_free:\n\tnfs4_opendata_put(data);\n}", "target": 1}
{"code": "static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)\n{\n#if BITS_PER_LONG == 32\n\treturn (void *)(unsigned long)context;\n#else\n\tvoid *p = pHba->ioctl_reply_context[context];\n\tpHba->ioctl_reply_context[context] = NULL;\n\treturn p;\n#endif\n}", "target": 1}
{"code": "find_entry2modify_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    back_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, FE_REALLY_INTERNAL ) );\n}", "target": 1}
{"code": "void RtmpProtocol::sendInvoke(const string &cmd, const AMFValue &val) {\n    AMFEncoder enc;\n    enc << cmd << ++_send_req_id << val;\n    sendRequest(MSG_CMD, enc.data());\n}", "target": 0}
{"code": "static int unix_dgram_peer_wake_connect(struct sock *sk, struct sock *other)\n{\n\tstruct unix_sock *u, *u_other;\n\tint rc;\n\tu = unix_sk(sk);\n\tu_other = unix_sk(other);\n\trc = 0;\n\tspin_lock(&u_other->peer_wait.lock);\n\tif (!u->peer_wake.private) {\n\t\tu->peer_wake.private = other;\n\t\t__add_wait_queue(&u_other->peer_wait, &u->peer_wake);\n\t\trc = 1;\n\t}\n\tspin_unlock(&u_other->peer_wait.lock);\n\treturn rc;\n}", "target": 0}
{"code": "static int do_i2c_mw(struct cmd_tbl *cmdtp, int flag, int argc,\n\t\t     char *const argv[])\n{\n\tuint\tchip;\n\tulong\taddr;\n\tint\talen;\n\tuchar\tbyte;\n\tint\tcount;\n\tint ret;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tstruct udevice *dev;\n#endif\n\tif ((argc < 4) || (argc > 5))\n\t\treturn CMD_RET_USAGE;\n\tchip = hextoul(argv[1], NULL);\n\taddr = hextoul(argv[2], NULL);\n\talen = get_alen(argv[2], DEFAULT_ADDR_LEN);\n\tif (alen > 3)\n\t\treturn CMD_RET_USAGE;\n#if CONFIG_IS_ENABLED(DM_I2C)\n\tret = i2c_get_cur_bus_chip(chip, &dev);\n\tif (!ret && alen != -1)\n\t\tret = i2c_set_chip_offset_len(dev, alen);\n\tif (ret)\n\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#endif\n\tbyte = hextoul(argv[3], NULL);\n\tif (argc == 5)\n\t\tcount = hextoul(argv[4], NULL);\n\telse\n\t\tcount = 1;\n\twhile (count-- > 0) {\n#if CONFIG_IS_ENABLED(DM_I2C)\n\t\tret = dm_i2c_write(dev, addr++, &byte, 1);\n#else\n\t\tret = i2c_write(chip, addr++, alen, &byte, 1);\n#endif\n\t\tif (ret)\n\t\t\treturn i2c_report_err(ret, I2C_ERR_WRITE);\n#if !defined(CONFIG_SYS_I2C_FRAM)\n\t\tudelay(11000);\n#endif\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "void _reset_fxsave_state()\n{\n    static OE_ALIGNED(OE_FXSAVE_ALIGNMENT) const uint64_t\n        _initial_fxstate[OE_FXSAVE_AREA_SIZE / sizeof(uint64_t)] = {\n            0x037F, 0, 0, 0xFFFF00001F80,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n            0,      0, 0, 0,\n        };\n    asm volatile(\"fxrstor %[fx_state] \\n\\t\"\n                 :\n                 : [fx_state] \"m\"(_initial_fxstate)\n                 :);\n}", "target": 1}
{"code": "void sendClean( char* str ) {\n    CleanupOutput(str);\n    send(str);\n}", "target": 0}
{"code": "bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct extent_tree *et;\n\tstruct extent_node *en;\n\tstruct extent_info ei;\n\tif (!f2fs_may_extent_tree(inode)) {\n\t\tif (i_ext && i_ext->len) {\n\t\t\ti_ext->len = 0;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tet = __grab_extent_tree(inode);\n\tif (!i_ext || !i_ext->len)\n\t\treturn false;\n\tget_extent_info(&ei, i_ext);\n\twrite_lock(&et->lock);\n\tif (atomic_read(&et->node_cnt))\n\t\tgoto out;\n\ten = __init_extent_tree(sbi, et, &ei);\n\tif (en) {\n\t\tspin_lock(&sbi->extent_lock);\n\t\tlist_add_tail(&en->list, &sbi->extent_list);\n\t\tspin_unlock(&sbi->extent_lock);\n\t}\nout:\n\twrite_unlock(&et->lock);\n\treturn false;\n}", "target": 1}
{"code": "libarchive_set_archive_type (EvArchive *archive,\n\t\t\t     EvArchiveType archive_type)\n{\n\tarchive->type = archive_type;\n\tarchive->libar = archive_read_new ();\n\tif (archive_type == EV_ARCHIVE_TYPE_ZIP)\n\t\tarchive_read_support_format_zip (archive->libar);\n\telse if (archive_type == EV_ARCHIVE_TYPE_7Z)\n\t\tarchive_read_support_format_7zip (archive->libar);\n\telse if (archive_type == EV_ARCHIVE_TYPE_TAR)\n\t\tarchive_read_support_format_tar (archive->libar);\n\telse if (archive_type == EV_ARCHIVE_TYPE_RAR) {\n\t\tarchive_read_support_format_rar (archive->libar);\n\t\tarchive_read_support_format_rar5 (archive->libar);\n\t} else\n\t\tg_assert_not_reached ();\n}", "target": 0}
{"code": "static int verify_ordered(unsigned mode1, const char *name1, unsigned mode2, const char *name2)\n{\n\tint len1 = strlen(name1);\n\tint len2 = strlen(name2);\n\tint len = len1 < len2 ? len1 : len2;\n\tunsigned char c1, c2;\n\tint cmp;\n\tcmp = memcmp(name1, name2, len);\n\tif (cmp < 0)\n\t\treturn 0;\n\tif (cmp > 0)\n\t\treturn TREE_UNORDERED;\n\tc1 = name1[len];\n\tc2 = name2[len];\n\tif (!c1 && !c2)\n\t\treturn TREE_HAS_DUPS;\n\tif (!c1 && S_ISDIR(mode1))\n\t\tc1 = '/';\n\tif (!c2 && S_ISDIR(mode2))\n\t\tc2 = '/';\n\treturn c1 < c2 ? 0 : TREE_UNORDERED;\n}", "target": 0}
{"code": "yy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}", "target": 1}
{"code": "static void process_constructors(RKernelCacheObj *obj, struct MACH0_(obj_t) *mach0, RList *ret, ut64 paddr, bool is_first, int mode, const char *prefix) {\n\tconst RVector *sections = MACH0_(load_sections) (mach0);\n\tif (!sections) {\n\t\treturn;\n\t}\n\tint type;\n\tstruct section_t *section;\n\tr_vector_foreach (sections, section) {\n\t\tif (section->size == 0) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (strstr (section->name, \"_mod_fini_func\") || strstr (section->name, \"_mod_term_func\")) {\n\t\t\ttype  = R_BIN_ENTRY_TYPE_FINI;\n\t\t} else if (strstr (section->name, \"_mod_init_func\")) {\n\t\t\ttype  = is_first ? 0 : R_BIN_ENTRY_TYPE_INIT;\n\t\t\tis_first = false;\n\t\t} else {\n\t\t\tcontinue;\n\t\t}\n\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsym->name = r_str_newf (\"%s.%s.%d\", prefix, (type == R_BIN_ENTRY_TYPE_INIT) ? \"init\" : \"fini\", count++);\n\t\t\t\tsym->vaddr = addr64;\n\t\t\t\tsym->paddr = paddr64;\n\t\t\t\tsym->size = 0;\n\t\t\t\tsym->forwarder = \"NONE\";\n\t\t\t\tsym->bind = \"GLOBAL\";\n\t\t\t\tsym->type = \"FUNC\";\n\t\t\t\tr_list_append (ret, sym);\n\t\t\t}\n\t\t}\n\t\tfree (buf);\n\t}\n}", "target": 1}
{"code": "MONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_CODE );\n}", "target": 1}
{"code": "void ntlm_print_av_pair_list(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\treturn;\n\tWLog_INFO(TAG, \"AV_PAIRs =\");\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair) != MsvAvEOL)\n\t{\n\t\tWLog_INFO(TAG, \"\\t%s AvId: %\" PRIu16 \" AvLen: %\" PRIu16 \"\",\n\t\t          AV_PAIR_STRINGS[ntlm_av_pair_get_id(pAvPair)], ntlm_av_pair_get_id(pAvPair),\n\t\t          ntlm_av_pair_get_len(pAvPair));\n\t\twinpr_HexDump(TAG, WLOG_INFO, ntlm_av_pair_get_value_pointer(pAvPair),\n\t\t              ntlm_av_pair_get_len(pAvPair));\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}\n}", "target": 1}
{"code": "static int udf_load_vrs(struct super_block *sb, struct udf_options *uopt,\n\t\t\tint silent, struct kernel_lb_addr *fileset)\n{\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tloff_t nsr_off;\n\tif (!sb_set_blocksize(sb, uopt->blocksize)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"Bad block size\\n\");\n\t\treturn 0;\n\t}\n\tsbi->s_last_block = uopt->lastblock;\n\tif (!uopt->novrs) {\n\t\tnsr_off = udf_check_vsd(sb);\n\t\tif (!nsr_off) {\n\t\t\tif (!silent)\n\t\t\t\tudf_warn(sb, \"No VRS found\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (nsr_off == -1)\n\t\t\tudf_debug(\"Failed to read byte 32768. Assuming open disc. Skipping validity check\\n\");\n\t\tif (!sbi->s_last_block)\n\t\t\tsbi->s_last_block = udf_get_last_block(sb);\n\t} else {\n\t\tudf_debug(\"Validity check skipped because of novrs option\\n\");\n\t}\n\tsbi->s_anchor = uopt->anchor;\n\tif (!udf_find_anchor(sb, fileset)) {\n\t\tif (!silent)\n\t\t\tudf_warn(sb, \"No anchor found\\n\");\n\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "int kvm_io_bus_write(struct kvm_vcpu *vcpu, enum kvm_bus bus_idx, gpa_t addr,\n\t\t     int len, const void *val)\n{\n\tstruct kvm_io_bus *bus;\n\tstruct kvm_io_range range;\n\tint r;\n\trange = (struct kvm_io_range) {\n\t\t.addr = addr,\n\t\t.len = len,\n\t};\n\tbus = srcu_dereference(vcpu->kvm->buses[bus_idx], &vcpu->kvm->srcu);\n\tr = __kvm_io_bus_write(vcpu, bus, &range, val);\n\treturn r < 0 ? r : 0;\n}", "target": 0}
{"code": "lookup_bytestring(netdissect_options *ndo, register const u_char *bs,\n\t\t  const unsigned int nlen)\n{\n\tstruct enamemem *tp;\n\tregister u_int i, j, k;\n\tif (nlen >= 6) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = (bs[4] << 8) | bs[5];\n\t} else if (nlen >= 4) {\n\t\tk = (bs[0] << 8) | bs[1];\n\t\tj = (bs[2] << 8) | bs[3];\n\t\ti = 0;\n\t} else\n\t\ti = j = k = 0;\n\ttp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];\n\twhile (tp->e_nxt)\n\t\tif (tp->e_addr0 == i &&\n\t\t    tp->e_addr1 == j &&\n\t\t    tp->e_addr2 == k &&\n\t\t    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)\n\t\t\treturn tp;\n\t\telse\n\t\t\ttp = tp->e_nxt;\n\ttp->e_addr0 = i;\n\ttp->e_addr1 = j;\n\ttp->e_addr2 = k;\n\ttp->e_bs = (u_char *) calloc(1, nlen + 1);\n\tif (tp->e_bs == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\tmemcpy(tp->e_bs, bs, nlen);\n\ttp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));\n\tif (tp->e_nxt == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"lookup_bytestring: calloc\");\n\treturn tp;\n}", "target": 1}
{"code": "static int rb_head_page_set_head(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t struct buffer_page *head,\n\t\t\t\t struct buffer_page *prev,\n\t\t\t\t int old_flag)\n{\n\treturn rb_head_page_set(cpu_buffer, head, prev,\n\t\t\t\told_flag, RB_PAGE_HEAD);\n}", "target": 0}
{"code": "void mp_obj_int_to_bytes_impl(mp_obj_t self_in, bool big_endian, size_t len, byte *buf) {\n    assert(mp_obj_is_exact_type(self_in, &mp_type_int));\n    mp_obj_int_t *self = MP_OBJ_TO_PTR(self_in);\n    mpz_as_bytes(&self->mpz, big_endian, len, buf);\n}", "target": 1}
{"code": "void Transform::interpolate_nearestneighbour( RawTile& in, unsigned int resampled_width, unsigned int resampled_height ){\n  unsigned char *input = (unsigned char*) in.data;\n  int channels = in.channels;\n  unsigned int width = in.width;\n  unsigned int height = in.height;\n  unsigned char *output;\n  bool new_buffer = false;\n  if( resampled_width*resampled_height > in.width*in.height ){\n    new_buffer = true;\n    output = new unsigned char[(unsigned long long)resampled_width*resampled_height*in.channels];\n  }\n  else output = (unsigned char*) in.data;\n  float xscale = (float)width / (float)resampled_width;\n  float yscale = (float)height / (float)resampled_height;\n  for( unsigned int j=0; j<resampled_height; j++ ){\n    for( unsigned int i=0; i<resampled_width; i++ ){\n      unsigned long ii = (unsigned int) floorf(i*xscale);\n      unsigned long jj = (unsigned int) floorf(j*yscale);\n      unsigned long pyramid_index = (unsigned int) channels * ( ii + jj*width );\n      unsigned long long resampled_index = (unsigned long long)(i + j*resampled_width)*channels;\n      for( int k=0; k<in.channels; k++ ){\n\toutput[resampled_index+k] = input[pyramid_index+k];\n      }\n    }\n  }\n  if( new_buffer ) delete[] (unsigned char*) input;\n  in.width = resampled_width;\n  in.height = resampled_height;\n  in.dataLength = resampled_width * resampled_height * channels * (in.bpc/8);\n  in.data = output;\n}", "target": 1}
{"code": "static void sas_unregister_devs_sas_addr(struct domain_device *parent,\n\t\t\t\t\t int phy_id, bool last)\n{\n\tstruct expander_device *ex_dev = &parent->ex_dev;\n\tstruct ex_phy *phy = &ex_dev->ex_phy[phy_id];\n\tstruct domain_device *child, *n, *found = NULL;\n\tif (last) {\n\t\tlist_for_each_entry_safe(child, n,\n\t\t\t&ex_dev->children, siblings) {\n\t\t\tif (SAS_ADDR(child->sas_addr) ==\n\t\t\t    SAS_ADDR(phy->attached_sas_addr)) {\n\t\t\t\tset_bit(SAS_DEV_GONE, &child->state);\n\t\t\t\tif (child->dev_type == SAS_EDGE_EXPANDER_DEVICE ||\n\t\t\t\t    child->dev_type == SAS_FANOUT_EXPANDER_DEVICE)\n\t\t\t\t\tsas_unregister_ex_tree(parent->port, child);\n\t\t\t\telse\n\t\t\t\t\tsas_unregister_dev(parent->port, child);\n\t\t\t\tfound = child;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tsas_disable_routing(parent, phy->attached_sas_addr);\n\t}\n\tmemset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE);\n\tif (phy->port) {\n\t\tsas_port_delete_phy(phy->port, phy->phy);\n\t\tsas_device_set_phy(found, phy->port);\n\t\tif (phy->port->num_phys == 0)\n\t\t\tsas_port_delete(phy->port);\n\t\tphy->port = NULL;\n\t}\n}", "target": 1}
{"code": "int main(void)\n{\n\tSuite *suite;\n\tSRunner *runner;\n\tint tests_failed;\n\tlog_setup(true);\n\tsuite = xml_load_suite();\n\trunner = srunner_create(suite);\n\tsrunner_run_all(runner, CK_NORMAL);\n\ttests_failed = srunner_ntests_failed(runner);\n\tsrunner_free(runner);\n\treturn (tests_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}", "target": 0}
{"code": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}", "target": 0}
{"code": "void RtmpProtocol::handle_C1_complex(const char *data){\n    const char *c1_start = data + 1;\n    const char *schema_start = c1_start + 8;\n    char *digest_start;\n    try {\n        auto digest = get_C1_digest((uint8_t *) schema_start + C1_SCHEMA_SIZE, &digest_start);\n        string c1_joined(c1_start, C1_HANDSHARK_SIZE);\n        c1_joined.erase(digest_start - c1_start, C1_DIGEST_SIZE);\n        check_C1_Digest(digest, c1_joined);\n        send_complex_S0S1S2(0, digest);\n    } catch (std::exception &) {\n        try {\n            auto digest = get_C1_digest((uint8_t *) schema_start, &digest_start);\n            string c1_joined(c1_start, C1_HANDSHARK_SIZE);\n            c1_joined.erase(digest_start - c1_start, C1_DIGEST_SIZE);\n            check_C1_Digest(digest, c1_joined);\n            send_complex_S0S1S2(1, digest);\n        } catch (std::exception &) {\n            handle_C1_simple(data);\n        }\n    }\n}", "target": 0}
{"code": "void dmar_free_irte(const struct intr_source *intr_src, uint16_t index)\n{\n\tstruct dmar_drhd_rt *dmar_unit;\n\tunion dmar_ir_entry *ir_table, *ir_entry;\n\tunion pci_bdf sid;\n\tif (intr_src->is_msi) {\n\t\tdmar_unit = device_to_dmaru((uint8_t)intr_src->src.msi.bits.b, intr_src->src.msi.fields.devfun);\n\t} else {\n\t\tdmar_unit = ioapic_to_dmaru(intr_src->src.ioapic_id, &sid);\n\t}\n\tif (is_dmar_unit_valid(dmar_unit, sid)) {\n\t\tir_table = (union dmar_ir_entry *)hpa2hva(dmar_unit->ir_table_addr);\n\t\tir_entry = ir_table + index;\n\t\tir_entry->bits.remap.present = 0x0UL;\n\t\tiommu_flush_cache(ir_entry, sizeof(union dmar_ir_entry));\n\t\tdmar_invalid_iec(dmar_unit, index, 0U, false);\n\t\tif (!is_irte_reserved(dmar_unit, index)) {\n\t\t\tspinlock_obtain(&dmar_unit->lock);\n\t\t\tbitmap_clear_nolock(index & 0x3FU, &dmar_unit->irte_alloc_bitmap[index >> 6U]);\n\t\t\tspinlock_release(&dmar_unit->lock);\n\t\t}\n\t}\n}", "target": 1}
{"code": "l2tp_msgtype_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_msgtype2str, \"MSGTYPE-#%u\",\n\t    EXTRACT_16BITS(ptr))));\n}", "target": 1}
{"code": "    DataBuf LoaderExifDataJpeg::getData() const\n    {\n        if (!valid()) return DataBuf();\n        ExifData::const_iterator pos = image_.exifData().findKey(dataKey_);\n        if (pos != image_.exifData().end()) {\n            DataBuf buf = pos->dataArea(); \n            if (buf.size_ == 0) { \n                buf = DataBuf(pos->size());\n                pos->copy(buf.pData_, invalidByteOrder);\n            }\n            buf.pData_[0] = 0xff; \n            return buf;\n        }\n        return DataBuf();\n    }", "target": 0}
{"code": "static int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\treturn 0;\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}", "target": 1}
{"code": "delta_head_create(struct delta_head **result)\n{\n\tstruct delta_head *tmp;\n\ttmp = malloc(sizeof(struct delta_head));\n\tif (tmp == NULL)\n\t\treturn pr_enomem();\n\tdoc_data_init(&tmp->doc_data);\n\t*result = tmp;\n\treturn 0;\n}", "target": 1}
{"code": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\tif (test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkzfree(buf);\n\treturn ret;\n}", "target": 1}
{"code": "int migrate_page_move_mapping(struct address_space *mapping,\n\t\tstruct page *newpage, struct page *page,\n\t\tstruct buffer_head *head, enum migrate_mode mode,\n\t\tint extra_count)\n{\n\tint expected_count = 1 + extra_count;\n\tvoid **pslot;\n\tif (!mapping) {\n\t\tif (page_count(page) != expected_count)\n\t\t\treturn -EAGAIN;\n\t\tset_page_memcg(newpage, page_memcg(page));\n\t\tnewpage->index = page->index;\n\t\tnewpage->mapping = page->mapping;\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageSwapBacked(newpage);\n\t\treturn MIGRATEPAGE_SUCCESS;\n\t}\n\tspin_lock_irq(&mapping->tree_lock);\n\tpslot = radix_tree_lookup_slot(&mapping->page_tree,\n \t\t\t\t\tpage_index(page));\n\texpected_count += 1 + page_has_private(page);\n\tif (page_count(page) != expected_count ||\n\t\tradix_tree_deref_slot_protected(pslot, &mapping->tree_lock) != page) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\tif (!page_freeze_refs(page, expected_count)) {\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\tif (mode == MIGRATE_ASYNC && head &&\n\t\t\t!buffer_migrate_lock_buffers(head, mode)) {\n\t\tpage_unfreeze_refs(page, expected_count);\n\t\tspin_unlock_irq(&mapping->tree_lock);\n\t\treturn -EAGAIN;\n\t}\n\tset_page_memcg(newpage, page_memcg(page));\n\tnewpage->index = page->index;\n\tnewpage->mapping = page->mapping;\n\tif (PageSwapBacked(page))\n\t\tSetPageSwapBacked(newpage);\n\tget_page(newpage);\t\n\tif (PageSwapCache(page)) {\n\t\tSetPageSwapCache(newpage);\n\t\tset_page_private(newpage, page_private(page));\n\t}\n\tradix_tree_replace_slot(pslot, newpage);\n\tpage_unfreeze_refs(page, expected_count - 1);\n\t__dec_zone_page_state(page, NR_FILE_PAGES);\n\t__inc_zone_page_state(newpage, NR_FILE_PAGES);\n\tif (!PageSwapCache(page) && PageSwapBacked(page)) {\n\t\t__dec_zone_page_state(page, NR_SHMEM);\n\t\t__inc_zone_page_state(newpage, NR_SHMEM);\n\t}\n\tspin_unlock_irq(&mapping->tree_lock);\n\treturn MIGRATEPAGE_SUCCESS;\n}", "target": 1}
{"code": "TEST(format_timespan) {\n        test_format_timespan_accuracy(1);\n        test_format_timespan_accuracy(USEC_PER_MSEC);\n        test_format_timespan_accuracy(USEC_PER_SEC);\n        _cleanup_free_ char *buf;\n        assert_se(buf = new(char, 5));\n        assert_se(buf == format_timespan(buf, 5, 100005, 1000));\n}", "target": 0}
{"code": "    void XmpSidecar::writeMetadata()\n    {\n        if (io_->open() != 0) {\n            throw Error(kerDataSourceOpenFailed, io_->path(), strError());\n        }\n        IoCloser closer(*io_);\n        if (writeXmpFromPacket() == false) {\n            Exiv2::XmpData  copy   ;\n            for (Exiv2::XmpData::const_iterator it = xmpData_.begin(); it != xmpData_.end(); ++it) {\n                if ( !matchi(it->key(),\"exif\") && !matchi(it->key(),\"iptc\") ) {\n                    copy[it->key()] = it->value();\n                }\n            }\n            copyExifToXmp(exifData_, xmpData_);\n            copyIptcToXmp(iptcData_, xmpData_);\n            for (Exiv2::XmpData::const_iterator it = copy.begin(); it != copy.end(); ++it) {\n                xmpData_[it->key()] = it->value() ;\n            }\n            for ( Exiv2::Dictionary_i it = dates_.begin() ; it != dates_.end() ; ++it ) {\n                std::string   sKey = it->first;\n                Exiv2::XmpKey key(sKey);\n                if ( xmpData_.findKey(key) != xmpData_.end() ) {\n                    std::string value_orig(it->second);\n                    std::string value_now(xmpData_[sKey].value().toString());\n                    if ( value_orig.find(value_now.substr(0,10)) != std::string::npos ) {\n                        xmpData_[sKey] = value_orig ;\n                    }\n                }\n            }\n            if (XmpParser::encode(xmpPacket_, xmpData_,\n                                  XmpParser::omitPacketWrapper|XmpParser::useCompactFormat) > 1) {\n#ifndef SUPPRESS_WARNINGS\n                EXV_ERROR << \"Failed to encode XMP metadata.\\n\";\n#endif\n            }\n        }\n        if (xmpPacket_.size() > 0) {\n            if (xmpPacket_.substr(0, 5)  != \"<?xml\") {\n                xmpPacket_ = xmlHeader + xmpPacket_ + xmlFooter;\n            }\n            BasicIo::UniquePtr tempIo(new MemIo);\n            assert(tempIo.get() != 0);\n            if (tempIo->write(reinterpret_cast<const byte*>(xmpPacket_.data()), xmpPacket_.size()) != xmpPacket_.size())\n                throw Error(kerImageWriteFailed);\n            if (tempIo->error()) throw Error(kerImageWriteFailed);\n            io_->close();\n            io_->transfer(*tempIo); \n        }\n    } ", "target": 0}
{"code": "void encode(ArgumentEncoder* encoder, CFArrayRef array)\n{\n    CFIndex size = CFArrayGetCount(array);\n    Vector<CFTypeRef, 32> values(size);\n    CFArrayGetValues(array, CFRangeMake(0, size), values.data());\n    encoder->encodeUInt64(size);\n    for (CFIndex i = 0; i < size; ++i) {\n        ASSERT(values[i]);\n        encode(encoder, values[i]);\n    }\n}", "target": 0}
{"code": "static struct dentry *proc_pid_instantiate(struct inode *dir,\n\t\t\t\t\t   struct dentry * dentry,\n\t\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *error = ERR_PTR(-ENOENT);\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\tinode->i_nlink = 5;\n#ifdef CONFIG_SECURITY\n\tinode->i_nlink += 1;\n#endif\n\tdentry->d_op = &pid_dentry_operations;\n\td_add(dentry, inode);\n\tif (pid_revalidate(dentry, NULL))\n\t\terror = NULL;\nout:\n\treturn error;\n}", "target": 0}
{"code": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\toldsize += bits;\n\tif ( msg->maxsize - msg->cursize < 4 ) {\n\t\tmsg->overflowed = qtrue;\n\t\treturn;\n\t}\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\tif ( msg->oob ) {\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t} else if ( bits==32 ) {\n\t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 8);\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}", "target": 1}
{"code": "static int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len)\n{\n\treturn lstat_cache(cache, name, len,\n\t\t\t   FL_DIR|FL_FULLPATH, prefix_len) &\n\t\tFL_DIR;\n}", "target": 0}
{"code": "struct r_bin_pe_addr_t *PE_(check_mingw)(RBinPEObj *pe) {\n\tstruct r_bin_pe_addr_t* entry;\n\tbool sw = false;\n\tut8 b[1024];\n\tsize_t n = 0;\n\tif (!pe || !pe->b) {\n\t\treturn 0LL;\n\t}\n\tentry = PE_(r_bin_pe_get_entrypoint) (pe);\n\tZERO_FILL (b);\n\tif (r_buf_read_at (pe->b, entry->paddr, b, sizeof (b)) < 0) {\n\t\tpe_printf (\"Warning: Cannot read entry at 0x%08\"PFMT64x \"\\n\", entry->paddr);\n\t\tfree (entry);\n\t\treturn NULL;\n\t}\n\tif (b[0] == 0x55 && b[1] == 0x89 && b[3] == 0x83 && b[6] == 0xc7 && b[13] == 0xff && b[19] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 19);\n\t}\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[10] == 0xff && b[16] == 0xe8) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 16);\n\t}\n\tif (b[0] == 0x83 && b[3] == 0xc7 && b[13] == 0xe8 && b[18] == 0x83 && b[21] == 0xe9) {\n\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 21);\n\t}\n\tif (sw) {\n\t\tfor (n = 0; n < sizeof (b) - 12; n++) {\n\t\t\tif (b[n] == 0xa1 && b[n + 5] == 0x89 && b[n + 8] == 0xe8) {\n\t\t\t\tsw = follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, n + 8);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t}\n\tfree (entry);\n\treturn NULL;\n}", "target": 1}
{"code": "inline bool loadModule(const char* filename, IR::Module& outModule)\n{\n\tstd::vector<U8> fileBytes;\n\tif(!loadFile(filename, fileBytes)) { return false; }\n\tif(*(U32*)fileBytes.data() == 0x6d736100)\n\t{ return loadBinaryModule(fileBytes.data(), fileBytes.size(), outModule); }\n\telse\n\t{\n\t\tfileBytes.push_back(0);\n\t\tstd::vector<WAST::Error> parseErrors;\n\t\tif(!WAST::parseModule(\n\t\t\t   (const char*)fileBytes.data(), fileBytes.size(), outModule, parseErrors))\n\t\t{\n\t\t\tLog::printf(Log::error, \"Error parsing WebAssembly text file:\\n\");\n\t\t\treportParseErrors(filename, parseErrors);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}", "target": 1}
{"code": "void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct scm_timestamping tss;\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\tif (need_software_tstamp && skb->tstamp == 0)\n\t\t__net_timestamp(skb);\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tstruct timespec ts;\n\t\t\tskb_get_timestampns(skb, &ts);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts), &ts);\n\t\t}\n\t}\n\tmemset(&tss, 0, sizeof(tss));\n\tif ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) &&\n\t    ktime_to_timespec_cond(skb->tstamp, tss.ts + 0))\n\t\tempty = 0;\n\tif (shhwtstamps &&\n\t    (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) &&\n\t    ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2))\n\t\tempty = 0;\n\tif (!empty) {\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(tss), &tss);\n\t\tif (skb_is_err_queue(skb) && skb->len &&\n\t\t    SKB_EXT_ERR(skb)->opt_stats)\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS,\n\t\t\t\t skb->len, skb->data);\n\t}\n}", "target": 0}
{"code": "__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,\n\t\t\t\t __be16 sport, __be16 dport)\n{\n\t__u32 seq;\n\t__u32 hash[4];\n\tstruct keydata *keyptr = get_keyptr();\n\thash[0] = (__force u32)saddr;\n\thash[1] = (__force u32)daddr;\n\thash[2] = ((__force u16)sport << 16) + (__force u16)dport;\n\thash[3] = keyptr->secret[11];\n\tseq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;\n\tseq += keyptr->count;\n\tseq += ktime_to_ns(ktime_get_real()) >> 6;\n\treturn seq;\n}", "target": 1}
{"code": "void RestAuthHandler::shutdownExecute(bool isFinalized) noexcept {\n  try {\n    if (_isValid) {\n      events::LoggedIn(*_request, _username);\n    } else {\n      events::CredentialsBad(*_request, _username);\n    }\n  } catch (...) {\n  }\n  RestVocbaseBaseHandler::shutdownExecute(isFinalized);\n}", "target": 1}
{"code": "mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data,\n\t\t  int len, bool more)\n{\n\tstruct page *page = virt_to_head_page(data);\n\tint offset = data - page_address(page);\n\tstruct sk_buff *skb = q->rx_head;\n\toffset += q->buf_offset;\n\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len,\n\t\t\tq->buf_size);\n\tif (more)\n\t\treturn;\n\tq->rx_head = NULL;\n\tdev->drv->rx_skb(dev, q - dev->q_rx, skb);\n}", "target": 1}
{"code": "static int inet6_fill_ifla6_attrs(struct sk_buff *skb, struct inet6_dev *idev)\n{\n\tstruct nlattr *nla;\n\tstruct ifla_cacheinfo ci;\n\tif (nla_put_u32(skb, IFLA_INET6_FLAGS, idev->if_flags))\n\t\tgoto nla_put_failure;\n\tci.max_reasm_len = IPV6_MAXPLEN;\n\tci.tstamp = cstamp_delta(idev->tstamp);\n\tci.reachable_time = jiffies_to_msecs(idev->nd_parms->reachable_time);\n\tci.retrans_time = jiffies_to_msecs(idev->nd_parms->retrans_time);\n\tif (nla_put(skb, IFLA_INET6_CACHEINFO, sizeof(ci), &ci))\n\t\tgoto nla_put_failure;\n\tnla = nla_reserve(skb, IFLA_INET6_CONF, DEVCONF_MAX * sizeof(s32));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tipv6_store_devconf(&idev->cnf, nla_data(nla), nla_len(nla));\n\tnla = nla_reserve(skb, IFLA_INET6_STATS, IPSTATS_MIB_MAX * sizeof(u64));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_STATS, nla_len(nla));\n\tnla = nla_reserve(skb, IFLA_INET6_ICMP6STATS, ICMP6_MIB_MAX * sizeof(u64));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tsnmp6_fill_stats(nla_data(nla), idev, IFLA_INET6_ICMP6STATS, nla_len(nla));\n\tnla = nla_reserve(skb, IFLA_INET6_TOKEN, sizeof(struct in6_addr));\n\tif (nla == NULL)\n\t\tgoto nla_put_failure;\n\tread_lock_bh(&idev->lock);\n\tmemcpy(nla_data(nla), idev->token.s6_addr, nla_len(nla));\n\tread_unlock_bh(&idev->lock);\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 0}
{"code": "static void free_user(struct kref *ref)\n{\n\tstruct ipmi_user *user = container_of(ref, struct ipmi_user, refcount);\n\tcleanup_srcu_struct(&user->release_barrier);\n\tkfree(user);\n}", "target": 0}
{"code": "deltas_head_init(struct deltas_head *list)\n{\n\tlist->array = NULL;\n\tlist->len = 0;\n\tlist->capacity = 0;\n}", "target": 1}
{"code": "bfad_im_get_stats(struct Scsi_Host *shost)\n{\n\tstruct bfad_im_port_s *im_port =\n\t\t\t(struct bfad_im_port_s *) shost->hostdata[0];\n\tstruct bfad_s         *bfad = im_port->bfad;\n\tstruct bfad_hal_comp fcomp;\n\tunion bfa_port_stats_u *fcstats;\n\tstruct fc_host_statistics *hstats;\n\tbfa_status_t    rc;\n\tunsigned long   flags;\n\tfcstats = kzalloc(sizeof(union bfa_port_stats_u), GFP_KERNEL);\n\tif (fcstats == NULL)\n\t\treturn NULL;\n\thstats = &bfad->link_stats;\n\tinit_completion(&fcomp.comp);\n\tspin_lock_irqsave(&bfad->bfad_lock, flags);\n\tmemset(hstats, 0, sizeof(struct fc_host_statistics));\n\trc = bfa_port_get_stats(BFA_FCPORT(&bfad->bfa),\n\t\t\t\tfcstats, bfad_hcb_comp, &fcomp);\n\tspin_unlock_irqrestore(&bfad->bfad_lock, flags);\n\tif (rc != BFA_STATUS_OK)\n\t\treturn NULL;\n\twait_for_completion(&fcomp.comp);\n\thstats->seconds_since_last_reset = fcstats->fc.secs_reset;\n\thstats->tx_frames = fcstats->fc.tx_frames;\n\thstats->tx_words  = fcstats->fc.tx_words;\n\thstats->rx_frames = fcstats->fc.rx_frames;\n\thstats->rx_words  = fcstats->fc.rx_words;\n\thstats->lip_count = fcstats->fc.lip_count;\n\thstats->nos_count = fcstats->fc.nos_count;\n\thstats->error_frames = fcstats->fc.error_frames;\n\thstats->dumped_frames = fcstats->fc.dropped_frames;\n\thstats->link_failure_count = fcstats->fc.link_failures;\n\thstats->loss_of_sync_count = fcstats->fc.loss_of_syncs;\n\thstats->loss_of_signal_count = fcstats->fc.loss_of_signals;\n\thstats->prim_seq_protocol_err_count = fcstats->fc.primseq_errs;\n\thstats->invalid_crc_count = fcstats->fc.invalid_crcs;\n\tkfree(fcstats);\n\treturn hstats;\n}", "target": 1}
{"code": "display_debug_not_supported (struct dwarf_section *section,\n\t\t\t     void *file ATTRIBUTE_UNUSED)\n{\n  printf (_(\"Displaying the debug contents of section %s is not yet supported.\\n\"),\n\t    section->name);\n  return 1;\n}", "target": 0}
{"code": "static void ide_atapi_cmd_read(IDEState *s, int lba, int nb_sectors,\n                               int sector_size)\n{\n#ifdef DEBUG_IDE_ATAPI\n    printf(\"read %s: LBA=%d nb_sectors=%d\\n\", s->atapi_dma ? \"dma\" : \"pio\",\n        lba, nb_sectors);\n#endif\n    if (s->atapi_dma) {\n        ide_atapi_cmd_read_dma(s, lba, nb_sectors, sector_size);\n    } else {\n        ide_atapi_cmd_read_pio(s, lba, nb_sectors, sector_size);\n    }\n}", "target": 0}
{"code": "int LibRaw_bigfile_datastream::seek(INT64 o, int whence)\n{\n  LR_BF_CHK();\n#if defined(_WIN32)\n#ifdef WIN32SECURECALLS\n  return _fseeki64(f, o, whence);\n#else\n  return fseek(f, (long)o, whence);\n#endif\n#else\n  return fseeko(f, o, whence);\n#endif\n}", "target": 0}
{"code": "u32 smm_get_cpu_smbase(unsigned int cpu_num)\n{\n\tif (cpu_num < CONFIG_MAX_CPUS) {\n\t\tif (cpus[cpu_num].active)\n\t\t\treturn cpus[cpu_num].smbase;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static CURLcode smtp_connect(struct connectdata *conn,\n                             bool *done) \n{\n  CURLcode result;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct SessionHandle *data = conn->data;\n  struct pingpong *pp = &smtpc->pp;\n  const char *path = conn->data->state.path;\n  int len;\n  char localhost[HOSTNAME_MAX + 1];\n  *done = FALSE; \n  Curl_reset_reqproto(conn);\n  result = smtp_init(conn);\n  if(CURLE_OK != result)\n    return result;\n  conn->bits.close = FALSE;\n  pp->response_time = RESP_TIMEOUT; \n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {\n    struct HTTP http_proxy;\n    struct FTP *smtp_save;\n    smtp_save = data->state.proto.smtp;\n    memset(&http_proxy, 0, sizeof(http_proxy));\n    data->state.proto.http = &http_proxy;\n    result = Curl_proxyCONNECT(conn, FIRSTSOCKET,\n                               conn->host.name, conn->remote_port);\n    data->state.proto.smtp = smtp_save;\n    if(CURLE_OK != result)\n      return result;\n  }\n  if((conn->handler->protocol & CURLPROTO_SMTPS) &&\n      data->state.used_interface != Curl_if_multi) {\n    result = Curl_ssl_connect(conn, FIRSTSOCKET);\n    if(result)\n      return result;\n  }\n  Curl_pp_init(pp); \n  pp->response_time = RESP_TIMEOUT; \n  pp->statemach_act = smtp_statemach_act;\n  pp->endofresp = smtp_endofresp;\n  pp->conn = conn;\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof localhost))\n      path = localhost;\n    else\n      path = \"localhost\";\n  }\n  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n  if(!smtpc->domain)\n    return CURLE_OUT_OF_MEMORY;\n  state(conn, SMTP_SERVERGREET);\n  if(data->state.used_interface == Curl_if_multi)\n    result = smtp_multi_statemach(conn, done);\n  else {\n    result = smtp_easy_statemach(conn);\n    if(!result)\n      *done = TRUE;\n  }\n  return result;\n}", "target": 1}
{"code": "check_SET_VLAN_PCP(struct ofpact_vlan_pcp *a, struct ofpact_check_params *cp)\n{\n    ovs_be16 *tci = &cp->match->flow.vlans[0].tci;\n    a->flow_has_vlan = (*tci & htons(VLAN_CFI)) != 0;\n    if (!a->flow_has_vlan && !a->push_vlan_if_needed) {\n        inconsistent_match(&cp->usable_protocols);\n    }\n    *tci |= htons(VLAN_CFI);\n    return 0;\n}", "target": 0}
{"code": "int jsi_PstateSetFile(jsi_Pstate *ps, Jsi_Channel fp, int skipbang)\n{\n    jsi_Lexer *l = ps->lexer;\n    jsi_PstateClear(ps);\n    l->ltype = LT_FILE;\n    l->d.fp = fp;\n    Jsi_Rewind(ps->interp, fp);\n    if (skipbang) {\n        char buf[1000];\n        if (Jsi_Gets(ps->interp, fp, buf, 1000) && (buf[0] != '#' || buf[1] != '!')) {\n            Jsi_Rewind(ps->interp, fp);\n        }\n    }\n    return JSI_OK;\n}", "target": 1}
{"code": "double Item_cache_str::val_real()\n{\n  DBUG_ASSERT(fixed == 1);\n  int err_not_used;\n  char *end_not_used;\n  if (!has_value())\n    return 0.0;\n  if (value)\n    return my_strntod(value->charset(), (char*) value->ptr(),\n\t\t      value->length(), &end_not_used, &err_not_used);\n  return (double) 0;\n}", "target": 0}
{"code": "qedi_dbg_info(struct qedi_dbg_ctx *qedi, const char *func, u32 line,\n\t      u32 level, const char *fmt, ...)\n{\n\tva_list va;\n\tstruct va_format vaf;\n\tchar nfunc[32];\n\tmemset(nfunc, 0, sizeof(nfunc));\n\tmemcpy(nfunc, func, sizeof(nfunc) - 1);\n\tva_start(va, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &va;\n\tif (!(qedi_dbg_log & level))\n\t\tgoto ret;\n\tif (likely(qedi) && likely(qedi->pdev))\n\t\tpr_info(\"[%s]:[%s:%d]:%d: %pV\", dev_name(&qedi->pdev->dev),\n\t\t\tnfunc, line, qedi->host_no, &vaf);\n\telse\n\t\tpr_info(\"[0000:00:00.0]:[%s:%d]: %pV\", nfunc, line, &vaf);\nret:\n\tva_end(va);\n}", "target": 1}
{"code": "bool_t xdr_nullstring(XDR *xdrs, char **objp)\n{\n     u_int size;\n     if (xdrs->x_op == XDR_ENCODE) {\n\t  if (*objp == NULL)\n\t       size = 0;\n\t  else\n\t       size = strlen(*objp) + 1;\n     }\n     if (! xdr_u_int(xdrs, &size)) {\n\t  return FALSE;\n\t}\n     switch (xdrs->x_op) {\n     case XDR_DECODE:\n\t  if (size == 0) {\n\t       *objp = NULL;\n\t       return TRUE;\n\t  } else if (*objp == NULL) {\n\t       *objp = (char *) mem_alloc(size);\n\t       if (*objp == NULL) {\n\t\t    errno = ENOMEM;\n\t\t    return FALSE;\n\t       }\n\t  }\n\t  return (xdr_opaque(xdrs, *objp, size));\n     case XDR_ENCODE:\n\t  if (size != 0)\n\t       return (xdr_opaque(xdrs, *objp, size));\n\t  return TRUE;\n     case XDR_FREE:\n\t  if (*objp != NULL)\n\t       mem_free(*objp, size);\n\t  *objp = NULL;\n\t  return TRUE;\n     }\n     return FALSE;\n}", "target": 1}
{"code": "static void smb_set_posix_lock_done(struct tevent_req *subreq)\n{\n\tstruct smb_request *req = NULL;\n\tNTSTATUS status;\n\tbool ok;\n\tok = smbd_smb1_do_locks_extract_smbreq(subreq, talloc_tos(), &req);\n\tSMB_ASSERT(ok);\n\tstatus = smbd_smb1_do_locks_recv(subreq);\n\tTALLOC_FREE(subreq);\n\tif (NT_STATUS_IS_OK(status)) {\n\t\tchar params[2] = {0};\n\t\tsend_trans2_replies(\n\t\t\treq->conn,\n\t\t\treq,\n\t\t\tNT_STATUS_OK,\n\t\t\tparams,\n\t\t\t2,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\t0xffff);\n\t} else {\n\t\treply_nterror(req, status);\n\t\tok = srv_send_smb(\n\t\t\treq->xconn,\n\t\t\t(char *)req->outbuf,\n\t\t\ttrue,\n\t\t\treq->seqnum+1,\n\t\t\tIS_CONN_ENCRYPTED(req->conn),\n\t\t\tNULL);\n\t\tif (!ok) {\n\t\t\texit_server_cleanly(\"smb_set_posix_lock_done: \"\n\t\t\t\t\t    \"srv_send_smb failed.\");\n\t\t}\n\t}\n\tTALLOC_FREE(req);\n\treturn;\n}", "target": 0}
{"code": "static int dns_resolver_match_preparse(struct key_match_data *match_data)\n{\n\tmatch_data->lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE;\n\tmatch_data->cmp = dns_resolver_cmp;\n\treturn 0;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    Jsi_Obj *obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); ov = Jsi_ValueNew(interp); }\n        Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0);\n    }\n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}", "target": 1}
{"code": "static void parse_content_range(URLContext *h, const char *p)\n{\n    HTTPContext *s = h->priv_data;\n    const char *slash;\n    if (!strncmp(p, \"bytes \", 6)) {\n        p     += 6;\n        s->off = strtoll(p, NULL, 10);\n        if ((slash = strchr(p, '/')) && strlen(slash) > 0)\n            s->filesize = strtoll(slash + 1, NULL, 10);\n    }\n    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))\n        h->is_streamed = 0; \n}", "target": 1}
{"code": "TEST(BCastTest, Basic_Tensor_Scalar) {\n  EXPECT_EQ(BCast({11, 7, 5, 3, 2}, {1}),\n            \"[2310][1][1][2310]\"\n            \"[2310]\"\n            \"[11,7,5,3,2]\"\n            \"[][0,1,2,3,4]\");\n  EXPECT_EQ(BCast({11, 7, 5, 3, 2}, {1}, false),\n            \"[11,7,5,3,2][1,1,1,1,1][1,1,1,1,1][11,7,5,3,2]\"\n            \"[11,7,5,3,2]\"\n            \"[11,7,5,3,2]\"\n            \"[][0,1,2,3,4]\");\n  EXPECT_EQ(BCast({1}, {11, 7, 5, 3, 2}),\n            \"[1][2310][2310][1]\"\n            \"[2310]\"\n            \"[11,7,5,3,2]\"\n            \"[0,1,2,3,4][]\");\n  EXPECT_EQ(BCast({1}, {11, 7, 5, 3, 2}, false),\n            \"[1,1,1,1,1][11,7,5,3,2][11,7,5,3,2][1,1,1,1,1]\"\n            \"[11,7,5,3,2]\"\n            \"[11,7,5,3,2]\"\n            \"[0,1,2,3,4][]\");\n  EXPECT_EQ(BCast({1, 2147483648}, {1}),\n            \"[2147483648][1][1][2147483648]\"\n            \"[2147483648]\"\n            \"[1,2147483648]\"\n            \"[0][0,1]\");\n}", "target": 0}
{"code": "PHP_FUNCTION(pg_escape_identifier)\n{\n\tphp_pgsql_escape_internal(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}", "target": 0}
{"code": "BOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \"client authentication failure\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\treturn TRUE;\n}", "target": 0}
{"code": "int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host,\n\t\t\t\tu8 event, struct sk_buff *skb)\n{\n\tint r = 0;\n\tstruct device *dev = &hdev->ndev->dev;\n\tstruct nfc_evt_transaction *transaction;\n\tpr_debug(\"connectivity gate event: %x\\n\", event);\n\tswitch (event) {\n\tcase ST21NFCA_EVT_CONNECTIVITY:\n\t\tr = nfc_se_connectivity(hdev->ndev, host);\n\tbreak;\n\tcase ST21NFCA_EVT_TRANSACTION:\n\t\tif (skb->len < NFC_MIN_AID_LENGTH + 2 &&\n\t\t    skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL);\n\t\tif (!transaction)\n\t\t\treturn -ENOMEM;\n\t\ttransaction->aid_len = skb->data[1];\n\t\tif (transaction->aid_len > sizeof(transaction->aid))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->aid, &skb->data[2],\n\t\t       transaction->aid_len);\n\t\tif (skb->data[transaction->aid_len + 2] !=\n\t\t    NFC_EVT_TRANSACTION_PARAMS_TAG)\n\t\t\treturn -EPROTO;\n\t\ttransaction->params_len = skb->data[transaction->aid_len + 3];\n\t\tif (transaction->params_len > ((skb->len - 2) - sizeof(struct nfc_evt_transaction)))\n\t\t\treturn -EINVAL;\n\t\tmemcpy(transaction->params, skb->data +\n\t\t       transaction->aid_len + 4, transaction->params_len);\n\t\tr = nfc_se_transaction(hdev->ndev, host, transaction);\n\tbreak;\n\tdefault:\n\t\tnfc_err(&hdev->ndev->dev, \"Unexpected event on connectivity gate\\n\");\n\t\treturn 1;\n\t}\n\tkfree_skb(skb);\n\treturn r;\n}", "target": 0}
{"code": "REDIS_STATIC int _quicklistNodeAllowMerge(const quicklistNode *a,\n                                          const quicklistNode *b,\n                                          const int fill) {\n    if (!a || !b)\n        return 0;\n    unsigned int merge_sz = a->sz + b->sz - 11;\n    if (likely(_quicklistNodeSizeMeetsOptimizationRequirement(merge_sz, fill)))\n        return 1;\n    else if (!sizeMeetsSafetyLimit(merge_sz))\n        return 0;\n    else if ((int)(a->count + b->count) <= fill)\n        return 1;\n    else\n        return 0;\n}", "target": 0}
{"code": "static DexString *dex_string_new(RzBuffer *buf, ut64 offset, st64 *pread) {\n\tut64 size = 0;\n\tchar *data = NULL;\n\tst64 read;\n\tDexString *string = NULL;\n\tread = rz_buf_uleb128(buf, &size);\n\tif (UT64_ADD_OVFCHK(size, 1)) {\n\t\treturn NULL;\n\t}\n\tdata = malloc(size + 1);\n\tif (!data || rz_buf_read(buf, (ut8 *)data, size) != size) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\tdata[size] = 0;\n\tstring = RZ_NEW0(DexString);\n\tif (!string) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\t*pread = read;\n\tstring->size = size;\n\tstring->offset = offset;\n\tstring->data = data;\n\treturn string;\n}", "target": 0}
{"code": "static int client_mpvio_read_packet(struct st_plugin_vio *mpv, uchar **buf)\n{\n  MCPVIO_EXT *mpvio= (MCPVIO_EXT*)mpv;\n  MYSQL *mysql= mpvio->mysql;\n  ulong  pkt_len;\n  if (mpvio->cached_server_reply.pkt)\n  {\n    *buf= mpvio->cached_server_reply.pkt;\n    mpvio->cached_server_reply.pkt= 0;\n    mpvio->packets_read++;\n    return mpvio->cached_server_reply.pkt_len;\n  }\n  if (mpvio->packets_read == 0)\n  {\n    if (client_mpvio_write_packet(mpv, 0, 0))\n      return (int)packet_error;\n  }\n  pkt_len= (*mysql->methods->read_change_user_result)(mysql);\n  mpvio->last_read_packet_len= pkt_len;\n  *buf= mysql->net.read_pos;\n  if (pkt_len == packet_error || **buf == 254)\n    return (int)packet_error; \n  if (pkt_len && **buf == 1)\n  {\n    (*buf)++;\n    pkt_len--;\n  }\n  mpvio->packets_read++;\n  return pkt_len;\n}", "target": 0}
{"code": "Http::FilterTrailersStatus Context::onRequestTrailers() {\n  if (!wasm_->onRequestTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onRequestTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}", "target": 1}
{"code": "void FrameLoader::frameDetached()\n{\n    stopAllLoaders();\n    m_frame->document()->stopActiveDOMObjects();\n    detachFromParent();\n}", "target": 0}
{"code": "u64 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,\n\t\t\t\t  __be16 sport, __be16 dport)\n{\n\tu32 secret[MD5_MESSAGE_BYTES / 4];\n\tu32 hash[MD5_DIGEST_WORDS];\n\tu64 seq;\n\tu32 i;\n\tmemcpy(hash, saddr, 16);\n\tfor (i = 0; i < 4; i++)\n\t\tsecret[i] = net_secret[i] + daddr[i];\n\tsecret[4] = net_secret[4] +\n\t\t(((__force u16)sport << 16) + (__force u16)dport);\n\tfor (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)\n\t\tsecret[i] = net_secret[i];\n\tmd5_transform(hash, secret);\n\tseq = hash[0] | (((u64)hash[1]) << 32);\n\tseq += ktime_to_ns(ktime_get_real());\n\tseq &= (1ull << 48) - 1;\n\treturn seq;\n}", "target": 0}
{"code": "static void log_handler(uint32_t level, const char *msg, void *arg)\n{\n\tfprintf(stdout, msg, arg);\n}", "target": 0}
{"code": "static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) {\n\tif (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) {\n\t\treturn NULL;\n\t}\n\tut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL);\n\tif (!offset) {\n\t\treturn NULL;\n\t}\n\tut64 size = sizeof (cache_accel_t);\n\tcache_accel_t *accel = R_NEW0 (cache_accel_t);\n\tif (!accel) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_fread_at (cache_buf, offset, (ut8*) accel, \"16il\", 1) != size) {\n\t\tR_FREE (accel);\n\t\treturn NULL;\n\t}\n\taccel->imagesExtrasOffset += offset;\n\taccel->bottomUpListOffset += offset;\n\taccel->dylibTrieOffset += offset;\n\taccel->initializersOffset += offset;\n\taccel->dofSectionsOffset += offset;\n\taccel->reExportListOffset += offset;\n\taccel->depListOffset += offset;\n\taccel->rangeTableOffset += offset;\n\treturn accel;\n}", "target": 1}
{"code": "int megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\tmax_cmd = instance->max_mfi_cmds;\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!instance->cmd_list[i]) {\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}", "target": 0}
{"code": "static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)\n{\n\treturn crypto_skcipher_setkey(private, key, keylen);\n}", "target": 1}
{"code": "\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\tif (edit && !edit->dead_leaf) {\n\t\tkey_payload_reserve(keyring,\n\t\t\t\t    keyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}", "target": 1}
{"code": "static int parse_import_ptr(struct MACH0_(obj_t)* bin, struct reloc_t *reloc, int idx) {\n\tint i, j, sym, wordsize;\n\tut32 stype;\n\twordsize = MACH0_(get_bits)(bin) / 8;\n\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\treturn 0;\n\t}\n\tif ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {\n\t\tstype = S_LAZY_SYMBOL_POINTERS;\n\t} else {\n\t\tstype = S_NON_LAZY_SYMBOL_POINTERS;\n\t}\n\treloc->offset = 0;\n\treloc->addr = 0;\n\treloc->addend = 0;\n#define CASE(T) case (T / 8): reloc->type = R_BIN_RELOC_ ## T; break\n\tswitch (wordsize) {\n\t\tCASE(8);\n\t\tCASE(16);\n\t\tCASE(32);\n\t\tCASE(64);\n\t\tdefault: return false;\n\t}\n#undef CASE\n\tfor (i = 0; i < bin->nsects; i++) {\n\t\tif ((bin->sects[i].flags & SECTION_TYPE) == stype) {\n\t\t\tfor (j=0, sym=-1; bin->sects[i].reserved1+j < bin->nindirectsyms; j++)\n\t\t\t\tif (idx == bin->indirectsyms[bin->sects[i].reserved1 + j]) {\n\t\t\t\t\tsym = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\treloc->offset = sym == -1 ? 0 : bin->sects[i].offset + sym * wordsize;\n\t\t\treloc->addr = sym == -1 ? 0 : bin->sects[i].addr + sym * wordsize;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_n( pj_scanner *scanner,\n\t\t\t    unsigned N, pj_str_t *out)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    pj_strset(out, scanner->curptr, N);\n    scanner->curptr += N;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "static void do_proc_open(FILE *fin, FILE *fout, int afdt_fd) {\n  char cmd[BUFFER_SIZE];\n  read_buf(fin, cmd);\n  if (strlen(cmd) == 0) {\n    fprintf(fout, \"error\\n%d\\n\", ENOENT);\n    fflush(fout);\n    return;\n  }\n  char cwd[BUFFER_SIZE];\n  read_buf(fin, cwd);\n  char buf[BUFFER_SIZE];\n  int env_size = 0;\n  std::vector<std::string> env;\n  read_buf(fin, buf);\n  sscanf(buf, \"%d\", &env_size);\n  for (int i = 0; i < env_size; i++) {\n    read_buf(fin, buf);\n    env.push_back(buf);\n  }\n  int pipe_size = 0;\n  read_buf(fin, buf);\n  sscanf(buf, \"%d\", &pipe_size);\n  std::vector<int> pvals;\n  for (int i = 0; i < pipe_size; i++) {\n    int fd_value;\n    read_buf(fin, buf);\n    sscanf(buf, \"%d\", &fd_value);\n    pvals.push_back(fd_value);\n  }\n  std::vector<int> pkeys;\n  for (int i = 0; i < pipe_size; i++) {\n    int fd = recv_fd(afdt_fd);\n    if (fd < 0) {\n      fprintf(fout, \"error\\n%d\\n\", EPROTO);\n      fflush(fout);\n      close_fds(pkeys);\n      return;\n    }\n    pkeys.push_back(fd);\n  }\n  pid_t child = fork();\n  if (child == 0) {\n    for (int i = 0; i < pipe_size; i++) {\n      dup2(pkeys[i], pvals[i]);\n    }\n    if (strlen(cwd) > 0 && chdir(cwd)) {\n    }\n    if (!env.empty()) {\n      char **envp = build_envp(env);\n      execle(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr, envp);\n      free(envp);\n    } else {\n      execl(\"/bin/sh\", \"sh\", \"-c\", cmd, nullptr);\n    }\n    _exit(127);\n  } else if (child > 0) {\n    fprintf(fout, \"%\" PRId64 \"\\n\", (int64_t)child);\n    fflush(fout);\n  } else {\n    fprintf(fout, \"error\\n%d\\n\", errno);\n    fflush(fout);\n  }\n  close_fds(pkeys);\n}", "target": 1}
{"code": "int ext4_resize_begin(struct super_block *sb)\n{\n\tint ret = 0;\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tif (EXT4_SB(sb)->s_mount_state & EXT4_ERROR_FS) {\n\t\text4_warning(sb, \"There are errors in the filesystem, \"\n\t\t\t     \"so online resizing is not allowed\\n\");\n\t\treturn -EPERM;\n\t}\n\tif (test_and_set_bit_lock(EXT4_RESIZING, &EXT4_SB(sb)->s_resize_flags))\n\t\tret = -EBUSY;\n\treturn ret;\n}", "target": 0}
{"code": "static int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_CACHE_SHIFT;\n\tfrom = pos & (PAGE_CACHE_SIZE - 1);\n\tto = from + len;\nretry:\n\thandle = ext4_journal_start(inode, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out;\n\t}\n\tflags |= AOP_FLAG_NOFS;\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\text4_journal_stop(handle);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t*pagep = page;\n\tret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\text4_get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\t}\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\nout:\n\treturn ret;\n}", "target": 1}
{"code": "int dbFree(struct inode *ip, s64 blkno, s64 nblocks)\n{\n\tstruct metapage *mp;\n\tstruct dmap *dp;\n\tint nb, rc;\n\ts64 lblkno, rem;\n\tstruct inode *ipbmap = JFS_SBI(ip->i_sb)->ipbmap;\n\tstruct bmap *bmp = JFS_SBI(ip->i_sb)->bmap;\n\tstruct super_block *sb = ipbmap->i_sb;\n\tIREAD_LOCK(ipbmap, RDWRLOCK_DMAP);\n\tif (unlikely((blkno == 0) || (blkno + nblocks > bmp->db_mapsize))) {\n\t\tIREAD_UNLOCK(ipbmap);\n\t\tprintk(KERN_ERR \"blkno = %Lx, nblocks = %Lx\\n\",\n\t\t       (unsigned long long) blkno,\n\t\t       (unsigned long long) nblocks);\n\t\tjfs_error(ip->i_sb, \"block to be freed is outside the map\\n\");\n\t\treturn -EIO;\n\t}\n\tif (JFS_SBI(sb)->flag & JFS_DISCARD)\n\t\tif (JFS_SBI(sb)->minblks_trim <= nblocks)\n\t\t\tjfs_issue_discard(ipbmap, blkno, nblocks);\n\tmp = NULL;\n\tfor (rem = nblocks; rem > 0; rem -= nb, blkno += nb) {\n\t\tif (mp) {\n\t\t\twrite_metapage(mp);\n\t\t}\n\t\tlblkno = BLKTODMAP(blkno, bmp->db_l2nbperpage);\n\t\tmp = read_metapage(ipbmap, lblkno, PSIZE, 0);\n\t\tif (mp == NULL) {\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn -EIO;\n\t\t}\n\t\tdp = (struct dmap *) mp->data;\n\t\tnb = min(rem, BPERDMAP - (blkno & (BPERDMAP - 1)));\n\t\tif ((rc = dbFreeDmap(bmp, dp, blkno, nb))) {\n\t\t\tjfs_error(ip->i_sb, \"error in block map\\n\");\n\t\t\trelease_metapage(mp);\n\t\t\tIREAD_UNLOCK(ipbmap);\n\t\t\treturn (rc);\n\t\t}\n\t}\n\twrite_metapage(mp);\n\tIREAD_UNLOCK(ipbmap);\n\treturn (0);\n}", "target": 1}
{"code": "static int nr_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tlock_sock(sk);\n\tif (sock->state != SS_UNCONNECTED) {\n\t\trelease_sock(sk);\n\t\treturn -EINVAL;\n\t}\n\tif (sk->sk_state != TCP_LISTEN) {\n\t\tmemset(&nr_sk(sk)->user_addr, 0, AX25_ADDR_LEN);\n\t\tsk->sk_max_ack_backlog = backlog;\n\t\tsk->sk_state           = TCP_LISTEN;\n\t\trelease_sock(sk);\n\t\treturn 0;\n\t}\n\trelease_sock(sk);\n\treturn -EOPNOTSUPP;\n}", "target": 0}
{"code": "        int          GetS16BE (int nPos, bool *pbSuccess)\n        {\n            if ( nPos < 0 || nPos + 1 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[nPos];\n            nRes = (nRes << 8) + m_sFile[ nPos + 1 ];\n            if ( nRes & 0x8000 )\n                nRes |= ~0xffff;\n            return nRes;\n        }", "target": 1}
{"code": "static void handle_put_publish(struct http_conn *conn,\n\t\t\t       const struct http_msg *msg,\n\t\t\t       struct mbuf *mb, size_t clen)\n{\n\tstruct ident_entry *ie = NULL;\n\tstruct pl pl;\n\tchar *key = NULL;\n\tint err;\n\terr = re_regex(msg->prm.p, msg->prm.l, \"?pairid=[0-9]+\", &pl);\n\tif (err) {\n\t\twarning(\"invalid input\\n\");\n\t\tgoto out;\n\t}\n\tpl_strdup(&key, &pl);\n\tie = dict_lookup(verifyd.idents, key);\n\tif (!ie) {\n\t\tinfo(\"publish: pairing-id %s not found\\n\", key);\n\t\thttp_ereply(conn, 404, \"Not found\");\n\t\tgoto out;\n\t}\n\tdebug(\"publish: saving content(%zu): %b\\n\",\n\t\t  clen, mbuf_buf(mb), mbuf_get_left(mb));\n\tmbuf_strdup(mb, &ie->content.publish, clen);\n\thttp_reply(conn, 200, \"OK\", NULL);\n\thttp_conn_close(conn);\n out:\n\tmem_deref(key);\n}", "target": 0}
{"code": "static int __poke_user(struct task_struct *child, addr_t addr, addr_t data)\n{\n\tstruct user *dummy = NULL;\n\taddr_t offset;\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT\n\t\tif (addr == (addr_t) &dummy->regs.acrs[15])\n\t\t\tchild->thread.acrs[15] = (unsigned int) (data >> 32);\n\t\telse\n#endif\n\t\t*(addr_t *)((addr_t) &child->thread.acrs + offset) = data;\n\t} else if (addr == (addr_t) &dummy->regs.orig_gpr2) {\n\t\ttask_pt_regs(child)->orig_gpr2 = data;\n\t} else if (addr < (addr_t) &dummy->regs.fp_regs) {\n\t\treturn 0;\n\t} else if (addr < (addr_t) (&dummy->regs.fp_regs + 1)) {\n\t\tif (addr == (addr_t) &dummy->regs.fp_regs.fpc)\n\t\t\tif ((unsigned int) data != 0 ||\n\t\t\t    test_fp_ctl(data >> (BITS_PER_LONG - 32)))\n\t\t\t\treturn -EINVAL;\n\t\toffset = addr - (addr_t) &dummy->regs.fp_regs;\n\t\t*(addr_t *)((addr_t) &child->thread.fp_regs + offset) = data;\n\t} else if (addr < (addr_t) (&dummy->regs.per_info + 1)) {\n\t\taddr -= (addr_t) &dummy->regs.per_info;\n\t\t__poke_user_per(child, addr, data);\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int LibRaw::minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n  fseek(ifp, -sizeof tail, SEEK_END);\n  fread(tail, 1, sizeof tail, ifp);\n  for (nz = i = 0; i < sizeof tail; i++)\n    if (tail[i])\n      nz++;\n  return nz > 20;\n}", "target": 0}
{"code": "_forceinline void Unpack::CopyString(uint Length,uint Distance)\n{\n  size_t SrcPtr=UnpPtr-Distance;\n  if (SrcPtr<MaxWinSize-MAX_LZ_MATCH && UnpPtr<MaxWinSize-MAX_LZ_MATCH)\n  {\n    byte *Src=Window+SrcPtr;\n    byte *Dest=Window+UnpPtr;\n    UnpPtr+=Length;\n#ifdef FAST_MEMCPY\n    if (Distance<Length) \n#endif\n      while (Length>=8)\n      {\n        Dest[0]=Src[0];\n        Dest[1]=Src[1];\n        Dest[2]=Src[2];\n        Dest[3]=Src[3];\n        Dest[4]=Src[4];\n        Dest[5]=Src[5];\n        Dest[6]=Src[6];\n        Dest[7]=Src[7];\n        Src+=8;\n        Dest+=8;\n        Length-=8;\n      }\n#ifdef FAST_MEMCPY\n    else\n      while (Length>=8)\n      {\n        memcpy(Dest,Src,8); \n        Src+=8;\n        Dest+=8;\n        Length-=8;\n      }\n#endif\n    if (Length>0) { Dest[0]=Src[0];\n    if (Length>1) { Dest[1]=Src[1];\n    if (Length>2) { Dest[2]=Src[2];\n    if (Length>3) { Dest[3]=Src[3];\n    if (Length>4) { Dest[4]=Src[4];\n    if (Length>5) { Dest[5]=Src[5];\n    if (Length>6) { Dest[6]=Src[6]; } } } } } } } \n  }\n  else\n    while (Length-- > 0) \n    {\n      Window[UnpPtr]=Window[SrcPtr++ & MaxWinMask];\n      UnpPtr=(UnpPtr+1) & MaxWinMask;\n    }\n}", "target": 1}
{"code": "const char * RtmpProtocol::handle_C0C1(const char *data, size_t len) {\n    if (len < 1 + C1_HANDSHARK_SIZE) {\n        return nullptr;\n    }\n    if (data[0] != HANDSHAKE_PLAINTEXT) {\n        throw std::runtime_error(\"only plaintext[0x03] handshake supported\");\n    }\n    if (memcmp(data + 5, \"\\x00\\x00\\x00\\x00\", 4) == 0) {\n        handle_C1_simple(data);\n    } else {\n#ifdef ENABLE_OPENSSL\n        handle_C1_complex(data);\n#else\n        WarnL << \"ENABLE_OPENSSLflash\";\n        handle_C1_simple(data);\n#endif\n    }\n    return data + 1 + C1_HANDSHARK_SIZE;\n}", "target": 0}
{"code": "TEST(ComparisonsTest,\n     QuantizedInt8GreaterWithBroadcastMultiplierGreaterThanOne) {\n  const float kMin = -127.f;\n  const float kMax = 127.f;\n  std::vector<std::vector<int>> test_shapes = {\n      {6}, {2, 3}, {2, 1, 3}, {1, 3, 1, 2}};\n  for (int i = 0; i < test_shapes.size(); ++i) {\n    ComparisonOpModel model({TensorType_INT8, test_shapes[i], kMin, kMax},\n                            {TensorType_INT8, {}, kMin, kMax}, TensorType_INT8,\n                            BuiltinOperator_GREATER);\n    model.QuantizeAndPopulate<int8_t>(model.input1(),\n                                      {572, -2, -71, 8, 11, 20});\n    model.QuantizeAndPopulate<int8_t>(model.input2(), {8});\n    model.Invoke();\n    EXPECT_THAT(model.GetOutput(),\n                ElementsAre(true, false, false, false, true, true))\n        << \"With shape number \" << i;\n  }\n}", "target": 0}
{"code": "lyd_new(struct lyd_node *parent, const struct lys_module *module, const char *name)\n{\n    const struct lys_node *snode = NULL, *siblings;\n    if ((!parent && !module) || !name) {\n        LOGARG;\n        return NULL;\n    }\n    siblings = lyd_new_find_schema(parent, module, 0);\n    if (!siblings) {\n        LOGARG;\n        return NULL;\n    }\n    if (lys_getnext_data(module, lys_parent(siblings), name, strlen(name), LYS_CONTAINER | LYS_LIST | LYS_NOTIF\n                         | LYS_RPC | LYS_ACTION, &snode) || !snode) {\n        LOGERR(siblings->module->ctx, LY_EINVAL, \"Failed to find \\\"%s\\\" as a sibling to \\\"%s:%s\\\".\",\n               name, lys_node_module(siblings)->name, siblings->name);\n        return NULL;\n    }\n    return _lyd_new(parent, snode, 0);\n}", "target": 1}
{"code": "void IndexedDBDatabase::RenameObjectStore(IndexedDBTransaction* transaction,\n                                          int64_t object_store_id,\n                                          const base::string16& new_name) {\n  DCHECK(transaction);\n  IDB_TRACE1(\"IndexedDBDatabase::RenameObjectStore\", \"txn.id\",\n             transaction->id());\n  DCHECK_EQ(transaction->mode(),\n            blink::mojom::IDBTransactionMode::VersionChange);\n  if (!ValidateObjectStoreId(object_store_id))\n    return;\n  IndexedDBObjectStoreMetadata& object_store_metadata =\n      metadata_.object_stores[object_store_id];\n  base::string16 old_name;\n  Status s = metadata_coding_->RenameObjectStore(\n      transaction->BackingStoreTransaction()->transaction(),\n      transaction->database()->id(), new_name, &old_name,\n      &object_store_metadata);\n  if (!s.ok()) {\n    ReportErrorWithDetails(s, \"Internal error renaming object store.\");\n    return;\n  }\n  DCHECK_EQ(object_store_metadata.name, new_name);\n  transaction->ScheduleAbortTask(\n      base::BindOnce(&IndexedDBDatabase::RenameObjectStoreAbortOperation, this,\n                     object_store_id, std::move(old_name)));\n}", "target": 0}
{"code": "static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\n\t\t\t   unsigned int cryptlen)\n{\n\tstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\n\tstruct crypto_aead *aead = crypto_aead_reqtfm(req);\n\tstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\n\tAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\n\tunsigned int assoclen = req->assoclen;\n\tstruct scatterlist sg[3];\n\tu8 odata[16];\n\tu8 idata[16];\n\tint ilen, err;\n\terr = format_input(odata, req, cryptlen);\n\tif (err)\n\t\tgoto out;\n\tsg_init_table(sg, 3);\n\tsg_set_buf(&sg[0], odata, 16);\n\tif (assoclen) {\n\t\tilen = format_adata(idata, assoclen);\n\t\tsg_set_buf(&sg[1], idata, ilen);\n\t\tsg_chain(sg, 3, req->src);\n\t} else {\n\t\tilen = 0;\n\t\tsg_chain(sg, 2, req->src);\n\t}\n\tahash_request_set_tfm(ahreq, ctx->mac);\n\tahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\n\tahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\n\terr = crypto_ahash_init(ahreq);\n\tif (err)\n\t\tgoto out;\n\terr = crypto_ahash_update(ahreq);\n\tif (err)\n\t\tgoto out;\n\tilen = 16 - (assoclen + ilen) % 16;\n\tif (ilen < 16) {\n\t\tmemset(idata, 0, ilen);\n\t\tsg_init_table(sg, 2);\n\t\tsg_set_buf(&sg[0], idata, ilen);\n\t\tif (plain)\n\t\t\tsg_chain(sg, 2, plain);\n\t\tplain = sg;\n\t\tcryptlen += ilen;\n\t}\n\tahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\n\terr = crypto_ahash_finup(ahreq);\nout:\n\treturn err;\n}", "target": 1}
{"code": "process_request_identities(SocketEntry *e)\n{\n\tIdentity *id;\n\tstruct sshbuf *msg, *keys;\n\tint r;\n\tu_int nentries = 0;\n\tdebug2_f(\"entering\");\n\tif ((msg = sshbuf_new()) == NULL || (keys = sshbuf_new()) == NULL)\n\t\tfatal_f(\"sshbuf_new failed\");\n\tTAILQ_FOREACH(id, &idtab->idlist, next) {\n\t\tif (identity_permitted(id, e, NULL, NULL, NULL) != 0)\n\t\t\tcontinue;\n\t\tif ((r = sshkey_puts_opts(id->key, keys,\n\t\t    SSHKEY_SERIALIZE_INFO)) != 0 ||\n\t\t    (r = sshbuf_put_cstring(keys, id->comment)) != 0) {\n\t\t\terror_fr(r, \"compose key/comment\");\n\t\t\tcontinue;\n\t\t}\n\t\tnentries++;\n\t}\n\tdebug2_f(\"replying with %u allowed of %u available keys\",\n\t    nentries, idtab->nentries);\n\tif ((r = sshbuf_put_u8(msg, SSH2_AGENT_IDENTITIES_ANSWER)) != 0 ||\n\t    (r = sshbuf_put_u32(msg, nentries)) != 0 ||\n\t    (r = sshbuf_putb(msg, keys)) != 0)\n\t\tfatal_fr(r, \"compose\");\n\tif ((r = sshbuf_put_stringb(e->output, msg)) != 0)\n\t\tfatal_fr(r, \"enqueue\");\n\tsshbuf_free(msg);\n\tsshbuf_free(keys);\n}", "target": 1}
{"code": "get_next_file(FILE *VFile, char *ptr)\n{\n\tchar *ret;\n\tret = fgets(ptr, PATH_MAX, VFile);\n\tif (!ret)\n\t\treturn NULL;\n\tif (ptr[strlen(ptr) - 1] == '\\n')\n\t\tptr[strlen(ptr) - 1] = '\\0';\n\treturn ret;\n}", "target": 1}
{"code": "    template<typename tp, typename tf, typename tc, typename to>\n    CImg<T>& draw_object3d(LibBoard::Board& board,\n                           const float x0, const float y0, const float z0,\n                           const CImg<tp>& vertices, const CImgList<tf>& primitives,\n                           const CImgList<tc>& colors, const CImgList<to>& opacities,\n                           const unsigned int render_type=4,\n                           const bool is_double_sided=false, const float focale=700,\n                           const float lightx=0, const float lighty=0, const float lightz=-5e8,\n                           const float specular_lightness=0.2f, const float specular_shininess=0.1f) {\n      return draw_object3d(board,x0,y0,z0,vertices,primitives,colors,opacities,render_type,\n                           is_double_sided,focale,lightx,lighty,lightz,\n                           specular_lightness,specular_shininess,CImg<floatT>::empty());", "target": 0}
{"code": "ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\ncleanup:\n\tbrelse(bh);\n\tup_write(&EXT2_I(inode)->xattr_sem);\n}", "target": 1}
{"code": "inline typename V::MapType FBUnserializer<V>::unserializeMap() {\n  p_ += CODE_SIZE;\n  typename V::MapType ret = V::createMap();\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    switch (code) {\n      case FB_SERIALIZE_VARCHAR:\n      case FB_SERIALIZE_STRING:\n        {\n          auto key = unserializeString();\n          auto value = unserializeThing();\n          V::mapSet(ret, std::move(key), std::move(value));\n        }\n        break;\n      default:\n        {\n          auto key = unserializeInt64();\n          auto value = unserializeThing();\n          V::mapSet(ret, std::move(key), std::move(value));\n        }\n    }\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}", "target": 1}
{"code": "void options_free() {\n    parse_global_option(CMD_FREE, NULL, NULL);\n}", "target": 1}
{"code": "rpmRC rpmReadPackageFile(rpmts ts, FD_t fd, const char * fn, Header * hdrp)\n{\n    char *msg = NULL;\n    Header h = NULL;\n    Header sigh = NULL;\n    hdrblob blob = NULL;\n    hdrblob sigblob = NULL;\n    rpmVSFlags vsflags = rpmtsVSFlags(ts) | RPMVSF_NEEDPAYLOAD;\n    rpmKeyring keyring = rpmtsGetKeyring(ts, 1);\n    struct rpmvs_s *vs = rpmvsCreate(0, vsflags, keyring);\n    struct pkgdata_s pkgdata = {\n\t.msgfunc = loghdrmsg,\n\t.fn = fn ? fn : Fdescr(fd),\n\t.msg = NULL,\n\t.rc = RPMRC_OK,\n    };\n    if (hdrp)\n\t*hdrp = NULL;\n    rpmRC rc = rpmpkgRead(vs, fd, &sigblob, &blob, &msg);\n    if (rc)\n\tgoto exit;\n    rc = RPMRC_FAIL;\n    if (!rpmvsVerify(vs, RPMSIG_VERIFIABLE_TYPE, handleHdrVS, &pkgdata)) {\n\tif (hdrp) {\n\t    if (hdrblobImport(sigblob, 0, &sigh, &msg))\n\t\tgoto exit;\n\t    if (hdrblobImport(blob, 0, &h, &msg))\n\t\tgoto exit;\n\t    headerMergeLegacySigs(h, sigh);\n\t    applyRetrofits(h);\n\t    *hdrp = headerLink(h);\n\t}\n\trc = RPMRC_OK;\n    }\n    if (rc == RPMRC_OK && pkgdata.rc)\n\trc = pkgdata.rc;\nexit:\n    if (rc && msg)\n\trpmlog(RPMLOG_ERR, \"%s: %s\\n\", Fdescr(fd), msg);\n    hdrblobFree(sigblob);\n    hdrblobFree(blob);\n    headerFree(sigh);\n    headerFree(h);\n    rpmKeyringFree(keyring);\n    rpmvsFree(vs);\n    free(msg);\n    return rc;\n}", "target": 1}
{"code": "TEST(TensorSliceReaderTest, InvalidTensorSlice) {\n  const string fname =\n      io::JoinPath(testing::TmpDir(), \"invalid_slice_checkpoint\");\n  TensorSliceWriter writer(fname, CreateTableTensorSliceBuilder);\n  const int32 data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n  TF_CHECK_OK(writer.Add(\"test\", TensorShape({4, 5}),\n                         TensorSlice::ParseOrDie(\"0,2:-\"), data));\n  TF_CHECK_OK(writer.Finish());\n  MutateSavedTensorSlices(fname, [](SavedTensorSlices sts) {\n    if (sts.has_meta()) {\n      for (auto& tensor : *sts.mutable_meta()->mutable_tensor()) {\n        tensor.mutable_slice(0)->mutable_extent(0)->set_length(-10);\n      }\n    }\n    return sts.SerializeAsString();\n  });\n  TensorSliceReader reader(fname, OpenTableTensorSliceReader);\n  EXPECT_FALSE(reader.status().ok());\n}", "target": 0}
{"code": "bool dir_has_correct_permissions(const char *dir_name)\n{\n    if (g_settings_privatereports)\n    {\n        struct stat statbuf;\n        if (lstat(dir_name, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode))\n        {\n            error_msg(\"Path '%s' isn't directory\", dir_name);\n            return false;\n        }\n        struct group *gr = getgrnam(\"abrt\");\n        if (!gr)\n        {\n            error_msg(\"Group 'abrt' does not exist\");\n            return false;\n        }\n        if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07)\n            return false;\n    }\n    return true;\n}", "target": 0}
{"code": "l2tp_result_code_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tND_PRINT((ndo, \"%u\", EXTRACT_16BITS(ptr))); ptr++;\t\n\tif (length > 2) {\t\t\t\t\n\t        ND_PRINT((ndo, \"/%u\", EXTRACT_16BITS(ptr))); ptr++;\n\t}\n\tif (length > 4) {\t\t\t\t\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length - 4);\n\t}\n}", "target": 1}
{"code": "\tCmdResult Handle (const std::vector<std::string>& parameters, User *user)\n\t{\n\t\tif (user->registered != REG_ALL)\n\t\t{\n\t\t\tif (!cap.ext.get(user))\n\t\t\t\treturn CMD_FAILURE;\n\t\t\tif (parameters[0].find(' ') != std::string::npos || parameters[0][0] == ':')\n\t\t\t\treturn CMD_FAILURE;\n\t\t\tSaslAuthenticator *sasl = authExt.get(user);\n\t\t\tif (!sasl)\n\t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0]));\n\t\t\telse if (sasl->SendClientMessage(parameters) == false)\t\n\t\t\t{\n\t\t\t\tsasl->AnnounceState();\n\t\t\t\tauthExt.unset(user);\n\t\t\t}\n\t\t}\n\t\treturn CMD_FAILURE;\n\t}", "target": 0}
{"code": "WebSharedWorker* RenderView::createSharedWorker(\n    WebFrame* frame, const WebURL& url, const WebString& name,\n    unsigned long long document_id) {\n  int route_id = MSG_ROUTING_NONE;\n  bool exists = false;\n  bool url_mismatch = false;\n  ViewHostMsg_CreateWorker_Params params;\n  params.url = url;\n  params.is_shared = true;\n  params.name = name;\n  params.document_id = document_id;\n  params.render_view_route_id = routing_id_;\n  params.route_id = MSG_ROUTING_NONE;\n  params.parent_appcache_host_id = 0;\n  params.script_resource_appcache_id = 0;\n  Send(new ViewHostMsg_LookupSharedWorker(\n      params, &exists, &route_id, &url_mismatch));\n  if (url_mismatch) {\n    return NULL;\n  } else {\n    return new WebSharedWorkerProxy(RenderThread::current(),\n                                    document_id,\n                                    exists,\n                                    route_id,\n                                    routing_id_);\n  }\n}", "target": 0}
{"code": "static jboolean Region_getBounds(JNIEnv* env, jobject, jlong regionHandle, jobject rectBounds) {\n SkRegion* region = reinterpret_cast<SkRegion*>(regionHandle);\n GraphicsJNI::irect_to_jrect(region->getBounds(), env, rectBounds);\n bool result = !region->isEmpty();\n return boolTojboolean(result);\n}", "target": 0}
{"code": "static bool ctx_single_port_submission(const struct intel_context *ce)\n{\n\treturn (IS_ENABLED(CONFIG_DRM_I915_GVT) &&\n\t\ti915_gem_context_force_single_submission(ce->gem_context));\n}", "target": 0}
{"code": "entityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: \n      default:\n        break;\n      }\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n      *nextPtr = next;\n      s = next;\n    }\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}", "target": 1}
{"code": "krb5_gss_process_context_token(minor_status, context_handle,\n                               token_buffer)\n    OM_uint32 *minor_status;\n    gss_ctx_id_t context_handle;\n    gss_buffer_t token_buffer;\n{\n    krb5_gss_ctx_id_rec *ctx;\n    OM_uint32 majerr;\n    ctx = (krb5_gss_ctx_id_t) context_handle;\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n    if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,\n                                     token_buffer,\n                                     GSS_C_NO_BUFFER, NULL, NULL,\n                                     KG_TOK_DEL_CTX)))\n        return(majerr);\n    return(krb5_gss_delete_sec_context(minor_status, &context_handle,\n                                       GSS_C_NO_BUFFER));\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_until_ch( pj_scanner *scanner, \n\t\t\t\t   int until_char, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    while (PJ_SCAN_CHECK_EOF(s) && *s != until_char) {\n\t++s;\n    }\n    pj_strset3(out, scanner->curptr, s);\n    scanner->curptr = s;\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}", "target": 1}
{"code": "date_s_new_bang(int argc, VALUE *argv, VALUE klass)\n{\n    VALUE ajd, of, sg, nth, sf;\n    int jd, df, rof;\n    double rsg;\n    rb_scan_args(argc, argv, \"03\", &ajd, &of, &sg);\n    switch (argc) {\n      case 0:\n\tajd = INT2FIX(0);\n      case 1:\n\tof = INT2FIX(0);\n      case 2:\n\tsg = INT2FIX(DEFAULT_SG);\n    }\n    old_to_new(ajd, of, sg,\n\t       &nth, &jd, &df, &sf, &rof, &rsg);\n    if (!df && f_zero_p(sf) && !rof)\n\treturn d_simple_new_internal(klass,\n\t\t\t\t     nth, jd,\n\t\t\t\t     rsg,\n\t\t\t\t     0, 0, 0,\n\t\t\t\t     HAVE_JD);\n    else\n\treturn d_complex_new_internal(klass,\n\t\t\t\t      nth, jd,\n\t\t\t\t      df, sf,\n\t\t\t\t      rof, rsg,\n\t\t\t\t      0, 0, 0,\n\t\t\t\t      0, 0, 0,\n\t\t\t\t      HAVE_JD | HAVE_DF);\n}", "target": 0}
{"code": "void GfxCalGrayColorSpace::getDefaultColor(GfxColor *color) const\n{\n    color->c[0] = 0;\n}", "target": 0}
{"code": "static int ipv6_route_open(struct inode *inode, struct file *file)\n{\n\treturn single_open_net(inode, file, ipv6_route_show);\n}", "target": 0}
{"code": "static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)\n{\n\tint ret;\n\tstruct k90_led *led = container_of(led_cdev, struct k90_led, cdev);\n\tstruct device *dev = led->cdev.dev->parent;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tint brightness;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_STATUS,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 8,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial state (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tbrightness = data[4];\n\tif (brightness < 0 || brightness > 3) {\n\t\tdev_warn(dev,\n\t\t\t \"Read invalid backlight brightness: %02hhx.\\n\",\n\t\t\t data[4]);\n\t\treturn -EIO;\n\t}\n\treturn brightness;\n}", "target": 1}
{"code": "sudo_auth_end_session(void)\n{\n    sudo_auth *auth;\n    int status;\n    debug_decl(sudo_auth_end_session, SUDOERS_DEBUG_AUTH);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->end_session && !IS_DISABLED(auth)) {\n\t    status = (auth->end_session)(auth);\n\t    if (status == AUTH_ERROR) {\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(1);\n}", "target": 1}
{"code": "lldp_mgmt_addr_tlv_print(netdissect_options *ndo,\n                         const u_char *pptr, u_int len)\n{\n    uint8_t mgmt_addr_len, intf_num_subtype, oid_len;\n    const u_char *tptr;\n    u_int tlen;\n    char *mgmt_addr;\n    tlen = len;\n    tptr = pptr;\n    if (tlen < 1) {\n        return 0;\n    }\n    mgmt_addr_len = *tptr++;\n    tlen--;\n    if (tlen < mgmt_addr_len) {\n        return 0;\n    }\n    mgmt_addr = lldp_network_addr_print(ndo, tptr, mgmt_addr_len);\n    if (mgmt_addr == NULL) {\n        return 0;\n    }\n    ND_PRINT((ndo, \"\\n\\t  Management Address length %u, %s\",\n           mgmt_addr_len, mgmt_addr));\n    tptr += mgmt_addr_len;\n    tlen -= mgmt_addr_len;\n    if (tlen < LLDP_INTF_NUM_LEN) {\n        return 0;\n    }\n    intf_num_subtype = *tptr;\n    ND_PRINT((ndo, \"\\n\\t  %s Interface Numbering (%u): %u\",\n           tok2str(lldp_intf_numb_subtype_values, \"Unknown\", intf_num_subtype),\n           intf_num_subtype,\n           EXTRACT_32BITS(tptr + 1)));\n    tptr += LLDP_INTF_NUM_LEN;\n    tlen -= LLDP_INTF_NUM_LEN;\n    if (tlen) {\n        oid_len = *tptr;\n        if (tlen < oid_len) {\n            return 0;\n        }\n        if (oid_len) {\n            ND_PRINT((ndo, \"\\n\\t  OID length %u\", oid_len));\n            safeputs(ndo, tptr + 1, oid_len);\n        }\n    }\n    return 1;\n}", "target": 1}
{"code": "NOEXPORT int ssl_tlsext_ticket_key_cb(SSL *ssl, unsigned char *key_name,\n        unsigned char *iv, EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc) {\n    CLI *c;\n    const EVP_CIPHER *cipher;\n    int iv_len;\n    (void)key_name; \n    s_log(LOG_DEBUG, \"Session ticket processing callback\");\n    c=SSL_get_ex_data(ssl, index_ssl_cli);\n    if(!HMAC_Init_ex(hctx, (const unsigned char *)(c->opt->ticket_mac->key_val),\n        c->opt->ticket_mac->key_len, EVP_sha256(), NULL)) {\n        s_log(LOG_ERR, \"HMAC_Init_ex failed\");\n        return -1;\n    }\n    if(c->opt->ticket_key->key_len == 16)\n        cipher = EVP_aes_128_cbc();\n    else \n        cipher = EVP_aes_256_cbc();\n    if(enc) { \n        iv_len = EVP_CIPHER_iv_length(cipher);\n        if(RAND_bytes(iv, iv_len) <= 0) { \n            s_log(LOG_ERR, \"RAND_bytes failed\");\n            return -1;\n        }\n        if(!EVP_EncryptInit_ex(ctx, cipher, NULL,\n            (const unsigned char *)(c->opt->ticket_key->key_val), iv)) {\n            s_log(LOG_ERR, \"EVP_EncryptInit_ex failed\");\n            return -1;\n        }\n    } else \n        if(!EVP_DecryptInit_ex(ctx, cipher, NULL,\n            (const unsigned char *)(c->opt->ticket_key->key_val), iv)) {\n            s_log(LOG_ERR, \"EVP_DecryptInit_ex failed\");\n            return -1;\n        }\n    if(strcmp(SSL_get_version(c->ssl), \"TLSv1.3\"))\n        return 1; \n    else\n        return 2; \n}", "target": 1}
{"code": "static void parse_relocation_info(struct MACH0_(obj_t) *bin, RSkipList *relocs, ut32 offset, ut32 num) {\n\tif (!num || !offset || (st32)num < 0) {\n\t\treturn;\n\t}\n\tut64 total_size = num * sizeof (struct relocation_info);\n\tif (offset > bin->size) {\n\t\treturn;\n\t}\n\tif (total_size > bin->size) {\n\t\ttotal_size = bin->size - offset;\n\t\tnum = total_size /= sizeof (struct relocation_info);\n\t}\n\tstruct relocation_info *info = calloc (num, sizeof (struct relocation_info));\n\tif (!info) {\n\t\treturn;\n\t}\n\tif (r_buf_read_at (bin->b, offset, (ut8 *) info, total_size) < total_size) {\n\t\tfree (info);\n\t\treturn;\n\t}\n\tsize_t i;\n\tfor (i = 0; i < num; i++) {\n\t\tstruct relocation_info a_info = info[i];\n\t\tut32 sym_num = a_info.r_symbolnum;\n\t\tif (sym_num > bin->nsymtab) {\n\t\t\tcontinue;\n\t\t}\n\t\tut32 stridx = bin->symtab[sym_num].n_strx;\n\t\tchar *sym_name = get_name (bin, stridx, false);\n\t\tif (!sym_name) {\n\t\t\tcontinue;\n\t\t}\n\t\tstruct reloc_t *reloc = R_NEW0 (struct reloc_t);\n\t\tif (!reloc) {\n\t\t\tfree (info);\n\t\t\tfree (sym_name);\n\t\t\treturn;\n\t\t}\n\t\treloc->addr = offset_to_vaddr (bin, a_info.r_address);\n\t\treloc->offset = a_info.r_address;\n\t\treloc->ord = sym_num;\n\t\treloc->type = a_info.r_type; \n\t\treloc->external = a_info.r_extern;\n\t\treloc->pc_relative = a_info.r_pcrel;\n\t\treloc->size = a_info.r_length;\n\t\tr_str_ncpy (reloc->name, sym_name, sizeof (reloc->name) - 1);\n\t\tr_skiplist_insert (relocs, reloc);\n\t\tfree (sym_name);\n\t}\n\tfree (info);\n}", "target": 1}
{"code": "should_hex_escape (gunichar           c,\n                   FlatpakEscapeFlags flags)\n{\n  if ((flags & FLATPAK_ESCAPE_ALLOW_NEWLINES) && c == '\\n')\n    return FALSE;\n  return !is_char_safe (c);\n}", "target": 0}
{"code": "void schedule_deferred_open_smb_message(uint16 mid)\n{\n\tstruct pending_message_list *pml;\n\tint i = 0;\n\tfor (pml = deferred_open_queue; pml; pml = pml->next) {\n\t\tuint16 msg_mid = SVAL(pml->buf.data,smb_mid);\n\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: [%d] msg_mid = %u\\n\", i++,\n\t\t\t(unsigned int)msg_mid ));\n\t\tif (mid == msg_mid) {\n\t\t\tstruct timed_event *te;\n\t\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: scheduling mid %u\\n\",\n\t\t\t\tmid ));\n\t\t\tte = event_add_timed(smbd_event_context(),\n\t\t\t\t\t     pml,\n\t\t\t\t\t     timeval_zero(),\n\t\t\t\t\t     smbd_deferred_open_timer,\n\t\t\t\t\t     pml);\n\t\t\tif (!te) {\n\t\t\t\tDEBUG(10,(\"schedule_deferred_open_smb_message: \"\n\t\t\t\t\t  \"event_add_timed() failed, skipping mid %u\\n\",\n\t\t\t\t\t  mid ));\n\t\t\t}\n\t\t\tTALLOC_FREE(pml->te);\n\t\t\tpml->te = te;\n\t\t\tDLIST_PROMOTE(deferred_open_queue, pml);\n\t\t\treturn;\n\t\t}\n\t}\n\tDEBUG(10,(\"schedule_deferred_open_smb_message: failed to find message mid %u\\n\",\n\t\tmid ));\n}", "target": 0}
{"code": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tif (vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\tvmcs_set_bits(CPU_BASED_VM_EXEC_CONTROL,\n\t\t      CPU_BASED_VIRTUAL_NMI_PENDING);\n}", "target": 0}
{"code": "void *bson_realloc( void *ptr, int size ) {\n    void *p;\n    p = bson_realloc_func( ptr, size );\n    bson_fatal_msg( !!p, \"realloc() failed\" );\n    return p;\n}", "target": 1}
{"code": "arista_print_date_hms_time(netdissect_options *ndo, uint32_t seconds,\n\t\tuint32_t nanoseconds)\n{\n\ttime_t ts;\n\tstruct tm *tm;\n\tchar buf[BUFSIZE];\n\tts = seconds + (nanoseconds / 1000000000);\n\tnanoseconds %= 1000000000;\n\tif (NULL == (tm = gmtime(&ts)))\n\t\tND_PRINT(\"gmtime() error\");\n\telse if (0 == strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S\", tm))\n\t\tND_PRINT(\"strftime() error\");\n\telse\n\t\tND_PRINT(\"%s.%09u\", buf, nanoseconds);\n}", "target": 1}
{"code": "Http::FilterDataStatus Context::onRequestBody(int body_buffer_length, bool end_of_stream) {\n  if (!wasm_->onRequestBody_) {\n    return Http::FilterDataStatus::Continue;\n  }\n  switch (wasm_\n              ->onRequestBody_(this, id_, static_cast<uint32_t>(body_buffer_length),\n                               static_cast<uint32_t>(end_of_stream))\n              .u64_) {\n  case 0:\n    return Http::FilterDataStatus::Continue;\n  case 1:\n    return Http::FilterDataStatus::StopIterationAndBuffer;\n  case 2:\n    return Http::FilterDataStatus::StopIterationAndWatermark;\n  default:\n    return Http::FilterDataStatus::StopIterationNoBuffer;\n  }\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n{\n    if (!PJ_SCAN_IS_NEWLINE(*scanner->curptr)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    if (*scanner->curptr == '\\r') {\n\t++scanner->curptr;\n    }\n    if (*scanner->curptr == '\\n') {\n\t++scanner->curptr;\n    }\n    ++scanner->line;\n    scanner->start_line = scanner->curptr;\n}", "target": 1}
{"code": "find_sig8_target_as_global_offset(Dwarf_Attribute attr,\n    Dwarf_Sig8  *sig8,\n    Dwarf_Bool  *is_info,\n    Dwarf_Off   *targoffset,\n    Dwarf_Error *error)\n{\n    Dwarf_Die  targdie = 0;\n    Dwarf_Bool targ_is_info = 0;\n    Dwarf_Off  localoff = 0;\n    int res = 0;\n    targ_is_info = attr->ar_cu_context->cc_is_info;\n    memcpy(sig8,attr->ar_debug_ptr,sizeof(*sig8));\n    res = dwarf_find_die_given_sig8(attr->ar_dbg,\n        sig8,&targdie,&targ_is_info,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    res = dwarf_die_offsets(targdie,targoffset,&localoff,error);\n    if (res != DW_DLV_OK) {\n        dwarf_dealloc_die(targdie);\n        return res;\n    }\n    *is_info = targdie->di_cu_context->cc_is_info;\n    dwarf_dealloc_die(targdie);\n    return DW_DLV_OK;\n}", "target": 1}
{"code": "static ssize_t available_instances_show(struct mdev_type *mtype,\n\t\t\t\t\tstruct mdev_type_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tconst struct mbochs_type *type =\n\t\t&mbochs_types[mtype_get_type_group_id(mtype)];\n\tint count = (max_mbytes - mbochs_used_mbytes) / type->mbytes;\n\treturn sprintf(buf, \"%d\\n\", count);\n}", "target": 1}
{"code": "int ocfs2_set_acl(handle_t *handle,\n\t\t\t struct inode *inode,\n\t\t\t struct buffer_head *di_bh,\n\t\t\t int type,\n\t\t\t struct posix_acl *acl,\n\t\t\t struct ocfs2_alloc_context *meta_ac,\n\t\t\t struct ocfs2_alloc_context *data_ac)\n{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint ret;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tret = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tif (ret == 0)\n\t\t\t\tacl = NULL;\n\t\t\tret = ocfs2_acl_set_mode(inode, di_bh,\n\t\t\t\t\t\t handle, mode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (acl) {\n\t\tvalue = ocfs2_acl_to_xattr(acl, &size);\n\t\tif (IS_ERR(value))\n\t\t\treturn (int)PTR_ERR(value);\n\t}\n\tif (handle)\n\t\tret = ocfs2_xattr_set_handle(handle, inode, di_bh, name_index,\n\t\t\t\t\t     \"\", value, size, 0,\n\t\t\t\t\t     meta_ac, data_ac);\n\telse\n\t\tret = ocfs2_xattr_set(inode, name_index, \"\", value, size, 0);\n\tkfree(value);\n\treturn ret;\n}", "target": 1}
{"code": "MONGO_EXPORT mongo_cursor *gridfile_get_chunks( gridfile *gfile, int start, int size ) {\n    bson_iterator it;\n    bson_oid_t id;\n    bson gte;\n    bson query;\n    bson orderby;\n    bson command;\n    mongo_cursor *cursor;\n    bson_find( &it, gfile->meta, \"_id\" );\n    id = *bson_iterator_oid( &it );\n    bson_init( &query );\n    bson_append_oid( &query, \"files_id\", &id );\n    if ( size == 1 ) {\n        bson_append_int( &query, \"n\", start );\n    }\n    else {\n        bson_init( &gte );\n        bson_append_int( &gte, \"$gte\", start );\n        bson_finish( &gte );\n        bson_append_bson( &query, \"n\", &gte );\n        bson_destroy( &gte );\n    }\n    bson_finish( &query );\n    bson_init( &orderby );\n    bson_append_int( &orderby, \"n\", 1 );\n    bson_finish( &orderby );\n    bson_init( &command );\n    bson_append_bson( &command, \"query\", &query );\n    bson_append_bson( &command, \"orderby\", &orderby );\n    bson_finish( &command );\n    cursor = mongo_find( gfile->gfs->client, gfile->gfs->chunks_ns,\n                         &command, NULL, size, 0, 0 );\n    bson_destroy( &command );\n    bson_destroy( &query );\n    bson_destroy( &orderby );\n    return cursor;\n}", "target": 1}
{"code": "inline bool ResolveAxis(const int num_dims, const int* axis,\n                        const int64_t num_axis, int* out_axis,\n                        int* out_num_axis) {\n  *out_num_axis = 0;  \n  if (num_dims == 0) {\n    return true;\n  }\n  for (int64_t idx = 0; idx < num_axis; ++idx) {\n    int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx];\n    TFLITE_DCHECK(current >= 0 && current < num_dims);\n    if (current < 0 || current >= num_dims) {\n      return false;\n    }\n    bool is_dup = false;\n    for (int j = 0; j < *out_num_axis; ++j) {\n      if (out_axis[j] == current) {\n        is_dup = true;\n        break;\n      }\n    }\n    if (!is_dup) {\n      out_axis[*out_num_axis] = current;\n      *out_num_axis += 1;\n    }\n  }\n  return true;\n}", "target": 0}
{"code": "static int sanitize_val_alu(struct bpf_verifier_env *env,\n\t\t\t    struct bpf_insn *insn)\n{\n\tstruct bpf_insn_aux_data *aux = cur_aux(env);\n\tif (can_skip_alu_sanitation(env, insn))\n\t\treturn 0;\n\treturn update_alu_sanitation_state(aux, BPF_ALU_NON_POINTER, 0);\n}", "target": 0}
{"code": "BOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\tcredssp_free(transport->credssp);\n\treturn TRUE;\n}", "target": 0}
{"code": "TEST_P(Http2IntegrationTest, LargeRequestTrailersRejected) { testLargeRequestTrailers(66, 60); }", "target": 0}
{"code": "DEFINE_TEST(test_read_too_many_filters)\n{\n\tconst char *name = \"test_read_too_many_filters.gz\";\n\tstruct archive *a;\n\tint r;\n\tassert((a = archive_read_new()) != NULL);\n\tr = archive_read_support_filter_gzip(a);\n\tif (r == ARCHIVE_WARN) {\n\t\tskipping(\"gzip reading not fully supported on this platform\");\n\t}\n\tassertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));\n\textract_reference_file(name);\n\tassertEqualIntA(a, ARCHIVE_FATAL,\n\t    archive_read_open_filename(a, name, 200));\n\tassertEqualInt(ARCHIVE_OK, archive_read_close(a));\n\tassertEqualInt(ARCHIVE_OK, archive_read_free(a));\n}", "target": 0}
{"code": "static int ensureDir(rpmPlugins plugins, const char *p, int owned, int create)\n{\n    char *path = xstrdup(p);\n    char *dp = path;\n    char *sp = NULL, *bn;\n    int oflags = O_RDONLY;\n    int dirfd = fsmOpenat(-1, \"/\", oflags);\n    int fd = dirfd; \n    while ((bn = strtok_r(dp, \"/\", &sp)) != NULL) {\n\tstruct stat sb;\n\tfd = fsmOpenat(dirfd, bn, oflags);\n\tif (fd < 0 && errno == ENOENT && create) {\n\t    mode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t    if (fsmDoMkDir(plugins, dirfd, bn, owned, mode) == 0) {\n\t\tfd = fsmOpenat(dirfd, bn, oflags|O_NOFOLLOW);\n\t    }\n\t}\n\tif (fd >= 0 && fstat(fd, &sb) == 0 && !S_ISDIR(sb.st_mode)) {\n\t    close(fd);\n\t    errno = ENOTDIR;\n\t    fd = -1;\n\t}\n\tclose(dirfd);\n\tif (fd >= 0) {\n\t    dirfd = fd;\n\t} else {\n\t    dirfd = -1;\n\t    rpmlog(RPMLOG_ERR, _(\"failed to open dir %s of %s: %s\\n\"),\n\t\t\t\tbn, p, strerror(errno));\n\t    break;\n\t}\n\tdp = NULL;\n    }\n    free(path);\n    return dirfd;\n}", "target": 0}
{"code": "save_positions (GPtrArray *page_names)\n{\n\tguint i;\n\tGHashTable *ht;\n\tht = g_hash_table_new (g_str_hash, g_str_equal);\n\tfor (i = 0; i < page_names->len; i++)\n\t\tg_hash_table_insert (ht, page_names->pdata[i], GUINT_TO_POINTER(i + 1));\n\treturn ht;\n}", "target": 0}
{"code": "static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tWARN_ON(req->buf == NULL);\n\tkfree(req->buf);\n\treq->buf = NULL;\n\tusb_ep_free_request(ep, req);\n}", "target": 0}
{"code": "static char *get_pid_environ_val(pid_t pid,char *val){\n  char temp[500];\n  int i=0;\n  int foundit=0;\n  FILE *fp;\n  sprintf(temp,\"/proc/%d/environ\",pid);\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n  for(;;){\n    temp[i]=fgetc(fp);    \n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }\n    switch(temp[i]){\n    case EOF:\n      fclose(fp);\n      return NULL;\n    case '=':\n      temp[i]=0;\n      if(!strcmp(temp,val)){\n\tfoundit=1;\n      }\n      i=0;\n      break;\n    case '\\0':\n      i=0;\n      break;\n    default:\n      i++;\n    }\n  }\n}", "target": 1}
{"code": "bool ImageLoader::HasPendingEvent() const {\n  if (image_content_ && !image_complete_ && !loading_image_document_)\n    return true;\n  if (pending_load_event_.IsActive() || pending_error_event_.IsActive())\n    return true;\n  return false;\n}", "target": 0}
{"code": "ikev1_cr_print(netdissect_options *ndo, u_char tpay _U_,\n\t       const struct isakmp_gen *ext, u_int item_len,\n\t       const u_char *ep _U_, uint32_t phase _U_, uint32_t doi0 _U_,\n\t       uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_cert *p;\n\tstruct ikev1_pl_cert cert;\n\tstatic const char *certstr[] = {\n\t\t\"none\",\t\"pkcs7\", \"pgp\", \"dns\",\n\t\t\"x509sign\", \"x509ke\", \"kerberos\", \"crl\",\n\t\t\"arl\", \"spki\", \"x509attr\",\n\t};\n\tND_PRINT((ndo,\"%s:\", NPSTR(ISAKMP_NPTYPE_CR)));\n\tp = (const struct ikev1_pl_cert *)ext;\n\tND_TCHECK(*p);\n\tUNALIGNED_MEMCPY(&cert, ext, sizeof(cert));\n\tND_PRINT((ndo,\" len=%d\", item_len - 4));\n\tND_PRINT((ndo,\" type=%s\", STR_OR_ID((cert.encode), certstr)));\n\tif (2 < ndo->ndo_vflag && 4 < item_len) {\n\t\tND_PRINT((ndo,\" \"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(ext + 1), item_len - 4))\n\t\t\tgoto trunc;\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_CR)));\n\treturn NULL;\n}", "target": 0}
{"code": "static int get_filter(struct sss_certmap_ctx *ctx,\n                      struct ldap_mapping_rule *parsed_mapping_rule,\n                      struct sss_cert_content *cert_content,\n                      char **filter)\n{\n    struct ldap_mapping_rule_comp *comp;\n    char *result = NULL;\n    char *expanded = NULL;\n    int ret;\n    result = talloc_strdup(ctx, \"\");\n    if (result == NULL) {\n        return ENOMEM;\n    }\n    for (comp = parsed_mapping_rule->list; comp != NULL; comp = comp->next) {\n        if (comp->type == comp_string) {\n            result = talloc_strdup_append(result, comp->val);\n        } else if (comp->type == comp_template) {\n            ret = expand_template(ctx, comp->parsed_template, cert_content,\n                                  &expanded);\n            if (ret != 0) {\n                CM_DEBUG(ctx, \"Failed to expanded template.\");\n                goto done;\n            }\n            result = talloc_strdup_append(result, expanded);\n            talloc_free(expanded);\n            expanded = NULL;\n            if (result == NULL) {\n                ret = ENOMEM;\n                goto done;\n            }\n        } else {\n            ret = EINVAL;\n            CM_DEBUG(ctx, \"Unsupported component type.\");\n            goto done;\n        }\n    }\n    ret = 0;\ndone:\n    talloc_free(expanded);\n    if (ret == 0) {\n        *filter = result;\n    } else {\n        talloc_free(result);\n    }\n    return ret;\n}", "target": 1}
{"code": "int user_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct user_key_payload *zap = NULL;\n\tint ret;\n\tret = key_payload_reserve(key, prep->datalen);\n\tif (ret < 0)\n\t\treturn ret;\n\tkey->expiry = prep->expiry;\n\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\tzap = dereference_key_locked(key);\n\trcu_assign_keypointer(key, prep->payload.data[0]);\n\tprep->payload.data[0] = NULL;\n\tif (zap)\n\t\tcall_rcu(&zap->rcu, user_free_payload_rcu);\n\treturn ret;\n}", "target": 1}
{"code": "static int adpt_system_info(void __user *buffer)\n{\n\tsysInfo_S si;\n\tmemset(&si, 0, sizeof(si));\n\tsi.osType = OS_LINUX;\n\tsi.osMajorVersion = 0;\n\tsi.osMinorVersion = 0;\n\tsi.osRevision = 0;\n\tsi.busType = SI_PCI_BUS;\n\tsi.processorFamily = DPTI_sig.dsProcessorFamily;\n#if defined __i386__\n\tadpt_i386_info(&si);\n#elif defined (__ia64__)\n\tadpt_ia64_info(&si);\n#elif defined(__sparc__)\n\tadpt_sparc_info(&si);\n#elif defined (__alpha__)\n\tadpt_alpha_info(&si);\n#else\n\tsi.processorType = 0xff ;\n#endif\n\tif (copy_to_user(buffer, &si, sizeof(si))){\n\t\tprintk(KERN_WARNING\"dpti: Could not copy buffer TO user\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn 0;\n}", "target": 1}
{"code": "int sub__messages_queue(const char *source_id, const char *topic, uint8_t qos, int retain, struct mosquitto_msg_store **stored)\n{\n\tint rc = MOSQ_ERR_SUCCESS, rc2;\n\tstruct mosquitto__subhier *subhier;\n\tchar **split_topics = NULL;\n\tchar *local_topic = NULL;\n\tassert(topic);\n\tif(sub__topic_tokenise(topic, &local_topic, &split_topics, NULL)) return 1;\n\tdb__msg_store_ref_inc(*stored);\n\tHASH_FIND(hh, db.subs, split_topics[0], strlen(split_topics[0]), subhier);\n\tif(subhier){\n\t\trc = sub__search(subhier, split_topics, source_id, topic, qos, retain, *stored);\n\t}\n\tif(retain){\n\t\trc2 = retain__store(topic, *stored, split_topics);\n\t\tif(rc2) rc = rc2;\n\t}\n\tmosquitto__free(split_topics);\n\tmosquitto__free(local_topic);\n\tdb__msg_store_ref_dec(stored);\n\treturn rc;\n}", "target": 1}
{"code": "cmsSEQ* CMSEXPORT cmsAllocProfileSequenceDescription(cmsContext ContextID, cmsUInt32Number n)\n{\n    cmsSEQ* Seq;\n    cmsUInt32Number i;\n    if (n == 0) return NULL;\n    if (n > 255) return NULL;\n    Seq = (cmsSEQ*) _cmsMallocZero(ContextID, sizeof(cmsSEQ));\n    if (Seq == NULL) return NULL;\n    Seq -> ContextID = ContextID;\n    Seq -> seq      = (cmsPSEQDESC*) _cmsCalloc(ContextID, n, sizeof(cmsPSEQDESC));\n    Seq -> n        = n;\n    if (Seq -> seq == NULL) {\n        _cmsFree(ContextID, Seq);\n        return NULL;\n    }\n    for (i=0; i < n; i++) {\n        Seq -> seq[i].Manufacturer = NULL;\n        Seq -> seq[i].Model        = NULL;\n        Seq -> seq[i].Description  = NULL;\n    }\n    return Seq;\n}", "target": 0}
{"code": "static void copy_fields(const FieldMatchContext *fm, AVFrame *dst,\n                        const AVFrame *src, int field)\n{\n    int plane;\n    for (plane = 0; plane < 4 && src->data[plane]; plane++)\n        av_image_copy_plane(dst->data[plane] + field*dst->linesize[plane], dst->linesize[plane] << 1,\n                            src->data[plane] + field*src->linesize[plane], src->linesize[plane] << 1,\n                            get_width(fm, src, plane), get_height(fm, src, plane) / 2);\n}", "target": 1}
{"code": "ldap_pvt_tls_init( void )\n{\n\treturn tls_init( tls_imp );\n}", "target": 0}
{"code": "spnego_gss_unwrap_aead(OM_uint32 *minor_status,\n\t\t       gss_ctx_id_t context_handle,\n\t\t       gss_buffer_t input_message_buffer,\n\t\t       gss_buffer_t input_assoc_buffer,\n\t\t       gss_buffer_t output_payload_buffer,\n\t\t       int *conf_state,\n\t\t       gss_qop_t *qop_state)\n{\n\tOM_uint32 ret;\n\tret = gss_unwrap_aead(minor_status,\n\t\t\t      context_handle,\n\t\t\t      input_message_buffer,\n\t\t\t      input_assoc_buffer,\n\t\t\t      output_payload_buffer,\n\t\t\t      conf_state,\n\t\t\t      qop_state);\n\treturn (ret);\n}", "target": 1}
{"code": "x509stack_peek_level(struct cert_stack *stack)\n{\n\tstruct repo_level_node *repo = SLIST_FIRST(&stack->levels);\n\treturn (repo != NULL) ? repo->level : 0;\n}", "target": 1}
{"code": "void jpc_qmfb_join_colgrp(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t joinbuf[QMFB_JOINBUFSIZE * JPC_QMFB_COLGRPSIZE];\n\tjpc_fix_t *buf = joinbuf;\n\tjpc_fix_t *srcptr;\n\tjpc_fix_t *dstptr;\n\tregister jpc_fix_t *srcptr2;\n\tregister jpc_fix_t *dstptr2;\n\tregister int n;\n\tregister int i;\n\tint hstartcol;\n\tif (bufsize > QMFB_JOINBUFSIZE) {\n\t\tif (!(buf = jas_alloc3(bufsize, JPC_QMFB_COLGRPSIZE, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\thstartcol = (numrows + 1 - parity) >> 1;\n\tn = hstartcol;\n\tsrcptr = &a[0];\n\tdstptr = buf;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tsrcptr += stride;\n\t\tdstptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\tsrcptr = &a[hstartcol * stride];\n\tdstptr = &a[(1 - parity) * stride];\n\tn = numrows - hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += stride;\n\t}\n\tsrcptr = buf;\n\tdstptr = &a[parity * stride];\n\tn = hstartcol;\n\twhile (n-- > 0) {\n\t\tdstptr2 = dstptr;\n\t\tsrcptr2 = srcptr;\n\t\tfor (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) {\n\t\t\t*dstptr2 = *srcptr2;\n\t\t\t++dstptr2;\n\t\t\t++srcptr2;\n\t\t}\n\t\tdstptr += 2 * stride;\n\t\tsrcptr += JPC_QMFB_COLGRPSIZE;\n\t}\n\tif (buf != joinbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "int read_super_2(squashfs_operations **s_ops, void *s)\n{\n\t squashfs_super_block_3 *sBlk_3 = s;\n\tif(sBlk_3->s_magic != SQUASHFS_MAGIC || sBlk_3->s_major != 2 ||\n\t\t\t\t\t\t\tsBlk_3->s_minor > 1)\n\t\treturn -1;\n\tsBlk.s.s_magic = sBlk_3->s_magic;\n\tsBlk.s.inodes = sBlk_3->inodes;\n\tsBlk.s.mkfs_time = sBlk_3->mkfs_time;\n\tsBlk.s.block_size = sBlk_3->block_size;\n\tsBlk.s.fragments = sBlk_3->fragments;\n\tsBlk.s.block_log = sBlk_3->block_log;\n\tsBlk.s.flags = sBlk_3->flags;\n\tsBlk.s.s_major = sBlk_3->s_major;\n\tsBlk.s.s_minor = sBlk_3->s_minor;\n\tsBlk.s.root_inode = sBlk_3->root_inode;\n\tsBlk.s.bytes_used = sBlk_3->bytes_used_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start;\n\tsBlk.s.directory_table_start = sBlk_3->directory_table_start_2;\n\tsBlk.s.fragment_table_start = sBlk_3->fragment_table_start_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start_2;\n\tsBlk.no_uids = sBlk_3->no_uids;\n\tsBlk.no_guids = sBlk_3->no_guids;\n\tsBlk.uid_start = sBlk_3->uid_start_2;\n\tsBlk.guid_start = sBlk_3->guid_start_2;\n\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n\t*s_ops = &ops;\n\tcomp = lookup_compressor(\"gzip\");\n\tif(sBlk_3->s_minor == 0)\n\t\tneeds_sorting = TRUE;\n\treturn TRUE;\n}", "target": 0}
{"code": "static u64 vmx_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset;\n\ttsc_offset = is_guest_mode(vcpu) ?\n\t\tto_vmx(vcpu)->nested.vmcs01_tsc_offset :\n\t\tvmcs_read64(TSC_OFFSET);\n\treturn host_tsc + tsc_offset;\n}", "target": 0}
{"code": "static const char *findvararg (CallInfo *ci, int n, StkId *pos) {\n  if (clLvalue(s2v(ci->func))->p->is_vararg) {\n    int nextra = ci->u.l.nextraargs;\n    if (n <= nextra) {\n      *pos = ci->func - nextra + (n - 1);\n      return \"(vararg)\";  \n    }\n  }\n  return NULL;  \n}", "target": 1}
{"code": "int mp_pack(lua_State *L) {\n    int nargs = lua_gettop(L);\n    int i;\n    mp_buf *buf;\n    if (nargs == 0)\n        return luaL_argerror(L, 0, \"MessagePack pack needs input.\");\n    if (!lua_checkstack(L, nargs))\n        return luaL_argerror(L, 0, \"Too many arguments for MessagePack pack.\");\n    buf = mp_buf_new(L);\n    for(i = 1; i <= nargs; i++) {\n        luaL_checkstack(L, 1, \"in function mp_check\");\n        lua_pushvalue(L, i);\n        mp_encode_lua_type(L,buf,0);\n        lua_pushlstring(L,(char*)buf->b,buf->len);\n        buf->free += buf->len;\n        buf->len = 0;\n    }\n    mp_buf_free(L, buf);\n    lua_concat(L, nargs);\n    return 1;\n}", "target": 0}
{"code": "jinit_merged_upsampler(j_decompress_ptr cinfo)\n{\n  my_upsample_ptr upsample;\n  upsample = (my_upsample_ptr)\n    (*cinfo->mem->alloc_small) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                                sizeof(my_upsampler));\n  cinfo->upsample = (struct jpeg_upsampler *)upsample;\n  upsample->pub.start_pass = start_pass_merged_upsample;\n  upsample->pub.need_context_rows = FALSE;\n  upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;\n  if (cinfo->max_v_samp_factor == 2) {\n    upsample->pub.upsample = merged_2v_upsample;\n    if (jsimd_can_h2v2_merged_upsample())\n      upsample->upmethod = jsimd_h2v2_merged_upsample;\n    else\n      upsample->upmethod = h2v2_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v2_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v2_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = (JSAMPROW)\n      (*cinfo->mem->alloc_large) ((j_common_ptr)cinfo, JPOOL_IMAGE,\n                (size_t)(upsample->out_row_width * sizeof(JSAMPLE)));\n  } else {\n    upsample->pub.upsample = merged_1v_upsample;\n    if (jsimd_can_h2v1_merged_upsample())\n      upsample->upmethod = jsimd_h2v1_merged_upsample;\n    else\n      upsample->upmethod = h2v1_merged_upsample;\n    if (cinfo->out_color_space == JCS_RGB565) {\n      if (cinfo->dither_mode != JDITHER_NONE) {\n        upsample->upmethod = h2v1_merged_upsample_565D;\n      } else {\n        upsample->upmethod = h2v1_merged_upsample_565;\n      }\n    }\n    upsample->spare_row = NULL;\n  }\n  build_ycc_rgb_table(cinfo);\n}", "target": 1}
{"code": "static int crypto_nivaead_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_aead raead;\n\tstruct aead_alg *aead = &alg->cra_aead;\n\tsnprintf(raead.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"nivaead\");\n\tsnprintf(raead.geniv, CRYPTO_MAX_ALG_NAME, \"%s\", aead->geniv);\n\traead.blocksize = alg->cra_blocksize;\n\traead.maxauthsize = aead->maxauthsize;\n\traead.ivsize = aead->ivsize;\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_AEAD,\n\t\t    sizeof(struct crypto_report_aead), &raead))\n\t\tgoto nla_put_failure;\n\treturn 0;\nnla_put_failure:\n\treturn -EMSGSIZE;\n}", "target": 1}
{"code": "void LibRaw::remove_caseSubstr(char *string, char *subStr) \n{\n  char *found;\n  while ((found = strcasestr(string,subStr))) {\n    if (!found) return;\n    int fill_len = strlen(subStr);\n    int p = found - string;\n    for (int i=p; i<p+fill_len; i++) {\n      string[i] = 32;\n    }\n  }\n  trimSpaces (string);\n}", "target": 0}
{"code": "bool RootWindow::DispatchTouchEvent(TouchEvent* event) {\n  DispatchHeldMouseMove();\n  if (ui::IsDIPEnabled()) {\n    float scale = ui::GetDeviceScaleFactor(layer());\n    ui::Transform transform = layer()->transform();\n    transform.ConcatScale(scale, scale);\n    event->UpdateForRootTransform(transform);\n  } else {\n    event->UpdateForRootTransform(layer()->transform());\n  }\n  bool handled = false;\n  ui::TouchStatus status = ui::TOUCH_STATUS_UNKNOWN;\n  Window* target = capture_window_;\n  if (!target) {\n    target = ConsumerToWindow(\n        gesture_recognizer_->GetTouchLockedTarget(event));\n    if (!target) {\n      target = ConsumerToWindow(\n          gesture_recognizer_->GetTargetForLocation(event->GetLocation()));\n    }\n  }\n  if (!target && !bounds().Contains(event->location())) {\n    target = this;\n  } else {\n    if (!target) {\n      target = GetEventHandlerForPoint(event->location());\n      if (!target)\n        return false;\n    }\n    TouchEvent translated_event(*event, this, target);\n    status = ProcessTouchEvent(target, &translated_event);\n    handled = status != ui::TOUCH_STATUS_UNKNOWN;\n    if (status == ui::TOUCH_STATUS_QUEUED ||\n        status == ui::TOUCH_STATUS_QUEUED_END)\n      gesture_recognizer_->QueueTouchEventForGesture(target, *event);\n  }\n  scoped_ptr<ui::GestureRecognizer::Gestures> gestures;\n  gestures.reset(gesture_recognizer_->ProcessTouchEventForGesture(\n      *event, status, target));\n  return ProcessGestures(gestures.get()) ? true : handled;\n}", "target": 0}
{"code": "convert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}", "target": 1}
{"code": "PJ_DEF(void) pj_scan_get_unescape( pj_scanner *scanner,\n\t\t\t\t   const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    char *dst = s;\n    pj_assert(pj_cis_match(spec,0)==0);\n    pj_assert(pj_cis_match(spec,'%')==0);\n    if (!pj_cis_match(spec, *s) && *s != '%') {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    out->ptr = s;\n    do {\n\tif (*s == '%') {\n\t    if (s+3 <= scanner->end && pj_isxdigit(*(s+1)) && \n\t\tpj_isxdigit(*(s+2))) \n\t    {\n\t\t*dst = (pj_uint8_t) ((pj_hex_digit_to_val(*(s+1)) << 4) +\n\t\t\t\t      pj_hex_digit_to_val(*(s+2)));\n\t\t++dst;\n\t\ts += 3;\n\t    } else {\n\t\t*dst++ = *s++;\n\t\t*dst++ = *s++;\n\t\tbreak;\n\t    }\n\t}\n\tif (pj_cis_match(spec, *s)) {\n\t    char *start = s;\n\t    do {\n\t\t++s;\n\t    } while (pj_cis_match(spec, *s));\n\t    if (dst != start) pj_memmove(dst, start, s-start);\n\t    dst += (s-start);\n\t} \n    } while (*s == '%');\n    scanner->curptr = s;\n    out->slen = (dst - out->ptr);\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}", "target": 1}
{"code": "int rds_rdma_extra_size(struct rds_rdma_args *args)\n{\n\tstruct rds_iovec vec;\n\tstruct rds_iovec __user *local_vec;\n\tint tot_pages = 0;\n\tunsigned int nr_pages;\n\tunsigned int i;\n\tlocal_vec = (struct rds_iovec __user *)(unsigned long) args->local_vec_addr;\n\tif (args->nr_local == 0)\n\t\treturn -EINVAL;\n\tfor (i = 0; i < args->nr_local; i++) {\n\t\tif (copy_from_user(&vec, &local_vec[i],\n\t\t\t\t   sizeof(struct rds_iovec)))\n\t\t\treturn -EFAULT;\n\t\tnr_pages = rds_pages_in_vec(&vec);\n\t\tif (nr_pages == 0)\n\t\t\treturn -EINVAL;\n\t\ttot_pages += nr_pages;\n\t\tif (tot_pages < 0)\n\t\t\treturn -EINVAL;\n\t}\n\treturn tot_pages * sizeof(struct scatterlist);\n}", "target": 0}
{"code": "static void show_object(struct object *object, struct strbuf *path,\n\t\t\tconst char *last, void *data)\n{\n\tstruct bitmap *base = data;\n\tbitmap_set(base, find_object_pos(object->oid.hash));\n\tmark_as_seen(object);\n}", "target": 1}
{"code": "unique_ptr<IOBuf> IOBuf::takeOwnership(\n    void* buf,\n    std::size_t capacity,\n    std::size_t offset,\n    std::size_t length,\n    FreeFunction freeFn,\n    void* userData,\n    bool freeOnError,\n    TakeOwnershipOption option) {\n  if (capacity > kMaxIOBufSize) {\n    throw_exception<std::bad_alloc>();\n  }\n  DCHECK(\n      !userData || (userData && freeFn) ||\n      (userData && !freeFn && (option == TakeOwnershipOption::STORE_SIZE)));\n  HeapFullStorage* storage = nullptr;\n  auto rollback = makeGuard([&] {\n    if (storage) {\n      free(storage);\n    }\n    takeOwnershipError(freeOnError, buf, freeFn, userData);\n  });\n  size_t requiredStorage = sizeof(HeapFullStorage);\n  size_t mallocSize = goodMallocSize(requiredStorage);\n  storage = static_cast<HeapFullStorage*>(checkedMalloc(mallocSize));\n  new (&storage->hs.prefix)\n      HeapPrefix(kIOBufInUse | kSharedInfoInUse, mallocSize);\n  new (&storage->shared)\n      SharedInfo(freeFn, userData, true );\n  auto result = unique_ptr<IOBuf>(new (&storage->hs.buf) IOBuf(\n      InternalConstructor(),\n      packFlagsAndSharedInfo(0, &storage->shared),\n      static_cast<uint8_t*>(buf),\n      capacity,\n      static_cast<uint8_t*>(buf) + offset,\n      length));\n  rollback.dismiss();\n  if (io_buf_alloc_cb) {\n    io_buf_alloc_cb(storage, mallocSize);\n    if (userData && !freeFn && (option == TakeOwnershipOption::STORE_SIZE)) {\n      io_buf_alloc_cb(buf, capacity);\n    }\n  }\n  return result;\n}", "target": 0}
{"code": "mptctl_eventenable (unsigned long arg)\n{\n\tstruct mpt_ioctl_eventenable __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_eventenable\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_eventenable))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_eventenable - \"\n\t\t\t\"Unable to read in mpt_ioctl_eventenable struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_eventenable() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_eventenable called.\\n\",\n\t    ioc->name));\n\tif (ioc->events == NULL) {\n\t\tint sz = MPTCTL_EVENT_LOG_SIZE * sizeof(MPT_IOCTL_EVENTS);\n\t\tioc->events = kzalloc(sz, GFP_KERNEL);\n\t\tif (!ioc->events) {\n\t\t\tprintk(MYIOC_s_ERR_FMT\n\t\t\t    \": ERROR - Insufficient memory to add adapter!\\n\",\n\t\t\t    ioc->name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tioc->alloc_total += sz;\n\t\tioc->eventContext = 0;\n        }\n\tioc->eventTypes = karg.eventTypes;\n\treturn 0;\n}", "target": 1}
{"code": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}", "target": 1}
{"code": "R_API RBinJavaVerificationObj *r_bin_java_verification_info_from_type(RBinJavaObj *bin, R_BIN_JAVA_STACKMAP_TYPE type, ut32 value) {\n\tRBinJavaVerificationObj *se = R_NEW0 (RBinJavaVerificationObj);\n\tif (!se) {\n\t\treturn NULL;\n\t}\n\tse->tag = type;\n\tif (se->tag == R_BIN_JAVA_STACKMAP_OBJECT) {\n\t\tse->info.obj_val_cp_idx = (ut16) value;\n\t} else if (se->tag == R_BIN_JAVA_STACKMAP_UNINIT) {\n\t\tse->info.uninit_offset = (ut16) value;\n\t}\n\treturn se;\n}", "target": 1}
{"code": "static xmlParserInputPtr plist_xml_external_entity_loader(const char *URL, const char *ID, xmlParserCtxtPtr ctxt)\n{\n    return NULL;\n}", "target": 0}
{"code": "static void configureIOD(EctEnhancedCT *ct)\n{\n    if (!ct)\n        return;\n}", "target": 0}
{"code": "  void TearDown() override {\n    peparse::DestructParsedPE(pe);\n  }", "target": 0}
{"code": "#else\n    static int input  (yyscan_t yyscanner)\n#endif\n{\n\tint c;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\tif ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )\n\t\t{\n\t\tif ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )\n\t\t\t*yyg->yy_c_buf_p = '\\0';\n\t\telse\n\t\t\t{ \n\t\t\tyy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;\n\t\t\t++yyg->yy_c_buf_p;\n\t\t\tswitch ( yy_get_next_buffer( yyscanner ) )\n\t\t\t\t{\n\t\t\t\tcase EOB_ACT_LAST_MATCH:\n\t\t\t\t\tre_yyrestart(yyin ,yyscanner);\n\t\t\t\tcase EOB_ACT_END_OF_FILE:\n\t\t\t\t\t{\n\t\t\t\t\tif ( re_yywrap(yyscanner ) )\n\t\t\t\t\t\treturn EOF;\n\t\t\t\t\tif ( ! yyg->yy_did_buffer_switch_on_eof )\n\t\t\t\t\t\tYY_NEW_FILE;\n#ifdef __cplusplus\n\t\t\t\t\treturn yyinput(yyscanner);\n#else\n\t\t\t\t\treturn input(yyscanner);\n#endif\n\t\t\t\t\t}\n\t\t\t\tcase EOB_ACT_CONTINUE_SCAN:\n\t\t\t\t\tyyg->yy_c_buf_p = yyg->yytext_ptr + offset;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tc = *(unsigned char *) yyg->yy_c_buf_p;\t\n\t*yyg->yy_c_buf_p = '\\0';\t\n\tyyg->yy_hold_char = *++yyg->yy_c_buf_p;\n\tif ( c == '\\n' )\n    do{ yylineno++;\n        yycolumn=0;\n    }while(0)\n;\n\treturn c;", "target": 1}
{"code": "static ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\tif (filp->f_flags & O_NONBLOCK)\n\t\tret = rpmsg_trysend(eptdev->ept, kbuf, len);\n\telse\n\t\tret = rpmsg_send(eptdev->ept, kbuf, len);\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}", "target": 1}
{"code": "static void adpt_alpha_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_ALPHA;\n}", "target": 1}
{"code": "static int check_swap_activate(struct file *swap_file, unsigned int max)\n{\n\tstruct address_space *mapping = swap_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tunsigned blocks_per_page;\n\tunsigned long page_no;\n\tunsigned blkbits;\n\tsector_t probe_block;\n\tsector_t last_block;\n\tsector_t lowest_block = -1;\n\tsector_t highest_block = 0;\n\tblkbits = inode->i_blkbits;\n\tblocks_per_page = PAGE_SIZE >> blkbits;\n\tprobe_block = 0;\n\tpage_no = 0;\n\tlast_block = i_size_read(inode) >> blkbits;\n\twhile ((probe_block + blocks_per_page) <= last_block && page_no < max) {\n\t\tunsigned block_in_page;\n\t\tsector_t first_block;\n\t\tcond_resched();\n\t\tfirst_block = bmap(inode, probe_block);\n\t\tif (first_block == 0)\n\t\t\tgoto bad_bmap;\n\t\tif (first_block & (blocks_per_page - 1)) {\n\t\t\tprobe_block++;\n\t\t\tgoto reprobe;\n\t\t}\n\t\tfor (block_in_page = 1; block_in_page < blocks_per_page;\n\t\t\t\t\tblock_in_page++) {\n\t\t\tsector_t block;\n\t\t\tblock = bmap(inode, probe_block + block_in_page);\n\t\t\tif (block == 0)\n\t\t\t\tgoto bad_bmap;\n\t\t\tif (block != first_block + block_in_page) {\n\t\t\t\tprobe_block++;\n\t\t\t\tgoto reprobe;\n\t\t\t}\n\t\t}\n\t\tfirst_block >>= (PAGE_SHIFT - blkbits);\n\t\tif (page_no) {\t\n\t\t\tif (first_block < lowest_block)\n\t\t\t\tlowest_block = first_block;\n\t\t\tif (first_block > highest_block)\n\t\t\t\thighest_block = first_block;\n\t\t}\n\t\tpage_no++;\n\t\tprobe_block += blocks_per_page;\nreprobe:\n\t\tcontinue;\n\t}\n\treturn 0;\nbad_bmap:\n\tpr_err(\"swapon: swapfile has holes\\n\");\n\treturn -EINVAL;\n}", "target": 0}
{"code": "dns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,\n  const uschar **fully_qualified_name)\n{\nint retval;\nunsigned long time_msec;\nif (!slow_lookup_log)\n  return dns_lookup(dnsa, name, type, fully_qualified_name);\ntime_msec = get_time_in_ms();\nretval = dns_lookup(dnsa, name, type, fully_qualified_name);\nif ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)\n  log_long_lookup(US\"name\", name, time_msec);\nreturn retval;\n}", "target": 0}
{"code": "void PDPServer::perform_builtin_endpoints_matching(\n        const ParticipantProxyData& pdata)\n{\n    if (mp_EDP != nullptr)\n    {\n        mp_EDP->assignRemoteEndpoints(pdata);\n    }\n    if (mp_builtin->mp_WLP != nullptr)\n    {\n        mp_builtin->mp_WLP->assignRemoteEndpoints(pdata);\n    }\n}", "target": 1}
{"code": "SMB2_open_free(struct smb_rqst *rqst)\n{\n\tint i;\n\tif (rqst && rqst->rq_iov) {\n\t\tcifs_small_buf_release(rqst->rq_iov[0].iov_base);\n\t\tfor (i = 1; i < rqst->rq_nvec; i++)\n\t\t\tif (rqst->rq_iov[i].iov_base != smb2_padding)\n\t\t\t\tkfree(rqst->rq_iov[i].iov_base);\n\t}\n}", "target": 0}
{"code": "kvm_irqfd(struct kvm *kvm, struct kvm_irqfd *args)\n{\n\tif (args->flags & ~(KVM_IRQFD_FLAG_DEASSIGN | KVM_IRQFD_FLAG_RESAMPLE))\n\t\treturn -EINVAL;\n\tif (args->gsi >= KVM_MAX_IRQ_ROUTES)\n\t\treturn -EINVAL;\n\tif (args->flags & KVM_IRQFD_FLAG_DEASSIGN)\n\t\treturn kvm_irqfd_deassign(kvm, args);\n\treturn kvm_irqfd_assign(kvm, args);\n}", "target": 0}
{"code": "XML_GetFeatureList(void) {\n  static const XML_Feature features[] = {\n    {XML_FEATURE_SIZEOF_XML_CHAR, XML_L(\"sizeof(XML_Char)\"), sizeof(XML_Char)},\n    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L(\"sizeof(XML_LChar)\"),\n     sizeof(XML_LChar)},\n#ifdef XML_UNICODE\n    {XML_FEATURE_UNICODE, XML_L(\"XML_UNICODE\"), 0},\n#endif\n#ifdef XML_UNICODE_WCHAR_T\n    {XML_FEATURE_UNICODE_WCHAR_T, XML_L(\"XML_UNICODE_WCHAR_T\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_DTD, XML_L(\"XML_DTD\"), 0},\n#endif\n#if XML_CONTEXT_BYTES > 0\n    {XML_FEATURE_CONTEXT_BYTES, XML_L(\"XML_CONTEXT_BYTES\"), XML_CONTEXT_BYTES},\n#endif\n#ifdef XML_MIN_SIZE\n    {XML_FEATURE_MIN_SIZE, XML_L(\"XML_MIN_SIZE\"), 0},\n#endif\n#ifdef XML_NS\n    {XML_FEATURE_NS, XML_L(\"XML_NS\"), 0},\n#endif\n#ifdef XML_LARGE_SIZE\n    {XML_FEATURE_LARGE_SIZE, XML_L(\"XML_LARGE_SIZE\"), 0},\n#endif\n#ifdef XML_ATTR_INFO\n    {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n     XML_L(\"XML_BLAP_MAX_AMP\"),\n     (long int)\n         EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT},\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT,\n     XML_L(\"XML_BLAP_ACT_THRES\"),\n     EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT},\n#endif\n    {XML_FEATURE_END, NULL, 0}\n  };\n  return features;\n}", "target": 1}
{"code": "njs_typed_array_get_string_tag(njs_vm_t *vm, njs_value_t *args,\n    njs_uint_t nargs, njs_index_t unused)\n{\n    njs_value_t  *this;\n    static const njs_value_t  *tags[NJS_OBJ_TYPE_TYPED_ARRAY_SIZE] = {\n        &njs_typed_array_uint8_tag,\n        &njs_typed_array_uint8_clamped_tag,\n        &njs_typed_array_int8_tag,\n        &njs_typed_array_uint16_tag,\n        &njs_typed_array_int16_tag,\n        &njs_typed_array_uint32_tag,\n        &njs_typed_array_int32_tag,\n        &njs_typed_array_float32_tag,\n        &njs_typed_array_float64_tag,\n    };\n    this = njs_argument(args, 0);\n    if (!njs_is_typed_array(this)) {\n        njs_set_undefined(&vm->retval);\n        return NJS_OK;\n    }\n    vm->retval = *tags[njs_typed_array_index(njs_typed_array(this)->type)];\n    return NJS_OK;\n}", "target": 0}
{"code": "static VALUE read_memory(VALUE klass, VALUE content)\n{\n  xmlRelaxNGParserCtxtPtr ctx = xmlRelaxNGNewMemParserCtxt(\n      (const char *)StringValuePtr(content),\n      (int)RSTRING_LEN(content)\n  );\n  xmlRelaxNGPtr schema;\n  VALUE errors = rb_ary_new();\n  VALUE rb_schema;\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    (void *)errors\n  );\n#endif\n  schema = xmlRelaxNGParse(ctx);\n  xmlSetStructuredErrorFunc(NULL, NULL);\n  xmlRelaxNGFreeParserCtxt(ctx);\n  if(NULL == schema) {\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n    return Qnil;\n  }\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  return rb_schema;\n}", "target": 1}
{"code": "static void spl_array_rewind_ex(spl_array_object *intern, HashTable *aht TSRMLS_DC) \n{\n\tzend_hash_internal_pointer_reset_ex(aht, &intern->pos);\n\tspl_array_update_pos(intern);\n\tspl_array_skip_protected(intern, aht TSRMLS_CC);\n} ", "target": 0}
{"code": "long ZEXPORT inflateMark(strm)\nz_streamp strm;\n{\n    struct inflate_state FAR *state;\n    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;\n    state = (struct inflate_state FAR *)strm->state;\n    return ((long)(state->back) << 16) +\n        (state->mode == COPY ? state->length :\n            (state->mode == MATCH ? state->was - state->length : 0));\n}", "target": 1}
{"code": "static void dhcps_send_offer(struct pbuf *packet_buffer)\n{\n\tuint8_t temp_ip = 0;\n\tdhcp_message_repository = (struct dhcp_msg *)packet_buffer->payload;\t\n#if (!IS_USE_FIXED_IP) \t\n\ttemp_ip = check_client_request_ip(&client_request_ip, client_addr);\n\tif(temp_ip == 0)\n\t\ttemp_ip = search_next_ip();\n#if (debug_dhcps)\t\n\tprintf(\"\\r\\n temp_ip = %d\",temp_ip);\n#endif\t\n\tif (temp_ip == 0) {\n#if 0\t\n\t  \tmemset(&ip_table, 0, sizeof(struct table));\n\t\tmark_ip_in_table((uint8_t)ip4_addr4(&dhcps_local_address));\n\t\tprintf(\"\\r\\n reset ip table!!\\r\\n\");\t\n#endif\t\n\t\tprintf(\"\\r\\n No useable ip!!!!\\r\\n\");\n\t}\n\tprintf(\"\\n\\r[%d]DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),temp_ip);\n\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), temp_ip);\n#endif   \n\tdhcps_initialize_message(dhcp_message_repository);\n\tadd_offer_options(add_msg_type(&dhcp_message_repository->options[4],\n\t\t\tDHCP_MESSAGE_TYPE_OFFER));\n\tudp_sendto_if(dhcps_pcb, packet_buffer,\n\t\t\t&dhcps_send_broadcast_address, DHCP_CLIENT_PORT, dhcps_netif);\n}", "target": 1}
{"code": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}", "target": 1}
{"code": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}", "target": 1}
{"code": "static void start_daemon()\n{\n\tstruct usb_sock_t *usb_sock;\n\tif (g_options.noprinter_mode == 0) {\n\t\tusb_sock = usb_open();\n\t\tif (usb_sock == NULL)\n\t\t\tgoto cleanup_usb;\n\t} else\n\t\tusb_sock = NULL;\n\tuint16_t desired_port = g_options.desired_port;\n\tstruct tcp_sock_t *tcp_socket;\n\twhile ((tcp_socket = tcp_open(desired_port)) == NULL &&\n\t       g_options.only_desired_port == 0) {\n\t\tdesired_port ++;\n\t\tif (desired_port == 1 || desired_port == 0)\n\t\t\tdesired_port = 49152;\n\t}\n\tif (tcp_socket == NULL)\n\t\tgoto cleanup_tcp;\n\tuint16_t real_port = tcp_port_number_get(tcp_socket);\n\tif (desired_port != 0 && g_options.only_desired_port == 1 &&\n\t    desired_port != real_port) {\n\t\tERR(\"Received port number did not match requested port number.\"\n\t\t    \" The requested port number may be too high.\");\n\t\tgoto cleanup_tcp;\n\t}\n\tprintf(\"%u|\", real_port);\n\tfflush(stdout);\n\tuint16_t pid;\n\tif (!g_options.nofork_mode && (pid = fork()) > 0) {\n\t\tprintf(\"%u|\", pid);\n\t\texit(0);\n\t}\n\tif (usb_can_callback(usb_sock))\n\t\tusb_register_callback(usb_sock);\n\tfor (;;) {\n\t\tstruct service_thread_param *args = calloc(1, sizeof(*args));\n\t\tif (args == NULL) {\n\t\t\tERR(\"Failed to alloc space for thread args\");\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\targs->usb_sock = usb_sock;\n\t\targs->tcp = tcp_conn_accept(tcp_socket);\n\t\tif (args->tcp == NULL) {\n\t\t\tERR(\"Failed to open tcp connection\");\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\tint status = pthread_create(&args->thread_handle, NULL,\n\t\t                            &service_connection, args);\n\t\tif (status) {\n\t\t\tERR(\"Failed to spawn thread, error %d\", status);\n\t\t\tgoto cleanup_thread;\n\t\t}\n\t\tcontinue;\n\tcleanup_thread:\n\t\tif (args != NULL) {\n\t\t\tif (args->tcp != NULL)\n\t\t\t\ttcp_conn_close(args->tcp);\n\t\t\tfree(args);\n\t\t}\n\t\tbreak;\n\t}\ncleanup_tcp:\n\tif (tcp_socket!= NULL)\n\t\ttcp_close(tcp_socket);\ncleanup_usb:\n\tif (usb_sock != NULL)\n\t\tusb_close(usb_sock);\n\treturn;\n}", "target": 1}
{"code": "pci_lintr_route(struct pci_vdev *dev)\n{\n\tstruct businfo *bi;\n\tstruct intxinfo *ii;\n\tif (dev->lintr.pin == 0)\n\t\treturn;\n\tbi = pci_businfo[dev->bus];\n\tassert(bi != NULL);\n\tii = &bi->slotinfo[dev->slot].si_intpins[dev->lintr.pin - 1];\n\tif (ii->ii_ioapic_irq == 0)\n\t\tii->ii_ioapic_irq = ioapic_pci_alloc_irq(dev);\n\tassert(ii->ii_ioapic_irq > 0);\n\tif (ii->ii_pirq_pin == 0)\n\t\tii->ii_pirq_pin = pirq_alloc_pin(dev);\n\tassert(ii->ii_pirq_pin > 0);\n\tdev->lintr.ioapic_irq = ii->ii_ioapic_irq;\n\tdev->lintr.pirq_pin = ii->ii_pirq_pin;\n\tpci_set_cfgdata8(dev, PCIR_INTLINE, pirq_irq(ii->ii_pirq_pin));\n}", "target": 1}
{"code": "static void on_umock_c_error(UMOCK_C_ERROR_CODE error_code)\n{\n    ASSERT_FAIL(\"umock_c reported error :%\" PRI_MU_ENUM \"\", MU_ENUM_VALUE(UMOCK_C_ERROR_CODE, error_code));\n}", "target": 0}
{"code": "static int hashtable_do_del(hashtable_t *hashtable,\n                            const char *key, size_t hash)\n{\n    pair_t *pair;\n    bucket_t *bucket;\n    size_t index;\n    index = hash % num_buckets(hashtable);\n    bucket = &hashtable->buckets[index];\n    pair = hashtable_find_pair(hashtable, bucket, key, hash);\n    if(!pair)\n        return -1;\n    if(&pair->list == bucket->first && &pair->list == bucket->last)\n        bucket->first = bucket->last = &hashtable->list;\n    else if(&pair->list == bucket->first)\n        bucket->first = pair->list.next;\n    else if(&pair->list == bucket->last)\n        bucket->last = pair->list.prev;\n    list_remove(&pair->list);\n    json_decref(pair->value);\n    jsonp_free(pair);\n    hashtable->size--;\n    return 0;\n}", "target": 1}
{"code": "bool CoinSpend::HasValidSerial() const\n{\n\treturn coinSerialNumber > 0 && coinSerialNumber < params->coinCommitmentGroup.groupOrder;\n}", "target": 0}
{"code": "h2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tconst char *b;\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (r2->req->req_body_status == REQ_BODY_NONE) {\n\t\tr2->state = H2_S_CLOS_REM;\n\t}\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tAZ(r2->req->ws->r);\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t\n\tif (req->req_body_status == REQ_BODY_INIT) {\n\t\tif (!http_GetHdr(req->http, H_Content_Length, &b))\n\t\t\treq->req_body_status = REQ_BODY_WITHOUT_LEN;\n\t\telse\n\t\t\treq->req_body_status = REQ_BODY_WITH_LEN;\n\t} else {\n\t\tassert (req->req_body_status == REQ_BODY_NONE);\n\t\tif (http_GetContentLength(req->http) > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); \n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task.func = h2_do_req;\n\treq->task.priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, &req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); \n\t}\n\treturn (0);\n}", "target": 1}
{"code": "void lzxd_free(struct lzxd_stream *lzx) {\n  struct mspack_system *sys;\n  if (lzx) {\n    sys = lzx->sys;\n    sys->free(lzx->inbuf);\n    sys->free(lzx->window);\n    sys->free(lzx);\n  }\n}", "target": 1}
{"code": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}", "target": 1}
{"code": "qemuProcessHandleMonitorEOF(qemuMonitorPtr mon,\n                            virDomainObjPtr vm,\n                            void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv;\n    struct qemuProcessEvent *processEvent;\n    virObjectLock(vm);\n    VIR_DEBUG(\"Received EOF on %p '%s'\", vm, vm->def->name);\n    priv = vm->privateData;\n    if (priv->beingDestroyed) {\n        VIR_DEBUG(\"Domain is being destroyed, EOF is expected\");\n        goto cleanup;\n    }\n    processEvent = g_new0(struct qemuProcessEvent, 1);\n    processEvent->eventType = QEMU_PROCESS_EVENT_MONITOR_EOF;\n    processEvent->vm = virObjectRef(vm);\n    if (virThreadPoolSendJob(driver->workerPool, 0, processEvent) < 0) {\n        virObjectUnref(vm);\n        qemuProcessEventFree(processEvent);\n        goto cleanup;\n    }\n    virObjectLock(mon);\n    qemuMonitorUnregister(mon);\n    virObjectUnlock(mon);\n    qemuDomainDestroyNamespace(driver, vm);\n cleanup:\n    virObjectUnlock(vm);\n}", "target": 0}
{"code": "int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)\n{\n\tstruct ip_options *opt;\n\topt = inet_sk(sk)->opt;\n\tif (opt == NULL || opt->cipso == 0)\n\t\treturn -ENOMSG;\n\treturn cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),\n\t\t\t\tsecattr);\n}", "target": 1}
{"code": "static ssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\tif (segment_eq(get_fs(), KERNEL_DS))\n\t\tflags |= AOP_FLAG_UNINTERRUPTIBLE;\n\tdo {\n\t\tstruct page *page;\n\t\tpgoff_t index;\t\t\n\t\tunsigned long offset;\t\n\t\tunsigned long bytes;\t\n\t\tsize_t copied;\t\t\n\t\tvoid *fsdata;\n\t\toffset = (pos & (PAGE_CACHE_SIZE - 1));\n\t\tindex = pos >> PAGE_CACHE_SHIFT;\n\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_count(i));\nagain:\n\t\tif (unlikely(iov_iter_fault_in_readable(i, bytes))) {\n\t\t\tstatus = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags,\n\t\t\t\t\t\t&page, &fsdata);\n\t\tif (unlikely(status))\n\t\t\tbreak;\n\t\tpagefault_disable();\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);\n\t\tpagefault_enable();\n\t\tflush_dcache_page(page);\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied,\n\t\t\t\t\t\tpage, fsdata);\n\t\tif (unlikely(status < 0))\n\t\t\tbreak;\n\t\tcopied = status;\n\t\tcond_resched();\n\t\tif (unlikely(copied == 0)) {\n\t\t\tbytes = min_t(unsigned long, PAGE_CACHE_SIZE - offset,\n\t\t\t\t\t\tiov_iter_single_seg_count(i));\n\t\t\tgoto again;\n\t\t}\n\t\tiov_iter_advance(i, copied);\n\t\tpos += copied;\n\t\twritten += copied;\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t} while (iov_iter_count(i));\n\treturn written ? written : status;\n}", "target": 1}
{"code": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}", "target": 1}
{"code": "static void adpt_ia64_info(sysInfo_S* si)\n{\n\tsi->processorType = PROC_IA64;\n}", "target": 1}
{"code": "static int adpt_i2o_online_hba(adpt_hba* pHba)\n{\n\tif (adpt_i2o_systab_send(pHba) < 0)\n\t\treturn -1;\n\tif (adpt_i2o_enable_hba(pHba) < 0)\n\t\treturn -1;\n\treturn 0;\n}", "target": 1}
{"code": "linkaddr_string(netdissect_options *ndo, const u_char *ep,\n\t\tconst unsigned int type, const unsigned int len)\n{\n\tregister u_int i;\n\tregister char *cp;\n\tregister struct enamemem *tp;\n\tif (len == 0)\n\t\treturn (\"<empty>\");\n\tif (type == LINKADDR_ETHER && len == ETHER_ADDR_LEN)\n\t\treturn (etheraddr_string(ndo, ep));\n\tif (type == LINKADDR_FRELAY)\n\t\treturn (q922_string(ndo, ep, len));\n\ttp = lookup_bytestring(ndo, ep, len);\n\tif (tp->e_name)\n\t\treturn (tp->e_name);\n\ttp->e_name = cp = (char *)malloc(len*3);\n\tif (tp->e_name == NULL)\n\t\t(*ndo->ndo_error)(ndo, \"linkaddr_string: malloc\");\n\t*cp++ = hex[*ep >> 4];\n\t*cp++ = hex[*ep++ & 0xf];\n\tfor (i = len-1; i > 0 ; --i) {\n\t\t*cp++ = ':';\n\t\t*cp++ = hex[*ep >> 4];\n\t\t*cp++ = hex[*ep++ & 0xf];\n\t}\n\t*cp = '\\0';\n\treturn (tp->e_name);\n}", "target": 1}
{"code": "TEST_F(QueryPlannerTest, InSparseIndex) {\n    addIndex(fromjson(\"{a: 1}\"),\n             false,  \n             true);  \n    runQuery(fromjson(\"{a: {$in: [null]}}\"));\n    assertNumSolutions(1U);\n    assertSolutionExists(\"{cscan: {dir: 1, filter: {a: {$eq: null}}}}\");\n}", "target": 0}
{"code": "bool CSPSource::portMatches(const KURL& url) const\n{\n    if (m_portWildcard == HasWildcard)\n        return true;\n    int port = url.port();\n    if (port == m_port)\n        return true;\n    if (!port)\n        return isDefaultPortForProtocol(m_port, url.protocol());\n    if (!m_port)\n        return isDefaultPortForProtocol(port, url.protocol());\n    return false;\n}", "target": 0}
{"code": "CompileResult generateBytecodeForSerialization(\n    raw_ostream &OS,\n    Module &M,\n    const BytecodeGenerationOptions &genOptions,\n    const SHA1 &sourceHash,\n    hermes::OptValue<uint32_t> segment,\n    SourceMapGenerator *sourceMapGenOrNull,\n    BaseBytecodeMap &baseBytecodeMap) {\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    std::unique_ptr<hbc::BCProviderFromBuffer> baseBCProvider = nullptr;\n    auto itr = baseBytecodeMap.find(segment ? *segment : 0);\n    if (itr != baseBytecodeMap.end()) {\n      baseBCProvider = std::move(itr->second);\n      baseBytecodeMap.erase(itr);\n    }\n    auto bytecodeModule = hbc::generateBytecode(\n        &M,\n        OS,\n        genOptions,\n        sourceHash,\n        segment,\n        sourceMapGenOrNull,\n        std::move(baseBCProvider));\n    if (auto N = M.getContext().getSourceErrorManager().getErrorCount()) {\n      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\";\n      return BackendError;\n    }\n    if (cl::DumpTarget == DumpBytecode) {\n      disassembleBytecode(hbc::BCProviderFromSrc::createBCProviderFromSrc(\n          std::move(bytecodeModule)));\n    }\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind\");\n  }\n  return Success;\n}", "target": 0}
{"code": "comics_document_thumbnails_get_thumbnail (EvDocumentThumbnails *document,\n\t\t\t\t\t  EvRenderContext      *rc,\n\t\t\t\t\t  gboolean              border)\n{\n\tGdkPixbuf *thumbnail;\n\tthumbnail = comics_document_render_pixbuf (EV_DOCUMENT (document), rc);\n\tif (border) {\n\t      GdkPixbuf *tmp_pixbuf = thumbnail;\n\t      thumbnail = ev_document_misc_get_thumbnail_frame (-1, -1, tmp_pixbuf);\n\t      g_object_unref (tmp_pixbuf);\n\t}\n\treturn thumbnail;\n}", "target": 1}
{"code": "static int parse_video_info(AVIOContext *pb, AVStream *st)\n{\n    uint16_t size_asf; \n    uint32_t size_bmp; \n    unsigned int tag;\n    st->codecpar->width  = avio_rl32(pb);\n    st->codecpar->height = avio_rl32(pb);\n    avio_skip(pb, 1); \n    size_asf = avio_rl16(pb);\n    tag = ff_get_bmp_header(pb, st, &size_bmp);\n    st->codecpar->codec_tag = tag;\n    st->codecpar->codec_id  = ff_codec_get_id(ff_codec_bmp_tags, tag);\n    size_bmp = FFMAX(size_asf, size_bmp);\n    if (size_bmp > BMP_HEADER_SIZE) {\n        int ret;\n        st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;\n        if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size +\n                                               AV_INPUT_BUFFER_PADDING_SIZE))) {\n            st->codecpar->extradata_size = 0;\n            return AVERROR(ENOMEM);\n        }\n        memset(st->codecpar->extradata + st->codecpar->extradata_size , 0,\n               AV_INPUT_BUFFER_PADDING_SIZE);\n        if ((ret = avio_read(pb, st->codecpar->extradata,\n                             st->codecpar->extradata_size)) < 0)\n            return ret;\n    }\n    return 0;\n}", "target": 1}
{"code": "static struct nfs4_state *nfs4_opendata_to_nfs4_state(struct nfs4_opendata *data)\n{\n\tstruct inode *inode;\n\tstruct nfs4_state *state = NULL;\n\tstruct nfs_delegation *delegation;\n\tint ret;\n\tif (!data->rpc_done) {\n\t\tstate = nfs4_try_open_cached(data);\n\t\tgoto out;\n\t}\n\tret = -EAGAIN;\n\tif (!(data->f_attr.valid & NFS_ATTR_FATTR))\n\t\tgoto err;\n\tinode = nfs_fhget(data->dir->d_sb, &data->o_res.fh, &data->f_attr);\n\tret = PTR_ERR(inode);\n\tif (IS_ERR(inode))\n\t\tgoto err;\n\tret = -ENOMEM;\n\tstate = nfs4_get_open_state(inode, data->owner);\n\tif (state == NULL)\n\t\tgoto err_put_inode;\n\tif (data->o_res.delegation_type != 0) {\n\t\tint delegation_flags = 0;\n\t\trcu_read_lock();\n\t\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\t\tif (delegation)\n\t\t\tdelegation_flags = delegation->flags;\n\t\trcu_read_unlock();\n\t\tif ((delegation_flags & 1UL<<NFS_DELEGATION_NEED_RECLAIM) == 0)\n\t\t\tnfs_inode_set_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t\telse\n\t\t\tnfs_inode_reclaim_delegation(state->inode,\n\t\t\t\t\tdata->owner->so_cred,\n\t\t\t\t\t&data->o_res);\n\t}\n\tupdate_open_stateid(state, &data->o_res.stateid, NULL,\n\t\t\tdata->o_arg.open_flags);\n\tiput(inode);\nout:\n\treturn state;\nerr_put_inode:\n\tiput(inode);\nerr:\n\treturn ERR_PTR(ret);\n}", "target": 1}
{"code": "usage (const char *prog)\n{\n\tg_print (\"- Lists file in a supported archive format\\n\");\n\tg_print (\"Usage: %s archive-type filename\\n\", prog);\n\tg_print (\"Where archive-type is one of rar, zip, 7z or tar\\n\");\n}", "target": 0}
{"code": "static int adpt_abort(struct scsi_cmnd * cmd)\n{\n\tadpt_hba* pHba = NULL;\t\n\tstruct adpt_device* dptdevice;\t\n\tu32 msg[5];\n\tint rcode;\n\tpHba = (adpt_hba*) cmd->device->host->hostdata[0];\n\tprintk(KERN_INFO\"%s: Trying to Abort\\n\",pHba->name);\n\tif ((dptdevice = (void*) (cmd->device->hostdata)) == NULL) {\n\t\tprintk(KERN_ERR \"%s: Unable to abort: No device in cmnd\\n\",pHba->name);\n\t\treturn FAILED;\n\t}\n\tmemset(msg, 0, sizeof(msg));\n\tmsg[0] = FIVE_WORD_MSG_SIZE|SGL_OFFSET_0;\n\tmsg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;\n\tmsg[2] = 0;\n\tmsg[3]= 0;\n\tmsg[4] = scsi_cmd_to_rq(cmd)->tag + 1;\n\tif (pHba->host)\n\t\tspin_lock_irq(pHba->host->host_lock);\n\trcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER);\n\tif (pHba->host)\n\t\tspin_unlock_irq(pHba->host->host_lock);\n\tif (rcode != 0) {\n\t\tif(rcode == -EOPNOTSUPP ){\n\t\t\tprintk(KERN_INFO\"%s: Abort cmd not supported\\n\",pHba->name);\n\t\t\treturn FAILED;\n\t\t}\n\t\tprintk(KERN_INFO\"%s: Abort failed.\\n\",pHba->name);\n\t\treturn FAILED;\n\t} \n\tprintk(KERN_INFO\"%s: Abort complete.\\n\",pHba->name);\n\treturn SUCCESS;\n}", "target": 1}
{"code": "exo_open_uri_known_category (const gchar  *uri,\n                             const gchar  *scheme,\n                             gboolean     *succeed)\n{\n  guint        i;\n  const gchar *category = NULL;\n  g_return_val_if_fail (uri != NULL, FALSE);\n  g_return_val_if_fail (scheme != NULL, FALSE);\n  for (i = 0; category == NULL && i < G_N_ELEMENTS (known_schemes); i++)\n    {\n      if (g_regex_match_simple (known_schemes[i].pattern, scheme, G_REGEX_CASELESS, 0))\n        {\n          *succeed = exo_open_launch_category (known_schemes[i].category, uri);\n          return TRUE;\n        }\n    }\n  return FALSE;\n}", "target": 0}
{"code": "int unit_name_path_escape(const char *f, char **ret) {\n        char *p, *s;\n        assert(f);\n        assert(ret);\n        p = strdupa(f);\n        if (!p)\n                return -ENOMEM;\n        path_simplify(p, false);\n        if (empty_or_root(p))\n                s = strdup(\"-\");\n        else {\n                if (!path_is_normalized(p))\n                        return -EINVAL;\n                delete_trailing_chars(p, \"/\");\n                p = skip_leading_chars(p, \"/\");\n                s = unit_name_escape(p);\n        }\n        if (!s)\n                return -ENOMEM;\n        *ret = s;\n        return 0;\n}", "target": 1}
{"code": "find_by_thp(struct tang_keys_info* tki, const char* target)\n{\n    if (!tki) {\n        return NULL;\n    }\n    json_auto_t* keys = json_deep_copy(tki->m_keys);\n    json_array_extend(keys, tki->m_rotated_keys);\n    size_t idx;\n    json_t* jwk;\n    const char** hashes = supported_hashes();\n    json_array_foreach(keys, idx, jwk) {\n        for (int i = 0; hashes[i]; i++) {\n            __attribute__ ((__cleanup__(cleanup_str))) char* thumbprint = jwk_thumbprint(jwk, hashes[i]);\n            if (!thumbprint || strcmp(thumbprint, target) != 0) {\n                continue;\n            }\n            if (jwk_valid_for_deriving_keys(jwk)) {\n                return json_incref(jwk);\n            } else if (jwk_valid_for_signing(jwk)) {\n                json_auto_t* sign = json_deep_copy(tki->m_sign);\n                if (json_array_append(sign, jwk) == -1) {\n                    return NULL;\n                }\n                json_auto_t* jws = jwk_sign(tki->m_payload, sign);\n                if (!jws) {\n                    return NULL;\n                }\n                return json_incref(jws);\n            }\n        }\n    }\n    return NULL;\n}", "target": 1}
{"code": "int ntlm_read_ntlm_v2_response(wStream* s, NTLMv2_RESPONSE* response)\n{\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn -1;\n\tStream_Read(s, response->Response, 16);\n\treturn ntlm_read_ntlm_v2_client_challenge(s, &(response->Challenge));\n}", "target": 0}
{"code": "static const EVP_MD *tpm_algorithm_to_openssl_digest(TPMI_ALG_HASH algorithm) {\n    switch(algorithm) {\n    case TPM_ALG_SHA1:\n        return EVP_sha1();\n    case ALG_SHA256_VALUE:\n        return EVP_sha256();\n    case TPM_ALG_SHA384:\n        return EVP_sha384();\n    case TPM_ALG_SHA512:\n        return EVP_sha512();\n    default:\n        return NULL;\n    }\n}", "target": 0}
{"code": "bool TABLE_REF::tmp_table_index_lookup_init(THD *thd,\n                                            KEY *tmp_key,\n                                            Item_iterator &it,\n                                            bool value,\n                                            uint skip)\n{\n  uint tmp_key_parts= tmp_key->user_defined_key_parts;\n  uint i;\n  DBUG_ENTER(\"TABLE_REF::tmp_table_index_lookup_init\");\n  key= 0; \n  key_length= tmp_key->key_length;\n  if (!(key_buff=\n        (uchar*) thd->calloc(ALIGN_SIZE(tmp_key->key_length) * 2)) ||\n      !(key_copy=\n        (store_key**) thd->alloc((sizeof(store_key*) *\n                                  (tmp_key_parts + 1)))) ||\n      !(items=\n        (Item**) thd->alloc(sizeof(Item*) * tmp_key_parts)))\n    DBUG_RETURN(TRUE);\n  key_buff2= key_buff + ALIGN_SIZE(tmp_key->key_length);\n  KEY_PART_INFO *cur_key_part= tmp_key->key_part;\n  store_key **ref_key= key_copy;\n  uchar *cur_ref_buff= key_buff;\n  it.open();\n  for (i= 0; i < skip; i++) it.next();\n  for (i= 0; i < tmp_key_parts; i++, cur_key_part++, ref_key++)\n  {\n    Item *item= it.next();\n    DBUG_ASSERT(item);\n    items[i]= item;\n    int null_count= MY_TEST(cur_key_part->field->real_maybe_null());\n    *ref_key= new store_key_item(thd, cur_key_part->field,\n                                 cur_ref_buff + null_count,\n                                 null_count ? cur_ref_buff : 0,\n                                 cur_key_part->length, items[i], value);\n    cur_ref_buff+= cur_key_part->store_length;\n  }\n  *ref_key= NULL; \n  key_err= 1;\n  key_parts= tmp_key_parts;\n  DBUG_RETURN(FALSE);\n}", "target": 0}
{"code": "htp_status_t htp_connp_REQ_PROTOCOL(htp_connp_t *connp) {\n    if (connp->in_tx->is_protocol_0_9 == 0) {\n        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        int64_t pos = connp->in_current_read_offset;\n        if (connp->in_current_len > connp->in_current_read_offset + HTTP09_MAX_JUNK_LEN) {\n            htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n            connp->in_tx->is_protocol_0_9 = 0;\n            connp->in_state = htp_connp_REQ_HEADERS;\n            connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n            return HTP_OK;\n        }\n        while (pos < connp->in_current_len) {\n            if (!htp_is_space(connp->in_current_data[pos])) {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            }\n            pos++;\n        }\n        connp->in_state = htp_connp_REQ_FINALIZE;\n    }\n    return HTP_OK;\n}", "target": 0}
{"code": "RCMS *r_pkcs7_parse_cms (const ut8 *buffer, ut32 length) {\n\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}", "target": 1}
{"code": "void SmallVectorTemplateBase<T, isPodLike>::grow(size_t MinSize) {\n  if (MinSize > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n  size_t NewCapacity = size_t(NextPowerOf2(this->capacity() + 2));\n  NewCapacity = std::min(std::max(NewCapacity, MinSize), size_t(UINT32_MAX));\n  T *NewElts = static_cast<T*>(llvh::safe_malloc(NewCapacity*sizeof(T)));\n  this->uninitialized_move(this->begin(), this->end(), NewElts);\n  destroy_range(this->begin(), this->end());\n  if (!this->isSmall())\n    free(this->begin());\n  this->BeginX = NewElts;\n  this->Capacity = NewCapacity;\n}", "target": 1}
{"code": "void WasmBinaryBuilder::readDylink0(size_t payloadLen) {\n  BYN_TRACE(\"== readDylink0\\n\");\n  auto sectionPos = pos;\n  uint32_t lastType = 0;\n  wasm.dylinkSection = make_unique<DylinkSection>();\n  while (pos < sectionPos + payloadLen) {\n    auto oldPos = pos;\n    auto dylinkType = getU32LEB();\n    if (lastType && dylinkType <= lastType) {\n      std::cerr << \"warning: out-of-order dylink.0 subsection: \" << dylinkType\n                << std::endl;\n    }\n    lastType = dylinkType;\n    auto subsectionSize = getU32LEB();\n    auto subsectionPos = pos;\n    if (dylinkType == BinaryConsts::UserSections::Subsection::DylinkMemInfo) {\n      wasm.dylinkSection->memorySize = getU32LEB();\n      wasm.dylinkSection->memoryAlignment = getU32LEB();\n      wasm.dylinkSection->tableSize = getU32LEB();\n      wasm.dylinkSection->tableAlignment = getU32LEB();\n    } else if (dylinkType ==\n               BinaryConsts::UserSections::Subsection::DylinkNeeded) {\n      size_t numNeededDynlibs = getU32LEB();\n      for (size_t i = 0; i < numNeededDynlibs; ++i) {\n        wasm.dylinkSection->neededDynlibs.push_back(getInlineString());\n      }\n    } else {\n      pos = oldPos;\n      size_t remaining = (sectionPos + payloadLen) - pos;\n      auto tail = getByteView(remaining);\n      wasm.dylinkSection->tail = {tail.first, tail.second};\n      break;\n    }\n    if (pos != subsectionPos + subsectionSize) {\n      throwError(\"bad dylink.0 subsection position change\");\n    }\n  }\n}", "target": 0}
{"code": "const char *string_of_NPNVariable(int variable)\n{\n  const char *str;\n  switch (variable) {\n#define _(VAL) case VAL: str = #VAL; break;\n\t_(NPNVxDisplay);\n\t_(NPNVxtAppContext);\n\t_(NPNVnetscapeWindow);\n\t_(NPNVjavascriptEnabledBool);\n\t_(NPNVasdEnabledBool);\n\t_(NPNVisOfflineBool);\n\t_(NPNVserviceManager);\n\t_(NPNVDOMElement);\n\t_(NPNVDOMWindow);\n\t_(NPNVToolkit);\n\t_(NPNVSupportsXEmbedBool);\n\t_(NPNVWindowNPObject);\n\t_(NPNVPluginElementNPObject);\n\t_(NPNVSupportsWindowless);\n\t_(NPNVprivateModeBool);\n\t_(NPNVsupportsAdvancedKeyHandling);\n#undef _\n  default:\n\tswitch (variable & 0xff) {\n#define _(VAL, VAR) case VAL: str = #VAR; break\n\t  _(10, NPNVserviceManager);\n\t  _(11, NPNVDOMElement);\n\t  _(12, NPNVDOMWindow);\n\t  _(13, NPNVToolkit);\n#undef _\n\tdefault:\n\t  str = \"<unknown variable>\";\n\t  break;\n\t}\n\tbreak;\n  }\n  return str;\n}", "target": 0}
{"code": "int sub__remove(struct mosquitto *context, const char *sub, uint8_t *reason)\n{\n\tint rc = 0;\n\tstruct mosquitto__subhier *subhier;\n\tconst char *sharename = NULL;\n\tchar *local_sub = NULL;\n\tchar **topics = NULL;\n\tassert(sub);\n\trc = sub__topic_tokenise(sub, &local_sub, &topics, &sharename);\n\tif(rc) return rc;\n\tHASH_FIND(hh, db.subs, topics[0], strlen(topics[0]), subhier);\n\tif(subhier){\n\t\t*reason = MQTT_RC_NO_SUBSCRIPTION_EXISTED;\n\t\trc = sub__remove_recurse(context, subhier, topics, reason, sharename);\n\t}\n\tmosquitto__free(local_sub);\n\tmosquitto__free(topics);\n\treturn rc;\n}", "target": 1}
{"code": "yang_free_nodes(struct ly_ctx *ctx, struct lys_node *node)\n{\n    struct lys_node *tmp, *child, *sibling;\n    if (!node) {\n        return;\n    }\n    tmp = node;\n    while (tmp) {\n        child = tmp->child;\n        sibling = tmp->next;\n        lydict_remove(ctx, tmp->name);\n        if (!(tmp->nodetype & (LYS_INPUT | LYS_OUTPUT))) {\n            lys_iffeature_free(ctx, tmp->iffeature, tmp->iffeature_size, 0, NULL);\n            lydict_remove(ctx, tmp->dsc);\n            lydict_remove(ctx, tmp->ref);\n        }\n        switch (tmp->nodetype) {\n        case LYS_GROUPING:\n        case LYS_RPC:\n        case LYS_ACTION:\n            yang_free_grouping(ctx, (struct lys_node_grp *)tmp);\n            break;\n        case LYS_CONTAINER:\n            yang_free_container(ctx, (struct lys_node_container *)tmp);\n            break;\n        case LYS_LEAF:\n            yang_free_leaf(ctx, (struct lys_node_leaf *)tmp);\n            break;\n        case LYS_LEAFLIST:\n            yang_free_leaflist(ctx, (struct lys_node_leaflist *)tmp);\n            break;\n        case LYS_LIST:\n            yang_free_list(ctx, (struct lys_node_list *)tmp);\n            break;\n        case LYS_CHOICE:\n            yang_free_choice(ctx, (struct lys_node_choice *)tmp);\n            break;\n        case LYS_CASE:\n            lys_when_free(ctx, ((struct lys_node_case *)tmp)->when, NULL);\n            break;\n        case LYS_ANYXML:\n        case LYS_ANYDATA:\n            yang_free_anydata(ctx, (struct lys_node_anydata *)tmp);\n            break;\n        case LYS_INPUT:\n        case LYS_OUTPUT:\n            yang_free_inout(ctx, (struct lys_node_inout *)tmp);\n            break;\n        case LYS_NOTIF:\n            yang_free_notif(ctx, (struct lys_node_notif *)tmp);\n            break;\n        case LYS_USES:\n            yang_free_uses(ctx, (struct lys_node_uses *)tmp);\n            break;\n        default:\n            break;\n        }\n        lys_extension_instances_free(ctx, tmp->ext, tmp->ext_size, NULL);\n        yang_free_nodes(ctx, child);\n        free(tmp);\n        tmp = sibling;\n    }\n}", "target": 0}
{"code": "relax_ng_parse(const char *path, xml_read_cb cb, void *arg)\n{\n\txmlTextReaderPtr reader;\n\txmlRelaxNGValidCtxtPtr rngvalidctx;\n\tint read;\n\tint error;\n\treader = xmlNewTextReaderFilename(path);\n\tif (reader == NULL)\n\t\treturn pr_val_err(\"Couldn't get XML '%s' file.\", path);\n\terror = xmlTextReaderRelaxNGSetSchema(reader, schema);\n\tif (error) {\n\t\terror = pr_val_err(\"Couldn't set Relax NG schema.\");\n\t\tgoto free_reader;\n\t}\n\trngvalidctx = xmlRelaxNGNewValidCtxt(schema);\n\tif (rngvalidctx == NULL) {\n\t\terror = pr_val_err(\"xmlRelaxNGNewValidCtxt() returned NULL\");\n\t\tgoto free_reader;\n\t}\n\txmlRelaxNGSetValidErrors(rngvalidctx, relax_ng_log_err,\n\t    relax_ng_log_warn, NULL);\n\terror = xmlTextReaderRelaxNGValidateCtxt(reader, rngvalidctx, 1);\n\tif (error) {\n\t\terror = pr_val_err(\"Invalid XML document\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlTextReaderSetStructuredErrorHandler(reader, relax_ng_log_str_err,\n\t    NULL);\n\twhile ((read = xmlTextReaderRead(reader)) == 1) {\n\t\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\t\tgoto free_valid_ctx;\n\t\t}\n\t\terror = cb(reader, arg);\n\t\tif (error)\n\t\t\tgoto free_valid_ctx;\n\t}\n\tif (read < 0) {\n\t\terror = pr_val_err(\"Error parsing XML document.\");\n\t\tgoto free_valid_ctx;\n\t}\n\tif (xmlTextReaderIsValid(reader) <= 0) {\n\t\terror = pr_val_err(\"XML document isn't valid.\");\n\t\tgoto free_valid_ctx;\n\t}\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\n\txmlFreeTextReader(reader);\n\treturn 0;\nfree_valid_ctx:\n\txmlRelaxNGFreeValidCtxt(rngvalidctx);\nfree_reader:\n\txmlFreeTextReader(reader);\n\treturn error;\n}", "target": 1}
{"code": "static void __xen_evtchn_do_upcall(void)\n{\n\tstruct vcpu_info *vcpu_info = __this_cpu_read(xen_vcpu);\n\tint cpu = smp_processor_id();\n\tstruct evtchn_loop_ctrl ctrl = { 0 };\n\tread_lock(&evtchn_rwlock);\n\tdo {\n\t\tvcpu_info->evtchn_upcall_pending = 0;\n\t\txen_evtchn_handle_events(cpu, &ctrl);\n\t\tBUG_ON(!irqs_disabled());\n\t\tvirt_rmb(); \n\t} while (vcpu_info->evtchn_upcall_pending);\n\tread_unlock(&evtchn_rwlock);\n\t__this_cpu_inc(irq_epoch);\n}", "target": 0}
{"code": "void _WM_do_pitch(struct _mdi *mdi, struct _event_data *data) {\n    struct _note *note_data = mdi->note;\n    uint8_t ch = data->channel;\n    MIDI_EVENT_DEBUG(__FUNCTION__,ch, data->data.value);\n    mdi->channel[ch].pitch = data->data.value - 0x2000;\n    if (mdi->channel[ch].pitch < 0) {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8192;\n    } else {\n        mdi->channel[ch].pitch_adjust = mdi->channel[ch].pitch_range\n        * mdi->channel[ch].pitch / 8191;\n    }\n    if (note_data) {\n        do {\n            if ((note_data->noteid >> 8) == ch) {\n                note_data->sample_inc = get_inc(mdi, note_data);\n            }\n            note_data = note_data->next;\n        } while (note_data);\n    }\n}", "target": 0}
{"code": "void AudioManagerBase::GetAudioInputDeviceNames(\n    media::AudioDeviceNames* device_names) {\n}", "target": 0}
{"code": "sasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\tif (! mu)\n\t{\n\t\tif (! *p->authzeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\treturn true;\n}", "target": 1}
{"code": "Variant HHVM_FUNCTION(mcrypt_get_block_size, const String& cipher,\n                                    const Variant& module ) {\n  MCRYPT td = mcrypt_module_open((char*)cipher.data(),\n                                 (char*)MCG(algorithms_dir).data(),\n                                 (char*)module.asCStrRef().data(),\n                                 (char*)MCG(modes_dir).data());\n  if (td == MCRYPT_FAILED) {\n    MCRYPT_OPEN_MODULE_FAILED(\"mcrypt_get_block_size\");\n    return false;\n  }\n  int64_t ret = mcrypt_enc_get_block_size(td);\n  mcrypt_module_close(td);\n  return ret;\n}", "target": 1}
{"code": "lrmd_remote_client_msg(gpointer data)\n{\n    int id = 0;\n    int rc = 0;\n    int disconnected = 0;\n    xmlNode *request = NULL;\n    crm_client_t *client = data;\n    if (client->remote->tls_handshake_complete == FALSE) {\n        int rc = 0;\n        do {\n            rc = gnutls_handshake(*client->remote->tls_session);\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote lrmd tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n        if (rc == 0) {\n            crm_debug(\"Remote lrmd tls handshake completed\");\n            client->remote->tls_handshake_complete = TRUE;\n            if (client->remote->auth_timeout) {\n                g_source_remove(client->remote->auth_timeout);\n            }\n            client->remote->auth_timeout = 0;\n            notify_of_new_client(client);\n        }\n        return 0;\n    }\n    rc = crm_remote_ready(client->remote, 0);\n    if (rc == 0) {\n        return 0;\n    } else if (rc < 0) {\n        crm_info(\"Client disconnected during remote client read\");\n        return -1;\n    }\n    crm_remote_recv(client->remote, -1, &disconnected);\n    request = crm_remote_parse_buffer(client->remote);\n    while (request) {\n        crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);\n        crm_trace(\"processing request from remote client with remote msg id %d\", id);\n        if (!client->name) {\n            const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);\n            if (value) {\n                client->name = strdup(value);\n            }\n        }\n        lrmd_call_id++;\n        if (lrmd_call_id < 1) {\n            lrmd_call_id = 1;\n        }\n        crm_xml_add(request, F_LRMD_CLIENTID, client->id);\n        crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);\n        crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);\n        process_lrmd_message(client, id, request);\n        free_xml(request);\n        request = crm_remote_parse_buffer(client->remote);\n    }\n    if (disconnected) {\n        crm_info(\"Client disconnect detected in tls msg dispatcher.\");\n        return -1;\n    }\n    return 0;\n}", "target": 0}
{"code": "ActivationPtr createActivation(Protobuf::Arena& arena, const StreamInfo::StreamInfo& info,\n                               const Http::RequestHeaderMap* request_headers,\n                               const Http::ResponseHeaderMap* response_headers,\n                               const Http::ResponseTrailerMap* response_trailers) {\n  auto activation = std::make_unique<Activation>();\n  activation->InsertValueProducer(Request,\n                                  std::make_unique<RequestWrapper>(arena, request_headers, info));\n  activation->InsertValueProducer(Response, std::make_unique<ResponseWrapper>(\n                                                arena, response_headers, response_trailers, info));\n  activation->InsertValueProducer(Connection, std::make_unique<ConnectionWrapper>(info));\n  activation->InsertValueProducer(Upstream, std::make_unique<UpstreamWrapper>(info));\n  activation->InsertValueProducer(Source, std::make_unique<PeerWrapper>(info, false));\n  activation->InsertValueProducer(Destination, std::make_unique<PeerWrapper>(info, true));\n  activation->InsertValueProducer(Metadata,\n                                  std::make_unique<MetadataProducer>(info.dynamicMetadata()));\n  activation->InsertValueProducer(FilterState,\n                                  std::make_unique<FilterStateWrapper>(info.filterState()));\n  return activation;\n}", "target": 0}
{"code": "MagickExport MagickBooleanType LinearStretchImage(Image *image,\n  const double black_point,const double white_point,ExceptionInfo *exception)\n{\n#define LinearStretchImageTag  \"LinearStretch/Image\"\n  CacheView\n    *image_view;\n  double\n    *histogram,\n    intensity;\n  MagickBooleanType\n    status;\n  ssize_t\n    black,\n    white,\n    y;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  histogram=(double *) AcquireQuantumMemory(MaxMap+1UL,sizeof(*histogram));\n  if (histogram == (double *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  (void) ResetMagickMemory(histogram,0,(MaxMap+1)*sizeof(*histogram));\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n    register ssize_t\n      x;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      intensity=GetPixelIntensity(image,p);\n      histogram[ScaleQuantumToMap(ClampToQuantum(intensity))]++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  intensity=0.0;\n  for (black=0; black < (ssize_t) MaxMap; black++)\n  {\n    intensity+=histogram[black];\n    if (intensity >= black_point)\n      break;\n  }\n  intensity=0.0;\n  for (white=(ssize_t) MaxMap; white != 0; white--)\n  {\n    intensity+=histogram[white];\n    if (intensity >= white_point)\n      break;\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  status=LevelImage(image,(double) ScaleMapToQuantum((MagickRealType) black),\n    (double) ScaleMapToQuantum((MagickRealType) white),1.0,exception);\n  return(status);\n}", "target": 0}
{"code": "static int filter_frame(AVFilterLink *inlink, AVFrame *in)\n{\n    GradFunContext *s = inlink->dst->priv;\n    AVFilterLink *outlink = inlink->dst->outputs[0];\n    AVFrame *out;\n    int p, direct;\n    if (av_frame_is_writable(in)) {\n        direct = 1;\n        out = in;\n    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n    for (p = 0; p < 4 && in->data[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n        if (FFMIN(w, h) > 2 * r)\n            filter(s, out->data[p], in->data[p], w, h, out->linesize[p], in->linesize[p], r);\n        else if (out->data[p] != in->data[p])\n            av_image_copy_plane(out->data[p], out->linesize[p], in->data[p], in->linesize[p], w, h);\n    }\n    if (!direct)\n        av_frame_free(&in);\n    return ff_filter_frame(outlink, out);\n}", "target": 1}
{"code": "bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  \n        ||  0==strcmp(symnam, \"__libc_init\")  \n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}", "target": 1}
{"code": "static void icmp_reply(struct icmp_bxm *icmp_param, struct sk_buff *skb)\n{\n\tstruct ipcm_cookie ipc;\n\tstruct rtable *rt = skb_rtable(skb);\n\tstruct net *net = dev_net(rt->dst.dev);\n\tstruct sock *sk;\n\tstruct inet_sock *inet;\n\t__be32 daddr;\n\tif (ip_options_echo(&icmp_param->replyopts, skb))\n\t\treturn;\n\tsk = icmp_xmit_lock(net);\n\tif (sk == NULL)\n\t\treturn;\n\tinet = inet_sk(sk);\n\ticmp_param->data.icmph.checksum = 0;\n\tinet->tos = ip_hdr(skb)->tos;\n\tdaddr = ipc.addr = rt->rt_src;\n\tipc.opt = NULL;\n\tipc.tx_flags = 0;\n\tif (icmp_param->replyopts.optlen) {\n\t\tipc.opt = &icmp_param->replyopts;\n\t\tif (ipc.opt->srr)\n\t\t\tdaddr = icmp_param->replyopts.faddr;\n\t}\n\t{\n\t\tstruct flowi4 fl4 = {\n\t\t\t.daddr = daddr,\n\t\t\t.saddr = rt->rt_spec_dst,\n\t\t\t.flowi4_tos = RT_TOS(ip_hdr(skb)->tos),\n\t\t\t.flowi4_proto = IPPROTO_ICMP,\n\t\t};\n\t\tsecurity_skb_classify_flow(skb, flowi4_to_flowi(&fl4));\n\t\trt = ip_route_output_key(net, &fl4);\n\t\tif (IS_ERR(rt))\n\t\t\tgoto out_unlock;\n\t}\n\tif (icmpv4_xrlim_allow(net, rt, icmp_param->data.icmph.type,\n\t\t\t       icmp_param->data.icmph.code))\n\t\ticmp_push_reply(icmp_param, &ipc, &rt);\n\tip_rt_put(rt);\nout_unlock:\n\ticmp_xmit_unlock(sk);\n}", "target": 1}
{"code": "static uint32_t generate_seed() {\n    uint32_t seed;\n    int done = 0;\n#if !defined(_WIN32) && defined(USE_URANDOM)\n    if (!done && seed_from_urandom(&seed) == 0)\n        done = 1;\n#endif\n#if defined(_WIN32) && defined(USE_WINDOWS_CRYPTOAPI)\n    if (!done && seed_from_windows_cryptoapi(&seed) == 0)\n        done = 1;\n#endif\n    if (!done) {\n        seed_from_timestamp_and_pid(&seed);\n    }\n    if (seed == 0)\n        seed = 1;\n    return seed;\n}", "target": 0}
{"code": "noko_init_xml_sax_parser_context()\n{\n  cNokogiriXmlSaxParserContext = rb_define_class_under(mNokogiriXmlSax, \"ParserContext\", rb_cObject);\n  rb_undef_alloc_func(cNokogiriXmlSaxParserContext);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"io\", parse_io, 2);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"memory\", parse_memory, 1);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"file\", parse_file, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"parse_with\", parse_with, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"replace_entities=\", set_replace_entities, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"replace_entities\", get_replace_entities, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"recovery=\", set_recovery, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"recovery\", get_recovery, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"line\", line, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"column\", column, 0);\n  id_read = rb_intern(\"read\");\n}", "target": 0}
{"code": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerify(\n                                                tCompletePhysicalAddress *pDataPages,\n                                                ULONG ulDataLength,\n                                                ULONG ulStartOffset,\n                                                ULONG flags,\n                                                BOOLEAN verifyLength,\n                                                LPCSTR caller)\n{\n    IPHeader *pIpHeader = (IPHeader *) RtlOffsetToPointer(pDataPages[0].Virtual, ulStartOffset);\n    tTcpIpPacketParsingResult res = QualifyIpPacket(pIpHeader, ulDataLength, verifyLength);\n    if (res.ipStatus == ppresNotIP || res.ipCheckSum == ppresIPTooShort)\n        return res;\n    if (res.ipStatus == ppresIPV4)\n    {\n        if (flags & pcrIpChecksum)\n            res = VerifyIpChecksum(&pIpHeader->v4, res, (flags & pcrFixIPChecksum) != 0);\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) \n            {\n                if(flags & pcrTcpV4Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV4Checksum));\n                }\n            }\n            else \n            {\n                if (flags & pcrUdpV4Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV4Checksum));\n                }\n            }\n        }\n    }\n    else if (res.ipStatus == ppresIPV6)\n    {\n        if(res.xxpStatus == ppresXxpKnown)\n        {\n            if (res.TcpUdp == ppresIsTCP) \n            {\n                if(flags & pcrTcpV6Checksum)\n                {\n                    res = VerifyTcpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixTcpV6Checksum));\n                }\n            }\n            else \n            {\n                if (flags & pcrUdpV6Checksum)\n                {\n                    res = VerifyUdpChecksum(pDataPages, ulDataLength, ulStartOffset, res, flags & (pcrFixPHChecksum | pcrFixUdpV6Checksum));\n                }\n            }\n        }\n    }\n    PrintOutParsingResult(res, 1, caller);\n    return res;\n}", "target": 0}
{"code": "TEST_P(RBACIntegrationTest, PathIgnoreCase) {\n  config_helper_.addFilter(RBAC_CONFIG_WITH_PATH_IGNORE_CASE_MATCH);\n  initialize();\n  codec_client_ = makeHttpConnection(lookupPort(\"http\"));\n  const std::vector<std::string> paths{\"/ignore_case\", \"/IGNORE_CASE\", \"/ignore_CASE\"};\n  for (const auto& path : paths) {\n    auto response = codec_client_->makeRequestWithBody(\n        Http::TestRequestHeaderMapImpl{\n            {\":method\", \"POST\"},\n            {\":path\", path},\n            {\":scheme\", \"http\"},\n            {\":authority\", \"host\"},\n            {\"x-forwarded-for\", \"10.0.0.1\"},\n        },\n        1024);\n    waitForNextUpstreamRequest();\n    upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{\":status\", \"200\"}}, true);\n    response->waitForEndStream();\n    ASSERT_TRUE(response->complete());\n    EXPECT_EQ(\"200\", response->headers().getStatusValue());\n  }\n}", "target": 0}
{"code": "stf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\t\treset_globals();\n\t\treturn e;\n\t}\n}", "target": 1}
{"code": "int LightProcess::pclose(FILE *f) {\n  if (!Available()) {\n    return ::pclose(f);\n  }\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  std::map<int64_t, int64_t>::iterator it = g_procs[id].m_popenMap.find((int64_t)f);\n  if (it == g_procs[id].m_popenMap.end()) {\n    return ::pclose(f);\n  }\n  int64_t f2 = it->second;\n  g_procs[id].m_popenMap.erase((int64_t)f);\n  fclose(f);\n  fprintf(g_procs[id].m_fout, \"pclose\\n%\" PRId64 \"\\n\", f2);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  int ret = -1;\n  sscanf(buf, \"%d\", &ret);\n  if (ret < 0) {\n    read_buf(g_procs[id].m_fin, buf);\n    sscanf(buf, \"%d\", &errno);\n  }\n  return ret;\n}", "target": 1}
{"code": "checkContentType(Buffer *buf)\n{\n    char *p;\n    Str r;\n    p = checkHeader(buf, \"Content-Type:\");\n    if (p == NULL)\n\treturn NULL;\n    r = Strnew();\n    while (*p && *p != ';' && !IS_SPACE(*p))\n\tStrcat_char(r, *p++);\n#ifdef USE_M17N\n    if ((p = strcasestr(p, \"charset\")) != NULL) {\n\tp += 7;\n\tSKIP_BLANKS(p);\n\tif (*p == '=') {\n\t    p++;\n\t    SKIP_BLANKS(p);\n\t    if (*p == '\"')\n\t\tp++;\n\t    content_charset = wc_guess_charset(p, 0);\n\t}\n    }\n#endif\n    return r->ptr;\n}", "target": 0}
{"code": "SECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\tstatus = table->DeleteSecurityContext(phContext);\n\treturn status;\n}", "target": 1}
{"code": "void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)\n{\n\tusb_kill_urb(mixer->urb);\n\tusb_kill_urb(mixer->rc_urb);\n}", "target": 1}
{"code": "register_commands (assuan_context_t ctx)\n{\n  static struct {\n    const char *name;\n    assuan_handler_t handler;\n    const char * const help;\n  } table[] = {\n    { \"SERIALNO\",     cmd_serialno, hlp_serialno },\n    { \"LEARN\",        cmd_learn,    hlp_learn },\n    { \"READCERT\",     cmd_readcert, hlp_readcert },\n    { \"READKEY\",      cmd_readkey,  hlp_readkey },\n    { \"SETDATA\",      cmd_setdata,  hlp_setdata },\n    { \"PKSIGN\",       cmd_pksign,   hlp_pksign },\n    { \"PKAUTH\",       cmd_pkauth,   hlp_pkauth },\n    { \"PKDECRYPT\",    cmd_pkdecrypt,hlp_pkdecrypt },\n    { \"INPUT\",        NULL },\n    { \"OUTPUT\",       NULL },\n    { \"GETATTR\",      cmd_getattr,  hlp_getattr },\n    { \"SETATTR\",      cmd_setattr,  hlp_setattr },\n    { \"WRITECERT\",    cmd_writecert,hlp_writecert },\n    { \"WRITEKEY\",     cmd_writekey, hlp_writekey },\n    { \"GENKEY\",       cmd_genkey,   hlp_genkey },\n    { \"RANDOM\",       cmd_random,   hlp_random },\n    { \"PASSWD\",       cmd_passwd,   hlp_passwd },\n    { \"CHECKPIN\",     cmd_checkpin, hlp_checkpin },\n    { \"LOCK\",         cmd_lock,     hlp_lock },\n    { \"UNLOCK\",       cmd_unlock,   hlp_unlock },\n    { \"GETINFO\",      cmd_getinfo,  hlp_getinfo },\n    { \"RESTART\",      cmd_restart,  hlp_restart },\n    { \"DISCONNECT\",   cmd_disconnect,hlp_disconnect },\n    { \"APDU\",         cmd_apdu,     hlp_apdu },\n    { \"KILLSCD\",      cmd_killscd,  hlp_killscd },\n    { NULL }\n  };\n  int i, rc;\n  for (i=0; table[i].name; i++)\n    {\n      rc = assuan_register_command (ctx, table[i].name, table[i].handler,\n                                    table[i].help);\n      if (rc)\n        return rc;\n    }\n  assuan_set_hello_line (ctx, \"GNU Privacy Guard's Smartcard server ready\");\n  assuan_register_reset_notify (ctx, reset_notify);\n  assuan_register_option_handler (ctx, option_handler);\n  return 0;\n}", "target": 0}
{"code": "static int validate_core_offset(const struct kvm_one_reg *reg)\n{\n\tu64 off = core_reg_offset_from_id(reg->id);\n\tint size;\n\tswitch (off) {\n\tcase KVM_REG_ARM_CORE_REG(regs.regs[0]) ...\n\t     KVM_REG_ARM_CORE_REG(regs.regs[30]):\n\tcase KVM_REG_ARM_CORE_REG(regs.sp):\n\tcase KVM_REG_ARM_CORE_REG(regs.pc):\n\tcase KVM_REG_ARM_CORE_REG(regs.pstate):\n\tcase KVM_REG_ARM_CORE_REG(sp_el1):\n\tcase KVM_REG_ARM_CORE_REG(elr_el1):\n\tcase KVM_REG_ARM_CORE_REG(spsr[0]) ...\n\t     KVM_REG_ARM_CORE_REG(spsr[KVM_NR_SPSR - 1]):\n\t\tsize = sizeof(__u64);\n\t\tbreak;\n\tcase KVM_REG_ARM_CORE_REG(fp_regs.vregs[0]) ...\n\t     KVM_REG_ARM_CORE_REG(fp_regs.vregs[31]):\n\t\tsize = sizeof(__uint128_t);\n\t\tbreak;\n\tcase KVM_REG_ARM_CORE_REG(fp_regs.fpsr):\n\tcase KVM_REG_ARM_CORE_REG(fp_regs.fpcr):\n\t\tsize = sizeof(__u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tif (KVM_REG_SIZE(reg->id) == size &&\n\t    IS_ALIGNED(off, size / sizeof(__u32)))\n\t\treturn 0;\n\treturn -EINVAL;\n}", "target": 0}
{"code": "find_entry2modify(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1, txn, 0 ) );\n}", "target": 1}
{"code": "int app_initialize(const char *const argv[])\n{\n    const char *argv_out[OGS_ARG_MAX];\n    bool user_config = false;\n    int i = 0;\n    for (i = 0; argv[i]; i++) {\n        if (strcmp(\"-c\", argv[i]) == 0) {\n            user_config = true; \n        }\n        argv_out[i] = argv[i];\n    }\n    argv_out[i] = NULL;\n    if (!user_config) {\n        argv_out[i++] = \"-c\";\n        argv_out[i++] = DEFAULT_CONFIG_FILENAME;\n        argv_out[i] = NULL;\n    }\n    if (ogs_app()->parameter.no_nrf == 0)\n        nrf_thread = test_child_create(\"nrf\", argv_out);\n    if (ogs_app()->parameter.no_scp == 0)\n        scp_thread = test_child_create(\"scp\", argv_out);\n    if (ogs_app()->parameter.no_upf == 0)\n        upf_thread = test_child_create(\"upf\", argv_out);\n    if (ogs_app()->parameter.no_smf == 0)\n        smf_thread = test_child_create(\"smf\", argv_out);\n    if (ogs_app()->parameter.no_amf == 0)\n        amf_thread = test_child_create(\"amf\", argv_out);\n    if (ogs_app()->parameter.no_ausf == 0)\n        ausf_thread = test_child_create(\"ausf\", argv_out);\n    if (ogs_app()->parameter.no_udm == 0)\n        udm_thread = test_child_create(\"udm\", argv_out);\n    if (ogs_app()->parameter.no_pcf == 0)\n        pcf_thread = test_child_create(\"pcf\", argv_out);\n    if (ogs_app()->parameter.no_nssf == 0)\n        nssf_thread = test_child_create(\"nssf\", argv_out);\n    if (ogs_app()->parameter.no_bsf == 0)\n        bsf_thread = test_child_create(\"bsf\", argv_out);\n    if (ogs_app()->parameter.no_udr == 0)\n        udr_thread = test_child_create(\"udr\", argv_out);\n    ogs_msleep(300);\n    return OGS_OK;;\n}", "target": 1}
{"code": "static void xen_free_irq(unsigned irq)\n{\n\tstruct irq_info *info = info_for_irq(irq);\n\tunsigned long flags;\n\tif (WARN_ON(!info))\n\t\treturn;\n\twrite_lock_irqsave(&evtchn_rwlock, flags);\n\tlist_del(&info->list);\n\tset_info_for_irq(irq, NULL);\n\tWARN_ON(info->refcnt > 0);\n\twrite_unlock_irqrestore(&evtchn_rwlock, flags);\n\tkfree(info);\n\tif (irq < nr_legacy_irqs())\n\t\treturn;\n\tirq_free_desc(irq);\n}", "target": 0}
{"code": "int mongo_env_write_socket( mongo *conn, const void *buf, int len ) {\n    const char *cbuf = buf;\n    int flags = 0;\n    while ( len ) {\n        int sent = send( conn->sock, cbuf, len, flags );\n        if ( sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            conn->connected = 0;\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n    return MONGO_OK;\n}", "target": 1}
{"code": "int nbd_init(int fd, QIOChannelSocket *sioc, uint16_t flags, off_t size)\n{\n    unsigned long sectors = size / BDRV_SECTOR_SIZE;\n    if (size / BDRV_SECTOR_SIZE != sectors) {\n        LOG(\"Export size %lld too large for 32-bit kernel\", (long long) size);\n        return -E2BIG;\n    }\n    TRACE(\"Setting NBD socket\");\n    if (ioctl(fd, NBD_SET_SOCK, (unsigned long) sioc->fd) < 0) {\n        int serrno = errno;\n        LOG(\"Failed to set NBD socket\");\n        return -serrno;\n    }\n    TRACE(\"Setting block size to %lu\", (unsigned long)BDRV_SECTOR_SIZE);\n    if (ioctl(fd, NBD_SET_BLKSIZE, (unsigned long)BDRV_SECTOR_SIZE) < 0) {\n        int serrno = errno;\n        LOG(\"Failed setting NBD block size\");\n        return -serrno;\n    }\n    TRACE(\"Setting size to %lu block(s)\", sectors);\n    if (size % BDRV_SECTOR_SIZE) {\n        TRACE(\"Ignoring trailing %d bytes of export\",\n              (int) (size % BDRV_SECTOR_SIZE));\n    }\n    if (ioctl(fd, NBD_SET_SIZE_BLOCKS, sectors) < 0) {\n        int serrno = errno;\n        LOG(\"Failed setting size (in blocks)\");\n        return -serrno;\n    }\n    if (ioctl(fd, NBD_SET_FLAGS, (unsigned long) flags) < 0) {\n        if (errno == ENOTTY) {\n            int read_only = (flags & NBD_FLAG_READ_ONLY) != 0;\n            TRACE(\"Setting readonly attribute\");\n            if (ioctl(fd, BLKROSET, (unsigned long) &read_only) < 0) {\n                int serrno = errno;\n                LOG(\"Failed setting read-only attribute\");\n                return -serrno;\n            }\n        } else {\n            int serrno = errno;\n            LOG(\"Failed setting flags\");\n            return -serrno;\n        }\n    }\n    TRACE(\"Negotiation ended\");\n    return 0;\n}", "target": 0}
{"code": "test(int equal, const char *user_input, const char *secret)\n{\n    int out = password_equal(user_input, secret);\n    printf(\"%s: \\\"%s\\\" \\\"%s\\\"\\n\",\n        (equal == out) ? \"PASS\" : \"FAIL\",\n        user_input, secret);\n}", "target": 0}
{"code": "  virtual void ForgetWifiNetwork(const std::string& service_path) {}", "target": 0}
{"code": "void ZydisFormatterBufferInit(ZydisFormatterBuffer* buffer, char* user_buffer,\n    ZyanUSize length)\n{\n    ZYAN_ASSERT(buffer);\n    ZYAN_ASSERT(user_buffer);\n    ZYAN_ASSERT(length);\n    buffer->is_token_list              = ZYAN_FALSE;\n    buffer->string.flags               = ZYAN_STRING_HAS_FIXED_CAPACITY;\n    buffer->string.vector.allocator    = ZYAN_NULL;\n    buffer->string.vector.element_size = sizeof(char);\n    buffer->string.vector.size         = 1;\n    buffer->string.vector.capacity     = length;\n    buffer->string.vector.data         = user_buffer;\n    *user_buffer = '\\0';\n}", "target": 1}
{"code": "horizontalDifference8(unsigned char *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From8)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef\t CLAMP\n#define  CLAMP(v) (From8[(v)])\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\tr1 = CLAMP(ip[3]); wp[3] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[4]); wp[4] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[5]); wp[5] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\twp += 3;\n\t\tip += 3;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\tr1 = CLAMP(ip[4]); wp[4] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[5]); wp[5] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[6]); wp[6] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[7]); wp[7] = (uint16)((a1-a2) & mask); a2 = a1;\n\t\twp += 4;\n\t\tip += 4;\n\t    }\n\t} else {\n\t    wp += n + stride - 1;\t\n\t    ip += n + stride - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "static void evdev_hangup(struct evdev *evdev)\n{\n\tstruct evdev_client *client;\n\tspin_lock(&evdev->client_lock);\n\tlist_for_each_entry(client, &evdev->client_list, node)\n\t\tkill_fasync(&client->fasync, SIGIO, POLL_HUP);\n\tspin_unlock(&evdev->client_lock);\n\twake_up_interruptible(&evdev->wait);\n}", "target": 0}
{"code": "  Status CalculateOutputIndex(OpKernelContext* context, int dimension,\n                              const vector<INDEX_TYPE>& parent_output_index,\n                              INDEX_TYPE output_index_multiplier,\n                              INDEX_TYPE output_size,\n                              vector<INDEX_TYPE>* result) {\n    const RowPartitionTensor row_partition_tensor =\n        GetRowPartitionTensor(context, dimension);\n    auto partition_type = GetRowPartitionTypeByDimension(dimension);\n    switch (partition_type) {\n      case RowPartitionType::VALUE_ROWIDS:\n        CalculateOutputIndexValueRowID(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      case RowPartitionType::ROW_SPLITS:\n        if (row_partition_tensor.size() - 1 > parent_output_index.size()) {\n          return errors::InvalidArgument(\n              \"Row partition size is greater than output size: \",\n              row_partition_tensor.size() - 1, \" > \",\n              parent_output_index.size());\n        }\n        CalculateOutputIndexRowSplit(\n            context, row_partition_tensor, parent_output_index,\n            output_index_multiplier, output_size, result);\n        return tensorflow::Status::OK();\n      default:\n        return errors::InvalidArgument(\n            \"Unsupported partition type:\",\n            RowPartitionTypeToString(partition_type));\n    }\n  }", "target": 0}
{"code": "Opal::Call::emit_established_in_main ()\n{\n  established ();\n}", "target": 0}
{"code": "std::string RestAuthHandler::generateJwt(std::string const& username,\n                                         std::string const& password) {\n  AuthenticationFeature* af = AuthenticationFeature::instance();\n  TRI_ASSERT(af != nullptr);\n  return fuerte::jwt::generateUserToken(af->tokenCache().jwtSecret(), username, _validFor);\n}", "target": 1}
{"code": "static int snd_ctl_elem_lock(struct snd_ctl_file *file,\n\t\t\t     struct snd_ctl_elem_id __user *_id)\n{\n\tstruct snd_card *card = file->card;\n\tstruct snd_ctl_elem_id id;\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tint result;\n\tif (copy_from_user(&id, _id, sizeof(id)))\n\t\treturn -EFAULT;\n\tdown_write(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &id);\n\tif (kctl == NULL) {\n\t\tresult = -ENOENT;\n\t} else {\n\t\tvd = &kctl->vd[snd_ctl_get_ioff(kctl, &id)];\n\t\tif (vd->owner != NULL)\n\t\t\tresult = -EBUSY;\n\t\telse {\n\t\t\tvd->owner = file;\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tup_write(&card->controls_rwsem);\n\treturn result;\n}", "target": 0}
{"code": "int read_header_tga(gdIOCtx *ctx, oTga *tga)\n{\n\tunsigned char header[18];\n\tif (gdGetBuf(header, sizeof(header), ctx) < 18) {\n\t\tgd_error(\"fail to read header\");\n\t\treturn -1;\n\t}\n\ttga->identsize = header[0];\n\ttga->colormaptype = header[1];\n\ttga->imagetype = header[2];\n\ttga->colormapstart = header[3] + (header[4] << 8);\n\ttga->colormaplength = header[5] + (header[6] << 8);\n\ttga->colormapbits = header[7];\n\ttga->xstart = header[8] + (header[9] << 8);\n\ttga->ystart = header[10] + (header[11] << 8);\n\ttga->width = header[12] + (header[13] << 8);\n\ttga->height = header[14] + (header[15] << 8);\n\ttga->bits = header[16];\n\ttga->alphabits = header[17] & 0x0f;\n\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\ttga->ident = NULL;\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n\t\tgdGetBuf(tga->ident, tga->identsize, ctx);\n\t}\n\treturn 1;\n}", "target": 1}
{"code": "static int rm_read_extradata(AVFormatContext *s, AVIOContext *pb, AVCodecParameters *par, unsigned size)\n{\n    if (size >= 1<<24) {\n        av_log(s, AV_LOG_ERROR, \"extradata size %u too large\\n\", size);\n        return -1;\n    }\n    if (ff_get_extradata(s, par, pb, size) < 0)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "target": 0}
{"code": "uint64_t ssh_scp_request_get_size64(ssh_scp scp)\n{\n    if (scp == NULL) {\n        return 0;\n    }\n    return scp->filelen;\n}", "target": 0}
{"code": "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\tstats->coremem = jiffies_to_usecs(p->acct_rss_mem1) * PAGE_SIZE / MB;\n\tstats->virtmem = jiffies_to_usecs(p->acct_vm_mem1) * PAGE_SIZE / MB;\n\tif (p->mm) {\n\t\tstats->hiwater_rss   = p->mm->hiwater_rss * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = p->mm->hiwater_vm * PAGE_SIZE / KB;\n\t}\n\tstats->read_char\t= p->rchar;\n\tstats->write_char\t= p->wchar;\n\tstats->read_syscalls\t= p->syscr;\n\tstats->write_syscalls\t= p->syscw;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  TFLITE_DCHECK(node->builtin_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  const auto params =\n      static_cast<const TfLiteFullyConnectedParams*>(node->builtin_data);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TF_LITE_ENSURE(context, input != nullptr);\n  const TfLiteTensor* filter = GetInput(context, node, kWeightsTensor);\n  TF_LITE_ENSURE(context, filter != nullptr);\n  const TfLiteTensor* bias = GetOptionalInputTensor(context, node, kBiasTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  TF_LITE_ENSURE_MSG(context, input->type == filter->type,\n                     \"Hybrid models are not supported on TFLite Micro.\");\n  return CalculateOpData(context, params->activation, input->type, input,\n                         filter, bias, output, data);\n}", "target": 0}
{"code": "static int cipso_v4_delopt(struct ip_options **opt_ptr)\n{\n\tint hdr_delta = 0;\n\tstruct ip_options *opt = *opt_ptr;\n\tif (opt->srr || opt->rr || opt->ts || opt->router_alert) {\n\t\tu8 cipso_len;\n\t\tu8 cipso_off;\n\t\tunsigned char *cipso_ptr;\n\t\tint iter;\n\t\tint optlen_new;\n\t\tcipso_off = opt->cipso - sizeof(struct iphdr);\n\t\tcipso_ptr = &opt->__data[cipso_off];\n\t\tcipso_len = cipso_ptr[1];\n\t\tif (opt->srr > opt->cipso)\n\t\t\topt->srr -= cipso_len;\n\t\tif (opt->rr > opt->cipso)\n\t\t\topt->rr -= cipso_len;\n\t\tif (opt->ts > opt->cipso)\n\t\t\topt->ts -= cipso_len;\n\t\tif (opt->router_alert > opt->cipso)\n\t\t\topt->router_alert -= cipso_len;\n\t\topt->cipso = 0;\n\t\tmemmove(cipso_ptr, cipso_ptr + cipso_len,\n\t\t\topt->optlen - cipso_off - cipso_len);\n\t\titer = 0;\n\t\toptlen_new = 0;\n\t\twhile (iter < opt->optlen)\n\t\t\tif (opt->__data[iter] != IPOPT_NOP) {\n\t\t\t\titer += opt->__data[iter + 1];\n\t\t\t\toptlen_new = iter;\n\t\t\t} else\n\t\t\t\titer++;\n\t\thdr_delta = opt->optlen;\n\t\topt->optlen = (optlen_new + 3) & ~3;\n\t\thdr_delta -= opt->optlen;\n\t} else {\n\t\t*opt_ptr = NULL;\n\t\thdr_delta = opt->optlen;\n\t\tkfree(opt);\n\t}\n\treturn hdr_delta;\n}", "target": 1}
{"code": "char *enl_ipc_get(const char *msg_data)\n{\n\tstatic char *message = NULL;\n\tstatic unsigned short len = 0;\n\tchar buff[13], *ret_msg = NULL;\n\tregister unsigned char i;\n\tunsigned char blen;\n\tif (msg_data == IPC_TIMEOUT) {\n\t\treturn(IPC_TIMEOUT);\n\t}\n\tfor (i = 0; i < 12; i++) {\n\t\tbuff[i] = msg_data[i];\n\t}\n\tbuff[12] = 0;\n\tblen = strlen(buff);\n\tif (message != NULL) {\n\t\tlen += blen;\n\t\tmessage = (char *) erealloc(message, len + 1);\n\t\tstrcat(message, buff);\n\t} else {\n\t\tlen = blen;\n\t\tmessage = (char *) emalloc(len + 1);\n\t\tstrcpy(message, buff);\n\t}\n\tif (blen < 12) {\n\t\tret_msg = message;\n\t\tmessage = NULL;\n\t\tD((\"Received complete reply:  \\\"%s\\\"\\n\", ret_msg));\n\t}\n\treturn(ret_msg);\n}", "target": 1}
{"code": "void WasmBinaryWriter::prepare() {\n  ModuleUtils::collectHeapTypes(*wasm, types, typeIndices);\n  importInfo = wasm::make_unique<ImportInfo>(*wasm);\n}", "target": 0}
{"code": "TEST_P(JSITest, HostObjectProtoTest) {\n  class ProtoHostObject : public HostObject {\n    Value get(Runtime& rt, const PropNameID&) override {\n      return String::createFromAscii(rt, \"phoprop\");\n    }\n  };\n  rt.global().setProperty(\n      rt,\n      \"pho\",\n      Object::createFromHostObject(rt, std::make_shared<ProtoHostObject>()));\n  EXPECT_EQ(\n      eval(\"({__proto__: pho})[Symbol.toPrimitive]\").getString(rt).utf8(rt),\n      \"phoprop\");\n}", "target": 0}
{"code": "l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint32_t *ptr = (const uint32_t *)dat;\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {\n\t\tND_PRINT((ndo, \"A\"));\n\t}\n\tif (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {\n\t\tND_PRINT((ndo, \"S\"));\n\t}\n}", "target": 1}
{"code": "mm_share_sync(struct mm_master **pmm, struct mm_master **pmmalloc)\n{\n\tstruct mm_master *mm;\n\tstruct mm_master *mmalloc;\n\tstruct mm_master *mmold;\n\tstruct mmtree rb_free, rb_allocated;\n\tdebug3(\"%s: Share sync\", __func__);\n\tmm = *pmm;\n\tmmold = mm->mmalloc;\n\tmm_memvalid(mmold, mm, sizeof(*mm));\n\tmmalloc = mm_create(NULL, mm->size);\n\tmm = mm_xmalloc(mmalloc, sizeof(struct mm_master));\n\tmemcpy(mm, *pmm, sizeof(struct mm_master));\n\tmm->mmalloc = mmalloc;\n\trb_free = mm->rb_free;\n\trb_allocated = mm->rb_allocated;\n\tRB_INIT(&mm->rb_free);\n\tRB_INIT(&mm->rb_allocated);\n\tmm_sync_list(&rb_free, &mm->rb_free, mm, mmold);\n\tmm_sync_list(&rb_allocated, &mm->rb_allocated, mm, mmold);\n\tmm_destroy(mmold);\n\t*pmm = mm;\n\t*pmmalloc = mmalloc;\n\tdebug3(\"%s: Share sync end\", __func__);\n}", "target": 1}
{"code": "u64 gf_net_get_ntp_ts()\n{\n\tu64 res;\n\tu32 sec, frac;\n\tgf_net_get_ntp(&sec, &frac);\n\tres = sec;\n\tres<<= 32;\n\tres |= frac;\n\treturn res;\n}", "target": 0}
{"code": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}", "target": 1}
{"code": "modify_bar_registration(struct pci_vdev *dev, int idx, int registration)\n{\n\tint error;\n\tstruct inout_port iop;\n\tstruct mem_range mr;\n\tif (is_pci_gvt(dev)) {\n\t\tprintf(\"modify_bar_registration: bypass for pci-gvt\\n\");\n\t\treturn;\n\t}\n\tswitch (dev->bar[idx].type) {\n\tcase PCIBAR_IO:\n\t\tbzero(&iop, sizeof(struct inout_port));\n\t\tiop.name = dev->name;\n\t\tiop.port = dev->bar[idx].addr;\n\t\tiop.size = dev->bar[idx].size;\n\t\tif (registration) {\n\t\t\tiop.flags = IOPORT_F_INOUT;\n\t\t\tiop.handler = pci_emul_io_handler;\n\t\t\tiop.arg = dev;\n\t\t\terror = register_inout(&iop);\n\t\t} else\n\t\t\terror = unregister_inout(&iop);\n\t\tbreak;\n\tcase PCIBAR_MEM32:\n\tcase PCIBAR_MEM64:\n\t\tbzero(&mr, sizeof(struct mem_range));\n\t\tmr.name = dev->name;\n\t\tmr.base = dev->bar[idx].addr;\n\t\tmr.size = dev->bar[idx].size;\n\t\tif (registration) {\n\t\t\tmr.flags = MEM_F_RW;\n\t\t\tmr.handler = pci_emul_mem_handler;\n\t\t\tmr.arg1 = dev;\n\t\t\tmr.arg2 = idx;\n\t\t\terror = register_mem(&mr);\n\t\t} else\n\t\t\terror = unregister_mem(&mr);\n\t\tbreak;\n\tdefault:\n\t\terror = EINVAL;\n\t\tbreak;\n\t}\n\tassert(error == 0);\n}", "target": 1}
{"code": "static BOOL rectangle_contained_in_band(const RECTANGLE_16* band, const RECTANGLE_16* endPtr,\n                                        const RECTANGLE_16* rect)\n{\n\tUINT16 refY = band->top;\n\tif ((band->top > rect->top) || (rect->bottom > band->bottom))\n\t\treturn FALSE;\n\twhile ((band < endPtr) && (band->top == refY) && (band->left <= rect->left))\n\t{\n\t\tif (rect->right <= band->right)\n\t\t\treturn TRUE;\n\t\tband++;\n\t}\n\treturn FALSE;\n}", "target": 0}
{"code": "horizontalDifference16(unsigned short *ip, int n, int stride, \n\tunsigned short *wp, uint16 *From14)\n{\n    register int  r1, g1, b1, a1, r2, g2, b2, a2, mask;\n#undef   CLAMP\n#define  CLAMP(v) From14[(v) >> 2]\n    mask = CODE_MASK;\n    if (n >= stride) {\n\tif (stride == 3) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);\n\t    n -= 3;\n\t    while (n > 0) {\n\t\tn -= 3;\n\t\twp += 3;\n\t\tip += 3;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t    }\n\t} else if (stride == 4) {\n\t    r2 = wp[0] = CLAMP(ip[0]);  g2 = wp[1] = CLAMP(ip[1]);\n\t    b2 = wp[2] = CLAMP(ip[2]);  a2 = wp[3] = CLAMP(ip[3]);\n\t    n -= 4;\n\t    while (n > 0) {\n\t\tn -= 4;\n\t\twp += 4;\n\t\tip += 4;\n\t\tr1 = CLAMP(ip[0]); wp[0] = (uint16)((r1-r2) & mask); r2 = r1;\n\t\tg1 = CLAMP(ip[1]); wp[1] = (uint16)((g1-g2) & mask); g2 = g1;\n\t\tb1 = CLAMP(ip[2]); wp[2] = (uint16)((b1-b2) & mask); b2 = b1;\n\t\ta1 = CLAMP(ip[3]); wp[3] = (uint16)((a1-a2) & mask); a2 = a1;\n\t    }\n\t} else {\n\t    ip += n - 1;\t\n\t    wp += n - 1;\t\n\t    n -= stride;\n\t    while (n > 0) {\n\t\tREPEAT(stride, wp[0] = CLAMP(ip[0]);\n\t\t\t\twp[stride] -= wp[0];\n\t\t\t\twp[stride] &= mask;\n\t\t\t\twp--; ip--)\n\t\tn -= stride;\n\t    }\n\t    REPEAT(stride, wp[0] = CLAMP(ip[0]); wp--; ip--)\n\t}\n    }\n}", "target": 1}
{"code": "void sctp_auth_calculate_hmac(const struct sctp_association *asoc,\n\t\t\t      struct sk_buff *skb,\n\t\t\t      struct sctp_auth_chunk *auth,\n\t\t\t      gfp_t gfp)\n{\n\tstruct scatterlist sg;\n\tstruct hash_desc desc;\n\tstruct sctp_auth_bytes *asoc_key;\n\t__u16 key_id, hmac_id;\n\t__u8 *digest;\n\tunsigned char *end;\n\tint free_key = 0;\n\tkey_id = ntohs(auth->auth_hdr.shkey_id);\n\thmac_id = ntohs(auth->auth_hdr.hmac_id);\n\tif (key_id == asoc->active_key_id)\n\t\tasoc_key = asoc->asoc_shared_key;\n\telse {\n\t\tstruct sctp_shared_key *ep_key;\n\t\tep_key = sctp_auth_get_shkey(asoc, key_id);\n\t\tif (!ep_key)\n\t\t\treturn;\n\t\tasoc_key = sctp_auth_asoc_create_secret(asoc, ep_key, gfp);\n\t\tif (!asoc_key)\n\t\t\treturn;\n\t\tfree_key = 1;\n\t}\n\tend = skb_tail_pointer(skb);\n\tsg_init_one(&sg, auth, end - (unsigned char *)auth);\n\tdesc.tfm = asoc->ep->auth_hmacs[hmac_id];\n\tdesc.flags = 0;\n\tdigest = auth->auth_hdr.hmac;\n\tif (crypto_hash_setkey(desc.tfm, &asoc_key->data[0], asoc_key->len))\n\t\tgoto free;\n\tcrypto_hash_digest(&desc, &sg, sg.length, digest);\nfree:\n\tif (free_key)\n\t\tsctp_auth_key_put(asoc_key);\n}", "target": 0}
{"code": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n        for (strip = 0; strip < nstrips; strip++) {\n                bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n                rows = bytes_read / scanline_size;\n                if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))\n                        TIFFError(\"\", \"Strip %d: read %lu bytes, strip size %lu\",\n                                  (int)strip + 1, (unsigned long) bytes_read,\n                                  (unsigned long)stripsize);\n                if (bytes_read < 0 && !ignore) {\n                        TIFFError(\"\", \"Error reading strip %lu after %lu rows\",\n                                  (unsigned long) strip, (unsigned long)rows);\n                        return 0;\n                }\n                bufp += stripsize;\n        }\n        return 1;\n} ", "target": 0}
{"code": "    TiffIfdMakernote::TiffIfdMakernote(uint16_t  tag,\n                                       IfdId     group,\n                                       IfdId     mnGroup,\n                                       MnHeader* pHeader,\n                                       bool      hasNext)\n        : TiffComponent(tag, group),\n          pHeader_(pHeader),\n          ifd_(tag, mnGroup, hasNext),\n          mnOffset_(0),\n          imageByteOrder_(invalidByteOrder)\n    {\n    }", "target": 0}
{"code": "static pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {\n\tpyc_object *tmp = NULL;\n\tpyc_object *ret = NULL;\n\tut32 i = 0;\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = get_object (buffer);\n\t\tif (!tmp) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!r_list_append (ret->data, tmp)) {\n\t\t\tfree_object (tmp);\n\t\t\tr_list_free (ret->data);\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "selaComputeCompositeParameters(const char  *fileout)\n{\nchar    *str, *nameh1, *nameh2, *namev1, *namev2;\nchar     buf[L_BUF_SIZE];\nl_int32  size, size1, size2, len;\nSARRAY  *sa;\nSELA    *selabasic, *selacomb;\n    selabasic = selaAddBasic(NULL);\n    selacomb = selaAddDwaCombs(NULL);\n    sa = sarrayCreate(64);\n    for (size = 2; size < 64; size++) {\n        selectComposableSizes(size, &size1, &size2);\n        nameh1 = selaGetBrickName(selabasic, size1, 1);\n        namev1 = selaGetBrickName(selabasic, 1, size1);\n        if (size2 > 1) {\n            nameh2 = selaGetCombName(selacomb, size1 * size2, L_HORIZ);\n            namev2 = selaGetCombName(selacomb, size1 * size2, L_VERT);\n        } else {\n            nameh2 = stringNew(\"\");\n            namev2 = stringNew(\"\");\n        }\n        snprintf(buf, L_BUF_SIZE,\n                 \"      { %d, %d, %d, \\\"%s\\\", \\\"%s\\\", \\\"%s\\\", \\\"%s\\\" },\",\n                 size, size1, size2, nameh1, nameh2, namev1, namev2);\n        sarrayAddString(sa, buf, L_COPY);\n        LEPT_FREE(nameh1);\n        LEPT_FREE(nameh2);\n        LEPT_FREE(namev1);\n        LEPT_FREE(namev2);\n    }\n    str = sarrayToString(sa, 1);\n    len = strlen(str);\n    l_binaryWrite(fileout, \"w\", str, len + 1);\n    LEPT_FREE(str);\n    sarrayDestroy(&sa);\n    selaDestroy(&selabasic);\n    selaDestroy(&selacomb);\n    return;\n}", "target": 1}
{"code": "    Iptcdatum& Iptcdatum::operator=(const Iptcdatum& rhs)\n    {\n        if (this == &rhs) return *this;\n        Metadatum::operator=(rhs);\n        key_.reset();\n        if (rhs.key_.get() != 0) key_ = rhs.key_->clone(); \n        value_.reset();\n        if (rhs.value_.get() != 0) value_ = rhs.value_->clone(); \n        return *this;\n    } ", "target": 0}
{"code": "FILE *LightProcess::LightPopenImpl(const char *cmd, const char *type,\n                                   const char *cwd) {\n  int id = GetId();\n  Lock lock(g_procs[id].m_procMutex);\n  fprintf(g_procs[id].m_fout, \"popen\\n%s\\n%s\\n%s\\n\", type, cmd, cwd);\n  fflush(g_procs[id].m_fout);\n  char buf[BUFFER_SIZE];\n  read_buf(g_procs[id].m_fin, buf);\n  if (strncmp(buf, \"error\", 5) == 0) {\n    return nullptr;\n  }\n  int64_t fptr = 0;\n  read_buf(g_procs[id].m_fin, buf);\n  sscanf(buf, \"%\" PRId64, &fptr);\n  if (!fptr) {\n    Logger::Error(\"Light process failed to return the file pointer.\");\n    return nullptr;\n  }\n  int fd = recv_fd(g_procs[id].m_afdt_fd);\n  if (fd < 0) {\n    Logger::Error(\"Light process failed to send the file descriptor.\");\n    return nullptr;\n  }\n  FILE *f = fdopen(fd, type);\n  g_procs[id].m_popenMap[(int64_t)f] = fptr;\n  return f;\n}", "target": 1}
{"code": "jsi_wsGetHeaders(jsi_wsPss *pss, struct lws *wsi, Jsi_DString* dStr, int lens[], int hmax)\n{\n    int n = 0, i = 0, nlen;\n    char buf[1000];\n    const char *cp;\n    while ((cp = (char*)lws_token_to_string((enum lws_token_indexes)n))) {\n        int len = lws_hdr_copy(wsi, buf, sizeof(buf), ( enum lws_token_indexes)n);\n        n++;\n        if (i>=(n*2+2)) break;\n        if (len<=0) continue;\n        buf[sizeof(buf)-1] = 0;\n        if (!buf[0]) continue;\n        nlen = Jsi_Strlen(cp);\n        if (nlen>0 && cp[nlen-1]==' ') nlen--;\n        if (nlen>0 && cp[nlen-1]==':') nlen--;\n        Jsi_DSAppendLen(dStr, cp, nlen);\n        Jsi_DSAppend(dStr, \"=\", buf, \"\\n\", NULL);\n        if (lens) {\n            lens[i++] = nlen;\n            lens[i++] = Jsi_Strlen(buf);\n        }\n    }\n    return i;\n}", "target": 1}
{"code": "    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(CentralDirectoryRecord) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), central_directory_record_signature, sizeof(central_directory_record_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&made_by_version), buffer.data() + sizeof(central_directory_record_signature), fields_size);\n        name = buffer.data() + sizeof(central_directory_record_signature) + fields_size;\n        extra_data = name + name_length;\n        comment = extra_data + extra_data_length;\n        return true;\n    }", "target": 1}
{"code": "      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }", "target": 1}
{"code": "static bool torture_winbind_struct_getpwent(struct torture_context *torture)\n{\n\tstruct winbindd_request req;\n\tstruct winbindd_response rep;\n\tstruct winbindd_pw *pwent;\n\ttorture_comment(torture, \"Running WINBINDD_GETPWENT (struct based)\\n\");\n\ttorture_comment(torture, \" - Running WINBINDD_SETPWENT first\\n\");\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\tDO_STRUCT_REQ_REP(WINBINDD_SETPWENT, &req, &rep);\n\ttorture_comment(torture, \" - Running WINBINDD_GETPWENT now\\n\");\n\tZERO_STRUCT(req);\n\tZERO_STRUCT(rep);\n\treq.data.num_entries = 1;\n\tif (torture_setting_bool(torture, \"samba3\", false)) {\n\t\tDO_STRUCT_REQ_REP_EXT(WINBINDD_GETPWENT, &req, &rep,\n\t\t\t\t      NSS_STATUS_SUCCESS, false, _STRUCT_NOOP,\n\t\t\t\t      NULL);\n\t} else {\n\t\tDO_STRUCT_REQ_REP(WINBINDD_GETPWENT, &req, &rep);\n\t}\n\tpwent = (struct winbindd_pw *)rep.extra_data.data;\n\tif (!torture_setting_bool(torture, \"samba3\", false)) {\n\t\ttorture_assert(torture, (pwent != NULL), \"NULL pwent\");\n\t}\n\tif (pwent) {\n\t\ttorture_comment(torture, \"name: %s, uid: %d, gid: %d, shell: %s\\n\",\n\t\t\t\tpwent->pw_name, pwent->pw_uid, pwent->pw_gid,\n\t\t\t\tpwent->pw_shell);\n\t}\n\treturn true;\n}", "target": 0}
{"code": "void ntlm_print_message_fields(NTLM_MESSAGE_FIELDS* fields, const char* name)\n{\n\tWLog_DBG(TAG, \"%s (Len: %\"PRIu16\" MaxLen: %\"PRIu16\" BufferOffset: %\"PRIu32\")\",\n\t         name, fields->Len, fields->MaxLen, fields->BufferOffset);\n\tif (fields->Len > 0)\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, fields->Buffer, fields->Len);\n}", "target": 1}
{"code": "bool AES_GCM_DecryptContext::Decrypt(\n\tconst void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,\n\tconst void *pIV,\n\tvoid *pPlaintextData, uint32 *pcbPlaintextData,\n\tconst void *pAdditionalAuthenticationData, size_t cbAuthenticationData\n) {\n    unsigned long long pcbPlaintextData_longlong;\n    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(\n\t\tstatic_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,\n\t\tnullptr,\n\t\tstatic_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,\n\t\tstatic_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,\n\t\tstatic_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )\n\t);\n    *pcbPlaintextData = pcbPlaintextData_longlong;\n    return nDecryptResult == 0;\n}", "target": 1}
{"code": "static int libusb_udev_isoch_transfer(IUDEVICE* idev, URBDRC_CHANNEL_CALLBACK* callback,\n                                      UINT32 MessageId, UINT32 RequestId, UINT32 EndpointAddress,\n                                      UINT32 TransferFlags, UINT32 StartFrame, UINT32 ErrorCount,\n                                      BOOL NoAck, const BYTE* packetDescriptorData,\n                                      UINT32 NumberOfPackets, UINT32 BufferSize, const BYTE* Buffer,\n                                      t_isoch_transfer_cb cb, UINT32 Timeout)\n{\n\tUINT32 iso_packet_size;\n\tUDEVICE* pdev = (UDEVICE*)idev;\n\tASYNC_TRANSFER_USER_DATA* user_data;\n\tstruct libusb_transfer* iso_transfer = NULL;\n\tURBDRC_PLUGIN* urbdrc;\n\tsize_t outSize = (NumberOfPackets * 12);\n\tuint32_t streamID = 0x40000000 | RequestId;\n\tif (!pdev || !pdev->urbdrc)\n\t\treturn -1;\n\turbdrc = pdev->urbdrc;\n\tuser_data = async_transfer_user_data_new(idev, MessageId, 48, BufferSize, Buffer,\n\t                                         outSize + 1024, NoAck, cb, callback);\n\tif (!user_data)\n\t\treturn -1;\n\tuser_data->ErrorCount = ErrorCount;\n\tuser_data->StartFrame = StartFrame;\n\tif (!Buffer)\n\t\tStream_Seek(user_data->data, (NumberOfPackets * 12));\n\tiso_packet_size = BufferSize / NumberOfPackets;\n\tiso_transfer = libusb_alloc_transfer(NumberOfPackets);\n\tif (iso_transfer == NULL)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"Error: libusb_alloc_transfer.\");\n\t\tasync_transfer_user_data_free(user_data);\n\t\treturn -1;\n\t}\n\tlibusb_fill_iso_transfer(iso_transfer, pdev->libusb_handle, EndpointAddress,\n\t                         Stream_Pointer(user_data->data), BufferSize, NumberOfPackets,\n\t                         func_iso_callback, user_data, Timeout);\n\tset_stream_id_for_buffer(iso_transfer, streamID);\n\tlibusb_set_iso_packet_lengths(iso_transfer, iso_packet_size);\n\tif (ArrayList_Add(pdev->request_queue, iso_transfer) < 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"Failed to queue iso transfer, streamID %08\" PRIx32 \" already in use!\",\n\t\t           streamID);\n\t\trequest_free(iso_transfer);\n\t\treturn -1;\n\t}\n\treturn libusb_submit_transfer(iso_transfer);\n}", "target": 1}
{"code": "comics_generate_command_lines (ComicsDocument *comics_document,\n\t\t\t       GError         **error)\n{\n\tgchar *quoted_file, *quoted_file_aux;\n\tgchar *quoted_command;\n\tComicBookDecompressType type;\n\ttype = comics_document->command_usage;\n\tcomics_document->regex_arg = command_usage_def[type].regex_arg;\n\tquoted_command = g_shell_quote (comics_document->selected_command);\n\tif (comics_document->regex_arg) {\n\t\tquoted_file = comics_regex_quote (comics_document->archive);\n\t\tquoted_file_aux = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t   g_strdup_printf (command_usage_def[type].list,\n\t\t\t                    comics_document->alternative_command,\n\t\t\t                    quoted_file_aux);\n\t\tg_free (quoted_file_aux);\n\t} else {\n\t\tquoted_file = g_shell_quote (comics_document->archive);\n\t\tcomics_document->list_command =\n\t\t\t\tg_strdup_printf (command_usage_def[type].list,\n\t\t\t\t                 quoted_command, quoted_file);\n\t}\n\tcomics_document->extract_command =\n\t\t\t    g_strdup_printf (command_usage_def[type].extract,\n\t\t\t\t             quoted_command);\n\tcomics_document->offset = command_usage_def[type].offset;\n\tif (command_usage_def[type].decompress_tmp) {\n\t\tcomics_document->dir = ev_mkdtemp (\"atril-comics-XXXXXX\", error);\n                if (comics_document->dir == NULL)\n                        return FALSE;\n\t\tcomics_document->decompress_tmp =\n\t\t\tg_strdup_printf (command_usage_def[type].decompress_tmp,\n\t\t\t\t\t quoted_command, quoted_file,\n\t\t\t\t\t comics_document->dir);\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\tif (!comics_decompress_temp_dir (comics_document->decompress_tmp,\n\t\t    comics_document->selected_command, error))\n\t\t\treturn FALSE;\n\t\telse\n\t\t\treturn TRUE;\n\t} else {\n\t\tg_free (quoted_file);\n\t\tg_free (quoted_command);\n\t\treturn TRUE;\n\t}\n}", "target": 1}
{"code": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\nretry:\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\tfutex_wait_queue_me(hb, &q, to);\n\tret = 0;\n\tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out_put_key;\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n\t\tgoto retry;\n\t}\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out_put_key;\n\trestart = &current_thread_info()->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n\tret = -ERESTART_RESTARTBLOCK;\nout_put_key:\n\tput_futex_key(fshared, &q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}", "target": 1}
{"code": "MONGO_EXPORT int mongo_run_command( mongo *conn, const char *db, const bson *command,\n                                    bson *out ) {\n    int ret = MONGO_OK;\n    bson response = {NULL, 0};\n    bson fields;\n    int sl = strlen( db );\n    char *ns = bson_malloc( sl + 5 + 1 ); \n    int res, success = 0;\n    strcpy( ns, db );\n    strcpy( ns+sl, \".$cmd\" );\n    res = mongo_find_one( conn, ns, command, bson_empty( &fields ), &response );\n    bson_free( ns );\n    if( res != MONGO_OK )\n        ret = MONGO_ERROR;\n    else {\n        bson_iterator it;\n        if( bson_find( &it, &response, \"ok\" ) )\n            success = bson_iterator_bool( &it );\n        if( !success ) {\n            conn->err = MONGO_COMMAND_FAILED;\n            bson_destroy( &response );\n            ret = MONGO_ERROR;\n        }\n        else {\n            if( out )\n                *out = response;\n            else\n                bson_destroy( &response );\n        }\n    }\n    return ret;\n}", "target": 1}
{"code": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}", "target": 1}
{"code": "get_indent_lnum(linenr_T lnum)\n{\n#ifdef FEAT_VARTABS\n    return get_indent_str_vtab(ml_get(lnum), (int)curbuf->b_p_ts,\n\t\t\t\t\t\t curbuf->b_p_vts_array, FALSE);\n#else\n    return get_indent_str(ml_get(lnum), (int)curbuf->b_p_ts, FALSE);\n#endif\n}", "target": 0}
{"code": "bool SpeechSynthesis::speaking() const\n{\n    return currentSpeechUtterance();\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    int i, n = 0, len = Jsi_ObjGetLength(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = Jsi_ObjGetLength(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;\n}", "target": 1}
{"code": "sudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw,\n    unsigned int mode)\n{\n    sudo_auth *auth;\n    int status = AUTH_SUCCESS;\n    debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH);\n    if (auth_switch[0].name == NULL)\n\tdebug_return_int(0);\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (ISSET(mode, MODE_NONINTERACTIVE))\n\t    SET(auth->flags, FLAG_NONINTERACTIVE);\n\tif (auth->init && !IS_DISABLED(auth)) {\n\t    status = (auth->init)(ctx, pw, auth);\n\t    if (status == AUTH_FAILURE)\n\t\tSET(auth->flags, FLAG_DISABLED);\n\t    else if (status == AUTH_ERROR)\n\t\tbreak;\t\t\n\t}\n    }\n    if ((standalone = IS_STANDALONE(&auth_switch[0]))) {\n\tbool found = false;\n\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    if (!IS_STANDALONE(auth)) {\n\t\taudit_failure(ctx, ctx->runas.argv,\n\t\t    N_(\"invalid authentication methods\"));\n\t\tlog_warningx(ctx, SLOG_SEND_MAIL,\n\t\t    N_(\"Invalid authentication methods compiled into sudo!  \"\n\t\t    \"You may not mix standalone and non-standalone authentication.\"));\n\t\tdebug_return_int(-1);\n\t    }\n\t    if (!found) {\n\t\tfound = true;\n\t\tcontinue;\n\t    }\n\t    SET(auth->flags, FLAG_DISABLED);\n\t}\n    }\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (!IS_DISABLED(auth)) {\n\t    sudo_auth *first = auth;\n\t    for (; auth->name; auth++) {\n\t\tif (!IS_DISABLED(auth))\n\t\t    break;\n\t    }\n\t    if (auth->name == NULL)\n\t\tSET(first->flags, FLAG_ONEANDONLY);\n\t    break;\n\t}\n    }\n    debug_return_int(status == AUTH_ERROR ? -1 : 0);\n}", "target": 1}
{"code": "ttwu_do_activate(struct rq *rq, struct task_struct *p, int wake_flags)\n{\n\tlockdep_assert_held(&rq->lock);\n#ifdef CONFIG_SMP\n\tif (p->sched_contributes_to_load)\n\t\trq->nr_uninterruptible--;\n#endif\n\tttwu_activate(rq, p, ENQUEUE_WAKEUP | ENQUEUE_WAKING);\n\tttwu_do_wakeup(rq, p, wake_flags);\n}", "target": 0}
{"code": "ZEND_API int zend_register_class_alias_ex(const char *name, int name_len, zend_class_entry *ce TSRMLS_DC) \n{\n\tchar *lcname = zend_str_tolower_dup(name, name_len);\n\tint ret;\n\tif (lcname[0] == '\\\\') {\n\t\tret = zend_hash_add(CG(class_table), lcname+1, name_len, &ce, sizeof(zend_class_entry *), NULL);\n\t} else {\n\t\tret = zend_hash_add(CG(class_table), lcname, name_len+1, &ce, sizeof(zend_class_entry *), NULL);\n\t}\n\tefree(lcname);\n\tif (ret == SUCCESS) {\n\t\tce->refcount++;\n\t}\n\treturn ret;\n}", "target": 0}
{"code": "void jpc_qmfb_split_col(jpc_fix_t *a, int numrows, int stride,\n  int parity)\n{\n\tint bufsize = JPC_CEILDIVPOW2(numrows, 1);\n\tjpc_fix_t splitbuf[QMFB_SPLITBUFSIZE];\n\tjpc_fix_t *buf = splitbuf;\n\tregister jpc_fix_t *srcptr;\n\tregister jpc_fix_t *dstptr;\n\tregister int n;\n\tregister int m;\n\tint hstartcol;\n\tif (bufsize > QMFB_SPLITBUFSIZE) {\n\t\tif (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) {\n\t\t\tabort();\n\t\t}\n\t}\n\tif (numrows >= 2) {\n\t\thstartcol = (numrows + 1 - parity) >> 1;\n\t\tm = numrows - hstartcol;\n\t\tn = m;\n\t\tdstptr = buf;\n\t\tsrcptr = &a[(1 - parity) * stride];\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\t++dstptr;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[(1 - parity) * stride];\n\t\tsrcptr = &a[(2 - parity) * stride];\n\t\tn = numrows - m - (!parity);\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\tsrcptr += stride << 1;\n\t\t}\n\t\tdstptr = &a[hstartcol * stride];\n\t\tsrcptr = buf;\n\t\tn = m;\n\t\twhile (n-- > 0) {\n\t\t\t*dstptr = *srcptr;\n\t\t\tdstptr += stride;\n\t\t\t++srcptr;\n\t\t}\n\t}\n\tif (buf != splitbuf) {\n\t\tjas_free(buf);\n\t}\n}", "target": 1}
{"code": "void RenderView::SyncNavigationState() {\n  if (!webview())\n    return;\n  const WebHistoryItem& item = webview()->mainFrame()->currentHistoryItem();\n  if (item.isNull())\n    return;\n  Send(new ViewHostMsg_UpdateState(\n      routing_id_, page_id_, webkit_glue::HistoryItemToString(item)));\n}", "target": 0}
{"code": "static inline int preempt_count_equals(int preempt_offset)\n{\n\tint nested = preempt_count() + rcu_preempt_depth();\n\treturn (nested == preempt_offset);\n}", "target": 0}
{"code": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}", "target": 1}
{"code": "void nfs4_close_state(struct path *path, struct nfs4_state *state, mode_t mode)\n{\n\t__nfs4_close(path, state, mode, 0);\n}", "target": 1}
{"code": "static void vhost_net_ubuf_put_wait_and_free(struct vhost_net_ubuf_ref *ubufs)\n{\n\tvhost_net_ubuf_put_and_wait(ubufs);\n\tkfree(ubufs);\n}", "target": 0}
{"code": "int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n  struct {\n    __u8 v;\n    __le64 magic;\n    __le32 len;\n    __le32 header_crc;\n    __le32 front_crc;\n    __le32 middle_crc;\n    __le32 data_crc;\n  } __attribute__ ((packed)) sigblock = {\n    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n  };\n  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n  try {\n    const CryptoKey::in_slice_t in {\n      sizeof(sigblock),\n      reinterpret_cast<const unsigned char*>(&sigblock)\n    };\n    const CryptoKey::out_slice_t out {\n      sizeof(exp_buf),\n      reinterpret_cast<unsigned char*>(&exp_buf)\n    };\n    key.encrypt(cct, in, out);\n  } catch (std::exception& e) {\n    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n    return -1;\n  }\n  *psig = *reinterpret_cast<__le64*>(exp_buf);\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}", "target": 1}
{"code": "log2vis_encoded_string (PyObject * string, const char *encoding,\n\t\t\tFriBidiParType base_direction, int clean, int reordernsm)\n{\n\tPyObject *logical = NULL;\t\n\tPyObject *result = NULL;\t\n\tlogical = PyUnicode_Decode (PyString_AS_STRING (string),\n\t\t\t\t    PyString_GET_SIZE (string),\n\t\t\t\t    encoding, \"strict\");\n\tif (logical == NULL)\n\t\treturn NULL;\n\tif (strcmp (encoding, \"utf-8\") == 0)\n\t\tresult = log2vis_utf8 (string,\n\t\t\t\t       PyUnicode_GET_SIZE (logical),\n\t\t\t\t       base_direction, clean, reordernsm);\n\telse\n\t{\n\t\tPyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);\n\t\tif (visual)\n\t\t{\n\t\t\tresult = PyUnicode_Encode (PyUnicode_AS_UNICODE\n\t\t\t\t\t\t   (visual),\n\t\t\t\t\t\t   PyUnicode_GET_SIZE (visual),\n\t\t\t\t\t\t   encoding, \"strict\");\n\t\t\tPy_DECREF (visual);\n\t\t}\n\t}\n\tPy_DECREF (logical);\n\treturn result;\n}", "target": 1}
{"code": "void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {\n\tbin->header_offset = r_buf_read_le16_at (buf, 0x3c);\n\tbin->ne_header = R_NEW0 (NE_image_header);\n\tif (!bin->ne_header) {\n\t\treturn;\n\t}\n\tbin->buf = buf;\n\tr_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));\n\tbin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;\n\tif (!bin->alignment) {\n\t\tbin->alignment = 1 << 9;\n\t}\n\tbin->os = __get_target_os (bin);\n\tut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;\n\tut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);\n\tbin->segment_entries = calloc (1, size);\n\tif (!bin->segment_entries) {\n\t\treturn;\n\t}\n\tr_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);\n\tbin->entry_table = calloc (1, bin->ne_header->EntryTableLength);\n\tr_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);\n\tbin->imports = r_bin_ne_get_imports (bin);\n\t__ne_get_resources (bin);\n}", "target": 1}
{"code": "int fz_colorspace_is_subtractive(fz_context *ctx, const fz_colorspace *cs)\n{\n\treturn cs && (cs->type == FZ_COLORSPACE_CMYK || cs->type == FZ_COLORSPACE_SEPARATION);\n}", "target": 0}
{"code": "static int StreamTcpPacketStateClosed(ThreadVars *tv, Packet *p,\n        StreamTcpThread *stt, TcpSession *ssn, PacketQueueNoLock *pq)\n{\n    if (ssn == NULL)\n        return -1;\n    if (p->tcph->th_flags & TH_RST) {\n        SCLogDebug(\"RST on closed state\");\n        return 0;\n    }\n    TcpStream *stream = NULL, *ostream = NULL;\n    if (PKT_IS_TOSERVER(p)) {\n        stream = &ssn->client;\n        ostream = &ssn->server;\n    } else {\n        stream = &ssn->server;\n        ostream = &ssn->client;\n    }\n    SCLogDebug(\"stream %s ostream %s\",\n            stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV?\"true\":\"false\",\n            ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV ? \"true\":\"false\");\n    if ((stream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) == 0) {\n        if (ostream->flags & STREAMTCP_STREAM_FLAG_RST_RECV) {\n            if (StreamTcpStateDispatch(tv, p, stt, ssn, &stt->pseudo_queue, ssn->pstate) < 0)\n                return -1;\n            if (ssn->state == TCP_CLOSED)\n                ssn->state = ssn->pstate;\n        }\n    }\n    return 0;\n}", "target": 0}
{"code": "void CMsgReader::readExtendedClipboard(rdr::S32 len)\n{\n  rdr::U32 flags;\n  rdr::U32 action;\n  if (len < 4)\n    throw Exception(\"Invalid extended clipboard message\");\n  if (len > maxCutText) {\n    vlog.error(\"Extended clipboard message too long (%d bytes) - ignoring\", len);\n    is->skip(len);\n    return;\n  }\n  flags = is->readU32();\n  action = flags & clipboardActionMask;\n  if (action & clipboardCaps) {\n    int i;\n    size_t num;\n    rdr::U32 lengths[16];\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        num++;\n    }\n    if (len < (rdr::S32)(4 + 4*num))\n      throw Exception(\"Invalid extended clipboard message\");\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (flags & (1 << i))\n        lengths[num++] = is->readU32();\n    }\n    handler->handleClipboardCaps(flags, lengths);\n  } else if (action == clipboardProvide) {\n    rdr::ZlibInStream zis;\n    int i;\n    size_t num;\n    size_t lengths[16];\n    rdr::U8* buffers[16];\n    zis.setUnderlying(is, len - 4);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      lengths[num] = zis.readU32();\n      if (lengths[num] > (size_t)maxCutText) {\n        vlog.error(\"Extended clipboard data too long (%d bytes) - ignoring\",\n                   (unsigned)lengths[num]);\n        zis.skip(lengths[num]);\n        flags &= ~(1 << i);\n        continue;\n      }\n      buffers[num] = new rdr::U8[lengths[num]];\n      zis.readBytes(buffers[num], lengths[num]);\n      num++;\n    }\n    zis.removeUnderlying();\n    handler->handleClipboardProvide(flags, lengths, buffers);\n    num = 0;\n    for (i = 0;i < 16;i++) {\n      if (!(flags & 1 << i))\n        continue;\n      delete [] buffers[num++];\n    }\n  } else {\n    switch (action) {\n    case clipboardRequest:\n      handler->handleClipboardRequest(flags);\n      break;\n    case clipboardPeek:\n      handler->handleClipboardPeek(flags);\n      break;\n    case clipboardNotify:\n      handler->handleClipboardNotify(flags);\n      break;\n    default:\n      throw Exception(\"Invalid extended clipboard action\");\n    }\n  }\n}", "target": 1}
{"code": "bool Mfcc::Initialize(int input_length, double input_sample_rate) {\n  bool initialized = mel_filterbank_.Initialize(\n      input_length, input_sample_rate, filterbank_channel_count_,\n      lower_frequency_limit_, upper_frequency_limit_);\n  initialized &=\n      dct_.Initialize(filterbank_channel_count_, dct_coefficient_count_);\n  initialized_ = initialized;\n  return initialized;\n}", "target": 1}
{"code": "static void irda_flow_indication(void *instance, void *sap, LOCAL_FLOW flow)\n{\n\tstruct irda_sock *self;\n\tstruct sock *sk;\n\tIRDA_DEBUG(2, \"%s()\\n\", __func__);\n\tself = instance;\n\tsk = instance;\n\tBUG_ON(sk == NULL);\n\tswitch (flow) {\n\tcase FLOW_STOP:\n\t\tIRDA_DEBUG(1, \"%s(), IrTTP wants us to slow down\\n\",\n\t\t\t   __func__);\n\t\tself->tx_flow = flow;\n\t\tbreak;\n\tcase FLOW_START:\n\t\tself->tx_flow = flow;\n\t\tIRDA_DEBUG(1, \"%s(), IrTTP wants us to start again\\n\",\n\t\t\t   __func__);\n\t\twake_up_interruptible(sk->sk_sleep);\n\t\tbreak;\n\tdefault:\n\t\tIRDA_DEBUG(0, \"%s(), Unknown flow command!\\n\", __func__);\n\t\tself->tx_flow = flow;\n\t\tbreak;\n\t}\n}", "target": 0}
{"code": "static inline ut8 r_read_ble8(const void *src) {\n\tif (!src) {\n\t\treturn UT8_MAX;\n\t}\n\treturn *(ut8 *)src;\n}", "target": 0}
{"code": "print_arrays_for(char *set)\n{\n  FILE *f;\n  sprintf(buf, \"%s.conf\", set);\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n  printf(\"\\\n\\n\\n\",\n\t set, prog);\n  print_array(f, set, \"ctype\",      CTYPE_TABLE_SIZE);\n  print_array(f, set, \"to_lower\",   TO_LOWER_TABLE_SIZE);\n  print_array(f, set, \"to_upper\",   TO_UPPER_TABLE_SIZE);\n  print_array(f, set, \"sort_order\", SORT_ORDER_TABLE_SIZE);\n  printf(\"\\n\");\n  fclose(f);\n  return;\n}", "target": 1}
{"code": "MYSQL_PARAMETERS *STDCALL mysql_get_parameters(void)\n{\n  return &mysql_internal_parameters;\n}", "target": 0}
{"code": "static int __init snd_mem_init(void)\n{\n#ifdef CONFIG_PROC_FS\n\tsnd_mem_proc = create_proc_entry(SND_MEM_PROC_FILE, 0644, NULL);\n\tif (snd_mem_proc)\n\t\tsnd_mem_proc->proc_fops = &snd_mem_proc_fops;\n#endif\n\treturn 0;\n}", "target": 0}
{"code": "unsigned long perf_instruction_pointer(struct pt_regs *regs)\n{\n\tbool use_siar = regs_use_siar(regs);\n\tunsigned long siar = mfspr(SPRN_SIAR);\n\tif (ppmu->flags & PPMU_P10_DD1) {\n\t\tif (siar)\n\t\t\treturn siar;\n\t\telse\n\t\t\treturn regs->nip;\n\t} else if (use_siar && siar_valid(regs))\n\t\treturn mfspr(SPRN_SIAR) + perf_ip_adjust(regs);\n\telse if (use_siar)\n\t\treturn 0;\t\t\n\telse\n\t\treturn regs->nip;\n}", "target": 1}
{"code": "PHPAPI zend_string *php_escape_shell_arg(char *str)\n{\n\tint x, y = 0, l = (int)strlen(str);\n\tzend_string *cmd;\n\tsize_t estimate = (4 * l) + 3;\n\tcmd = zend_string_alloc(4 * l + 2, 0); \n#ifdef PHP_WIN32\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\tfor (x = 0; x < l; x++) {\n\t\tint mb_len = php_mblen(str + x, (l - x));\n\t\tif (mb_len < 0) {\n\t\t\tcontinue;\n\t\t} else if (mb_len > 1) {\n\t\t\tmemcpy(ZSTR_VAL(cmd) + y, str + x, mb_len);\n\t\t\ty += mb_len;\n\t\t\tx += mb_len - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (str[x]) {\n#ifdef PHP_WIN32\n\t\tcase '\"':\n\t\tcase '%':\n\t\tcase '!':\n\t\t\tZSTR_VAL(cmd)[y++] = ' ';\n\t\t\tbreak;\n#else\n\t\tcase '\\'':\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\t\tdefault:\n\t\t\tZSTR_VAL(cmd)[y++] = str[x];\n\t\t}\n\t}\n#ifdef PHP_WIN32\n\tif (y > 0 && '\\\\' == ZSTR_VAL(cmd)[y - 1]) {\n\t\tint k = 0, n = y - 1;\n\t\tfor (; n >= 0 && '\\\\' == ZSTR_VAL(cmd)[n]; n--, k++);\n\t\tif (k % 2) {\n\t\t\tZSTR_VAL(cmd)[y++] = '\\\\';\n\t\t}\n\t}\n\tZSTR_VAL(cmd)[y++] = '\"';\n#else\n\tZSTR_VAL(cmd)[y++] = '\\'';\n#endif\n\tZSTR_VAL(cmd)[y] = '\\0';\n\tif ((estimate - y) > 4096) {\n\t\tcmd = zend_string_truncate(cmd, y, 0);\n\t}\n\tZSTR_LEN(cmd) = y;\n\treturn cmd;\n}", "target": 1}
{"code": "static int selinux_task_setnice(struct task_struct *p, int nice)\n{\n\treturn avc_has_perm(&selinux_state,\n\t\t\t    current_sid(), task_sid(p), SECCLASS_PROCESS,\n\t\t\t    PROCESS__SETSCHED, NULL);\n}", "target": 0}
{"code": "void gf_bs_skip_bytes(GF_BitStream *bs, u64 nbBytes)\n{\n\tif (!bs || !nbBytes) return;\n\tgf_bs_align(bs);\n\tif ((bs->bsmode == GF_BITSTREAM_FILE_WRITE) || (bs->bsmode == GF_BITSTREAM_FILE_READ)) {\n\t\tif (bs->cache_write)\n\t\t\tbs_flush_write_cache(bs);\n\t\tif (bs->cache_read) {\n\t\t\tu32 csize = bs->cache_read_size - bs->cache_read_pos;\n\t\t\tif (csize>=nbBytes) {\n\t\t\t\tbs->cache_read_pos += (u32) nbBytes;\n\t\t\t\tbs->position += nbBytes;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnbBytes -= csize;\n\t\t\tbs->position += csize;\n\t\t\tbs->cache_read_pos = bs->cache_read_size;\n\t\t}\n\t\tbs->position += nbBytes;\n\t\tif (bs->bsmode == GF_BITSTREAM_FILE_READ) {\n\t\t\tif (bs->position > bs->size) bs->position = bs->size;\n\t\t}\n\t\tgf_fseek(bs->stream, bs->position, SEEK_SET);\n\t\treturn;\n\t}\n\tif (bs->bsmode == GF_BITSTREAM_READ) {\n\t\tif (bs->remove_emul_prevention_byte) {\n\t\t\twhile (nbBytes) {\n\t\t\t\tgf_bs_read_u8(bs);\n\t\t\t\tnbBytes--;\n\t\t\t}\n\t\t} else {\n\t\t\tbs->position += nbBytes;\n\t\t\tif (bs->position>bs->size) {\n\t\t\t\tbs->position = bs->size;\n\t\t\t\tbs->overflow_state = 1;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\twhile (nbBytes) {\n\t\tgf_bs_write_int(bs, 0, 8);\n\t\tnbBytes--;\n\t}\n}", "target": 0}
{"code": "    bool IsLoaded() {return Loaded;}", "target": 0}
{"code": "HIDDEN void log_cachehdr(const char *name, const char *contents,\n                         const char *raw, void *rock)\n{\n    struct buf *buf = (struct buf *) rock;\n    if (name[0] == ':') return;\n    if (!strcasecmp(name, \"authorization\")) {\n        const char *creds = strchr(contents, ' ') + 1;\n        buf_printf(buf, \"%c%s: %.*s%-*s\\r\\n\", toupper(name[0]), name+1,\n                   (int) (creds - contents), contents,\n                   (int) strlen(creds), \"...\");\n    }\n    else if (raw)\n        buf_appendcstr(buf, raw);\n    else\n        buf_printf(buf, \"%c%s: %s\\r\\n\", toupper(name[0]), name+1, contents);\n}", "target": 0}
{"code": "void CScreenshotPortal::onScreenshot(sdbus::MethodCall& call) {\n    sdbus::ObjectPath requestHandle;\n    call >> requestHandle;\n    std::string appID;\n    call >> appID;\n    std::string parentWindow;\n    call >> parentWindow;\n    std::unordered_map<std::string, sdbus::Variant> options;\n    call >> options;\n    Debug::log(LOG, \"[screenshot] New screenshot request:\");\n    Debug::log(LOG, \"[screenshot]  | {}\", requestHandle.c_str());\n    Debug::log(LOG, \"[screenshot]  | appid: {}\", appID);\n    bool isInteractive = options.count(\"interactive\") && options[\"interactive\"].get<bool>() && inShellPath(\"slurp\");\n    const std::string HYPR_DIR             = \"/tmp/hypr/\";\n    const std::string SNAP_FILE            = \"xdph_screenshot.png\";\n    const std::string FILE_PATH            = HYPR_DIR + SNAP_FILE;\n    const std::string SNAP_CMD             = \"grim \" + FILE_PATH;\n    const std::string SNAP_INTERACTIVE_CMD = \"grim -g \\\"$(slurp)\\\" \" + FILE_PATH;\n    std::unordered_map<std::string, sdbus::Variant> results;\n    results[\"uri\"] = \"file:\n    std::filesystem::remove(FILE_PATH);\n    std::filesystem::create_directory(HYPR_DIR);\n    if (isInteractive)\n        execAndGet(SNAP_INTERACTIVE_CMD.c_str());\n    else\n        execAndGet(SNAP_CMD.c_str());\n    uint32_t responseCode = std::filesystem::exists(FILE_PATH) ? 0 : 1;\n    auto reply = call.createReply();\n    reply << responseCode;\n    reply << results;\n    reply.send();\n}", "target": 1}
{"code": "static int dump_seek(struct file *file, loff_t off)\n{\n\tif (file->f_op->llseek && file->f_op->llseek != no_llseek) {\n\t\tif (file->f_op->llseek(file, off, SEEK_CUR) < 0)\n\t\t\treturn 0;\n\t} else {\n\t\tchar *buf = (char *)get_zeroed_page(GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn 0;\n\t\twhile (off > 0) {\n\t\t\tunsigned long n = off;\n\t\t\tif (n > PAGE_SIZE)\n\t\t\t\tn = PAGE_SIZE;\n\t\t\tif (!dump_write(file, buf, n))\n\t\t\t\treturn 0;\n\t\t\toff -= n;\n\t\t}\n\t\tfree_page((unsigned long)buf);\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "static int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\tline += 3; \n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\t*out = (git_pkt *)pkt;\n\treturn 0;\nout_err:\n\tgiterr_set(GITERR_NET, \"invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}", "target": 1}
{"code": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TFLITE_DCHECK(node->user_data != nullptr);\n  OpData* data = static_cast<OpData*>(node->user_data);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE(context, input != nullptr);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE(context, output != nullptr);\n  TF_LITE_ENSURE_EQ(context, output->quantization.type,\n                    kTfLiteAffineQuantization);\n  const auto* affine_quantization =\n      reinterpret_cast<TfLiteAffineQuantization*>(output->quantization.params);\n  TF_LITE_ENSURE(context, affine_quantization);\n  TF_LITE_ENSURE(context, affine_quantization->scale);\n  TF_LITE_ENSURE(context, affine_quantization->scale->size == 1);\n  TF_LITE_ENSURE(context, input->type == kTfLiteFloat32 ||\n                              input->type == kTfLiteInt16 ||\n                              input->type == kTfLiteInt8);\n  TF_LITE_ENSURE(context, output->type == kTfLiteUInt8 ||\n                              output->type == kTfLiteInt8 ||\n                              output->type == kTfLiteInt16);\n  if (((input->type == kTfLiteInt16 || input->type == kTfLiteInt8) &&\n       output->type == kTfLiteInt8) ||\n      (input->type == kTfLiteInt16 && output->type == kTfLiteInt16)) {\n    double effective_scale = static_cast<double>(input->params.scale) /\n                             static_cast<double>(output->params.scale);\n    QuantizeMultiplier(effective_scale, &data->output_multiplier,\n                       &data->output_shift);\n  }\n  data->quantization_params.zero_point = output->params.zero_point;\n  data->quantization_params.scale = static_cast<double>(output->params.scale);\n  data->input_zero_point = input->params.zero_point;\n  return kTfLiteOk;\n}", "target": 0}
{"code": "static struct btf *find_kfunc_desc_btf(struct bpf_verifier_env *env,\n\t\t\t\t       u32 func_id, s16 offset,\n\t\t\t\t       struct module **btf_modp)\n{\n\tif (offset) {\n\t\tif (offset < 0) {\n\t\t\tverbose(env, \"negative offset disallowed for kernel module function call\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\treturn __find_kfunc_desc_btf(env, offset, btf_modp);\n\t}\n\treturn btf_vmlinux ?: ERR_PTR(-ENOENT);\n}", "target": 0}
{"code": "static void timestamp(void)\n{\n    struct compile_time * const oct = &official_compile_time;\n    const struct tm *tp, *best_gm;\n    time(&oct->t);\n    best_gm = NULL;\n    tp = localtime(&oct->t);\n    if (tp) {\n        oct->local = *tp;\n        best_gm = &oct->local;\n        oct->have_local = true;\n    }\n    tp = gmtime(&oct->t);\n    if (tp) {\n        oct->gm = *tp;\n        best_gm = &oct->gm;\n        oct->have_gm = true;\n        if (!oct->have_local)\n            oct->local = oct->gm;\n    } else {\n        oct->gm = oct->local;\n    }\n    if (best_gm) {\n        oct->posix = make_posix_time(best_gm);\n        oct->have_posix = true;\n    }\n}", "target": 0}
{"code": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}", "target": 0}
{"code": "cherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n\tif ((conn->validator == NULL) ||\n\t    cherokee_buffer_is_empty (&conn->validator->user))\n\t\treturn ret_error;\n\tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");\n\tif (size != conn->validator->user.len)\n\t\treturn ret_error;\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props->filter.buf ? props->filter.buf : \"\");\n\t\treturn ret_error;\n\t}\n\tTRACE (ENTRIES, \"subtree search (%s): done\\n\", ldap->filter.buf ? ldap->filter.buf : \"\");\n\tre = ldap_count_entries (ldap->conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tfirst = ldap_first_entry (ldap->conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\tdn = ldap_get_dn (ldap->conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\tldap_msgfree (message);\n\tret = validate_dn (props, dn, conn->validator->passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\tre = ldap_unbind_s (ldap->conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\tTRACE (ENTRIES, \"Access to use %s has been granted\\n\", conn->validator->user.buf);\n\treturn ret_ok;\n}", "target": 1}
{"code": "TfLiteStatus EvalHashtable(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE(context, node->user_data != nullptr);\n  const auto* params =\n      reinterpret_cast<const TfLiteHashtableParams*>(node->user_data);\n  const int resource_id = std::hash<std::string>{}(params->table_name);\n  TfLiteTensor* resource_handle_tensor =\n      GetOutput(context, node, kResourceHandleTensor);\n  auto* resource_handle_data =\n      GetTensorData<std::int32_t>(resource_handle_tensor);\n  resource_handle_data[0] = resource_id;\n  Subgraph* subgraph = reinterpret_cast<Subgraph*>(context->impl_);\n  auto& resources = subgraph->resources();\n  resource::CreateHashtableResourceIfNotAvailable(\n      &resources, resource_id, params->key_dtype, params->value_dtype);\n  return kTfLiteOk;\n}", "target": 1}
{"code": "AP4_StszAtom::AP4_StszAtom(AP4_UI32        size, \n                           AP4_UI08        version,\n                           AP4_UI32        flags,\n                           AP4_ByteStream& stream) :\n    AP4_Atom(AP4_ATOM_TYPE_STSZ, size, version, flags)\n{\n    stream.ReadUI32(m_SampleSize);\n    stream.ReadUI32(m_SampleCount);\n    if (m_SampleSize == 0) { \n        if (m_SampleCount > (size-8)/4) {\n            m_SampleCount = 0;\n            return;\n        }\n        AP4_Cardinal sample_count = m_SampleCount;\n        m_Entries.SetItemCount(sample_count);\n        unsigned char* buffer = new unsigned char[sample_count*4];\n        AP4_Result result = stream.Read(buffer, sample_count*4);\n        if (AP4_FAILED(result)) {\n            delete[] buffer;\n            return;\n        }\n        for (unsigned int i=0; i<sample_count; i++) {\n            m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]);\n        }\n        delete[] buffer;\n    }\n}", "target": 0}
{"code": "iasecc_chv_verify(struct sc_card *card, struct sc_pin_cmd_data *pin_cmd,\n\t\tint *tries_left)\n{\n\tstruct sc_context *ctx = card->ctx;\n\tstruct sc_acl_entry acl = pin_cmd->pin1.acls[IASECC_ACLS_CHV_VERIFY];\n\tstruct sc_apdu apdu;\n\tint rv;\n\tLOG_FUNC_CALLED(ctx);\n\tsc_log(ctx, \"Verify CHV PIN(ref:%i,len:%i,acl:%X:%X)\", pin_cmd->pin_reference, pin_cmd->pin1.len,\n\t\t\tacl.method, acl.key_ref);\n\tif (acl.method & IASECC_SCB_METHOD_SM)   {\n\t\trv = iasecc_sm_pin_verify(card, acl.key_ref, pin_cmd, tries_left);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\tif (pin_cmd->pin1.data && !pin_cmd->pin1.len)   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, 0x20, 0, pin_cmd->pin_reference);\n\t}\n\telse if (pin_cmd->pin1.data && pin_cmd->pin1.len)   {\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x20, 0, pin_cmd->pin_reference);\n\t\tapdu.data = pin_cmd->pin1.data;\n\t\tapdu.datalen = pin_cmd->pin1.len;\n\t\tapdu.lc = pin_cmd->pin1.len;\n\t}\n\telse if ((card->reader->capabilities & SC_READER_CAP_PIN_PAD) && !pin_cmd->pin1.data && !pin_cmd->pin1.len)   {\n\t\trv = iasecc_chv_verify_pinpad(card, pin_cmd, tries_left);\n\t\tsc_log(ctx, \"Result of verifying CHV with PIN pad %i\", rv);\n\t\tLOG_FUNC_RETURN(ctx, rv);\n\t}\n\telse   {\n\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\trv = sc_transmit_apdu(card, &apdu);\n\tLOG_TEST_RET(ctx, rv, \"APDU transmit failed\");\n\tif (tries_left && apdu.sw1 == 0x63 && (apdu.sw2 & 0xF0) == 0xC0)\n\t\t*tries_left = apdu.sw2 & 0x0F;\n\trv = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tLOG_FUNC_RETURN(ctx, rv);\n}", "target": 0}
{"code": "struct dst_entry *inet6_csk_route_req(const struct sock *sk,\n\t\t\t\t      struct flowi6 *fl6,\n\t\t\t\t      const struct request_sock *req,\n\t\t\t\t      u8 proto)\n{\n\tstruct inet_request_sock *ireq = inet_rsk(req);\n\tconst struct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct in6_addr *final_p, final;\n\tstruct dst_entry *dst;\n\tmemset(fl6, 0, sizeof(*fl6));\n\tfl6->flowi6_proto = proto;\n\tfl6->daddr = ireq->ir_v6_rmt_addr;\n\tfinal_p = fl6_update_dst(fl6, np->opt, &final);\n\tfl6->saddr = ireq->ir_v6_loc_addr;\n\tfl6->flowi6_oif = ireq->ir_iif;\n\tfl6->flowi6_mark = ireq->ir_mark;\n\tfl6->fl6_dport = ireq->ir_rmt_port;\n\tfl6->fl6_sport = htons(ireq->ir_num);\n\tsecurity_req_classify_flow(req, flowi6_to_flowi(fl6));\n\tdst = ip6_dst_lookup_flow(sk, fl6, final_p);\n\tif (IS_ERR(dst))\n\t\treturn NULL;\n\treturn dst;\n}", "target": 1}
{"code": "int bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}", "target": 1}
{"code": "sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx,\n    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,\n    int *cmnd_status, int pwflag)\n{\n    struct defaults_list *defs = NULL;\n    struct sudoers_parse_tree *parse_tree = NULL;\n    struct cmndspec *cs = NULL;\n    struct sudo_nss *nss;\n    struct cmnd_info info;\n    unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST;\n    int m, match = UNSPEC;\n    debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER);\n    if (pwflag) {\n\tdebug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback,\n\t    cb_data, pwflag));\n    }\n    if (!set_perms(ctx, PERM_RUNAS))\n\tdebug_return_uint(validated);\n    TAILQ_FOREACH(nss, snl, entries) {\n\tif (nss->query(ctx, nss, ctx->user.pw) == -1) {\n\t    SET(validated, VALIDATE_ERROR);\n\t    break;\n\t}\n\tm = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback,\n\t    cb_data, &cs, &defs);\n\tif (m != UNSPEC) {\n\t    match = m;\n\t    parse_tree = nss->parse_tree;\n\t}\n\tif (!sudo_nss_can_continue(nss, m))\n\t    break;\n    }\n    if (match != UNSPEC) {\n\tif (info.cmnd_path != NULL) {\n\t    free(ctx->user.cmnd);\n\t    ctx->user.cmnd = info.cmnd_path;\n\t    if (ctx->user.cmnd_stat != NULL)\n\t\t*ctx->user.cmnd_stat = info.cmnd_stat;\n\t    *cmnd_status = info.status;\n\t}\n\tif (defs != NULL)\n\t    (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false);\n\tif (!apply_cmndspec(ctx, cs))\n\t    SET(validated, VALIDATE_ERROR);\n\telse if (match == ALLOW)\n\t    SET(validated, VALIDATE_SUCCESS);\n\telse\n\t    SET(validated, VALIDATE_FAILURE);\n    }\n    if (!restore_perms())\n\tSET(validated, VALIDATE_ERROR);\n    debug_return_uint(validated);\n}", "target": 1}
{"code": "void Context::onDelete() {\n  if (wasm_->onDelete_) {\n    wasm_->onDelete_(this, id_);\n  }\n}", "target": 1}
{"code": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP &&\n\t    kvm_is_linear_rip(vcpu, vcpu->arch.singlestep_rip))\n\t\trflags |= X86_EFLAGS_TF;\n\tkvm_x86_ops->set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}", "target": 0}
{"code": "int tcp_read_sock(struct sock *sk, read_descriptor_t *desc,\n\t\t  sk_read_actor_t recv_actor)\n{\n\tstruct sk_buff *skb;\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tu32 seq = tp->copied_seq;\n\tu32 offset;\n\tint copied = 0;\n\tif (sk->sk_state == TCP_LISTEN)\n\t\treturn -ENOTCONN;\n\twhile ((skb = tcp_recv_skb(sk, seq, &offset)) != NULL) {\n\t\tif (offset < skb->len) {\n\t\t\tint used;\n\t\t\tsize_t len;\n\t\t\tlen = skb->len - offset;\n\t\t\tif (tp->urg_data) {\n\t\t\t\tu32 urg_offset = tp->urg_seq - seq;\n\t\t\t\tif (urg_offset < len)\n\t\t\t\t\tlen = urg_offset;\n\t\t\t\tif (!len)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused = recv_actor(desc, skb, offset, len);\n\t\t\tif (used < 0) {\n\t\t\t\tif (!copied)\n\t\t\t\t\tcopied = used;\n\t\t\t\tbreak;\n\t\t\t} else if (used <= len) {\n\t\t\t\tseq += used;\n\t\t\t\tcopied += used;\n\t\t\t\toffset += used;\n\t\t\t}\n\t\t\tskb = tcp_recv_skb(sk, seq-1, &offset);\n\t\t\tif (!skb || (offset+1 != skb->len))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (tcp_hdr(skb)->fin) {\n\t\t\tsk_eat_skb(sk, skb, 0);\n\t\t\t++seq;\n\t\t\tbreak;\n\t\t}\n\t\tsk_eat_skb(sk, skb, 0);\n\t\tif (!desc->count)\n\t\t\tbreak;\n\t\ttp->copied_seq = seq;\n\t}\n\ttp->copied_seq = seq;\n\ttcp_rcv_space_adjust(sk);\n\tif (copied > 0)\n\t\ttcp_cleanup_rbuf(sk, copied);\n\treturn copied;\n}", "target": 0}
{"code": "void PrintWebViewHelper::DidFinishPrinting(PrintingResult result) {\n  switch (result) {\n    case OK:\n      break;\n    case FAIL_PRINT_INIT:\n      DCHECK(!notify_browser_of_print_failure_);\n      break;\n    case FAIL_PRINT:\n      if (notify_browser_of_print_failure_ && print_pages_params_) {\n        int cookie = print_pages_params_->params.document_cookie;\n        Send(new PrintHostMsg_PrintingFailed(routing_id(), cookie));\n      }\n      break;\n    case FAIL_PREVIEW:\n      int cookie =\n          print_pages_params_ ? print_pages_params_->params.document_cookie : 0;\n      if (notify_browser_of_print_failure_) {\n        LOG(ERROR) << \"CreatePreviewDocument failed\";\n        Send(new PrintHostMsg_PrintPreviewFailed(routing_id(), cookie));\n      } else {\n        Send(new PrintHostMsg_PrintPreviewCancelled(routing_id(), cookie));\n      }\n      print_preview_context_.Failed(notify_browser_of_print_failure_);\n      break;\n  }\n  prep_frame_view_.reset();\n  print_pages_params_.reset();\n  notify_browser_of_print_failure_ = true;\n}", "target": 0}
{"code": "static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) {\n    int istart = 0, n, i = 0, dir=1, idx=-1;\n    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    if (!seq) {\n        goto bail;\n    }\n    n = Jsi_ObjGetLength(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }\n    if (op == 2) {\n        istart = n-1;\n        dir = -1;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    for (i = istart; ; i+=dir)\n    {\n        if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt)\n            break;\n        if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) {\n            idx = i;\n            break;\n        }\n    }\nbail:\n    if (op == 3)\n        Jsi_ValueMakeBool(interp, ret, (idx!=-1));\n    else\n        Jsi_ValueMakeNumber(interp, ret, idx);\n    return JSI_OK;\n}", "target": 1}
{"code": "static void mirror_abort(Job *job)\n{\n    int ret = mirror_exit_common(job);\n    assert(ret == 0);\n}", "target": 0}
{"code": "const char *jsi_GetHomeDir(Jsi_Interp *interp) {\n    const char *str = NULL;\n    if (interp->homeDir)\n        return interp->homeDir;\n#ifdef __WIN32\n    str = getenv(\"USERPROFILE\"); \n#else\n    if ((str = getenv(\"HOME\")) == NULL) {\n        struct passwd pwd, *pw;\n        char buf[20000];\n        if (getpwuid_r(getuid(), &pwd, buf, sizeof(buf), &pw) == 0 && pw->pw_dir)        \n            str = pw->pw_dir;\n    }\n#endif\n    if (!str) {\n        Jsi_LogBug(\"no home dir\");\n        str = \"/\";\n    }\n#ifdef JSI_LITE_ONLY\n    return str;\n#else\n    return (interp->homeDir = Jsi_KeyAdd(interp, str));\n#endif\n}", "target": 1}
{"code": "static int sip_endpoint_identifier_str2type(const char *str)\n{\n\tint method;\n\tif (!strcasecmp(str, \"username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_USERNAME;\n\t} else if (!strcasecmp(str, \"auth_username\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_AUTH_USERNAME;\n\t} else if (!strcasecmp(str, \"ip\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_IP;\n\t} else if (!strcasecmp(str, \"header\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_HEADER;\n\t} else if (!strcasecmp(str, \"request_uri\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_REQUEST_URI;\n\t} else if (!strcasecmp(str, \"transport\")) {\n\t\tmethod = AST_SIP_ENDPOINT_IDENTIFY_BY_TRANSPORT;\n\t} else {\n\t\tmethod = -1;\n\t}\n\treturn method;\n}", "target": 1}
{"code": "slice_unit::slice_unit(decoder_context* decctx)\n  : nal(NULL),\n    shdr(NULL),\n    imgunit(NULL),\n    flush_reorder_buffer(false),\n    nThreads(0),\n    first_decoded_CTB_RS(-1),\n    last_decoded_CTB_RS(-1),\n    thread_contexts(NULL),\n    ctx(decctx)\n{\n  state = Unprocessed;\n  nThreadContexts = 0;\n}", "target": 0}
{"code": "auth_password(Authctxt *authctxt, const char *password)\n{\n\tstruct passwd * pw = authctxt->pw;\n\tint result, ok = authctxt->valid;\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tstatic int expire_checked = 0;\n#endif\n\tif (strlen(password) > MAX_PASSWORD_LEN)\n\t\treturn 0;\n#ifndef HAVE_CYGWIN\n\tif (pw->pw_uid == 0 && options.permit_root_login != PERMIT_YES)\n\t\tok = 0;\n#endif\n\tif (*password == '\\0' && options.permit_empty_passwd == 0)\n\t\treturn 0;\n#ifdef KRB5\n\tif (options.kerberos_authentication == 1) {\n\t\tint ret = auth_krb5_password(authctxt, password);\n\t\tif (ret == 1 || ret == 0)\n\t\t\treturn ret && ok;\n\t}\n#endif\n#ifdef HAVE_CYGWIN\n\t{\n\t\tHANDLE hToken = cygwin_logon_user(pw, password);\n\t\tif (hToken == INVALID_HANDLE_VALUE)\n\t\t\treturn 0;\n\t\tcygwin_set_impersonation_token(hToken);\n\t\treturn ok;\n\t}\n#endif\n#ifdef USE_PAM\n\tif (options.use_pam)\n\t\treturn (sshpam_auth_passwd(authctxt, password) && ok);\n#endif\n#if defined(USE_SHADOW) && defined(HAS_SHADOW_EXPIRE)\n\tif (!expire_checked) {\n\t\texpire_checked = 1;\n\t\tif (auth_shadow_pwexpired(authctxt))\n\t\t\tauthctxt->force_pwchange = 1;\n\t}\n#endif\n\tresult = sys_auth_passwd(authctxt, password);\n\tif (authctxt->force_pwchange)\n\t\tdisable_forwarding();\n\treturn (result && ok);\n}", "target": 0}
{"code": "static inline short key_read_state(const struct key *key)\n{\n\treturn smp_load_acquire(&key->state);\n}", "target": 0}
{"code": "struct tcp_conn_t *tcp_conn_accept(struct tcp_sock_t *sock)\n{\n\tstruct tcp_conn_t *conn = calloc(1, sizeof *conn);\n\tif (conn == NULL) {\n\t\tERR(\"Calloc for connection struct failed\");\n\t\tgoto error;\n\t}\n\tconn->sd = accept(sock->sd, NULL, NULL);\n\tif (conn->sd < 0) {\n\t\tERR(\"accept failed\");\n\t\tgoto error;\n\t}\n\treturn conn;\nerror:\n\tif (conn != NULL)\n\t\tfree(conn);\n\treturn NULL;\n}", "target": 1}
{"code": "static inline bool key_is_negative(const struct key *key)\n{\n\treturn key_read_state(key) < 0;\n}", "target": 0}
{"code": "socket_accept(const int sock)\n{\n        struct sockaddr_storage addrin;\n        socklen_t addrinlen = sizeof(addrin);\n        int net;\n        net = accept(sock, (struct sockaddr *) &addrin, &addrinlen);\n        if (net < 0) {\n                err_nonfatal(\"Failed to accept socket connection: %m\");\n        }\n        return net;\n}", "target": 0}
{"code": "void SetSitesMuted(const TabStripModel& tab_strip,\n                   const std::vector<int>& indices,\n                   const bool mute) {\n  for (int tab_index : indices) {\n    content::WebContents* web_contents = tab_strip.GetWebContentsAt(tab_index);\n    GURL url = web_contents->GetLastCommittedURL();\n    if (url.SchemeIs(content::kChromeUIScheme)) {\n      SetTabAudioMuted(web_contents, mute,\n                       TabMutedReason::CONTENT_SETTING_CHROME, std::string());\n    } else {\n      Profile* profile =\n          Profile::FromBrowserContext(web_contents->GetBrowserContext());\n      HostContentSettingsMap* settings =\n          HostContentSettingsMapFactory::GetForProfile(profile);\n      ContentSetting setting =\n          mute ? CONTENT_SETTING_BLOCK : CONTENT_SETTING_ALLOW;\n      if (setting == settings->GetDefaultContentSetting(\n                         CONTENT_SETTINGS_TYPE_SOUND, nullptr)) {\n        setting = CONTENT_SETTING_DEFAULT;\n      }\n      settings->SetContentSettingDefaultScope(\n          url, url, CONTENT_SETTINGS_TYPE_SOUND, std::string(), setting);\n    }\n  }\n}", "target": 0}
{"code": "QStringList JlCompress::extractDir(QuaZip &zip, const QString &dir)\n{\n    if(!zip.open(QuaZip::mdUnzip)) {\n        return QStringList();\n    }\n    QDir directory(dir);\n    QStringList extracted;\n    if (!zip.goToFirstFile()) {\n        return QStringList();\n    }\n    do {\n        QString name = zip.getCurrentFileName();\n        QString absFilePath = directory.absoluteFilePath(name);\n        if (!extractFile(&zip, \"\", absFilePath)) {\n            removeFile(extracted);\n            return QStringList();\n        }\n        extracted.append(absFilePath);\n    } while (zip.goToNextFile());\n    zip.close();\n    if(zip.getZipError()!=0) {\n        removeFile(extracted);\n        return QStringList();\n    }\n    return extracted;\n}", "target": 1}
{"code": "static void *__dma_alloc_coherent(struct device *dev, size_t size,\n\t\t\t\t  dma_addr_t *dma_handle, gfp_t flags,\n\t\t\t\t  struct dma_attrs *attrs)\n{\n\tif (dev == NULL) {\n\t\tWARN_ONCE(1, \"Use an actual device structure for DMA allocation\\n\");\n\t\treturn NULL;\n\t}\n\tif (IS_ENABLED(CONFIG_ZONE_DMA) &&\n\t    dev->coherent_dma_mask <= DMA_BIT_MASK(32))\n\t\tflags |= GFP_DMA;\n\tif (IS_ENABLED(CONFIG_DMA_CMA) && (flags & __GFP_WAIT)) {\n\t\tstruct page *page;\n\t\tvoid *addr;\n\t\tsize = PAGE_ALIGN(size);\n\t\tpage = dma_alloc_from_contiguous(dev, size >> PAGE_SHIFT,\n\t\t\t\t\t\t\tget_order(size));\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\t*dma_handle = phys_to_dma(dev, page_to_phys(page));\n\t\taddr = page_address(page);\n\t\tif (flags & __GFP_ZERO)\n\t\t\tmemset(addr, 0, size);\n\t\treturn addr;\n\t} else {\n\t\treturn swiotlb_alloc_coherent(dev, size, dma_handle, flags);\n\t}\n}", "target": 1}
{"code": "\tvirtual size_t\tRead(void *buffer, size_t size, size_t count)\n\t{\n\t\tif (!m_fp) return 0;\n\t\treturn fread(buffer, size, count, m_fp);\n\t}", "target": 1}
{"code": "spnego_gss_pseudo_random(OM_uint32 *minor_status,\n\t\t\t gss_ctx_id_t context,\n\t\t\t int prf_key,\n\t\t\t const gss_buffer_t prf_in,\n\t\t\t ssize_t desired_output_len,\n\t\t\t gss_buffer_t prf_out)\n{\n\tOM_uint32 ret;\n\tret = gss_pseudo_random(minor_status,\n\t\t\t\tcontext,\n\t\t\t\tprf_key,\n\t\t\t\tprf_in,\n\t\t\t\tdesired_output_len,\n\t\t\t\tprf_out);\n        return (ret);\n}", "target": 1}
{"code": "write_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);\n\t\tstrs = backtrace_symbols(buffer, nptrs);\n\t\tif (strs == NULL) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get stack backtrace\");\n\t\t\treturn;\n\t\t}\n\t\tfor (i = 1; i < nptrs - 2; i++)\n\t\t\tlog_message(LOG_INFO, \"  %s\", strs[i]);\n\t\tfree(strs);\n\t}\n}", "target": 1}
{"code": "cdf_unpack_dir(cdf_directory_t *d, char *buf)\n{\n\tsize_t len = 0;\n\tCDF_UNPACKA(d->d_name);\n\tCDF_UNPACK(d->d_namelen);\n\tCDF_UNPACK(d->d_type);\n\tCDF_UNPACK(d->d_color);\n\tCDF_UNPACK(d->d_left_child);\n\tCDF_UNPACK(d->d_right_child);\n\tCDF_UNPACK(d->d_storage);\n\tCDF_UNPACKA(d->d_storage_uuid);\n\tCDF_UNPACK(d->d_flags);\n\tCDF_UNPACK(d->d_created);\n\tCDF_UNPACK(d->d_modified);\n\tCDF_UNPACK(d->d_stream_first_sector);\n\tCDF_UNPACK(d->d_size);\n\tCDF_UNPACK(d->d_unused0);\n}", "target": 0}
{"code": "void test_stat(const char *path)\n{\n\tstruct stat sb;\n\tif (stat(path, &sb) >= 0) {\n\t\tfprintf(stderr, \"leak at stat of %s\\n\", path);\n\t\texit(1);\n\t}\n\tif (errno != ENOENT) {\n\t\tfprintf(stderr, \"leak at stat of %s: errno was %d\\n\", path, errno);\n\t\texit(1);\n\t}\n}", "target": 0}
{"code": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}", "target": 1}
{"code": "static int edit_ext(char* editor, char* name, char* date, char* data)\n{\n\tint fd;\n\tint st;\n\tint sz;\n\tchar* b;\n\tchar* l;\n\tchar buff[512];\n\tpid_t pid;\n\tstrcpy(buff,\"/tmp/nodau.XXXXXX\");\n\tfd = mkstemp(buff);\n\tif (fd < 0)\n\t\treturn 1;\n\tpid = fork();\n\tif (pid < 0) {\n\t\treturn 1;\n\t}else if (pid) {\n\t\tclose(fd);\n\t\twaitpid(pid,&st,0);\n\t\tif (!st) {\n\t\t\tif ((fd = open(buff,O_RDONLY)) < 0)\n\t\t\t\treturn 1;\n\t\t\tsz = lseek(fd,0,SEEK_END);\n\t\t\tlseek(fd,0,SEEK_SET);\n\t\t\tif (sz) {\n\t\t\t\tb = alloca(sz+1);\n\t\t\t\tif (sz != read(fd,b,sz))\n\t\t\t\t\treturn 1;\n\t\t\t\tclose(fd);\n\t\t\t\tremove(buff);\n\t\t\t\tb[sz] = 0;\n\t\t\t\tl = strstr(b,\"-----\");\n\t\t\t\tif (l) {\n\t\t\t\t\tl += 6;\n\t\t\t\t\tif (db_update(name,l))\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tprintf(\"%s saved\\n\",name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn st;\n\t}\n\tsz = strlen(name)+strlen(date)+strlen(data)+50;\n\tb = alloca(sz);\n\tsz = sprintf(\n\t\tb,\n\t\t\"%s (%s)\\nText above this line is ignored\\n-----\\n%s\",\n\t\tname,\n\t\tdate,\n\t\tdata\n\t);\n\tif (write(fd,b,sz) != sz) {\n\t\texit(1);\n\t}\n\tfsync(fd);\n\tclose(fd);\n\tst = execl(editor,editor,buff,(char*)NULL);\n\texit(st);\n\treturn 1;\n}", "target": 1}
{"code": "lldpd_alloc_mgmt(int family, void *addrptr, size_t addrsize, u_int32_t iface)\n{\n\tstruct lldpd_mgmt *mgmt;\n\tlog_debug(\"alloc\", \"allocate a new management address (family: %d)\", family);\n\tif (family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST) {\n\t\terrno = EAFNOSUPPORT;\n\t\treturn NULL;\n\t}\n\tif (addrsize > LLDPD_MGMT_MAXADDRSIZE) {\n\t\terrno = EOVERFLOW;\n\t\treturn NULL;\n\t}\n\tmgmt = calloc(1, sizeof(struct lldpd_mgmt));\n\tif (mgmt == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn NULL;\n\t}\n\tmgmt->m_family = family;\n\tassert(addrsize <= LLDPD_MGMT_MAXADDRSIZE);\n\tmemcpy(&mgmt->m_addr, addrptr, addrsize);\n\tmgmt->m_addrsize = addrsize;\n\tmgmt->m_iface = iface;\n\treturn mgmt;\n}", "target": 1}
{"code": "njs_string_alloc(njs_vm_t *vm, njs_value_t *value, uint64_t size,\n    uint64_t length)\n{\n    uint32_t      total, map_offset, *map;\n    njs_string_t  *string;\n    if (njs_slow_path(size > NJS_STRING_MAX_LENGTH)) {\n        njs_range_error(vm, \"invalid string length\");\n        return NULL;\n    }\n    value->type = NJS_STRING;\n    njs_string_truth(value, size);\n    if (size <= NJS_STRING_SHORT) {\n        value->short_string.size = size;\n        value->short_string.length = length;\n        return value->short_string.start;\n    }\n    value->short_string.size = NJS_STRING_LONG;\n    value->short_string.length = 0;\n    value->long_string.external = 0;\n    value->long_string.size = size;\n    if (size != length && length > NJS_STRING_MAP_STRIDE) {\n        map_offset = njs_string_map_offset(size);\n        total = map_offset + njs_string_map_size(length);\n    } else {\n        map_offset = 0;\n        total = size;\n    }\n    string = njs_mp_alloc(vm->mem_pool, sizeof(njs_string_t) + total);\n    if (njs_fast_path(string != NULL)) {\n        value->long_string.data = string;\n        string->start = (u_char *) string + sizeof(njs_string_t);\n        string->length = length;\n        string->retain = 1;\n        if (map_offset != 0) {\n            map = (uint32_t *) (string->start + map_offset);\n            map[0] = 0;\n        }\n        return string->start;\n    }\n    njs_memory_error(vm);\n    return NULL;\n}", "target": 0}
{"code": "    TiffBinaryArray::~TiffBinaryArray()\n    {\n        for (Components::iterator i = elements_.begin(); i != elements_.end(); ++i) {\n            delete *i;\n        }\n    }", "target": 0}
{"code": "struct resource_pool *dce120_create_resource_pool(\n\tuint8_t num_virtual_links,\n\tstruct dc *dc)\n{\n\tstruct dce110_resource_pool *pool =\n\t\tkzalloc(sizeof(struct dce110_resource_pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn NULL;\n\tif (construct(num_virtual_links, dc, pool))\n\t\treturn &pool->base;\n\tkfree(pool);\n\tBREAK_TO_DEBUGGER();\n\treturn NULL;\n}", "target": 0}
{"code": "void GfxDeviceGrayColorSpace::getGray(const GfxColor *color, GfxGray *gray) const\n{\n    *gray = clip01(color->c[0]);\n}", "target": 0}
{"code": "manuf_name_lookup(const guint8 *addr)\n{\n    guint32       manuf_key;\n    guint8       oct;\n    hashmanuf_t  *manuf_value;\n    manuf_key = addr[0];\n    manuf_key = manuf_key<<8;\n    oct = addr[1];\n    manuf_key = manuf_key | oct;\n    manuf_key = manuf_key<<8;\n    oct = addr[2];\n    manuf_key = manuf_key | oct;\n    manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n    if (manuf_value != NULL) {\n        return manuf_value;\n    }\n    if ((manuf_key & 0x00010000) != 0) {\n        manuf_key &= 0x00FEFFFF;\n        manuf_value = (hashmanuf_t*)wmem_map_lookup(manuf_hashtable, GUINT_TO_POINTER(manuf_key));\n        if (manuf_value != NULL) {\n            return manuf_value;\n        }\n    }\n    const char *short_name, *long_name;\n    short_name = ws_manuf_lookup_str(addr, &long_name);\n    if (short_name != NULL) {\n        return manuf_hash_new_entry(addr, short_name, long_name);\n    }\n    return manuf_hash_new_entry(addr, NULL, NULL);\n} ", "target": 1}
{"code": "void main_init() { \n#ifdef USE_SYSTEMD\n    int i;\n    systemd_fds=sd_listen_fds(1);\n    if(systemd_fds<0)\n        fatal(\"systemd initialization failed\");\n    listen_fds_start=SD_LISTEN_FDS_START;\n    for(i=0; i<systemd_fds; ++i)\n        set_nonblock(listen_fds_start+i, 1);\n#else\n    systemd_fds=0; \n    listen_fds_start=3; \n#endif\n    if(ssl_init()) \n        fatal(\"TLS initialization failed\");\n    if(sthreads_init()) \n        fatal(\"Threads initialization failed\");\n    options_defaults();\n    options_apply();\n#ifndef USE_FORK\n    get_limits(); \n#endif\n    fds=s_poll_alloc();\n    if(pipe_init(signal_pipe, \"signal_pipe\"))\n        fatal(\"Signal pipe initialization failed: \"\n            \"check your personal firewall\");\n    if(pipe_init(terminate_pipe, \"terminate_pipe\"))\n        fatal(\"Terminate pipe initialization failed: \"\n            \"check your personal firewall\");\n    stunnel_info(LOG_NOTICE);\n    if(systemd_fds>0)\n        s_log(LOG_INFO, \"Systemd socket activation: %d descriptors received\",\n            systemd_fds);\n}", "target": 1}
{"code": "mmsMsg_isFilenameSave(const char* filename)\n{\n    if (filename)\n    {\n        if (strstr(filename, \"..\"))\n            return false;\n        if (strstr(filename, \"./\"))\n            return false;\n        return true;\n    }\n    else {\n        return false;\n    }\n}", "target": 0}
{"code": "static void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  if ((p->stop & 4)) {\n    p->stop ^= 4;\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}", "target": 1}
{"code": "http_splitheader(struct http *hp, int req)\n{\n\tchar *p, *q, **hh;\n\tint n;\n\tchar buf[20];\n\tCHECK_OBJ_NOTNULL(hp, HTTP_MAGIC);\n\tif (req) {\n\t\tmemset(hp->req, 0, sizeof hp->req);\n\t\thh = hp->req;\n\t} else {\n\t\tmemset(hp->resp, 0, sizeof hp->resp);\n\t\thh = hp->resp;\n\t}\n\tn = 0;\n\tp = hp->rxbuf;\n\twhile (vct_islws(*p))\n\t\tp++;\n\thh[n++] = p;\n\twhile (!vct_islws(*p))\n\t\tp++;\n\tassert(!vct_iscrlf(*p));\n\t*p++ = '\\0';\n\twhile (vct_issp(*p))\t\t\n\t\tp++;\n\tassert(!vct_iscrlf(*p));\n\thh[n++] = p;\n\twhile (!vct_islws(*p))\n\t\tp++;\n\tif (vct_iscrlf(*p)) {\n\t\thh[n++] = NULL;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t} else {\n\t\t*p++ = '\\0';\n\t\twhile (vct_issp(*p))\t\t\n\t\t\tp++;\n\t\thh[n++] = p;\n\t\twhile (!vct_iscrlf(*p))\n\t\t\tp++;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t}\n\tassert(n == 3);\n\twhile (*p != '\\0') {\n\t\tassert(n < MAX_HDR);\n\t\tif (vct_iscrlf(*p))\n\t\t\tbreak;\n\t\thh[n++] = p++;\n\t\twhile (*p != '\\0' && !vct_iscrlf(*p))\n\t\t\tp++;\n\t\tq = p;\n\t\tp += vct_skipcrlf(p);\n\t\t*q = '\\0';\n\t}\n\tp += vct_skipcrlf(p);\n\tassert(*p == '\\0');\n\tfor (n = 0; n < 3 || hh[n] != NULL; n++) {\n\t\tsprintf(buf, \"http[%2d] \", n);\n\t\tvtc_dump(hp->vl, 4, buf, hh[n], -1);\n\t}\n}", "target": 1}
{"code": "static int is_cmd_rcvr_exclusive(struct ipmi_smi *intf,\n\t\t\t\t unsigned char netfn,\n\t\t\t\t unsigned char cmd,\n\t\t\t\t unsigned int  chans)\n{\n\tstruct cmd_rcvr *rcvr;\n\tlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link) {\n\t\tif ((rcvr->netfn == netfn) && (rcvr->cmd == cmd)\n\t\t\t\t\t&& (rcvr->chans & chans))\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}", "target": 0}
{"code": "asmlinkage void __sched schedule(void)\n{\n\tstruct task_struct *prev, *next;\n\tunsigned long *switch_count;\n\tstruct rq *rq;\n\tint cpu;\nneed_resched:\n\tpreempt_disable();\n\tcpu = smp_processor_id();\n\trq = cpu_rq(cpu);\n\trcu_note_context_switch(cpu);\n\tprev = rq->curr;\n\trelease_kernel_lock(prev);\nneed_resched_nonpreemptible:\n\tschedule_debug(prev);\n\tif (sched_feat(HRTICK))\n\t\thrtick_clear(rq);\n\traw_spin_lock_irq(&rq->lock);\n\tclear_tsk_need_resched(prev);\n\tswitch_count = &prev->nivcsw;\n\tif (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {\n\t\tif (unlikely(signal_pending_state(prev->state, prev))) {\n\t\t\tprev->state = TASK_RUNNING;\n\t\t} else {\n\t\t\tif (prev->flags & PF_WQ_WORKER) {\n\t\t\t\tstruct task_struct *to_wakeup;\n\t\t\t\tto_wakeup = wq_worker_sleeping(prev, cpu);\n\t\t\t\tif (to_wakeup)\n\t\t\t\t\ttry_to_wake_up_local(to_wakeup);\n\t\t\t}\n\t\t\tdeactivate_task(rq, prev, DEQUEUE_SLEEP);\n\t\t}\n\t\tswitch_count = &prev->nvcsw;\n\t}\n\tpre_schedule(rq, prev);\n\tif (unlikely(!rq->nr_running))\n\t\tidle_balance(cpu, rq);\n\tput_prev_task(rq, prev);\n\tnext = pick_next_task(rq);\n\tif (likely(prev != next)) {\n\t\tsched_info_switch(prev, next);\n\t\tperf_event_task_sched_out(prev, next);\n\t\trq->nr_switches++;\n\t\trq->curr = next;\n\t\t++*switch_count;\n\t\tcontext_switch(rq, prev, next); \n\t\tcpu = smp_processor_id();\n\t\trq = cpu_rq(cpu);\n\t} else\n\t\traw_spin_unlock_irq(&rq->lock);\n\tpost_schedule(rq);\n\tif (unlikely(reacquire_kernel_lock(prev)))\n\t\tgoto need_resched_nonpreemptible;\n\tpreempt_enable_no_resched();\n\tif (need_resched())\n\t\tgoto need_resched;\n}", "target": 1}
{"code": "static int ip_options_get_finish(struct net *net, struct ip_options **optp,\n\t\t\t\t struct ip_options *opt, int optlen)\n{\n\twhile (optlen & 3)\n\t\topt->__data[optlen++] = IPOPT_END;\n\topt->optlen = optlen;\n\tif (optlen && ip_options_compile(net, opt, NULL)) {\n\t\tkfree(opt);\n\t\treturn -EINVAL;\n\t}\n\tkfree(*optp);\n\t*optp = opt;\n\treturn 0;\n}", "target": 1}
{"code": "void rose_start_t1timer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\tdel_timer(&rose->timer);\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->t1;\n\tadd_timer(&rose->timer);\n}", "target": 1}
{"code": "static void nfs4_return_incompatible_delegation(struct inode *inode, mode_t open_flags)\n{\n\tstruct nfs_delegation *delegation;\n\trcu_read_lock();\n\tdelegation = rcu_dereference(NFS_I(inode)->delegation);\n\tif (delegation == NULL || (delegation->type & open_flags) == open_flags) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\trcu_read_unlock();\n\tnfs_inode_return_delegation(inode);\n}", "target": 1}
{"code": "static ssize_t write_mem(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t written, sz;\n\tunsigned long copied;\n\tvoid *ptr;\n\tif (p != *ppos)\n\t\treturn -EFBIG;\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\twritten = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n#endif\n\twhile (count > 0) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n\t\t\treturn -EPERM;\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tcopied = copy_from_user(ptr, buf, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (copied) {\n\t\t\twritten += sz - copied;\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n\t*ppos += written;\n\treturn written;\n}", "target": 1}
{"code": "Eina_Bool ewk_view_forward_possible(Evas_Object* ewkView)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    return ewk_frame_forward_possible(smartData->main_frame);\n}", "target": 0}
{"code": "void GLES2DecoderImpl::DeleteRenderbuffersHelper(\n    GLsizei n, const GLuint* client_ids) {\n  for (GLsizei ii = 0; ii < n; ++ii) {\n    RenderbufferManager::RenderbufferInfo* info =\n        GetRenderbufferInfo(client_ids[ii]);\n    if (info) {\n      GLuint service_id = info->service_id();\n      glDeleteRenderbuffersEXT(1, &service_id);\n      RemoveRenderbufferInfo(client_ids[ii]);\n    }\n  }\n}", "target": 0}
{"code": "socks_request_free(socks_request_t *req)\n{\n  if (!req)\n    return;\n  if (req->username) {\n    memwipe(req->username, 0x10, req->usernamelen);\n    tor_free(req->username);\n  }\n  if (req->password) {\n    memwipe(req->password, 0x04, req->passwordlen);\n    tor_free(req->password);\n  }\n  memwipe(req, 0xCC, sizeof(socks_request_t));\n  tor_free(req);\n}", "target": 0}
{"code": "get_strings_2_svc(gstrings_arg *arg, struct svc_req *rqstp)\n{\n    static gstrings_ret             ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n    xdr_free(xdr_gstrings_ret, &ret);\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n    if ((ret.code = check_handle((void *)handle)))\n        goto exit_func;\n    ret.api_version = handle->api_version;\n    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {\n        ret.code = KADM5_FAILURE;\n        goto exit_func;\n    }\n    if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {\n        ret.code = KADM5_BAD_PRINCIPAL;\n        goto exit_func;\n    }\n    if (! cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ) &&\n        (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,\n                                                        rqst2name(rqstp),\n                                                        ACL_INQUIRE,\n                                                        arg->princ,\n                                                        NULL))) {\n        ret.code = KADM5_AUTH_GET;\n        log_unauth(\"kadm5_get_strings\", prime_arg,\n                   &client_name, &service_name, rqstp);\n    } else {\n        ret.code = kadm5_get_strings((void *)handle, arg->princ, &ret.strings,\n                                     &ret.count);\n        if (ret.code != 0)\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n        log_done(\"kadm5_get_strings\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}", "target": 1}
{"code": "static int fts3ExprGlobalHitsCb(\n  Fts3Expr *pExpr,                \n  int iPhrase,                    \n  void *pCtx                      \n){\n  MatchInfo *p = (MatchInfo *)pCtx;\n  return sqlite3Fts3EvalPhraseStats(\n      p->pCursor, pExpr, &p->aMatchinfo[3*iPhrase*p->nCol]\n  );\n}", "target": 0}
{"code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}", "target": 0}
{"code": "static void read_conf(FILE *conffile)\n{\n    char *buffer, *line, *val;\n    buffer = loadfile(conffile);\n    for (line = strtok(buffer, \"\\r\\n\"); line; line = strtok(NULL, \"\\r\\n\")) {\n        if (!strncmp(line, \"export \", 7))\n            continue;\n        val = strchr(line, '=');\n        if (!val) {\n            printf(\"invalid configuration line\\n\");\n            break;\n        }\n        *val++ = '\\0';\n        if (!strcmp(line, \"JSON_INDENT\"))\n            conf.indent = atoi(val);\n        if (!strcmp(line, \"JSON_COMPACT\"))\n            conf.compact = atoi(val);\n        if (!strcmp(line, \"JSON_ENSURE_ASCII\"))\n            conf.ensure_ascii = atoi(val);\n        if (!strcmp(line, \"JSON_PRESERVE_ORDER\"))\n            conf.preserve_order = atoi(val);\n        if (!strcmp(line, \"JSON_SORT_KEYS\"))\n            conf.sort_keys = atoi(val);\n        if (!strcmp(line, \"STRIP\"))\n            conf.strip = atoi(val);\n        if (!strcmp(line, \"HASHSEED\")) {\n            conf.have_hashseed = 1;\n            conf.hashseed = atoi(val);\n        } else {\n            conf.have_hashseed = 0;\n        }\n    }\n    free(buffer);\n}", "target": 0}
{"code": "static int ha_quic_add_handshake_data(SSL *ssl, enum ssl_encryption_level_t level,\n                                      const uint8_t *data, size_t len)\n{\n\tint ret = 0;\n\tstruct quic_conn *qc = SSL_get_ex_data(ssl, ssl_qc_app_data_index);\n\tstruct quic_enc_level **qel = ssl_to_qel_addr(qc, level);\n\tstruct quic_pktns **pktns = ssl_to_quic_pktns(qc, level);\n\tTRACE_ENTER(QUIC_EV_CONN_ADDDATA, qc);\n\tTRACE_PROTO(\"ha_quic_add_handshake_data() called\", QUIC_EV_CONN_IO_CB, qc, NULL, ssl);\n#ifdef HAVE_SSL_0RTT_QUIC\n\tif ((qc->flags & QUIC_FL_CONN_NO_TOKEN_RCVD) && qc_ssl_eary_data_accepted(ssl)) {\n\t\tTRACE_PROTO(\"connection to be killed\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tqc->flags |= QUIC_FL_CONN_TO_KILL|QUIC_FL_CONN_SEND_RETRY;\n\t\tgoto leave;\n\t}\n#endif\n\tif (qc->flags & QUIC_FL_CONN_TO_KILL) {\n\t\tTRACE_PROTO(\"connection to be killed\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tgoto out;\n\t}\n\tif (qc->flags & QUIC_FL_CONN_IMMEDIATE_CLOSE) {\n\t\tTRACE_PROTO(\"CC required\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tgoto out;\n\t}\n\tif (!*qel && !qc_enc_level_alloc(qc, pktns, qel, level))\n\t\tgoto leave;\n\tif (!qc_ssl_crypto_data_cpy(qc, *qel, data, len)) {\n\t\tTRACE_ERROR(\"Could not bufferize\", QUIC_EV_CONN_ADDDATA, qc);\n\t\tgoto leave;\n\t}\n\tTRACE_DEVEL(\"CRYPTO data buffered\", QUIC_EV_CONN_ADDDATA,\n\t            qc, &level, &len);\n out:\n\tret = 1;\n leave:\n\tTRACE_LEAVE(QUIC_EV_CONN_ADDDATA, qc);\n\treturn ret;\n}", "target": 0}
{"code": "\t\tAccessorRunner(ReferenceHandle& target, Local<Value> key_handle) :\n\t\tcontext{target.context},\n\t\ttarget{target.reference},\n\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)} {\n\t\t\ttarget.CheckDisposed();\n\t\t\tif (!key || (!key_handle->IsName() && !key_handle->IsUint32())) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t} else if (target.type_of != decltype(target.type_of)::Object) {\n\t\t\t\tthrow RuntimeTypeError(\"Reference is not an object\");\n\t\t\t}\n\t\t}", "target": 0}
